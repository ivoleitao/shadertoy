[
    {
        "ver": "0.1",
        "info": {
            "id": "ldXXDj",
            "date": "1406802116",
            "viewed": 77013,
            "name": "Music - Pirates",
            "username": "iq",
            "description": "An improvement on the music sequencing strategy, much better than that used in the Mario shader. This one supports polyphony (within the same channel) and is much more compact (which means that it does compile)",
            "likes": 582,
            "published": 3,
            "flags": 8,
            "usePreview": 1,
            "tags": []
        },
        "renderpass": [
            {
                "inputs": [
                    {
                        "id": "XdfGRn",
                        "filepath": "\/media\/a\/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg",
                        "previewfilepath": "\/media\/ap\/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg",
                        "type": "texture",
                        "channel": 0,
                        "sampler": {
                            "filter": "mipmap",
                            "wrap": "repeat",
                            "vflip": "false",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    },
                    {
                        "id": "4dXGzn",
                        "filepath": "\/media\/a\/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png",
                        "previewfilepath": "\/media\/ap\/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png",
                        "type": "texture",
                        "channel": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "wrap": "repeat",
                            "vflip": "false",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [],
                "code": "\/\/ Created by inigo quilez - iq\/2014\n\/\/   https:\/\/www.youtube.com\/c\/InigoQuilez\n\/\/   https:\/\/iquilezles.org\/\n\/\/ Creative Commons license.\n\n\n\/\/ A simple and cheap 2D shader to accompany the Pirates of the Caribean music.\n\n\nfloat fbm( vec2 p )\n{\n    return 0.5000*texture( iChannel1, p*1.00 ).x + \n           0.2500*texture( iChannel1, p*2.02 ).x + \n           0.1250*texture( iChannel1, p*4.03 ).x + \n           0.0625*texture( iChannel1, p*8.04 ).x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = mod( iTime, 60.0 );\n\tvec2 p = (2.0*fragCoord-iResolution.xy) \/ iResolution.y;\n    vec2 i = p;\n\n    \/\/ camera\n    p += vec2(1.0,3.0)*0.001*2.0*cos( iTime*5.0 + vec2(0.0,1.5) );    \n    p += vec2(1.0,3.0)*0.001*1.0*cos( iTime*9.0 + vec2(1.0,4.5) );    \n    float an = 0.3*sin( 0.1*time );\n    float co = cos(an);\n    float si = sin(an);\n    p = mat2( co, -si, si, co )*p*0.85;\n    \n    \/\/ water\n    vec2 q = vec2(p.x,1.0)\/p.y;\n    q.y -= 0.9*time;    \n    vec2 off = texture( iChannel0, 0.1*q*vec2(1.0,2.0) - vec2(0.0,0.007*iTime) ).xy;\n    q += 0.4*(-1.0 + 2.0*off);\n    vec3 col = 0.2*sqrt(texture( iChannel0, 0.05*q *vec2(1.0,4.0) + vec2(0.0,0.01*iTime) ).zyx);\n    float re = 1.0-smoothstep( 0.0, 0.7, abs(p.x-0.6) - abs(p.y)*0.5+0.2 );\n    col += 1.0*vec3(1.0,0.9,0.73)*re*0.2*(0.1+0.9*off.y)*5.0*(1.0-col.x);\n    float re2 = 1.0-smoothstep( 0.0, 2.0, abs(p.x-0.6) - abs(p.y)*0.85 );\n    col += 0.7*re2*smoothstep(0.35,1.0,texture( iChannel1, 0.075*q *vec2(1.0,4.0) ).x);\n    \n    \/\/ sky\n    vec3 sky = vec3(0.0,0.05,0.1)*1.4;\n    \/\/ stars    \n    sky += 0.5*smoothstep( 0.95,1.00,texture( iChannel1, 0.25*p ).x);\n    sky += 0.5*smoothstep( 0.85,1.0,texture( iChannel1, 0.25*p ).x);\n    sky += 0.2*pow(1.0-max(0.0,p.y),2.0);\n    \/\/ clouds    \n    float f = fbm( 0.002*vec2(p.x,1.0)\/p.y );\n    vec3 cloud = vec3(0.3,0.4,0.5)*0.7*(1.0-0.85*smoothstep(0.4,1.0,f));\n    sky = mix( sky, cloud, 0.95*smoothstep( 0.4, 0.6, f ) );\n    sky = mix( sky, vec3(0.33,0.34,0.35), pow(1.0-max(0.0,p.y),2.0) );\n    col = mix( col, sky, smoothstep(0.0,0.1,p.y) );\n\n    \/\/ horizon\n    col += 0.1*pow(clamp(1.0-abs(p.y),0.0,1.0),9.0);\n\n    \/\/ moon\n    float d = length(p-vec2(0.6,0.5));\n    vec3 moon = vec3(0.98,0.97,0.95)*(1.0-0.1*smoothstep(0.2,0.5,f));\n    col += 0.8*moon*exp(-4.0*d)*vec3(1.1,1.0,0.8);\n    col += 0.2*moon*exp(-2.0*d);\n    moon *= 0.85+0.15*smoothstep(0.25,0.7,fbm(0.05*p+0.3));\n    col = mix( col, moon, 1.0-smoothstep(0.2,0.22,d) );\n    \n    \/\/ postprocess\n    col = pow( 1.4*col, vec3(1.5,1.2,1.0) );    \n    col *= clamp(1.0-0.3*length(i), 0.0, 1.0 );\n\n    \/\/ fade\n    col *=       smoothstep( 3.0, 6.0,time);\n    col *= 1.0 - smoothstep(44.0,50.0,time);\n\n    fragColor = vec4( col, 1.0 );\n}",
                "name": "Image",
                "description": "",
                "type": "image"
            },
            {
                "inputs": [],
                "outputs": [],
                "code": "\/\/ Created by inigo quilez - iq\/2014\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ main instrument\nfloat instrument( float freq, float time )\n{\n    freq = 440.0*pow(freq\/440.0,1.003); \/\/ spread\n    \n    float ph = 1.0;\n    ph *= sin(6.2831*freq*time);\n    ph *= 0.2+0.8*max(0.0,6.0-0.01*freq);\n    ph *= exp(-time*freq*0.2);\n    \n    float y = 0.0;\n    y += 0.70*sin(1.00*6.2831*freq*time+ph)*exp2(-0.7*0.007*freq*time);\n    y += 0.20*sin(2.01*6.2831*freq*time+ph)*exp2(-0.7*0.011*freq*time);\n    y += 0.20*sin(3.01*6.2831*freq*time+ph)*exp2(-0.7*0.015*freq*time);\n    y += 0.16*sin(4.01*6.2831*freq*time+ph)*exp2(-0.7*0.018*freq*time);\n    y += 0.13*sin(5.01*6.2831*freq*time+ph)*exp2(-0.7*0.021*freq*time);\n    y += 0.10*sin(6.01*6.2831*freq*time+ph)*exp2(-0.7*0.027*freq*time);\n    y += 0.09*sin(8.01*6.2831*freq*time+ph)*exp2(-0.7*0.030*freq*time);\n    y += 0.07*sin(9.01*6.2831*freq*time+ph)*exp2(-0.7*0.033*freq*time);\n\n    y += 0.45*y*y*y;\n       \n    y *= 1.0 + 1.5*exp(-8.0*time);\n    y *= clamp( time\/0.004, 0.0, 1.0 );\n\n    y *= 2.5-1.5*clamp( log2(freq)\/10.0,0.0,1.0);\n\treturn y;\t\n}\n\n\n\/\/ music data\nfloat doChannel1( float soundTime );\nfloat doChannel2( float soundTime );\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ sound shader entrypoint\n\/\/\n\/\/ input: time in seconds\n\/\/ ouput: stereo wave valuie at \"time\"\n\/\/----------------------------------------------------------------------------------------\n\nvec2 mainSound( in int samp, float time )\n{\t\n    time = mod( time, 60.0 );\n    \n    vec2 y = vec2(0.0);\n    y += vec2(0.7,0.3)*doChannel1( time ); \/\/ main instrument\n    y += vec2(0.3,0.7)*doChannel2( time ); \/\/ secondary instrument\n\ty *= 0.1;\n    \n\treturn y;\n}\n\n\/\/----------------------------------------------------------------------------------------\n\n#define D(a) b+=float(a);if(t>b)x=b;\n\n\/\/----------------------------------------------------------------------------------------\n\n#define tint 0.144\n\nfloat doChannel1( float t )\n{\n  float x = 0.0;\n  float y = 0.0;\n  float b = 0.0;\n  t \/= tint;\n\n  \/\/ F2\n  x = t; b = 0.0;\n  D(36)D(2)D(2)D(20)D(2)D(16)D(6)D(2)D(226)\n  y += instrument( 174.0, tint*(t-x) );\n\n  \/\/ G2\n  x = t; b = 0.0;\n  D(53)D(208)\n  y += instrument( 195.0, tint*(t-x) );\n\n  \/\/ A2\n  x = t; b = 0.0;\n  D(34)D(2)D(2)D(2)D(1)D(7)D(2)D(2)D(2)D(1)D(3)D(8)D(2)D(8)D(2)D(4)D(2)D(2)D(2)D(1)\n  D(31)D(2)D(4)D(138)D(46)D(2)\n  y += instrument( 220.0, tint*(t-x) );\n\n  \/\/ A#2\n  x = t; b = 0.0;\n  D(42)D(2)D(2)D(14)D(2)D(2)D(1)D(25)D(2)D(16)D(2)D(2)\n  y += instrument( 233.0, tint*(t-x) );\n\n  \/\/ B2\n  x = t; b = 0.0;\n  D(125)\n  y += instrument( 246.0, tint*(t-x) );\n\n  \/\/ C3\n  x = t; b = 0.0;\n  D(35)D(6)D(7)D(2)D(3)D(1)D(5)D(7)D(2)D(2)D(1)D(1)D(2)D(3)D(6)D(199)D(2)D(2)D(2)D(1)\n  y += instrument( 261.0, tint*(t-x) );\n\n  \/\/ C#3\n  x = t; b = 0.0;\n  D(120)D(2)D(4)D(132)D(1)D(5)D(42)D(2)\n  y += instrument( 277.0, tint*(t-x) );\n\n  \/\/ D3\n  x = t; b = 0.0;\n  D(0)D(2)D(1)D(2)D(1)D(2)D(1)D(1)D(1)D(1)D(2)D(1)D(2)D(1)D(2)D(1)D(1)D(1)D(1)D(2)\n  D(1)D(2)D(1)D(2)D(1)D(3)D(2)D(2)D(2)D(2)D(2)D(1)D(5)D(3)D(5)D(2)D(2)D(12)D(2)D(6)\n  D(2)D(2)D(2)D(2)D(2)D(1)D(1)D(2)D(5)D(3)D(2)D(2)D(2)D(3)D(3)D(6)D(1)D(136)D(9)D(2)\n  D(2)D(2)D(1)D(17)D(2)D(2)D(2)D(1)D(11)\n  y += instrument( 293.0, tint*(t-x) );\n\n  \/\/ E3\n  x = t; b = 0.0;\n  D(41)D(7)D(2)D(15)D(7)D(2)D(27)D(6)D(13)D(2)D(4)D(132)D(1)D(23)D(2)D(2)D(2)D(18)D(4)\n  y += instrument( 329.0, tint*(t-x) );\n\n  \/\/ F3\n  x = t; b = 0.0;\n  D(42)D(2)D(2)D(20)D(2)D(2)D(19)D(11)D(2)D(6)D(2)D(4)D(5)D(5)D(8)D(2)D(2)D(20)D(2)D(16)\n  D(6)D(2)D(82)D(4)D(2)D(2)D(2)D(2)D(1)D(12)D(5)D(2)D(2)D(2)D(1)D(7)\n  y += instrument( 349.0, tint*(t-x) );\n\n  \/\/ G3\n  x = t; b = 0.0;\n  D(47)D(24)D(19)D(2)D(2)D(2)D(2)D(3)D(11)D(37)D(120)D(13)D(2)D(2)D(2)D(18)\n  y += instrument( 391.0, tint*(t-x) );\n\n  \/\/ A3\n  x = t; b = 0.0;\n  D(95)D(5)D(2)D(12)D(16)D(2)D(2)D(2)D(1)D(7)D(2)D(2)D(2)D(1)D(3)D(8)D(2)D(8)D(2)D(4)\n  D(2)D(2)D(2)D(1)D(31)D(2)D(4)D(2)D(2)D(12)D(1)D(1)D(30)D(2)D(2)D(3)D(12)D(5)D(2)D(2)\n  D(3)\n  y += instrument( 440.0, tint*(t-x) );\n\n  \/\/ A#3\n  x = t; b = 0.0;\n  D(96)D(2)D(40)D(2)D(2)D(14)D(2)D(2)D(1)D(25)D(2)D(16)D(2)D(2)D(24)D(18)D(1)D(1)D(24)D(24)\n  y += instrument( 466.0, tint*(t-x) );\n\n  \/\/ C4\n  x = t; b = 0.0;\n  D(131)D(6)D(7)D(2)D(3)D(1)D(5)D(7)D(2)D(2)D(1)D(1)D(2)D(3)D(6)D(47)D(2)\n  y += instrument( 523.0, tint*(t-x) );\n\n  \/\/ C#4\n  x = t; b = 0.0;\n  D(216)D(2)D(3)\n  y += instrument( 554.0, tint*(t-x) );\n\n  \/\/ D4\n  x = t; b = 0.0;\n  D(132)D(2)D(2)D(2)D(2)D(2)D(1)D(5)D(3)D(5)D(2)D(2)D(12)D(2)D(6)D(2)D(2)D(2)D(2)D(2)\n  D(1)D(1)D(2)D(5)D(3)D(2)D(2)D(2)D(3)D(3)D(6)D(2)D(2)D(4)D(4)D(2)D(5)D(7)D(5)\n  y += instrument( 587.0, tint*(t-x) );\n\n  \/\/ E4\n  x = t; b = 0.0;\n  D(137)D(7)D(2)D(15)D(7)D(2)D(27)D(6)D(13)D(2)D(8)\n  y += instrument( 659.0, tint*(t-x) );\n\n  \/\/ F4\n  x = t; b = 0.0;\n  D(138)D(2)D(2)D(20)D(2)D(2)D(19)D(11)D(2)D(6)D(2)D(4)D(5)D(13)D(2)D(1)D(4)D(3)\n  y += instrument( 698.0, tint*(t-x) );\n\n  \/\/ G4\n  x = t; b = 0.0;\n  D(143)D(24)D(19)D(2)D(2)D(2)D(2)D(3)D(11)D(24)D(14)D(4)\n  y += instrument( 783.0, tint*(t-x) );\n\n  \/\/ A4\n  x = t; b = 0.0;\n  D(191)D(5)D(2)D(12)D(24)\n  y += instrument( 880.0, tint*(t-x) );\n\n  \/\/ A#4\n  x = t; b = 0.0;\n  D(192)D(2)D(52)\n  y += instrument( 932.0, tint*(t-x) );\n\n  \/\/ C5\n  x = t; b = 0.0;\n  y += instrument( 1046.0, tint*(t-x) );\n  return y;\n}\n\nfloat doChannel2( float t )\n{\n  float x = 0.0;\n  float y = 0.0;\n  float b = 0.0;\n  t \/= tint;\n\n  \/\/ D0\n  x = t; b = 0.0;\n  D(24)D(6)D(3)\n  y += instrument( 36.0, tint*(t-x) );\n\n  \/\/ F0\n  x = t; b = 0.0;\n  D(66)D(2)D(1)D(2)D(91)D(2)D(1)D(2)\n  y += instrument( 43.0, tint*(t-x) );\n\n  \/\/ G0\n  x = t; b = 0.0;\n  D(96)D(2)D(1)D(2)D(91)D(2)D(1)D(2)D(49)D(2)D(1)D(2)D(1)D(2)D(1)D(2)\n  y += instrument( 48.0, tint*(t-x) );\n\n  \/\/ A0\n  x = t; b = 0.0;\n  D(48)D(2)D(1)D(2)D(22)D(2)D(43)D(2)D(1)D(2)D(1)D(2)D(1)D(2)D(13)D(2)D(1)D(2)D(22)D(2)\n  D(43)D(2)D(1)D(2)D(13)D(2)D(1)D(2)D(1)D(2)D(1)D(2)D(13)D(2)D(1)D(2)D(1)D(2)D(1)D(2)\n  D(37)D(2)D(1)D(2)\n  y += instrument( 55.0, tint*(t-x) );\n\n  \/\/ A#0\n  x = t; b = 0.0;\n  D(42)D(2)D(1)D(2)D(13)D(2)D(1)D(2)D(25)D(2)D(1)D(2)D(13)D(2)D(1)D(2)D(25)D(2)D(1)D(2)\n  D(13)D(2)D(1)D(2)D(25)D(2)D(1)D(2)D(13)D(2)D(1)D(2)D(23)\n  y += instrument( 58.0, tint*(t-x) );\n\n  \/\/ C1\n  x = t; b = 0.0;\n  D(41)D(31)D(2)D(63)D(31)D(2)D(56)D(2)D(2)D(52)D(2)D(1)D(2)\n  y += instrument( 65.0, tint*(t-x) );\n\n  \/\/ D1\n  x = t; b = 0.0;\n  D(24)D(6)D(3)D(3)D(2)D(1)D(15)D(2)D(1)D(2)D(19)D(2)D(1)D(2)D(1)D(2)D(1)D(2)D(13)D(2)\n  D(1)D(2)D(7)D(2)D(1)D(2)D(13)D(2)D(1)D(15)D(2)D(1)D(2)D(19)D(2)D(1)D(2)D(1)D(2)D(1)\n  D(2)D(13)D(2)D(1)D(2)D(7)D(2)D(1)D(2)D(7)D(2)D(46)D(2)D(1)D(2)D(1)D(2)D(1)D(1)D(1)\n  D(13)D(2)D(1)D(2)D(1)D(2)D(1)D(1)D(1)D(7)\n  y += instrument( 73.0, tint*(t-x) );\n\n  \/\/ F1\n  x = t; b = 0.0;\n  D(66)D(2)D(1)D(2)D(91)D(2)D(1)D(2)D(121)D(2)D(1)D(1)D(1)\n  y += instrument( 87.0, tint*(t-x) );\n\n  \/\/ G1\n  x = t; b = 0.0;\n  D(96)D(2)D(1)D(2)D(91)D(2)D(1)D(2)D(49)D(2)D(1)D(2)D(1)D(2)D(1)D(2)\n  y += instrument( 97.0, tint*(t-x) );\n\n  \/\/ A1\n  x = t; b = 0.0;\n  D(48)D(2)D(1)D(2)D(22)D(2)D(43)D(2)D(1)D(2)D(1)D(2)D(1)D(2)D(13)D(2)D(1)D(2)D(22)D(2)\n  D(43)D(2)D(1)D(2)D(13)D(2)D(1)D(2)D(1)D(2)D(1)D(2)D(13)D(2)D(1)D(2)D(1)D(2)D(1)D(2)\n  D(37)D(2)D(1)D(2)\n  y += instrument( 110.0, tint*(t-x) );\n\n  \/\/ A#1\n  x = t; b = 0.0;\n  D(42)D(2)D(1)D(2)D(13)D(2)D(1)D(2)D(25)D(2)D(1)D(2)D(13)D(2)D(1)D(2)D(25)D(2)D(1)D(2)\n  D(13)D(2)D(1)D(2)D(25)D(2)D(1)D(2)D(13)D(2)D(1)D(2)D(23)\n  y += instrument( 116.0, tint*(t-x) );\n\n  \/\/ C2\n  x = t; b = 0.0;\n  D(41)D(31)D(2)D(63)D(31)D(2)D(56)D(2)D(2)D(52)D(2)D(1)D(2)\n  y += instrument( 130.0, tint*(t-x) );\n\n  \/\/ D2\n  x = t; b = 0.0;\n  D(36)D(2)D(1)D(15)D(2)D(1)D(2)D(19)D(2)D(1)D(2)D(1)D(2)D(1)D(2)D(13)D(2)D(1)D(2)D(7)\n  D(2)D(1)D(2)D(13)D(2)D(1)D(15)D(2)D(1)D(2)D(19)D(2)D(1)D(2)D(1)D(2)D(1)D(2)D(13)D(2)\n  D(1)D(2)D(7)D(2)D(1)D(2)D(7)D(2)D(46)D(2)D(1)D(2)D(1)D(2)D(1)D(1)D(1)D(13)D(2)D(1)\n  D(2)D(1)D(2)D(1)D(1)D(1)D(7)\n  y += instrument( 146.0, tint*(t-x) );\n\n  \/\/ F2\n  x = t; b = 0.0;\n  D(288)D(2)D(1)D(1)D(1)\n  y += instrument( 174.0, tint*(t-x) );\n  return y;\n}\n\n",
                "name": "Sound",
                "description": "",
                "type": "sound"
            }
        ]
    },
    {
        "ver": "0.1",
        "info": {
            "id": "llj3Rz",
            "date": "1426763378",
            "viewed": 62499,
            "name": "[NV15] Space Curvature",
            "username": "iq",
            "description": "Space curvature. Sphere is raytraced. Plane is raymarched. Atmospheric glow is analytical",
            "likes": 610,
            "published": 3,
            "flags": 9,
            "usePreview": 0,
            "tags": []
        },
        "renderpass": [
            {
                "inputs": [
                    {
                        "id": "XdfGRn",
                        "filepath": "\/media\/a\/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg",
                        "previewfilepath": "\/media\/ap\/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg",
                        "type": "texture",
                        "channel": 0,
                        "sampler": {
                            "filter": "mipmap",
                            "wrap": "repeat",
                            "vflip": "false",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    },
                    {
                        "id": "XsX3Rn",
                        "filepath": "\/media\/a\/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg",
                        "previewfilepath": "\/media\/ap\/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg",
                        "type": "texture",
                        "channel": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "wrap": "repeat",
                            "vflip": "false",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "4dfGRr",
                        "channel": 0
                    }
                ],
                "code": "\/\/ Copyright Inigo Quilez, 2015 - https:\/\/iquilezles.org\/\n\/\/ I am the sole copyright owner of this Work.\n\/\/ You cannot host, display, distribute or share this Work in any form,\n\/\/ including physical and digital. You cannot use this Work in any\n\/\/ commercial or non-commercial product, website or project. You cannot\n\/\/ sell this Work and you cannot mint an NFTs of it.\n\/\/ I share this Work for educational purposes, and you can link to it,\n\/\/ through an URL, proper attribution and unmodified screenshot, as part\n\/\/ of your educational material. If these conditions are too restrictive\n\/\/ please contact me and we'll definitely work it out.\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2\n#endif\n\n\n\/\/ https:\/\/iquilezles.org\/articles\/spherefunctions\/\nfloat shpIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( rd, oc );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h>0.0 ) h = -b - sqrt( h );\n    return h;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/spherefunctions\/\nfloat sphDistance( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float h = dot( oc, oc ) - b*b;\n    return sqrt( max(0.0,h)) - sph.w;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/spherefunctions\/\nfloat sphSoftShadow( in vec3 ro, in vec3 rd, in vec4 sph, in float k )\n{\n    vec3 oc = sph.xyz - ro;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    return (b<0.0) ? 1.0 : 1.0 - smoothstep( 0.0, 1.0, k*h\/b );\n}    \n\n\/\/ https:\/\/iquilezles.org\/articles\/spherefunctions\/\nvec3 sphNormal( in vec3 pos, in vec4 sph )\n{\n    return (pos - sph.xyz)\/sph.w;    \n}\n\nvec3 fancyCube( sampler2D sam, in vec3 d, in float s, in float b )\n{\n    vec3 colx = texture( sam, 0.5 + s*d.yz\/d.x, b ).xyz;\n    vec3 coly = texture( sam, 0.5 + s*d.zx\/d.y, b ).xyz;\n    vec3 colz = texture( sam, 0.5 + s*d.xy\/d.z, b ).xyz;\n    vec3 n = d*d;\n    return (colx*n.x + coly*n.y + colz*n.z)\/(n.x+n.y+n.z);\n}\n\nvec2 hash( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*43758.5453); }\n\nvec2 voronoi( in vec2 x )\n{\n    vec2 n = floor( x );\n    vec2 f = fract( x );\n\n\tvec3 m = vec3( 8.0 );\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2  g = vec2( float(i), float(j) );\n        vec2  o = hash( n + g );\n        vec2  r = g - f + o;\n\t\tfloat d = dot( r, r );\n        if( d<m.x ) m = vec3( d, o );\n    }\n\n    return vec2( sqrt(m.x), m.y+m.z );\n}\n\n\/\/=======================================================\n\nvec3 background( in vec3 d, in vec3 l )\n{\n    vec3 col = vec3(0.0);\n         col += 0.5*pow( fancyCube( iChannel1, d, 0.05, 5.0 ).zyx, vec3(2.0) );\n         col += 0.2*pow( fancyCube( iChannel1, d, 0.10, 3.0 ).zyx, vec3(1.5) );\n         col += 0.8*vec3(0.80,0.5,0.6)*pow( fancyCube( iChannel1, d, 0.1, 0.0 ).xxx, vec3(6.0) );\n    float stars = smoothstep( 0.3, 0.7, fancyCube( iChannel1, d, 0.91, 0.0 ).x );\n\n    vec3 n = abs(d);\n    n = n*n*n;\n    \n    vec2 vxy = voronoi( 50.0*d.xy );\n    vec2 vyz = voronoi( 50.0*d.yz );\n    vec2 vzx = voronoi( 50.0*d.zx );\n    vec2 r = (vyz*n.x + vzx*n.y + vxy*n.z) \/ (n.x+n.y+n.z);\n    col += 0.5 * stars * clamp(1.0-(3.0+r.y*5.0)*r.x,0.0,1.0);\n\n    col = 1.5*col - 0.2;\n    col += vec3(-0.05,0.1,0.0);\n\n    float s = clamp( dot(d,l), 0.0, 1.0 );\n    col += 0.4*pow(s,5.0)*vec3(1.0,0.7,0.6)*2.0;\n    col += 0.4*pow(s,64.0)*vec3(1.0,0.9,0.8)*2.0;\n    \n    return col;\n}\n\n\/\/--------------------------------------------------------------------\n\nconst vec4 sph1 = vec4( 0.0, 0.0, 0.0, 1.0 );\n\nfloat rayTrace( in vec3 ro, in vec3 rd )\n{\n    return shpIntersect( ro, rd, sph1 );\n}\n\nfloat map( in vec3 pos )\n{\n    vec2 r = pos.xz - sph1.xz;\n    float h = 1.0-2.0\/(1.0+0.3*dot(r,r));\n    return pos.y - h;\n}\n\nfloat rayMarch( in vec3 ro, in vec3 rd, float tmax )\n{\n    float t = 0.0;\n    \n    \/\/ bounding plane\n    float h = (1.0-ro.y)\/rd.y;\n    if( h>0.0 ) t=h;\n\n    \/\/ raymarch\n    for( int i=0; i<20; i++ )    \n    {        \n        vec3 pos = ro + t*rd;\n        float h = map( pos );\n        if( h<0.001 || t>tmax ) break;\n        t += h;\n    }\n    return t;    \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    vec3 lig = normalize( vec3(1.0,0.2,1.0) );\n    vec3 col = background( rd, lig );\n    \n    \/\/ raytrace stuff    \n    float t = rayTrace( ro, rd );\n\n    if( t>0.0 )\n    {\n        vec3 mat = vec3( 0.18 );\n        vec3 pos = ro + t*rd;\n        vec3 nor = sphNormal( pos, sph1 );\n            \n        float am = 0.1*iTime;\n        vec2 pr = vec2( cos(am), sin(am) );\n        vec3 tnor = nor;\n        tnor.xz = mat2( pr.x, -pr.y, pr.y, pr.x ) * tnor.xz;\n\n        float am2 = 0.08*iTime - 1.0*(1.0-nor.y*nor.y);\n        pr = vec2( cos(am2), sin(am2) );\n        vec3 tnor2 = nor;\n        tnor2.xz = mat2( pr.x, -pr.y, pr.y, pr.x ) * tnor2.xz;\n\n        vec3 ref = reflect( rd, nor );\n        float fre = clamp( 1.0+dot( nor, rd ), 0.0 ,1.0 );\n\n        float l = fancyCube( iChannel0, tnor, 0.03, 0.0 ).x;\n        l += -0.1 + 0.3*fancyCube( iChannel0, tnor, 8.0, 0.0 ).x;\n\n        vec3 sea  = mix( vec3(0.0,0.07,0.2), vec3(0.0,0.01,0.3), fre );\n        sea *= 0.15;\n\n        vec3 land = vec3(0.02,0.04,0.0);\n        land = mix( land, vec3(0.05,0.1,0.0), smoothstep(0.4,1.0,fancyCube( iChannel0, tnor, 0.1, 0.0 ).x ));\n        land *= fancyCube( iChannel0, tnor, 0.3, 0.0 ).xyz;\n        land *= 0.5;\n\n        float los = smoothstep(0.45,0.46, l);\n        mat = mix( sea, land, los );\n\n        vec3 wrap = -1.0 + 2.0*fancyCube( iChannel1, tnor2.xzy, 0.025, 0.0 ).xyz;\n        float cc1 = fancyCube( iChannel1, tnor2 + 0.2*wrap, 0.05, 0.0 ).y;\n        float clouds = smoothstep( 0.3, 0.6, cc1 );\n\n        mat = mix( mat, vec3(0.93*0.15), clouds );\n\n        float dif = clamp( dot(nor, lig), 0.0, 1.0 );\n        mat *= 0.8;\n        vec3 lin  = vec3(3.0,2.5,2.0)*dif;\n        lin += 0.01;\n        col = mat * lin;\n        col = pow( col, vec3(0.4545) );\n        col += 0.6*fre*fre*vec3(0.9,0.9,1.0)*(0.3+0.7*dif);\n\n        float spe = clamp( dot(ref,lig), 0.0, 1.0 );\n        float tspe = pow( spe, 3.0 ) + 0.5*pow( spe, 16.0 );\n        col += (1.0-0.5*los)*clamp(1.0-2.0*clouds,0.0,1.0)*0.3*vec3(0.5,0.4,0.3)*tspe*dif;;\n    }\n    \n    \/\/ raymarch stuff    \n    float tmax = 20.0;\n    if( t>0.0 ) tmax = t; \n    t = rayMarch( ro, rd, tmax );    \n    if( t<tmax )\n    {\n        vec3 pos = ro + t*rd;\n\n        vec2 scp = sin(2.0*6.2831*pos.xz);\n\n        vec3 wir = vec3( 0.0 );\n        wir += 1.0*exp(-12.0*abs(scp.x));\n        wir += 1.0*exp(-12.0*abs(scp.y));\n        wir += 0.5*exp( -4.0*abs(scp.x));\n        wir += 0.5*exp( -4.0*abs(scp.y));\n        wir *= 0.2 + 1.0*sphSoftShadow( pos, lig, sph1, 4.0 );\n\n        col += wir*0.5*exp( -0.05*t*t );\n    }        \n\n    \/\/ outter glow\n    if( dot(rd,sph1.xyz-ro)>0.0 )\n    {\n        float d = sphDistance( ro, rd, sph1 );\n        vec3 glo = vec3(0.0);\n        glo += vec3(0.6,0.7,1.0)*0.3*exp(-2.0*abs(d))*step(0.0,d);\n        glo += 0.6*vec3(0.6,0.7,1.0)*0.3*exp(-8.0*abs(d));\n        glo += 0.6*vec3(0.8,0.9,1.0)*0.4*exp(-100.0*abs(d));\n        col += glo*1.5;\n    }        \n    \n    col *= smoothstep( 0.0, 6.0, iTime );\n\n    return col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 rt, in float cr )\n{\n\tvec3 cw = normalize(rt-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.0);\n#if AA>1\n\t#define ZERO min(iFrame,0)\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        \/\/ pixel coordinates\n        vec2 o = vec2(float(m),float(n)) \/ float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)\/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)\/iResolution.y;\n#endif \n\n        float zo = 1.0 + smoothstep( 5.0, 15.0, abs(iTime-48.0) );\n        float an = 3.0 + 0.05*iTime + 6.0*iMouse.x\/iResolution.x;\n        vec3 ro = zo*vec3( 2.0*cos(an), 1.0, 2.0*sin(an) );\n        vec3 rt = vec3( 1.0, 0.0, 0.0 );\n        mat3 cam = setCamera( ro, rt, 0.35 );\n        vec3 rd = normalize( cam * vec3( p, -2.0) );\n\n        col += render( ro, rd );\n\n#if AA>1\n    }\n    col \/= float(AA*AA);\n#endif\n\n    vec2 q = fragCoord \/ iResolution.xy;\n    col *= 0.2 + 0.8*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\n\tfragColor = vec4( col, 1.0 );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    float zo = 1.0 + smoothstep( 5.0, 15.0, abs(iTime-48.0) );\n    float an = 3.0 + 0.05*iTime;\n    vec3 ro = zo*vec3( 2.0*cos(an), 1.0, 2.0*sin(an) );\n\n    vec3 rt = vec3( 1.0, 0.0, 0.0 );\n    mat3 cam = setCamera( ro, rt, 0.35 );\n    \n    fragColor = vec4( render( ro + cam*fragRayOri,\n                                   cam*fragRayDir ), 1.0 );\n\n}",
                "name": "Image",
                "description": "",
                "type": "image"
            },
            {
                "inputs": [
                    {
                        "id": "XsX3Rn",
                        "filepath": "\/media\/a\/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg",
                        "previewfilepath": "\/media\/ap\/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg",
                        "type": "texture",
                        "channel": 0,
                        "sampler": {
                            "filter": "mipmap",
                            "wrap": "repeat",
                            "vflip": "false",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "XsfGRr",
                        "channel": 0
                    }
                ],
                "code": "vec2 mainSound( in int samp, float time )\n{\n\tvec2 y = vec2( 0.0 );\n\t\n    float d = 1.0;\n    for( int j=0; j<4; j++ )\n    {\n\n        float base = 512.0 + 512.0*sin( time * 0.25 );\n\n        for(int i=0; i<256; i++ )\n        {\n            float h = float(i)\/256.0;\n\n            vec2 ti = texture( iChannel0, vec2(h,time*0.1)).xy;\n\n            float a = ti.x*ti.x\/(0.1+h*h);\n\n            y += d * a * cos( vec2(3.0*h,0.0) + 6.2831*time*base*h + ti.y*100.0 );\n        }\n        time += 0.15;\n        d *= 0.9;\n    }    \n\n    y \/= 256.0;\n    y \/= 2.0;\n    \n    y = sin(1.57*y);\n    \n    return y;\n}",
                "name": "Sound",
                "description": "",
                "type": "sound"
            }
        ]
    },
    {
        "ver": "0.1",
        "info": {
            "id": "XdBGzd",
            "date": "1392082162",
            "viewed": 61630,
            "name": "Sphere - projection",
            "username": "iq",
            "description": "Analytic projection of a sphere to screen pixels. Spheres in world space become ellipses in clip space. The ellipses can be analytically determined from the camera and sphere geometry. This shaders computers their center, axis and area in raster pixels.",
            "likes": 117,
            "published": 3,
            "flags": 0,
            "usePreview": 0,
            "tags": []
        },
        "renderpass": [
            {
                "inputs": [],
                "outputs": [
                    {
                        "id": "4dfGRr",
                        "channel": 0
                    }
                ],
                "code": "\/\/ The MIT License\n\/\/ https:\/\/www.youtube.com\/c\/InigoQuilez\n\/\/ https:\/\/iquilezles.org\/\n\/\/ Copyright \u00a9 2014 Inigo Quilez\n\/\/ Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\/\/ Analytic projection of a sphere to screen pixels. \n\n\/\/ Spheres in world space become ellipses when projected to the camera view plane. In fact, these\n\/\/ ellipses can be analytically determined from the camera parameters and the sphere geometry,\n\/\/ such that their exact position, orientation and surface area can be compunted. This means that,\n\/\/ given a sphere and a camera and buffer resolution, there is an analytical formula that \n\/\/ provides the amount of pixels covered by a sphere in the image. This can be very useful for\n\/\/ implementing LOD for objects based on their size in screen (think of trees, vegetation, characters\n\/\/ or any other such complex object).\n\n\/\/ This shaders implements this formula, and provides too the center and axes of the ellipse\n\n\/\/ More info, here: https:\/\/iquilezles.org\/articles\/sphereproj\n\n\/\/ ---------------------------------------------------------------------------------------------\n\nstruct ProjectionResult\n{\n    float area;      \/\/ probably all we care about in practical applications is the area, \n    vec2  center;    \/\/ but i'm outputing all the information for debugging and ilustration\n    vec2  axisA;     \/\/ purposes\n    vec2  axisB;\t\n\tfloat a, b, c, d, e, f;\n};\n\nProjectionResult projectSphere( \/* sphere        *\/ in vec4 sph, \n\t\t\t\t                \/* camera matrix *\/ in mat4 cam,\n\t\t\t\t\t\t\t    \/* projection    *\/ in float fle )\n{\n    \/\/ transform to camera space\t\n\tvec3  o = (cam*vec4(sph.xyz,1.0)).xyz;\n\t\n    float r2 = sph.w*sph.w;\n\tfloat z2 = o.z*o.z;\t\n\tfloat l2 = dot(o,o);\n\t\n\tfloat area = -3.141593*fle*fle*r2*sqrt(abs((l2-r2)\/(r2-z2)))\/(r2-z2);\n\t\n\t\/\/return area;\n\t\n\t\n    \/\/-- debug stuff ---\n\n\t\n\t\/\/ axis\n\tvec2 axa = fle*sqrt(-r2*(r2-l2)\/((l2-z2)*(r2-z2)*(r2-z2)))*vec2( o.x,o.y);\n\tvec2 axb = fle*sqrt(-r2*(r2-l2)\/((l2-z2)*(r2-z2)*(r2-l2)))*vec2(-o.y,o.x);\n\n    \/\/area = length(axa)*length(axb)*3.141593;\t\n\t\n\t\/\/ center\n\tvec2  cen = fle*o.z*o.xy\/(z2-r2);\n\n\treturn ProjectionResult( area, \n\t\t\t\t\t\t\t cen, axa, axb, \n                     \/* implicit ellipse f(x,y) = a\u00c2\u00b7x\u00c2\u00b2 + b\u00c2\u00b7y\u00c2\u00b2 + c\u00c2\u00b7x\u00c2\u00b7y + d\u00c2\u00b7x + e\u00c2\u00b7y + f = 0 *\/\n                     \/* a *\/ r2 - o.y*o.y - z2,\n                     \/* b *\/ r2 - o.x*o.x - z2,\n                     \/* c *\/ 2.0*o.x*o.y,\n                     \/* d *\/ 2.0*o.x*o.z*fle,\n                     \/* e *\/ 2.0*o.y*o.z*fle,\n                     \/* f *\/ (r2-l2+z2)*fle*fle );\n\t\n}\n\n\/\/-----------------------------------------------------------------\n\/\/ Digit drawing function by P_Malin (https:\/\/www.shadertoy.com\/view\/4sf3RN)\n\nfloat SampleDigit(const in float n, const in vec2 vUV)\n{\t\t\n\tif(vUV.x  < 0.0) return 0.0;\n\tif(vUV.y  < 0.0) return 0.0;\n\tif(vUV.x >= 1.0) return 0.0;\n\tif(vUV.y >= 1.0) return 0.0;\n\t\n\tfloat data = 0.0;\n\t\n\t     if(n < 0.5) data = 7.0 + 5.0*16.0 + 5.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\telse if(n < 1.5) data = 2.0 + 2.0*16.0 + 2.0*256.0 + 2.0*4096.0 + 2.0*65536.0;\n\telse if(n < 2.5) data = 7.0 + 1.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 3.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 4.5) data = 4.0 + 7.0*16.0 + 5.0*256.0 + 1.0*4096.0 + 1.0*65536.0;\n\telse if(n < 5.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n\telse if(n < 6.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n\telse if(n < 7.5) data = 4.0 + 4.0*16.0 + 4.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 8.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\telse if(n < 9.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\t\n\tvec2 vPixel = floor(vUV * vec2(4.0, 5.0));\n\tfloat fIndex = vPixel.x + (vPixel.y * 4.0);\n\t\n\treturn mod(floor(data \/ pow(2.0, fIndex)), 2.0);\n}\n\nfloat PrintInt(const in vec2 uv, const in float value )\n{\n\tfloat res = 0.0;\n\tfloat maxDigits = 1.0+ceil(log2(value)\/log2(10.0));\n\tfloat digitID = floor(uv.x);\n\tif( digitID>0.0 && digitID<maxDigits )\n\t{\n        float digitVa = mod( floor( value\/pow(10.0,maxDigits-1.0-digitID) ), 10.0 );\n        res = SampleDigit( digitVa, vec2(fract(uv.x), uv.y) );\n\t}\n\n\treturn res;\t\n}\n\n\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\nfloat oSphere( in vec3 pos, in vec3 nor, in vec4 sph )\n{\n    vec3 di = sph.xyz - pos;\n    float l = length(di);\n    return 1.0 - max(0.0,dot(nor,di\/l))*sph.w*sph.w\/(l*l); \n}\n\nfloat ssSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    vec3 oc = sph.xyz - ro;\n    float b = dot( oc, rd );\n\t\n    float res = 1.0;\n    if( b>0.0 )\n    {\n        float h = dot(oc,oc) - b*b - sph.w*sph.w;\n        res = smoothstep( 0.0, 1.0, 12.0*h\/b );\n    }\n    return res;\n}\n\nfloat sdSegment( vec2 a, vec2 b, vec2 p )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\t\n\treturn length( pa - ba*h );\n}\n\nvec3 drawMaths( vec3 col, in ProjectionResult res, in vec2 p )\n{\n\tfloat showMaths = 1.0;\/\/smoothstep( -0.5, 0.5, cos(0.5*6.2831*lTime) );\n\n\tfloat impl = res.a*p.x*p.x + res.b*p.y*p.y + res.c*p.x*p.y + res.d*p.x + res.e*p.y + res.f;\n\t\n\tcol = mix( col, vec3(1.0,0.0,0.0), showMaths*(1.0-smoothstep(0.00,0.10, abs(impl))));\n\tcol = mix( col, vec3(1.0,1.0,0.0), showMaths*(1.0-smoothstep(0.00,0.01, sdSegment( res.center-res.axisA, res.center+res.axisA, p  )) ));\n\tcol = mix( col, vec3(1.0,1.0,0.0), showMaths*(1.0-smoothstep(0.00,0.01, sdSegment( res.center-res.axisB, res.center+res.axisB, p  )) ));\n\tcol = mix( col, vec3(1.0,0.0,0.0), showMaths*(1.0-smoothstep(0.03,0.04, length(p-res.center))));\n    vec2 pp  = res.center + 0.5*max( max( res.axisA, -res.axisA ), max( res.axisB, -res.axisB ) );\n\tcol = mix( col, vec3(1.0), PrintInt( ((p-pp)-vec2(0.0,0.0))\/0.07, floor(res.area) ) );\n\n\treturn col;\n}\n\nfloat gridTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n    const float N = 10.0;\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;\n    vec2 a = p + 0.5*w;\n    vec2 b = p - 0.5*w;           \n    vec2 i = (floor(a)+min(fract(a)*N,1.0)-\n              floor(b)-min(fract(b)*N,1.0))\/(N*w);\n    return (1.0-i.x)*(1.0-i.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) \/ iResolution.y;\n\t\n\tfloat fov = 1.0;\n\t\n\tfloat an = 12.0 + 0.5*iTime + 10.0*iMouse.x\/iResolution.x;\n\tvec3 ro = vec3( 3.0*cos(an), 0.0, 3.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n\tvec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\tvec3 rd = normalize( p.x*uu + p.y*vv + fov*ww );\n\tmat4 cam = mat4( uu.x, uu.y, uu.z, 0.0,\n\t\t\t\t\t vv.x, vv.y, vv.z, 0.0,\n\t\t\t\t\t ww.x, ww.y, ww.z, 0.0,\n\t\t\t\t\t -dot(uu,ro), -dot(vv,ro), -dot(ww,ro), 1.0 );\n\t\n\tvec4 sph1 = vec4(-2.0, 1.0,0.0,1.1);\n\tvec4 sph2 = vec4( 3.0, 1.5,1.0,1.2);\n\tvec4 sph3 = vec4( 1.0,-1.0,1.0,1.3);\n\n\tfloat tmin = 10000.0;\n\tvec3  nor = vec3(0.0);\n\tfloat occ = 1.0;\n\tvec3  pos = vec3(0.0);\n\t\n\tvec3 sur = vec3(1.0);\n\tfloat h = iSphere( ro, rd, sph1 );\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n\t\tpos = ro + h*rd;\n\t\tnor = normalize(pos-sph1.xyz); \n\t\tocc = oSphere( pos, nor, sph2 ) * oSphere( pos, nor, sph3 );\n\t\tsur = vec3(1.0,0.7,0.2)*smoothstep(-0.6,-0.2,sin(20.0*(pos.x-sph1.x)));\n\t}\n\th = iSphere( ro, rd, sph2 );\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n\t\tpos = ro + h*rd;\n\t\tnor = normalize(pos-sph2.xyz); \n\t\tocc = oSphere( pos, nor, sph1 ) * oSphere( pos, nor, sph3 );\n\t\tsur = vec3(0.7,1.0,0.2)*smoothstep(-0.6,-0.2,sin(20.0*(pos.z-sph2.z)));\n\t}\n\th = iSphere( ro, rd, sph3 );\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n\t\tpos = ro + h*rd;\n\t\tnor = normalize(pos-sph3.xyz); \n\t\tocc = oSphere( pos, nor, sph1 ) * oSphere( pos, nor, sph2 );\n\t\tsur = vec3(1.0,0.2,0.2)*smoothstep(-0.6,-0.2,sin(20.0*(pos.y-sph3.y)));\n\t}\n\th = (-2.0-ro.y)\/rd.y;\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n\t\tpos = ro + h*rd;\n\t\tnor = vec3(0.0,1.0,0.0); \n\t\tocc = oSphere( pos, nor, sph1 ) * oSphere( pos, nor, sph2 ) * oSphere( pos, nor, sph3 );\n        sur = vec3(1.0)*gridTextureGradBox( pos.xz, dFdx(pos.xz), dFdy(pos.xz) );\n\t}\n\n\tvec3 col = vec3(0.0);\n\n\tif( tmin<100.0 )\n\t{\n\t    pos = ro + tmin*rd;\n        col = vec3(1.0);\n\t\t\n\t\tvec3 lig = normalize( vec3(2.0,1.4,-1.0) );\n\t\tfloat sha = 1.0;\n\t\tsha *= ssSphere( pos, lig, sph1 );\n\t\tsha *= ssSphere( pos, lig, sph2 );\n\t\tsha *= ssSphere( pos, lig, sph3 );\n\n\t\tfloat ndl = clamp( dot(nor,lig), 0.0, 1.0 );\n\t\tcol = occ*(0.5+0.5*nor.y)*vec3(0.2,0.3,0.4) + sha*vec3(1.0,0.9,0.8)*ndl + sha*vec3(1.5)*ndl*pow( clamp(dot(normalize(-rd+lig),nor),0.0,1.0), 16.0 );\n\t\tcol *= sur;\n\t\t\n        col *= exp( -0.25*(max(0.0,tmin-3.0)) );\n\n\t}\n\n\tcol = pow( col, vec3(0.45) );\n\t\n\t\/\/-------------------------------------------------------\n\t\n\tProjectionResult res = projectSphere( sph1, cam, fov );\n\tres.area *= iResolution.y*iResolution.y*0.25;\n    if( res.area>0.0 ) col = drawMaths( col, res, p );\n\t\n\tres = projectSphere( sph2, cam, fov );\n\tres.area *= iResolution.y*iResolution.y*0.25;\n    if( res.area>0.0 ) col = drawMaths( col, res, p );\n\t\n\tres = projectSphere( sph3, cam, fov );\n\tres.area *= iResolution.y*iResolution.y*0.25;\n    if( res.area>0.0 ) col = drawMaths( col, res, p );\n\n\t\/\/-------------------------------------------------------\n\t\n\tfragColor = vec4( col, 1.0 );\n}",
                "name": "Image",
                "description": "",
                "type": "image"
            }
        ]
    },
    {
        "ver": "0.1",
        "info": {
            "id": "MddGzf",
            "date": "1451884800",
            "viewed": 61299,
            "name": "Bricks Game",
            "username": "iq",
            "description": "Use arrow keys or the mouse to move the paddle. Use space to restart. This shader uses the new Multipass system",
            "likes": 412,
            "published": 3,
            "flags": 112,
            "usePreview": 0,
            "tags": []
        },
        "renderpass": [
            {
                "inputs": [
                    {
                        "id": "4dXGR8",
                        "filepath": "\/media\/previz\/buffer00.png",
                        "previewfilepath": "\/media\/previz\/buffer00.png",
                        "type": "buffer",
                        "channel": 0,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    },
                    {
                        "id": "XdX3RN",
                        "filepath": "https:\/\/soundcloud.com\/algoritmos666\/tron-legacy-soundtrack-ost-03",
                        "previewfilepath": "https:\/\/soundcloud.com\/algoritmos666\/tron-legacy-soundtrack-ost-03",
                        "type": "musicstream",
                        "channel": 1,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "4dfGRr",
                        "channel": 0
                    }
                ],
                "code": "\/\/ Created by inigo quilez - iq\/2016\n\/\/ https:\/\/www.youtube.com\/c\/InigoQuilez\n\/\/ https:\/\/iquilezles.org\/\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\/\/\n\/\/ Game rendering. Regular 2D distance field rendering.\n\/\/\n\n\n\/\/ storage register\/texel addresses\nconst ivec2 txBallPosVel = ivec2(0,0);\nconst ivec2 txPaddlePos  = ivec2(1,0);\nconst ivec2 txPoints     = ivec2(2,0);\nconst ivec2 txState      = ivec2(3,0);\nconst ivec2 txLastHit    = ivec2(4,0);\nconst ivec4 txBricks     = ivec4(0,1,13,12);\n\nconst float ballRadius = 0.035;\nconst float paddleSize = 0.30;\nconst float paddleWidth = 0.06;\nconst float paddlePosY  = -0.90;\nconst float brickW = 2.0\/13.0;\nconst float brickH = 1.0\/15.0;\n\n\/\/----------------\n\nconst vec2 shadowOffset = vec2(-0.03,0.03);\n\n\/\/=================================================================================================\n\/\/ distance functions\n\/\/=================================================================================================\n\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat udHorizontalSegment( in vec2 p, in float xa, in float xb, in float y )\n{\n    vec2 pa = p - vec2(xa,y);\n    float ba = xb - xa;\n    pa.x -= ba*clamp( pa.x\/ba, 0.0, 1.0 );\n    return length( pa );\n}\n\nfloat udRoundBox( in vec2 p, in vec2 c, in vec2 b, in float r )\n{\n  return length(max(abs(p-c)-b,0.0))-r;\n}\n\n\/\/=================================================================================================\n\/\/ utility\n\/\/=================================================================================================\n\nfloat hash1( in float n )\n{\n    return fract(sin(n)*138.5453123);\n}\n\n\/\/ Digit data by P_Malin (https:\/\/www.shadertoy.com\/view\/4sf3RN)\nconst int[] font = int[](0x75557, 0x22222, 0x74717, 0x74747, 0x11574, 0x71747, 0x71757, 0x74444, 0x75757, 0x75747);\nconst int[] powers = int[](1, 10, 100, 1000, 10000);\nint PrintInt( in vec2 uv, in int value )\n{\n    const int maxDigits = 3;\n    if( abs(uv.y-0.5)<0.5 )\n    {\n        int iu = int(floor(uv.x));\n        if( iu>=0 && iu<maxDigits )\n        {\n            int n = (value\/powers[maxDigits-iu-1]) % 10;\n            uv.x = fract(uv.x);\/\/(uv.x-float(iu)); \n            ivec2 p = ivec2(floor(uv*vec2(4.0,5.0)));\n            return (font[n] >> (p.x+p.y*4)) & 1;\n        }\n    }\n    return 0;\n}\n\n\/\/=================================================================================================\n\nfloat doBrick( in ivec2 id, out vec3 col, out float glo, out vec2 cen )\n{\n    float alp = 0.0;\n    \n    glo = 0.0;\n    col = vec3(0.0);\n    cen = vec2(0.0);\n    \n    if( id.x>0 && id.x<13 && id.y>=0 && id.y<12 )\n    {\n        vec2 brickHere = texelFetch( iChannel0, txBricks.xy+id, 0 ).xy;\n\n        alp = 1.0;\n        glo = 0.0;\n        if( brickHere.x < 0.5 )\n        {\n            float t = max(0.0,iTime-brickHere.y-0.1);\n            alp = exp(-2.0*t );\n            glo = exp(-4.0*t );\n        }\n         \n        if( alp>0.001 )\n        {\n            float fid = hash1( float(id.x*3 + id.y*16) );\n            col = vec3(0.5,0.5,0.6) + 0.4*sin( fid*2.0 + 4.5 + vec3(0.0,1.0,1.0) );\n            if( hash1(fid*13.1)>0.85 )\n            {\n                col = 1.0 - 0.9*col;\n                col.xy += 0.2;\n            }\n        }\n        \n        cen = vec2( -1.0 + float(id.x)*brickW + 0.5*brickW,\n                     1.0 - float(id.y)*brickH - 0.5*brickH );\n    }\n\n    return alp;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy) \/ iResolution.y;\n    float px = 2.0\/iResolution.y;\n    \n    \/\/------------------------\n    \/\/ load game state\n    \/\/------------------------\n    vec2  ballPos   = texelFetch( iChannel0, txBallPosVel, 0 ).xy;\n    float paddlePos = texelFetch( iChannel0, txPaddlePos, 0 ).x;\n    float points    = texelFetch( iChannel0, txPoints, 0 ).x;\n    float state     = texelFetch( iChannel0, txState, 0 ).x;\n    vec3  lastHit   = texelFetch( iChannel0, txLastHit, 0 ).xyz;\n\n    \n    \/\/------------------------\n    \/\/ draw\n    \/\/------------------------\n    vec3 col = vec3(0.0);\n    vec3 emi = vec3(0.0);\n    \n    \/\/ board\n    {\n        col = 0.6*vec3(0.4,0.6,0.7)*(1.0-0.4*length( uv ));\n        col *= 1.0 - 0.1*smoothstep( 0.0,1.0,sin(uv.x*80.0)*sin(uv.y*80.0))*(1.0 - smoothstep( 1.0, 1.01, abs(uv.x) ) );\n    }    \n\n    \/\/ bricks\n    {\n        float b = brickW*0.17;\n\n        \/\/ soft shadow\n        {\n            vec2 st = uv + shadowOffset;\n            ivec2 id = ivec2(floor( vec2( (1.0+st.x)\/brickW, (1.0-st.y)\/brickH) ));\n\n            vec3 bcol; vec2 bcen; float bglo;\n\n            float sha = 0.0;\n            for( int j=-1; j<=1; j++ )\n        \tfor( int i=-1; i<=1; i++ )\n        \t{\n                ivec2 idr = id + ivec2(i, j );\n                float alp = doBrick( idr, bcol, bglo, bcen );\n                float f = udRoundBox( st, bcen, 0.5*vec2(brickW,brickH)-b, b );\n                float s = 1.0 - smoothstep( -brickH*0.5, brickH*1.0, f ); \n                s = mix( 0.0, s, alp );\n                sha = max( sha, s );\n            }\n            col = mix( col, col*0.4, sha );\n        }\n    \n\n        ivec2 id = ivec2(floor( vec2( (1.0+uv.x)\/brickW, (1.0-uv.y)\/brickH) ));\n        \n        \/\/ shape\n        {\n            vec3 bcol; vec2 bcen; float bglo;\n            float alp = doBrick( id, bcol, bglo, bcen );\n            if( alp>0.0001 )\n            {\n                float f = udRoundBox( uv, bcen, 0.5*vec2(brickW,brickH)-b, b );\n                bglo  += 0.6*smoothstep( -4.0*px, 0.0, f );\n\n                bcol *= 0.7 + 0.3*smoothstep( -4.0*px, -2.0*px, f );\n                bcol *= 0.5 + 1.7*bglo;\n                col = mix( col, bcol, alp*(1.0-smoothstep( -px, px, f )) );\n            }\n        }\n        \n        \/\/ gather glow\n        for( int j=-1; j<=1; j++ )\n        for( int i=-1; i<=1; i++ )\n        {\n            ivec2 idr = id + ivec2(i, j );\n            vec3 bcol = vec3(0.0); vec2 bcen; float bglo;\n            float alp = doBrick( idr, bcol, bglo, bcen );\n            float f = udRoundBox( uv, bcen, 0.5*vec2(brickW,brickH)-b, b );\n            emi += bcol*bglo*exp(-600.0*f*f);\n        }\n    }    \n    \n    \n    \/\/ ball \n    {\n        float hit = exp(-4.0*(iTime-lastHit.y) );\n\n        \/\/ shadow\n        float f = 1.0-smoothstep( ballRadius*0.5, ballRadius*2.0, length( uv - ballPos + shadowOffset ) );\n        col = mix( col, col*0.4, f );\n\n        \/\/ shape\n        f = length( uv - ballPos ) - ballRadius;\n        vec3 bcol = vec3(1.0,0.6,0.2);\n        bcol *= 1.0 + 0.7*smoothstep( -3.0*px, -1.0*px, f );\n        bcol *= 0.7 + 0.3*hit;\n        col = mix( col, bcol, 1.0-smoothstep( 0.0, px, f ) );\n        \n        emi  += bcol*0.75*hit*exp(-500.0*f*f );\n    }\n    \n    \n    \/\/ paddle\n    {\n        float hit = exp(-4.0*(iTime-lastHit.x) ) * sin(20.0*(iTime-lastHit.x));\n        float hit2 = exp(-4.0*(iTime-lastHit.x) );\n        float y = uv.y + 0.04*hit * (1.0-pow(abs(uv.x-paddlePos)\/(paddleSize*0.5),2.0));\n\n        \/\/ shadow\n        float f = udHorizontalSegment( vec2(uv.x,y)+shadowOffset, paddlePos-paddleSize*0.5,paddlePos+paddleSize*0.5,paddlePosY );\n        f = 1.0-smoothstep( paddleWidth*0.5*0.5, paddleWidth*0.5*2.0, f );\n        col = mix( col, col*0.4, f );\n\n        \/\/ shape\n        f = udHorizontalSegment( vec2(uv.x,y), paddlePos-paddleSize*0.5, paddlePos+paddleSize*0.5,paddlePosY ) - paddleWidth*0.5;\n        vec3 bcol = vec3(1.0,0.6,0.2);\n        bcol *= 1.0 + 0.7*smoothstep( -3.0*px, -1.0*px, f );\n        bcol *= 0.7 + 0.3*hit2;\n        col = mix( col, bcol, 1.0-smoothstep( -px, px, f ) );\n        emi  += bcol*0.75*hit2*exp( -500.0*f*f );\n\n    }\n\n    \n    \/\/ borders\n    {\n        float f = abs(abs(uv.x)-1.02);\n        f = min( f, udHorizontalSegment(uv,-1.0,1.0,1.0) );\n        f *= 2.0;\n        float a = 0.8 + 0.2*sin(2.6*iTime) + 0.1*sin(4.0*iTime);\n        float hit  = exp(-4.0*(iTime-lastHit.z) );\n        \/\/\n        a *= 1.0-0.3*hit;\n        col += a*0.5*vec3(0.6,0.30,0.1)*exp(- 30.0*f*f);\n        col += a*0.5*vec3(0.6,0.35,0.2)*exp(-150.0*f*f);\n        col += a*1.7*vec3(0.6,0.50,0.3)*exp(-900.0*f*f);\n    }\n    \n    \/\/ score\n    {\n        float f = float(PrintInt( (uv-vec2(-1.5,0.8))*10.0, int(points) ));\n        col = mix( col, vec3(1.0,1.0,1.0), f );\n    }\n    \n    \n    \/\/ add emmission\n    col += emi;\n    \n\n    \/\/------------------------\n    \/\/ game over\n    \/\/------------------------\n    col = mix( col, vec3(1.0,0.5,0.2), state * (0.5+0.5*sin(30.0*iTime)) );\n\n    fragColor = vec4(col,1.0);\n}",
                "name": "Image",
                "description": "",
                "type": "image"
            },
            {
                "inputs": [
                    {
                        "id": "4dXGRr",
                        "filepath": "\/presets\/tex00.jpg",
                        "previewfilepath": "\/presets\/tex00.jpg",
                        "type": "keyboard",
                        "channel": 1,
                        "sampler": {
                            "filter": "nearest",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    },
                    {
                        "id": "4dXGR8",
                        "filepath": "\/media\/previz\/buffer00.png",
                        "previewfilepath": "\/media\/previz\/buffer00.png",
                        "type": "buffer",
                        "channel": 0,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "4dXGR8",
                        "channel": 0
                    }
                ],
                "code": "\/\/ Created by inigo quilez - iq\/2016\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\/\/\n\/\/ Gameplay computation.\n\/\/\n\/\/ The gameplay buffer is 14x14 pixels. The whole game is run\/played for each one of these\n\/\/ pixels. A filter in the end of the shader takes only the bit  of infomration that needs \n\/\/ to be stored in each texl of the game-logic texture.\n\n\/\/ storage register\/texel addresses\nconst ivec2 txBallPosVel = ivec2(0,0);\nconst ivec2 txPaddlePos  = ivec2(1,0);\nconst ivec2 txPoints     = ivec2(2,0);\nconst ivec2 txState      = ivec2(3,0);\nconst ivec2 txLastHit    = ivec2(4,0);\nconst ivec4 txBricks     = ivec4(0,1,13,12);\n\nconst float ballRadius = 0.035;\nconst float paddleSize = 0.30;\nconst float paddleWidth = 0.06;\nconst float paddlePosY  = -0.90;\nconst float brickW = 2.0\/13.0;\nconst float brickH = 1.0\/15.0;\n\nconst float gameSpeed =  3.0;\nconst float inputSpeed = 2.0;\n\nconst int KEY_SPACE = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_RIGHT = 39;\n\n\/\/----------------------------------------------------------------------------------------------\n\nfloat hash1( float n ) { return fract(sin(n)*138.5453123); }\n\n\/\/ intersect a disk sweept in a linear segment with a line\/plane. \nfloat iPlane( in vec2 ro, in vec2 rd, float rad, vec3 pla )\n{\n    float a = dot( rd, pla.xy );\n    if( a>0.0 ) return -1.0;\n    float t = (rad - pla.z - dot(ro,pla.xy)) \/ a;\n    if( t>=1.0 ) t=-1.0;\n    return t;\n}\n\n\/\/ intersect a disk sweept in a linear segment with a box \nvec3 iBox( in vec2 ro, in vec2 rd, in float rad, in vec2 bce, in vec2 bwi ) \n{\n    vec2 m = 1.0\/rd;\n    vec2 n = m*(ro - bce);\n    vec2 k = abs(m)*(bwi+rad);\n    vec2 t1 = -n - k;\n    vec2 t2 = -n + k;\n\tfloat tN = max( t1.x, t1.y );\n\tfloat tF = min( t2.x, t2.y );\n\tif( tN > tF || tF < 0.0) return vec3(-1.0);\n    if( tN>=1.0 ) return vec3(-1.0);\n\tvec2 nor = -sign(rd)*step(t1.yx,t1.xy);\n\treturn vec3( tN, nor );\n}\n\n\/\/----------------------------------------------------------------------------------------------\n\nvec4 loadValue( in ivec2 re )\n{\n    return texelFetch( iChannel0, re, 0 );\n}\nvoid storeValue( in ivec2 re, in vec4 va, inout vec4 fragColor, in ivec2 p )\n{\n    fragColor = (p==re) ? va : fragColor;\n}\nvoid storeValue( in ivec4 re, in vec4 va, inout vec4 fragColor, in ivec2 p )\n{\n    fragColor = ( p.x>=re.x && p.y>=re.y && p.x<=re.z && p.y<=re.w ) ? va : fragColor;\n}\n\n\/\/----------------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ipx = ivec2(fragCoord-0.5);\n \n    \/\/ don't compute gameplay outside of the data area\n    if( fragCoord.x > 14.0 || fragCoord.y>14.0 ) discard;\n    \n    \/\/---------------------------------------------------------------------------------   \n\t\/\/ load game state\n\t\/\/---------------------------------------------------------------------------------\n    vec4  balPosVel = loadValue( txBallPosVel );\n    float paddlePos = loadValue( txPaddlePos ).x;\n    float points    = loadValue( txPoints ).x;\n    float state     = loadValue( txState ).x;\n    vec3  lastHit   = loadValue( txLastHit ).xyz;        \/\/ paddle, brick, wall\n    vec2  brick     = loadValue( ipx ).xy;               \/\/ visible, hittime\n\t\n    \/\/---------------------------------------------------------------------------------\n    \/\/ reset\n\t\/\/---------------------------------------------------------------------------------\n\tif( iFrame==0 ) state = -1.0;\n\t\n    if( state < -0.5 )\n    {\n        state = 0.0;\n        balPosVel = vec4(0.0,paddlePosY+ballRadius+paddleWidth*0.5+0.001, 0.6,1.0);\n        paddlePos = 0.0;\n        points = 0.0;\n        state = 0.0;\n        brick = vec2(1.0,-5.0);\n        lastHit = vec3(-1.0);\n        \n        \n        if( fragCoord.x<1.0 || fragCoord.x>12.0 )\n        {\n            brick.x = 0.0;\n            brick.y = -10.0;\n        }\n        \n\n    }\n\n    \/\/---------------------------------------------------------------------------------\n    \/\/ do game\n    \/\/---------------------------------------------------------------------------------\n\n    \/\/ game over (or won), wait for space key press to resume\n    if( state > 0.5 )\n    {\n        float pressSpace = texelFetch( iChannel1, ivec2(KEY_SPACE,0.0), 0 ).x;\n        if( pressSpace>0.5 )\n        {\n            state = -1.0;\n        }\n    }\n    \n    \/\/ if game mode (not game over), play game\n    else if( state < 0.5 ) \n\t{\n\n        \/\/-------------------\n        \/\/ paddle\n        \/\/-------------------\n        float oldPaddlePos = paddlePos;\n        if( iMouse.w>0.01 )\n        {\n            \/\/ move with mouse\n            paddlePos = (-1.0 + 2.0*iMouse.x\/iResolution.x)*iResolution.x\/iResolution.y;\n        }\n        else\n        {\n            \/\/ move with keyboard\n            float moveRight = texelFetch( iChannel1, ivec2(KEY_RIGHT,0), 0 ).x;\n            float moveLeft  = texelFetch( iChannel1, ivec2(KEY_LEFT,0), 0 ).x;\n            paddlePos += 0.02*inputSpeed*(moveRight - moveLeft);\n        }\n        paddlePos = clamp( paddlePos, -1.0+0.5*paddleSize+paddleWidth*0.5, 1.0-0.5*paddleSize-paddleWidth*0.5 );\n\n        float moveTotal = sign( paddlePos - oldPaddlePos );\n\n        \/\/-------------------\n        \/\/ ball\n\t\t\/\/-------------------\n        float dis = 0.01*gameSpeed*(iTimeDelta*60.0);\n        \n        \/\/ do up to 3 sweep collision detections (usually 0 or 1 will happen only)\n        for( int j=0; j<3; j++ )\n        {\n            ivec3 oid = ivec3(-1);\n            vec2 nor;\n            float t = 1000.0;\n\n            \/\/ test walls\n            const vec3 pla1 = vec3(-1.0, 0.0,1.0 ); \n            const vec3 pla2 = vec3( 1.0, 0.0,1.0 ); \n            const vec3 pla3 = vec3( 0.0,-1.0,1.0 ); \n            float t1 = iPlane( balPosVel.xy, dis*balPosVel.zw, ballRadius, pla1 ); if( t1>0.0         ) { t=t1; nor = pla1.xy; oid.x=1; }\n            float t2 = iPlane( balPosVel.xy, dis*balPosVel.zw, ballRadius, pla2 ); if( t2>0.0 && t2<t ) { t=t2; nor = pla2.xy; oid.x=2; }\n            float t3 = iPlane( balPosVel.xy, dis*balPosVel.zw, ballRadius, pla3 ); if( t3>0.0 && t3<t ) { t=t3; nor = pla3.xy; oid.x=3; }\n            \n            \/\/ test paddle\n            vec3  t4 = iBox( balPosVel.xy, dis*balPosVel.zw, ballRadius, vec2(paddlePos,paddlePosY), vec2(paddleSize*0.5,paddleWidth*0.5) );\n            if( t4.x>0.0 && t4.x<t ) { t=t4.x; nor = t4.yz; oid.x=4;  }\n            \n            \/\/ test bricks\n            ivec2 idr = ivec2(floor( vec2( (1.0+balPosVel.x)\/brickW, (1.0-balPosVel.y)\/brickH) ));\n            ivec2 vs = ivec2(sign(balPosVel.zw));\n            for( int j=0; j<3; j++ )\n            for( int i=0; i<3; i++ )\n            {\n                ivec2 id = idr + ivec2( vs.x*i,-vs.y*j);\n                if( id.x>=0 && id.x<13 && id.y>=0 && id.y<12 )\n                {\n                    float brickHere = texelFetch( iChannel0, (txBricks.xy+id), 0 ).x;\n                    if( brickHere>0.5 )\n                    {\n                        vec2 ce = vec2( -1.0 + float(id.x)*brickW + 0.5*brickW,\n                                         1.0 - float(id.y)*brickH - 0.5*brickH );\n                        vec3 t5 = iBox( balPosVel.xy, dis*balPosVel.zw, ballRadius, ce, 0.5*vec2(brickW,brickH) );\n                        if( t5.x>0.0 && t5.x<t )\n                        {\n                            oid = ivec3(5,id);\n                            t = t5.x;\n                            nor = t5.yz;\n                        }\n                    }\n                }\n            }\n    \n            \/\/ no collisions\n            if( oid.x<0 ) break;\n\n            \n            \/\/ bounce\n            balPosVel.xy += t*dis*balPosVel.zw;\n            dis *= 1.0-t;\n            \n            \/\/ did hit walls\n            if( oid.x<4 )\n            {\n                balPosVel.zw = reflect( balPosVel.zw, nor );\n                lastHit.z = iTime;\n            }\n            \/\/ did hit paddle\n            else if( oid.x<5 )\n            {\n                balPosVel.zw = reflect( balPosVel.zw, nor );\n                \/\/ borders bounce back\n                     if( balPosVel.x > (paddlePos+paddleSize*0.5) ) balPosVel.z =  abs(balPosVel.z);\n                else if( balPosVel.x < (paddlePos-paddleSize*0.5) ) balPosVel.z = -abs(balPosVel.z);\n                balPosVel.z += 0.37*moveTotal;\n                balPosVel.z += 0.11*hash1( float(iFrame)*7.1 );\n                balPosVel.z = clamp( balPosVel.z, -0.9, 0.9 );\n                balPosVel.zw = normalize(balPosVel.zw);\n                \n                \/\/ \n                lastHit.x = iTime;\n                lastHit.y = iTime;\n            }\n            \/\/ did hit a brick\n            else if( oid.x<6 )\n            {\n                balPosVel.zw = reflect( balPosVel.zw, nor );\n                lastHit.y = iTime;\n                points += 1.0;\n                if( points>131.5 )\n                {\n                    state = 2.0; \/\/ won game!\n                }\n\n                if( ipx == txBricks.xy+oid.yz )\n                {\n                    brick = vec2(0.0, iTime);\n                }\n            }\n        }\n        \n        balPosVel.xy += dis*balPosVel.zw;\n        \n        \/\/ detect miss\n        if( balPosVel.y<-1.0 )\n        {\n            state = 1.0; \/\/ game over\n        }\n    }\n    \n\t\/\/---------------------------------------------------------------------------------\n\t\/\/ store game state\n\t\/\/---------------------------------------------------------------------------------\n    fragColor = vec4(0.0);\n    \n \n    storeValue( txBallPosVel, vec4(balPosVel),             fragColor, ipx );\n    storeValue( txPaddlePos,  vec4(paddlePos,0.0,0.0,0.0), fragColor, ipx );\n    storeValue( txPoints,     vec4(points,0.0,0.0,0.0),    fragColor, ipx );\n    storeValue( txState,      vec4(state,0.0,0.0,0.0),     fragColor, ipx );\n    storeValue( txLastHit,    vec4(lastHit,0.0),           fragColor, ipx );\n    storeValue( txBricks,     vec4(brick,0.0,0.0),         fragColor, ipx );\n}",
                "name": "Buffer A",
                "description": "",
                "type": "buffer"
            }
        ]
    },
    {
        "ver": "0.1",
        "info": {
            "id": "4sS3zG",
            "date": "1391423499",
            "viewed": 60806,
            "name": "Dolphin",
            "username": "iq",
            "description": "Dolphin jumping (with very broken geometry and UVs, and water normals)",
            "likes": 248,
            "published": 3,
            "flags": 0,
            "usePreview": 0,
            "tags": []
        },
        "renderpass": [
            {
                "inputs": [
                    {
                        "id": "4sfGRn",
                        "filepath": "\/media\/a\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg",
                        "previewfilepath": "\/media\/ap\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg",
                        "type": "texture",
                        "channel": 3,
                        "sampler": {
                            "filter": "mipmap",
                            "wrap": "repeat",
                            "vflip": "false",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    },
                    {
                        "id": "XsX3Rn",
                        "filepath": "\/media\/a\/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg",
                        "previewfilepath": "\/media\/ap\/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg",
                        "type": "texture",
                        "channel": 2,
                        "sampler": {
                            "filter": "mipmap",
                            "wrap": "repeat",
                            "vflip": "false",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    },
                    {
                        "id": "Xsf3zn",
                        "filepath": "\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
                        "previewfilepath": "\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
                        "type": "texture",
                        "channel": 0,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "repeat",
                            "vflip": "false",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "4dfGRr",
                        "channel": 0
                    }
                ],
                "code": "\/\/ Copyright Inigo Quilez, 2014 - https:\/\/iquilezles.org\/\n\/\/ I am the sole copyright owner of this Work.\n\/\/ You cannot host, display, distribute or share this Work in any form,\n\/\/ including physical and digital. You cannot use this Work in any\n\/\/ commercial or non-commercial product, website or project. You cannot\n\/\/ sell this Work and you cannot mint an NFTs of it.\n\/\/ I share this Work for educational purposes, and you can link to it,\n\/\/ through an URL, proper attribution and unmodified screenshot, as part\n\/\/ of your educational material. If these conditions are too restrictive\n\/\/ please contact me and we'll definitely work it out.\n\t\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\/\nvec2 sd2Segment( vec3 a, vec3 b, vec3 p )\n{\n\tvec3  pa = p - a;\n\tvec3  ba = b - a;\n\tfloat t = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\tvec3  v = pa - ba*t;\n\treturn vec2( dot(v,v), t );\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\/\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/smin\/\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)\/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/functions\/\nfloat almostIdentity( float x, float m, float n )\n{\n    if( x>m ) return x;\n    float a = 2.0*n - m;\n    float b = 2.0*m - 3.0*n;\n    float t = x\/m;\n    return (a*t + b)*t*t + n;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/functions\/\nfloat almostAbs( float x )\n{\n    return 1.0-x*x;\n    \n    return almostIdentity(abs(x), 0.05, 0.025 );\n}\n\n\nfloat hash(vec2 p)\n{\n    p  = 50.0*fract( p*0.3183099);\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                              hash( i + vec2(1.0,0.0) ), u.x),\n                         mix( hash( i + vec2(0.0,1.0) ), \n                              hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\/\/-----------------------------------------------------------------------------------\n\n#define NUMI 11\n#define NUMF 11.0\n\nvec3 fishPos;\nfloat fishTime;\nfloat isJump;\nfloat isJump2;\n\nvec2 anima( float ih, float t )\n{\n    float an1 = 0.9*(0.5+0.2*ih)*cos(5.0*ih - 3.0*t + 6.2831\/4.0);\n    float an2 = 1.0*cos(3.5*ih - 1.0*t + 6.2831\/4.0);\n    float an = mix( an1, an2, isJump );\n    float ro = 0.4*cos(4.0*ih - 1.0*t)*(1.0-0.5*isJump);\n\treturn vec2( an, ro );\n}\n\nvec3 anima2( void )\n{\n    vec3 a1 = vec3(0.0,        sin(3.0*fishTime+6.2831\/4.0),0.0);\n    vec3 a2 = vec3(0.0,1.5+2.5*cos(1.0*fishTime),0.0);\n\tvec3 a = mix( a1, a2, isJump );\n\ta.y *= 0.5;\n\ta.x += 0.1*sin(0.1 - 1.0*fishTime)*(1.0-isJump);\n    return a;\n}\n\n\/\/ simple version of the dolphin, without fins and tail\n\/\/ just for collision detection with water\nfloat sdDolphinCheap( vec3 p )\n{\n\tp -= fishPos;\n\tvec3 a = anima2();\n\t\t\n    float res = 100000.0;\n\tfor( int i=0; i<NUMI; i++ )\n\t{\t\n\t\tfloat ih = float(i)\/NUMF;\n\t\tvec2 anim = anima( ih, fishTime );\n\t\tfloat ll = 0.48; if( i==0 ) ll=0.655;\n\t\tvec3 b = a + ll*normalize(vec3(sin(anim.y), sin(anim.x), cos(anim.x)));\n\t\tvec2 dis = sd2Segment( a, b, p );\n        float h = ih+dis.y\/NUMF;\n\t\tfloat ra = 0.04 + h*(1.0-h)*(1.0-h)*2.7;\n\t\tres = min( res, sqrt(dis.x) - ra );\n\t\ta = b;\n\t}\n\treturn 0.75 * res;\n}\n\nvec3 ccd, ccp;\n\t\nvec2 sdDolphin( vec3 p )\n{\n    vec2 res = vec2( 1000.0, 0.0 );\n\n\tp -= fishPos;\n\n\tvec3 a = anima2();\n\t\n\tfloat or = 0.0;\n\tfloat th = 0.0;\n\tfloat hm = 0.0;\n\n\tvec3 p1 = a; vec3 d1=vec3(0.0);\n\tvec3 p2 = a; vec3 d2=vec3(0.0);\n\tvec3 p3 = a; vec3 d3=vec3(0.0);\n\tvec3 mp = a;\n\tfor( int i=0; i<NUMI; i++ )\n\t{\t\n\t\tfloat ih = float(i)\/NUMF;\n\t\tvec2 anim = anima( ih, fishTime );\n\t\tfloat ll = 0.48; if( i==0 ) ll=0.655;\n\t\tvec3 b = a + ll*normalize(vec3(sin(anim.y), sin(anim.x), cos(anim.x)));\n\t\t\n\t\tvec2 dis = sd2Segment( a, b, p );\n\n\t\tif( dis.x<res.x ) {res=vec2(dis.x,ih+dis.y\/NUMF); mp=a+(b-a)*dis.y; ccd = b-a;}\n\t\t\n\t\tif( i==3 ) { p1=a; d1 = b-a; }\n\t\tif( i==4 ) { p3=a; d3 = b-a; }\n\t\tif( i==(NUMI-1) ) { p2=b; d2 = b-a; }\n\n\t\ta = b;\n\t}\n\tccp = mp;\n\t\n\tfloat h = res.y;\n\tfloat ra = 0.05 + h*(1.0-h)*(1.0-h)*2.7;\n\tra += 7.0*max(0.0,h-0.04)*exp(-30.0*max(0.0,h-0.04)) * smoothstep(-0.1, 0.1, p.y-mp.y);\n\tra -= 0.03*(smoothstep(0.0, 0.1, abs(p.y-mp.y)))*(1.0-smoothstep(0.0,0.1,h));\n\tra += 0.05*clamp(1.0-3.0*h,0.0,1.0);\n    ra += 0.035*(1.0-smoothstep( 0.0, 0.025, abs(h-0.1) ))* (1.0-smoothstep(0.0, 0.1, abs(p.y-mp.y)));\n\t\n\t\/\/ body\n\tres.x = 0.75 * (distance(p,mp) - ra);\n\n    \/\/ fin\t\n\td3 = normalize(d3);\n\tfloat k = sqrt(1.0 - d3.y*d3.y);\n\tmat3 ms = mat3(  d3.z\/k, -d3.x*d3.y\/k, d3.x,\n\t\t\t\t        0.0,            k, d3.y,\n\t\t\t\t    -d3.x\/k, -d3.y*d3.z\/k, d3.z );\n\tvec3 ps = p - p3;\n\tps = ms*ps;\n\tps.z -= 0.1;\n    float d5 = length(ps.yz) - 0.9;\n\td5 = max( d5, -(length(ps.yz-vec2(0.6,0.0)) - 0.35) );\n\td5 = max( d5, udRoundBox( ps+vec3(0.0,-0.5,0.5), vec3(0.0,0.5,0.5), 0.02 ) );\n\tres.x = smin( res.x, d5, 0.1 );\n\t\n    \/\/ fin\t\n\td1 = normalize(d1);\n\tk = sqrt(1.0 - d1.y*d1.y);\n\tms = mat3(  d1.z\/k, -d1.x*d1.y\/k, d1.x,\n\t\t\t\t   0.0,            k, d1.y,\n               -d1.x\/k, -d1.y*d1.z\/k, d1.z );\n\tps = p - p1;\n\tps = ms*ps;\n\tps.x = abs(ps.x);\n\tfloat l = ps.x;\n\tl=clamp( (l-0.4)\/0.5, 0.0, 1.0 );\n\tl=4.0*l*(1.0-l);\n\tl *= 1.0-clamp(5.0*abs(ps.z+0.2),0.0,1.0);\n\tps.xyz += vec3(-0.2,0.36,-0.2);\n    d5 = length(ps.xz) - 0.8;\n\td5 = max( d5, -(length(ps.xz-vec2(0.2,0.4)) - 0.8) );\n\td5 = max( d5, udRoundBox( ps+vec3(0.0,0.0,0.0), vec3(1.0,0.0,1.0), 0.015+0.05*l ) );\n\tres.x = smin( res.x, d5, 0.12 );\n\t\n    \/\/ tail\t\n\td2 = normalize(d2);\n\tmat2 mf = mat2( d2.z, d2.y, -d2.y, d2.z );\n\tvec3 pf = p - p2 - d2*0.25;\n\tpf.yz = mf*pf.yz;\n    float d4 = length(pf.xz) - 0.6;\n\td4 = max( d4, -(length(pf.xz-vec2(0.0,0.8)) - 0.9) );\n\td4 = max( d4, udRoundBox( pf, vec3(1.0,0.005,1.0), 0.005 ) );\n\tres.x = smin( res.x, d4, 0.1 );\n\t\n\treturn res;\n}\n\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\n\nvec2 sdWaterCheap( vec3 p )\n{\n    vec2 q = 0.1*p.xz;\n\tfloat f = 0.0;\n    f += 0.50000*almostAbs(noise( q )); q = m2*q*2.02; q -= 0.1*iTime;\n    f += 0.25000*almostAbs(noise( q )); q = m2*q*2.03; q += 0.2*iTime;\n    f += 0.12500*almostAbs(noise( q )); q = m2*q*2.01; q -= 0.4*iTime;\n    f += 0.06250*almostAbs(noise( q )); q = m2*q*2.02; q += 1.0*iTime;\n    f += 0.03125*almostAbs(noise( q ));\n    \/\/f = f*f;\n    \n    return vec2(1.8-2.0*f,f);\n}\n\nvec3 sdWater( vec3 p )\n{\n\tvec2 q = 0.05*p.xz;\n\n    vec2 w = sdWaterCheap( p );\n    \n    \/\/ splash from collision with dolphin\n\tfloat sss = abs(sdDolphinCheap(p));\n\tfloat spla = exp(-4.0*sss);\n\tspla += 0.5*exp(-14.0*sss);\n\tspla *= mix(1.0,texture( iChannel0, 0.2*p.xz ).x,spla*spla);\n\tspla *= -0.85;\n\tspla *= isJump;\n\tspla *= mix( 1.0, smoothstep(0.0,0.5,p.z-fishPos.z-1.5), isJump2 );\n\n\treturn vec3( p.y-w.x + spla, w.y, sss );\n}\n\nvec2 intersectDolphin( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 10.0;\n\tconst float precis = 0.001;\n    float t = 0.0;\n\tfloat l = 0.0;\n    for( int i=0; i<128; i++ )\n    {\n\t    vec2 res = sdDolphin( ro+rd*t );\n        float h = res.x;\n\t\tl = res.y;\n\t\tif( h<precis || t>maxd ) break;\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n    return vec2( t, l);\n}\n\nvec3 intersectWater( vec3 ro, in vec3 rd )\n{\n\tconst float precis = 0.001;\n\tfloat l = 0.0;\n\tfloat s = 0.0;\n\n\tfloat t = (2.5-ro.y)\/rd.y; \n\tif( t<0.0 ) return vec3(-1.0);\n\n\tfor( int i=0; i<12; i++ )\n    {\n\t    vec3 res = sdWater( ro+rd*t );\n\t\tl = res.y;\n\t\ts = res.z;\n\t\tif( abs(res.x)<precis ) break;\n        t += res.x;\n    }\n\n    return vec3( t, l, s );\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/normalsSDF\nvec3 calcNormalFish( in vec3 pos )\n{\n#if 0    \n    const vec3 eps = vec3(0.08,0.0,0.0);\n\tfloat v = sdDolphin(pos).x;\n\treturn normalize( vec3(\n           sdDolphin(pos+eps.xyy).x - v,\n           sdDolphin(pos+eps.yxy).x - v,\n           sdDolphin(pos+eps.yyx).x - v ) );\n#else\n    \/\/ inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=min(iFrame,0); i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdDolphin(pos+0.08*e).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nvec3 calcNormalWater( in vec3 pos )\n{\n    const vec3 eps = vec3(0.025,0.0,0.0);\n    float v = sdWater(pos).x;\t\n\treturn normalize( vec3( sdWater(pos+eps.xyy).x - v,\n                            eps.x,\n                            sdWater(pos+eps.yyx).x - v ) );\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/rmshadows\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n\tfloat h = 1.0;\n    for( int i=0; i<25; i++ )\n    {\n        h = sdDolphinCheap(ro + rd*t);\n        res = min( res, k*h\/t );\n\t\tt += clamp( h, 0.05, 0.5 );\n\t\tif( h<0.0001 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nconst vec3 lig = vec3(0.86,0.15,0.48);\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, float glossy, float glossy2, float shadows, in vec3 col, float occ )\n{\n    vec3 hal = normalize(lig-rd);\n\tvec3 ref = reflect(rd,nor);\n\t\n    \/\/ lighting\n    float sky = clamp(nor.y,0.0,1.0);\n\tfloat bou = clamp(-nor.y,0.0,1.0);\n    float dif = max(dot(nor,lig),0.0);\n    float bac = max(0.3 + 0.7*dot(nor,-vec3(lig.x,0.0,lig.z)),0.0);\n    float sha = 1.0-shadows; if( (shadows*dif)>0.001 ) sha=softshadow( pos+0.01*nor, lig, 0.0005, 32.0 );\n    float fre = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 5.0 );\n    float spe = max( 0.0, pow( clamp( dot(hal,nor), 0.0, 1.0), 0.01+glossy ) );\n    float sss = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 2.0 );\n    \n    float shr = 1.0;\n    if( shadows>0.0 ) shr=softshadow( pos+0.01*nor, normalize(ref+vec3(0.0,1.0,0.0)), 0.0005, 8.0 );\n    \n    \/\/ lights\n    vec3 brdf = vec3(0.0);\n    brdf += 20.0*dif*vec3(4.00,2.20,1.40)*vec3(sha,sha*0.5+0.5*sha*sha,sha*sha);\n    brdf += 11.0*sky*vec3(0.20,0.40,0.55)*(0.5+0.5*occ);\n    brdf += 1.0*bac*vec3(0.40,0.60,0.70);\/\/*occ;\n    brdf += 11.0*bou*vec3(0.05,0.30,0.50);\n    brdf += 5.0*sss*vec3(0.40,0.40,0.40)*(0.3+0.7*dif*sha)*glossy*occ;\n    brdf += 0.8*spe*vec3(1.30,1.00,0.90)*sha*dif*(0.1+0.9*fre)*glossy*glossy;\n    brdf += shr*40.0*glossy*vec3(1.0,1.0,1.0)*occ*smoothstep( -0.3+0.3*glossy2, 0.2, ref.y )*(0.5+0.5*smoothstep( -0.2+0.2*glossy2, 1.0, ref.y ))*(0.04+0.96*fre);\n    col = col*brdf;\n    col += shr*(0.1 + 1.6*fre)*occ*glossy2*glossy2*40.0*vec3(1.0,0.9,0.8)*smoothstep( 0.0, 0.2, ref.y )*(0.5+0.5*smoothstep( 0.0, 1.0, ref.y ));\/\/*smoothstep(-0.1,0.0,dif);\n    col += 1.2*glossy*pow(spe,4.0)*vec3(1.4,1.1,0.9)*sha*dif*(0.04+0.96*fre)*occ;\n\t\n\treturn col;\n}\n\nvec3 normalMap( in vec2 pos )\n{\n\tfloat v = texture( iChannel3, 0.03*pos ).x;\n\treturn normalize(vec3(\n        v-texture( iChannel3, 0.03*pos+vec2(1.0\/1024.0,0.0)).x,\n\t    1.0\/16.0,\n\t    v-texture( iChannel3, 0.03*pos+vec2(0.0,1.0\/1024.0)).x ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy \/ iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x\/iResolution.y;\n    vec2 m = vec2(0.5);\n\tif( iMouse.z>0.0 ) m = iMouse.xy\/iResolution.xy;\n\n    \/\/-----------------------------------------------------\n    \/\/ animate\n    \/\/-----------------------------------------------------\n\t\n\tfishTime = 0.6 + 2.0*iTime - 20.0;\n\t\n\tfishPos = vec3( 0.0, 0.0-0.2, -1.1*fishTime );\n\t\n\tisJump  = 0.5 + 0.5*cos(     -0.4+0.5*fishTime);\n\tisJump2 = 0.5 + 0.5*cos( 0.6+0.5*fishTime);\n\tfloat isJump3 = 0.5 + 0.5*cos(-1.4+0.5*fishTime);\n\n    \/\/-----------------------------------------------------\n    \/\/ camera\n    \/\/-----------------------------------------------------\n\n\tfloat an = 1.2 + 0.1*iTime - 12.0*(m.x-0.5);\n\n\tvec3 ta = vec3(fishPos.x,0.8,fishPos.z) - vec3(0.0,0.0,-2.0);\n\tvec3 ro = ta + vec3(4.0*sin(an),3.1,4.0*cos(an));\n\n    \/\/ shake\n\tro += 0.05*sin(4.0*iTime*vec3(1.1,1.2,1.3)+vec3(3.0,0.0,1.0) );\n\tta += 0.05*sin(4.0*iTime*vec3(1.7,1.5,1.6)+vec3(1.0,2.0,1.0) );\n\n    \/\/ camera matrix\n    vec3 ww = normalize( ta - ro );\n    \/\/vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n\tvec3 uu = normalize( vec3(-ww.z,0.0,ww.x) );\n    vec3 vv = normalize( cross(uu,ww));\n\t\n\t\/\/ create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww*(1.0+0.7*smoothstep(-0.4,0.4,sin(0.34*iTime))) );\n\n    \/\/-----------------------------------------------------\n\t\/\/ render\n    \/\/-----------------------------------------------------\n\n\tfloat t = 1000.0;\n\t\n\tvec3 col = vec3(0.0);\n\tvec3 bgcol = vec3(0.6,0.7,0.8) - .2*clamp(rd.y,0.0,1.0);\n\n    \/\/ acceleration bounding plane at y=3.2\n\tfloat pt = (3.2-ro.y)\/rd.y;\n\tif( rd.y<0.0 && pt>0.0 ) ro=ro+rd*pt;\n\n\t\/\/ raymarch\n    vec2 tmat1 = intersectDolphin(ro,rd);\n\tvec3 posy = vec3(-100000.0);\n    if( tmat1.x>0.0 )\n    {\n\t\tvec2 tmat = tmat1;\n\t\tt = tmat.x;\n        \/\/ geometry\n        vec3 pos = ro + tmat.x*rd;\n        vec3 nor = calcNormalFish(pos);\n\t\tvec3 ref = reflect( rd, nor );\n\t\tvec3 fpos = pos - fishPos;\n\n\t\tvec3 auu = normalize( vec3(-ccd.z,0.0,ccd.x) );\n\t\tvec3 avv = normalize( cross(ccd,auu) );\n\t\tvec3 ppp = vec3( dot(fpos-ccp,auu),  dot(fpos-ccp,avv), tmat.y );\n\t\tvec2 uv = vec2( 1.0*atan(ppp.x,ppp.y)\/3.1416, 4.0*ppp.z );\n\n\t\tvec3 bnor = -1.0+2.0*texture(iChannel0,uv).xyz;\n        nor += 0.01*bnor;\n\n\t\tvec3 te = texture( iChannel2, uv ).xyz;\n\t\tvec4 mate;\n\t\tmate.w = 10.0;\n        mate.xyz = mix( vec3(0.3,0.38,0.46)*0.6, vec3(0.8,0.9,1.0), smoothstep(-0.05,0.05,ppp.y-tmat.y*0.5+0.1) );\n        mate.xyz *= 1.0 + 0.3*te;\n\t\tmate.xyz *= smoothstep( 0.0, 0.06, distance(vec3(abs(ppp.x),ppp.yz)*vec3(1.0,1.0,4.0),vec3(0.35,0.0,0.4)) );\n\t\tmate.xyz *= 1.0 - 0.75*(1.0-smoothstep( 0.0, 0.02, abs(ppp.y) ))*(1.0-smoothstep( 0.07, 0.11, tmat.y ));\n\t\tmate.xyz *= 0.1*0.23*0.6;\n        mate.w *= (0.7+0.3*te.x)*smoothstep( 0.0, 0.01, pos.y-sdWaterCheap( pos ).x );\n\t\t\t\n        \/\/ surface-light interacion\n        col = doLighting( pos, nor, rd, mate.w, 0.0, 0.0, mate.xyz, 1.0 );\n\t\n\t\tposy = pos;\n\t}\n\t\n    vec3 tmat2 = intersectWater(ro,rd);\n\tvec3 col2 = vec3(0.0);\n\tif( tmat2.x>0.0 && (tmat1.x<0.0 || tmat2.x<tmat1.x) )\n\t{\n\t\tvec3 tmat = tmat2;\n\n        t = tmat.x;\n\n        vec3 pos = ro + tmat.x*rd;\n        vec3 nor = calcNormalWater(pos);\n\t\tvec3 ref = reflect( rd, nor );\n        nor = normalize( nor + 0.15*normalMap(pos.xz) );\n        float fre = pow( clamp(1.0 + dot( rd, nor ),0.0,1.0), 2.0 );\n        \n        \/\/ water\n        vec4 mate;\n\t\tmate.xyz = 0.05*mix( vec3(0.0,0.07,0.2)*0.8, vec3(0.0,0.12,0.2), (1.0-smoothstep(0.2,0.8,tmat.y))*(0.5+0.5*fre) );\n\t\tmate.w = fre;\t\n\n        \/\/ foam\n        float foam = 1.0-smoothstep( 0.4, 0.6, tmat.y );\n        foam *= abs(nor.z)*2.0;\n        foam *= clamp(1.0-2.0*texture( iChannel2, vec2(1.0,0.75)*0.31*pos.xz ).x,0.0,1.0);\n        mate = mix( mate, vec4(0.1*0.2,0.11*0.2,0.13*0.2,0.5), foam );\n\t\tfloat al = clamp( 0.5 + 0.2*(pos.y - posy.y), 0.0, 1.0 );\n\t\tfoam = exp( -3.0*abs(tmat.z) );\n\t\tfoam *= texture( iChannel3, pos.zx ).x;\n\t\tfoam = clamp( foam*3.0, 0.0, 1.0 );\n\t\tfoam *= isJump;\n\t\tfoam *= mix( 1.0, smoothstep(0.0,0.5,pos.z-fishPos.z-1.5), isJump2 );\n\t\tmate.xyz = mix( mate.xyz, vec3(0.9,0.95,1.0)*0.05, foam*foam );\n        \n\t\tcol = mix( col, vec3(0.9,0.95,1.0)*1.2, foam );\n\t\tal *= 1.0-foam;\n\n\t\tfloat occ = clamp(3.5*sdDolphinCheap(pos+vec3(0.0,0.4,0.0)) * sdDolphinCheap(pos+vec3(0.0,1.0,0.0)),0.0,1.0);\n        occ = mix(1.0,occ,isJump);\n        occ = 0.35 + 0.65*occ;\n\t\tmate.xyz *= occ;\n        col *= occ;\n\n\t\tmate.xyz = doLighting( pos, nor, rd, mate.w*10.0, mate.w*0.5, 1.0, mate.xyz, occ );\n\t\t\n        \/\/ caustics in dolphin\n        float cc  = 0.65*texture( iChannel0, 2.5*0.02*posy.xz + 0.007*iTime*vec2( 1.0, 0.0) ).x;\n        cc += 0.35*texture( iChannel0, 1.8*0.04*posy.xz + 0.011*iTime*vec2( 0.0, 1.0) ).x;\n        cc = 0.6*(1.0-smoothstep( 0.0, 0.05, abs(cc-0.5))) + \n\t         0.4*(1.0-smoothstep( 0.0, 0.20, abs(cc-0.5)));\n        col *= 1.0 + 0.8*cc;\n\t\t\n\t\tcol = mix( col, mate.xyz, al );\n\t}\n\t\t\n\tfloat sun = pow( max(0.0,dot( lig, rd )),8.0 );\n\tcol += vec3(0.8,0.5,0.1)*sun*0.3;\n\n    \/\/ gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.45) );\n\n    \/\/ color\n    col = col*0.5 + 0.5*col*col*(3.0-2.0*col);\n\t\t\n    \/\/ vigneting\t\n\tcol *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\n    \/\/ fade\t\n\tcol *= smoothstep( 0.0, 1.0, iTime );\n\t\n\tfragColor = vec4( col, 1.0 );\n}",
                "name": "Image",
                "description": "",
                "type": "image"
            }
        ]
    },
    {
        "ver": "0.1",
        "info": {
            "id": "4sX3Rn",
            "date": "1358124981",
            "viewed": 59552,
            "name": "Menger Sponge",
            "username": "iq",
            "description": "Four iterations of the famous fractal structure. See [url]https:\/\/iquilezles.org\/articles\/menger[\/url] for the full explanation of how this was done.",
            "likes": 126,
            "published": 3,
            "flags": 1,
            "usePreview": 0,
            "tags": []
        },
        "renderpass": [
            {
                "inputs": [],
                "outputs": [
                    {
                        "id": "4dfGRr",
                        "channel": 0
                    }
                ],
                "code": "\/\/ The MIT License\n\/\/ https:\/\/www.youtube.com\/c\/InigoQuilez\n\/\/ https:\/\/iquilezles.org\/\n\/\/ Copyright \u00a9 2013 Inigo Quilez\n\/\/ Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\/\/ https:\/\/iquilezles.org\/articles\/menger\n\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2\n#endif\n\n\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3  di = abs(p) - b;\n    float mc = maxcomp(di);\n    return min(mc,length(max(di,0.0)));\n}\n\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0\/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nconst mat3 ma = mat3( 0.60, 0.00,  0.80,\n                      0.00, 1.00,  0.00,\n                     -0.80, 0.00,  0.60 );\nvec4 map( in vec3 p )\n{\n    float d = sdBox(p,vec3(1.0));\n    vec4 res = vec4( d, 1.0, 0.0, 0.0 );\n\n    float ani = smoothstep( -0.2, 0.2, -cos(0.5*iTime) );\n\tfloat off = 1.5*sin( 0.01*iTime );\n\t\n    float s = 1.0;\n    for( int m=0; m<4; m++ )\n    {\n        p = mix( p, ma*(p+off), ani );\n\t   \n        vec3 a = mod( p*s, 2.0 )-1.0;\n        s *= 3.0;\n        vec3 r = abs(1.0 - 3.0*abs(a));\n        float da = max(r.x,r.y);\n        float db = max(r.y,r.z);\n        float dc = max(r.z,r.x);\n        float c = (min(da,min(db,dc))-1.0)\/s;\n\n        if( c>d )\n        {\n          d = c;\n          res = vec4( d, min(res.y,0.2*da*db*dc), (1.0+float(m))\/4.0, 0.0 );\n        }\n    }\n\n    return res;\n}\n\nvec4 intersect( in vec3 ro, in vec3 rd )\n{\n    vec2 bb = iBox( ro, rd, vec3(1.05) );\n    if( bb.y<bb.x ) return vec4(-1.0);\n    \n    float tmin = bb.x;\n    float tmax = bb.y;\n    \n    float t = tmin;\n    vec4 res = vec4(-1.0);\n    for( int i=0; i<64; i++ )\n    {\n        vec4 h = map(ro + rd*t);\n\t\tif( h.x<0.002 || t>tmax ) break;\n        res = vec4(t,h.yzw);\n        t += h.x;\n    }\n\tif( t>tmax ) res=vec4(-1.0);\n    return res;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    vec2 bb = iBox( ro, rd, vec3(1.05) );\n    float tmax = bb.y;\n    \n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<64; i++ )\n    {\n        float h = map(ro + rd*t).x;\n        res = min( res, k*h\/t );\n        if( res<0.001 ) break;\n\t\tt += clamp( h, 0.005, 0.1 );\n        if( t>tmax ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec3 eps = vec3(.001,0.0,0.0);\n    return normalize(vec3(\n    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n    map(pos+eps.yyx).x - map(pos-eps.yyx).x ));\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    \/\/ background color\n    vec3 col = mix( vec3(0.3,0.2,0.1)*0.5, vec3(0.7, 0.9, 1.0), 0.5 + 0.5*rd.y );\n\t\n    vec4 tmat = intersect(ro,rd);\n    if( tmat.x>0.0 )\n    {\n        vec3  pos = ro + tmat.x*rd;\n        vec3  nor = calcNormal(pos);\n        \n        vec3 matcol = 0.5 + 0.5*cos(vec3(0.0,1.0,2.0)+2.0*tmat.z);\n        \n        float occ = tmat.y;\n\n        const vec3 light = normalize(vec3(1.0,0.9,0.3));\n        float dif = dot(nor,light);\n        float sha = 1.0;\n        if( dif>0.0 ) sha=softshadow( pos, light, 0.01, 64.0 );\n        dif = max(dif,0.0);\n        vec3  hal = normalize(light-rd);\n        float spe = dif*sha*pow(clamp(dot(hal,nor),0.0,1.0),16.0)*(0.04+0.96*pow(clamp(1.0-dot(hal,light),0.0,1.0),5.0));\n        \n\t\tfloat sky = 0.5 + 0.5*nor.y;\n        float bac = max(0.4 + 0.6*dot(nor,vec3(-light.x,light.y,-light.z)),0.0);\n\n        vec3 lin  = vec3(0.0);\n        lin += 1.00*dif*vec3(1.10,0.85,0.60)*sha;\n        lin += 0.50*sky*vec3(0.10,0.20,0.40)*occ;\n        lin += 0.10*bac*vec3(1.00,1.00,1.00)*(0.5+0.5*occ);\n        lin += 0.25*occ*vec3(0.15,0.17,0.20);\t \n        col = matcol*lin + spe*128.0;\n    }\n\n    col = 1.5*col\/(1.0+col);\n    col = sqrt( col );\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ camera\n    vec3 ro = 1.1*vec3(2.5*sin(0.25*iTime),1.0+1.0*cos(iTime*.13),2.5*cos(0.25*iTime));\n\n#if AA>1\n    #define ZERO (min(iFrame,0))\n    vec3 col = vec3(0.0);\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        \/\/ pixel coordinates\n        vec2 o = vec2(float(m),float(n)) \/ float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)\/iResolution.y;\n\n        vec3 ww = normalize(vec3(0.0) - ro);\n        vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n        vec3 vv = normalize(cross(ww,uu));\n        vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n\n        col += render( ro, rd );\n    }\n    col \/= float(AA*AA);\n#else   \n    vec2 p = (2.0*fragCoord-iResolution.xy)\/iResolution.y;\n    vec3 ww = normalize(vec3(0.0) - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n    vec3 col = render( ro, rd );\n#endif        \n    \n    fragColor = vec4(col,1.0);\n}\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    float time = iTime*0.25 + 0.01*iMouse.x;\n    float anim = 1.1 + 0.5*smoothstep( -0.3, 0.3, cos(0.1*iTime) );\n\n    vec3 col = render( fragRayOri + vec3(0.0,1.0,2.5), fragRayDir );\n    fragColor = vec4( col, 1.0 );\n}",
                "name": "Image",
                "description": "",
                "type": "image"
            }
        ]
    },
    {
        "ver": "0.1",
        "info": {
            "id": "4tByz3",
            "date": "1511132429",
            "viewed": 57044,
            "name": "Ladybug",
            "username": "iq",
            "description": "A ladybug on a mushroom. It renders really slowly. Sorry for that, this is not meant to be rendered with raymarching really, but well, here we are. I'll get a pass later",
            "likes": 263,
            "published": 3,
            "flags": 32,
            "usePreview": 0,
            "tags": []
        },
        "renderpass": [
            {
                "inputs": [
                    {
                        "id": "4dXGR8",
                        "filepath": "\/media\/previz\/buffer00.png",
                        "previewfilepath": "\/media\/previz\/buffer00.png",
                        "type": "buffer",
                        "channel": 0,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "4dfGRr",
                        "channel": 0
                    }
                ],
                "code": "\/\/ Copyright Inigo Quilez, 2017 - https:\/\/iquilezles.org\/\n\/\/ I am the sole copyright owner of this Work.\n\/\/ You cannot host, display, distribute or share this Work in any form,\n\/\/ including physical and digital. You cannot use this Work in any\n\/\/ commercial or non-commercial product, website or project. You cannot\n\/\/ sell this Work and you cannot mint an NFTs of it.\n\/\/ I share this Work for educational purposes, and you can link to it,\n\/\/ through an URL, proper attribution and unmodified screenshot, as part\n\/\/ of your educational material. If these conditions are too restrictive\n\/\/ please contact me and we'll definitely work it out.\n\n\/\/ You can buy a metal print of this shader here:\n\/\/ https:\/\/www.redbubble.com\/i\/metal-print\/Ladybug-by-InigoQuilez\/39845563.0JXQP\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord \/ iResolution.xy;\n    \n    \n    \/\/ dof\n    const float focus = 2.35;\n\n    vec4 acc = vec4(0.0);\n    const int N = 12;\n\tfor( int j=-N; j<=N; j++ )\n    for( int i=-N; i<=N; i++ )\n    {\n        vec2 off = vec2(float(i),float(j));\n        \n        vec4 tmp = texture( iChannel0, q + off\/vec2(800.0,450.0) ); \n        \n        float depth = tmp.w;\n        \n        vec3  color = tmp.xyz;\n        \n        float coc = 0.05 + 12.0*abs(depth-focus)\/depth;\n        \n        if( dot(off,off) < (coc*coc) )\n        {\n            float w = 1.0\/(coc*coc); \n            acc += vec4(color*w,w);\n        }\n    }\n    \n    vec3 col = acc.xyz \/ acc.w;\n\n    \n    \/\/ gamma\n    col = pow( col, vec3(0.4545) );\n    \n    \/\/ color correct - it seems my laptop has a fucked up contrast\/gamma seeting, so I need\n    \/\/                 to do this for the picture to look okey in all computers but mine...\n    col = col*1.1 - 0.06;\n    \n    \/\/ vignetting\n    col *= 0.8 + 0.3*sqrt( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y) );\n\n    fragColor = vec4(col,1.0);\n}",
                "name": "Image",
                "description": "",
                "type": "image"
            },
            {
                "inputs": [
                    {
                        "id": "XsX3Rn",
                        "filepath": "\/media\/a\/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg",
                        "previewfilepath": "\/media\/ap\/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg",
                        "type": "texture",
                        "channel": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "wrap": "repeat",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "4dXGR8",
                        "channel": 0
                    }
                ],
                "code": "\/\/ Created by inigo quilez - iq\/2017\n\/\/ I share this piece (art and code) here in Shadertoy and through its Public API, only for educational purposes. \n\/\/ You cannot use, sell, share or host this piece or modifications of it as part of your own commercial or non-commercial product, website or project.\n\/\/ You can share a link to it or an unmodified screenshot of it provided you attribute \"by Inigo Quilez, @iquilezles and iquilezles.org\". \n\/\/ If you are a teacher, lecturer, educator or similar and these conditions are too restrictive for your needs, please contact me and we'll work it out.\n\n\n#define MAT_MUSH_HEAD 1.0\n#define MAT_MUSH_NECK 2.0\n#define MAT_LADY_BODY 3.0\n#define MAT_LADY_HEAD 4.0\n#define MAT_LADY_LEGS 5.0\n#define MAT_GRASS     6.0\n#define MAT_GROUND    7.0\n#define MAT_MOSS      8.0\n#define MAT_CITA      9.0\n\nvec2  hash2( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*18.5453); }\nvec3  hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(338.5453123,278.1459123,191.1234)); }\nfloat dot2(in vec2 p ) { return dot(p,p); }\nfloat dot2(in vec3 p ) { return dot(p,p); }\n\nvec2 sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n    return vec2( length(pa-h*ba), h );\n}\nvec2 sdLine( in vec3 p, in vec3 a, in vec3 b )\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n    return vec2( length(pa-h*ba), h );\n}\nvec2 sdLineOri( in vec3 p, in vec3 b )\n{\n    float h = clamp( dot(p,b)\/dot(b,b), 0.0, 1.0 );\n    \n    return vec2( length(p-h*b), h );\n}\nvec2 sdLineOriY( in vec3 p, in float b )\n{\n    float h = clamp( p.y\/b, 0.0, 1.0 );\n    p.y -= b*h;\n    return vec2( length(p), h );\n}\nfloat sdEllipsoid( in vec3 pos, in vec3 cen, in vec3 rad )\n{\n    vec3 p = pos - cen;\n    float k0 = length(p\/rad);\n    float k1 = length(p\/(rad*rad));\n    return k0*(k0-1.0)\/k1;\n}\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25\/k;\n}\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25\/k;\n}\nvec3 rotateX( in vec3 p, float t )\n{\n    float co = cos(t);\n    float si = sin(t);\n    p.yz = mat2(co,-si,si,co)*p.yz;\n    return p;\n}\nvec3 rotateY( in vec3 p, float t )\n{\n    float co = cos(t);\n    float si = sin(t);\n    p.xz = mat2(co,-si,si,co)*p.xz;\n    return p;\n}\nvec3 rotateZ( in vec3 p, float t )\n{\n    float co = cos(t);\n    float si = sin(t);\n    p.xy = mat2(co,-si,si,co)*p.xy;\n    return p;\n}\n\n\/\/==================================================\n\n#define ZERO (min(iFrame,0))\n\n\/\/==================================================\n\nvec3 mapLadyBug( vec3 p )\n{\n    float dBody = sdEllipsoid( p, vec3(0.0), vec3(0.8, 0.75, 1.0) );\n    dBody = smax( dBody, -sdEllipsoid( p, vec3(0.0,-0.1,0.0), vec3(0.75, 0.7, 0.95) ), 0.05 );\n    dBody = smax( dBody, -sdEllipsoid( p, vec3(0.0,0.0,0.8), vec3(0.35, 0.35, 0.5) ), 0.05 );\n  \tdBody = smax( dBody, sdEllipsoid( p, vec3(0.0,1.7,-0.1), vec3(2.0, 2.0, 2.0) ), 0.05 );\n  \tdBody = smax( dBody, -abs(p.x)+0.005, 0.02 + 0.1*clamp(p.z*p.z*p.z*p.z,0.0,1.0) );\n\n    vec3 res = vec3( dBody, MAT_LADY_BODY, 0.0 );\n\n    \/\/ --------\n    vec3 hc = vec3(0.0,0.1,0.8);\n    vec3 ph = rotateX(p-hc,0.5);\n    float dHead = sdEllipsoid( ph, vec3(0.0,0.0,0.0), vec3(0.35, 0.25, 0.3) );\n    dHead = smax( dHead, -sdEllipsoid( ph, vec3(0.0,-0.95,0.0), vec3(1.0) ), 0.03 );\n    dHead = min( dHead, sdEllipsoid( ph, vec3(0.0,0.1,0.3), vec3(0.15,0.08,0.15) ) );\n\n    if( dHead < res.x ) res = vec3( dHead, MAT_LADY_HEAD, 0.0 );\n    \n    res.x += 0.0007*sin(150.0*p.x)*sin(150.0*p.z)*sin(150.0*p.y); \/\/ iqiq\n\n    \/\/ -------------\n    \n    vec3 k1 = vec3(0.42,-0.05,0.92);\n    vec3 k2 = vec3(0.49,-0.2,1.05);\n    float dLegs = 10.0;\n\n    float sx = sign(p.x);\n    p.x = abs(p.x);\n    for( int k=0; k<3; k++ )\n    {   \n        vec3 q = p;\n        q.y -= min(sx,0.0)*0.1;\n        if( k==0) q += vec3( 0.0,0.11,0.0);\n        if( k==1) q += vec3(-0.3,0.1,0.2);\n        if( k==2) q += vec3(-0.3,0.1,0.6);\n        \n        vec2 se = sdLine( q, vec3(0.3,0.1,0.8), k1 );\n        se.x -= 0.015 + 0.15*se.y*se.y*(1.0-se.y);\n        dLegs = min(dLegs,se.x);\n\n        se = sdLine( q, k1, k2 );\n        se.x -= 0.01 + 0.01*se.y;\n        dLegs = min(dLegs,se.x);\n\n        se = sdLine( q, k2, k2 + vec3(0.1,0.0,0.1) );\n        se.x -= 0.02 - 0.01*se.y;\n        dLegs = min(dLegs,se.x);\n    }\n    \n    if( dLegs<res.x ) res = vec3(dLegs,MAT_LADY_LEGS, 0.0);\n\n\n    return res;\n}\n\nvec3 worldToMushrom( in vec3 pos )\n{\n    vec3 qos = pos;\n    qos.xy = (mat2(60,11,-11,60)\/61.0) * qos.xy;\n    qos.y += 0.03*sin(3.0*qos.z - 2.0*sin(3.0*qos.x));\n    qos.y -= 0.4;\n    return qos;\n}\n\nvec3 mapMushroom( in vec3 pos )\n{\n    vec3 res;\n\n    vec3 qos = worldToMushrom(pos);\n\n    {\n        \/\/ head\n        float d1 = sdEllipsoid( qos, vec3(0.0, 1.4,0.0), vec3(0.8,1.0,0.8) );\n\n        \/\/ displacement\n        float f;\n        vec3 tos = qos*0.5;\n        f  = 1.00*(sin( 63.0*tos.x+sin( 23.0*tos.z)));\n        f += 0.50*(sin(113.0*tos.z+sin( 41.0*tos.x)));\n        f += 0.25*(sin(233.0*tos.x+sin(111.0*tos.z)));\n        f = 0.5*(f + f*f*f);\n        d1 -= 0.0005*f - 0.01;\n\n        \/\/ cut the lower half\n        float d2 = sdEllipsoid( qos, vec3(0.0, 0.5,0.0), vec3(1.3,1.2,1.3) );\n        float d = smax( d1, -d2, 0.1 );\n        res = vec3( d, MAT_MUSH_HEAD, 0.0 );\n    }\n\n\n    {\n        \/\/ stem\n        pos.x += 0.3*sin(pos.y) - 0.65;\n        float pa = sin( 20.0*atan(pos.z,pos.x) );\n        vec2 se = sdLine( pos, vec3(0.0,2.0,0.0), vec3(0.0,0.0,0.0) );\n        float tt = 0.25 - 0.1*4.0*se.y*(1.0-se.y);\n        float d3 = se.x - tt;\n        \n        \/\/ skirt\n        vec2 ros = vec2(length(pos.xz),pos.y);\n        se = sdLine( ros, vec2(0.0,1.9), vec2(0.31,1.5) );\n        float d4 = se.x - 0.02;\/\/*(1.0-se.y);\n        d3 = smin( d3, d4, 0.05);\n\n        d3 += 0.003*pa;\n        d3 *= 0.7;\n\n        if( d3<res.x )\n            res = vec3( d3, MAT_MUSH_NECK, 0.0 );\n    }\n\n    return res;\n}\n\nvec3 mapGrass( in vec3 pos, float h )\n{\n    vec3 res = vec3(1e20,0.0,0.0);\n    \n    const float gf = 4.0;\n\n    vec3 qos = pos * gf;\n\n    vec2 n = floor( qos.xz );\n    vec2 f = fract( qos.xz );\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2  g = vec2( float(i), float(j) );\n\n        vec2 ra2 = hash2( n + g + vec2(31.0,57.0) );\n\n        if( ra2.x<0.73 ) continue;\n\n        vec2  o = hash2( n + g );\n        vec2  r = g - f + o;\n        vec2 ra = hash2( n + g + vec2(11.0,37.0) );\n\n        float gh = 2.0*(0.3+0.7*ra.x);\n\n        float rosy = qos.y - h*gf;\n\n        r.xy = reflect( r.xy, normalize(-1.0+2.0*ra) );\n        r.x -= 0.03*rosy*rosy;\n        \n        r.x *= 4.0;\n        float mo = 0.1*sin( 2.0*iTime + 20.0*ra.y )*(0.2+0.8*ra.x);\n        vec2 se = sdLineOri( vec3(r.x,rosy,r.y), vec3(4.0 + mo,gh*gf,mo) );\n        float gr = 0.3*sqrt(1.0-0.99*se.y);\n        float d = se.x - gr;\n        d \/= 4.0;\n\n        d \/= gf;\n        if( d<res.x )\n        {\n            res.x = d;\n            res.y = MAT_GRASS;\n            res.z = r.y;\n        }\n    }\n    \n    return res;\n}\n\nvec3 mapCrapInTheAir( in vec3 pos)\n{\n    ivec2 id = ivec2(floor((pos.xz+2.0)\/4.0));\n    pos.xz = mod(pos.xz+2.0,4.0)-2.0;\n    float dm = 1e10;\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 o = vec3(0.0,3.2,0.0);\n        o += vec3(1.7,1.50,1.7)*(-1.0 + 2.0*hash3(float(i)));\n        o += vec3(0.3,0.15,0.3)*sin(0.3*iTime + vec3(float(i+id.y),float(i+3+id.x),float(i*2+1+2*id.x)));\n        float d = dot2(pos - o);\n        dm = min(d,dm);\n    }\n    dm = sqrt(dm)-0.02;\n    \n    return vec3( dm, MAT_CITA, 0.0);\n}\n\nvec3 mapMoss( in vec3 pos, float h)\n{\n    vec3 res = vec3(1e20,0.0,0.0);\n\n    const float gf = 2.0;\n    \n    vec3 qos = pos * gf;\n    vec2 n = floor( qos.xz );\n    vec2 f = fract( qos.xz );\n\n    for( int k=ZERO; k<2; k++ )\n    {\n        for( int j=-1; j<=1; j++ )\n        for( int i=-1; i<=1; i++ )\n        {\n            vec2  g = vec2( float(i), float(j) );\n            vec2  o = hash2( n + g + vec2(float(k),float(k*5)));\n            vec2  r = g - f + o;\n\n            vec2 ra  = hash2( n + g + vec2(11.0, 37.0) + float(2*k) );\n            vec2 ra2 = hash2( n + g + vec2(41.0,137.0) + float(3*k) );\n\n            float mh = 0.5 + 1.0*ra2.y;\n            vec3 ros = qos - vec3(0.0,h*gf,0.0);\n\n            vec3 rr = vec3(r.x,ros.y,r.y);\n\n            rr.xz = reflect( rr.xz, normalize(-1.0+2.0*ra) );\n\n            rr.xz += 0.5*(-1.0+2.0*ra2);\n            vec2 se  = sdLineOriY( rr, gf*mh );\n            float sey = se.y;\n            float d = se.x - 0.05*(2.0-smoothstep(0.0,0.1,abs(se.y-0.9)));\n\n            vec3 pp = vec3(rr.x,mod(rr.y+0.2*0.0,0.4)-0.2*0.0,rr.z);\n\n            float an = mod( 21.0*floor( (rr.y+0.2*0.0)\/0.4 ), 1.57 );\n            float cc = cos(an);\n            float ss = sin(an);\n            pp.xz = mat2(cc,ss,-ss,cc)*pp.xz;\n\n            pp.xz = abs(pp.xz);\n            vec3 ppp = (pp.z>pp.x) ? pp.zyx : pp; \n            vec2 se2 = sdLineOri( ppp, vec3( 0.4,0.3,0.0) );\n            vec2 se3 = sdLineOri( pp,  vec3( 0.2,0.3,0.2) ); if( se3.x<se2.x ) se2 = se3;\n            float d2 = se2.x - (0.02 + 0.03*se2.y);\n\n            d2 = max( d2, (rr.y-0.83*gf*mh) );\n            d = smin( d, d2, 0.05 );\n\n            d \/= gf;\n            d *= 0.9;\n            if( d<res.x )\n            {\n                res.x = d;\n                res.y = MAT_MOSS;\n                res.z = clamp(length(rr.xz)*4.0+rr.y*0.2,0.0,1.0);\n                float e = clamp((pos.y - h)\/1.0,0.0,1.0);\n                res.z *= 0.02 + 0.98*e*e;\n                \n                if( ra.y>0.85 && abs(se.y-0.95)<0.1 ) res.z = -res.z;\n            }\n        }\n    }\n    \n    return res;\n}\n\nvec3 worldToLadyBug( in vec3 p )\n{\n    \/\/ TODO: combine all of the above in a single 4x4 matrix\n    p = 4.0*(p - vec3(-0.0,3.2-0.6,-0.57));\n    p = rotateY( rotateZ( rotateX( p, -0.92 ), 0.49), 3.5 );\n    p.y += 0.2;\n    return p;\n}\n\nconst vec3 mushroomPos1 = vec3( 0.0,0.1,0.0);\nconst vec3 mushroomPos2 = vec3(-3.0,0.0,3.0);\n\nfloat terrain( in vec2 pos )\n{\n    return 0.3 - 0.3*sin(pos.x*0.5 - sin(pos.y*0.5));\n}\n\nvec3 mapShadow( in vec3 pos )\n{\n    \/\/ terrain\n    float h = terrain( pos.xz );\n    float d = pos.y - h;\n    vec3 res = vec3( d, MAT_GROUND, 0.0 );\n    \n    \/\/ mushrooms\n    {\n      \/\/ intancing\n      vec3 m1 =  pos - mushroomPos1;\n      vec3 m2 = (pos - mushroomPos2).zyx;\n      if( dot2(m2.xz) < dot2(m1.xz) ) m1 = m2;\n    \n      \/\/ bounding volume\n      float bb = sdLine( m1, vec3(0.2,0.0,0.0), vec3(0.36,2.0,0.0) ).x-0.8;\n      if( bb<res.x ) \n      {\n\t  vec3 tmp = mapMushroom(m1);\n      if( tmp.x<res.x ) res = tmp;\n      }\n    }\n    \n    \/\/ ladybug\n    {\n      vec3 q = worldToLadyBug(pos);\n      if( (length(q)-1.5)\/4.0<res.x ) \/\/ bounding volume\n      {\n      vec3 tmp = mapLadyBug(q); tmp.x\/=4.0;\n      if( tmp.x<res.x ) res = tmp;\n      }\n    }\n    \n    \/\/ grass\n    {\n      if( pos.y-2.5<res.x ) \/\/ bounding volume\n      {\n      vec3 tmp = mapGrass(pos,h);\n      if( tmp.x<res.x ) res=tmp;\n      }\n    }\n    \n    \/\/ moss\n    {\n      if( pos.y-1.9<res.x ) \/\/ bounding volume\n      {\n      vec3 tmp = mapMoss(pos,h);\n      if( tmp.x<res.x ) res=tmp;\n      }\n    }\n    \n    return res;\n}\n\nvec3 map( in vec3 pos )\n{\n    vec3 res = mapShadow(pos);\n        \n    vec3 tmp = mapCrapInTheAir(pos);\n    if( tmp.x<res.x ) res=tmp;\n\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n#if 0    \n    vec2 e = vec2(0.002,0.0); \n    return normalize( vec3( map(pos+e.xyy).x - map(pos-e.xyy).x,\n                            map(pos+e.yxy).x - map(pos-e.yxy).x,\n                            map(pos+e.yyx).x - map(pos-e.yyx).x ) );\n#else\n    \/\/ inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+e*0.002).x;\n    }\n    return normalize(n);\n#endif    \n}\n    \nfloat calcShadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.01;\n    for( int i=ZERO; i<100; i++ )\n    {\n        vec3 pos = ro + rd*t;\n        float h = mapShadow( pos ).x;\n        res = min( res, 16.0*max(h,0.0)\/t );\n        if( h<0.0001 || pos.y>3.0 ) break;\n        \n        t += clamp(h,0.01,0.1);\n    }\n    \n    return clamp(res,0.0,1.0);\n}\n\nvec3 raycast( in vec3 ro, in vec3 rd )\n{\n    const float tmax = 12.0;\n    \n\tvec3 res = vec3(1.0,-1.0, 0.0);\n\n    for( int i=ZERO; i<256; i++ )\n    {\n        vec3 h = map( ro + rd*res.x );\n        if( h.x<(0.00015*res.x) || res.x>tmax )\n            break;\n        res.x += h.x;\n        res.y = h.y;\n        res.z = h.z;\n    }\n    \n    if( res.x>=tmax ) res.y = -1.0;\n    \n    return res;\n}\n\nvoid materials( in float matID, in float matID2, in vec3 pos, in vec3 nor,\n                out vec3 matColor, out float matRough,\n                out vec3 matNor, out float matOcc, out float matSSS, out float matRefOcc, out vec3 matGamma )\n{\n    matNor = nor;\n    matOcc = 1.0;\n    matSSS = 0.0;\n    matRough = 1.0;\n    matRefOcc = 1.0;\n    matGamma = vec3(1.0);\n    \n    if( matID<MAT_MUSH_HEAD+0.5 )\n    {\n        vec3 m1 =  pos - mushroomPos1;\n    \tvec3 m2 = (pos - mushroomPos2).zyx;\n    \tif( dot2(m2.xz) < dot2(m1.xz) ) m1 = m2;\n\n        vec3 qos = worldToMushrom( m1 );\n\n        matColor = vec3(0.26,0.21,0.15);\n        matColor -= 0.2*smoothstep(0.4,0.9,texture( iChannel1, 0.8*qos.xz ).x);\n        matColor = mix( vec3(0.35,0.35,0.35 ), matColor, smoothstep(1.5,2.4,qos.y) );\n        matColor = mix( vec3(0.05,0.02,0.01 ), matColor, smoothstep(1.5,1.65,qos.y) );\n        matColor -= 0.2*texture( iChannel1, 0.1*qos.xz ).zyx;\n        matColor *= 0.4*0.45;\n        matColor = max( matColor, 0.0 );\n        \n        matColor += matColor*vec3(0.3,0.6,0.0)*(1.0-smoothstep( 0.8, 1.4, length(m1-vec3(0.5,1.1,-0.3)) ));\n        \n        matRough = 0.6;\n        matSSS = 1.0;\n        matOcc = smoothstep( 0.4,1.5,length(worldToLadyBug( pos ).xz) );\n        matRefOcc = matOcc;\n        matGamma = vec3(0.75,0.87,1.0);\n    }\n    else if( matID<MAT_MUSH_NECK+0.5 )\n    {\n        vec2 uv = vec2( pos.y*0.5, atan(pos.x,pos.z)*(3.0\/3.14159) );\n\n        matColor = vec3(0.42,0.35,0.15);\n        \n        float pa = smoothstep(0.3,0.8,pos.y);\n\n        matColor -= pa*0.2*texture( iChannel1, 0.5*uv ).xxx;\n        matColor = max(vec3(0.0),matColor);\n        \n        matColor *= 0.22;\n        matColor = clamp( matColor, 0.0, 1.0 );\n        \n        matRough = 0.7;\n        matSSS = 1.0;\n        \n        matOcc = clamp( (pos.y-0.5)\/1.3,0.0,1.0);\n        matOcc = matOcc*matOcc;\n        matOcc *= clamp( 1.0-(pos.y-1.2)\/1.2,0.0,1.0);\n        matOcc = matOcc*0.5 + 0.5*matOcc*matOcc;\n        matRefOcc = matOcc;\n        matGamma = vec3(0.75,0.95,1.0);\n    }\n    else if( matID<MAT_LADY_BODY+.5 )\n    {\n        vec3 qos = worldToLadyBug( pos );\n            \n        \/\/ red\n        matColor = vec3(0.16,0.008,0.0);\n\n        float f = texture( iChannel1, 0.1*qos.xz ).x;\n        matColor = mix( matColor, vec3(0.15,0.07,0.0), f*f );\n        \n        qos.x = abs(qos.x);\n        vec2 uv = vec2( atan(qos.x,qos.y), 1.57*qos.z )*0.1;\n\n        \/\/ white\n        float p = length( (qos.xz-vec2(0.0,0.9))*vec2(0.5,1.0));\n        matColor = mix( matColor, vec3(1.0,0.8,0.6)*0.6, 1.0-smoothstep(0.09,0.14,p) );\n\n        \/\/ black\n        p = cos(uv.x*40.0)*cos(uv.y*40.0+1.57);\n        matColor *= 1.0-smoothstep( 0.35, 0.45, p );\n        \n        f = texture( iChannel1, qos.xz*vec2(0.8,0.1) ).x;\n        matColor *= 1.0 - 0.5*f;\n        f = texture( iChannel1, 4.0*qos.xz ).x;\n        matColor *= 1.0 - 0.99*f*f;\n        \n        matColor *= 1.3;\n        matRough = 0.15;\n        matOcc = 0.6 + 0.4*smoothstep( 0.0,0.3,qos.y );\n        matRefOcc = 0.2 + 0.8*smoothstep( 0.0,0.35,qos.y );\n    }\n    else if( matID<MAT_LADY_HEAD+.5 )\n    {\n        vec3 qos = worldToLadyBug( pos );\n\n        matColor = vec3(0.001);\n\n        qos.z += -0.22;\n        qos.y += -0.7;\n        float p = cos(12.0*qos.z)*cos(5.0*qos.y);\n        p += .1*cos(48.0*qos.z)*cos(20.0*qos.y);\n        matColor = mix( matColor, vec3(1.0,0.9,0.8)*0.8, smoothstep(0.8,1.0,p) );\n        matRough = 0.2;\n        matRefOcc = matOcc;\n    }\n    else if( matID<MAT_LADY_LEGS+.5 )\n    {\n        matColor = vec3(0.0,0.0,0.0);\n        matRough = 0.8;\n        matRefOcc = matOcc;\n    }\n    else if( matID<MAT_GRASS+0.5 )\n    {\n    \tmatColor = vec3(0.1,0.15,0.03);\n        \n        float h = terrain( pos.xz );\n        float e = clamp(pos.y-h,0.0,1.0);\n        matOcc = 0.01 + 0.99*e*e;\n        \n        matColor *= 1.0 - 0.3*cos(matID2*23.0);\n        matColor += 0.04*sin(matID2*41.0);\n        \n        matSSS = 0.2;\n        matColor *= 0.75;\n        matRough = 0.5;\n        matOcc *= 0.1+0.9*smoothstep( 0.0, 2.0, length(pos.xz-mushroomPos1.xz-vec2(0.3,0.3)) );\n        matRefOcc = matOcc;\n        matGamma = vec3(0.9,0.9,1.0);\n    }\n    else if( matID<MAT_GROUND+0.5 )\n    {\n        matColor = vec3(0.2,0.2,0.0);\n        matRough = 1.0;\n        matOcc = 0.02;\n        matRefOcc = matOcc;\n    }\n    else if( matID<MAT_MOSS+0.5 )\n    {\n        matColor = (matID2>0.0) ? vec3(0.18,0.15,0.02) : vec3(0.1,0.05,0.005);\n        \n        float f = texture( iChannel1, pos.xy*8.0 ).x;\n        matColor *= 0.55 + f;\n            \n        matOcc = abs(matID2);\n        matOcc *= 0.2+0.8*smoothstep( 0.0, 1.5, length(pos.xz-mushroomPos1.xz-vec2(0.3,0.3)) );\n        matOcc *= 0.2+0.8*smoothstep( 0.0, 1.5, length(pos.xz-mushroomPos2.xz-vec2(0.0,0.0)) );\n        matRough = 0.25;\n        matSSS = 0.5;\n        matRefOcc = matOcc;\n        matGamma = vec3(0.7,0.7,1.0);\n        \n        if( matID2<0.0 ) { matGamma = vec3(0.7,0.9,1.0); matRough = 0.75;}\n    }\n    else \/\/if( matID<MAT_CITA+0.5 )\n    {\n        matColor = vec3(1.0);\n        matSSS = 1.0;\n        matRough = 1.0;\n        matGamma = vec3(0.5);\n    }\n}\n\nvec3 lighting( in float dis, in vec3 rd, in vec3 pos, in vec3 nor,\n               in float occ,\n               in vec3 matColor, in float matRough, in float matSSS, in float matRefOcc,\n               in vec3 matGamma )\n{\n    vec3 col = vec3(0.0);\n\n    float fre = clamp( 1.0+dot(nor,rd), 0.0, 1.0 );\n    float sfre = 0.04 + 0.96*pow( fre, 5.0 );\n    float pn = exp2( 10.0*(1.0-matRough) );\n\n    \/\/ sun light\n    {\n        vec3 sunColor = vec3(7.0,4.0,3.0)*1.4;\n        vec3 sun = normalize(vec3(-0.8,0.35,-0.3));\n        float dif = clamp( dot(sun,nor), 0.0, 1.0 );\n        float sha = 0.0; if( dif>0.001 ) sha = calcShadow( pos, sun );\n        vec3 hal = normalize( sun - rd );\n        float spe = pow( clamp(dot(hal,nor), 0.0, 1.0 ), pn );\n        col += matColor * sunColor * dif * vec3(sha,0.5*sha*(1.0+sha),sha*sha);\n        col += (1.0-matRough)*sunColor * spe * pn * dif * sha * sfre \/ 4.0;\n    }\n\n    \/\/ sky light\n    {\n        vec3 skyColor = vec3(0.3,0.4,0.7)*1.0;\n        float dif = 0.5 + 0.5*nor.y;\n        col += matColor * skyColor * dif * occ;\n        col += skyColor * (1.0-matRough) * smoothstep( 0.0,0.2,reflect(rd,nor).y ) * sfre * 2.5 * matRefOcc;\n    }\n\n    \/\/ bounce light\n    {\n        vec3 bouColor = vec3(0.2,0.4,0.0)*1.2;\n        float dif = clamp(0.5 - 0.5*nor.y,0.0,1.0);\n        col += matColor * bouColor * dif * occ;\n    }\n\n    col += fre*matColor*occ*matSSS;\n    col = pow( max(col,0.0), matGamma );\n\n    return col;\n}\n\nvec3 background(in vec3 d)\n{\n    \/\/ cheap cubemap\n    vec3 n = abs(d);\n    vec2 uv = (n.x>n.y && n.x>n.z) ? d.yz\/d.x: \n              (n.y>n.x && n.y>n.z) ? d.zx\/d.y:\n                                     d.xy\/d.z;\n    return vec3(0.02,0.01,0.00) + vec3(2.5)*pow(texture( iChannel1, 0.1*uv, 1.0 ).yxz,vec3(2.6,4.0,4.2));\n}\n\nmat3 calcCamera( in vec3 ro, in vec3 ta )\n{\n    vec3 w = normalize( ro-ta );\n    vec3 u = normalize( cross( vec3(0.0,1.0,0.0), w ) );\n    vec3 v =          ( cross( w, u ) );\n    \n    return mat3( u, v, w );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy+2.0*fragCoord) \/ iResolution.y;\n    \n    \/\/ camera\n    vec3 ro = vec3(0.0,2.7,-3.0);\n    vec3 ta = vec3(0.0,1.9,0.0);\n    ro.x += 0.3*sin(0.03*iTime);    \n    mat3 camRot = calcCamera( ro, ta );\n    \n    \/\/ ray\n    vec3 rd = normalize( camRot * vec3(p,-2.0) );\n    \n    \/\/ background\n    vec3 col = background(rd);\n \n    \/\/ scene\n    vec3 tm = raycast(ro,rd);\n    float t = tm.x;\n    float matID = tm.y;\n    if( matID>0.5 )\n    {\n        vec3 pos = ro + t*rd;\n    \tvec3 nor = calcNormal( pos ); \n        \n        vec3 matNormal, matColor, matGamma;\n        float matRough, matOcc, matSSS, matRefOcc;\n        \n        materials( matID, tm.z, pos, nor, matColor, matRough, matNormal, matOcc, matSSS, matRefOcc, matGamma );\n        col = lighting( t, rd, pos, matNormal, matOcc, matColor, matRough, matSSS, matRefOcc, matGamma );\n    }\n    else\n    {\n        t = 30.0;\n    }\n    \n\tfragColor = vec4( col, t*dot(rd,normalize(ta-ro)) );\n}",
                "name": "Buffer A",
                "description": "",
                "type": "buffer"
            }
        ]
    },
    {
        "ver": "0.1",
        "info": {
            "id": "4sX3R2",
            "date": "1379564832",
            "viewed": 51775,
            "name": "Monster",
            "username": "iq",
            "description": "Rotating, translating and reflecting a sphere 22 times (and using orbit trapping for coloring). Raymarching and lighting as usual.",
            "likes": 237,
            "published": 3,
            "flags": 0,
            "usePreview": 0,
            "tags": []
        },
        "renderpass": [
            {
                "inputs": [
                    {
                        "id": "XsX3zn",
                        "filepath": "\/media\/a\/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png",
                        "previewfilepath": "\/media\/ap\/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png",
                        "type": "cubemap",
                        "channel": 0,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "clamp",
                            "vflip": "false",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [],
                "code": "\/\/ Copyright Inigo Quilez, 2013 - https:\/\/iquilezles.org\/\n\/\/ I am the sole copyright owner of this Work.\n\/\/ You cannot host, display, distribute or share this Work in any form,\n\/\/ including physical and digital. You cannot use this Work in any\n\/\/ commercial or non-commercial product, website or project. You cannot\n\/\/ sell this Work and you cannot mint an NFTs of it.\n\/\/ I share this Work for educational purposes, and you can link to it,\n\/\/ through an URL, proper attribution and unmodified screenshot, as part\n\/\/ of your educational material. If these conditions are too restrictive\n\/\/ please contact me and we'll definitely work it out.\n\n#define AA 1\n\nvec2 hash2( float n )\n{\n    return fract(sin(vec2(n,n+1.0))*vec2(13.5453123,31.1459123));\n}\n\nvec3 hash3( float n )\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(13.5453123,31.1459123,37.3490423));\n}\n\nvec3 noise( in float x )\n{\n    float p = floor(x);\n    float f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    return mix( hash3(p+0.0), hash3(p+1.0),f);\n}\n\n\nmat4 rotationMat( in vec3 xyz )\n{\n    vec3 si = sin(xyz);\n    vec3 co = cos(xyz);\n\n\treturn mat4( co.y*co.z,                co.y*si.z,               -si.y,       0.0,\n                 si.x*si.y*co.z-co.x*si.z, si.x*si.y*si.z+co.x*co.z, si.x*co.y,  0.0,\n                 co.x*si.y*co.z+si.x*si.z, co.x*si.y*si.z-si.x*co.z, co.x*co.y,  0.0,\n\t\t\t     0.0,                      0.0,                      0.0,        1.0 );\n}\n\nconst float s = 1.1;\n\nmat4 mm;\n\nvec3 map( vec3 p )\n{\n\tfloat k = 1.0;\n\tfloat m = 1e10;\n\tfor( int i=0; i<22; i++ ) \n\t{\n\t\tm = min( m, dot(p,p)\/(k*k) );\n\t\tp = (mm*vec4((abs(p)),1.0)).xyz;\n\t\tk*= s;\n\t}\n\t\n\n\tfloat d = (length(p)-0.25)\/k;\n\t\n\tfloat h = p.z - 0.35*p.x;\n\t\n\treturn vec3( d, m, h );\n}\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n    float t = 0.0;\n    for( int i=0; i<100; i++ )\n\t{\n        vec3 res = map( ro+rd*t );\n        if( res.x<0.0002 ) return vec3(t,res.yz);\n        t += res.x;\n\t\tif( t>9.0 ) break;\n    }\n\n    return vec3( -1.0 );\n}\n\nvec3 calcNormal( in vec3 pos, float e )\n{\n    vec3 eps = vec3(e,0.0,0.0);\n\n\treturn normalize( vec3(\n           map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n           map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<32; i++ )\n    {\n        float h = map(ro + rd*t).x;\n\t\th = max( h, 0.0 );\n        res = min( res, k*h\/t );\n        t += clamp( h, 0.001, 0.1 );\n\t\tif( res<0.01 || t>6.0 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat totao = 0.0;\n    for( int aoi=0; aoi<16; aoi++ )\n    {\n\t\tvec3 aopos = -1.0+2.0*hash3(float(aoi)*213.47);\n\t\taopos *= sign( dot(aopos,nor) );\n\t\taopos = pos + nor*0.01 + aopos*0.04;\n        float dd = clamp( map( aopos ).x*4.0, 0.0, 1.0 );\n        totao += dd;\n    }\n\ttotao \/= 16.0;\n\t\n    return clamp( totao*totao*50.0, 0.0, 1.0 );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ animation\t\n    float rtime = iTime;\n\n    float time = rtime;\n    time += 15.0*smoothstep(  15.0, 25.0, rtime );\n    time += 20.0*smoothstep(  65.0, 80.0, rtime );\n    time += 35.0*smoothstep( 105.0, 135.0, rtime );\n    time += 20.0*smoothstep( 165.0, 180.0, rtime );\n    time += 40.0*smoothstep( 220.0, 290.0, rtime );\n    time +=  5.0*smoothstep( 320.0, 330.0, rtime );\n    float time1 = (time-10.0)*1.5 - 167.0;\n    float time2 = time;\n\n    mm = rotationMat( vec3(0.4,0.1,3.4) + \n                     0.15*sin(0.1*vec3(0.40,0.30,0.61)*time1) + \n                     0.15*sin(0.1*vec3(0.11,0.53,0.48)*time1));\n    mm[0].xyz *= s;\t\n    mm[1].xyz *= s;\n    mm[2].xyz *= s;\t\n    mm[3].xyz = vec3( 0.15, 0.05, -0.07 ) + 0.05*sin(vec3(0.0,1.0,2.0) + 0.2*vec3(0.31,0.24,0.42)*time1);\n\n\n    \/\/ camera\n    vec2 m = vec2(0.5);\n    if( iMouse.z>0.0 ) m = iMouse.xy\/iResolution.xy;\n    float an = 1.0 + 0.1*time2 - 6.2*m.x;\n    float cr = 0.15*sin(0.2*time2);\n    vec3 ro = (2.4 + 0.6*smoothstep(10.0,20.0,time2))*vec3(sin(an),0.25,cos(an));\n    vec3 ta = vec3( 0.0, 0.0 + 0.13*cos(0.3*time2), 0.0 );\n    ta += 0.05*noise(  0.0 + 1.0*time );\n    ro += 0.05*noise( 11.3 + 1.0*time );\n    \/\/ camera-to-world transformation    \n    mat3 ca = setCamera( ro, ta, cr );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 of = -0.5 + vec2(float(m),float(n))\/float(AA);\n        vec2 q = (fragCoord + of) \/ iResolution.xy;\n#else\n        vec2 q = fragCoord\/ iResolution.xy;\n#endif        \n        vec2 p = -1.0 + 2.0 * q;\n        p.x *= iResolution.x\/iResolution.y;\n\n        \/\/ ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,3.0) );\n\n        \/\/ raymarch\n        vec3 tmat = intersect(ro,rd);\n\n        \/\/ shade\n        vec3 col = vec3(0.0);\n        if( tmat.z>-0.5 )\n        {\n            \/\/ geometry\n            vec3 pos = ro + tmat.x*rd;\n            vec3 nor = calcNormal(pos, 0.005);\n            vec3 sor = calcNormal(pos, 0.010);\n\n            \/\/ material\n            vec3 mate = vec3(1.0);\n            mate = mix( vec3(0.5,0.5,0.2), vec3(0.5,0.3,0.0), 0.5 + 0.5*sin(4.0+8000.0*tmat.y)  );\n            mate = mix( vec3(1.0,0.9,0.8), mate, 0.5 + 0.5*sin(4.0+20.0*tmat.z) );\n            mate.x *= 1.15;\n\n            \/\/ lighting\n            float occ = 1.1*calcAO( pos, nor );\n            occ *= 0.75 + 0.25*clamp(tmat.y*400.0,0.0,1.0);\n\n            \/\/ diffuse\n            col = vec3(0.0);\n            for( int i=0; i<32; i++ )\n            {\n                \/\/vec3 rr = normalize(-1.0 + 2.0*texture( iChannel2, vec2((0.5+float(i)),0.5)\/256.0,-100.0).xyz);\n                vec3 rr = normalize(-1.0 + 2.0*hash3(float(i)*123.5463));\n                rr = normalize( nor + 7.0*rr );\n                rr = rr * sign(dot(nor,rr));\t\t\t\t\t\t\t  \n                float ds = occ;\/\/softshadow( pos, rr, 0.01, 32.0 );\n                col += pow( texture( iChannel0, rr ).xyz, vec3(2.2) ) * dot(rr,nor) * ds;\n            }\n            col \/= 32.0;\t\t\t\t\t\t\t\t\t\t\n\n            col *= 1.8;\n\n            \/\/ subsurface\t\t\n            col *= 1.0 + 1.0*vec3(1.0,0.6,0.1)*pow(clamp(1.0+dot(rd,sor),0.0,1.0),2.0)*vec3(1.0);\n\n            \/\/ specular\t\t\n            float fre = pow( clamp(1.0+dot(rd,nor),0.0,1.0), 5.0 );\n            vec3 ref = reflect( rd, nor );\n            float rs = softshadow( pos, ref, 0.01, 32.0 );\n            col += 1.8 * (0.04 + 12.0*fre) * occ * pow( texture( iChannel0, ref ).xyz, vec3(2.0) ) * rs;\n\n            col *= mate;\n        }\n        else\n        {\n            \/\/ background\t\t\n            col = pow( texture( iChannel0, rd ).xyz, vec3(2.2) );\n        }\n        tot += col;\n#if AA>1\n    }\n    tot \/= float(AA*AA);\n#endif\n    \n\t\/\/ gamma\n\ttot = pow( clamp( tot*1.5, 0.0, 1.0 ), vec3(0.45) );\n\n\t\/\/ vigneting\n    {\n        vec2 q = fragCoord\/ iResolution.xy;\n\t    tot *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n    }\n\t\n    fragColor = vec4( tot, 1.0 );\n}\n",
                "name": "Image",
                "description": "",
                "type": "image"
            }
        ]
    }
]