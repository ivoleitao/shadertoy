<!DOCTYPE HTML>
<html lang="en">
<head>
    
<title>ingagard - Shadertoy BETA</title>
<meta charset="utf-8" />
<meta name="Keywords" content="shadertoy, shader toy, quilez, inigo, jeremias, pol, fractals, demoscene, computer graphics, mathematics, rendering, demo, 3D, realtime, shader, raytracing, raymarching, webgl, glsl" />
<meta name="Description" content="Build shaders, share them, and learn from the best community." />
<meta name="Author" content="Beautypi" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<link rel="image_src" href="https://www.shadertoy.com/img/logo.png" />
<link rel="apple-touch-icon" href="/img/launch_icon_57.png"/>
<link rel="apple-touch-icon" sizes="72x72" href="/img/launch_icon_72.png"/>
<link rel="apple-touch-icon" sizes="114x114" href="/img/launch_icon_114.png"/>
<link rel="shortcut icon" href="/img/favicon.ico"/>

<style>::-webkit-scrollbar {
    height: 8px;
    width: 8px;
    background: #404040;
}

::-webkit-scrollbar-thumb
{
    background: #909090;
    border-radius: 0ex;
}

::-webkit-scrollbar-corner
{
    background: #000;
}

::-webkit-input-placeholder
{
	font-style:italic;
}
input:-moz-placeholder, textarea:-moz-placeholder
{
	font-style:italic;
}
input.placeholder-text, textarea.placeholder-text
{
	font-style:italic;
}

pre 
{
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
    white-space: -pre-wrap;
    white-space: -o-pre-wrap;
    word-wrap: break-word;
}

@font-face
{
    font-family: Lobster;
    src: url("/img/lobster.otf") format("opentype");
}

div#centerScreen
{
    left: 50%;
    top: 50%;
    position: absolute;
}

a.headerLinks:hover
{
    background-color:#505050;
    color : #ff8020;
}

body
{
    color: #000000;
    font-size:12px;
    font-style:normal;
    font-family:Tahoma,Arial;
    background-repeat: no-repeat;
    //background-attachment: fixed;
    padding:0px;
    margin:0px;
    text-align: left;
    background-color: #d0d0d0;
    background-repeat: repeat;
    user-select: text;
}

a,
a:hover,
a:visited
{
  color : inherit;
}

div#content {
    width: 95%;
    overflow: hidden;
    margin: auto;
    padding: 0px;
    min-height: calc(100vh - 80px);
    //box-sizing: border-box;
}


.notificationCount
{
 background-color:#ff0000;
 padding-left:3px;
 padding-right:1px;
 padding-top:1px;
 padding-bottom:1px;
}

div#header
{
    background-color: #404040;
    top: 0px;
    left: 0px;
    width: 100%;
    padding: 0;
    margin: 0;
    color: #ffffff;
    display: flex;
    flex-direction:row;
}

#headerBlock1
{
    width: 50%;
    display:flex;
    align-items:center;
}

a#headerTitle
{
    font-size: 2.25em;
    font-family: Lobster,Tahoma,Arial;
    text-decoration: none;
    padding-left:32px;
    padding-right:32px;
}

#headerSearch
{
    display: inline-block;
    color: #000000;
    width: 300px;
}

input[type=search]#mySearch
{
    width: 100%;
    border-radius: 6px;
    border: 1px solid black;
    padding:12px;
}

#headerBlock2
{
    width: 50%;
    margin-left: auto;
    display: flex;
    justify-content: flex-end;
}


a#headerTitle:hover
{
    color : #ff8020;
}

a.headerLinks
{
    font-weight: bold;
    padding-top: 14px;
    padding-bottom: 14px;
    padding-left: 14px;
    padding-right: 14px;
    margin:0px;
    text-decoration: none;
    transition: background-color 0.15s linear, color 0.15s linear;
}

#footer
{
    background-color: rgba(64,64,64,0.25);
    color: #000000;
    padding: 0px;
    margin: 0px;
    width: 100%;
    display: flex;
    justify-content: space-between;
    flex-wrap: wrap;
}

#footer div
{
    padding-top:10px;
    padding-bottom:0px;
    padding-left:16px;
    padding-right:16px;
}

#footer div ul
{
    margin-left:0px;
    padding-left:16px;
}

#footer div ul li
{
    padding-top:6px;
}

a.regular
{
    font-weight:bold;
    text-decoration:none
}

a.regular:hover
{
  color : #ff8020;
}

a.user
{
    font-weight:bold;
    text-decoration:none;
}

a.user:hover
{
  color : #ff8020;
  text-decoration: underline;
}

.uiButton
{
    border: none;
    outline: none;
    margin: 0px;
    padding: 0px;
    width: 22px;
    height: 22px;
    position: absolute;
    cursor: pointer;
    border-radius: 4px;
}

.uiButton:hover
{
    box-shadow: inset 0px 0px 1px 1px #808080, 0px 0px 1px 1px #808080;
}

.uiDivBUtton
{
    cursor:pointer;
}

.uiDivBUtton:hover
{
    color: #ffffff;
}


.dialog
{
    display: block;
    background-color: #e0e0e0;
    color: #000000;
    border:1px solid #000;
    padding:0px;
    margin:0px;
    text-align:left;
    border-radius: 4px;
    box-shadow:4px 4px 6px 0px rgba(0,0,0,0.5);
    overflow: hidden;
    z-index:1000;
    visibility: hidden;
    opacity:0;
    -moz-transition: opacity 0.25s linear,visibility 0.25s linear;
    -webkit-transition: opacity 0.25s linear,visibility 0.25s linear;
    transition: opacity 0.25s linear,visibility 0.25s linear;
}

.dialogHeader
{
    left:0px;
    top: 0px;
    width:100%;
    height:32px;
    position: absolute;
    background-color: #808080;
    cursor:move;
}

.dialogTitle
{
    left: 12px;
    top: 4px;
    position: absolute;
    padding: 0px;
    margin: 0px;
    color:#000000;
    font-size:1.5em;
    text-align: left;
    user-select: none;
    -moz-user-select: -moz-none;
    -webkit-user-select: none;
}

.dialogOverlay
{
    z-index:1000;

    visibility: hidden;
    opacity:0;
    -moz-transition: opacity 0.25s linear,visibility 0.25s linear;
    -webkit-transition: opacity 0.25s linear,visibility 0.25s linear;
    transition: opacity 0.25s linear,visibility 0.25s linear;

    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    width:100%;
    height:100%;
    position:absolute;

    background-color:rgba(0,0,0,.4);
}

.viewsIcon, .likesIcon
{
    border: none;
    outline: none;
    display:inline-block;
    background-repeat:no-repeat;
    top:0px;
    left:0px;
    padding:0px;
    padding-right: 2px;
    margin:0px;
    position:relative;
}

.userPictureSmall
{
    background-color:#808080;
    border: 1px solid #000000;
    width:32px;
    height:32px;
}

.dialogCloseButton
{
    right:8px;
    top: 4px;
    width:22px;
    height:22px;
    position: absolute;
    background-image: url("/img/close.png");
    cursor: pointer;
    border-radius: 4px;
}

.dialogCloseButton:hover
{
    box-shadow: inset 0px 0px 4px 2px #ffffff, 0px 0px 4px 2px #ffffff;
}

.dialogContentButtons
{
     padding:0;
     border:0;
     text-align: justify;
     left: 24px;
     bottom:40px;
     position:absolute;
}

.dialogButton
{
    text-align: center;
    vertical-align: middle;
    display: inline-block;
    border-radius: 4px;
    font-weight: bold;
    cursor: pointer;
    padding-bottom:5px;
    padding-top:4px;
    padding-left: 8px;
    padding-right: 8px;
    margin-left:4px;
    margin-right:4px;
    text-decoration: none;
    color:#000000;
    width: 80px;
    -moz-transition:    background-color 0.15s linear, color 0.15s linear;
    -webkit-transition: background-color 0.15s linear, color 0.15s linear;
    transition:         background-color 0.15s linear, color 0.15s linear;
}

.dialogButton:hover
{
  background-color:#808080;
  color : #ff8020;
}

.dialogCloseButton:hover
{
    box-shadow: inset 0px 0px 4px 2px #ffffff, 0px 0px 4px 2px #ffffff;
}

.dialogContent
{
    color: inherit;
    overflow: auto;
    width:100%;
    height:100%;
    left: 0px;
    top: 32px;
    position:absolute
}

.dialogContentBody
{
    color: inherit;
    width:100%;
    height:auto;
    padding-top:24px;
    padding-bottom:24px;
    padding-left:24px;
    padding-right:24px;
    text-align: left;
}

.formButton
{
    font-weight:bold;
	color:#ffffff;
	border:none;
    text-align:center;
	background-color:#808080;
    border-radius: 4px;
	padding-left:8px;
	padding-right:8px;
	padding-top:4px;
	padding-bottom:4px;
    cursor:pointer;
    min-width:80px;
    box-sizing: border-box;
}
.formInput {
    border-radius: 6px;
    border: 1px solid black;
    padding: 4px;
    border: none;
}
.formButton:hover {
    background-color: #e0e0e0;
}
.formButton:disabled
{
	color:#b0b0b0;
	background-color:#808080;
}

.formButtonSmall
{
    color:#ffffff;
    border:none;
    text-align:center;
    background-color:#808080;
    border-radius: 4px;
    padding-left:2px;
    padding-right:2px;
    padding-top:2px;
    padding-bottom:2px;
    cursor:pointer;
    min-width:40px;
}

.formButtonSmall:hover
{
    background-color: #e0e0e0;
}

.formButtonSmall:disabled
{
    color:#b0b0b0;
    background-color:#808080;
}

.formButtonSmall.disabled2,
.formButton.disabled2 { color:#b0b0b0; background-color:#808080; pointer-events: none; }

.inputForm
{
    padding-left:2%;
    padding-right:2%;
    resize: none;
    text-align: left;
    background-color:#e0e0e0;
    outline: none;
    border-radius: 4px;
    border: 1px solid #808080;
    color:inherit;
    box-sizing: border-box;
}

.inputForm:focus
{
    border: 1px solid #AFCDD8;
    background-color: #EBF2F4;
}

.transparentPannel
{
    background-color:rgba(64,64,64,0.1);
    padding:16px;
}

.comment, .commentSelf, .commentNew
{
    border-radius: 4px;
    width: 100%;
    margin-left: 0px;
    margin-right: 0px;
    margin-top: 0px;
    margin-bottom: 6px;

    padding: 14px;
    box-sizing: border-box;
    display: grid;
    grid-template-columns: 32px auto 8px;
    grid-template-rows: 1fr;
    grid-gap:8px;
}

.comment:nth-child(even)
{
    background-color: rgba(64,64,64,0.1);
}

.comment:nth-child(odd)
{
    background-color: rgba(128,128,128,0.1);
}

.commentSelf
{
    background-color: rgba(240,160,64,0.1);
}

.commentNew
{
    padding-right: 0px;
    grid-template-columns: 40px auto;
}

.commentContent
{
    vertical-align: top;
    text-align: left;
    word-break: break-all;
    word-break: break-word;
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
}


/* ----------------------- media resolutions ------------------------ */

@media screen and (max-width:799px)
{
    div#header {flex-direction:column; }
    #headerBlock1 { width:100%; }
    #headerBlock2 { width:100%; justify-content: space-around;}
    div#headerSearch {width:200px;}
    input#mySearch { width:200px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .previewText { width:130px; }
    .transparentPannel { padding:10px; }
}

@media screen and (min-width:800px) and (max-width:1279px)
{
    body { font-size: 9px; }
    div#headerSearch {width: 250px;}
    input#mySearch { width:250px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .previewText { width:130px; }
    .transparentPannel { padding:11px; }
}

@media screen and (min-width:1280px) and (max-width:1439px)
{
    body { font-size: 10px; }
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:28px; }
    .previewText { width:180px; }
    .transparentPannel { padding:12px; }
}

@media screen and (min-width:1440px) and (max-width:1919px)
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:28px; }
    .previewText { width:180px; }
    .transparentPannel { padding:12px; }
}

@media screen and (min-width:1920px) and (max-width:2559px)
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:32px; }
    .previewText { width:220px; }
    .transparentPannel { padding:16px; }
}

@media screen and (min-width:2560px) 
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:32px; }
    .previewText { width:220px; }
    .transparentPannel { padding:16px; }
}
body
{
    background-image: url("/img/themes/classic/background.jpg");
}
</style>


    <script>"use strict"

//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piCamera
//
//==============================================================================

function piCamera()
{
    var mMatrix = setIdentity();
    var mMatrixInv = setIdentity();

    var mPosition = [0.0,0.0,0.0];
    var mXRotation = 0.0;
    var mYRotation = 0.0;

    var mPositionTarget = [0.0,0.0,0.0];
    var mXRotationTarget = 0.0;
    var mYRotationTarget = 0.0;

    var me = {};
/*
    me.Set = function( pos, dir, roll) 
             {
                 mMatrix    = setLookat( pos, add(pos,dir), [Math.sin(roll),Math.cos(roll),Math.sin(roll)] );
                 mMatrixInv = invertFast( mMatrix );
             };
*/
    me.SetPos = function(pos)
                {
                    mPosition = pos;
                    //mMatrix[ 3] = -(mMatrix[0] * pos[0] + mMatrix[1] * pos[1] + mMatrix[ 2] * pos[2]);
                    //mMatrix[ 7] = -(mMatrix[4] * pos[0] + mMatrix[5] * pos[1] + mMatrix[ 6] * pos[2]);
                    //mMatrix[11] = -(mMatrix[8] * pos[0] + mMatrix[9] * pos[1] + mMatrix[10] * pos[2]);
                };
/*
    me.GlobalMove = function(pos)
                    {
                        mMatrix[ 3] -= (mMatrix[0] * pos[0] + mMatrix[1] * pos[1] + mMatrix[ 2] * pos[2]);
                        mMatrix[ 7] -= (mMatrix[4] * pos[0] + mMatrix[5] * pos[1] + mMatrix[ 6] * pos[2]);
                        mMatrix[11] -= (mMatrix[8] * pos[0] + mMatrix[9] * pos[1] + mMatrix[10] * pos[2]);
                        mMatrixInv = invertFast(mMatrix);
                    };
*/
    me.LocalMove = function( dis )
                    {
                        dis = matMulvec( setRotationY(-mYRotation), dis);
                        mPositionTarget = sub(mPositionTarget,dis)
                    };

    me.RotateXY = function( x, y)
                  {
                    mXRotationTarget -= x;
                    mYRotationTarget -= y;
                    mXRotationTarget = Math.min( Math.max( mXRotationTarget, -Math.PI/2), Math.PI/2 );
                  };


    me.CameraExectue = function( dt )
    {
        // smooth position
        mXRotation += (mXRotationTarget-mXRotation) * 12.0*dt;
        mYRotation += (mYRotationTarget-mYRotation) * 12.0*dt;
        mPosition = add(mPosition, mul( sub(mPositionTarget, mPosition), 12.0*dt));

        // Make Camera matrix
        mMatrix = matMul( matMul(setRotationX(mXRotation), 
                                 setRotationY(mYRotation)),  
                                 setTranslation(mPosition));
        mMatrixInv = invertFast(mMatrix);

    }

    me.GetMatrix = function() { return mMatrix; };
    me.GetMatrixInverse = function() { return mMatrixInv; };
    me.SetMatrix = function( mat ) 
                    {
                        mMatrix = mat;
                        mMatrixInv = invertFast(mMatrix);

                        mPosition = getXYZ(matMulpoint(mat, [0.0,0.0,0.0]));
                        mPositionTarget = mPosition;
                    };

    me.GetPos = function() { return getXYZ(matMulpoint(mMatrixInv, [0.0,0.0,0.0])); }
    me.GetDir = function() { return getXYZ(normalize(matMulvec(mMatrixInv, [0.0,0.0,-1.0]))); }

    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piFile
//
//==============================================================================

function piFile( binaryDataArrayBuffer )
{
    // private
    //var mDataView = new DataView( binaryDataArrayBuffer, 0 );
    var mDataView = binaryDataArrayBuffer;
    var mOffset = 0;

    // public members
    var me = {};
    me.mDummy = 0;
/*
    // public functions
    me.Seek = function( off ) { mOffset = off - 3; };
    me.ReadUInt16 = function()  { var res = mDataView.getUint16( mOffset ); mOffset+=2; return res; };
    me.ReadUInt32 = function()  { var res = mDataView.getUint32( mOffset ); mOffset+=4; return res; };
    me.ReadUInt64 = function()  { return me.ReadUInt32() + (me.ReadUInt32()<<32); };
    me.ReadFloat32 = function() { var res = mDataView.getFloat32( mOffset ); mOffset+=4; return res; };
*/

    me.Seek = function( off ) { mOffset = off; };
    me.ReadUInt8  = function()  { var res = (new Uint8Array(mDataView,mOffset))[0]; mOffset+=1; return res; };
    me.ReadUInt16 = function()  { var res = (new Uint16Array(mDataView,mOffset))[0]; mOffset+=2; return res; };
    me.ReadUInt32 = function()  { var res = (new Uint32Array(mDataView,mOffset))[0]; mOffset+=4; return res; };
    me.ReadUInt64 = function()  { return me.ReadUInt32() + (me.ReadUInt32()<<32); };
    me.ReadFloat32 = function() { var res = (new Float32Array(mDataView,mOffset))[0]; mOffset+=4; return res; };
    me.ReadFloat32Array = function(n) 
                          { 
                              var src = new Float32Array(mDataView, mOffset);
                              var res = [];  for( var i=0; i<n; i++ ) { res[i] = src[i]; }
                              mOffset += 4*n;
                              return res;
                          };
    me.ReadFloat32ArrayNative = function(n) { var src = new Float32Array(mDataView, mOffset); mOffset += 4*n; return src; };
    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piMesh
//
//==============================================================================

function piMesh()
{
    this.mChunks = [];
    this.mPrimitiveType = 0;
    this.mVertexFormat = null;
}

/*
piMesh.prototype.normalize = function( ppos, npos )
{
    var numv = this.mVertexData.length;
    var numt = this.mIndices.length;

    for( var i=0; i<numv; i++ )
    {
        //float *v = (float*)piMesh_GetVertexData( me, i, npos );
        //v[0] = 0.0f;
        //v[1] = 0.0f;
        //v[2] = 0.0f;
        this.mVerts[8 * i + 3] = 0.0;
        this.mVerts[8 * i + 4] = 0.0;
        this.mVerts[8 * i + 5] = 0.0;
    }

    for( var i=0; i<numt; i++ )
    {
        piMeshFace *face = me->mFaceData.mIndexArray[0].mBuffer + i;

        const int ft = face->mNum;
        
        vec3 nor = vec3( 0.0f, 0.0f, 0.0f );
        for( int j=0; j<ft; j++ )
        {
            const vec3 va = *((vec3*)piMesh_GetVertexData( me, face->mIndex[ j      ], ppos ));
            const vec3 vb = *((vec3*)piMesh_GetVertexData( me, face->mIndex[(j+1)%ft], ppos ));

            nor += cross( va, vb );
        }

        for( int j=0; j<ft; j++ )
        {
            vec3 *n = (vec3*)piMesh_GetVertexData( me, face->mIndex[j], npos );
            n->x += nor.x;
            n->y += nor.y;
            n->z += nor.z;
        }
    }

    for( var i=0; i<numv; i++ )
    {
        vec3 *v = (vec3*)piMesh_GetVertexData( me, i, npos );
        *v = normalize( *v );
    }
}
*/

piMesh.prototype.createCube = function(renderer)
{
    this.mPrimitiveType = 0;

    this.mChunks[0] = { mVerts : new Float32Array([ -1.0, -1.0, -1.0,
                                       1.0, -1.0, -1.0,
                                      -1.0,  1.0, -1.0,
                                       1.0,  1.0, -1.0,
                                      -1.0, -1.0,  1.0,
                                       1.0, -1.0,  1.0,
                                      -1.0,  1.0,  1.0,
                                       1.0,  1.0,  1.0 ]),

                        mIndices : new Uint16Array([ 0, 2, 1,   1, 2, 3,   5, 1, 3,   5, 3, 7,   4, 5, 7,   4, 7, 6,   4, 6, 2,   4, 2, 0,   6, 7, 3,   6, 3, 2,   4, 0, 1,   4, 1, 5 ]),
                        mNumVertices : 8,
                        mNumFaces : 12, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };

    this.mVertexFormat = { mStride:12, mChannels:[ { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false } ] };

    return true;
}

piMesh.prototype.createCubeSharp = function (renderer)
{
    this.mPrimitiveType = 0;

    this.mChunks[0] = { mVerts : new Float32Array([-1.0, 1.0,-1.0,   0.0, 1.0, 0.0,   0.0, 0.0,
                                    -1.0, 1.0, 1.0,   0.0, 1.0, 0.0,   0.0, 1.0,
                                     1.0, 1.0, 1.0,   0.0, 1.0, 0.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   0.0, 1.0, 0.0,   1.0, 0.0,

                                    -1.0,-1.0, 1.0,   0.0, 0.0, 1.0,   0.0, 0.0,
                                     1.0,-1.0, 1.0,   0.0, 0.0, 1.0,   0.0, 1.0,
                                     1.0, 1.0, 1.0,   0.0, 0.0, 1.0,   1.0, 1.0,
                                    -1.0, 1.0, 1.0,   0.0, 0.0, 1.0,   1.0, 0.0,

                                     1.0, 1.0, 1.0,   1.0, 0.0, 0.0,   0.0, 0.0,
                                     1.0,-1.0, 1.0,   1.0, 0.0, 0.0,   0.0, 1.0,
                                     1.0,-1.0,-1.0,   1.0, 0.0, 0.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   1.0, 0.0, 0.0,   1.0, 0.0,

                                     1.0,-1.0,-1.0,   0.0, 0.0,-1.0,   0.0, 0.0,
                                    -1.0,-1.0,-1.0,   0.0, 0.0,-1.0,   0.0, 1.0,
                                    -1.0, 1.0,-1.0,   0.0, 0.0,-1.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   0.0, 0.0,-1.0,   1.0, 0.0,

                                    -1.0,-1.0, 1.0,   0.0,-1.0, 0.0,   0.0, 0.0,
                                    -1.0,-1.0,-1.0,   0.0,-1.0, 0.0,   0.0, 1.0,
                                     1.0,-1.0,-1.0,   0.0,-1.0, 0.0,   1.0, 1.0,
                                     1.0,-1.0, 1.0,   0.0,-1.0, 0.0,   1.0, 0.0,

                                    -1.0, 1.0, 1.0,  -1.0, 0.0, 0.0,   0.0, 0.0,
                                    -1.0, 1.0,-1.0,  -1.0, 0.0, 0.0,   0.0, 1.0,
                                    -1.0,-1.0,-1.0,  -1.0, 0.0, 0.0,   1.0, 1.0,
                                    -1.0,-1.0, 1.0,  -1.0, 0.0, 0.0,   1.0, 0.0 ]),

                        mIndices : new Uint16Array([0,1,2, 0,2,3,   4,5,6, 4,6,7,    8,9,10,8,10,11,   12,13,14,12,14,15,   16,17,18,16,18,19,   20,21,22,20,22,23]),
                        mNumVertices : 24,
                        mNumFaces : 12, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };


    this.mVertexFormat = { mStride:32, mChannels:[ { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false },
                                                   { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false },
                                                   { mNumComponents:2, mType: renderer.TYPE.FLOAT32, mNormalize: false } ] };

    return true;
}


piMesh.prototype.createUnitQuad = function (renderer)
{
    this.mPrimitiveType = 0;
    this.mVertexFormat = { mStride:8, mChannels: [ {mNumComponents:2, mType: renderer.TYPE.FLOAT32, mNormalize: false} ] };

    this.mChunks[0] = { mVerts : new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0,  1.0, 1.0,  1.0]),
                        mIndices : new Uint16Array([0, 2, 1, 1, 2, 3]),
                        mNumVertices : 4,
                        mNumFaces : 2, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };
 
    return true;
}




piMesh.prototype.destroy = function()
{
    //delete this.mVerts;   this.mVerts = null;
    //delete this.mIndices; this.mIndices = null;
}

piMesh.prototype.scale = function (x, y, z)
{
    var stride = this.mVertexFormat.mStride/4;
    for( var j=0; j<this.mChunks.length; j++ )
    {
        var nv = this.mChunks[j].mNumVertices;
        for (var i = 0; i < nv; i++) 
        {
            this.mChunks[j].mVerts[stride * i + 0] *= x;
            this.mChunks[j].mVerts[stride * i + 1] *= y;
            this.mChunks[j].mVerts[stride * i + 2] *= z;
        }
    }
}

piMesh.prototype.translate = function (x, y, z) 
{
    var stride = this.mVertexFormat.mStride/4;
    for( var j=0; j<this.mChunks.length; j++ )
    {
        var nv = this.mChunks[j].mNumVertices;
        for (var i = 0; i < nv; i++) 
        {
            this.mChunks[j].mVerts[stride * i + 0] += x;
            this.mChunks[j].mVerts[stride * i + 1] += y;
            this.mChunks[j].mVerts[stride * i + 2] += z;
        }
    }
}

piMesh.prototype.GPULoad = function (renderer)
{
    for( var i=0; i<this.mChunks.length; i++ )
    {
        var vbo = renderer.CreateVertexArray(this.mChunks[i].mVerts, renderer.BUFTYPE.STATIC );
        if (vbo == null)
            return false;

        var ibo = renderer.CreateIndexArray(this.mChunks[i].mIndices, renderer.BUFTYPE.STATIC);
        if (ibo == null)
            return false;

        this.mChunks[i].mVBO = vbo;
        this.mChunks[i].mIBO = ibo;
    }
    return true;
}

piMesh.prototype.GPURender = function (renderer, positions )//, matPrj, matCam )
{
    //renderer.SetShaderConstantMat4F("unMPrj", matPrj, false );

    var num = this.mChunks.length;
    for( var i=0; i<num; i++ )
    {
        //var mat =  matMul( matCam, this.mChunks[i].mTransform );
        //renderer.SetShaderConstantMat4F("unMMod", mat, false);

        renderer.AttachVertexArray(this.mChunks[i].mVBO, this.mVertexFormat, positions );
        renderer.AttachIndexArray(this.mChunks[i].mIBO );
        renderer.DrawPrimitive(renderer.PRIMTYPE.TRIANGLES, this.mChunks[i].mNumFaces * 3, true, 1);
        renderer.DetachIndexArray(this.mChunks[i].mIBO);
        renderer.DetachVertexArray(this.mChunks[i].mVBO, this.mVertexFormat );
    }
}
//==============================================================================
//
// piLibs 2014-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piRenderer
//
//==============================================================================

function piRenderer()
{
    // private members

    var mGL = null;
    var mBindedShader = null;
    var mIs20 = false;
    var mFloat32Textures;
    var mFloat32Filter;
    var mFloat16Textures;
    var mDrawBuffers;
    var mDepthTextures;
    var mDerivatives;
    var mFloat16Filter;
    var mShaderTextureLOD;
    var mAnisotropic;
    var mRenderToFloat32F;
    var mDebugShader;
    var mAsynchCompile;

    var mVBO_Quad = null;
    var mVBO_Tri = null;
    var mVBO_CubePosNor = null;
    var mVBO_CubePos = null;
    var mShaderHeader = ["",""];
    var mShaderHeaderLines = [0,0];

    // public members
    var me = {};

    me.CLEAR      = { Color: 1, Zbuffer : 2, Stencil : 4 };
    me.TEXFMT     = { C4I8 : 0, C1I8 : 1, C1F16 : 2, C4F16 : 3, C1F32 : 4, C4F32 : 5, Z16 : 6, Z24 : 7, Z32 : 8, C3F32:9 };
    me.TEXWRP     = { CLAMP : 0, REPEAT : 1 };
    me.BUFTYPE    = { STATIC : 0, DYNAMIC : 1 };
    me.PRIMTYPE   = { POINTS : 0, LINES : 1, LINE_LOOP : 2, LINE_STRIP : 3, TRIANGLES : 4, TRIANGLE_STRIP : 5 };
    me.RENDSTGATE = { WIREFRAME : 0, FRONT_FACE : 1, CULL_FACE : 2, DEPTH_TEST : 3, ALPHA_TO_COVERAGE : 4 };
    me.TEXTYPE    = { T2D : 0, T3D : 1, CUBEMAP : 2 };
    me.FILTER     = { NONE : 0, LINEAR : 1, MIPMAP : 2, NONE_MIPMAP : 3 };
    me.TYPE       = { UINT8 : 0, UINT16 : 1, UINT32 : 2, FLOAT16: 3, FLOAT32 : 4, FLOAT64: 5 };

    // private functions

    var iFormatPI2GL = function( format )
    {
        if( mIs20 )
        {
             if (format === me.TEXFMT.C4I8)  return { mGLFormat: mGL.RGBA8,           mGLExternal: mGL.RGBA,             mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1I8)  return { mGLFormat: mGL.R8,              mGLExternal: mGL.RED,              mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1F16) return { mGLFormat: mGL.R16F,            mGLExternal: mGL.RED,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F16) return { mGLFormat: mGL.RGBA16F,         mGLExternal: mGL.RGBA,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C1F32) return { mGLFormat: mGL.R32F,            mGLExternal: mGL.RED,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F32) return { mGLFormat: mGL.RGBA32F,         mGLExternal: mGL.RGBA,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C3F32) return { mGLFormat: mGL.RGB32F,          mGLExternal: mGL.RGB,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.Z16)   return { mGLFormat: mGL.DEPTH_COMPONENT16, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        else if (format === me.TEXFMT.Z24)   return { mGLFormat: mGL.DEPTH_COMPONENT24, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        else if (format === me.TEXFMT.Z32)   return { mGLFormat: mGL.DEPTH_COMPONENT32F, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        }
        else
        {
             if (format === me.TEXFMT.C4I8)  return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1I8)  return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.LUMINANCE,       mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1F16) return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.LUMINANCE,       mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F16) return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C1F32) return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.RED,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F32) return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.Z16)   return { mGLFormat: mGL.DEPTH_COMPONENT, mGLExternal: mGL.DEPTH_COMPONENT, mGLType: mGL.UNSIGNED_SHORT }
        }

        return null;
     }

    // public functions

    me.Initialize = function( gl )
                    {
                        mGL = gl;

                        mIs20 = !(gl instanceof WebGLRenderingContext);

                        if( mIs20 )
                        {
                            mFloat32Textures  = true;
                            mFloat32Filter    = mGL.getExtension( 'OES_texture_float_linear');
                            mFloat16Textures  = true;
                            mFloat16Filter    = mGL.getExtension( 'OES_texture_half_float_linear' );
                            mDerivatives      = true;
                            mDrawBuffers      = true;
                            mDepthTextures    = true;
                            mShaderTextureLOD = true;
                            mAnisotropic = mGL.getExtension( 'EXT_texture_filter_anisotropic' );
                            mRenderToFloat32F = mGL.getExtension( 'EXT_color_buffer_float');
                            mDebugShader = mGL.getExtension('WEBGL_debug_shaders');
                            mAsynchCompile = mGL.getExtension('KHR_parallel_shader_compile');

							mGL.hint( mGL.FRAGMENT_SHADER_DERIVATIVE_HINT, mGL.NICEST);
                        }
                        else
                        {
                            mFloat32Textures  = mGL.getExtension( 'OES_texture_float' );
                            mFloat32Filter    = mGL.getExtension( 'OES_texture_float_linear');
                            mFloat16Textures  = mGL.getExtension( 'OES_texture_half_float' );
                            mFloat16Filter    = mGL.getExtension( 'OES_texture_half_float_linear' );
                            mDerivatives      = mGL.getExtension( 'OES_standard_derivatives' );
                            mDrawBuffers      = mGL.getExtension( 'WEBGL_draw_buffers' );
                            mDepthTextures    = mGL.getExtension( 'WEBGL_depth_texture' );
                            mShaderTextureLOD = mGL.getExtension( 'EXT_shader_texture_lod' );
                            mAnisotropic      = mGL.getExtension( 'EXT_texture_filter_anisotropic' );
                            mRenderToFloat32F = mFloat32Textures;
                            mDebugShader      = null;
                            mAsynchCompile    = null;
							
							if( mDerivatives !== null) mGL.hint( mDerivatives.FRAGMENT_SHADER_DERIVATIVE_HINT_OES, mGL.NICEST);
                        }
                        
                        
                        var maxTexSize = mGL.getParameter( mGL.MAX_TEXTURE_SIZE );
                        var maxCubeSize = mGL.getParameter( mGL.MAX_CUBE_MAP_TEXTURE_SIZE );
                        var maxRenderbufferSize = mGL.getParameter( mGL.MAX_RENDERBUFFER_SIZE );
                        var extensions = mGL.getSupportedExtensions();
                        var textureUnits = mGL.getParameter( mGL.MAX_TEXTURE_IMAGE_UNITS );
                        console.log("WebGL (2.0=" + mIs20 + "):" +
                                    " Asynch Compile: "  + ((mAsynchCompile !==null) ? "yes" : "no") +
                                    ", Textures: F32 ["   + ((mFloat32Textures !==null) ? "yes" : "no") +
                                    "], F16 ["   + ((mFloat16Textures !==null) ? "yes" : "no") +
                                    "], Depth [" + ((mDepthTextures   !==null) ? "yes" : "no") +
                                    "], LOD ["    + ((mShaderTextureLOD!==null) ? "yes" : "no") +
                                    "], Aniso ["   + ((mAnisotropic     !==null) ? "yes" : "no") +
                                    "], Units [" + textureUnits +
                                    "], Max Size [" + maxTexSize +
                                    "], Cube Max Size [" + maxCubeSize +
                                    "], Targets: MRT ["            + ((mDrawBuffers     !==null) ? "yes" : "no") +
                                    "], F32 ["     + ((mRenderToFloat32F!==null) ? "yes" : "no") +
                                    "], Max Size [" + maxRenderbufferSize + "]");

                        // create a 2D quad Vertex Buffer
                        var vertices = new Float32Array( [ -1.0, -1.0,   1.0, -1.0,    -1.0,  1.0,     1.0, -1.0,    1.0,  1.0,    -1.0,  1.0] );
                        mVBO_Quad = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Quad );
                        mGL.bufferData( mGL.ARRAY_BUFFER, vertices, mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 2D triangle Vertex Buffer
                        mVBO_Tri = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Tri );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0,   3.0, -1.0,    -1.0,  3.0] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 3D cube Vertex Buffer
                        mVBO_CubePosNor = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePosNor );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0, -1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0, -1.0,  1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0,  1.0, -1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0,  1.0,  1.0,  -1.0,  0.0,  0.0,
                                                                               1.0,  1.0, -1.0,   1.0,  0.0,  0.0,
                                                                               1.0,  1.0,  1.0,   1.0,  0.0,  0.0,
                                                                               1.0, -1.0, -1.0,   1.0,  0.0,  0.0,
                                                                               1.0, -1.0,  1.0,   1.0,  0.0,  0.0,
                                                                               1.0,  1.0,  1.0,   0.0,  1.0,  0.0,
                                                                               1.0,  1.0, -1.0,   0.0,  1.0,  0.0,
                                                                              -1.0,  1.0,  1.0,   0.0,  1.0,  0.0,
                                                                              -1.0,  1.0, -1.0,   0.0,  1.0,  0.0,
                                                                               1.0, -1.0, -1.0,   0.0, -1.0,  0.0,
                                                                               1.0, -1.0,  1.0,   0.0, -1.0,  0.0,
                                                                              -1.0, -1.0, -1.0,   0.0, -1.0,  0.0,
                                                                              -1.0, -1.0,  1.0,   0.0, -1.0,  0.0,
                                                                              -1.0,  1.0,  1.0,   0.0,  0.0,  1.0,
                                                                              -1.0, -1.0,  1.0,   0.0,  0.0,  1.0,
                                                                               1.0,  1.0,  1.0,   0.0,  0.0,  1.0,
                                                                               1.0, -1.0,  1.0,   0.0,  0.0,  1.0,
                                                                              -1.0, -1.0, -1.0,   0.0,  0.0, -1.0,
                                                                              -1.0,  1.0, -1.0,   0.0,  0.0, -1.0,
                                                                               1.0, -1.0, -1.0,   0.0,  0.0, -1.0,
                                                                               1.0,  1.0, -1.0,   0.0,  0.0, -1.0 ] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 3D cube Vertex Buffer
                        mVBO_CubePos = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePos );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0, -1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                               1.0,  1.0, -1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0, -1.0,  1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0,  1.0, -1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0, -1.0,  1.0,
                                                                              -1.0, -1.0, -1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0, -1.0,  1.0,
                                                                              -1.0, -1.0, -1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0,  1.0, -1.0 ] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        //-------------------------------------------------------------------

                        mShaderHeader[0] = "";
                        mShaderHeaderLines[0] = 0;
                        if( mIs20 ) 
                        { 
                            mShaderHeader[0] += "#version 300 es\n" +
                                                "#ifdef GL_ES\n"+
                                                "precision highp float;\n" +
                                                "precision highp int;\n"+
                                                "precision mediump sampler3D;\n"+
                                                "#endif\n"; 
                            mShaderHeaderLines[0] += 6;
                        }
                        else
                        {
                            mShaderHeader[0] += "#ifdef GL_ES\n"+
                                                "precision highp float;\n" +
                                                "precision highp int;\n"+
                                                "#endif\n"+
                                                "float round( float x ) { return floor(x+0.5); }\n"+
                                                "vec2 round(vec2 x) { return floor(x + 0.5); }\n"+
                                                "vec3 round(vec3 x) { return floor(x + 0.5); }\n"+
                                                "vec4 round(vec4 x) { return floor(x + 0.5); }\n"+
                                                "float trunc( float x, float n ) { return floor(x*n)/n; }\n"+
                                                "mat3 transpose(mat3 m) { return mat3(m[0].x, m[1].x, m[2].x, m[0].y, m[1].y, m[2].y, m[0].z, m[1].z, m[2].z); }\n"+
                                                "float determinant( in mat2 m ) { return m[0][0]*m[1][1] - m[0][1]*m[1][0]; }\n"+
                                                "float determinant( mat4 m ) { float b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0], b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0], b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0], b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1], b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1], b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2], b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0], b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0], b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0], b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1], b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1], b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;}\n"+
                                                "mat2 inverse(mat2 m) { float det = determinant(m); return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / det; }\n"+
                                                "mat4 inverse(mat4 m ) { float inv0 = m[1].y*m[2].z*m[3].w - m[1].y*m[2].w*m[3].z - m[2].y*m[1].z*m[3].w + m[2].y*m[1].w*m[3].z + m[3].y*m[1].z*m[2].w - m[3].y*m[1].w*m[2].z; float inv4 = -m[1].x*m[2].z*m[3].w + m[1].x*m[2].w*m[3].z + m[2].x*m[1].z*m[3].w - m[2].x*m[1].w*m[3].z - m[3].x*m[1].z*m[2].w + m[3].x*m[1].w*m[2].z; float inv8 = m[1].x*m[2].y*m[3].w - m[1].x*m[2].w*m[3].y - m[2].x  * m[1].y * m[3].w + m[2].x  * m[1].w * m[3].y + m[3].x * m[1].y * m[2].w - m[3].x * m[1].w * m[2].y; float inv12 = -m[1].x  * m[2].y * m[3].z + m[1].x  * m[2].z * m[3].y +m[2].x  * m[1].y * m[3].z - m[2].x  * m[1].z * m[3].y - m[3].x * m[1].y * m[2].z + m[3].x * m[1].z * m[2].y; float inv1 = -m[0].y*m[2].z * m[3].w + m[0].y*m[2].w * m[3].z + m[2].y  * m[0].z * m[3].w - m[2].y  * m[0].w * m[3].z - m[3].y * m[0].z * m[2].w + m[3].y * m[0].w * m[2].z; float inv5 = m[0].x  * m[2].z * m[3].w - m[0].x  * m[2].w * m[3].z - m[2].x  * m[0].z * m[3].w + m[2].x  * m[0].w * m[3].z + m[3].x * m[0].z * m[2].w - m[3].x * m[0].w * m[2].z; float inv9 = -m[0].x  * m[2].y * m[3].w +  m[0].x  * m[2].w * m[3].y + m[2].x  * m[0].y * m[3].w - m[2].x  * m[0].w * m[3].y - m[3].x * m[0].y * m[2].w + m[3].x * m[0].w * m[2].y; float inv13 = m[0].x  * m[2].y * m[3].z - m[0].x  * m[2].z * m[3].y - m[2].x  * m[0].y * m[3].z + m[2].x  * m[0].z * m[3].y + m[3].x * m[0].y * m[2].z - m[3].x * m[0].z * m[2].y; float inv2 = m[0].y  * m[1].z * m[3].w - m[0].y  * m[1].w * m[3].z - m[1].y  * m[0].z * m[3].w + m[1].y  * m[0].w * m[3].z + m[3].y * m[0].z * m[1].w - m[3].y * m[0].w * m[1].z; float inv6 = -m[0].x  * m[1].z * m[3].w + m[0].x  * m[1].w * m[3].z + m[1].x  * m[0].z * m[3].w - m[1].x  * m[0].w * m[3].z - m[3].x * m[0].z * m[1].w + m[3].x * m[0].w * m[1].z; float inv10 = m[0].x  * m[1].y * m[3].w - m[0].x  * m[1].w * m[3].y - m[1].x  * m[0].y * m[3].w + m[1].x  * m[0].w * m[3].y + m[3].x * m[0].y * m[1].w - m[3].x * m[0].w * m[1].y; float inv14 = -m[0].x  * m[1].y * m[3].z + m[0].x  * m[1].z * m[3].y + m[1].x  * m[0].y * m[3].z - m[1].x  * m[0].z * m[3].y - m[3].x * m[0].y * m[1].z + m[3].x * m[0].z * m[1].y; float inv3 = -m[0].y * m[1].z * m[2].w + m[0].y * m[1].w * m[2].z + m[1].y * m[0].z * m[2].w - m[1].y * m[0].w * m[2].z - m[2].y * m[0].z * m[1].w + m[2].y * m[0].w * m[1].z; float inv7 = m[0].x * m[1].z * m[2].w - m[0].x * m[1].w * m[2].z - m[1].x * m[0].z * m[2].w + m[1].x * m[0].w * m[2].z + m[2].x * m[0].z * m[1].w - m[2].x * m[0].w * m[1].z; float inv11 = -m[0].x * m[1].y * m[2].w + m[0].x * m[1].w * m[2].y + m[1].x * m[0].y * m[2].w - m[1].x * m[0].w * m[2].y - m[2].x * m[0].y * m[1].w + m[2].x * m[0].w * m[1].y; float inv15 = m[0].x * m[1].y * m[2].z - m[0].x * m[1].z * m[2].y - m[1].x * m[0].y * m[2].z + m[1].x * m[0].z * m[2].y + m[2].x * m[0].y * m[1].z - m[2].x * m[0].z * m[1].y; float det = m[0].x * inv0 + m[0].y * inv4 + m[0].z * inv8 + m[0].w * inv12; det = 1.0 / det; return det*mat4( inv0, inv1, inv2, inv3,inv4, inv5, inv6, inv7,inv8, inv9, inv10, inv11,inv12, inv13, inv14, inv15);}\n"+                                                
                                                "float sinh(float x)  { return (exp(x)-exp(-x))/2.; }\n"+
                                                "float cosh(float x)  { return (exp(x)+exp(-x))/2.; }\n"+
                                                "float tanh(float x)  { return sinh(x)/cosh(x); }\n"+
                                                "float coth(float x)  { return cosh(x)/sinh(x); }\n"+
                                                "float sech(float x)  { return 1./cosh(x); }\n"+
                                                "float csch(float x)  { return 1./sinh(x); }\n"+
                                                "float asinh(float x) { return    log(x+sqrt(x*x+1.)); }\n"+
                                                "float acosh(float x) { return    log(x+sqrt(x*x-1.)); }\n"+
                                                "float atanh(float x) { return .5*log((1.+x)/(1.-x)); }\n"+
                                                "float acoth(float x) { return .5*log((x+1.)/(x-1.)); }\n"+
                                                "float asech(float x) { return    log((1.+sqrt(1.-x*x))/x); }\n"+
                                                "float acsch(float x) { return    log((1.+sqrt(1.+x*x))/x); }\n";
                            mShaderHeaderLines[0] += 26;
                        }

                        //-------------------------------------------------------

                        mShaderHeader[1] = "";
                        mShaderHeaderLines[1] = 0;
                        if( mIs20 ) 
                        { 
                            mShaderHeader[1] += "#version 300 es\n"+
                                                "#ifdef GL_ES\n"+
                                                "precision highp float;\n"+
                                                "precision highp int;\n"+
                                                "precision mediump sampler3D;\n"+
                                                "#endif\n"; 
                            mShaderHeaderLines[1] += 6;
                        }
                        else
                        {
                            if( mDerivatives ) { mShaderHeader[1] += "#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n"; mShaderHeaderLines[1]+=3; }
                            if( mShaderTextureLOD  ) { mShaderHeader[1] += "#extension GL_EXT_shader_texture_lod : enable\n"; mShaderHeaderLines[1]++; }
                            mShaderHeader[1] += "#ifdef GL_ES\n"+
                                                "precision highp float;\n"+
                                                "precision highp int;\n"+
                                                "#endif\n"+ 
                                                "vec4 texture(     sampler2D   s, vec2 c)                   { return texture2D(s,c); }\n"+
                                                "vec4 texture(     sampler2D   s, vec2 c, float b)          { return texture2D(s,c,b); }\n"+
                                                "vec4 texture(     samplerCube s, vec3 c )                  { return textureCube(s,c); }\n"+
                                                "vec4 texture(     samplerCube s, vec3 c, float b)          { return textureCube(s,c,b); }\n"+
                                                "float round( float x ) { return floor(x+0.5); }\n"+
                                                "vec2 round(vec2 x) { return floor(x + 0.5); }\n"+
                                                "vec3 round(vec3 x) { return floor(x + 0.5); }\n"+
                                                "vec4 round(vec4 x) { return floor(x + 0.5); }\n"+
                                                "float trunc( float x, float n ) { return floor(x*n)/n; }\n"+
                                                "mat3 transpose(mat3 m) { return mat3(m[0].x, m[1].x, m[2].x, m[0].y, m[1].y, m[2].y, m[0].z, m[1].z, m[2].z); }\n"+
                                                "float determinant( in mat2 m ) { return m[0][0]*m[1][1] - m[0][1]*m[1][0]; }\n"+
                                                "float determinant( mat4 m ) { float b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0], b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0], b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0], b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1], b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1], b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2], b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0], b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0], b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0], b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1], b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1], b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;}\n"+
                                                "mat2 inverse(mat2 m) { float det = determinant(m); return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / det; }\n"+
                                                "mat4 inverse(mat4 m ) { float inv0 = m[1].y*m[2].z*m[3].w - m[1].y*m[2].w*m[3].z - m[2].y*m[1].z*m[3].w + m[2].y*m[1].w*m[3].z + m[3].y*m[1].z*m[2].w - m[3].y*m[1].w*m[2].z; float inv4 = -m[1].x*m[2].z*m[3].w + m[1].x*m[2].w*m[3].z + m[2].x*m[1].z*m[3].w - m[2].x*m[1].w*m[3].z - m[3].x*m[1].z*m[2].w + m[3].x*m[1].w*m[2].z; float inv8 = m[1].x*m[2].y*m[3].w - m[1].x*m[2].w*m[3].y - m[2].x  * m[1].y * m[3].w + m[2].x  * m[1].w * m[3].y + m[3].x * m[1].y * m[2].w - m[3].x * m[1].w * m[2].y; float inv12 = -m[1].x  * m[2].y * m[3].z + m[1].x  * m[2].z * m[3].y +m[2].x  * m[1].y * m[3].z - m[2].x  * m[1].z * m[3].y - m[3].x * m[1].y * m[2].z + m[3].x * m[1].z * m[2].y; float inv1 = -m[0].y*m[2].z * m[3].w + m[0].y*m[2].w * m[3].z + m[2].y  * m[0].z * m[3].w - m[2].y  * m[0].w * m[3].z - m[3].y * m[0].z * m[2].w + m[3].y * m[0].w * m[2].z; float inv5 = m[0].x  * m[2].z * m[3].w - m[0].x  * m[2].w * m[3].z - m[2].x  * m[0].z * m[3].w + m[2].x  * m[0].w * m[3].z + m[3].x * m[0].z * m[2].w - m[3].x * m[0].w * m[2].z; float inv9 = -m[0].x  * m[2].y * m[3].w +  m[0].x  * m[2].w * m[3].y + m[2].x  * m[0].y * m[3].w - m[2].x  * m[0].w * m[3].y - m[3].x * m[0].y * m[2].w + m[3].x * m[0].w * m[2].y; float inv13 = m[0].x  * m[2].y * m[3].z - m[0].x  * m[2].z * m[3].y - m[2].x  * m[0].y * m[3].z + m[2].x  * m[0].z * m[3].y + m[3].x * m[0].y * m[2].z - m[3].x * m[0].z * m[2].y; float inv2 = m[0].y  * m[1].z * m[3].w - m[0].y  * m[1].w * m[3].z - m[1].y  * m[0].z * m[3].w + m[1].y  * m[0].w * m[3].z + m[3].y * m[0].z * m[1].w - m[3].y * m[0].w * m[1].z; float inv6 = -m[0].x  * m[1].z * m[3].w + m[0].x  * m[1].w * m[3].z + m[1].x  * m[0].z * m[3].w - m[1].x  * m[0].w * m[3].z - m[3].x * m[0].z * m[1].w + m[3].x * m[0].w * m[1].z; float inv10 = m[0].x  * m[1].y * m[3].w - m[0].x  * m[1].w * m[3].y - m[1].x  * m[0].y * m[3].w + m[1].x  * m[0].w * m[3].y + m[3].x * m[0].y * m[1].w - m[3].x * m[0].w * m[1].y; float inv14 = -m[0].x  * m[1].y * m[3].z + m[0].x  * m[1].z * m[3].y + m[1].x  * m[0].y * m[3].z - m[1].x  * m[0].z * m[3].y - m[3].x * m[0].y * m[1].z + m[3].x * m[0].z * m[1].y; float inv3 = -m[0].y * m[1].z * m[2].w + m[0].y * m[1].w * m[2].z + m[1].y * m[0].z * m[2].w - m[1].y * m[0].w * m[2].z - m[2].y * m[0].z * m[1].w + m[2].y * m[0].w * m[1].z; float inv7 = m[0].x * m[1].z * m[2].w - m[0].x * m[1].w * m[2].z - m[1].x * m[0].z * m[2].w + m[1].x * m[0].w * m[2].z + m[2].x * m[0].z * m[1].w - m[2].x * m[0].w * m[1].z; float inv11 = -m[0].x * m[1].y * m[2].w + m[0].x * m[1].w * m[2].y + m[1].x * m[0].y * m[2].w - m[1].x * m[0].w * m[2].y - m[2].x * m[0].y * m[1].w + m[2].x * m[0].w * m[1].y; float inv15 = m[0].x * m[1].y * m[2].z - m[0].x * m[1].z * m[2].y - m[1].x * m[0].y * m[2].z + m[1].x * m[0].z * m[2].y + m[2].x * m[0].y * m[1].z - m[2].x * m[0].z * m[1].y; float det = m[0].x * inv0 + m[0].y * inv4 + m[0].z * inv8 + m[0].w * inv12; det = 1.0 / det; return det*mat4( inv0, inv1, inv2, inv3,inv4, inv5, inv6, inv7,inv8, inv9, inv10, inv11,inv12, inv13, inv14, inv15);}\n"+
                                                "float sinh(float x)  { return (exp(x)-exp(-x))/2.; }\n"+
                                                "float cosh(float x)  { return (exp(x)+exp(-x))/2.; }\n"+
                                                "float tanh(float x)  { return sinh(x)/cosh(x); }\n"+
                                                "float coth(float x)  { return cosh(x)/sinh(x); }\n"+
                                                "float sech(float x)  { return 1./cosh(x); }\n"+
                                                "float csch(float x)  { return 1./sinh(x); }\n"+
                                                "float asinh(float x) { return    log(x+sqrt(x*x+1.)); }\n"+
                                                "float acosh(float x) { return    log(x+sqrt(x*x-1.)); }\n"+
                                                "float atanh(float x) { return .5*log((1.+x)/(1.-x)); }\n"+
                                                "float acoth(float x) { return .5*log((x+1.)/(x-1.)); }\n"+
                                                "float asech(float x) { return    log((1.+sqrt(1.-x*x))/x); }\n"+
                                                "float acsch(float x) { return    log((1.+sqrt(1.+x*x))/x); }\n";
                            mShaderHeaderLines[1] += 30;
                            if( mShaderTextureLOD )
                            {
                            mShaderHeader[1] += "vec4 textureLod(  sampler2D   s, vec2 c, float b)          { return texture2DLodEXT(s,c,b); }\n";
                            mShaderHeader[1] += "vec4 textureGrad( sampler2D   s, vec2 c, vec2 dx, vec2 dy) { return texture2DGradEXT(s,c,dx,dy); }\n";
                            mShaderHeaderLines[1] += 2;

                            //mShaderHeader[1] += "vec4 texelFetch( sampler2D s, ivec2 c, int l) { return texture2DLodEXT(s,(vec2(c)+0.5)/vec2(800,450),float(l)); }\n";
                            //mShaderHeaderLines[1] += 1;
                            }
                        }

                        return true;
                    };

        me.GetCaps =    function ()
                        {   
                            return { mIsGL20 : mIs20,
                                     mFloat32Textures: mFloat32Textures != null,
                                     mFloat16Textures: mFloat16Textures != null,
                                     mDrawBuffers: mDrawBuffers != null,
                                     mDepthTextures: mDepthTextures != null,
                                     mDerivatives: mDerivatives != null,
                                     mShaderTextureLOD: mShaderTextureLOD != null };
                        };

        me.GetShaderHeaderLines = function (shaderType)
                        {   
                            return mShaderHeaderLines[shaderType];
                        };

        me.CheckErrors = function()
                         {
                                var error = mGL.getError();
                                if( error != mGL.NO_ERROR ) 
                                { 
                                    for( var prop in mGL ) 
                                    {
                                        if( typeof mGL[prop] == 'number' ) 
                                        {
                                            if( mGL[prop] == error )
                                            {
                                                console.log( "GL Error " + error + ": " + prop );
                                                break;
                                            }
                                        }
                                    }
                                }
                         };

        me.Clear =  function( flags, ccolor, cdepth, cstencil )
                    {
                        var mode = 0;
                        if( flags & 1 ) { mode |= mGL.COLOR_BUFFER_BIT;   mGL.clearColor( ccolor[0], ccolor[1], ccolor[2], ccolor[3] ); }
                        if( flags & 2 ) { mode |= mGL.DEPTH_BUFFER_BIT;   mGL.clearDepth( cdepth ); }
                        if( flags & 4 ) { mode |= mGL.STENCIL_BUFFER_BIT; mGL.clearStencil( cstencil ); }
                        mGL.clear( mode );
                    };


        me.CreateTexture = function ( type, xres, yres, format, filter, wrap, buffer)
                           {
                                if( mGL===null ) return null;

                                var id = mGL.createTexture();

                                var glFoTy = iFormatPI2GL( format );
                                var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                if( type===me.TEXTYPE.T2D )
                                {
                                    mGL.bindTexture( mGL.TEXTURE_2D, id );
//if( buffer==null )
    //mGL.texStorage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, xres, yres);
//else
                                    mGL.texImage2D( mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texParameteri( mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap );
                                    mGL.texParameteri( mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap );

                                    if (filter === me.FILTER.NONE)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }

                                    mGL.bindTexture( mGL.TEXTURE_2D, null );
                                }
                                else if( type===me.TEXTYPE.T3D )
                                {
                                    if( mIs20 )
                                    {
                                        mGL.bindTexture( mGL.TEXTURE_3D, id );
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_BASE_LEVEL, 0);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAX_LEVEL, Math.log2(xres));
                                        if (filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                        }
                                        else if (filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        }
                                        else
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_3D);
                                        }
                                        mGL.texImage3D( mGL.TEXTURE_3D, 0, glFoTy.mGLFormat, xres, yres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );

                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_R, glWrap );
                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_S, glWrap );
                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_T, glWrap );

                                        if (filter === me.FILTER.MIPMAP)
                                            mGL.generateMipmap( mGL.TEXTURE_3D );
                                        mGL.bindTexture( mGL.TEXTURE_3D, null );
                                    }
                                    else 
                                    {
                                        return null;
                                    }
                                }
                                else 
                                {
                                    mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );

                                    // this works great if we know the number of required mipmaps in advance (1, or other)
                                   //mGL.texStorage2D( mGL.TEXTURE_CUBE_MAP, 1, glFoTy.mGLFormat, xres, yres );

                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );

                                    if( filter === me.FILTER.NONE)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR)
                                    {
                                        mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR );
                                        mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR );
                                    }
                                    else if (filter === me.FILTER.MIPMAP)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                    }

                                    if (filter === me.FILTER.MIPMAP)
                                        mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );

                                    mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                }
                        return { mObjectID: id, mXres: xres, mYres: yres, mFormat: format, mType: type, mFilter: filter, mWrap: wrap, mVFlip:false };
                        };

        me.CreateTextureFromImage = function ( type, image, format, filter, wrap, flipY) 
                                {
                                    if( mGL===null ) return null;

                                    var id = mGL.createTexture();

                                    var glFoTy = iFormatPI2GL( format );

                                    var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                    if( type===me.TEXTYPE.T2D )
                                    {
                                        mGL.bindTexture(mGL.TEXTURE_2D, id);

                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, flipY);
                                        mGL.pixelStorei(mGL.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                                        if( mIs20 ) mGL.pixelStorei(mGL.UNPACK_COLORSPACE_CONVERSION_WEBGL, mGL.NONE );

                                        mGL.texImage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image);

                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap);

                                        if (filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                        }
                                        else if( filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_2D);
                                        }
                                        else
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_2D);
                                        }
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                        mGL.bindTexture(mGL.TEXTURE_2D, null);
                                    }
                                    else if( type===me.TEXTYPE.T3D )
                                    {
                                        return null;
                                    }
                                    else 
                                    {
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, flipY);
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[0] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[1] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (flipY ? image[3] : image[2]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (flipY ? image[2] : image[3]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[4] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[5] );

                                        if( filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR );
                                            mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR );
                                        }
                                        else if (filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                            mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );
                                        }
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                    }
                                    return { mObjectID: id, mXres: image.width, mYres: image.height, mFormat: format, mType: type, mFilter: filter, mWrap:wrap, mVFlip:flipY };
                                };

        me.SetSamplerFilter = function (te, filter, doGenerateMipsIfNeeded) 
                            {
                                if (te.mFilter === filter) return;

                                if (te.mType === me.TEXTYPE.T2D) 
                                {
                                    mGL.bindTexture(mGL.TEXTURE_2D, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_2D, null);

                                }
                                else if (te.mType === me.TEXTYPE.T3D) 
                                {
                                    mGL.bindTexture(mGL.TEXTURE_3D, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_3D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_3D);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_3D, null);

                                }
                                else
                                {
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_CUBE_MAP);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_CUBE_MAP);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                                }


                                te.mFilter = filter;
                            };

        me.SetSamplerWrap = function (te, wrap)
                            {
                                if (te.mWrap === wrap) return;

                                var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                var id = te.mObjectID;

                                if (te.mType === me.TEXTYPE.T2D)
                                {
                                    mGL.bindTexture(mGL.TEXTURE_2D, id);
                                    mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap);
                                    mGL.bindTexture(mGL.TEXTURE_2D, null);

                                }
                                else if (te.mType === me.TEXTYPE.T3D)
                                {
                                    mGL.bindTexture(mGL.TEXTURE_3D, id);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_R, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_S, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_T, glWrap);
                                    mGL.bindTexture(mGL.TEXTURE_3D, null);
                                }

                                te.mWrap = wrap;
                            };

        me.SetSamplerVFlip = function (te, vflip, image)
                            {
                                if (te.mVFlip === vflip) return;

                                var id = te.mObjectID;

                                if (te.mType === me.TEXTYPE.T2D)
                                {
                                    if( image != null)
                                    {
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture(mGL.TEXTURE_2D, id);
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, vflip);
                                        var glFoTy = iFormatPI2GL( te.mFormat );
                                        mGL.texImage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image);
                                        mGL.bindTexture(mGL.TEXTURE_2D, null);
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
                                }
                                else if (te.mType === me.TEXTYPE.CUBEMAP)
                                {
                                    if( image != null)
                                    {
                                        var glFoTy = iFormatPI2GL( te.mFormat );
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );
                                        mGL.pixelStorei( mGL.UNPACK_FLIP_Y_WEBGL, vflip);
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[0] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[1] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (vflip ? image[3] : image[2]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (vflip ? image[2] : image[3]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[4] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[5] );
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
        
                                }

                                te.mVFlip = vflip;
                            };

        me.CreateMipmaps =  function (te)
                            {
                                if( te.mType===me.TEXTYPE.T2D )
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                    mGL.bindTexture(mGL.TEXTURE_2D, te.mObjectID);
                                    mGL.generateMipmap(mGL.TEXTURE_2D);
                                    mGL.bindTexture(mGL.TEXTURE_2D, null);
                                }
                                else if( te.mType===me.TEXTYPE.CUBEMAP )
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, te.mObjectID);
                                    mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                                }
                            };

        me.UpdateTexture =  function( tex, x0, y0, xres, yres, buffer )
                            {
                                var glFoTy = iFormatPI2GL( tex.mFormat );
                                if( tex.mType===me.TEXTYPE.T2D )
                                {
                                    mGL.activeTexture( mGL.TEXTURE0);
                                    mGL.bindTexture( mGL.TEXTURE_2D, tex.mObjectID );
                                    mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, tex.mVFlip );
                                    mGL.texSubImage2D( mGL.TEXTURE_2D, 0, x0, y0, xres, yres, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.bindTexture( mGL.TEXTURE_2D, null );
                                    mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                }
                            };

        me.UpdateTextureFromImage = function( tex, image )
                                {
                                    var glFoTy = iFormatPI2GL( tex.mFormat );
                                    if( tex.mType===me.TEXTYPE.T2D )
                                    {
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture( mGL.TEXTURE_2D, tex.mObjectID );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, tex.mVFlip );
                                        mGL.texImage2D(  mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image );
                                        mGL.bindTexture( mGL.TEXTURE_2D, null );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
                                };

        me.DestroyTexture = function( te )
                            {
                                 mGL.deleteTexture( te.mObjectID );
                            };

        me.AttachTextures = function (num, t0, t1, t2, t3) 
                            {
                                if (num > 0 && t0 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                         if (t0.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t0.mObjectID);
                                    else if (t0.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t0.mObjectID);
                                    else if (t0.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t0.mObjectID);
                                }

                                if (num > 1 && t1 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE1);
                                         if (t1.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t1.mObjectID);
                                    else if (t1.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t1.mObjectID);
                                    else if (t1.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t1.mObjectID);
                                }

                                if (num > 2 && t2 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE2);
                                         if (t2.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t2.mObjectID);
                                    else if (t2.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t2.mObjectID);
                                    else if (t2.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t2.mObjectID);
                                }

                                if (num > 3 && t3 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE3);
                                         if (t3.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t3.mObjectID);
                                    else if (t3.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t3.mObjectID);
                                    else if (t3.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t3.mObjectID);
                                }
                            };

        me.DettachTextures = function()
                             {
                                mGL.activeTexture(mGL.TEXTURE0);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE1);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE2);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE3);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                             };

        me.CreateRenderTarget = function ( color0, color1, color2, color3, depth, wantZbuffer )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if (depth === null)
                                    {
                                        if( wantZbuffer===true )
                                        {
                                            var zb = mGL.createRenderbuffer();
                                            mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);
                                            mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, color0.mXres, color0.mYres);

                                            mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                        }
                                    }
                                    else
                                    {
                                        mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.TEXTURE_2D, depth.mObjectID, 0);
                                    }

                                    if( color0 !=null ) mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_2D, color0.mObjectID, 0);

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                        return null;

                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mTex0: color0 };
                                };

        me.DestroyRenderTarget = function ( tex )
                                 {
                                     mGL.deleteFramebuffer(tex.mObjectID);
                                 };

        me.SetRenderTarget = function (tex)
                             {
                                if( tex===null )
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                else
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, tex.mObjectID);

                                //mGL.drawBuffers([mGL.COLOR_ATTACHMENT0, mGL.COLOR_ATTACHMENT1]);
                             };

        me.CreateRenderTargetNew = function ( wantColor0, wantZbuffer, xres, yres, samples )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if( wantZbuffer===true )
                                    {
                                        var zb = mGL.createRenderbuffer();
                                        mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);

                                        if( samples==1 )
                                        mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, xres, yres);
                                        else
                                        mGL.renderbufferStorageMultisample(mGL.RENDERBUFFER, samples, mGL.DEPTH_COMPONENT16, xres, yres);
                                        mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                    }

                                    if( wantColor0 )
                                    {
                                        var cb = mGL.createRenderbuffer();
                                        mGL.bindRenderbuffer(mGL.RENDERBUFFER, cb);
                                        if( samples==1 )
                                        mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.RGBA8, xres, yres);
                                        else
                                        mGL.renderbufferStorageMultisample(mGL.RENDERBUFFER, samples, mGL.RGBA8, xres, yres);
                                        mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.RENDERBUFFER, cb);
                                    }

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                    {
                                        return null;
                                    }
                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mXres: xres, mYres:yres, mTex0: color0 };
                                };

        me.CreateRenderTargetCubeMap = function ( color0, depth, wantZbuffer )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if (depth === null)
                                    {
                                        if( wantZbuffer===true )
                                        {
                                            var zb = mGL.createRenderbuffer();
                                            mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);
                                            mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, color0.mXres, color0.mYres);
                                            mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                        }
                                    }
                                    else
                                    {
                                        mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.TEXTURE_2D, depth.mObjectID, 0);
                                    }

                                    if( color0 !=null ) mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_CUBE_MAP_POSITIVE_X, color0.mObjectID, 0);

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                        return null;

                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mTex0: color0 };
                                };

        me.SetRenderTargetCubeMap = function (fbo, face)
                             {
                                if( fbo===null )
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                else
                                {
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, fbo.mObjectID);
                                    mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_CUBE_MAP_POSITIVE_X+face, fbo.mTex0.mObjectID, 0);
                                }
                             };


        me.BlitRenderTarget = function( dst, src )
                                {
                                    mGL.bindFramebuffer(mGL.READ_FRAMEBUFFER, src.mObjectID);
                                    mGL.bindFramebuffer(mGL.DRAW_FRAMEBUFFER, dst.mObjectID);
                                    mGL.clearBufferfv(mGL.COLOR, 0, [0.0, 0.0, 0.0, 1.0]);
                                    mGL.blitFramebuffer( 0, 0, src.mXres, src.mYres,
                                                         0, 0, src.mXres, src.mYres,
                                                         mGL.COLOR_BUFFER_BIT, mGL.LINEAR
                                    );
                                };

        me.SetViewport = function( vp )
                         {
                              mGL.viewport( vp[0], vp[1], vp[2], vp[3] );
                         };

        me.SetWriteMask = function( c0, c1, c2, c3, z )
                          {
                              mGL.depthMask(z);
                              mGL.colorMask(c0,c0,c0,c0);
                          };

        me.SetState = function( stateName, stateValue )
                      {
                            if (stateName === me.RENDSTGATE.WIREFRAME)
                            {
                                if( stateValue ) mGL.polygonMode( mGL.FRONT_AND_BACK, mGL.LINE );
                                else             mGL.polygonMode( mGL.FRONT_AND_BACK, mGL.FILL );
                            }
                            else if (stateName === me.RENDSTGATE.FRONT_FACE)
                            {
                                if( stateValue ) mGL.cullFace( mGL.BACK );
                                else             mGL.cullFace( mGL.FRONT );
                            }
                            else if (stateName === me.RENDSTGATE.CULL_FACE)
                            {
                                if( stateValue ) mGL.enable( mGL.CULL_FACE );
                                else             mGL.disable( mGL.CULL_FACE );
                            }
                            else if (stateName === me.RENDSTGATE.DEPTH_TEST)
                            {
                                if( stateValue ) mGL.enable( mGL.DEPTH_TEST );
                                else             mGL.disable( mGL.DEPTH_TEST );
                            }
                            else if (stateName === me.RENDSTGATE.ALPHA_TO_COVERAGE)
                            {
                                if( stateValue ) { mGL.enable(  mGL.SAMPLE_ALPHA_TO_COVERAGE ); }
                                else             { mGL.disable( mGL.SAMPLE_ALPHA_TO_COVERAGE ); }
                            }
                      };

        me.SetMultisample = function( v)
                    {
                        if( v===true )
                        {
                            mGL.enable(mGL.SAMPLE_COVERAGE);
                            mGL.sampleCoverage(1.0, false);
                        }
                        else
                        {
                            mGL.disable(mGL.SAMPLE_COVERAGE);
                        }
                    };

        me.GetTranslatedShaderSource = function (shader) 
                          {
                            if( mGL===null ) return null;
                            if( mDebugShader===null ) return null;
                            let vfs = mGL.getAttachedShaders(shader.mProgram);
                            let str = mDebugShader.getTranslatedShaderSource(vfs[1]);
                            let parts = str.split("GLSL END"); str = (parts.length<2) ? str : parts[1];
                            return str;
                          };

        me.CreateShader = function (vsSource, fsSource, preventCache, forceSynch, onResolve) 
                          {
                            if( mGL===null ) return;

                            var vs = mGL.createShader( mGL.VERTEX_SHADER   );
                            var fs = mGL.createShader( mGL.FRAGMENT_SHADER );

                            vsSource = mShaderHeader[0] + vsSource;
                            fsSource = mShaderHeader[1] + fsSource;

                            if( preventCache )
                            {
                                let vran = Math.random().toString(36).substring(7);
                                let fran = Math.random().toString(36).substring(7);
                                vsSource += "\n#define K" + vran + "\n";
                                fsSource += "\n#define K" + fran + "\n";
                            }

                            var timeStart = getRealTime();

                            mGL.shaderSource(vs, vsSource);
                            mGL.shaderSource(fs, fsSource);
                            mGL.compileShader(vs);
                            mGL.compileShader(fs);

                            var pr = mGL.createProgram();
                            mGL.attachShader(pr, vs);
                            mGL.attachShader(pr, fs);
                            mGL.linkProgram(pr);

                            //-------------
                            let checkErrors = function()
                            {
                                if (!mGL.getProgramParameter(pr, mGL.LINK_STATUS))
                                {
                                    // vs error
                                    if (!mGL.getShaderParameter(vs, mGL.COMPILE_STATUS))
                                    {
                                        let vsLog = mGL.getShaderInfoLog(vs);
                                        onResolve(false, { mErrorType: 0, mErrorStr: vsLog });
                                        mGL.deleteProgram(pr);
                                    }
                                    // fs error
                                    else if (!mGL.getShaderParameter(fs, mGL.COMPILE_STATUS))
                                    {
                                        let fsLog = mGL.getShaderInfoLog(fs);
                                        onResolve(false, { mErrorType: 1, mErrorStr: fsLog });
                                        mGL.deleteProgram(pr);
                                    }
                                    // link error
                                    else
                                    {
                                        let infoLog = mGL.getProgramInfoLog(pr);
                                        onResolve(false, { mErrorType: 2, mErrorStr: infoLog });
                                        mGL.deleteProgram(pr);
                                    }
                                }
                                // no errors
                                else
                                {
                                    let compilationTime = getRealTime() - timeStart;
                                    onResolve(true, { mProgram: pr, mTime: compilationTime });
                                }
                            };

                            // check compilation
                            if (mAsynchCompile === null || forceSynch===true )
                            {
                                checkErrors();
                            }
                            else
                            {
                                let loopCheckCompletion = function ()
                                {
                                    if( mGL.getProgramParameter(pr, mAsynchCompile.COMPLETION_STATUS_KHR) === true )
                                        checkErrors();
                                    else
                                        setTimeout(loopCheckCompletion, 10);
                                };
                                setTimeout(loopCheckCompletion, 10);
                            }
                        };

        me.AttachShader = function( shader )
                          {
                                if( shader===null )
                                {
                                    mBindedShader = null;
                                    mGL.useProgram( null );
                                }
                                else
                                {
                                    mBindedShader = shader;
                                    mGL.useProgram(shader.mProgram);
                                }
                          };

        me.DetachShader = function ()
                        {
                            mGL.useProgram(null);
                        };

        me.DestroyShader = function( tex )
                        {
                            mGL.deleteProgram(tex.mProgram);
                        };

        me.GetAttribLocation = function (shader, name)
                        {
                            return mGL.getAttribLocation(shader.mProgram, name);
                        };

        me.SetShaderConstantLocation = function (shader, name)
                        {
                            return mGL.getUniformLocation(shader.mProgram, name);
                        };

        me.SetShaderConstantMat4F = function( uname, params, istranspose )
                        {
                            var program = mBindedShader;

                            let pos = mGL.getUniformLocation( program.mProgram, uname );
                            if( pos===null )
                                return false;

                            if( istranspose===false )
                            {
                                var tmp = new Float32Array( [ params[0], params[4], params[ 8], params[12],
                                                              params[1], params[5], params[ 9], params[13],
                                                              params[2], params[6], params[10], params[14],
                                                              params[3], params[7], params[11], params[15] ] );
	                            mGL.uniformMatrix4fv(pos,false,tmp);
                            }
                            else
                                mGL.uniformMatrix4fv(pos,false,new Float32Array(params) );
                            return true;
                        };

        me.SetShaderConstant1F_Pos = function(pos, x)
                        {
                            mGL.uniform1f(pos, x);
                            return true;
                        };

        me.SetShaderConstant1FV_Pos = function(pos, x)
                        {
                            mGL.uniform1fv(pos, x);
                            return true;
                        };

        me.SetShaderConstant1F = function( uname, x )
                        {
                            var pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1f(pos, x);
                            return true;
                        };

        me.SetShaderConstant1I = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1i(pos, x);
                            return true;
                        };
        me.SetShaderConstant1I_Pos = function(pos, x)
                        {
                            mGL.uniform1i(pos, x);
                            return true;
                        };


        me.SetShaderConstant2F = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform2fv(pos, x);
                            return true;
                        };

        me.SetShaderConstant3F = function(uname, x, y, z)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform3f(pos, x, y, z);
                            return true;
                        };

        me.SetShaderConstant1FV = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1fv(pos, new Float32Array(x));
                            return true;
                        };

        me.SetShaderConstant3FV = function(uname, x) 
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform3fv(pos, new Float32Array(x) );
                            return true;
                        };

        me.SetShaderConstant4FV = function(uname, x) 
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform4fv(pos, new Float32Array(x) );
                            return true;
                        };

        me.SetShaderTextureUnit = function( uname, unit )
                        {
                            var program = mBindedShader;
                            let pos = mGL.getUniformLocation(program.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform1i(pos, unit);
                            return true;
                        };

        me.CreateVertexArray = function( data, mode )
                        {
                            let id = mGL.createBuffer();
                            mGL.bindBuffer(mGL.ARRAY_BUFFER, id);
                            if (mode === me.BUFTYPE.STATIC)
                                mGL.bufferData(mGL.ARRAY_BUFFER, data, mGL.STATIC_DRAW);
                            else
                                mGL.bufferData(mGL.ARRAY_BUFFER, data, mGL.DYNAMIC_DRAW);
                            return { mObject: id };
                        };

        me.CreateIndexArray = function( data, mode )
                        {
                            let id = mGL.createBuffer();
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, id );
                            if (mode === me.BUFTYPE.STATIC)
                                mGL.bufferData(mGL.ELEMENT_ARRAY_BUFFER, data, mGL.STATIC_DRAW);
                            else
                                mGL.bufferData(mGL.ELEMENT_ARRAY_BUFFER, data, mGL.DYNAMIC_DRAW);
                            return { mObject: id };
                        };

        me.DestroyArray = function( tex )
                        {
                            mGL.destroyBuffer(tex.mObject);
                        };

        me.AttachVertexArray = function( tex, attribs, pos )
                        {
                            let shader = mBindedShader;

                            mGL.bindBuffer( mGL.ARRAY_BUFFER, tex.mObject);

                            var num = attribs.mChannels.length;
                            var stride = attribs.mStride;

                            var offset = 0;
                            for (var i = 0; i < num; i++)
                            {
                                var id = pos[i];
                                mGL.enableVertexAttribArray(id);
                                var dtype = mGL.FLOAT;
                                var dsize = 4;
                                     if( attribs.mChannels[i].mType === me.TYPE.UINT8   ) { dtype = mGL.UNSIGNED_BYTE;  dsize = 1; }
                                else if( attribs.mChannels[i].mType === me.TYPE.UINT16  ) { dtype = mGL.UNSIGNED_SHORT; dsize = 2; }
                                else if( attribs.mChannels[i].mType === me.TYPE.FLOAT32 ) { dtype = mGL.FLOAT;          dsize = 4; }
                                mGL.vertexAttribPointer(id, attribs.mChannels[i].mNumComponents, dtype, attribs.mChannels[i].mNormalize, stride, offset);
                                offset += attribs.mChannels[i].mNumComponents * dsize;
                            }
                        };

        me.AttachIndexArray = function( tex )
                        {
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, tex.mObject);
                        };

        me.DetachVertexArray = function (tex, attribs)
                        {
                            let num = attribs.mChannels.length;
                            for (let i = 0; i < num; i++)
                                mGL.disableVertexAttribArray(i);
                            mGL.bindBuffer(mGL.ARRAY_BUFFER, null);
                        };

        me.DetachIndexArray = function( tex )
                        {
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, null);
                        };

        me.DrawPrimitive = function( typeOfPrimitive, num, useIndexArray, numInstances )
                        {
                            let glType = mGL.POINTS;
                            if( typeOfPrimitive===me.PRIMTYPE.POINTS ) glType = mGL.POINTS;
                            if( typeOfPrimitive===me.PRIMTYPE.LINES ) glType = mGL.LINES;
                            if( typeOfPrimitive===me.PRIMTYPE.LINE_LOOP ) glType = mGL.LINE_LOOP;
                            if( typeOfPrimitive===me.PRIMTYPE.LINE_STRIP ) glType = mGL.LINE_STRIP;
                            if( typeOfPrimitive===me.PRIMTYPE.TRIANGLES ) glType = mGL.TRIANGLES;
                            if( typeOfPrimitive===me.PRIMTYPE.TRIANGLE_STRIP ) glType = mGL.TRIANGLE_STRIP;

                            if( numInstances<=1 )
                            {
  	                            if( useIndexArray ) mGL.drawElements( glType, num, mGL.UNSIGNED_SHORT, 0 );
	                            else                mGL.drawArrays( glType, 0, num );
                            }
                            else
                            {
                                mGL.drawArraysInstanced(glType, 0, num, numInstances);
                                mGL.drawElementsInstanced( glType, num, mGL.UNSIGNED_SHORT, 0, numInstances);
                            }
                        };


        me.DrawFullScreenTriangle_XY = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Tri );
                            mGL.vertexAttribPointer( vpos, 2, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays( mGL.TRIANGLES, 0, 3 );
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        };


        me.DrawUnitQuad_XY = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Quad );
                            mGL.vertexAttribPointer( vpos, 2, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays( mGL.TRIANGLES, 0, 6 );
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        };

        me.DrawUnitCube_XYZ_NOR = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePosNor );
                            mGL.vertexAttribPointer( vpos[0], 3, mGL.FLOAT, false, 0, 0 );
                            mGL.vertexAttribPointer( vpos[1], 3, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos[0] );
                            mGL.enableVertexAttribArray( vpos[1] );
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 0, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 4, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 8, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 12, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 16, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 20, 4);
                            mGL.disableVertexAttribArray( vpos[0] );
                            mGL.disableVertexAttribArray( vpos[1] );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        }

        me.DrawUnitCube_XYZ = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePos );
                            mGL.vertexAttribPointer( vpos, 3, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 0, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 4, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 8, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 12, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 16, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 20, 4);
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        }

        me.SetBlend = function( enabled )
                    {
                        if( enabled )
                        {
                            mGL.enable( mGL.BLEND );
                            mGL.blendEquationSeparate( mGL.FUNC_ADD, mGL.FUNC_ADD );
                            mGL.blendFuncSeparate( mGL.SRC_ALPHA, mGL.ONE_MINUS_SRC_ALPHA, mGL.ONE, mGL.ONE_MINUS_SRC_ALPHA );
                        }
                        else
                        {
                            mGL.disable( mGL.BLEND );
                        }
                    };

        me.GetPixelData = function( data, offset, xres, yres )
                        {
                            mGL.readPixels(0, 0, xres, yres, mGL.RGBA, mGL.UNSIGNED_BYTE, data, offset);
                        };

        me.GetPixelDataRenderTarget = function( obj, data, xres, yres )
                        {
                            mGL.bindFramebuffer(mGL.FRAMEBUFFER, obj.mObjectID);
                            mGL.readBuffer(mGL.COLOR_ATTACHMENT0);
                            mGL.readPixels(0, 0, xres, yres, mGL.RGBA, mGL.FLOAT, data, 0);
                            mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                        };
    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piShading
//
//==============================================================================

function smoothstep(a, b, x)
{
    x = (x - a) / (b - a);
    if (x < 0) x = 0; else if (x > 1) x = 1;
    return x * x * (3.0 - 2.0 * x);
}

function clamp01(x)
{
    if( x < 0.0 ) x = 0.0;
    if( x > 1.0 ) x = 1.0;
    return x;
}

function clamp(x, a, b)
{
    if( x < a ) x = a;
    if( x > b ) x = b;
    return x;
}

function screen(a, b)
{
    return 1.0 - (1.0 - a) * (1.0 - b);
}

function parabola(x)
{
    return 4.0 * x * (1.0 - x);
}

function min(a, b)
{
    return (a < b) ? a : b;
}

function max(a, b)
{
    return (a > b) ? a : b;
}

function noise( x )
{
    function grad(i, j, x, y)
    {
        var h = 7 * i + 131 * j;
        h = (h << 13) ^ h;
        h = (h * (h * h * 15731 + 789221) + 1376312589);

        var rx = (h & 0x20000000) ? x : -x;
        var ry = (h & 0x10000000) ? y : -y;

        return rx + ry;
    }

    var i = [ Math.floor(x[0]), Math.floor(x[1]) ];
    var f = [ x[0] - i[0], x[1] - i[1] ];
    var w = [ f[0]*f[0]*(3.0-2.0*f[0]), f[1]*f[1]*(3.0-2.0*f[1]) ];

    var a = grad( i[0]+0, i[1]+0, f[0]+0.0, f[1]+0.0 );
    var b = grad( i[0]+1, i[1]+0, f[0]-1.0, f[1]+0.0 );
    var c = grad( i[0]+0, i[1]+1, f[0]+0.0, f[1]-1.0 );
    var d = grad( i[0]+1, i[1]+1, f[0]-1.0, f[1]-1.0 );

    return a + (b-a)*w[0] + (c-a)*w[1] + (a-b-c+d)*w[0]*w[1];
}//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piVecTypes
//
//==============================================================================


function vec3( a, b, c )
{
    return [ a, b, c ];
}

function add( a, b )
{
    return [ a[0]+b[0], a[1]+b[1], a[2]+b[2] ];
}

function sub( a, b )
{
    return [ a[0]-b[0], a[1]-b[1], a[2]-b[2] ];
}

function mul( a, s ) 
{
    return [ a[0]*s, a[1]*s, a[2]*s ];
}

function cross( a, b )
{
    return [ a[1]*b[2] - a[2]*b[1],
             a[2]*b[0] - a[0]*b[2],
             a[0]*b[1] - a[1]*b[0] ];
}

function dot( a, b ) 
{
    return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
}

function normalize( v ) 
{
    var is = 1.0 / Math.sqrt( v[0]*v[0] + v[1]*v[1] + v[2]*v[2] );
    return [ v[0]*is, v[1]*is, v[2]*is ];
}

function createCirclePoint( cen, uuu, vvv, rad, s, t )
{
    return [ cen[0] + rad*(uuu[0]*s + vvv[0]*t),
             cen[1] + rad*(uuu[1]*s + vvv[1]*t),
             cen[2] + rad*(uuu[2]*s + vvv[2]*t) ];
}

function createTangent( a, b, c )
{
    var cb = normalize( [ c[0]-b[0], c[1]-b[1], c[2]-b[2] ] );
    var ba = normalize( [ b[0]-a[0], b[1]-a[1], b[2]-a[2] ] );
    return normalize( [ ba[0]+cb[0], ba[1]+cb[1], ba[2]+cb[2] ] );

}

//===================================

function vec4( a, b, c, d )
{
    return [ a, b, c, d ];
}

function getXYZ( v )
{
    return [ v[0], v[1], v[2] ];
}

//===================================

function setIdentity()
{
    return [ 1.0, 0.0, 0.0, 0.0,
             0.0, 1.0, 0.0, 0.0,
             0.0, 0.0, 1.0, 0.0,
             0.0, 0.0, 0.0, 1.0 ];
}

function setRotationX( t )
{
    var sint = Math.sin(t);
    var cost = Math.cos(t);

    return [ 1.0,   0.0,   0.0, 0.0,
             0.0,  cost, -sint, 0.0, 
             0.0,  sint,  cost, 0.0,
             0.0,   0.0,   0.0, 1.0 ];
}

function setRotationY( t )
{
    var sint = Math.sin(t);
    var cost = Math.cos(t);

    return [ cost, 0.0, -sint, 0.0,
              0.0, 1.0,   0.0, 0.0, 
             sint, 0.0,  cost, 0.0,
              0.0, 0.0,   0.0, 1.0 ];
}

function extractRotationEuler( m)
{
    var res = [];
    if (m[0] == 1.0)
    {
        res[0] = Math.atan2(m[2], m[11]);
        res[1] = 0.0;
        res[2] = 0.0;

    }
    else if (m[0] == -1.0)
    {
        res[0] = Math.atan2( m[2], m[11]);
        res[1] = 0.0;
        res[2] = 0.0;
    }
    else
    {
        res[0] = Math.atan2( -m[9], m[10]);
        res[1] = Math.atan2( m[8], Math.sqrt(m[9]*m[9] + m[10]*m[10]));
        res[2] = Math.atan2( m[4], m[0]);
    }
    return res;
}

function setFromQuaternion( q )
{
    var ww = q[3]*q[3];
    var xx = q[0]*q[0];
    var yy = q[1]*q[1];
    var zz = q[2]*q[2];

    return [ ww+xx-yy-zz,                   2.0*(q[0]*q[1] - q[3]*q[2]), 2.0*(q[0]*q[2] + q[3]*q[1]), 0.0,
               2.0*(q[0]*q[1] + q[3]*q[2]),   ww-xx+yy-zz,                 2.0*(q[1]*q[2] - q[3]*q[0]), 0.0,
               2.0*(q[0]*q[2] - q[3]*q[1]),   2.0*(q[1]*q[2] + q[3]*q[0]), ww-xx-yy+zz,                 0.0,
               0.0,                           0.0,                         0.0,                         1.0 ];
}

function setPerspective( fovy, aspect, znear, zfar )
{
    var tan = Math.tan(fovy * Math.PI/180.0);
    var x = 1.0 / (tan*aspect);
    var y = 1.0 / (tan);
    var c = -(zfar + znear) / ( zfar - znear);
    var d = -(2.0 * zfar * znear) / (zfar - znear);

    return [ x,    0.0,  0.0,  0.0,
             0.0,  y,    0.0,  0.0,
             0.0,  0.0,  c,     d,
             0.0,  0.0, -1.0,  0.0 ];
}

function setLookAt( eye, tar, up )
{
    var dir = [ -tar[0]+eye[0], -tar[1]+eye[1], -tar[2]+eye[2] ];

	var m00 = dir[2]*up[1] - dir[1]*up[2]; 
    var m01 = dir[0]*up[2] - dir[2]*up[0];
    var m02 = dir[1]*up[0] - dir[0]*up[1];
    var im = 1.0/Math.sqrt( m00*m00 + m01*m01 + m02*m02 );
    m00 *= im;
    m01 *= im;
    m02 *= im;

	var m04 = m02*dir[1] - m01*dir[2]; 
    var m05 = m00*dir[2] - m02*dir[0];
    var m06 = m01*dir[0] - m00*dir[1];
    im = 1.0/Math.sqrt( m04*m04 + m05*m05 + m06*m06 );
    m04 *= im;
    m05 *= im;
    m06 *= im;

	var m08 = dir[0];
	var m09 = dir[1];
	var m10 = dir[2];
    im = 1.0/Math.sqrt( m08*m08 + m09*m09 + m10*m10 );
    m08 *= im;
    m09 *= im;
    m10 *= im;

	var m03 = -(m00*eye[0] + m01*eye[1] + m02*eye[2] );
	var m07 = -(m04*eye[0] + m05*eye[1] + m06*eye[2] );
	var m11 = -(m08*eye[0] + m09*eye[1] + m10*eye[2] );

    return [ m00, m01, m02, m03,
             m04, m05, m06, m07,
             m08, m09, m10, m11,
             0.0, 0.0, 0.0, 1.0 ];
}


function setOrtho( left, right, bottom, top, znear, zfar )
{
   var x = 2.0 / (right - left);
   var y = 2.0 / (top - bottom);
   var a = (right + left) / (right - left);
   var b = (top + bottom) / (top - bottom);
   var c = -2.0 / (zfar - znear);
   var d = -(zfar + znear) / ( zfar - znear);

   return [  x, 0.0, 0.0,   a,
           0.0,   y, 0.0,   b,
           0.0, 0.0,   c,   d,
           0.0, 0.0, 0.0, 1.0 ];
}

function setTranslation( p )
{
    return [ 1.0, 0.0, 0.0, p[0],
             0.0, 1.0, 0.0, p[1],
             0.0, 0.0, 1.0, p[2],
             0.0, 0.0, 0.0, 1.0 ];
}

function setScale( s )
{
    return [ s[0], 0.0,  0.0,  0.0,
             0.0,  s[1], 0.0,  0.0,
             0.0,  0.0,  s[2], 0.0,
             0.0,  0.0,  0.0,  1.0];
}

function setProjection( fov, znear, zfar )
{
    var x = 2.0 / (fov[3]+fov[2]);
    var y = 2.0 / (fov[0]+fov[1]);
    var a = (fov[3]-fov[2]) / (fov[3]+fov[2]);
    var b = (fov[0]-fov[1]) / (fov[0]+fov[1]);
    var c = -(zfar + znear) / ( zfar - znear);
    var d = -(2.0*zfar*znear) / (zfar - znear);
    return [   x, 0.0,    a, 0.0,
             0.0,   y,    b, 0.0,
             0.0, 0.0,    c,   d,
             0.0, 0.0, -1.0, 0.0 ];
   // inverse is:
   //return mat4x4( 1.0/x, 0.0f,  0.0f,   a/x,
   //               0.0f,  1.0/y, 0.0f,   b/x,
   //               0.0f,  0.0f,  0.0f,   -1.0,
   //               0.0f,  0.0f,  1.0f/d, c/d );
}


function invertFast( m )
{
    var inv = [
   
             m[5]  * m[10] * m[15] - 
             m[5]  * m[11] * m[14] - 
             m[9]  * m[6]  * m[15] + 
             m[9]  * m[7]  * m[14] +
             m[13] * m[6]  * m[11] - 
             m[13] * m[7]  * m[10],

             -m[1]  * m[10] * m[15] + 
              m[1]  * m[11] * m[14] + 
              m[9]  * m[2] * m[15] - 
              m[9]  * m[3] * m[14] - 
              m[13] * m[2] * m[11] + 
              m[13] * m[3] * m[10],

             m[1]  * m[6] * m[15] - 
             m[1]  * m[7] * m[14] - 
             m[5]  * m[2] * m[15] + 
             m[5]  * m[3] * m[14] + 
             m[13] * m[2] * m[7] - 
             m[13] * m[3] * m[6],

             -m[1] * m[6] * m[11] + 
              m[1] * m[7] * m[10] + 
              m[5] * m[2] * m[11] - 
              m[5] * m[3] * m[10] - 
              m[9] * m[2] * m[7] + 
              m[9] * m[3] * m[6],

             -m[4]  * m[10] * m[15] + 
              m[4]  * m[11] * m[14] + 
              m[8]  * m[6]  * m[15] - 
              m[8]  * m[7]  * m[14] - 
              m[12] * m[6]  * m[11] + 
              m[12] * m[7]  * m[10],

             m[0]  * m[10] * m[15] - 
             m[0]  * m[11] * m[14] - 
             m[8]  * m[2] * m[15] + 
             m[8]  * m[3] * m[14] + 
             m[12] * m[2] * m[11] - 
             m[12] * m[3] * m[10],

             -m[0]  * m[6] * m[15] + 
              m[0]  * m[7] * m[14] + 
              m[4]  * m[2] * m[15] - 
              m[4]  * m[3] * m[14] - 
              m[12] * m[2] * m[7] + 
              m[12] * m[3] * m[6],


             m[0] * m[6] * m[11] - 
             m[0] * m[7] * m[10] - 
             m[4] * m[2] * m[11] + 
             m[4] * m[3] * m[10] + 
             m[8] * m[2] * m[7] - 
             m[8] * m[3] * m[6],


             m[4]  * m[9] * m[15] - 
             m[4]  * m[11] * m[13] - 
             m[8]  * m[5] * m[15] + 
             m[8]  * m[7] * m[13] + 
             m[12] * m[5] * m[11] - 
             m[12] * m[7] * m[9],



             -m[0]  * m[9] * m[15] + 
              m[0]  * m[11] * m[13] + 
              m[8]  * m[1] * m[15] - 
              m[8]  * m[3] * m[13] - 
              m[12] * m[1] * m[11] + 
              m[12] * m[3] * m[9],

              m[0]  * m[5] * m[15] - 
              m[0]  * m[7] * m[13] - 
              m[4]  * m[1] * m[15] + 
              m[4]  * m[3] * m[13] + 
              m[12] * m[1] * m[7] - 
              m[12] * m[3] * m[5],

              -m[0] * m[5] * m[11] + 
               m[0] * m[7] * m[9] + 
               m[4] * m[1] * m[11] - 
               m[4] * m[3] * m[9] - 
               m[8] * m[1] * m[7] + 
               m[8] * m[3] * m[5],

              -m[4]  * m[9] * m[14] + 
               m[4]  * m[10] * m[13] +
               m[8]  * m[5] * m[14] - 
               m[8]  * m[6] * m[13] - 
               m[12] * m[5] * m[10] + 
               m[12] * m[6] * m[9],

              m[0]  * m[9] * m[14] - 
              m[0]  * m[10] * m[13] - 
              m[8]  * m[1] * m[14] + 
              m[8]  * m[2] * m[13] + 
              m[12] * m[1] * m[10] - 
              m[12] * m[2] * m[9],

              -m[0]  * m[5] * m[14] + 
               m[0]  * m[6] * m[13] + 
               m[4]  * m[1] * m[14] - 
               m[4]  * m[2] * m[13] - 
               m[12] * m[1] * m[6] + 
               m[12] * m[2] * m[5],

              m[0] * m[5] * m[10] - 
              m[0] * m[6] * m[9] - 
              m[4] * m[1] * m[10] + 
              m[4] * m[2] * m[9] + 
              m[8] * m[1] * m[6] - 
              m[8] * m[2] * m[5] ];

    var det = m[0] * inv[0] + m[1] * inv[4] + m[2] * inv[8] + m[3] * inv[12];

    det = 1.0/det;

    for( var i = 0; i<16; i++ ) inv[i] = inv[i] * det;

    return inv;
}

function matMul( a, b )
{
    var res = [];
    for( var i=0; i<4; i++ )
    {
        var x = a[4*i+0];
        var y = a[4*i+1];
        var z = a[4*i+2];
        var w = a[4*i+3];

        res[4*i+0] = x * b[ 0] + y * b[ 4] + z * b[ 8] + w * b[12];
        res[4*i+1] = x * b[ 1] + y * b[ 5] + z * b[ 9] + w * b[13];
        res[4*i+2] = x * b[ 2] + y * b[ 6] + z * b[10] + w * b[14];
        res[4*i+3] = x * b[ 3] + y * b[ 7] + z * b[11] + w * b[15];
    }

    return res;
}

function matMulpoint( m, v )
{
    return [ m[0]*v[0] + m[1]*v[1] + m[ 2]*v[2] + m[ 3],
             m[4]*v[0] + m[5]*v[1] + m[ 6]*v[2] + m[ 7],
             m[8]*v[0] + m[9]*v[1] + m[10]*v[2] + m[11] ];
}

function matMulvec( m, v )
{
    return [ m[0]*v[0] + m[1]*v[1] + m[ 2]*v[2],
             m[4]*v[0] + m[5]*v[1] + m[ 6]*v[2],
             m[8]*v[0] + m[9]*v[1] + m[10]*v[2] ];
}


function bound3( infi )
{
    return [ infi, -infi, infi, -infi, infi, -infi ];
}

function bound3_include( a, p )
{
    return [
        (p[0]<a[0]) ? p[0] : a[0],
        (p[0]>a[1]) ? p[0] : a[1],
        (p[1]<a[2]) ? p[1] : a[2],
        (p[1]>a[3]) ? p[1] : a[3],
        (p[2]<a[4]) ? p[2] : a[4],
        (p[2]>a[5]) ? p[2] : a[5] ];
}

function bound3_center( b )
{
    return [ 0.5*(b[0]+b[1]),
             0.5*(b[2]+b[3]),
             0.5*(b[4]+b[5]) ];
}

function bound3_radius( b )
{
    return [ 0.5*(b[1]-b[0]),
             0.5*(b[3]-b[2]),
             0.5*(b[5]-b[4]) ];
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piWebVR
//
//==============================================================================

function WebVR( isVREnabledCallback, canvasElement )
{
    isVREnabledCallback(false);
    /*


    this.mSupportVR = false;
    this.mHMD = null;

    var me = this;
    var listVRDisplays = function (vrdevs) {
        for (var i = 0; i < vrdevs.length; i++)
        {
            if (vrdevs[i] instanceof VRDisplay)
            {
                me.mHMD = vrdevs[i];
                console.log("WebVR is available.");
                console.log(me.mHMD);
                break;
            }
        }

        isVREnabledCallback(true);
        me.mSupportVR = true;
    }

    if (navigator.getVRDisplays)
    {
        navigator.getVRDisplays().then(listVRDisplays);
    }

    isVREnabledCallback(false);
    this.mCanvas = canvasElement;
    */
}

WebVR.prototype.IsSupported = function()
{
    return false;
    //return this.mSupportVR;
}

WebVR.prototype.GetData = function( id )
{
    return {};
    /*
    var frameData = new VRFrameData();
    var s = this.mHMD.getFrameData(frameData);
    var ss = frameData.pose;
    
    var fovL = this.mHMD.getEyeParameters("left");
    var fovR = this.mHMD.getEyeParameters( "right" );

    // camera info
    var cPos = vec3(0.0, 0.0, 0.0);
    if (ss.position)
        cPos = vec3(-ss.position[0], -ss.position[1], -ss.position[2]);
    var rot = vec4(0.0, 0.0, 0.0, 0.0);
    if (ss.orientation)
        rot = vec4(ss.orientation[0], ss.orientation[1], ss.orientation[2], ss.orientation[3]);
    var cRot = setFromQuaternion(rot);
    var cTra = setTranslation(cPos);
    var cMat = matMul(invertFast(cRot), cTra);
    
    // per eye info
    var lTra = setTranslation( vec3(-fovL.offset[0], -fovL.offset[1], -fovL.offset[2]) );
    var lMat = matMul(lTra, cMat);
    var lPrj = [ Math.tan( fovL.fieldOfView.upDegrees * Math.PI/180.0),
                 Math.tan(fovL.fieldOfView.downDegrees * Math.PI / 180.0),
                 Math.tan(fovL.fieldOfView.leftDegrees * Math.PI / 180.0),
                 Math.tan(fovL.fieldOfView.rightDegrees * Math.PI / 180.0)];

    var rTra = setTranslation(vec3(-fovR.offset[0], -fovR.offset[1], -fovR.offset[2]));
    var rMat = matMul(rTra, cMat);
    var rPrj = [Math.tan(fovR.fieldOfView.upDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.downDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.leftDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.rightDegrees * Math.PI / 180.0)];

    return {
        mCamera   : { mCamera: cMat },
        mLeftEye  : { mVP:[0,0,fovL.renderWidth,fovL.renderHeight], mProjection:lPrj, mCamera:lMat },
        mRightEye : { mVP:[fovR.renderWidth/2,0,fovR.renderWidth,fovR.renderHeight], mProjection:rPrj, mCamera:rMat }
           };
    */
}

WebVR.prototype.Enable = function( id )
{
    /*
    this.mHMD.requestPresent([{ source: this.mCanvas }]).then(
        function ()
        {
        },
        function (err)
        {
            console.log("webVR : requestPresent failed.");
        }
    );
    */
}

WebVR.prototype.Disable = function( id )
{
    /*
    if (!this.mHMD.isPresenting)
    {
        return;
    }

    this.mHMD.exitPresent().then(
        function ()
        {
        },
        function (err)
        {
            console.log("webVR : exitPresent failed.");
        }
    );
    */
}

WebVR.prototype.RequestAnimationFrame = function (id)
{
    //this.mHMD.requestAnimationFrame(id);
}

WebVR.prototype.IsPresenting = function (id)
{
    /*
    if (this.mHMD.isPresenting)
    {
        return true;
    }
    */
    return false;
}

WebVR.prototype.Finish = function (id)
{
    /*
    if (this.mHMD.isPresenting)
    {
        this.mHMD.submitFrame();
    }
    */
}

//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piWebUtils
//
//==============================================================================


// RequestAnimationFrame
window.requestAnimFrame = ( function () { return window.requestAnimationFrame    || window.webkitRequestAnimationFrame ||
                                                 window.mozRequestAnimationFrame || window.oRequestAnimationFrame ||
                                                 window.msRequestAnimationFrame  || function( cb ) { window.setTimeout(cb,1000/60); };
                                        } )();

// performance.now
window.getRealTime = ( function() { if ("performance" in window ) return function() { return window.performance.now(); }
                                                                  return function() { return (new Date()).getTime(); }
                                  } )();

window.URL = window.URL || window.webkitURL;

navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;

function htmlEntities(str) 
{
    return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g,'&apos;');
}

function piDisableTouch()
{
    document.body.addEventListener('touchstart', function(e){ e.preventDefault(); });
}

var piGetTime = function ( timestamp )
{
    if (timestamp == 0)
        return "";
    return new Date(timestamp * 1000).toISOString().substr(0, 10);
}

function piGetCoords( obj )
{
    var x = 0;
    var y = 0; 
    do
    {
         x += obj.offsetLeft;
         y += obj.offsetTop;
    }while( obj = obj.offsetParent );

    return { mX:x, mY:y };
}

function piGetMouseCoords( ev, canvasElement )
{
    var pos = piGetCoords(canvasElement );
    var mcx =                        (ev.pageX - pos.mX) * canvasElement.width / canvasElement.offsetWidth;
    var mcy = canvasElement.height - (ev.pageY - pos.mY) * canvasElement.height / canvasElement.offsetHeight;

    return { mX: mcx, mY: mcy };

}

function piGetSourceElement( e )
{
    var ele = null;
    if( e.target )     ele = e.target;
    if( e.srcElement ) ele = e.srcElement;
    return ele;
}

function piRequestFullScreen( ele )
{
    if( ele==null ) ele =   document.documentElement;
         if( ele.requestFullscreen       ) ele.requestFullscreen();
    else if( ele.msRequestFullscreen     ) ele.msRequestFullscreen();
    else if( ele.mozRequestFullScreen    ) ele.mozRequestFullScreen();
    else if( ele.webkitRequestFullscreen ) ele.webkitRequestFullscreen( Element.ALLOW_KEYBOARD_INPUT );
}

function piIsFullScreen()
{
    return document.fullscreen || document.mozFullScreen || document.webkitIsFullScreen || document.msFullscreenElement || false;
}

function piExitFullScreen()
{
       if( document.exitFullscreen       ) document.exitFullscreen();
  else if( document.msExitFullscreen     ) document.msExitFullscreen();
  else if( document.mozCancelFullScreen  ) document.mozCancelFullScreen();
  else if( document.webkitExitFullscreen ) document.webkitExitFullscreen();
}

function piIsMobile()
{
    return (navigator.userAgent.match(/Android/i) ||
            navigator.userAgent.match(/webOS/i) ||
            navigator.userAgent.match(/iPhone/i) ||
            navigator.userAgent.match(/iPad/i) ||
            navigator.userAgent.match(/iPod/i) ||
            navigator.userAgent.match(/BlackBerry/i) ||
            navigator.userAgent.match(/Windows Phone/i)) ? true : false;
}

function piCreateGlContext( cv, useAlpha, useDepth, usePreserveBuffer, useSupersampling )
{
    var opts = { alpha: useAlpha, 
                 depth: useDepth, 
                 stencil: false, 
                 premultipliedAlpha: false, 
                 antialias: useSupersampling, 
                 preserveDrawingBuffer: usePreserveBuffer, 
                 powerPreference: "high-performance" }; // "low_power", "high_performance", "default"

    var gl = null;
    if( gl === null) gl = cv.getContext( "webgl2", opts );
    if( gl === null) gl = cv.getContext( "experimental-webgl2", opts );
    if( gl === null) gl = cv.getContext( "webgl", opts );
    if( gl === null) gl = cv.getContext( "experimental-webgl", opts );

    return gl;
}

function piCreateAudioContext()
{
    var res = null;
    try
    {
        if( window.AudioContext ) res = new AudioContext();
        if( res==null && window.webkitAudioContext ) res = new webkitAudioContext();
    }
    catch( e )
    {
        res = null;
    }
    return res;
}

function piHexColorToRGB(str) // "#ff3041"
{
    var rgb = parseInt(str.slice(1), 16);
    var r = (rgb >> 16) & 255;
    var g = (rgb >> 8) & 255;
    var b = (rgb >> 0) & 255;
    return [r, g, b];
}

function piCreateFPSCounter()
{
    var mFrame;
    var mTo;
    var mFPS;

    var iReset = function( time )
    {
        mFrame = 0;
        mTo = time;
        mFPS = 60.0;
    }

    var iCount = function( time )
    {
        mFrame++;

        if( (time-mTo)>500.0 )
        {
            mFPS = 1000.0*mFrame/(time-mTo);
            mFrame = 0;
            mTo = time;
            return true;
        }
        return false;
    }

    var iGetFPS = function()
    {
        return mFPS;
    }
    
    return { Reset : iReset, Count : iCount, GetFPS : iGetFPS };
}

function piCanMediaRecorded(canvas)
{
    if (typeof window.MediaRecorder !== 'function' || typeof canvas.captureStream !== 'function') {
        return false;
    }
    return true;
}

function piCreateMediaRecorder(isRecordingCallback, canvas) 
{
    if (piCanMediaRecorded(canvas) == false)
    {
        return null;
    }
    
    var options = { audioBitsPerSecond : 0, videoBitsPerSecond : 8000000 }; 
	     if (MediaRecorder.isTypeSupported('video/webm;codecs=h264')) options.mimeType = 'video/webm;codecs=h264';
    else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9' )) options.mimeType = 'video/webm;codecs=vp9';
    else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8' )) options.mimeType = 'video/webm;codecs=vp8';
    else                                                              options.mimeType = 'video/webm;';

    var mediaRecorder = new MediaRecorder(canvas.captureStream(), options);
    var chunks = [];
    
    mediaRecorder.ondataavailable = function(e) 
    {
        if (e.data.size > 0) 
        {
            chunks.push(e.data);
        }
    };
 
    mediaRecorder.onstart = function(){ 
        isRecordingCallback( true );
    };
    
    mediaRecorder.onstop = function()
    {
         isRecordingCallback( false );
         let blob     = new Blob(chunks, {type: "video/webm"});
         chunks       = [];
         let videoURL = window.URL.createObjectURL(blob);
         let url      = window.URL.createObjectURL(blob);
         let a        = document.createElement("a");
         document.body.appendChild(a);
         a.style      = "display: none";
         a.href       = url;
         a.download   = "capture.webm";
         a.click();
         window.URL.revokeObjectURL(url);
     };
    
    return mediaRecorder;
}

function piExportToEXR(width, height, numComponents, type, bytes)
{
    var bytesPerComponent = 0;
    if      (type=="Uint")   bytesPerComponent = 4; 
    else if (type=="Half")   bytesPerComponent = 2;
    else if (type=="Float")  bytesPerComponent = 4;

    var tHeader = 258 + (18 * numComponents + 1);
    var tTable = 8 * height;
    var tScanlines = height * (4 + 4 + (numComponents * bytesPerComponent * width));
    var tTotal = tHeader + tTable + tScanlines;

    //console.log("    header size = " + tHeader);
    //console.log("    table size = " + tTable);
    //console.log("    scanlines size = " + tScanlines);
    //console.log("    total = " + tTotal);

    var buffer = new ArrayBuffer(tTotal); 
    var data = new DataView(buffer);

    // Header
    {
        // Header : 4 bytes -> 0x76, 0x2f, 0x31, 0x01
        var c = 0;
        data.setUint8 (c++, 0x76);
        data.setUint8 (c++, 0x2f);
        data.setUint8 (c++, 0x31);
        data.setUint8 (c++, 0x01);

        // Version : 4 bytes -> 2, 0, 0, 0
        data.setUint8 (c++, 0x02);
        data.setUint8 (c++, 0x0);
        data.setUint8 (c++, 0x0);
        data.setUint8 (c++, 0x0);
        
        // Write channel info
        // Write attribute name : "channels"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x73);
            data.setUint8 (c++, 0x0);

            // Write attribute type : "chlist"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00);

            // Write attribute size : 18 x 3 + 1 = 55
            var attribSize = 18 * numComponents + 1;
            data.setUint8 (c++, attribSize); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            var i;
            for (i = 0; i < numComponents; i++)
            {
                // Attribute : "B" (42) "G" (47) "R" (52)
                if (i==0)       data.setUint8 (c++, 0x42);
                else if (i==1)  data.setUint8 (c++, 0x47);
                else if (i==2)  data.setUint8 (c++, 0x52);
                data.setUint8 (c++, 0x00);
                
                // Value : Float (2), Half (1), Uint (0)
                if      (type=="Uint")   data.setUint8 (c++, 0x00); 
                else if (type=="Half")   data.setUint8 (c++, 0x01);
                else if (type=="Float")  data.setUint8 (c++, 0x02);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);

                // Plinear
                data.setUint8 (c++, 0x01);

                // Reserved
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 

                // X sampling
                data.setUint8 (c++, 0x01); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                
                // Y sampling
                data.setUint8 (c++, 0x01);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
            }
            // End attribute
            data.setUint8 (c++, 0x00);
    
        // Write attribute name : "compression"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6d); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x00);

            // Write attribute type : "compression"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6d); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x00);

            // Write attribute size : "1"
            data.setUint8 (c++, 0x01); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // Write attribute value : "0" (None)
            data.setUint8 (c++, 0x00);

        // datawindow
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x00); 

            // box2i
            data.setUint8 (c++, 0x62); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x00);

            // size 16
            data.setUint8 (c++, 0x10); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0 3 2
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 

            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint32 (c, width-1, true);
            c += 4;
            
            data.setUint32 (c, height-1, true); 
            c += 4;

        // displayWindow
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x79); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x00);

            // box2i
            data.setUint8 (c++, 0x62); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x00); 

            // size 16
            data.setUint8 (c++, 0x10); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0 3 2
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint32 (c, width-1, true);
            c += 4;
            
            data.setUint32 (c, height-1, true); 
            c += 4;

        // lineOrder
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x4f); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00); 
            
            // lineOrder
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x4f); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00); 
            
            // size
            data.setUint8 (c++, 0x01);
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);
            
            // value 
            data.setUint8 (c++, 0x00);

        // PixelAspectRatio
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x41); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x52); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x00); 

            // float
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00);
        
            // size 4
            data.setUint8 (c++, 0x04); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 1.0
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x80); 
            data.setUint8 (c++, 0x3f);
        
        // screenWindowCenter
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x63);
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x43); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e);
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00);

            // v2f
            data.setUint8 (c++, 0x76); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x00);

            // size 8
            data.setUint8 (c++, 0x08); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

        // screenWindowWidth
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x00); 
            
            // float
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00); 

            // size
            data.setUint8 (c++, 0x04); 
            data.setUint8 (c++, 0x00);
            data.setUint8 (c++, 0x00);
            data.setUint8 (c++, 0x00);

            // value
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x80); 
            data.setUint8 (c++, 0x3f);

        // End of header
        data.setUint8 (c++, 0x00);
    }
    //console.log("header size = " + c);

    // Scanline table
    var initc = c + height * 8;
    for (var scanline = 0 ; scanline < height ; scanline ++)
    {
        var jump = initc + scanline * (8 + width * bytesPerComponent * numComponents); 
        data.setUint32 (c, jump, true);
        c += 4; 

        data.setUint32 (c, 0x00, true);
        c += 4;
    }
    //console.log("header + scanlines table size = " + c);

    // Scanlines
    for (var scanline = 0 ; scanline < height ; scanline ++)
    {
        // Scanline
        data.setUint32(c, scanline, true);
        c += 4;

        // size 24
        var size = width * numComponents * bytesPerComponent; 
        data.setUint32(c, size, true);
        c += 4;

        var numComponentsSource = 4; // number of components in the SOURCE image
        for (var component = 0; component < numComponents ; component ++) 
        {
            for (var pixel = 0 ; pixel < width ; pixel ++) 
            {
                // flip vertical, so we read OpenGL buffers without JS image flipping
                var v = bytes[(height-1-scanline) * width *numComponentsSource + pixel * numComponentsSource + (2-component)];
                if      (type=="Float") data.setFloat32(c, v, true);
                else if (type=="Half")  data.setUint16(c, v, true);

                c += bytesPerComponent;
            }
        }
    }
    //console.log("total size = " + c);
    return new Blob([buffer], {type: 'application/octet-stream'});
}


function piExportToWAV(numSamples, rate, bits, numChannels, words)
{
    let numBytes = numSamples * numChannels * bits/8;

    let buffer = new ArrayBuffer(44 + numBytes); 
    let data = new DataView(buffer);

    {
        data.setUint32( 0, 0x46464952, true );  // RIFF
        data.setUint32( 4, numBytes + 36, true);
        {
            data.setUint32( 8, 0x45564157, true );  // WAV_WAVE
            data.setUint32( 12, 0x20746D66, true );  // WAV_FMT
            {
                data.setUint32( 16, 16, true);
                data.setUint16( 20, 1, true ); // WAV_FORMAT_PCM
                data.setUint16( 22, numChannels, true);
                data.setUint32( 24, rate, true);
                data.setUint32( 28, rate*numChannels*bits / 8, true);
                data.setUint16( 32, numChannels*bits / 8, true);
                data.setUint16( 34, bits, true);
            }

            data.setUint32( 36, 0x61746164, true);  // WAV_DATA
            {
                data.setUint32( 40, numBytes, true);
                let numWords = numSamples * numChannels;
                for(let i=0; i<numWords; i++ )
                {
                    data.setInt16( 44 + i*2, words[i], true );
                }
            }
        }
    }


    //console.log("total size = " + c);
    return new Blob([buffer], {type: 'application/octet-stream'});
}

function piTriggerDownload(name, blob)
{
    let url = URL.createObjectURL(blob);
    let aElement = document.createElement("a");
    aElement.href     = url;
    aElement.target   = "_self";
    aElement.download = name;
    document.body.appendChild(aElement);
    aElement.click();
    document.body.removeChild(aElement);
}</script>
    <script>"use strict"

function bufferID_to_assetID( id )
{
    if( id===0 ) return '4dXGR8';
    if( id===1 ) return 'XsXGR8';
    if( id===2 ) return '4sXGR8';
    if( id===3 ) return 'XdfGR8';
    return 'none';
}
function assetID_to_bufferID( id )
{
    if( id==='4dXGR8' ) return 0;
    if( id==='XsXGR8' ) return 1;
    if( id==='4sXGR8' ) return 2;
    if( id==='XdfGR8' ) return 3;
    return -1;
}

function assetID_to_cubemapBuferID( id )
{
    if( id==='4dX3Rr' ) return 0;
    return -1;
}
function cubamepBufferID_to_assetID( id )
{
    if( id===0 ) return '4dX3Rr';
    return 'none';
}

function EffectPass( renderer, is20, isLowEnd, hasShaderTextureLOD, callback, obj, forceMuted, forcePaused, outputGainNode, copyProgram, id, effect  )
{
    this.mID = id;
    this.mInputs  = [null, null, null, null ];
    this.mOutputs = [null, null, null, null ];
    this.mSource = null;

    this.mGainNode = outputGainNode;
    this.mSoundShaderCompiled = false;

    this.mEffect = effect;
    this.mRenderer = renderer;
    this.mProgramCopy = copyProgram; 
    this.mCompilationTime = 0;

    this.mType = "none";
    this.mName = "none";
    this.mFrame = 0;

    this.mShaderTextureLOD = hasShaderTextureLOD;
    this.mIs20 = is20;
    this.mIsLowEnd = isLowEnd;
    this.mTextureCallbackFun = callback;
    this.mTextureCallbackObj = obj;
    this.mForceMuted = forceMuted;
    this.mForcePaused = forcePaused;
}

EffectPass.prototype.MakeHeader_Image = function()
{
    let header = "";

    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for( let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        // old API
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                  header += "uniform sampler2D iChannel" + i + ";\n";

        // new API (see shadertoy.com/view/wtdGW8)
        header += "uniform struct {\n";
             if( inp===null )                  header += "  sampler2D";
        else if( inp.mInfo.mType==="cubemap" ) header += "  samplerCube";
        else if( inp.mInfo.mType==="volume"  ) header += "  sampler3D";
        else                                  header += "  sampler2D";
        header +=        " sampler;\n";
        header += "  vec3  size;\n";
        header += "  float time;\n";
        header += "  int   loaded;\n";
        header += "}iCh" + i + ";\n";
    }
	header += "void mainImage( out vec4 c, in vec2 f );\n";
    header += "void st_assert( bool cond );\n";
    header += "void st_assert( bool cond, int v );\n";

    if( this.mIs20 ) 
    {
        header += "\nout vec4 shadertoy_out_color;\n" +
        "void st_assert( bool cond, int v ) {if(!cond){if(v==0)shadertoy_out_color.x=-1.0;else if(v==1)shadertoy_out_color.y=-1.0;else if(v==2)shadertoy_out_color.z=-1.0;else shadertoy_out_color.w=-1.0;}}\n" +
        "void st_assert( bool cond        ) {if(!cond)shadertoy_out_color.x=-1.0;}\n" +
        "void main( void )" +
        "{" +
            "shadertoy_out_color = vec4(1.0,1.0,1.0,1.0);" + 
            "vec4 color = vec4(0.0,0.0,0.0,1.0);" +
            "mainImage( color, gl_FragCoord.xy );" +
            "if(shadertoy_out_color.x<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(shadertoy_out_color.y<0.0) color=vec4(0.0,1.0,0.0,1.0);" +
            "if(shadertoy_out_color.z<0.0) color=vec4(0.0,0.0,1.0,1.0);" +
            "if(shadertoy_out_color.w<0.0) color=vec4(1.0,1.0,0.0,1.0);" +
            "shadertoy_out_color = vec4(color.xyz,1.0);" +
        "}";
    }
    else
    {
        header += "" +
        "void st_assert( bool cond, int v ) {if(!cond){if(v==0)gl_FragColor.x=-1.0;else if(v==1)gl_FragColor.y=-1.0;else if(v==2)gl_FragColor.z=-1.0;else gl_FragColor.w=-1.0;}}\n" +
        "void st_assert( bool cond        ) {if(!cond)gl_FragColor.x=-1.0;}\n" +
        "void main( void )" +
        "{" +
            "gl_FragColor = vec4(0.0,0.0,0.0,1.0);" + 
            "vec4 color = vec4(0.0,0.0,0.0,1.0);" +
            "mainImage( color, gl_FragCoord.xy );" +
            "color.w = 1.0;" +
            "if(gl_FragColor.w<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(gl_FragColor.x<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(gl_FragColor.y<0.0) color=vec4(0.0,1.0,0.0,1.0);" +
            "if(gl_FragColor.z<0.0) color=vec4(0.0,0.0,1.0,1.0);" +
            "if(gl_FragColor.w<0.0) color=vec4(1.0,1.0,0.0,1.0);" +
            "gl_FragColor = vec4(color.xyz,1.0);"+
        "}";
    }
    header += "\n";

    /*
    this.mImagePassFooterVR = "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 ) 
        this.mImagePassFooterVR += "\nout vec4 outColor;\n";
    this.mImagePassFooterVR += "void main( void )" +
    "{" +
        "vec4 color = vec4(0.0,0.0,0.0,1.0);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainVR( color, gl_FragCoord.xy-unViewport.xy, ro, rd );" +
        "color.w = 1.0;"
    if( this.mIs20 ) 
        this.mImagePassFooterVR +=  "outColor = color;}";
    else
        this.mImagePassFooterVR +=  "gl_FragColor = color;}";
    */
    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Buffer = function()
{
    let header = "";
    
    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                  header += "uniform sampler2D iChannel" + i + ";\n";
    }

	header += "void mainImage( out vec4 c,  in vec2 f );\n"

    if( this.mIs20 )
        header += "\nout vec4 outColor;\n";
    header += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(0.0,0.0,0.0,1.0);" +
        "mainImage( color, gl_FragCoord.xy );";
    if( this.mIs20 )
        header +="outColor = color; }";
    else
        header +="gl_FragColor = color; }";
    header += "\n";

    /*
    this.mImagePassFooterVR = "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 )
    this.mImagePassFooterVR += "\nout vec4 outColor;\n";
    this.mImagePassFooterVR += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(0.0,0.0,0.0,1.0);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainVR( color, gl_FragCoord.xy-unViewport.xy, ro, rd );";
    if( this.mIs20 )
        this.mImagePassFooterVR +="outColor = color; }";
    else
        this.mImagePassFooterVR +="gl_FragColor = color; }";
    */
    this.mHeader = header;
    this.mHeaderLength = 0;
}


EffectPass.prototype.MakeHeader_Cubemap = function()
{
    let header = "";
    
    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                   header += "uniform sampler2D iChannel" + i + ";\n";
    }

	header += "void mainCubemap( out vec4 c, in vec2 f, in vec3 ro, in vec3 rd );\n"

    header += "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 )
        header += "\nout vec4 outColor;\n";
    header += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(0.0,0.0,0.0,1.0);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainCubemap( color, gl_FragCoord.xy-unViewport.xy, ro, rd );";
    if( this.mIs20 )
        header +="outColor = color; }";
    else
        header +="gl_FragColor = color; }";
    header += "\n";

    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Sound = function()
{
    let header = "";

    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform float     iChannelTime[4];\n" +
              "uniform float     iTimeOffset;\n" +
              "uniform int       iSampleOffset;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n";

    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp!==null && inp.mInfo.mType==="cubemap" )
            header += "uniform samplerCube iChannel" + i + ";\n";
        else
            header += "uniform sampler2D iChannel" + i + ";\n";
    }
    header += "\n";
    header += "vec2 mainSound( in int samp, float time );\n";

    if( this.mIs20 )
    {
        header += "out vec4 outColor; void main()" +
            "{" +
            "float t = iTimeOffset + ((gl_FragCoord.x-0.5) + (gl_FragCoord.y-0.5)*512.0)/iSampleRate;" +
            "int   s = iSampleOffset + int(gl_FragCoord.y-0.2)*512 + int(gl_FragCoord.x-0.2);" +
            "vec2 y = mainSound( s, t );" +
            "vec2 v  = floor((0.5+0.5*y)*65536.0);" +
            "vec2 vl =   mod(v,256.0)/255.0;" +
            "vec2 vh = floor(v/256.0)/255.0;" +
            "outColor = vec4(vl.x,vh.x,vl.y,vh.y);" +
            "}";
    }
    else
    {
        header += "void main()" +
            "{" +
            "float t = iTimeOffset + ((gl_FragCoord.x-0.5) + (gl_FragCoord.y-0.5)*512.0)/iSampleRate;" +
            "vec2 y = mainSound( 0, t );" +
            "vec2 v  = floor((0.5+0.5*y)*65536.0);" +
            "vec2 vl =   mod(v,256.0)/255.0;" +
            "vec2 vh = floor(v/256.0)/255.0;" +
            "gl_FragColor = vec4(vl.x,vh.x,vl.y,vh.y);" +
            "}";
    }
    header += "\n";
    this.mHeader = header;
    this.mHeaderLength = 0;
}


EffectPass.prototype.MakeHeader_Common = function ()
{
    let header = "";
    let headerlength = 0;

    header += "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n";
    headerlength += 2;

    if (this.mIs20)
    {
        header += "out vec4 outColor;\n";
        headerlength += 1;
    }
    header += "void main( void )\n";
    headerlength += 1;

    if (this.mIs20)
        header += "{ outColor = vec4(0.0); }";
    else
        header += "{ gl_FragColor = vec4(0.0); }";
    headerlength += 1;
    header += "\n";
    headerlength += 1;

    this.mHeader = header;
    this.mHeaderLength = headerlength;
}

EffectPass.prototype.MakeHeader = function()
{
         if( this.mType==="image" ) this.MakeHeader_Image();
    else if( this.mType==="sound" ) this.MakeHeader_Sound();
    else if( this.mType==="buffer") this.MakeHeader_Buffer();
    else if( this.mType==="common") this.MakeHeader_Common();
    else if( this.mType==="cubemap") this.MakeHeader_Cubemap();
    else console.log("ERROR 4");
}

EffectPass.prototype.Create_Image = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mSupportsVR = false;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    //this.mProgramVR = null;
}
EffectPass.prototype.Destroy_Image = function( wa )
{
}

EffectPass.prototype.Create_Buffer = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mSupportsVR = false;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    //this.mProgramVR = null;
}

EffectPass.prototype.Destroy_Buffer = function( wa )
{
}

EffectPass.prototype.Create_Cubemap = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
}

EffectPass.prototype.Destroy_Cubemap = function( wa )
{
}

EffectPass.prototype.Create_Common = function( wa )
{
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.MakeHeader();
}
EffectPass.prototype.Destroy_Common = function( wa )
{
}

EffectPass.prototype.Create_Sound = function (wa)
{
    this.MakeHeader();


    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    this.mSampleRate = 44100;
    this.mPlayTime = 60*3;
    this.mPlaySamples = this.mPlayTime*this.mSampleRate;
    this.mBuffer = wa.createBuffer( 2, this.mPlaySamples, this.mSampleRate );

    //-------------------
    this.mTextureDimensions = 512;
    this.mRenderTexture = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D, 
                                                       this.mTextureDimensions, this.mTextureDimensions,
                                                       this.mRenderer.TEXFMT.C4I8,
                                                       this.mRenderer.FILTER.NONE,
                                                       this.mRenderer.TEXWRP.CLAMP, null);
    this.mRenderFBO = this.mRenderer.CreateRenderTarget(this.mRenderTexture, null, null, null, null, false);

    //-----------------------------

    // ArrayBufferView pixels;
    this.mTmpBufferSamples = this.mTextureDimensions*this.mTextureDimensions;
    this.mData = new Uint8Array( this.mTmpBufferSamples*4 );

    this.mPlaying = false;
}

EffectPass.prototype.Destroy_Sound = function( wa )
{
    if( this.mPlayNode!==null ) this.mPlayNode.stop();
    this.mPlayNode = null;
    this.mBuffer = null;
    this.mData = null;

    this.mRenderer.DestroyRenderTarget(this.mRenderFBO);
    this.mRenderer.DestroyTexture(this.mRenderTexture);
}

EffectPass.prototype.Create = function( passType, wa )
{
    this.mType = passType;
    this.mSource = null;

         if( passType==="image" ) this.Create_Image( wa );
    else if( passType==="sound" ) this.Create_Sound( wa );
    else if( passType==="buffer") this.Create_Buffer( wa );
    else if( passType==="common") this.Create_Common( wa );
    else if( passType==="cubemap") this.Create_Cubemap( wa );
    else alert("ERROR 1");
}

EffectPass.prototype.SetName = function (passName)
{
    this.mName = passName;
}

EffectPass.prototype.SetCode = function (src)
{
    this.mSource = src;
}

EffectPass.prototype.Destroy = function( wa )
{
    this.mSource = null;
         if( this.mType==="image" ) this.Destroy_Image( wa );
    else if( this.mType==="sound" ) this.Destroy_Sound( wa );
    else if( this.mType==="buffer") this.Destroy_Buffer( wa );
    else if( this.mType==="common") this.Destroy_Common( wa );
    else if( this.mType==="cubemap") this.Destroy_Cubemap( wa );
    else alert("ERROR 2");
}

EffectPass.prototype.NewShader_Sound = function( shaderCode, commonShaderCodes)
{
    let vsSource = null;

    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for( let i=0; i<commonShaderCodes.length; i++ )
    {
        fsSource += commonShaderCodes[i]+'\n';
    }
    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;
    fsSource += shaderCode;

    this.mSoundShaderCompiled = false;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader_Image = function ( shaderCode, commonShaderCodes )
{
    this.mSupportsVR = false;


    let vsSource = null;
    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for (let i = 0; i < commonShaderCodes.length; i++)
    {
        fsSource += commonShaderCodes[i]+'\n';
    }
    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;
    fsSource += shaderCode;

    return [vsSource, fsSource];


    /*
    let n1 = shaderCode.indexOf("mainVR(");
    let n2 = shaderCode.indexOf("mainVR (");
    let n3 = shaderCode.indexOf("mainVR  (");
    if( n1>0 || n2>0 || n3>0 )
    {
        let vsSourceVR;
        if( this.mIs20 )
            vsSourceVR = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        else
            vsSourceVR = "attribute in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

        let fsSourceVR = this.mHeader;
        for (let i = 0; i < commonShaderCodes.length; i++) {
            fsSourceVR += commonShaderCodes[i];
        }
        fsSourceVR += shaderCode;
        fsSourceVR += this.mImagePassFooterVR;

        let res = this.mRenderer.CreateShader(vsSource, fsSourceVR, preventCache);
        if( res.mResult == false )
        {
            return res.mInfo;
        }
        if( this.mProgramVR != null )
            this.mRenderer.DestroyShader( this.mProgramVR );

        this.mSupportsVR = true;
        this.mProgramVR = res;
    }
    */
}

EffectPass.prototype.NewShader_Cubemap = function( shaderCode, commonShaderCodes )
{
    let vsSource = null;
    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for (let i = 0; i < commonShaderCodes.length; i++)
    {
        fsSource += commonShaderCodes[i]+'\n';
    }

    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;

    fsSource += shaderCode;

    return [vsSource, fsSource];
}


EffectPass.prototype.NewShader_Common = function (shaderCode )
{
    let vsSource = null;
    if (this.mIs20)
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader + shaderCode;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader = function ( commonSourceCodes, preventCache, onResolve)
{
    if( this.mRenderer===null ) return;

    let vs_fs = null;

         if( this.mType==="sound"  ) vs_fs = this.NewShader_Sound(   this.mSource, commonSourceCodes );
    else if( this.mType==="image"  ) vs_fs = this.NewShader_Image(   this.mSource, commonSourceCodes );
    else if( this.mType==="buffer" ) vs_fs = this.NewShader_Image(   this.mSource, commonSourceCodes );
    else if( this.mType==="common" ) vs_fs = this.NewShader_Common(  this.mSource,                   );
    else if( this.mType==="cubemap") vs_fs = this.NewShader_Cubemap( this.mSource, commonSourceCodes );
    else { console.log("ERROR 3: \"" + this.mType + "\""); return; }

    let me = this;
    this.mRenderer.CreateShader(vs_fs[0], vs_fs[1], preventCache, false,
        function (worked, info)
        {
            if (worked === true)
            {
                if (me.mType === "sound")
                {
                    me.mSoundShaderCompiled = true;
                }

                me.mCompilationTime = info.mTime;
                me.mError = false;
                me.mErrorStr = "No Errors";
                if (me.mProgram !== null)
                    me.mRenderer.DestroyShader(me.mProgram);
                me.mTranslatedSource = me.mRenderer.GetTranslatedShaderSource(info);
                me.mProgram = info;
            }
            else
            {
                me.mError = true;
                me.mErrorStr = info.mErrorStr;
            }
            onResolve();
        });
}

EffectPass.prototype.DestroyInput = function( id )
{
    if( this.mInputs[id]===null ) return;

    if( this.mInputs[id].mInfo.mType==="texture" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    if( this.mInputs[id].mInfo.mType==="volume" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="webcam" )
    {
        this.mInputs[id].video.pause();
        this.mInputs[id].video.src = "";

        if( this.mInputs[id].video.srcObject!==null )
        {
        let tracks = this.mInputs[id].video.srcObject.getVideoTracks();
        if( tracks ) tracks[0].stop();
        }
        this.mInputs[id].video = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="video" )
    {
        this.mInputs[id].video.pause();
        this.mInputs[id].video = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="music" || this.mInputs[id].mInfo.mType==="musicstream")
    {
        this.mInputs[id].audio.pause();
        this.mInputs[id].audio.mSound.mFreqData = null;
        this.mInputs[id].audio.mSound.mWaveData = null;
        this.mInputs[id].audio = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="cubemap" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="keyboard" )
    {
        //if( this.mInputs[id].globject != null )
          //  this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="mic" )
    {
        this.mInputs[id].mic = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }

    this.mInputs[id] = null;
}

EffectPass.prototype.TooglePauseInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused )
        {
            inp.video.play();
            inp.video.mPaused = false;
        }
        else
        {
            inp.video.pause();
            inp.video.mPaused = true;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        wa.resume()
        if( inp.audio.mPaused )
        {
            if( inp.loaded )
            {
                inp.audio.play();
            }
            inp.audio.mPaused = false;
        }
        else
        {
            inp.audio.pause();
            inp.audio.mPaused = true;
        }
        return inp.audio.mPaused;
    }

    return null;
}

EffectPass.prototype.StopInput = function( id )
{
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused === false )
        {
            inp.video.pause();
            inp.video.mPaused = true;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
    {
        if( inp.audio.mPaused === false )
        {
            inp.audio.pause();
            inp.audio.mPaused = true;
        }
        return inp.audio.mPaused;
    }
    return null;
}

EffectPass.prototype.ResumeInput = function( id )
{
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused )
        {
            inp.video.play();
            inp.video.mPaused = false;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
    {
        if( inp.audio.mPaused )
        {
            inp.audio.play();
            inp.audio.mPaused = false;
        }
        return inp.audio.mPaused;
    }
    return null;
}

EffectPass.prototype.RewindInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];

    if( inp==null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.loaded )
        {
            inp.video.currentTime = 0;
        }
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        wa.resume()
        if( inp.loaded )
        {
            inp.audio.currentTime = 0;
        }
    }
}

EffectPass.prototype.MuteInput = function( wa, id )
{
    let inp = this.mInputs[id];
    if( inp===null ) return;

    if( inp.mInfo.mType==="video" )
    {
        inp.video.muted = true;
        inp.video.mMuted = true;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if (wa !== null) inp.audio.mSound.mGain.gain.value = 0.0;
        inp.audio.mMuted = true;
    }
}

EffectPass.prototype.UnMuteInput = function( wa, id )
{
    let inp = this.mInputs[id];
    if( inp===null ) return;

    if( inp.mInfo.mType==="video" )
    {
        inp.video.muted = false;
        inp.video.mMuted = false;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if (wa !== null) inp.audio.mSound.mGain.gain.value = 1.0;
        inp.audio.mMuted = false;
    }
}

EffectPass.prototype.ToggleMuteInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];
    if( inp===null ) return null;

    if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mMuted ) this.UnMuteInput(wa,id);
        else                   this.MuteInput(wa,id);
        return inp.video.mMuted;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if( inp.audio.mMuted ) this.UnMuteInput(wa,id);
        else                   this.MuteInput(wa,id);
        return inp.audio.mMuted;
    }

    return null;
}

EffectPass.prototype.UpdateInputs = function( wa, forceUpdate, keyboard )
{
   for (let i=0; i<this.mInputs.length; i++ )
   {
        let inp = this.mInputs[i];

        if( inp===null )
        {
            if( forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, null, false, 0, 0, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.image, true, 1, 1, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mPreview, true, 1, 1, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
            if( inp.loaded && forceUpdate )
            {
                if( this.mTextureCallbackFun!==null )
                {
                    let img = (assetID_to_cubemapBuferID(inp.mInfo.mID)===-1) ? inp.image[0] : inp.mImage;
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, img, true, 2, 1, -1.0, this.mID );
                }
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:keyboard.mIcon,mData:keyboard.mData}, false, 6, 0, -1.0, this.mID );
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, -1, this.mID );
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
              if( inp.loaded && inp.audio.mPaused === false && inp.audio.mForceMuted === false )
              {
                  if( wa !== null )
                  {
                      inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                      inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                  }

                  if (this.mTextureCallbackFun!==null)
                  {
                           if (inp.mInfo.mType === "music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:(wa==null)?null:inp.audio.mSound.mFreqData}, false, 4, 1, inp.audio.currentTime, this.mID);
                      else if (inp.mInfo.mType === "musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:(wa==null)?null:inp.audio.mSound.mFreqData, info: inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                  }
              }
              else if( inp.loaded===false )
              {
                  if (this.mTextureCallbackFun!==null)
                      this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:null}, false, 4, 0, -1.0, this.mID);
              }
        }
        else if( inp.mInfo.mType==="mic" )
        {
              if( inp.loaded && inp.mForceMuted === false )
              {
                  if( wa !== null )
                  {
                      inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                      inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
                  }
                  if( this.mTextureCallbackFun!==null )
                      this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave: ((wa==null)?null:inp.mFreqData) }, false, 5, 1, 0, this.mID );
              }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:null}, true, 9, 1, -1.0, this.mID );
            }
        }
    }
}

EffectPass.prototype.Sampler2Renderer = function (sampler)
{
    let filter = this.mRenderer.FILTER.NONE;
    if (sampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
    if (sampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
    let wrap = this.mRenderer.TEXWRP.REPEAT;
    if (sampler.wrap === "clamp") wrap = this.mRenderer.TEXWRP.CLAMP;
    let vflip = false;
    if (sampler.vflip === "true") vflip = true;

    return { mFilter: filter, mWrap: wrap, mVFlip: vflip };
}

EffectPass.prototype.GetSamplerVFlip = function (id)
{
    let inp = this.mInputs[id];
    return inp.mInfo.mSampler.vflip;
}

EffectPass.prototype.GetTranslatedShaderSource = function ()
{
    return this.mTranslatedSource;
}


EffectPass.prototype.SetSamplerVFlip = function (id, str) 
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let filter = false;
    if (str === "true") filter = true;

    if (inp === null)
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
    }
    else if (inp.mInfo.mType === "video")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "webcam")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, null);
            inp.mInfo.mSampler.vflip = str;
        }
    }
}

EffectPass.prototype.GetAcceptsVFlip = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return false;
    if (inp.mInfo.mType === "video")  return true;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return true;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return false;
    return true;
}

EffectPass.prototype.GetSamplerFilter = function (id)
{
    let inp = this.mInputs[id];
    if( inp===null) return;
    return inp.mInfo.mSampler.filter;
}

EffectPass.prototype.SetSamplerFilter = function (id, str, buffers, cubeBuffers) 
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let filter = renderer.FILTER.NONE;
    if (str === "linear") filter = renderer.FILTER.LINEAR;
    if (str === "mipmap") filter = renderer.FILTER.MIPMAP;

    if (inp === null)
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "video")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap")
    {
        if (inp.loaded) 
        {
            if( assetID_to_cubemapBuferID(inp.mInfo.mID)===0)
            {
                renderer.SetSamplerFilter(cubeBuffers[0].mTexture[0], filter, true);
                renderer.SetSamplerFilter(cubeBuffers[0].mTexture[1], filter, true);
                inp.mInfo.mSampler.filter = str;
            }
            else
            {
                renderer.SetSamplerFilter(inp.globject, filter, true);
                inp.mInfo.mSampler.filter = str;
            }
        }
    }
    else if (inp.mInfo.mType === "webcam")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "buffer")
    {
        renderer.SetSamplerFilter(buffers[inp.id].mTexture[0], filter, true);
        renderer.SetSamplerFilter(buffers[inp.id].mTexture[1], filter, true);
        inp.mInfo.mSampler.filter = str;
    }
    else if (inp.mInfo.mType === "keyboard")
    {
        inp.mInfo.mSampler.filter = str;
    }
}



EffectPass.prototype.GetAcceptsMipmapping = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return this.mIs20;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return this.mIs20;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return this.mIs20;
    return false;
}

EffectPass.prototype.GetAcceptsLinear = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return true;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return true;
    if (inp.mInfo.mType === "music")  return true;
    if (inp.mInfo.mType === "musicstream") return true;
    if (inp.mInfo.mType === "mic")  return true;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return true;
    return false;
}


EffectPass.prototype.GetAcceptsWrapRepeat = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return this.mIs20;
    if (inp.mInfo.mType === "cubemap") return false;
    if (inp.mInfo.mType === "webcam")  return this.mIs20;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return this.mIs20;
    return false;
}

EffectPass.prototype.GetSamplerWrap = function (id)
{
    let inp = this.mInputs[id];
    return inp.mInfo.mSampler.wrap;
}
EffectPass.prototype.SetSamplerWrap = function (id, str, buffers)
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let restr = renderer.TEXWRP.REPEAT;
    if (str === "clamp") restr = renderer.TEXWRP.CLAMP;

    if (inp === null) 
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "video") 
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap") 
    {
        if (inp.loaded)
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "webcam") 
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "buffer")
    {
        renderer.SetSamplerWrap(buffers[inp.id].mTexture[0], restr);
        renderer.SetSamplerWrap(buffers[inp.id].mTexture[1], restr);
        inp.mInfo.mSampler.wrap = str;
    }
}


EffectPass.prototype.GetTexture = function( slot )
{
    let inp = this.mInputs[slot];
    if( inp===null ) return null;
    return inp.mInfo;

}

EffectPass.prototype.SetOutputs = function( slot, id )
{
    this.mOutputs[slot] = id;
}

EffectPass.prototype.SetOutputsByBufferID = function( slot, id )
{
    if( this.mType==="buffer" )
    {
        this.mOutputs[slot] = bufferID_to_assetID( id );

        this.mEffect.ResizeBuffer( id, this.mEffect.mXres, this.mEffect.mYres, false );
    }
    else if( this.mType==="cubemap" )
    {
        this.mOutputs[slot] = cubamepBufferID_to_assetID( id );
        this.mEffect.ResizeCubemapBuffer(id, 1024, 1024 );
    }
}

EffectPass.prototype.NewTexture = function( wa, slot, url, buffers, cubeBuffers, keyboard )
{
    var me = this;
    var renderer = this.mRenderer;

    if( renderer===null ) return;

    let texture = null;

    if( url===null || url.mType===null )
    {
        if( me.mTextureCallbackFun!==null )
            me.mTextureCallbackFun( this.mTextureCallbackObj, slot, null, true, 0, 0, -1.0, me.mID );
        me.DestroyInput( slot );
        me.mInputs[slot] = null;
        me.MakeHeader();
        return { mFailed:false, mNeedsShaderCompile:false };
    }
    else if( url.mType==="texture" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.image = new Image();
        texture.image.crossOrigin = '';
        texture.image.onload = function()
        {
            let rti = me.Sampler2Renderer(url.mSampler);

            // O.M.G. FIX THIS
            let channels = renderer.TEXFMT.C4I8;
            if (url.mID === "Xdf3zn" || url.mID === "4sf3Rn" || url.mID === "4dXGzn" || url.mID === "4sf3Rr")
                channels = renderer.TEXFMT.C1I8;
            
            texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.image, channels, rti.mFilter, rti.mWrap, rti.mVFlip);

            texture.loaded = true;
            if( me.mTextureCallbackFun!==null )
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.image, true, 1, 1, -1.0, me.mID );
        }
        texture.image.src = url.mSrc;


        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="volume" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.mImage = { mData:null, mXres:1, mYres:0, mZres:0 };
        texture.mPreview = new Image();
        texture.mPreview.crossOrigin = '';

	    var xmlHttp = new XMLHttpRequest();
        if( xmlHttp===null ) return { mFailed:true };

        xmlHttp.open('GET', url.mSrc, true);
        xmlHttp.responseType = "arraybuffer";
        xmlHttp.onerror = function()
        {
            console.log( "Error 1 loading Volume" );
        }
        xmlHttp.onload = function()
        {
            let data = xmlHttp.response;
            if (!data ) { console.log( "Error 2 loading Volume" ); return; }

            let file = piFile(data);

            let signature = file.ReadUInt32();
            texture.mImage.mXres = file.ReadUInt32();
            texture.mImage.mYres = file.ReadUInt32();
            texture.mImage.mZres = file.ReadUInt32();
            let binNumChannels = file.ReadUInt8();
            let binLayout = file.ReadUInt8();
            let binFormat = file.ReadUInt16();
            let format = renderer.TEXFMT.C1I8;
                 if( binNumChannels===1 && binFormat===0 )  format = renderer.TEXFMT.C1I8;
            else if( binNumChannels===2 && binFormat===0 )  format = renderer.TEXFMT.C2I8;
            else if( binNumChannels===3 && binFormat===0 )  format = renderer.TEXFMT.C3I8;
            else if( binNumChannels===4 && binFormat===0 )  format = renderer.TEXFMT.C4I8;
            else if( binNumChannels===1 && binFormat===10 ) format = renderer.TEXFMT.C1F32;
            else if( binNumChannels===2 && binFormat===10 ) format = renderer.TEXFMT.C2F32;
            else if( binNumChannels===3 && binFormat===10 ) format = renderer.TEXFMT.C3F32;
            else if( binNumChannels===4 && binFormat===10 ) format = renderer.TEXFMT.C4F32;
            else return;

            let buffer = new Uint8Array(data, 20); // skip 16 bytes (header of .bin)

            let rti = me.Sampler2Renderer(url.mSampler);

            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T3D, texture.mImage.mXres, texture.mImage.mYres, format, rti.mFilter, rti.mWrap, buffer);

            if( texture.globject===null )
            {
                console.log( "Error 4: loading Volume" ); 
                return { mFailed:true };
            }

            if (me.mTextureCallbackFun !== null)
            {
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mPreview, true, 1, 1, -1.0, me.mID );
            }

            texture.loaded = true;

            // load icon for it
            texture.mPreview.onload = function()
            {
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mPreview, true, 1, 1, -1.0, me.mID );
            }
            texture.mPreview.src = url.mPreviewSrc;
        }
        xmlHttp.send("");


        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]==null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="volume")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="cubemap" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;

        let rti = me.Sampler2Renderer(url.mSampler);

        if( assetID_to_cubemapBuferID(url.mID)!==-1 )
        {
            texture.mImage = new Image();
            texture.mImage.onload = function()
            {
                texture.loaded = true;
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mImage, true, 2, 1, -1.0, me.mID );
            }
            texture.mImage.src = "/media/previz/cubemap00.png";

            this.mEffect.ResizeCubemapBuffer(0, 1024, 1024 );

        }
        else
        {
            texture.image = [ new Image(), new Image(), new Image(), new Image(), new Image(), new Image() ];

            let numLoaded = 0;
            for (var i=0; i<6; i++ )
            {
                texture.image[i].mId = i;
                texture.image[i].crossOrigin = '';
                texture.image[i].onload = function()
                {
                    var id = this.mId;
                    numLoaded++;
                    if( numLoaded===6 )
                    {
                        texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.CUBEMAP, texture.image, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                        texture.loaded = true;
                        if (me.mTextureCallbackFun !== null)
                            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, texture.image[0], true, 2, 1, -1.0, me.mID);
                    }
                }

                if( i === 0) 
                {
                    texture.image[i].src = url.mSrc;
                } 
                else 
                {
                    let n = url.mSrc.lastIndexOf(".");
                    texture.image[i].src = url.mSrc.substring(0, n) + "_" + i + url.mSrc.substring(n, url.mSrc.length);
                }
            }
        }

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]==null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="cubemap")) };

        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="webcam" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;

        texture.video = document.createElement('video');
    	texture.video.width = 320;
    	texture.video.height = 240;
    	texture.video.autoplay = true;
    	texture.video.loop = true;
        texture.mForceMuted = this.mForceMuted;
        texture.mImage = null;

        let rti = me.Sampler2Renderer(url.mSampler);

        var loadImageInsteadOfWebCam = function()
        {
            texture.mImage = new Image();
            texture.mImage.onload = function()
            {
                texture.loaded = true;
                texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.mImage, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mImage, true, 7, 1, -1.0, me.mID );
            }
            texture.mImage.src = "/media/previz/webcam.png";
        }
        
        loadImageInsteadOfWebCam();

        if( typeof navigator.getUserMedia !== "undefined"  && texture.mForceMuted===false )
        {
            texture.video.addEventListener("canplay", function (e)
            {
				try
				{
                    texture.mImage = null;
                    if( texture.globject != null )
                        renderer.DestroyTexture( texture.globject );
					texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.video, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
					texture.loaded = true;
                }
                catch(e)
                {
                    loadImageInsteadOfWebCam();
	                alert( 'Your browser can not transfer webcam data to the GPU.');
                }
            } );

            navigator.mediaDevices.getUserMedia( 
                                { "video": { width: 1280, height: 720 }, "audio": false } )
                                .then( function(stream)
                                       {
                                            texture.video.srcObject = stream;
    	                               } )
                                .catch( function(error)
                                        {
                                            loadImageInsteadOfWebCam();
    		                                alert( 'Unable to capture WebCam. Please reload the page.' );
    	                                } );
        }
        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]==null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!="music") && 
                                                                (this.mInputs[slot].mInfo.mType!="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="mic" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.mForceMuted = this.mForceMuted;
        texture.mAnalyser = null;
        let num = 512;
        texture.mFreqData = new Uint8Array( num );
        texture.mWaveData = new Uint8Array( num );

        if( wa === null || typeof navigator.getUserMedia === "undefined" )
        {
            if( !texture.mForceMuted ) alert( "Shadertoy: Web Audio not implement in this browser" );
            texture.mForceMuted = true; 
        }

        if( texture.mForceMuted )
        {
            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, num, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null)
            texture.loaded = true;
        }
        else
        {
        navigator.getUserMedia( { "audio": true },
                                function(stream)
                                {
                                  texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, null)
                                  texture.mic = wa.createMediaStreamSource(stream);
                                  texture.mAnalyser = wa.createAnalyser();
                                  texture.mic.connect( texture.mAnalyser );
                                  texture.loaded = true;
    	                        },
                                function(error)
                                {
    		                        alert( 'Unable open Mic. Please reload the page.' );
    	                        } );
        }
        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="video" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.video = document.createElement('video');
    	texture.video.loop = true;
        texture.video.preload = "auto";
        texture.video.mPaused = this.mForcePaused;
        texture.video.mMuted = true;//this.mForceMuted;
    	texture.video.muted  = true;//this.mForceMuted;
        if( this.mForceMuted===true )
            texture.video.volume = 0;
    	texture.video.autoplay = false;
        texture.video.hasFalled = false;
        
        let rti = me.Sampler2Renderer(url.mSampler);

        texture.video.addEventListener("canplay", function (e)
        {
            texture.video.play().then( function()
                                       {
                                           texture.video.mPaused = false;

                                           texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.video, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                                           texture.loaded = true;
            
                                           if( me.mTextureCallbackFun!=null )
                                               me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.video, true, 3, 1, -1.0, me.mID );
                                        } )
                               .catch( function(error)
                                       {
                                           console.log( error );
                                       }
                                );
        } );

        texture.video.addEventListener( "error", function(e)
        {
               if( texture.video.hasFalled===true ) { alert("Error: cannot load video" ); return; }
               let str = texture.video.src;
               str = str.substr(0,str.lastIndexOf('.') ) + ".mp4";
               texture.video.src = str;
               texture.video.hasFalled = true;
        } );

        texture.video.src = url.mSrc;

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]==null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!="music") && 
                                                                (this.mInputs[slot].mInfo.mType!="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="music" || url.mType==="musicstream" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.audio = document.createElement('audio');
    	texture.audio.loop = true;
        texture.audio.mMuted = this.mForceMuted;
        texture.audio.mForceMuted = this.mForceMuted;
        texture.audio.muted = this.mForceMuted;
        if( this.mForceMuted===true )
            texture.audio.volume = 0;
        texture.audio.autoplay = false;
        texture.audio.hasFalled = false;
        texture.audio.mPaused = false;
        texture.audio.mSound = {};

        if( this.mForceMuted===false )
        {
            if(url.mType==="musicstream" && SC === null)
            {
                alert( "Shadertoy: Soundcloud could not be reached" );
                texture.audio.mForceMuted = true;
            }
            }

        if( wa === null && this.mForceMuted===false )
        {
            alert( "Shadertoy: Web Audio not implement in this browser" );
            texture.audio.mForceMuted = true;
        }

        if( texture.audio.mForceMuted )
        {
            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null);
            let num = 512;
            texture.audio.mSound.mFreqData = new Uint8Array( num );
            texture.audio.mSound.mWaveData = new Uint8Array( num );
            texture.loaded = true;
        }

        texture.audio.addEventListener( "canplay", function()
        {
            if( texture===null || texture.audio===null ) return;
            if( this.mForceMuted  ) return;
            if( texture.loaded === true ) return;

            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null)

            texture.audio.mSound.mSource   = wa.createMediaElementSource( texture.audio );
            texture.audio.mSound.mAnalyser = wa.createAnalyser();
            texture.audio.mSound.mGain     = wa.createGain();

            texture.audio.mSound.mSource.connect(   texture.audio.mSound.mAnalyser );
            texture.audio.mSound.mAnalyser.connect( texture.audio.mSound.mGain );
            texture.audio.mSound.mGain.connect(me.mGainNode);

            texture.audio.mSound.mFreqData = new Uint8Array( texture.audio.mSound.mAnalyser.frequencyBinCount );
            texture.audio.mSound.mWaveData = new Uint8Array( texture.audio.mSound.mAnalyser.frequencyBinCount );

            if( texture.audio.mPaused )
            {
                texture.audio.pause();
            }
            else
            {
                texture.audio.play().then( function() {/*console.log("ok");*/} ).catch( function(e){console.log("error " + e);} );
            }
            texture.loaded = true;
        } );

        texture.audio.addEventListener( "error", function(e)
        {
               if( this.mForceMuted  ) return;

               if( texture.audio.hasFalled===true ) { return; }
               let str = texture.audio.src;
               str = str.substr(0,str.lastIndexOf('.') ) + ".ogg";
               texture.audio.src = str;
               texture.audio.hasFalled = true;
        } );

        if( !texture.audio.mForceMuted )
        {
            if(url.mType==="musicstream")
            {
                SC.resolve(url.mSrc, 
                    function(song) 
                    {
                        if( song.streamable===true )
                        {
                            texture.audio.crossOrigin = 'anonymous';
                            texture.audio.src = song.stream_url;
                            texture.audio.soundcloudInfo = song;
                        }
                        else
                        {
                            alert('Shadertoy: Soundcloud 3 - This track cannot be streamed' );
                        }
                    },
                    function(error)
                    {
                        if (me.mTextureCallbackFun!==null)
                        {
                            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null}, false, 4, 0, -1.0, me.mID);
                        }
                    } );
            } 
            else
            {
                texture.audio.src = url.mSrc;
            }
        }

        if (me.mTextureCallbackFun!==null)
        {
            if (url.mType === "music")            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null}, false, 4, 0, -1.0, me.mID);
            else if (url.mType === "musicstream") me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null, info: texture.audio.soundcloudInfo}, false, 8, 0, -1.0, me.mID);
        }

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="keyboard" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = true;

        texture.keyboard = {};

        if( me.mTextureCallbackFun!==null )
            me.mTextureCallbackFun( me.mTextureCallbackObj, slot, {mImage: keyboard.mIcon, mData: keyboard.mData}, false, 6, 1, -1.0, me.mID );

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!="music") && 
                                                                (this.mInputs[slot].mInfo.mType!="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="buffer" )
    {
        texture = {};
        texture.mInfo = url;

        texture.image = new Image();
        texture.image.onload = function()
        {
            if( me.mTextureCallbackFun!=null )
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, {texture: texture.image, data:null}, true, 9, 1, -1.0, me.mID );
        }
        texture.image.src = url.mSrc;
        texture.id = assetID_to_bufferID( url.mID );
        texture.loaded = true;

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!="music") && 
                                                                (this.mInputs[slot].mInfo.mType!="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!="video")) };

        this.DestroyInput( slot );
        this.mInputs[slot] = texture;

        this.mEffect.ResizeBuffer(texture.id, this.mEffect.mXres, this.mEffect.mYres, false );

        this.SetSamplerFilter(slot, url.mSampler.filter, buffers, cubeBuffers, true);
        this.SetSamplerVFlip(slot, url.mSampler.vflip);
        this.SetSamplerWrap(slot, url.mSampler.wrap, buffers);

        this.MakeHeader();
        return returnValue;
    }
    else
    {
        alert( "input type error" );
        return { mFailed: true };
    }

    return { mFailed: true };
}

EffectPass.prototype.Paint_Image = function( vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    let times = [ 0.0, 0.0, 0.0, 0.0 ];

    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds()  + d.getMilliseconds()/1000.0 ];

    let mouse = [  mousePosX, mousePosY, mouseOriX, mouseOriY ];


    //------------------------
    
    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];
    let texIsLoaded = [0, 0, 0, 0 ];
    let texID = [ null, null, null, null];

    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            texID[i] = keyboard.mTexture;
            texIsLoaded[i] = 1;
            resos[3*i+0] = 256;
            resos[3*i+1] = 3;
            resos[3*i+2] = 1;
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
            if (inp.loaded === true)
            {
                let id = assetID_to_cubemapBuferID(inp.mInfo.mID);
                if( id!==-1 )
                {
                    texID[i] = cubeBuffers[id].mTexture[ cubeBuffers[id].mLastRenderDone ];
                    resos[3*i+0] = cubeBuffers[id].mResolution[0];
                    resos[3*i+1] = cubeBuffers[id].mResolution[1];
                    resos[3*i+2] = 1;
                    texIsLoaded[i] = 1;

                    // hack. in webgl2.0 we have samplers, so we don't need this crap here
                    let filter = this.mRenderer.FILTER.NONE;
                         if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                    else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                    this.mRenderer.SetSamplerFilter( texID[i], filter, false);
                }
                else
                {
                    texID[i] = inp.globject;
                    texIsLoaded[i] = 1;
                }
            }
        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mImage, false, 7, 1, -1, this.mID );

                    texID[i] = inp.globject;
                    texIsLoaded[i] = 1;
                    resos[3*i+0] = inp.mImage.width;
                    resos[3*i+1] = inp.mImage.height;
                    resos[3*i+2] = 1;
                }
                else  if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {

                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 7, 1, -1, this.mID );

                    texID[i] = inp.globject;
                    this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                    resos[3*i+0] = inp.video.videoWidth;
                    resos[3*i+1] = inp.video.videoHeight;
                    resos[3*i+2] = 1;
                    texIsLoaded[i] = 1;
                }
            }
            else 
            {
                texID[i] = null;
                texIsLoaded[i] = 0;
                resos[3*i+0] = inp.video.width;
                resos[3*i+1] = inp.video.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.mPaused === false )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, inp.video.currentTime, this.mID );
            }

            if( inp.loaded===true )
            { 
                times[i] = inp.video.currentTime;
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;

      	        if( inp.video.mPaused === false )
      	        {
      	            this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
                resos[3*i+0] = inp.video.videoWidth;
                resos[3*i+1] = inp.video.videoHeight;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.audio.mPaused === false && inp.audio.mForceMuted === false && inp.loaded===true )
            {
                if( wa !== null )
                {
                    inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                    inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                }

                if( this.mTextureCallbackFun!==null )
                {
                         if( inp.mInfo.mType==="music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa === null) ? null : { wave : inp.audio.mSound.mFreqData }, false, 4, 1, inp.audio.currentTime, this.mID);
                    else if( inp.mInfo.mType==="musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa === null) ? null : { wave : inp.audio.mSound.mFreqData, info : inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                }
            }

            if( inp.loaded===true )
            {
                times[i] = inp.audio.currentTime;
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;

                if( inp.audio.mForceMuted === true )
                {
                    times[i] = 10.0 + time;
                    let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.audio.mSound.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                  //let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.audio.mSound.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }

                }

      	        if( inp.audio.mPaused === false )
                {
      	            let waveLen = Math.min(inp.audio.mSound.mWaveData.length, 512);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512, 1, inp.audio.mSound.mFreqData);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 1, 512, 1, inp.audio.mSound.mWaveData);
                }

                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                    times[i] = 10.0 + time;
                    let num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                    //var num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }
            }
            else
            {
                inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
            }

            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave:inp.mFreqData}, false, 5, 1, -1, this.mID );

            if( inp.loaded===true )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                let waveLen = Math.min( inp.mWaveData.length, 512 );
                this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512,     1, inp.mFreqData);
                this.mRenderer.UpdateTexture(inp.globject, 0, 1, waveLen, 1, inp.mWaveData);
                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            let id = inp.id;
            if( inp.loaded===true  )
            {
                texID[i] = buffers[id].mTexture[ buffers[id].mLastRenderDone ];
                texIsLoaded[i] = 1;
                resos[3*i+0] = xres;
                resos[3*i+1] = yres;
                resos[3*i+2] = 1;
                // hack. in webgl2.0 we have samplers, so we don't need this crap here
                let filter = this.mRenderer.FILTER.NONE;
                     if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                this.mRenderer.SetSamplerFilter( texID[i], filter, false);
            }

            if( this.mTextureCallbackFun!==null )
            {
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:buffers[id].mThumbnailBuffer}, false, 9, 1, -1, this.mID );
            }
        }
    }

    this.mRenderer.AttachTextures( 4, texID[0], texID[1], texID[2], texID[3] );

    //-----------------------------------

    let prog = this.mProgram;

    //if( vrData!=null && this.mSupportsVR ) prog = this.mProgramVR;



    this.mRenderer.AttachShader(prog);

    this.mRenderer.SetShaderConstant1F(  "iTime", time);
    this.mRenderer.SetShaderConstant3F(  "iResolution", xres, yres, 1.0);
    this.mRenderer.SetShaderConstant4FV( "iMouse", mouse);
    this.mRenderer.SetShaderConstant1FV( "iChannelTime", times );              // OBSOLETE
    this.mRenderer.SetShaderConstant4FV( "iDate", dates );
    this.mRenderer.SetShaderConstant3FV( "iChannelResolution", resos );        // OBSOLETE
    this.mRenderer.SetShaderConstant1F(  "iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit( "iChannel0", 0 );
    this.mRenderer.SetShaderTextureUnit( "iChannel1", 1 );
    this.mRenderer.SetShaderTextureUnit( "iChannel2", 2 );
    this.mRenderer.SetShaderTextureUnit( "iChannel3", 3 );
    this.mRenderer.SetShaderConstant1I(  "iFrame", this.mFrame );
    this.mRenderer.SetShaderConstant1F(  "iTimeDelta", dtime);
    this.mRenderer.SetShaderConstant1F(  "iFrameRate", fps );

    this.mRenderer.SetShaderConstant1F(  "iCh0.time", times[0] );
    this.mRenderer.SetShaderConstant1F(  "iCh1.time", times[1] );
    this.mRenderer.SetShaderConstant1F(  "iCh2.time", times[2] );
    this.mRenderer.SetShaderConstant1F(  "iCh3.time", times[3] );
    this.mRenderer.SetShaderConstant3F(  "iCh0.size", resos[0], resos[ 1], resos[ 2] );
    this.mRenderer.SetShaderConstant3F(  "iCh1.size", resos[3], resos[ 4], resos[ 5] );
    this.mRenderer.SetShaderConstant3F(  "iCh2.size", resos[6], resos[ 7], resos[ 8] );
    this.mRenderer.SetShaderConstant3F(  "iCh3.size", resos[9], resos[10], resos[11] );
    this.mRenderer.SetShaderConstant1I(  "iCh0.loaded",       texIsLoaded[0] );
    this.mRenderer.SetShaderConstant1I(  "iCh1.loaded",       texIsLoaded[1] );
    this.mRenderer.SetShaderConstant1I(  "iCh2.loaded",       texIsLoaded[2] );
    this.mRenderer.SetShaderConstant1I(  "iCh3.loaded",       texIsLoaded[3] );

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");


    if( (vrData !== null) && this.mSupportsVR )
    {
        for (let i=0; i<2; i++ )
        {
            let ei = (i===0) ? vrData.mLeftEye : vrData.mRightEye;

            let vp = [i * xres / 2, 0, xres / 2, yres];

            this.mRenderer.SetViewport(vp);

            let fov = ei.mProjection;
            let corA = [ -fov[2], -fov[1], -1.0 ];
            let corB = [  fov[3], -fov[1], -1.0 ];
            let corC = [  fov[3],  fov[0], -1.0 ];
            let corD = [ -fov[2],  fov[0], -1.0 ];
            let apex = [ 0.0, 0.0, 0.0 ];

            let ma = invertFast( ei.mCamera );
            corA = matMulpoint( ma, corA ); 
            corB = matMulpoint( ma, corB ); 
            corC = matMulpoint( ma, corC ); 
            corD = matMulpoint( ma, corD ); 
            apex = matMulpoint( ma, apex ); 

            let corners = [ corA[0], corA[1], corA[2], 
                            corB[0], corB[1], corB[2], 
                            corC[0], corC[1], corC[2], 
                            corD[0], corD[1], corD[2],
                            apex[0], apex[1], apex[2]];

            this.mRenderer.SetShaderConstant3FV("unCorners", corners);
            this.mRenderer.SetShaderConstant4FV("unViewport", vp);

            this.mRenderer.DrawUnitQuad_XY(l1);
        }
    }
    else 
    {
        this.mRenderer.SetViewport([0, 0, xres, yres]);
        this.mRenderer.DrawFullScreenTriangle_XY( l1 );
    }

    this.mRenderer.DettachTextures();
}

EffectPass.prototype.iRenderSound = function(d, callback )
{
    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds() ];

    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];

    this.mRenderer.SetRenderTarget(this.mRenderFBO);

    this.mRenderer.SetViewport([0, 0, this.mTextureDimensions, this.mTextureDimensions]);
    this.mRenderer.AttachShader(this.mProgram);
    this.mRenderer.SetBlend( false );

    let texID = [null, null, null, null];
    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
    }

    this.mRenderer.AttachTextures(4, texID[0], texID[1], texID[2], texID[3]);

    let l2 = this.mRenderer.SetShaderConstantLocation(this.mProgram, "iTimeOffset");
    let l3 = this.mRenderer.SetShaderConstantLocation(this.mProgram, "iSampleOffset");
    this.mRenderer.SetShaderConstant4FV("iDate", dates);
    this.mRenderer.SetShaderConstant3FV("iChannelResolution", resos);
    this.mRenderer.SetShaderConstant1F("iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit("iChannel0", 0);
    this.mRenderer.SetShaderTextureUnit("iChannel1", 1);
    this.mRenderer.SetShaderTextureUnit("iChannel2", 2);
    this.mRenderer.SetShaderTextureUnit("iChannel3", 3);

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    //--------------------------------
    let numSamples = this.mTmpBufferSamples;
    let numBlocks = this.mPlaySamples / numSamples;
    for (let j=0; j<numBlocks; j++ )
    {
        let off = j*numSamples;
        
        this.mRenderer.SetShaderConstant1F_Pos(l2, off / this.mSampleRate);
        this.mRenderer.SetShaderConstant1I_Pos(l3, off );
        this.mRenderer.DrawUnitQuad_XY(l1);

        this.mRenderer.GetPixelData(this.mData, 0, this.mTextureDimensions, this.mTextureDimensions);

        callback( off, this.mData, numSamples );
    }

    this.mRenderer.DetachShader();
    this.mRenderer.DettachTextures();
    this.mRenderer.SetRenderTarget(null);
}

EffectPass.prototype.Paint_Sound = function( wa, d )
{
    let bufL = this.mBuffer.getChannelData(0); // Float32Array
    let bufR = this.mBuffer.getChannelData(1); // Float32Array

    this.iRenderSound( d, function(off, data, numSamples)
                         {
                            for( let i=0; i<numSamples; i++ )
                            {
                                bufL[off+i] = -1.0 + 2.0*(data[4*i+0]+256.0*data[4*i+1])/65535.0;
                                bufR[off+i] = -1.0 + 2.0*(data[4*i+2]+256.0*data[4*i+3])/65535.0;
                            }
                         }
                     );
}

EffectPass.prototype.SetUniforms = function(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    let times = [ 0.0, 0.0, 0.0, 0.0 ];

    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds()  + d.getMilliseconds()/1000.0 ];

    let mouse = [  mousePosX, mousePosY, mouseOriX, mouseOriY ];

    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];

    //------------------------
    
    let texID = [ null, null, null, null];

    for( let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            texID[i] = keyboard.mTexture;
        }
        else if( inp.mInfo.mType=="cubemap" )
        {
            if (inp.loaded === true)
            {
                let id = assetID_to_cubemapBuferID(inp.mInfo.mID);
                if( id!==-1 )
                {
                    texID[i] = cubeBuffers[id].mTexture[ cubeBuffers[id].mLastRenderDone ];
                    resos[3*i+0] = cubeBuffers[id].mResolution[0];
                    resos[3*i+1] = cubeBuffers[id].mResolution[1];
                    resos[3*i+2] = 1;
    
                    // hack. in webgl2.0 we have samplers, so we don't need this crap here
                    let filter = this.mRenderer.FILTER.NONE;
                         if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                    else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                    this.mRenderer.SetSamplerFilter( texID[i], filter, false);
                }
                else
                {
                    texID[i] = inp.globject;
                }
            }

        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    texID[i] = inp.globject;
                    resos[3*i+0] = inp.mImage.width;
                    resos[3*i+1] = inp.mImage.height;
                    resos[3*i+2] = 1;
                }
                else  if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {
                    texID[i] = inp.globject;
                    resos[3*i+0] = inp.video.videoWidth;
                    resos[3*i+1] = inp.video.videoHeight;
                    resos[3*i+2] = 1;
                }
            }
            else 
            {
                texID[i] = null;
                resos[3*i+0] = inp.video.width;
                resos[3*i+1] = inp.video.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
           if( inp.loaded===true )
           { 
                times[i] = inp.video.currentTime;
                texID[i] = inp.globject;
                resos[3*i+0] = inp.video.videoWidth;
                resos[3*i+1] = inp.video.videoHeight;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.loaded===true )
            {
                times[i] = inp.audio.currentTime;
                texID[i] = inp.globject;

                if( inp.audio.mForceMuted === true )
                {
                    times[i] = 10.0 + time;
                }

                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                times[i] = 10.0 + time;
            }

            if( inp.loaded===true )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = buffers[inp.id].mTexture[ buffers[inp.id].mLastRenderDone ];
                resos[3*i+0] = buffers[inp.id].mResolution[0];
                resos[3*i+1] = buffers[inp.id].mResolution[1];
                resos[3*i+2] = 1;
            }
        }
    }

    this.mRenderer.AttachTextures( 4, texID[0], texID[1], texID[2], texID[3] );

    //-----------------------------------

    this.mRenderer.AttachShader(this.mProgram);

    this.mRenderer.SetShaderConstant1F(  "iTime", time);
    this.mRenderer.SetShaderConstant3F(  "iResolution", xres, yres, 1.0);
    this.mRenderer.SetShaderConstant4FV( "iMouse", mouse);
    this.mRenderer.SetShaderConstant1FV( "iChannelTime", times );              // OBSOLETE
    this.mRenderer.SetShaderConstant4FV( "iDate", dates );
    this.mRenderer.SetShaderConstant3FV( "iChannelResolution", resos );        // OBSOLETE
    this.mRenderer.SetShaderConstant1F(  "iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit( "iChannel0", 0 );
    this.mRenderer.SetShaderTextureUnit( "iChannel1", 1 );
    this.mRenderer.SetShaderTextureUnit( "iChannel2", 2 );
    this.mRenderer.SetShaderTextureUnit( "iChannel3", 3 );
    this.mRenderer.SetShaderConstant1I(  "iFrame", this.mFrame );
    this.mRenderer.SetShaderConstant1F(  "iTimeDelta", dtime);
    this.mRenderer.SetShaderConstant1F(  "iFrameRate", fps );

    this.mRenderer.SetShaderConstant1F(  "iChannel[0].time",       times[0] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[1].time",       times[1] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[2].time",       times[2] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[3].time",       times[3] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[0].resolution", resos[0], resos[ 1], resos[ 2] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[1].resolution", resos[3], resos[ 4], resos[ 5] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[2].resolution", resos[6], resos[ 7], resos[ 8] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[3].resolution", resos[9], resos[10], resos[11] );
}

EffectPass.prototype.ProcessInputs = function(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
        }
        else if( inp.mInfo.mType==="volume" )
        {
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mImage, false, 7, 1, -1, this.mID );
                }
                else if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 7, 1, -1, this.mID );

                    this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.mPaused === false )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, inp.video.currentTime, this.mID );
            }

            if( inp.loaded===true )
            { 
      	        if( inp.video.mPaused === false )
      	        {
      	            this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.audio.mPaused === false && inp.audio.mForceMuted === false && inp.loaded===true )
            {
                if( wa !== null )
                {
                    inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                    inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                }

                if( this.mTextureCallbackFun!==null )
                {
                         if( inp.mInfo.mType==="music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa == null) ? null : { wave : inp.audio.mSound.mFreqData }, false, 4, 1, inp.audio.currentTime, this.mID);
                    else if( inp.mInfo.mType==="musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa == null) ? null : { wave : inp.audio.mSound.mFreqData, info : inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                }
            }

            if( inp.loaded===true )
            {
                if( inp.audio.mForceMuted === true )
                {
                    let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.audio.mSound.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                  //let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.audio.mSound.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }

                }

      	        if( inp.audio.mPaused === false )
                {
      	            let waveLen = Math.min(inp.audio.mSound.mWaveData.length, 512);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512, 1, inp.audio.mSound.mFreqData);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 1, 512, 1, inp.audio.mSound.mWaveData);
                }
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                    let num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                    for( let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }
            }
            else
            {
                inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
            }

            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave:inp.mFreqData}, false, 5, 1, -1, this.mID );

            if( inp.loaded===true )
            {
                let waveLen = Math.min( inp.mWaveData.length, 512 );
                this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512,     1, inp.mFreqData);
                this.mRenderer.UpdateTexture(inp.globject, 0, 1, waveLen, 1, inp.mWaveData);
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded===true  )
            {
                let id = inp.id;
                let texID = buffers[id].mTexture[ buffers[id].mLastRenderDone ];

                // hack. in webgl2.0 we have samplers, so we don't need this crap here
                let filter = this.mRenderer.FILTER.NONE;
                     if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                this.mRenderer.SetSamplerFilter( texID, filter, false);
            }

            if( this.mTextureCallbackFun!==null )
            {
				let id = inp.id;
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:buffers[id].mThumbnailBuffer}, false, 9, 1, -1, this.mID );
            }
        }
    }
}

EffectPass.prototype.Paint_Cubemap = function( vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face )
{
    this.ProcessInputs(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face );
    this.SetUniforms(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    let vp = [0, 0, xres, yres];

    this.mRenderer.SetViewport(vp);

    let corA = [ -1.0, -1.0, -1.0 ];
    let corB = [  1.0, -1.0, -1.0 ];
    let corC = [  1.0,  1.0, -1.0 ];
    let corD = [ -1.0,  1.0, -1.0 ];
    let apex = [  0.0,  0.0,  0.0 ];

    if( face===0 )
    {
        corA = [  1.0,  1.0,  1.0 ];
        corB = [  1.0,  1.0, -1.0 ];
        corC = [  1.0, -1.0, -1.0 ];
        corD = [  1.0, -1.0,  1.0 ];
    }
    else if( face===1 ) // -X
    {
        corA = [ -1.0,  1.0, -1.0 ];
        corB = [ -1.0,  1.0,  1.0 ];
        corC = [ -1.0, -1.0,  1.0 ];
        corD = [ -1.0, -1.0, -1.0 ];
    }
    else if( face===2 ) // +Y
    {
        corA = [ -1.0,  1.0, -1.0 ];
        corB = [  1.0,  1.0, -1.0 ];
        corC = [  1.0,  1.0,  1.0 ];
        corD = [ -1.0,  1.0,  1.0 ];
    }
    else if( face===3 ) // -Y
    {
        corA = [ -1.0, -1.0,  1.0 ];
        corB = [  1.0, -1.0,  1.0 ];
        corC = [  1.0, -1.0, -1.0 ];
        corD = [ -1.0, -1.0, -1.0 ];
    }
    else if( face===4 ) // +Z
    {
        corA = [ -1.0,  1.0,  1.0 ];
        corB = [  1.0,  1.0,  1.0 ];
        corC = [  1.0, -1.0,  1.0 ];
        corD = [ -1.0, -1.0,  1.0 ];
    }
    else //if( face===5 ) // -Z
    {
        corA = [  1.0,  1.0, -1.0 ];
        corB = [ -1.0,  1.0, -1.0 ];
        corC = [ -1.0, -1.0, -1.0 ];
        corD = [  1.0, -1.0, -1.0 ];
    }

    let corners = [ corA[0], corA[1], corA[2], 
                    corB[0], corB[1], corB[2], 
                    corC[0], corC[1], corC[2], 
                    corD[0], corD[1], corD[2],
                    apex[0], apex[1], apex[2]];

    this.mRenderer.SetShaderConstant3FV("unCorners", corners);
    this.mRenderer.SetShaderConstant4FV("unViewport", vp);

    this.mRenderer.DrawUnitQuad_XY(l1);

    this.mRenderer.DettachTextures();
}


EffectPass.prototype.Paint = function( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, bufferNeedsMimaps, buffers, cubeBuffers, keyboard, effect )
{
    if( this.mType==="sound" )
    {
        if (this.mSoundShaderCompiled === true)
        {
            // make sure all textures are loaded
            for (let i=0; i<this.mInputs.length; i++ )
            {
                let inp = this.mInputs[i];
                if (inp === null) continue;

                if (inp.mInfo.mType === "texture" && !inp.loaded) return;
                if (inp.mInfo.mType === "cubemap" && !inp.loaded) return;
            }

            this.Paint_Sound(wa, da);
            this.mSoundShaderCompiled = false;
        }
        if (this.mFrame === 0)
        {
            if (this.mPlaying===true)
            {
                this.mPlayNode.disconnect();
                this.mPlayNode.stop();
                this.mPlayNode = null;
            }
            this.mPlaying = true;

            this.mPlayNode = wa.createBufferSource();
            this.mPlayNode.buffer = this.mBuffer;
            this.mPlayNode.connect(this.mGainNode);
            this.mPlayNode.start(0);
        }
        this.mFrame++;
    }
    else if( this.mType==="image" )
    {
        this.mRenderer.SetRenderTarget( null );
        this.Paint_Image( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );
        this.mFrame++;
    }
    else if( this.mType==="common" )
    {
        //console.log("rendering common");
    }
    else if( this.mType==="buffer" )
    {
        this.mEffect.ResizeBuffer(bufferID, this.mEffect.mXres, this.mEffect.mYres, false );

        let buffer = buffers[bufferID];

        let dstID = 1 - buffer.mLastRenderDone;

        this.mRenderer.SetRenderTarget( buffer.mTarget[dstID] );
        this.Paint_Image( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );

        // compute mipmaps if needd
        if( bufferNeedsMimaps )
        {
            this.mRenderer.CreateMipmaps( buffer.mTexture[dstID]);
        }

        // make thumbnail
        //if( this.mTextureCallbackFun != null )
        /*
        {
            this.mRenderer.SetRenderTarget( buffer.mThumbnailRenderTarget );
            let v = [0, 0, buffer.mThumbnailRes[0], buffer.mThumbnailRes[1]];
            this.mRenderer.SetBlend(false);
            this.mRenderer.SetViewport(v);
            this.mRenderer.AttachShader(this.mProgramCopy);
            let l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, "pos");
            this.mRenderer.SetShaderConstant4FV("v", v);
            this.mRenderer.AttachTextures(1, buffer.mTexture[dstID], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);
            this.mRenderer.DettachTextures();
            this.mRenderer.DetachShader();
            this.mRenderer.GetPixelData( new Uint8Array(buffer.mThumbnailBuffer.data.buffer), buffer.mThumbnailRes[0], buffer.mThumbnailRes[1] );
            this.mRenderer.SetRenderTarget(null);
        }
        */
        buffers[bufferID].mLastRenderDone = 1 - buffers[bufferID].mLastRenderDone;
        this.mFrame++;
    }
    else if( this.mType==="cubemap" )
    {
        this.mEffect.ResizeCubemapBuffer(bufferID, 1024, 1024, false );

        let buffer = cubeBuffers[bufferID];

        xres = buffer.mResolution[0];
        yres = buffer.mResolution[1];
        let dstID = 1 - buffer.mLastRenderDone;
        for( let face=0; face<6; face++ )
        {
            this.mRenderer.SetRenderTargetCubeMap( buffer.mTarget[dstID], face );
            this.Paint_Cubemap( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face );
        }
        this.mRenderer.SetRenderTargetCubeMap( null, 0 );

        // compute mipmaps if needd
        if( bufferNeedsMimaps )
        {
            this.mRenderer.CreateMipmaps( buffer.mTexture[dstID]);
        }
        cubeBuffers[bufferID].mLastRenderDone = 1 - cubeBuffers[bufferID].mLastRenderDone;

        this.mFrame++;
    }

}

EffectPass.prototype.StopOutput_Sound = function( wa )
{
    if( this.mPlayNode===null ) return;
    this.mPlayNode.disconnect();

};

EffectPass.prototype.ResumeOutput_Sound = function( wa )
{
    if( this.mPlayNode===null ) return;

    wa.resume()
    this.mPlayNode.connect( this.mGainNode );
};

EffectPass.prototype.StopOutput_Image = function( wa )
{
};

EffectPass.prototype.ResumeOutput_Image = function( wa )
{
};

EffectPass.prototype.StopOutput = function( wa )
{
    for (let j=0; j<this.mInputs.length; j++ )
        this.StopInput(j);

    if( this.mType==="sound" )
         this.StopOutput_Sound( wa );
    else
         this.StopOutput_Image( wa );
}

EffectPass.prototype.ResumeOutput = function( wa )
{
    for (let j=0; j<this.mInputs.length; j++ )
        this.ResumeInput(j);

    if( this.mType==="sound" )
         this.ResumeOutput_Sound( wa );
    else
         this.ResumeOutput_Image( wa );
}

EffectPass.prototype.GetCompilationTime = function()
{
    return this.mCompilationTime;
}

//============================================================================================================
function Screenshots()
{
    // private
    let mTexture = null;
    let mTarget = null;
    let mXres = 0;
    let mYres = 0;
    let mCubemapToEquirectProgram;
    let mRenderer = null;

    // public
    var me = {};

    me.Initialize = function(renderer)
    {
        mRenderer = renderer;
        let caps = mRenderer.GetCaps();
        let is20 = caps.mIsGL20;


        let vsSourceC, fsSourceC;
        if( is20 )
        {
            vsSourceC = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
            fsSourceC = "uniform samplerCube t; out vec4 outColor; void main() { vec2 px = gl_FragCoord.xy/vec2(4096.0,2048.0); vec2 an = 3.1415926535898 * (px*vec2(2.0, 1.0) - vec2(0.0,0.5)); vec3 rd = vec3(-cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x)); outColor = texture(t, rd); }";
        }
        else
        {
            vsSourceC = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
            fsSourceC = "uniform samplerCube t; void main() { vec2 px = gl_FragCoord.xy/vec2(4096.0,2048.0); vec2 an = 3.1415926535898 * (px*vec2(2.0, 1.0) - vec2(0.0,0.5)); vec3 rd = vec3(-cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x)); gl_FragColor = texture(t, rd); }";
        }

        let compileShader = function (worked, info)
        {
            if (worked === false)
            {
                console.log("Failed to compile cubemap resample shader (" + errorType + "): " + log);
            }
            else
            {
                mCubemapToEquirectProgram = info;
            }
        }
        mRenderer.CreateShader(vsSourceC, fsSourceC, false, true, compileShader);

        return true;
    };

    me.Allocate = function( xres, yres )
    {
        if( xres>mXres || yres>mYres )
        {
            let texture = mRenderer.CreateTexture(mRenderer.TEXTYPE.T2D, xres, yres, mRenderer.TEXFMT.C4F32, mRenderer.FILTER.NONE, mRenderer.TEXWRP.CLAMP, null);
            let target = mRenderer.CreateRenderTarget( texture, null, null, null, null, false);

            if( mXres!==0 )
            {
                mRenderer.DestroyTexture(mTexture);
                mRenderer.DestroyRenderTarget(mTarget);
            }

            mTexture = texture;
            mTarget = target;
            mXres = xres;
            mYres = yres;
        }
    };

    me.GetProgram = function()
    {
        return mCubemapToEquirectProgram;
    };
    me.GetTarget = function()
    {
        return mTarget;
    };

    return me;
};

//============================================================================================================

function Effect(vr, ac, canvas, callback, obj, forceMuted, forcePaused, resizeCallback, crashCallback )
{
    let xres = canvas.width;
    let yres = canvas.height;

    let me = this;
    this.mCanvas = canvas;
    this.mCreated = false;
    this.mRenderer = null;
    this.mAudioContext = ac;
    this.mGLContext = null;
    this.mWebVR = vr;
    this.mRenderingStereo = false;
    this.mXres = xres;
    this.mYres = yres;
    this.mForceMuted = forceMuted;
    if( ac===null ) this.mForceMuted = true;
    this.mForcePaused = forcePaused;
    this.mGainNode = null;
    this.mPasses = [];
    this.mFrame = 0;
    this.mTextureCallbackFun = callback;
    this.mTextureCallbackObj = obj;
    this.mMaxBuffers = 4;
    this.mMaxCubeBuffers = 1;
    this.mMaxPasses = this.mMaxBuffers + 1 + 1 + 1 + 1; // some day decouple passes from buffers (4 buffers + common + Imagen + sound + cubemap)
    this.mBuffers = [];
    this.mCubeBuffers = [];
    this.mScreenshotSytem = null;
    this.mCompilationTime = 0;
    this.mIsLowEnd = piIsMobile();

    this.mGLContext = piCreateGlContext(canvas, false, false, true, false); // need preserve-buffe to true in order to capture screenshots
    if (this.mGLContext === null)
    {
        return;
    }

    canvas.addEventListener("webglcontextlost", function (event)
        {
            event.preventDefault();
            crashCallback();
        }, false);

    this.mRenderer = piRenderer();
    if (!this.mRenderer.Initialize(this.mGLContext))
        return;

    this.mScreenshotSytem = Screenshots();
    if (!this.mScreenshotSytem.Initialize(this.mRenderer))
        return;

    var caps = this.mRenderer.GetCaps();
    this.mIs20 = caps.mIsGL20;
    this.mShaderTextureLOD = caps.mShaderTextureLOD;
    //-------------
    if( ac!==null )
    {   
        this.mGainNode = ac.createGain();
        if( !forceMuted )
        {
            this.mGainNode.connect( ac.destination);
        }
        if (this.mForceMuted )
            this.mGainNode.gain.value = 0.0;
        else
            this.mGainNode.gain.value = 1.0;
    }

    //-------------
    let vsSourceC, fsSourceC;
    if( this.mIs20 )
    {
        vsSourceC = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceC = "uniform vec4 v; uniform sampler2D t; out vec4 outColor; void main() { outColor = textureLod(t, gl_FragCoord.xy / v.zw, 0.0); }";
    }
    else
    {
        vsSourceC = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceC = "uniform vec4 v; uniform sampler2D t; void main() { gl_FragColor = texture2D(t, gl_FragCoord.xy / v.zw, -100.0); }";
    }

    this.mRenderer.CreateShader(vsSourceC, fsSourceC, false, true, function(worked, info)
        {
            if (worked === false) console.log("Failed to compile shader to copy buffers : " + info.mErrorStr);
            else me.mProgramCopy = info;
        });

    let vsSourceD, fsSourceD;
    if( this.mIs20 )
    {
        vsSourceD = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceD = "uniform vec4 v; uniform sampler2D t; out vec4 outColor; void main() { vec2 uv = gl_FragCoord.xy / v.zw; outColor = texture(t, vec2(uv.x,1.0-uv.y)); }";
    }
    else
    {
        vsSourceD = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceD = "uniform vec4 v; uniform sampler2D t; void main() { vec2 uv = gl_FragCoord.xy / v.zw; gl_FragColor = texture2D(t, vec2(uv.x,1.0-uv.y)); }";
    }

    this.mRenderer.CreateShader(vsSourceD, fsSourceD, false, true, function (worked, info)
        {
            if (worked === false) console.log("Failed to compile shader to downscale buffers : " + info.mErrorStr);
            else me.mProgramDownscale = info;
        });


    // set all buffers and cubemaps to null
    for( let i=0; i<this.mMaxBuffers; i++ )
    {
        this.mBuffers[i] = { mTexture: [null, null], 
                             mTarget:  [null, null], 
                             mResolution: [0, 0],
                             mLastRenderDone: 0,
                             mThumbnailRenderTarget: null,
                             mThumbnailTexture: null,
                             mThumbnailBuffer:  null,
                             mThumbnailRes: [0, 0] };
    }

    for( let i=0; i<this.mMaxCubeBuffers; i++ )
    {
        this.mCubeBuffers[i] = { mTexture: [null, null], 
                                mTarget:  [null, null], 
                                mResolution: [0, 0],
                                mLastRenderDone: 0,
                                mThumbnailRenderTarget: null,
                                mThumbnailTexture: null,
                                mThumbnailBuffer:  null,
                                mThumbnailRes: [0, 0] };
    }

    //-------

    let keyboardData = new Uint8Array( 256*3 );
    for (let j=0; j<(256*3); j++ ) { keyboardData[j] = 0; }
    let kayboardTexture = this.mRenderer.CreateTexture( this.mRenderer.TEXTYPE.T2D, 256, 3, this.mRenderer.TEXFMT.C1I8, this.mRenderer.FILTER.NONE, this.mRenderer.TEXWRP.CLAMP, null);
    let keyboardImage = new Image();
    if( callback!==null )
        keyboardImage.src = "/img/keyboard.png"; // don't load PNG if no UI 
    this.mKeyboard = { mData: keyboardData, mTexture: kayboardTexture, mIcon: keyboardImage };

    let iResize = function( xres, yres )
    {
        me.mCanvas.width = xres;
        me.mCanvas.height = yres;
        me.mXres = xres;
        me.mYres = yres;
        me.ResizeBuffers(xres, yres);
        resizeCallback(xres, yres);
    };

    let bestAttemptFallback = function()
    {
        let devicePixelRatio = window.devicePixelRatio || 1;
        let xres = Math.round(me.mCanvas.offsetWidth  * devicePixelRatio) | 0;
        let yres = Math.round(me.mCanvas.offsetHeight * devicePixelRatio) | 0;
        iResize(xres, yres);
    };

    if(!window.ResizeObserver)
    {
        console.log("WARNING: This browser doesn't support ResizeObserver.");
        bestAttemptFallback();
        window.addEventListener("resize", bestAttemptFallback);
    }
    else
    {
        this.mRO = new ResizeObserver( function(entries, observer)
        {
            var entry = entries[0];
            if (!entry['devicePixelContentBoxSize'])
            {
                observer.unobserve(me.mCanvas);
                console.log("WARNING: This browser doesn't support ResizeObserver + device-pixel-content-box (2)");
                bestAttemptFallback();
                window.addEventListener("resize", bestAttemptFallback);
            }
            else
            {
                let box = entry.devicePixelContentBoxSize[0];
                let xres = box.inlineSize;
                let yres = box.blockSize;
                iResize(xres, yres);
            }
        });
        try
        {
            this.mRO.observe(this.mCanvas, { box: ["device-pixel-content-box"] });
            //this.mRO.observe(this.mCanvas);
        }
        catch (e)
        {
            console.log("WARNING: This browser doesn't support ResizeObserver + device-pixel-content-box (1)");
            bestAttemptFallback();
            window.addEventListener("resize", bestAttemptFallback);
        }
    }

    this.mCreated = true;
}


Effect.prototype.ResizeCubemapBuffer = function(i, xres, yres )
{
    let oldXres = this.mCubeBuffers[i].mResolution[0];
    let oldYres = this.mCubeBuffers[i].mResolution[1];

    if( this.mCubeBuffers[i].mTexture[0]===null || oldXres !== xres || oldYres !== yres )
    {
        let texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.CUBEMAP,
            xres, yres,
            this.mRenderer.TEXFMT.C4F16,
            this.mRenderer.FILTER.LINEAR,
            this.mRenderer.TEXWRP.CLAMP, 
            null);
        let target1 = this.mRenderer.CreateRenderTargetCubeMap( texture1, null, false);

        let texture2 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.CUBEMAP,
            xres, yres,
            this.mRenderer.TEXFMT.C4F16,
            this.mRenderer.FILTER.LINEAR,
            this.mRenderer.TEXWRP.CLAMP, 
            null);

        let target2 = this.mRenderer.CreateRenderTargetCubeMap( texture2, null, false);

        // Store new buffers
        this.mCubeBuffers[i].mTexture = [texture1,texture2], 
        this.mCubeBuffers[i].mTarget =  [target1, target2 ], 
        this.mCubeBuffers[i].mLastRenderDone = 0;
        this.mCubeBuffers[i].mResolution[0] = xres;
        this.mCubeBuffers[i].mResolution[1] = yres;
    }
}


Effect.prototype.ResizeBuffer = function( i, xres, yres, skipIfNotExists )
{
    if( skipIfNotExists && this.mBuffers[i].mTexture[0]===null ) return;

    let oldXres = this.mBuffers[i].mResolution[0];
    let oldYres = this.mBuffers[i].mResolution[1];

    if( oldXres !== xres || oldYres !== yres )
    {
        let needCopy = (this.mBuffers[i].mTexture[0]!==null);

        let texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,
            xres, yres,
            this.mRenderer.TEXFMT.C4F32,
            (needCopy) ? this.mBuffers[i].mTexture[0].mFilter : this.mRenderer.FILTER.NONE,
            (needCopy) ? this.mBuffers[i].mTexture[0].mWrap   : this.mRenderer.TEXWRP.CLAMP, 
            null);

        let texture2 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,
            xres, yres,
            this.mRenderer.TEXFMT.C4F32,
            (needCopy) ? this.mBuffers[i].mTexture[1].mFilter : this.mRenderer.FILTER.NONE,
            (needCopy) ? this.mBuffers[i].mTexture[1].mWrap   : this.mRenderer.TEXWRP.CLAMP, 
            null);

        let target1 = this.mRenderer.CreateRenderTarget( texture1, null, null, null, null, false);
        let target2 = this.mRenderer.CreateRenderTarget( texture2, null, null, null, null, false);

        if( needCopy )
        {
            let v = [0, 0, Math.min(xres, oldXres), Math.min(yres, oldYres)];
            this.mRenderer.SetBlend(false);
            this.mRenderer.SetViewport(v);
            this.mRenderer.AttachShader(this.mProgramCopy);
            let l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, "pos");
            let vOld = [0, 0, oldXres, oldYres];
            this.mRenderer.SetShaderConstant4FV("v", vOld);

            // Copy old buffers 1 to new buffer
            this.mRenderer.SetRenderTarget(target1);
            this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[0], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);

            // Copy old buffers 2 to new buffer
            this.mRenderer.SetRenderTarget(target2);
            this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[1], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);

            // Deallocate old memory
            this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[0]);
            this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[0]);
            this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[1]);
            this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[1]);
            //this.mRenderer.DestroyTexture(this.mBuffers[i].thumbnailTexture);
        }

        // Store new buffers
        this.mBuffers[i].mTexture = [texture1,texture2], 
        this.mBuffers[i].mTarget =  [target1, target2 ], 
        this.mBuffers[i].mLastRenderDone = 0;
        this.mBuffers[i].mResolution[0] = xres;
        this.mBuffers[i].mResolution[1] = yres;
    }
}

Effect.prototype.saveScreenshot = function(passid)
{
    let pass = this.mPasses[passid];

    if( pass.mType === "buffer" )
    {
        let bufferID = assetID_to_bufferID( this.mPasses[passid].mOutputs[0] );

        let texture = this.mBuffers[bufferID].mTarget[ this.mBuffers[bufferID].mLastRenderDone ];

        let numComponents = 3;
        let width = texture.mTex0.mXres;
        let height = texture.mTex0.mYres;
        let type = "Float"; // Other options Float, Half, Uint
        let bytes = new Float32Array(width * height * 4 );//numComponents);
        this.mRenderer.GetPixelDataRenderTarget( texture, bytes, width, height );
        let blob = piExportToEXR(width, height, numComponents, type, bytes);

        // Offer download automatically to the user
        piTriggerDownload("image.exr", blob);
    }
    else if( pass.mType === "cubemap" )
    {
        let xres = 4096;
        let yres = 2048;
        this.mScreenshotSytem.Allocate( xres, yres );

        let cubeBuffer = this.mCubeBuffers[0];

        let target = this.mScreenshotSytem.GetTarget();
        this.mRenderer.SetRenderTarget( target );

        let program = this.mScreenshotSytem.GetProgram();

        this.mRenderer.AttachShader(program);
        let l1 = this.mRenderer.GetAttribLocation(program, "pos");
        this.mRenderer.SetViewport( [0, 0, xres, yres] );
        this.mRenderer.AttachTextures(1, cubeBuffer.mTexture[ cubeBuffer.mLastRenderDone ], null, null, null);
        this.mRenderer.DrawUnitQuad_XY(l1);
        this.mRenderer.DettachTextures();
        this.mRenderer.SetRenderTarget( null );

        let data = new Float32Array(xres*yres*4);
        this.mRenderer.GetPixelDataRenderTarget( target, data, xres, yres );

        let blob = piExportToEXR(xres, yres, 3, "Float", data );
        piTriggerDownload("image.exr", blob);
    }
    else if( pass.mType === "sound" )
    {
        let offset = 0;
        const bits = 16;
        const numChannels = 2;
        let words = new Int16Array(60*pass.mSampleRate*numChannels );

        pass.iRenderSound( new Date(), function(off, data, numSamples)
                                         {
                                            for( let i=0; i<numSamples; i++ )
                                            {
                                                words[offset++] = (data[4*i+0]+256.0*data[4*i+1]) - 32767;
                                                words[offset++] = (data[4*i+2]+256.0*data[4*i+3]) - 32767;
                                            }
                                         }
                                     );

        let blob = piExportToWAV( 60*pass.mSampleRate, pass.mSampleRate, bits, numChannels, words);

        piTriggerDownload("sound.wav", blob);
    }    
}

Effect.prototype.ResizeBuffers = function(xres, yres)
{
    for (let i=0; i<this.mMaxBuffers; i++ )
    {
        this.ResizeBuffer(i, xres, yres, true);
    }
}

Effect.prototype.IsEnabledVR = function ()
{
    if (this.mRenderingStereo) return true;
    return false;
}

Effect.prototype.EnableVR = function()
{
    if( !this.mWebVR.IsSupported() ) return;
    if( this.mRenderingStereo ) return;

    this.mRenderingStereo = true;
    this.mWebVR.Enable();
}

Effect.prototype.DisableVR = function()
{
    if( !this.mWebVR.IsSupported() ) return;
    if( !this.mRenderingStereo ) return;

    this.mRenderingStereo = false;
    this.mWebVR.Disable();
}

Effect.prototype.GetTexture = function( passid, slot )
{
    return this.mPasses[passid].GetTexture( slot );
}

Effect.prototype.NewTexture = function( passid, slot, url )
{
    return this.mPasses[passid].NewTexture( this.mAudioContext, slot, url, this.mBuffers, this.mCubeBuffers, this.mKeyboard );
}

Effect.prototype.SetOutputs = function( passid, slot, url )
{
    this.mPasses[passid].SetOutputs( slot, url );
}

Effect.prototype.SetOutputsByBufferID = function( passid, slot, id )
{
    this.mPasses[passid].SetOutputsByBufferID( slot, id );
}

Effect.prototype.GetAcceptsLinear = function (passid, slot) 
{
    return this.mPasses[passid].GetAcceptsLinear(slot);
}

Effect.prototype.GetAcceptsMipmapping = function (passid, slot) 
{
    return this.mPasses[passid].GetAcceptsMipmapping(slot);
}

Effect.prototype.GetAcceptsWrapRepeat = function (passid, slot) 
{
    return this.mPasses[passid].GetAcceptsWrapRepeat(slot);
}

Effect.prototype.GetAcceptsVFlip = function (passid, slot)
{
    return this.mPasses[passid].GetAcceptsVFlip(slot);
}

Effect.prototype.SetSamplerFilter = function (passid, slot, str) 
{
    this.mPasses[passid].SetSamplerFilter(slot, str, this.mBuffers, this.mCubeBuffers);
}

Effect.prototype.GetTranslatedShaderSource = function (passid)
{
    return this.mPasses[passid].GetTranslatedShaderSource();
}

Effect.prototype.GetSamplerFilter = function (passid, slot) {
    return this.mPasses[passid].GetSamplerFilter(slot);
}

Effect.prototype.SetSamplerWrap = function (passid, slot, str) {
    this.mPasses[passid].SetSamplerWrap(slot, str, this.mBuffers);
}

Effect.prototype.GetSamplerWrap = function (passid, slot) {
    return this.mPasses[passid].GetSamplerWrap(slot);
}

Effect.prototype.SetSamplerVFlip = function (passid, slot, str) {
    this.mPasses[passid].SetSamplerVFlip(slot, str);
}

Effect.prototype.GetSamplerVFlip = function (passid, slot) {
    return this.mPasses[passid].GetSamplerVFlip(slot);
}

Effect.prototype.GetHeaderSize = function (passid)
{
    return this.mPasses[passid].mHeaderLength + 
           this.mRenderer.GetShaderHeaderLines(1);
 
}

Effect.prototype.ToggleVolume = function()
{
    this.mForceMuted = !this.mForceMuted;

    // outp
    if (this.mForceMuted)
        this.mGainNode.gain.value = 0.0;
    else
        this.mGainNode.gain.value = 1.0;

    // inp
    let num = this.mPasses.length;
    for( let j=0; j<num; j++ )
    {
        for( let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            if( this.mForceMuted )
                this.mPasses[j].MuteInput( this.mAudioContext, i );
            else
                this.mPasses[j].UnMuteInput( this.mAudioContext, i );
        }
    }

    return this.mForceMuted;
}

Effect.prototype.SetKeyDown = function( passid, k )
{
    if( this.mKeyboard.mData[ k + 0*256 ] == 255 ) return;

    this.mKeyboard.mData[ k + 0*256 ] = 255;
    this.mKeyboard.mData[ k + 1*256 ] = 255;
    this.mKeyboard.mData[ k + 2*256 ] = 255 - this.mKeyboard.mData[ k + 2*256 ];
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    let num = this.mPasses.length;
    for (let j=0; j<num; j++ )
    {
        for (let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            let inp = this.mPasses[j].mInputs[i];
            if( inp!==null && inp.mInfo.mType==="keyboard" )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:this.mKeyboard.mIcon, mData: this.mKeyboard.mData}, false, 6, 1, -1.0, this.mPasses[j].mID );
            }
        }
    }
}

Effect.prototype.SetKeyUp = function( passid, k )
{
    this.mKeyboard.mData[ k + 0*256 ] = 0;
    this.mKeyboard.mData[ k + 1*256 ] = 0;
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    let num = this.mPasses.length;
    for (let j=0; j<num; j++ )
    {
        for (let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            let inp = this.mPasses[j].mInputs[i];
            if( inp!==null && inp.mInfo.mType==="keyboard" )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:this.mKeyboard.mIcon, mData: this.mKeyboard.mData}, false, 6, 1, -1.0, this.mPasses[j].mID );
            }
        }
    }

}

Effect.prototype.StopOutputs = function()
{
    let wa = this.mAudioContext;

    let num = this.mPasses.length;
    for (let i=0; i<num; i++ )
    {
        this.mPasses[i].StopOutput( wa );
    }
}

Effect.prototype.ResumeOutputs = function()
{
    let wa = this.mAudioContext;

    let num = this.mPasses.length;
    for (let i=0; i<num; i++ )
    {
        this.mPasses[i].ResumeOutput( wa );
    }
}

Effect.prototype.PauseInput = function( passid, id )
{
    return this.mPasses[passid].TooglePauseInput( this.mAudioContext, id );
}

Effect.prototype.ToggleMuteInput = function( passid, id )
{
    return this.mPasses[passid].ToggleMuteInput( this.mAudioContext, id );
}

Effect.prototype.RewindInput = function( passid, id )
{
    this.mPasses[passid].RewindInput( this.mAudioContext, id );
}

Effect.prototype.UpdateInputs = function( passid, forceUpdate )
{
   this.mPasses[passid].UpdateInputs( this.mAudioContext, forceUpdate, this.mKeyboard );
}

Effect.prototype.ResetTime = function()
{
    this.mFrame = 0;
    this.mAudioContext.resume()

    let num = this.mPasses.length;
    for( let i=0; i<num; i++ )
    {
        this.mPasses[i].mFrame = 0;
        for( let j=0; j<this.mPasses[i].mInputs.length; j++ )
            this.mPasses[i].RewindInput(this.mAudioContext, j)
    }
}

Effect.prototype.RequestAnimationFrame = function (id)
{
    if (this.mRenderingStereo && this.mWebVR.IsPresenting())
    {
        this.mWebVR.RequestAnimationFrame(id);
    }
    else
    {
        requestAnimFrame(id);
    }
}

Effect.prototype.Paint = function(time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, isPaused)
{
    let wa = this.mAudioContext;
    let da = new Date();
    let vrData = null; if (this.mRenderingStereo) vrData = this.mWebVR.GetData();
    let xres = this.mXres / 1;
    let yres = this.mYres / 1;

    if( this.mFrame===0 )
    {
        for( let i=0; i<this.mMaxBuffers; i++ )
        {
            if( this.mBuffers[i].mTexture[0]!==null )
            {
                this.mRenderer.SetRenderTarget( this.mBuffers[i].mTarget[0] );
                this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
                this.mRenderer.SetRenderTarget( this.mBuffers[i].mTarget[1] );
                this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
				
				this.mRenderer.CreateMipmaps( this.mBuffers[i].mTexture[0] );
				this.mRenderer.CreateMipmaps( this.mBuffers[i].mTexture[1] );
            }
        }
        for( let i=0; i<this.mMaxCubeBuffers; i++ )
        {
            if( this.mCubeBuffers[i].mTexture[0]!==null )
            {
                for( let face=0; face<6; face++ )
                {
                    this.mRenderer.SetRenderTargetCubeMap( this.mCubeBuffers[i].mTarget[0], face );
                    this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
                    this.mRenderer.SetRenderTargetCubeMap( this.mCubeBuffers[i].mTarget[1], face );
                    this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
					this.mRenderer.CreateMipmaps( this.mCubeBuffers[i].mTexture[0] );
				    this.mRenderer.CreateMipmaps( this.mCubeBuffers[i].mTexture[1] );
                }
            }
        }
    }

    let num = this.mPasses.length;

    // render sound first
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "sound" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, null, false, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render buffers second
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "buffer" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        let bufferID = assetID_to_bufferID( this.mPasses[i].mOutputs[0] );

        // check if any downstream pass needs mipmaps when reading from this buffer
        let needMipMaps = false;
        for (let j=0; j<num; j++ )
        {
            for (let k=0; k<this.mPasses[j].mInputs.length; k++ )
            {
                let inp = this.mPasses[j].mInputs[k];
                if( inp!==null && inp.mInfo.mType==="buffer" && inp.id === bufferID && inp.mInfo.mSampler.filter === "mipmap")
                {
                    needMipMaps = true;
                    break;
                }
            }
        }

        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, needMipMaps, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }


    // render cubemap buffers second
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "cubemap" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        let bufferID = 0;//assetID_to_bufferID( this.mPasses[i].mOutputs[0] );

        // check if any downstream pass needs mipmaps when reading from this buffer
        let needMipMaps = false;

        for (let j=0; j<num; j++ )
        {
            for (let k=0; k<this.mPasses[j].mInputs.length; k++ )
            {
                let inp = this.mPasses[j].mInputs[k];
                if( inp!==null && inp.mInfo.mType==="cubemap" )
                {
                    if( assetID_to_cubemapBuferID(inp.mInfo.mID)===0 && inp.mInfo.mSampler.filter === "mipmap" )
                    {
                        needMipMaps = true;
                        break;
                    }
                }
            }
        }

        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, needMipMaps, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render image last
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "image" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, null, false, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }   

    // erase keypresses
    for (let k=0; k<256; k++ )
    {
       this.mKeyboard.mData[ k + 1*256 ] = 0;
    }
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    if( this.mRenderingStereo ) this.mWebVR.Finish();

    this.mFrame++;
}

Effect.prototype.NewShader = function( passid, preventCache, onResolve )
{
    let commonSourceCodes = [];
    for (let i=0; i<this.mPasses.length; i++ )
    {
        if( this.mPasses[i].mType==="common")
        {
            commonSourceCodes.push(this.mPasses[i].mSource);
        }
    }

    this.mPasses[passid].NewShader(commonSourceCodes, preventCache, onResolve );
}

Effect.prototype.GetNumPasses = function()
{
    return this.mPasses.length;
}

Effect.prototype.GetNumOfType = function(passtype)
{
    let id = 0;
    for (let j=0; j<this.mPasses.length; j++ )
    {
        if( this.mPasses[j].mType===passtype )
        {
            id++;
        }
    }
    return id;
}

Effect.prototype.GetPassType = function( id )
{
    return this.mPasses[id].mType;
}
Effect.prototype.GetPassName = function( id )
{
    return this.mPasses[id].mName;
}
Effect.prototype.GetCode = function( id )
{
    return this.mPasses[id].mSource;
}
Effect.prototype.SetCode = function( id, source )
{
    this.mPasses[id].SetCode(source);
}
Effect.prototype.GetError = function (id)
{
    return this.mPasses[id].mError;
}
Effect.prototype.GetErrorStr = function (id)
{
    return this.mPasses[id].mErrorStr;
}
Effect.prototype.GetErrorGlobal = function()
{
    for (let i = 0; i < this.mPasses.length; i++)
    {
        if (this.mPasses[i].mError)
        {
            return true;
        }
    }
    return false;
}

Effect.prototype.Load = function (jobj )
{
    if (jobj.ver !== "0.1")
    {
        console.log("Wrong Format");
        return false;
    }

    let numPasses = jobj.renderpass.length;

    if( numPasses<1 || numPasses>this.mMaxPasses )
    {
        console.log("Corrupted Shader - " + numPasses);
        return false;
    }

    this.mPasses = [];
    for (let j = 0; j < numPasses; j++)
    {
        let rpass = jobj.renderpass[j];

        // skip sound passes if in thumbnail mode
        if( this.mForceMuted && rpass.type === "sound" ) continue;

        let wpass = new EffectPass(this.mRenderer, this.mIs20, this.mIsLowEnd, this.mShaderTextureLOD,
                                   this.mTextureCallbackFun, this.mTextureCallbackObj, this.mForceMuted, this.mForcePaused, this.mGainNode,
                                   this.mProgramDownscale, j, this);

        wpass.Create(rpass.type, this.mAudioContext);

        let numInputs = rpass.inputs.length;

        for (let i = 0; i < 4; i++)
        {
            wpass.NewTexture(this.mAudioContext, i, null, null, null);
        }
        for (let i = 0; i < numInputs; i++)
        {
            let lid  = rpass.inputs[i].channel;
            let styp = rpass.inputs[i].type;
            let sid  = rpass.inputs[i].id;
            let ssrc = rpass.inputs[i].filepath;
            let psrc = rpass.inputs[i].previewfilepath;
            let samp = rpass.inputs[i].sampler;

            wpass.NewTexture(this.mAudioContext, lid, { mType: styp, mID: sid, mSrc: ssrc, mSampler: samp, mPreviewSrc: psrc }, this.mBuffers, this.mCubeBuffers, this.mKeyboard);
        }

        for (let i = 0; i < 4; i++)
        {
            wpass.SetOutputs(i, null);
        }

        let numOutputs = rpass.outputs.length;
        for (let i = 0; i < numOutputs; i++)
        {
            let outputID = rpass.outputs[i].id;
            let outputCH = rpass.outputs[i].channel;
            wpass.SetOutputs(outputCH, outputID);
        }

        // create some hardcoded names. This should come from the DB
        let rpassName = "";
        if (rpass.type === "common" ) rpassName = "Common";
        if (rpass.type === "sound"  ) rpassName = "Sound";
        if (rpass.type === "image"  ) rpassName = "Image";
        if (rpass.type === "buffer") rpassName = "Buffer " + String.fromCharCode(65 + assetID_to_bufferID(wpass.mOutputs[0]));
        if (rpass.type === "cubemap") rpassName = "Cube A";// " + String.fromCharCode(65 + assetID_to_bufferID(this.mPasses[j].mOutputs[0]));
        wpass.SetName(rpassName);
        wpass.SetCode(rpass.code);

        this.mPasses.push(wpass);
    }
    return true;
}

Effect.prototype.CompileSome = function ( passes, preventCache, onResolve )
{
    let me = this;

    let to = getRealTime();
    let allPromisses = [];
    for (let j = 0; j < passes.length; j++)
    {
        allPromisses.push(new Promise(function (resolve, reject)
        {
            me.NewShader(passes[j], preventCache, function () { resolve(1); });
        }));
    }

    // aggregated callback when all passes have been compiled
    Promise.all(allPromisses).then(function (values)
    {
        let totalError = false;
        for (let j = 0; j < me.mPasses.length; j++)
        {
            if (me.mPasses[j].mError)
            {
                totalError = true;
                break;
            }
        }
        me.mCompilationTime = getRealTime() - to;
        onResolve(!totalError);
    }).catch(console.log);
}

Effect.prototype.Compile = function (preventCache, onResolve )
{
    let me = this;

    let to = getRealTime();
    let allPromisses = [];
    let numPasses = this.mPasses.length;
    for (let j = 0; j < numPasses; j++)
    {
        allPromisses.push(new Promise(function (resolve, reject)
        {
            me.NewShader(j, preventCache, function () { resolve(1); });
        }));
    }

    // aggregated callback when all passes have been compiled
    Promise.all(allPromisses).then(function (values)
    {
        let totalError = false;
        for (let j = 0; j < numPasses; j++)
        {
            if (me.mPasses[j].mError)
            {
                totalError = true;
                break;
            }
        }
        me.mCompilationTime = getRealTime() - to;
        onResolve(!totalError);
    }).catch(console.log);
}

Effect.prototype.GetCompilationTime = function( id )
{
    return this.mPasses[id].GetCompilationTime()/1000.0;
}
Effect.prototype.GetTotalCompilationTime = function()
{
    return this.mCompilationTime/1000.0;
}

Effect.prototype.DestroyPass = function( id )
{
   this.mPasses[id].Destroy( this.mAudioContext );
   this.mPasses.splice(id, 1);
}

Effect.prototype.AddPass = function( passType, passName, onResolve )
{
    let shaderStr = null;

    if( passType==="sound"   ) shaderStr = "vec2 mainSound( int samp, float time )\n{\n    // A 440 Hz wave that attenuates quickly overt time\n    return vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );\n}";
    if( passType==="buffer"  ) shaderStr = "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}";
    if( passType==="common"  ) shaderStr = "vec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}";
    if( passType==="cubemap" ) shaderStr = "void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Ray direction as color\n    vec3 col = 0.5 + 0.5*rayDir;\n\n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}";

    let id = this.GetNumPasses();
    this.mPasses[id] = new EffectPass( this.mRenderer, this.mIs20, this.mIsLowEnd, this.mShaderTextureLOD,
                                       this.mTextureCallbackFun, this.mTextureCallbackObj, this.mForceMuted, this.mForcePaused, this.mGainNode, 
                                       this.mProgramDownscale, id, this );

    this.mPasses[id].Create( passType, this.mAudioContext );
    this.mPasses[id].SetName( passName );
    this.mPasses[id].SetCode( shaderStr );
    this.NewShader(id, false, function ()
    {
        onResolve();
    });

    return { mId : id, mShader : shaderStr };
}

// this should be removed once we have MultiPass 2.0 and passes render to arbitrary buffers
Effect.prototype.IsBufferPassUsed = function( bufferID )
{
    for (let j=0; j<this.mPasses.length; j++ )
    {
        if( this.mPasses[j].mType !== "buffer" ) continue;
        if( this.mPasses[j].mOutputs[0] === bufferID_to_assetID(bufferID) ) return true;
    }
    return false;
}

Effect.prototype.Save = function()
{
    var result = {};

    result.ver = "0.1";

    result.renderpass = [];

    let numPasses = this.mPasses.length;
    for (let j=0; j<numPasses; j++ )
    {
        result.renderpass[j] = {};

        result.renderpass[j].outputs = new Array();
        for (let i = 0; i<4; i++ )
        {
            let outputID = this.mPasses[j].mOutputs[i];
            if( outputID===null ) continue;
            result.renderpass[j].outputs.push( { channel: i, id: outputID } );
        }
        result.renderpass[j].inputs = new Array();
        for (let i = 0; i<4; i++ )
        {
            if( this.mPasses[j].mInputs[i]===null ) continue;
            result.renderpass[j].inputs.push( {channel: i,
                                               type    : this.mPasses[j].mInputs[i].mInfo.mType,
                                               id      : this.mPasses[j].mInputs[i].mInfo.mID,
                                               filepath: this.mPasses[j].mInputs[i].mInfo.mSrc,
                                               sampler : this.mPasses[j].mInputs[i].mInfo.mSampler });
        }

        result.renderpass[j].code = this.mPasses[j].mSource;
        result.renderpass[j].name = this.mPasses[j].mName
        result.renderpass[j].description = "";
        result.renderpass[j].type = this.mPasses[j].mType;
    }

    result.flags = this.calcFlags();

    return result;
}

Effect.prototype.calcFlags = function ()
{
    let flagVR = false;
    let flagWebcam = false;
    let flagSoundInput = false;
    let flagSoundOutput = false;
    let flagKeyboard = false;
    let flagMultipass = false;
    let flagMusicStream = false;

    let numPasses = this.mPasses.length;
    for (let j = 0; j < numPasses; j++)
    {
        let pass = this.mPasses[j];

        if (pass.mType === "sound") flagSoundOutput = true;
        if (pass.mType === "buffer") flagMultipass = true;

        for (let i = 0; i < 4; i++)
        {
            if (pass.mInputs[i] === null) continue;

            if (pass.mInputs[i].mInfo.mType === "webcam") flagWebcam = true;
            else if (pass.mInputs[i].mInfo.mType === "keyboard") flagKeyboard = true;
            else if (pass.mInputs[i].mInfo.mType === "mic") flagSoundInput = true;
            else if (pass.mInputs[i].mInfo.mType === "musicstream") flagMusicStream = true;
        }

        let n1 = pass.mSource.indexOf("mainVR(");
        let n2 = pass.mSource.indexOf("mainVR (");
        if (n1 > 0 || n2 > 0) flagVR = true;
    }

    return {
        mFlagVR: flagVR,
        mFlagWebcam: flagWebcam,
        mFlagSoundInput: flagSoundInput,
        mFlagSoundOutput: flagSoundOutput,
        mFlagKeyboard: flagKeyboard,
        mFlagMultipass: flagMultipass,
        mFlagMusicStream: flagMusicStream
    };
}</script>
    <script>"use strict"

const kMaxCompileTime = 10.0;

function iReportCrash(shaderID)
{
    let req = new XMLHttpRequest();
    req.onload = function ()
    {
        let jsn = req.response;
        if (jsn === null) return;
        if (jsn.result === 0)
        {
            // yep
        }
    };
    req.open("POST", "/shadertoy", true);
    req.responseType = "json";
    req.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    req.send( "s=" + shaderID + "&r=2" );
}
</script>
    <script>"use strict"

var gActive = -1;
var mShaders = [];
var gNumCanvases = 0;

function myrefresh( id, slot, img, forceFrame, gui, guiID, renderID, time )
{
    if( mShaders[id].mReady===false ) return;
    if( forceFrame )
    {
        if (mShaders[id].mScreenshot === false)
        {
            mShaders[id].gEffect.Paint(mShaders[id].mTime / 1000.0, 1.0 / 60.0, 60.0, 0, 0, 0, 0, false);
        }
    }
}

function startRendering()
{
    if( gActive<0 ) return;
    if( mShaders[gActive].mReady===false ) return;
    if( mShaders[gActive].mScreenshot===true ) return;

    let time = getRealTime();

    mShaders[gActive].mFPS.Count( time );
    mShaders[gActive].mTime = mShaders[gActive].mTime0 + (time - mShaders[gActive].mTo);
    let dtime = 1000.0/60.0;
    mShaders[gActive].gEffect.Paint( mShaders[gActive].mTime/1000.0, dtime/1000.0, mShaders[gActive].mFPS.GetFPS(), 0,0,0,0, false);

    requestAnimFrame( startRendering );
}

function iLoadAndCompile(jsn, i )
{
    var shaderObj = jsn[i];
    if (shaderObj === null) return;

    var resizeCB = function (xres, yres) { myrefresh(i, 0, null, true, false, 0, -1.0) };
    var crashCB = function () { alert('crash');/*iReportCrash(gShaderIDs[i])*/ };
    mShaders[i].gEffect = new Effect(null, null, mShaders[i].mPreview.mCanvas, myrefresh, i, true, true, resizeCB, crashCB);

    if (!mShaders[i].gEffect.Load(shaderObj)) return;

    mShaders[i].gEffect.Compile(false, function (worked)
    {
        if (worked === true)
        {
            previewShowRender(mShaders[i].mPreview);

            mShaders[i].mScreenshot = false;
            mShaders[i].mReady = true;
            mShaders[i].mTime = 10.0 * 1000.0;
            mShaders[i].mTime0 = 0.0;
            mShaders[i].mTo = 0.0;
            mShaders[i].mFPS = piCreateFPSCounter();
            mShaders[i].mPreview.mCanvas.addEventListener("mouseout", function (ev) { gActive = -1; }, true);
            mShaders[i].mPreview.mBase.addEventListener("mouseover", function (ev) { if (mShaders[i].mPreview.mUI !== null) mShaders[i].mPreview.mUI.classList.add('isVisible'); }, true);
            mShaders[i].mPreview.mBase.addEventListener("mouseout", function (ev) { if (mShaders[i].mPreview.mUI !== null) mShaders[i].mPreview.mUI.classList.remove('isVisible'); }, true);
            mShaders[i].mPreview.mCanvas.addEventListener("mouseover", function (ev)
            {
                let ele = piGetSourceElement(ev);
                if (ele.mId === undefined) return;

                gActive = ele.mId;
                if (!mShaders[gActive].mReady) return;
                let time = getRealTime();
                mShaders[gActive].mTo = time;
                mShaders[gActive].mTime0 = mShaders[gActive].mTime;
                mShaders[gActive].mFPS.Reset(time);

                startRendering();
            }, true);


            /*
            let compilationTime = mShaders[i].gEffect.GetTotalCompilationTime();
            if (compilationTime > kMaxCompileTime)
            {
                iReportCrash(mShaders[i].mShaderID);
            }*/

            myrefresh(i, null, null, true, false, 0, -1.0);
        }
        else
        {
            mShaders[i].mReady = false;
            previewShowError(mShaders[i].mPreview);
        }
    });
};


function iProcessShader( jsn, i )
{
    var shaderObj = jsn[i];
    if( shaderObj===null ) return;

    if ((shaderObj.info.usePreview === 0 && !gUseScreenshots) || (mShaders[i].mPreviewReady !== 1))
    {
        iLoadAndCompile(jsn, i);
    }
    else
    {
        mShaders[i].mScreenshot = true;
        if( shaderObj.info.usePreview === 1 )
            previewShowScreenshot(mShaders[i].mPreview, 1); // comp
        else if (gUseScreenshots)
            previewShowScreenshot(mShaders[i].mPreview, 2); // sett
    }

    if( i<(jsn.length-1) ) setTimeout( function(){iProcessShader(jsn,i+1);}, 10 );
}

function iInitUI(numCanvases, uiCallback, windowTitle)
{
    gNumCanvases = numCanvases;
    document.getElementById("mySearch").focus();

    //-----------------------------------------------------------------
    // window
    //-----------------------------------------------------------------
    if (windowTitle !== null) {
        document.title = windowTitle;
    }

    //-----------------------------------------------------------------
    // ui
    //-----------------------------------------------------------------
    var num = Math.min(gShaders.length, gNumCanvases);

    //var base = document.getElementsByClassName( "searchResult" );

    for (let i = 0; i < gNumCanvases; i++)
    {
        let pv = createPreview(i);

        if (i >= num) {
            previewHide(pv);
            continue;
        }

        let shaderID = gShaders[i].info.id;
        
        if (pv.mUI !== null && uiCallback !== null) {
            pv.mUI.addEventListener('click', function (ev) {
                uiCallback(shaderID);
                ev.preventDefault();
            }, false);
        }
        
        previewShowLoading(pv);
        
        mShaders[i] = {};
        mShaders[i].mShaderID = shaderID;
        mShaders[i].mPreview = pv;
        mShaders[i].mScreenshot = false;
        mShaders[i].mPreview.mLink.href = "/view/" + shaderID;
        mShaders[i].mPreviewReady = 0;
        mShaders[i].mReady = false;
        mShaders[i].gEffect = null;

        previewLoadScreenshot(mShaders[i].mPreview,
            function () { mShaders[i].mPreviewReady = 1; if (mShaders[i].mReady === false) previewShowScreenshot(mShaders[i].mPreview, 0); },
            function () { mShaders[i].mPreviewReady = 2; },
            shaderID);
    }

    if (num <= 0) {
        return;
    }
}

function iInitShaders(jsn)
{
    for (let i = 0; i < jsn.length; i++)
    {
        let shaderObj = jsn[i];
        if (shaderObj === null) continue;
        let inf = shaderObj.info;
        mShaders[i].mPreview.mTextA.textContent = inf.name;
        mShaders[i].mPreview.mTextB.innerHTML = "<a class='user' href='/user/" + htmlEntities(inf.username) + "'>" + htmlEntities(inf.username) + "</a>";
        mShaders[i].mPreview.mTextC.innerHTML = "<img src='/img/themes/" + gThemeName + "/views.png' class='viewsIcon'></img>" + inf.viewed + "    &nbsp;&nbsp;  <img src='/img/themes/" + gThemeName + "/likes.png' class='likesIcon'></img>" + inf.likes;
    }

    setTimeout(function () { iProcessShader(jsn, 0); }, 10);
}

function resultsInitStatic(numCanvases, uiCallback, windowTitle)
{
    iInitUI(numCanvases, uiCallback, windowTitle);

    iInitShaders(gShaders);
}

function resultsInit(numCanvases, uiCallback, windowTitle)
{	
    iInitUI(numCanvases, uiCallback, windowTitle);

    var num = Math.min(gShaderIDs.length, gNumCanvases);

    var mHttpReq = new XMLHttpRequest();

    mHttpReq.abort();

    var str = "{ \"shaders\" : [";
    for( let i=0; i<num; i++ )
    {
         str += "\"" + gShaderIDs[i] + "\"";
         if( i!==(num-1) ) str += ", ";
    }
    str += "] }";

    str = "s=" + encodeURIComponent( str ) + "&nt=0&nl=0&np=0";

    mHttpReq.open( "POST", "/shadertoy", true );
    mHttpReq.responseType = "json";
    mHttpReq.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    mHttpReq.onload = function ()
    {
        let jsn = this.response;
        if( jsn===null )
        {
            console.log( "Could not load shaders" );
            return;
        }

        iInitShaders(jsn);
    }
    mHttpReq.send( str );
}</script>
    <style>
    .shaderPreview
    {
    display: block;
    background-color: #000000;
    background-image: url("/img/loading.gif");
    background-repeat: no-repeat;
    background-position: center;
    padding: 0px;
    margin: 0px;
    border: 0px solid #000000;
    border-radius: 8px;
    width:100%;
    height:100%;
    position: absolute;
    overflow:hidden;
    }

    .previewInfo
    {
    width: 100%;
    left: 0px;
    top: 2px;
    position: relative;
    visibility: hidden;
    }

    .previewCanvas
    {
    left: 0px;
    top: 0px;
    padding: 0px;
    margin: 0px;
    position: absolute;
    cursor: pointer;
    width:100%;
    height:100%;
    border-radius: 8px;
    border: 0px solid #000000;
    backgroundColor: transparent;
visibility: hidden;
opacity:0;
transition: opacity 1.0s ease;
    }

    .previewText
    {
        text-overflow: ellipsis;
    white-space: nowrap;
    padding-right: 1px;
    }

    .previewTextUser
    {
    text-overflow: ellipsis;
    white-space: nowrap;
    padding-left: 3px;
    }

    .previewStats
    {
    padding-right: 1px;
    right: 0px;
    top: 0px;
    position: absolute;
    }

    .previewErrorContainer
    {
    left:0px;
    top:0px;
    width:100%;
    height:100%;
    padding:0px;
    margin:0px;
    background-color:#000000;
    border-radius:8px;
    cursor:pointer;
    visibility:hidden;
    }

    .previewErrorMessage
    {
    top:50%;
    position:absolute;
    width:100%;
    text-align:center;
    padding:0;
    margin:auto;
    color:#ff0000;
    font-size:2em;
    font-style:italic;
    }

    .previewNoGLContainter
    {
    left:0px;
    top:0px;
    width:100%;
    height:100%;
    padding:0px;
    margin:0px;
    position:absolute;
    background-color:#000000;
    border-radius:8px;
    cursor:pointer;
    pointer-events:none;
    visibility:hidden;
    font-size:2em;
    }

    .previewNoGLMessage
    {
    width:86%;
    height:90%;
    padding-left:7%;
    padding-right:7%;
    padding-top:10%;
    padding-bottom:0px;
    color:#ff0000;
    position:absolute;
    visibility:hidden;
    }

    .previewThumbnailContainer
    {
    width:100%;
    height:100%;
    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    cursor:pointer;
    visibility:hidden;
    border-radius:8px;
    border:0px solid #000000;
    }

    .previewThumbnailImage
    {
    width:100%;
    height:100%;
    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    cursor:pointer;
    border-radius:8px;
    border:0px solid #000000;
opacity: 0.0;
transition: opacity 1.0s ease;
    }

    .previewThumbnailIcon
    {
    width:64px;
    height:32px;
    left:0px;
    top:0px;
    padding:0px;
    padding-top:12px;
    margin:0px;
    position:absolute;
    color:#ffffff;
    background-color:#ff8020;
    font-weight:bold;
    border-radius:0px 0px 8px 0px;
    text-align:center;
    //visibility:hidden;
    }


    .previewUIContainter
    {
    display: block;
    right:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    //cursor:pointer;
    //pointer-events:none;
    //visibility:hidden;
    }
</style>

<script>
    function previewHide(me)
    {
    me.mBase.style.visibility = "hidden";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "hidden";
    }

    function previewShowRender(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "visible";
me.mCanvas.style.opacity = 1.0;
    me.mCanvas.style.borderRadius ="8px;";
//  me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "visible";
    }

    function previewShowScreenshot(me, message)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "visible";
me.mThumbnailImg.style.opacity = 1.0;
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "visible";
    me.mThumbnailWar1.style.visibility = (message===1)?"visible":"hidden";
    me.mThumbnailWar2.style.visibility = (message===2)?"visible":"hidden";
    }

    function previewShowLoading(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "hidden";

    me.mLink.style.visibility = "visible";
    me.mBase.style.backgroundColor = "#ff0000;"
    me.mCont.style.visibility = "visible";
    }

    function previewShowNoWebGL(me, shaderID)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "visible";
    me.mError.style.visibility = "visible";
    me.mThumbnailImgNoWebGL.onerror = function(ev) 
                                      { 
                                            me.mThumbnailImgNoWebGL.style.visibility="hidden"; 
                                            me.mMessageNoWebGL.style.visibility="visible"; 
                                      };
    me.mThumbnailImgNoWebGL.src = "/media/shaders/" + shaderID + ".jpg";
    }

    function previewShowError(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "visible";
    me.mCont.style.visibility = "visible";
    }

    function previewLoadScreenshot( me, cbSuccess, cbError, shaderID )
    {
    var url = "/media/shaders/" + shaderID + ".jpg";
    me.mThumbnailImg.onload = cbSuccess;
    me.mThumbnailImg.onerror = function(ev) { cbError(); };
    me.mThumbnailImg.src = url;
    }
        
    function createPreview(id)
    {
        var bar = document.getElementById( "Preview_"+id+"_Canvas" );
        bar.width = bar.offsetWidth;
        bar.height = bar.offsetHeight;
        bar.mId = id;

        return { mBase: document.getElementById( "Preview_"+id+"_Container" ),
        mLink: document.getElementById( "Preview_"+id+"_Link" ),
        mCanvas: bar,
        mCont: document.getElementById( "Preview_"+id+"_Info" ),
        mTextA: document.getElementById( "Preview_"+id+"_Text" ),
        mTextB: document.getElementById( "Preview_"+id+"_TextUser" ),
        mTextC: document.getElementById( "Preview_"+id+"_Stats" ),
        mNoWebGL: document.getElementById( "Preview_"+id+"_NoWebGL" ),
        mError: document.getElementById( "Preview_"+id+"_Error" ),
        mCanvas2D: document.getElementById( "Preview_"+id+"_Thumnail" ),
        mThumbnailImg: document.getElementById( "Preview_"+id+"_ThumnailImage" ),
        mThumbnailWar1: document.getElementById( "Preview_"+id+"_ThumnailWarning1" ),
        mThumbnailWar2: document.getElementById( "Preview_"+id+"_ThumnailWarning2" ),
        mThumbnailImgNoWebGL: document.getElementById( "Preview_"+id+"_ThumnailImageNoWebGL" ),
        mMessageNoWebGL: document.getElementById( "Preview_"+id+"_MessageNoWebGL"),
        mUI: document.getElementById( "Preview_"+id+"_UI" )
        };
    }
</script>

    <style>

    #content
    {
        user-select: text;
        -moz-user-select: -moz-text;
        -webkit-user-select: text;
        padding:0px;
        margin:0px;
        position:relative;
    }

    #divUser
    {
        padding:0px;
        padding-top:24px;
        padding-bottom:16px;
        width:100%;
    }

    div#controls
    {
        width:100%;
        padding-top:16px;
        padding-bottom:16px;
        display:flex;
        justify-content:space-between; 
        flex-wrap:wrap;
    }

    div#controls > div
    {
        display:inline-flex;
    }

    .controlOptions
    {
        display:inline-block;
    }

    div#shaderGrid
    {
        width:100%;
        padding:0px;
        margin:0px;
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        grid-template-rows: repeat(2, 1fr);
        grid-column-gap: 64px;
        grid-row-gap: 16px;
    }

    .searchResult
    {
        margin: 0px;
        padding: 0px;
        width: 100%;
    }
    .searchResultContainer
    {
        width: 100%;
        padding-bottom:56.25%;
        height: 0;
        position: relative;
    }

    div#navigation
    {
        text-align: center;
        width: 100%;
    }


    #userPicture
    {
        background-color:#808080;
        border: 1px solid #000000;
        padding:0px;
        left:0px;
        top:0px;
        width:128px;
        height:128px;
    }

    a.pageButtons, .pageButtonsCurrent
    {
        
        //background-color: #303030;
        border-style: solid;
        border-width: 1px;
        border-color: #808080;
        text-align: center;
        vertical-align: middle;
        margin-left: 12px;
        display: inline-block;
        border-radius: 4px;
		font-weight:bold;
        cursor: pointer;
        padding-bottom:5px;
        padding-top:4px;
        padding-left: 8px;
        padding-right: 8px;
        margin:8px;
    }

    a.pageButtons
    {
        text-decoration: none;
        -moz-transition:    background-color 0.15s linear, color 0.15s linear;
        -webkit-transition: background-color 0.15s linear, color 0.15s linear;
        transition:         background-color 0.15s linear, color 0.15s linear;
    }

    a.pageButtons:hover
    {
      background-color:#808080;
      color : #ff8020;
    }

    .pageButtonsCurrent
    {
        background-color: #808080;
        color:#000000;
    }

    /* ----------------------- media resolutions ------------------------ */

    @media screen and (max-width:799px) 
    {
        div#shaderGrid  { grid-template-columns: 1fr; grid-template-rows: repeat(8, 1fr); grid-column-gap: 0px; grid-row-gap: 16px; padding-bottom:16px; }

        div#controls
        {
            width:100%;
            display:flex;
            justify-content:flex-start; 
            flex-wrap:wrap;
        }

        div#controls > div
        {
            display:inline-flex;
            width:100%;
            margin-left: 0px;
            margin-right: 0px;
            padding-bottom:16px;
        }
    }
    </style>

    <script>

    var gShaders=[{"ver":"0.1","info":{"id":"MlscWX","date":"1509015241","viewed":18775,"name":"Turn n' Burn","username":"ingagard","description":"Please read description in the top of Image for information about controls and optimizations.\nUse the mouse while holding down the left mouse button to control the camera.\n\nEnjoy!","likes":200,"published":3,"flags":48,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"\/media\/a\/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"\/media\/ap\/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Copyright \u00a9 2017 Kim Berkeby\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/*\n\n CONTROLS:\n ---------\n SPACE  FIRE MISSILE\n \n S      ROLL LEFT\n F      ROLL RIGHT  \n E      PITCH DOWN\n D      PITCH UP\n \n W      YAW LEFT   (PLANE TURN) \n R      YAW RIGHT   (PLANE TURN)\n \n SHIFT  INCREASE SPEED\n CTRL   DECCREASE SPEED \n \n F1     ZOOM OUT\n F2     ZOOM IN\n \n NOTICE:\n Controls can be changed to use arrow keys if you uncomment the alternative controls in Buf A. \n \n \n Toggle effects by pressing folloving keys:\n ------------------------------------------\n 1-key  = Lens dirt  on\/off               (default off)\n 2-key  = Grain filter  on\/off            (default on)\n 3-key  = Chromatic aberration  on\/off    (default on)    \n 4-key  = Anti aliasing  on\/off           (default on)\n 5-key  = Lens flare  on\/off              (default on)\n \n --------------------------------------------------------\n TO INCREASE PERFORMANCE:\n \n Delete one or several defines from Buf B:\n \n #define SHADOWS\n #define QUALITY_TREE\n #define QUALITY_REFLECTIONS\n #define EXACT_EXPLOSIONS\n --------------------------------------------------------\n \n This shader was made by using distance functions found in HG_SDF:\n http:\/\/mercury.sexy\n \n Special thanks to Inigo Quilez for his great tutorials on:\n https:\/\/iquilezles.org\/\n \n Last but not least, thanks to all the nice people here at ShaderToy! :-D\n\n*\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ POST EFFECTS BUFFER\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Channel 0 = Buffer A. Read data from data-buffer.\n\/\/ Channel 1 = LowRes noise texture. Used in fast noise functions.\n\/\/ Channel 2 = Buffer C. Get the colors of the render from the last buffer.\n\/\/ Channel 3 = Organic 2 texture. Used in lens dirt filter.\n\n\n  #define FastNoise(posX) (  textureLod(iChannel1, (posX+0.5)\/iResolution.xy, 0.0).r)\n  #define readAlpha(memPos) (  textureLod(iChannel2, memPos, 0.0).a)\n  #define read(memPos) (  texelFetch(iChannel0, memPos, 0).a)\n  #define readRGB(memPos) (  texelFetch(iChannel0, memPos, 0).rgb)\n  #define CLOUDLEVEL -70.0\n  #define PI acos(-1.)\n  #pragma optimize(off) \nmat3 cameraMatrix;\nvec3 planePos=vec3(0.);\nvec3 sunPos=vec3(0.);\nconst vec3 eps = vec3(0.02, 0.0, 0.0);\n\nfloat GetExplosionIntensity(float life)\n{\n  return mix(1., .0, smoothstep(0., 5.0, distance(life, 5.)));\n}\n\n\/\/ 3D noise function (IQ)\nfloat fastFBM(vec3 p)\n{\n  vec3 ip=floor(p);\n  p-=ip; \n  vec3 s=vec3(7, 157, 113);\n  vec4 h=vec4(0., s.yz, s.y+s.z)+dot(ip, s);\n  p=p*p*(3.-2.*p); \n  h=mix(fract(sin(h)*43758.5), fract(sin(h+s.x)*43758.5), p.x);\n  h.xy=mix(h.xz, h.yw, p.y);\n  return mix(h.x, h.y, p.z);\n}\n\nmat3 setCamera(  vec3 ro, vec3 ta, float cr )\n{\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n  vec3 cu = normalize( cross(cw, cp) );\n  vec3 cv = normalize( cross(cu, cw) );\n  return mat3( cu, cv, cw );\n}\n\nvec2 GetScreenPos(vec3 pos)\n{\n  return vec2(PI*dot( pos, cameraMatrix[0].xyz ), PI* dot( pos, cameraMatrix[1].xyz ));\n}\n\nvec3 CalculateSunFlare(vec3 rayDir, vec3 rayOrigin, vec2 screenSpace, float alpha, float enableFlare)\n{\n  float visibility = pow(max(0., dot(sunPos, rayDir)), 8.0);  \n  if (visibility<=0.05) return vec3(0.);\n\n  vec2 sunScreenPos = GetScreenPos(sunPos);\n\n  vec2 uvT = screenSpace-sunScreenPos;\n  float sunIntensity = (1.0\/(pow(length(uvT)*4.0+1.0, 1.30)))*visibility;\n\n  vec3 flareColor = vec3(0.);\n  vec2 offSet = uvT;\n  vec2 offSetStep=  0.4*sunScreenPos;\n  vec3 color;\n  float size=.0, dist=0.;\n  \n  if(enableFlare>0.)\n  {\n  \/\/ check if center of sun is covered by any object. MATH IS OFF AT SCREEN CHECK POS! sunScreenPos\/2.0 +0.5 IS NOT EXACTLY SUN MIDDLE!\n  \/\/ only draw if not covered by any object\n  if (readAlpha( sunScreenPos\/2.0 +0.5)<0.50)\n  {\n    \/\/ create flare rings\n    for (float i =1.; i<8.; i++)\n    {\n      color.rg = vec2(abs((sin(i*53.))), 0.65);\n      color.b = abs((cos(i*25.)));\n      offSet += offSetStep;\n\n      size = 0.05+((1.-sin(i*0.54))*0.28);\n      dist = pow(distance(sunScreenPos, offSet), 1.20);\n\n      flareColor += mix(vec3(0.), sunIntensity*(10.*size) * color, smoothstep(size, size-dist, dist))\/(1.0-size);\n    }\n  }\n  flareColor*=mix(0., 1.0, smoothstep(0., 0.1, visibility));\n  }\n    \n  \/\/ flare star shape\n  vec3 sunSpot = vec3(1.30, 1., .80)*sunIntensity*(sin(FastNoise((sunScreenPos.x+sunScreenPos.y)*2.3+atan(uvT.x, uvT.y)*15.)*5.0)*.12);\n  \/\/ sun glow\n  sunSpot+=vec3(1.0, 0.96, 0.90)*sunIntensity*.75;\n  sunSpot+=vec3(1.0, 0.76, 0.20)*visibility*0.15;\n\n  return flareColor+(sunSpot*(1.0-alpha));\n}\nvec3 CalculateExplosionFlare(vec3 rayDir, vec3 rayOrigin, vec2 screenSpace, float alpha, vec3 explosionPos, float enableFlare)\n{\n\n  float visibility = max(0., dot(explosionPos, rayDir));  \n  if (visibility<=0.15) return vec3(0.);\n\n  vec2 flareScreenPos = GetScreenPos(explosionPos);\n  vec2 uvT = screenSpace-flareScreenPos;\n  float flareIntensity = 0.2*visibility;\n  vec3 flareColor = vec3(0.);\n  vec2 offSet = uvT;\n  vec2 offSetStep=  0.4*flareScreenPos;\n  vec3 color;\n  float size=.0, dist=0.; \n\n    if(enableFlare>0.)\n    {\n  \/\/ create flare rings\n  for (float i =1.; i<8.; i++)\n  {\n    color.rg = vec2(0.75+(0.25*sin(i*i)));\n    color.b = 0.75+(0.35*cos(i*i));\n    offSet += offSetStep;\n    size = 0.05+((1.-sin(i*0.54))*0.38);\n    dist = pow(distance(flareScreenPos, offSet), 1.20);\n\n    flareColor += mix(vec3(0.), flareIntensity*(4.*size) * color, smoothstep(size, size-dist, dist))\/(1.0-size);\n  }\n  flareColor\/=2.;\n    }\n  \/\/ flare star shape\n  vec3 flareSpot = vec3(1.30, 1., .80)*flareIntensity*(sin(FastNoise((flareScreenPos.x+flareScreenPos.y)*5.+atan(uvT.x, uvT.y)*10.)*4.0)*.2+3.5*flareIntensity);\n  \/\/ flare glow\n  flareSpot+=vec3(1.0, 0.7, 0.2)*pow(visibility, 12.0)*0.3;\n\n  return (flareColor+flareSpot)*(1.0-alpha);\n}\n\nvoid pR(inout vec2 p, float a)\n{\n  p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat DrawExplosion(int id, inout vec4 color, vec3 rayDir, vec3 rayOrigin, vec2 screenSpace, float enableFlare)\n{\n  id *= 100; \n  float dist =-10000.;\n  float life = read(ivec2(122+id, 0));\n\n  \/\/ check if explosion has been spawned\n  if (life>0. )\n  {     \n    vec3 pos = normalize(readRGB(ivec2(120+id, 0))-planePos); \n    float eDist = pow(max(0., dot(pos, rayDir)), 2.0); \n    float intensity =GetExplosionIntensity(life);\n    dist = eDist*intensity*1.4;\n    color.rgb += CalculateExplosionFlare(rayDir, rayOrigin, screenSpace, 1.0-intensity, pos, enableFlare);\n    color.rgb = mix(color.rgb, color.rgb+vec3(1.0, 0.4, 0)*0.5, eDist*intensity);\n  }   \n  return dist;\n}  \n\n\nvec3 AntiAliasing(vec2 uv)\n{\n  vec2 offset = vec2(0.11218413712, 0.33528304367) * (1.0 \/ iResolution.xy);\n\n  return (texture(iChannel2, uv + vec2(-offset.x, offset.y)) +\n    texture(iChannel2, uv + vec2( offset.y, offset.x)) +\n    texture(iChannel2, uv + vec2( offset.x, -offset.y)) +\n    texture(iChannel2, uv + vec2(-offset.y, -offset.x))).rgb * 0.25;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{  \n  vec2 mo = iMouse.xy\/iResolution.xy;\n  vec2 uv = fragCoord.xy \/ iResolution.xy;\n  vec2 screenSpace = (-iResolution.xy + 2.0*(fragCoord))\/iResolution.y;\n\n  \/\/ read values from buffer\n  vec3 effects = readRGB(ivec2(20, 0));  \n  vec3 effects2 = readRGB(ivec2(22, 0)); \n  float turn = read(ivec2(1, 10));\n  sunPos = readRGB(ivec2(50, 0));\n  planePos = readRGB(ivec2(55, 0));\n  \/\/ setup camera and ray direction\n  vec2 camRot = readRGB(ivec2(57, 0)).xy;\n  float CAMZOOM = read(ivec2(52, 0));  \n  vec3 rayOrigin = vec3(CAMZOOM*cos(camRot.x), 3.+CAMZOOM*sin(camRot.y), -3.+CAMZOOM*sin(camRot.x) );\n  pR(rayOrigin.xz, -turn);\n  cameraMatrix  = setCamera( rayOrigin, vec3(0., 0., -3. ), 0.0 );\n  vec3 rayDir = cameraMatrix * normalize( vec3(screenSpace.xy, 2.0) );\n\n  vec2 d = abs((uv - 0.5) * 2.0);\n  d = pow(d, vec2(2.0, 2.0));\n  float minDist = -1000.0;\n\n\n  vec4 color;\n\n  \/\/ chromatic aberration?\n  if (effects.z>0.)\n  {\n    float offSet = distance(uv, vec2(0.5))*0.005;\n    \/\/ AA pass?\n    if (effects2.y>0.)\n    {\n      color.rgb = vec3(AntiAliasing(uv + offSet).r, AntiAliasing(uv).g, AntiAliasing(uv - offSet).b);\n    } else\n    {\n      color.rgb = vec3(texture(iChannel2, uv + offSet).r, texture(iChannel2, uv).g, texture(iChannel2, uv - offSet).b);\n    }\n  }\n  \/\/ no chromatic aberration \n  else\n  {\n    \/\/ AA pass?\n    if (effects2.y>0.)\n    {\n      color.rgb=AntiAliasing(uv);\n    } else\n    {\n      color.rgb = texture(iChannel2, uv).rgb;\n    }\n  }\n\n  color.a=textureLod(iChannel2, uv, 0.).a;\n\n  \/\/ add sun with lens flare effect\n  color.rgb += CalculateSunFlare(rayDir, rayOrigin, screenSpace, clamp(color.a, 0., 1.0),effects2.x);\n\n  \/\/ add explosion light effects\n  minDist = max(minDist, DrawExplosion(0, color, rayDir, rayOrigin, screenSpace,effects2.x));\n  minDist = max(minDist, DrawExplosion(1, color, rayDir, rayOrigin, screenSpace,effects2.x));\n\n  float cloudDistance = distance(rayOrigin.y+planePos.y, -CLOUDLEVEL);\n\n  \/\/ grain noise\n  if (effects.y>0.)\n  {\n    vec2 grainTexPos = ((fragCoord.xy + iTime*60.0*vec2(10, 35.))*mix(0.6, 0.2, smoothstep(5.0, 0., cloudDistance)))\/iChannelResolution[0].xy;\n    vec2 filmNoise = textureLod( iChannel1, grainTexPos, 0. ).rb;\n    \/\/ scale up effect when flying through clouds\n    color.rgb *= mix( vec3(1), mix(vec3(1, .5, 0), vec3(0, .5, 1), filmNoise.x), mix(.04, 0.7, smoothstep(5.0, 0., cloudDistance))*filmNoise.y );\n  }\n\n  \/\/ flying though clouds\n  color = mix(color, clamp(color+max(0.4, fastFBM(rayOrigin+planePos)*2.), 0., 1.0), smoothstep(5.0, 0., cloudDistance));\n\n\n  \/\/ Lens dirt when looking into strong light source\n  if (effects.x>0.)\n  {\n    minDist=max(minDist, pow(max(0., dot(sunPos, rayDir)), 2.0));     \n    float dirtTex = textureLod( iChannel3, (fragCoord.xy \/ iResolution.x), 0.3 ).r*2.5;\n\n    color.rgb += 0.04*dirtTex*minDist;\n  }\n\n  fragColor =  vec4(pow(color.rgb, vec3(1.0\/1.1)), 1.0 ) * (0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.2 ));\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sfGRn","filepath":"\/media\/a\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"\/media\/ap\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzn","filepath":"\/media\/a\/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"\/media\/ap\/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"\/presets\/tex00.jpg","previewfilepath":"\/presets\/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ DATA BUFFER  -  PLANE MOVEMENT, KEYBOARD CHECKS AND MISSILE UPDATE (IF LAUNCHED)\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Channel 0 = Keyoard input. Used to capture key-presses.\n\/\/ Channel 1 = LowRes noise texture. Used in fast noise functions.\n\/\/ Channel 2 = This buffer (A). Read and write data to update movement in this shader.\n\/\/ Channel 3 = Lichen texture. Used to create landscape height map used in collision detection.\n\n  #define PI acos(-1.)\n  #define keyClick(ascii)   ( texelFetch(iChannel0, ivec2(ascii, 0), 0).x > 0.)\n  #define keyPress(ascii)   ( texelFetch(iChannel0, ivec2(ascii, 1), 0).x > 0.)\n  #define read(memPos) (  texelFetch(iChannel2, memPos, 0).a)\n  #define readRGB(memPos) (  texelFetch(iChannel2, memPos, 0).rgb)\n  #define MAX_HEIGHT 150. \n  #define MIN_HEIGHT 0. \n  #define STARTHEIGHT 40.\n  #pragma optimize(off) \n\/\/ SPACE   FIRE MISSILE\n#define MISSILE_KEY 32  \n\/\/ S    ROLL LEFT\n#define ROLL_LEFT_KEY 83  \n\/\/ F    ROLL RIGHT\n#define ROLL_RIGHT_KEY 70      \n\/\/ W    YAW LEFT   (PLANE STRIFE)\n#define LEFT_KEY 87    \n\/\/ R    YAW RIGHT   (PLANE STRIFE)\n#define RIGHT_KEY 82     \n\/\/ E    PITCH DOWN\n#define UP_KEY 69     \n\/\/ D    PITCH UP\n#define DOWN_KEY 68     \n\/\/ SHIFT  INC SPEED\n#define SPEED_INCREASE_KEY 16     \n\/\/ CTRL   DEC SPEED\n#define SPEED_DECREASE_KEY 17    \n\/\/ F1     ZOOM OUT\n#define ZOOMOUT_KEY 112\n\/\/ F2     ZOOM IN\n#define ZOOMIN_KEY 113\n\n\/\/ Alternative controls if uncommented  (lets you use arrow keys to control the plane)\n\/* \n\/\/ ENTER   FIRE MISSILE\n#define MISSILE_KEY 13\n\/\/ LEFT ARROW    ROLL LEFT\n#define ROLL_LEFT_KEY 37  \n\/\/ RIGHT ARROW    ROLL RIGHT\n#define ROLL_RIGHT_KEY 39     \n\/\/ DELETE   YAW LEFT   (PLANE STRIFE)\n#define LEFT_KEY 46    \n\/\/ PAGE DOWN    YAW RIGHT   (PLANE STRIFE)\n#define RIGHT_KEY 34     \n\/\/ UP ARROW    PITCH DOWN\n#define UP_KEY 38     \n\/\/ DOWN ARROW    PITCH UP\n#define DOWN_KEY 40     \n\/\/ SHIFT  INC SPEED\n#define SPEED_INCREASE_KEY 16     \n\/\/ CTRL   DEC SPEED\n#define SPEED_DECREASE_KEY 17    \n\/\/ F1     ZOOM OUT\n#define ZOOMOUT_KEY 112\n\/\/ F2     ZOOM IN\n#define ZOOMIN_KEY 113\n*\/\n\n\nvec3 sunPos=vec3(0.);\nvec3 planePos=vec3(0.);\nfloat explosionCount=0.;\n\n\nstruct Missile\n{ \n  vec3 pos;\n  float life;\n  vec3 orientation;   \/\/ roll,pitch,turn amount\n    vec3 startPos;\n};\n\nstruct Explosion\n{ \n  vec3 pos;\n  float life;\n};\n\n\n\nmat3 setCamera(  vec3 ro, vec3 ta, float cr )\n{\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n  vec3 cu = normalize( cross(cw, cp) );\n  vec3 cv = normalize( cross(cu, cw) );\n  return mat3( cu, cv, cw );\n}\n\nmat2 r2(float r) {\n  float c=cos(r), s=sin(r);\n  return mat2(c, s, -s, c);\n}\n\nvoid pR(inout vec2 p, float a) \n{\n  p*=r2(a);\n}\n\nfloat noise2D( in vec2 pos, float lod)\n{   \n  vec2 f = fract(pos);\n  f = f*f*(3.0-2.0*f);\n  vec2 rg = textureLod( iChannel1, (((floor(pos).xy+vec2(37.0, 17.0)) + f.xy)+ 0.5)\/64.0, lod).yx;  \n  return -1.0+2.0*mix( rg.x, rg.y, 0.5 );\n}\n\nfloat noise2D( in vec2 pos )\n{\n  return noise2D(pos, 0.0);\n}\n\n\/\/ 3D noise function (IQ)\nfloat fastFBM(vec3 p)\n{\n  vec3 ip=floor(p);\n  p-=ip; \n  vec3 s=vec3(7, 157, 113);\n  vec4 h=vec4(0., s.yz, s.y+s.z)+dot(ip, s);\n  p=p*p*(3.-2.*p); \n  h=mix(fract(sin(h)*43758.5), fract(sin(h+s.x)*43758.5), p.x);\n  h.xy=mix(h.xz, h.yw, p.y);\n  return mix(h.x, h.y, p.z);\n}\n\nfloat hash(float h) \n{\n  return fract(sin(h) * 43758.5453123);\n}\n\nfloat noise(vec3 x) \n{\n  vec3 p = floor(x);\n  vec3 f = fract(x);\n  f = f * f * (3.0 - 2.0 * f);\n\n  float n = p.x + p.y * 157.0 + 113.0 * p.z;\n  return -1.0+2.0*mix(\n    mix(mix(hash(n + 0.0), hash(n + 1.0), f.x), \n    mix(hash(n + 157.0), hash(n + 158.0), f.x), f.y), \n    mix(mix(hash(n + 113.0), hash(n + 114.0), f.x), \n    mix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\n\nfloat NoTreeZone(vec3 p)\n{\n    float dist = distance(readRGB(ivec2(140, 0)).xz,p.xz);\n    dist = min(dist,distance(readRGB(ivec2(142, 0)).xz,p.xz));\n    dist = min(dist,distance(readRGB(ivec2(144, 0)).xz,p.xz));\n    dist = min(dist,distance(readRGB(ivec2(146, 0)).xz,p.xz));\n    dist = min(dist,distance(readRGB(ivec2(148, 0)).xz,p.xz));\n    return dist;\n}\nfloat GetTerrainHeight( vec3 p)\n{\n  vec2 p2 = (p.xz+planePos.xz)*0.0005;\n\n  float heightDecrease = mix(1.0,0.,smoothstep(0.,15.0,NoTreeZone(p+planePos)));\n    \n  float mainHeight = -2.3+fastFBM((p+vec3(planePos.x, 0., planePos.z))*0.025)*max(11., abs(22.*noise2D(p2))); \n  mainHeight-=heightDecrease;\n    \n  float terrainHeight=mainHeight;\n  p2*=4.0;\n  terrainHeight += textureLod( iChannel3, p2, 2.7 ).x*1.; \n  p2*=2.0;\n  terrainHeight -= textureLod( iChannel3, p2, 1.2 ).x*.7;\n  p2*=3.0;\n  terrainHeight -= textureLod( iChannel3, p2, 0.5 ).x*.1;\n\n  terrainHeight=mix(terrainHeight, mainHeight*1.4, smoothstep(1.5, 3.5, terrainHeight)); \n\n  return   terrainHeight;\n}\n\nfloat GetTreeHeight( vec3 p, float terrainHeight)\n{\n  if(NoTreeZone(p+planePos)<25.) return 0.;\n  float treeHeight = textureLod(iChannel3, (p.xz+planePos.xz)*0.006, .1).x;\n  float tree = mix(0., mix(0., mix(0., 2.0, smoothstep(0.3, 0.86, treeHeight)), smoothstep(1.5, 3.5, terrainHeight)), step(0.3, treeHeight)); \n  tree -= tree*0.75;\n  tree*=4.0;\n\n  return  tree;\n}\n\nvec3 TranslatePos(vec3 p, float _direction, float _pitch, float _roll)\n{\n  pR(p.xz, _direction);\n  pR(p.zy, _pitch);\n\n  return p;\n}\n\nvoid LaunchMissile(inout Missile missile, vec3 startPos, vec3 orientation)\n{\n  missile.life=4.0; \n  missile.orientation = orientation;\n  missile.pos =  startPos;\n  missile.startPos= planePos;\n  missile.orientation.y *=cos(missile.orientation.x-PI);\n}\n\nvoid UpdateMissile(inout Missile missile, float id, inout vec4 fragColor, vec2 fragCoord, vec3 moveDiff)\n{\n  float adressStep = id*100.;\n     \n  Explosion explosion;\n \n  \/\/ read variables for explosion s\n  explosion.pos = readRGB(ivec2(120+int(adressStep), 0));    \n  explosion.life = read(ivec2(122+int(adressStep), 0));\n\n  \/\/ update active missile and save variables\n  if ( missile.life>0.)\n  {\n    missile.life-= 0.015;\n    vec3 velocityAdd = vec3(0., 0., 1.4);\n\n    pR(velocityAdd.yz, missile.orientation.y);\n    pR(velocityAdd.xz, -missile.orientation.z);\n\n    missile.pos += velocityAdd; \/\/ add velocity movement to pos\n    missile.pos.xz-=moveDiff.xz; \/\/ add plane movement to pos\n\n    \/\/ ground collision check                 \n    vec3 testPoint = missile.pos;\n      \n    testPoint+=vec3(4.8 - (9.6*id), -0.4, -3.0);\n    pR(testPoint.xz, missile.orientation.z);\n    testPoint-=vec3(4.8 - (9.6*id), -0.4, -3.0);\n    testPoint.y+=missile.startPos.y;\n      \n    float tHeight = GetTerrainHeight(testPoint);\n    tHeight+=GetTreeHeight(testPoint, tHeight);\n\n    \/\/ does missile hit terrain?\n    if (testPoint.y<tHeight)\n    {\n      \/\/ if colliding, kill missile and spawn explosion.             \n       explosion.pos =  missile.pos+missile.startPos;\n       explosion.pos.y = tHeight-3.0;\n       explosion.life=10.0;\n       missile.life=-10.;\n       explosionCount+=2.0;\n       explosionCount = mod(explosionCount,10.);\n    }\n\n    fragColor.a = mix(missile.life, fragColor.a, step(1., distance(fragCoord.xy, vec2(100.0+adressStep, 0.0))));\n    fragColor.rgb = mix(missile.startPos, fragColor.rgb, step(1., distance(fragCoord.xy, vec2(102.0+adressStep, 0.0))));\n    fragColor.rgb = mix(missile.orientation, fragColor.rgb, step(1., distance(fragCoord.xy, vec2(108.0+adressStep, 0.0)))); \n    fragColor.rgb = mix(missile.pos, fragColor.rgb, step(1., distance(fragCoord.xy, vec2(116.0+adressStep, 0.0))));\n            \n  }\n  \/\/ ##################################################################\n\n  \/\/ update explosion\n  if ( explosion.life>0.)\n  {   \n    explosion.life-= 0.115;\n   \/\/ explosion.life= 9.715;\n    fragColor.rgb = mix(explosion.pos, fragColor.rgb, step(1., distance(fragCoord.xy, vec2(120.0+adressStep, 0.0)))); \n    fragColor.a = mix(explosion.life, fragColor.a, step(1., distance(fragCoord.xy, vec2(122.0+adressStep, 0.0))));\n      \n    \/\/ terrain holes\n    fragColor.rgb = mix(mix(explosion.pos, fragColor.rgb, step(1., distance(fragCoord.xy, vec2(140.0+explosionCount, 0.0)))),fragColor.rgb,step(0.4,distance(5.0,explosion.life)));\n  }\n}\n\n\nvoid ToggleEffects(inout vec4 fragColor, vec2 fragCoord)\n{\n   \/\/ read and save effect values from buffer  \n   vec3 effects =  mix(vec3(-1.0,1.0,1.0), readRGB(ivec2(20, 0)), step(1.0, float(iFrame)));\n   effects.x*=1.0+(-2.*float(keyPress(49))); \/\/1-key  LENSDIRT\n   effects.y*=1.0+(-2.*float(keyPress(50))); \/\/2-key  GRAINFILTER\n   effects.z*=1.0+(-2.*float(keyPress(51))); \/\/3-key  ChromaticAberration\n   \n   vec3 effects2 =  mix(vec3(1.0,1.0,1.0), readRGB(ivec2(22, 0)), step(1.0, float(iFrame)));\n   effects2.y*=1.0+(-2.*float(keyPress(52))); \/\/4-key  AA-pass\n   effects2.x*=1.0+(-2.*float(keyPress(53))); \/\/5-key  lens flare\n\n   fragColor.rgb = mix(effects, fragColor.rgb, step(1., distance(fragCoord.xy, vec2(20.0, 0.0))));  \n   fragColor.rgb = mix(effects2, fragColor.rgb, step(1., distance(fragCoord.xy, vec2(22.0, 0.0))));  \n}\n\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{  \n  vec2 mo = iMouse.xy\/iResolution.xy;\n  vec2 uv = fragCoord.xy \/ iResolution.xy;\n  vec2 screenSpace = (-iResolution.xy + 2.0*(fragCoord))\/iResolution.y;\n\n  \/\/ read plane values from buffer\n  float turn = mix(1.0, read(ivec2(1, 10)), step(1.0, float(iFrame)));\n  float roll = mix(3.14, read(ivec2(1, 1)), step(1.0, float(iFrame)));\n  float rudderAngle = read(ivec2(6, 1));\n  float speed = read(ivec2(10, 1));\n  float pitch = read(ivec2(15, 1));\n  explosionCount = read(ivec2(3, 0));  \n    \n  sunPos = mix(normalize( vec3(-1.0, 0.3, -.50) ), readRGB(ivec2(50, 0)), step(1.0, float(iFrame)));\n  planePos = mix(vec3(-400, STARTHEIGHT, -100), readRGB(ivec2(55, 0)), step(1.0, float(iFrame)));\n  float CAMZOOM = mix(13.9, read(ivec2(52, 0)), step(1.0, float(iFrame)));  \n  vec2 camRot = vec2(-1., 0.340);\n\n  \/\/ setup camera and ray direction\n  camRot.x+=mo.x*16.; \n  camRot.y+=mo.y*16.; \n \n  \/\/ limit roll\n  roll=mod(roll, 6.28);\n \n    \/\/ add turn angle based on roll  \n  float turnAmount = mix(0., 1.57, smoothstep(0., 1.57, 1.57-distance(1.57, roll-3.14)));\n  turnAmount += mix(0., -1.57, smoothstep(0., 1.57, 1.57-distance(-1.57, roll-3.14)));\n  float PitchAdd = sin(pitch);\n \n  \/\/ YAW\n  turn+=0.02*rudderAngle;\n  \/\/ add turn angle  \n  turn+=turnAmount*0.015;\n  turn-=0.1*(((pitch*0.25)*cos(roll-1.57)));\n  \n    turn= mod(turn,PI*2.);\n  vec3 oldPlanePos = vec3(planePos.x, planePos.y, planePos.z);\n\n  \/\/ move plane\n  planePos.xz += vec2(cos(turn+1.5707963)*0.5,  sin(turn+1.5707963)*0.5)*(0.7+speed)*cos(pitch);\n  planePos.y = clamp(planePos.y+((PitchAdd*0.25)*cos(roll-PI)), MIN_HEIGHT, MAX_HEIGHT);\n\n  rudderAngle*=0.97;\n  \/\/ check key inputs\n  rudderAngle-=0.03*float(keyClick(LEFT_KEY));\n  rudderAngle+=0.03*float(keyClick(RIGHT_KEY));\n  rudderAngle=clamp(rudderAngle, -0.4, 0.4);;\n  roll-=0.055*float(keyClick(ROLL_LEFT_KEY));\n  roll+=0.055*float(keyClick(ROLL_RIGHT_KEY));\n\n  speed+=(0.02*float(keyClick(SPEED_INCREASE_KEY)));\n  speed-=(0.02*float(keyClick(SPEED_DECREASE_KEY)));\n  speed=clamp(speed, -0.3, 1.);\n   \n  \/\/ prevent plane from getting into terrain\n  float tHeight = GetTerrainHeight(planePos);\n  tHeight+=GetTreeHeight(planePos, tHeight);\n  float minHeight = tHeight+12.;\n  planePos.y = max(planePos.y,minHeight);\n    \n   \/\/ pitch = sin(pitch);\n  pitch-=(mix(0.02, 0., smoothstep(0., 3., 3.0-abs(distance(planePos.y, minHeight))))*float(keyClick(UP_KEY))); \/\/e-key\n  pitch+=(mix(0.02, 0., smoothstep(0., 3., 3.0-abs(distance(planePos.y, MAX_HEIGHT))))*float(keyClick(DOWN_KEY))); \/\/d-key\n  pitch = clamp(pitch, -1.25, 1.25);\n  pitch*=0.97;\n\n  turnAmount += mix(0., -1.57, smoothstep(0., 1.57, 1.57-distance(-1.57, roll-3.14)));\n  fragColor = vec4(textureLod(iChannel2, uv,0.).rgb,0.);\n    \n  \/\/ ------------------------- MISSILES ------------------------------\n  \/\/ NOTE: MISSILES ARE RENDERED IN BUFFER B TOGETHER WITH THE TERRAIN     \n  int adressStep = 0;\n  bool launchLocked=false;\n  Missile missile;\n  for (int i=0; i<2; i++)\n  {\n    adressStep = i*100;\n      \n    \/\/ read variables for missiles\n    missile.life = read(ivec2(100 + adressStep, 0));\n    missile.startPos = readRGB(ivec2(102 + adressStep, 0));  \n    missile.orientation = readRGB(ivec2(108 + adressStep, 0));\n    missile.pos = readRGB(ivec2(116 + adressStep, 0));\n\n  \/\/ if missile is \"dead\" check if a new missile is being lanched by pressing the M-key\n  if (keyPress(MISSILE_KEY) && !launchLocked)\n  {    \n   if (missile.life<=0.)\n   {\n      LaunchMissile(missile, vec3(4.8- (9.6*float(i)), -0.4, -3.0), vec3(roll, pitch, turn));  \n      launchLocked=true;\n   } \n }    \n\n  UpdateMissile(missile, float(i), fragColor, fragCoord, (planePos-oldPlanePos));\n  \/\/ ##################################################################\n  }\n\n  ToggleEffects(fragColor, fragCoord);\n   \n  CAMZOOM-=0.3*float(keyClick(ZOOMIN_KEY));\n  CAMZOOM+=0.3*float(keyClick(ZOOMOUT_KEY));\n  CAMZOOM=clamp(CAMZOOM, 10., 30.);;\n  \n  \/\/ save roll,speed and scroll values etc to buffer A \n  fragColor.a = mix(turn, fragColor.a, step(1., distance(fragCoord.xy, vec2(1.0, 10.0)))); \n  fragColor.a = mix(speed, fragColor.a, step(1., distance(fragCoord.xy, vec2(10.0, 1.0)))); \n  fragColor.a = mix(roll, fragColor.a, step(1., distance(fragCoord.xy, vec2(1.0, 1.0)))); \n  fragColor.a = mix(pitch, fragColor.a, step(1., distance(fragCoord.xy, vec2(15.0, 1.0)))); \n  fragColor.a = mix(rudderAngle, fragColor.a, step(1., distance(fragCoord.xy, vec2(6.0, 1.0))));\n  fragColor.a = mix(explosionCount, fragColor.a, step(1., distance(fragCoord.xy, vec2(3.0, 0.0)))); \n  fragColor.rgb = mix(sunPos, fragColor.rgb, step(1., distance(fragCoord.xy, vec2(50.0, 0.0))));\n  fragColor.a = mix(CAMZOOM, fragColor.a, step(1., distance(fragCoord.xy, vec2(52.0, 0.0))));\n  fragColor.rgb = mix(planePos, fragColor.rgb, step(1., distance(fragCoord.xy, vec2(55.0, 0.0))));\n  fragColor.rgb = mix(vec3(camRot.xy, 0.), fragColor.rgb, step(1., distance(fragCoord.xy, vec2(57.0, 0.0))));\n}\n","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4sfGRn","filepath":"\/media\/a\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"\/media\/ap\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzn","filepath":"\/media\/a\/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"\/media\/ap\/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ TERRAIN BUFFER  -   RENDERS TERRAIN AND LAUNCHED MISSILES + EXPLOSIONS \n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Channel 0 = Fine noise texture. Used in noise functions.\n\/\/ Channel 1 = LowRes noise texture. Used in fast noise functions.\n\/\/ Channel 2 = Buffer A. Read data from data-buffer.\n\/\/ Channel 3 = Lichen texture. Used to create landscape height map and textures.\n\n  #define read(memPos) (  texelFetch(iChannel2, memPos, 0).a)\n  #define readRGB(memPos) (  texelFetch(iChannel2, memPos, 0).rgb)\n  #define MAX_HEIGHT 150. \n  #define WATER_LOD 0.4\n  #define CLOUDLEVEL -70.0\n  #define PI acos(-1.)\n  #pragma optimize(off) \n  \/\/ remove on or several of below defines, if FPS is too low\n  #define SHADOWS\n  #define QUALITY_TREE\n  #define QUALITY_REFLECTIONS\n  #define EXACT_EXPLOSIONS\n  \/\/ ---------------------------------------------------------\n\nfloat turn=0.;\nvec2 cloudPos=vec2(0.);\nfloat eFlameDist=10000.0;\nvec3 checkPos=vec3(0.);\nvec3 sunPos=vec3(0.);\nconst vec3 sunColor = vec3(1.00, 0.90, 0.85);\n\nconst vec3 eps = vec3(0.02, 0.0, 0.0);\nvec3 planePos=vec3(0.);\n\nstruct RayHit\n{\n  bool hit;  \n  vec3 hitPos;\n  vec3 normal;\n  float dist;\n  float depth;\n  float eFlameDist;\n};\n\nstruct Missile\n{ \n  vec3 pos;\n  float life;\n  vec3 orientation;   \/\/ roll,pitch,turn amount\n  vec3 origin;\n};\n    \nstruct Explosion\n{ \n  vec3 pos;\n  float life;\n};\n\nmat2 r2(float r) {\n  float c=cos(r), s=sin(r);\n  return mat2(c, s, -s, c);\n}\n\n#define r3(r) mat2(sin(vec4(-1, 0, 0, 1)*acos(0.)+r))\n\nvoid pR(inout vec2 p, float a)\n{\n  p*=r2(a);\n}\n\nfloat sgn(float x)\n{   \n  return (x<0.)?-1.:1.;\n}\n\nfloat hash(float h) \n{\n  return fract(sin(h) * 43758.5453123);\n}\n\nfloat noise(vec3 x) \n{\n  vec3 p = floor(x);\n  vec3 f = fract(x);\n  f = f * f * (3.0 - 2.0 * f);\n\n  float n = p.x + p.y * 157.0 + 113.0 * p.z;\n  return -1.0+2.0*mix(\n    mix(mix(hash(n + 0.0), hash(n + 1.0), f.x), \n    mix(hash(n + 157.0), hash(n + 158.0), f.x), f.y), \n    mix(mix(hash(n + 113.0), hash(n + 114.0), f.x), \n    mix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\n\nfloat fbm(vec3 p) \n{\n  float f = 0.5000 * noise(p);\n  p *= 2.01;\n  f += 0.2500 * noise(p);\n  p *= 2.02;\n  f += 0.1250 * noise(p);\n  return f;\n}\n\nfloat noise2D( in vec2 pos, float lod)\n{   \n  vec2 f = fract(pos);\n  f = f*f*(3.0-2.0*f);\n  vec2 rg = textureLod( iChannel1, (((floor(pos).xy+vec2(37.0, 17.0)) + f.xy)+ 0.5)\/64.0, lod).yx;  \n  return -1.0+2.0*mix( rg.x, rg.y, 0.5 );\n}\nfloat noise2D( in vec2 pos )\n{\n  return noise2D(pos, 0.0);\n}\n\n\/\/ 3D noise function (IQ)\nfloat fastFBM(vec3 p)\n{\n  vec3 ip=floor(p);\n  p-=ip; \n  vec3 s=vec3(7, 157, 113);\n  vec4 h=vec4(0., s.yz, s.y+s.z)+dot(ip, s);\n  p=p*p*(3.-2.*p); \n  h=mix(fract(sin(h)*43758.5), fract(sin(h+s.x)*43758.5), p.x);\n  h.xy=mix(h.xz, h.yw, p.y);\n  return mix(h.x, h.y, p.z);\n}\nfloat fastFBMneg(vec3 p)\n{\n  return -1.0+2.0*fastFBM(p);\n}\nvec2 pModPolar(vec2 p, float repetitions) {\n  float angle = 2.*PI\/repetitions;\n  float a = atan(p.y, p.x) + angle\/2.;\n  float r = length(p);\n  float c = floor(a\/angle);\n  a = mod(a, angle) - angle\/2.;\n  p = vec2(cos(a), sin(a))*r;\n  if (abs(c) >= (repetitions\/2.)) c = abs(c);\n  return p;\n}\n\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)\/size);\n  p = mod(p+halfsize, size) - halfsize;\n  if (c > stop) {\n    p += size*(c - stop);\n    c = stop;\n  }\n  if (c <start) {\n    p += size*(c - start);\n    c = start;\n  }\n  return c;\n}\nfloat pMirror (inout float p, float dist) {\n  float s = sgn(p);\n  p = abs(p)-dist;\n  return s;\n}\n\nfloat fCylinder(vec3 p, float r, float height) {\n  float d = length(p.xy) - r;\n  d = max(d, abs(p.z) - height);\n  return d;\n}\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  return (length( p\/r.xyz ) - 1.0) * r.y;\n}\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.y-h.y, max((q.z*0.866025+q.x*0.5), q.x)-h.x);\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\nfloat fSphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat GetExplosionIntensity(Explosion ex)\n{\n  return mix(1., .0, smoothstep(0., 5.0, distance(ex.life, 5.)));\n}\n\nfloat NoTreeZone(vec3 p)\n{\n  float dist = distance(readRGB(ivec2(140, 0)).xz, p.xz);\n  dist = min(dist, distance(readRGB(ivec2(142, 0)).xz, p.xz));\n  dist = min(dist, distance(readRGB(ivec2(144, 0)).xz, p.xz));\n  dist = min(dist, distance(readRGB(ivec2(146, 0)).xz, p.xz));\n  dist = min(dist, distance(readRGB(ivec2(148, 0)).xz, p.xz));\n  return dist;\n}\nfloat GetTerrainHeight( vec3 p)\n{\n  vec2 p2 = (p.xz+planePos.xz)*0.0005;\n\n  float heightDecrease = mix(1.0, 0., smoothstep(0., 15.0, NoTreeZone(p+planePos)));\n\n  float mainHeight = -2.3+fastFBM((p+vec3(planePos.x, 0., planePos.z))*0.025)*max(11., abs(22.*noise2D(p2))); \n  mainHeight-=heightDecrease;\n\n  float terrainHeight=mainHeight;\n  p2*=4.0;\n  terrainHeight += textureLod( iChannel3, p2, 2.7 ).x*1.; \n  p2*=2.0;\n  terrainHeight -= textureLod( iChannel3, p2, 1.2 ).x*.7;\n  p2*=3.0;\n  terrainHeight -= textureLod( iChannel3, p2, 0.5 ).x*.1;\n\n  terrainHeight=mix(terrainHeight, mainHeight*1.4, smoothstep(1.5, 3.5, terrainHeight)); \n\n  return   terrainHeight;\n}\n\nfloat GetTreeHeight( vec3 p, float terrainHeight)\n{\n  if (NoTreeZone(p+planePos)<25.) return 0.;\n  float treeHeight = textureLod(iChannel3, (p.xz+planePos.xz)*0.006, .1).x;\n  float tree = mix(0., mix(0., mix(0., 2.0, smoothstep(0.3, 0.86, treeHeight)), smoothstep(1.5, 3.5, terrainHeight)), step(0.3, treeHeight)); \n  tree -= tree*0.75;\n  tree*=4.0;\n\n  return  tree;\n}\n\nfloat MapTerrainSimple( vec3 p)\n{\n  float terrainHeight = GetTerrainHeight(p);   \n  return  p.y - max((terrainHeight+GetTreeHeight(p, terrainHeight)), 0.);\n}\n\nfloat GetStoneHeight(vec3 p, float terrainHeight)\n{\n  return (textureLod(iChannel1, (p.xz+planePos.xz)*0.05, 0.).x*max(0., -0.3+(1.25*terrainHeight)));\n}\n\nfloat MapTerrain( vec3 p)\n{   \n  float terrainHeight = GetTerrainHeight(p);   \n  terrainHeight= mix(terrainHeight+GetStoneHeight(p, terrainHeight), terrainHeight, smoothstep(0., 1.5, terrainHeight));\n  terrainHeight= mix(terrainHeight+(textureLod(iChannel1, (p.xz+planePos.xz)*0.0015, 0.).x*max(0., -0.3+(.5*terrainHeight))), terrainHeight, smoothstep(1.2, 12.5, terrainHeight));\n\n  terrainHeight= mix(terrainHeight-0.30, terrainHeight, smoothstep(-0.5, 0.25, terrainHeight));\n  float water=0.;\n  if (terrainHeight<=0.)\n  {   \n    water = (-0.5+(0.5*(noise2D((p.xz+planePos.xz+ vec2(-iTime*0.4, iTime*0.25))*2.60, WATER_LOD))));\n    water*=(-0.5+(0.5*(noise2D((p.xz+planePos.xz+ vec2(iTime*.3, -iTime*0.25))*2.90), WATER_LOD)));\n  }\n  return   p.y -  max((terrainHeight+GetTreeHeight(p, terrainHeight)), -water*0.04);\n}\n\n\nfloat MapTree( vec3 p)\n{  \n  float terrainHeight = GetTerrainHeight(p);\n  float treeHeight =GetTreeHeight(p, terrainHeight);\n\n  \/\/ get terrain height at position and tree height onto that\n  return  p.y - terrainHeight-treeHeight;\n}\n\nvec3 calcTreeNormal( in vec3 pos )\n{    \n  return normalize( vec3(MapTree(pos+eps.xyy) - MapTree(pos-eps.xyy), 0.5*2.0*eps.x, MapTree(pos+eps.yyx) - MapTree(pos-eps.yyx) ) );\n}\n\nvec4 TraceTrees( vec3 origin, vec3 direction, int steps, float terrainHeight)\n{\n  vec4 treeCol =vec4(0.5, 0.5, 0.5, 0.0);\n  float intensity=0.0, t = .0, dist = 0.0;\n  vec3 rayPos, nn;\n  float precis=.0, dif =0.0, densAdd =.0;\n  float treeHeight = 0.0;\n  float td =.0;\n  for ( int i=0; i<steps; i++ )\n  {\n    rayPos = origin+direction*t;\n    treeHeight = GetTreeHeight(rayPos, terrainHeight);\n    dist = rayPos.y - (terrainHeight + treeHeight);  \n    precis = 0.015*t;\n\n    if (treeHeight>0.1 && dist<precis)\n    {\n      nn= calcTreeNormal(rayPos);  \n      dif = clamp( dot( nn, sunPos ), 0.0, 1.0 );\n\n      densAdd = (precis-dist)*3.0*td;\n      treeCol.rgb+=(0.5*td)*dif;\n      treeCol.a+=(1.-treeCol.a)*densAdd;\n    } \n    if (treeCol.a > 0.99) \n    {\n      break;\n    }\n    td = max(0.04, dist*0.5);\n    t+=td;\n  }\n\n  return clamp(treeCol, 0., 1.);\n}\n\n\nRayHit TraceTerrainReflection( vec3 origin, vec3 direction, int steps)\n{\n  RayHit result;\n  float precis = 0.0, maxDist = 100.0, t = 0.0, dist = 0.0;\n  vec3 rayPos;\n\n  for ( int i=0; i<steps; i++ )\n  {\n    rayPos =origin+direction*t; \n    dist = MapTerrainSimple( rayPos);\n    precis = 0.01*t;\n\n    if (dist<precis || t>maxDist )\n    {             \n      result.hit=!(t>maxDist);\n      result.depth = t; \n      result.dist = dist;                              \n      result.hitPos = origin+((direction*t));     \n      break;\n    }\n\n    t += dist*0.5;\n  }\n\n  return result;\n}\n\nRayHit TraceTerrain( vec3 origin, vec3 direction, int steps)\n{\n  RayHit result;\n  float precis = 0.0, maxDist = 400.0, t = 0.0, dist = 0.0;\n  vec3 rayPos;\n\n  for ( int i=0; i<steps; i++ )\n  {\n    rayPos =origin+direction*t; \n    dist = MapTerrain( rayPos);\n    precis = 0.001*t;\n\n    if (dist<precis || t>maxDist )\n    {             \n      result.hit=!(t>maxDist);\n      result.depth = t; \n      result.dist = dist;                              \n      result.hitPos = origin+((direction*t));     \n      break;\n    }\n\n    t += dist*0.5;\n  }\n\n  return result;\n}\n\nfloat SoftShadow( in vec3 origin, in vec3 direction )\n{\n  float res = 2.0, t = 0.0, h;\n  for ( int i=0; i<16; i++ )\n  {\n    h = MapTerrain(origin+direction*t);\n    res = min( res, 3.5*h\/t );\n    t += clamp( h, 0.02, 0.8);\n    if ( h<0.002 ) break;\n  }\n  return clamp( res, 0.0, 1.0 );\n}\n\n\nvec3 calcNormal( in vec3 pos )\n{    \n  return normalize( vec3(MapTerrain(pos+eps.xyy) - MapTerrain(pos-eps.xyy), 0.5*2.0*eps.x, MapTerrain(pos+eps.yyx) - MapTerrain(pos-eps.yyx) ) );\n}\n\nfloat GetCloudHeight(vec3 p)\n{    \n  vec3 p2 = (p+vec3(planePos.x, 0., planePos.z)+vec3(cloudPos.x, 0., cloudPos.y))*0.03;\n\n  float i  = (-0.3+noise(p2))*4.4; \n  p2*=2.52;\n  i +=abs(noise( p2 ))*1.7; \n  p2*=2.53;\n  i += noise( p2 )*1.; \n  p2*=2.51;\n  i += noise(p2 )*0.5;\n  p2*=4.22;\n  i += noise( p2)*0.2;\n  return i*3.;\n}\n\nfloat GetCloudHeightBelow(vec3 p)\n{    \n  vec3 p2 = (p+vec3(planePos.x, 0., planePos.z)+vec3(cloudPos.x, 0., cloudPos.y))*0.03;\n\n  float i  = (-0.3+noise(p2))*4.4; \n  p2*=2.52;\n  i +=noise( p2 )*1.7; \n  p2*=2.53;\n  i += noise( p2 )*1.; \n  p2*=2.51;\n  i += noise(p2 )*0.5;\n  p2*=3.42;\n  i += noise( p2)*0.2;\n  i*=0.5;\n  i-=0.25*i; \n\n  return i*5.;\n}\n\nfloat GetHorizon( vec3 p)\n{\n  return sdEllipsoid(p, vec3(1000., -CLOUDLEVEL, 1000.));\n}\n\nfloat MapCloud( vec3 p)\n{\n  return GetHorizon(p) - max(-3., (1.3*GetCloudHeight(p)));\n}\n\nvec4 TraceClouds( vec3 origin, vec3 direction, vec3 skyColor, int steps)\n{\n  vec4 cloudCol=vec4(skyColor*vec3(0.65, 0.69, 0.72)*1.3, 0.0);\n  cloudCol.rgb=mix(cloudCol.rgb, sunColor, 0.32);\n\n  float density = 0.0, t = .0, dist = 0.0;\n  vec3 rayPos;\n  float precis; \n  float td =.0;\n  float densAdd;\n  float sunDensity;\n  for ( int i=0; i<steps; i++ )\n  {\n    rayPos = origin+direction*t;\n    density = max(-5., 1.7+(GetCloudHeight(rayPos)*1.3));\n    dist = GetHorizon(rayPos)-(density);\n\n    precis = 0.01*t;\n    if (dist<precis && density>-5.1)\n    {    \n      sunDensity = MapCloud(rayPos+sunPos*3.);\n      densAdd =  mix(0., 0.5*(1.0-cloudCol.a), smoothstep(-5.1, 4.3, density));\n      cloudCol.rgb-=clamp((density-sunDensity), 0., 1.0)*0.06*sunColor*densAdd;\n      cloudCol.rgb += 0.003*max(0., sunDensity)*density*densAdd;\n      \n\n      cloudCol.a+=(1.-cloudCol.a)*densAdd;\n    } \n\n    if (cloudCol.a > 0.99) break; \n\n    td = max(0.12, dist*0.45);\n    t+=td;\n  }\n\n  \/\/ mix clouds color with sky color\n  float mixValue = smoothstep(100., 620., t);\n  cloudCol.rgb = mix(cloudCol.rgb, skyColor, mixValue);\n\n  return cloudCol;\n}\n\nvec4 TraceCloudsBelow( vec3 origin, vec3 direction, vec3 skyColor, int steps)\n{\n  vec4 cloudCol=vec4(vec3(0.95, 0.95, 0.98)*0.7, 0.0);\n  cloudCol.rgb=mix(cloudCol.rgb, sunColor, 0.2);\n\n  float density = 0.0, t = .0, dist = 0.0;\n  vec3 rayPos;\n  float precis; \n  float td =.0;\n  float energy=1.0;\n  float densAdd=0.;\n  float sunDensity;\n\n  for ( int i=0; i<steps; i++ )\n  {\n    rayPos = origin+direction*t;\n    density = clamp(GetCloudHeightBelow(rayPos), 0., 1.)*2.;          \n    dist = -GetHorizon(rayPos);\n\n    precis = 0.015*t;\n    if (dist<precis && density>0.001)\n    {    \n      densAdd = 0.14*density\/td;\n      sunDensity = clamp(GetCloudHeightBelow(rayPos+sunPos*3.), -0.6, 2.)*2.; \n      cloudCol.rgb-=sunDensity*0.02*cloudCol.a*densAdd; \n      cloudCol.a+=(1.-cloudCol.a)*densAdd;\n\n      cloudCol.rgb += 0.03*max(0., density-sunDensity)*densAdd;\n\n      cloudCol.rgb+=mix(vec3(0.), vec3(1.0, 1.0, 0.9)*0.013, energy)*sunColor;\n      energy*=0.96;\n    } \n\n    if (cloudCol.a > 0.99) break; \n\n    td = max(1.4, dist);\n    t+=td;\n  }\n    \n  \/\/ mix clouds color with sky color\n  cloudCol.rgb = mix(cloudCol.rgb, vec3(0.97), smoothstep(100., 960., t)); \n  cloudCol.a = mix(cloudCol.a, 0., smoothstep(0., 960., t));\n\n  return cloudCol;\n}\n\nfloat getTrailDensity( vec3 p)\n{\n  return noise(p*3.)*1.;\n}\n\nvoid TranslateMissilePos(inout vec3 p, Missile missile)\n{  \n  p = p-(missile.pos);  \n  p+=missile.origin;\n  pR(p.xz, missile.orientation.z);\n  pR(p.xy, -missile.orientation.x +PI);\n  p-=missile.origin;\n}\n\nvec2 MapSmokeTrail( vec3 p, Missile missile)\n{\n  TranslateMissilePos(p, missile);\n  float spreadDistance = 1.5;\n  p.z+=3.82;\n\n  \/\/ map trail by using mod op and ellipsoids\n  float s = pModInterval1(p.z, -spreadDistance, .0, min(12., (missile.pos.z-planePos.z)\/spreadDistance));     \n  float dist = sdEllipsoid(p+vec3(0.0, 0.0, .4), vec3(0.6, 0.6, 3.));   \n  dist-= getTrailDensity(p+vec3(10.*s))*0.25;\n\n  return vec2(dist, s);\n}\n\n\nvec4 TraceSmoketrail( vec3 origin, vec3 direction, int steps, Missile missile)\n{\n  vec4 trailCol =vec4(0.5, 0.5, 0.5, 0.0);\n  float height = 0.0, t = .0;\n  vec2 dist = vec2(0.0);\n  vec3 rayPos;\n  float precis; \n  float td =.0;\n  for ( int i=0; i<steps; i++ )\n  {\n    rayPos = origin+direction*t;\n    dist = MapSmokeTrail(rayPos, missile);  \n    precis = 0.002*t;\n    if (dist.x<precis)\n    {     \n      trailCol.rgb+=(0.5*(getTrailDensity(rayPos+sunPos*.17)))*0.03;\n\n      float densAdd =(precis-dist.x)*0.20;\n      trailCol.a+=(1.-trailCol.a)*densAdd\/(1.+(pow(dist.y, 2.0)*0.021));\n    } \n\n    if (trailCol.a > 0.99) break; \n\n    td = max(0.04, dist.x);\n    t+=td;\n  }\n\n  return clamp(trailCol, 0., 1.);\n}\n\n\nfloat MapExplosion( vec3 p, Explosion ex)\n{ \n  checkPos = (ex.pos)-vec3(planePos.x, 0., planePos.z); \n  checkPos=p-checkPos;\n\n  float testDist = fSphere(checkPos, 20.0);\n  if (testDist>10.)  return testDist;\n\n  float intensity =GetExplosionIntensity(ex);\n  float d= fSphere(checkPos, intensity*15.);  \n\n  \/\/ terrain clipping\n  #ifdef EXACT_EXPLOSIONS\n    d=max(d, -MapTerrain(p));\n  #else\n    d = max(d, -sdBox(checkPos+vec3(0., 50., 0.), vec3(50., 50.0, 50.0)));\n  #endif\n\n  \/\/ add explosion \"noise\/flames\"\n  float displace = fbm(((checkPos) + vec3(1, -2, -1)*iTime)*0.5);\n  return d + (displace * 1.5*max(0., 4.*intensity));\n}\n\n\nRayHit TraceExplosion(in vec3 origin, in vec3 direction, int steps, Explosion ex)\n{\n  RayHit result;\n  float precis = 0.0, maxDist = 350.0, t = 0.0, dist = 0.0;\n  vec3 rayPos;\n\n  for ( int i=0; i<steps; i++ )\n  {\n    rayPos =origin+direction*t; \n    dist = MapExplosion( rayPos, ex);\n    precis = 0.01*t;\n\n    if (dist<precis || t>maxDist )\n    {             \n      result.hit=!(t>maxDist);\n      result.depth = t; \n      result.dist = dist;                              \n      result.hitPos = origin+((direction*t));     \n      break;\n    }\n\n    t += dist*0.5;\n  }\n\n  return result;\n}\n\n\/\/ inspired by https:\/\/www.shadertoy.com\/view\/XdfGz8\nvec3 GetExplosionColor(float x)\n{\n  vec3 col1= vec3(240., 211., 167.)\/255.;\n  vec3 col2 = vec3(210., 90., 60.)\/255.;\n  vec3 col3 = vec3(84., 20., 13.)\/255.;\n\n  float t = fract(x*3.);\n  vec3 c= mix(col2, col3, t);\n  c= mix(mix(col1, col2, t), c, step(0.666, x));\n  return mix(mix(vec3(4, 4, 4), col1, t), c, step(0.333, x));\n}\n\nvec3 GetExplosionLight(float specLevel, vec3 normal, RayHit rayHit, vec3 rayDir, vec3 origin)\n{                \n  vec3 reflectDir = reflect( rayDir, normal );\n\n  vec3 lightTot = vec3(0.0);\n  float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );\n  float dif = clamp( dot( normal, sunPos ), 0.0, 1.0 );\n  float bac = clamp( dot( normal, normalize(vec3(-sunPos.x, 0.0, -sunPos.z)) ), 0.0, 1.0 ) * clamp(1.0-rayHit.hitPos.y\/20.0, 0.0, 1.0);\n\n  float fre = pow( clamp(1.0+dot(normal, rayDir), 0.0, 1.0), 2.0 );\n  specLevel*= pow(clamp( dot( reflectDir, sunPos ), 0.0, 1.0 ), 7.0);\n  float skylight = smoothstep( -0.1, 0.1, reflectDir.y );\n\n  lightTot += 1.5*dif*vec3(1.00, 0.90, 0.85);\n  lightTot += 0.50*skylight*vec3(0.40, 0.60, 0.95);\n  lightTot += 1.00*specLevel*vec3(0.9, 0.8, 0.7)*dif;\n  lightTot += 0.50*bac*vec3(0.25, 0.25, 0.25);\n  lightTot += 0.25*fre*vec3(1.00, 1.00, 1.00);\n\n  return clamp(lightTot, 0., 10.);\n}\n\n\nvoid DrawExplosion(int id, RayHit marchResult, inout vec3 color, vec3 rayDir, vec3 rayOrigin)\n{\n  Explosion explosion;\n  id *= 100;\n  explosion.life = read(ivec2(122+id, 0));\n\n  \/\/ check if explosion has been spawned\n  if (explosion.life>0.)\n  {  \n    explosion.pos = readRGB(ivec2(120+id, 0)); \n\n    vec3 testPoint = explosion.pos-planePos;\n    \/\/ ensure the explosions starts on ground\n    \/\/ explosion.pos.y=GetTerrainHeight(testPoint);\n\n    \/\/ explosion light flash    \n    if (marchResult.hit)\n    {\n      float intensity = GetExplosionIntensity(explosion);\n\n      vec3 testCol = color.rgb+vec3(1.0, 0.59, 0.28)*2.5;\n      color.rgb=mix(color.rgb, mix(testCol, color.rgb, smoothstep(0., 40.0*intensity, distance(testPoint.xz, marchResult.hitPos.xz))), intensity);\n    }\n\n    \/\/ trace explosion  \n    RayHit exploTest = TraceExplosion(rayOrigin, rayDir, 68, explosion);   \n    if (exploTest.hit)\n    {\n      color.rgb = GetExplosionColor(clamp(0.5+((fbm((exploTest.hitPos + vec3(1, -2, -1)*iTime)*0.5))), 0.0, 0.99));\n      color.rgb = mix(color.rgb, color.rgb*0.45, smoothstep(0., 12., distance(exploTest.hitPos.y, GetTerrainHeight(testPoint))));\n    }\n\n    color.rgb = mix(color.rgb*3.0, color.rgb, smoothstep(0., 12.4, exploTest.dist));\n  }\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n}\n\nfloat MapFlare( vec3 p, Missile missile)\n{\n  TranslateMissilePos(p, missile);\n  return sdEllipsoid( p+ vec3(0., 0., 2.4), vec3(.05, 0.05, .15));\n}\n\nfloat TraceEngineFlare(in vec3 origin, in vec3 direction, Missile missile)\n{\n  float t = 0.0;\n  vec3 rayPos = vec3(0.0);\n  float dist=10000.;\n\n  for ( int i=0; i<10; i++ )\n  {\n    rayPos =origin+direction*t;\n    dist = min(dist, MapFlare( rayPos, missile));\n    t += dist;\n  }\n\n  return dist;\n}\n\nfloat MapMissile(vec3 p, Missile missile)\n{\n  float d= fCylinder( p, 0.70, 1.7);\n  if (d<1.0)\n  {\n    d = fCylinder( p, 0.12, 1.2);   \n    d =min(d, sdEllipsoid( p- vec3(0, 0, 1.10), vec3(0.12, 0.12, 1.0))); \n\n    checkPos = p;  \n    pR(checkPos.xy, 0.785);\n    checkPos.xy = pModPolar(checkPos.xy, 4.0);\n\n    d=min(d, sdHexPrism( checkPos-vec3(0., 0., .60), vec2(0.50, 0.01)));\n    d=min(d, sdHexPrism( checkPos+vec3(0., 0., 1.03), vec2(0.50, 0.01)));\n    d = max(d, -sdBox(p+vec3(0., 0., 3.15), vec3(3.0, 3.0, 2.0)));\n    d = max(d, -fCylinder(p+vec3(0., 0., 2.15), 0.09, 1.2));\n  }\n  return d;\n}\n\nfloat MapFlyingMissile( vec3 p, Missile missile)\n{\n  TranslateMissilePos(p, missile);  \n  \/\/ map missile flame\n  eFlameDist = min(eFlameDist, sdEllipsoid( p+ vec3(0., 0., 2.2+cos(iTime*90.0)*0.23), vec3(.17, 0.17, 1.0)));\n  \/\/ map missile \n  return min(MapMissile(p, missile), eFlameDist);\n}\n\nRayHit TraceMissile(in vec3 origin, in vec3 direction, int steps, Missile missile)\n{\n  RayHit result;\n  float maxDist = 450.0;\n  float t = 0.0, glassDist = 0.0, dist = 100000.0;\n  vec3 rayPos;\n  eFlameDist=10000.0;\n  for ( int i=0; i<steps; i++ )\n  {\n    rayPos =origin+direction*t;\n    dist = MapFlyingMissile(rayPos, missile);\n\n    if (dist<0.01 || t>maxDist )\n    {                \n      result.hit=!(t>maxDist);\n      result.depth = t; \n      result.dist = dist;                              \n      result.hitPos = origin+((direction*t));   \n\n      result.eFlameDist = eFlameDist;\n      break;\n    }\n    t += dist;\n  }\n\n  return result;\n}\n\nfloat SoftShadowMissile( in vec3 origin, in vec3 direction, Missile missile )\n{\n  float res = 2.0, t = 0.02, h;\n  for ( int i=0; i<8; i++ )\n  {\n    h = MapMissile(origin+direction*t, missile);\n    res = min( res, 7.5*h\/t );\n    t += clamp( h, 0.05, 0.2 );\n    if ( h<0.001 || t>2.5 ) break;\n  }\n  return clamp( res, 0.0, 1.0 );\n}\n\nvec3 GetMissileLightning(float specLevel, vec3 normal, RayHit rayHit, vec3 rayDir, vec3 origin, Missile missile)\n{       \n  float dif = clamp( dot( normal, sunPos ), 0.0, 1.0 );\n  vec3 reflectDir = reflect( rayDir, normal );\n  specLevel= 3.5*pow(clamp( dot( reflectDir, sunPos ), 0.0, 1.0 ), 9.0\/3.);\n\n  float fre = pow( 1.0-abs(dot( normal, rayDir )), 2.0 );\n  fre = mix( .03, 1.0, fre );   \n  float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );\n\n  float shadow = SoftShadowMissile(origin+((rayDir*rayHit.depth)*0.998), sunPos, missile);\n  dif*=shadow;\n  float skyLight = smoothstep( -0.1, 0.1, reflectDir.y );\n\n  vec3 lightTot = (vec3(0.7)*amb); \n  lightTot+=vec3(0.85)*dif;\n  lightTot += 1.00*specLevel*dif;\n  lightTot += 0.80*skyLight*vec3(0.40, 0.60, 1.00);\n  lightTot= mix(lightTot*.7, lightTot*1.2, fre );\n\n  return lightTot*sunColor;\n}\n\nvec3 calcMissileNormal( in vec3 pos, Missile missile )\n{    \n  return normalize( vec3(MapFlyingMissile(pos+eps.xyy, missile) - MapFlyingMissile(pos-eps.xyy, missile), 0.5*2.0*eps.x, MapFlyingMissile(pos+eps.yyx, missile) - MapFlyingMissile(pos-eps.yyx, missile) ) );\n}\n\nmat3 setCamera(  vec3 ro, vec3 ta, float cr )\n{\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n  vec3 cu = normalize( cross(cw, cp) );\n  vec3 cv = normalize( cross(cu, cw) );\n  return mat3( cu, cv, cw );\n}\n\n\/\/ set sky color tone. 2 gradient passes using MIX.\nvec3 GetSkyColor(vec3 rayDir)\n{ \n  return mix(mix(vec3(0.15, 0.19, 0.24), vec3(220., 230., 240.0)\/255., smoothstep(1.0, .30, rayDir.y)), mix(vec3(229.0, 221., 230)\/200., sunColor, 0.15), smoothstep(0.15, -0.13, rayDir.y));\n}\n\n\/\/ scene lightning\nvec3 GetSceneLight(float specLevel, vec3 normal, RayHit rayHit, vec3 rayDir, vec3 origin)\n{                \n  vec3 reflectDir = reflect( rayDir, normal );\n\n  vec3 lightTot = vec3(0.0);\n  float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );\n  float dif = clamp( dot( normal, sunPos ), 0.0, 1.0 );\n  float bac = clamp( dot( normal, normalize(vec3(-sunPos.x, 0.0, -sunPos.z)) ), 0.0, 1.0 ) * clamp(1.0-rayHit.hitPos.y\/20.0, 0.0, 1.0);\n  ;\n  float fre = pow( clamp(1.0+dot(normal, rayDir), 0.0, 1.0), 2.0 );\n  specLevel*= pow(clamp( dot( reflectDir, sunPos ), 0.0, 1.0 ), 7.0);\n  float skylight = smoothstep( -0.1, 0.1, reflectDir.y );\n\n  float shadow=1.; \n  #ifdef SHADOWS\n    shadow = SoftShadow(origin+((rayDir*rayHit.depth)*0.988), sunPos);\n  #endif\n\n    lightTot += 1.5*dif*vec3(1.00, 0.90, 0.85)*shadow;\n  lightTot += 0.50*skylight*vec3(0.40, 0.60, 0.95);\n  lightTot += 1.00*specLevel*vec3(0.9, 0.8, 0.7)*dif;\n  lightTot += 0.50*bac*vec3(0.25, 0.25, 0.25);\n  lightTot += 0.25*fre*vec3(1.00, 1.00, 1.00)*shadow;\n\n  return clamp(lightTot, 0., 10.)*sunColor;\n}\n\nvec3 GetSceneLightWater(float specLevel, vec3 normal, RayHit rayHit, vec3 rayDir, vec3 origin)\n{                \n  vec3 reflectDir = reflect( rayDir, normal );\n  float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );\n  float dif = clamp( dot( normal, sunPos ), 0.0, 1.0 );\n  float bac = clamp( dot( normal, normalize(vec3(-sunPos.x, 0.0, -sunPos.z)) ), 0.0, 1.0 ) * clamp(1.0-rayHit.hitPos.y\/20.0, 0.0, 1.0);\n\n  specLevel*= pow(clamp( dot( reflectDir, sunPos ), 0.0, 1.0 ), 9.0);\n\n  float skylight = smoothstep( -0.1, 0.1, reflectDir.y );\n  float fre = pow( 1.0-abs(dot( normal, rayDir )), 4.0 );\n  fre = mix( .03, 1.0, fre );   \n\n  vec3 reflection = vec3(1.0);\n  vec3 lightTot = vec3(0.0);\n\n  lightTot += 1.15*dif*vec3(1.00, 0.90, 0.85);\n  lightTot += 1.00*specLevel*vec3(0.9, 0.8, 0.7)*dif;    \n  lightTot= mix(lightTot, reflection, fre );\n  lightTot += 0.70*skylight*vec3(0.70, 0.70, 0.85);\n  lightTot += 1.30*bac*vec3(0.25, 0.25, 0.25);\n  lightTot += 0.25*amb*vec3(0.80, 0.90, 0.95);  \n  return clamp(lightTot, 0., 10.);\n}\n\n\nvoid ApplyFog(inout vec3 color, vec3 skyColor, vec3 rayOrigin, vec3 rayDir, float depth)   \n{\n  float mixValue = smoothstep(50., 15000., pow(depth, 2.)*0.1);\n  float sunVisibility = max(0., dot(sunPos, rayDir));\n  \/\/ horizontal fog\n  vec3 fogColor = mix(sunColor*0.7, skyColor, mixValue);  \n  fogColor = mix(fogColor, sunColor, smoothstep(0., 1., sunVisibility));   \n  color = mix(color, fogColor, mixValue);\n\n  \/\/ vertical fog\n  float heightAmount = .01;\n  float fogAmount = 0.2 * exp(-rayOrigin.y*heightAmount) * (1.0-exp( -depth*rayDir.y*heightAmount ))\/rayDir.y;\n  color = mix(color, fogColor, fogAmount);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{  \n  vec2 mo = iMouse.xy\/iResolution.xy;\n  vec2 uv = fragCoord.xy \/ iResolution.xy;\n  vec2 screenSpace = (-iResolution.xy + 2.0*(fragCoord))\/iResolution.y;\n\n  \/\/ read plane data from buffer\n  turn = read(ivec2(1, 10));\n  float roll = read(ivec2(1, 1));\n  float speed = read(ivec2(10, 1));\n  float pitch = read(ivec2(15, 1));\n  sunPos =  readRGB(ivec2(50, 0));\n  planePos = readRGB(ivec2(55, 0));\n  float CAMZOOM = read(ivec2(52, 0));  \n\n  \/\/ setup camera and ray direction\n  vec2 camRot = readRGB(ivec2(57, 0)).xy;\n\n  cloudPos = vec2(-iTime*0.3, iTime*0.45);\n\n  vec3 rayOrigin = vec3(CAMZOOM*cos(camRot.x), planePos.y+CAMZOOM*sin(camRot.y), -3.+CAMZOOM*sin(camRot.x) );    \n  pR(rayOrigin.xz, -turn);\n  mat3 ca = setCamera( rayOrigin, vec3(0., planePos.y, -3. ), 0.0 );\n  vec3 rayDir = ca * normalize( vec3(screenSpace.xy, 2.0) );\n\n  \/\/ create sky color fade\n  vec3 skyColor = GetSkyColor(rayDir);\n  vec3 color = skyColor;\n  float alpha=0.;\n\n  RayHit marchResult = TraceTerrain(rayOrigin, rayDir, 1200);\n\n  \/\/ is terrain hit?\n  if (marchResult.hit)\n  { \n\n    alpha=1.0;\n    marchResult.normal = calcNormal(marchResult.hitPos);  \n\n    float specLevel=0.7;\n    color=vec3(0.5);\n\n    \/\/ create terrain texture\n    vec3 colorRocks= vec3(mix(texture(iChannel3, (marchResult.hitPos.xz+planePos.xz)*.01).rgb, texture(iChannel3, (marchResult.hitPos.xz+vec2(10000.0, 10000.0)+planePos.xz)*.01).rgb, fastFBM(marchResult.hitPos)));\n    color =colorRocks;\n    color.rgb = mix(color.rgb, color*3., abs(noise2D((marchResult.hitPos.xz+planePos.xz)*0.4, 1.0))); \n\n    \/\/ grass\n    color.rgb = mix(color.rgb, ((color+noise2D((marchResult.hitPos.xz+planePos.xz)*24., 1.0))+vec3(0.5, 0.4, .1))*0.3, smoothstep(0.2, 2.0, marchResult.hitPos.y)); \n\n    float stoneHeight = GetStoneHeight(marchResult.hitPos, (GetTerrainHeight(marchResult.hitPos)));     \n    color.rgb = mix(color.rgb, vec3(0.5+(noise(marchResult.hitPos+vec3(planePos.x, 0., planePos.z))*0.3)), smoothstep(1., .0, stoneHeight));\n    specLevel = mix(specLevel, specLevel*2.6, smoothstep(1., .0, stoneHeight));\n\n    \/\/ beach\n    color.rgb = mix((color+vec3(1.2, 1.1, 1.0))*0.5, color.rgb, smoothstep(0.3, 0.7, marchResult.hitPos.y)); \n\n\n    float burn = NoTreeZone(marchResult.hitPos+planePos);\n    color=mix(color*0.1, color, smoothstep(0., 25., burn));\n\n    \/\/ create slight wave difference between water and beach level\n    float wave = max(0., cos(abs(noise2D((marchResult.hitPos.xz+planePos.xz)))+(iTime*.5)+(length(marchResult.hitPos.xz)*0.03))*0.09);\n\n    vec3 light;\n    \/\/ check if terrain is below water level\n    if (marchResult.hitPos.y<0.3+wave)\n    {\n      vec3 terrainHit = rayOrigin+((rayDir*marchResult.depth)*0.998);\n      vec3 refDir = reflect(rayDir, marchResult.normal);\n      vec4 testClouds = TraceCloudsBelow(terrainHit, refDir, skyColor, 30);\n\n      color = vec3(0.3);\n\n      float sunVisibility = max(0., dot(sunPos, rayDir));\n\n      \/\/ calculate water fresnel  \n      float dotNormal = dot(rayDir, marchResult.normal);\n      float fresnel = pow(1.0-abs(dotNormal), 4.);  \n      vec3 rayRef = rayDir-marchResult.normal*dotNormal;\n\n      \/\/color.rgb  = mix(mix(vec3(1.0), (vec3(0.7)+sunColor)*1.50, smoothstep(150., 350.,marchResult.depth)), color.rgb, smoothstep(-TERRAINLEVEL-0.37, -TERRAINLEVEL+0.25, marchResult.hitPos.y));\n      color.rgb  = mix(color*.7, color.rgb, smoothstep(-3.0, -0.15, marchResult.hitPos.y));\n\n      color = color+(sunColor*pow(sunVisibility, 5.0));\n\n      \/\/ sea color\n      color = mix(mix(color, color+fresnel, fresnel ), color, smoothstep(-0.1, 0.15, marchResult.hitPos.y));\n\n      vec3 reflection = color;\n\n      #ifdef QUALITY_REFLECTIONS\n        \/\/ cast rays from water surface onto terrain. If terrain is hit, color water dark in these areas.\n        RayHit reflectResult = TraceTerrainReflection(terrainHit, refDir, 100); \n\n      if (reflectResult.hit==true)\n      {\n        reflection  = mix(color, vec3(.01, 0.03, .0), 0.9);\n      }\n      #endif\n        light = GetSceneLightWater(specLevel, marchResult.normal, marchResult, rayDir, rayOrigin);   \n      color=mix(mix(color.rgb, testClouds.rgb, testClouds.a*.26), mix(color.rgb, testClouds.rgb, testClouds.a), smoothstep(0., 0.7, fresnel)); \n      color=mix(mix(color.rgb, reflection, 0.5), reflection, smoothstep(0., 0.7, fresnel)); \n      color=mix(color, color+(0.5*fresnel), smoothstep(0., 0.3, fresnel)); \n\n      color=color*light;\n      color = mix(color, skyColor, smoothstep(320., 400., marchResult.depth));\n    } \n    \/\/ terrain is ABOVE water level  \n    else\n    {\n      \/\/ get lightning based on material\n      light = GetSceneLight(specLevel, marchResult.normal, marchResult, rayDir, rayOrigin);   \n\n      \/\/ apply lightning\n      color = color*light;\n\n      #ifdef QUALITY_TREE\n        \/\/ add trees\n        vec4 treeColor = TraceTrees(rayOrigin, rayDir, 28, marchResult.hitPos.y-0.3 );      \n      color =clamp( mix( color, treeColor.rgb*((noise2D((marchResult.hitPos.xz+planePos.xz)*36., 3.0)+vec3(0.56, 0.66, .45))*0.6)*sunColor*(.30+(0.6*light)), treeColor.a ), 0.02, 1.); \n      #endif\n    }\n\n    color = mix(color, (color+sunColor)*0.6, smoothstep(70., 300., marchResult.depth));\n    \/\/ add haze when high above ground  \n    color = mix(color, color+vec3(0.37, 0.58, 0.9)*sunColor, mix(0., 0.75, smoothstep(-CLOUDLEVEL*0.65, MAX_HEIGHT, planePos.y)));  \n    ApplyFog(color, skyColor, rayOrigin, rayDir, marchResult.depth);\n  } else\n  {\n    \/\/ add volumetric clouds \n    \/\/ below cloud level\n    if (rayOrigin.y<-CLOUDLEVEL && rayDir.y>0.)\n    {  \n      vec4 cloudColor=TraceCloudsBelow(rayOrigin, rayDir, skyColor, 60);    \n\n      \/\/ make clouds slightly light near the sun\n      float sunVisibility = pow(max(0., dot(sunPos, rayDir)), 2.0)*0.10;\n      color.rgb = mix(color.rgb, max(vec3(0.), cloudColor.rgb+sunVisibility), cloudColor.a);      \n      \/\/color.rgb = mix(color.rgb, cloudColor.rgb, cloudColor.a);       \n      alpha+=cloudColor.a*0.86;\n    }\n  }\n\n  \/\/ add volumetric clouds \n  \/\/ above cloud level\n  if (rayOrigin.y>=-CLOUDLEVEL)\n  {  \n    vec4 cloudColor=TraceClouds(rayOrigin, rayDir, skyColor, 80);    \n    color.rgb = mix(color.rgb, cloudColor.rgb, cloudColor.a);\n  }\n\n  rayDir = ca * normalize( vec3(screenSpace.xy, 2.0) );\n  DrawExplosion(0, marchResult, color, rayDir, rayOrigin);\n  DrawExplosion(1, marchResult, color, rayDir, rayOrigin);\n\n\n  \/\/ #################################################################### \/\/    \n  \/\/ ##############             MISSILES             #################### \/\/     \n  \/\/ #################################################################### \/\/    \n\n  rayOrigin = vec3(CAMZOOM*cos(camRot.x), CAMZOOM*sin(camRot.y), CAMZOOM*sin(camRot.x) );\n  pR(rayOrigin.xz, -turn);\n  ca = setCamera( rayOrigin, vec3(0., 0., 0. ), 0.0 );\n  rayDir = ca * normalize( vec3(screenSpace.xy, 2.0) );\n\n  int adressStep = 0;\n  Missile missile;\n  for (int i=0; i<2; i++)\n  {\n    adressStep = i*100;\n    missile.life = read(ivec2(100 + adressStep, 0));\n    \/\/ check if missile is launched\n    if (missile.life>0.)\n    {\n      missile.origin = vec3(4.8 - (9.6*float(i)), -0.4, -3.0);       \n      missile.orientation = readRGB(ivec2(108+adressStep, 0));\n      missile.pos = readRGB(ivec2(116+adressStep, 0));\n\n      \/\/ calculate engine flare\n      float lightDist = TraceEngineFlare(rayOrigin, rayDir, missile);\n\n      \/\/ add engine flares for missiles based on engine distance\n      vec3 lightFlares=vec3(0.);\n      lightFlares =  mix((vec3(1., 0.4, 0.2)), vec3(0.), smoothstep(0., 1.1, lightDist));             \n      lightFlares =  mix(lightFlares+(2.*vec3(1., 0.5, 0.2)), lightFlares, smoothstep(0., 0.7, lightDist));\n      lightFlares =  mix(lightFlares+vec3(1., 1., 1.), lightFlares, smoothstep(0., 0.2, lightDist));\n\n      \/\/ rayTrace missile\n      RayHit marchResult = TraceMissile(rayOrigin, rayDir, 64, missile);\n\n      \/\/ apply color and lightning to missile if hit in raymarch test    \n      if (marchResult.hit)\n      {\n        marchResult.normal = calcMissileNormal(marchResult.hitPos, missile);  \n\n        \/\/ create texture map and set specular levels\n        vec4 col = vec4(0.45, 0.45, 0.45, 0.8);\n\n        \/\/ flame\n        col.rgb=mix(col.rgb, vec3(1.2, .55, 0.30)*2.5, smoothstep(.16, 0., marchResult.eFlameDist));\n\n        \/\/ get lightning based on material\n        vec3 light = GetMissileLightning(col.a, marchResult.normal, marchResult, rayDir, rayOrigin, missile);   \n\n        \/\/ apply lightning\n        color.rgb = col.rgb*light;\n\n        alpha = 1.; \n\n        lightFlares = mix(lightFlares, vec3(.0), step(0.1, distance(marchResult.dist, marchResult.eFlameDist)));\n      }\n\n      color.rgb+=lightFlares;\n\n      \/\/draw smoke trail behind missile\n      vec4 trailColor = TraceSmoketrail(rayOrigin, rayDir, 48, missile);     \n      color.rgb = mix(color.rgb, trailColor.rgb, trailColor.a);\n      alpha+=trailColor.a;   \n\n      if (marchResult.hit) \n      { \n        break;\n      }\n    }\n  }\n  \/\/ #################################################################### \/\/\n  \/\/ #################################################################### \/\/\n\n  fragColor = vec4(color.rgb, min(1.0, alpha));\n}\n","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"XdXGzn","filepath":"\/media\/a\/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"\/media\/ap\/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3zn","filepath":"\/media\/a\/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"\/media\/ap\/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ PLANE BUFFER   -   RENDERS PLANE ONLY\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Channel 0 = Buffer B. Get the colors of the terrain buffer render.\n\/\/ Channel 1 = LowRes noise texture. Used in fast noise functions.\n\/\/ Channel 2 = Buffer A. Read data from data-buffer.\n\/\/ Channel 3 = Forest blurred cube map. Used in reflections in plane window and hull.\n\n  #pragma optimize(off) \n#define PI acos(-1.)\n  #define read(memPos) (  texelFetch(iChannel2, memPos, 0).a)\n  #define readRGB(memPos) (  texelFetch(iChannel2, memPos, 0).rgb)\n  #define RAYSTEPS 300\n  #define CLOUDLEVEL -70.0\n  float turn=0., pitch = 0., roll=0., rudderAngle = 0.;\nfloat speed = 0.5;\nvec3 checkPos=vec3(0.);\nvec3 sunPos=vec3(0.);\nconst vec3 sunColor = vec3(1.00, 0.90, 0.85);\nvec3 planePos=vec3(0.);\nconst vec3 eps = vec3(0.02, 0.0, 0.0);\n\nfloat winDist=10000.0;\nfloat engineDist=10000.0;\nfloat eFlameDist=10000.0;\nfloat blackDist=10000.0;\nfloat bombDist=10000.0;\nfloat bombDist2=10000.0;\nfloat missileDist=10000.0;\nfloat frontWingDist=10000.0;\nfloat rearWingDist=10000.0;\nfloat topWingDist=10000.0;\nvec2 missilesLaunched=vec2(0.);\n\nfloat sgn(float x) \n{   \n  return (x<0.)?-1.:1.;\n}\n\nstruct RayHit\n{\n  bool hit;  \n  vec3 hitPos;\n  vec3 normal;\n  float dist;\n  float depth;\n\n  float winDist;\n  float engineDist;\n  float eFlameDist;\n  float blackDist;\n  float bombDist;\n  float bombDist2;\n  float missileDist;\n  float frontWingDist;\n  float rearWingDist;\n  float topWingDist;\n};\n\nfloat noise2D( in vec2 pos, float lod)\n{   \n  vec2 f = fract(pos);\n  f = f*f*(3.0-2.0*f);\n  vec2 rg = textureLod( iChannel1, (((floor(pos).xy+vec2(37.0, 17.0)) + f.xy)+ 0.5)\/64.0, lod).yx;  \n  return -1.0+2.0*mix( rg.x, rg.y, 0.5 );\n}\nfloat noise2D( in vec2 pos )\n{\n  return noise2D(pos, 0.0);\n}\n\nfloat noise( in vec3 x )\n{\n  vec3 p = floor(x);\n  vec3 f = fract(x);\n\n  float a = textureLod( iChannel1, x.xy\/64.0 + (p.z+0.0)*120.7123, 0.1 ).x;\n  float b = textureLod( iChannel1, x.xy\/64.0 + (p.z+1.0)*120.7123, 0.1 ).x;\n  return mix( a, b, f.z );\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x, p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa, ba)\/dot(ba, ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  return (length( p\/r.xyz ) - 1.0) * r.y;\n}\n\nfloat sdConeSection( vec3 p, float h, float r1, float r2 )\n{\n  float d1 = -p.z - h;\n  float q = p.z - h;\n  float si = 0.5*(r1-r2)\/h;\n  float d2 = max( sqrt( dot(p.xy, p.xy)*(1.0-si*si)) + q*si - r2, q );\n  return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.);\n}\n\nfloat fCylinder(vec3 p, float r, float height) {\n  float d = length(p.xy) - r;\n  d = max(d, abs(p.z) - height);\n  return d;\n}\nfloat fSphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.y-h.y, max((q.z*0.866025+q.x*0.5), q.x)-h.x);\n}\n\nfloat fOpPipe(float a, float b, float r) {\n  return length(vec2(a, b)) - r;\n}\n\nvec2 pModPolar(vec2 p, float repetitions) {\n  float angle = 2.*PI\/repetitions;\n  float a = atan(p.y, p.x) + angle\/2.;\n  float r = length(p);\n  float c = floor(a\/angle);\n  a = mod(a, angle) - angle\/2.;\n  p = vec2(cos(a), sin(a))*r;\n  if (abs(c) >= (repetitions\/2.)) c = abs(c);\n  return p;\n}\n\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)\/size);\n  p = mod(p+halfsize, size) - halfsize;\n  if (c > stop) {\n    p += size*(c - stop);\n    c = stop;\n  }\n  if (c <start) {\n    p += size*(c - start);\n    c = start;\n  }\n  return c;\n}\n\nfloat pMirror (inout float p, float dist) {\n  float s = sgn(p);\n  p = abs(p)-dist;\n  return s;\n}\n\nmat2 r2(float r)\n{\n  float c=cos(r), s=sin(r);\n  return mat2(c, s, -s, c);\n}\n\n#define r3(r) mat2(sin(vec4(-1, 0, 0, 1)*acos(0.)+r))\n  void pR(inout vec2 p, float a) \n{\n  p*=r2(a);\n}\n\nfloat fOpUnionRound(float a, float b, float r) {\n  vec2 u = max(vec2(r - a, r - b), vec2(0));\n  return max(r, min (a, b)) - length(u);\n}\n\nfloat fOpIntersectionRound(float a, float b, float r) {\n  vec2 u = max(vec2(r + a, r + b), vec2(0));\n  return min(-r, max (a, b)) + length(u);\n}\n\n\/\/ limited by euler rotation. I wont get a good plane rotation without quaternions! :-(\nvec3 TranslatePos(vec3 p, float _pitch, float _roll)\n{\n  pR(p.xy, _roll-PI);\n  p.z+=5.;\n  pR(p.zy, _pitch);\n  p.z-=5.; \n  return p;\n}\n\nfloat MapEsmPod(vec3 p)\n{\n  float dist = fCylinder( p, 0.15, 1.0);   \n  checkPos =  p- vec3(0, 0, -1.0);\n  pModInterval1(checkPos.z, 2.0, .0, 1.0);\n  return min(dist, sdEllipsoid(checkPos, vec3(0.15, 0.15, .5)));\n}\n\nfloat MapMissile(vec3 p)\n{\n  float d= fCylinder( p, 0.70, 1.7);\n  if (d<1.0)\n  {\n    missileDist = min(missileDist, fCylinder( p, 0.12, 1.2));   \n    missileDist =min(missileDist, sdEllipsoid( p- vec3(0, 0, 1.10), vec3(0.12, 0.12, 1.0))); \n\n    checkPos = p;  \n    pR(checkPos.xy, 0.785);\n    checkPos.xy = pModPolar(checkPos.xy, 4.0);\n\n    missileDist=min(missileDist, sdHexPrism( checkPos-vec3(0., 0., .60), vec2(0.50, 0.01)));\n    missileDist=min(missileDist, sdHexPrism( checkPos+vec3(0., 0., 1.03), vec2(0.50, 0.01)));\n    missileDist = max(missileDist, -sdBox(p+vec3(0., 0., 3.15), vec3(3.0, 3.0, 2.0)));\n    missileDist = max(missileDist, -fCylinder(p+vec3(0., 0., 2.15), 0.09, 1.2));\n  }\n  return missileDist;\n}\n\nfloat MapFrontWing(vec3 p, float mirrored)\n{\n  missileDist=10000.0;\n\n  checkPos = p;\n  pR(checkPos.xy, -0.02);\n  float wing =sdBox( checkPos- vec3(4.50, 0.25, -4.6), vec3(3.75, 0.04, 2.6)); \n\n  if (wing<5.) \/\/Bounding Box test\n  {\n    \/\/ cutouts\n    checkPos = p-vec3(3.0, 0.3, -.30);\n    pR(checkPos.xz, -0.5);\n    wing=fOpIntersectionRound(wing, -sdBox( checkPos, vec3(6.75, 1.4, 2.0)), 0.1);\n\n    checkPos = p - vec3(8.0, 0.3, -8.80);\n    pR(checkPos.xz, -0.05);\n    wing=fOpIntersectionRound(wing, -sdBox( checkPos, vec3(10.75, 1.4, 2.0)), 0.1);\n\n    checkPos = p- vec3(9.5, 0.3, -8.50);\n    wing=fOpIntersectionRound(wing, -sdBox( checkPos, vec3(2.0, 1.4, 6.75)), 0.6);\n\n    \/\/ join wing and engine\n    wing=min(wing, sdCapsule(p- vec3(2.20, 0.3, -4.2), vec3(0, 0, -1.20), vec3(0, 0, 0.8), 0.04));\n    wing=min(wing, sdCapsule(p- vec3(3., 0.23, -4.2), vec3(0, 0, -1.20), vec3(0, 0, 0.5), 0.04));    \n\n    checkPos = p;\n    pR(checkPos.xz, -0.03);\n    wing=min(wing, sdConeSection(checkPos- vec3(0.70, -0.1, -4.52), 5.0, 0.25, 0.9));   \n\n    checkPos = p;\n    pR(checkPos.yz, 0.75);\n    wing=fOpIntersectionRound(wing, -sdBox( checkPos- vec3(3.0, -.5, 1.50), vec3(3.75, 3.4, 2.0)), 0.12); \n    pR(checkPos.yz, -1.95);\n    wing=fOpIntersectionRound(wing, -sdBox( checkPos- vec3(2.0, .70, 2.20), vec3(3.75, 3.4, 2.0)), 0.12); \n\n    checkPos = p- vec3(0.47, 0.0, -4.3);\n    pR(checkPos.yz, 1.57);\n    wing=min(wing, sdTorus(checkPos-vec3(0.0, -3., .0), vec2(.3, 0.05)));   \n\n    \/\/ flaps\n    wing =max(wing, -sdBox( p- vec3(3.565, 0.1, -6.4), vec3(1.50, 1.4, .5)));\n    wing =max(wing, -max(sdBox( p- vec3(5.065, 0.1, -8.4), vec3(0.90, 1.4, 2.5)), -sdBox( p- vec3(5.065, 0., -8.4), vec3(0.89, 1.4, 2.49))));\n\n    checkPos = p- vec3(3.565, 0.18, -6.20+0.30);\n    pR(checkPos.yz, -0.15+(0.8*pitch));\n    wing =min(wing, sdBox( checkPos+vec3(0.0, 0.0, 0.30), vec3(1.46, 0.007, 0.3)));\n\n    \/\/ missile holder\n    float holder = sdBox( p- vec3(3.8, -0.26, -4.70), vec3(0.04, 0.4, 0.8));\n\n    checkPos = p;\n    pR(checkPos.yz, 0.85);\n    holder=max(holder, -sdBox( checkPos- vec3(2.8, -1.8, -3.0), vec3(1.75, 1.4, 1.0))); \n    holder=max(holder, -sdBox( checkPos- vec3(2.8, -5.8, -3.0), vec3(1.75, 1.4, 1.0))); \n    holder =fOpUnionRound(holder, sdBox( p- vec3(3.8, -0.23, -4.70), vec3(1.0, 0.03, 0.5)), 0.1); \n\n    \/\/ bomb\n    bombDist = fCylinder( p- vec3(3.8, -0.8, -4.50), 0.35, 1.);   \n    bombDist =min(bombDist, sdEllipsoid( p- vec3(3.8, -0.8, -3.50), vec3(0.35, 0.35, 1.0)));   \n    bombDist =min(bombDist, sdEllipsoid( p- vec3(3.8, -0.8, -5.50), vec3(0.35, 0.35, 1.0)));   \n\n    \/\/ missiles\n    checkPos = p-vec3(2.9, -0.45, -4.50);\n\n    \/\/ check if any missile has been fired. If so, do NOT mod missile position  \n    float maxMissiles =0.; \n    if (mirrored>0.) maxMissiles =  mix(1.0, 0., step(1., missilesLaunched.x));\n    else maxMissiles =  mix(1.0, 0., step(1., missilesLaunched.y)); \n\n    pModInterval1(checkPos.x, 1.8, .0, maxMissiles);\n    holder = min(holder, MapMissile(checkPos));\n\n    \/\/ ESM Pod\n    holder = min(holder, MapEsmPod(p-vec3(7.2, 0.06, -5.68)));\n\n    \/\/ wheelholder\n    wing=min(wing, sdBox( p- vec3(0.6, -0.25, -3.8), vec3(0.8, 0.4, .50)));\n\n    wing=min(bombDist, min(wing, holder));\n  }\n\n  return wing;\n}\n\nfloat MapRearWing(vec3 p)\n{\n  float wing2 =sdBox( p- vec3(2.50, 0.1, -8.9), vec3(1.5, 0.017, 1.3)); \n  if (wing2<0.15) \/\/Bounding Box test\n  {\n    \/\/ cutouts\n    checkPos = p-vec3(3.0, 0.0, -5.9);\n    pR(checkPos.xz, -0.5);\n    wing2=fOpIntersectionRound(wing2, -sdBox( checkPos, vec3(6.75, 1.4, 2.0)), 0.2); \n\n    checkPos = p-vec3(0.0, 0.0, -4.9);\n    pR(checkPos.xz, -0.5);\n    wing2=fOpIntersectionRound(wing2, -sdBox( checkPos, vec3(3.3, 1.4, 1.70)), 0.2);\n\n    checkPos = p-vec3(3.0, 0.0, -11.70);\n    pR(checkPos.xz, -0.05);\n    wing2=fOpIntersectionRound(wing2, -sdBox( checkPos, vec3(6.75, 1.4, 2.0)), 0.1); \n\n    checkPos = p-vec3(4.30, 0.0, -11.80);\n    pR(checkPos.xz, 1.15);\n    wing2=fOpIntersectionRound(wing2, -sdBox( checkPos, vec3(6.75, 1.4, 2.0)), 0.1);\n  }\n  return wing2;\n} \n\nfloat MapTailFlap(vec3 p, float mirrored)\n{\n  p.z+=0.3;\n  pR(p.xz, rudderAngle*(-1.*mirrored)); \n  p.z-=0.3;\n\n  float tailFlap =sdBox(p- vec3(0., -0.04, -.42), vec3(0.025, .45, .30));\n\n  \/\/ tailFlap front cutout\n  checkPos = p- vec3(0., 0., 1.15);\n  pR(checkPos.yz, 1.32);\n  tailFlap=max(tailFlap, -sdBox( checkPos, vec3(.75, 1.41, 1.6)));\n\n  \/\/ tailFlap rear cutout\n  checkPos = p- vec3(0., 0, -2.75);  \n  pR(checkPos.yz, -0.15);\n  tailFlap=fOpIntersectionRound(tailFlap, -sdBox( checkPos, vec3(.75, 1.4, 2.0)), 0.05);\n\n  checkPos = p- vec3(0., 0., -.65);\n  tailFlap = min(tailFlap, sdEllipsoid( checkPos-vec3(0.00, 0.25, 0), vec3(0.06, 0.05, 0.15)));\n  tailFlap = min(tailFlap, sdEllipsoid( checkPos-vec3(0.00, 0.10, 0), vec3(0.06, 0.05, 0.15)));\n\n  return tailFlap;\n}\n\nfloat MapTopWing(vec3 p, float mirrored)\n{    \n  checkPos = p- vec3(1.15, 1.04, -8.5);\n  pR(checkPos.xy, -0.15);  \n  float topWing = sdBox( checkPos, vec3(0.014, 0.8, 1.2));\n  if (topWing<.15) \/\/Bounding Box test\n  {\n    float flapDist = MapTailFlap(checkPos, mirrored);\n\n    checkPos = p- vec3(1.15, 1.04, -8.5);\n    pR(checkPos.xy, -0.15);  \n    \/\/ top border    \n    topWing = min(topWing, sdBox( checkPos-vec3(0, 0.55, 0), vec3(0.04, 0.1, 1.25)));\n\n    float flapCutout = sdBox(checkPos- vec3(0., -0.04, -1.19), vec3(0.02, .45, 1.0));\n    \/\/ tailFlap front cutout\n    checkPos = p- vec3(1.15, 2., -7.65);\n    pR(checkPos.yz, 1.32);\n    flapCutout=max(flapCutout, -sdBox( checkPos, vec3(.75, 1.41, 1.6)));\n\n    \/\/ make hole for tail flap\n    topWing=max(topWing, -flapCutout);\n\n    \/\/ front cutouts\n    checkPos = p- vec3(1.15, 2., -7.);\n    pR(checkPos.yz, 1.02);\n    topWing=fOpIntersectionRound(topWing, -sdBox( checkPos, vec3(.75, 1.41, 1.6)), 0.05);\n\n    \/\/ rear cutout\n    checkPos = p- vec3(1.15, 1., -11.25);  \n    pR(checkPos.yz, -0.15);\n    topWing=fOpIntersectionRound(topWing, -sdBox( checkPos, vec3(.75, 1.4, 2.0)), 0.05);\n\n    \/\/ top roll \n    topWing=min(topWing, sdCapsule(p- vec3(1.26, 1.8, -8.84), vec3(0, 0, -.50), vec3(0, 0, 0.3), 0.06)); \n\n    topWing = min(topWing, flapDist);\n  }\n  return topWing;\n}\n\nfloat MapPlane( vec3 p)\n{\n  float  d=100000.0;\n  vec3 pOriginal = p;\n  \/\/ rotate position \n  p=TranslatePos(p, pitch, roll);\n  float mirrored=0.;\n  \/\/ AABB TEST  \n  float test = sdBox( p- vec3(0., -0., -3.), vec3(7.5, 4., 10.6));    \n  if (test>1.0) return test;\n\n  \/\/ mirror position at x=0.0. Both sides of the plane are equal.\n  mirrored = pMirror(p.x, 0.0);\n\n  float body= min(d, sdEllipsoid(p-vec3(0., 0.1, -4.40), vec3(0.50, 0.30, 2.)));\n  body=fOpUnionRound(body, sdEllipsoid(p-vec3(0., 0., .50), vec3(0.50, 0.40, 3.25)), 1.);\n  body=min(body, sdConeSection(p- vec3(0., 0., 3.8), 0.1, 0.15, 0.06));   \n\n  body=min(body, sdConeSection(p- vec3(0., 0., 3.8), 0.7, 0.07, 0.01));   \n\n  \/\/ window\n  winDist =sdEllipsoid(p-vec3(0., 0.3, -0.10), vec3(0.45, 0.4, 1.45));\n  winDist =fOpUnionRound(winDist, sdEllipsoid(p-vec3(0., 0.3, 0.60), vec3(0.3, 0.6, .75)), 0.4);\n  winDist = max(winDist, -body);\n  body = min(body, winDist);\n  body=min(body, fOpPipe(winDist, sdBox(p-vec3(0., 0., 1.0), vec3(3.0, 1., .01)), 0.03));\n  body=min(body, fOpPipe(winDist, sdBox(p-vec3(0., 0., .0), vec3(3.0, 1., .01)), 0.03));\n\n  \/\/ front (nose)\n  body=max(body, -max(fCylinder(p-vec3(0, 0, 2.5), .46, 0.04), -fCylinder(p-vec3(0, 0, 2.5), .35, 0.1)));\n  checkPos = p-vec3(0, 0, 2.5);\n  pR(checkPos.yz, 1.57);\n  body=fOpIntersectionRound(body, -sdTorus(checkPos+vec3(0, 0.80, 0), vec2(.6, 0.05)), 0.015);\n  body=fOpIntersectionRound(body, -sdTorus(checkPos+vec3(0, 2.30, 0), vec2(.62, 0.06)), 0.015);\n\n  \/\/ wings       \n  frontWingDist = MapFrontWing(p, mirrored);\n  d=min(d, frontWingDist);   \n  rearWingDist = MapRearWing(p);\n  d=min(d, rearWingDist);\n  topWingDist = MapTopWing(p, mirrored);\n  d=min(d, topWingDist);\n\n  \/\/ bottom\n  checkPos = p-vec3(0., -0.6, -5.0);\n  pR(checkPos.yz, 0.07);  \n  d=fOpUnionRound(d, sdBox(checkPos, vec3(0.5, 0.2, 3.1)), 0.40);\n\n  float holder = sdBox( p- vec3(0., -1.1, -4.30), vec3(0.08, 0.4, 0.8));  \n  checkPos = p;\n  pR(checkPos.yz, 0.85);\n  holder=max(holder, -sdBox( checkPos- vec3(0., -5.64, -2.8), vec3(1.75, 1.4, 1.0))); \n  d=fOpUnionRound(d, holder, 0.25);\n\n  \/\/ large bomb\n  bombDist2 = fCylinder( p- vec3(0., -1.6, -4.0), 0.45, 1.);   \n  bombDist2 =min(bombDist2, sdEllipsoid( p- vec3(0., -1.6, -3.20), vec3(0.45, 0.45, 2.)));   \n  bombDist2 =min(bombDist2, sdEllipsoid( p- vec3(0., -1.6, -4.80), vec3(0.45, 0.45, 2.)));   \n\n  d=min(d, bombDist2);\n\n  d=min(d, sdEllipsoid(p- vec3(1.05, 0.13, -8.4), vec3(0.11, 0.18, 1.0)));    \n\n  checkPos = p- vec3(0, 0.2, -5.0);\n  d=fOpUnionRound(d, fOpIntersectionRound(sdBox( checkPos, vec3(1.2, 0.14, 3.7)), -sdBox( checkPos, vec3(1., 1.14, 4.7)), 0.2), 0.25);\n\n  d=fOpUnionRound(d, sdEllipsoid( p- vec3(0, 0., -4.), vec3(1.21, 0.5, 2.50)), 0.75);\n\n  \/\/ engine cutout\n  blackDist = max(d, fCylinder(p- vec3(.8, -0.15, 0.), 0.5, 2.4)); \n  d=max(d, -fCylinder(p- vec3(.8, -0.15, 0.), 0.45, 2.4)); \n\n  \/\/ engine\n  d =max(d, -sdBox(p-vec3(0., 0, -9.5), vec3(1.5, 0.4, 0.7)));\n\n  engineDist=fCylinder(p- vec3(0.40, -0.1, -8.7), .42, 0.2);\n  checkPos = p- vec3(0.4, -0.1, -8.3);\n  pR(checkPos.yz, 1.57);\n  engineDist=min(engineDist, sdTorus(checkPos, vec2(.25, 0.25)));\n  engineDist=min(engineDist, sdConeSection(p- vec3(0.40, -0.1, -9.2), 0.3, .22, .36));\n\n  checkPos = p-vec3(0., 0., -9.24);  \n  checkPos.xy-=vec2(0.4, -0.1);\n  checkPos.xy = pModPolar(checkPos.xy, 22.0);\n\n  float engineCone = fOpPipe(engineDist, sdBox( checkPos, vec3(.6, 0.001, 0.26)), 0.015);\n  engineDist=min(engineDist, engineCone);\n\n  d=min(d, engineDist);\n  eFlameDist = sdEllipsoid( p- vec3(0.4, -0.1, -9.45-(speed*0.07)+cos(iTime*40.0)*0.014), vec3(.17, 0.17, .10));\n  d=min(d, eFlameDist);\n\n  d=min(d, winDist);\n  d=min(d, body);\n\n  d=min(d, sdBox( p- vec3(1.1, 0., -6.90), vec3(.33, .12, .17))); \n  checkPos = p-vec3(0.65, 0.55, -1.4);\n  pR(checkPos.yz, -0.35);\n  d=min(d, sdBox(checkPos, vec3(0.2, 0.1, 0.45)));\n\n  return min(d, eFlameDist);\n}\n\nRayHit TracePlane(in vec3 origin, in vec3 direction)\n{\n  RayHit result;\n  float maxDist = 150.0;\n  float t = 0.0, dist = 0.0;\n  vec3 rayPos;\n  eFlameDist=10000.0;\n  for ( int i=0; i<RAYSTEPS; i++ )\n  {\n    rayPos =origin+direction*t;\n    dist = MapPlane( rayPos);\n\n    if (abs(dist)<0.003 || t>maxDist )\n    {                \n      result.hit=!(t>maxDist);\n      result.depth = t; \n      result.dist = dist;                              \n      result.hitPos = origin+((direction*t));   \n      result.winDist = winDist;\n      result.engineDist = engineDist;\n      result.eFlameDist = eFlameDist;\n      result.blackDist = blackDist;\n      result.bombDist = bombDist;\n      result.bombDist2 = bombDist2;\n      result.missileDist = missileDist;\n      result.frontWingDist = frontWingDist;\n      result.rearWingDist = rearWingDist;\n      result.topWingDist = topWingDist;\n      break;\n    }\n    t += dist;\n  }\n\n  return result;\n}\n\nfloat MapLights( vec3 p)\n{\n  vec3 pOriginal = p;\n  \/\/ rotate position \n  p=TranslatePos(p, pitch, roll);   \n  \/\/ mirror position at x=0.0. Both sides of the plane are equal.\n  pMirror(p.x, 0.0);\n\n  return max(sdEllipsoid( p- vec3(0.4, -0.1, -9.5), vec3(0.03, 0.03, 0.03+max(0., (speed*0.07)))), -sdBox(p- vec3(0.4, -0.1, -9.6+2.0), vec3(2.0, 2.0, 2.0)));\n}\n\nfloat TraceLights(in vec3 origin, in vec3 direction)\n{\n  float maxDist = 150.0;\n  float t = 0.0;\n  vec3 rayPos;\n  float dist=10000.;\n\n  for ( int i=0; i<10; i++ )\n  {\n    rayPos =origin+direction*t;\n    dist = min(dist, MapLights( rayPos));\n    t += dist;\n  }\n\n  return dist;\n}\n\nvec3 calcNormal( in vec3 pos )\n{    \n  return normalize( vec3(MapPlane(pos+eps.xyy) - MapPlane(pos-eps.xyy), 0.5*2.0*eps.x, MapPlane(pos+eps.yyx) - MapPlane(pos-eps.yyx) ) );\n}\n\nfloat SoftShadow( in vec3 origin, in vec3 direction )\n{\n  float res = 2.0, t = 0.02, h;\n  for ( int i=0; i<24; i++ )\n  {\n    h = MapPlane(origin+direction*t);\n    res = min( res, 7.5*h\/t );\n    t += clamp( h, 0.05, 0.2 );\n    if ( h<0.001 || t>2.5 ) break;\n  }\n  return clamp( res, 0.0, 1.0 );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n  vec3 cu = normalize( cross(cw, cp) );\n  vec3 cv = normalize( cross(cu, cw) );\n  return mat3( cu, cv, cw );\n}\n\n\n\/\/ Advanced lightning pass\nvec3 GetSceneLight(float specLevel, vec3 normal, RayHit rayHit, vec3 rayDir, vec3 origin, float specSize)\n{          \n  float dif = clamp( dot( normal, sunPos ), 0.0, 1.0 );\n  vec3 reflectDir = reflect( rayDir, normal );\n  specLevel*= pow(clamp( dot( reflectDir, sunPos ), 0.0, 1.0 ), 9.0\/specSize);\n  vec3 reflection = vec3(texture(iChannel3, reflectDir ).r*1.5);\n\n  float fre = pow( 1.0-abs(dot( normal, rayDir )), 2.0 );\n  fre = mix( .03, 1.0, fre );   \n  float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );\n\n  vec3 shadowPos = origin+((rayDir*rayHit.depth)*0.998);\n\n  float shadow = SoftShadow(shadowPos, sunPos);\n  dif*=shadow;\n  float skyLight = smoothstep( -0.1, 0.1, reflectDir.y );\n  skyLight *= SoftShadow(shadowPos, reflectDir );\n\n  vec3 lightTot = (vec3(0.2)*amb); \n  lightTot+=vec3(0.85)*dif;\n  lightTot= mix(lightTot, reflection*max(0.3, shadow), fre );\n  lightTot += 1.00*specLevel*dif;\n  lightTot += 0.50*skyLight*vec3(0.40, 0.60, 1.00);\n  lightTot= mix(lightTot*.7, lightTot*1.2, fre );\n\n  fre = pow( 1.0-abs(dot(rayHit.normal, rayDir)), 4.0);\n  fre = mix(0., mix( .1, 1.0, specLevel*0.5), fre );\n  lightTot = mix( lightTot, lightTot+ vec3(1.6), fre );\n\n  return lightTot*sunColor;\n}\n\nfloat drawRect(vec2 p1, vec2 p2, vec2 uv) \n{\n  vec4 rect = vec4(p1, p2);\n  vec2 hv = step(rect.xy, uv) * step(uv, rect.zw);\n  return hv.x * hv.y;\n}\n\n\/\/ Thanks I\u00c3\u00b1igo Quilez!\nfloat line(vec2 p, vec2 a, vec2 b, float size)\n{\n  vec2 pa = -p - a;\n  vec2 ba = b - a;\n  float h = clamp( dot(pa, ba)\/dot(ba, ba), 0.0, 1.0 );\n  float d = length( pa - ba*h );\n\n  return clamp((((1.0+size) - d)-0.99)*100.0, 0.0, 1.0);\n}\n\nvoid AddLetters(vec2 hitPos, inout vec3 col, vec2 linePos)\n{\n  \/\/ text\n  vec3 textColor = vec3(0.2);\n  vec2 absHitPos2 = vec2(hitPos.x-1.05, hitPos.y);\n\n  pModInterval1(absHitPos2.x, 8., linePos.x, linePos.x+10.);\n\n  \/\/ E\n  col =mix(col, textColor, line(absHitPos2, linePos+vec2(1.45, 0.4), linePos+vec2(1.45, .9), 0.06));\n  col =mix(col, textColor, line(absHitPos2, linePos+vec2(1.45, 0.9), linePos+vec2(1.1, .9), 0.06));\n  col =mix(col, textColor, line(absHitPos2, linePos+vec2(1.45, 0.65), linePos+vec2(1.25, 0.65), 0.06));\n  col =mix(col, textColor, line(absHitPos2, linePos+vec2(1.45, 0.4), linePos+vec2(1.1, .4), 0.06));\n  \/\/ F            \n  col =mix(col, textColor, line(absHitPos2, linePos+vec2(0.9, 0.4), linePos+vec2(0.9, .9), 0.06));\n  col =mix(col, textColor, line(absHitPos2, linePos+vec2(0.9, 0.9), linePos+vec2(.65, .9), 0.06));\n  col =mix(col, textColor, line(absHitPos2, linePos+vec2(0.9, 0.65), linePos+vec2(.75, 0.65), 0.06));\n  \/\/ Z\n  col =mix(col, textColor, line(absHitPos2, linePos+vec2(0.45, 0.4), linePos+vec2(.1, 0.9), 0.06));\n  col =mix(col, textColor, line(absHitPos2, linePos+vec2(0.45, 0.9), linePos+vec2(.1, 0.9), 0.06));\n  col =mix(col, textColor, line(absHitPos2, linePos+vec2(0.45, 0.4), linePos+vec2(.1, 0.4), 0.06));\n}\n\n\nvec3 GetReflectionMap(vec3 rayDir, vec3 normal)\n{\n  return texture(iChannel3, reflect( rayDir, normal )).rgb;\n}\n\nvec4 GetMaterial(vec3 rayDir, inout RayHit rayHit, vec2 fragCoord, inout float specSize)\n{\n  vec3 hitPos =TranslatePos(rayHit.hitPos, pitch, roll);\n  vec2 center;\n  float dist;\n\n  float specLevel=0.7;\n  specSize=0.7;\n\n  float fre = pow( 1.0-abs(dot( rayHit.normal, rayDir )), 3.0 );\n  fre = mix( .03, 1.0, fre );   \n\n  \/\/ vec3 tint = vec3(0.62,.50,0.40)*1.15;\n  vec3 tint = vec3(1.62, 1.50, 1.30)*0.65;\n  vec3 brightCamo =1.15*tint;\n  vec3 darkCamo = 0.78*tint;\n\n\n  vec3 baseTexture = mix(brightCamo, darkCamo, smoothstep(0.5, 0.52, noise(hitPos*1.6)));\n\n  \/\/ baseTexture = col;\n  vec3 col=mix(brightCamo, darkCamo, smoothstep(0.5, 0.52, noise(hitPos*1.6)));\n  vec3 reflection = GetReflectionMap(rayDir, rayHit.normal);\n  \/\/ create base color mixes\n  vec3 lightColor = (vec3(1.0));\n  vec3 darkColor = (vec3(0.25));\n  vec3 missilBaseCol =  lightColor*0.5;\n  vec3 missilBaseCol2 =  darkColor;\n  vec3 missilCol = lightColor;\n  vec3 missilCol2 = lightColor*0.27;\n\n  if (distance(rayHit.dist, rayHit.topWingDist)<.01)\n  { \n    \/\/ top wing stripes\n    col=mix(darkColor, baseTexture, smoothstep(0.55, 0.57, distance(0.85, hitPos.y)));\n    col=mix(lightColor, col, smoothstep(.32, 0.34, distance(0.95, hitPos.y)));\n\n    \/\/ create star (top wings)    \n    center = vec2(-8.73, 0.95)-vec2(hitPos.z, hitPos.y);\n    dist = length(center); \n    col=mix(darkColor, col, smoothstep(0.24, 0.26, dist));\n    col=mix(lightColor, col, smoothstep(0.24, 0.26, (dist*1.15)+abs(cos( atan(center.y, center.x)*2.5)*0.13)));\n  } else if (distance(rayHit.dist, rayHit.winDist)<.01)\n  { \n    \/\/ windows\n    col=vec3(0.2, 0.21, 0.22)*reflection;\n    specSize=3.2;\n    specLevel=3.5;\n    fre = pow( 1.0-abs(dot(rayHit.normal, rayDir)), 3.0);\n    fre = mix( mix( .0, .01, specLevel ), mix( .4, 1.0, specLevel ), fre );\n    col = mix(col, vec3(1.5), fre );\n  } else if (distance(rayHit.dist, rayHit.missileDist)<.01)\n  {  \n    specSize=2.;\n    specLevel=2.;\n    \/\/ small missiles\n    col=mix(missilBaseCol, missilCol2, smoothstep(-3.35, -3.37, hitPos.z));\n    col=mix(col, missilCol, smoothstep(-3.2, -3.22, hitPos.z));\n    col=mix(missilCol2, col, smoothstep(.32, 0.34, distance(-4.75, hitPos.z)));\n    col=mix(missilBaseCol, col, smoothstep(.25, 0.27, distance(-4.75, hitPos.z)));\n  } else if (distance(rayHit.dist, rayHit.bombDist)<.01)\n  { \n    specSize=2.;\n    specLevel=1.7;\n    \/\/ small bombs   \n    col=mix(missilCol, missilBaseCol, smoothstep(1.18, 1.2, distance(-4.5, hitPos.z)));      \n    col=mix(col, missilCol2, smoothstep(1.3, 1.32, distance(-4.5, hitPos.z)));\n  } else if (distance(rayHit.dist, rayHit.bombDist2)<.01)\n  {   \n    specSize=2.;\n    specLevel=1.8;\n    \/\/ large bomb  \n    col=mix(missilBaseCol2, missilCol, smoothstep(1.48, 1.5, distance(-4.1, hitPos.z)));      \n    col=mix(col, missilBaseCol, smoothstep(1.6, 1.62, distance(-4.1, hitPos.z)));      \n    col=mix(missilBaseCol, col, smoothstep(0.45, 0.47, distance(-4.1, hitPos.z)));\n  } else\n  {\n    \/\/ remove camo from wing tip\n    col =mix(col, brightCamo, line(vec2(abs(hitPos.x), hitPos.z), vec2(-7.25, 5.), vec2(-1.45, 1.7), 0.3));\n\n    \/\/ color bottom gray\n    col=mix(lightColor*0.7, col, step(0.01, hitPos.y));\n\n    \/\/ front\n    col = mix(col, lightColor, smoothstep(3.0, 3.02, hitPos.z));  \n    col = mix(col, darkColor, smoothstep(3.08, 3.1, hitPos.z));\n    col =mix(col*1.4, col, smoothstep(.07, .09, distance(1.8, hitPos.z)));\n\n\n    \/\/ front wing stripes\n    col=mix(darkColor, col, smoothstep(1.4, 1.42, distance(-6.90, hitPos.z)));\n    col=mix(lightColor, col, smoothstep(1.3, 1.32, distance(-6.90, hitPos.z)));\n    col=mix(darkColor, col, smoothstep(.84, 0.86, distance(-6.7, hitPos.z)));\n    col=mix(lightColor, col, smoothstep(.22, 0.235, distance(-6.94, hitPos.z)));\n\n    \/\/ vertical stripes   \n    float xMod = mod(hitPos.x-0.5, 11.0);\n    col=mix(darkColor, col, smoothstep(0.5, 0.52, distance(5., xMod)));\n    col=mix(lightColor, col, smoothstep(0.4, 0.42, distance(5., xMod)));\n\n\n    \/\/ boxes \n    vec2 absHitPos = abs(hitPos.xz);\n\n    col =mix(col, col*1.40, drawRect(vec2(0.4, 2.0)-0.05, vec2(0.8, 2.0)+0.05+0.25, absHitPos));\n    col =mix(col, col*0.2, drawRect(vec2(0.4, 2.0), vec2(0.8, 2.0)+0.2, absHitPos));\n\n    \/\/ side 17      \n    vec2 linePos = vec2(-0.55, 0.);\n    vec3 textColor = vec3(0.2);\n    if (hitPos.x<0.)\n    {\n      col =mix(col, textColor, line(hitPos.zy, linePos+vec2(0., -0.2), linePos+vec2(0., .2), 0.04));\n      col =mix(col, textColor, line(hitPos.zy, linePos+vec2(-0.2, -0.2), linePos+vec2(-.4, -.2), 0.04));\n      col =mix(col, textColor, line(hitPos.zy, linePos+vec2(-0.4, -0.2), linePos+vec2(-.25, .2), 0.04));\n    } else\n    {\n      col =mix(col, textColor, line(hitPos.zy, linePos+vec2(-0.35, -0.2), linePos+vec2(-0.35, .2), 0.04));\n      col =mix(col, textColor, line(hitPos.zy, linePos+vec2(0.1, -0.2), linePos+vec2(-.15, -.2), 0.04));\n      col =mix(col, textColor, line(hitPos.zy, linePos+vec2(-0.15, 0.2), linePos+vec2(.10, -.2), 0.04));\n    }  \n\n    if (hitPos.y>0.15)\n    {\n      \/\/ letters BoundingBox\n      if (drawRect(vec2(3.2, 3.8)-0.05, vec2(4.9, 4.8), absHitPos)>=1.)\n      {\n        AddLetters(hitPos.xz, col, vec2(-3.70, 3.60));\n      }\n\n      \/\/ more boxes \n      col =mix(col, col*1.40, drawRect(vec2(0.2, 3.6)-0.05, vec2(1., 3.6)+0.05+0.35, absHitPos)); \n      col =mix(col, col*0.2, drawRect(vec2(0.2, 3.6), vec2(1., 3.6)+0.3, absHitPos));          \n      col =mix(col, col*0.2, drawRect(vec2(3.5, 4.8), vec2(4.5, 5.3), absHitPos));\n\n      \/\/ create star (front wings)         \n      center = vec2(5., -5.1)-vec2(xMod, hitPos.z);\n      dist = length(center);\n      col=mix(lightColor, col, smoothstep(0.8, 0.82, dist));\n      col=mix(darkColor, col, smoothstep(0.7, 0.72, dist));\n      col=mix(lightColor, col, smoothstep(0.7, 0.72, (dist*1.15)+abs(cos( atan(center.y, center.x)*2.5)*0.3)));\n      col=mix(darkColor, col, smoothstep(0.6, 0.62, (dist*1.50)+abs(cos( atan(center.y, center.x)*2.5)*0.3)));\n    } else\n    {\n      \/\/ bottom details\n      col =mix(col, darkColor, line(vec2(abs(hitPos.x), hitPos.z), vec2(0., -1.5), vec2(-0.3, -1.5), 0.06));\n      col =mix(col, darkColor, line(vec2(abs(hitPos.x), hitPos.z), vec2(-0.3, -1.5), vec2(-0.3, -1.), 0.085));\n    }\n\n    \/\/ rear wing stripes\n    col=mix(darkColor, col, smoothstep(.55, 0.57, distance(-9.6, hitPos.z)));\n    col=mix(lightColor, col, smoothstep(.5, 0.52, distance(-9.6, hitPos.z)));\n    col=mix(darkColor, col, smoothstep(.4, 0.42, distance(-9.6, hitPos.z)));\n\n    \/\/ esm pods\n    col = mix(col, lightColor*0.75, smoothstep(7.02, 7.04, abs(hitPos.x)));\n\n    \/\/ stabilizer\n    col = mix(col, lightColor*0.75, smoothstep(1.72, 1.74, abs(hitPos.y)));\n\n    \/\/ engines exhaust\n    col=mix(mix(vec3(0.7), reflection, fre), col, step(.05, rayHit.engineDist));\n    specSize=mix(4., specSize, step(.05, rayHit.engineDist));\n    col=mix(col*0.23, col, step(.02, rayHit.blackDist));\n    col=mix(col+0.5, col, smoothstep(.04, 0.10, distance(2.75, hitPos.z)));\n  }\n  fre = pow( 1.0-abs(dot(rayHit.normal, rayDir)), 7.0);\n  fre = mix( 0., mix( .2, 1.0, specLevel*0.5 ), fre );\n  col = mix( col, vec3(1.0, 1.0, 1.1)*1.5, fre );\n\n  return vec4(col, specLevel);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n  vec2 mo = iMouse.xy\/iResolution.xy;\n  vec2 uv = fragCoord.xy \/ iResolution.xy;\n  vec2 screenSpace = (-iResolution.xy + 2.0*(fragCoord))\/iResolution.y;\n  vec2 cloudPos = vec2(-iTime*1.3, -iTime*.95);\n  float CAMZOOM = read(ivec2(52, 0));  \n\n  \/\/ read missile data\n  missilesLaunched = vec2(read(ivec2(100, 0)), read(ivec2(200, 0)));\n\n  \/\/ read roll and speed values from buffer\n  turn = read(ivec2(1, 10));\n  roll = read(ivec2(1, 1));\n  speed = read(ivec2(10, 1));\n  pitch = read(ivec2(15, 1));\n  rudderAngle = read(ivec2(6, 1));\n  sunPos = readRGB(ivec2(50, 0));\n  planePos = readRGB(ivec2(55, 0));\n  pR(sunPos.xz, turn);\n\n  \/\/ setup camera and ray direction\n  vec2 camRot = readRGB(ivec2(57, 0)).xy;\n\n  vec3 rayOrigin = vec3(CAMZOOM*cos(camRot.x), CAMZOOM*sin(camRot.y), -3.+CAMZOOM*sin(camRot.x) );\n  mat3 ca = setCamera( rayOrigin, vec3(0., 0., -3. ), 0.0 );\n  vec3 rayDir = ca * normalize( vec3(screenSpace.xy, 2.0) );\n\n  \/\/ load background from buffer A\n  vec4 color =  texture(iChannel0, uv);\n\n  \/\/ calculate engine flare\n  float lightDist = TraceLights(rayOrigin, rayDir);\n    \n  vec3 lightFlares = vec3(0.);\n  lightFlares =  mix((vec3(1., 0.4, 0.2)), vec3(0.), smoothstep(0., .35, lightDist));             \n  lightFlares =  mix(lightFlares+(2.*vec3(1., 0.5, 0.2)), lightFlares, smoothstep(0., 0.15, lightDist));\n  lightFlares =  mix(lightFlares+vec3(1., 1., 1.), lightFlares, smoothstep(0., 0.08, lightDist));\n  RayHit marchResult = TracePlane(rayOrigin, rayDir);\n\n  if (marchResult.hit)\n  {\n    float specSize=1.0;\n\n    marchResult.normal = calcNormal(marchResult.hitPos); \n\n    \/\/ create texture map and set specular levels\n    color = GetMaterial(rayDir, marchResult, fragCoord, specSize);\n\n    if (marchResult.dist != marchResult.eFlameDist)\n    {\n      \/\/ get lightning based on material\n      vec3 light = GetSceneLight(color.a, marchResult.normal, marchResult, rayDir, rayOrigin, specSize);   \n\n      \/\/ cloud shadows on plane if below cloud level\n      if (planePos.y<=-CLOUDLEVEL)\n      {  \n        \/\/ get cloud shadows at rayMarch hitpos\n        float clouds =clamp(max(0., -0.15+noise(marchResult.hitPos+planePos+vec3(cloudPos.x, 0., cloudPos.y))), 0., 1.)*.5;\n\n        color.rgb*= 1.0-clouds;\n        \/\/ sun light  \n        color.rgb*= 1.+(clouds);\n      }   \n\n      \/\/ apply lightning\n      color.rgb *=light;\n\n      \/\/ balance colors\n      color.rgb = pow(color.rgb, vec3(1.0\/1.1));\n    }\n\n    color.rgb = mix(color.rgb, vec3(0.3, 0.5, 0.7), 0.1);    \n    color.a=1.0;  \n\n    lightFlares = mix(lightFlares, lightFlares*0., step(0.1, distance(marchResult.dist, marchResult.eFlameDist)));\n  }\n\n  color.rgb+=lightFlares;\n  fragColor = color;\n}\n","name":"Buf C","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"MlfcR2","date":"1505470962","viewed":7150,"name":"Lighthouse Raymarch HighRes 1.01","username":"ingagard","description":"Decided to make something a bit more complex this time. Used many types of Mod operations in my raymarch map. Hopefully you will enjoy this shader. Use mouse to interact. \n","likes":61,"published":3,"flags":32,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"Xsf3Rr","filepath":"\/media\/a\/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"\/media\/ap\/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"\/media\/a\/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"\/media\/ap\/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ CREATED BY KIM BERKEBY, SEP 2017 \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ SPECIAL THANKS TO Inigo Quilez  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ Feel free to mail me at mr.kimb@hotmail.com \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define PI 3.14159265\n  #define TAU (2.*PI)\n  #define PHI (sqrt(5.)*0.5 + 0.5)\n  #define M_NONE -1.0\n  #define M_NOISE 1.0\n  #pragma optimize(off) \n  const vec3 sunPos = normalize(vec3(5.3, 2.7, -1.));\nconst vec3 sunColor = vec3(0.80, 0.7, 0.55);         \nconst vec3 eps = vec3(0.02, 0.0, 0.0);\nfloat winDist=100000.0;\nfloat dekoDist=100000.0;\nfloat steelDist=100000.0;\n\nstruct RayHit\n{\n  bool hit;  \n  vec3 hitPos;\n  vec3 normal;\n  float dist;\n  float depth;\n  float steps;\n  float winDist;\n  float dekoDist;\n  float steelDist;\n  float glassDist;\n};\n\n\nfloat hash(float h) \n{\n  return fract(sin(h) * 43758.5453123);\n}\n\nfloat noise(vec3 x) \n{\n  vec3 p = floor(x);\n  vec3 f = fract(x);\n  f = f * f * (3.0 - 2.0 * f);\n\n  float n = p.x + p.y * 157.0 + 113.0 * p.z;\n  return mix(\n    mix(mix(hash(n + 0.0), hash(n + 1.0), f.x), \n    mix(hash(n + 157.0), hash(n + 158.0), f.x), f.y), \n    mix(mix(hash(n + 113.0), hash(n + 114.0), f.x), \n    mix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\n\nfloat fbm(vec3 p) \n{\n  float f = 0.0;\n  f = 0.5000 * noise(p);\n  p *= 2.01;\n  f += 0.2500 * noise(p);\n  p *= 2.02;\n  f += 0.1250 * noise(p);\n  return f;\n}\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x, p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa, ba)\/dot(ba, ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  return (length( p\/r.xyz ) - 1.0) * r.y;\n}\n\nfloat sdConeSection( vec3 p, float h, float r1, float r2 )\n{\n  float d1 = -p.y - h;\n  float q = p.y - h;\n  float si = 0.5*(r1-r2)\/h;\n  float d2 = max( sqrt( dot(p.xz, p.xz)*(1.0-si*si)) + q*si - r2, q );\n  return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.);\n}\n\nfloat fCylinder(vec3 p, float r, float height) {\n  float d = length(p.xy) - r;\n  d = max(d, abs(p.z) - height);\n  return d;\n}\n\nfloat fCylinderH(vec3 p, float r, float height) {\n  float d = length(p.xz) - r;\n  d = max(d, abs(p.y) - height);\n  return d;\n}\n\nfloat fCylinderV(vec3 p, float r, float height) {\n  float d = length(p.yz) - r;\n  d = max(d, abs(p.x) - height);\n  return d;\n}\n\nfloat fOpPipe(float a, float b, float r) {\n  return length(vec2(a, b)) - r;\n}\n\nfloat fOpIntersectionChamfer(float a, float b, float r) {\n  return max(max(a, b), (a + r + b)*sqrt(0.5));\n}\n\nfloat fOpUnionChamfer(float a, float b, float r) {\n  return min(min(a, b), (a - r + b)*sqrt(0.5));\n}\n\nvec2 pModPolar(in vec2 p, float repetitions) {\n  float angle = 2.*PI\/repetitions;\n  float a = atan(p.y, p.x) + angle\/2.;\n  float r = length(p);\n  float c = floor(a\/angle);\n  a = mod(a, angle) - angle\/2.;\n  p = vec2(cos(a), sin(a))*r;\n  if (abs(c) >= (repetitions\/2.)) c = abs(c);\n  return p;\n}\n\nfloat pModSingle1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)\/size);\n  if (p >= 0.)\n    p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)\/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { \/\/yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\n\nfloat SmallWindow( vec3 p)\n{\n  float d= sdBox(p-vec3(-.65, 1.17, 0.0), vec3(0.08, 0.4, 0.4));\n\n  if(d<1.) \/\/ AABB\n  {\n  d= max(d, -sdBox(p-vec3(-.06, 1.17, 0.0), vec3(0.54, 0.36, .36))); \n  d= max(d, -sdBox(p-vec3(-.22, 1.17, 0.0), vec3(0.54, 0.32, .32))); \n  d= min(d, sdBox(p-vec3(-0.58, 1.65, 0.), vec3(0.165, 0.04, 0.5)));\n  steelDist= min(steelDist, sdBox(p-vec3(-.64, 1.17, 0.0), vec3(0.02, 0.30, 0.02))); \n  vec3 winPos = p-vec3(-.64, 1.10, 0.0);\n  pModInterval1(winPos.y,0.25,0.,1.0);\n  steelDist= min(steelDist, sdBox(winPos, vec3(0.01, 0.02, 0.38))); \n  d= min(d, sdBox(p-vec3(-.59, .71, 0.), vec3(0.13, 0.05, 0.45)));\n  d= min(d, sdBox(p-vec3(-.59, 0.69, 0.), vec3(0.18, 0.025, 0.50)));\n\n  \/\/ lower decoration \n  d= min(d, sdBox(p-vec3(-0.70, .49, 0.), vec3(0.25, 0.2, 0.07)));   \n  d = fOpIntersectionChamfer(d, -fCylinder(p-vec3(-0.32, .25, 0.), 0.23, 1.63), 0.03);\n  }\n  return d;\n}\n\n\nfloat Window( vec3 p)\n{\n  float d= sdBox(p-vec3(-0.58, 1.17, 0.), vec3(0.075, 0.7, 0.4));\n\n    if(d<2.0)\n    {\n  d = max(d, -sdBox(p-vec3(-0.28, 1.17, 0.), vec3(0.25, 0.67, 0.37)));\n  d= fOpIntersectionChamfer(d, -sdBox(p-vec3(-0.21, 1.17, 0.), vec3(1.3, 0.55, 0.22)), 0.09); \n  d= min(d, sdBox(p-vec3(-0.58, 1.7, 0.), vec3(0.325, 0.06, 0.48)));\n\n  steelDist= min(steelDist, sdBox(p-vec3(-0.55, 1.17, 0.), vec3(0.01, 0.60, 0.02))); \n \n  vec3 winPos = p-vec3(-0.55, 0.80, 0.);\n  pModInterval1(winPos.y,0.30,0.,2.0);        \n  steelDist= min(steelDist, sdBox(winPos, vec3(0.01, 0.02, 0.4))); \n\n  d=min(d, max(max(fCylinderV(p-vec3(-0.5, 1.74, 0.), 0.42, 0.13), -sdBox(p-vec3(-0.5, 1.49, 0.), vec3(1., 0.27, 1.5))), -fCylinderV(p-vec3(-0.5, 1.74, 0.), 0.38, 0.53)));\n\n  d= min(d, sdBox(p-vec3(-.52, .42, 0.), vec3(0.13, 0.05, 0.45)));\n  d= min(d, sdBox(p-vec3(-.52, 0.40, 0.), vec3(0.18, 0.025, 0.50)));\n\n  \/\/ lower decoration \n  d= min(d, sdBox(p-vec3(-0.55, .20, 0.4), vec3(0.15, 0.2, 0.05)));   \n  d= min(d, sdBox(p-vec3(-0.55, .20, -0.4), vec3(0.15, 0.2, 0.05)));\n  d = fOpIntersectionChamfer(d, -fCylinder(p-vec3(-0.3, .0, 0.), 0.23, 1.63), 0.02);\n\n  \/\/ upper decoration \n  dekoDist=min(dekoDist, sdBox(p-vec3(-0.55, 2.63, 0.), vec3(0.3, 0.45, 0.12)));    \n  dekoDist = fOpIntersectionChamfer(dekoDist, -fCylinder(p-vec3(-0.22, 2.45, -0.1), 0.21, 0.63), 0.03);\n    }\n  return d;\n}\n\n\nfloat MapStreeLight(  vec3 p)\n{\n  float d= fCylinder(p-vec3(0.31, -3.5, 0.), 0.7, 0.01);\n  d=fOpPipe(d, fCylinder(p-vec3(.31, -4., 0.), 0.7, 3.0), .05);   \n  d=min(d, fCylinderH(p-vec3(.98, -6.14, 0.), 0.05, 2.4));        \n  d=fOpUnionChamfer(d, fCylinderH(p-vec3(.98, -8., 0.), 0.1, 1.0), 0.12);  \n  d=min(d, sdSphere(p-vec3(-0.05, -3.4, 0.), 0.2));  \n  d=min(d, sdSphere(p-vec3(-0.05, -3.75, 0.), 0.4));        \n  d=max(d, -sdSphere(p-vec3(-.05, -3.9, 0.), 0.45)); \n\n  return d;\n}\n\nfloat MapGlass(  vec3 p)\n{  \n  vec3 checkPos = p;\n\n  float dist = sdCappedCylinder(p-vec3(0.0, 5.0, 0), vec2(1.02, .8));\n  checkPos.xz = pModPolar(p.xz, 6.0);\n  dist = min(dist, sdBox(checkPos-vec3(1.60, 1.1, 0.), vec3(0.01, .60, 0.35)));   \n  checkPos.xz = pModPolar(p.xz, 5.0);\n  dist = min(dist, sdBox(checkPos-vec3(1.84, -3.33, 0.), vec3(0.01, 0.30, .3))); \n  return min(dist, sdBox(checkPos-vec3(2.12, -6.83, 0.), vec3(0.01, 0.30, .3)));\n}\n\n\n#define radius 1.6\n#define outRad 1.82\n#define inRad 1.12\nvec3 checkPos;\n\nfloat Map(  vec3 p)\n{\n  float  d=100000.0;\n  checkPos = p;\n  winDist=dekoDist=steelDist=100000.0;\n\n  d=sdCappedCylinder(p-vec3(0.0, -3.0, 0), vec2(4.0, 12.45));\n  if(d<1.0)\n  {\n  \n  d = sdCappedCylinder(p-vec3(0.0, 3.7, 0), vec2(inRad, .45));\n  d=min(d, sdSphere(p-vec3(0., 4., 0), 0.50));\n  d=min(d, fCylinderH(p-vec3(0.0, 1.3, 0), radius, 1.80));\n  d=min(d, sdConeSection(p-vec3(0.0, -6.0, 0.), 5.3, 2.4, 1.7));\n  d=min(d, sdConeSection(p-vec3(0.0, -13.0, 0.), 1.8, 2.8, 2.6));\n\n  \/\/ lamp\n  d=min(d, sdSphere(p-vec3(0., 4.9, 0), 0.3));\n  d=min(d, sdCappedCylinder(p-vec3(0.0, 4.5, 0), vec2(0.12, 1.2)));\n\n  dekoDist=min(dekoDist, sdTorus(p-vec3(0.0, 5.8, 0), vec2(inRad, .15)));                  \n  dekoDist =min(dekoDist, sdTorus(p-vec3(0.0, 4., 0), vec2(inRad, .11)));\n  dekoDist=min(dekoDist, sdTorus(p-vec3(0.0, -.35, 0), vec2(radius-0.05, .15)));\n  dekoDist=min(dekoDist, fCylinderH(p-vec3(0.0, -.5, 0), radius+0.02, .15));\n  dekoDist=min(dekoDist, sdTorus(p-vec3(0.0, -0.6, 0), vec2(radius+0.15, .15)));\n  dekoDist=min(dekoDist, sdTorus(p-vec3(0.0, -1.65, 0), vec2(radius+0.08, .15))); \n  dekoDist=min(dekoDist, fCylinderH(p-vec3(0.0, 3.18, 0), radius+0.35, 0.15));  \n  dekoDist=min(dekoDist, fCylinderH(p-vec3(0.0, 2.7, 0), radius+0.14, .30));\n  dekoDist=min(dekoDist, fCylinderH(p-vec3(0.0, 2.85, 0), radius+0.18, .18));\n  dekoDist=min(dekoDist, fCylinderH(p-vec3(0.0, 3.1, 0), radius+0.22, .18));\n  dekoDist=min(dekoDist, sdTorus(p-vec3(0.0, -9., 0), vec2(radius+0.6, .25))); \n  dekoDist=min(dekoDist, sdTorus(p-vec3(0.0, -11.30, 0.), vec2(2.42, 0.25)));     \n\n  \/\/ lower border\n  dekoDist=min(dekoDist, sdTorus(p-vec3(0.0, -2.35, 0), vec2(radius+0.25, .15)));\n\n  \/\/ deko and windows steel top\n  checkPos.xz = pModPolar(p.xz, 12.0);\n  steelDist=min(steelDist, sdCappedCylinder(checkPos-vec3(outRad+0.05, 3.6, 0), vec2(0.03, .42)));\n  steelDist=min(steelDist, sdCapsule(checkPos-vec3(inRad-0.06, 4.2, 0), vec3(0, 0., 0), vec3(0, 1.45, 0), 0.02));\n  steelDist=min(steelDist, sdBox(checkPos-vec3(inRad-0.19, 6.25, 0), vec3(0.25, .3, 0.25)));\n  steelDist=fOpIntersectionChamfer(steelDist, -sdBox(checkPos-vec3(inRad+0.20, 6.25, 0), vec3(0.19, 0.24, 0.19)), 0.12);\n\n  \/\/ top\n  dekoDist=min(dekoDist, sdCappedCylinder(p-vec3(0.0, 6.2, 0), vec2(inRad, .45)));\n  dekoDist=min(dekoDist, sdSphere(p-vec3(0., 6.5, 0), 1.10));\n  steelDist=min(steelDist, sdCappedCylinder(p-vec3(0.0, 7.5, 0), vec2(0.5, .45)));\n  steelDist=min(steelDist, sdSphere(p-vec3(0., 7.9, 0), 0.45));\n  steelDist=min(steelDist, sdSphere(p-vec3(0., 8.4, 0), 0.10));   \n     \n  vec3 pp = p-vec3(0.0, 4.4, 0);\n  pModInterval1(pp.y,0.4,0.0,2.);          \n  steelDist=min(steelDist, sdTorus(pp, vec2(inRad-0.02, .02)));\n      \n  pp = p-vec3(0.0, 3.55, 0);\n  pModInterval1(pp.y,0.15,0.0,3.);          \n  steelDist=min(steelDist, sdTorus(pp, vec2(outRad+0.05, .025)));\n\n  \/\/ upper decoration\n  checkPos.xz = pModPolar(p.xz, 6.0);\n  dekoDist = max(dekoDist, -fCylinderV(checkPos-vec3(0.0, 2.4, 0), 0.6, 2.63));\n\n  \/\/ windows cutouts   \n  checkPos.xz = pModPolar(p.xz, 6.0);   \n  d=max(d, -sdBox(checkPos-vec3(2.20, 1.17, 0.), vec3(3.25, 0.7, 0.4))); \n  checkPos.xz = pModPolar(p.xz, 5.0); \n  pp = checkPos-vec3(2.50, -6.83, 0.);\n  pModInterval1(pp.y,3.5,0.0,1.);         \n  d= max(d, -sdBox(pp, vec3(1.3, 0.35, 0.35)));  \n\n  \/\/ upper windows   \n  checkPos.xz = pModPolar(p.xz, 6.0);   \n  winDist = min(winDist, Window(checkPos-vec3(2.20, 0, 0.))); \n\n  \/\/ middle windows (upper deco)\n  checkPos.xz = pModPolar(p.xz, 5.0); \n  dekoDist=min(dekoDist, sdBox(checkPos-vec3(2.10, -2.44, 0.0), vec3(0.3, 0.4, 0.12)));   \n  dekoDist = fOpIntersectionChamfer(dekoDist, -fCylinder(checkPos-vec3(2.40, -2.04, 0.0), 0.21, 0.63), .03); \n  dekoDist = max(dekoDist, -fCylinder(checkPos-vec3(2.50, -2.62, 0.0), 0.51, 0.63));\n  \n  \/\/ middle and lower windows      \n   pp = checkPos-vec3(2.78, -8.0, 0.);\n  float m=pModInterval1(pp.y, 3.5,0.,1.);\n  winDist = min(winDist, SmallWindow(pp+mix(vec3(0.),vec3(0.28,0.0, 0.),m)));   \n\n  \/\/ make tower hollow\n  d=max(d, -sdConeSection(p-vec3(0.0, -6.0, 0.), 5., 2.3, 1.55));\n\n  dekoDist=min(dekoDist, sdTorus(p-vec3(0.0, -15.2, 0), vec2(2.5, .75))); \n  dekoDist=min(dekoDist, sdBox(p-vec3(-0., -14.3, 2.5), vec3(0.7, 1.4, 0.4)));    \n  dekoDist=min(dekoDist, fCylinder(p-vec3(-0., -13., 2.5), 0.7, 0.4)); \n\n  \/\/ create door opening    \n  float doorOpening = min(sdBox(p-vec3(-0., -14.3, 2.5), vec3(0.6, 1.3, 4.6)), fCylinder(p-vec3(-0., -13., 2.5), 0.6, 4.6));\n\n  dekoDist = min(fOpPipe(dekoDist, doorOpening, 0.13), max(dekoDist, -doorOpening));\n\n  checkPos.xz = pModPolar(p.xz, 8.0);\n  d=fOpIntersectionChamfer(d, -fCylinderH(checkPos-vec3(2.95, -15.4, 0), 0.2, 3.6), 0.5);    \n  checkPos.xz = pModPolar(p.xz, 16.0);\n  d=fOpUnionChamfer(d, fCylinderH(checkPos-vec3(2.2, -10.3, 0), 0.03, 0.8), 0.4);    \n\n  d=max(d, -sdBox(p-vec3(-0., -14.3, 2.7), vec3(0.6, 1.3, 4.6)));    \n  d=max(d, -fCylinder(p-vec3(-0., -13., 2.5), 0.6, 4.6));    \n\n  \/\/ door   \n  d=min(d, sdBox(p-vec3(-0., -13.6, 2.0), vec3(0.6, 1.3, 0.4))); \n    \n  \/\/ door cutout     \n  pp = p-vec3(-0.28, -13.3, 2.4);\n  pModInterval1(pp.x, 0.56,0.,1.);     \n  d=max(d, -sdBox(pp, vec3(0.25, 0.25, 0.08)));   \n  pp = p-vec3(-0.28, -14.1, 2.4);\n  pModInterval1(pp.x, 0.56,0.,1.);     \n  d=max(d, -sdBox(pp, vec3(0.25, 0.4, 0.08))); \n\n  dekoDist=max(dekoDist, -sdBox(p-vec3(-0., -16.2, 0), vec3(6.6, 1.3, 8.6)));  \n  }\n    \n  \n  \/\/ railing (platform) \n  checkPos.xz = pModPolar(p.xz, 32.0);   \n  steelDist=min(steelDist, sdCappedCylinder(checkPos-vec3(radius+8., -14.4, 0), vec2(0.05, .46)));   \n  steelDist=min(steelDist, sdTorus(p-vec3(0., -14.2, 0), vec2(radius+8., 0.02)));\n  steelDist=min(steelDist, sdTorus(p-vec3(0., -14.35, 0), vec2(radius+8., 0.02)));\n  steelDist=min(steelDist, sdTorus(p-vec3(0., -13.9, 0), vec2(radius+8., 0.04)));\n  checkPos.xz = pModPolar(p.xz, 7.0); \n  steelDist = min(steelDist, MapStreeLight(checkPos-vec3(radius+6.7, -6.63, 0)));  \n  steelDist=max(steelDist, -sdBox(p-vec3(13.3, 0., 0.), vec3(6.6, 22.5, 3.7)));   \n  steelDist=max(steelDist, -sdBox(p-vec3(0.0, -16.05, 0), vec3(16.6, 1.2, 16.6)));  \n    \n  return  min(d, min(steelDist, min(dekoDist, winDist)));\n}\n\n\nvec3 calcNormal(  vec3 pos )\n{    \n  return normalize( vec3(Map(pos+eps.xyy) - Map(pos-eps.xyy), 0.5*2.0*eps.x, Map(pos+eps.yyx) - Map(pos-eps.yyx) ) );\n}\n\nvec3 calcNoiseNormal(  vec3 pos )\n{    \n  return normalize( vec3(fbm(pos+eps.xyy) - fbm(pos-eps.xyy), 0.5*2.0*eps.x, fbm(pos+eps.yyx) - fbm(pos-eps.yyx) ) );\n}\n\nfloat SoftShadow(  vec3 origin,  vec3 direction )\n{\n  float res = 2.0, t = 0.0, h;\n  for ( int i=0; i<32; i++ )\n  {\n    h = Map(origin+direction*t);\n    res = min( res, 6.5*h\/t );\n    t += clamp( h, 0.07, 0.6 );\n    if ( h<0.0025 ) break;\n  }\n  return clamp( res, 0.0, 1.0 );\n}\n\n\n\nRayHit March( vec3 origin,  vec3 direction)\n{\n  RayHit result;\n  float maxDist = 70.0;\n  float t = 0.0, glassDist = 10000.0, dist = 0.0;\n  vec3 rayPos;\n\n  for ( int i=0; i<200; i++ )\n  {\n    rayPos =origin+direction*t;\n    dist = Map( rayPos);\n    glassDist=min(glassDist, MapGlass( rayPos));\n\n    if (abs(dist)<0.001 || t>maxDist )\n    {             \n      result.hit=!(t>maxDist);\n      result.depth = t; \n      result.dist = dist;                              \n      result.hitPos = origin+((direction*t));   \n      result.steps = float(i);\n      result.winDist = winDist;\n      result.glassDist = glassDist;\n      result.dekoDist = dekoDist;\n      result.steelDist = steelDist;\n      break;\n    }\n    t += dist;\n  }    \n   \n\n  return result;\n}\n\/\/ Copyright \u00a9 2015 Inigo Quilez\nvec3 CubeMap( sampler2D sam, in vec3 d )\n{\n    vec3 n = abs(d);\n\n#if 0\n    \/\/ sort components (small to big)    \n    float mi = min(min(n.x,n.y),n.z);\n    float ma = max(max(n.x,n.y),n.z);\n    vec3 o = vec3( mi, n.x+n.y+n.z-mi-ma, ma );\n    return texture( sam, .1*o.xy\/o.z ).xyz;\n#else\n    vec2 uv = (n.x>n.y && n.x>n.z) ? d.yz\/d.x: \n              (n.y>n.x && n.y>n.z) ? d.zx\/d.y:\n                                     d.xy\/d.z;\n    return texture( sam, uv ).xyz;\n    \n#endif    \n}\n\nmat3 setCamera( vec3 ro,  vec3 ta, float cr )\n{\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n  vec3 cu = normalize( cross(cw, cp) );\n  vec3 cv = normalize( cross(cu, cw) );\n  return mat3( cu, cv, cw );\n}\n\n\/\/ Copyright \u00a9 2013 Inigo Quilez\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n  float occ = 0.0;\n  float sca = 1.0;\n  for ( int i=0; i<5; i++ )\n  {\n    float hr = 0.01 + 0.12*float(i)\/4.0;\n    vec3 aopos =  nor * hr + pos;\n    float dd = Map( aopos );\n    occ += -(dd-hr)*sca;\n    sca *= 0.95;\n  }\n  return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\n\nvec3 GetSceneLight(float specLevel, vec3 normal, RayHit rayHit, vec3 rayDir, vec3 origin)\n{        \n  vec3 reflectDir = reflect( rayDir, normal );\n\n  float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );\n  float dif = clamp( dot( normal, sunPos ), 0.0, 1.0 );\n  float bac = clamp( dot( normal, normalize(vec3(-sunPos.x, 0.0, -sunPos.z))), 0.0, 1.0 )*clamp( 1.0-rayHit.hitPos.y, 0.0, 1.0);\n  float fre = pow( clamp(1.0+dot(normal, rayDir), 0.0, 1.0), 2.0 );\n  specLevel*= pow(clamp( dot( reflectDir, sunPos ), 0.0, 1.0 ), 16.0);\n\n  float skylight = smoothstep( -0.1, 0.1, reflectDir.y );\n  vec3 shadowPos = origin+((rayDir*rayHit.depth)*0.99);  \n  dif *= SoftShadow( shadowPos, sunPos);\n  skylight *=SoftShadow(shadowPos, reflectDir);\n\n  vec3 lightTot = vec3(0.0);\n\n    \n    \n  lightTot += 1.30*dif*vec3(1.00, 0.80, 0.55);\n  lightTot += 0.50*skylight*vec3(0.40, 0.60, 1.00);\n      lightTot += 1.20*specLevel*vec3(0.9, 0.8, 0.7)*dif;\n  lightTot += 0.50*bac*vec3(0.25, 0.25, 0.25);\n  lightTot += 0.25*fre*vec3(1.00, 1.00, 1.00);\n  return lightTot +(0.40*amb*vec3(0.40, 0.60, 1.00));\n}\n\n\n\n\nvec4 GetMaterial( vec3 rayDir, inout RayHit rayHit)\n{\n  vec3 col = vec3(0.6);\n  float specLevel=1.30;\n\n  \/\/ windows\n  if (rayHit.winDist==rayHit.dist)\n  {\n    vec3 dirt =  CubeMap(iChannel3, rayHit.hitPos*.1).rgb*0.8; \n    col = vec3(0.9);\n    col = mix(col, dirt, fbm(rayHit.hitPos*1.71)); \n    specLevel = 0.4;\n  } \n  \/\/ decorations\n  else if (rayHit.dekoDist==rayHit.dist)\n  {    \n    col=vec3(0.6);\n    vec3 moss =  CubeMap(iChannel3, rayHit.hitPos*0.22).rgb*vec3(0.356, 0.455, 0.228);\n    vec3 dirt =  CubeMap(iChannel3, (rayHit.hitPos*.44)).rgb*1.5; \n    col = mix(col, dirt*0.7, fbm(rayHit.hitPos*10.71)); \n    col = mix(col, moss, pow(fbm(rayHit.hitPos*0.71), 1.5)); \n    col = mix(col, moss, smoothstep(0.55+fbm(rayHit.hitPos*0.51), -.4, rayHit.winDist));\n    rayHit.normal = mix(rayHit.normal, (rayHit.normal+calcNoiseNormal(rayHit.hitPos*10.9))*0.5, 0.25);\n    specLevel = 2.3;\n  } \n  \/\/ steel \n  else if (rayHit.steelDist==rayHit.dist)\n  {\n    vec3 dirt =  CubeMap(iChannel3, (rayHit.hitPos*.44)).rgb*1.5; \n    col = vec3(0.3+(fbm(rayHit.hitPos*1.71)*.5));\n    col = mix(col, dirt*0.7, fbm(rayHit.hitPos*10.71));         \n    specLevel = 6.0;\n  } \n  \/\/ tower base texture\n  else\n  {\n    vec3 moss =  texture(iChannel3, vec2(atan(rayHit.hitPos.z,rayHit.hitPos.x)*2.0, rayHit.hitPos.y)*0.22).rgb*vec3(0.356, 0.455, 0.228);\n    vec3 dirt =  texture(iChannel3, vec2(atan(rayHit.hitPos.z,rayHit.hitPos.x)*2.0, rayHit.hitPos.y)*.44).rgb*1.5; \n    \/\/ top part\n    if (rayHit.hitPos.y>-11.1)\n    {     \n      col=vec3(0.9);\n      col = mix(col, dirt*0.7, fbm(rayHit.hitPos*.71)); \n      col = mix(col, moss, smoothstep(-9., -11.01, rayHit.hitPos.y+fbm(rayHit.hitPos*3.71)));  \n      col = mix(col, dirt, smoothstep(2.1+fbm(rayHit.hitPos*0.71), -.40, pow(rayHit.dekoDist, 3.00)));   \n      col = mix(col, dirt, smoothstep(1.1+fbm(rayHit.hitPos*0.51), -.4, pow(rayHit.winDist, 2.50)));\n      col = mix(dirt, col, smoothstep(2.0, 1.3, rayHit.hitPos.y+fbm(rayHit.hitPos*3.71)));  \n      rayHit.normal = mix(rayHit.normal, (rayHit.normal+calcNoiseNormal(rayHit.hitPos*10.))*0.5, 0.15);\n    } \n    \/\/ lower part\n    else\n    {\n      vec3 tex2 =  texture(iChannel3, vec2(atan(rayHit.hitPos.z,rayHit.hitPos.x)*2.0, rayHit.hitPos.y)*0.8).rgb;\n      col=mix(moss, tex2, 0.5);\n      col = mix(col, dirt*0.7, fbm(rayHit.hitPos*.21));\n      col = mix(moss, col, smoothstep(-10., -12.01, rayHit.hitPos.y+fbm(rayHit.hitPos*3.71)));\n      col = mix(col, moss, smoothstep(-13., -15.01, rayHit.hitPos.y+fbm(rayHit.hitPos*3.71))); \n      rayHit.normal = mix(rayHit.normal, (rayHit.normal+calcNoiseNormal(rayHit.hitPos*8.))*0.5, 0.15);\n    }\n  }\n\n  return vec4(col, specLevel);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{  \n  vec2 mo = iMouse.xy\/iResolution.xy;\n  vec2 uv = fragCoord.xy \/ iResolution.xy;\n  vec2 screenSpace = (-iResolution.xy + 2.0*(fragCoord))\/iResolution.y;\n\n  float camrot = 20.0+(iTime*0.2);\n  if (iMouse.w>0.1) camrot+=mo.x*16.; \n\n  vec3 rayOrigin = vec3(8.*cos(camrot), 1.+12.*sin(camrot*1.8), 13.5 + 24.0*sin(camrot) );\n  mat3 ca = setCamera( rayOrigin, vec3(0., -6., 0.5 ), 0.0 );\n  vec3 rayDir = ca * normalize( vec3(screenSpace.xy, 2.0) );\n\n  vec3 skyColor = texture(iChannel0, uv).rgb;\n  vec3 color = skyColor;\n\n  RayHit marchResult = March(rayOrigin, rayDir);\n\n  if (marchResult.hit)\n  {\n    marchResult.normal = calcNormal(marchResult.hitPos);  \n    vec4 col = GetMaterial(rayDir, marchResult);\n\n    \/\/ get lightning based on material\n    vec3 light = GetSceneLight(col.a, marchResult.normal, marchResult, rayDir, rayOrigin);   \n    \/\/ apply lightning\n    color = col.rgb*light;\n  }\n\n    color = mix(mix(color, skyColor, 0.5),color,step(0.05,marchResult.glassDist));\n  \n\n  color = mix(color, skyColor, smoothstep(40., 140., marchResult.depth));  \n\n  float sun = clamp( dot(sunPos, rayDir), 0.0, 1.0 );  \n  color += vec3(.9, 0.4, 0.2)*sun*sun*clamp((rayDir.y+0.4)\/0.4, 0.0, 0.4);\n\n  fragColor = vec4(pow(color.rgb, vec3(1.0\/1.1)), 1.0 ) * (0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.2 ));\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"\/media\/a\/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"\/media\/ap\/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"\/media\/a\/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"\/media\/ap\/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"\/media\/a\/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"\/media\/ap\/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ CREATED BY KIM BERKEBY, SEP 2017 \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ SPECIAL THANKS TO Inigo Quilez  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ Feel free to mail me at mr.kimb@hotmail.com \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n#define WATER_LOD 0.27\n#define PI 3.14159265\n  #define TAU (2.*PI)\n  #define PHI (sqrt(5.)*0.5 + 0.5)\n  #define M_NONE -1.0\n  #define M_NOISE 1.0\n  #pragma optimize(off) \n  const vec3 sunPos = normalize(vec3(5.3, 2.7, -1.));\nconst vec3 sunColor = vec3(0.80, 0.7, 0.55);         \nconst vec3 eps = vec3(0.02, 0.0, 0.0);\nfloat steelDist=100000.0;\nfloat terrainDist=100000.0;\nfloat platformDist=100000.0;\nfloat waterDist=100000.0;\n\nstruct RayHit\n{\n  bool hit;  \n  vec3 hitPos;\n  vec3 normal;\n  float dist;\n  float depth;\n  float steelDist;\n  float terrainDist;\n  float platformDist;\n  float waterDist;\n};\n\nfloat hash(float h) \n{\n  return fract(sin(h) * 43758.5453123);\n}\n\nfloat noise(vec3 x) \n{\n  vec3 p = floor(x);\n  vec3 f = fract(x);\n  f = f * f * (3.0 - 2.0 * f);\n\n  float n = p.x + p.y * 157.0 + 113.0 * p.z;\n  return mix(\n    mix(mix(hash(n + 0.0), hash(n + 1.0), f.x), \n    mix(hash(n + 157.0), hash(n + 158.0), f.x), f.y), \n    mix(mix(hash(n + 113.0), hash(n + 114.0), f.x), \n    mix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\nfloat noise2D( in vec2 pos , float lod)\n{\n  vec2 f = fract(pos);\n  f = f*f*(3.0-2.0*f);\n  vec2 rg = textureLod( iChannel1, (((floor(pos).xy+vec2(37.0, 17.0)) + f.xy)+ 0.5)\/256.0, lod).yx;  \n  return -1.0+2.0*mix( rg.x, rg.y, 0.5 );\n}\nfloat noise2D( in vec2 pos )\n{\nreturn noise2D(pos,0.0);\n}\n\nvec3 calcWaterNormal( vec2 pos, float res )\n{   \n  return normalize(vec3(noise2D((pos + vec2(-0.001, 0))* res,WATER_LOD)-noise2D((pos + vec2(+0.001, 0))* res,WATER_LOD), noise2D((pos + vec2(0, -0.001))*res,WATER_LOD)-noise2D((pos + vec2(0, +0.001))* res,WATER_LOD), .005)) * 0.5 + 0.5;\n}\n\nfloat fbm(vec3 p) \n{\n  float f = 0.0;\n  f = 0.5000 * noise(p);\n  p *= 2.01;\n  f += 0.2500 * noise(p);\n  p *= 2.02;\n  f += 0.1250 * noise(p);\n  return f;\n}\n\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x, p.y);\n  return length(q)-t.y;\n}\n\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdConeSection( vec3 p, float h, float r1, float r2 )\n{\n  float d1 = -p.y - h;\n  float q = p.y - h;\n  float si = 0.5*(r1-r2)\/h;\n  float d2 = max( sqrt( dot(p.xz, p.xz)*(1.0-si*si)) + q*si - r2, q );\n  return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.);\n}\n\nfloat fCylinder(vec3 p, float r, float height) {\n  float d = length(p.xy) - r;\n  d = max(d, abs(p.z) - height);\n  return d;\n}\n\nfloat fCylinderH(vec3 p, float r, float height) {\n  float d = length(p.xz) - r;\n  d = max(d, abs(p.y) - height);\n  return d;\n}\n\nfloat fCylinderV(vec3 p, float r, float height) {\n  float d = length(p.yz) - r;\n  d = max(d, abs(p.x) - height);\n  return d;\n}\n\nfloat fHexagonCircumcircle(vec3 p, vec2 h) {\n  vec3 q = abs(p);\n  return max(q.y - h.y, max(q.x*sqrt(3.)*0.5 + q.z*0.5, q.z) - h.x);\n}\n\nfloat fOpPipe(float a, float b, float r) {\n  return length(vec2(a, b)) - r;\n}\n\nfloat fOpIntersectionChamfer(float a, float b, float r) {\n  return max(max(a, b), (a + r + b)*sqrt(0.5));\n}\n\nfloat fOpUnionChamfer(float a, float b, float r) {\n  return min(min(a, b), (a - r + b)*sqrt(0.5));\n}\n\nvec2 pModPolar(vec2 p, float repetitions) {\n  float angle = 2.*PI\/repetitions;\n  float a = atan(p.y, p.x) + angle\/2.;\n  float r = length(p);\n  float c = floor(a\/angle);\n  a = mod(a, angle) - angle\/2.;\n  p = vec2(cos(a), sin(a))*r;\n  if (abs(c) >= (repetitions\/2.)) c = abs(c);\n  return p;\n}\n\nfloat pModSingle1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)\/size);\n  if (p >= 0.)\n    p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\n\nfloat MapTerrain( vec3 p)\n{\n  return   p.y+18.5-mix(\n    (textureLod(iChannel0, p.xz*0.001, 0.0).r*1.2) + \n    (textureLod(iChannel0, p.xz*0.01, 0.0).r*.7) + \n    (textureLod(iChannel0, p.xz*0.075, 0.0).r*0.91), \n    0., smoothstep(8.0, 18.0, min(distance(p, vec3(0.0, -17.3, 0.)), distance(p, vec3(10.5, -17.3, 2.))*3.5)));\n}\n\nfloat MapStreeLight(vec3 p)\n{\n  float d= fCylinder(p-vec3(0.31, -3.5, 0.), 0.7, 0.01);\n  d=fOpPipe(d, fCylinder(p-vec3(.31, -4., 0.), 0.7, 3.0), .05);   \n  d=min(d, fCylinderH(p-vec3(.98, -6.14, 0.), 0.05, 2.4));        \n  d=fOpUnionChamfer(d, fCylinderH(p-vec3(.98, -8., 0.), 0.1, 1.0), 0.12);  \n  d=min(d, sdSphere(p-vec3(-0.05, -3.4, 0.), 0.2));  \n  d=min(d, sdSphere(p-vec3(-0.05, -3.75, 0.), 0.4));        \n  d=max(d, -sdSphere(p-vec3(-.05, -3.9, 0.), 0.45)); \n\n  return d;\n}\n\n\nconst float radius =1.6;\nconst float outRad = 1.82;\nconst float inRad = 1.12;\nvec3 checkPos;\n\nfloat Map(vec3 p)\n{\n  float  d=100000.0;\n  checkPos = p;\n  steelDist=platformDist=waterDist=terrainDist=100000.0;\n\n  d=min(d, sdCappedCylinder(p-vec3(0.0, 3.7, 0), vec2(inRad, .45)));\n  d=min(d, sdSphere(p-vec3(0., 4., 0), 0.50));\n  d=min(d, fCylinderH(p-vec3(0.0, 1.3, 0), radius, 1.80));\n  d=min(d, sdConeSection(p-vec3(0.0, -6.0, 0.), 5.3, 2.4, 1.7));\n  d=min(d, sdConeSection(p-vec3(0.0, -13.0, 0.), 1.8, 2.8, 2.6));\n    \n  if(sdCappedCylinder(p-vec3(0.0, -19.0, 0), vec2(22.0, 7.))<10.0)\n  {\n  \/\/ platform \n  platformDist = fHexagonCircumcircle(p-vec3(0.0, -16.05, 0), vec2(radius+8.2, 1.4));  \n  platformDist=fOpUnionChamfer(platformDist, fHexagonCircumcircle(p-vec3(0.0, -15.05, 0), vec2(radius+8.7, 0.15)), 0.25);  \n\n  checkPos.xz = pModPolar(p.xz, 12.0);   \n  platformDist= min(platformDist, fHexagonCircumcircle(p-vec3(0.0, -16.42, 0), vec2(radius+8.3, 0.2)));  \n  platformDist=fOpIntersectionChamfer(platformDist, -sdBox(checkPos-vec3(radius+8.8, -16.55, 0.), vec3(1.0, 1., 1.8)), 0.1); \n  platformDist=fOpIntersectionChamfer(platformDist, -sdCappedCylinder(p-vec3(0., -14.4, 0), vec2(radius+7.4, .25)), 0.5);   \n\n  \/\/ railing (platform) \n  checkPos.xz = pModPolar(p.xz, 32.0);   \n  steelDist=min(steelDist, sdCappedCylinder(checkPos-vec3(radius+8., -14.4, 0), vec2(0.05, .46)));   \n  steelDist=min(steelDist, sdTorus(p-vec3(0., -14.2, 0), vec2(radius+8., 0.02)));\n  steelDist=min(steelDist, sdTorus(p-vec3(0., -14.35, 0), vec2(radius+8., 0.02)));\n  steelDist=min(steelDist, sdTorus(p-vec3(0., -13.9, 0), vec2(radius+8., 0.04)));\n\n  checkPos.xz = pModPolar(p.xz, 7.0); \n  steelDist = min(steelDist, MapStreeLight(checkPos-vec3(radius+6.7, -6.63, 0)));  \n  steelDist=max(steelDist, -sdBox(p-vec3(13.3, 0., 0.), vec3(6.6, 22.5, 3.7)));      \n  platformDist=max(platformDist, -sdBox(p-vec3(13.3, -12.5, 0.), vec3(4.6, 12.5, 3.5)));   \n       \n  terrainDist = MapTerrain(p);\n  }\n  \n  checkPos = p-vec3(11.70, -15.8, 0); \n    \n  pModSingle1(checkPos.x, 6.); \n  if(sdBox(checkPos-vec3(0,-1.0, 0), vec3(3.6, 2.3, 4.))<6.0)\n  {\n  float bridge = sdBox(checkPos-vec3(0, 0.8, 0), vec3(3.0, 0.1, 3.6)); \n  bridge=fOpUnionChamfer(bridge, sdBox(checkPos+vec3(0, 1., 0), vec3(3.0, 1.9, 3.3)), 0.15);   \n  bridge=fOpIntersectionChamfer(bridge, -sdBox(checkPos-vec3(0, 0.9, 0), vec3(6.0, 0.2, 3.3)), 0.10); \n  bridge=min(fOpPipe(bridge, -fCylinder(checkPos+vec3(0, 2.65, 0), 3., 4.6), 0.15), max(bridge, -fCylinder(checkPos+vec3(0, 2.65, 0), 3., 4.6)));\n  platformDist = min(platformDist, bridge);\n\n    \n  \/\/ railing (bridge)\n  checkPos = p-vec3(9.50, -14.42, 0.); \n  pModSingle1(checkPos.x, 2.); \n  steelDist=min(steelDist, sdCappedCylinder(checkPos-vec3(0, 0, 3.5), vec2(0.05, .45)));              \n  steelDist=min(steelDist, fCylinderV(p-vec3(39.0, -14.4, 3.5), 0.02, 29.45));  \n  steelDist=min(steelDist, fCylinderV(p-vec3(39.0, -14.55, 3.5), 0.02, 29.45));  \n  steelDist=min(steelDist, fCylinderV(p-vec3(38.90, -13.95, 3.5), 0.04, 29.45));  \n\n  steelDist=min(steelDist, sdCappedCylinder(checkPos-vec3(0, 0, -3.5), vec2(0.05, .45)));                    \n  steelDist=min(steelDist, fCylinderV(p-vec3(39.0, -14.4, -3.5), 0.02, 29.45));  \n  steelDist=min(steelDist, fCylinderV(p-vec3(39.0, -14.55, -3.5), 0.02, 29.45));  \n  steelDist=min(steelDist, fCylinderV(p-vec3(38.90, -13.95, -3.5), 0.04, 29.45));  \n  }\n\n \n  waterDist = p.y+17.5;\n\n  return  min(d, min(waterDist, min(terrainDist, min(platformDist, steelDist))));\n}\n\n\nvec3 calcNormal(  vec3 pos )\n{    \n  return normalize( vec3(Map(pos+eps.xyy) - Map(pos-eps.xyy), 0.5*2.0*eps.x, Map(pos+eps.yyx) - Map(pos-eps.yyx) ) );\n}\nvec3 calcTexNormal(in sampler2D sam, in vec2 pos )\n{    \n  return normalize(vec3(textureLod(sam, pos + vec2(-0.001, 0),0.0).r-textureLod(sam, pos + vec2(+0.001, 0),0.0).r, textureLod(sam, pos + vec2(0, -0.001),0.0).r-textureLod(sam, pos + vec2(0, +0.001),0.0).r, .03)) * 0.5 + 0.5;\n}\nvec3 calcNoiseNormal(  vec3 pos )\n{    \n  return normalize( vec3(fbm(pos+eps.xyy) - fbm(pos-eps.xyy), 0.5*2.0*eps.x, fbm(pos+eps.yyx) - fbm(pos-eps.yyx) ) );\n}\n\n\nfloat SoftShadow(  vec3 origin,  vec3 direction )\n{\n  float res = 2.0, t = 0.0, h;\n  for ( int i=0; i<32; i++ )\n  {\n    h = Map(origin+direction*t);\n    res = min( res, 6.5*h\/t );\n    t += clamp( h, 0.07, 0.6 );\n    if ( h<0.0025 ) break;\n  }\n  return clamp( res, 0.0, 1.0 );\n}\n\n\nRayHit MarchReflection( vec3 origin,  vec3 direction)\n{\n  RayHit result;\n  float maxDist = 90.0;\n  float t = 0.0, dist = 0.0;\n  vec3 rayPos;\n \n  for ( int i=0; i<32; i++ )\n  {\n    rayPos =origin+direction*t;\n    dist = Map( rayPos);\n \n\n    if (abs(dist)<0.05 || t>maxDist )\n    {             \n      result.hit=!(t>maxDist);\n      result.depth = t; \n      result.dist = dist;                              \n      result.hitPos = origin+((direction*t));   \n      result.steelDist = steelDist;\n      result.platformDist = platformDist;\n      result.terrainDist =terrainDist;\n      result.waterDist =waterDist;\n      break;\n    }\n    t += dist;\n  }\n\n  return result;\n}\n\nRayHit March( vec3 origin,  vec3 direction)\n{\n  RayHit result;\n  float maxDist = 380.0;\n  float t = 0.0, dist = 0.0;\n  vec3 rayPos;\n \n  for ( int i=0; i<200; i++ )\n  {\n    rayPos =origin+direction*t;\n    dist = Map( rayPos);\n \n\n    if (dist<0.01 || t>maxDist )\n    {             \n      result.hit=!(t>maxDist);\n      result.depth = t; \n      result.dist = dist;                              \n      result.hitPos = origin+((direction*t));   \n      result.steelDist = steelDist;\n      result.platformDist = platformDist;\n      result.terrainDist =terrainDist;\n      result.waterDist =waterDist;\n      break;\n    }\n    t += dist;\n  }\n\n  return result;\n}\n\n\nvec4 CubeMap( sampler2D sam,  vec3 hitPos,  vec3 n,  float k)\n{ \n    vec3 m = pow( abs( n ), vec3(k) );\n\tvec4 x = textureLod( sam, hitPos.yz,2. );\n\tvec4 y = textureLod( sam, hitPos.zx, 2. );\n\tvec4 z = textureLod( sam, hitPos.xy, 2. );\n\treturn (x*m.x + y*m.y + z*m.z) \/ (m.x + m.y + m.z);\n}\nmat3 setCamera(  vec3 ro,  vec3 ta, float cr )\n{\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n  vec3 cu = normalize( cross(cw, cp) );\n  vec3 cv = normalize( cross(cu, cw) );\n  return mat3( cu, cv, cw );\n}\n\n\nvec3 GetSkyColor( vec2 screenSpace,  vec3 rayDir,  vec3 rayOrigin)\n{\n\n  vec3 skyColor = mix(vec3(0.6, 0.7, 0.8), vec3(0.9), smoothstep(1.0, -.0, screenSpace.y)); \n  skyColor =  mix(skyColor, vec3(0.6, 0.7, 0.8), smoothstep(-0., -1., screenSpace.y*1.1));\n  float sun = clamp( dot(sunPos, rayDir), 0.0, 1.0 );\n  skyColor += vec3(.9, 0.4, 0.2)*sun*sun*clamp((rayDir.y+0.4)\/0.4, 0.0, 1.0);\n\n  float cloudScale = (200.0-rayOrigin.y)\/abs(rayDir.y);\n    if(cloudScale>0.05)\n    {\n  vec2 cloudUV = ((rayOrigin+cloudScale*rayDir).xz+ vec2(iTime*12.4, iTime*7.2))*.00009;\n  vec3  cloudNormal = calcTexNormal(iChannel2, cloudUV);\n  float cloudShade = clamp( dot( cloudNormal, sunPos ), 0.0, .6 );\n  skyColor = mix(skyColor,mix( skyColor, vec3(1.)*cloudShade, pow(texture( iChannel2, cloudUV).x, 3.)),smoothstep(0. ,0.2, abs(distance(0.,rayDir.y))));\n            }\n    return skyColor;\n}\n\n\n\n\nvec3 GetSceneLight(float specLevel, vec3 normal, RayHit rayHit, vec3 rayDir, vec3 origin)\n{        \n  vec3 reflectDir = reflect( rayDir, normal );\n\n  float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );\n  float dif = clamp( dot( normal, sunPos ), 0.0, 1.0 );\n  float bac = clamp( dot( normal, normalize(vec3(-sunPos.x, 0.0, -sunPos.z))), 0.0, 1.0 )*clamp( 1.0-rayHit.hitPos.y, 0.0, 1.0);\n  float fre = pow( clamp(1.0+dot(normal, rayDir), 0.0, 1.0), 2.0 );\n  specLevel*= pow(clamp( dot( reflectDir, sunPos ), 0.0, 1.0 ), 16.0);\n\n  float skylight = smoothstep( -0.1, 0.1, reflectDir.y );\n  vec3 shadowPos = origin+((rayDir*rayHit.depth)*0.98);  \n  dif *= SoftShadow( shadowPos, sunPos);\n  skylight *=SoftShadow(shadowPos, reflectDir);\n\n  vec3 lightTot = vec3(0.0);\n\n    \n    \n  lightTot += 1.30*dif*vec3(1.00, 0.80, 0.55);\n  lightTot += 0.50*skylight*vec3(0.40, 0.60, 1.00);\n      lightTot += 1.20*specLevel*vec3(0.9, 0.8, 0.7)*dif;\n  lightTot += 0.50*bac*vec3(0.25, 0.25, 0.25);\n  lightTot += 0.25*fre*vec3(1.00, 1.00, 1.00);\n  return lightTot +(0.40*amb*vec3(0.40, 0.60, 1.00));\n}\n\n\nvec4 GetMaterial( vec3 rayDir, inout RayHit rayHit)\n{\n  vec3 col = vec3(0.6);\n  float specLevel=1.30;\n  \n  \/\/ steel \n  if (rayHit.steelDist==rayHit.dist)\n  {\n    vec3 dirt =  CubeMap(iChannel3, (rayHit.hitPos*.44), rayHit.normal, 4.0).rgb*1.5; \n    col = vec3(0.3+(fbm(rayHit.hitPos*1.71)*.5));\n    col = mix(col, dirt*0.7, fbm(rayHit.hitPos*10.71));         \n    specLevel = 6.0;\n  }\n  \/\/stones and terrain \n  else if (rayHit.terrainDist==rayHit.dist)\n  {\n    vec3 moss =  CubeMap(iChannel3, rayHit.hitPos*0.22, rayHit.normal, 4.0).rgb*vec3(0.356, 0.455, 0.228);\n    col  =  CubeMap(iChannel3, (rayHit.hitPos*.44), rayHit.normal, 4.0).rgb; \n    col = mix( col, vec3(0.7), reflect( rayDir, rayHit.normal ).x);\n    col = mix(col, moss, smoothstep(-16.5, -18., rayHit.hitPos.y));\n    specLevel = .90;\n  } \n\n  \/\/ platform and bridge  \n  else if (rayHit.platformDist==rayHit.dist)\n  {\n    \n    vec3 dirt =  vec3(fbm(rayHit.hitPos*.41)); \n    vec3 dirt2 =  CubeMap(iChannel3, rayHit.hitPos*0.07, rayHit.normal, 4.0).rgb;  \n    vec3 dirt3 =  CubeMap(iChannel3, rayHit.hitPos*.002, rayHit.normal, 4.0).rgb;            \n    vec3 bNormal = calcNoiseNormal(rayHit.hitPos*15.)*0.55;\n    col = mix(mix(dirt2, dirt, 0.3), dirt3, 0.5);\n    col = mix(col, vec3(fbm(rayHit.hitPos*2.3)*0.3), smoothstep(-15.5, -18.01, rayHit.hitPos.y));          \n    specLevel=col.r*fbm(rayHit.hitPos*20.);       \n    rayHit.normal = mix(rayHit.normal, (rayHit.normal+bNormal)*0.5, 0.15);\n  \n  } \n\n  return vec4(col, specLevel);\n}\n\nvoid mainImage( out vec4 fragColor,  vec2 fragCoord )\n{  \n  vec2 mo = iMouse.xy\/iResolution.xy;\n  vec2 uv = fragCoord.xy \/ iResolution.xy;\n  vec2 screenSpace = (-iResolution.xy + 2.0*(fragCoord))\/iResolution.y;\n\n  float camrot = 20.0+(iTime*0.2);\n  if (iMouse.w>0.1) camrot+=mo.x*16.; \n\n  vec3 rayOrigin = vec3(8.*cos(camrot), 1.+12.*sin(camrot*1.8), 13.5 + 24.0*sin(camrot) );\n  mat3 ca = setCamera( rayOrigin, vec3(0., -6., 0.5 ), 0.0 );\n  vec3 rayDir = ca * normalize( vec3(screenSpace.xy, 2.0) );\n\n  vec3 skyColor = GetSkyColor(screenSpace, rayDir, rayOrigin);\n  vec3 color = skyColor;\n\n  RayHit marchResult = March(rayOrigin, rayDir);\n\n  if (marchResult.hit)\n  {\n    marchResult.normal = calcNormal(marchResult.hitPos);  \n\n    vec4 col;\n\n    \/\/ water\n    if (marchResult.waterDist==marchResult.dist)\n    {       \n      col = vec4(skyColor*0.35, 12.90); \n      vec3 waterNormal = ((calcWaterNormal(marchResult.hitPos.xz + vec2(-iTime*0.4, -iTime*0.2), 1.66))*(calcWaterNormal(marchResult.hitPos.xz + vec2(iTime*0.4, iTime*0.2), 3.61)));      \n    marchResult.normal = (vec3(0.0, 1.0, 0.0)+waterNormal)*0.4;\n\n        \n      vec3 ref = normalize(reflect(rayDir, marchResult.normal));\n      RayHit reflectResult = MarchReflection(marchResult.hitPos + (ref*0.002), ref); \n\n      \/\/ draw reflected objects and mix with water color\n      if (reflectResult.hit==true)\n      {   \n          \/\/ advanced reflections\n\n         \/\/  reflectResult.normal = calcNormal(reflectResult.hitPos); \n          \/\/ col.rgb = mix(col.rgb, GetMaterial(ref, reflectResult).rgb, 0.5);\n    \n          \/\/ fake reflections\n          col.rgb = mix(col.rgb, vec3(0.5).rgb, 0.5);\n     \n      }\n      marchResult.normal=(vec3(0.0, 1.0, 0.0)+waterNormal)*0.5;\n    }\n    \/\/ above water level\n    else\n    {\n      col = GetMaterial(rayDir, marchResult);\n    }\n\n    \/\/ get lightning based on material\n    vec3 light = GetSceneLight(col.a, marchResult.normal, marchResult, rayDir, rayOrigin);   \n\n    \/\/ apply lightning\n    color = col.rgb*light;\n        color = mix(color, skyColor, smoothstep(100., 200., marchResult.depth));  \n\n  }\n\n\n  float sun = clamp( dot(sunPos, rayDir), 0.0, 1.0 );  \n  color += vec3(.9, 0.4, 0.2)*sun*sun*clamp((rayDir.y+0.4)\/0.4, 0.0, 0.4);\n\n  fragColor = vec4(pow(color.rgb, vec3(1.0\/0.9)), 1.0 ) * (0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.2 ));\n}\n","name":"Buf A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"4djfWt","date":"1502964941","viewed":4632,"name":"Tunnel 3D Shape","username":"ingagard","description":"I have never worked with shaders before, only software rendering. Hope you enjoy it anyway. :-) ","likes":71,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"\/media\/a\/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"\/media\/ap\/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGzn","filepath":"\/media\/a\/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"\/media\/ap\/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"\/media\/a\/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"\/media\/ap\/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"\/media\/a\/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"\/media\/ap\/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define rotate(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nfloat lineWidth=7.0;\nfloat tunneRotSpeed = 0.05;\nfloat tunnelSpeed = 0.06;\nfloat size=100.0;\nvec3 objectStartPos = vec3(0, 0, -50.0);    \nfloat camRange=1000.0;\nfloat scale[8];\nvec3 projPos[8];    \n\nvec4 quads[6] = vec4[]( \n    vec4(0, 1, 2, 3), \n    vec4(4, 5, 6, 7), \n    vec4(3, 7, 4, 0), \n    vec4(6, 5, 1, 2), \n    vec4(0, 1, 5, 4), \n    vec4(2, 3, 7, 6));\n\nvec3 edges[24];\n\n\nvoid oval(vec2 screenCoord, vec2 center, float radius, float strokeThickness, vec4 strokeColor, vec4 fillColor, inout vec4 pixel)\n{\n  float dist= distance(screenCoord, center);\n\n  if (dist<radius)\n  { \n    if (dist<radius-strokeThickness)\n    {\n      pixel = fillColor;\n    } else\n    {\n      pixel = strokeColor;\n    }\n  }\n}\n\n\nbool lineItersection(vec2 v1, vec2 v2, vec2 v3, vec2 v4) \n{    \n  float bx = v2.x - v1.x;\n  float by = v2.y - v1.y;\n  float dx = v4.x - v3.x;\n  float dy = v4.y - v3.y;\n\n  float b_dot_d_perp = bx * dy - by * dx;\n\n  if (b_dot_d_perp == 0.0) return false;\n\n  float cx = v3.x - v1.x;\n  float cy = v3.y - v1.y;\n\n  float t = (cx * dy - cy * dx) \/ b_dot_d_perp;\n  if (t < 0.0 || t > 1.0)  return false;\n\n  float u = (cx * by - cy * bx) \/ b_dot_d_perp;\n  if (u < 0.0 || u > 1.0)  return false;\n\n  return true;\n}\n\n\nvoid Line(vec2 screenCoord, vec2 p1, vec2 p2, float thickness, vec4 color, inout vec4 pixel)\n{\n\n  float a = distance(p1, screenCoord);\n  float b = distance(p2, screenCoord);\n  float c = distance(p1, p2);\n\n  if ( a >= c || b >=  c ) return;\n\n  float p = (a + b + c) * 0.5;\n\n  float dist = 2.0 \/ c * sqrt( p * ( p - a) * ( p - b) * ( p - c));\n\n  if (dist<thickness)\n  {\n    pixel = mix(pixel, color, 1.0\/max(1.0, dist*3.0));\n  }\n}\n\n\n\nbool insideQuad(vec2 v1, vec2 v2, vec2 v3, vec2 v4, vec2 point)\n{\n\n  vec2 point2 = vec2(point.x-10000.0,point.y);\n    \n  int colCount = 0;\n\n  if (lineItersection(point, point2, v1, v2))         \n  {     colCount++;  }\n  if (lineItersection(point, point2, v2, v3))\n  {     colCount++;  }\n  if (lineItersection(point, point2, v3, v4))\n  {     colCount++;  }\n  if (lineItersection(point, point2, v4, v1))\n  {     colCount++;  }\n\n  return (colCount==1);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float frame = float(iTime)*60.0;\n  float FrameRad = radians(frame);\n  float sinFrame = sin(FrameRad);\n  float cosFrame = cos(FrameRad);\n  float sinFrame2 = sinFrame*0.2;\n  float cosFrame2 = cosFrame*2.2;\n  vec2 center = (iResolution.xy\/2.0)+vec2((cosFrame*sinFrame2)*250.0, (cosFrame-cosFrame2)*50.0);\n  vec2 centerFragDist = center-fragCoord;\n  vec3 halfRes = vec3(iResolution.x*0.5, iResolution.y*0.5, 0);   \n  vec2 uvTunnel = fragCoord.xy \/ iResolution.xy;\n  float angle = atan( centerFragDist.y, centerFragDist.x)*3.14;\n  float dist = length(fragCoord-center);\n\n  uvTunnel.x=1.0\/(dist*0.0005);\n  uvTunnel.y=angle;\n\n  vec4 color = texture(iChannel3, uvTunnel*vec2(0.4, 3.0)+vec2(frame*tunnelSpeed, frame*tunneRotSpeed));\n  color*=vec4(0.2, 0.4, 1.0, 1.0)*(2.0\/(dist*0.01));   \n\n  float rot = frame*0.02;\n  vec2 uv = (fragCoord.xy \/ iResolution.xy);\n  vec2 uv2 = (fragCoord.xy \/ iResolution.xy +vec2(frame*0.01, frame*0.003))*0.1;\n  vec2 screenCoord = vec2(fragCoord.x, iResolution.y-fragCoord.y);\n\n  vec3 camPos = vec3(0, 0, 90.0+cos(FrameRad)*50.0);\n    \n  vec3 verts[8] = vec3[](\n    vec3(-1.0, -1.0, -1.0), \n    vec3(-1.0, -1.0, 1.0), \n    vec3(1.0, -1.0, 1.0), \n    vec3(1.0, -1.0, -1.0), \n    vec3(-1.0, 1.0, -1.0), \n    vec3(-1.0, 1.0, 1.0), \n    vec3(1.0, 1.0, 1.0), \n    vec3(1.0, 1.0, -1.0));\n    \n  for (int i=0; i<8; i++)\n  {           \n      \/\/ Y ROTATION    \n      verts[i].xz *= rotate(rot); \n      \/\/ X ROTATION\n      verts[i].yz *= rotate(rot*0.7);  \n      \/\/ Z ROTATION\n      verts[i].xy *= rotate(rot*0.2);  \n      \n      verts[i]+=objectStartPos;\n  }\n\n  for (int i=0; i<8; i++)\n  {                            \n    float camDistance = distance(verts[i], camPos);\n    scale[i] = (camRange\/camDistance)*0.1;\n    projPos[i] = verts[i]-camPos;\n    projPos[i]*=size*scale[i];    \n    projPos[i]+= halfRes;\n  }\n\n  float range =  max(0.0, 1.0*sin(FrameRad));\n \n  for (int i=0; i<6; i++)\n  {\n    vec3 center = (projPos[int(quads[i].x)]+projPos[int(quads[i].y)]+projPos[int(quads[i].z)]+projPos[int(quads[i].w)])\/4.0;           \n    edges[i*4 + 0]=projPos[int(quads[i].x)]+((center-projPos[int(quads[i].x)])*range);\n    edges[i*4 + 1]=projPos[int(quads[i].y)]+((center-projPos[int(quads[i].y)])*range);\n    edges[i*4 + 2]=projPos[int(quads[i].z)]+((center-projPos[int(quads[i].z)])*range);\n    edges[i*4 + 3]=projPos[int(quads[i].w)]+((center-projPos[int(quads[i].w)])*range);            \n  }\n\n  for (int i=0; i<6; i++)\n  {  \n    if (insideQuad(edges[i*4 + 0].xy, edges[i*4 + 1].xy, edges[i*4 + 2].xy, edges[i*4 + 3].xy, screenCoord))\n    { \n      vec2 center = (edges[i*4 + 0].xy+edges[i*4 + 1].xy+edges[i*4 + 2].xy+edges[i*4 + 3].xy)\/4.0;                \n\n      float minX = min(edges[i*4 + 0].x, min(edges[i*4 + 1].x, min(edges[i*4 + 2].x, edges[i*4 + 3].x)));\n      float minY = min(edges[i*4 + 0].y, min(edges[i*4 + 1].y, min(edges[i*4 + 2].y, edges[i*4 + 3].y)));\n      float maxX = max(edges[i*4 + 0].x, max(edges[i*4 + 1].x, max(edges[i*4 + 2].x, edges[i*4 + 3].x)));\n      float maxY = max(edges[i*4 + 0].y, max(edges[i*4 + 1].y, max(edges[i*4 + 2].y, edges[i*4 + 3].y)));\n\n      float width = maxX-minX;\n      float height = maxY-minY;       \n      float xDist = distance(minX, screenCoord.x)\/width;\n      float yDist = distance(minY, screenCoord.y)\/height;\n\n      color = (color+texture(iChannel2, vec2(xDist, 1.0-yDist)*0.1))*0.75;\n      color-=0.2*((distance(center, screenCoord)\/width));\n    }\n  }\n\n  vec4 lineColor = color*3.0;\n\n  for (int i=0; i<6; i++)      \n  {    \n    Line(screenCoord, edges[i*4 + 0].xy, edges[i*4 + 1].xy, lineWidth, lineColor, color);  \n    Line(screenCoord, edges[i*4 + 1].xy, edges[i*4 + 2].xy, lineWidth, lineColor, color);  \n    Line(screenCoord, edges[i*4 + 2].xy, edges[i*4 + 3].xy, lineWidth, lineColor, color);  \n    Line(screenCoord, edges[i*4 + 3].xy, edges[i*4 + 0].xy, lineWidth, lineColor, color);\n  }\n\n  for (int i=0; i<24; i++)\n  {       \n    oval(screenCoord, edges[i].xy, 4.0, lineWidth, vec4(1.0), color*5.0, color);\n  }\n\n  vec2 sunPos = vec2(400.0+(cos(FrameRad)*300.0), 200.0+(sin(FrameRad)*100.0));      \n  float sunDist = distance(screenCoord, sunPos)*0.02;\n\n  fragColor = color + vec4(0.1\/sunDist, 0.1\/sunDist, 0.2\/sunDist, 0);\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4llBD8","date":"1511771220","viewed":4567,"name":"[Planet] Outer Space","username":"ingagard","description":"Please uncomment #define HIGH_QUALITY  in buf C for full experiance.\n\nPress 2-key to toggle manual\/auto camera mode. Description for more info...\n\nManual camera allows you to use mouse to control the camera.\nThis also enables zoom with D and E keys.","likes":60,"published":3,"flags":112,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"\/media\/previz\/buffer03.png","previewfilepath":"\/media\/previz\/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"MsSSz1","filepath":"https:\/\/soundcloud.com\/chamberlainyeah\/path-to-shangri-la-1","previewfilepath":"https:\/\/soundcloud.com\/chamberlainyeah\/path-to-shangri-la-1","type":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Copyright \u00a9 2017 Kim Berkeby (email: mr.kimb@hotmail.com)\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/*\n\n Toggle effects by pressing folloving keys:\n ------------------------------------------\n 1-key  = Change color tint mode  \n\n 2-key  = Switch manual\/auto camera mode         (default auto)\n\n ------------------  NOTICE    ------------------------------------\n Using manual camera allows you to use mouse to control the camera.\n This also allows you to use D and E keys to zoom (alternative F1 and F2 keys)\n -------------------------------------------\n\n 3-key  = Chromatic aberration  on\/off           (default on)    \n 4-key  = God Rays  on\/off                       (default on)\n 5-key  = Lens flare  on\/off                     (default on)\n\n --------------------------------------------------------\n --------------------------------------------------------\n\n  TO INCREASE PERFORMANCE OR QUALITY:\n  --------------------------------\n  \n  Turn on\/off one or several defines in Buf C:\n \n  #define CLOUDS\n  #define QUALITY_CLOUDS\n\n  #define SHADOWS\n  #define ROTATING_MOON\n  #define ROTATING_PLANET\n  #define SPACE_CLOUDS\n  #define HIGH_QUALITY_BELT\n\n  Enable for full experience (can crash some machines):\n \n\n  #define HIGH_QUALITY    <-----\n\n\n --------------------------------------------------------\n \n This shader was made by using distance functions found in HG_SDF:\n http:\/\/mercury.sexy\n \n Special thanks to Inigo Quilez for his great tutorials on:\n https:\/\/iquilezles.org\/\n\n Music by chamberlain:\n https:\/\/soundcloud.com\/chamberlainyeah\/path-to-shangri-la-1\n\n Last but not least, thanks to all the nice people here at ShaderToy! :-D\n\n*\/\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ POST EFFECTS BUFFER\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  #define FastNoise(posX) (  textureLod(iChannel1, (posX+0.5)\/iResolution.xy, 0.0).r)\n  #define readAlpha(memPos) (  textureLod(iChannel2, memPos, 0.0).a)\n  #define readRGB(memPos) (  texelFetch(iChannel0, memPos, 0).rgb)\n  #define PI acos(-1.)\n  #pragma optimize(off) \n\nmat3 cameraMatrix;\n\nvec3 sunPos=vec3(0.);\n\nfloat CalcSum(vec2 uvPos) \n{\n    vec4 col = textureLod(iChannel2, uvPos,0.);\n    float sum = (col.r+col.g+col.b)*0.333;\n    return mix(0.,sum,step(0.65,sum-col.a));\n}\n\n#define VOLUMESAMPLES 32\nfloat GetVolumetrics(vec2 pos, vec2 uv)\n{\n    float sum \t = 0.;\n    float weight = 1. \/ float(VOLUMESAMPLES);\n    vec2 dir = pos-uv;\n    \n    for(int i = 0; i < VOLUMESAMPLES; i++)\n    {\n        sum += CalcSum(uv)*(1.-(float(i)*weight));\n        uv += dir * .01;\n    }\n    \n    return sum * weight;\n}\n\nmat3 setCamera(  vec3 ro, vec3 ta, float cr )\n{\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n  vec3 cu = normalize( cross(cw, cp) );\n  vec3 cv = normalize( cross(cu, cw) );\n  return mat3( cu, cv, cw );\n}\n\nvec2 GetScreenPos(vec3 pos)\n{\n  return vec2(PI*dot( pos, cameraMatrix[0].xyz ), PI* dot( pos, cameraMatrix[1].xyz ));\n}\n\nvec3 CalculateSunFlare(vec3 rayDir, vec3 rayOrigin, vec2 screenSpace, float alpha, float enableFlare, vec2 uv)\n{\n\n  float visibility = pow(max(0., dot(sunPos, rayDir)), 5.0);  \n  if (visibility<=0.006) return vec3(0.);\n\n  vec2 sunScreenPos = GetScreenPos(sunPos);\n\n  vec2 uvT = screenSpace-sunScreenPos;  \n  vec2 offSetCol = (uvT.xy-1.)\/iResolution.xy*14.5;  \n     \n  float sunIntensity = (1.0\/(pow(length(uvT)*4.0+1.0, 1.30)))*visibility;\n\n  vec3 flareColor = vec3(0.);\n  vec2 offSet = uvT;\n  vec2 offSetStep=  0.4*sunScreenPos;\n  float size=.0, dist=0.;\n  \n  if(enableFlare>0.)\n  {\n  \/\/ check if center of sun is covered by any object. MATH IS OFF AT SCREEN CHECK POS! sunScreenPos\/2.0 +0.5 IS NOT EXACTLY SUN MIDDLE!\n  \/\/ only draw if not covered by any object\n  if (readAlpha( sunScreenPos\/2.0 +0.5)<0.50)\n  {\n    \/\/ create flare rings\n    for (float i =1.; i<8.; i++)\n    {\n      offSet += offSetStep;\n\n      size = 0.006+((1.-sin(i*0.54))*0.2);\n      dist = pow(length(sunScreenPos+offSetCol-offSet), 1.20);\n      flareColor.r += mix(0., sunIntensity*(18.*size), smoothstep(size, size-dist, dist))\/(1.0-size);\n      dist = pow(length(sunScreenPos-offSet), 1.20);\n      flareColor.g += mix(0., sunIntensity*(18.*size), smoothstep(size, size-dist, dist))\/(1.0-size);\n      dist = pow(length(sunScreenPos-offSetCol-offSet), 1.20);\n      flareColor.b += mix(0., sunIntensity*(18.*size), smoothstep(size, size-dist, dist))\/(1.0-size);   \n    }\n\n  }\n      flareColor = mix(flareColor,flareColor*.1, max(0.,visibility));\n      flareColor += vec3(1.0, .7, .0)  * pow(visibility, 2.);\n}\n  flareColor*=mix(2., .2, smoothstep(0., 1., visibility)); \n    \n  \/\/ flare star shape\n  vec3 sunSpot = vec3(1.30, 1., .80)*sunIntensity*(sin(FastNoise((sunScreenPos.x+sunScreenPos.y)*2.3+atan(uvT.x, uvT.y)*15.)*5.0)*.12);\n  \n  \/\/ sun glow\n  sunSpot+=vec3(1.0, 0.9,0.8)*sunIntensity*2.5;\n    \n     float d = length(uvT*vec2(4.,.2))*50.;\n\tsunSpot += vec3(1.0, 0.776, 0.620)\/pow(d,2.);\n\td = length(uvT*vec2(.2,4.))*50.;\n\tsunSpot += vec3(1.0, 0.776, 0.620)\/pow(d,2.);\n \n  return flareColor+(sunSpot*(1.0-alpha));\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{  \n  vec2 uv = fragCoord.xy \/ iResolution.xy;\n  vec2 screenSpace = (-iResolution.xy + 2.0*(fragCoord))\/iResolution.y;\n\n  \/\/ read values from buffer\n  vec3 effects = readRGB(ivec2(120, 0));  \n  vec3 effects2 = readRGB(ivec2(122, 0)); \n\n  sunPos = readRGB(ivec2(50, 0));\n    \n  \/\/ setup camera and ray direction\n  vec2 camRot = readRGB(ivec2(57, 0)).xy;\n  vec3 rayOrigin =readRGB(ivec2(62, 0));\n  cameraMatrix  = setCamera( rayOrigin, vec3(0., 0., 0. ), 0.0 );\n  vec3 rayDir = cameraMatrix * normalize( vec3(screenSpace.xy, 2.0) );\n\n  vec4 color = vec4(0.);\n\n  \/\/ chromatic aberration?\n  if (effects.z>0.)\n  {\n    vec2 offSet = (uv.xy*3.-1.)\/iResolution.xy*1.5;\n    color.rgb = vec3(texture(iChannel2, uv + offSet).r, texture(iChannel2, uv).g, texture(iChannel2, uv - offSet).b);   \n  }\n  \/\/ no chromatic aberration \n  else\n  {\n      color.rgb = texture(iChannel2, uv).rgb;\n  }\n\n  color.a=textureLod(iChannel2, uv, 0.).a;\n\n  \/\/ add sun with lens flare effect\n  color.rgb += CalculateSunFlare(rayDir, rayOrigin, screenSpace, clamp(color.a, 0., 1.0),effects2.x,uv);\n\n    \n  \/\/ perform volumetric light ray pass if looking into the sun\n  if (effects2.y>0.)\n  { \n    vec2 sunScreenPos = GetScreenPos(sunPos);\n    float sunVisibility = max(0.,dot(sunPos, rayDir));\n         \n    if(length(sunScreenPos)<2.3)\n    {\n      color.rgb += mix(0.,GetVolumetrics(sunScreenPos\/2.0 +0.5, uv),pow(sunVisibility,6.));\n    }\n  } \n    \n  \/\/ gamma correction and edge fade\n  fragColor =  vec4(pow(color.rgb, vec3(1.0\/1.1)), 1.0 ) * (0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.32 ));\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"\/presets\/tex00.jpg","previewfilepath":"\/presets\/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ DATA BUFFER  -  CAMERA CONTROL AND KEYBOARD CHECKS\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  \/\/ #pragma optimize(off) \n  #define keyClick(ascii)   ( texelFetch(iChannel0, ivec2(ascii, 0), 0).x > 0.)\n  #define keyPress(ascii)   ( texelFetch(iChannel0, ivec2(ascii, 1), 0).x > 0.)\n  #define read(memPos) (  texelFetch(iChannel2, memPos, 0).a)\n  #define readRGB(memPos) (  texelFetch(iChannel2, memPos, 0).rgb)\n\n  \/\/ D     ZOOM OUT\n  #define ZOOMOUT_KEY 68\n  \/\/ E     ZOOM IN\n  #define ZOOMIN_KEY 69\n  \/\/ F1     ZOOM OUT (alternative)\n  #define ZOOMOUT_KEY_ALT 112\n  \/\/ F2     ZOOM IN (alternative)\n  #define ZOOMIN_KEY_ALT 113\n\n  \/\/#define MANUAL_CAMERA\n  #define ROTATING_SUN\n\n\n  #define pR(p, a) p*=r2(a)\n\nmat2 r2(float r) \n{\n  float c=cos(r), s=sin(r);\n  return mat2(c, s, -s, c);\n}\n\nvoid ToggleEffects(inout vec4 fragColor, vec2 fragCoord)\n{\n  \/\/ read and save effect values from buffer  \n  vec3 effects =  mix(vec3(-1.0, -1.0, -1.0), readRGB(ivec2(120, 0)), step(1.0, float(iFrame)));\n  effects.x*=1.0+(-2.*float(keyPress(49))); \/\/1-key  color tint mode\n  effects.y*=1.0+(-2.*float(keyPress(50))); \/\/2-key  manual \/ auto camera mode\n  effects.z*=1.0+(-2.*float(keyPress(51))); \/\/3-key  chromatic aberration\n\n  vec3 effects2 =  mix(vec3(1.0, 1.0, 1.0), readRGB(ivec2(122, 0)), step(1.0, float(iFrame)));\n  effects2.y*=1.0+(-2.*float(keyPress(52))); \/\/4-key  god Rays\n  effects2.x*=1.0+(-2.*float(keyPress(53))); \/\/5-key  lens flare\n\n  fragColor.rgb = mix(effects, fragColor.rgb, step(1., length(fragCoord.xy-vec2(120.0, 0.0))));  \n  fragColor.rgb = mix(effects2, fragColor.rgb, step(1., length(fragCoord.xy-vec2(122.0, 0.0))));\n}\n\nmat3 setCamera(  vec3 ro, vec3 ta, float cr )\n{\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n  vec3 cu = normalize( cross(cw, cp) );\n  vec3 cv = normalize( cross(cu, cw) );\n  return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{ \n  vec2 mo = iMouse.xy\/iResolution.xy;\n  vec2 uv = fragCoord.xy \/ iResolution.xy;\n  vec2 screenSpace = (-iResolution.xy + 2.0*(fragCoord))\/iResolution.y;\n\n  \/\/ load data  \n  vec3 sunPos = normalize( vec3(-.50, 0.13, .700));\n  vec3 camData = mix(vec3(0., 0., 230.), readRGB(ivec2(52, 0)), step(1.0, float(iFrame)));  \n  vec2 camRot = mix(vec2(3.73, 0.), readRGB(ivec2(57, 0)).xy, step(1.0, float(iFrame))); \n  vec3 oldOrigin = readRGB(ivec2(62, 0));\n\n  ToggleEffects(fragColor, fragCoord);\n\n  \/\/ adding a small amount of camRot.y just to check if the camera has been moved in ANY way when later doing AA pass\n  float camrot = 15.+(iTime*0.1);\n  vec3 rayOrigin = vec3(230.*cos(camrot), 10.-40.*sin(-camrot*4.)+(0.0001*camRot.y), 230.0*sin(-camrot) );\n  mat3 ca = setCamera( rayOrigin, vec3(0., 0., 0. ), 0.0 );\n  vec3 rayDir = ca * normalize( vec3(screenSpace.xy, 2.0) );\n\n\n  \/\/ manual camera mode?  2-key\n  if (readRGB(ivec2(120, 0)).y>0.)\n  {\n    if (iMouse.z>0.)\n    {\n      camRot.x=(mo.x*12.); \n      camRot.y=-64.+((mo.y)*128.);\n    }\n    camRot.y = clamp(camRot.y, -128., 128.);\n\n    camData.z-=0.3*float(keyClick(ZOOMIN_KEY) || keyClick(ZOOMIN_KEY_ALT));\n    camData.z+=0.3*float(keyClick(ZOOMOUT_KEY) || keyClick(ZOOMOUT_KEY_ALT));\n    camData.z=clamp(camData.z, 180., 320.);\n\n    rayOrigin = vec3(camData.z*cos(camRot.x), camRot.y, camData.z*sin(camRot.x) );\n  }\n\n  \/\/ rotate the sun\n  #ifdef ROTATING_SUN\n    pR(sunPos.xz, -iTime*0.2);\n  #endif\n\n  \/\/ save date    \n  fragColor.rgb = mix(sunPos, fragColor.rgb, step(1., length(fragCoord.xy-vec2(50.0, 0.0))));\n  fragColor.rgb = mix(camData, fragColor.rgb, step(1., length(fragCoord.xy-vec2(52.0, 0.0))));\n  fragColor.rgb = mix(rayOrigin, fragColor.rgb, step(1., length(fragCoord.xy-vec2(62.0, 0.0))));\n  fragColor.rgb = mix(oldOrigin, fragColor.rgb, step(1., length(fragCoord.xy-vec2(60.0, 0.0))));\n\n  fragColor.rgb = mix(vec3(camRot.xy, 0.), fragColor.rgb, step(1., length(fragCoord.xy-vec2(57.0, 0.0))));\n}\n","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"XdfGRn","filepath":"\/media\/a\/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"\/media\/ap\/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzn","filepath":"\/media\/a\/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"\/media\/ap\/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ BACKGROUND BUFFER -   RENDERS SPACE\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n  #define PI 3.14159265359\n  #define PI_TWO 6.28318530718\n  #define readRGB(memPos) (  texelFetch(iChannel2, memPos, 0).rgb)\n  \/\/#pragma optimize(off) \n\n\n  #define COMETS\n\n  vec2 PosToSphere(vec3 pos)\n{\n  float x = atan(pos.z, pos.x); \n  float y = acos(pos.y \/ length(pos)); \n  return vec2(2.*x \/ PI_TWO, 2.*y \/ PI);\n}\n\nfloat hash(float h)\n{\n  return fract(sin(h) * 43758.5453123);\n} \n\nvec3 sunPos=vec3(0.);\n\n\/\/ by IQ\nfloat noise(vec3 x) \n{\n  vec3 p = floor(x);\n  vec3 f = fract(x);\n  f = f * f * (3.0 - 2.0 * f);\n\n  float n = p.x + p.y * 157.0 + 113.0 * p.z;\n  return -1.0+2.0*mix(\n    mix(mix(hash(n + 0.0), hash(n + 1.0), f.x), \n    mix(hash(n + 157.0), hash(n + 158.0), f.x), f.y), \n    mix(mix(hash(n + 113.0), hash(n + 114.0), f.x), \n    mix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\n\n\/\/ by IQ\nfloat fastFBM(vec3 p)\n{\n  vec3 ip=floor(p);\n  p-=ip; \n  vec3 s=vec3(7, 157, 113);\n  vec4 h=vec4(0., s.yz, s.y+s.z)+dot(ip, s);\n  p=p*p*(3.-2.*p); \n  h=mix(fract(sin(h)*43758.5), fract(sin(h+s.x)*43758.5), p.x);\n  h.xy=mix(h.xz, h.yw, p.y);\n  return mix(h.x, h.y, p.z);\n}\n\nmat3 setCamera(  vec3 ro, vec3 ta, float cr )\n{\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n  vec3 cu = normalize( cross(cw, cp) );\n  vec3 cv = normalize( cross(cu, cw) );\n  return mat3( cu, cv, cw );\n}\nvec4 SphereMap(sampler2D sam, in vec3 p)\n{\n  vec2 spherePos = PosToSphere(p);\n  return textureLod(sam, spherePos, 2.*log2(spherePos.y*2.));\n}\n\n\/\/ https:\/\/www.shadertoy.com\/view\/MtsGWH\nvec4 BoxMap( sampler2D sam, in vec3 p, in vec3 n, in float k, in float LOD)\n{\n  vec3 m = pow( abs(n), vec3(k) );\n  vec4 x = textureLod( sam, p.yz, LOD);\n  vec4 y = textureLod( sam, p.zx, LOD);\n  vec4 z = textureLod( sam, p.xy, LOD);\n  return (x*m.x + y*m.y + z*m.z)\/(m.x+m.y+m.z);\n}\n\n\n#define pR(p, a) (p)*=r2(a)\n  mat2 r2(float r) {\n  float c=cos(r), s=sin(r);\n  return mat2(c, s, -s, c);\n}\n\n\nvec3 GetSpaceColor(vec3 rayDir)\n{ \n  vec3 stars = BoxMap(iChannel0, rayDir, rayDir, 0.5, 0.0).rgb;\n  vec3 stars2 = SphereMap(iChannel0, rayDir).rgb; \n\n  vec3 starPos = rayDir+vec3(iTime*0.0004, iTime*0.0005, iTime*0.0003);\n  float starsDetailS = pow(noise(starPos*450.), 1.);\n  float starsDetailM = pow(noise(starPos*150.), 2.);\n  float starsDetailL = pow(0.45+noise(starPos*52.), 3.);\n\n  vec3 starColor = vec3(1.0);\n\n  starColor.r += abs(starsDetailS-starsDetailM);\n  starColor.g += abs(starsDetailL-starsDetailM);\n  starColor.b += abs(starsDetailS-starsDetailL);\n\n  starColor=(starColor*0.5)+(starsDetailL*.5);\n\n  float sun = mix(0., pow( clamp( 0.5 + 0.5*dot(sunPos, rayDir), 0.0, 1.0 ), 2.0 ), smoothstep(.33, .0, rayDir.y));\n  float sun2 = clamp( 0.75 + 0.25*dot(sunPos, rayDir), 0.0, 1.0 );\n\n  vec3 col = mix(vec3(0, 0, 164)\/255., vec3(0, 0, 150)\/255., smoothstep(0.8, 0.00, rayDir.y)*sun2);\n  col = mix(col, vec3(100, 0, 169)\/255., smoothstep(0.015, .0, rayDir.y)*sun2);\n  col = mix(col, vec3(160, 0, 136)\/255., smoothstep(0.3, 1.0, sun));\n  col = mix(col, vec3(255, 0, 103)\/255., smoothstep(0.6, 1.0, sun));\n\n  col=col*stars;\n  col = mix(col, vec3(starsDetailS*starColor), smoothstep(0.7, 1., starsDetailS));\n  col = mix(col, vec3(starsDetailM*starColor), smoothstep(0.7, 1., starsDetailM));\n\n  vec3 nebula = (vec3(stars.r, 0., 0.)*stars2.r);\n  nebula = mix(nebula, nebula*2., pow(stars2.r, 2.));\n  nebula = mix(nebula, vec3(1.), pow(stars2.r, 4.));        \n\n  vec3 offset = vec3(iTime, iTime*2., 0.)*0.01;\n  vec2 addStep = vec2(-0.04, -0.07)*0.05;\n  vec2 pp = PosToSphere(rayDir);\n\n  #ifdef COMETS\n    vec3 comet = textureLod(iChannel3, (pp)-offset.xy, 1.).rgb;\n\n  for ( int i=0; i<30*int(step(0.2, comet.r)); i++ )\n  {\n    col = mix(col, vec3(1.), step(0.4, pow(textureLod(iChannel3, (pp*2.)-offset.xy, 1.).r, 6.))\/((float(i)+1.)));\n    offset.xy+=addStep;\n  }   \n  #endif\n\n    nebula = mix(nebula, nebula*vec3(1.2, 0.9, .50), max(0., readRGB(ivec2(120, 0)).x));\n\n  return col+nebula;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{  \n  vec2 uv = fragCoord.xy \/ iResolution.xy;\n  vec2 screenSpace = (-iResolution.xy + 2.0*(fragCoord))\/iResolution.y;\n  float alpha=0.;\n\n  sunPos =  readRGB(ivec2(50, 0));\n  \/\/ setup camera and ray direction\n  vec2 camRot = readRGB(ivec2(57, 0)).xy;   \n  vec3 rayOrigin =readRGB(ivec2(62, 0));\n  mat3 ca = setCamera( rayOrigin, vec3(0., 0., 0. ), 0.0 );\n  vec3 rayDir = ca * normalize( vec3(screenSpace.xy, 2.0) );\n\n  vec3 color =  GetSpaceColor(rayDir)*1.5;\n\n  vec2 beltPos = rayDir.xz;\n  pR(beltPos, iTime*0.01);\n  vec3 noisePos = vec3(iTime*2., iTime*4., iTime*0.5)*0.2;\n  vec3 test= textureLod(iChannel0, beltPos*0.4, log2(beltPos.y*2.)).rgb*vec3(1.3, 0.74, 1.);\n  color.rgb = mix(color.rgb+test*vec3(1.2, 0.9, .50), color.rgb, smoothstep(0., 0.3, (0.5+(.285*fastFBM(noisePos+(rayDir*122.))))*distance(((rayDir.y)*3.1), 0.)));\n\n  fragColor = vec4(mix(color.rgb, color.rgb*vec3(1., 0.97, 0.40), max(0., readRGB(ivec2(120, 0)).x)), 0.);\n}\n","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"XdX3Rn","filepath":"\/media\/a\/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"\/media\/ap\/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"\/media\/a\/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"\/media\/ap\/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ PLANET BUFFER -   RENDERS PLANETS, RING AND SPACE-CLOUDS\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define readRGB(memPos) (  texelFetch(iChannel2, memPos, 0).rgb)\n  #define PI 3.14159265359\n  #define PI_TWO 6.28318530718\n  \/\/#pragma optimize(off) \n\n  \/\/ Delete on or several of below defines to increase performance\n  #define CLOUDS\n  #define QUALITY_CLOUDS\n  #define SHADOWS\n  #define ROTATING_MOON\n  #define ROTATING_PLANET\n  #define SPACE_CLOUDS\n  #define HIGH_QUALITY_BELT\n\n  \/\/enable for full experience (can crash some machines)\n  \/\/#define HIGH_QUALITY\n\n\n  float hash(float h)\n{\n  return fract(sin(h) * 43758.5453123);\n} \n\nstruct RayHit\n{\n  bool hit;  \n  vec3 hitPos;\n  vec3 normal;\n  vec4 dist;\n  float depth;\n};\n\nvec3 sunPos=vec3(0.);\n\nvec2 PosToSphere(vec3 pos)\n{\n  float x = atan(pos.z, pos.x); \n  float y = acos(pos.y \/ length(pos)); \n  return vec2( x \/ (2.0 * PI), y \/ PI);\n}\n\n\/\/ by afl_ext (achlubek)\n\/\/*****************************************************************\nfloat oct(vec3 p) {\n  return fract(4768.1232345456 * sin((p.x+p.y*43.0+p.z*137.0)));\n}\nfloat oct(vec2 p) {\n  return fract(4768.1232345456 * sin((p.x+p.y*43.0)));\n}\n\nfloat noise2D(vec2 x) {\n  vec2 p = floor(x);\n  vec2 fr = fract(x);\n  vec2 LB = p;\n  vec2 LT = p + vec2(0.0, 1.0);\n  vec2 RB = p + vec2(1.0, 0.0);\n  vec2 RT = p + vec2(1.0, 1.0);\n\n  float LBo = oct(LB);\n  float RBo = oct(RB);\n  float LTo = oct(LT);\n  float RTo = oct(RT);\n\n  float noise1d1 = mix(LBo, RBo, fr.x);\n  float noise1d2 = mix(LTo, RTo, fr.x);\n\n  float noise2d = mix(noise1d1, noise1d2, fr.y);\n\n  return -1.0+2.0*noise2d;\n}\n\nfloat noise(vec3 x) { \n  vec3 p = floor(x);\n  vec3 fr = fract(x);\n  vec3 LBZ = p + vec3(0.0, 0.0, 0.0);\n  vec3 LTZ = p + vec3(0.0, 1.0, 0.0);\n  vec3 RBZ = p + vec3(1.0, 0.0, 0.0);\n  vec3 RTZ = p + vec3(1.0, 1.0, 0.0);\n\n  vec3 LBF = p + vec3(0.0, 0.0, 1.0);\n  vec3 LTF = p + vec3(0.0, 1.0, 1.0);\n  vec3 RBF = p + vec3(1.0, 0.0, 1.0);\n  vec3 RTF = p + vec3(1.0, 1.0, 1.0);\n\n  float l0candidate1 = oct(LBZ);\n  float l0candidate2 = oct(RBZ);\n  float l0candidate3 = oct(LTZ);\n  float l0candidate4 = oct(RTZ);\n\n  float l0candidate5 = oct(LBF);\n  float l0candidate6 = oct(RBF);\n  float l0candidate7 = oct(LTF);\n  float l0candidate8 = oct(RTF);\n\n  float l1candidate1 = mix(l0candidate1, l0candidate2, fr[0]);\n  float l1candidate2 = mix(l0candidate3, l0candidate4, fr[0]);\n  float l1candidate3 = mix(l0candidate5, l0candidate6, fr[0]);\n  float l1candidate4 = mix(l0candidate7, l0candidate8, fr[0]);\n\n\n  float l2candidate1 = mix(l1candidate1, l1candidate2, fr[1]);\n  float l2candidate2 = mix(l1candidate3, l1candidate4, fr[1]);\n\n\n  float l3candidate1 = mix(l2candidate1, l2candidate2, fr[2]);\n\n  return -1.0+2.0*l3candidate1;\n} \n\/\/*****************************************************************\n\/\/ by IQ\n\/\/*****************************************************************\n\nfloat fastFBM(vec3 p)\n{\n  vec3 ip=floor(p);\n  p-=ip; \n  vec3 s=vec3(7, 157, 113);\n  vec4 h=vec4(0., s.yz, s.y+s.z)+dot(ip, s);\n  p=p*p*(3.-2.*p); \n  h=mix(fract(sin(h)*43758.5), fract(sin(h+s.x)*43758.5), p.x);\n  h.xy=mix(h.xz, h.yw, p.y);\n  return mix(h.x, h.y, p.z);\n}\n\n\/\/*****************************************************************\n\n\n#define pR(p, a) (p)*=r2(a)\n  mat2 r2(float r) {\n  float c=cos(r), s=sin(r);\n  return mat2(c, s, -s, c);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa, ba)\/dot(ba, ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nvec2 pModPolar(in vec2 p, float repetitions) {\n  float angle = 2.*PI\/repetitions;\n  float a = atan(p.y, p.x) + angle\/2.;\n  float r = length(p);\n  float c = floor(a\/angle);\n  a = mod(a, angle) - angle\/2.;\n  p = vec2(cos(a), sin(a))*r;\n  if (abs(c) >= (repetitions\/2.)) c = abs(c);\n  return p;\n}\n\nfloat pModInterval1(inout float p, float size, float start, float stop)\n{\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)\/size);\n  p = mod(p+halfsize, size) - halfsize;\n  if (c > stop) { \/\/yes, this might not be the best thing numerically.\n    p += size*(c - stop);\n    c = stop;\n  }\n  if (c <start) {\n    p += size*(c - start);\n    c = start;\n  }\n  return c;\n}\n\n\n\nvec4 TraceSpaceClouds( vec3 origin, vec3 direction, int steps)\n{\n  vec4 col = vec4(.7, 0.7, 1., 0.);\n\n  float precis = 0.0, t = 0.0;\n  vec3 rayPos = vec3(0.);\n  vec3 texPos = vec3(0.);\n  float density=0.;\n\n  for ( int i=0; i<steps+min(0, iFrame); i++ )\n  {\n    rayPos =origin+direction*t; \n\n    if (sdSphere(rayPos, 70.)<0.01) break;\n\n    vec3 texPos = (rayPos+vec3(iTime*27.3, iTime*2.3, -iTime*13.3));\n\n    density = pow(fastFBM(texPos*0.002), 4.);\n    density *= pow(fastFBM(texPos*0.007 ), 6.);\n    density *= pow(fastFBM(texPos*0.05), 1.);\n\n    if (density>0.0)\n    {        \n      col.a+=(1.-col.a)*density;\n    }\n\n    if (col.a>0.999) break;\n\n    t+=9.;\n  }\n  return col;\n}\n\n\n\nfloat MapRing(vec3 p, float inRadius, float outRadius, float height)\n{\n  pR(p.xy, 0.15);\n  return max(sdCappedCylinder(p, vec2(outRadius, height)), -sdCappedCylinder(p, vec2(inRadius, 15.)));\n}\n\nvec4 GetRingHitPos( vec3 origin, vec3 direction)\n{\n  float dist = 1000000.;\n  float precis = 0.0, t = 0.0;\n  vec3 rayPos = vec3(0.);\n  for ( int i=0; i<48+min(0, iFrame); i++ )\n  {\n    rayPos =origin+direction*t; \n    dist = MapRing( rayPos, 110., 155., 5.);\n    precis =0.01*t;\n    if (dist<precis || t>500.)\n    {       \n      break;\n    }\n    t+=dist;\n  }\n\n  return vec4(rayPos, dist);\n}\n\nvec4 TraceRing( vec3 origin, vec3 direction, int steps, float scale, float densLimit, float rotSpeed, float inRad, float outRad)\n{\n  vec4 ringColor = vec4(0.12, 0.12, 0.17, 0.);\n  float dist = 1000000.;\n  float precis = 0.0, t = 0.0, density=0., densAdd=0., sunDensity=0.;\n  vec3 rayPos = vec3(0.);\n  vec3 texPos = vec3(0.);\n    float planetDist=10000.;\n  for ( int i=0; i<steps+min(0, iFrame); i++ )\n  {\n    rayPos =origin+direction*t; \n    rayPos.y+=cos((rayPos.x+rayPos.z)*0.23)*.25;\n\n    dist = MapRing( rayPos, inRad, outRad, 3.4);\n    precis =0.001*t;\n    planetDist = sdSphere(rayPos, 70.);\n    dist = min(dist,planetDist);\n      \n    if (dist!=planetDist)\n    {\n\n    texPos = rayPos;\n    pR(texPos.xz, -iTime*rotSpeed);\n    density = pow((fastFBM(texPos*scale)), 8.);\n\n    if (dist<precis && density>densLimit)\n    {       \n      densAdd = 0.35;\n      sunDensity = pow(fastFBM((texPos+sunPos*.7)*scale), 8.); \n      ringColor.rgb += max(0., density-sunDensity)*(1.-ringColor.a)*densAdd*0.8;\n      ringColor.a+=(1.-ringColor.a)*densAdd*0.5;\n    }\n    }\n    if (ringColor.a>0.999) break;\n\n    t+=max(.04, dist);\n  }\n  return ringColor;\n}\n\n#define calcNormal( pos ) normalize( vec3(MapPlanet(pos+vec3(0.02, 0.0, 0.0).xyy).x - MapPlanet(pos-vec3(0.02, 0.0, 0.0).xyy).x, 0.5*2.0*0.02, MapPlanet(pos+vec3(0.02, 0.0, 0.0).yyx).x - MapPlanet(pos-vec3(0.02, 0.0, 0.0).yyx).x ) )\n  #define calcNormalRocks( pos ) normalize( vec3(MapRocks(pos+vec3(0.02, 0.0, 0.0).xyy) - MapRocks(pos-vec3(0.02, 0.0, 0.0).xyy), 0.5*2.0*0.02, MapRocks(pos+vec3(0.02, 0.0, 0.0).yyx) - MapRocks(pos-vec3(0.02, 0.0, 0.0).yyx) ) )\n  #define calcNormalGlobe( pos ) normalize( vec3(sdSphere(pos+vec3(0.02, 0.0, 0.0).xyy, 70.) - sdSphere(pos-vec3(0.02, 0.0, 0.0).xyy, 70.), 0.5*2.0*0.02, sdSphere(pos+vec3(0.02, 0.0, 0.0).yyx, 70.) - sdSphere(pos-vec3(0.02, 0.0, 0.0).yyx, 70.) ) )\n\n  RayHit GetDistancePlanet( vec3 origin, vec3 direction, int steps, float maxDist, inout vec3 hitPos)\n{\n  RayHit result;\n  float dist = 1000000.;\n  float precis = 0.0, t = 0.0;\n  vec3 rayPos;\n\n  for ( int i=0; i<steps+min(0, iFrame); i++ )\n  {\n    rayPos =origin+direction*t; \n    hitPos = rayPos;\n    dist = min(dist, sdSphere(rayPos, 70.));\n    t += dist;\n  }\n\n  result.hit=(dist<1.);\n  result.depth = t; \n  result.dist.x = dist;  \n  result.hitPos = origin+((direction*t)); \n\n  return result;\n}\n\nfloat GetTerrainHeight( vec3 p)\n{   \n  p*=0.0032;\n\n  float terrainHeight =fastFBM(p)*14.; \n  p*=3.0;      \n  pR(p.xz, 3.14);\n  terrainHeight -= fastFBM(p)*10.2;\n  p*=3.0;      \n  pR(p.xz, 3.14);   \n  terrainHeight -= fastFBM(p)*5.2;\n  p*=3.0;      \n  pR(p.xz, 3.14);\n  return terrainHeight - (fastFBM(p)*1.5);\n}\n\nvoid GetPlanetRotation(inout vec3 p)\n{\n  #ifdef ROTATING_PLANET\n    pR(p.xz, (0.08*-iTime));\n  #endif\n}\nvoid GetMoonRotation(inout vec3 p)\n{\n  #ifdef ROTATING_MOON\n    pR(p.xz, 2.65-(0.005*-iTime)); \n  #else\n    pR(p.xz, 2.65);\n  #endif\n}\n\nvec3 GetMoonPosition(vec3 p)\n{\n  vec3 pos = vec3(-430., 180., -430);\n  GetMoonRotation(pos);\n  return pos;\n}\n\n\nvec4 MapPlanet(vec3 p)\n{\n  vec3 moonPos = p-GetMoonPosition(p);\n  vec2 mapPos = PosToSphere(moonPos);\n  float heightMap = -fastFBM((moonPos*0.5)*.4);\n  float moon = sdSphere(moonPos, 40.+heightMap);\n  GetPlanetRotation(p);  \n  mapPos = PosToSphere(p);\n  heightMap = ((GetTerrainHeight(8.*p)*0.35))*textureLod(iChannel3, 2.*mapPos, log2(mapPos.y*2.)).z*1.5;\n  return vec4(min(moon, sdSphere(p, 70.-min(2., (1.-heightMap)))), heightMap, moon, 0.);\n}\n\nRayHit TracePlanet( vec3 origin, vec3 direction, int steps, float maxDist)\n{\n  RayHit result;\n  vec4 dist = vec4(1000000.);\n  float precis = 0.0, t = 0.0;\n  vec3 rayPos;\n\n  for ( int i=0; i<steps+min(0, iFrame); i++ )\n  {\n    rayPos =origin+direction*t; \n    dist = MapPlanet( rayPos);\n    precis =0.00001*t;\n\n    if (dist.x<precis || t>maxDist)\n    {             \n      result.hit=!(t>maxDist);\n      result.depth = t; \n      result.dist = dist;  \n      result.hitPos = origin+((direction*t));    \n      break;\n    }\n\n    t += dist.x*0.55;\n  }\n\n  return result;\n}\n\n\nvoid GetRockRotation(inout vec3 p)\n{\n  pR(p.xy, 0.15); \n  pR(p.xz, -iTime*0.052);\n}\n\nfloat MapRocks(vec3 p)\n{\n  GetRockRotation(p);\n  vec3 checkPos = p;\n  checkPos.xz = pModPolar(checkPos.xz, 230.0);\n  checkPos-=vec3(124, 0., 0.);\n  pModInterval1(checkPos.x, 6., 0., 4.);\n  return sdSphere(checkPos, pow(0.5+noise(p*0.44), 2.)*1.5);\n}\n\nRayHit TraceRocks( vec3 origin, vec3 direction, int steps, float maxDist)\n{\n  RayHit result;\n  float dist = 1000000.;\n  float precis = 0.0, t = 0.0;\n  vec3 rayPos;\n\n  for ( int i=0; i<steps+min(0, iFrame); i++ )\n  {\n    rayPos =origin+direction*t; \n    rayPos.y+=cos((rayPos.x+rayPos.z)*0.23)*.5;\n    dist = MapRocks( rayPos);\n    float planetDist = sdSphere(rayPos, 70.) ;\n    dist=min(dist, planetDist);\n\n    if (dist!=planetDist) \n    {\n      precis =0.001*t;\n\n      if (dist<precis || t>maxDist)\n      {             \n        result.hit=!(t>maxDist);\n        result.depth = t; \n        result.dist.x = dist;  \n        result.hitPos = origin+((direction*t));    \n        break;\n      }\n    }\n\n    t += dist*0.6;\n  }\n\n  return result;\n}\n\n\nfloat GetCloudDensitySimple(vec3 p)\n{\n      vec2 cloudPos = vec2(iTime*.036, 0.006*iTime);\n      vec2 cPos = PosToSphere(p);\n\n      vec3 clouds1 = textureLod(iChannel1, (cPos+cloudPos), 4.0*log2(cPos.y*2.)).rrr+0.25;\n      cPos = PosToSphere(p-vec3(10., 10, 10));\n      vec3 clouds2 = textureLod(iChannel1, (cPos+(0.55*cloudPos)), 4.0*log2(cPos.y*2.)).rgb;\n\n     return pow(clouds1.r*clouds2.g, 2.);\n}\n\n#define calcNormalClouds( pos ) normalize( vec3(GetCloudDensitySimple(pos+vec3(0.02, 0.0, 0.0).xyy) - GetCloudDensitySimple(pos-vec3(0.02, 0.0, 0.0).xyy), 0.5*2.0*0.02, GetCloudDensitySimple(pos+vec3(0.02, 0.0, 0.0).yyx) - GetCloudDensitySimple(pos-vec3(0.02, 0.0, 0.0).yyx) ) )\n \n\nvec4 TraceClouds( vec3 origin, vec3 direction, vec3 skyColor, int steps)\n{ \n  vec4 cloudCol=vec4(.52, 0.31, 0.31, 0.);\n  float density = 0.0, t = .0;\n  vec3 rayPos = vec3(0.);\n  float densAdd=0.;\n  float sunDensity=0.;\n\n  for ( int i=0; i<steps; i++ )\n  {\n    rayPos = origin+direction*t;\n    density = GetCloudDensitySimple(rayPos);          \n\n    if (density>0.001)\n    {    \n      densAdd = density*0.35;\n      sunDensity = GetCloudDensitySimple(rayPos+(sunPos*3.));          \n      cloudCol.rgb += max(0., density-sunDensity)*densAdd;\n      cloudCol.a+=(1.-cloudCol.a)*densAdd*0.4;\n    }\n    if (cloudCol.a > 0.99) break; \n\n    t+=.25;\n  }\n\n  cloudCol.a = clamp(cloudCol.a, 0., 1.);\n  return cloudCol;\n}\n\n\nmat3 setCamera(  vec3 ro, vec3 ta, float cr )\n{\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n  vec3 cu = normalize( cross(cw, cp) );\n  vec3 cv = normalize( cross(cu, cw) );\n  return mat3( cu, cv, cw );\n}\nfloat SoftShadowRing( in vec3 origin, in vec3 direction )\n{\n  float res =1., t = 0.0, h=0.;\n  vec3 rayPos = vec3(origin+direction*t);    \n\n    for ( int i=0; i<10+min(0, iFrame); i++ )\n    {\n      h = MapPlanet(rayPos).x;\n      res = min( res, 8.5*h\/t );\n      t += clamp( h, 0.01, 100.1);\n      if ( h<0.005 ) break;\n      rayPos = vec3(origin+direction*t);\n    }\n  return clamp( res, 0.0, 1.0 );\n}\n\n\nfloat SoftShadow( in vec3 origin, in vec3 direction )\n{\n  float res =1., t = 0.0, h=0.;\n  vec3 rayPos = vec3(origin+direction*t);    \n  #ifdef HIGH_QUALITY\n    for ( int i=0; i<30+min(0, iFrame); i++ )\n  {\n    h = MapPlanet(rayPos).x;\n    #ifdef HIGH_QUALITY_BELT\n    h = min(h, MapRocks(rayPos));\n    #endif\n      \n    res = min( res, 3.5*h\/t );\n    t += clamp( h, 0.01, 250.1);\n    if ( h<0.005 ) break;\n    rayPos = vec3(origin+direction*t);\n  }\n  #else\n    for ( int i=0; i<10+min(0, iFrame); i++ )\n    {\n      h = MapPlanet(rayPos).x;\n      res = min( res, 8.5*h\/t );\n      t += clamp( h, 0.01, 100.1);\n      if ( h<0.005 ) break;\n      rayPos = vec3(origin+direction*t);\n    }\n  #endif\n\n\n    return clamp( res, 0.0, 1.0 );\n}\n\n\nvec3 GetLight(float specLevel, vec3 normal, RayHit rayHit, vec3 rayDir, vec3 origin, float illuminance)\n{                \n  vec3 reflectDir = reflect( rayDir, normal );\n  vec3 shadowPos = origin+((rayDir*rayHit.depth)*0.98);\n\n  vec3 lightTot = vec3(0.0);\n  float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );\n  float dif = clamp( dot( normal, sunPos ), 0.0, 1.0 );\n  float dif2 =max(0., dot( normal, normalize(vec3(1.5, 0., -3.5)) ));\n\n  float fre = clamp(1.0+dot(normal, rayDir), 0.0, 1.0);\n  specLevel*= pow(clamp( dot( reflectDir, sunPos ), 0.0, 1.0 ), 2.0);\n  float skylight = smoothstep( -0.1, 0.1, reflectDir.y );\n\n  float shadow=1.;\n  #ifdef SHADOWS\n    shadow = SoftShadow(shadowPos, sunPos);\n  dif*=shadow;\n  #endif\n\n    const vec3 sunColor = vec3(1.1, 1.1, 1.1); \n  lightTot += 2.*dif*sunColor;\n  lightTot +=0.5*dif2*vec3(.6, .35, 1.5);\n  lightTot += 1.0*amb*vec3(0.2, 0.25, 0.4);  \n  lightTot += 0.40*skylight*vec3(0.4, 0.6, 1.0);\n  lightTot += 2.*specLevel*vec3(1., 0.85, 0.75)*dif;  \n  fre = pow( 1.0-abs(dot(rayHit.normal, rayDir)), 3.0);\n  lightTot = mix( lightTot, lightTot*2.5, fre );\n\n  return clamp(lightTot, 0.1, 10.);\n}\n\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{  \n  vec2 uv = fragCoord.xy \/ iResolution.xy;\n  vec2 screenSpace = (-iResolution.xy + 2.0*(fragCoord))\/iResolution.y;\n\n  sunPos =  readRGB(ivec2(50, 0));\n\n  \/\/ setup camera and ray direction\n  vec2 camRot = readRGB(ivec2(57, 0)).xy;\n  vec3 rayOrigin =readRGB(ivec2(62, 0));\n  mat3 ca = setCamera( rayOrigin, vec3(0., 0., 0.), 0.0 );\n  vec3 rayDir = ca * normalize( vec3(screenSpace.xy, 2.0) );\n\n\n  \/\/ create sky color fade\n  vec4 color = texture(iChannel0, uv);\n  color.a=0.;\n\n  vec3 hitPos = vec3(0.);\n  RayHit plametDistResult = GetDistancePlanet(rayOrigin, rayDir, 32, 400., hitPos);\n\n\n  RayHit marchResult = TracePlanet(rayOrigin, rayDir, 200, 1000.);\n\n  \/\/ is terrain hit?\n  if (marchResult.hit)\n  { \n\n    vec3 col= vec3(0.); \n\n    \/\/ moon hit\n    if (length(marchResult.dist.x-marchResult.dist.z)<0.05)\n    {\n      vec3 pp = marchResult.hitPos;\n      GetMoonRotation(pp);\n\n      vec2 texPos = PosToSphere(pp);\n      vec4 tex = textureLod(iChannel1, texPos*2., log2(texPos.y*2.));\n      col = tex.rgb;\n      marchResult.normal = calcNormal(marchResult.hitPos); \n      vec3 light = GetLight(1., marchResult.normal, marchResult, rayDir, rayOrigin, 0.0)*0.35;   \n      col = (col*light)+vec3(0.1, 0., 0.1);\n    }\n    \/\/ planet hit\n    else\n    {\n      vec3 pp = marchResult.hitPos;     \n      GetPlanetRotation(pp);\n\n      float specLevel = 1.;\n      if (marchResult.dist.y>-0.5) \/\/ land\n      {\n        vec2 texPos = PosToSphere(pp);\n        vec3 tex = textureLod(iChannel1, 2.*texPos, log2(texPos.y*2.)).rgb;\n\n        col = vec3(1., 0.32, 0.2)*tex;\n\n        col=mix(tex.rgb*vec3(0.9, 0.8, 0.76)*0.3, vec3(.29, 0.1, 0.1)*2.25*(0.6+(tex)), smoothstep(-0.83, -.10, marchResult.dist.y));\n        col=mix(col, vec3(.5, 0.3, 0.3), smoothstep(-.10, .39, marchResult.dist.y));\n        col*=0.5;\n        marchResult.normal = calcNormal(marchResult.hitPos);\n      } else   \/\/ liqid\n      {  \n        specLevel=4.;\n        col=mix(vec3(0.2, 0., 0.)*0.23, vec3(0.2, 0., 0.)*1.15, smoothstep(-1.615, .15, marchResult.dist.y));\n\n        marchResult.normal = calcNormalGlobe(marchResult.hitPos)+(0.2*fastFBM((pp*6.+vec3(iTime*0.4))));\n      } \n\n      vec3 light = GetLight(specLevel, marchResult.normal, marchResult, rayDir, rayOrigin, 0.0);   \n      col = col*light;   \n\n      float sunDot = dot( marchResult.normal, sunPos);\n\n      #ifdef CLOUDS\n      plametDistResult.normal = calcNormalGlobe(plametDistResult.hitPos);\n      float sunAmount = 0.15+(0.85*max(0., dot( plametDistResult.normal, sunPos )));\n\n      #ifdef QUALITY_CLOUDS\n        vec4 cloudColor=TraceClouds(rayOrigin+((rayDir*plametDistResult.depth)*0.97), rayDir, vec3(.3), 30);   \n      col.rgb = mix(col.rgb, col+(cloudColor.rgb*sunAmount)*0.5, smoothstep(0.24, 0.37, cloudColor.a*cloudColor.a));\n      #endif\n\n     float cloudDensity = GetCloudDensitySimple(plametDistResult.hitPos);\n     vec3 cloudNormal = calcNormalClouds(plametDistResult.hitPos);\n\n        float cDif = max(0.,dot(cloudNormal, sunPos));\n           col.rgb += mix(0., (0.2+cDif)*max(0., dot( plametDistResult.normal, sunPos )), smoothstep(0.15, 0.45, cloudDensity));   \n      #endif\n\n        \/\/ add atmosphere\n        float fre = 0.5+max(0., (0.5*(1.0+dot(marchResult.normal, rayDir))));\n      col= mix(col, vec3(.6, 0.7, .9)*2.5, pow(fre, 6.0)*max(0.62, sunDot));\n    }\n\n    color.rgb = col; \n    color.a+=1.;\n  } \n\n  if (!marchResult.hit || length(marchResult.dist.x-marchResult.dist.z)<0.05)\n  { \n    vec3 nPos = rayDir;\n\n    color.rgb = mix(vec3(.3, .4, .6), color.rgb, smoothstep(-6., 7., plametDistResult.dist.x));\n\n    color.rgb = mix(mix(color.rgb+vec3(2.), color.rgb, smoothstep(-0., 0.50, plametDistResult.dist.x)), color.rgb, step(1., plametDistResult.dist.x));\n\n    pR(nPos.xy, iTime*0.016);\n    pR(nPos.zx, iTime*0.01);\n    float atNoise = max(0., noise((nPos*13.)*1.75));\n\n    color.rgb = mix(color.rgb+vec3(.2, 0.45, .642), color.rgb, pow(smoothstep(-2., 20., plametDistResult.dist.x+(22.*atNoise)), .50));\n  }\n\n\n  vec3 background = color.rgb;\n\n  \/\/ get distance to ring bounding shape. Only draw content of ring if raytrace hit the ring. VEC4(hitpos.xyz,distance)\n  vec4 ringHitPos = GetRingHitPos(rayOrigin, rayDir);\n\n  float shadow =1.;\n\n  #ifdef SHADOWS\n    shadow = max(0.5, SoftShadowRing(ringHitPos.xyz, sunPos));\n  #endif\n\n    #ifdef HIGH_QUALITY_BELT\n    \/\/ trace rock belt\n    RayHit rockMarch = TraceRocks(rayOrigin, rayDir, 100, 500.);   \n\n  \/\/ is rock belt hit?\n  if (rockMarch.hit)\n  { \n    vec3 pp = rockMarch.hitPos;\n    GetRockRotation(pp);\n\n    vec3 rockCol= vec3(0.5)+(0.4*abs(noise(pp*3.))); \n    rockMarch.normal = calcNormalRocks(rockMarch.hitPos); \n    vec3 rockLight = GetLight(1., rockMarch.normal, rockMarch, rayDir, rayOrigin, 0.0)*0.4; \n    rockCol = rockCol*rockLight;\n    \/\/rockCol = mix(rockCol,mix(rockCol,rockCol+background,0.35),smoothstep(100.,500.,rockMarch.depth));  \n    color.rgb = rockCol;\n  }\n  #endif \n\n    \/\/vec3 origin, vec3 direction, int steps, float scale, float densLimit, float rotSpeed, float inRad, float outRad)\n\n    vec4 ringColor = TraceRing(rayOrigin, rayDir, 40, 1.1, .15, 0.04, 120., 150.);    \n  color.rgb =mix( color.rgb, clamp(ringColor.rgb*shadow, 0., 0.8), ringColor.a );   \n\n  ringColor = TraceRing(rayOrigin, rayDir, 40, 1.65, 0.12, 0.06, 120., 150.);      \n  color.rgb =mix( color.rgb, clamp(ringColor.rgb*shadow, 0., 0.8), ringColor.a );\n\n  ringColor = TraceRing(rayOrigin, rayDir, 30, 1., 0.12, 0.07, 120., 145.);      \n  color.rgb =mix( color.rgb, clamp(ringColor.rgb*shadow, 0., 0.8), ringColor.a );\n\n\n  #ifdef SPACE_CLOUDS\n  vec4 cColor = TraceSpaceClouds(rayOrigin, rayDir, 90);      \n  color.rgb =mix( color.rgb, cColor.rgb, cColor.a );  \n  #endif\n\n  fragColor = color;\n}\n","name":"Buf C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"\/media\/previz\/buffer03.png","previewfilepath":"\/media\/previz\/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ AA BUFFER -    REMOVES NOISE\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\n#define readRGB(memPos) (  texelFetch(iChannel2, memPos, 0).rgb)\n\/\/#pragma optimize(off) \n\n#define PERFORM_AA_PASS\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n      vec2 uv = fragCoord.xy \/ iResolution.xy;\n  vec2 screenSpace = (-iResolution.xy + 2.0*(fragCoord))\/iResolution.y;\n  vec4 color = textureLod(iChannel0, uv,0.);\n\n    \n #ifdef PERFORM_AA_PASS\n    \/\/ Perform AA pass\n    if( iFrame>0) \n    {\n            \/\/ if the camera is kept steady, switch to fine AA pass.\n            if(length(readRGB(ivec2(62, 0))-readRGB(ivec2(60, 0)))>0.)           \n       {\n            \/\/ better for moving cameras\n            vec3 oldColor = textureLod(iChannel1, uv,1.0).rgb;\n            color.rgb = mix(color.rgb,oldColor,0.2);\n       }      \n            else\n            {\n                  \/\/ good for static camera\n             vec3 oldColor = texelFetch(iChannel1, ivec2(fragCoord-0.5), 0 ).rgb;\n            color.rgb = mix( oldColor, color.rgb, 0.5 );\n            }\n    }   \n  #endif\n    \n    fragColor = color;\n}","name":"Buf D","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"lllBRn","date":"1510814867","viewed":2417,"name":"Tower Of Light","username":"ingagard","description":"Please read instructions under the \"Image\" tab for full controls and optimization. \n\nMANY FEATURES ARE DISABLED. PLEASE ENABLE THE DEFINES TO SEE ALL FEATURES. Thanks!\n\nhttps:\/\/youtu.be\/pKY_-Kgs_1Q\nhttps:\/\/youtu.be\/_Kh7GcYLM3I\n\n","likes":66,"published":3,"flags":112,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"\/media\/previz\/buffer03.png","previewfilepath":"\/media\/previz\/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"MsSSzz","filepath":"https:\/\/soundcloud.com\/musa-muh-nur\/nature-sounds-beautiful","previewfilepath":"https:\/\/soundcloud.com\/musa-muh-nur\/nature-sounds-beautiful","type":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Copyright \u00a9 2017 Kim Berkeby (email: mr.kimb@hotmail.com)\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/*\n Youtube version of the shader (great thanks to Adrian Chlubek, aka afl_ext):\n\n https:\/\/youtu.be\/pKY_-Kgs_1Q\n https:\/\/youtu.be\/_Kh7GcYLM3I\n\n CONTROLS:\n ---------\n Hold left mouse button and move mouse to pitch and rotate camera.\n  \n D     ZOOM OUT\n E     ZOOM IN\n\nF1     ZOOM OUT (alternative)\nF2     ZOOM IN  (alternative)\n\n R     CAMERA UP\n F     CAMERA DOWN\n  \n\n Notice:\n If you want to invert the mouse look, please enable #define INVERT_MOUSE_Y in Buf A.\n\n\n Toggle effects by pressing folloving keys:\n ------------------------------------------\n\n 2-key  = Grain filter  on\/off                   (default on)\n 3-key  = Chromatic aberration  on\/off           (default on)    \n 4-key  = God Rays  on\/off                       (default on)\n 5-key  = Lens flare  on\/off                     (default on)\n\n ---------------------------------------------------------------------------------\n *********************************************************************************\n\n MANY FEATURES ARE DISABLED. PLEASE ENABLE THE DEFINES TO SEE ALL FEATURES. Thanks!\n\n *********************************************************************************\n ---------------------------------------------------------------------------------\n \n\n TO INCREASE PERFORMANCE OR VIEW:\n --------------------------------\n  \n  Delete one or several defines from Buf C:\n \n  #define TERRAIN   (removing this will make the shader ONLY render the tower model)\n  #define TREES\n  #define QUALITY_REFLECTIONS\n  #define QUALITYFOLIAGE\n  #define GRASS\n  #define SHADOWS\n  #define PERFORM_AO_PASS\n  #define BRIDGE\n  #define BOAT\n\n  Delete one or several defines from Buf D:\n \n  #define PERFORM_AO_PASS\n  #define PERFORM_AA_PASS    (deleting this will cause a lot of noise)\n  #define SHADOWS\n\n --------------------------------------------------------\n \n This shader was made by using distance functions found in HG_SDF:\n http:\/\/mercury.sexy\n \n Special thanks to Inigo Quilez for his great tutorials on:\n https:\/\/iquilezles.org\/\n\n Music by Muse Muh Nur:\n https:\/\/soundcloud.com\/musa-muh-nur\/nature-sounds-beautiful\n\n Last but not least, thanks to all the nice people here at ShaderToy! :-D\n\n*\/\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ POST EFFECTS BUFFER\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Channel 0 = Buffer A. Read data from data-buffer.\n\/\/ Channel 1 = LowRes noise texture. Used in fast noise functions.\n\/\/ Channel 2 = Buffer C. Get the colors of the render from the last buffer.\n\/\/ Channel 3 = Music ( https:\/\/soundcloud.com\/musa-muh-nur\/nature-sounds-beautiful )\n\n  #define FastNoise(posX) (  textureLod(iChannel1, (posX+0.5)\/iResolution.xy, 0.0).r)\n  #define readAlpha(memPos) (  textureLod(iChannel2, memPos, 0.0).a)\n  #define read(memPos) (  texelFetch(iChannel0, memPos, 0).a)\n  #define readRGB(memPos) (  texelFetch(iChannel0, memPos, 0).rgb)\n  #define PI acos(-1.)\n  #pragma optimize(off) \n\nmat3 cameraMatrix;\n\nvec3 sunPos=vec3(0.);\n\nfloat CalcSum(vec2 uvPos) \n{\n    vec4 col = textureLod(iChannel2, uvPos,0.);\n    float sum = (col.r+col.g+col.b)*0.333;\n    return mix(0.,sum,step(0.75,sum-col.a));\n}\n\n#define VOLUMESAMPLES 24\nfloat GetVolumetrics(vec2 pos, vec2 uv)\n{\n    float sum \t = 0.;\n    float weight = 1. \/ float(VOLUMESAMPLES);\n    vec2 dir = pos-uv;\n    \n    for(int i = 0; i < VOLUMESAMPLES; i++)\n    {\n        sum += CalcSum(uv);\n        uv += dir * .036;\n    }\n    \n    return sum * weight * 0.4;\n}\n\nmat3 setCamera(  vec3 ro, vec3 ta, float cr )\n{\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n  vec3 cu = normalize( cross(cw, cp) );\n  vec3 cv = normalize( cross(cu, cw) );\n  return mat3( cu, cv, cw );\n}\n\nvec2 GetScreenPos(vec3 pos)\n{\n  return vec2(PI*dot( pos, cameraMatrix[0].xyz ), PI* dot( pos, cameraMatrix[1].xyz ));\n}\n\nvec3 CalculateSunFlare(vec3 rayDir, vec3 rayOrigin, vec2 screenSpace, float alpha, float enableFlare)\n{\n\n  float visibility = pow(max(0., dot(sunPos, rayDir)), 5.0);  \n  if (visibility<=0.006) return vec3(0.);\n  vec2 sunScreenPos = GetScreenPos(sunPos);\n\n  vec2 uvT = screenSpace-sunScreenPos;\n  float sunIntensity = (1.0\/(pow(length(uvT)*4.0+1.0, 1.30)))*visibility;\n\n  vec3 flareColor = vec3(0.);\n  vec2 offSet = uvT;\n  vec2 offSetStep=  0.4*sunScreenPos;\n  vec3 color;\n  float size=.0, dist=0.;\n  \n  if(enableFlare>0.)\n  {\n  \/\/ check if center of sun is covered by any object. MATH IS OFF AT SCREEN CHECK POS! sunScreenPos\/2.0 +0.5 IS NOT EXACTLY SUN MIDDLE!\n  \/\/ only draw if not covered by any object\n  if (readAlpha( sunScreenPos\/2.0 +0.5)<0.50)\n  {\n    \/\/ create flare rings\n    for (float i =1.; i<8.; i++)\n    {\n      color.rg = vec2(abs((sin(i*53.))), 0.65);\n      color.b = abs((cos(i*25.)));\n      offSet += offSetStep;\n\n      size = 0.05+((1.-sin(i*0.54))*0.28);\n      dist = pow(length(sunScreenPos-offSet), 1.20);\n\n      flareColor += mix(vec3(0.), sunIntensity*(10.*size) * color, smoothstep(size, size-dist, dist))\/(1.0-size);\n    }\n\n      flareColor = mix(flareColor,flareColor*.1, max(0.,visibility));\n  flareColor += (vec3(1.0, .0, .0)  * pow(visibility, 1.)*.5);\n  }\n  flareColor*=mix(2., .2, smoothstep(0., 1., visibility)); \n\n  \n  }\n    \n  \/\/ flare star shape\n  vec3 sunSpot = vec3(1.30, 1., .80)*sunIntensity*(sin(FastNoise((sunScreenPos.x+sunScreenPos.y)*2.3+atan(uvT.x, uvT.y)*15.)*5.0)*.12);\n  \/\/ sun glow\n  sunSpot+=vec3(1.0, 0.96, 0.90)*sunIntensity*.75;\n  sunSpot+=vec3(1.0, 0.76, 0.20)*visibility*0.245;\n    \n  return flareColor+(sunSpot*(1.0-alpha));\n}\n\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{  \n  vec2 uv = fragCoord.xy \/ iResolution.xy;\n  vec2 screenSpace = (-iResolution.xy + 2.0*(fragCoord))\/iResolution.y;\n\n  \/\/ read values from buffer\n  vec3 effects = readRGB(ivec2(120, 0));  \n  vec3 effects2 = readRGB(ivec2(122, 0)); \n  float turn = read(ivec2(1, 10));\n  sunPos = readRGB(ivec2(50, 0));\n  \/\/ setup camera and ray direction\n  vec2 camRot = readRGB(ivec2(57, 0)).xy;\n  vec3 camData  = readRGB(ivec2(52, 0));  \n\n  vec3 rayOrigin = vec3(camData.z*cos(camRot.x), camData.y,camData.z*sin(camRot.x) );\n     rayOrigin.y = readRGB(ivec2(62, 0)).y;\n    cameraMatrix  = setCamera( rayOrigin, vec3(0., camData.y+(11.*camRot.y), 0. ), 0.0 );\n  vec3 rayDir = cameraMatrix * normalize( vec3(screenSpace.xy, 2.0) );\n\n  vec2 d = abs((uv - 0.5) * 2.0);\n  d = pow(d, vec2(2.0, 2.0));\n  float minDist = -1000.0;\n\n\n  vec4 color;\n\n  \/\/ chromatic aberration?\n  if (effects.z>0.)\n  {\n    vec2 offSet = (uv.xy*2.-1.)\/iResolution.xy*1.5;\n    color.rgb = vec3(texture(iChannel2, uv + offSet).r, texture(iChannel2, uv).g, texture(iChannel2, uv - offSet).b);\n    \n  }\n  \/\/ no chromatic aberration \n  else\n  {\n      color.rgb = texture(iChannel2, uv).rgb;\n  }\n\n  color.a=textureLod(iChannel2, uv, 0.).a;\n\n  \/\/ add sun with lens flare effect\n  color.rgb += CalculateSunFlare(rayDir, rayOrigin, screenSpace, clamp(color.a, 0., 1.0),effects2.x);\n\n  \/\/ grain noise\n  if (effects.y>0.)\n  {\n    vec2 grainTexPos = ((fragCoord.xy + iTime*60.0*vec2(10, 35.))*0.6)\/iChannelResolution[0].xy;\n    vec2 filmNoise = textureLod( iChannel1, grainTexPos, 0. ).rb;\n  }\n\n  if (effects2.y>0.)\n  {\n    \/\/ perform volumetric light ray pass if looking into the sun\nfloat sunVisibility = max(0.,dot(sunPos, rayDir));\n    if(sunVisibility>0.)\n    {\n          vec2 sunScreenPos = GetScreenPos(sunPos);\n           color.rgb += mix(0.,GetVolumetrics(sunScreenPos\/2.0 +0.5, uv),pow(sunVisibility,6.));\n    }\n  } \n    \n  fragColor =  vec4(pow(color.rgb, vec3(1.0\/1.1)), 1.0 ) * (0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.32 ));\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdXGzn","filepath":"\/media\/a\/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"\/media\/ap\/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"\/presets\/tex00.jpg","previewfilepath":"\/presets\/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"\/media\/a\/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"\/media\/ap\/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ DATA BUFFER  -  CAMERA CONTROL AND KEYBOARD CHECKS\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Channel 0 = Keyoard input. Used to capture key-presses.\n\/\/ Channel 1 = LowRes noise texture. Used in fast noise functions.\n\/\/ Channel 2 = This buffer (A). Read and write data to update this shader.\n\/\/ Channel 3 = Lichen texture. Used to create landscape height map and textures.\n  #pragma optimize(off) \n  #define keyClick(ascii)   ( texelFetch(iChannel0, ivec2(ascii, 0), 0).x > 0.)\n  #define keyPress(ascii)   ( texelFetch(iChannel0, ivec2(ascii, 1), 0).x > 0.)\n  #define read(memPos) (  texelFetch(iChannel2, memPos, 0).a)\n  #define readRGB(memPos) (  texelFetch(iChannel2, memPos, 0).rgb)\n  \/\/#define INVERT_MOUSE_Y \n\n  \/\/ R    CAM UP\n  #define UP_KEY 82     \n  \/\/ F    CAM DOWN\n  #define DOWN_KEY 70      \n  \/\/ D     ZOOM OUT\n  #define ZOOMOUT_KEY 68\n  \/\/ E     ZOOM IN\n  #define ZOOMIN_KEY 69\n  \/\/ F1     ZOOM OUT (alternative)\n  #define ZOOMOUT_KEY_ALT 112\n  \/\/ F2     ZOOM IN (alternative)\n  #define ZOOMIN_KEY_ALT 113\n\n\n\/\/ noise functions by IQ (somewhat modified to fit my usage)\nfloat noise2D( in vec2 pos, float lod)\n{   \n  vec2 f = fract(pos);\n  f = f*f*(3.0-2.0*f);\n  vec2 rg = textureLod( iChannel1, (((floor(pos).xy+vec2(37.0, 17.0)) + f.xy)+ 0.5)\/64.0, lod).yx;  \n  return -1.0+2.0*mix( rg.x, rg.y, 0.5 );\n}\nfloat noise2D( in vec2 pos )\n{\n  return noise2D(pos, 0.0);\n}\nfloat fastFBM(vec3 p)\n{\n  vec3 ip=floor(p);\n  p-=ip; \n  vec3 s=vec3(7, 157, 113);\n  vec4 h=vec4(0., s.yz, s.y+s.z)+dot(ip, s);\n  p=p*p*(3.-2.*p); \n  h=mix(fract(sin(h)*43758.5), fract(sin(h+s.x)*43758.5), p.x);\n  h.xy=mix(h.xz, h.yw, p.y);\n  return mix(h.x, h.y, p.z);\n}\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\nfloat GetTerrainHeight( vec3 p)\n{\n  vec2 p2 = (p.xz)*0.0005;\n\n  float mainHeight = -2.3+fastFBM(p*0.025)*max(11., abs(22.*noise2D(p2))); \n  float terrainHeight=mainHeight;\n  p2*=4.0;\n  terrainHeight += textureLod( iChannel3, p2, 2.7 ).x*1.; \n  p2*=2.0;\n  terrainHeight -= textureLod( iChannel3, p2, 1.2 ).x*.7;\n  p2*=3.0;\n  terrainHeight -= textureLod( iChannel3, p2, 0.5 ).x*.1;\n\n  terrainHeight=mix(terrainHeight, mainHeight*1.4, smoothstep(1.5, 3.5, terrainHeight)); \n  terrainHeight=mix(-0.6, terrainHeight, smoothstep(200., 240., length(p.xz-vec2(0., 120.))));\n  terrainHeight=mix(-0.6, terrainHeight, smoothstep(250., 300., length(p.xz-vec2(100., -100.))));\n\n  return   terrainHeight*1.4;\n}\n\n\nvoid ToggleEffects(inout vec4 fragColor, vec2 fragCoord)\n{\n  \/\/ read and save effect values from buffer  \n  vec3 effects =  mix(vec3(-1.0, 1.0, -1.0), readRGB(ivec2(120, 0)), step(1.0, float(iFrame)));\n  effects.y*=1.0+(-2.*float(keyPress(50))); \/\/2-key  Grain Filter\n  effects.z*=1.0+(-2.*float(keyPress(51))); \/\/3-key  ChromaticAberration\n\n  vec3 effects2 =  mix(vec3(1.0, 1.0, 1.0), readRGB(ivec2(122, 0)), step(1.0, float(iFrame)));\n  effects2.y*=1.0+(-2.*float(keyPress(52))); \/\/4-key  God Rays\n  effects2.x*=1.0+(-2.*float(keyPress(53))); \/\/5-key  lens flare\n\n  fragColor.rgb = mix(effects, fragColor.rgb, step(1., length(fragCoord.xy-vec2(120.0, 0.0))));  \n  fragColor.rgb = mix(effects2, fragColor.rgb, step(1., length(fragCoord.xy-vec2(122.0, 0.0))));\n}\n\nmat3 setCamera(  vec3 ro, vec3 ta, float cr )\n{\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n  vec3 cu = normalize( cross(cw, cp) );\n  vec3 cv = normalize( cross(cu, cw) );\n  return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{ \n  const vec3 offSet = vec3(-143, 0., 292);\n  vec2 mo = iMouse.xy\/iResolution.xy;\n  vec2 uv = fragCoord.xy \/ iResolution.xy;\n  vec2 screenSpace = (-iResolution.xy + 2.0*(fragCoord))\/iResolution.y;\n\n  vec3 sunPos = mix(normalize( vec3(1.730, 0.13, .700) ), readRGB(ivec2(50, 0)), step(1.0, float(iFrame)));\n  vec3 camData = mix(vec3(0., 7., 68.), readRGB(ivec2(52, 0)), step(1.0, float(iFrame)));  \n  vec2 camRot = mix(vec2(4.73, 0.), readRGB(ivec2(57, 0)).xy, step(1.0, float(iFrame))); \n  vec3 oldOrigin = readRGB(ivec2(62, 0));\n    \n  if (iMouse.z>0.)\n  {\n    \/\/ setup camera and ray direction\n    camRot.x=(mo.x*12.); \n    #ifdef INVERT_MOUSE_Y \n      camRot.y=6.-((mo.y)*12.);\n#else\n  camRot.y=-6.+((mo.y)*12.);\n#endif\n}\ncamRot.y = clamp(camRot.y, -3., 3.);\n\n\nToggleEffects(fragColor, fragCoord);\n\ncamData.z-=0.3*float(keyClick(ZOOMIN_KEY) || keyClick(ZOOMIN_KEY_ALT));\ncamData.z+=0.3*float(keyClick(ZOOMOUT_KEY) || keyClick(ZOOMOUT_KEY_ALT));\ncamData.z=clamp(camData.z, 4., 100.);\n\n\ncamData.y+=0.3*float(keyClick(UP_KEY));\ncamData.y-=0.3*float(keyClick(DOWN_KEY));\ncamData.y=clamp(camData.y, 6., 30.);\n\n\/\/ adding a small amount of camRot.y just to check if the camera has been moved in ANY way when later doing AA pass\nvec3 rayOrigin = vec3(offSet.x+camData.z*cos(camRot.x), camData.y+(0.0001*camRot.y), offSet.z+camData.z*sin(camRot.x) );    \nmat3 ca = setCamera( rayOrigin, vec3(0., camData.y+(11.*camRot.y), 0. ), 0.0 );\nvec3 rayDir = ca * normalize( vec3(screenSpace.xy, 2.0) );\n                    \n\/\/ prevent camera from going below terrain\nfloat groundH = GetTerrainHeight(rayOrigin)+3.;   \nrayOrigin.y= max(rayOrigin.y, groundH);\ncamData.y = max(camData.y, groundH);\n\nfragColor.rgb = mix(sunPos, fragColor.rgb, step(1., length(fragCoord.xy-vec2(50.0, 0.0))));\nfragColor.rgb = mix(camData, fragColor.rgb, step(1., length(fragCoord.xy-vec2(52.0, 0.0))));\nfragColor.rgb = mix(rayOrigin, fragColor.rgb, step(1., length(fragCoord.xy-vec2(62.0, 0.0))));\nfragColor.rgb = mix(oldOrigin, fragColor.rgb, step(1., length(fragCoord.xy-vec2(60.0, 0.0))));\n        \nfragColor.rgb = mix(vec3(camRot.xy, 0.), fragColor.rgb, step(1., length(fragCoord.xy-vec2(57.0, 0.0))));\n}\n","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"XdXGzn","filepath":"\/media\/a\/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"\/media\/ap\/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"\/media\/a\/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"\/media\/ap\/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"\/media\/a\/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"\/media\/ap\/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ TERRAIN BUFFER  -   RENDERS TERRAIN AND BRIDGE\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Channel 0 = Fine noise texture. Used in noise functions.\n\/\/ Channel 1 = LowRes noise texture. Used in fast noise functions.\n\/\/ Channel 2 = Buffer A. Read data from data-buffer.\n\/\/ Channel 3 = Lichen texture. Used to create landscape height map and textures.\n#define read(memPos) (  texelFetch(iChannel2, memPos, 0).a)\n#define readRGB(memPos) (  texelFetch(iChannel2, memPos, 0).rgb)\n#define PI 3.14159265359\n#define saturate(x) clamp(x, 0., 1.)\n#pragma optimize(off) \n#define NO_UNROLL(X) (X + min(0,iFrame))\n\n\/\/ Delete one or several of below defines to increase performance\n#define TERRAIN \n#define TREES\n#define QUALITY_REFLECTIONS\n#define QUALITYFOLIAGE\n#define GRASS\n#define SHADOWS\n\/\/#define PERFORM_AO_PASS\n#define BRIDGE\n\/\/#define BOAT\n\/\/#define ACCURATE_BOAT_REFLECTION\n\n\/\/ Try enabling below define if shader doesn\u00b4t compile\n\/\/#define LOWRES_TEXTURES\n\nfloat hash(float h)\n{\n  return fract(sin(h) * 43758.5453123);\n} \n\nstruct RayHit\n{\n  bool hit;  \n  vec3 hitPos;\n  vec3 normal;\n  vec4 dist;\n  float treeDist;\n  float depth;\n};\n\n    \nfloat treeDist;\nvec2 cloudPos=vec2(0.);\nvec3 wind=vec3(0.);\nvec3 sunPos=vec3(0.);\n\n\n\/\/ noise functions by IQ (somewhat modified to fit my usage)\nfloat noise(vec3 x) \n{\n  vec3 p = floor(x);\n  vec3 f = fract(x);\n  f = f * f * (3.0 - 2.0 * f);\n\n  float n = p.x + p.y * 157.0 + 113.0 * p.z;\n  return -1.0+2.0*mix(\n    mix(mix(hash(n + 0.0), hash(n + 1.0), f.x), \n    mix(hash(n + 157.0), hash(n + 158.0), f.x), f.y), \n    mix(mix(hash(n + 113.0), hash(n + 114.0), f.x), \n    mix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\n\n#define addPos vec2(1.0, 0.0)\n\nfloat noise2D( in vec2 pos, float lod)\n{   \n  vec2 f = fract(pos);\n  f = f*f*(3.0-2.0*f);\n  vec2 rg = textureLod( iChannel1, (((floor(pos).xy+vec2(37.0, 17.0)) + f.xy)+ 0.5)\/64.0, lod).yx;  \n  return -1.0+2.0*mix( rg.x, rg.y, 0.5 );\n}\n\nfloat noise2D( in vec2 pos )\n{\n  return noise2D(pos, 0.0);\n}\n\nfloat terrainNoise(vec2 p)\n{\n  vec3 p3  = fract(vec3(p.xyx) * .1031);\n  p3 += dot(p3, p3.yzx + 19.19);\n  return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise( in vec2 x )\n{\n  vec2 p = floor(x);\n  vec2 f = fract(x);\n  f = f*f*(3.0-2.0*f);\n\n  float res = mix(mix( terrainNoise(p), terrainNoise(p + addPos.xy), f.x), \n    mix( terrainNoise(p + addPos.yx), terrainNoise(p + addPos.xx), f.x), f.y);\n  return res;\n}\nfloat fastFBM(vec3 p)\n{\n  vec3 ip=floor(p);\n  p-=ip; \n  vec3 s=vec3(7, 157, 113);\n  vec4 h=vec4(0., s.yz, s.y+s.z)+dot(ip, s);\n  p=p*p*(3.-2.*p); \n  h=mix(fract(sin(h)*43758.5), fract(sin(h+s.x)*43758.5), p.x);\n  h.xy=mix(h.xz, h.yw, p.y);\n  return mix(h.x, h.y, p.z);\n}\n\n#define pR(p, a) (p)*=r2(a)\nmat2 r2(float r) {\n  float c=cos(r), s=sin(r);\n  return mat2(c, s, -s, c);\n}\n\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  return (length( p\/r ) - 1.0) * min(min(r.x, r.y), r.z);\n}\n#define GetHorizon(p) sdEllipsoid(p, vec3(1000., 50., 1000.))\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\nfloat sdConeSection( vec3 p, float h, float r1, float r2 )\n{\n  float d1 = -p.y - h;\n  float q = p.y - h;\n  float si = 0.5*(r1-r2)\/h;\n  float d2 = max( sqrt( dot(p.xz, p.xz)*(1.0-si*si)) + q*si - r2, q );\n  return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.);\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\nfloat fCylinder(vec3 p, float r, float height) {\n  float d = length(p.xy) - r;\n  d = max(d, abs(p.z) - height);\n  return d;\n}\n\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)\/size);\n  p = mod(p+halfsize, size) - halfsize;\n  if (c > stop) { \/\/yes, this might not be the best thing numerically.\n    p += size*(c - stop);\n    c = stop;\n  }\n  if (c <start) {\n    p += size*(c - start);\n    c = start;\n  }\n  return c;\n}\n\n\/\/ Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)\/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n\nfloat GetCloudHeightBelow(vec3 p)\n{         \n  vec3 p2 = (p*0.00015)+vec3(-iTime*0.0013, 0., -iTime*0.00165);\n\n  float i =-0.6+(textureLod(iChannel0,p2,0.50).r*1.5); \n  p2*=1.52;\n  i +=(-1.0+2.0*textureLod(iChannel0,p2,0.40).g)*0.5; \n  p2*=2.53;\n  i += (-1.0+2.0*textureLod(iChannel0,p2,0.30).b)*.25; \n  p2*=2.51;\n  i -= (-1.0+2.0*textureLod(iChannel0,p2,0.20).r)*0.12;\n\n  return i-0.1;\n}\n\nvec4 TraceCloudsBelow( vec3 origin, vec3 direction, vec3 skyColor, int steps)\n{ \n\n  const vec3 sunColor = vec3(1.0, 0.53, 0.37); \n  vec4 cloudCol=vec4(vec3(1.0, 0.53, 0.37)*1.3, 0.0);\n\n  float density = 0.0, dist = 0.0;\n\n  vec3 rayPos;\n  float precis; \n  float td =.0;\n  float densAdd=0.;\n  float shadowDensity;\nfloat add=1.;\n    int i=0;\n  float t = (550.0-origin.y)\/direction.y;\n  \n  for ( int ii=i; i<NO_UNROLL(steps); i++ )\n  {\n    rayPos = origin+direction*t;  \n    density = GetCloudHeightBelow(rayPos);          \n      \n\n    if (density>0.01)\n    {    \n\n      densAdd = 0.12*density*max(0.,add);\n      shadowDensity = GetCloudHeightBelow(rayPos+(sunPos*90.)); \n        \n     cloudCol.rgb += densAdd*max(0.,(density-shadowDensity))*sunColor;  \n     cloudCol.rgb-=1.4*shadowDensity*densAdd; \n      cloudCol.a+=(1.-cloudCol.a)*densAdd;\n        add-=densAdd;\n        if (add<0. || cloudCol.a > 0.99) break; \n\n    } \n    t+=2.;\n  }\n         \n\n  \/\/ mix clouds color with sky color\n  cloudCol.rgb = mix(cloudCol.rgb, vec3(0.97), smoothstep(100., 4960., t)); \n  cloudCol.a = mix(cloudCol.a, 0., smoothstep(0., 4860., t));\n    \n  return cloudCol;\n}\n\nconst mat2 r2D = mat2(1.3623, 1.7531, -1.7131, 1.4623);\n\nfloat GetTerrainHeight( vec3 p)\n{\n  vec2 p2 = (p.xz)*0.0005;\n\n  float mainHeight = -2.3+fastFBM(p*0.025)*max(11., abs(22.*noise2D(p2))); \n  float terrainHeight=mainHeight;\n  p2*=4.0;\n     \n  terrainHeight += textureLod( iChannel3, p2, 2.7 ).x*1.; \n  p2*=2.0;  p2 *= r2D;       \n  terrainHeight -= textureLod( iChannel3, p2, 1.2 ).x*.7;\n  p2*=3.0;  p2 *= r2D;          \n  terrainHeight -= textureLod( iChannel3, p2, 0.5 ).x*.1;\n\n  terrainHeight=mix(terrainHeight, mainHeight*1.4, smoothstep(1.5, 3.5, terrainHeight));\n      \n  vec2 offPos = p.xz-vec3(-143, 0., 292).xz;\n  terrainHeight=mix(-0.6, terrainHeight,smoothstep(180., 220., length(offPos-vec2(100., -185.))));\n  terrainHeight=mix(-0.6, terrainHeight, smoothstep(150., 320., length((p.z*2.5)-vec3(-143, 0., 292).z+320.)));\n  terrainHeight=mix(-0.6, terrainHeight, smoothstep(50.,300., length(offPos-vec2(800., -450.))));\n\n  return   terrainHeight;\n}\n\n\nfloat GetMountainHeight( vec3 p)\n{\n  vec2 p2 = p.xz*0.02;\n\n  float d = .24+(0.65*noise(p2*.25));\n  d = 120.0 * d * d ;\n\n  float height = d * noise(p2); \n  p2 *= r2D;   d *= 0.49;\n  height += d * noise(p2); \n  p2 *= r2D;   d *= 0.46;\n  height += d * noise(p2); \n  p2 *= r2D;   d *= 0.43;\n  height += d * noise(p2); \n  p2 *= r2D;  d *= 0.4;\n  height += d * noise(p2); \n  p2 *= r2D;\n\n  height += pow(abs(noise(p2*.002)), 8.0)*400.-5.0;\n\n height=mix(-200., height*0.5, smoothstep(600., 1100., length(p.xz-vec3(-143, 0., 292).xz-vec2(1800., -700.))));\n  height=mix(0., height, smoothstep(600., 850., length(vec3(-143, 0., 292).xz-p.xz)));\n  return  height;\n}\n\n\n#define GetWaterWave(p) (((-0.5+(0.5*(noise2D((p.xz+ vec2(-iTime*0.3, iTime*0.25))*2.60, 0.2)))) + (-0.5+(0.5*(noise2D((p.xz+ vec2(-iTime*-.48, iTime*-0.25))*1.60, 0.2)))))*0.5 )\n\nfloat GetTreeHeight( vec2 p, vec2 realP, float terrainHeight)\n{\n  float tree =textureLod(iChannel1, (p*0.05), 0.).r-0.13;\n\n\n  float randomFactor = 50.*(noise(p));\n  \/\/ remove trees near tower\n  tree=mix(0., tree, smoothstep(80.+randomFactor, 100.+randomFactor, length(realP-vec2(-143, 292))));\n  \/\/ remove trees in distance (out at sea)\n  tree=mix(0., tree, smoothstep(230., 340., length(realP-vec2(100., 0.))));\n tree=mix(0., tree, smoothstep(2.20, 2.30, terrainHeight));\n  return max(0., tree-0.4);\n}\n\nfloat GetStoneHeight(vec2 p, float terrainHeight)\n{\n  float height = textureLod(iChannel3, p*0.075, .1).x;\n  \/\/ create small stones at the coast line\n  float heightAdd =textureLod(iChannel1, p*0.008, 1.).x*2.;\n  heightAdd *= mix(1., 0., smoothstep(0.423, 0.7, length(0.1-terrainHeight)));\n  terrainHeight+=heightAdd;\n      \n  \/\/ add stones to hills\n  height = mix(0., mix(height, 0., smoothstep(4.0, 6.0, terrainHeight)), smoothstep(-.10, 0.10, terrainHeight));\n  height=mix(0., height, smoothstep(2.5, 4.0, length(p-vec2(-143, 292))));\n\n  return max(0., height);\n}\n\nfloat GetBoulderHeight( vec2 p, float terrainHeight)\n{\n  if (terrainHeight<1.8) return 0.;\n\n  float height = pow(textureLod(iChannel3, p*0.02, .1).x, 0.5)*0.8;\n  height += textureLod(iChannel3, (p*r2D)*0.04, .0).x*0.05;\n  height += textureLod(iChannel1, p*0.1, .1).x*0.01;\n  height = mix(0., height-0.45, step(0.5, height));\n\n  height*=.54;\n  height*=12.;\n\n  height=mix(0., height, smoothstep(1.80, 2.70, terrainHeight));\n  \/\/ no boulders near tower\n  height=mix(0., height, smoothstep(6., 19., length(p-vec2(-143, 292))));\n  return max(0., height);\n}\n\n\nfloat GetFoliageHeight(vec3 p, float terrainHeight, float boulderHeight, float stoneHeight)\n{\n  float fol =  textureLod(iChannel1, ((wind.xy*1.6*cos(p.x+p.y))+p.xz)*0.3, 0.1).r;\n  fol = mix(.0, fol, step(0.5, fol));\n  fol=mix(fol, 0., smoothstep(1.80, .270, terrainHeight));\n  fol=mix(fol, 0., smoothstep(0.24, 0.3, stoneHeight));\n\n  fol=mix(fol, 0., smoothstep(0.03, 0.2, boulderHeight));\n  \/\/ no foliage near tower\n  fol=mix(0., fol, smoothstep(4., 9., length(p.xz-vec3(-143, 0., 292).xz)));\n\n  return max(0., fol);\n}\n\nvec3 AddWind(vec3 p, vec2 wind, vec3 offSet)\n{\n  p-=offSet;\n  pR(p.xy, (wind.x-wind.y)*0.35);\n  pR(p.zy, (wind.y+wind.x)*0.35);   \n  return p+offSet;\n}\nvec3 TranslateBridge(vec3 p)\n{  \n  p = p-vec3(-143, 0., 292)-vec3(-.5, 1.75, 15.);  \n  p.xz*=r2(1.7);\n  return p;\n}\n\nvec3 TranslateBoat(in vec3 p)\n{\n  p = p-vec3(-143, 0., 292)-vec3(-8., 1.3, 33.); \n  p.xz*=r2(3.14);\n  return AddWind(p, wind.xy, vec3(-2., 0, -5.));\n}\n\nvec3 TranslateBuoy(in vec3 p)\n{\n  p = p-vec3(-143, 0., 292)-vec3(62., 2.2, -30.); \n  return AddWind(p, wind.xy, vec3(2., 0., -1.));\n}\n\nfloat MapMountains(in vec3 p)\n{       \n  return p.y -  GetMountainHeight(p);\n}\n\n\n\nfloat MapBoat(vec3 p)\n{\n  p=TranslateBoat(p);\n  \/\/ AABB\n  if (sdBox(p+vec3(0., 0., .50), vec3(1.7, 1.0, 4.))>1.) return 10000.;\n\n  \/\/ hull exterior  \n  float centerDist =length(p.x-0.);    \n  float centerAdd = 0.07*-smoothstep(0.04, 0.1, centerDist);\n  float frontDist = max(0.01, 1.3-max(0., (0.25*(0.15*pow(length(p.z-0.), 2.)))));\n  float widthAdd =mix(0.06*(floor(((p.y+frontDist) + 0.15)\/0.3)), 0., step(2., length(0.-p.y)));\n\n  float d= fCylinder( p, 1.45+widthAdd, 1.3+centerAdd+widthAdd);  \n  d =min(d, sdEllipsoid( p- vec3(0, 0, 1.250), vec3(1.45+widthAdd, 1.465+centerAdd, 1.+centerAdd+widthAdd))); \n  d =min(d, sdEllipsoid( p- vec3(0, 0, -1.20), vec3(1.45+widthAdd, 1.465+centerAdd, 3.+centerAdd+widthAdd))); \n\n  \/\/ hull cutouts\n  d= max(d, -fCylinder( p- vec3(0, 0.25, -0.10), 1.3+widthAdd, 1.4));  \n  d =max(d, -max(sdEllipsoid( p- vec3(0, 0.05, -.60), vec3(1.25+widthAdd, 1.2, 3.40)),-sdBox(p-vec3(0.,0.,4.), vec3(3., 10., 3.1)))); \n\n  \/\/ cut of the to part of the hull to make the boat open\n\n  d=max(d, -sdBox(p-vec3(0., 1.05+centerAdd, 0.), vec3(10., frontDist, 14.)));\n\n  \/\/ seats\n  return min(d, min(sdBox(p-vec3(0., -0.5, 0.9), vec3(1.3, 0.055, 0.35)), sdBox(p-vec3(0., -0.5, 0.9-2.2), vec3(1.3, 0.055, 0.35))));\n}\n\nfloat MapBridge(vec3 p)\n{\n  p=TranslateBridge(p);\n  \/\/ AABB\n  if (sdBox(p-vec3(10., -1.0, 0.0), vec3(11.5, 2.50, 2.25))>3.) return 10000.;\n\n  vec3 bPos = p+vec3(0.36, 0.0, 0.0);\n  \/\/ bottom planks\n  pModInterval1(bPos.x, 0.35, 0., 60.);\n  float d= sdBox(bPos-vec3(0., 0.0, 0.1), vec3(0.12, 0.08, 1.80));\n\n  \/\/ bearing balks\n  bPos = p-vec3(-1.75, -0.726, -2.);\n  pModInterval1(bPos.x, 3.2, 0., 7.);\n  d= min(d, sdBox(bPos-vec3(0., .0, 2.1), vec3(0.15, 0.15, 2.00)));\n  float m = pModInterval1(bPos.z, 4.2, 0., 1.);\n  d= min(d, sdCappedCylinder(bPos+vec3(0., 0.55, 0.), vec2(0.2, 2.8-m)));\n\n  \/\/ side rails      \n  bPos = p-vec3(10.8, 0., -1.7);\n  m = pModInterval1(bPos.z, 3.60, 0., 1.);\n   m = pModInterval1(bPos.y, 1.40, 0., 1.-m);\n     \n  d= min(d, sdBox(bPos, vec3(10., 0.14, .12)));\n\n  return d;\n}\n\/\/ Simple terrain map. Skip boulders, foliage and waves\nvec4 MapTerrainReflections( vec3 p)\n{\n    treeDist = 10000.;\n  float boatDist= 10000.;\n  float bridgeDist=10000.;\n  float height = GetTerrainHeight(p); \n  float tHeight= height + GetStoneHeight(p.xz, height);\n  tHeight*=1.4;\n  if (tHeight>0.)\n  {\n    tHeight +=textureLod( iChannel1, p.xz*.2, 0.2 ).x*.03;  \n               \n      #ifdef TREES   \n      vec3 treePos = p-vec3(0.,tHeight+2.,0.);\n      vec2 mm = floor( treePos.xz\/8.0 );\t\n\ttreePos.xz = mod( treePos.xz, 8.0 ) - 4.0;\n\n      float treeHeight=GetTreeHeight(mm,p.xz, tHeight);\n      \n      if(treeHeight>0.05)\n      {             \n          treeDist = sdEllipsoid(treePos,vec3(2.,5.7,2.));\n                     treeDist+=(noise(p*1.26)*.6285);\n         treeDist+=(noise(p*3.26)*.395);\n           treeDist+=(noise(p*6.26)*.09825);\n      }\n    #endif\n  }\n  #ifdef BRIDGE\n    bridgeDist=MapBridge(p);   \n  #endif\n    #ifdef BOAT\n    #ifdef ACCURATE_BOAT_REFLECTION\n    boatDist=MapBoat(p); \n    #else\n    \/\/ fake boat by using ellipsoid\n    boatDist=sdEllipsoid( TranslateBoat(p)- vec3(0, -0.20, -1.0), vec3(1.65, 1., 3.40));\n    #endif\n    \n  #endif\n\n    \/\/ mask tower position by placing a cone\n    return  vec4(min(treeDist,min(min(boatDist, bridgeDist), min(p.y - max(tHeight, 0.), sdConeSection(p-vec3(-143, 0., 292)-vec3(0., 13., 0.), 10.45, 3.70, 1.70)))), boatDist, bridgeDist, tHeight);\n}\n\n  \/\/ Full terrain map. Excludes tower mask\n  vec4 MapTerrain( vec3 p)\n{       \n  float boatDist= 10000.;\n  float bridgeDist=10000.;\n  treeDist = 10000.;\n  float water=0.;\n  float height = GetTerrainHeight(p); \n  float tHeight=mix(height, 4., smoothstep(12., 1.98, length(p.xz-vec3(-143, 0., 292).xz))); \n  float boulderHeight = GetBoulderHeight(p.xz, height);\n  float stoneHeight = GetStoneHeight(p.xz, tHeight);\n  tHeight+= mix(stoneHeight, 0., step(0.1, boulderHeight));\n\n  tHeight= mix(tHeight-.20, tHeight*1.4, smoothstep(0.0, 0.25, tHeight));\n\n  if (tHeight>0.)\n  {\n    tHeight +=textureLod( iChannel1, p.xz*.2, 0.2 ).x*.03;\n\n    tHeight+=boulderHeight;\n      \n                   #ifdef TREES   \n      vec3 treePos = p-vec3(0.,tHeight+2.,0.);\n      vec2 mm = floor( treePos.xz\/8.0 );\t\n\ttreePos.xz = mod( treePos.xz, 8.0 ) - 4.0;\n      \n      float treeHeight=GetTreeHeight(mm,p.xz, tHeight);\n      \n      if(treeHeight>0.05)\n      {\n          treeDist = sdEllipsoid(treePos,vec3(2.,5.7,2.));\n                     treeDist+=(noise(p*1.26)*.6285);\n         treeDist+=(noise(p*3.26)*.395);\n           treeDist+=(noise(p*6.26)*.09825);\n      }\n    #endif\n      \n    #ifdef GRASS\n      tHeight+=GetFoliageHeight(p, height, stoneHeight, boulderHeight);\n    #endif\n\n  } else\n  {\n    water = GetWaterWave(p);\n  }\n\n    \n  #ifdef BRIDGE\n    bridgeDist=MapBridge(p);    \n  #endif\n    #ifdef BOAT\n    boatDist=MapBoat(p);\n  #endif\n    \n    return vec4(min(treeDist,min(min(boatDist, bridgeDist), p.y -  max(tHeight, -water*0.05))), boatDist, bridgeDist, height);\n}\n \nfloat MapWater(vec3 p)\n{\n  return p.y - (-GetWaterWave(p)*0.05);\n}\n\n#define calcFolNormal( pos, th, bh, sh ) normalize( vec3(GetFoliageHeight(pos+vec3(0.02, 0.0, 0.0).xyy, th, bh, sh) - GetFoliageHeight(pos-vec3(0.02, 0.0, 0.0).xyy, th, bh, sh), 0.5*2.0*vec3(0.02, 0.0, 0.0).x, GetFoliageHeight(pos+vec3(0.02, 0.0, 0.0).yyx, th, bh, sh) - GetFoliageHeight(pos-vec3(0.02, 0.0, 0.0).yyx, th, bh, sh) ) )\n#define calcNormal( pos) normalize( vec3(MapTerrain(pos+vec3(0.02, 0.0, 0.0).xyy).x - MapTerrain(pos-vec3(0.02, 0.0, 0.0).xyy).x, 0.5*2.0*vec3(0.02, 0.0, 0.0).x, MapTerrain(pos+vec3(0.02, 0.0, 0.0).yyx).x - MapTerrain(pos-vec3(0.02, 0.0, 0.0).yyx).x ) )\n#define calcNormalWater( pos) normalize( vec3(MapWater(pos+vec3(0.02, 0.0, 0.0).xyy) - MapWater(pos-vec3(0.02, 0.0, 0.0).xyy), 0.5*2.0*vec3(0.02, 0.0, 0.0).x, MapWater(pos+vec3(0.02, 0.0, 0.0).yyx) - MapWater(pos-vec3(0.02, 0.0, 0.0).yyx) ) )\n#define calcNormalMountains( pos) normalize( vec3(MapMountains(pos+vec3(0.02, 0.0, 0.0).xyy) - MapMountains(pos-vec3(0.02, 0.0, 0.0).xyy), 0.5*2.0*vec3(0.02, 0.0, 0.0).x, MapMountains(pos+vec3(0.02, 0.0, 0.0).yyx) - MapMountains(pos-vec3(0.02, 0.0, 0.0).yyx) ) )\n#define calcTexNormal(sam, p) ( vec3(normalize(vec3(textureLod(sam, p + vec2(-0.001, 0), 0.).r-textureLod(sam, p + vec2(+0.001, 0), 0.).r, textureLod(sam, p + vec2(0, -0.001), 0.).r-textureLod(sam, p + vec2(0, +0.001), 0.).r, .02))) * 0.5 + 0.5 )\n\nvec4 TraceFoliage( vec3 origin, vec3 direction, int steps, vec3 foliageMainColor)\n{\n  vec4 folCol = vec4(foliageMainColor, 0.);\n  float t = .0;\n  vec3 random = vec3(0.);\n  vec3 rayPos, nn;\n  float dif =0.0, densAdd =.0;\n  float folHeight = 0.0;\n  for ( int i=0; i<NO_UNROLL(steps); i++ )\n  {\n    random = vec3(0.081*cos(float(i)));\n    rayPos = random+origin+direction*t;\n\n    float terrainHeight =GetTerrainHeight(rayPos);\n    float boulderHeight = GetBoulderHeight(rayPos.xz, terrainHeight);\n    float stoneHeight = GetStoneHeight(rayPos.xz, terrainHeight);\n    stoneHeight= mix(stoneHeight, 0., step(0.1, boulderHeight));  \n    folHeight = GetFoliageHeight(rayPos, terrainHeight, boulderHeight, stoneHeight);\n\n\n    if (folHeight>0.06)\n    {\n      nn= calcFolNormal(rayPos, terrainHeight, boulderHeight, stoneHeight);  \n      dif = max(0., dot( nn, sunPos ));\n      folCol.rgb+=0.1*dif;\n      folCol.a+=(1.-folCol.a)*0.1;\n    } \n    if (folCol.a>1.) break;\n\n    t+=0.015;\n  }\n\n  return clamp(folCol, 0., 1.);\n}\n\n\nbool TraceTerrainReflection( vec3 origin, vec3 direction, int steps)\n{\n  float precis = 0.00, t = 0.0, dist = 0.0;\n  vec3 rayPos;\n\n  for ( int i=0; i<NO_UNROLL(steps); i++ )\n  {\n    rayPos =origin+direction*t; \n    dist = MapTerrainReflections( rayPos).x;\n    precis = 0.006*t;\n\n    if (dist<precis || t>400.0)\n    {             \n      return !(t>400.0);\n    }\n\n    t += dist;\n  }\n\n  return false;\n}\n\nRayHit TraceTerrain( vec3 origin, vec3 direction, int steps, float maxDist)\n{\n  RayHit result;\n  vec4 dist = vec4(1000000.);\n  float precis = 0.0, t = 0.0;\n  vec3 rayPos;\n\n  for ( int i=0; i<NO_UNROLL(steps); i++ )\n  {\n    rayPos =origin+direction*t; \n    dist = MapTerrain( rayPos);\n    precis =0.001*t;\n\n    if (dist.x<precis || t>maxDist)\n    {             \n      result.hit=!(t>maxDist);\n      result.depth = t; \n      result.dist = dist;  \n      result.treeDist = treeDist;  \n      result.hitPos = origin+((direction*t));    \n      break;\n    }\n\n    t += dist.x*0.5;\n  }\n\n  return result;\n}\n\nRayHit TraceMountains( vec3 origin, vec3 direction, int steps, float maxDist)\n{\n  RayHit result;\n  float dist=0.;\n  \n  float precis = 0.0, t = 0.0;\n  vec3 rayPos;\n\n  for ( int i=0; i<NO_UNROLL(steps); i++ )\n  {\n    rayPos =origin+direction*t; \n    dist = MapMountains( rayPos);\n    precis = 0.001*t;\n\n    if (dist<precis || t>maxDist)\n    {             \n      result.hit=!(t>maxDist);\n      result.depth = t; \n      result.dist.x = dist;   \n      result.hitPos = origin+((direction*t));    \n      break;\n    }\n\n    t += dist*1.;\n  }\n\n  return result;\n}\n\nmat3 setCamera(  vec3 ro, vec3 ta, float cr )\n{\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n  vec3 cu = normalize( cross(cw, cp) );\n  vec3 cv = normalize( cross(cu, cw) );\n  return mat3( cu, cv, cw );\n}\n\n\nfloat SoftShadow( in vec3 origin, in vec3 direction )\n{\n  float res =1., t = 0.0, h;\n  vec3 rayPos = vec3(origin+direction*t);\n\n  for ( int i=0; i<NO_UNROLL(20); i++ )\n  {\n    h = MapTerrain(rayPos).x;\n\n    res = min( res, 8.5*h\/t );\n    t += clamp( h, 0.01, 0.25);\n    if ( h<0.005 ) break;\n    rayPos = vec3(origin+direction*t);\n  }\n  return clamp( res, 0.0, 1.0 );\n}\nfloat SoftShadowTower( in vec3 origin, in vec3 direction, float res)\n{\n  float t = 0.0, h;\n  vec3 rayPos = vec3(origin+direction*t);\n\n  for ( int i=0; i<NO_UNROLL(11); i++ )\n  {\n\n    h = sdConeSection(rayPos-vec3(-143, 0., 292)-vec3(0., 12., 0.), 10.45, 2.40, 1.40);\n\n    res = min( res, 6.5*h\/t );\n    t += clamp( h, 0.4, 1.5);\n    if ( h<0.005 ) break;\n    rayPos = vec3(origin+direction*t);\n  }\n  return clamp( res, 0.0, 1.0 );\n}\n\n\n#define colorStep 0.004\n  #define gradStep 0.0022\n\n  \/\/ create rain bow opposite direction to the sun\n  vec3 CalculateRainbow(vec3 rayDir, vec3 rayOrigin, vec2 screenSpace)\n{  \n  float visibility = pow(max(0., dot(vec3(sunPos.x*-1., 0., sunPos.z*-1.), rayDir)), 20.0);  \n\n  \/\/ rainbow colors based on center distance\n  float colorPos = 0.05;\n  vec3 color = mix(vec3(0.), vec3(1.0, 0, 0), smoothstep(colorPos, colorPos+gradStep, visibility)) ; \n  colorPos+=colorStep;\n  color = mix(color, vec3(1.0, 0.5, 0), smoothstep(colorPos, colorPos+gradStep, visibility)) ; \n  colorPos+=colorStep;\n  color = mix(color, vec3(1.0, 1., 0), smoothstep(colorPos, colorPos+gradStep, visibility)) ;\n  colorPos+=colorStep;\n  color = mix(color, vec3(.0, 1., 0), smoothstep(colorPos, colorPos+gradStep, visibility)) ;\n  colorPos+=colorStep;\n  color = mix(color, vec3(.0, .20, 1.), smoothstep(colorPos, colorPos+gradStep, visibility)) ;\n  colorPos+=colorStep;\n  color = mix(color, vec3(.0, .0, .9), smoothstep(colorPos, colorPos+gradStep, visibility)) ;\n  colorPos+=colorStep;\n  color = mix(color, vec3(.3, .0, 1.), smoothstep(colorPos, colorPos+gradStep, visibility)) ;\n  colorPos+=colorStep;\n  color = mix(color, vec3(0.), smoothstep(colorPos, colorPos+gradStep, visibility)) ;                                   \n\n  \/\/ tone rainbow colors to transparent the closer to rayDir = 0.0 we get\n  return color*visibility*2.15*mix(0., 1.0,smoothstep(0.3, 0., length(0.3-rayDir.y)));\n}\n\n\/\/ set sky color tone. \nvec3 GetSkyColor(vec3 rayDir)\n{ \n    float sun = mix(0.,pow( clamp( 0.5 + 0.5*dot(sunPos,rayDir), 0.0, 1.0 ), 3.0 ),smoothstep(.33, .0, rayDir.y));\n    float sun2 = clamp( 0.75 + 0.25*dot(sunPos,rayDir), 0.0, 1.0 );\n    \n    vec3 col = mix(vec3(156,140,164)\/255., vec3(166,134,150)\/255.,smoothstep(0.8, 0.00, rayDir.y)*sun2);\n    col = mix(col, vec3(239,181,169)\/255.,smoothstep(0.4, .0, rayDir.y)*sun2);\n    col = mix(col, vec3(255,190,136)\/255.,smoothstep(.4, 1.0, sun));\n    col = mix(col, vec3(255,135,103)\/255.,smoothstep(.8, 1.0, sun));\n    return col;\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n  float occ = 0.0;\n  float sca = 1.0;\n  for ( int i=0; i<NO_UNROLL(3); i++ )\n  {\n    float hr = 0.01 + 0.15*float(i);\n    vec3 aopos =  nor * hr + pos;\n    float dd = MapTerrain( aopos ).x;\n    occ += -(dd-hr)*sca;\n    sca *= 0.96;\n  }\n  return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\n\nvec3 GetLightTerrain(float specLevel, vec3 normal, RayHit rayHit, vec3 rayDir, vec3 origin, float illuminance)\n{                \n  vec3 reflectDir = reflect( rayDir, normal );\n  vec3 shadowPos = origin+((rayDir*rayHit.depth)*0.98);\n\n  float occ = 1.;\n  #ifdef PERFORM_AO_PASS\n    occ = calcAO(shadowPos, normal );\n  #endif\n\n  vec3 lightTot = vec3(0.0);\n  float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );\n  float dif = clamp( dot( normal, sunPos ), 0.0, 1.0 );\n  float fre = clamp(1.0+dot(normal, rayDir), 0.0, 1.0);\n  specLevel*= pow(clamp( dot( reflectDir, sunPos ), 0.0, 1.0 ), 2.0);\n  float skylight = smoothstep( -0.1, 0.1, reflectDir.y );\n\n\n  #ifdef SHADOWS\n    float shadow=1.;\n  shadow = SoftShadow(shadowPos, sunPos);\n  shadow = min(shadow, SoftShadowTower(shadowPos, sunPos, shadow));\n  shadow = max(illuminance, shadow);\n  dif*=shadow;\n  #endif\n    \n  const vec3 sunColor = vec3(1.1, 0.53, 0.27); \n  lightTot += 3.*dif*sunColor;\n\n  lightTot += .65*amb*vec3(0.35, 0.45, 0.6)*occ;  \n  lightTot += 0.60*skylight*clamp(GetSkyColor(reflectDir), 0., 1.)*occ;\n  lightTot += 2.*specLevel*vec3(1., 0.85, 0.75)*dif;  \n  fre = pow( 1.0-abs(dot(rayHit.normal, rayDir)), 4.0);\n  lightTot = mix( lightTot, lightTot*2., fre );\n\n  return clamp(lightTot, 0.22, 10.);\n}\n\nvec3 GetLightMountains(float specLevel, vec3 normal, RayHit rayHit, vec3 rayDir, vec3 origin)\n{                \n  vec3 reflectDir = reflect( rayDir, normal );\n  vec3 shadowPos = origin+((rayDir*rayHit.depth)*0.98);\n  const vec3 sunColor = vec3(1.1, 0.53, 0.27); \n    \n  vec3 lightTot = vec3(0.0);\n  float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );\n  float dif = clamp( dot( normal, sunPos ), 0.0, 1.0 );\n  float fre = clamp(1.0+dot(normal, rayDir), 0.0, 1.0);\n  specLevel*= pow(clamp( dot( reflectDir, sunPos ), 0.0, 1.0 ), 2.0);\n  float skylight = smoothstep( -0.1, 0.1, reflectDir.y );\n\n\n  lightTot += 3.*dif*sunColor;\n\n  lightTot += .65*amb*vec3(0.35, 0.45, 0.6);  \n  lightTot += 0.60*skylight*clamp(GetSkyColor(reflectDir), 0., 1.);\n  lightTot += 2.*specLevel*vec3(1., 0.85, 0.75)*dif;  \n  fre = pow( 1.0-abs(dot(rayHit.normal, rayDir)), 4.0);\n  lightTot = mix( lightTot, lightTot*2., fre );\n\n  return clamp(lightTot, 0.22, 10.);\n}\n\nvec3 GetLightWater(float specLevel, vec3 normal, RayHit rayHit, vec3 rayDir, vec3 origin)\n{                \n  const vec3 sunColor = vec3(1.1, 0.53, 0.27); \n  vec3 reflectDir = reflect( rayDir, normal );\n  float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );\n  float dif = clamp( dot( normal, sunPos ), 0.0, 1.0 );\n\n  specLevel*= pow(clamp( dot( reflectDir, sunPos ), 0.0, 1.0 ), 9.0);\n\n  float skylight = smoothstep( -0.1, 0.1, reflectDir.y );\n  float fre = pow( 1.0-abs(dot( normal, rayDir )), 3.0 );\n  fre = mix( .03, 1.0, fre );   \n\n  const vec3 reflection = vec3(1.0);\n  vec3 lightTot = vec3(0.0);\n\n  lightTot += 3.*dif*sunColor;\n\n  vec3 skyCol = GetSkyColor(reflectDir);\n\n  lightTot += 0.5*amb*vec3(0.35, 0.45, 0.6);  \n  lightTot += 0.70*skylight*skyCol;\n  lightTot += 2.*specLevel*vec3(1., 0.85, 0.75)*dif;  \n  fre = pow( 1.0-abs(dot(rayHit.normal, rayDir)), 4.0);\n  lightTot = mix( lightTot, lightTot+skyCol, fre );\n\n  return clamp(lightTot, 0., 10.);\n}\n\n\n\nvoid ApplyFog(inout vec3 color, vec3 skyColor, vec3 rayOrigin, vec3 rayDir, float depth)   \n{\n  const vec3 sunColor = vec3(1.1, 0.53, 0.27); \n  float mixValue = smoothstep(50., 15000., depth);\n  float sunVisibility = max(0., dot(sunPos, rayDir));\n  \/\/ horizontal fog\n  vec3 fogColor = sunColor*0.7;  \n  fogColor = mix(fogColor, sunColor, smoothstep(0., 0.5, sunVisibility));   \n  color = mix(color, fogColor, mixValue);\n\n  \/\/ vertical fog\n  const float heightAmount = .008;\n  float fogAmount = 0.2 * exp(-rayOrigin.y*heightAmount) * (1.0-exp( -depth*rayDir.y*heightAmount ))\/rayDir.y;\n  color = mix(color, fogColor, min(0.5, fogAmount));\n}\n\/\/ https:\/\/www.shadertoy.com\/view\/MtsGWH\nvec4 BoxMap( sampler2D sam, in vec3 p, in vec3 n, in float k )\n{\n  vec3 m = pow( abs(n), vec3(k) );\n  vec4 x = texture( sam, p.yz );\n  vec4 y = texture( sam, p.zx );\n  vec4 z = texture( sam, p.xy );\n  return (x*m.x + y*m.y + z*m.z)\/(m.x+m.y+m.z);\n}\nvec4 BoxMapFast( sampler2D sam, in vec3 p, in vec3 n, in float k )\n{\n  vec3 m = pow( abs(n), vec3(k) );\n  vec4 x = textureLod( sam, p.yz ,0.);\n  vec4 y = textureLod( sam, p.zx ,0.);\n  vec4 z = textureLod( sam, p.xy ,0.);\n  return (x*m.x + y*m.y + z*m.z)\/(m.x+m.y+m.z);\n}\n\n\n#define MOSSCOLOR (vec3(29, 39, 31)\/255.)\n#define MOSSCOLOR2 (vec3(74, 80, 59)\/315.)\n#define TREECOLOR col.rgb = (0.2+(0.8*abs(noise(marchResult.hitPos*2.))))*vec3(.9, 1., .8)*0.3;\n\nvec3 GetBridgeTexture(RayHit marchResult)\n{\n  vec3 checkPos = TranslateBridge(marchResult.hitPos); \n  vec3 woodTexture = vec3(BoxMap(iChannel1, vec3(checkPos.z*0.01, checkPos.yx*0.31), (marchResult.normal), 0.5).r);\n  vec3 bridgeColor =  woodTexture*(0.6+(0.4*noise(checkPos.zx*17.)));\n  float n = noise2D(checkPos.xz*1.3);\n  return mix(bridgeColor*MOSSCOLOR2, bridgeColor, smoothstep(-.64-(2.*n), 2.269-(2.*n), marchResult.hitPos.y));\n}\n\nvec3 GetBoatTexture(RayHit marchResult)\n{\n  vec3 checkPos = TranslateBoat(marchResult.hitPos); \n  vec3 bCol= vec3(62, 52, 47)*1.3\/255.;\n  float frontDist = max(0., (0.25*(0.16*pow(length(checkPos.z-0.), 2.))));\n  float n = 1.+(0.2*noise(vec3(checkPos.zx*0.01, checkPos.x)*34.));\n  n *= 0.9+(0.1*noise2D(checkPos.xy*26.));  \n  bCol = mix(vec3(0.6), bCol*n, step(-0.625, checkPos.y-frontDist));\n  bCol = mix(vec3(0.05), bCol, step(0.08, length(-.7-(checkPos.y-frontDist))));\n  bCol = mix(bCol*0.8, bCol*1.2, smoothstep(0., 0.18, length(-0.23-(checkPos.y-frontDist))));   \n  bCol = mix(bCol, bCol*0.47, smoothstep(0.0, 0.32, length(0.-mod(checkPos.y-frontDist, 0.3)))); \n  return mix(bCol, bCol*0.8, smoothstep(-.1, 0.8, noise2D(checkPos.xz*3.7)));  \n}\n\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{  \n  vec2 uv = fragCoord.xy \/ iResolution.xy;\n  vec2 screenSpace = (-iResolution.xy + 2.0*(fragCoord))\/iResolution.y;\n\n  wind= (vec3(0.05, -0.1, -0.1)*(cos((iTime)*2.)*sin((iTime)*.5)));\n  cloudPos = vec2(-iTime*1.3, -iTime*1.65);\n  sunPos =  readRGB(ivec2(50, 0));\n  vec3 camData  = readRGB(ivec2(52, 0));  \n\n  \/\/ setup camera and ray direction\n  vec2 camRot = readRGB(ivec2(57, 0)).xy;\n\n  vec3 rayOrigin = vec3(vec3(-143, 0., 292).x+camData.z*cos(camRot.x), camData.y, vec3(-143, 0., 292).z+camData.z*sin(camRot.x) );    \n  rayOrigin.y = readRGB(ivec2(62, 0)).y;\n  mat3 ca = setCamera( rayOrigin, vec3(vec3(-143, 0., 292).x, camData.y+(11.*camRot.y), vec3(-143, 0., 292).z ), 0.0 );\n  vec3 rayDir = ca * normalize( vec3(screenSpace.xy, 2.0) );\n\n  const vec3 sunColor = vec3(1.1, 0.53, 0.27); \n    \n\n  \/\/ create sky color fade\n  vec4 color = vec4(0.,0.,0.,10000.);\n  color.rgb  =  GetSkyColor(rayDir);\n\n  \/\/ add volumetric clouds (top)\n  if (rayDir.y>0.)\n  {  \n    vec4 cloudColor=TraceCloudsBelow(rayOrigin, rayDir, color.rgb, 90);    \n\n      \n    \/\/ make clouds slightly light near the sun\n    float sunVisibility = pow(max(0., dot(sunPos, rayDir)), 2.0)*0.25;\n    color.rgb = mix(color.rgb, max(vec3(0.), mix(cloudColor.rgb,cloudColor.rgb,.6)+sunVisibility), cloudColor.a);  \n    color.rgb +=  CalculateRainbow(rayDir, rayOrigin, screenSpace);\n            \n  \n    \/\/ color.rgb = mix(color.rgb, cloudColor.rgb, cloudColor.a);       \n    color.a+=cloudColor.a*0.86;\n  }\n    \n  #ifdef TERRAIN\n\n    vec3 skyColor = GetSkyColor(rayDir);\n    RayHit marchResult = TraceTerrain(rayOrigin, rayDir, 500, 1000.);\n\n\n    \/\/ is terrain hit?\n    if (marchResult.hit)\n    { \n      vec3 col;\n      float alpha=1.0;\n\n      float specLevel=1.;\n      col=color.rgb;\n\n      vec3 light;\n\n      float terrainHeight =marchResult.dist.w;\n      float stoneHeight = GetStoneHeight(marchResult.hitPos.xz, terrainHeight);     \n      float treeHeight =GetTreeHeight(marchResult.hitPos.xz,marchResult.hitPos.xz, terrainHeight);\n   \n      \/\/ check if terrain is below water level\n      if (terrainHeight<-stoneHeight && marchResult.dist.x!=marchResult.dist.z && marchResult.dist.x!=marchResult.dist.y)\n      {\n        marchResult.normal = calcNormalWater(marchResult.hitPos);  \n        \n        vec3 terrainHit = rayOrigin+((rayDir*marchResult.depth)*0.985);\n        vec3 refDir = reflect(rayDir, marchResult.normal);\n        vec4 testClouds = vec4(0.);        \n        col = vec3(0.3);\n\n        vec3 bottomColor =  clamp(vec3(textureLod(iChannel3, marchResult.hitPos.xz*0.13, 0.2).r*clamp( dot( calcTexNormal(iChannel3, (marchResult.hitPos.xz*0.1)+marchResult.normal.xz), sunPos ), 0.0, 1.0 )*vec3(1., 0.9, 0.7)), 0.2, 0.6);\n\n        col = mix(col, bottomColor, smoothstep(-0.65, -0.33, terrainHeight));\n\n        \/\/ calculate water fresnel  \n        float fresnel = pow(1.0-abs(dot(rayDir, marchResult.normal)), 4.);  \n\n        \/\/ col.rgb  = mix(col*.7, col.rgb, smoothstep(-3.0, -0.15, marchResult.hitPos.y));\n        col = col+((sunColor*pow(max(0., dot(sunPos, rayDir)), 5.0))*0.5);\n\n        vec3 reflection = col;\n\n        #ifdef QUALITY_REFLECTIONS\n          \/\/ get cloud reflections for water\n          testClouds = TraceCloudsBelow(terrainHit, refDir, skyColor, 30);\n        \/\/ cast rays from water surface onto terrain. If terrain is hit, color water dark in these areas.    \n        if (TraceTerrainReflection(terrainHit, refDir, 40))\n        {\n          reflection  = mix(col, vec3(.01, 0.03, .0), 0.9);\n        }\n        #endif\n\n\n          light = GetLightWater(specLevel, marchResult.normal, marchResult, rayDir, rayOrigin);   \n        col=mix(mix(col.rgb, testClouds.rgb, testClouds.a), mix(col.rgb, testClouds.rgb, testClouds.a), smoothstep(0., 0.7, fresnel)); \n        col=mix(mix(col.rgb, reflection, 0.5), reflection, smoothstep(0., 0.3, fresnel)); \n        col=mix(mix(col.rgb, ((col+noise2D((marchResult.hitPos.xz)*24., 1.0))+vec3(0.5, 0.4, .1))*0.3, smoothstep(0., 1.0, marchResult.hitPos.y)), col+(0.5*fresnel), smoothstep(0., 0.3, fresnel)); \n\n\n        col=col*light;\n\n        col = mix(col, skyColor, smoothstep(320., 400., marchResult.depth));\n      } \n      \/\/ terrain is ABOVE water level  \n      else\n      {\n         marchResult.normal = calcNormal(marchResult.hitPos);  \n\n          float boulderHeight = GetBoulderHeight(marchResult.hitPos.xz, terrainHeight)-treeHeight;     \n          float foliageHeight = GetFoliageHeight(marchResult.hitPos, terrainHeight, boulderHeight, stoneHeight)-treeHeight;     \n\n          float noiseMedium = noise(marchResult.hitPos*23.3);\n          float noiseLarge = noise(marchResult.hitPos*0.3); \n          vec4 fColor = vec4(0.0);\n\n          \/\/texture bridge\n          if ( length(marchResult.dist.x-marchResult.dist.z)<0.01)\n          {\n            col.rgb = GetBridgeTexture(marchResult);\n              specLevel*=1.45*col.r;\n          }\n          \/\/texture boat\n          else if ( length(marchResult.dist.x-marchResult.dist.y)<0.01)\n          { \n            col.rgb = GetBoatTexture(marchResult);\n            specLevel*=col.r;\n          }\n          else if ( length(marchResult.dist.x-marchResult.treeDist)<0.01)\n          { \n       \n           TREECOLOR;\n           \n          }\n          \/\/ texture terrain\n          else\n          {\n            \/\/ create terrain texture\n            #ifdef LOWRES_TEXTURES\n            vec3 colorRocks= vec3(BoxMapFast(iChannel3, marchResult.hitPos*0.61, (marchResult.normal), 0.5).r);\n            vec3 colorRocks2 = vec3(BoxMapFast(iChannel3, marchResult.hitPos*0.11, (marchResult.normal), 0.5).r);\n            #else\n            vec3 colorRocks= vec3(BoxMap(iChannel3, marchResult.hitPos*0.61, (marchResult.normal), 0.5).r);\n            vec3 colorRocks2 = vec3(BoxMap(iChannel3, marchResult.hitPos*0.11, (marchResult.normal), 0.5).r);           \n            #endif\n              \n            colorRocks = mix(colorRocks, colorRocks2, 0.5);\n\n            float moss =  0.75*(1.2+noiseMedium);\n            vec3 grassCol = vec3(.15, .14, .10);\n            vec3 dirtCol =vec3(.2, .16, .14);\n            col =colorRocks;\n\n            float mossAmount = mix(mix(1., 0.47, max(0., noiseMedium)), 0., max(0., marchResult.normal.z));\n\n            \/\/ create boulder texture\n            vec3 boulderColor = mix(colorRocks2, colorRocks*1.4, marchResult.normal.y);\n            \/\/ add boulder moss\n            boulderColor = mix(boulderColor*(0.6+(0.5*noiseMedium)), vec3(0.48+(0.4*abs(noiseMedium))), smoothstep(0., .7, noiseLarge));\n            boulderColor = mix(mix(moss*MOSSCOLOR2, boulderColor*0.67, max(0., noiseMedium)), boulderColor, max(0., marchResult.normal.z));\n\n            \/\/ add stone moss\n            vec3 stoneColor = mix(colorRocks2, colorRocks*1.4, marchResult.normal.y);\n            stoneColor = mix(stoneColor*(0.8+(0.2*noiseMedium)), vec3(0.8), smoothstep(0., 1.5, noiseMedium));\n            stoneColor = mix(mix(moss*MOSSCOLOR*1.4, stoneColor, smoothstep(0.7, 0.9, stoneHeight)), boulderColor*(0.74+(0.5*noiseMedium)), smoothstep(.0, 2.57, terrainHeight));\n\n         \n            vec3 foliageCol = mix(vec3(216., 156, 101)\/255., vec3(216., 156, 101)\/355., smoothstep(0.20, .50, max(0., noiseMedium)));\n            foliageCol = mix(vec3(0.16), foliageCol, smoothstep(0.0, 0.74, max(0., foliageHeight)));\n               \n        \n                  \/\/ apply textures\n            col.rgb = mix(col.rgb, stoneColor, smoothstep(0.02, 0.7, stoneHeight));\n            col.rgb = mix(col.rgb, boulderColor, smoothstep(0.02, .30, boulderHeight));   \n            col.rgb = mix(col.rgb, foliageCol, step(0.01, foliageHeight));\n              \n            specLevel = mix(specLevel, 5.*stoneColor.r, step(.03, stoneHeight));\n            specLevel = mix(specLevel, mix((3.2*boulderColor.r), 1.5*boulderColor.r, mossAmount), step(.03, boulderHeight));\n            specLevel = mix(specLevel, 0.15, step(.03, foliageHeight));\n              \n          #ifdef QUALITYFOLIAGE\n            fColor = TraceFoliage(marchResult.hitPos+marchResult.normal*0.004, rayDir, 32, vec3(0.55, 0.36, 0.45));    \n          #endif\n          }      \n\n          \/\/ get lightning based on material\n          light = GetLightTerrain(specLevel, marchResult.normal, marchResult, rayDir, rayOrigin, 0.0);   \n          col = col*light;         \n          col =mix( col,  saturate(mix(col, fColor.rgb* vec3(1., 0.7, 0.47), 0.55)), fColor.a );       \n      }\n      \n\n      col = mix(col, (col+sunColor)*0.6, smoothstep(70., 600., marchResult.depth));\n\n      ApplyFog(col, skyColor, rayOrigin, rayDir, marchResult.depth);\n      color.rgb = col; \n      color.a= marchResult.depth;\n    } \n    else  \/\/ if main trace missed terrain, continue from last ray postion and trace mountains\n    {\n      RayHit marchResult2 = TraceMountains(rayOrigin+(rayDir*marchResult.depth*0.7), rayDir, 100, 1000.);\n\n      \/\/ mountains hit\n      if (marchResult2.hit)\n      {\n        marchResult2.normal = calcNormalMountains(marchResult2.hitPos);  \n \n        \/\/ adding some slight haze at mountain bottom\n        vec3 col = vec3(0.5);\n\n        vec3 light = GetLightMountains(0.6, marchResult2.normal, marchResult2, rayDir, rayOrigin);   \n        col = col*light;\n        col = mix(col, (col+sunColor)*0.6, smoothstep(70., 600., marchResult2.depth));\n        col = mix(mix(col,vec3(.9, 0.7, 0.57)*(.4+1.27*abs(noise((marchResult2.hitPos.xz-vec2(iTime*17.0,0))*0.02))),0.5),col,smoothstep(0.,70.,marchResult2.hitPos.y));\n\n        ApplyFog(col, skyColor, rayOrigin, rayDir, marchResult.depth);\n        color.rgb = col; color.a=500.;\n      }\n    }\n  #endif\n    \n  fragColor = color;\n}\n","name":"Buf C","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3Rr","filepath":"\/media\/a\/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"\/media\/ap\/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"\/media\/previz\/buffer03.png","previewfilepath":"\/media\/previz\/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ TOWER BUFFER  -   RENDERS TOWER ONLY\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Channel 0 = Buffer C. Capture rendered data from previous buffer\n\/\/ Channel 1 = Buffer D. This buffer for use in AA pass.\n\/\/ Channel 2 = Buffer A. Read data from data-buffer.\n\/\/ Channel 3 = Organic3 texture. Used to create tower stone look.\n#define read(memPos) (  texelFetch(iChannel2, memPos, 0).a)\n#define readRGB(memPos) (  texelFetch(iChannel2, memPos, 0).rgb)\n#define PI 3.14159265359\n#pragma optimize(off) \n#define NO_UNROLL(X) (X + min(0,iFrame))\n\n\/\/ Delete one or several of below defines to increase performance\n\/\/#define PERFORM_AO_PASS\n#define PERFORM_AA_PASS\n#define SHADOWS\n\/\/#define HIGH_QUALITY\n\n\/\/ Try enabling below define if shader doesn\u00b4t compile\n\/\/#define LOWRES_TEXTURES\n\nvec3 sunPos = normalize( vec3(0.50, 1.0, 1.0) );\n\nfloat winDist=100000.0;\nfloat dekoDist=100000.0;\nfloat steelDist=100000.0;\nfloat lampDist=100000.0;\nfloat doorDist=100000.0;\n\n\nstruct RayHit\n{\n  bool hit;  \n  vec3 hitPos;\n  vec3 normal;\n  float dist;\n  float depth;\n  float winDist;\n  float dekoDist;\n  float steelDist;\n  float glassDist;\n  float lampDist;\n  float doorDist;\n};\n\n\nfloat noise(vec3 p)\n{\n  vec3 ip=floor(p);\n  p-=ip; \n  vec3 s=vec3(7, 157, 113);\n  vec4 h=vec4(0., s.yz, s.y+s.z)+dot(ip, s);\n  p=p*p*(3.-2.*p); \n  h=mix(fract(sin(h)*43758.5), fract(sin(h+s.x)*43758.5), p.x);\n  h.xy=mix(h.xz, h.yw, p.y);\n  return mix(h.x, h.y, p.z);\n}\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x, p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa, ba)\/dot(ba, ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  return (length( p\/r ) - 1.0) * min(min(r.x, r.y), r.z);\n}\n\nfloat sdConeSection( vec3 p, float h, float r1, float r2 )\n{\n  float d1 = -p.y - h;\n  float q = p.y - h;\n  float si = 0.5*(r1-r2)\/h;\n  float d2 = max( sqrt( dot(p.xz, p.xz)*(1.0-si*si)) + q*si - r2, q );\n  return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.);\n}\n\nfloat fCylinder(vec3 p, float r, float height) {\n  float d = length(p.xy) - r;\n  d = max(d, abs(p.z) - height);\n  return d;\n}\n\nfloat fCylinderH(vec3 p, float r, float height) {\n  float d = length(p.xz) - r;\n  d = max(d, abs(p.y) - height);\n  return d;\n}\n\nfloat fCylinderV(vec3 p, float r, float height) {\n  float d = length(p.yz) - r;\n  d = max(d, abs(p.x) - height);\n  return d;\n}\n\nfloat fOpPipe(float a, float b, float r) {\n  return length(vec2(a, b)) - r;\n}\n\nfloat fOpIntersectionChamfer(float a, float b, float r) {\n  return max(max(a, b), (a + r + b)*sqrt(0.5));\n}\n\nfloat fOpUnionChamfer(float a, float b, float r) {\n  return min(min(a, b), (a - r + b)*sqrt(0.5));\n}\n\nvec2 pModPolar(in vec2 p, float repetitions) {\n  float angle = 2.*PI\/repetitions;\n  float a = atan(p.y, p.x) + angle\/2.;\n  float r = length(p);\n  float c = floor(a\/angle);\n  a = mod(a, angle) - angle\/2.;\n  p = vec2(cos(a), sin(a))*r;\n  if (abs(c) >= (repetitions\/2.)) c = abs(c);\n  return p;\n}\n\nmat2 r2(float r) {\n  float c=cos(r), s=sin(r);\n  return mat2(c, s, -s, c);\n}\n#define pR(p, a) (p)*=r2(a)\n\n\n  float pModInterval1(inout float p, float size, float start, float stop) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)\/size);\n  p = mod(p+halfsize, size) - halfsize;\n  if (c > stop) { \/\/yes, this might not be the best thing numerically.\n    p += size*(c - stop);\n    c = stop;\n  }\n  if (c <start) {\n    p += size*(c - start);\n    c = start;\n  }\n  return c;\n}\n\n\nfloat SmallWindow( vec3 p)\n{\n  \/\/ AABB\n  if ( sdBox(p-vec3(-.65, 1.17, 0.0), vec3(1.))<0.1) \n  {\n    \/\/ window base\n    float d= sdBox(p-vec3(-.65, 1.17, 0.0), vec3(0.08, 0.4, 0.4));       \n    \/\/ window cutouts\n    d= max(d, -sdBox(p-vec3(-.06, 1.17, 0.0), vec3(0.54, 0.36, .36))); \n    d= max(d, -sdBox(p-vec3(-.22, 1.17, 0.0), vec3(0.54, 0.32, .32))); \n    \/\/ deco above window  \n    d= min(d, sdBox(p-vec3(-0.58, 1.6, 0.), vec3(0.165, 0.04, 0.5)));\n    \/\/ window steel vertical \n    steelDist= min(steelDist, sdBox(p-vec3(-.62, 1.17, 0.0), vec3(0.02, 0.32, 0.02))); \n    \/\/ window steel horizontal \n    vec3 winPos = p-vec3(-.62, 1.03, 0.0);\n    pModInterval1(winPos.y, 0.25, 0., 1.0);\n    steelDist= min(steelDist, sdBox(winPos, vec3(0.007, 0.018, 0.38))); \n    \/\/ deco below window  \n    d= min(d, sdBox(p-vec3(-.59, .71, 0.), vec3(0.13, 0.05, 0.45)));\n    d= min(d, sdBox(p-vec3(-.59, 0.69, 0.), vec3(0.18, 0.025, 0.50)));\n    \/\/ deco in the middle below window\n    d= min(d, sdBox(p-vec3(-0.70, .49, 0.), vec3(0.25, 0.2, 0.07)));   \n    d = fOpIntersectionChamfer(d, -fCylinder(p-vec3(-0.32, .25, 0.), 0.23, 1.63), 0.03);\n    return d;\n  }\n  else\n  {\n      return 10000.;\n  }\n}\n\n\nfloat Window( vec3 p)\n{\n  \/\/ window base\n  float d= sdBox(p-vec3(-0.58, 1.07, 0.), vec3(0.075, 0.6, 0.4));\n\n  if (d<2.0)\n  {  \n    \/\/ window cutouts\n    d = max(d, -sdBox(p-vec3(-0.28, 1.07, 0.), vec3(0.25, 0.60, 0.34)));\n    d= max(d, -sdBox(p-vec3(-0.21, 1.05, 0.), vec3(1.4, 0.5, 0.25))); \n    d= min(d, sdBox(p-vec3(-0.58, 1.7, 0.), vec3(0.325, 0.06, 0.48)));\n\n    \/\/ window steel vertical \n    steelDist= min(steelDist, sdBox(p-vec3(-0.55, 1.17, 0.), vec3(0.01, 0.60, 0.02))); \n\n    \/\/ window steel horizontal \n    vec3 winPos = p-vec3(-0.55, 0.75, 0.);\n    pModInterval1(winPos.y, 0.30, 0., 2.0);        \n    steelDist= min(steelDist, sdBox(winPos, vec3(0.01, 0.02, 0.4))); \n\n    d=min(d, max(max(fCylinderV(p-vec3(-0.5, 1.74, 0.), 0.42, 0.13), -sdBox(p-vec3(-0.5, 1.49, 0.), vec3(1., 0.27, 1.5))), -fCylinderV(p-vec3(-0.5, 1.74, 0.), 0.38, 0.53)));\n\n    d= min(d, sdBox(p-vec3(-.52, .42, 0.), vec3(0.13, 0.05, 0.45)));\n    d= min(d, sdBox(p-vec3(-.52, 0.40, 0.), vec3(0.18, 0.025, 0.50)));\n\n    \/\/ lower decoration \n    d= min(d, sdBox(p-vec3(-0.55, .20, 0.4), vec3(0.15, 0.2, 0.05)));   \n    d= min(d, sdBox(p-vec3(-0.55, .20, -0.4), vec3(0.15, 0.2, 0.05)));\n    d = fOpIntersectionChamfer(d, -fCylinder(p-vec3(-0.3, .0, 0.), 0.23, 1.63), 0.02);\n\n    \/\/ upper decoration \n    dekoDist=min(dekoDist, sdBox(p-vec3(-0.55, 2.63, 0.), vec3(0.3, 0.45, 0.12)));    \n    dekoDist = fOpIntersectionChamfer(dekoDist, -fCylinder(p-vec3(-0.22, 2.45, -0.1), 0.21, 0.63), 0.03);\n  }\n  return d;\n}\n\n\n\n\n#define radius 1.6\n#define outRad 1.82\n#define inRad 1.12\n\nfloat Map(  vec3 p)\n{\n\n  p.y-=21.25;\n  float  d=100000.0;\n  vec3 checkPos = p;\n  winDist=dekoDist=steelDist=lampDist=doorDist = 100000.0;\n  d=sdCappedCylinder(p-vec3(0.0, -3.0, 0), vec2(3.20, 12.45));\n  if (d>.2) return d;\n\n  float noiseScale=(1.+(0.01*abs(noise(p*22.))));\n  float noiseScale2=(1.+(0.03*abs(noise(p*13.))));\n\n  d = sdCappedCylinder(p-vec3(0.0, 3.7, 0), vec2(inRad, .45));\n\n  d=min(d, fCylinderH(p-vec3(0.0, 1.3, 0), radius*noiseScale, 1.80));\n  d=min(d, sdConeSection(p-vec3(0.0, -6.0, 0.), 5.3, 2.4*noiseScale, 1.7*noiseScale));\n  d=min(d, sdConeSection(p-vec3(0.0, -13.0, 0.), 1.8, 2.8*noiseScale, 2.6*noiseScale));\n\n  \/\/ roof \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n  dekoDist=min(dekoDist, sdConeSection(p-vec3(0., 6.7, 0), 0.40, 1.2, 0.8)); \n\n  checkPos = p;\n  checkPos.xz = pModPolar(checkPos.xz, 26.0);   \n  checkPos-=vec3(1.2, 6.7, 0);\n  pR(checkPos.xy, 0.5);\n\n  dekoDist=fOpUnionChamfer(dekoDist, sdCappedCylinder(checkPos, vec2(0.08, 0.47)), 0.1); \/\/ roof\n\n  steelDist=min(steelDist, sdSphere(p-vec3(0., 6.6, 0), 1.05));    \n  vec3 pp = p-vec3(0., 8., 0);\n  float m = pModInterval1(pp.y, -0.14, 0.0, 2.);         \n  steelDist=min(steelDist, sdSphere(pp, 0.20+(0.12*m)));   \n  steelDist = fOpUnionChamfer(steelDist, sdCapsule(p-vec3(0., 8., 0), vec3(0, 0., 0), vec3(0, 1.0, 0), 0.013), 0.1);\n\n  checkPos = p;\n  \/\/ deko and windows steel top\n  checkPos.xz = pModPolar(p.xz, 12.0);\n  steelDist=min(steelDist, sdCappedCylinder(checkPos-vec3(outRad+0.05, 3.6, 0), vec2(0.03, .42))); \/\/ top railing\n  steelDist=min(steelDist, sdCappedCylinder(checkPos-vec3(inRad-0.06, 4.4, 0), vec2(0.02, 1.45))); \/\/ window grid\n  steelDist=min(steelDist, sdBox(checkPos-vec3(inRad-0.19, 6.25, 0), vec3(0.25, .3, 0.25)));\n  steelDist=fOpIntersectionChamfer(steelDist, -sdBox(checkPos-vec3(inRad+0.20, 6.25, 0), vec3(0.19, 0.24, 0.19)), 0.12);\n  \/\/ top window grid\n  pp = p-vec3(0.0, 4.4, 0);\n  pModInterval1(pp.y, 0.4, 0.0, 2.);          \n  steelDist=min(steelDist, sdTorus(pp, vec2(inRad-0.02, .02)));  \n\n  \/\/ top railing\n  pp = p-vec3(0.0, 3.55, 0);\n  m = pModInterval1(pp.y, 0.15, 0.0, 3.);          \n  steelDist=min(steelDist, sdTorus(pp, vec2(outRad+0.05, mix(0.02, .035, step(3., m)))));\n\n  #ifdef HIGH_QUALITY  \n  d=min(d, sdSphere(p-vec3(0., 4., 0), 0.50));\n  \/\/ lamp\n  lampDist = sdEllipsoid(p-vec3(0., 4.9, 0), vec3(0.5, 0.6, 0.5)*(1.+abs(0.1*cos(p.y*50.))));\n  lampDist = min(lampDist, sdCappedCylinder(p-vec3(0.0, 4.5, 0), vec2(0.12, 1.2)));    \n  d=min(d, lampDist);\n  #endif\n    \n  \/\/ tower \"rings\"\n  pp = p-vec3(0.0, 4., 0);\n  m = pModInterval1(pp.y, 1.8, 0.0, 1.);  \n  dekoDist=min(dekoDist, sdTorus(pp, vec2(inRad, mix(.11, 0.15, step(1., m)))));                  \n\n  \/\/ upper \"rings\"\n  pp = p-vec3(0.0, -0.6, 0);\n  m = pModInterval1(pp.y, -1.05, 0.0, 1.);   \n  dekoDist=min(dekoDist, sdTorus(pp, vec2(mix(radius+0.15, radius+0.08, step(1., m)), 0.15)));                  \n\n\n  dekoDist=min(dekoDist, sdTorus(p-vec3(0.0, -.35, 0), vec2(radius-0.05, .15)));\n  dekoDist=min(dekoDist, fCylinderH(p-vec3(0.0, -.5, 0), radius+0.02, .15));\n  dekoDist=min(dekoDist, fCylinderH(p-vec3(0.0, 3.18, 0), radius+0.35, 0.15));  \n\n  \/\/ upper decoration\n  pp = p-vec3(0.0, 2.7, 0);     \n  dekoDist=min(dekoDist, fCylinderH(pp, radius+0.10, .30)); pp.y-=.15;\n  dekoDist=min(dekoDist, fCylinderH(pp, radius+0.28, 0.18)); pp.y-=.15;\n  dekoDist=min(dekoDist, fCylinderH(pp, radius+0.46, 0.18));\n  checkPos.xz = pModPolar(p.xz, 6.0);\n  dekoDist = max(dekoDist, -fCylinderV(checkPos-vec3(0.0, 2.4, 0), 0.6, 2.63));\n\n  \/\/ middle and lower \"rings\"\n  pp = p-vec3(0.0, -9., 0);\n  m = pModInterval1(pp.y, -2.3, 0.0, 1.);    \n  dekoDist=min(dekoDist, sdTorus(pp, vec2( mix( radius+0.6, 2.42, step(1., m)), .25))); \n\n  #ifdef HIGH_QUALITY\n  \/\/ windows cutouts   \n  checkPos.xz = pModPolar(p.xz, 6.0);   \n  d=max(d, -sdBox(checkPos-vec3(2.20, 1.07, 0.), vec3(3.25, 0.6, 0.4))); \n  checkPos.xz = pModPolar(p.xz, 5.0); \n  pp = checkPos-vec3(2.50, -6.83, 0.);\n  pModInterval1(pp.y, 3.5, 0.0, 1.);         \n  d= max(d, -sdBox(pp, vec3(1.3, 0.35, 0.35)));  \n  #endif\n\n  \/\/ upper windows   \n  checkPos.xz = pModPolar(p.xz, 6.0);   \n  winDist = min(winDist, Window(checkPos-vec3(2.20, 0, 0.))); \n\n  \/\/ small windows  (upper deco)\n  checkPos.xz = pModPolar(p.xz, 5.0); \n\n  pp = checkPos-vec3(2.10, -2.44, 0.0);\n  m=pModInterval1(pp.y, -3.5, 0., 1.);\n\n  pp-=mix(vec3(0.), vec3(0.28, 0.0, 0.), m);\n  dekoDist=min(dekoDist, sdBox(pp, vec3(0.3, 0.4, 0.12)));   \n  dekoDist = fOpIntersectionChamfer(dekoDist, -fCylinder(pp+vec3(-.30, -0.4, 0.0), 0.21, 0.63), .03); \n  dekoDist = max(dekoDist, -fCylinder(pp+vec3(-.40, .22, 0.0), 0.51, 0.63));  \n  dekoDist=min(dekoDist, sdTorus(p-vec3(0.0, -2.26 - (m*3.55), 0), vec2(radius+0.25, .15)*(1.0+(m*0.14))));\n\n  \/\/ small windows  \n  pp = checkPos-vec3(2.82, -8.0, 0.);\n  m=pModInterval1(pp.y, 3.5, 0., 1.);\n  winDist = min(winDist, SmallWindow(pp+mix(vec3(0.), vec3(0.28, 0.0, 0.), m)));   \n\n  #ifdef HIGH_QUALITY\n  \/\/ make tower hollow\n  d=max(d, -sdConeSection(p-vec3(0.0, -6.0, 0.), 5., 2.3, 1.55));\n  #endif\n    \n  dekoDist=min(dekoDist, sdTorus(p-vec3(0., -15.2, 0), vec2(2.5, .75*noiseScale2))); \n  \n  dekoDist=min(dekoDist, fCylinder(p-vec3(-0.05, -12.95, 2.25), 0.7, 0.5)); \n\n  \/\/ create door opening    \n  float doorOpening = min(sdBox(p-vec3(-0.05, -13.9, 2.5), vec3(1.3, 1.4, 4.6)), fCylinder(p-vec3(-0.05, -12.75, 2.5), 0.6, 4.6));\n\n  dekoDist = min(fOpPipe(dekoDist, doorOpening, 0.13), max(dekoDist, -doorOpening));\n\n  checkPos.xz = pModPolar(p.xz, 8.0);\n  d=fOpIntersectionChamfer(d, -fCylinderH(checkPos-vec3(2.95, -15.4, 0), 0.2, 3.6), 0.5);    \n  checkPos.xz = pModPolar(p.xz, 16.0);\n  d=fOpUnionChamfer(d, fCylinderH(checkPos-vec3(2.2, -10.3, 0), 0.03, 0.8), 0.4);    \n\n  d=max(d, -sdBox(p-vec3(-0., -14., 2.7), vec3(0.6, 1.3, 4.6)));    \n  d=max(d, -fCylinder(p-vec3(-0., -12.7, 2.5), 0.6, 4.6));    \n\n  \/\/ door   \n  doorDist =sdBox(p-vec3(-0., -13.6, 2.0), vec3(0.6, 1.3, 0.4)); \n\n  \/\/ door cutout     \n  pp = p-vec3(-0.28, -13., 2.4);\n  pModInterval1(pp.x, 0.46, 0., 1.);     \n  doorDist=max(doorDist, -sdBox(pp, vec3(0.15, 0.25, 0.08)));   \n  pp = p-vec3(-0.28, -13.8, 2.4);   \n  doorDist=max(doorDist, -sdBox(pp, vec3(0.15, 0.4, 0.08))); pp.x-=0.46;\n  doorDist=max(doorDist, -sdBox(pp, vec3(0.15, 0.4, 0.08))); \n\n  pp = p-vec3(-0., -15.20, 3.30);\n  pp.z+=0.3; pp.y-=0.15;\n  dekoDist=min(dekoDist, sdBox(pp, vec3(1.2, .075, 0.4)));  \n  pp.z+=0.3; pp.y-=0.15;\n  dekoDist=min(dekoDist, sdBox(pp, vec3(1.2, .075, 0.4)));  \n      pp.z+=0.3; pp.y-=0.15;\n  dekoDist=min(dekoDist, sdBox(pp, vec3(1.2, .075, 0.4)));  \n  d=min(d, steelDist);\n  d=min(d, dekoDist);\n  d=min(d, winDist);\n  d=min(d, doorDist);\n  return  d;\n}\n\n\n\n\nfloat MapGlass(  vec3 p)\n{   \n\n  p.y-=21.25;\n  vec3 checkPos = p;\n  \/\/ tower windows\n  float d = sdCappedCylinder(p-vec3(0.0, 5.0, 0), vec2(1.00, .8));\n  checkPos.xz = pModPolar(p.xz, 6.0);\n  \/\/ upper windows\n  #ifdef HIGH_QUALITY\n  d = min(d, sdBox(checkPos-vec3(1.550, 1.1, 0.), vec3(0.01, .60, 0.3)));   \n  #else\n  d = min(d, sdBox(checkPos-vec3(1.62, 1.1, 0.), vec3(0.01, .60, 0.3)));   \n  #endif  \n  checkPos.xz = pModPolar(p.xz, 5.0);\n  \/\/ middle and lower windows \n  #ifdef HIGH_QUALITY\n  checkPos-=vec3(2.03, -6.8, 0.);\n  #else\n  checkPos-=vec3(2.18, -6.8, 0.);\n  #endif\n    float m=pModInterval1(checkPos.y, 3.5, 0., 1.);\n  return min(d, sdBox(checkPos+mix(vec3(0.), vec3(0.28, 0.0, 0.), m), vec3(0.01, 0.4, .3)));\n}\n\n\n#define calcNormal( pos ) normalize( vec3(Map(pos+vec3(0.02, 0.0, 0.0).xyy) - Map(pos-vec3(0.02, 0.0, 0.0).xyy), 0.5*2.0*0.02, Map(pos+vec3(0.02, 0.0, 0.0).yyx) - Map(pos-vec3(0.02, 0.0, 0.0).yyx) ) )\n\n  float SoftShadow( in vec3 origin, in vec3 direction )\n{\n  float res = 1.0, t = 0.0, h;\n  for ( int i=0; i<NO_UNROLL(16); i++ )\n  {\n    h = Map(origin+direction*t);\n    res = min( res, 7.5*h\/t );\n    t += clamp( h, 0.02, 0.15);\n    if ( h<0.002 ) break;\n  }\n  return clamp( res, 0.0, 1.0 );\n}\n\nRayHit March( vec3 origin, vec3 direction, float maxDist)\n{\n  RayHit result;\n  float t = 0.0, dist = 0.0, glassDist=100000.0;\n  vec3 rayPos = vec3(0.);\n    float td=0.;\n  float precis=.0;\n  for ( int i=0; i<NO_UNROLL(120); i++ )\n  {\n    rayPos =origin+direction*t;\n    dist = Map( rayPos);\n    #ifdef HIGH_QUALITY\n    if(glassDist>0.05)\n    { \n      glassDist = min(glassDist, MapGlass(rayPos));\n    }\n    #else\n    glassDist =MapGlass(rayPos);\n    dist=min(dist,glassDist); \n    #endif\n    precis = 0.001*t;\n    if (dist<precis || t>maxDist )\n    {\n      result.hit=!(t>maxDist);\n      result.depth = t; \n      result.dist = dist;                              \n      result.hitPos = origin+direction*(t-td);   \n      result.winDist = winDist;\n      result.dekoDist = dekoDist;\n      result.glassDist = glassDist;\n      result.steelDist = steelDist;\n      result.lampDist = lampDist;\n      result.doorDist = doorDist;\n      break;\n    }\n    td= dist*0.65;\n      t+=td;\n  }    \n\n\n  return result;\n}\n\nmat3 setCamera( vec3 ro, vec3 ta, float cr )\n{\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n  vec3 cu = normalize( cross(cw, cp) );\n  vec3 cv = normalize( cross(cu, cw) );\n  return mat3( cu, cv, cw );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n  float occ = 0.0;\n  float sca = 1.0;\n  for ( int i=0; i<NO_UNROLL(3); i++ )\n  {\n    float hr = 0.01 + 0.1*float(i);\n    vec3 aopos =  nor * hr + pos;\n    float dd = Map( aopos );\n    occ += -(dd-hr)*sca;\n    sca *= 0.93;\n  }\n  return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\n\/\/ set sky color tone. \nvec3 GetSkyColor(vec3 rayDir)\n{ \n  float sun = mix(0., pow( clamp( 0.5 + 0.5*dot(sunPos, rayDir), 0.0, 1.0 ), 3.0 ), smoothstep(.33, .0, rayDir.y));\n  float sun2 = clamp( 0.75 + 0.25*dot(sunPos, rayDir), 0.0, 1.0 );\n\n  vec3 col = mix(vec3(156, 140, 164)\/255., vec3(166, 134, 150)\/255., smoothstep(0.8, 0.00, rayDir.y)*sun2);\n  col = mix(col, vec3(239, 181, 169)\/255., smoothstep(0.4, .0, rayDir.y)*sun2);\n  col = mix(col, vec3(255, 190, 136)\/255., smoothstep(.4, 1.0, sun));\n  col = mix(col, vec3(255, 135, 103)\/255., smoothstep(.8, 1.0, sun));\n\n  col = mix(col, col+vec3(1.0, 0.96, 0.90), pow(max(0., dot(sunPos, rayDir)), 14.0));\n\n  return col;\n}\n\n\n\nvec3 GetSceneLight(float specLevel, vec3 normal, RayHit rayHit, vec3 rayDir, vec3 origin, float specSize)\n{         \n  const vec3 sunColor = vec3(1.1, 0.53, 0.27); \n  vec3 reflectDir = reflect( rayDir, normal );\n\n  float occ = 1.;\n  #ifdef PERFORM_AO_PASS\n    occ = calcAO( rayHit.hitPos, normal );\n  #endif\n\n    vec3 lightTot = vec3(0.0);\n  float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );\n  float dif = clamp( dot( normal, sunPos ), 0.0, 1.0 );\n  float bac = clamp( dot( normal, normalize(vec3(-sunPos.x, 0.0, -sunPos.z)) ), 0.0, 1.0 );\n\n  float fre = clamp(1.0+dot(normal, rayDir), 0.0, 1.0);\n  specLevel*= pow(clamp( dot( reflectDir, sunPos ), 0.0, 1.0 ), 2.0);\n  float skylight = smoothstep( -0.1, 0.1, reflectDir.y );\n\n  float shadow=1.; \n  #ifdef SHADOWS\n    shadow = SoftShadow(rayHit.hitPos+normal*0.001, sunPos);\n  #endif\n    dif*=shadow;\n\n  lightTot += 1.6*dif*sunColor;\n\n  lightTot += 0.75*amb*vec3(0.35, 0.45, 0.6)*occ;  \n  lightTot += 0.270*skylight*GetSkyColor(reflectDir)*occ;\n  lightTot += 1.*specLevel*vec3(1., 0.85, 0.75)*dif;  \n  fre = pow( 1.0-abs(dot(rayHit.normal, rayDir)), 2.0)*occ;\n  fre = mix(0., mix( .1, 1.0, specLevel*0.5), fre );\n  lightTot = mix( lightTot, lightTot+ vec3(3.)*vec3(0.9, 0.6, 0.57), fre );\n\n  return clamp(lightTot, 0., 10.);\n}\n\n\nvoid ApplyFog(inout vec3 color, vec3 skyColor, vec3 rayOrigin, vec3 rayDir, float depth)   \n{\n  const vec3 sunColor = vec3(1.1, 0.53, 0.27); \n  float mixValue = smoothstep(50., 15000., pow(depth, 2.)*0.03);\n  float sunVisibility = max(0., dot(sunPos, rayDir));\n  \/\/ horizontal fog\n  vec3 fogColor = mix(sunColor*0.7, skyColor, mixValue);  \n  fogColor = mix(fogColor, sunColor, smoothstep(0., 0.5, sunVisibility));   \n  color = mix(color, fogColor, mixValue);\n\n  \/\/ vertical fog\n  const float heightAmount = .008;\n  float fogAmount = 0.2 * exp(-rayOrigin.y*heightAmount) * (1.0-exp( -depth*rayDir.y*heightAmount ))\/rayDir.y;\n  color = mix(color, fogColor, fogAmount);\n}\n\n\/\/ https:\/\/www.shadertoy.com\/view\/MtsGWH\nvec4 BoxMap( sampler2D sam, in vec3 p, in vec3 n, in float k )\n{\n  vec3 m = pow( abs(n), vec3(k) );\n  vec4 x = texture( sam, p.yz );\n  vec4 y = texture( sam, p.zx );\n  vec4 z = texture( sam, p.xy );\n  return (x*m.x + y*m.y + z*m.z)\/(m.x+m.y+m.z);\n}\nvec4 BoxMapFast( sampler2D sam, in vec3 p, in vec3 n, in float k )\n{\n  vec3 m = pow( abs(n), vec3(k) );\n  vec4 x = textureLod( sam, p.yz ,0.4);\n  vec4 y = textureLod( sam, p.zx ,0.4);\n  vec4 z = textureLod( sam, p.xy ,0.4);\n  return (x*m.x + y*m.y + z*m.z)\/(m.x+m.y+m.z);\n}\n\nvec4 GetMaterial(vec3 rayDir, inout RayHit rayHit, vec2 fragCoord, inout float specSize)\n{\n  vec2 center;\n  float dist;\n\n  float specLevel=1.;\n  specSize=12.8;\n\n  #ifdef LOWRES_TEXTURES\n  vec3 tex =  BoxMapFast(iChannel3, rayHit.hitPos*0.22, rayHit.normal, 0.5).rgb; \n  vec3 dirtTex =  BoxMapFast(iChannel3, (rayHit.hitPos+vec3(10000.0))*0.13, rayHit.normal, 0.5).rgb;   \n  #else\n  vec3 tex =  BoxMap(iChannel3, rayHit.hitPos*0.22, rayHit.normal, 0.5).rgb; \n  vec3 dirtTex =  BoxMap(iChannel3, (rayHit.hitPos+vec3(10000.0))*0.13, rayHit.normal, 0.5).rgb;   \n  #endif\n\n  float noiseTex = abs(noise(rayHit.hitPos*0.2));\n\n  vec3 scratches = dirtTex*tex;\n\n  vec3 altCol =dirtTex;\n\n\n  vec3 col = mix(mix(tex, vec3(1.3), 0.6), 0.7*dirtTex, smoothstep(0.196, 0.36, scratches.r));\n  altCol = mix(altCol, vec3(1.), smoothstep(0.196, 0.32, scratches.b));\n\n\n  col = mix(altCol, col, smoothstep(.6, .61, length(12.65-rayHit.hitPos.y)));   \n  col = mix(altCol, col, smoothstep(.60, .61, length(15.9-rayHit.hitPos.y))); \n  col = mix(altCol, col, smoothstep(.80, .81, length(19.85-rayHit.hitPos.y)));   \n  col = mix(col, altCol, smoothstep(25.15, 25.16, rayHit.hitPos.y));      \n\n  if (length(rayHit.dist-rayHit.winDist)<0.01)\n  {\n    specSize=10.;\n    col = mix(vec3(1.), vec3(0.37), smoothstep(0.156, 0.24, scratches.b))*(1.0+(noiseTex*0.15));\n    specLevel=mix(4., 0.45, col.r);\n  } else if (length(rayHit.dist-rayHit.dekoDist)<0.01)\n  {  \n    specLevel=2.; \n    specSize=20.;\n    col=altCol;\n  } else if (length(rayHit.dist-rayHit.steelDist)<0.01)\n  {  \n    float fre = clamp(1.0+dot(rayHit.normal, rayDir), 0.0, 1.0);\n    vec3 reflectDir = reflect( rayDir, rayHit.normal );\n    specLevel=2.2; \n    specSize=6.2;\n    col = mix(tex, vec3(1.1), smoothstep(0.14, 0.26, scratches.r));\n    col = mix(col, mix(col, GetSkyColor(reflectDir), 0.4), fre);\n  } else if (length(rayHit.dist-rayHit.doorDist)<0.01)\n  {       \n    specLevel=1.2;  \n    specSize=10.2;\n\n    col = mix(vec3(0.85), vec3(0.19), smoothstep(0.14, 0.3, scratches.r));\n  } \n  else\n  {\n    vec3 dirtMask = mix(col, min(col, dirtTex), smoothstep(0.13, 0.22, scratches.r));\n    col=mix(dirtMask, col, 0.2+(0.8*smoothstep(0., 0.84, rayHit.dekoDist)));\n    col=mix(dirtMask, col, 0.2+(0.8*smoothstep(0., 0.42, rayHit.winDist)));\n  }\n\n  vec3 moss =  mix(col, tex*vec3(0.356, 0.415, 0.328), 0.7);\n  moss = mix(moss, col, smoothstep(4.5, 10., rayHit.hitPos.y));\n  col = mix(col, moss, smoothstep(-.75, 0.1, 0.3+abs(noise(rayHit.hitPos*4.))-(0.11*rayHit.hitPos.y)));\n\n  specLevel = mix(2.*specLevel, specLevel*0.3, smoothstep(0.14, 0.26, scratches.b));\n\n\n  col *= 0.1+(max(0.7, dirtTex.b));   \n\n  \/\/ make specs irregular by using texture intensity to scale the values\n  specLevel*=tex.r;\n  specSize*=tex.r;\n        \n  #ifdef HIGH_QUALITY   \n  \/\/ color lamp\n  col = mix(vec3(1.0), col, smoothstep(0., 1.1, length(rayHit.dist-rayHit.lampDist)));\n  specLevel = mix(3., specLevel, step(0.01, length(rayHit.dist-rayHit.lampDist)));\n  specSize = mix(6., specSize, step(0.01, length(rayHit.dist-rayHit.lampDist)));\n  #endif\n    \n  return vec4(col, specLevel);\n}\n\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{  \n  vec2 uv = fragCoord.xy \/ iResolution.xy;\n  vec2 screenSpace = (-iResolution.xy + 2.0*(fragCoord))\/iResolution.y;\n\n  sunPos =  readRGB(ivec2(50, 0));\n  vec3 camData  = readRGB(ivec2(52, 0));  \n\n  \/\/ setup camera and ray direction\n  vec2 camRot = readRGB(ivec2(57, 0)).xy;\n\n\n  vec3 rayOrigin = vec3(camData.z*cos(camRot.x), camData.y, camData.z*sin(camRot.x) );    \n  rayOrigin.y = readRGB(ivec2(62, 0)).y;\n  mat3 ca = setCamera( rayOrigin, vec3(0., camData.y+(11.*camRot.y), 0. ), 0.0 );\n  vec3 rayDir = ca * normalize( vec3(screenSpace.xy, 2.0) );\n\n  \/\/ vec4 color = vec4(0.2,0.2,0.16,1000000000.);\/\/texture(iChannel0, uv);\n  vec4 color = textureLod(iChannel0, uv,0.);\n\n  float bufferDepth = color.a;\n  color.a=0.;\n\n  RayHit marchResult = March(rayOrigin, rayDir, min(110.,bufferDepth));\n\n  \/\/ only draw if ray hit is closer to camera origin than the same position in the buffer.\n    if (marchResult.hit)\n    {\n      float specSize = 1.0;\n      marchResult.normal = calcNormal(marchResult.hitPos);  \n        \n     #ifdef HIGH_QUALITY   \n     vec4 col = GetMaterial(rayDir, marchResult, fragCoord, specSize);\n\n      \/\/ get lightning based on material\n      vec3 light = GetSceneLight(col.a, marchResult.normal, marchResult, rayDir, rayOrigin, specSize);   \n      \/\/ apply lightning\n      color.rgb = col.rgb*light;\n\n      ApplyFog(color.rgb, GetSkyColor(rayDir), rayOrigin, rayDir, marchResult.depth);\n\n    \n     #else\n     if (marchResult.dist==marchResult.glassDist)\n     {       \n     vec3 sky= GetSkyColor(rayDir*=vec3(-1., 1., -1.));\n     color.rgb= mix(mix(color.rgb*0.4, sky, length(sky)*0.36), color.rgb, step(0.05, marchResult.glassDist));    \n     }\n     else\n     {\n        \n      vec4 col = GetMaterial(rayDir, marchResult, fragCoord, specSize);\n\n      \/\/ get lightning based on material\n      vec3 light = GetSceneLight(col.a, marchResult.normal, marchResult, rayDir, rayOrigin, specSize);   \n      \/\/ apply lightning\n      color.rgb = col.rgb*light;\n\n      ApplyFog(color.rgb, GetSkyColor(rayDir), rayOrigin, rayDir, marchResult.depth);\n     }  \n     #endif\n        \n      color.a+=1.;\n    }\n  \n\n    #ifdef HIGH_QUALITY\n    vec3 sky= GetSkyColor(rayDir*=vec3(-1., 1., -1.));\n    color.rgb= mix(mix(color.rgb*0.4, sky, length(sky)*0.36), color.rgb, step(0.05, marchResult.glassDist));\n    #endif\n \n    \n #ifdef PERFORM_AA_PASS\n    \/\/ Perform AA pass\n    if( iFrame>0 && bufferDepth<5000.) \n    {\n            \/\/ if the camera is kept steady, switch to fine AA pass.\n            if(length(readRGB(ivec2(62, 0))-readRGB(ivec2(60, 0)))>0.)           \n       {\n            \/\/ better for moving cameras\n            vec3 oldColor = textureLod(iChannel1, uv,1.0).rgb;\n            color.rgb = mix(color.rgb,oldColor,max(0.2,0.85*(clamp(bufferDepth,1.,100.)\/500.)));\n       }      \n            else\n            {\n                  \/\/ good for static camera\n             vec3 oldColor = texelFetch(iChannel1, ivec2(fragCoord-0.5), 0 ).rgb;\n            color.rgb = mix( oldColor, color.rgb, 0.15 );\n            }\n    }   \n  #endif\n\n  fragColor = color;\n}\n","name":"Buf D","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"ltlyz4","date":"1504269165","viewed":2003,"name":"Winterlands ","username":"ingagard","description":"Great thanks to Inigo Quilez, Ollj and FabriceNeyret2! I\u00b4ve finally learned some raymarching. :-)\n\nNOTE: Set treeDetail to 0.0 if FPS is too low.\n\nHOLD DOWN left mouse button and move the mouse to interact. Hope you like it! Enjoy!","likes":25,"published":3,"flags":96,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"\/media\/a\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"\/media\/ap\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"\/media\/a\/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"\/media\/ap\/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"\/media\/a\/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"\/media\/ap\/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define rotate(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nvec3 light = vec3(2.0, 3.0, 2.0);\nfloat camRot=1.4;\nvec2 cam_Adress = vec2(0.0, 0.0);\nvec2 cam_RotAdress = vec2(0.0, 1.0);\nvec3 camPos = vec3(0, 0, 0);\nvec2 scroll;\n\nconst vec3 eps = vec3(0.02, 0.0, 0.0);\nconst int maxRaySteps=360;\nconst float waterLevel = 9.7;\nconst float treeDetail = 0.2; \/\/0.0; Change if FPS is too low\nconst float texWaterLevel = 0.097;\nconst float treeSpacing = 1.8;\nconst float treeSpacingFactor = 1.0\/1.2;\nconst float treeSpacingScaler = 0.018*1.2;\nconst vec2 half_treeSpacing = vec2(0.6);\n\n\nstruct RayHit\n{\n  bool treeHit;\n  bool hit;  \n  vec3 hitPos;\n  vec3 normal;\n  float dist;\n  float depth;\n  float steps;\n  float unclampedHeight;\n  float terrainHeight;\n  float treeHeight;\n};\n\nbool treeHit;\nfloat terrainHeight;\nfloat treeHeight;\nfloat unclampedHeight;\nvec2 testPoint;\nvec2 test; \nvec2 pointWithoutMod;\nfloat heightMod;\n\nfloat GetTerrainHeight(in vec2 p)\n{\n  treeHit=false;\n  float col = textureLod(iChannel0, p*0.125, 0.0).r*0.20;\n  col -= textureLod(iChannel0, p*0.15, 0.0).r*0.191;\n  col += textureLod(iChannel0, p*0.15, 0.0).r*0.1;\n\n\n  \/\/ create trees at the right height level\n  if (col<texWaterLevel-0.003 && col>texWaterLevel-0.120)\n  {\n    testPoint = (p*300.0)+col*12.0;\n    test = mod(testPoint, treeSpacing+(col*treeDetail));           \n    pointWithoutMod =  testPoint - test; \n    heightMod = textureLod(iChannel0, pointWithoutMod*2.325, 0.0).r;\n\n\n    treeHeight = (heightMod-pow(treeSpacingFactor*distance(test, half_treeSpacing), 1.0+heightMod))*treeSpacingScaler;      \n    treeHeight -= (0.45*distance(col, texWaterLevel-0.0075));\n\n    if (treeHeight>0.002 )\n    {\n      col -= treeHeight;\n      treeHit=true;\n    }\n  }\n  \/\/ add stones at beach\n  if (col>texWaterLevel-0.01)\n  {\n\n    heightMod = textureLod(iChannel0, p*3.0, 0.0).r;\n\n\n    float stoneHeight = ((heightMod*0.03)-0.015);\n\n    if (stoneHeight>0.001)\n    {\n      col -= stoneHeight;\n    }\n  }\n\n  unclampedHeight = col;\n  terrainHeight = clamp(col, -1.0, texWaterLevel);\n  return terrainHeight;\n}\n\n\n\nfloat TerrainDistance( in vec3 p)\n{\n  return p.y + GetTerrainHeight(vec2(p.xz)+scroll);\n}\n\n\nvec3 CalcNormal( in vec3 pos )\n{    \n  return normalize( vec3(TerrainDistance(pos+eps.xyy) - TerrainDistance(pos-eps.xyy), 0.5*2.0*eps.x, TerrainDistance(pos+eps.yyx) - TerrainDistance(pos-eps.yyx) ) );\n}\n\n\nfloat TerrainSoftShadow( in vec3 origin, in vec3 direction )\n{\n  float res = 2.0;\n  float t = 0.0;\n  float hardness = 6.0;\n  for ( int i=0; i<8; i++ )\n  {\n    float h = TerrainDistance(origin+direction*t);\n    res = min( res, hardness*h\/t );\n    t += clamp( h, 0.02, 0.10 );\n    if ( h<0.002 ) break;\n  }\n  return clamp( res, 0.0, 1.0 );\n}\n\n\n\nRayHit TerrainMarch(in vec3 origin, in vec3 direction)\n{\n  RayHit result;\n  result.treeHit = false;\n  float maxDist = 1.0, precis = 0.007;\n  float t = 0.0, dist = 0.0, distStep = 0.1;\n  vec3 rayPos =vec3(0);\n\n  for ( int i=0; i<maxRaySteps; i++ )\n  {\n    rayPos =origin+direction*t;\n    dist = TerrainDistance( rayPos);\n\n    if (abs(dist)<precis || t>maxDist )\n    {        \n      result.hit = !(t>maxDist);\n      result.depth = t; \n      result.dist = dist;                              \n      result.hitPos = origin+((direction*t)*0.99);   \n      result.steps = float(i);\n      result.unclampedHeight=unclampedHeight;\n      result.treeHit = treeHit;\n      result.terrainHeight = terrainHeight;\n      result.treeHeight = treeHeight;\n      break;\n    }\n    t += dist*distStep;\n  }\n\n  return result;\n}\n\n\n\nvec4 read(in sampler2D buffer, in vec2 memPos, vec2 resolution)\n{\n  return texture(buffer, (memPos+0.5)\/resolution, -100.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\n  if (iFrame>0)\n  {\n    camPos = read(iChannel3, cam_Adress, iChannelResolution[3].xy).rgb;\n    camRot = read(iChannel3, cam_RotAdress, iChannelResolution[3].xy).r;\n  }\n\n  vec2 uv = fragCoord.xy \/ iResolution.xy;\n  if (iMouse.z>0.0) camRot= (iMouse.x - iResolution.x * 0.5)*0.01;   \n  \/\/float camPitch= (iMouse.y - iResolution.y * 0.25)*0.01;   \n\n  vec3 camOrigin = vec3(0, 0, -2);\n  vec2 screenSpace = (2.0*fragCoord.xy-iResolution.xy)\/iResolution.y;\n  screenSpace-=0.2;\n    \n  scroll = camPos.xy;\n  vec3 directionRay = normalize(vec3(screenSpace, 1.0));\n    \n  directionRay.xz *= rotate(camRot);\n  directionRay = normalize(directionRay);\n    \n  vec3 sunPos = normalize(vec3(0.3, 0.7, 1.0));\n  vec4 sunColor = vec4(0.80, 0.7, 0.55, 1.0);\n\n  vec4 haze =  mix(vec4(0.9), vec4(0.6, 0.7, 0.8, 1.0), smoothstep(0., 0.6, abs(directionRay.y*2.0))); \n  haze =  mix(haze, vec4(0.6, 0.7, 0.8, 1.0), smoothstep(0., 1.1, abs(directionRay.y*1.1))); \n\n  vec2 cloudUV = vec2(uv.x, distance(0.0, uv.y) * 1.0); \n\n  vec4 color = haze;\n  vec4 clouds = vec4(texture(iChannel3, cloudUV).a);\n\n  float cloudOpacity = clouds.a;\n  vec4 cloudNormal = vec4(vec4(normalize(vec3(texture(iChannel3, cloudUV + vec2(-0.001, 0)).a-texture(iChannel3, cloudUV + vec2(+0.001, 0)).a, texture(iChannel3, cloudUV + vec2(0, -0.001)).a-texture(iChannel3, cloudUV + vec2(0, +0.001)).a, .02)), 1.0).xyz * 0.5 + 0.5, 1.);\n\n  float cloudInt = (cloudNormal.r+cloudNormal.g+cloudNormal.b)*0.333;\n\n  color = max(color, (color+cloudInt)*0.5);\n\n\n  float diff2= clamp(dot(cloudNormal.xyz, sunPos-directionRay), 0.0, .80);\n\n  clouds*=diff2*sunColor;\n  color += color*clouds;\n\n\n  RayHit marchResult = TerrainMarch(camOrigin, directionRay);\n\n\n  if (marchResult.hit)\n  {\n    \/\/ get raymarch normal\n    marchResult.normal = CalcNormal(marchResult.hitPos);  \n\n    float height =  marchResult.terrainHeight*100.0;\n    float realHeight =  marchResult.unclampedHeight*100.0;\n    vec4 waterColor = color;\n    vec2 waterMotion = vec2(float(iTime)*.005, float(iTime)*.0012);\n\n    \/\/ check if area is below water level\n    if (height+0.2>waterLevel && !marchResult.treeHit)\n    {\n      vec4 bottomColor = texture(iChannel2, (marchResult.hitPos.xz+scroll)*22.30);\n      float scale1 = 14.0;\n      float scale2 = 16.0;\n      float scale3 = 22.0;\n      vec2 uvCoord = (marchResult.hitPos.xz+scroll+waterMotion)*scale1;\n\n      vec4 wavenormal = vec4(vec4(normalize(vec3(texture(iChannel0, uvCoord\n        + vec2(-0.001, 0)).r-texture(iChannel0, uvCoord\n        + vec2(+0.001, 0)).r, texture(iChannel0, uvCoord\n        + vec2(0, -0.001)).r-texture(iChannel0, uvCoord\n        + vec2(0, +0.001)).r, .02)), 1.0).xyz * 0.5 + 0.5, 1.)*0.33333;\n\n      uvCoord = (marchResult.hitPos.xz+scroll+waterMotion)*scale2;\n\n      wavenormal += vec4(vec4(normalize(vec3(texture(iChannel1, uvCoord\n        + vec2(-0.001, 0)).r-texture(iChannel0, uvCoord\n        + vec2(+0.001, 0)).r, texture(iChannel0, uvCoord\n        + vec2(0, -0.001)).r-texture(iChannel0, uvCoord\n        + vec2(0, +0.001)).r, .02)), 0.0).xyz * 0.5 + 0.5, 1.)*0.33333;\n\n      uvCoord = (marchResult.hitPos.xz+scroll+waterMotion)*scale3;\n\n      wavenormal += vec4(vec4(normalize(vec3(texture(iChannel2, uvCoord\n        + vec2(-0.001, 0)).r-texture(iChannel2, uvCoord\n        + vec2(+0.001, 0)).r, texture(iChannel2, uvCoord\n        + vec2(0, -0.001)).r-texture(iChannel2, uvCoord\n        + vec2(0, +0.001)).r, .02)), 1.0).xyz * 0.5 + 0.5, 1.)*0.33333;\n\n\n      \/\/ set normal to rgb 0,1,0  to do mirror reflections on water surface\n      vec3 ref = normalize(reflect(directionRay, vec3(0.0, 1.0, 0.0)));\n      RayHit reflectResult = TerrainMarch(marchResult.hitPos + (ref*0.001), ref); \n\n      float waveDepth = pow((wavenormal.r+wavenormal.g+wavenormal.b)*0.75, 2.0);\n\n\n      \/\/ draw reflected objects and mix with water color\n      if (reflectResult.hit==true)\n      {\n        waterColor *= mix(waterColor, textureLod(iChannel1, (reflectResult.hitPos.xz+scroll)*18.0, 0.0), waveDepth);\n      }\n\n\n\n      float atten = max(1.0 - dot(wavenormal.r, reflectResult.dist) * 0.001, 0.0)*1.5;\n\n\n      waterColor*= atten;\n\n      waterColor = mix(waterColor, waterColor*0.12, wavenormal.g);\n      waterColor = mix(waterColor, waterColor*1.20, wavenormal.r);\n    }\n\n    \/\/ terrain color \n    if (marchResult.treeHit==false)\n    {\n\n      \/\/ texturing\n      vec4 texcolor = textureLod(iChannel0, (marchResult.hitPos.xz+scroll)*8.0, 0.0);\n      vec4 texcolor2 = mix(mix(texcolor, textureLod(iChannel1, (marchResult.hitPos.xz+scroll)*7.30, 0.0), 0.8), texcolor, pow(texcolor.r, 2.0));\n      vec4 texcolor3 = mix(texcolor, textureLod(iChannel2, (marchResult.hitPos.xz+scroll)*22.30, 0.0), 1.4);\n      vec4 moss = textureLod(iChannel0, (marchResult.hitPos.xz+scroll)*27.30, 0.0)*1.5*vec4(0.7, 0.8, 0.3, 1.0);\n\n\n      vec4 finalColor = mix(texcolor, textureLod(iChannel1, (marchResult.hitPos.xz+scroll)*5.90, 0.0), 1.4);\n      finalColor= mix(finalColor, textureLod(iChannel1, (marchResult.hitPos.xz+scroll)*4.0, 0.0), 0.5);\n      finalColor = mix(finalColor, texcolor2, smoothstep(0.0, 0.3, marchResult.normal.z));\n\n      \/\/ apply snow\n      finalColor = mix(vec4((texcolor2.r+texcolor2.g+texcolor2.b)+finalColor)*0.85, finalColor, smoothstep(0.04, 0.4, marchResult.normal.x));\n      \/\/ apply moss\n      finalColor = mix(finalColor, moss, smoothstep(0.0, 0.40, pow(texcolor3.r, 3.0))*smoothstep(waterLevel-2.30, waterLevel-0.6, realHeight));\n\n\n      float diff= clamp(dot(marchResult.normal, normalize(sunPos)), 0.0, 1.0);\n      float shadow = TerrainSoftShadow(marchResult.hitPos, normalize(sunPos));\n      float amb = clamp( 0.5+0.5*marchResult.normal.r, 0.0, 1.0 )*1.0;\n\n      vec3 lin = vec3(0.0);  \n      lin+=diff*shadow;\n      lin+=amb*vec3(0.5, 0.5, 0.8)*2.0;\n\n\n      \/\/ apply lightning\n      color = finalColor*vec4(lin, 1.0)*sunColor;\n      \/\/ apply shoreline \n      color = mix(color, texcolor3*1.5*sunColor, smoothstep(waterLevel-0.20, waterLevel-0.2, realHeight));\n      \/\/ apply water transition\n      waterColor = mix((color*waterColor), waterColor, smoothstep(waterLevel, waterLevel+0.4, realHeight));\n\n      \/\/ apply water\n      color = mix(waterColor+0.24, color, smoothstep(waterLevel, waterLevel-.3, realHeight));\n\n      color=mix(color, color*shadow, 0.34);\n    }\n    \/\/ tree color  \n    else\n    {\n      vec4 snowMask = vec4(textureLod(iChannel1, (marchResult.hitPos.xz+scroll)*12.30, 0.0).r*5.0);\n      vec4 pine = textureLod(iChannel0, (marchResult.hitPos.xz+scroll)*127.30, 0.0)*0.6*vec4(0.4, 0.8, 0.1, 1.0);\n\n      color = pine*vec4(1.0\/max(1.20, (0.015*marchResult.steps)));\n\n      \/\/ apply snow\n      color = mix(vec4(snowMask+color)*0.45, color, smoothstep(0.10, 1.0, 1.0\/(300.0*marchResult.treeHeight)));\n      color = mix(vec4(snowMask+color)*0.45, color, smoothstep(0.04, 0.4, marchResult.normal.x));\n\n\n      float diff= clamp(dot(marchResult.normal, normalize(sunPos)), 0.0, 1.0);\n      float shadow = TerrainSoftShadow(marchResult.hitPos, normalize(sunPos));\n      float amb = clamp( 0.5+0.5*marchResult.normal.r, 0.0, 1.0 )*1.0;\n\n      vec3 lin = vec3(0.0);  \n      lin+=diff*shadow;\n      lin+=amb*vec3(0.5, 0.5, 0.8)*2.0;\n\n      color = color*vec4(lin, 1.0)*sunColor;\n    }\n\n\n\n    \/\/ apply fog\n    color =mix(color*(1.5-(0.12*height)), haze, pow(0.95*marchResult.depth, 1.2));\n   \n      \/\/ apply snowy winds\n    vec2 winduv= marchResult.hitPos.xz+scroll+vec2(float(iTime)*0.005, float(iTime)*0.02);\n    color =mix(color, (color+vec4(textureLod(iChannel0, winduv*0.24, 0.0).r))*0.75, pow(4.0*clamp(marchResult.terrainHeight, 0.0, 1.0), 2.0));\n    color =mix(color, (color+vec4(textureLod(iChannel0, winduv*1.24, 0.0).r))*0.75, pow(4.0*clamp(marchResult.terrainHeight, 0.0, 1.0), 2.0));\n    color =mix(color, (color+vec4(textureLod(iChannel0, winduv*2.24, 0.0).r))*0.75, pow(4.0*clamp(marchResult.terrainHeight, 0.0, 1.0), 2.0));\n  }\n\n  \/\/ sun\n  float sun = clamp( dot(sunPos, directionRay), 0.0, 1.0 );\n  color += vec4(vec3(.9, 0.4, 0.2)*sun*sun*clamp((directionRay.y+0.4)\/0.4, 0.0, 0.40), 1.0);\n\n  color*=mix(0.0,1.0, smoothstep(0.0,0.75,float(iTime)));\n  fragColor = vec4(pow(color.rgb, vec3(1.0\/0.9)), 1.0 ) * (0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.2 ));\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3Rr","filepath":"\/media\/a\/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"\/media\/ap\/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"\/media\/a\/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"\/media\/ap\/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"MdXSWf","filepath":"https:\/\/soundcloud.com\/relaxdaily\/instrumental-background-music-france-vid","previewfilepath":"https:\/\/soundcloud.com\/relaxdaily\/instrumental-background-music-france-vid","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define rotate(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n  struct RayHit\n{\n  bool treeHit;\n  bool hit;  \n  vec3 hitPos;\n  vec3 normal;\n  float dist;\n  float depth;\n  float steps;\n  float id;\n};\n\nfloat camRot=1.5;\n\nvec2 cam_Adress = vec2(0.0, 0.0);\nvec2 cam_RotAdress = vec2(0.0, 1.0);\nfloat moveSpeed= 0.001; \nvec3 camPos = vec3(0, 0, 1.5);\n\nvec4 read(in sampler2D buffer, in vec2 memPos, vec2 resolution)\n{\n  return texture(buffer, (memPos+0.5)\/resolution, -100.);\n}\n\nvec4 GetCloudColor(in vec2 p)\n{\n  float col = textureLod(iChannel0, p*.19, 0.0).r;\n  col -= textureLod(iChannel0, p*.15, 0.0).r;\n  col += textureLod(iChannel0, p*.01, 0.0).r;\n  col *= textureLod(iChannel0, p*.15, 0.0).r*1.5;\n  return vec4(col);\n}\n\n\n\nfloat ellipsoid( in vec3 p, in vec3 r )\n{\n  return (length( p\/r ) - 1.0) * min(min(r.x, r.y), r.z);\n}\n\n\nRayHit SkyMarch(in vec3 origin, in vec3 direction)\n{\n  RayHit result;\n  result.treeHit = false;\n  float maxDist = 10.10, precis = 0.004;\n  float t = 0.0, dist = 0.0, distStep = 0.75;\n  vec3 rayPos =vec3(0);\n\n  for ( int i=0; i<64; i++ )\n  {\n    rayPos =origin+direction*t;\n\n    dist = max(ellipsoid(  rayPos-vec3(0.0, 0., -2.0), vec3( 10.0, 0.5, 10.0)), \n      -ellipsoid( rayPos-vec3(0.0, 0., -2.0), vec3(9.0, 0.49, 9.0)));\n\n    if (abs(dist)<precis || t>maxDist )\n    {        \n      result.hit=true;\n      result.depth = t; \n      result.dist = dist;                              \n      result.hitPos = origin+((direction*t)*0.99);   \n      result.steps = float(i);\n      result.id=1.0;\n      break;\n    }\n    t += dist*distStep;\n  }\n  if (t>maxDist) {\n    result.hit=false;\n  }\n\n  return result;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n  if (iFrame>0)\n  {\n    camPos = read(iChannel3, cam_Adress, iChannelResolution[3].xy).rgb;\n    camRot = read(iChannel3, cam_RotAdress, iChannelResolution[3].xy).r;    \n   \n    if (iMouse.z>0.0) camRot= (iMouse.x - iResolution.x * 0.5)*0.01;    \n    camPos.xy-=vec2(cos(camRot-1.5707963268), sin(camRot-1.5707963268))*moveSpeed;\n  }\n\n\n  vec2 uv = fragCoord.xy \/ iResolution.xy;\n  float vig = 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 );     \n  \/\/  vec4 haze =  mix(vec4(0.6,0.7,0.8,1.0),vec4(0.9),  (1.0-uv.y) * 2.0);  \n  vec4 color =vec4(0);\/\/haze;\n\n\n\n  float camPitch= clamp((iMouse.y - iResolution.y * 0.5)*0.01, 0.0, 1.1);   \n\n  vec2 cloudPos = vec2(float(iTime)*0.01, float(iTime)*0.04)*0.8;\n  vec2 scroll = camPos.xy*1.;\n\n  vec3 camOrigin = vec3(0, 0, -2);\n  vec2 screenSpace = (2.0*fragCoord.xy-iResolution.xy)\/iResolution.y;\n\n  vec3 directionRay = normalize(vec3(screenSpace, 1.0));\n\n\n  \/\/ directionRay.yz *= rotate(camPitch);\n  directionRay.xz *= rotate(camRot);\n\n\n\n\n  if (distance(fragCoord, cam_Adress)<=1.0)\n  {\n    fragColor.rgb = camPos;\n  }\n  else if (distance(fragCoord, cam_RotAdress)<=1.0)\n  {\n    fragColor.r = camRot;\n  }\n    \n  if (uv.y>=0.5)\n  {\n    RayHit marchResult =SkyMarch(camOrigin, directionRay);\n\n    if (marchResult.hit)\n    {\n\n      vec4 cloudColor = GetCloudColor(marchResult.hitPos.xz+cloudPos+scroll);\n      color = mix(color, mix(color, cloudColor, cloudColor.a), smoothstep(0.0, .12, 1.0\/marchResult.dist));\n    }\n\n    color.r = mix(color.r, 0.0, 0.80-(distance(screenSpace.y, 0.0)));\n  } else\n  {\n    color.r = texture(iChannel3, vec2(uv.x, 1.0-(uv.y))).a;\n  }\n  fragColor.a =  clamp(color.r, 0.0, 1.0);\n  \/\/ fragColor = color;\n}\n","name":"Buf A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"ltXcDr","date":"1504442037","viewed":1080,"name":"Retro Gaming","username":"ingagard","description":"I really love this raymarch stuff. As a graphics artist, I wanted to try making a real model out of raymarch shapes. Hope you like the outcome.\nI decided to come up with my own design for the gamepad to not break any design-copyrights. ENJOY!","likes":22,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dX3zn","filepath":"\/media\/a\/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"\/media\/ap\/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ CREATED BY KIM BERKEBY, SEP 2017 \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/ BIG THANKS TO Inigo Quilez FOR PROVIDING THE SHAPE DISTANCE FUNCTIONS \/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nstruct RayHit\n{\n  bool hit;  \n  vec3 hitPos;\n  vec3 normal;\n  float dist;\n  float depth;\n  float steps;\n  int hitID;\n};\n\n\nRayHit marchResult;\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y, max(q.x*0.866025+p.y*0.5, -p.y)-h.x*0.5);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa, ba)\/dot(ba, ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n#define rotate(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat Cable( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a;\n  b.xz = mix(b.xz, b.xz*rotate(1.1), smoothstep(1.0, 6.0, pa.z));\n  b.xz = mix(b.xz, b.xz*rotate(-1.20), smoothstep(1.0, 14.0, pa.z));\n  b.y = mix(b.y, -1.55, smoothstep(.0, 1.0, pa.z));\n\n  vec3 ba = b - a;\n  float h = clamp( dot(pa, ba)\/dot(ba, ba), 0.0, 1.0 );\n\n  return length( pa - ba*h ) - r;\n}\n\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n  return (length( p\/r ) - 1.0) * min(min(r.x, r.y), r.z);\n}\n\n\nvec3 opRotXY( vec3 pos, vec3 rayPos, float rad )\n{\n  vec3 sPos = rayPos-pos;\n  sPos.xy *= rotate(rad);\n  return sPos+rayPos;\n}\nvec3 opRotXZ( vec3 pos, vec3 rayPos, float rad )\n{\n  vec3 sPos = rayPos-pos;\n  sPos.xz *= rotate(rad);\n  return sPos+rayPos;\n}\nvec3 opRotYZ( vec3 pos, vec3 rayPos, float rad )\n{\n  vec3 sPos = rayPos-pos;\n  sPos.yz *= rotate(rad);\n  return sPos+rayPos;\n}\n\n\n\nfloat ControllerBase(in vec3 p, vec3 oPos, float oScale)\n{\n\n  float d = sdCappedCylinder(p-oPos-vec3(1.40, -0.04, 0.0), vec2(1.0, 0.12)*oScale);\n  d = min(d, sdCappedCylinder(p-oPos-vec3(-1.40, -0.04, 0.0), vec2(1.0, 0.12)*oScale));\n  d = min(d, sdCappedCylinder(p-oPos-vec3(-.35, 0.0, -.40), vec2(0.5, 0.08)*oScale));\n  d = min(d, sdCappedCylinder(p-oPos-vec3(.35, 0.0, -.40), vec2(0.5, 0.08)*oScale));\n\n\n  d=min(d, sdBox(p-oPos-vec3(.0, 0.0, 0.2), vec3(1.0, .08, 0.7)*oScale));\n  d = min(d, sdBox(p-oPos-vec3(.0, 0.0, 0.2), vec3(0.50, .07, 0.79)*oScale));\n  d=max(d, -sdBox(p-oPos-vec3(.0, 0.0, 1.1), vec3(0.20, 1.08, 0.15)*oScale));   \n\n  return d;\n}\n\nfloat ShoulderButtons(in vec3 p, float controllBase, vec3 oPos, float oScale)\n{\n  float d = sdCappedCylinder(p-oPos-vec3(1.45, -0.1, 0.10), vec2(1.0, 0.12)*oScale);\n  d = min(d, sdCappedCylinder(p-oPos-vec3(-1.45, -0.1, 0.10), vec2(1.0, 0.12)*oScale));\n  d =  min(d, sdBox(p-oPos-vec3(.0, -0.1, 0.2), vec3(1.60, .08, 0.8)*oScale));\n\n  d=  max(d, -sdBox(p-oPos-vec3(.0, 0.0, 0.42), vec3(1.2, 1.08, 2.9)*oScale));\n  d=  max(d, -sdBox(p-oPos-vec3(2.50, 0.0, 0.42), vec3(0.4, 1.08, 2.9)*oScale));\n  d=  max(d, -sdBox(p-oPos-vec3(-2.50, 0.0, 0.42), vec3(0.4, 1.08, 2.9)*oScale));\n\n  d=  max(d, -sdBox(p-oPos-vec3(0, 0.0, -0.42), vec3(3.0, 0.68, 1.)*oScale));\n\n  return d;\n}\n\n\nfloat d,d1,d2,d3,d4,d5,d6,d7,d8,d9;\n\nfloat Map( in vec3 p)\n{\n    d,d1,d2,d3,d4,d5,d6,d7,d8,d9 = 100000.0;\n    \n  d8 = ControllerBase(p, vec3(0, -0.51, 1.0), 1.05);\n  d = ControllerBase(p, vec3(0, -0.3, 1.0), 1.0);\n\n  \/\/ button ring\n  d=  max(d, -sdCappedCylinder(p-vec3(-1.45, -0.22, 1.0), vec2(0.8, 0.02)));\n  d8=  min(d8, sdCappedCylinder(p-vec3(-1.45, -0.25, 1.0), vec2(0.765, 0.03)));\n  d8=  min(d8, sdEllipsoid(p-vec3(-1.45, -0.25, 1.0), vec3(0.7, 0.1, 0.7)));\n\n  \/\/ button holes\n  d8=  max(d8, -sdEllipsoid(p-vec3(-1.45, -0.18, 1.40), vec3(0.32, 0.06, 0.32)));\n  d8=  max(d8, -sdEllipsoid(p-vec3(-1.45, -0.18, .60), vec3(0.32, 0.06, 0.32)));\n  d8=  max(d8, -sdEllipsoid(p-vec3(-1.90, -0.18, 1.0), vec3(0.32, 0.06, 0.32)));\n  d8=  max(d8, -sdEllipsoid(p-vec3(-1.00, -0.18, 1.0), vec3(0.32, 0.06, 0.32)));\n\n  \/\/ buttons\n  d2= sdCappedCylinder(p-vec3(-1.45, -0.3, 1.40), vec2(0.18, 0.12));\n  d9= sdCappedCylinder(p-vec3(-1.45, -0.3, 0.60), vec2(0.18, 0.12));\n  d2= min(d2, sdCappedCylinder(p-vec3(-1.90, -0.3, 1.0), vec2(0.18, 0.12)));\n  d9= min(d9, sdCappedCylinder(p-vec3(-1.0, -0.3, 1.0), vec2(0.18, 0.12)));\n\n  \/\/ button details       \n  d2=  max(d2, -sdEllipsoid(p-vec3(-1.45, -0.16, 1.40), vec3(0.25, 0.04, 0.25)));\n  d9=  max(d9, -sdEllipsoid(p-vec3(-1.45, -0.16, .60), vec3(0.25, 0.04, 0.25)));\n  d2=  max(d2, -sdEllipsoid(p-vec3(-1.90, -0.16, 1.0), vec3(0.25, 0.04, 0.25)));\n  d9=  max(d9, -sdEllipsoid(p-vec3(-1.0, -0.16, 1.0), vec3(0.25, 0.04, 0.25)));\n\n  \/\/ cross cutout\n  d=  max(d, -sdEllipsoid(p-vec3(1.55, -0.22, 1.0), vec3(0.7, 0.1, 0.7)));\n  d=  max(d, -sdEllipsoid(p-vec3(1.55, -0.22, 1.0), vec3(1.0, 0.03, 1.0)));\n  d3 = sdEllipsoid(p-vec3(1.55, -0.265, 1.0), vec3(.46, 0.06, .46));\n\n  \/\/ cross\n  d3 = min(d3, sdBox(p-vec3(1.55, -0.22, 1.0), vec3(0.4, 0.06, 0.13)));\n  d3 = min(d3, sdBox(p-vec3(1.55, -0.22, 1.0), vec3(0.13, 0.06, 0.4)));\n\n  \/\/ cross details\n  d3=  max(d3, -sdEllipsoid(p-vec3(1.55, -0.2, 1.0), vec3(0.16, 0.04, 0.16)));\n\n  \/\/ calculate button arrows and perform boolean\n  vec3 pPos = p-vec3(1.55, -0.13, 1.25);\n  pPos.xz *=rotate(radians(120.0));\n  pPos.zy *=rotate(radians(90.0));\n  d3 = max(d3, -sdTriPrism(pPos, vec2(.15, 0.05)));\n\n  pPos = p-vec3(1.55, -0.13, 0.75);\n  pPos.xz *=rotate(radians(300.0));\n  pPos.zy *=rotate(radians(90.0));\n  d3 = max(d3, -sdTriPrism(pPos, vec2(.15, 0.05)));\n\n  pPos = p-vec3(1.8, -0.13, 1.0);\n  pPos.xz *=rotate(radians(210.0));\n  pPos.zy *=rotate(radians(90.0));\n  d3 = max(d3, -sdTriPrism(pPos, vec2(.15, 0.05)));\n\n  pPos = p-vec3(1.3, -0.13, 1.0);\n  pPos.xz *=rotate(radians(30.0));\n  pPos.zy *=rotate(radians(90.0));\n  d3 = max(d3, -sdTriPrism(pPos, vec2(.15, 0.05)));\n\n  \/\/ cable input\n  d=max(d, -sdCapsule(p-vec3(.0, -0.4, 2.1), vec3(0.0, 0.0, -0.5), vec3(0.0, 0.0, 3.0), 0.13));   \n  d=min(d, sdCapsule(p-vec3(.0, -0.39, 2.07), vec3(0.0, 0.0, -0.1), vec3(0.0, 0.0, -0.1), 0.11));   \n\n  \/\/ cable\n  d4 = sdCapsule(p-vec3(.0, -0.39, 2.07), vec3(0.0, 0.0, 0), vec3(0.0, 0.0, 0), 0.11);       \n  d4=min(d4, Cable(p-vec3(.0, -0.4, 2.1), vec3(0., 0., -1.0), vec3(0., 0., 70.0), 0.072));   \n\n  \/\/ analog buttons\n  d= max(d, -sdEllipsoid(p-vec3(0.35, -0.15, .50), vec3(0.4, 0.2, 0.4)));\n  d= max(d, -sdEllipsoid(p-vec3(-0.35, -0.15, .50), vec3(0.4, 0.2, 0.4)));\n\n  d5=  sdEllipsoid(p-vec3(0.35, -0.35, .50), vec3(0.3, 0.18, 0.3));\n  d5= min(d5, sdCappedCylinder(p-vec3(0.35, -0.35, .50), vec2(0.15, 0.3)));\n  d5=  min(d5, sdEllipsoid(p-vec3(0.35, -0.05, .50), vec3(0.22, 0.03, 0.22)));\n\n  d5=  min(d5, sdEllipsoid(p-vec3(-0.35, -0.35, .50), vec3(0.3, 0.18, 0.3)));\n  d5= min(d5, sdCappedCylinder(p-vec3(-0.35, -0.35, .50), vec2(0.15, 0.3)));\n  d5=  min(d5, sdEllipsoid(p-vec3(-0.35, -0.05, .50), vec3(0.22, 0.03, 0.22)));\n\n  \/\/ start select cutouts\n  d=max(d, -sdCapsule(p-vec3(-.1, -.06, 1.4), vec3(0., 0., -0.15), vec3(-0.22, 0., 0.05), 0.2));   \n  d=max(d, -sdCapsule(p-vec3(.45, -.06, 1.4), vec3(0., 0., -0.15), vec3(-0.22, 0., 0.05), 0.2));   \n\n  \/\/ start select buttons\n  d7=sdCapsule(p-vec3(-.1, -.25, 1.4), vec3(0., 0., -0.15), vec3(-0.22, 0., 0.05), 0.095);   \n  d7=min(d7, sdCapsule(p-vec3(.45, -.25, 1.4), vec3(0., 0., -0.15), vec3(-0.22, 0., 0.05), 0.095));   \n\n  d6 = ShoulderButtons(p, d, vec3(0, -0.3, 1.0), 1.0);\n\n    \n  return  min(d,min(d2,min(d3,min(d4,min(d5,min(d6,min(d7,min(d8,min(d9,p.y+0.75)))))))));\n}\n\n\nvec3 calcNormal( in vec3 pos )\n{   \n    const vec3 eps = vec3(0.02, 0.0, 0.0);\n  return normalize( vec3(Map(pos+eps.xyy) - Map(pos-eps.xyy), 0.5*2.0*eps.x, Map(pos+eps.yyx) - Map(pos-eps.yyx) ) );\n}\n\nfloat SoftShadow( in vec3 origin, in vec3 direction )\n{\n  float res = 2.0;\n  float t = 0.0;\n  float hardness = 6.50;\n  for ( int i=0; i<10; i++ )\n  {\n    float h = Map(origin+direction*t);\n    res = min( res, hardness*h\/t );\n    t += clamp( h, 0.02, 0.075 );\n    if ( h<0.002 ) break;\n  }\n  return clamp( res, 0.0, 1.0 );\n}\n\n\nRayHit March(in vec3 origin, in vec3 direction, float maxDist, float precis, int maxSteps)\n{\n  RayHit result;\n\n  float t = 0.0, dist = 0.0, distStep = 1.0;\n  vec3 rayPos =vec3(0);\n\n  for ( int i=0; i<maxSteps; i++ )\n  {\n    rayPos =origin+direction*t;\n    dist = Map( rayPos);\n\n    if (abs(dist)<precis || t>maxDist )\n    {    \n        result.hitID =10;\n        \n        if(d == dist){  result.hitID =1;}\n        else if(d2 == dist){  result.hitID =2;}\n        else if(d3 == dist){  result.hitID =3;}\n        else if(d4 == dist){  result.hitID =4;}\n        else if(d5 == dist){  result.hitID =5;}\n        else if(d6 == dist){  result.hitID =6;}\n        else if(d7 == dist){  result.hitID =7;}\n        else if(d8 == dist){  result.hitID =8;}\n        else if(d9 == dist){  result.hitID =9;}\n   \n      result.depth = t; \n      result.dist = dist;                              \n      result.hitPos = origin+((direction*t)*0.99);   \n      result.steps = float(i);\n      break;\n    }\n    t += dist*distStep;\n  }\n\n\n  return result;\n}\n\n\/\/ Thanks to Inigo Quilez\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n  vec3 cu = normalize( cross(cw, cp) );\n  vec3 cv = normalize( cross(cu, cw) );\n  return mat3( cu, cv, cw );\n}\n\nvec3 GetSceneLight(float specLevel, vec3 normal, vec3 pos, vec3 rayDir)\n{      \n  vec3 light1 = normalize(vec3(-1.0, 2.8, 1.0));\n    \n  vec3 reflectDir = reflect( rayDir, normal );\n  specLevel *= pow(clamp( dot( reflectDir, light1 ), 0.0, 1.0 ), 16.0);\n\n  float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );\n  float diffuse = clamp( dot( normal, light1 ), 0.0, 1.0 );\n  float skyLight = smoothstep( -0.1, 0.1, reflectDir.y );\n  float fill = pow( clamp(1.0+dot(normal, rayDir), 0.0, 1.0), 1.0 )*1.0;\n  float backLight = clamp( dot( normal, normalize(vec3(-light1.x, 0.0, -light1.z))), 0.0, 1.0 )*5.0;\n\n  diffuse *= SoftShadow( pos, light1);\n  skyLight *= SoftShadow( pos, reflectDir);\n\n  vec3 lightTot = 1.30*diffuse*vec3(1.00, 0.80, 0.55);\n  lightTot += specLevel*vec3(1.00, 0.90, 0.70)*diffuse;\n  lightTot += 0.40*amb*vec3(0.40, 0.60, 1.00);\n  lightTot += 0.50*skyLight*vec3(0.40, 0.60, 1.00);\n  lightTot += 0.50*backLight*vec3(0.25, 0.25, 0.25);\n\n  return lightTot+(0.25*fill*vec3(1.00, 1.00, 1.00));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n  vec2 mo = iMouse.xy\/iResolution.xy;\n  vec2 uv = fragCoord.xy \/ iResolution.xy;\n  vec2 screenSpace = (-iResolution.xy + 2.0*(fragCoord))\/iResolution.y;\n\n  float camrot = 0.5*iTime;\n  if (iMouse.w>0.1) camrot=0.0; \n\n  vec3 rayOrigin = vec3( -0.5+3.5*cos(camrot + 6.0*mo.x), 1.0 + 2.0, 0.5 + 4.0*sin(camrot + 6.0*mo.x) );\n  mat3 ca = setCamera( rayOrigin, vec3( 0.0, -0.9, 0.5 ), 0.0 );\n  vec3 rayDir = ca * normalize( vec3(screenSpace.xy, 2.0) );\n  vec4 color =vec4(0);\n\n   marchResult = March(rayOrigin, rayDir, 110.0, 0.001, 128);\n   marchResult.normal = calcNormal(marchResult.hitPos); \n    \n      \/\/ pad top, buttons, cross, cable, sticks, shoulder buttons\n  const vec4[10] partColor = vec4[] (vec4(.65, 0.14, 0.14, 0.6), \/\/ pad top\n  vec4(0.5, 0.14, .14, 0.6), \/\/buttons\n  vec4(.3, 0.3, 0.3, 0.5), \/\/cross\n  vec4(0.2, 0.2, 0.2, 0.35), \/\/cable\n  vec4(.3, 0.3, 0.3, 0.4), \/\/sticks\n  vec4(0.5, 0.5, .5, 0.6), \/\/ shoulder buttons\n  vec4(.3, 0.3, 0.3, 0.5), \/\/ start\/select\n  vec4(.3, 0.3, 0.3, 0.4), \/\/ pad bottom\n  vec4(0.5, 0.5, .5, 0.6), \/\/buttons left\n  vec4(.35, .35, .34, 0.3)); \/\/ ground\n   vec4 col =partColor[marchResult.hitID-1];\n   vec3 light = GetSceneLight(col.a, marchResult.normal, marchResult.hitPos, rayDir);   \n    \n    \/\/ reflections in floor\n    if (marchResult.hitID==10)\n    {\n      vec3 refDir = normalize(reflect(rayDir, marchResult.normal));\n      RayHit reflectResult = March(marchResult.hitPos + (refDir*0.001), refDir, 30.0, 0.03, 64); \n\n      if (reflectResult.hit==true)\n      {\n        col = mix(col, col+(col* partColor[reflectResult.hitID-1]), .65);\n      }\n    }\n\n    float rim = clamp(1.0+dot(marchResult.normal, rayDir), 0.0, 1.0);\n    vec4 ref = vec4(texture( iChannel0, marchResult.normal+rayDir).rgb, 1.0); \n    ref += rim*pow(0.5, 2.0);\n    ref \/= pow(2.0, col.a);\n\n    \/\/ apply lightning\n    color = col*vec4(light, 1.0);\n    color.rgb= mix((color.rgb+(color.rgb*ref.rgb))*col.a, (color.rgb+vec3(1.4))*col.a, pow(marchResult.normal.r, 2.0));\n  \n\n  fragColor = vec4(pow(color.rgb, vec3(1.0\/0.9)), 1.0 ) * (0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.2 ));\n  \/\/  fragColor = vec4(marchResult.normal,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"XlfyRr","date":"1503327314","viewed":889,"name":"Text Display Helper","username":"ingagard","description":"Text display routine to make life easier when writing text. \nFeel free to give me some performance improvement tips or other helpful feedback. ENJOY!","likes":5,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"\/media\/a\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"\/media\/ap\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"int _= 32; \nint _0 = 48;\nint _1 = 49;\nint\t_2 = 50;\nint\t_3 = 51;\nint\t_4 = 52;\nint _5 = 53;\nint _6 = 54;\nint _7 = 55;\nint _8 = 56;\nint _9 = 57;\nint _A = 65;\nint _B = 66;\nint _C = 67;\nint _D = 68;\nint _E = 69;\nint _F = 70;\nint _G = 71;\nint _H = 72;\nint _I = 73;\nint _J = 74;\nint _K = 75;\nint _L = 76;\nint _M = 77;\nint _N = 78;\nint _O = 79;\nint _P = 80;\nint _Q = 81;\nint _R = 82;\nint _S = 83;\nint _T = 84;\nint _U = 85;\nint _V = 65;\nint _W = 66;\nint _X = 67;\nint _Y = 68;\nint _Z = 69;\nint _a = 97;\nint _b = 98;\nint _c = 99;\nint _d = 100;\nint _e = 101;\nint _f = 102;\nint _g = 103;\nint _h = 104;\nint _i = 105;\nint _j = 106;\nint _k = 107;\nint _l = 108;\nint _m = 109;\nint _n = 110;\nint _o = 111;\nint _p = 112;\nint _q = 113;\nint _r = 114;\nint _s = 115;\nint _t = 116;\nint _u = 117;\nint _v = 118;\nint _w = 119;\nint _x = 120;\nint _y = 121;\nint _z = 122;\n\n\/*\nascii table:\nhttp:\/\/www.theasciicode.com.ar\/american-standard-code-information-interchange\/ascii-codes-table.png\n*\/\n\n\n\n\n\/\/ char size 64*64   16 char per row\nvoid WriteChar(vec2 screenCoord, vec2 pos, float charValue, float fontSize, vec4 fontColor, inout vec4 pixel)\n{\n  if (screenCoord.x >=pos.x && screenCoord.x <=pos.x+fontSize && screenCoord.y >=pos.y && screenCoord.y <=pos.y+fontSize)\n  {\n      \/\/ calculate texture grab position of character\n      float col = mod(charValue,16.0);\n      vec2 charPos = vec2(col,(charValue-col)\/16.0);\n      charPos *= 64.0;\n      \n      vec2 dist = screenCoord-pos;\n\n      vec2 steps = (vec2(1.0,-1.0) \/ iChannelResolution[0].xy);\n      vec2 startOffset = charPos *steps;\n      \n      \/\/ scale texture uv step by fontSize\n      steps*=(1.0\/(fontSize\/64.0));\n      dist *=steps;\n      vec4 c = texture(iChannel0,startOffset+dist);\n\n      \/\/ Check if texture is a part of the character\n      if(c.r>0.6)\n      {\n        pixel=mix(pixel,fontColor, fontColor.w);\n      }      \n  }\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float frame = radians(iTime)*120.0;\n    float cosValue = cos(frame);\n    float sinValue = sin(frame);\n    \n    vec2 screenCoord = vec2(fragCoord.x, iResolution.y-fragCoord.y);\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n\tvec4 color; \n        \n    \/\/ backdrop effect\n    if (mod(screenCoord.x,50.0)+mod(screenCoord.y,50.0) < 50.0)\n    {\n         color = vec4(0.15);\n    }\n    else\n    {\n         color = vec4(0);\n    }\n        \n    \/\/ SET TEXT VARIABLES ********************\n    vec2 textPos = vec2(-1150.0+(mod(frame*200.0,2000.0)),40.0+cos(frame+uv.x*5.0)*25.0);\n    float fontSize = 112.0;\n    float charSpacing = fontSize*0.5;\n    vec4 fontColor = vec4(uv.x,uv.x*4.0, 1.0-uv.x,1.0);\n\n    \/\/ write text by storing as an array of ascii values (table above)\n    \/\/ A SMALL TEST OF\n    int text[15] = int[](_A,_,_s,_m,_a,_l,_l,_,_T,_E,_S,_T,_,_O,_F);\n    \n    for(int i=0; i<15; i++)\n    {\n    WriteChar(screenCoord,textPos+vec2(float(i)*charSpacing,0.0),float(text[i]),fontSize, fontColor, color);\n    }  \n    \/\/ THE BELOW CODE IS JUST VARIATIONS\n    \/\/ ****************************************\n    \n    \n    \/\/ CENTER SCALE TEST ******************** \n    textPos = iResolution.xy*0.5;\n    fontSize = 78.0 + (cosValue*32.0);\n    charSpacing = fontSize*0.5;\n    fontColor = vec4(0.5-cosValue*0.5,0.5+cosValue*0.5, uv.x*1.0,1.0);\n    \n    \/\/ center text \n    \/\/ FONTS &\n    int text2[7] = int[](_f,_o,_n,_t,_s,_,38);\n    textPos.x -= (7.0*charSpacing)*0.5;\n    textPos.y -= fontSize*0.5;\n    \n    for(int i=0; i<7; i++)\n    {\n    WriteChar(screenCoord,textPos+vec2(float(i)*charSpacing,0.0),float(text2[i]),fontSize, fontColor, color);\n    }\n  \n    \n    \/\/ NUMBERS AND TRANSPARENCY ******************** \n    textPos = vec2(180.0+cos(frame+uv.x*25.0)*5.0,320.0+sin(frame+uv.x*25.0)*5.0);\n    fontSize = 76.0;\n    charSpacing = fontSize*0.5;\n    fontColor = vec4(uv.x*4.0,2.0-uv.x, 2.0*uv.y,0.2);\n    \n    \/\/ # 123456789\n    int text3[12] = int[](35,_,_1,_2,_3,_4,_5,_6,_7,_8,_9,_0);\n    \n    for(int i=0; i<12; i++)\n    {\n    WriteChar(screenCoord,textPos+vec2(float(i)*charSpacing,0.0),float(text3[i]),fontSize, fontColor, color);\n    }\n    \n    fragColor = color;\n}\n\n","name":"Image","description":"","type":"image"}]}];var gFollow = -1;
    var gUseScreenshots = piIsMobile();
    var gThemeName = "classic";
    </script>

</head>

<body onload="resultsInitStatic(8,null,null)">

<!-- header =================================================================================== -->


<div id="header">

    <div id="headerBlock1">
        <a href="/" id="headerTitle">Shadertoy</a>
        <form name="formSearch" action="/results" method="get" style="display:inline-block;">
        <div  id="headerSearch">
            <input type="search" id="mySearch" name="query" placeholder="Search..." value=""/>
        </div>
        </form>
    </div>

    <div id="headerBlock2">
            <a class="headerLinks" href="/browse">Browse</a>
        <a class="headerLinks" href="/new">New</a>
        <a class="headerLinks" href="/signin">Sign In</a>
        </div>
</div>
<!-- content ================================================================================== -->

<div id="content">

    
    <script>
    function follow()
    {
        if (gFollow < 0) return;
        try
        {
            var req = new XMLHttpRequest();
            req.onload = function()
            {
                var jsn = req.response;
                if( jsn==null ) return;
                let btnFollow = document.getElementById( "btnFollow");
                if (gFollow == 1) {
                    gFollow = 0;
                    btnFollow.value="Follow";
                } else if (gFollow == 0) {
                    gFollow = 1;
                    btnFollow.value="Unfollow";
                }
            }
            req.open( "POST", "/shadertoy", true );
            req.responseType = "json";
            req.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
            if (gFollow == 1) {
                var str = "fu=1&uid=ingagard";
            } else if (gFollow == 0) {
                var str = "fs=1&uid=ingagard";
            }
            req.send( str );
        }
        catch(e)
        {
            alert( "exception: " + e );
        }
    }
    </script>

    <!-- ---------------------------------- --> 

    <div id="divUser">
        <table style="border:0px;border-spacing:0px;border-collapse:collapse;"><tr>
        <td style="vertical-align:top;">
        <img id="userPicture" src="/img/profile.jpg"></img>        </td>
        <td style="vertical-align:top;padding-left:16px;">
        <b>Name</b>: ingagard <br/><b>Joined</b>: August 12, 2017 <br/> <br/><b>Shaders</b>: 9<br/><b>Playlists</b>: 0<br/><b>Comments</b>: 306<br/> <br/><b>Following</b>: 0<br/><b>Followers</b>: 9<br/>        </td>
        <td style="vertical-align:top;padding-left:32px;">
        <b>About</b><br><br>Name:<br/>Kim Berkeby<br/><br/>Email: <br/>mr.kimb@hotmail.com <br/><br/>Interests: <br/>3D graphics, programming and body building        </td>
        <td style="vertical-align:top;padding-left:32px;">
                    </td>
        </tr></table>
    </div>

<!-- --------------------------- -->

  <div id="controls">

    <div>
      <div style="text-align: center; vertical-align: middle; display: inline-block; padding-bottom:5px; padding-top:4px; margin-right:8px; margin-bottom:8px; margin-top:8px;">
      Sort:      </div>
      <div class="controlOptions"><div class="pageButtonsCurrent" href="/user/ingagard/sort=popular">Popular</div><a class="pageButtons" href="/user/ingagard/sort=newest">Newest</a><a class="pageButtons" href="/user/ingagard/sort=love">Love</a></div>
    </div>

    <div id="controlFilter">
      <div style="display:flex;margin-right:8px;align-items:center;">Filter:</div>
      <div class="controlOptions"> <a class="pageButtons" href="/user/ingagard&sort=popular&filter=multipass">Multipass</a><a class="pageButtons" href="/user/ingagard&sort=popular&filter=soundoutput">GPU Sound</a><a class="pageButtons" href="/user/ingagard&sort=popular&filter=vr">VR</a><a class="pageButtons" href="/user/ingagard&sort=popular&filter=soundinput">Microphone</a><a class="pageButtons" href="/user/ingagard&sort=popular&filter=musicstream">Soundcloud</a><a class="pageButtons" href="/user/ingagard&sort=popular&filter=webcam">Webcam</a></div>
    </div>

    <div>
        <div style="text-align: center; vertical-align: middle; display: inline-block; padding-bottom:5px; padding-top:4px; margin-right:8px; margin-bottom:8px; margin-top:8px;">
        Results (9):        </div>

        <div class="controlOptions">
              <div id="pageButton"0 class="pageButtonsCurrent" href="/user/ingagard/sort=popular&from=0&num=8">1</div><a id="pageButton"1 class="pageButtons" href="/user/ingagard/sort=popular&from=8&num=8">2</a>        </div>
    </div>
  </div>


  <div id="shaderGrid">
    <div class='searchResult'><div class='searchResultContainer' id='Preview_0_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_0_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_0_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_0_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_0_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_0_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_0_Thumnail'>        <img class='previewThumbnailImage' id='Preview_0_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_0_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_0_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_0_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_0_Info'>  <span class='previewText'  id='Preview_0_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_0_TextUser'></span>  <span class='previewStats' id='Preview_0_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_1_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_1_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_1_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_1_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_1_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_1_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_1_Thumnail'>        <img class='previewThumbnailImage' id='Preview_1_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_1_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_1_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_1_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_1_Info'>  <span class='previewText'  id='Preview_1_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_1_TextUser'></span>  <span class='previewStats' id='Preview_1_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_2_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_2_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_2_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_2_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_2_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_2_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_2_Thumnail'>        <img class='previewThumbnailImage' id='Preview_2_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_2_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_2_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_2_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_2_Info'>  <span class='previewText'  id='Preview_2_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_2_TextUser'></span>  <span class='previewStats' id='Preview_2_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_3_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_3_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_3_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_3_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_3_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_3_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_3_Thumnail'>        <img class='previewThumbnailImage' id='Preview_3_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_3_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_3_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_3_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_3_Info'>  <span class='previewText'  id='Preview_3_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_3_TextUser'></span>  <span class='previewStats' id='Preview_3_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_4_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_4_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_4_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_4_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_4_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_4_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_4_Thumnail'>        <img class='previewThumbnailImage' id='Preview_4_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_4_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_4_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_4_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_4_Info'>  <span class='previewText'  id='Preview_4_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_4_TextUser'></span>  <span class='previewStats' id='Preview_4_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_5_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_5_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_5_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_5_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_5_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_5_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_5_Thumnail'>        <img class='previewThumbnailImage' id='Preview_5_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_5_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_5_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_5_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_5_Info'>  <span class='previewText'  id='Preview_5_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_5_TextUser'></span>  <span class='previewStats' id='Preview_5_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_6_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_6_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_6_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_6_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_6_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_6_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_6_Thumnail'>        <img class='previewThumbnailImage' id='Preview_6_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_6_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_6_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_6_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_6_Info'>  <span class='previewText'  id='Preview_6_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_6_TextUser'></span>  <span class='previewStats' id='Preview_6_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_7_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_7_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_7_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_7_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_7_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_7_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_7_Thumnail'>        <img class='previewThumbnailImage' id='Preview_7_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_7_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_7_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_7_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_7_Info'>  <span class='previewText'  id='Preview_7_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_7_TextUser'></span>  <span class='previewStats' id='Preview_7_Stats'></span></div></div>  </div>
</div>

<!-- footer ================================================================================== -->

<div id="footer">
    
    <div><span style="color:#ffffff;">Community Forums</span>
      <ul>
      <li><a class="regular" href="/events">Official Events</a></li>
      <li><a class="regular" href="https://www.facebook.com/groups/147749602472741">In Facebook (english)</a></li>
      <li><a class="regular" href="https://www.facebook.com/groups/1339783682699494">In Facebook (korean)</a></li>
      <li><a class="regular" href="https://discord.gg/XtmMN6E">In Discord</a> (<a class="regular" href="https://discordapp.com/channels/578696555612209173/579531723348639754">direct link</a>)</li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Feedback and Support</span>
      <ul>
      <li><a class="regular" href="https://www.facebook.com/Shadertoy">Facebook</a></li>
      <li><a class="regular" href="https://twitter.com/shadertoy">Twitter</a></li>
      <li><a class="regular" href="https://www.patreon.com/shadertoy">Patreon</a></li>
      <li><a class="regular" href="https://trello.com/b/5hM0CjId">Roadmap</a></li>

      
      </ul>
    </div>

    <div><span style="color:#ffffff;">Shadertoy</span>
      <ul>
      <li><a class="regular" href="/store">Store</a></li>
      <li><a class="regular" href="/howto">Documentation</a></li>
      <li><a class="regular" href="/terms">Terms & Privacy</a></li>
      <li><a class="regular" href="/about">About</a></li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Apps and Plugins</span>
      <ul>
      <li><a class="regular" href="https://itunes.apple.com/us/app/shadertoy/id717961814">Official iPhone App</a> by <a class="user" href="/user/reinder">Reinder</a></li>
      <li><a class="regular" href="https://steamcommunity.com/sharedfiles/filedetails/?id=1726697188">Screensaver</a> by <a class="user" href="/user/kosro">Kosro</a></li>
      <li><a class="regular" href="https://chrome.google.com/webstore/detail/shadertoy-unofficial-plug/ohicbclhdmkhoabobgppffepcopomhgl">Shadertoy plugin</a> by <a class="user" href="/user/patu">Patu</a></li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Tutorials</span>
      <ul>
      <li><a class="regular" href="https://www.youtube.com/watch?v=0ifChJ0nJfM">Shader coding intro</a> by <a class="user" href="/user/iq">iq</a></li>
      <li><a class="regular" href="https://shadertoyunofficial.wordpress.com/">Shadertoy Unofficial</a> by <a class="user" href="/user/FabriceNeyret2">FabriceNeyret2</a></li>
      </ul>
    </div>

</div>

<div id="compliance" style="padding-bottom:6px;visibility:hidden;left:0;top:0px;width:100%;background-color:rgb(200,120,20,0.93);position:absolute;color:#FFFFFF">
    <div style="text-align: center; margin-top:8px">
        We use cookies to give you the best experience on our website. If you continue using Shadertoy, we'll assume that you are happy to receive all cookies on this website. 
        For more information, please review our <a class="regular" href="/terms">Terms & Privacy</a>.
    </div> 
    <div style="text-align: center;margin-top:6px">
        <button type="button" style="width:100px;font-size:inherit" onclick="acceptCompliance()">Accept</button>
    </div>
</div>

<script>
(function runCompliance() 
{
    let showCompliance = 1;
    let allcookies = document.cookie;
    let cookiearray = allcookies.split(';');
    for (var i=0; i<cookiearray.length; i++)
    {
        let name  = cookiearray[i].split('=')[0];
        let value = cookiearray[i].split('=')[1];
        if (name.trim() == "scmp") 
        {
            showCompliance = value;
            break;
        }
    }

    if (showCompliance === 1) 
    {
        var ve = document.getElementById("compliance");
        ve.style.visibility="visible";
    }
})();

function acceptCompliance()
{
    let now = new Date();
    now.setTime( now.getTime() + (5*365*24*60*60*1000) );
    document.cookie="scmp=0;expires=" + now.toUTCString() + ";";

    var ve = document.getElementById("compliance");
    ve.style.visibility="hidden";
}
</script>

<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-44068895-1', 'shadertoy.com');
    ga('send', 'pageview');
</script>
</body>
</html>
