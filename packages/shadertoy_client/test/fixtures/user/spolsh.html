<!DOCTYPE HTML>
<html lang="en">
<head>
    
<title>spolsh - Shadertoy BETA</title>
<meta charset="utf-8" />
<meta name="Keywords" content="shadertoy, shader toy, quilez, inigo, jeremias, pol, fractals, demoscene, computer graphics, mathematics, rendering, demo, 3D, realtime, shader, raytracing, raymarching, webgl, glsl" />
<meta name="Description" content="Build shaders, share them, and learn from the best community." />
<meta name="Author" content="Beautypi" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<link rel="image_src" href="https://www.shadertoy.com/img/logo.png" />
<link rel="apple-touch-icon" href="/img/launch_icon_57.png"/>
<link rel="apple-touch-icon" sizes="72x72" href="/img/launch_icon_72.png"/>
<link rel="apple-touch-icon" sizes="114x114" href="/img/launch_icon_114.png"/>
<link rel="shortcut icon" href="/img/favicon.ico"/>

<style>::-webkit-scrollbar {
    height: 8px;
    width: 8px;
    background: #404040;
}

::-webkit-scrollbar-thumb
{
    background: #909090;
    border-radius: 0ex;
}

::-webkit-scrollbar-corner
{
    background: #000;
}

::-webkit-input-placeholder
{
	font-style:italic;
}
input:-moz-placeholder, textarea:-moz-placeholder
{
	font-style:italic;
}
input.placeholder-text, textarea.placeholder-text
{
	font-style:italic;
}

pre 
{
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
    white-space: -pre-wrap;
    white-space: -o-pre-wrap;
    word-wrap: break-word;
}

@font-face
{
    font-family: Lobster;
    src: url("/img/lobster.otf") format("opentype");
}

div#centerScreen
{
    left: 50%;
    top: 50%;
    position: absolute;
}

a.headerLinks:hover
{
    background-color:#505050;
    color : #ff8020;
}

body
{
    color: #000000;
    font-size:12px;
    font-style:normal;
    font-family:Tahoma,Arial;
    background-repeat: no-repeat;
    //background-attachment: fixed;
    padding:0px;
    margin:0px;
    text-align: left;
    background-color: #d0d0d0;
    background-repeat: repeat;
    user-select: text;
}

a,
a:hover,
a:visited
{
  color : inherit;
}

div#content {
    width: 95%;
    overflow: hidden;
    margin: auto;
    padding: 0px;
    min-height: calc(100vh - 80px);
    //box-sizing: border-box;
}


.notificationCount
{
 background-color:#ff0000;
 padding-left:3px;
 padding-right:1px;
 padding-top:1px;
 padding-bottom:1px;
}

div#header
{
    background-color: #404040;
    top: 0px;
    left: 0px;
    width: 100%;
    padding: 0;
    margin: 0;
    color: #ffffff;
    display: flex;
    flex-direction:row;
}

#headerBlock1
{
    width: 50%;
    display:flex;
    align-items:center;
}

a#headerTitle
{
    font-size: 2.25em;
    font-family: Lobster,Tahoma,Arial;
    text-decoration: none;
    padding-left:32px;
    padding-right:32px;
}

#headerSearch
{
    display: inline-block;
    color: #000000;
    width: 300px;
}

input[type=search]#mySearch
{
    width: 100%;
    border-radius: 6px;
    border: 1px solid black;
    padding:12px;
}

#headerBlock2
{
    width: 50%;
    margin-left: auto;
    display: flex;
    justify-content: flex-end;
}


a#headerTitle:hover
{
    color : #ff8020;
}

a.headerLinks
{
    font-weight: bold;
    padding-top: 14px;
    padding-bottom: 14px;
    padding-left: 14px;
    padding-right: 14px;
    margin:0px;
    text-decoration: none;
    transition: background-color 0.15s linear, color 0.15s linear;
}

#footer
{
    background-color: rgba(64,64,64,0.25);
    color: #000000;
    padding: 0px;
    margin: 0px;
    width: 100%;
    display: flex;
    justify-content: space-between;
    flex-wrap: wrap;
}

#footer div
{
    padding-top:10px;
    padding-bottom:0px;
    padding-left:16px;
    padding-right:16px;
}

#footer div ul
{
    margin-left:0px;
    padding-left:16px;
}

#footer div ul li
{
    padding-top:6px;
}

a.regular
{
    font-weight:bold;
    text-decoration:none
}

a.regular:hover
{
  color : #ff8020;
}

a.user
{
    font-weight:bold;
    text-decoration:none;
}

a.user:hover
{
  color : #ff8020;
  text-decoration: underline;
}

.uiButton
{
    border: none;
    outline: none;
    margin: 0px;
    padding: 0px;
    width: 22px;
    height: 22px;
    position: absolute;
    cursor: pointer;
    border-radius: 4px;
}

.uiButton:hover
{
    box-shadow: inset 0px 0px 1px 1px #808080, 0px 0px 1px 1px #808080;
}

.uiDivBUtton
{
    cursor:pointer;
}

.uiDivBUtton:hover
{
    color: #ffffff;
}


.dialog
{
    display: block;
    background-color: #e0e0e0;
    color: #000000;
    border:1px solid #000;
    padding:0px;
    margin:0px;
    text-align:left;
    border-radius: 4px;
    box-shadow:4px 4px 6px 0px rgba(0,0,0,0.5);
    overflow: hidden;
    z-index:1000;
    visibility: hidden;
    opacity:0;
    -moz-transition: opacity 0.25s linear,visibility 0.25s linear;
    -webkit-transition: opacity 0.25s linear,visibility 0.25s linear;
    transition: opacity 0.25s linear,visibility 0.25s linear;
}

.dialogHeader
{
    left:0px;
    top: 0px;
    width:100%;
    height:32px;
    position: absolute;
    background-color: #808080;
    cursor:move;
}

.dialogTitle
{
    left: 12px;
    top: 4px;
    position: absolute;
    padding: 0px;
    margin: 0px;
    color:#000000;
    font-size:1.5em;
    text-align: left;
    user-select: none;
    -moz-user-select: -moz-none;
    -webkit-user-select: none;
}

.dialogOverlay
{
    z-index:1000;

    visibility: hidden;
    opacity:0;
    -moz-transition: opacity 0.25s linear,visibility 0.25s linear;
    -webkit-transition: opacity 0.25s linear,visibility 0.25s linear;
    transition: opacity 0.25s linear,visibility 0.25s linear;

    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    width:100%;
    height:100%;
    position:absolute;

    background-color:rgba(0,0,0,.4);
}

.viewsIcon, .likesIcon
{
    border: none;
    outline: none;
    display:inline-block;
    background-repeat:no-repeat;
    top:0px;
    left:0px;
    padding:0px;
    padding-right: 2px;
    margin:0px;
    position:relative;
}

.userPictureSmall
{
    background-color:#808080;
    border: 1px solid #000000;
    width:32px;
    height:32px;
}

.dialogCloseButton
{
    right:8px;
    top: 4px;
    width:22px;
    height:22px;
    position: absolute;
    background-image: url("/img/close.png");
    cursor: pointer;
    border-radius: 4px;
}

.dialogCloseButton:hover
{
    box-shadow: inset 0px 0px 4px 2px #ffffff, 0px 0px 4px 2px #ffffff;
}

.dialogContentButtons
{
     padding:0;
     border:0;
     text-align: justify;
     left: 24px;
     bottom:40px;
     position:absolute;
}

.dialogButton
{
    text-align: center;
    vertical-align: middle;
    display: inline-block;
    border-radius: 4px;
    font-weight: bold;
    cursor: pointer;
    padding-bottom:5px;
    padding-top:4px;
    padding-left: 8px;
    padding-right: 8px;
    margin-left:4px;
    margin-right:4px;
    text-decoration: none;
    color:#000000;
    width: 80px;
    -moz-transition:    background-color 0.15s linear, color 0.15s linear;
    -webkit-transition: background-color 0.15s linear, color 0.15s linear;
    transition:         background-color 0.15s linear, color 0.15s linear;
}

.dialogButton:hover
{
  background-color:#808080;
  color : #ff8020;
}

.dialogCloseButton:hover
{
    box-shadow: inset 0px 0px 4px 2px #ffffff, 0px 0px 4px 2px #ffffff;
}

.dialogContent
{
    color: inherit;
    overflow: auto;
    width:100%;
    height:100%;
    left: 0px;
    top: 32px;
    position:absolute
}

.dialogContentBody
{
    color: inherit;
    width:100%;
    height:auto;
    padding-top:24px;
    padding-bottom:24px;
    padding-left:24px;
    padding-right:24px;
    text-align: left;
}

.formButton
{
    font-weight:bold;
	color:#ffffff;
	border:none;
    text-align:center;
	background-color:#808080;
    border-radius: 4px;
	padding-left:8px;
	padding-right:8px;
	padding-top:4px;
	padding-bottom:4px;
    cursor:pointer;
    min-width:80px;
    box-sizing: border-box;
}
.formInput {
    border-radius: 6px;
    border: 1px solid black;
    padding: 4px;
    border: none;
}
.formButton:hover {
    background-color: #e0e0e0;
}
.formButton:disabled
{
	color:#b0b0b0;
	background-color:#808080;
}

.formButtonSmall
{
    color:#ffffff;
    border:none;
    text-align:center;
    background-color:#808080;
    border-radius: 4px;
    padding-left:2px;
    padding-right:2px;
    padding-top:2px;
    padding-bottom:2px;
    cursor:pointer;
    min-width:40px;
}

.formButtonSmall:hover
{
    background-color: #e0e0e0;
}

.formButtonSmall:disabled
{
    color:#b0b0b0;
    background-color:#808080;
}

.formButtonSmall.disabled2,
.formButton.disabled2 { color:#b0b0b0; background-color:#808080; pointer-events: none; }

.inputForm
{
    padding-left:2%;
    padding-right:2%;
    resize: none;
    text-align: left;
    background-color:#e0e0e0;
    outline: none;
    border-radius: 4px;
    border: 1px solid #808080;
    color:inherit;
    box-sizing: border-box;
}

.inputForm:focus
{
    border: 1px solid #AFCDD8;
    background-color: #EBF2F4;
}

.transparentPannel
{
    background-color:rgba(64,64,64,0.1);
    padding:16px;
}

.comment, .commentSelf, .commentNew
{
    border-radius: 4px;
    width: 100%;
    margin-left: 0px;
    margin-right: 0px;
    margin-top: 0px;
    margin-bottom: 6px;

    padding: 14px;
    box-sizing: border-box;
    display: grid;
    grid-template-columns: 32px auto 8px;
    grid-template-rows: 1fr;
    grid-gap:8px;
}

.comment:nth-child(even)
{
    background-color: rgba(64,64,64,0.1);
}

.comment:nth-child(odd)
{
    background-color: rgba(128,128,128,0.1);
}

.commentSelf
{
    background-color: rgba(240,160,64,0.1);
}

.commentNew
{
    padding-right: 0px;
    grid-template-columns: 40px auto;
}

.commentContent
{
    vertical-align: top;
    text-align: left;
    word-break: break-all;
    word-break: break-word;
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
}


/* ----------------------- media resolutions ------------------------ */

@media screen and (max-width:799px)
{
    div#header {flex-direction:column; }
    #headerBlock1 { width:100%; }
    #headerBlock2 { width:100%; justify-content: space-around;}
    div#headerSearch {width:200px;}
    input#mySearch { width:200px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .previewText { width:130px; }
    .transparentPannel { padding:10px; }
}

@media screen and (min-width:800px) and (max-width:1279px)
{
    body { font-size: 9px; }
    div#headerSearch {width: 250px;}
    input#mySearch { width:250px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .previewText { width:130px; }
    .transparentPannel { padding:11px; }
}

@media screen and (min-width:1280px) and (max-width:1439px)
{
    body { font-size: 10px; }
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:28px; }
    .previewText { width:180px; }
    .transparentPannel { padding:12px; }
}

@media screen and (min-width:1440px) and (max-width:1919px)
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:28px; }
    .previewText { width:180px; }
    .transparentPannel { padding:12px; }
}

@media screen and (min-width:1920px) and (max-width:2559px)
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:32px; }
    .previewText { width:220px; }
    .transparentPannel { padding:16px; }
}

@media screen and (min-width:2560px) 
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:32px; }
    .previewText { width:220px; }
    .transparentPannel { padding:16px; }
}
body
{
    background-image: url("/img/themes/classic/background.jpg");
}
</style>


    <script>"use strict"

//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piCamera
//
//==============================================================================

function piCamera()
{
    var mMatrix = setIdentity();
    var mMatrixInv = setIdentity();

    var mPosition = [0.0,0.0,0.0];
    var mXRotation = 0.0;
    var mYRotation = 0.0;

    var mPositionTarget = [0.0,0.0,0.0];
    var mXRotationTarget = 0.0;
    var mYRotationTarget = 0.0;

    var me = {};
/*
    me.Set = function( pos, dir, roll) 
             {
                 mMatrix    = setLookat( pos, add(pos,dir), [Math.sin(roll),Math.cos(roll),Math.sin(roll)] );
                 mMatrixInv = invertFast( mMatrix );
             };
*/
    me.SetPos = function(pos)
                {
                    mPosition = pos;
                    //mMatrix[ 3] = -(mMatrix[0] * pos[0] + mMatrix[1] * pos[1] + mMatrix[ 2] * pos[2]);
                    //mMatrix[ 7] = -(mMatrix[4] * pos[0] + mMatrix[5] * pos[1] + mMatrix[ 6] * pos[2]);
                    //mMatrix[11] = -(mMatrix[8] * pos[0] + mMatrix[9] * pos[1] + mMatrix[10] * pos[2]);
                };
/*
    me.GlobalMove = function(pos)
                    {
                        mMatrix[ 3] -= (mMatrix[0] * pos[0] + mMatrix[1] * pos[1] + mMatrix[ 2] * pos[2]);
                        mMatrix[ 7] -= (mMatrix[4] * pos[0] + mMatrix[5] * pos[1] + mMatrix[ 6] * pos[2]);
                        mMatrix[11] -= (mMatrix[8] * pos[0] + mMatrix[9] * pos[1] + mMatrix[10] * pos[2]);
                        mMatrixInv = invertFast(mMatrix);
                    };
*/
    me.LocalMove = function( dis )
                    {
                        dis = matMulvec( setRotationY(-mYRotation), dis);
                        mPositionTarget = sub(mPositionTarget,dis)
                    };

    me.RotateXY = function( x, y)
                  {
                    mXRotationTarget -= x;
                    mYRotationTarget -= y;
                    mXRotationTarget = Math.min( Math.max( mXRotationTarget, -Math.PI/2), Math.PI/2 );
                  };


    me.CameraExectue = function( dt )
    {
        // smooth position
        mXRotation += (mXRotationTarget-mXRotation) * 12.0*dt;
        mYRotation += (mYRotationTarget-mYRotation) * 12.0*dt;
        mPosition = add(mPosition, mul( sub(mPositionTarget, mPosition), 12.0*dt));

        // Make Camera matrix
        mMatrix = matMul( matMul(setRotationX(mXRotation), 
                                 setRotationY(mYRotation)),  
                                 setTranslation(mPosition));
        mMatrixInv = invertFast(mMatrix);

    }

    me.GetMatrix = function() { return mMatrix; };
    me.GetMatrixInverse = function() { return mMatrixInv; };
    me.SetMatrix = function( mat ) 
                    {
                        mMatrix = mat;
                        mMatrixInv = invertFast(mMatrix);

                        mPosition = getXYZ(matMulpoint(mat, [0.0,0.0,0.0]));
                        mPositionTarget = mPosition;
                    };

    me.GetPos = function() { return getXYZ(matMulpoint(mMatrixInv, [0.0,0.0,0.0])); }
    me.GetDir = function() { return getXYZ(normalize(matMulvec(mMatrixInv, [0.0,0.0,-1.0]))); }

    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piFile
//
//==============================================================================

function piFile( binaryDataArrayBuffer )
{
    // private
    //var mDataView = new DataView( binaryDataArrayBuffer, 0 );
    var mDataView = binaryDataArrayBuffer;
    var mOffset = 0;

    // public members
    var me = {};
    me.mDummy = 0;
/*
    // public functions
    me.Seek = function( off ) { mOffset = off - 3; };
    me.ReadUInt16 = function()  { var res = mDataView.getUint16( mOffset ); mOffset+=2; return res; };
    me.ReadUInt32 = function()  { var res = mDataView.getUint32( mOffset ); mOffset+=4; return res; };
    me.ReadUInt64 = function()  { return me.ReadUInt32() + (me.ReadUInt32()<<32); };
    me.ReadFloat32 = function() { var res = mDataView.getFloat32( mOffset ); mOffset+=4; return res; };
*/

    me.Seek = function( off ) { mOffset = off; };
    me.ReadUInt8  = function()  { var res = (new Uint8Array(mDataView,mOffset))[0]; mOffset+=1; return res; };
    me.ReadUInt16 = function()  { var res = (new Uint16Array(mDataView,mOffset))[0]; mOffset+=2; return res; };
    me.ReadUInt32 = function()  { var res = (new Uint32Array(mDataView,mOffset))[0]; mOffset+=4; return res; };
    me.ReadUInt64 = function()  { return me.ReadUInt32() + (me.ReadUInt32()<<32); };
    me.ReadFloat32 = function() { var res = (new Float32Array(mDataView,mOffset))[0]; mOffset+=4; return res; };
    me.ReadFloat32Array = function(n) 
                          { 
                              var src = new Float32Array(mDataView, mOffset);
                              var res = [];  for( var i=0; i<n; i++ ) { res[i] = src[i]; }
                              mOffset += 4*n;
                              return res;
                          };
    me.ReadFloat32ArrayNative = function(n) { var src = new Float32Array(mDataView, mOffset); mOffset += 4*n; return src; };
    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piMesh
//
//==============================================================================

function piMesh()
{
    this.mChunks = [];
    this.mPrimitiveType = 0;
    this.mVertexFormat = null;
}

/*
piMesh.prototype.normalize = function( ppos, npos )
{
    var numv = this.mVertexData.length;
    var numt = this.mIndices.length;

    for( var i=0; i<numv; i++ )
    {
        //float *v = (float*)piMesh_GetVertexData( me, i, npos );
        //v[0] = 0.0f;
        //v[1] = 0.0f;
        //v[2] = 0.0f;
        this.mVerts[8 * i + 3] = 0.0;
        this.mVerts[8 * i + 4] = 0.0;
        this.mVerts[8 * i + 5] = 0.0;
    }

    for( var i=0; i<numt; i++ )
    {
        piMeshFace *face = me->mFaceData.mIndexArray[0].mBuffer + i;

        const int ft = face->mNum;
        
        vec3 nor = vec3( 0.0f, 0.0f, 0.0f );
        for( int j=0; j<ft; j++ )
        {
            const vec3 va = *((vec3*)piMesh_GetVertexData( me, face->mIndex[ j      ], ppos ));
            const vec3 vb = *((vec3*)piMesh_GetVertexData( me, face->mIndex[(j+1)%ft], ppos ));

            nor += cross( va, vb );
        }

        for( int j=0; j<ft; j++ )
        {
            vec3 *n = (vec3*)piMesh_GetVertexData( me, face->mIndex[j], npos );
            n->x += nor.x;
            n->y += nor.y;
            n->z += nor.z;
        }
    }

    for( var i=0; i<numv; i++ )
    {
        vec3 *v = (vec3*)piMesh_GetVertexData( me, i, npos );
        *v = normalize( *v );
    }
}
*/

piMesh.prototype.createCube = function(renderer)
{
    this.mPrimitiveType = 0;

    this.mChunks[0] = { mVerts : new Float32Array([ -1.0, -1.0, -1.0,
                                       1.0, -1.0, -1.0,
                                      -1.0,  1.0, -1.0,
                                       1.0,  1.0, -1.0,
                                      -1.0, -1.0,  1.0,
                                       1.0, -1.0,  1.0,
                                      -1.0,  1.0,  1.0,
                                       1.0,  1.0,  1.0 ]),

                        mIndices : new Uint16Array([ 0, 2, 1,   1, 2, 3,   5, 1, 3,   5, 3, 7,   4, 5, 7,   4, 7, 6,   4, 6, 2,   4, 2, 0,   6, 7, 3,   6, 3, 2,   4, 0, 1,   4, 1, 5 ]),
                        mNumVertices : 8,
                        mNumFaces : 12, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };

    this.mVertexFormat = { mStride:12, mChannels:[ { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false } ] };

    return true;
}

piMesh.prototype.createCubeSharp = function (renderer)
{
    this.mPrimitiveType = 0;

    this.mChunks[0] = { mVerts : new Float32Array([-1.0, 1.0,-1.0,   0.0, 1.0, 0.0,   0.0, 0.0,
                                    -1.0, 1.0, 1.0,   0.0, 1.0, 0.0,   0.0, 1.0,
                                     1.0, 1.0, 1.0,   0.0, 1.0, 0.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   0.0, 1.0, 0.0,   1.0, 0.0,

                                    -1.0,-1.0, 1.0,   0.0, 0.0, 1.0,   0.0, 0.0,
                                     1.0,-1.0, 1.0,   0.0, 0.0, 1.0,   0.0, 1.0,
                                     1.0, 1.0, 1.0,   0.0, 0.0, 1.0,   1.0, 1.0,
                                    -1.0, 1.0, 1.0,   0.0, 0.0, 1.0,   1.0, 0.0,

                                     1.0, 1.0, 1.0,   1.0, 0.0, 0.0,   0.0, 0.0,
                                     1.0,-1.0, 1.0,   1.0, 0.0, 0.0,   0.0, 1.0,
                                     1.0,-1.0,-1.0,   1.0, 0.0, 0.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   1.0, 0.0, 0.0,   1.0, 0.0,

                                     1.0,-1.0,-1.0,   0.0, 0.0,-1.0,   0.0, 0.0,
                                    -1.0,-1.0,-1.0,   0.0, 0.0,-1.0,   0.0, 1.0,
                                    -1.0, 1.0,-1.0,   0.0, 0.0,-1.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   0.0, 0.0,-1.0,   1.0, 0.0,

                                    -1.0,-1.0, 1.0,   0.0,-1.0, 0.0,   0.0, 0.0,
                                    -1.0,-1.0,-1.0,   0.0,-1.0, 0.0,   0.0, 1.0,
                                     1.0,-1.0,-1.0,   0.0,-1.0, 0.0,   1.0, 1.0,
                                     1.0,-1.0, 1.0,   0.0,-1.0, 0.0,   1.0, 0.0,

                                    -1.0, 1.0, 1.0,  -1.0, 0.0, 0.0,   0.0, 0.0,
                                    -1.0, 1.0,-1.0,  -1.0, 0.0, 0.0,   0.0, 1.0,
                                    -1.0,-1.0,-1.0,  -1.0, 0.0, 0.0,   1.0, 1.0,
                                    -1.0,-1.0, 1.0,  -1.0, 0.0, 0.0,   1.0, 0.0 ]),

                        mIndices : new Uint16Array([0,1,2, 0,2,3,   4,5,6, 4,6,7,    8,9,10,8,10,11,   12,13,14,12,14,15,   16,17,18,16,18,19,   20,21,22,20,22,23]),
                        mNumVertices : 24,
                        mNumFaces : 12, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };


    this.mVertexFormat = { mStride:32, mChannels:[ { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false },
                                                   { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false },
                                                   { mNumComponents:2, mType: renderer.TYPE.FLOAT32, mNormalize: false } ] };

    return true;
}


piMesh.prototype.createUnitQuad = function (renderer)
{
    this.mPrimitiveType = 0;
    this.mVertexFormat = { mStride:8, mChannels: [ {mNumComponents:2, mType: renderer.TYPE.FLOAT32, mNormalize: false} ] };

    this.mChunks[0] = { mVerts : new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0,  1.0, 1.0,  1.0]),
                        mIndices : new Uint16Array([0, 2, 1, 1, 2, 3]),
                        mNumVertices : 4,
                        mNumFaces : 2, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };
 
    return true;
}




piMesh.prototype.destroy = function()
{
    //delete this.mVerts;   this.mVerts = null;
    //delete this.mIndices; this.mIndices = null;
}

piMesh.prototype.scale = function (x, y, z)
{
    var stride = this.mVertexFormat.mStride/4;
    for( var j=0; j<this.mChunks.length; j++ )
    {
        var nv = this.mChunks[j].mNumVertices;
        for (var i = 0; i < nv; i++) 
        {
            this.mChunks[j].mVerts[stride * i + 0] *= x;
            this.mChunks[j].mVerts[stride * i + 1] *= y;
            this.mChunks[j].mVerts[stride * i + 2] *= z;
        }
    }
}

piMesh.prototype.translate = function (x, y, z) 
{
    var stride = this.mVertexFormat.mStride/4;
    for( var j=0; j<this.mChunks.length; j++ )
    {
        var nv = this.mChunks[j].mNumVertices;
        for (var i = 0; i < nv; i++) 
        {
            this.mChunks[j].mVerts[stride * i + 0] += x;
            this.mChunks[j].mVerts[stride * i + 1] += y;
            this.mChunks[j].mVerts[stride * i + 2] += z;
        }
    }
}

piMesh.prototype.GPULoad = function (renderer)
{
    for( var i=0; i<this.mChunks.length; i++ )
    {
        var vbo = renderer.CreateVertexArray(this.mChunks[i].mVerts, renderer.BUFTYPE.STATIC );
        if (vbo == null)
            return false;

        var ibo = renderer.CreateIndexArray(this.mChunks[i].mIndices, renderer.BUFTYPE.STATIC);
        if (ibo == null)
            return false;

        this.mChunks[i].mVBO = vbo;
        this.mChunks[i].mIBO = ibo;
    }
    return true;
}

piMesh.prototype.GPURender = function (renderer, positions )//, matPrj, matCam )
{
    //renderer.SetShaderConstantMat4F("unMPrj", matPrj, false );

    var num = this.mChunks.length;
    for( var i=0; i<num; i++ )
    {
        //var mat =  matMul( matCam, this.mChunks[i].mTransform );
        //renderer.SetShaderConstantMat4F("unMMod", mat, false);

        renderer.AttachVertexArray(this.mChunks[i].mVBO, this.mVertexFormat, positions );
        renderer.AttachIndexArray(this.mChunks[i].mIBO );
        renderer.DrawPrimitive(renderer.PRIMTYPE.TRIANGLES, this.mChunks[i].mNumFaces * 3, true, 1);
        renderer.DetachIndexArray(this.mChunks[i].mIBO);
        renderer.DetachVertexArray(this.mChunks[i].mVBO, this.mVertexFormat );
    }
}
//==============================================================================
//
// piLibs 2014-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piRenderer
//
//==============================================================================

function piRenderer()
{
    // private members

    var mGL = null;
    var mBindedShader = null;
    var mIs20 = false;
    var mFloat32Textures;
    var mFloat32Filter;
    var mFloat16Textures;
    var mDrawBuffers;
    var mDepthTextures;
    var mDerivatives;
    var mFloat16Filter;
    var mShaderTextureLOD;
    var mAnisotropic;
    var mRenderToFloat32F;
    var mDebugShader;
    var mAsynchCompile;

    var mVBO_Quad = null;
    var mVBO_Tri = null;
    var mVBO_CubePosNor = null;
    var mVBO_CubePos = null;
    var mShaderHeader = ["",""];
    var mShaderHeaderLines = [0,0];

    // public members
    var me = {};

    me.CLEAR      = { Color: 1, Zbuffer : 2, Stencil : 4 };
    me.TEXFMT     = { C4I8 : 0, C1I8 : 1, C1F16 : 2, C4F16 : 3, C1F32 : 4, C4F32 : 5, Z16 : 6, Z24 : 7, Z32 : 8, C3F32:9 };
    me.TEXWRP     = { CLAMP : 0, REPEAT : 1 };
    me.BUFTYPE    = { STATIC : 0, DYNAMIC : 1 };
    me.PRIMTYPE   = { POINTS : 0, LINES : 1, LINE_LOOP : 2, LINE_STRIP : 3, TRIANGLES : 4, TRIANGLE_STRIP : 5 };
    me.RENDSTGATE = { WIREFRAME : 0, FRONT_FACE : 1, CULL_FACE : 2, DEPTH_TEST : 3, ALPHA_TO_COVERAGE : 4 };
    me.TEXTYPE    = { T2D : 0, T3D : 1, CUBEMAP : 2 };
    me.FILTER     = { NONE : 0, LINEAR : 1, MIPMAP : 2, NONE_MIPMAP : 3 };
    me.TYPE       = { UINT8 : 0, UINT16 : 1, UINT32 : 2, FLOAT16: 3, FLOAT32 : 4, FLOAT64: 5 };

    // private functions

    var iFormatPI2GL = function( format )
    {
        if( mIs20 )
        {
             if (format === me.TEXFMT.C4I8)  return { mGLFormat: mGL.RGBA8,           mGLExternal: mGL.RGBA,             mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1I8)  return { mGLFormat: mGL.R8,              mGLExternal: mGL.RED,              mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1F16) return { mGLFormat: mGL.R16F,            mGLExternal: mGL.RED,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F16) return { mGLFormat: mGL.RGBA16F,         mGLExternal: mGL.RGBA,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C1F32) return { mGLFormat: mGL.R32F,            mGLExternal: mGL.RED,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F32) return { mGLFormat: mGL.RGBA32F,         mGLExternal: mGL.RGBA,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C3F32) return { mGLFormat: mGL.RGB32F,          mGLExternal: mGL.RGB,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.Z16)   return { mGLFormat: mGL.DEPTH_COMPONENT16, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        else if (format === me.TEXFMT.Z24)   return { mGLFormat: mGL.DEPTH_COMPONENT24, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        else if (format === me.TEXFMT.Z32)   return { mGLFormat: mGL.DEPTH_COMPONENT32F, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        }
        else
        {
             if (format === me.TEXFMT.C4I8)  return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1I8)  return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.LUMINANCE,       mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1F16) return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.LUMINANCE,       mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F16) return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C1F32) return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.RED,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F32) return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.Z16)   return { mGLFormat: mGL.DEPTH_COMPONENT, mGLExternal: mGL.DEPTH_COMPONENT, mGLType: mGL.UNSIGNED_SHORT }
        }

        return null;
     }

    // public functions

    me.Initialize = function( gl )
                    {
                        mGL = gl;

                        mIs20 = !(gl instanceof WebGLRenderingContext);

                        if( mIs20 )
                        {
                            mFloat32Textures  = true;
                            mFloat32Filter    = mGL.getExtension( 'OES_texture_float_linear');
                            mFloat16Textures  = true;
                            mFloat16Filter    = mGL.getExtension( 'OES_texture_half_float_linear' );
                            mDerivatives      = true;
                            mDrawBuffers      = true;
                            mDepthTextures    = true;
                            mShaderTextureLOD = true;
                            mAnisotropic = mGL.getExtension( 'EXT_texture_filter_anisotropic' );
                            mRenderToFloat32F = mGL.getExtension( 'EXT_color_buffer_float');
                            mDebugShader = mGL.getExtension('WEBGL_debug_shaders');
                            mAsynchCompile = mGL.getExtension('KHR_parallel_shader_compile');

							mGL.hint( mGL.FRAGMENT_SHADER_DERIVATIVE_HINT, mGL.NICEST);
                        }
                        else
                        {
                            mFloat32Textures  = mGL.getExtension( 'OES_texture_float' );
                            mFloat32Filter    = mGL.getExtension( 'OES_texture_float_linear');
                            mFloat16Textures  = mGL.getExtension( 'OES_texture_half_float' );
                            mFloat16Filter    = mGL.getExtension( 'OES_texture_half_float_linear' );
                            mDerivatives      = mGL.getExtension( 'OES_standard_derivatives' );
                            mDrawBuffers      = mGL.getExtension( 'WEBGL_draw_buffers' );
                            mDepthTextures    = mGL.getExtension( 'WEBGL_depth_texture' );
                            mShaderTextureLOD = mGL.getExtension( 'EXT_shader_texture_lod' );
                            mAnisotropic      = mGL.getExtension( 'EXT_texture_filter_anisotropic' );
                            mRenderToFloat32F = mFloat32Textures;
                            mDebugShader      = null;
                            mAsynchCompile    = null;
							
							if( mDerivatives !== null) mGL.hint( mDerivatives.FRAGMENT_SHADER_DERIVATIVE_HINT_OES, mGL.NICEST);
                        }
                        
                        
                        var maxTexSize = mGL.getParameter( mGL.MAX_TEXTURE_SIZE );
                        var maxCubeSize = mGL.getParameter( mGL.MAX_CUBE_MAP_TEXTURE_SIZE );
                        var maxRenderbufferSize = mGL.getParameter( mGL.MAX_RENDERBUFFER_SIZE );
                        var extensions = mGL.getSupportedExtensions();
                        var textureUnits = mGL.getParameter( mGL.MAX_TEXTURE_IMAGE_UNITS );
                        console.log("WebGL (2.0=" + mIs20 + "):" +
                                    " Asynch Compile: "  + ((mAsynchCompile !==null) ? "yes" : "no") +
                                    ", Textures: F32 ["   + ((mFloat32Textures !==null) ? "yes" : "no") +
                                    "], F16 ["   + ((mFloat16Textures !==null) ? "yes" : "no") +
                                    "], Depth [" + ((mDepthTextures   !==null) ? "yes" : "no") +
                                    "], LOD ["    + ((mShaderTextureLOD!==null) ? "yes" : "no") +
                                    "], Aniso ["   + ((mAnisotropic     !==null) ? "yes" : "no") +
                                    "], Units [" + textureUnits +
                                    "], Max Size [" + maxTexSize +
                                    "], Cube Max Size [" + maxCubeSize +
                                    "], Targets: MRT ["            + ((mDrawBuffers     !==null) ? "yes" : "no") +
                                    "], F32 ["     + ((mRenderToFloat32F!==null) ? "yes" : "no") +
                                    "], Max Size [" + maxRenderbufferSize + "]");

                        // create a 2D quad Vertex Buffer
                        var vertices = new Float32Array( [ -1.0, -1.0,   1.0, -1.0,    -1.0,  1.0,     1.0, -1.0,    1.0,  1.0,    -1.0,  1.0] );
                        mVBO_Quad = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Quad );
                        mGL.bufferData( mGL.ARRAY_BUFFER, vertices, mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 2D triangle Vertex Buffer
                        mVBO_Tri = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Tri );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0,   3.0, -1.0,    -1.0,  3.0] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 3D cube Vertex Buffer
                        mVBO_CubePosNor = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePosNor );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0, -1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0, -1.0,  1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0,  1.0, -1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0,  1.0,  1.0,  -1.0,  0.0,  0.0,
                                                                               1.0,  1.0, -1.0,   1.0,  0.0,  0.0,
                                                                               1.0,  1.0,  1.0,   1.0,  0.0,  0.0,
                                                                               1.0, -1.0, -1.0,   1.0,  0.0,  0.0,
                                                                               1.0, -1.0,  1.0,   1.0,  0.0,  0.0,
                                                                               1.0,  1.0,  1.0,   0.0,  1.0,  0.0,
                                                                               1.0,  1.0, -1.0,   0.0,  1.0,  0.0,
                                                                              -1.0,  1.0,  1.0,   0.0,  1.0,  0.0,
                                                                              -1.0,  1.0, -1.0,   0.0,  1.0,  0.0,
                                                                               1.0, -1.0, -1.0,   0.0, -1.0,  0.0,
                                                                               1.0, -1.0,  1.0,   0.0, -1.0,  0.0,
                                                                              -1.0, -1.0, -1.0,   0.0, -1.0,  0.0,
                                                                              -1.0, -1.0,  1.0,   0.0, -1.0,  0.0,
                                                                              -1.0,  1.0,  1.0,   0.0,  0.0,  1.0,
                                                                              -1.0, -1.0,  1.0,   0.0,  0.0,  1.0,
                                                                               1.0,  1.0,  1.0,   0.0,  0.0,  1.0,
                                                                               1.0, -1.0,  1.0,   0.0,  0.0,  1.0,
                                                                              -1.0, -1.0, -1.0,   0.0,  0.0, -1.0,
                                                                              -1.0,  1.0, -1.0,   0.0,  0.0, -1.0,
                                                                               1.0, -1.0, -1.0,   0.0,  0.0, -1.0,
                                                                               1.0,  1.0, -1.0,   0.0,  0.0, -1.0 ] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 3D cube Vertex Buffer
                        mVBO_CubePos = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePos );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0, -1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                               1.0,  1.0, -1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0, -1.0,  1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0,  1.0, -1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0, -1.0,  1.0,
                                                                              -1.0, -1.0, -1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0, -1.0,  1.0,
                                                                              -1.0, -1.0, -1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0,  1.0, -1.0 ] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        //-------------------------------------------------------------------

                        mShaderHeader[0] = "";
                        mShaderHeaderLines[0] = 0;
                        if( mIs20 ) 
                        { 
                            mShaderHeader[0] += "#version 300 es\n" +
                                                "#ifdef GL_ES\n"+
                                                "precision highp float;\n" +
                                                "precision highp int;\n"+
                                                "precision mediump sampler3D;\n"+
                                                "#endif\n"; 
                            mShaderHeaderLines[0] += 6;
                        }
                        else
                        {
                            mShaderHeader[0] += "#ifdef GL_ES\n"+
                                                "precision highp float;\n" +
                                                "precision highp int;\n"+
                                                "#endif\n"+
                                                "float round( float x ) { return floor(x+0.5); }\n"+
                                                "vec2 round(vec2 x) { return floor(x + 0.5); }\n"+
                                                "vec3 round(vec3 x) { return floor(x + 0.5); }\n"+
                                                "vec4 round(vec4 x) { return floor(x + 0.5); }\n"+
                                                "float trunc( float x, float n ) { return floor(x*n)/n; }\n"+
                                                "mat3 transpose(mat3 m) { return mat3(m[0].x, m[1].x, m[2].x, m[0].y, m[1].y, m[2].y, m[0].z, m[1].z, m[2].z); }\n"+
                                                "float determinant( in mat2 m ) { return m[0][0]*m[1][1] - m[0][1]*m[1][0]; }\n"+
                                                "float determinant( mat4 m ) { float b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0], b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0], b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0], b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1], b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1], b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2], b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0], b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0], b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0], b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1], b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1], b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;}\n"+
                                                "mat2 inverse(mat2 m) { float det = determinant(m); return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / det; }\n"+
                                                "mat4 inverse(mat4 m ) { float inv0 = m[1].y*m[2].z*m[3].w - m[1].y*m[2].w*m[3].z - m[2].y*m[1].z*m[3].w + m[2].y*m[1].w*m[3].z + m[3].y*m[1].z*m[2].w - m[3].y*m[1].w*m[2].z; float inv4 = -m[1].x*m[2].z*m[3].w + m[1].x*m[2].w*m[3].z + m[2].x*m[1].z*m[3].w - m[2].x*m[1].w*m[3].z - m[3].x*m[1].z*m[2].w + m[3].x*m[1].w*m[2].z; float inv8 = m[1].x*m[2].y*m[3].w - m[1].x*m[2].w*m[3].y - m[2].x  * m[1].y * m[3].w + m[2].x  * m[1].w * m[3].y + m[3].x * m[1].y * m[2].w - m[3].x * m[1].w * m[2].y; float inv12 = -m[1].x  * m[2].y * m[3].z + m[1].x  * m[2].z * m[3].y +m[2].x  * m[1].y * m[3].z - m[2].x  * m[1].z * m[3].y - m[3].x * m[1].y * m[2].z + m[3].x * m[1].z * m[2].y; float inv1 = -m[0].y*m[2].z * m[3].w + m[0].y*m[2].w * m[3].z + m[2].y  * m[0].z * m[3].w - m[2].y  * m[0].w * m[3].z - m[3].y * m[0].z * m[2].w + m[3].y * m[0].w * m[2].z; float inv5 = m[0].x  * m[2].z * m[3].w - m[0].x  * m[2].w * m[3].z - m[2].x  * m[0].z * m[3].w + m[2].x  * m[0].w * m[3].z + m[3].x * m[0].z * m[2].w - m[3].x * m[0].w * m[2].z; float inv9 = -m[0].x  * m[2].y * m[3].w +  m[0].x  * m[2].w * m[3].y + m[2].x  * m[0].y * m[3].w - m[2].x  * m[0].w * m[3].y - m[3].x * m[0].y * m[2].w + m[3].x * m[0].w * m[2].y; float inv13 = m[0].x  * m[2].y * m[3].z - m[0].x  * m[2].z * m[3].y - m[2].x  * m[0].y * m[3].z + m[2].x  * m[0].z * m[3].y + m[3].x * m[0].y * m[2].z - m[3].x * m[0].z * m[2].y; float inv2 = m[0].y  * m[1].z * m[3].w - m[0].y  * m[1].w * m[3].z - m[1].y  * m[0].z * m[3].w + m[1].y  * m[0].w * m[3].z + m[3].y * m[0].z * m[1].w - m[3].y * m[0].w * m[1].z; float inv6 = -m[0].x  * m[1].z * m[3].w + m[0].x  * m[1].w * m[3].z + m[1].x  * m[0].z * m[3].w - m[1].x  * m[0].w * m[3].z - m[3].x * m[0].z * m[1].w + m[3].x * m[0].w * m[1].z; float inv10 = m[0].x  * m[1].y * m[3].w - m[0].x  * m[1].w * m[3].y - m[1].x  * m[0].y * m[3].w + m[1].x  * m[0].w * m[3].y + m[3].x * m[0].y * m[1].w - m[3].x * m[0].w * m[1].y; float inv14 = -m[0].x  * m[1].y * m[3].z + m[0].x  * m[1].z * m[3].y + m[1].x  * m[0].y * m[3].z - m[1].x  * m[0].z * m[3].y - m[3].x * m[0].y * m[1].z + m[3].x * m[0].z * m[1].y; float inv3 = -m[0].y * m[1].z * m[2].w + m[0].y * m[1].w * m[2].z + m[1].y * m[0].z * m[2].w - m[1].y * m[0].w * m[2].z - m[2].y * m[0].z * m[1].w + m[2].y * m[0].w * m[1].z; float inv7 = m[0].x * m[1].z * m[2].w - m[0].x * m[1].w * m[2].z - m[1].x * m[0].z * m[2].w + m[1].x * m[0].w * m[2].z + m[2].x * m[0].z * m[1].w - m[2].x * m[0].w * m[1].z; float inv11 = -m[0].x * m[1].y * m[2].w + m[0].x * m[1].w * m[2].y + m[1].x * m[0].y * m[2].w - m[1].x * m[0].w * m[2].y - m[2].x * m[0].y * m[1].w + m[2].x * m[0].w * m[1].y; float inv15 = m[0].x * m[1].y * m[2].z - m[0].x * m[1].z * m[2].y - m[1].x * m[0].y * m[2].z + m[1].x * m[0].z * m[2].y + m[2].x * m[0].y * m[1].z - m[2].x * m[0].z * m[1].y; float det = m[0].x * inv0 + m[0].y * inv4 + m[0].z * inv8 + m[0].w * inv12; det = 1.0 / det; return det*mat4( inv0, inv1, inv2, inv3,inv4, inv5, inv6, inv7,inv8, inv9, inv10, inv11,inv12, inv13, inv14, inv15);}\n"+                                                
                                                "float sinh(float x)  { return (exp(x)-exp(-x))/2.; }\n"+
                                                "float cosh(float x)  { return (exp(x)+exp(-x))/2.; }\n"+
                                                "float tanh(float x)  { return sinh(x)/cosh(x); }\n"+
                                                "float coth(float x)  { return cosh(x)/sinh(x); }\n"+
                                                "float sech(float x)  { return 1./cosh(x); }\n"+
                                                "float csch(float x)  { return 1./sinh(x); }\n"+
                                                "float asinh(float x) { return    log(x+sqrt(x*x+1.)); }\n"+
                                                "float acosh(float x) { return    log(x+sqrt(x*x-1.)); }\n"+
                                                "float atanh(float x) { return .5*log((1.+x)/(1.-x)); }\n"+
                                                "float acoth(float x) { return .5*log((x+1.)/(x-1.)); }\n"+
                                                "float asech(float x) { return    log((1.+sqrt(1.-x*x))/x); }\n"+
                                                "float acsch(float x) { return    log((1.+sqrt(1.+x*x))/x); }\n";
                            mShaderHeaderLines[0] += 26;
                        }

                        //-------------------------------------------------------

                        mShaderHeader[1] = "";
                        mShaderHeaderLines[1] = 0;
                        if( mIs20 ) 
                        { 
                            mShaderHeader[1] += "#version 300 es\n"+
                                                "#ifdef GL_ES\n"+
                                                "precision highp float;\n"+
                                                "precision highp int;\n"+
                                                "precision mediump sampler3D;\n"+
                                                "#endif\n"; 
                            mShaderHeaderLines[1] += 6;
                        }
                        else
                        {
                            if( mDerivatives ) { mShaderHeader[1] += "#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n"; mShaderHeaderLines[1]+=3; }
                            if( mShaderTextureLOD  ) { mShaderHeader[1] += "#extension GL_EXT_shader_texture_lod : enable\n"; mShaderHeaderLines[1]++; }
                            mShaderHeader[1] += "#ifdef GL_ES\n"+
                                                "precision highp float;\n"+
                                                "precision highp int;\n"+
                                                "#endif\n"+ 
                                                "vec4 texture(     sampler2D   s, vec2 c)                   { return texture2D(s,c); }\n"+
                                                "vec4 texture(     sampler2D   s, vec2 c, float b)          { return texture2D(s,c,b); }\n"+
                                                "vec4 texture(     samplerCube s, vec3 c )                  { return textureCube(s,c); }\n"+
                                                "vec4 texture(     samplerCube s, vec3 c, float b)          { return textureCube(s,c,b); }\n"+
                                                "float round( float x ) { return floor(x+0.5); }\n"+
                                                "vec2 round(vec2 x) { return floor(x + 0.5); }\n"+
                                                "vec3 round(vec3 x) { return floor(x + 0.5); }\n"+
                                                "vec4 round(vec4 x) { return floor(x + 0.5); }\n"+
                                                "float trunc( float x, float n ) { return floor(x*n)/n; }\n"+
                                                "mat3 transpose(mat3 m) { return mat3(m[0].x, m[1].x, m[2].x, m[0].y, m[1].y, m[2].y, m[0].z, m[1].z, m[2].z); }\n"+
                                                "float determinant( in mat2 m ) { return m[0][0]*m[1][1] - m[0][1]*m[1][0]; }\n"+
                                                "float determinant( mat4 m ) { float b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0], b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0], b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0], b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1], b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1], b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2], b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0], b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0], b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0], b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1], b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1], b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;}\n"+
                                                "mat2 inverse(mat2 m) { float det = determinant(m); return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / det; }\n"+
                                                "mat4 inverse(mat4 m ) { float inv0 = m[1].y*m[2].z*m[3].w - m[1].y*m[2].w*m[3].z - m[2].y*m[1].z*m[3].w + m[2].y*m[1].w*m[3].z + m[3].y*m[1].z*m[2].w - m[3].y*m[1].w*m[2].z; float inv4 = -m[1].x*m[2].z*m[3].w + m[1].x*m[2].w*m[3].z + m[2].x*m[1].z*m[3].w - m[2].x*m[1].w*m[3].z - m[3].x*m[1].z*m[2].w + m[3].x*m[1].w*m[2].z; float inv8 = m[1].x*m[2].y*m[3].w - m[1].x*m[2].w*m[3].y - m[2].x  * m[1].y * m[3].w + m[2].x  * m[1].w * m[3].y + m[3].x * m[1].y * m[2].w - m[3].x * m[1].w * m[2].y; float inv12 = -m[1].x  * m[2].y * m[3].z + m[1].x  * m[2].z * m[3].y +m[2].x  * m[1].y * m[3].z - m[2].x  * m[1].z * m[3].y - m[3].x * m[1].y * m[2].z + m[3].x * m[1].z * m[2].y; float inv1 = -m[0].y*m[2].z * m[3].w + m[0].y*m[2].w * m[3].z + m[2].y  * m[0].z * m[3].w - m[2].y  * m[0].w * m[3].z - m[3].y * m[0].z * m[2].w + m[3].y * m[0].w * m[2].z; float inv5 = m[0].x  * m[2].z * m[3].w - m[0].x  * m[2].w * m[3].z - m[2].x  * m[0].z * m[3].w + m[2].x  * m[0].w * m[3].z + m[3].x * m[0].z * m[2].w - m[3].x * m[0].w * m[2].z; float inv9 = -m[0].x  * m[2].y * m[3].w +  m[0].x  * m[2].w * m[3].y + m[2].x  * m[0].y * m[3].w - m[2].x  * m[0].w * m[3].y - m[3].x * m[0].y * m[2].w + m[3].x * m[0].w * m[2].y; float inv13 = m[0].x  * m[2].y * m[3].z - m[0].x  * m[2].z * m[3].y - m[2].x  * m[0].y * m[3].z + m[2].x  * m[0].z * m[3].y + m[3].x * m[0].y * m[2].z - m[3].x * m[0].z * m[2].y; float inv2 = m[0].y  * m[1].z * m[3].w - m[0].y  * m[1].w * m[3].z - m[1].y  * m[0].z * m[3].w + m[1].y  * m[0].w * m[3].z + m[3].y * m[0].z * m[1].w - m[3].y * m[0].w * m[1].z; float inv6 = -m[0].x  * m[1].z * m[3].w + m[0].x  * m[1].w * m[3].z + m[1].x  * m[0].z * m[3].w - m[1].x  * m[0].w * m[3].z - m[3].x * m[0].z * m[1].w + m[3].x * m[0].w * m[1].z; float inv10 = m[0].x  * m[1].y * m[3].w - m[0].x  * m[1].w * m[3].y - m[1].x  * m[0].y * m[3].w + m[1].x  * m[0].w * m[3].y + m[3].x * m[0].y * m[1].w - m[3].x * m[0].w * m[1].y; float inv14 = -m[0].x  * m[1].y * m[3].z + m[0].x  * m[1].z * m[3].y + m[1].x  * m[0].y * m[3].z - m[1].x  * m[0].z * m[3].y - m[3].x * m[0].y * m[1].z + m[3].x * m[0].z * m[1].y; float inv3 = -m[0].y * m[1].z * m[2].w + m[0].y * m[1].w * m[2].z + m[1].y * m[0].z * m[2].w - m[1].y * m[0].w * m[2].z - m[2].y * m[0].z * m[1].w + m[2].y * m[0].w * m[1].z; float inv7 = m[0].x * m[1].z * m[2].w - m[0].x * m[1].w * m[2].z - m[1].x * m[0].z * m[2].w + m[1].x * m[0].w * m[2].z + m[2].x * m[0].z * m[1].w - m[2].x * m[0].w * m[1].z; float inv11 = -m[0].x * m[1].y * m[2].w + m[0].x * m[1].w * m[2].y + m[1].x * m[0].y * m[2].w - m[1].x * m[0].w * m[2].y - m[2].x * m[0].y * m[1].w + m[2].x * m[0].w * m[1].y; float inv15 = m[0].x * m[1].y * m[2].z - m[0].x * m[1].z * m[2].y - m[1].x * m[0].y * m[2].z + m[1].x * m[0].z * m[2].y + m[2].x * m[0].y * m[1].z - m[2].x * m[0].z * m[1].y; float det = m[0].x * inv0 + m[0].y * inv4 + m[0].z * inv8 + m[0].w * inv12; det = 1.0 / det; return det*mat4( inv0, inv1, inv2, inv3,inv4, inv5, inv6, inv7,inv8, inv9, inv10, inv11,inv12, inv13, inv14, inv15);}\n"+
                                                "float sinh(float x)  { return (exp(x)-exp(-x))/2.; }\n"+
                                                "float cosh(float x)  { return (exp(x)+exp(-x))/2.; }\n"+
                                                "float tanh(float x)  { return sinh(x)/cosh(x); }\n"+
                                                "float coth(float x)  { return cosh(x)/sinh(x); }\n"+
                                                "float sech(float x)  { return 1./cosh(x); }\n"+
                                                "float csch(float x)  { return 1./sinh(x); }\n"+
                                                "float asinh(float x) { return    log(x+sqrt(x*x+1.)); }\n"+
                                                "float acosh(float x) { return    log(x+sqrt(x*x-1.)); }\n"+
                                                "float atanh(float x) { return .5*log((1.+x)/(1.-x)); }\n"+
                                                "float acoth(float x) { return .5*log((x+1.)/(x-1.)); }\n"+
                                                "float asech(float x) { return    log((1.+sqrt(1.-x*x))/x); }\n"+
                                                "float acsch(float x) { return    log((1.+sqrt(1.+x*x))/x); }\n";
                            mShaderHeaderLines[1] += 30;
                            if( mShaderTextureLOD )
                            {
                            mShaderHeader[1] += "vec4 textureLod(  sampler2D   s, vec2 c, float b)          { return texture2DLodEXT(s,c,b); }\n";
                            mShaderHeader[1] += "vec4 textureGrad( sampler2D   s, vec2 c, vec2 dx, vec2 dy) { return texture2DGradEXT(s,c,dx,dy); }\n";
                            mShaderHeaderLines[1] += 2;

                            //mShaderHeader[1] += "vec4 texelFetch( sampler2D s, ivec2 c, int l) { return texture2DLodEXT(s,(vec2(c)+0.5)/vec2(800,450),float(l)); }\n";
                            //mShaderHeaderLines[1] += 1;
                            }
                        }

                        return true;
                    };

        me.GetCaps =    function ()
                        {   
                            return { mIsGL20 : mIs20,
                                     mFloat32Textures: mFloat32Textures != null,
                                     mFloat16Textures: mFloat16Textures != null,
                                     mDrawBuffers: mDrawBuffers != null,
                                     mDepthTextures: mDepthTextures != null,
                                     mDerivatives: mDerivatives != null,
                                     mShaderTextureLOD: mShaderTextureLOD != null };
                        };

        me.GetShaderHeaderLines = function (shaderType)
                        {   
                            return mShaderHeaderLines[shaderType];
                        };

        me.CheckErrors = function()
                         {
                                var error = mGL.getError();
                                if( error != mGL.NO_ERROR ) 
                                { 
                                    for( var prop in mGL ) 
                                    {
                                        if( typeof mGL[prop] == 'number' ) 
                                        {
                                            if( mGL[prop] == error )
                                            {
                                                console.log( "GL Error " + error + ": " + prop );
                                                break;
                                            }
                                        }
                                    }
                                }
                         };

        me.Clear =  function( flags, ccolor, cdepth, cstencil )
                    {
                        var mode = 0;
                        if( flags & 1 ) { mode |= mGL.COLOR_BUFFER_BIT;   mGL.clearColor( ccolor[0], ccolor[1], ccolor[2], ccolor[3] ); }
                        if( flags & 2 ) { mode |= mGL.DEPTH_BUFFER_BIT;   mGL.clearDepth( cdepth ); }
                        if( flags & 4 ) { mode |= mGL.STENCIL_BUFFER_BIT; mGL.clearStencil( cstencil ); }
                        mGL.clear( mode );
                    };


        me.CreateTexture = function ( type, xres, yres, format, filter, wrap, buffer)
                           {
                                if( mGL===null ) return null;

                                var id = mGL.createTexture();

                                var glFoTy = iFormatPI2GL( format );
                                var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                if( type===me.TEXTYPE.T2D )
                                {
                                    mGL.bindTexture( mGL.TEXTURE_2D, id );
//if( buffer==null )
    //mGL.texStorage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, xres, yres);
//else
                                    mGL.texImage2D( mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texParameteri( mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap );
                                    mGL.texParameteri( mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap );

                                    if (filter === me.FILTER.NONE)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }

                                    mGL.bindTexture( mGL.TEXTURE_2D, null );
                                }
                                else if( type===me.TEXTYPE.T3D )
                                {
                                    if( mIs20 )
                                    {
                                        mGL.bindTexture( mGL.TEXTURE_3D, id );
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_BASE_LEVEL, 0);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAX_LEVEL, Math.log2(xres));
                                        if (filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                        }
                                        else if (filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        }
                                        else
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_3D);
                                        }
                                        mGL.texImage3D( mGL.TEXTURE_3D, 0, glFoTy.mGLFormat, xres, yres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );

                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_R, glWrap );
                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_S, glWrap );
                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_T, glWrap );

                                        if (filter === me.FILTER.MIPMAP)
                                            mGL.generateMipmap( mGL.TEXTURE_3D );
                                        mGL.bindTexture( mGL.TEXTURE_3D, null );
                                    }
                                    else 
                                    {
                                        return null;
                                    }
                                }
                                else 
                                {
                                    mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );

                                    // this works great if we know the number of required mipmaps in advance (1, or other)
                                   //mGL.texStorage2D( mGL.TEXTURE_CUBE_MAP, 1, glFoTy.mGLFormat, xres, yres );

                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );

                                    if( filter === me.FILTER.NONE)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR)
                                    {
                                        mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR );
                                        mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR );
                                    }
                                    else if (filter === me.FILTER.MIPMAP)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                    }

                                    if (filter === me.FILTER.MIPMAP)
                                        mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );

                                    mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                }
                        return { mObjectID: id, mXres: xres, mYres: yres, mFormat: format, mType: type, mFilter: filter, mWrap: wrap, mVFlip:false };
                        };

        me.CreateTextureFromImage = function ( type, image, format, filter, wrap, flipY) 
                                {
                                    if( mGL===null ) return null;

                                    var id = mGL.createTexture();

                                    var glFoTy = iFormatPI2GL( format );

                                    var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                    if( type===me.TEXTYPE.T2D )
                                    {
                                        mGL.bindTexture(mGL.TEXTURE_2D, id);

                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, flipY);
                                        mGL.pixelStorei(mGL.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                                        if( mIs20 ) mGL.pixelStorei(mGL.UNPACK_COLORSPACE_CONVERSION_WEBGL, mGL.NONE );

                                        mGL.texImage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image);

                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap);

                                        if (filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                        }
                                        else if( filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_2D);
                                        }
                                        else
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_2D);
                                        }
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                        mGL.bindTexture(mGL.TEXTURE_2D, null);
                                    }
                                    else if( type===me.TEXTYPE.T3D )
                                    {
                                        return null;
                                    }
                                    else 
                                    {
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, flipY);
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[0] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[1] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (flipY ? image[3] : image[2]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (flipY ? image[2] : image[3]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[4] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[5] );

                                        if( filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR );
                                            mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR );
                                        }
                                        else if (filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                            mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );
                                        }
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                    }
                                    return { mObjectID: id, mXres: image.width, mYres: image.height, mFormat: format, mType: type, mFilter: filter, mWrap:wrap, mVFlip:flipY };
                                };

        me.SetSamplerFilter = function (te, filter, doGenerateMipsIfNeeded) 
                            {
                                if (te.mFilter === filter) return;

                                if (te.mType === me.TEXTYPE.T2D) 
                                {
                                    mGL.bindTexture(mGL.TEXTURE_2D, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_2D, null);

                                }
                                else if (te.mType === me.TEXTYPE.T3D) 
                                {
                                    mGL.bindTexture(mGL.TEXTURE_3D, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_3D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_3D);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_3D, null);

                                }
                                else
                                {
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_CUBE_MAP);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_CUBE_MAP);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                                }


                                te.mFilter = filter;
                            };

        me.SetSamplerWrap = function (te, wrap)
                            {
                                if (te.mWrap === wrap) return;

                                var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                var id = te.mObjectID;

                                if (te.mType === me.TEXTYPE.T2D)
                                {
                                    mGL.bindTexture(mGL.TEXTURE_2D, id);
                                    mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap);
                                    mGL.bindTexture(mGL.TEXTURE_2D, null);

                                }
                                else if (te.mType === me.TEXTYPE.T3D)
                                {
                                    mGL.bindTexture(mGL.TEXTURE_3D, id);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_R, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_S, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_T, glWrap);
                                    mGL.bindTexture(mGL.TEXTURE_3D, null);
                                }

                                te.mWrap = wrap;
                            };

        me.SetSamplerVFlip = function (te, vflip, image)
                            {
                                if (te.mVFlip === vflip) return;

                                var id = te.mObjectID;

                                if (te.mType === me.TEXTYPE.T2D)
                                {
                                    if( image != null)
                                    {
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture(mGL.TEXTURE_2D, id);
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, vflip);
                                        var glFoTy = iFormatPI2GL( te.mFormat );
                                        mGL.texImage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image);
                                        mGL.bindTexture(mGL.TEXTURE_2D, null);
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
                                }
                                else if (te.mType === me.TEXTYPE.CUBEMAP)
                                {
                                    if( image != null)
                                    {
                                        var glFoTy = iFormatPI2GL( te.mFormat );
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );
                                        mGL.pixelStorei( mGL.UNPACK_FLIP_Y_WEBGL, vflip);
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[0] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[1] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (vflip ? image[3] : image[2]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (vflip ? image[2] : image[3]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[4] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[5] );
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
        
                                }

                                te.mVFlip = vflip;
                            };

        me.CreateMipmaps =  function (te)
                            {
                                if( te.mType===me.TEXTYPE.T2D )
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                    mGL.bindTexture(mGL.TEXTURE_2D, te.mObjectID);
                                    mGL.generateMipmap(mGL.TEXTURE_2D);
                                    mGL.bindTexture(mGL.TEXTURE_2D, null);
                                }
                                else if( te.mType===me.TEXTYPE.CUBEMAP )
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, te.mObjectID);
                                    mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                                }
                            };

        me.UpdateTexture =  function( tex, x0, y0, xres, yres, buffer )
                            {
                                var glFoTy = iFormatPI2GL( tex.mFormat );
                                if( tex.mType===me.TEXTYPE.T2D )
                                {
                                    mGL.activeTexture( mGL.TEXTURE0);
                                    mGL.bindTexture( mGL.TEXTURE_2D, tex.mObjectID );
                                    mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, tex.mVFlip );
                                    mGL.texSubImage2D( mGL.TEXTURE_2D, 0, x0, y0, xres, yres, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.bindTexture( mGL.TEXTURE_2D, null );
                                    mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                }
                            };

        me.UpdateTextureFromImage = function( tex, image )
                                {
                                    var glFoTy = iFormatPI2GL( tex.mFormat );
                                    if( tex.mType===me.TEXTYPE.T2D )
                                    {
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture( mGL.TEXTURE_2D, tex.mObjectID );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, tex.mVFlip );
                                        mGL.texImage2D(  mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image );
                                        mGL.bindTexture( mGL.TEXTURE_2D, null );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
                                };

        me.DestroyTexture = function( te )
                            {
                                 mGL.deleteTexture( te.mObjectID );
                            };

        me.AttachTextures = function (num, t0, t1, t2, t3) 
                            {
                                if (num > 0 && t0 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                         if (t0.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t0.mObjectID);
                                    else if (t0.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t0.mObjectID);
                                    else if (t0.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t0.mObjectID);
                                }

                                if (num > 1 && t1 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE1);
                                         if (t1.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t1.mObjectID);
                                    else if (t1.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t1.mObjectID);
                                    else if (t1.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t1.mObjectID);
                                }

                                if (num > 2 && t2 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE2);
                                         if (t2.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t2.mObjectID);
                                    else if (t2.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t2.mObjectID);
                                    else if (t2.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t2.mObjectID);
                                }

                                if (num > 3 && t3 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE3);
                                         if (t3.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t3.mObjectID);
                                    else if (t3.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t3.mObjectID);
                                    else if (t3.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t3.mObjectID);
                                }
                            };

        me.DettachTextures = function()
                             {
                                mGL.activeTexture(mGL.TEXTURE0);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE1);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE2);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE3);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                             };

        me.CreateRenderTarget = function ( color0, color1, color2, color3, depth, wantZbuffer )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if (depth === null)
                                    {
                                        if( wantZbuffer===true )
                                        {
                                            var zb = mGL.createRenderbuffer();
                                            mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);
                                            mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, color0.mXres, color0.mYres);

                                            mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                        }
                                    }
                                    else
                                    {
                                        mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.TEXTURE_2D, depth.mObjectID, 0);
                                    }

                                    if( color0 !=null ) mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_2D, color0.mObjectID, 0);

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                        return null;

                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mTex0: color0 };
                                };

        me.DestroyRenderTarget = function ( tex )
                                 {
                                     mGL.deleteFramebuffer(tex.mObjectID);
                                 };

        me.SetRenderTarget = function (tex)
                             {
                                if( tex===null )
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                else
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, tex.mObjectID);

                                //mGL.drawBuffers([mGL.COLOR_ATTACHMENT0, mGL.COLOR_ATTACHMENT1]);
                             };

        me.CreateRenderTargetNew = function ( wantColor0, wantZbuffer, xres, yres, samples )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if( wantZbuffer===true )
                                    {
                                        var zb = mGL.createRenderbuffer();
                                        mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);

                                        if( samples==1 )
                                        mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, xres, yres);
                                        else
                                        mGL.renderbufferStorageMultisample(mGL.RENDERBUFFER, samples, mGL.DEPTH_COMPONENT16, xres, yres);
                                        mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                    }

                                    if( wantColor0 )
                                    {
                                        var cb = mGL.createRenderbuffer();
                                        mGL.bindRenderbuffer(mGL.RENDERBUFFER, cb);
                                        if( samples==1 )
                                        mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.RGBA8, xres, yres);
                                        else
                                        mGL.renderbufferStorageMultisample(mGL.RENDERBUFFER, samples, mGL.RGBA8, xres, yres);
                                        mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.RENDERBUFFER, cb);
                                    }

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                    {
                                        return null;
                                    }
                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mXres: xres, mYres:yres, mTex0: color0 };
                                };

        me.CreateRenderTargetCubeMap = function ( color0, depth, wantZbuffer )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if (depth === null)
                                    {
                                        if( wantZbuffer===true )
                                        {
                                            var zb = mGL.createRenderbuffer();
                                            mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);
                                            mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, color0.mXres, color0.mYres);
                                            mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                        }
                                    }
                                    else
                                    {
                                        mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.TEXTURE_2D, depth.mObjectID, 0);
                                    }

                                    if( color0 !=null ) mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_CUBE_MAP_POSITIVE_X, color0.mObjectID, 0);

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                        return null;

                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mTex0: color0 };
                                };

        me.SetRenderTargetCubeMap = function (fbo, face)
                             {
                                if( fbo===null )
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                else
                                {
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, fbo.mObjectID);
                                    mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_CUBE_MAP_POSITIVE_X+face, fbo.mTex0.mObjectID, 0);
                                }
                             };


        me.BlitRenderTarget = function( dst, src )
                                {
                                    mGL.bindFramebuffer(mGL.READ_FRAMEBUFFER, src.mObjectID);
                                    mGL.bindFramebuffer(mGL.DRAW_FRAMEBUFFER, dst.mObjectID);
                                    mGL.clearBufferfv(mGL.COLOR, 0, [0.0, 0.0, 0.0, 1.0]);
                                    mGL.blitFramebuffer( 0, 0, src.mXres, src.mYres,
                                                         0, 0, src.mXres, src.mYres,
                                                         mGL.COLOR_BUFFER_BIT, mGL.LINEAR
                                    );
                                };

        me.SetViewport = function( vp )
                         {
                              mGL.viewport( vp[0], vp[1], vp[2], vp[3] );
                         };

        me.SetWriteMask = function( c0, c1, c2, c3, z )
                          {
                              mGL.depthMask(z);
                              mGL.colorMask(c0,c0,c0,c0);
                          };

        me.SetState = function( stateName, stateValue )
                      {
                            if (stateName === me.RENDSTGATE.WIREFRAME)
                            {
                                if( stateValue ) mGL.polygonMode( mGL.FRONT_AND_BACK, mGL.LINE );
                                else             mGL.polygonMode( mGL.FRONT_AND_BACK, mGL.FILL );
                            }
                            else if (stateName === me.RENDSTGATE.FRONT_FACE)
                            {
                                if( stateValue ) mGL.cullFace( mGL.BACK );
                                else             mGL.cullFace( mGL.FRONT );
                            }
                            else if (stateName === me.RENDSTGATE.CULL_FACE)
                            {
                                if( stateValue ) mGL.enable( mGL.CULL_FACE );
                                else             mGL.disable( mGL.CULL_FACE );
                            }
                            else if (stateName === me.RENDSTGATE.DEPTH_TEST)
                            {
                                if( stateValue ) mGL.enable( mGL.DEPTH_TEST );
                                else             mGL.disable( mGL.DEPTH_TEST );
                            }
                            else if (stateName === me.RENDSTGATE.ALPHA_TO_COVERAGE)
                            {
                                if( stateValue ) { mGL.enable(  mGL.SAMPLE_ALPHA_TO_COVERAGE ); }
                                else             { mGL.disable( mGL.SAMPLE_ALPHA_TO_COVERAGE ); }
                            }
                      };

        me.SetMultisample = function( v)
                    {
                        if( v===true )
                        {
                            mGL.enable(mGL.SAMPLE_COVERAGE);
                            mGL.sampleCoverage(1.0, false);
                        }
                        else
                        {
                            mGL.disable(mGL.SAMPLE_COVERAGE);
                        }
                    };

        me.GetTranslatedShaderSource = function (shader) 
                          {
                            if( mGL===null ) return null;
                            if( mDebugShader===null ) return null;
                            let vfs = mGL.getAttachedShaders(shader.mProgram);
                            let str = mDebugShader.getTranslatedShaderSource(vfs[1]);
                            let parts = str.split("GLSL END"); str = (parts.length<2) ? str : parts[1];
                            return str;
                          };

        me.CreateShader = function (vsSource, fsSource, preventCache, forceSynch, onResolve) 
                          {
                            if( mGL===null ) return;

                            var vs = mGL.createShader( mGL.VERTEX_SHADER   );
                            var fs = mGL.createShader( mGL.FRAGMENT_SHADER );

                            vsSource = mShaderHeader[0] + vsSource;
                            fsSource = mShaderHeader[1] + fsSource;

                            if( preventCache )
                            {
                                let vran = Math.random().toString(36).substring(7);
                                let fran = Math.random().toString(36).substring(7);
                                vsSource += "\n#define K" + vran + "\n";
                                fsSource += "\n#define K" + fran + "\n";
                            }

                            var timeStart = getRealTime();

                            mGL.shaderSource(vs, vsSource);
                            mGL.shaderSource(fs, fsSource);
                            mGL.compileShader(vs);
                            mGL.compileShader(fs);

                            var pr = mGL.createProgram();
                            mGL.attachShader(pr, vs);
                            mGL.attachShader(pr, fs);
                            mGL.linkProgram(pr);

                            //-------------
                            let checkErrors = function()
                            {
                                if (!mGL.getProgramParameter(pr, mGL.LINK_STATUS))
                                {
                                    // vs error
                                    if (!mGL.getShaderParameter(vs, mGL.COMPILE_STATUS))
                                    {
                                        let vsLog = mGL.getShaderInfoLog(vs);
                                        onResolve(false, { mErrorType: 0, mErrorStr: vsLog });
                                        mGL.deleteProgram(pr);
                                    }
                                    // fs error
                                    else if (!mGL.getShaderParameter(fs, mGL.COMPILE_STATUS))
                                    {
                                        let fsLog = mGL.getShaderInfoLog(fs);
                                        onResolve(false, { mErrorType: 1, mErrorStr: fsLog });
                                        mGL.deleteProgram(pr);
                                    }
                                    // link error
                                    else
                                    {
                                        let infoLog = mGL.getProgramInfoLog(pr);
                                        onResolve(false, { mErrorType: 2, mErrorStr: infoLog });
                                        mGL.deleteProgram(pr);
                                    }
                                }
                                // no errors
                                else
                                {
                                    let compilationTime = getRealTime() - timeStart;
                                    onResolve(true, { mProgram: pr, mTime: compilationTime });
                                }
                            };

                            // check compilation
                            if (mAsynchCompile === null || forceSynch===true )
                            {
                                checkErrors();
                            }
                            else
                            {
                                let loopCheckCompletion = function ()
                                {
                                    if( mGL.getProgramParameter(pr, mAsynchCompile.COMPLETION_STATUS_KHR) === true )
                                        checkErrors();
                                    else
                                        setTimeout(loopCheckCompletion, 10);
                                };
                                setTimeout(loopCheckCompletion, 10);
                            }
                        };

        me.AttachShader = function( shader )
                          {
                                if( shader===null )
                                {
                                    mBindedShader = null;
                                    mGL.useProgram( null );
                                }
                                else
                                {
                                    mBindedShader = shader;
                                    mGL.useProgram(shader.mProgram);
                                }
                          };

        me.DetachShader = function ()
                        {
                            mGL.useProgram(null);
                        };

        me.DestroyShader = function( tex )
                        {
                            mGL.deleteProgram(tex.mProgram);
                        };

        me.GetAttribLocation = function (shader, name)
                        {
                            return mGL.getAttribLocation(shader.mProgram, name);
                        };

        me.SetShaderConstantLocation = function (shader, name)
                        {
                            return mGL.getUniformLocation(shader.mProgram, name);
                        };

        me.SetShaderConstantMat4F = function( uname, params, istranspose )
                        {
                            var program = mBindedShader;

                            let pos = mGL.getUniformLocation( program.mProgram, uname );
                            if( pos===null )
                                return false;

                            if( istranspose===false )
                            {
                                var tmp = new Float32Array( [ params[0], params[4], params[ 8], params[12],
                                                              params[1], params[5], params[ 9], params[13],
                                                              params[2], params[6], params[10], params[14],
                                                              params[3], params[7], params[11], params[15] ] );
	                            mGL.uniformMatrix4fv(pos,false,tmp);
                            }
                            else
                                mGL.uniformMatrix4fv(pos,false,new Float32Array(params) );
                            return true;
                        };

        me.SetShaderConstant1F_Pos = function(pos, x)
                        {
                            mGL.uniform1f(pos, x);
                            return true;
                        };

        me.SetShaderConstant1FV_Pos = function(pos, x)
                        {
                            mGL.uniform1fv(pos, x);
                            return true;
                        };

        me.SetShaderConstant1F = function( uname, x )
                        {
                            var pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1f(pos, x);
                            return true;
                        };

        me.SetShaderConstant1I = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1i(pos, x);
                            return true;
                        };
        me.SetShaderConstant1I_Pos = function(pos, x)
                        {
                            mGL.uniform1i(pos, x);
                            return true;
                        };


        me.SetShaderConstant2F = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform2fv(pos, x);
                            return true;
                        };

        me.SetShaderConstant3F = function(uname, x, y, z)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform3f(pos, x, y, z);
                            return true;
                        };

        me.SetShaderConstant1FV = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1fv(pos, new Float32Array(x));
                            return true;
                        };

        me.SetShaderConstant3FV = function(uname, x) 
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform3fv(pos, new Float32Array(x) );
                            return true;
                        };

        me.SetShaderConstant4FV = function(uname, x) 
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform4fv(pos, new Float32Array(x) );
                            return true;
                        };

        me.SetShaderTextureUnit = function( uname, unit )
                        {
                            var program = mBindedShader;
                            let pos = mGL.getUniformLocation(program.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform1i(pos, unit);
                            return true;
                        };

        me.CreateVertexArray = function( data, mode )
                        {
                            let id = mGL.createBuffer();
                            mGL.bindBuffer(mGL.ARRAY_BUFFER, id);
                            if (mode === me.BUFTYPE.STATIC)
                                mGL.bufferData(mGL.ARRAY_BUFFER, data, mGL.STATIC_DRAW);
                            else
                                mGL.bufferData(mGL.ARRAY_BUFFER, data, mGL.DYNAMIC_DRAW);
                            return { mObject: id };
                        };

        me.CreateIndexArray = function( data, mode )
                        {
                            let id = mGL.createBuffer();
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, id );
                            if (mode === me.BUFTYPE.STATIC)
                                mGL.bufferData(mGL.ELEMENT_ARRAY_BUFFER, data, mGL.STATIC_DRAW);
                            else
                                mGL.bufferData(mGL.ELEMENT_ARRAY_BUFFER, data, mGL.DYNAMIC_DRAW);
                            return { mObject: id };
                        };

        me.DestroyArray = function( tex )
                        {
                            mGL.destroyBuffer(tex.mObject);
                        };

        me.AttachVertexArray = function( tex, attribs, pos )
                        {
                            let shader = mBindedShader;

                            mGL.bindBuffer( mGL.ARRAY_BUFFER, tex.mObject);

                            var num = attribs.mChannels.length;
                            var stride = attribs.mStride;

                            var offset = 0;
                            for (var i = 0; i < num; i++)
                            {
                                var id = pos[i];
                                mGL.enableVertexAttribArray(id);
                                var dtype = mGL.FLOAT;
                                var dsize = 4;
                                     if( attribs.mChannels[i].mType === me.TYPE.UINT8   ) { dtype = mGL.UNSIGNED_BYTE;  dsize = 1; }
                                else if( attribs.mChannels[i].mType === me.TYPE.UINT16  ) { dtype = mGL.UNSIGNED_SHORT; dsize = 2; }
                                else if( attribs.mChannels[i].mType === me.TYPE.FLOAT32 ) { dtype = mGL.FLOAT;          dsize = 4; }
                                mGL.vertexAttribPointer(id, attribs.mChannels[i].mNumComponents, dtype, attribs.mChannels[i].mNormalize, stride, offset);
                                offset += attribs.mChannels[i].mNumComponents * dsize;
                            }
                        };

        me.AttachIndexArray = function( tex )
                        {
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, tex.mObject);
                        };

        me.DetachVertexArray = function (tex, attribs)
                        {
                            let num = attribs.mChannels.length;
                            for (let i = 0; i < num; i++)
                                mGL.disableVertexAttribArray(i);
                            mGL.bindBuffer(mGL.ARRAY_BUFFER, null);
                        };

        me.DetachIndexArray = function( tex )
                        {
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, null);
                        };

        me.DrawPrimitive = function( typeOfPrimitive, num, useIndexArray, numInstances )
                        {
                            let glType = mGL.POINTS;
                            if( typeOfPrimitive===me.PRIMTYPE.POINTS ) glType = mGL.POINTS;
                            if( typeOfPrimitive===me.PRIMTYPE.LINES ) glType = mGL.LINES;
                            if( typeOfPrimitive===me.PRIMTYPE.LINE_LOOP ) glType = mGL.LINE_LOOP;
                            if( typeOfPrimitive===me.PRIMTYPE.LINE_STRIP ) glType = mGL.LINE_STRIP;
                            if( typeOfPrimitive===me.PRIMTYPE.TRIANGLES ) glType = mGL.TRIANGLES;
                            if( typeOfPrimitive===me.PRIMTYPE.TRIANGLE_STRIP ) glType = mGL.TRIANGLE_STRIP;

                            if( numInstances<=1 )
                            {
  	                            if( useIndexArray ) mGL.drawElements( glType, num, mGL.UNSIGNED_SHORT, 0 );
	                            else                mGL.drawArrays( glType, 0, num );
                            }
                            else
                            {
                                mGL.drawArraysInstanced(glType, 0, num, numInstances);
                                mGL.drawElementsInstanced( glType, num, mGL.UNSIGNED_SHORT, 0, numInstances);
                            }
                        };


        me.DrawFullScreenTriangle_XY = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Tri );
                            mGL.vertexAttribPointer( vpos, 2, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays( mGL.TRIANGLES, 0, 3 );
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        };


        me.DrawUnitQuad_XY = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Quad );
                            mGL.vertexAttribPointer( vpos, 2, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays( mGL.TRIANGLES, 0, 6 );
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        };

        me.DrawUnitCube_XYZ_NOR = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePosNor );
                            mGL.vertexAttribPointer( vpos[0], 3, mGL.FLOAT, false, 0, 0 );
                            mGL.vertexAttribPointer( vpos[1], 3, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos[0] );
                            mGL.enableVertexAttribArray( vpos[1] );
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 0, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 4, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 8, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 12, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 16, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 20, 4);
                            mGL.disableVertexAttribArray( vpos[0] );
                            mGL.disableVertexAttribArray( vpos[1] );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        }

        me.DrawUnitCube_XYZ = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePos );
                            mGL.vertexAttribPointer( vpos, 3, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 0, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 4, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 8, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 12, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 16, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 20, 4);
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        }

        me.SetBlend = function( enabled )
                    {
                        if( enabled )
                        {
                            mGL.enable( mGL.BLEND );
                            mGL.blendEquationSeparate( mGL.FUNC_ADD, mGL.FUNC_ADD );
                            mGL.blendFuncSeparate( mGL.SRC_ALPHA, mGL.ONE_MINUS_SRC_ALPHA, mGL.ONE, mGL.ONE_MINUS_SRC_ALPHA );
                        }
                        else
                        {
                            mGL.disable( mGL.BLEND );
                        }
                    };

        me.GetPixelData = function( data, offset, xres, yres )
                        {
                            mGL.readPixels(0, 0, xres, yres, mGL.RGBA, mGL.UNSIGNED_BYTE, data, offset);
                        };

        me.GetPixelDataRenderTarget = function( obj, data, xres, yres )
                        {
                            mGL.bindFramebuffer(mGL.FRAMEBUFFER, obj.mObjectID);
                            mGL.readBuffer(mGL.COLOR_ATTACHMENT0);
                            mGL.readPixels(0, 0, xres, yres, mGL.RGBA, mGL.FLOAT, data, 0);
                            mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                        };
    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piShading
//
//==============================================================================

function smoothstep(a, b, x)
{
    x = (x - a) / (b - a);
    if (x < 0) x = 0; else if (x > 1) x = 1;
    return x * x * (3.0 - 2.0 * x);
}

function clamp01(x)
{
    if( x < 0.0 ) x = 0.0;
    if( x > 1.0 ) x = 1.0;
    return x;
}

function clamp(x, a, b)
{
    if( x < a ) x = a;
    if( x > b ) x = b;
    return x;
}

function screen(a, b)
{
    return 1.0 - (1.0 - a) * (1.0 - b);
}

function parabola(x)
{
    return 4.0 * x * (1.0 - x);
}

function min(a, b)
{
    return (a < b) ? a : b;
}

function max(a, b)
{
    return (a > b) ? a : b;
}

function noise( x )
{
    function grad(i, j, x, y)
    {
        var h = 7 * i + 131 * j;
        h = (h << 13) ^ h;
        h = (h * (h * h * 15731 + 789221) + 1376312589);

        var rx = (h & 0x20000000) ? x : -x;
        var ry = (h & 0x10000000) ? y : -y;

        return rx + ry;
    }

    var i = [ Math.floor(x[0]), Math.floor(x[1]) ];
    var f = [ x[0] - i[0], x[1] - i[1] ];
    var w = [ f[0]*f[0]*(3.0-2.0*f[0]), f[1]*f[1]*(3.0-2.0*f[1]) ];

    var a = grad( i[0]+0, i[1]+0, f[0]+0.0, f[1]+0.0 );
    var b = grad( i[0]+1, i[1]+0, f[0]-1.0, f[1]+0.0 );
    var c = grad( i[0]+0, i[1]+1, f[0]+0.0, f[1]-1.0 );
    var d = grad( i[0]+1, i[1]+1, f[0]-1.0, f[1]-1.0 );

    return a + (b-a)*w[0] + (c-a)*w[1] + (a-b-c+d)*w[0]*w[1];
}//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piVecTypes
//
//==============================================================================


function vec3( a, b, c )
{
    return [ a, b, c ];
}

function add( a, b )
{
    return [ a[0]+b[0], a[1]+b[1], a[2]+b[2] ];
}

function sub( a, b )
{
    return [ a[0]-b[0], a[1]-b[1], a[2]-b[2] ];
}

function mul( a, s ) 
{
    return [ a[0]*s, a[1]*s, a[2]*s ];
}

function cross( a, b )
{
    return [ a[1]*b[2] - a[2]*b[1],
             a[2]*b[0] - a[0]*b[2],
             a[0]*b[1] - a[1]*b[0] ];
}

function dot( a, b ) 
{
    return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
}

function normalize( v ) 
{
    var is = 1.0 / Math.sqrt( v[0]*v[0] + v[1]*v[1] + v[2]*v[2] );
    return [ v[0]*is, v[1]*is, v[2]*is ];
}

function createCirclePoint( cen, uuu, vvv, rad, s, t )
{
    return [ cen[0] + rad*(uuu[0]*s + vvv[0]*t),
             cen[1] + rad*(uuu[1]*s + vvv[1]*t),
             cen[2] + rad*(uuu[2]*s + vvv[2]*t) ];
}

function createTangent( a, b, c )
{
    var cb = normalize( [ c[0]-b[0], c[1]-b[1], c[2]-b[2] ] );
    var ba = normalize( [ b[0]-a[0], b[1]-a[1], b[2]-a[2] ] );
    return normalize( [ ba[0]+cb[0], ba[1]+cb[1], ba[2]+cb[2] ] );

}

//===================================

function vec4( a, b, c, d )
{
    return [ a, b, c, d ];
}

function getXYZ( v )
{
    return [ v[0], v[1], v[2] ];
}

//===================================

function setIdentity()
{
    return [ 1.0, 0.0, 0.0, 0.0,
             0.0, 1.0, 0.0, 0.0,
             0.0, 0.0, 1.0, 0.0,
             0.0, 0.0, 0.0, 1.0 ];
}

function setRotationX( t )
{
    var sint = Math.sin(t);
    var cost = Math.cos(t);

    return [ 1.0,   0.0,   0.0, 0.0,
             0.0,  cost, -sint, 0.0, 
             0.0,  sint,  cost, 0.0,
             0.0,   0.0,   0.0, 1.0 ];
}

function setRotationY( t )
{
    var sint = Math.sin(t);
    var cost = Math.cos(t);

    return [ cost, 0.0, -sint, 0.0,
              0.0, 1.0,   0.0, 0.0, 
             sint, 0.0,  cost, 0.0,
              0.0, 0.0,   0.0, 1.0 ];
}

function extractRotationEuler( m)
{
    var res = [];
    if (m[0] == 1.0)
    {
        res[0] = Math.atan2(m[2], m[11]);
        res[1] = 0.0;
        res[2] = 0.0;

    }
    else if (m[0] == -1.0)
    {
        res[0] = Math.atan2( m[2], m[11]);
        res[1] = 0.0;
        res[2] = 0.0;
    }
    else
    {
        res[0] = Math.atan2( -m[9], m[10]);
        res[1] = Math.atan2( m[8], Math.sqrt(m[9]*m[9] + m[10]*m[10]));
        res[2] = Math.atan2( m[4], m[0]);
    }
    return res;
}

function setFromQuaternion( q )
{
    var ww = q[3]*q[3];
    var xx = q[0]*q[0];
    var yy = q[1]*q[1];
    var zz = q[2]*q[2];

    return [ ww+xx-yy-zz,                   2.0*(q[0]*q[1] - q[3]*q[2]), 2.0*(q[0]*q[2] + q[3]*q[1]), 0.0,
               2.0*(q[0]*q[1] + q[3]*q[2]),   ww-xx+yy-zz,                 2.0*(q[1]*q[2] - q[3]*q[0]), 0.0,
               2.0*(q[0]*q[2] - q[3]*q[1]),   2.0*(q[1]*q[2] + q[3]*q[0]), ww-xx-yy+zz,                 0.0,
               0.0,                           0.0,                         0.0,                         1.0 ];
}

function setPerspective( fovy, aspect, znear, zfar )
{
    var tan = Math.tan(fovy * Math.PI/180.0);
    var x = 1.0 / (tan*aspect);
    var y = 1.0 / (tan);
    var c = -(zfar + znear) / ( zfar - znear);
    var d = -(2.0 * zfar * znear) / (zfar - znear);

    return [ x,    0.0,  0.0,  0.0,
             0.0,  y,    0.0,  0.0,
             0.0,  0.0,  c,     d,
             0.0,  0.0, -1.0,  0.0 ];
}

function setLookAt( eye, tar, up )
{
    var dir = [ -tar[0]+eye[0], -tar[1]+eye[1], -tar[2]+eye[2] ];

	var m00 = dir[2]*up[1] - dir[1]*up[2]; 
    var m01 = dir[0]*up[2] - dir[2]*up[0];
    var m02 = dir[1]*up[0] - dir[0]*up[1];
    var im = 1.0/Math.sqrt( m00*m00 + m01*m01 + m02*m02 );
    m00 *= im;
    m01 *= im;
    m02 *= im;

	var m04 = m02*dir[1] - m01*dir[2]; 
    var m05 = m00*dir[2] - m02*dir[0];
    var m06 = m01*dir[0] - m00*dir[1];
    im = 1.0/Math.sqrt( m04*m04 + m05*m05 + m06*m06 );
    m04 *= im;
    m05 *= im;
    m06 *= im;

	var m08 = dir[0];
	var m09 = dir[1];
	var m10 = dir[2];
    im = 1.0/Math.sqrt( m08*m08 + m09*m09 + m10*m10 );
    m08 *= im;
    m09 *= im;
    m10 *= im;

	var m03 = -(m00*eye[0] + m01*eye[1] + m02*eye[2] );
	var m07 = -(m04*eye[0] + m05*eye[1] + m06*eye[2] );
	var m11 = -(m08*eye[0] + m09*eye[1] + m10*eye[2] );

    return [ m00, m01, m02, m03,
             m04, m05, m06, m07,
             m08, m09, m10, m11,
             0.0, 0.0, 0.0, 1.0 ];
}


function setOrtho( left, right, bottom, top, znear, zfar )
{
   var x = 2.0 / (right - left);
   var y = 2.0 / (top - bottom);
   var a = (right + left) / (right - left);
   var b = (top + bottom) / (top - bottom);
   var c = -2.0 / (zfar - znear);
   var d = -(zfar + znear) / ( zfar - znear);

   return [  x, 0.0, 0.0,   a,
           0.0,   y, 0.0,   b,
           0.0, 0.0,   c,   d,
           0.0, 0.0, 0.0, 1.0 ];
}

function setTranslation( p )
{
    return [ 1.0, 0.0, 0.0, p[0],
             0.0, 1.0, 0.0, p[1],
             0.0, 0.0, 1.0, p[2],
             0.0, 0.0, 0.0, 1.0 ];
}

function setScale( s )
{
    return [ s[0], 0.0,  0.0,  0.0,
             0.0,  s[1], 0.0,  0.0,
             0.0,  0.0,  s[2], 0.0,
             0.0,  0.0,  0.0,  1.0];
}

function setProjection( fov, znear, zfar )
{
    var x = 2.0 / (fov[3]+fov[2]);
    var y = 2.0 / (fov[0]+fov[1]);
    var a = (fov[3]-fov[2]) / (fov[3]+fov[2]);
    var b = (fov[0]-fov[1]) / (fov[0]+fov[1]);
    var c = -(zfar + znear) / ( zfar - znear);
    var d = -(2.0*zfar*znear) / (zfar - znear);
    return [   x, 0.0,    a, 0.0,
             0.0,   y,    b, 0.0,
             0.0, 0.0,    c,   d,
             0.0, 0.0, -1.0, 0.0 ];
   // inverse is:
   //return mat4x4( 1.0/x, 0.0f,  0.0f,   a/x,
   //               0.0f,  1.0/y, 0.0f,   b/x,
   //               0.0f,  0.0f,  0.0f,   -1.0,
   //               0.0f,  0.0f,  1.0f/d, c/d );
}


function invertFast( m )
{
    var inv = [
   
             m[5]  * m[10] * m[15] - 
             m[5]  * m[11] * m[14] - 
             m[9]  * m[6]  * m[15] + 
             m[9]  * m[7]  * m[14] +
             m[13] * m[6]  * m[11] - 
             m[13] * m[7]  * m[10],

             -m[1]  * m[10] * m[15] + 
              m[1]  * m[11] * m[14] + 
              m[9]  * m[2] * m[15] - 
              m[9]  * m[3] * m[14] - 
              m[13] * m[2] * m[11] + 
              m[13] * m[3] * m[10],

             m[1]  * m[6] * m[15] - 
             m[1]  * m[7] * m[14] - 
             m[5]  * m[2] * m[15] + 
             m[5]  * m[3] * m[14] + 
             m[13] * m[2] * m[7] - 
             m[13] * m[3] * m[6],

             -m[1] * m[6] * m[11] + 
              m[1] * m[7] * m[10] + 
              m[5] * m[2] * m[11] - 
              m[5] * m[3] * m[10] - 
              m[9] * m[2] * m[7] + 
              m[9] * m[3] * m[6],

             -m[4]  * m[10] * m[15] + 
              m[4]  * m[11] * m[14] + 
              m[8]  * m[6]  * m[15] - 
              m[8]  * m[7]  * m[14] - 
              m[12] * m[6]  * m[11] + 
              m[12] * m[7]  * m[10],

             m[0]  * m[10] * m[15] - 
             m[0]  * m[11] * m[14] - 
             m[8]  * m[2] * m[15] + 
             m[8]  * m[3] * m[14] + 
             m[12] * m[2] * m[11] - 
             m[12] * m[3] * m[10],

             -m[0]  * m[6] * m[15] + 
              m[0]  * m[7] * m[14] + 
              m[4]  * m[2] * m[15] - 
              m[4]  * m[3] * m[14] - 
              m[12] * m[2] * m[7] + 
              m[12] * m[3] * m[6],


             m[0] * m[6] * m[11] - 
             m[0] * m[7] * m[10] - 
             m[4] * m[2] * m[11] + 
             m[4] * m[3] * m[10] + 
             m[8] * m[2] * m[7] - 
             m[8] * m[3] * m[6],


             m[4]  * m[9] * m[15] - 
             m[4]  * m[11] * m[13] - 
             m[8]  * m[5] * m[15] + 
             m[8]  * m[7] * m[13] + 
             m[12] * m[5] * m[11] - 
             m[12] * m[7] * m[9],



             -m[0]  * m[9] * m[15] + 
              m[0]  * m[11] * m[13] + 
              m[8]  * m[1] * m[15] - 
              m[8]  * m[3] * m[13] - 
              m[12] * m[1] * m[11] + 
              m[12] * m[3] * m[9],

              m[0]  * m[5] * m[15] - 
              m[0]  * m[7] * m[13] - 
              m[4]  * m[1] * m[15] + 
              m[4]  * m[3] * m[13] + 
              m[12] * m[1] * m[7] - 
              m[12] * m[3] * m[5],

              -m[0] * m[5] * m[11] + 
               m[0] * m[7] * m[9] + 
               m[4] * m[1] * m[11] - 
               m[4] * m[3] * m[9] - 
               m[8] * m[1] * m[7] + 
               m[8] * m[3] * m[5],

              -m[4]  * m[9] * m[14] + 
               m[4]  * m[10] * m[13] +
               m[8]  * m[5] * m[14] - 
               m[8]  * m[6] * m[13] - 
               m[12] * m[5] * m[10] + 
               m[12] * m[6] * m[9],

              m[0]  * m[9] * m[14] - 
              m[0]  * m[10] * m[13] - 
              m[8]  * m[1] * m[14] + 
              m[8]  * m[2] * m[13] + 
              m[12] * m[1] * m[10] - 
              m[12] * m[2] * m[9],

              -m[0]  * m[5] * m[14] + 
               m[0]  * m[6] * m[13] + 
               m[4]  * m[1] * m[14] - 
               m[4]  * m[2] * m[13] - 
               m[12] * m[1] * m[6] + 
               m[12] * m[2] * m[5],

              m[0] * m[5] * m[10] - 
              m[0] * m[6] * m[9] - 
              m[4] * m[1] * m[10] + 
              m[4] * m[2] * m[9] + 
              m[8] * m[1] * m[6] - 
              m[8] * m[2] * m[5] ];

    var det = m[0] * inv[0] + m[1] * inv[4] + m[2] * inv[8] + m[3] * inv[12];

    det = 1.0/det;

    for( var i = 0; i<16; i++ ) inv[i] = inv[i] * det;

    return inv;
}

function matMul( a, b )
{
    var res = [];
    for( var i=0; i<4; i++ )
    {
        var x = a[4*i+0];
        var y = a[4*i+1];
        var z = a[4*i+2];
        var w = a[4*i+3];

        res[4*i+0] = x * b[ 0] + y * b[ 4] + z * b[ 8] + w * b[12];
        res[4*i+1] = x * b[ 1] + y * b[ 5] + z * b[ 9] + w * b[13];
        res[4*i+2] = x * b[ 2] + y * b[ 6] + z * b[10] + w * b[14];
        res[4*i+3] = x * b[ 3] + y * b[ 7] + z * b[11] + w * b[15];
    }

    return res;
}

function matMulpoint( m, v )
{
    return [ m[0]*v[0] + m[1]*v[1] + m[ 2]*v[2] + m[ 3],
             m[4]*v[0] + m[5]*v[1] + m[ 6]*v[2] + m[ 7],
             m[8]*v[0] + m[9]*v[1] + m[10]*v[2] + m[11] ];
}

function matMulvec( m, v )
{
    return [ m[0]*v[0] + m[1]*v[1] + m[ 2]*v[2],
             m[4]*v[0] + m[5]*v[1] + m[ 6]*v[2],
             m[8]*v[0] + m[9]*v[1] + m[10]*v[2] ];
}


function bound3( infi )
{
    return [ infi, -infi, infi, -infi, infi, -infi ];
}

function bound3_include( a, p )
{
    return [
        (p[0]<a[0]) ? p[0] : a[0],
        (p[0]>a[1]) ? p[0] : a[1],
        (p[1]<a[2]) ? p[1] : a[2],
        (p[1]>a[3]) ? p[1] : a[3],
        (p[2]<a[4]) ? p[2] : a[4],
        (p[2]>a[5]) ? p[2] : a[5] ];
}

function bound3_center( b )
{
    return [ 0.5*(b[0]+b[1]),
             0.5*(b[2]+b[3]),
             0.5*(b[4]+b[5]) ];
}

function bound3_radius( b )
{
    return [ 0.5*(b[1]-b[0]),
             0.5*(b[3]-b[2]),
             0.5*(b[5]-b[4]) ];
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piWebVR
//
//==============================================================================

function WebVR( isVREnabledCallback, canvasElement )
{
    isVREnabledCallback(false);
    /*


    this.mSupportVR = false;
    this.mHMD = null;

    var me = this;
    var listVRDisplays = function (vrdevs) {
        for (var i = 0; i < vrdevs.length; i++)
        {
            if (vrdevs[i] instanceof VRDisplay)
            {
                me.mHMD = vrdevs[i];
                console.log("WebVR is available.");
                console.log(me.mHMD);
                break;
            }
        }

        isVREnabledCallback(true);
        me.mSupportVR = true;
    }

    if (navigator.getVRDisplays)
    {
        navigator.getVRDisplays().then(listVRDisplays);
    }

    isVREnabledCallback(false);
    this.mCanvas = canvasElement;
    */
}

WebVR.prototype.IsSupported = function()
{
    return false;
    //return this.mSupportVR;
}

WebVR.prototype.GetData = function( id )
{
    return {};
    /*
    var frameData = new VRFrameData();
    var s = this.mHMD.getFrameData(frameData);
    var ss = frameData.pose;
    
    var fovL = this.mHMD.getEyeParameters("left");
    var fovR = this.mHMD.getEyeParameters( "right" );

    // camera info
    var cPos = vec3(0.0, 0.0, 0.0);
    if (ss.position)
        cPos = vec3(-ss.position[0], -ss.position[1], -ss.position[2]);
    var rot = vec4(0.0, 0.0, 0.0, 0.0);
    if (ss.orientation)
        rot = vec4(ss.orientation[0], ss.orientation[1], ss.orientation[2], ss.orientation[3]);
    var cRot = setFromQuaternion(rot);
    var cTra = setTranslation(cPos);
    var cMat = matMul(invertFast(cRot), cTra);
    
    // per eye info
    var lTra = setTranslation( vec3(-fovL.offset[0], -fovL.offset[1], -fovL.offset[2]) );
    var lMat = matMul(lTra, cMat);
    var lPrj = [ Math.tan( fovL.fieldOfView.upDegrees * Math.PI/180.0),
                 Math.tan(fovL.fieldOfView.downDegrees * Math.PI / 180.0),
                 Math.tan(fovL.fieldOfView.leftDegrees * Math.PI / 180.0),
                 Math.tan(fovL.fieldOfView.rightDegrees * Math.PI / 180.0)];

    var rTra = setTranslation(vec3(-fovR.offset[0], -fovR.offset[1], -fovR.offset[2]));
    var rMat = matMul(rTra, cMat);
    var rPrj = [Math.tan(fovR.fieldOfView.upDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.downDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.leftDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.rightDegrees * Math.PI / 180.0)];

    return {
        mCamera   : { mCamera: cMat },
        mLeftEye  : { mVP:[0,0,fovL.renderWidth,fovL.renderHeight], mProjection:lPrj, mCamera:lMat },
        mRightEye : { mVP:[fovR.renderWidth/2,0,fovR.renderWidth,fovR.renderHeight], mProjection:rPrj, mCamera:rMat }
           };
    */
}

WebVR.prototype.Enable = function( id )
{
    /*
    this.mHMD.requestPresent([{ source: this.mCanvas }]).then(
        function ()
        {
        },
        function (err)
        {
            console.log("webVR : requestPresent failed.");
        }
    );
    */
}

WebVR.prototype.Disable = function( id )
{
    /*
    if (!this.mHMD.isPresenting)
    {
        return;
    }

    this.mHMD.exitPresent().then(
        function ()
        {
        },
        function (err)
        {
            console.log("webVR : exitPresent failed.");
        }
    );
    */
}

WebVR.prototype.RequestAnimationFrame = function (id)
{
    //this.mHMD.requestAnimationFrame(id);
}

WebVR.prototype.IsPresenting = function (id)
{
    /*
    if (this.mHMD.isPresenting)
    {
        return true;
    }
    */
    return false;
}

WebVR.prototype.Finish = function (id)
{
    /*
    if (this.mHMD.isPresenting)
    {
        this.mHMD.submitFrame();
    }
    */
}

//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piWebUtils
//
//==============================================================================


// RequestAnimationFrame
window.requestAnimFrame = ( function () { return window.requestAnimationFrame    || window.webkitRequestAnimationFrame ||
                                                 window.mozRequestAnimationFrame || window.oRequestAnimationFrame ||
                                                 window.msRequestAnimationFrame  || function( cb ) { window.setTimeout(cb,1000/60); };
                                        } )();

// performance.now
window.getRealTime = ( function() { if ("performance" in window ) return function() { return window.performance.now(); }
                                                                  return function() { return (new Date()).getTime(); }
                                  } )();

window.URL = window.URL || window.webkitURL;

navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;

function htmlEntities(str) 
{
    return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g,'&apos;');
}

function piDisableTouch()
{
    document.body.addEventListener('touchstart', function(e){ e.preventDefault(); });
}

var piGetTime = function ( timestamp )
{
    if (timestamp == 0)
        return "";
    return new Date(timestamp * 1000).toISOString().substr(0, 10);
}

function piGetCoords( obj )
{
    var x = 0;
    var y = 0; 
    do
    {
         x += obj.offsetLeft;
         y += obj.offsetTop;
    }while( obj = obj.offsetParent );

    return { mX:x, mY:y };
}

function piGetMouseCoords( ev, canvasElement )
{
    var pos = piGetCoords(canvasElement );
    var mcx =                        (ev.pageX - pos.mX) * canvasElement.width / canvasElement.offsetWidth;
    var mcy = canvasElement.height - (ev.pageY - pos.mY) * canvasElement.height / canvasElement.offsetHeight;

    return { mX: mcx, mY: mcy };

}

function piGetSourceElement( e )
{
    var ele = null;
    if( e.target )     ele = e.target;
    if( e.srcElement ) ele = e.srcElement;
    return ele;
}

function piRequestFullScreen( ele )
{
    if( ele==null ) ele =   document.documentElement;
         if( ele.requestFullscreen       ) ele.requestFullscreen();
    else if( ele.msRequestFullscreen     ) ele.msRequestFullscreen();
    else if( ele.mozRequestFullScreen    ) ele.mozRequestFullScreen();
    else if( ele.webkitRequestFullscreen ) ele.webkitRequestFullscreen( Element.ALLOW_KEYBOARD_INPUT );
}

function piIsFullScreen()
{
    return document.fullscreen || document.mozFullScreen || document.webkitIsFullScreen || document.msFullscreenElement || false;
}

function piExitFullScreen()
{
       if( document.exitFullscreen       ) document.exitFullscreen();
  else if( document.msExitFullscreen     ) document.msExitFullscreen();
  else if( document.mozCancelFullScreen  ) document.mozCancelFullScreen();
  else if( document.webkitExitFullscreen ) document.webkitExitFullscreen();
}

function piIsMobile()
{
    return (navigator.userAgent.match(/Android/i) ||
            navigator.userAgent.match(/webOS/i) ||
            navigator.userAgent.match(/iPhone/i) ||
            navigator.userAgent.match(/iPad/i) ||
            navigator.userAgent.match(/iPod/i) ||
            navigator.userAgent.match(/BlackBerry/i) ||
            navigator.userAgent.match(/Windows Phone/i)) ? true : false;
}

function piCreateGlContext( cv, useAlpha, useDepth, usePreserveBuffer, useSupersampling )
{
    var opts = { alpha: useAlpha, 
                 depth: useDepth, 
                 stencil: false, 
                 premultipliedAlpha: false, 
                 antialias: useSupersampling, 
                 preserveDrawingBuffer: usePreserveBuffer, 
                 powerPreference: "high-performance" }; // "low_power", "high_performance", "default"

    var gl = null;
    if( gl === null) gl = cv.getContext( "webgl2", opts );
    if( gl === null) gl = cv.getContext( "experimental-webgl2", opts );
    if( gl === null) gl = cv.getContext( "webgl", opts );
    if( gl === null) gl = cv.getContext( "experimental-webgl", opts );

    return gl;
}

function piCreateAudioContext()
{
    var res = null;
    try
    {
        if( window.AudioContext ) res = new AudioContext();
        if( res==null && window.webkitAudioContext ) res = new webkitAudioContext();
    }
    catch( e )
    {
        res = null;
    }
    return res;
}

function piHexColorToRGB(str) // "#ff3041"
{
    var rgb = parseInt(str.slice(1), 16);
    var r = (rgb >> 16) & 255;
    var g = (rgb >> 8) & 255;
    var b = (rgb >> 0) & 255;
    return [r, g, b];
}

function piCreateFPSCounter()
{
    var mFrame;
    var mTo;
    var mFPS;

    var iReset = function( time )
    {
        mFrame = 0;
        mTo = time;
        mFPS = 60.0;
    }

    var iCount = function( time )
    {
        mFrame++;

        if( (time-mTo)>500.0 )
        {
            mFPS = 1000.0*mFrame/(time-mTo);
            mFrame = 0;
            mTo = time;
            return true;
        }
        return false;
    }

    var iGetFPS = function()
    {
        return mFPS;
    }
    
    return { Reset : iReset, Count : iCount, GetFPS : iGetFPS };
}

function piCanMediaRecorded(canvas)
{
    if (typeof window.MediaRecorder !== 'function' || typeof canvas.captureStream !== 'function') {
        return false;
    }
    return true;
}

function piCreateMediaRecorder(isRecordingCallback, canvas) 
{
    if (piCanMediaRecorded(canvas) == false)
    {
        return null;
    }
    
    var options = { audioBitsPerSecond : 0, videoBitsPerSecond : 8000000 }; 
	     if (MediaRecorder.isTypeSupported('video/webm;codecs=h264')) options.mimeType = 'video/webm;codecs=h264';
    else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9' )) options.mimeType = 'video/webm;codecs=vp9';
    else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8' )) options.mimeType = 'video/webm;codecs=vp8';
    else                                                              options.mimeType = 'video/webm;';

    var mediaRecorder = new MediaRecorder(canvas.captureStream(), options);
    var chunks = [];
    
    mediaRecorder.ondataavailable = function(e) 
    {
        if (e.data.size > 0) 
        {
            chunks.push(e.data);
        }
    };
 
    mediaRecorder.onstart = function(){ 
        isRecordingCallback( true );
    };
    
    mediaRecorder.onstop = function()
    {
         isRecordingCallback( false );
         let blob     = new Blob(chunks, {type: "video/webm"});
         chunks       = [];
         let videoURL = window.URL.createObjectURL(blob);
         let url      = window.URL.createObjectURL(blob);
         let a        = document.createElement("a");
         document.body.appendChild(a);
         a.style      = "display: none";
         a.href       = url;
         a.download   = "capture.webm";
         a.click();
         window.URL.revokeObjectURL(url);
     };
    
    return mediaRecorder;
}

function piExportToEXR(width, height, numComponents, type, bytes)
{
    var bytesPerComponent = 0;
    if      (type=="Uint")   bytesPerComponent = 4; 
    else if (type=="Half")   bytesPerComponent = 2;
    else if (type=="Float")  bytesPerComponent = 4;

    var tHeader = 258 + (18 * numComponents + 1);
    var tTable = 8 * height;
    var tScanlines = height * (4 + 4 + (numComponents * bytesPerComponent * width));
    var tTotal = tHeader + tTable + tScanlines;

    //console.log("    header size = " + tHeader);
    //console.log("    table size = " + tTable);
    //console.log("    scanlines size = " + tScanlines);
    //console.log("    total = " + tTotal);

    var buffer = new ArrayBuffer(tTotal); 
    var data = new DataView(buffer);

    // Header
    {
        // Header : 4 bytes -> 0x76, 0x2f, 0x31, 0x01
        var c = 0;
        data.setUint8 (c++, 0x76);
        data.setUint8 (c++, 0x2f);
        data.setUint8 (c++, 0x31);
        data.setUint8 (c++, 0x01);

        // Version : 4 bytes -> 2, 0, 0, 0
        data.setUint8 (c++, 0x02);
        data.setUint8 (c++, 0x0);
        data.setUint8 (c++, 0x0);
        data.setUint8 (c++, 0x0);
        
        // Write channel info
        // Write attribute name : "channels"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x73);
            data.setUint8 (c++, 0x0);

            // Write attribute type : "chlist"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00);

            // Write attribute size : 18 x 3 + 1 = 55
            var attribSize = 18 * numComponents + 1;
            data.setUint8 (c++, attribSize); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            var i;
            for (i = 0; i < numComponents; i++)
            {
                // Attribute : "B" (42) "G" (47) "R" (52)
                if (i==0)       data.setUint8 (c++, 0x42);
                else if (i==1)  data.setUint8 (c++, 0x47);
                else if (i==2)  data.setUint8 (c++, 0x52);
                data.setUint8 (c++, 0x00);
                
                // Value : Float (2), Half (1), Uint (0)
                if      (type=="Uint")   data.setUint8 (c++, 0x00); 
                else if (type=="Half")   data.setUint8 (c++, 0x01);
                else if (type=="Float")  data.setUint8 (c++, 0x02);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);

                // Plinear
                data.setUint8 (c++, 0x01);

                // Reserved
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 

                // X sampling
                data.setUint8 (c++, 0x01); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                
                // Y sampling
                data.setUint8 (c++, 0x01);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
            }
            // End attribute
            data.setUint8 (c++, 0x00);
    
        // Write attribute name : "compression"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6d); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x00);

            // Write attribute type : "compression"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6d); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x00);

            // Write attribute size : "1"
            data.setUint8 (c++, 0x01); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // Write attribute value : "0" (None)
            data.setUint8 (c++, 0x00);

        // datawindow
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x00); 

            // box2i
            data.setUint8 (c++, 0x62); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x00);

            // size 16
            data.setUint8 (c++, 0x10); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0 3 2
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 

            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint32 (c, width-1, true);
            c += 4;
            
            data.setUint32 (c, height-1, true); 
            c += 4;

        // displayWindow
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x79); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x00);

            // box2i
            data.setUint8 (c++, 0x62); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x00); 

            // size 16
            data.setUint8 (c++, 0x10); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0 3 2
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint32 (c, width-1, true);
            c += 4;
            
            data.setUint32 (c, height-1, true); 
            c += 4;

        // lineOrder
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x4f); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00); 
            
            // lineOrder
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x4f); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00); 
            
            // size
            data.setUint8 (c++, 0x01);
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);
            
            // value 
            data.setUint8 (c++, 0x00);

        // PixelAspectRatio
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x41); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x52); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x00); 

            // float
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00);
        
            // size 4
            data.setUint8 (c++, 0x04); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 1.0
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x80); 
            data.setUint8 (c++, 0x3f);
        
        // screenWindowCenter
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x63);
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x43); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e);
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00);

            // v2f
            data.setUint8 (c++, 0x76); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x00);

            // size 8
            data.setUint8 (c++, 0x08); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

        // screenWindowWidth
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x00); 
            
            // float
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00); 

            // size
            data.setUint8 (c++, 0x04); 
            data.setUint8 (c++, 0x00);
            data.setUint8 (c++, 0x00);
            data.setUint8 (c++, 0x00);

            // value
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x80); 
            data.setUint8 (c++, 0x3f);

        // End of header
        data.setUint8 (c++, 0x00);
    }
    //console.log("header size = " + c);

    // Scanline table
    var initc = c + height * 8;
    for (var scanline = 0 ; scanline < height ; scanline ++)
    {
        var jump = initc + scanline * (8 + width * bytesPerComponent * numComponents); 
        data.setUint32 (c, jump, true);
        c += 4; 

        data.setUint32 (c, 0x00, true);
        c += 4;
    }
    //console.log("header + scanlines table size = " + c);

    // Scanlines
    for (var scanline = 0 ; scanline < height ; scanline ++)
    {
        // Scanline
        data.setUint32(c, scanline, true);
        c += 4;

        // size 24
        var size = width * numComponents * bytesPerComponent; 
        data.setUint32(c, size, true);
        c += 4;

        var numComponentsSource = 4; // number of components in the SOURCE image
        for (var component = 0; component < numComponents ; component ++) 
        {
            for (var pixel = 0 ; pixel < width ; pixel ++) 
            {
                // flip vertical, so we read OpenGL buffers without JS image flipping
                var v = bytes[(height-1-scanline) * width *numComponentsSource + pixel * numComponentsSource + (2-component)];
                if      (type=="Float") data.setFloat32(c, v, true);
                else if (type=="Half")  data.setUint16(c, v, true);

                c += bytesPerComponent;
            }
        }
    }
    //console.log("total size = " + c);
    return new Blob([buffer], {type: 'application/octet-stream'});
}


function piExportToWAV(numSamples, rate, bits, numChannels, words)
{
    let numBytes = numSamples * numChannels * bits/8;

    let buffer = new ArrayBuffer(44 + numBytes); 
    let data = new DataView(buffer);

    {
        data.setUint32( 0, 0x46464952, true );  // RIFF
        data.setUint32( 4, numBytes + 36, true);
        {
            data.setUint32( 8, 0x45564157, true );  // WAV_WAVE
            data.setUint32( 12, 0x20746D66, true );  // WAV_FMT
            {
                data.setUint32( 16, 16, true);
                data.setUint16( 20, 1, true ); // WAV_FORMAT_PCM
                data.setUint16( 22, numChannels, true);
                data.setUint32( 24, rate, true);
                data.setUint32( 28, rate*numChannels*bits / 8, true);
                data.setUint16( 32, numChannels*bits / 8, true);
                data.setUint16( 34, bits, true);
            }

            data.setUint32( 36, 0x61746164, true);  // WAV_DATA
            {
                data.setUint32( 40, numBytes, true);
                let numWords = numSamples * numChannels;
                for(let i=0; i<numWords; i++ )
                {
                    data.setInt16( 44 + i*2, words[i], true );
                }
            }
        }
    }


    //console.log("total size = " + c);
    return new Blob([buffer], {type: 'application/octet-stream'});
}

function piTriggerDownload(name, blob)
{
    let url = URL.createObjectURL(blob);
    let aElement = document.createElement("a");
    aElement.href     = url;
    aElement.target   = "_self";
    aElement.download = name;
    document.body.appendChild(aElement);
    aElement.click();
    document.body.removeChild(aElement);
}</script>
    <script>"use strict"

function bufferID_to_assetID( id )
{
    if( id===0 ) return '4dXGR8';
    if( id===1 ) return 'XsXGR8';
    if( id===2 ) return '4sXGR8';
    if( id===3 ) return 'XdfGR8';
    return 'none';
}
function assetID_to_bufferID( id )
{
    if( id==='4dXGR8' ) return 0;
    if( id==='XsXGR8' ) return 1;
    if( id==='4sXGR8' ) return 2;
    if( id==='XdfGR8' ) return 3;
    return -1;
}

function assetID_to_cubemapBuferID( id )
{
    if( id==='4dX3Rr' ) return 0;
    return -1;
}
function cubamepBufferID_to_assetID( id )
{
    if( id===0 ) return '4dX3Rr';
    return 'none';
}

function EffectPass( renderer, is20, isLowEnd, hasShaderTextureLOD, callback, obj, forceMuted, forcePaused, outputGainNode, copyProgram, id, effect  )
{
    this.mID = id;
    this.mInputs  = [null, null, null, null ];
    this.mOutputs = [null, null, null, null ];
    this.mSource = null;

    this.mGainNode = outputGainNode;
    this.mSoundShaderCompiled = false;

    this.mEffect = effect;
    this.mRenderer = renderer;
    this.mProgramCopy = copyProgram; 
    this.mCompilationTime = 0;

    this.mType = "none";
    this.mName = "none";
    this.mFrame = 0;

    this.mShaderTextureLOD = hasShaderTextureLOD;
    this.mIs20 = is20;
    this.mIsLowEnd = isLowEnd;
    this.mTextureCallbackFun = callback;
    this.mTextureCallbackObj = obj;
    this.mForceMuted = forceMuted;
    this.mForcePaused = forcePaused;
}

EffectPass.prototype.MakeHeader_Image = function()
{
    let header = "";

    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for( let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        // old API
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                  header += "uniform sampler2D iChannel" + i + ";\n";

        // new API (see shadertoy.com/view/wtdGW8)
        header += "uniform struct {\n";
             if( inp===null )                  header += "  sampler2D";
        else if( inp.mInfo.mType==="cubemap" ) header += "  samplerCube";
        else if( inp.mInfo.mType==="volume"  ) header += "  sampler3D";
        else                                  header += "  sampler2D";
        header +=        " sampler;\n";
        header += "  vec3  size;\n";
        header += "  float time;\n";
        header += "  int   loaded;\n";
        header += "}iCh" + i + ";\n";
    }
	header += "void mainImage( out vec4 c, in vec2 f );\n";
    header += "void st_assert( bool cond );\n";
    header += "void st_assert( bool cond, int v );\n";

    if( this.mIs20 ) 
    {
        header += "\nout vec4 shadertoy_out_color;\n" +
        "void st_assert( bool cond, int v ) {if(!cond){if(v==0)shadertoy_out_color.x=-1.0;else if(v==1)shadertoy_out_color.y=-1.0;else if(v==2)shadertoy_out_color.z=-1.0;else shadertoy_out_color.w=-1.0;}}\n" +
        "void st_assert( bool cond        ) {if(!cond)shadertoy_out_color.x=-1.0;}\n" +
        "void main( void )" +
        "{" +
            "shadertoy_out_color = vec4(1.0,1.0,1.0,1.0);" + 
            "vec4 color = vec4(0.0,0.0,0.0,1.0);" +
            "mainImage( color, gl_FragCoord.xy );" +
            "if(shadertoy_out_color.x<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(shadertoy_out_color.y<0.0) color=vec4(0.0,1.0,0.0,1.0);" +
            "if(shadertoy_out_color.z<0.0) color=vec4(0.0,0.0,1.0,1.0);" +
            "if(shadertoy_out_color.w<0.0) color=vec4(1.0,1.0,0.0,1.0);" +
            "shadertoy_out_color = vec4(color.xyz,1.0);" +
        "}";
    }
    else
    {
        header += "" +
        "void st_assert( bool cond, int v ) {if(!cond){if(v==0)gl_FragColor.x=-1.0;else if(v==1)gl_FragColor.y=-1.0;else if(v==2)gl_FragColor.z=-1.0;else gl_FragColor.w=-1.0;}}\n" +
        "void st_assert( bool cond        ) {if(!cond)gl_FragColor.x=-1.0;}\n" +
        "void main( void )" +
        "{" +
            "gl_FragColor = vec4(0.0,0.0,0.0,1.0);" + 
            "vec4 color = vec4(0.0,0.0,0.0,1.0);" +
            "mainImage( color, gl_FragCoord.xy );" +
            "color.w = 1.0;" +
            "if(gl_FragColor.w<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(gl_FragColor.x<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(gl_FragColor.y<0.0) color=vec4(0.0,1.0,0.0,1.0);" +
            "if(gl_FragColor.z<0.0) color=vec4(0.0,0.0,1.0,1.0);" +
            "if(gl_FragColor.w<0.0) color=vec4(1.0,1.0,0.0,1.0);" +
            "gl_FragColor = vec4(color.xyz,1.0);"+
        "}";
    }
    header += "\n";

    /*
    this.mImagePassFooterVR = "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 ) 
        this.mImagePassFooterVR += "\nout vec4 outColor;\n";
    this.mImagePassFooterVR += "void main( void )" +
    "{" +
        "vec4 color = vec4(0.0,0.0,0.0,1.0);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainVR( color, gl_FragCoord.xy-unViewport.xy, ro, rd );" +
        "color.w = 1.0;"
    if( this.mIs20 ) 
        this.mImagePassFooterVR +=  "outColor = color;}";
    else
        this.mImagePassFooterVR +=  "gl_FragColor = color;}";
    */
    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Buffer = function()
{
    let header = "";
    
    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                  header += "uniform sampler2D iChannel" + i + ";\n";
    }

	header += "void mainImage( out vec4 c,  in vec2 f );\n"

    if( this.mIs20 )
        header += "\nout vec4 outColor;\n";
    header += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(0.0,0.0,0.0,1.0);" +
        "mainImage( color, gl_FragCoord.xy );";
    if( this.mIs20 )
        header +="outColor = color; }";
    else
        header +="gl_FragColor = color; }";
    header += "\n";

    /*
    this.mImagePassFooterVR = "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 )
    this.mImagePassFooterVR += "\nout vec4 outColor;\n";
    this.mImagePassFooterVR += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(0.0,0.0,0.0,1.0);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainVR( color, gl_FragCoord.xy-unViewport.xy, ro, rd );";
    if( this.mIs20 )
        this.mImagePassFooterVR +="outColor = color; }";
    else
        this.mImagePassFooterVR +="gl_FragColor = color; }";
    */
    this.mHeader = header;
    this.mHeaderLength = 0;
}


EffectPass.prototype.MakeHeader_Cubemap = function()
{
    let header = "";
    
    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                   header += "uniform sampler2D iChannel" + i + ";\n";
    }

	header += "void mainCubemap( out vec4 c, in vec2 f, in vec3 ro, in vec3 rd );\n"

    header += "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 )
        header += "\nout vec4 outColor;\n";
    header += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(0.0,0.0,0.0,1.0);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainCubemap( color, gl_FragCoord.xy-unViewport.xy, ro, rd );";
    if( this.mIs20 )
        header +="outColor = color; }";
    else
        header +="gl_FragColor = color; }";
    header += "\n";

    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Sound = function()
{
    let header = "";

    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform float     iChannelTime[4];\n" +
              "uniform float     iTimeOffset;\n" +
              "uniform int       iSampleOffset;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n";

    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp!==null && inp.mInfo.mType==="cubemap" )
            header += "uniform samplerCube iChannel" + i + ";\n";
        else
            header += "uniform sampler2D iChannel" + i + ";\n";
    }
    header += "\n";
    header += "vec2 mainSound( in int samp, float time );\n";

    if( this.mIs20 )
    {
        header += "out vec4 outColor; void main()" +
            "{" +
            "float t = iTimeOffset + ((gl_FragCoord.x-0.5) + (gl_FragCoord.y-0.5)*512.0)/iSampleRate;" +
            "int   s = iSampleOffset + int(gl_FragCoord.y-0.2)*512 + int(gl_FragCoord.x-0.2);" +
            "vec2 y = mainSound( s, t );" +
            "vec2 v  = floor((0.5+0.5*y)*65536.0);" +
            "vec2 vl =   mod(v,256.0)/255.0;" +
            "vec2 vh = floor(v/256.0)/255.0;" +
            "outColor = vec4(vl.x,vh.x,vl.y,vh.y);" +
            "}";
    }
    else
    {
        header += "void main()" +
            "{" +
            "float t = iTimeOffset + ((gl_FragCoord.x-0.5) + (gl_FragCoord.y-0.5)*512.0)/iSampleRate;" +
            "vec2 y = mainSound( 0, t );" +
            "vec2 v  = floor((0.5+0.5*y)*65536.0);" +
            "vec2 vl =   mod(v,256.0)/255.0;" +
            "vec2 vh = floor(v/256.0)/255.0;" +
            "gl_FragColor = vec4(vl.x,vh.x,vl.y,vh.y);" +
            "}";
    }
    header += "\n";
    this.mHeader = header;
    this.mHeaderLength = 0;
}


EffectPass.prototype.MakeHeader_Common = function ()
{
    let header = "";
    let headerlength = 0;

    header += "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n";
    headerlength += 2;

    if (this.mIs20)
    {
        header += "out vec4 outColor;\n";
        headerlength += 1;
    }
    header += "void main( void )\n";
    headerlength += 1;

    if (this.mIs20)
        header += "{ outColor = vec4(0.0); }";
    else
        header += "{ gl_FragColor = vec4(0.0); }";
    headerlength += 1;
    header += "\n";
    headerlength += 1;

    this.mHeader = header;
    this.mHeaderLength = headerlength;
}

EffectPass.prototype.MakeHeader = function()
{
         if( this.mType==="image" ) this.MakeHeader_Image();
    else if( this.mType==="sound" ) this.MakeHeader_Sound();
    else if( this.mType==="buffer") this.MakeHeader_Buffer();
    else if( this.mType==="common") this.MakeHeader_Common();
    else if( this.mType==="cubemap") this.MakeHeader_Cubemap();
    else console.log("ERROR 4");
}

EffectPass.prototype.Create_Image = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mSupportsVR = false;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    //this.mProgramVR = null;
}
EffectPass.prototype.Destroy_Image = function( wa )
{
}

EffectPass.prototype.Create_Buffer = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mSupportsVR = false;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    //this.mProgramVR = null;
}

EffectPass.prototype.Destroy_Buffer = function( wa )
{
}

EffectPass.prototype.Create_Cubemap = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
}

EffectPass.prototype.Destroy_Cubemap = function( wa )
{
}

EffectPass.prototype.Create_Common = function( wa )
{
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.MakeHeader();
}
EffectPass.prototype.Destroy_Common = function( wa )
{
}

EffectPass.prototype.Create_Sound = function (wa)
{
    this.MakeHeader();


    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    this.mSampleRate = 44100;
    this.mPlayTime = 60*3;
    this.mPlaySamples = this.mPlayTime*this.mSampleRate;
    this.mBuffer = wa.createBuffer( 2, this.mPlaySamples, this.mSampleRate );

    //-------------------
    this.mTextureDimensions = 512;
    this.mRenderTexture = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D, 
                                                       this.mTextureDimensions, this.mTextureDimensions,
                                                       this.mRenderer.TEXFMT.C4I8,
                                                       this.mRenderer.FILTER.NONE,
                                                       this.mRenderer.TEXWRP.CLAMP, null);
    this.mRenderFBO = this.mRenderer.CreateRenderTarget(this.mRenderTexture, null, null, null, null, false);

    //-----------------------------

    // ArrayBufferView pixels;
    this.mTmpBufferSamples = this.mTextureDimensions*this.mTextureDimensions;
    this.mData = new Uint8Array( this.mTmpBufferSamples*4 );

    this.mPlaying = false;
}

EffectPass.prototype.Destroy_Sound = function( wa )
{
    if( this.mPlayNode!==null ) this.mPlayNode.stop();
    this.mPlayNode = null;
    this.mBuffer = null;
    this.mData = null;

    this.mRenderer.DestroyRenderTarget(this.mRenderFBO);
    this.mRenderer.DestroyTexture(this.mRenderTexture);
}

EffectPass.prototype.Create = function( passType, wa )
{
    this.mType = passType;
    this.mSource = null;

         if( passType==="image" ) this.Create_Image( wa );
    else if( passType==="sound" ) this.Create_Sound( wa );
    else if( passType==="buffer") this.Create_Buffer( wa );
    else if( passType==="common") this.Create_Common( wa );
    else if( passType==="cubemap") this.Create_Cubemap( wa );
    else alert("ERROR 1");
}

EffectPass.prototype.SetName = function (passName)
{
    this.mName = passName;
}

EffectPass.prototype.SetCode = function (src)
{
    this.mSource = src;
}

EffectPass.prototype.Destroy = function( wa )
{
    this.mSource = null;
         if( this.mType==="image" ) this.Destroy_Image( wa );
    else if( this.mType==="sound" ) this.Destroy_Sound( wa );
    else if( this.mType==="buffer") this.Destroy_Buffer( wa );
    else if( this.mType==="common") this.Destroy_Common( wa );
    else if( this.mType==="cubemap") this.Destroy_Cubemap( wa );
    else alert("ERROR 2");
}

EffectPass.prototype.NewShader_Sound = function( shaderCode, commonShaderCodes)
{
    let vsSource = null;

    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for( let i=0; i<commonShaderCodes.length; i++ )
    {
        fsSource += commonShaderCodes[i]+'\n';
    }
    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;
    fsSource += shaderCode;

    this.mSoundShaderCompiled = false;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader_Image = function ( shaderCode, commonShaderCodes )
{
    this.mSupportsVR = false;


    let vsSource = null;
    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for (let i = 0; i < commonShaderCodes.length; i++)
    {
        fsSource += commonShaderCodes[i]+'\n';
    }
    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;
    fsSource += shaderCode;

    return [vsSource, fsSource];


    /*
    let n1 = shaderCode.indexOf("mainVR(");
    let n2 = shaderCode.indexOf("mainVR (");
    let n3 = shaderCode.indexOf("mainVR  (");
    if( n1>0 || n2>0 || n3>0 )
    {
        let vsSourceVR;
        if( this.mIs20 )
            vsSourceVR = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        else
            vsSourceVR = "attribute in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

        let fsSourceVR = this.mHeader;
        for (let i = 0; i < commonShaderCodes.length; i++) {
            fsSourceVR += commonShaderCodes[i];
        }
        fsSourceVR += shaderCode;
        fsSourceVR += this.mImagePassFooterVR;

        let res = this.mRenderer.CreateShader(vsSource, fsSourceVR, preventCache);
        if( res.mResult == false )
        {
            return res.mInfo;
        }
        if( this.mProgramVR != null )
            this.mRenderer.DestroyShader( this.mProgramVR );

        this.mSupportsVR = true;
        this.mProgramVR = res;
    }
    */
}

EffectPass.prototype.NewShader_Cubemap = function( shaderCode, commonShaderCodes )
{
    let vsSource = null;
    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for (let i = 0; i < commonShaderCodes.length; i++)
    {
        fsSource += commonShaderCodes[i]+'\n';
    }

    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;

    fsSource += shaderCode;

    return [vsSource, fsSource];
}


EffectPass.prototype.NewShader_Common = function (shaderCode )
{
    let vsSource = null;
    if (this.mIs20)
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader + shaderCode;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader = function ( commonSourceCodes, preventCache, onResolve)
{
    if( this.mRenderer===null ) return;

    let vs_fs = null;

         if( this.mType==="sound"  ) vs_fs = this.NewShader_Sound(   this.mSource, commonSourceCodes );
    else if( this.mType==="image"  ) vs_fs = this.NewShader_Image(   this.mSource, commonSourceCodes );
    else if( this.mType==="buffer" ) vs_fs = this.NewShader_Image(   this.mSource, commonSourceCodes );
    else if( this.mType==="common" ) vs_fs = this.NewShader_Common(  this.mSource,                   );
    else if( this.mType==="cubemap") vs_fs = this.NewShader_Cubemap( this.mSource, commonSourceCodes );
    else { console.log("ERROR 3: \"" + this.mType + "\""); return; }

    let me = this;
    this.mRenderer.CreateShader(vs_fs[0], vs_fs[1], preventCache, false,
        function (worked, info)
        {
            if (worked === true)
            {
                if (me.mType === "sound")
                {
                    me.mSoundShaderCompiled = true;
                }

                me.mCompilationTime = info.mTime;
                me.mError = false;
                me.mErrorStr = "No Errors";
                if (me.mProgram !== null)
                    me.mRenderer.DestroyShader(me.mProgram);
                me.mTranslatedSource = me.mRenderer.GetTranslatedShaderSource(info);
                me.mProgram = info;
            }
            else
            {
                me.mError = true;
                me.mErrorStr = info.mErrorStr;
            }
            onResolve();
        });
}

EffectPass.prototype.DestroyInput = function( id )
{
    if( this.mInputs[id]===null ) return;

    if( this.mInputs[id].mInfo.mType==="texture" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    if( this.mInputs[id].mInfo.mType==="volume" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="webcam" )
    {
        this.mInputs[id].video.pause();
        this.mInputs[id].video.src = "";

        if( this.mInputs[id].video.srcObject!==null )
        {
        let tracks = this.mInputs[id].video.srcObject.getVideoTracks();
        if( tracks ) tracks[0].stop();
        }
        this.mInputs[id].video = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="video" )
    {
        this.mInputs[id].video.pause();
        this.mInputs[id].video = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="music" || this.mInputs[id].mInfo.mType==="musicstream")
    {
        this.mInputs[id].audio.pause();
        this.mInputs[id].audio.mSound.mFreqData = null;
        this.mInputs[id].audio.mSound.mWaveData = null;
        this.mInputs[id].audio = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="cubemap" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="keyboard" )
    {
        //if( this.mInputs[id].globject != null )
          //  this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="mic" )
    {
        this.mInputs[id].mic = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }

    this.mInputs[id] = null;
}

EffectPass.prototype.TooglePauseInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused )
        {
            inp.video.play();
            inp.video.mPaused = false;
        }
        else
        {
            inp.video.pause();
            inp.video.mPaused = true;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        wa.resume()
        if( inp.audio.mPaused )
        {
            if( inp.loaded )
            {
                inp.audio.play();
            }
            inp.audio.mPaused = false;
        }
        else
        {
            inp.audio.pause();
            inp.audio.mPaused = true;
        }
        return inp.audio.mPaused;
    }

    return null;
}

EffectPass.prototype.StopInput = function( id )
{
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused === false )
        {
            inp.video.pause();
            inp.video.mPaused = true;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
    {
        if( inp.audio.mPaused === false )
        {
            inp.audio.pause();
            inp.audio.mPaused = true;
        }
        return inp.audio.mPaused;
    }
    return null;
}

EffectPass.prototype.ResumeInput = function( id )
{
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused )
        {
            inp.video.play();
            inp.video.mPaused = false;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
    {
        if( inp.audio.mPaused )
        {
            inp.audio.play();
            inp.audio.mPaused = false;
        }
        return inp.audio.mPaused;
    }
    return null;
}

EffectPass.prototype.RewindInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];

    if( inp==null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.loaded )
        {
            inp.video.currentTime = 0;
        }
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        wa.resume()
        if( inp.loaded )
        {
            inp.audio.currentTime = 0;
        }
    }
}

EffectPass.prototype.MuteInput = function( wa, id )
{
    let inp = this.mInputs[id];
    if( inp===null ) return;

    if( inp.mInfo.mType==="video" )
    {
        inp.video.muted = true;
        inp.video.mMuted = true;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if (wa !== null) inp.audio.mSound.mGain.gain.value = 0.0;
        inp.audio.mMuted = true;
    }
}

EffectPass.prototype.UnMuteInput = function( wa, id )
{
    let inp = this.mInputs[id];
    if( inp===null ) return;

    if( inp.mInfo.mType==="video" )
    {
        inp.video.muted = false;
        inp.video.mMuted = false;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if (wa !== null) inp.audio.mSound.mGain.gain.value = 1.0;
        inp.audio.mMuted = false;
    }
}

EffectPass.prototype.ToggleMuteInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];
    if( inp===null ) return null;

    if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mMuted ) this.UnMuteInput(wa,id);
        else                   this.MuteInput(wa,id);
        return inp.video.mMuted;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if( inp.audio.mMuted ) this.UnMuteInput(wa,id);
        else                   this.MuteInput(wa,id);
        return inp.audio.mMuted;
    }

    return null;
}

EffectPass.prototype.UpdateInputs = function( wa, forceUpdate, keyboard )
{
   for (let i=0; i<this.mInputs.length; i++ )
   {
        let inp = this.mInputs[i];

        if( inp===null )
        {
            if( forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, null, false, 0, 0, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.image, true, 1, 1, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mPreview, true, 1, 1, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
            if( inp.loaded && forceUpdate )
            {
                if( this.mTextureCallbackFun!==null )
                {
                    let img = (assetID_to_cubemapBuferID(inp.mInfo.mID)===-1) ? inp.image[0] : inp.mImage;
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, img, true, 2, 1, -1.0, this.mID );
                }
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:keyboard.mIcon,mData:keyboard.mData}, false, 6, 0, -1.0, this.mID );
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, -1, this.mID );
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
              if( inp.loaded && inp.audio.mPaused === false && inp.audio.mForceMuted === false )
              {
                  if( wa !== null )
                  {
                      inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                      inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                  }

                  if (this.mTextureCallbackFun!==null)
                  {
                           if (inp.mInfo.mType === "music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:(wa==null)?null:inp.audio.mSound.mFreqData}, false, 4, 1, inp.audio.currentTime, this.mID);
                      else if (inp.mInfo.mType === "musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:(wa==null)?null:inp.audio.mSound.mFreqData, info: inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                  }
              }
              else if( inp.loaded===false )
              {
                  if (this.mTextureCallbackFun!==null)
                      this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:null}, false, 4, 0, -1.0, this.mID);
              }
        }
        else if( inp.mInfo.mType==="mic" )
        {
              if( inp.loaded && inp.mForceMuted === false )
              {
                  if( wa !== null )
                  {
                      inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                      inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
                  }
                  if( this.mTextureCallbackFun!==null )
                      this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave: ((wa==null)?null:inp.mFreqData) }, false, 5, 1, 0, this.mID );
              }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:null}, true, 9, 1, -1.0, this.mID );
            }
        }
    }
}

EffectPass.prototype.Sampler2Renderer = function (sampler)
{
    let filter = this.mRenderer.FILTER.NONE;
    if (sampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
    if (sampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
    let wrap = this.mRenderer.TEXWRP.REPEAT;
    if (sampler.wrap === "clamp") wrap = this.mRenderer.TEXWRP.CLAMP;
    let vflip = false;
    if (sampler.vflip === "true") vflip = true;

    return { mFilter: filter, mWrap: wrap, mVFlip: vflip };
}

EffectPass.prototype.GetSamplerVFlip = function (id)
{
    let inp = this.mInputs[id];
    return inp.mInfo.mSampler.vflip;
}

EffectPass.prototype.GetTranslatedShaderSource = function ()
{
    return this.mTranslatedSource;
}


EffectPass.prototype.SetSamplerVFlip = function (id, str) 
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let filter = false;
    if (str === "true") filter = true;

    if (inp === null)
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
    }
    else if (inp.mInfo.mType === "video")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "webcam")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, null);
            inp.mInfo.mSampler.vflip = str;
        }
    }
}

EffectPass.prototype.GetAcceptsVFlip = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return false;
    if (inp.mInfo.mType === "video")  return true;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return true;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return false;
    return true;
}

EffectPass.prototype.GetSamplerFilter = function (id)
{
    let inp = this.mInputs[id];
    if( inp===null) return;
    return inp.mInfo.mSampler.filter;
}

EffectPass.prototype.SetSamplerFilter = function (id, str, buffers, cubeBuffers) 
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let filter = renderer.FILTER.NONE;
    if (str === "linear") filter = renderer.FILTER.LINEAR;
    if (str === "mipmap") filter = renderer.FILTER.MIPMAP;

    if (inp === null)
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "video")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap")
    {
        if (inp.loaded) 
        {
            if( assetID_to_cubemapBuferID(inp.mInfo.mID)===0)
            {
                renderer.SetSamplerFilter(cubeBuffers[0].mTexture[0], filter, true);
                renderer.SetSamplerFilter(cubeBuffers[0].mTexture[1], filter, true);
                inp.mInfo.mSampler.filter = str;
            }
            else
            {
                renderer.SetSamplerFilter(inp.globject, filter, true);
                inp.mInfo.mSampler.filter = str;
            }
        }
    }
    else if (inp.mInfo.mType === "webcam")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "buffer")
    {
        renderer.SetSamplerFilter(buffers[inp.id].mTexture[0], filter, true);
        renderer.SetSamplerFilter(buffers[inp.id].mTexture[1], filter, true);
        inp.mInfo.mSampler.filter = str;
    }
    else if (inp.mInfo.mType === "keyboard")
    {
        inp.mInfo.mSampler.filter = str;
    }
}



EffectPass.prototype.GetAcceptsMipmapping = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return this.mIs20;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return this.mIs20;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return this.mIs20;
    return false;
}

EffectPass.prototype.GetAcceptsLinear = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return true;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return true;
    if (inp.mInfo.mType === "music")  return true;
    if (inp.mInfo.mType === "musicstream") return true;
    if (inp.mInfo.mType === "mic")  return true;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return true;
    return false;
}


EffectPass.prototype.GetAcceptsWrapRepeat = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return this.mIs20;
    if (inp.mInfo.mType === "cubemap") return false;
    if (inp.mInfo.mType === "webcam")  return this.mIs20;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return this.mIs20;
    return false;
}

EffectPass.prototype.GetSamplerWrap = function (id)
{
    let inp = this.mInputs[id];
    return inp.mInfo.mSampler.wrap;
}
EffectPass.prototype.SetSamplerWrap = function (id, str, buffers)
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let restr = renderer.TEXWRP.REPEAT;
    if (str === "clamp") restr = renderer.TEXWRP.CLAMP;

    if (inp === null) 
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "video") 
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap") 
    {
        if (inp.loaded)
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "webcam") 
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "buffer")
    {
        renderer.SetSamplerWrap(buffers[inp.id].mTexture[0], restr);
        renderer.SetSamplerWrap(buffers[inp.id].mTexture[1], restr);
        inp.mInfo.mSampler.wrap = str;
    }
}


EffectPass.prototype.GetTexture = function( slot )
{
    let inp = this.mInputs[slot];
    if( inp===null ) return null;
    return inp.mInfo;

}

EffectPass.prototype.SetOutputs = function( slot, id )
{
    this.mOutputs[slot] = id;
}

EffectPass.prototype.SetOutputsByBufferID = function( slot, id )
{
    if( this.mType==="buffer" )
    {
        this.mOutputs[slot] = bufferID_to_assetID( id );

        this.mEffect.ResizeBuffer( id, this.mEffect.mXres, this.mEffect.mYres, false );
    }
    else if( this.mType==="cubemap" )
    {
        this.mOutputs[slot] = cubamepBufferID_to_assetID( id );
        this.mEffect.ResizeCubemapBuffer(id, 1024, 1024 );
    }
}

EffectPass.prototype.NewTexture = function( wa, slot, url, buffers, cubeBuffers, keyboard )
{
    var me = this;
    var renderer = this.mRenderer;

    if( renderer===null ) return;

    let texture = null;

    if( url===null || url.mType===null )
    {
        if( me.mTextureCallbackFun!==null )
            me.mTextureCallbackFun( this.mTextureCallbackObj, slot, null, true, 0, 0, -1.0, me.mID );
        me.DestroyInput( slot );
        me.mInputs[slot] = null;
        me.MakeHeader();
        return { mFailed:false, mNeedsShaderCompile:false };
    }
    else if( url.mType==="texture" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.image = new Image();
        texture.image.crossOrigin = '';
        texture.image.onload = function()
        {
            let rti = me.Sampler2Renderer(url.mSampler);

            // O.M.G. FIX THIS
            let channels = renderer.TEXFMT.C4I8;
            if (url.mID === "Xdf3zn" || url.mID === "4sf3Rn" || url.mID === "4dXGzn" || url.mID === "4sf3Rr")
                channels = renderer.TEXFMT.C1I8;
            
            texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.image, channels, rti.mFilter, rti.mWrap, rti.mVFlip);

            texture.loaded = true;
            if( me.mTextureCallbackFun!==null )
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.image, true, 1, 1, -1.0, me.mID );
        }
        texture.image.src = url.mSrc;


        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="volume" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.mImage = { mData:null, mXres:1, mYres:0, mZres:0 };
        texture.mPreview = new Image();
        texture.mPreview.crossOrigin = '';

	    var xmlHttp = new XMLHttpRequest();
        if( xmlHttp===null ) return { mFailed:true };

        xmlHttp.open('GET', url.mSrc, true);
        xmlHttp.responseType = "arraybuffer";
        xmlHttp.onerror = function()
        {
            console.log( "Error 1 loading Volume" );
        }
        xmlHttp.onload = function()
        {
            let data = xmlHttp.response;
            if (!data ) { console.log( "Error 2 loading Volume" ); return; }

            let file = piFile(data);

            let signature = file.ReadUInt32();
            texture.mImage.mXres = file.ReadUInt32();
            texture.mImage.mYres = file.ReadUInt32();
            texture.mImage.mZres = file.ReadUInt32();
            let binNumChannels = file.ReadUInt8();
            let binLayout = file.ReadUInt8();
            let binFormat = file.ReadUInt16();
            let format = renderer.TEXFMT.C1I8;
                 if( binNumChannels===1 && binFormat===0 )  format = renderer.TEXFMT.C1I8;
            else if( binNumChannels===2 && binFormat===0 )  format = renderer.TEXFMT.C2I8;
            else if( binNumChannels===3 && binFormat===0 )  format = renderer.TEXFMT.C3I8;
            else if( binNumChannels===4 && binFormat===0 )  format = renderer.TEXFMT.C4I8;
            else if( binNumChannels===1 && binFormat===10 ) format = renderer.TEXFMT.C1F32;
            else if( binNumChannels===2 && binFormat===10 ) format = renderer.TEXFMT.C2F32;
            else if( binNumChannels===3 && binFormat===10 ) format = renderer.TEXFMT.C3F32;
            else if( binNumChannels===4 && binFormat===10 ) format = renderer.TEXFMT.C4F32;
            else return;

            let buffer = new Uint8Array(data, 20); // skip 16 bytes (header of .bin)

            let rti = me.Sampler2Renderer(url.mSampler);

            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T3D, texture.mImage.mXres, texture.mImage.mYres, format, rti.mFilter, rti.mWrap, buffer);

            if( texture.globject===null )
            {
                console.log( "Error 4: loading Volume" ); 
                return { mFailed:true };
            }

            if (me.mTextureCallbackFun !== null)
            {
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mPreview, true, 1, 1, -1.0, me.mID );
            }

            texture.loaded = true;

            // load icon for it
            texture.mPreview.onload = function()
            {
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mPreview, true, 1, 1, -1.0, me.mID );
            }
            texture.mPreview.src = url.mPreviewSrc;
        }
        xmlHttp.send("");


        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]==null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="volume")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="cubemap" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;

        let rti = me.Sampler2Renderer(url.mSampler);

        if( assetID_to_cubemapBuferID(url.mID)!==-1 )
        {
            texture.mImage = new Image();
            texture.mImage.onload = function()
            {
                texture.loaded = true;
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mImage, true, 2, 1, -1.0, me.mID );
            }
            texture.mImage.src = "/media/previz/cubemap00.png";

            this.mEffect.ResizeCubemapBuffer(0, 1024, 1024 );

        }
        else
        {
            texture.image = [ new Image(), new Image(), new Image(), new Image(), new Image(), new Image() ];

            let numLoaded = 0;
            for (var i=0; i<6; i++ )
            {
                texture.image[i].mId = i;
                texture.image[i].crossOrigin = '';
                texture.image[i].onload = function()
                {
                    var id = this.mId;
                    numLoaded++;
                    if( numLoaded===6 )
                    {
                        texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.CUBEMAP, texture.image, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                        texture.loaded = true;
                        if (me.mTextureCallbackFun !== null)
                            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, texture.image[0], true, 2, 1, -1.0, me.mID);
                    }
                }

                if( i === 0) 
                {
                    texture.image[i].src = url.mSrc;
                } 
                else 
                {
                    let n = url.mSrc.lastIndexOf(".");
                    texture.image[i].src = url.mSrc.substring(0, n) + "_" + i + url.mSrc.substring(n, url.mSrc.length);
                }
            }
        }

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]==null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="cubemap")) };

        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="webcam" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;

        texture.video = document.createElement('video');
    	texture.video.width = 320;
    	texture.video.height = 240;
    	texture.video.autoplay = true;
    	texture.video.loop = true;
        texture.mForceMuted = this.mForceMuted;
        texture.mImage = null;

        let rti = me.Sampler2Renderer(url.mSampler);

        var loadImageInsteadOfWebCam = function()
        {
            texture.mImage = new Image();
            texture.mImage.onload = function()
            {
                texture.loaded = true;
                texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.mImage, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mImage, true, 7, 1, -1.0, me.mID );
            }
            texture.mImage.src = "/media/previz/webcam.png";
        }
        
        loadImageInsteadOfWebCam();

        if( typeof navigator.getUserMedia !== "undefined"  && texture.mForceMuted===false )
        {
            texture.video.addEventListener("canplay", function (e)
            {
				try
				{
                    texture.mImage = null;
                    if( texture.globject != null )
                        renderer.DestroyTexture( texture.globject );
					texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.video, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
					texture.loaded = true;
                }
                catch(e)
                {
                    loadImageInsteadOfWebCam();
	                alert( 'Your browser can not transfer webcam data to the GPU.');
                }
            } );

            navigator.mediaDevices.getUserMedia( 
                                { "video": { width: 1280, height: 720 }, "audio": false } )
                                .then( function(stream)
                                       {
                                            texture.video.srcObject = stream;
    	                               } )
                                .catch( function(error)
                                        {
                                            loadImageInsteadOfWebCam();
    		                                alert( 'Unable to capture WebCam. Please reload the page.' );
    	                                } );
        }
        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]==null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!="music") && 
                                                                (this.mInputs[slot].mInfo.mType!="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="mic" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.mForceMuted = this.mForceMuted;
        texture.mAnalyser = null;
        let num = 512;
        texture.mFreqData = new Uint8Array( num );
        texture.mWaveData = new Uint8Array( num );

        if( wa === null || typeof navigator.getUserMedia === "undefined" )
        {
            if( !texture.mForceMuted ) alert( "Shadertoy: Web Audio not implement in this browser" );
            texture.mForceMuted = true; 
        }

        if( texture.mForceMuted )
        {
            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, num, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null)
            texture.loaded = true;
        }
        else
        {
        navigator.getUserMedia( { "audio": true },
                                function(stream)
                                {
                                  texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, null)
                                  texture.mic = wa.createMediaStreamSource(stream);
                                  texture.mAnalyser = wa.createAnalyser();
                                  texture.mic.connect( texture.mAnalyser );
                                  texture.loaded = true;
    	                        },
                                function(error)
                                {
    		                        alert( 'Unable open Mic. Please reload the page.' );
    	                        } );
        }
        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="video" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.video = document.createElement('video');
    	texture.video.loop = true;
        texture.video.preload = "auto";
        texture.video.mPaused = this.mForcePaused;
        texture.video.mMuted = true;//this.mForceMuted;
    	texture.video.muted  = true;//this.mForceMuted;
        if( this.mForceMuted===true )
            texture.video.volume = 0;
    	texture.video.autoplay = false;
        texture.video.hasFalled = false;
        
        let rti = me.Sampler2Renderer(url.mSampler);

        texture.video.addEventListener("canplay", function (e)
        {
            texture.video.play().then( function()
                                       {
                                           texture.video.mPaused = false;

                                           texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.video, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                                           texture.loaded = true;
            
                                           if( me.mTextureCallbackFun!=null )
                                               me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.video, true, 3, 1, -1.0, me.mID );
                                        } )
                               .catch( function(error)
                                       {
                                           console.log( error );
                                       }
                                );
        } );

        texture.video.addEventListener( "error", function(e)
        {
               if( texture.video.hasFalled===true ) { alert("Error: cannot load video" ); return; }
               let str = texture.video.src;
               str = str.substr(0,str.lastIndexOf('.') ) + ".mp4";
               texture.video.src = str;
               texture.video.hasFalled = true;
        } );

        texture.video.src = url.mSrc;

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]==null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!="music") && 
                                                                (this.mInputs[slot].mInfo.mType!="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="music" || url.mType==="musicstream" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.audio = document.createElement('audio');
    	texture.audio.loop = true;
        texture.audio.mMuted = this.mForceMuted;
        texture.audio.mForceMuted = this.mForceMuted;
        texture.audio.muted = this.mForceMuted;
        if( this.mForceMuted===true )
            texture.audio.volume = 0;
        texture.audio.autoplay = false;
        texture.audio.hasFalled = false;
        texture.audio.mPaused = false;
        texture.audio.mSound = {};

        if( this.mForceMuted===false )
        {
            if(url.mType==="musicstream" && SC === null)
            {
                alert( "Shadertoy: Soundcloud could not be reached" );
                texture.audio.mForceMuted = true;
            }
            }

        if( wa === null && this.mForceMuted===false )
        {
            alert( "Shadertoy: Web Audio not implement in this browser" );
            texture.audio.mForceMuted = true;
        }

        if( texture.audio.mForceMuted )
        {
            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null);
            let num = 512;
            texture.audio.mSound.mFreqData = new Uint8Array( num );
            texture.audio.mSound.mWaveData = new Uint8Array( num );
            texture.loaded = true;
        }

        texture.audio.addEventListener( "canplay", function()
        {
            if( texture===null || texture.audio===null ) return;
            if( this.mForceMuted  ) return;
            if( texture.loaded === true ) return;

            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null)

            texture.audio.mSound.mSource   = wa.createMediaElementSource( texture.audio );
            texture.audio.mSound.mAnalyser = wa.createAnalyser();
            texture.audio.mSound.mGain     = wa.createGain();

            texture.audio.mSound.mSource.connect(   texture.audio.mSound.mAnalyser );
            texture.audio.mSound.mAnalyser.connect( texture.audio.mSound.mGain );
            texture.audio.mSound.mGain.connect(me.mGainNode);

            texture.audio.mSound.mFreqData = new Uint8Array( texture.audio.mSound.mAnalyser.frequencyBinCount );
            texture.audio.mSound.mWaveData = new Uint8Array( texture.audio.mSound.mAnalyser.frequencyBinCount );

            if( texture.audio.mPaused )
            {
                texture.audio.pause();
            }
            else
            {
                texture.audio.play().then( function() {/*console.log("ok");*/} ).catch( function(e){console.log("error " + e);} );
            }
            texture.loaded = true;
        } );

        texture.audio.addEventListener( "error", function(e)
        {
               if( this.mForceMuted  ) return;

               if( texture.audio.hasFalled===true ) { return; }
               let str = texture.audio.src;
               str = str.substr(0,str.lastIndexOf('.') ) + ".ogg";
               texture.audio.src = str;
               texture.audio.hasFalled = true;
        } );

        if( !texture.audio.mForceMuted )
        {
            if(url.mType==="musicstream")
            {
                SC.resolve(url.mSrc, 
                    function(song) 
                    {
                        if( song.streamable===true )
                        {
                            texture.audio.crossOrigin = 'anonymous';
                            texture.audio.src = song.stream_url;
                            texture.audio.soundcloudInfo = song;
                        }
                        else
                        {
                            alert('Shadertoy: Soundcloud 3 - This track cannot be streamed' );
                        }
                    },
                    function(error)
                    {
                        if (me.mTextureCallbackFun!==null)
                        {
                            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null}, false, 4, 0, -1.0, me.mID);
                        }
                    } );
            } 
            else
            {
                texture.audio.src = url.mSrc;
            }
        }

        if (me.mTextureCallbackFun!==null)
        {
            if (url.mType === "music")            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null}, false, 4, 0, -1.0, me.mID);
            else if (url.mType === "musicstream") me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null, info: texture.audio.soundcloudInfo}, false, 8, 0, -1.0, me.mID);
        }

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="keyboard" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = true;

        texture.keyboard = {};

        if( me.mTextureCallbackFun!==null )
            me.mTextureCallbackFun( me.mTextureCallbackObj, slot, {mImage: keyboard.mIcon, mData: keyboard.mData}, false, 6, 1, -1.0, me.mID );

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!="music") && 
                                                                (this.mInputs[slot].mInfo.mType!="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="buffer" )
    {
        texture = {};
        texture.mInfo = url;

        texture.image = new Image();
        texture.image.onload = function()
        {
            if( me.mTextureCallbackFun!=null )
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, {texture: texture.image, data:null}, true, 9, 1, -1.0, me.mID );
        }
        texture.image.src = url.mSrc;
        texture.id = assetID_to_bufferID( url.mID );
        texture.loaded = true;

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!="music") && 
                                                                (this.mInputs[slot].mInfo.mType!="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!="video")) };

        this.DestroyInput( slot );
        this.mInputs[slot] = texture;

        this.mEffect.ResizeBuffer(texture.id, this.mEffect.mXres, this.mEffect.mYres, false );

        this.SetSamplerFilter(slot, url.mSampler.filter, buffers, cubeBuffers, true);
        this.SetSamplerVFlip(slot, url.mSampler.vflip);
        this.SetSamplerWrap(slot, url.mSampler.wrap, buffers);

        this.MakeHeader();
        return returnValue;
    }
    else
    {
        alert( "input type error" );
        return { mFailed: true };
    }

    return { mFailed: true };
}

EffectPass.prototype.Paint_Image = function( vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    let times = [ 0.0, 0.0, 0.0, 0.0 ];

    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds()  + d.getMilliseconds()/1000.0 ];

    let mouse = [  mousePosX, mousePosY, mouseOriX, mouseOriY ];


    //------------------------
    
    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];
    let texIsLoaded = [0, 0, 0, 0 ];
    let texID = [ null, null, null, null];

    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            texID[i] = keyboard.mTexture;
            texIsLoaded[i] = 1;
            resos[3*i+0] = 256;
            resos[3*i+1] = 3;
            resos[3*i+2] = 1;
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
            if (inp.loaded === true)
            {
                let id = assetID_to_cubemapBuferID(inp.mInfo.mID);
                if( id!==-1 )
                {
                    texID[i] = cubeBuffers[id].mTexture[ cubeBuffers[id].mLastRenderDone ];
                    resos[3*i+0] = cubeBuffers[id].mResolution[0];
                    resos[3*i+1] = cubeBuffers[id].mResolution[1];
                    resos[3*i+2] = 1;
                    texIsLoaded[i] = 1;

                    // hack. in webgl2.0 we have samplers, so we don't need this crap here
                    let filter = this.mRenderer.FILTER.NONE;
                         if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                    else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                    this.mRenderer.SetSamplerFilter( texID[i], filter, false);
                }
                else
                {
                    texID[i] = inp.globject;
                    texIsLoaded[i] = 1;
                }
            }
        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mImage, false, 7, 1, -1, this.mID );

                    texID[i] = inp.globject;
                    texIsLoaded[i] = 1;
                    resos[3*i+0] = inp.mImage.width;
                    resos[3*i+1] = inp.mImage.height;
                    resos[3*i+2] = 1;
                }
                else  if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {

                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 7, 1, -1, this.mID );

                    texID[i] = inp.globject;
                    this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                    resos[3*i+0] = inp.video.videoWidth;
                    resos[3*i+1] = inp.video.videoHeight;
                    resos[3*i+2] = 1;
                    texIsLoaded[i] = 1;
                }
            }
            else 
            {
                texID[i] = null;
                texIsLoaded[i] = 0;
                resos[3*i+0] = inp.video.width;
                resos[3*i+1] = inp.video.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.mPaused === false )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, inp.video.currentTime, this.mID );
            }

            if( inp.loaded===true )
            { 
                times[i] = inp.video.currentTime;
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;

      	        if( inp.video.mPaused === false )
      	        {
      	            this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
                resos[3*i+0] = inp.video.videoWidth;
                resos[3*i+1] = inp.video.videoHeight;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.audio.mPaused === false && inp.audio.mForceMuted === false && inp.loaded===true )
            {
                if( wa !== null )
                {
                    inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                    inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                }

                if( this.mTextureCallbackFun!==null )
                {
                         if( inp.mInfo.mType==="music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa === null) ? null : { wave : inp.audio.mSound.mFreqData }, false, 4, 1, inp.audio.currentTime, this.mID);
                    else if( inp.mInfo.mType==="musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa === null) ? null : { wave : inp.audio.mSound.mFreqData, info : inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                }
            }

            if( inp.loaded===true )
            {
                times[i] = inp.audio.currentTime;
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;

                if( inp.audio.mForceMuted === true )
                {
                    times[i] = 10.0 + time;
                    let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.audio.mSound.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                  //let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.audio.mSound.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }

                }

      	        if( inp.audio.mPaused === false )
                {
      	            let waveLen = Math.min(inp.audio.mSound.mWaveData.length, 512);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512, 1, inp.audio.mSound.mFreqData);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 1, 512, 1, inp.audio.mSound.mWaveData);
                }

                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                    times[i] = 10.0 + time;
                    let num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                    //var num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }
            }
            else
            {
                inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
            }

            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave:inp.mFreqData}, false, 5, 1, -1, this.mID );

            if( inp.loaded===true )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                let waveLen = Math.min( inp.mWaveData.length, 512 );
                this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512,     1, inp.mFreqData);
                this.mRenderer.UpdateTexture(inp.globject, 0, 1, waveLen, 1, inp.mWaveData);
                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            let id = inp.id;
            if( inp.loaded===true  )
            {
                texID[i] = buffers[id].mTexture[ buffers[id].mLastRenderDone ];
                texIsLoaded[i] = 1;
                resos[3*i+0] = xres;
                resos[3*i+1] = yres;
                resos[3*i+2] = 1;
                // hack. in webgl2.0 we have samplers, so we don't need this crap here
                let filter = this.mRenderer.FILTER.NONE;
                     if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                this.mRenderer.SetSamplerFilter( texID[i], filter, false);
            }

            if( this.mTextureCallbackFun!==null )
            {
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:buffers[id].mThumbnailBuffer}, false, 9, 1, -1, this.mID );
            }
        }
    }

    this.mRenderer.AttachTextures( 4, texID[0], texID[1], texID[2], texID[3] );

    //-----------------------------------

    let prog = this.mProgram;

    //if( vrData!=null && this.mSupportsVR ) prog = this.mProgramVR;



    this.mRenderer.AttachShader(prog);

    this.mRenderer.SetShaderConstant1F(  "iTime", time);
    this.mRenderer.SetShaderConstant3F(  "iResolution", xres, yres, 1.0);
    this.mRenderer.SetShaderConstant4FV( "iMouse", mouse);
    this.mRenderer.SetShaderConstant1FV( "iChannelTime", times );              // OBSOLETE
    this.mRenderer.SetShaderConstant4FV( "iDate", dates );
    this.mRenderer.SetShaderConstant3FV( "iChannelResolution", resos );        // OBSOLETE
    this.mRenderer.SetShaderConstant1F(  "iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit( "iChannel0", 0 );
    this.mRenderer.SetShaderTextureUnit( "iChannel1", 1 );
    this.mRenderer.SetShaderTextureUnit( "iChannel2", 2 );
    this.mRenderer.SetShaderTextureUnit( "iChannel3", 3 );
    this.mRenderer.SetShaderConstant1I(  "iFrame", this.mFrame );
    this.mRenderer.SetShaderConstant1F(  "iTimeDelta", dtime);
    this.mRenderer.SetShaderConstant1F(  "iFrameRate", fps );

    this.mRenderer.SetShaderConstant1F(  "iCh0.time", times[0] );
    this.mRenderer.SetShaderConstant1F(  "iCh1.time", times[1] );
    this.mRenderer.SetShaderConstant1F(  "iCh2.time", times[2] );
    this.mRenderer.SetShaderConstant1F(  "iCh3.time", times[3] );
    this.mRenderer.SetShaderConstant3F(  "iCh0.size", resos[0], resos[ 1], resos[ 2] );
    this.mRenderer.SetShaderConstant3F(  "iCh1.size", resos[3], resos[ 4], resos[ 5] );
    this.mRenderer.SetShaderConstant3F(  "iCh2.size", resos[6], resos[ 7], resos[ 8] );
    this.mRenderer.SetShaderConstant3F(  "iCh3.size", resos[9], resos[10], resos[11] );
    this.mRenderer.SetShaderConstant1I(  "iCh0.loaded",       texIsLoaded[0] );
    this.mRenderer.SetShaderConstant1I(  "iCh1.loaded",       texIsLoaded[1] );
    this.mRenderer.SetShaderConstant1I(  "iCh2.loaded",       texIsLoaded[2] );
    this.mRenderer.SetShaderConstant1I(  "iCh3.loaded",       texIsLoaded[3] );

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");


    if( (vrData !== null) && this.mSupportsVR )
    {
        for (let i=0; i<2; i++ )
        {
            let ei = (i===0) ? vrData.mLeftEye : vrData.mRightEye;

            let vp = [i * xres / 2, 0, xres / 2, yres];

            this.mRenderer.SetViewport(vp);

            let fov = ei.mProjection;
            let corA = [ -fov[2], -fov[1], -1.0 ];
            let corB = [  fov[3], -fov[1], -1.0 ];
            let corC = [  fov[3],  fov[0], -1.0 ];
            let corD = [ -fov[2],  fov[0], -1.0 ];
            let apex = [ 0.0, 0.0, 0.0 ];

            let ma = invertFast( ei.mCamera );
            corA = matMulpoint( ma, corA ); 
            corB = matMulpoint( ma, corB ); 
            corC = matMulpoint( ma, corC ); 
            corD = matMulpoint( ma, corD ); 
            apex = matMulpoint( ma, apex ); 

            let corners = [ corA[0], corA[1], corA[2], 
                            corB[0], corB[1], corB[2], 
                            corC[0], corC[1], corC[2], 
                            corD[0], corD[1], corD[2],
                            apex[0], apex[1], apex[2]];

            this.mRenderer.SetShaderConstant3FV("unCorners", corners);
            this.mRenderer.SetShaderConstant4FV("unViewport", vp);

            this.mRenderer.DrawUnitQuad_XY(l1);
        }
    }
    else 
    {
        this.mRenderer.SetViewport([0, 0, xres, yres]);
        this.mRenderer.DrawFullScreenTriangle_XY( l1 );
    }

    this.mRenderer.DettachTextures();
}

EffectPass.prototype.iRenderSound = function(d, callback )
{
    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds() ];

    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];

    this.mRenderer.SetRenderTarget(this.mRenderFBO);

    this.mRenderer.SetViewport([0, 0, this.mTextureDimensions, this.mTextureDimensions]);
    this.mRenderer.AttachShader(this.mProgram);
    this.mRenderer.SetBlend( false );

    let texID = [null, null, null, null];
    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
    }

    this.mRenderer.AttachTextures(4, texID[0], texID[1], texID[2], texID[3]);

    let l2 = this.mRenderer.SetShaderConstantLocation(this.mProgram, "iTimeOffset");
    let l3 = this.mRenderer.SetShaderConstantLocation(this.mProgram, "iSampleOffset");
    this.mRenderer.SetShaderConstant4FV("iDate", dates);
    this.mRenderer.SetShaderConstant3FV("iChannelResolution", resos);
    this.mRenderer.SetShaderConstant1F("iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit("iChannel0", 0);
    this.mRenderer.SetShaderTextureUnit("iChannel1", 1);
    this.mRenderer.SetShaderTextureUnit("iChannel2", 2);
    this.mRenderer.SetShaderTextureUnit("iChannel3", 3);

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    //--------------------------------
    let numSamples = this.mTmpBufferSamples;
    let numBlocks = this.mPlaySamples / numSamples;
    for (let j=0; j<numBlocks; j++ )
    {
        let off = j*numSamples;
        
        this.mRenderer.SetShaderConstant1F_Pos(l2, off / this.mSampleRate);
        this.mRenderer.SetShaderConstant1I_Pos(l3, off );
        this.mRenderer.DrawUnitQuad_XY(l1);

        this.mRenderer.GetPixelData(this.mData, 0, this.mTextureDimensions, this.mTextureDimensions);

        callback( off, this.mData, numSamples );
    }

    this.mRenderer.DetachShader();
    this.mRenderer.DettachTextures();
    this.mRenderer.SetRenderTarget(null);
}

EffectPass.prototype.Paint_Sound = function( wa, d )
{
    let bufL = this.mBuffer.getChannelData(0); // Float32Array
    let bufR = this.mBuffer.getChannelData(1); // Float32Array

    this.iRenderSound( d, function(off, data, numSamples)
                         {
                            for( let i=0; i<numSamples; i++ )
                            {
                                bufL[off+i] = -1.0 + 2.0*(data[4*i+0]+256.0*data[4*i+1])/65535.0;
                                bufR[off+i] = -1.0 + 2.0*(data[4*i+2]+256.0*data[4*i+3])/65535.0;
                            }
                         }
                     );
}

EffectPass.prototype.SetUniforms = function(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    let times = [ 0.0, 0.0, 0.0, 0.0 ];

    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds()  + d.getMilliseconds()/1000.0 ];

    let mouse = [  mousePosX, mousePosY, mouseOriX, mouseOriY ];

    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];

    //------------------------
    
    let texID = [ null, null, null, null];

    for( let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            texID[i] = keyboard.mTexture;
        }
        else if( inp.mInfo.mType=="cubemap" )
        {
            if (inp.loaded === true)
            {
                let id = assetID_to_cubemapBuferID(inp.mInfo.mID);
                if( id!==-1 )
                {
                    texID[i] = cubeBuffers[id].mTexture[ cubeBuffers[id].mLastRenderDone ];
                    resos[3*i+0] = cubeBuffers[id].mResolution[0];
                    resos[3*i+1] = cubeBuffers[id].mResolution[1];
                    resos[3*i+2] = 1;
    
                    // hack. in webgl2.0 we have samplers, so we don't need this crap here
                    let filter = this.mRenderer.FILTER.NONE;
                         if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                    else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                    this.mRenderer.SetSamplerFilter( texID[i], filter, false);
                }
                else
                {
                    texID[i] = inp.globject;
                }
            }

        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    texID[i] = inp.globject;
                    resos[3*i+0] = inp.mImage.width;
                    resos[3*i+1] = inp.mImage.height;
                    resos[3*i+2] = 1;
                }
                else  if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {
                    texID[i] = inp.globject;
                    resos[3*i+0] = inp.video.videoWidth;
                    resos[3*i+1] = inp.video.videoHeight;
                    resos[3*i+2] = 1;
                }
            }
            else 
            {
                texID[i] = null;
                resos[3*i+0] = inp.video.width;
                resos[3*i+1] = inp.video.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
           if( inp.loaded===true )
           { 
                times[i] = inp.video.currentTime;
                texID[i] = inp.globject;
                resos[3*i+0] = inp.video.videoWidth;
                resos[3*i+1] = inp.video.videoHeight;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.loaded===true )
            {
                times[i] = inp.audio.currentTime;
                texID[i] = inp.globject;

                if( inp.audio.mForceMuted === true )
                {
                    times[i] = 10.0 + time;
                }

                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                times[i] = 10.0 + time;
            }

            if( inp.loaded===true )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = buffers[inp.id].mTexture[ buffers[inp.id].mLastRenderDone ];
                resos[3*i+0] = buffers[inp.id].mResolution[0];
                resos[3*i+1] = buffers[inp.id].mResolution[1];
                resos[3*i+2] = 1;
            }
        }
    }

    this.mRenderer.AttachTextures( 4, texID[0], texID[1], texID[2], texID[3] );

    //-----------------------------------

    this.mRenderer.AttachShader(this.mProgram);

    this.mRenderer.SetShaderConstant1F(  "iTime", time);
    this.mRenderer.SetShaderConstant3F(  "iResolution", xres, yres, 1.0);
    this.mRenderer.SetShaderConstant4FV( "iMouse", mouse);
    this.mRenderer.SetShaderConstant1FV( "iChannelTime", times );              // OBSOLETE
    this.mRenderer.SetShaderConstant4FV( "iDate", dates );
    this.mRenderer.SetShaderConstant3FV( "iChannelResolution", resos );        // OBSOLETE
    this.mRenderer.SetShaderConstant1F(  "iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit( "iChannel0", 0 );
    this.mRenderer.SetShaderTextureUnit( "iChannel1", 1 );
    this.mRenderer.SetShaderTextureUnit( "iChannel2", 2 );
    this.mRenderer.SetShaderTextureUnit( "iChannel3", 3 );
    this.mRenderer.SetShaderConstant1I(  "iFrame", this.mFrame );
    this.mRenderer.SetShaderConstant1F(  "iTimeDelta", dtime);
    this.mRenderer.SetShaderConstant1F(  "iFrameRate", fps );

    this.mRenderer.SetShaderConstant1F(  "iChannel[0].time",       times[0] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[1].time",       times[1] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[2].time",       times[2] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[3].time",       times[3] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[0].resolution", resos[0], resos[ 1], resos[ 2] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[1].resolution", resos[3], resos[ 4], resos[ 5] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[2].resolution", resos[6], resos[ 7], resos[ 8] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[3].resolution", resos[9], resos[10], resos[11] );
}

EffectPass.prototype.ProcessInputs = function(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
        }
        else if( inp.mInfo.mType==="volume" )
        {
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mImage, false, 7, 1, -1, this.mID );
                }
                else if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 7, 1, -1, this.mID );

                    this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.mPaused === false )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, inp.video.currentTime, this.mID );
            }

            if( inp.loaded===true )
            { 
      	        if( inp.video.mPaused === false )
      	        {
      	            this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.audio.mPaused === false && inp.audio.mForceMuted === false && inp.loaded===true )
            {
                if( wa !== null )
                {
                    inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                    inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                }

                if( this.mTextureCallbackFun!==null )
                {
                         if( inp.mInfo.mType==="music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa == null) ? null : { wave : inp.audio.mSound.mFreqData }, false, 4, 1, inp.audio.currentTime, this.mID);
                    else if( inp.mInfo.mType==="musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa == null) ? null : { wave : inp.audio.mSound.mFreqData, info : inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                }
            }

            if( inp.loaded===true )
            {
                if( inp.audio.mForceMuted === true )
                {
                    let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.audio.mSound.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                  //let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.audio.mSound.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }

                }

      	        if( inp.audio.mPaused === false )
                {
      	            let waveLen = Math.min(inp.audio.mSound.mWaveData.length, 512);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512, 1, inp.audio.mSound.mFreqData);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 1, 512, 1, inp.audio.mSound.mWaveData);
                }
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                    let num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                    for( let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }
            }
            else
            {
                inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
            }

            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave:inp.mFreqData}, false, 5, 1, -1, this.mID );

            if( inp.loaded===true )
            {
                let waveLen = Math.min( inp.mWaveData.length, 512 );
                this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512,     1, inp.mFreqData);
                this.mRenderer.UpdateTexture(inp.globject, 0, 1, waveLen, 1, inp.mWaveData);
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded===true  )
            {
                let id = inp.id;
                let texID = buffers[id].mTexture[ buffers[id].mLastRenderDone ];

                // hack. in webgl2.0 we have samplers, so we don't need this crap here
                let filter = this.mRenderer.FILTER.NONE;
                     if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                this.mRenderer.SetSamplerFilter( texID, filter, false);
            }

            if( this.mTextureCallbackFun!==null )
            {
				let id = inp.id;
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:buffers[id].mThumbnailBuffer}, false, 9, 1, -1, this.mID );
            }
        }
    }
}

EffectPass.prototype.Paint_Cubemap = function( vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face )
{
    this.ProcessInputs(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face );
    this.SetUniforms(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    let vp = [0, 0, xres, yres];

    this.mRenderer.SetViewport(vp);

    let corA = [ -1.0, -1.0, -1.0 ];
    let corB = [  1.0, -1.0, -1.0 ];
    let corC = [  1.0,  1.0, -1.0 ];
    let corD = [ -1.0,  1.0, -1.0 ];
    let apex = [  0.0,  0.0,  0.0 ];

    if( face===0 )
    {
        corA = [  1.0,  1.0,  1.0 ];
        corB = [  1.0,  1.0, -1.0 ];
        corC = [  1.0, -1.0, -1.0 ];
        corD = [  1.0, -1.0,  1.0 ];
    }
    else if( face===1 ) // -X
    {
        corA = [ -1.0,  1.0, -1.0 ];
        corB = [ -1.0,  1.0,  1.0 ];
        corC = [ -1.0, -1.0,  1.0 ];
        corD = [ -1.0, -1.0, -1.0 ];
    }
    else if( face===2 ) // +Y
    {
        corA = [ -1.0,  1.0, -1.0 ];
        corB = [  1.0,  1.0, -1.0 ];
        corC = [  1.0,  1.0,  1.0 ];
        corD = [ -1.0,  1.0,  1.0 ];
    }
    else if( face===3 ) // -Y
    {
        corA = [ -1.0, -1.0,  1.0 ];
        corB = [  1.0, -1.0,  1.0 ];
        corC = [  1.0, -1.0, -1.0 ];
        corD = [ -1.0, -1.0, -1.0 ];
    }
    else if( face===4 ) // +Z
    {
        corA = [ -1.0,  1.0,  1.0 ];
        corB = [  1.0,  1.0,  1.0 ];
        corC = [  1.0, -1.0,  1.0 ];
        corD = [ -1.0, -1.0,  1.0 ];
    }
    else //if( face===5 ) // -Z
    {
        corA = [  1.0,  1.0, -1.0 ];
        corB = [ -1.0,  1.0, -1.0 ];
        corC = [ -1.0, -1.0, -1.0 ];
        corD = [  1.0, -1.0, -1.0 ];
    }

    let corners = [ corA[0], corA[1], corA[2], 
                    corB[0], corB[1], corB[2], 
                    corC[0], corC[1], corC[2], 
                    corD[0], corD[1], corD[2],
                    apex[0], apex[1], apex[2]];

    this.mRenderer.SetShaderConstant3FV("unCorners", corners);
    this.mRenderer.SetShaderConstant4FV("unViewport", vp);

    this.mRenderer.DrawUnitQuad_XY(l1);

    this.mRenderer.DettachTextures();
}


EffectPass.prototype.Paint = function( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, bufferNeedsMimaps, buffers, cubeBuffers, keyboard, effect )
{
    if( this.mType==="sound" )
    {
        if (this.mSoundShaderCompiled === true)
        {
            // make sure all textures are loaded
            for (let i=0; i<this.mInputs.length; i++ )
            {
                let inp = this.mInputs[i];
                if (inp === null) continue;

                if (inp.mInfo.mType === "texture" && !inp.loaded) return;
                if (inp.mInfo.mType === "cubemap" && !inp.loaded) return;
            }

            this.Paint_Sound(wa, da);
            this.mSoundShaderCompiled = false;
        }
        if (this.mFrame === 0)
        {
            if (this.mPlaying===true)
            {
                this.mPlayNode.disconnect();
                this.mPlayNode.stop();
                this.mPlayNode = null;
            }
            this.mPlaying = true;

            this.mPlayNode = wa.createBufferSource();
            this.mPlayNode.buffer = this.mBuffer;
            this.mPlayNode.connect(this.mGainNode);
            this.mPlayNode.start(0);
        }
        this.mFrame++;
    }
    else if( this.mType==="image" )
    {
        this.mRenderer.SetRenderTarget( null );
        this.Paint_Image( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );
        this.mFrame++;
    }
    else if( this.mType==="common" )
    {
        //console.log("rendering common");
    }
    else if( this.mType==="buffer" )
    {
        this.mEffect.ResizeBuffer(bufferID, this.mEffect.mXres, this.mEffect.mYres, false );

        let buffer = buffers[bufferID];

        let dstID = 1 - buffer.mLastRenderDone;

        this.mRenderer.SetRenderTarget( buffer.mTarget[dstID] );
        this.Paint_Image( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );

        // compute mipmaps if needd
        if( bufferNeedsMimaps )
        {
            this.mRenderer.CreateMipmaps( buffer.mTexture[dstID]);
        }

        // make thumbnail
        //if( this.mTextureCallbackFun != null )
        /*
        {
            this.mRenderer.SetRenderTarget( buffer.mThumbnailRenderTarget );
            let v = [0, 0, buffer.mThumbnailRes[0], buffer.mThumbnailRes[1]];
            this.mRenderer.SetBlend(false);
            this.mRenderer.SetViewport(v);
            this.mRenderer.AttachShader(this.mProgramCopy);
            let l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, "pos");
            this.mRenderer.SetShaderConstant4FV("v", v);
            this.mRenderer.AttachTextures(1, buffer.mTexture[dstID], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);
            this.mRenderer.DettachTextures();
            this.mRenderer.DetachShader();
            this.mRenderer.GetPixelData( new Uint8Array(buffer.mThumbnailBuffer.data.buffer), buffer.mThumbnailRes[0], buffer.mThumbnailRes[1] );
            this.mRenderer.SetRenderTarget(null);
        }
        */
        buffers[bufferID].mLastRenderDone = 1 - buffers[bufferID].mLastRenderDone;
        this.mFrame++;
    }
    else if( this.mType==="cubemap" )
    {
        this.mEffect.ResizeCubemapBuffer(bufferID, 1024, 1024, false );

        let buffer = cubeBuffers[bufferID];

        xres = buffer.mResolution[0];
        yres = buffer.mResolution[1];
        let dstID = 1 - buffer.mLastRenderDone;
        for( let face=0; face<6; face++ )
        {
            this.mRenderer.SetRenderTargetCubeMap( buffer.mTarget[dstID], face );
            this.Paint_Cubemap( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face );
        }
        this.mRenderer.SetRenderTargetCubeMap( null, 0 );

        // compute mipmaps if needd
        if( bufferNeedsMimaps )
        {
            this.mRenderer.CreateMipmaps( buffer.mTexture[dstID]);
        }
        cubeBuffers[bufferID].mLastRenderDone = 1 - cubeBuffers[bufferID].mLastRenderDone;

        this.mFrame++;
    }

}

EffectPass.prototype.StopOutput_Sound = function( wa )
{
    if( this.mPlayNode===null ) return;
    this.mPlayNode.disconnect();

};

EffectPass.prototype.ResumeOutput_Sound = function( wa )
{
    if( this.mPlayNode===null ) return;

    wa.resume()
    this.mPlayNode.connect( this.mGainNode );
};

EffectPass.prototype.StopOutput_Image = function( wa )
{
};

EffectPass.prototype.ResumeOutput_Image = function( wa )
{
};

EffectPass.prototype.StopOutput = function( wa )
{
    for (let j=0; j<this.mInputs.length; j++ )
        this.StopInput(j);

    if( this.mType==="sound" )
         this.StopOutput_Sound( wa );
    else
         this.StopOutput_Image( wa );
}

EffectPass.prototype.ResumeOutput = function( wa )
{
    for (let j=0; j<this.mInputs.length; j++ )
        this.ResumeInput(j);

    if( this.mType==="sound" )
         this.ResumeOutput_Sound( wa );
    else
         this.ResumeOutput_Image( wa );
}

EffectPass.prototype.GetCompilationTime = function()
{
    return this.mCompilationTime;
}

//============================================================================================================
function Screenshots()
{
    // private
    let mTexture = null;
    let mTarget = null;
    let mXres = 0;
    let mYres = 0;
    let mCubemapToEquirectProgram;
    let mRenderer = null;

    // public
    var me = {};

    me.Initialize = function(renderer)
    {
        mRenderer = renderer;
        let caps = mRenderer.GetCaps();
        let is20 = caps.mIsGL20;


        let vsSourceC, fsSourceC;
        if( is20 )
        {
            vsSourceC = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
            fsSourceC = "uniform samplerCube t; out vec4 outColor; void main() { vec2 px = gl_FragCoord.xy/vec2(4096.0,2048.0); vec2 an = 3.1415926535898 * (px*vec2(2.0, 1.0) - vec2(0.0,0.5)); vec3 rd = vec3(-cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x)); outColor = texture(t, rd); }";
        }
        else
        {
            vsSourceC = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
            fsSourceC = "uniform samplerCube t; void main() { vec2 px = gl_FragCoord.xy/vec2(4096.0,2048.0); vec2 an = 3.1415926535898 * (px*vec2(2.0, 1.0) - vec2(0.0,0.5)); vec3 rd = vec3(-cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x)); gl_FragColor = texture(t, rd); }";
        }

        let compileShader = function (worked, info)
        {
            if (worked === false)
            {
                console.log("Failed to compile cubemap resample shader (" + errorType + "): " + log);
            }
            else
            {
                mCubemapToEquirectProgram = info;
            }
        }
        mRenderer.CreateShader(vsSourceC, fsSourceC, false, true, compileShader);

        return true;
    };

    me.Allocate = function( xres, yres )
    {
        if( xres>mXres || yres>mYres )
        {
            let texture = mRenderer.CreateTexture(mRenderer.TEXTYPE.T2D, xres, yres, mRenderer.TEXFMT.C4F32, mRenderer.FILTER.NONE, mRenderer.TEXWRP.CLAMP, null);
            let target = mRenderer.CreateRenderTarget( texture, null, null, null, null, false);

            if( mXres!==0 )
            {
                mRenderer.DestroyTexture(mTexture);
                mRenderer.DestroyRenderTarget(mTarget);
            }

            mTexture = texture;
            mTarget = target;
            mXres = xres;
            mYres = yres;
        }
    };

    me.GetProgram = function()
    {
        return mCubemapToEquirectProgram;
    };
    me.GetTarget = function()
    {
        return mTarget;
    };

    return me;
};

//============================================================================================================

function Effect(vr, ac, canvas, callback, obj, forceMuted, forcePaused, resizeCallback, crashCallback )
{
    let xres = canvas.width;
    let yres = canvas.height;

    let me = this;
    this.mCanvas = canvas;
    this.mCreated = false;
    this.mRenderer = null;
    this.mAudioContext = ac;
    this.mGLContext = null;
    this.mWebVR = vr;
    this.mRenderingStereo = false;
    this.mXres = xres;
    this.mYres = yres;
    this.mForceMuted = forceMuted;
    if( ac===null ) this.mForceMuted = true;
    this.mForcePaused = forcePaused;
    this.mGainNode = null;
    this.mPasses = [];
    this.mFrame = 0;
    this.mTextureCallbackFun = callback;
    this.mTextureCallbackObj = obj;
    this.mMaxBuffers = 4;
    this.mMaxCubeBuffers = 1;
    this.mMaxPasses = this.mMaxBuffers + 1 + 1 + 1 + 1; // some day decouple passes from buffers (4 buffers + common + Imagen + sound + cubemap)
    this.mBuffers = [];
    this.mCubeBuffers = [];
    this.mScreenshotSytem = null;
    this.mCompilationTime = 0;
    this.mIsLowEnd = piIsMobile();

    this.mGLContext = piCreateGlContext(canvas, false, false, true, false); // need preserve-buffe to true in order to capture screenshots
    if (this.mGLContext === null)
    {
        return;
    }

    canvas.addEventListener("webglcontextlost", function (event)
        {
            event.preventDefault();
            crashCallback();
        }, false);

    this.mRenderer = piRenderer();
    if (!this.mRenderer.Initialize(this.mGLContext))
        return;

    this.mScreenshotSytem = Screenshots();
    if (!this.mScreenshotSytem.Initialize(this.mRenderer))
        return;

    var caps = this.mRenderer.GetCaps();
    this.mIs20 = caps.mIsGL20;
    this.mShaderTextureLOD = caps.mShaderTextureLOD;
    //-------------
    if( ac!==null )
    {   
        this.mGainNode = ac.createGain();
        if( !forceMuted )
        {
            this.mGainNode.connect( ac.destination);
        }
        if (this.mForceMuted )
            this.mGainNode.gain.value = 0.0;
        else
            this.mGainNode.gain.value = 1.0;
    }

    //-------------
    let vsSourceC, fsSourceC;
    if( this.mIs20 )
    {
        vsSourceC = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceC = "uniform vec4 v; uniform sampler2D t; out vec4 outColor; void main() { outColor = textureLod(t, gl_FragCoord.xy / v.zw, 0.0); }";
    }
    else
    {
        vsSourceC = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceC = "uniform vec4 v; uniform sampler2D t; void main() { gl_FragColor = texture2D(t, gl_FragCoord.xy / v.zw, -100.0); }";
    }

    this.mRenderer.CreateShader(vsSourceC, fsSourceC, false, true, function(worked, info)
        {
            if (worked === false) console.log("Failed to compile shader to copy buffers : " + info.mErrorStr);
            else me.mProgramCopy = info;
        });

    let vsSourceD, fsSourceD;
    if( this.mIs20 )
    {
        vsSourceD = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceD = "uniform vec4 v; uniform sampler2D t; out vec4 outColor; void main() { vec2 uv = gl_FragCoord.xy / v.zw; outColor = texture(t, vec2(uv.x,1.0-uv.y)); }";
    }
    else
    {
        vsSourceD = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceD = "uniform vec4 v; uniform sampler2D t; void main() { vec2 uv = gl_FragCoord.xy / v.zw; gl_FragColor = texture2D(t, vec2(uv.x,1.0-uv.y)); }";
    }

    this.mRenderer.CreateShader(vsSourceD, fsSourceD, false, true, function (worked, info)
        {
            if (worked === false) console.log("Failed to compile shader to downscale buffers : " + info.mErrorStr);
            else me.mProgramDownscale = info;
        });


    // set all buffers and cubemaps to null
    for( let i=0; i<this.mMaxBuffers; i++ )
    {
        this.mBuffers[i] = { mTexture: [null, null], 
                             mTarget:  [null, null], 
                             mResolution: [0, 0],
                             mLastRenderDone: 0,
                             mThumbnailRenderTarget: null,
                             mThumbnailTexture: null,
                             mThumbnailBuffer:  null,
                             mThumbnailRes: [0, 0] };
    }

    for( let i=0; i<this.mMaxCubeBuffers; i++ )
    {
        this.mCubeBuffers[i] = { mTexture: [null, null], 
                                mTarget:  [null, null], 
                                mResolution: [0, 0],
                                mLastRenderDone: 0,
                                mThumbnailRenderTarget: null,
                                mThumbnailTexture: null,
                                mThumbnailBuffer:  null,
                                mThumbnailRes: [0, 0] };
    }

    //-------

    let keyboardData = new Uint8Array( 256*3 );
    for (let j=0; j<(256*3); j++ ) { keyboardData[j] = 0; }
    let kayboardTexture = this.mRenderer.CreateTexture( this.mRenderer.TEXTYPE.T2D, 256, 3, this.mRenderer.TEXFMT.C1I8, this.mRenderer.FILTER.NONE, this.mRenderer.TEXWRP.CLAMP, null);
    let keyboardImage = new Image();
    if( callback!==null )
        keyboardImage.src = "/img/keyboard.png"; // don't load PNG if no UI 
    this.mKeyboard = { mData: keyboardData, mTexture: kayboardTexture, mIcon: keyboardImage };

    let iResize = function( xres, yres )
    {
        me.mCanvas.width = xres;
        me.mCanvas.height = yres;
        me.mXres = xres;
        me.mYres = yres;
        me.ResizeBuffers(xres, yres);
        resizeCallback(xres, yres);
    };

    let bestAttemptFallback = function()
    {
        let devicePixelRatio = window.devicePixelRatio || 1;
        let xres = Math.round(me.mCanvas.offsetWidth  * devicePixelRatio) | 0;
        let yres = Math.round(me.mCanvas.offsetHeight * devicePixelRatio) | 0;
        iResize(xres, yres);
    };

    if(!window.ResizeObserver)
    {
        console.log("WARNING: This browser doesn't support ResizeObserver.");
        bestAttemptFallback();
        window.addEventListener("resize", bestAttemptFallback);
    }
    else
    {
        this.mRO = new ResizeObserver( function(entries, observer)
        {
            var entry = entries[0];
            if (!entry['devicePixelContentBoxSize'])
            {
                observer.unobserve(me.mCanvas);
                console.log("WARNING: This browser doesn't support ResizeObserver + device-pixel-content-box (2)");
                bestAttemptFallback();
                window.addEventListener("resize", bestAttemptFallback);
            }
            else
            {
                let box = entry.devicePixelContentBoxSize[0];
                let xres = box.inlineSize;
                let yres = box.blockSize;
                iResize(xres, yres);
            }
        });
        try
        {
            this.mRO.observe(this.mCanvas, { box: ["device-pixel-content-box"] });
            //this.mRO.observe(this.mCanvas);
        }
        catch (e)
        {
            console.log("WARNING: This browser doesn't support ResizeObserver + device-pixel-content-box (1)");
            bestAttemptFallback();
            window.addEventListener("resize", bestAttemptFallback);
        }
    }

    this.mCreated = true;
}


Effect.prototype.ResizeCubemapBuffer = function(i, xres, yres )
{
    let oldXres = this.mCubeBuffers[i].mResolution[0];
    let oldYres = this.mCubeBuffers[i].mResolution[1];

    if( this.mCubeBuffers[i].mTexture[0]===null || oldXres !== xres || oldYres !== yres )
    {
        let texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.CUBEMAP,
            xres, yres,
            this.mRenderer.TEXFMT.C4F16,
            this.mRenderer.FILTER.LINEAR,
            this.mRenderer.TEXWRP.CLAMP, 
            null);
        let target1 = this.mRenderer.CreateRenderTargetCubeMap( texture1, null, false);

        let texture2 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.CUBEMAP,
            xres, yres,
            this.mRenderer.TEXFMT.C4F16,
            this.mRenderer.FILTER.LINEAR,
            this.mRenderer.TEXWRP.CLAMP, 
            null);

        let target2 = this.mRenderer.CreateRenderTargetCubeMap( texture2, null, false);

        // Store new buffers
        this.mCubeBuffers[i].mTexture = [texture1,texture2], 
        this.mCubeBuffers[i].mTarget =  [target1, target2 ], 
        this.mCubeBuffers[i].mLastRenderDone = 0;
        this.mCubeBuffers[i].mResolution[0] = xres;
        this.mCubeBuffers[i].mResolution[1] = yres;
    }
}


Effect.prototype.ResizeBuffer = function( i, xres, yres, skipIfNotExists )
{
    if( skipIfNotExists && this.mBuffers[i].mTexture[0]===null ) return;

    let oldXres = this.mBuffers[i].mResolution[0];
    let oldYres = this.mBuffers[i].mResolution[1];

    if( oldXres !== xres || oldYres !== yres )
    {
        let needCopy = (this.mBuffers[i].mTexture[0]!==null);

        let texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,
            xres, yres,
            this.mRenderer.TEXFMT.C4F32,
            (needCopy) ? this.mBuffers[i].mTexture[0].mFilter : this.mRenderer.FILTER.NONE,
            (needCopy) ? this.mBuffers[i].mTexture[0].mWrap   : this.mRenderer.TEXWRP.CLAMP, 
            null);

        let texture2 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,
            xres, yres,
            this.mRenderer.TEXFMT.C4F32,
            (needCopy) ? this.mBuffers[i].mTexture[1].mFilter : this.mRenderer.FILTER.NONE,
            (needCopy) ? this.mBuffers[i].mTexture[1].mWrap   : this.mRenderer.TEXWRP.CLAMP, 
            null);

        let target1 = this.mRenderer.CreateRenderTarget( texture1, null, null, null, null, false);
        let target2 = this.mRenderer.CreateRenderTarget( texture2, null, null, null, null, false);

        if( needCopy )
        {
            let v = [0, 0, Math.min(xres, oldXres), Math.min(yres, oldYres)];
            this.mRenderer.SetBlend(false);
            this.mRenderer.SetViewport(v);
            this.mRenderer.AttachShader(this.mProgramCopy);
            let l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, "pos");
            let vOld = [0, 0, oldXres, oldYres];
            this.mRenderer.SetShaderConstant4FV("v", vOld);

            // Copy old buffers 1 to new buffer
            this.mRenderer.SetRenderTarget(target1);
            this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[0], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);

            // Copy old buffers 2 to new buffer
            this.mRenderer.SetRenderTarget(target2);
            this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[1], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);

            // Deallocate old memory
            this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[0]);
            this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[0]);
            this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[1]);
            this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[1]);
            //this.mRenderer.DestroyTexture(this.mBuffers[i].thumbnailTexture);
        }

        // Store new buffers
        this.mBuffers[i].mTexture = [texture1,texture2], 
        this.mBuffers[i].mTarget =  [target1, target2 ], 
        this.mBuffers[i].mLastRenderDone = 0;
        this.mBuffers[i].mResolution[0] = xres;
        this.mBuffers[i].mResolution[1] = yres;
    }
}

Effect.prototype.saveScreenshot = function(passid)
{
    let pass = this.mPasses[passid];

    if( pass.mType === "buffer" )
    {
        let bufferID = assetID_to_bufferID( this.mPasses[passid].mOutputs[0] );

        let texture = this.mBuffers[bufferID].mTarget[ this.mBuffers[bufferID].mLastRenderDone ];

        let numComponents = 3;
        let width = texture.mTex0.mXres;
        let height = texture.mTex0.mYres;
        let type = "Float"; // Other options Float, Half, Uint
        let bytes = new Float32Array(width * height * 4 );//numComponents);
        this.mRenderer.GetPixelDataRenderTarget( texture, bytes, width, height );
        let blob = piExportToEXR(width, height, numComponents, type, bytes);

        // Offer download automatically to the user
        piTriggerDownload("image.exr", blob);
    }
    else if( pass.mType === "cubemap" )
    {
        let xres = 4096;
        let yres = 2048;
        this.mScreenshotSytem.Allocate( xres, yres );

        let cubeBuffer = this.mCubeBuffers[0];

        let target = this.mScreenshotSytem.GetTarget();
        this.mRenderer.SetRenderTarget( target );

        let program = this.mScreenshotSytem.GetProgram();

        this.mRenderer.AttachShader(program);
        let l1 = this.mRenderer.GetAttribLocation(program, "pos");
        this.mRenderer.SetViewport( [0, 0, xres, yres] );
        this.mRenderer.AttachTextures(1, cubeBuffer.mTexture[ cubeBuffer.mLastRenderDone ], null, null, null);
        this.mRenderer.DrawUnitQuad_XY(l1);
        this.mRenderer.DettachTextures();
        this.mRenderer.SetRenderTarget( null );

        let data = new Float32Array(xres*yres*4);
        this.mRenderer.GetPixelDataRenderTarget( target, data, xres, yres );

        let blob = piExportToEXR(xres, yres, 3, "Float", data );
        piTriggerDownload("image.exr", blob);
    }
    else if( pass.mType === "sound" )
    {
        let offset = 0;
        const bits = 16;
        const numChannels = 2;
        let words = new Int16Array(60*pass.mSampleRate*numChannels );

        pass.iRenderSound( new Date(), function(off, data, numSamples)
                                         {
                                            for( let i=0; i<numSamples; i++ )
                                            {
                                                words[offset++] = (data[4*i+0]+256.0*data[4*i+1]) - 32767;
                                                words[offset++] = (data[4*i+2]+256.0*data[4*i+3]) - 32767;
                                            }
                                         }
                                     );

        let blob = piExportToWAV( 60*pass.mSampleRate, pass.mSampleRate, bits, numChannels, words);

        piTriggerDownload("sound.wav", blob);
    }    
}

Effect.prototype.ResizeBuffers = function(xres, yres)
{
    for (let i=0; i<this.mMaxBuffers; i++ )
    {
        this.ResizeBuffer(i, xres, yres, true);
    }
}

Effect.prototype.IsEnabledVR = function ()
{
    if (this.mRenderingStereo) return true;
    return false;
}

Effect.prototype.EnableVR = function()
{
    if( !this.mWebVR.IsSupported() ) return;
    if( this.mRenderingStereo ) return;

    this.mRenderingStereo = true;
    this.mWebVR.Enable();
}

Effect.prototype.DisableVR = function()
{
    if( !this.mWebVR.IsSupported() ) return;
    if( !this.mRenderingStereo ) return;

    this.mRenderingStereo = false;
    this.mWebVR.Disable();
}

Effect.prototype.GetTexture = function( passid, slot )
{
    return this.mPasses[passid].GetTexture( slot );
}

Effect.prototype.NewTexture = function( passid, slot, url )
{
    return this.mPasses[passid].NewTexture( this.mAudioContext, slot, url, this.mBuffers, this.mCubeBuffers, this.mKeyboard );
}

Effect.prototype.SetOutputs = function( passid, slot, url )
{
    this.mPasses[passid].SetOutputs( slot, url );
}

Effect.prototype.SetOutputsByBufferID = function( passid, slot, id )
{
    this.mPasses[passid].SetOutputsByBufferID( slot, id );
}

Effect.prototype.GetAcceptsLinear = function (passid, slot) 
{
    return this.mPasses[passid].GetAcceptsLinear(slot);
}

Effect.prototype.GetAcceptsMipmapping = function (passid, slot) 
{
    return this.mPasses[passid].GetAcceptsMipmapping(slot);
}

Effect.prototype.GetAcceptsWrapRepeat = function (passid, slot) 
{
    return this.mPasses[passid].GetAcceptsWrapRepeat(slot);
}

Effect.prototype.GetAcceptsVFlip = function (passid, slot)
{
    return this.mPasses[passid].GetAcceptsVFlip(slot);
}

Effect.prototype.SetSamplerFilter = function (passid, slot, str) 
{
    this.mPasses[passid].SetSamplerFilter(slot, str, this.mBuffers, this.mCubeBuffers);
}

Effect.prototype.GetTranslatedShaderSource = function (passid)
{
    return this.mPasses[passid].GetTranslatedShaderSource();
}

Effect.prototype.GetSamplerFilter = function (passid, slot) {
    return this.mPasses[passid].GetSamplerFilter(slot);
}

Effect.prototype.SetSamplerWrap = function (passid, slot, str) {
    this.mPasses[passid].SetSamplerWrap(slot, str, this.mBuffers);
}

Effect.prototype.GetSamplerWrap = function (passid, slot) {
    return this.mPasses[passid].GetSamplerWrap(slot);
}

Effect.prototype.SetSamplerVFlip = function (passid, slot, str) {
    this.mPasses[passid].SetSamplerVFlip(slot, str);
}

Effect.prototype.GetSamplerVFlip = function (passid, slot) {
    return this.mPasses[passid].GetSamplerVFlip(slot);
}

Effect.prototype.GetHeaderSize = function (passid)
{
    return this.mPasses[passid].mHeaderLength + 
           this.mRenderer.GetShaderHeaderLines(1);
 
}

Effect.prototype.ToggleVolume = function()
{
    this.mForceMuted = !this.mForceMuted;

    // outp
    if (this.mForceMuted)
        this.mGainNode.gain.value = 0.0;
    else
        this.mGainNode.gain.value = 1.0;

    // inp
    let num = this.mPasses.length;
    for( let j=0; j<num; j++ )
    {
        for( let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            if( this.mForceMuted )
                this.mPasses[j].MuteInput( this.mAudioContext, i );
            else
                this.mPasses[j].UnMuteInput( this.mAudioContext, i );
        }
    }

    return this.mForceMuted;
}

Effect.prototype.SetKeyDown = function( passid, k )
{
    if( this.mKeyboard.mData[ k + 0*256 ] == 255 ) return;

    this.mKeyboard.mData[ k + 0*256 ] = 255;
    this.mKeyboard.mData[ k + 1*256 ] = 255;
    this.mKeyboard.mData[ k + 2*256 ] = 255 - this.mKeyboard.mData[ k + 2*256 ];
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    let num = this.mPasses.length;
    for (let j=0; j<num; j++ )
    {
        for (let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            let inp = this.mPasses[j].mInputs[i];
            if( inp!==null && inp.mInfo.mType==="keyboard" )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:this.mKeyboard.mIcon, mData: this.mKeyboard.mData}, false, 6, 1, -1.0, this.mPasses[j].mID );
            }
        }
    }
}

Effect.prototype.SetKeyUp = function( passid, k )
{
    this.mKeyboard.mData[ k + 0*256 ] = 0;
    this.mKeyboard.mData[ k + 1*256 ] = 0;
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    let num = this.mPasses.length;
    for (let j=0; j<num; j++ )
    {
        for (let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            let inp = this.mPasses[j].mInputs[i];
            if( inp!==null && inp.mInfo.mType==="keyboard" )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:this.mKeyboard.mIcon, mData: this.mKeyboard.mData}, false, 6, 1, -1.0, this.mPasses[j].mID );
            }
        }
    }

}

Effect.prototype.StopOutputs = function()
{
    let wa = this.mAudioContext;

    let num = this.mPasses.length;
    for (let i=0; i<num; i++ )
    {
        this.mPasses[i].StopOutput( wa );
    }
}

Effect.prototype.ResumeOutputs = function()
{
    let wa = this.mAudioContext;

    let num = this.mPasses.length;
    for (let i=0; i<num; i++ )
    {
        this.mPasses[i].ResumeOutput( wa );
    }
}

Effect.prototype.PauseInput = function( passid, id )
{
    return this.mPasses[passid].TooglePauseInput( this.mAudioContext, id );
}

Effect.prototype.ToggleMuteInput = function( passid, id )
{
    return this.mPasses[passid].ToggleMuteInput( this.mAudioContext, id );
}

Effect.prototype.RewindInput = function( passid, id )
{
    this.mPasses[passid].RewindInput( this.mAudioContext, id );
}

Effect.prototype.UpdateInputs = function( passid, forceUpdate )
{
   this.mPasses[passid].UpdateInputs( this.mAudioContext, forceUpdate, this.mKeyboard );
}

Effect.prototype.ResetTime = function()
{
    this.mFrame = 0;
    this.mAudioContext.resume()

    let num = this.mPasses.length;
    for( let i=0; i<num; i++ )
    {
        this.mPasses[i].mFrame = 0;
        for( let j=0; j<this.mPasses[i].mInputs.length; j++ )
            this.mPasses[i].RewindInput(this.mAudioContext, j)
    }
}

Effect.prototype.RequestAnimationFrame = function (id)
{
    if (this.mRenderingStereo && this.mWebVR.IsPresenting())
    {
        this.mWebVR.RequestAnimationFrame(id);
    }
    else
    {
        requestAnimFrame(id);
    }
}

Effect.prototype.Paint = function(time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, isPaused)
{
    let wa = this.mAudioContext;
    let da = new Date();
    let vrData = null; if (this.mRenderingStereo) vrData = this.mWebVR.GetData();
    let xres = this.mXres / 1;
    let yres = this.mYres / 1;

    if( this.mFrame===0 )
    {
        for( let i=0; i<this.mMaxBuffers; i++ )
        {
            if( this.mBuffers[i].mTexture[0]!==null )
            {
                this.mRenderer.SetRenderTarget( this.mBuffers[i].mTarget[0] );
                this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
                this.mRenderer.SetRenderTarget( this.mBuffers[i].mTarget[1] );
                this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
				
				this.mRenderer.CreateMipmaps( this.mBuffers[i].mTexture[0] );
				this.mRenderer.CreateMipmaps( this.mBuffers[i].mTexture[1] );
            }
        }
        for( let i=0; i<this.mMaxCubeBuffers; i++ )
        {
            if( this.mCubeBuffers[i].mTexture[0]!==null )
            {
                for( let face=0; face<6; face++ )
                {
                    this.mRenderer.SetRenderTargetCubeMap( this.mCubeBuffers[i].mTarget[0], face );
                    this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
                    this.mRenderer.SetRenderTargetCubeMap( this.mCubeBuffers[i].mTarget[1], face );
                    this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
					this.mRenderer.CreateMipmaps( this.mCubeBuffers[i].mTexture[0] );
				    this.mRenderer.CreateMipmaps( this.mCubeBuffers[i].mTexture[1] );
                }
            }
        }
    }

    let num = this.mPasses.length;

    // render sound first
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "sound" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, null, false, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render buffers second
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "buffer" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        let bufferID = assetID_to_bufferID( this.mPasses[i].mOutputs[0] );

        // check if any downstream pass needs mipmaps when reading from this buffer
        let needMipMaps = false;
        for (let j=0; j<num; j++ )
        {
            for (let k=0; k<this.mPasses[j].mInputs.length; k++ )
            {
                let inp = this.mPasses[j].mInputs[k];
                if( inp!==null && inp.mInfo.mType==="buffer" && inp.id === bufferID && inp.mInfo.mSampler.filter === "mipmap")
                {
                    needMipMaps = true;
                    break;
                }
            }
        }

        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, needMipMaps, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }


    // render cubemap buffers second
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "cubemap" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        let bufferID = 0;//assetID_to_bufferID( this.mPasses[i].mOutputs[0] );

        // check if any downstream pass needs mipmaps when reading from this buffer
        let needMipMaps = false;

        for (let j=0; j<num; j++ )
        {
            for (let k=0; k<this.mPasses[j].mInputs.length; k++ )
            {
                let inp = this.mPasses[j].mInputs[k];
                if( inp!==null && inp.mInfo.mType==="cubemap" )
                {
                    if( assetID_to_cubemapBuferID(inp.mInfo.mID)===0 && inp.mInfo.mSampler.filter === "mipmap" )
                    {
                        needMipMaps = true;
                        break;
                    }
                }
            }
        }

        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, needMipMaps, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render image last
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "image" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, null, false, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }   

    // erase keypresses
    for (let k=0; k<256; k++ )
    {
       this.mKeyboard.mData[ k + 1*256 ] = 0;
    }
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    if( this.mRenderingStereo ) this.mWebVR.Finish();

    this.mFrame++;
}

Effect.prototype.NewShader = function( passid, preventCache, onResolve )
{
    let commonSourceCodes = [];
    for (let i=0; i<this.mPasses.length; i++ )
    {
        if( this.mPasses[i].mType==="common")
        {
            commonSourceCodes.push(this.mPasses[i].mSource);
        }
    }

    this.mPasses[passid].NewShader(commonSourceCodes, preventCache, onResolve );
}

Effect.prototype.GetNumPasses = function()
{
    return this.mPasses.length;
}

Effect.prototype.GetNumOfType = function(passtype)
{
    let id = 0;
    for (let j=0; j<this.mPasses.length; j++ )
    {
        if( this.mPasses[j].mType===passtype )
        {
            id++;
        }
    }
    return id;
}

Effect.prototype.GetPassType = function( id )
{
    return this.mPasses[id].mType;
}
Effect.prototype.GetPassName = function( id )
{
    return this.mPasses[id].mName;
}
Effect.prototype.GetCode = function( id )
{
    return this.mPasses[id].mSource;
}
Effect.prototype.SetCode = function( id, source )
{
    this.mPasses[id].SetCode(source);
}
Effect.prototype.GetError = function (id)
{
    return this.mPasses[id].mError;
}
Effect.prototype.GetErrorStr = function (id)
{
    return this.mPasses[id].mErrorStr;
}
Effect.prototype.GetErrorGlobal = function()
{
    for (let i = 0; i < this.mPasses.length; i++)
    {
        if (this.mPasses[i].mError)
        {
            return true;
        }
    }
    return false;
}

Effect.prototype.Load = function (jobj )
{
    if (jobj.ver !== "0.1")
    {
        console.log("Wrong Format");
        return false;
    }

    let numPasses = jobj.renderpass.length;

    if( numPasses<1 || numPasses>this.mMaxPasses )
    {
        console.log("Corrupted Shader - " + numPasses);
        return false;
    }

    this.mPasses = [];
    for (let j = 0; j < numPasses; j++)
    {
        let rpass = jobj.renderpass[j];

        // skip sound passes if in thumbnail mode
        if( this.mForceMuted && rpass.type === "sound" ) continue;

        let wpass = new EffectPass(this.mRenderer, this.mIs20, this.mIsLowEnd, this.mShaderTextureLOD,
                                   this.mTextureCallbackFun, this.mTextureCallbackObj, this.mForceMuted, this.mForcePaused, this.mGainNode,
                                   this.mProgramDownscale, j, this);

        wpass.Create(rpass.type, this.mAudioContext);

        let numInputs = rpass.inputs.length;

        for (let i = 0; i < 4; i++)
        {
            wpass.NewTexture(this.mAudioContext, i, null, null, null);
        }
        for (let i = 0; i < numInputs; i++)
        {
            let lid  = rpass.inputs[i].channel;
            let styp = rpass.inputs[i].type;
            let sid  = rpass.inputs[i].id;
            let ssrc = rpass.inputs[i].filepath;
            let psrc = rpass.inputs[i].previewfilepath;
            let samp = rpass.inputs[i].sampler;

            wpass.NewTexture(this.mAudioContext, lid, { mType: styp, mID: sid, mSrc: ssrc, mSampler: samp, mPreviewSrc: psrc }, this.mBuffers, this.mCubeBuffers, this.mKeyboard);
        }

        for (let i = 0; i < 4; i++)
        {
            wpass.SetOutputs(i, null);
        }

        let numOutputs = rpass.outputs.length;
        for (let i = 0; i < numOutputs; i++)
        {
            let outputID = rpass.outputs[i].id;
            let outputCH = rpass.outputs[i].channel;
            wpass.SetOutputs(outputCH, outputID);
        }

        // create some hardcoded names. This should come from the DB
        let rpassName = "";
        if (rpass.type === "common" ) rpassName = "Common";
        if (rpass.type === "sound"  ) rpassName = "Sound";
        if (rpass.type === "image"  ) rpassName = "Image";
        if (rpass.type === "buffer") rpassName = "Buffer " + String.fromCharCode(65 + assetID_to_bufferID(wpass.mOutputs[0]));
        if (rpass.type === "cubemap") rpassName = "Cube A";// " + String.fromCharCode(65 + assetID_to_bufferID(this.mPasses[j].mOutputs[0]));
        wpass.SetName(rpassName);
        wpass.SetCode(rpass.code);

        this.mPasses.push(wpass);
    }
    return true;
}

Effect.prototype.CompileSome = function ( passes, preventCache, onResolve )
{
    let me = this;

    let to = getRealTime();
    let allPromisses = [];
    for (let j = 0; j < passes.length; j++)
    {
        allPromisses.push(new Promise(function (resolve, reject)
        {
            me.NewShader(passes[j], preventCache, function () { resolve(1); });
        }));
    }

    // aggregated callback when all passes have been compiled
    Promise.all(allPromisses).then(function (values)
    {
        let totalError = false;
        for (let j = 0; j < me.mPasses.length; j++)
        {
            if (me.mPasses[j].mError)
            {
                totalError = true;
                break;
            }
        }
        me.mCompilationTime = getRealTime() - to;
        onResolve(!totalError);
    }).catch(console.log);
}

Effect.prototype.Compile = function (preventCache, onResolve )
{
    let me = this;

    let to = getRealTime();
    let allPromisses = [];
    let numPasses = this.mPasses.length;
    for (let j = 0; j < numPasses; j++)
    {
        allPromisses.push(new Promise(function (resolve, reject)
        {
            me.NewShader(j, preventCache, function () { resolve(1); });
        }));
    }

    // aggregated callback when all passes have been compiled
    Promise.all(allPromisses).then(function (values)
    {
        let totalError = false;
        for (let j = 0; j < numPasses; j++)
        {
            if (me.mPasses[j].mError)
            {
                totalError = true;
                break;
            }
        }
        me.mCompilationTime = getRealTime() - to;
        onResolve(!totalError);
    }).catch(console.log);
}

Effect.prototype.GetCompilationTime = function( id )
{
    return this.mPasses[id].GetCompilationTime()/1000.0;
}
Effect.prototype.GetTotalCompilationTime = function()
{
    return this.mCompilationTime/1000.0;
}

Effect.prototype.DestroyPass = function( id )
{
   this.mPasses[id].Destroy( this.mAudioContext );
   this.mPasses.splice(id, 1);
}

Effect.prototype.AddPass = function( passType, passName, onResolve )
{
    let shaderStr = null;

    if( passType==="sound"   ) shaderStr = "vec2 mainSound( int samp, float time )\n{\n    // A 440 Hz wave that attenuates quickly overt time\n    return vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );\n}";
    if( passType==="buffer"  ) shaderStr = "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}";
    if( passType==="common"  ) shaderStr = "vec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}";
    if( passType==="cubemap" ) shaderStr = "void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Ray direction as color\n    vec3 col = 0.5 + 0.5*rayDir;\n\n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}";

    let id = this.GetNumPasses();
    this.mPasses[id] = new EffectPass( this.mRenderer, this.mIs20, this.mIsLowEnd, this.mShaderTextureLOD,
                                       this.mTextureCallbackFun, this.mTextureCallbackObj, this.mForceMuted, this.mForcePaused, this.mGainNode, 
                                       this.mProgramDownscale, id, this );

    this.mPasses[id].Create( passType, this.mAudioContext );
    this.mPasses[id].SetName( passName );
    this.mPasses[id].SetCode( shaderStr );
    this.NewShader(id, false, function ()
    {
        onResolve();
    });

    return { mId : id, mShader : shaderStr };
}

// this should be removed once we have MultiPass 2.0 and passes render to arbitrary buffers
Effect.prototype.IsBufferPassUsed = function( bufferID )
{
    for (let j=0; j<this.mPasses.length; j++ )
    {
        if( this.mPasses[j].mType !== "buffer" ) continue;
        if( this.mPasses[j].mOutputs[0] === bufferID_to_assetID(bufferID) ) return true;
    }
    return false;
}

Effect.prototype.Save = function()
{
    var result = {};

    result.ver = "0.1";

    result.renderpass = [];

    let numPasses = this.mPasses.length;
    for (let j=0; j<numPasses; j++ )
    {
        result.renderpass[j] = {};

        result.renderpass[j].outputs = new Array();
        for (let i = 0; i<4; i++ )
        {
            let outputID = this.mPasses[j].mOutputs[i];
            if( outputID===null ) continue;
            result.renderpass[j].outputs.push( { channel: i, id: outputID } );
        }
        result.renderpass[j].inputs = new Array();
        for (let i = 0; i<4; i++ )
        {
            if( this.mPasses[j].mInputs[i]===null ) continue;
            result.renderpass[j].inputs.push( {channel: i,
                                               type    : this.mPasses[j].mInputs[i].mInfo.mType,
                                               id      : this.mPasses[j].mInputs[i].mInfo.mID,
                                               filepath: this.mPasses[j].mInputs[i].mInfo.mSrc,
                                               sampler : this.mPasses[j].mInputs[i].mInfo.mSampler });
        }

        result.renderpass[j].code = this.mPasses[j].mSource;
        result.renderpass[j].name = this.mPasses[j].mName
        result.renderpass[j].description = "";
        result.renderpass[j].type = this.mPasses[j].mType;
    }

    result.flags = this.calcFlags();

    return result;
}

Effect.prototype.calcFlags = function ()
{
    let flagVR = false;
    let flagWebcam = false;
    let flagSoundInput = false;
    let flagSoundOutput = false;
    let flagKeyboard = false;
    let flagMultipass = false;
    let flagMusicStream = false;

    let numPasses = this.mPasses.length;
    for (let j = 0; j < numPasses; j++)
    {
        let pass = this.mPasses[j];

        if (pass.mType === "sound") flagSoundOutput = true;
        if (pass.mType === "buffer") flagMultipass = true;

        for (let i = 0; i < 4; i++)
        {
            if (pass.mInputs[i] === null) continue;

            if (pass.mInputs[i].mInfo.mType === "webcam") flagWebcam = true;
            else if (pass.mInputs[i].mInfo.mType === "keyboard") flagKeyboard = true;
            else if (pass.mInputs[i].mInfo.mType === "mic") flagSoundInput = true;
            else if (pass.mInputs[i].mInfo.mType === "musicstream") flagMusicStream = true;
        }

        let n1 = pass.mSource.indexOf("mainVR(");
        let n2 = pass.mSource.indexOf("mainVR (");
        if (n1 > 0 || n2 > 0) flagVR = true;
    }

    return {
        mFlagVR: flagVR,
        mFlagWebcam: flagWebcam,
        mFlagSoundInput: flagSoundInput,
        mFlagSoundOutput: flagSoundOutput,
        mFlagKeyboard: flagKeyboard,
        mFlagMultipass: flagMultipass,
        mFlagMusicStream: flagMusicStream
    };
}</script>
    <script>"use strict"

const kMaxCompileTime = 10.0;

function iReportCrash(shaderID)
{
    let req = new XMLHttpRequest();
    req.onload = function ()
    {
        let jsn = req.response;
        if (jsn === null) return;
        if (jsn.result === 0)
        {
            // yep
        }
    };
    req.open("POST", "/shadertoy", true);
    req.responseType = "json";
    req.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    req.send( "s=" + shaderID + "&r=2" );
}
</script>
    <script>"use strict"

var gActive = -1;
var mShaders = [];
var gNumCanvases = 0;

function myrefresh( id, slot, img, forceFrame, gui, guiID, renderID, time )
{
    if( mShaders[id].mReady===false ) return;
    if( forceFrame )
    {
        if (mShaders[id].mScreenshot === false)
        {
            mShaders[id].gEffect.Paint(mShaders[id].mTime / 1000.0, 1.0 / 60.0, 60.0, 0, 0, 0, 0, false);
        }
    }
}

function startRendering()
{
    if( gActive<0 ) return;
    if( mShaders[gActive].mReady===false ) return;
    if( mShaders[gActive].mScreenshot===true ) return;

    let time = getRealTime();

    mShaders[gActive].mFPS.Count( time );
    mShaders[gActive].mTime = mShaders[gActive].mTime0 + (time - mShaders[gActive].mTo);
    let dtime = 1000.0/60.0;
    mShaders[gActive].gEffect.Paint( mShaders[gActive].mTime/1000.0, dtime/1000.0, mShaders[gActive].mFPS.GetFPS(), 0,0,0,0, false);

    requestAnimFrame( startRendering );
}

function iLoadAndCompile(jsn, i )
{
    var shaderObj = jsn[i];
    if (shaderObj === null) return;

    var resizeCB = function (xres, yres) { myrefresh(i, 0, null, true, false, 0, -1.0) };
    var crashCB = function () { alert('crash');/*iReportCrash(gShaderIDs[i])*/ };
    mShaders[i].gEffect = new Effect(null, null, mShaders[i].mPreview.mCanvas, myrefresh, i, true, true, resizeCB, crashCB);

    if (!mShaders[i].gEffect.Load(shaderObj)) return;

    mShaders[i].gEffect.Compile(false, function (worked)
    {
        if (worked === true)
        {
            previewShowRender(mShaders[i].mPreview);

            mShaders[i].mScreenshot = false;
            mShaders[i].mReady = true;
            mShaders[i].mTime = 10.0 * 1000.0;
            mShaders[i].mTime0 = 0.0;
            mShaders[i].mTo = 0.0;
            mShaders[i].mFPS = piCreateFPSCounter();
            mShaders[i].mPreview.mCanvas.addEventListener("mouseout", function (ev) { gActive = -1; }, true);
            mShaders[i].mPreview.mBase.addEventListener("mouseover", function (ev) { if (mShaders[i].mPreview.mUI !== null) mShaders[i].mPreview.mUI.classList.add('isVisible'); }, true);
            mShaders[i].mPreview.mBase.addEventListener("mouseout", function (ev) { if (mShaders[i].mPreview.mUI !== null) mShaders[i].mPreview.mUI.classList.remove('isVisible'); }, true);
            mShaders[i].mPreview.mCanvas.addEventListener("mouseover", function (ev)
            {
                let ele = piGetSourceElement(ev);
                if (ele.mId === undefined) return;

                gActive = ele.mId;
                if (!mShaders[gActive].mReady) return;
                let time = getRealTime();
                mShaders[gActive].mTo = time;
                mShaders[gActive].mTime0 = mShaders[gActive].mTime;
                mShaders[gActive].mFPS.Reset(time);

                startRendering();
            }, true);


            /*
            let compilationTime = mShaders[i].gEffect.GetTotalCompilationTime();
            if (compilationTime > kMaxCompileTime)
            {
                iReportCrash(mShaders[i].mShaderID);
            }*/

            myrefresh(i, null, null, true, false, 0, -1.0);
        }
        else
        {
            mShaders[i].mReady = false;
            previewShowError(mShaders[i].mPreview);
        }
    });
};


function iProcessShader( jsn, i )
{
    var shaderObj = jsn[i];
    if( shaderObj===null ) return;

    if ((shaderObj.info.usePreview === 0 && !gUseScreenshots) || (mShaders[i].mPreviewReady !== 1))
    {
        iLoadAndCompile(jsn, i);
    }
    else
    {
        mShaders[i].mScreenshot = true;
        if( shaderObj.info.usePreview === 1 )
            previewShowScreenshot(mShaders[i].mPreview, 1); // comp
        else if (gUseScreenshots)
            previewShowScreenshot(mShaders[i].mPreview, 2); // sett
    }

    if( i<(jsn.length-1) ) setTimeout( function(){iProcessShader(jsn,i+1);}, 10 );
}

function iInitUI(numCanvases, uiCallback, windowTitle)
{
    gNumCanvases = numCanvases;
    document.getElementById("mySearch").focus();

    //-----------------------------------------------------------------
    // window
    //-----------------------------------------------------------------
    if (windowTitle !== null) {
        document.title = windowTitle;
    }

    //-----------------------------------------------------------------
    // ui
    //-----------------------------------------------------------------
    var num = Math.min(gShaders.length, gNumCanvases);

    //var base = document.getElementsByClassName( "searchResult" );

    for (let i = 0; i < gNumCanvases; i++)
    {
        let pv = createPreview(i);

        if (i >= num) {
            previewHide(pv);
            continue;
        }

        let shaderID = gShaders[i].info.id;
        
        if (pv.mUI !== null && uiCallback !== null) {
            pv.mUI.addEventListener('click', function (ev) {
                uiCallback(shaderID);
                ev.preventDefault();
            }, false);
        }
        
        previewShowLoading(pv);
        
        mShaders[i] = {};
        mShaders[i].mShaderID = shaderID;
        mShaders[i].mPreview = pv;
        mShaders[i].mScreenshot = false;
        mShaders[i].mPreview.mLink.href = "/view/" + shaderID;
        mShaders[i].mPreviewReady = 0;
        mShaders[i].mReady = false;
        mShaders[i].gEffect = null;

        previewLoadScreenshot(mShaders[i].mPreview,
            function () { mShaders[i].mPreviewReady = 1; if (mShaders[i].mReady === false) previewShowScreenshot(mShaders[i].mPreview, 0); },
            function () { mShaders[i].mPreviewReady = 2; },
            shaderID);
    }

    if (num <= 0) {
        return;
    }
}

function iInitShaders(jsn)
{
    for (let i = 0; i < jsn.length; i++)
    {
        let shaderObj = jsn[i];
        if (shaderObj === null) continue;
        let inf = shaderObj.info;
        mShaders[i].mPreview.mTextA.textContent = inf.name;
        mShaders[i].mPreview.mTextB.innerHTML = "<a class='user' href='/user/" + htmlEntities(inf.username) + "'>" + htmlEntities(inf.username) + "</a>";
        mShaders[i].mPreview.mTextC.innerHTML = "<img src='/img/themes/" + gThemeName + "/views.png' class='viewsIcon'></img>" + inf.viewed + "    &nbsp;&nbsp;  <img src='/img/themes/" + gThemeName + "/likes.png' class='likesIcon'></img>" + inf.likes;
    }

    setTimeout(function () { iProcessShader(jsn, 0); }, 10);
}

function resultsInitStatic(numCanvases, uiCallback, windowTitle)
{
    iInitUI(numCanvases, uiCallback, windowTitle);

    iInitShaders(gShaders);
}

function resultsInit(numCanvases, uiCallback, windowTitle)
{	
    iInitUI(numCanvases, uiCallback, windowTitle);

    var num = Math.min(gShaderIDs.length, gNumCanvases);

    var mHttpReq = new XMLHttpRequest();

    mHttpReq.abort();

    var str = "{ \"shaders\" : [";
    for( let i=0; i<num; i++ )
    {
         str += "\"" + gShaderIDs[i] + "\"";
         if( i!==(num-1) ) str += ", ";
    }
    str += "] }";

    str = "s=" + encodeURIComponent( str ) + "&nt=0&nl=0&np=0";

    mHttpReq.open( "POST", "/shadertoy", true );
    mHttpReq.responseType = "json";
    mHttpReq.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    mHttpReq.onload = function ()
    {
        let jsn = this.response;
        if( jsn===null )
        {
            console.log( "Could not load shaders" );
            return;
        }

        iInitShaders(jsn);
    }
    mHttpReq.send( str );
}</script>
    <style>
    .shaderPreview
    {
    display: block;
    background-color: #000000;
    background-image: url("/img/loading.gif");
    background-repeat: no-repeat;
    background-position: center;
    padding: 0px;
    margin: 0px;
    border: 0px solid #000000;
    border-radius: 8px;
    width:100%;
    height:100%;
    position: absolute;
    overflow:hidden;
    }

    .previewInfo
    {
    width: 100%;
    left: 0px;
    top: 2px;
    position: relative;
    visibility: hidden;
    }

    .previewCanvas
    {
    left: 0px;
    top: 0px;
    padding: 0px;
    margin: 0px;
    position: absolute;
    cursor: pointer;
    width:100%;
    height:100%;
    border-radius: 8px;
    border: 0px solid #000000;
    backgroundColor: transparent;
visibility: hidden;
opacity:0;
transition: opacity 1.0s ease;
    }

    .previewText
    {
        text-overflow: ellipsis;
    white-space: nowrap;
    padding-right: 1px;
    }

    .previewTextUser
    {
    text-overflow: ellipsis;
    white-space: nowrap;
    padding-left: 3px;
    }

    .previewStats
    {
    padding-right: 1px;
    right: 0px;
    top: 0px;
    position: absolute;
    }

    .previewErrorContainer
    {
    left:0px;
    top:0px;
    width:100%;
    height:100%;
    padding:0px;
    margin:0px;
    background-color:#000000;
    border-radius:8px;
    cursor:pointer;
    visibility:hidden;
    }

    .previewErrorMessage
    {
    top:50%;
    position:absolute;
    width:100%;
    text-align:center;
    padding:0;
    margin:auto;
    color:#ff0000;
    font-size:2em;
    font-style:italic;
    }

    .previewNoGLContainter
    {
    left:0px;
    top:0px;
    width:100%;
    height:100%;
    padding:0px;
    margin:0px;
    position:absolute;
    background-color:#000000;
    border-radius:8px;
    cursor:pointer;
    pointer-events:none;
    visibility:hidden;
    font-size:2em;
    }

    .previewNoGLMessage
    {
    width:86%;
    height:90%;
    padding-left:7%;
    padding-right:7%;
    padding-top:10%;
    padding-bottom:0px;
    color:#ff0000;
    position:absolute;
    visibility:hidden;
    }

    .previewThumbnailContainer
    {
    width:100%;
    height:100%;
    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    cursor:pointer;
    visibility:hidden;
    border-radius:8px;
    border:0px solid #000000;
    }

    .previewThumbnailImage
    {
    width:100%;
    height:100%;
    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    cursor:pointer;
    border-radius:8px;
    border:0px solid #000000;
opacity: 0.0;
transition: opacity 1.0s ease;
    }

    .previewThumbnailIcon
    {
    width:64px;
    height:32px;
    left:0px;
    top:0px;
    padding:0px;
    padding-top:12px;
    margin:0px;
    position:absolute;
    color:#ffffff;
    background-color:#ff8020;
    font-weight:bold;
    border-radius:0px 0px 8px 0px;
    text-align:center;
    //visibility:hidden;
    }


    .previewUIContainter
    {
    display: block;
    right:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    //cursor:pointer;
    //pointer-events:none;
    //visibility:hidden;
    }
</style>

<script>
    function previewHide(me)
    {
    me.mBase.style.visibility = "hidden";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "hidden";
    }

    function previewShowRender(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "visible";
me.mCanvas.style.opacity = 1.0;
    me.mCanvas.style.borderRadius ="8px;";
//  me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "visible";
    }

    function previewShowScreenshot(me, message)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "visible";
me.mThumbnailImg.style.opacity = 1.0;
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "visible";
    me.mThumbnailWar1.style.visibility = (message===1)?"visible":"hidden";
    me.mThumbnailWar2.style.visibility = (message===2)?"visible":"hidden";
    }

    function previewShowLoading(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "hidden";

    me.mLink.style.visibility = "visible";
    me.mBase.style.backgroundColor = "#ff0000;"
    me.mCont.style.visibility = "visible";
    }

    function previewShowNoWebGL(me, shaderID)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "visible";
    me.mError.style.visibility = "visible";
    me.mThumbnailImgNoWebGL.onerror = function(ev) 
                                      { 
                                            me.mThumbnailImgNoWebGL.style.visibility="hidden"; 
                                            me.mMessageNoWebGL.style.visibility="visible"; 
                                      };
    me.mThumbnailImgNoWebGL.src = "/media/shaders/" + shaderID + ".jpg";
    }

    function previewShowError(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "visible";
    me.mCont.style.visibility = "visible";
    }

    function previewLoadScreenshot( me, cbSuccess, cbError, shaderID )
    {
    var url = "/media/shaders/" + shaderID + ".jpg";
    me.mThumbnailImg.onload = cbSuccess;
    me.mThumbnailImg.onerror = function(ev) { cbError(); };
    me.mThumbnailImg.src = url;
    }
        
    function createPreview(id)
    {
        var bar = document.getElementById( "Preview_"+id+"_Canvas" );
        bar.width = bar.offsetWidth;
        bar.height = bar.offsetHeight;
        bar.mId = id;

        return { mBase: document.getElementById( "Preview_"+id+"_Container" ),
        mLink: document.getElementById( "Preview_"+id+"_Link" ),
        mCanvas: bar,
        mCont: document.getElementById( "Preview_"+id+"_Info" ),
        mTextA: document.getElementById( "Preview_"+id+"_Text" ),
        mTextB: document.getElementById( "Preview_"+id+"_TextUser" ),
        mTextC: document.getElementById( "Preview_"+id+"_Stats" ),
        mNoWebGL: document.getElementById( "Preview_"+id+"_NoWebGL" ),
        mError: document.getElementById( "Preview_"+id+"_Error" ),
        mCanvas2D: document.getElementById( "Preview_"+id+"_Thumnail" ),
        mThumbnailImg: document.getElementById( "Preview_"+id+"_ThumnailImage" ),
        mThumbnailWar1: document.getElementById( "Preview_"+id+"_ThumnailWarning1" ),
        mThumbnailWar2: document.getElementById( "Preview_"+id+"_ThumnailWarning2" ),
        mThumbnailImgNoWebGL: document.getElementById( "Preview_"+id+"_ThumnailImageNoWebGL" ),
        mMessageNoWebGL: document.getElementById( "Preview_"+id+"_MessageNoWebGL"),
        mUI: document.getElementById( "Preview_"+id+"_UI" )
        };
    }
</script>

    <style>

    #content
    {
        user-select: text;
        -moz-user-select: -moz-text;
        -webkit-user-select: text;
        padding:0px;
        margin:0px;
        position:relative;
    }

    #divUser
    {
        padding:0px;
        padding-top:24px;
        padding-bottom:16px;
        width:100%;
    }

    div#controls
    {
        width:100%;
        padding-top:16px;
        padding-bottom:16px;
        display:flex;
        justify-content:space-between; 
        flex-wrap:wrap;
    }

    div#controls > div
    {
        display:inline-flex;
    }

    .controlOptions
    {
        display:inline-block;
    }

    div#shaderGrid
    {
        width:100%;
        padding:0px;
        margin:0px;
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        grid-template-rows: repeat(2, 1fr);
        grid-column-gap: 64px;
        grid-row-gap: 16px;
    }

    .searchResult
    {
        margin: 0px;
        padding: 0px;
        width: 100%;
    }
    .searchResultContainer
    {
        width: 100%;
        padding-bottom:56.25%;
        height: 0;
        position: relative;
    }

    div#navigation
    {
        text-align: center;
        width: 100%;
    }


    #userPicture
    {
        background-color:#808080;
        border: 1px solid #000000;
        padding:0px;
        left:0px;
        top:0px;
        width:128px;
        height:128px;
    }

    a.pageButtons, .pageButtonsCurrent
    {
        
        //background-color: #303030;
        border-style: solid;
        border-width: 1px;
        border-color: #808080;
        text-align: center;
        vertical-align: middle;
        margin-left: 12px;
        display: inline-block;
        border-radius: 4px;
		font-weight:bold;
        cursor: pointer;
        padding-bottom:5px;
        padding-top:4px;
        padding-left: 8px;
        padding-right: 8px;
        margin:8px;
    }

    a.pageButtons
    {
        text-decoration: none;
        -moz-transition:    background-color 0.15s linear, color 0.15s linear;
        -webkit-transition: background-color 0.15s linear, color 0.15s linear;
        transition:         background-color 0.15s linear, color 0.15s linear;
    }

    a.pageButtons:hover
    {
      background-color:#808080;
      color : #ff8020;
    }

    .pageButtonsCurrent
    {
        background-color: #808080;
        color:#000000;
    }

    /* ----------------------- media resolutions ------------------------ */

    @media screen and (max-width:799px) 
    {
        div#shaderGrid  { grid-template-columns: 1fr; grid-template-rows: repeat(8, 1fr); grid-column-gap: 0px; grid-row-gap: 16px; padding-bottom:16px; }

        div#controls
        {
            width:100%;
            display:flex;
            justify-content:flex-start; 
            flex-wrap:wrap;
        }

        div#controls > div
        {
            display:inline-flex;
            width:100%;
            margin-left: 0px;
            margin-right: 0px;
            padding-bottom:16px;
        }
    }
    </style>

    <script>

    var gShaders=[{"ver":"0.1","info":{"id":"WscGRM","date":"1568303317","viewed":5142,"name":"Hutger Rauer (4k Intro port)","username":"spolsh","description":"Web GL port of Hutger Rauer 4K Intro released at Xenium 2019 demoparty (xenium.rocks) scoring 2nd place\nhttps:\/\/www.pouet.net\/prod.php?which=82772","likes":71,"published":3,"flags":64,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"4tX3WB","filepath":"https:\/\/soundcloud.com\/spolsh\/shxk2-hutger-raurer","previewfilepath":"https:\/\/soundcloud.com\/spolsh\/shxk2-hutger-raurer","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/*\n''''''''''''''''''''''''''''''''''''''''''''        Xenium 2019\n'''@@@@''''''''''@@@'''''@@@@@@@@@@@@@@@@'''\n'''@@@@'''''''''@@@@@'''@@@@@@@@@@@@@@@@@@''\n''@@@@@@''''''''@@@@@'''@@@@@@@@@@@@@@@@@@''  code  klos\n''@@@@@@''''''''@@@@@'''@@@@@@@@@@@@@@@@@@''        shx\n''@@@@@@''''''''@@@@@'''@@@@@@@@@@@@@@@@@@''        \n''@@@@@@''''''''@@@@@''''''''''''''''@@@@@''\n''@@@@@@''''''''@@@@@''''''''''''''''@@@@@''  music shx\n''@@@@@@''''''''@@@@@''''''''''''''''@@@@@''  \n''@@@@@@'''@@@@@@@@@@''''@@@@@@@@@@@@@@@@@''\n''@@@@@@'''@@@@@@@@@@'''@@@@@@@@@@@@@@@@@@''  gfx   klos\n''@@@@@@''@@@@@@@@@@@'''@@@@@@@@@@@@@@@@@@''  \n''@@@@@@''@@@@@@@@@@@'''@@@@@@@@@@@@@@@@@@''\n'''@@@@''''@@@@@@@@@''''@@@@@@@@@@@@@@@@@@''  >>> Hutger Rauer <<<\n''''''''''''''''''''''''''''''''''''''''''''  \n''''''''''''''''''''''''''''''''''''''''''''\n'''@@@@''''@@@@@@@@@'''''@@@@@@@@@@@@@@@@'''\n'''@@@@''''@@@@@@@@@@'''@@@@@@@@@@@@@@@@@@''  tools .crinkler\n''@@@@@@''@@@@@@@@@@@'''@@@@@@@@@@@@@@@@@@''        .4klang\n''@@@@@@''@@@@@@@@@@@'''@@@@@@@@@@@@@@@@@@''        .opengl\n''@@@@@@'''@@@@@@@@@@'''@@@@@@@@@@@@@@@@@@''        .k2yasm\n''@@@@@@''''''''@@@@@'''@@@@@'''''''''''''''\n''@@@@@@''''''''@@@@@'''@@@@@'''''''''''''''  greets\n''@@@@@@''''''''@@@@@'''@@@@@'''''''''''''''    Aberration Creations,\n''@@@@@@''''''''@@@@@'''@@@@@@@@@@@@@@@@@'''    Abyss, Adapt, Alcatraz,\n''@@@@@@''''''''@@@@@'''@@@@@@@@@@@@@@@@@@''    Altair, Brain Control,\n''@@@@@@''''''''@@@@@'''@@@@@@@@@@@@@@@@@@''    Dekadence, Desire, FHI,\n''@@@@@@''''''''@@@@@'''@@@@@@@@@@@@@@@@@@''    Fulcrum, Hprg, LJ, Nuance,\n'''@@@@'''''''''@@@@''''@@@@@@@@@@@@@@@@@@''    PVM, Rabenauge, Skyrunner,\n''''''''''''''''''''''''''''''''''''''''''''\tTitan & everybody we forgot!\n*\/\n\n#define USE_MINIMIZED\n\n\/\/ #define v iChannelTime[0]\n\/\/ #define v (mod(iTime, 109.0)) \/\/ Spotet compilation issues recently\n#define v iTime\n#define l iResolution\n\n#define PI 3.1415\n#define F gl_FragCoord\n#define O (min(iFrame,0))\n#define N normalize\n#define M(v)smoothstep(0.,1.,v)\n#define C(v)clamp(v,0.,1.)\n\n#ifdef USE_MINIMIZED\n\n    #define S float\n    #define W vec2\n    #define V vec3\n    #define I int[]\n    #define J S[]\n\n\n    int m=-1;\n\n    S i=1.,\n      x=0.,\n      y=0.,\n      z=1e+09;\n\n    V a=V(1,-1,0),\n      s=V(0,.9,0),\n      r=V(60,2,2.5),\n      e=V(1.2,.3,.1);\n\n    W \/\/ l=W(1920,1080),\n      p=W(1e+09);\n\n    mat2 n(S m)\n    {\n      S y=sin(m),\n        x=cos(m);\n      return mat2(x,y,-y,x);\n    }\n    S t(S x)\n    {\n      return x*exp(1.-x);\n    }\n    S h(W x)\n    {\n      return fract(sin(dot(x,W(12.9898,78.233)))*43758.5);\n    }\n    S w(W m)\n    {\n      W x=floor(m),\n        z=fract(m),\n         p=z*z*(3.-2.*z);\n\n      S y=h(x),\n        e=h(x+a.xz),\n        i=h(x+a.zx),\n        s=h(x+a.xx);\n\n      return mix(y,e,p.x)+(i-y)*p.y*(1.-p.x)+(s-e)*p.x*p.y;\n    }\n    S d(W x)\n    {\n      return.5*w(x)+.25*w(2.*x)+.125*w(4.*x);\n    }\n    S d(S x,S m,S z)\n    {\n      S y=C(.5+.5*(m-x)\/z);\n      return mix(m,x,y)-z*y*(1.-y);\n    }\n    S h(V x,V m,V y)\n    {\n      V p=step(m-y,x)-step(m+y,x);\n      return p.x*p.y*p.z;\n    }\n    S d(V x,V y)\n    {\n      V m=abs(x)-y;\n      return length(max(m,0.))+min(max(m.x,max(m.y,m.z)),0.);\n    }\n    S h(V m,V x)\n    {\n      S y=length(m\/x);\n      return y*(y-1.)\/length(m\/(x*x));\n    }\n    W n(W y,W x)\n    {\n      return y.x<x.x?y:x;\n    }\n    V t(V x,S m)\n    {\n      return x.xy*=n(m),x;\n    }\n    W P(V m)\n    {\n      V i=m;\n      i.z=abs(abs(i.z)-.3);\n      p.x=min(p.x,length(i-V(.87,.28,.05))-.045);\n      W y=W(p.x,5);\n      V e=m;\n      if(x<9.)\n        e.x=mod(e.x+4.,8.)-4.,e.z=mod(e.z+1.,2.)-1.,y=n(y,vec2(h(e,vec3(1.2,.6,.6)),4));\n      else\n        {\n          if(h(m,V(0,.5,0),V(2.4,1.,1.5))>.5)\n            {\n              V r=e;\n              r.xz=abs(r.xz);\n              r-=V(.6,.15,.4);\n              p.y=min(p.y,d(e-V(-.9,.3,0),V(.1,.02,.3))-.03);\n              S z=d(max(h(abs(e-V(-.2,.2,0)),V(1.3,.3,1.)),d(e-V(0,.2,0),V(1.3,.08,.34))-.1),mix(h(t(e,.2)-V(-.45,.3,0),V(.6,.2,.35)),d(t(e,.2)-V(-.45,.3,0),V(.6,.3,.35))-.1,.3)-.05,.04),s=max(length(r.xy)-.16,abs(r.z)-.11);\n              y=n(y,n(W(max(-length(r-.1*a.zzx)+.12,s),3),W(max(max(max(max(-s+.02,max(z-.04,d(s,z,.17))),-t(e,.1*PI).x-.85),-e.y+.05),-d(e-vec3(1,.28,0),vec3(.15,.04,.4))),4)));\n            }\n          V r=m-V(-12.*x+666.48,1,0);\n          r.xz*=n(8.*x);\n          mat2 z=n(.25*PI);\n          r.yz*=z;\n          r.xy*=z;\n          S s=d(r,V(.5));\n          p.y=min(p.y,s);\n          V l=m-V(-.9,-.45,0);\n          l.z=abs(l.z);\n          l-=V(-.02,0,.3-.01*cos(2.*l.x+28.*x));\n          p.y=min(p.y,d(l-V(-20,.75,-.05),V(20,.01,.06)));\n          y=n(y,W(p.y,4));\n        }\n      m.x+=12.*x;\n      V r=m;\n      r.z=abs(r.z);\n      r.x=mod(r.x+1.5,3.)-1.5;\n      y=n(y,W(min(d(r-V(0,-.095,.7),V(.5,.1,.06)),d(r-V(0,-.095,2.1),V(1.5,.1,.06))),6));\n      if(abs(m.z)>2.)\n        y=n(y,W(m.y-d(m.xz)*.2*M((abs(m.z)-2.2)\/.4)-d(m.xz*.1)*4.*M((abs(m.z)-2.6)\/7.4)*M((x-18.)\/10.),2));\n      return y;\n    }\n    W P(V x,V y,V z)\n    {\n      V m=1.\/y,e=m*x,\n        s=abs(m)*z,\n        p=-e-s,\n        r=-e+s;\n      return W(max(max(p.x,p.y),p.z),min(min(r.x,r.y),r.z));\n    }\n    W P(V m,V x)\n    {\n      if(i>.5)\n        r.yz=W(4,30);\n      W y=W(1e+09,-1),\n        p=P(m-s,x,r),\n        e;\n      S z=.1,\n        a=90.,\n        l=-m.y\/x.y,\n        d;\n\n      if(l>0.)\n        a=min(a,l),\n        y=W(l,0);\n\n      if(p.x<p.y&&p.y>0.&&p.x<a)\n        {\n          d=z=max(p.x,z);\n          if(i<.5)\n            y=n(y,W(p.y,1));\n          for(int o=O;o<128&&d<min(p.y,a);o++)\n            {\n              e=P(m+x*d);\n              if(e.x<.0001*d)\n                {\n                  y=W(d,e.y);\n                  break;\n                }\n              d+=e.x;\n            }\n        }\n      return y;\n    }\n    V g(V x)\n    {\n      W m=W(1,-1)*.002;\n      return N(m.xyy*P(x+m.xyy).x+m.yyx*P(x+m.yyx).x+m.yxy*P(x+m.yxy).x+m.xxx*P(x+m.xxx).x);\n    }\n    V g(V m,V x)\n    {\n      S y=1.-abs(atan(m.z,m.x)\/2.*PI);\n      return mix(mix(.1*a.zzx*max(5.*m.y+.3,0.)+(.2*M((y-.9)\/.1)*(e-.2)+2.*M((y-.99)\/.01)*e)*(10.*max(0.,m.y)),V(0),step(m.y,.03*d(-20.*m.xz)))+.5*pow(max(0.,m.y),8.)*e,.01*e,step(m.y,.07*d(-10.*m.xz)));\n    }\n    I c=I(12,-1,13,-1,0,1,2,3,4,5,6,7,8,0,10,11,9,4,3,14,5,6,4,3,7,-1);\n    J o=J(3.,5.,6.,7.,9.,11.,16.,21.85,26.,27.,27.9,32.,40.,54.,54.5,55.,55.5,66.,67.,74.,82.,83.,90.,91.,96.,106.),\n      u=J(2.,4.,1.2,-2.,20.,20.,2.5,0.,-7.,4.,12.,20.,30.,40.,-2.),\n      b=J(.1,.2,1.,1.2,.2,2.2,1.5,30.,1.5,1.2,.2,1.,1.,5.,1.2),\n      k=J(-.3,-.1,-8.,-1.5,-1.5,.7,3.,2.,1.5,-3.5,-.1,-6.,-4.,-.3,0.),\n      Z=J(20.,0.,1.7,1.,0.,0.,.7,4.,5.,0.,0.,0.,30.,43.,1.),\n      Y=J(0.,-.2,-.2,-.5,-50.,-50.,-.1,-8.,-.5,-.05,-25.,-50.,-25.,-30.,-.3),\n      X=J(-5.,0.,-.3,-.2,0.,0.,-.1,-1.,.5,-.05,0.,0.,-25.,-30.2,-.1);\n\n    void mainImage(out vec4 f, in vec2 fragCoord)\n    {   \n      f = a.zzzx;\n\n      W r=(-l.xy+2.*F.xy)\/l.y,\n        w=F.xy\/l.xy,\n        U;\n\n      if(abs(r.y)>.74) return;\n\n      \/\/ x=S(v)\/44100.+h(F.xy)*.04;  \n      x=v+h(F.xy)*.04; \n\n      if (iMouse.xy==vec2(0) && iFrame==0) \/\/ miniature\n        x=88.+h(F.xy)*.04;\n\n      i=x>55.5&&x<91.?0.:1.;  \n      V T=V(0.,.1,0),R,Q,L,K,H,G,E,D;\n      R=Q=L=K=H=G=E=D=V(0);\n      for(int B=O;B<o.length();++B)\n        {\n          if(x>=o[B])\n            {\n              y=x-o[B];\n              m=c[B];\n              if(m>=0)\n                R=V(u[m],b[m],k[m]),T.x=Z[m],Q.x=Y[m],L.x=X[m];\n            }\n        }\n      if(m==-1)\n        return;\n      R+=Q*y;\n      T+=L*y;\n      R.y+=.01*h(a.xx*100.*x);\n      r+=4.*dot(r,r)*h(F.xy+x)\/l.xy;\n      V B=N(T-R),\n        A=N(cross(B,a.zxz)),\n        q=cross(A,B),\n        j=mat3(A,q,B)*N(V(r,4)),\n        ab=g(j,R),\n        ac=V(1),\n        ad=V(2,.5,0);\n\n      p=a.xx*1e+09;\n      for(int ae=O;ae<3;++ae)\n        {\n          U=P(R,j);\n          if(ae==0)\n            z=U.x;\n          if(U.y<0.)\n            {\n              K+=g(j,R)*ac;\n              break;\n            }\n          H=R+U.x*j;\n          G=U.y<1.5?U.y<.5?a.zxz:V(0,N(s.yz-H.yz)):g(H);\n          W af=M((abs(fract(1.5*H.yz+.5)*2.-1.)-.1)\/.02),\n            ag=M((abs(fract(1.5*H.yz+.5)*2.-1.)-.05)\/.05);\n          S ah=pow(dot(G,j)+1.,.2),\n            ai=exp2(min(0.,P(H+G*.07).x\/.07-1.))*exp2(min(0.,P(H+G*.15).x\/.15-1.))*exp2(min(0.,P(H+G*.3).x\/.3-1.)),\n            aj=pow(t(10.*fract(.92*x)),8.),ak=1.-C(floor(2.*fract(.1*(H.x+12.*x)))),\n            al=1.-min(af.x,af.y),am=1.-min(ag.x,ag.y);\t\t\n          E=V(.1);\n          if(U.y==0.)\n            E*=.1*d((H.xz+12.*a.xz*x)*W(4,80)),ah*=.1;\n          D=(ai+80.*V(0,.5,1)\/pow(length(ad-H),.1)*M(dot(N(ad-H),-N(V(1,-5,0)))-.1\/1.5))*E;\n          if(U.y==1.)\n            H.yz*=n(.2*floor(5.*x)*step(60.,x)),D+=2.-2.*C(floor(10.*fract(.05*(H.x+12.*x))))+5.*ak*(aj*al*step(60.,x)+am*step(70.,x))*mix(V(1),\n            am*mix(e.zyx,a.xzz,ak),M((x-75.)\/5.));\n          if(U.y==4.)\n            D+=e*pow(max(0.,G.y),3.)*M(d(600.*H.xz)*4.-2.);\n          K+=(1.-ah)*D*ac;\n          ac*=ah;\n          j=reflect(j,G);\n          R=H+.001*j;\n        }\n      p=.5*exp(-p*10.);\n      w*=1.-w.yx;\n      f=vec4(pow((mix(mix(ab,K+e.zyx*p.x+e*p.y,exp(-.001*z*z)),e,.02*(1.-exp(-.001*z*z)))+V(t(max(0.,10.*(x-55.5))))+V(t(max(0.,10.*(x-91.)))))*pow(w.x*w.y*15.,.5),V(.4545)),1.);\n    }\n\n#else \/\/ USE_MINIMIZED\n\n    int tid = -1;\n\n    float gOpen\t= 1.,\n          gTime\t= 0.,\n          tdiff = 0.,\n          tt\t= 10e8;\n\n    vec3  r\t\t\t  \t= vec3(  1, -1, 0  ),\n          gBoundsPos  \t= vec3(  0, .9, 0  ),\n          gBoundsSize \t= vec3( 60,  2, 2.5),\n          LINE_COLOR  \t= vec3( 1.2, .3, .1);\n\n    vec2 \/\/ R\t\t\t= vec2(1920, 1080),\n         gBloom\t\t= vec2(10e8);\n\n    mat2 rot(float a)\n    {\n        float s = sin(a),\n          c = cos(a);\n        return mat2(c, s, -s, c);\n    }\n\n    float impulse(float k)\n    {\n        return k * exp(1. - k);\n    }\n\n    float hash(vec2 p)\n    {\n        return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453123);\n    }\n\n    float noise(vec2 p)\n    {\n        vec2 i = floor(p),\n             f = fract(p), \n             u = f * f * (3. - 2. * f);\n\n        float a = hash(i), \n              b = hash(i + r.xz),\n              c = hash(i + r.zx),\n              d = hash(i + r.xx);  \n\n        return mix(a, b, u.x) +\n                (c - a) * u.y * (1. - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    float fbm(vec2 x)\n    {\n        return + .5   * noise(     x)\n               + .25  * noise(2. * x)\n               + .125 * noise(4. * x);\n    }\n\n    float smin(float a, float b, float k)\n    {\n        float h = C(.5+.5*(b - a) \/ k);\n        return mix(b, a, h) - k * h * (1. - h);\n    }\n\n    float insideBox3D(vec3 p, vec3 center, vec3 size)\n    {\n        vec3 s = step(center - size, p) - step(center + size, p);\n        return s.x * s.y * s.z;\n    }\n\n    float sdBox(vec3 p, vec3 b)\n    {\n        vec3 d = abs(p) - b;\n        return length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.);\n    }\n\n    float sdEll(vec3 p, vec3 r)\n    {\n        float k0 = length(p \/ r);\n        return k0 * (k0 - 1.) \/ length(p \/ (r * r));\n    }\n\n    vec2 opU(vec2 d1, vec2 d2)\n    {\n        return d1.x < d2.x ? d1 : d2;\n    }\n\n    vec3 rotXY(vec3 p, float a)\n    {\n        p.xy *= rot(a);\n        return p;\n    }\n\n    vec2 map(vec3 pos)\n    {\n        \/\/ car light\n        vec3 pR = pos;\n        pR.z = abs(abs(pR.z) - 0.3);\n        gBloom.x = min(gBloom.x, length(pR - vec3(.87, 0.28, 0.05)) - .045);\n        vec2 res = vec2(gBloom.x, 5);\n\n        vec3 pC = pos;\n        if (gTime < 9.) \/\/ gTStart\n        {\n            pC.x = mod(pC.x + 4.0, 8.0) - 4.0;\n            pC.z = mod(pC.z + 1.0, 2.0) - 1.0;\n            res = opU(res, vec2(sdEll(pC, vec3(1.2, .6, .6)), 4));\n        }\n        else\n        {\n            if (insideBox3D(pos, vec3(0, .5, 0), vec3(2.4, 1., 1.5)) > .5)\n            {\n                vec3 pW = pC;\n\n                pW.xz = abs(pW.xz);\n                pW -= vec3(.6, .15, .4);\n\n                gBloom.y = min(gBloom.y, sdBox(pC - vec3(-0.9, 0.3, 0), vec3(0.1, 0.02, 0.3)) - 0.03);\n\n                float sBody0 = smin(\n                                max(\n                                    sdEll(abs(pC - vec3(-0.2, 0.2, 0)), vec3(1.3, 0.3, 1.)),\n                                    sdBox(pC - vec3(0, 0.2, 0), vec3(1.3, 0.08, 0.34)) - .1\n                                ), mix(\n                                    sdEll(rotXY(pC, 0.2) - vec3(-0.45, 0.3, 0), vec3(0.6, 0.2, 0.35)),\n                                    sdBox(rotXY(pC, 0.2) - vec3(-0.45, 0.3, 0), vec3(0.6, 0.3, 0.35)) - .1,\n                                    0.3) - 0.05,\n                            0.04),\n                    sWheels0 = max(length(pW.xy) - 0.16, abs(pW.z) - 0.11);\n\n                res = opU( \n                        res,\n                        opU(\n                            vec2( max(-length(pW - .1 * r.zzx) + .12, sWheels0), 3),\n                            vec2( max(\n                                    max(\n                                        max(\n                                            max(\n                                                -sWheels0 + .02,\n                                                max(\n                                                    sBody0 - .04, \n                                                    smin(sWheels0, sBody0, .17)\n                                                )\n                                            ),\n                                        -rotXY(pC, .1 * PI).x - .85),\n                                        -pC.y + .05\n                                    ),\n                                    -sdBox(pC -vec3(1, .28, 0), vec3(.15, .04, .4))\n                                ),\n                                4\n                            )\n                        )\n                    );\n            }\n\n            \/\/ orb\n            vec3 pB = pos - vec3(-12. * gTime + 666.48, 1, 0); \/\/ gTTunel\n            pB.xz *= rot(8. * gTime);\n            mat2 r2 = rot(.25 * PI);\n            pB.yz *= r2;\n            pB.xy *= r2;\n            float box0 = sdBox(pB, vec3(.5));\n            gBloom.y = min(gBloom.y, box0);\n\n            \/\/ trail\n            vec3 pT = pos - vec3(-.9, -.45, 0);\n            pT.z = abs(pT.z);\n            pT -= vec3(-.02, 0, .3 -.01 * cos( 2.*pT.x+28.*gTime ));\n            gBloom.y = min(gBloom.y, sdBox(pT - vec3(-20, .75, -.05), vec3(20, .01, .06)));\n            res = opU(res, vec2(gBloom.y, 4));\n        }\n\n        pos.x += 12. * gTime;\n        \/\/ lanes\n        vec3 pL = pos;\n        pL.z = abs(pL.z);\n        pL.x = mod(pL.x + 1.5, 3.) - 1.5;\n        res = opU(res, vec2(\n                min(sdBox(pL - vec3(0, -.095,  .7), vec3( .5, .1, .06)),\n                    sdBox(pL - vec3(0, -.095, 2.1), vec3(1.5, .1, .06))),\n                 6));\n\n        \/\/ ground\n        if (abs(pos.z) > 2.)\n        {\n            res = opU(res, vec2(\n                        pos.y\n                        - fbm(pos.xz     ) *  .2 * M((abs(pos.z) - 2.2) \/  .4)\n                        - fbm(pos.xz * .1) * 4.  * M((abs(pos.z) - 2.6) \/ 7.4) * M((gTime - 18.)\/10.),\n                        2));\n        }\n\n        return res;\n    }\n\n    vec2 iBox(vec3 ro, vec3 rd, vec3 rad)\n    {\n        vec3 m = 1. \/ rd,\n          n = m * ro,\n          k = abs(m) * rad,\n          t1 = -n - k,\n          t2 = -n + k;\n        return vec2(max(max(t1.x, t1.y), t1.z),\n                 min(min(t2.x, t2.y), t2.z));\n    }\n\n    vec2 castRay(vec3 ro, vec3 rd)\n    {\n        if (gOpen > .5)\n            gBoundsSize.yz = vec2(4, 30);\n\n        vec2 res = vec2(10e8, -1),\n             tb = iBox(ro - gBoundsPos, rd, gBoundsSize),\n             h;\n\n        float tmin =  .1,\n              tmax = 90.,\n              tp1 = -ro.y \/ rd.y,\n              t;\n\n        \/\/ raytrace floor plane\n        if (tp1 > 0.)\n        {\n            tmax = min(tmax, tp1);\n            res = vec2(tp1, 0);\n        }    \n\n        \/\/ raymarch primitives   \n        if (tb.x < tb.y && tb.y > 0. && tb.x < tmax)\n        {\n            t = tmin = max(tb.x, tmin);\n            if (gOpen < .5)\n                res = opU(res, vec2(tb.y, 1));\n\n            for (int i = O; i < 128 && t < min(tb.y, tmax); i++)\n            {\n                h = map(ro + rd * t);\n                if (h.x < (.0001 * t))\n                {\n                    res = vec2(t, h.y);\n                    break;\n                }\n                t += h.x;\n            }\n        }\n\n        return res;\n    }\n\n    vec3 calcNormal(vec3 pos)\n    { \/\/ https:\/\/iquilezles.org\/articles\/normalsSDF\n       vec2 e = vec2(1, -1) * .002;\n       return N(e.xyy * map(pos + e.xyy).x +\n                e.yyx * map(pos + e.yyx).x +\n                e.yxy * map(pos + e.yxy).x +\n                e.xxx * map(pos + e.xxx).x);\n    }\n\n    vec3 sky(vec3 rd, vec3 ro)\n    {    \n        float angle = 1. - abs(atan(rd.z, rd.x) \/ 2. * PI);\n        return mix(\n                mix(\n                        .1 * r.zzx * max(5. * rd.y + .3, 0.)\t\t\t\t\t\t\t\t\/\/ bg\n                            + (    .2 * M((angle - .9 )\/.1 ) * (LINE_COLOR - .2)\t\t\t\/\/ line glow\n                                + 2.  * M((angle - .99)\/.01) *  LINE_COLOR      )\t\t\t\/\/ line\n                                * (10. * max(0., rd.y)),\t\t\t\t\t\t\t\t\t\/\/ line scale and bottom up gradient\n                        vec3(0),\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\/\/ distant mountains shape color\n                        step(rd.y, .03 * fbm(-20. * rd.xz))\t\t\t\t\t\t\t\t    \/\/ distant mountains shape\n                    ) \n                    + .5 * pow(max(0., rd.y), 8.) * LINE_COLOR,\t\t\t\t\t\t\t\t\/\/ dome light\n                .01 * LINE_COLOR,\n                step(rd.y, .07*fbm(-10.*rd.xz))\n            );\n    }\n\n    \/\/             \t\t       0,    1,    2,    3,    4,    5,    6,    7,    8,    9,    10,   11,   12,   13,    14,   15,   16,   17,   18,   19,   20,   21,   22,\t  23,   24,    25\n    int[] \ttids = int[](     12,   -1,   13,   -1,    0,    1,    2,    3,    4,    5,     6,    7,    8,    0,    10,   11,    9,    4,    3,   14,    5,    6,    4,    3,    7,   -1);\n    float[] time = float[](  3.0,  5.0,  6.0,  7.0,  9.0, 11.0, 16.0, 21.85, 26.0, 27.0,  27.9, 32.0, 40.0, 54.0,  54.5, 55.0, 55.5, 66.0, 67.0, 74.0, 82.0, 83.0, 90.0, 91.0, 96.0, 106.), \/\/ 100.0\n            rox  = float[](  2.0,  4.0,  1.2, -2.0, 20.0, 20.0,  2.5,  0.0, -7.0,  4.0,  12.0, 20.0, 30.0, 40.0, -2.0),\n            roy  = float[](  0.1,  0.2,  1.0,  1.2,  0.2,  2.2,  1.5, 30.0,  1.5,  1.2,   0.2,  1.0,  1.0,  5.0,  1.2),\n            roz  = float[]( -0.3, -0.1, -8.0, -1.5, -1.5,  0.7,  3.0,  2.0,  1.5, -3.5,  -0.1, -6.0, -4.0, -0.3,  0.0),\n            tax  = float[]( 20.0,  0.0,  1.7,  1.0,  0.0,  0.0,  0.7,  4.0,  5.0,  0.0,   0.0,  0.0, 30.0, 43.0,  1.0),\n            roxm = float[](  0.0, -0.2, -0.2, -0.5,-50.0,-50.0, -0.1, -8.0, -0.5, -0.05,-25.0,-50.0,-25.0,-30.0, -0.3),\n            taxm = float[]( -5.0,  0.0, -0.3, -0.2,  0.0,  0.0, -0.1, -1.0,  0.5, -0.05,  0.0,  0.0,-25.0,-30.2, -0.1);\n    \/\/                         0,    1,    2,    3,    4,    5,    6,    7,    8,    9,    10,   11,   12,   13,    14,   15,   16,   17,   18,   19,   20,   21,   22,\t  23,   24,    25\n\n    \/\/ void main()\n    void mainImage(out vec4 f, in vec2 fragCoord)\n    {\n        vec2 p = (-l.xy + 2. * F.xy) \/ l.y;\n        vec2 q = F.xy \/ l.xy;\n        vec2 res;\n\n        if (abs(p.y) > 0.74) return;\n\n        gTime = v + (hash(F.xy)*.04);\n        gOpen = gTime > 55.5 && gTime < 91. ? 0.0 : 1.0; \/\/ gTTunel, gTEnd\n\n        vec3 ta = vec3(0.,.1,0),\n          ro, rom, tam,  col,  pos,  nor,  alb,  rad;\n        ro = rom = tam = col = pos = nor = alb = rad = vec3(0);\n\n        for (int ti = O; ti < time.length(); ++ti)\n        {\n            if (gTime >= time[ti])\n            {\n                tdiff = gTime - time[ti];\n                tid = tids[ti];\n                if (tid >= 0)\n                {\n                    ro = vec3(rox[tid], roy[tid], roz[tid]);\n                    ta.x = tax[tid];\n                    rom.x = roxm[tid];\n                    tam.x = taxm[tid];\n                }\n            }\n        }\n        if (tid == -1) return;\n        ro += rom * tdiff;\n        ta += tam * tdiff;\n        ro.y += 0.01 * hash(r.xx * 100. * gTime);\n        p += 4.*dot(p,p)*(hash(F.xy+gTime))\/l.xy;\n\n        vec3 cw = N(ta - ro);\n        vec3 cu = N(cross(cw, r.zxz));\n        vec3 cv = cross(cu, cw);\n        vec3 rd = mat3(cu, cv, cw) * N(vec3(p, 4));\n        vec3 bg = sky(rd, ro);\n        vec3 tint = vec3(1);\n        vec3 pSpot = vec3(2, .5, 0);\n\n        gBloom = r.xx*10e8;\n        for (int bi = O; bi < 3; ++bi)\n        {\n            res = castRay(ro, rd);\n\n            if (bi == 0)\n            {\n                tt = res.x;\n            }\n\n            if (res.y < .0)\n            {\n                col += sky(rd, ro) * tint;\n                break;\n            }\n\n            pos = ro + res.x * rd;\n            nor = (res.y < 1.5)\n                ? (res.y < 0.5)\n                    ? r.zxz\n                    : vec3(0, N(gBoundsPos.yz - pos.yz))\n                : calcNormal(pos);\n\n            vec2 str0 = M( ( abs(fract(1.5*pos.yz+0.5)*2.-1.) -.1 ) \/.02 );\n            vec2 str1 = M( ( abs(fract(1.5*pos.yz+0.5)*2.-1.) -.05) \/.05 );\n\n            float fre = pow(dot(nor, rd) + 1., .2),\n              ao = 1. \n                * exp2(min(0., map(pos + nor * .07).x \/ .07 - 1.))\n                * exp2(min(0., map(pos + nor * .15).x \/ .15 - 1.))\n                * exp2(min(0., map(pos + nor * .3 ).x \/ .3  - 1.)),\n              imp = pow( impulse(10.*fract(.92*gTime)), 8.),\n              frames1 = 1. - C( floor(2. * fract(.1 *(pos.x + 12.*gTime)) ) ),\t\t\/\/ frames\n              stripes0 = 1. - min(str0.x, str0.y),\t\t\t\t\t\t\t\t\t\/\/ blinking stripes\n              stripes1 = 1. - min(str1.x, str1.y);\t\t\t\t\t\t\t\t\t\/\/ blinking stripes              \n\n            alb = vec3(.1);\n            if (res.y == 0.)\n            {\n                alb *= .1 * fbm((pos.xz + 12. * r.xz * gTime) * vec2(4, 80));\n                fre *= .1;\n            }\n\n            rad = (ao\n                 + 80.\n                    * vec3(0, .5, 1)\n                    * 1. \/ pow( length(pSpot - pos), 0.1)\n                    * M( dot( N(pSpot - pos), -N(vec3(1, -5, 0)) ) -.1 \/ 1.5)\n                  ) * alb;\n\n            if (res.y == 1.0)\n            {\n                pos.yz *= rot(0.2*floor(5.0*gTime) * step(60.0, gTime));\n\n                rad +=  2. -2.*C( floor(10.* fract(.05*(pos.x + 12.*gTime)) ) )\n                        + 5. * frames1 * (  imp * stripes0 * step(60., gTime)\n                                +                 stripes1 * step(70., gTime))\n                        * mix(vec3(1), stripes1 * mix(LINE_COLOR.bgr, r.xzz, frames1), M( (gTime-75.) \/ 5.) );\n            }\n\n            if (res.y == 4.)        \n                rad += LINE_COLOR * pow(max(0.,nor.y), 3.) * M( fbm(600.*pos.xz)*4.-2. );\n\n            col += (1. - fre) * rad * tint;\n            tint *= fre;\n\n            rd = reflect(rd, nor);\n            ro = pos + .001 * rd;\n        }\n\n        gBloom = .5 * exp(-gBloom * 10.);\n        q *= 1. - q.yx;\n\n        f = vec4(pow(\t\t\t\t\t\t\t\t\t\t\t\t\/\/ gamma start\n            (\t\n                mix(\t\t\t\t\t\t\t\t\t\t\t\t\/\/ air red fog\n                    mix(\t\t\t\t\t\t\t\t\t\t\t\/\/ horizon blend blue fog\n                        bg,\n                        col\n                        + LINE_COLOR.bgr * gBloom.x\t\t\t\t\t\/\/ bloom red\n                        + LINE_COLOR     * gBloom.y,\t\t\t\t\/\/ bloom blue\n                        exp(-.001 * tt * tt)\n                    ),\n                    LINE_COLOR,\n                    .02 * (1. - exp(-.001 * tt * tt))\n                )\t\t\t\t\t\t\t\t\t\t\n                + vec3(impulse(max(0., 10. * (gTime - 55.5) )))\t\t\/\/ collision flash\n                + vec3(impulse(max(0., 10. * (gTime - 91. ) )))\t\t\/\/ tunnel leave flash\n            )\n             * pow(q.x * q.y * 15., .5),\t\t\t\t\t\t\t\/\/ vignette\n            vec3(.4545)), 1.);\t\t\t\t\t\t\t\t\t\t\/\/ gamma end\n    }\n\n#endif \/\/ USE_MINIMIZED","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"wtS3W3","date":"1561330954","viewed":4915,"name":"Sunset Drive Unlimited","username":"spolsh","description":"Retro futuristic game and animation. Started at jam and polished during couple of spare evening. Details in shader code headers.\nPlease post your high scores :) Enjoy!","likes":154,"published":3,"flags":112,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"\/media\/previz\/buffer03.png","previewfilepath":"\/media\/previz\/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Mll3z2","filepath":"https:\/\/soundcloud.com\/rombo_rama\/lifelike-so-electric","previewfilepath":"https:\/\/soundcloud.com\/rombo_rama\/lifelike-so-electric","type":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Copyright \u00a9 2019 Michal Klos\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ Sunset Drive Unlimited\n\/\/  Endless runner with synthwave stylization\n\/\/\t\"Brick Driver\" sequel, because it missed fluent turning and coins:\n\/\/\thttps:\/\/www.shadertoy.com\/view\/wssSD4\n\n\/\/ #define options in Common tab\n\/\/  Some effects can be disabled on low end gpus\n\n\/\/ Gameplay is based on Brick Game Racing,\n\/\/  https:\/\/youtu.be\/EdMyKRC8qyU\n\n\/\/ First draft created in 24h on Game Jam Square 26-28.04.2019\n\/\/\tFinished after couple of spare evenings on 24.06.2019\n\n\/\/ Based on:\n\/\/ - \"80's raymarching\" by villedieumorgan. https:\/\/shadertoy.com\/view\/lsVSRt\n\/\/ - \"[SH16B] Speed Drive 80\" by knarkowicz. https:\/\/shadertoy.com\/view\/4ldGz4\n\/\/ Other snippets credits in comments next to the code\n\/\/ Thank you guys for sharing it, hope you like it :)\n\n\/\/ Music: Lifelike - So Electric\n\/\/  https:\/\/soundcloud.com\/rombo_rama\/lifelike-so-electric\n\n\nvec3 fxaa( vec3 color )\n{\n\t\/\/ FXAA implementation by mudlord (I think?)\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n\tvec2 pp = 1.0 \/ R.xy;\n    float lumaNW = dot(texture(iChannel0, (F.xy + vec2(-1.0, -1.0)) * pp).xyz, luma);\n    float lumaNE = dot(texture(iChannel0, (F.xy + vec2(1.0, -1.0)) * pp).xyz, luma);\n    float lumaSW = dot(texture(iChannel0, (F.xy + vec2(-1.0, 1.0)) * pp).xyz, luma);\n    float lumaSE = dot(texture(iChannel0, (F.xy + vec2(1.0, 1.0)) * pp).xyz, luma);\n    float lumaM  = dot(color.xyz,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir = vec2(-((lumaNW + lumaNE) - (lumaSW + lumaSE)), ((lumaNW + lumaSW) - (lumaNE + lumaSE)));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * (1.0\/8.0)), (1.0\/128.0));\n\n    float rcpDirMin = 2.5 \/ (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(8.0, 8.0),\n              max(vec2(-8.0, -8.0),\n              dir * rcpDirMin)) * pp;\n\n    vec3 rgbA = 0.5 * (\n        texture(iChannel0, F.xy * pp + dir * (1.0 \/ 3.0 - 0.5)).xyz +\n        texture(iChannel0, F.xy * pp + dir * (2.0 \/ 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n        texture(iChannel0, F.xy * pp + dir * -0.5).xyz +\n        texture(iChannel0, F.xy * pp + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax)){\n        return rgbA;\n    } else {\n        return rgbB;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4( 0.0 );\n\t\n\tvec2 uv = F.xy \/ R.xy;\n    vec2 q = 1.0 - 2.0 * uv;\n    q.x *= R.x \/ R.y;\n\n#ifdef FORCED_RATIO\n    float bars = step( abs( q.y ) * g_forceRatio, R.x \/ R.y );\n    if ( bars < 0.5 ) return;\t\n#endif \/\/ FORCED_RATIO\n       \n    fragColor = texture( iChannel0, vec2( uv ) );\n\n#ifdef FXAA\t\n\tfragColor.rgb = fxaa( fragColor.rgb );\n#endif\n\n#ifdef NOISE\n    fragColor.rgb *= 0.8 + 0.2 * hash22( 1000.0 * ( F.xy \/ R.xy + fract( iTime ) ) ).x;\n#endif\n\n#ifdef FPS_COUNTER    \n    vec2 h = F.xy \/ R.xy;\n    h.x *= R.x \/ R.y;\n    fragColor.rgb += printInt( ( h -vec2( 0.0, 0.21 ) ) * 30.0, iFrameRate );\n#endif \n\n    \/\/ gamma\n\tfragColor.rgb = pow( fragColor.rgb, vec3( 0.4545 ) );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"\/presets\/tex00.jpg","previewfilepath":"\/presets\/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ Copyright \u00a9 2019 Michal Klos\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ Sunset Drive Unlimited\n\/\/  Endless runner with synthwave stylization\n\/\/\t\"Brick Driver\" sequel, because it missed fluent turning and coins:\n\/\/\thttps:\/\/www.shadertoy.com\/view\/wssSD4\n\n\/\/ #define options in Common tab\n\/\/  Some effects can be disabled on low end gpus\n\n\/\/ Gameplay is based on Brick Game Racing,\n\/\/  https:\/\/youtu.be\/EdMyKRC8qyU\n\n\/\/ First draft created in 24h on Game Jam Square 26-28.04.2019\n\/\/\tFinished after couple of spare evenings on 24.06.2019\n\n\/\/ Based on:\n\/\/ - \"80's raymarching\" by villedieumorgan. https:\/\/shadertoy.com\/view\/lsVSRt\n\/\/ - \"[SH16B] Speed Drive 80\" by knarkowicz. https:\/\/shadertoy.com\/view\/4ldGz4\n\/\/ Other snippets credits in comments next to the code\n\/\/ Thank you guys for sharing it, hope you like it :)\n\n\/\/ Music: Lifelike - So Electric\n\/\/  https:\/\/soundcloud.com\/rombo_rama\/lifelike-so-electric\n\n\n\nAppState updateGame( AppState s, float isDemo )\n{\n    if ( isDemo > 0.0 )\n    {\n        s.timeAccumulated += 1.0 * iTimeDelta;\n    \ts.playerPos.y = 5.0 * s.timeAccumulated;\n    }\n    else\n    {\n        float playerCellID = floor( s.playerPos.y );\n        s.paceScale = saturate( ( playerCellID - 50.0) \/ 500.0);\n        float timeMultiplier = mix( 0.75, 2.0, pow( s.paceScale, 1.0 ) );\n\n        s.timeAccumulated += timeMultiplier * iTimeDelta;\n        s.playerPos.y = 5.0 * s.timeAccumulated;\n    }    \n    \n    float playerCellID = floor( s.playerPos.y );\n\n    if ( isDemo > 0.0 )\n    {           \n        float cellOffset = 1.0;\n        float nextPlayerCellID = playerCellID + cellOffset;\n\n        float nextCellCoinRND = hash11( nextPlayerCellID + s.seed ); \/\/ skip rnd obstacle every second cell to make room for driving\n        nextCellCoinRND *= mix( 1.0, -1.0, step( mod( nextPlayerCellID, 4.0 ), 1.5 ) ); \/\/ gaps in coin placing: 2 gaps, 2 coins\n        nextCellCoinRND = mix( nextCellCoinRND, -1.0, step( nextPlayerCellID, 5.0 ) ); \/\/ head start\n        float nextCellCoinCol = floor( 3.0 * nextCellCoinRND );\n\n        \/\/ OBSTACLE\n        float nextCellObsRND = hash11( 100.0 * nextPlayerCellID + s.seed );\n        nextCellObsRND *= mix( 1.0, -1.0, step( mod( nextPlayerCellID, 3.0 ), 1.5 ) );\n        nextCellObsRND = mix( nextCellObsRND, -1.0, step( nextPlayerCellID, 7.0 ) ); \/\/ head start\n        float nextCellObsCol = floor( 3.0 * nextCellObsRND );\n        \n        float inputObs = 0.0;                \n        if ( nextCellObsCol > -0.5 )\n        {\n            nextCellCoinCol -= 0.5; \/\/ pos fix\n        \tfloat toObs = nextCellObsCol - s.playerPos.x;\n        \n            if ( nextCellObsCol == 1.0 )\n                inputObs = hash11( nextPlayerCellID + s.seed );\n            \n            if ( nextCellObsCol < 1.0 )\n                inputObs = 1.0;\n\n            if ( nextCellObsCol > 1.0 )\n                inputObs = -1.0;\n        }\n        \n        \n        float inputCoin = 0.0;\n        if ( nextCellCoinCol > -0.5 )\n        {               \n            nextCellCoinCol -= 0.5; \/\/ pos fix\n            float toCoin = nextCellCoinCol - s.playerPos.x;\n            \n\t\t\tinputCoin = sign(toCoin) * saturate( abs( toCoin ) );\n        }\n\n        float inputDir = inputCoin + 5.0 * inputObs;\n        inputDir = sign( inputDir ) * 4.0 * saturate( abs( inputDir ) );\n        \n        s.isPressedLeft  = step( 0.5, -inputDir );\n        s.isPressedRight = step( 0.5,  inputDir );\n    }\n\n    float speed = mix( 0.1, 0.15, isDemo );\n    s.playerPos.x -= speed * s.isPressedLeft; \n    s.playerPos.x += speed * s.isPressedRight; \n\n    s.playerPos.x = clamp( s.playerPos.x, -0.5, 1.5 );\n\n    if ( playerCellID != s.coin0Pos ) \n    {\n        s.coin3Pos \t = s.coin2Pos;\n        s.coin3Taken = s.coin2Taken;\n\n        s.coin2Pos \t = s.coin1Pos;\n        s.coin2Taken = s.coin1Taken;\n\n        s.coin1Pos \t = s.coin0Pos;\n        s.coin1Taken = s.coin0Taken;\n\n        s.coin0Pos = playerCellID;\n        s.coin0Taken = 0.0;\n    }\n \n    \/\/ COIN start\n    float cellCoinRND = hash11( playerCellID + s.seed ); \/\/ skip rnd obstacle every second cell to make room for driving\n    cellCoinRND *= mix( 1.0, -1.0, step( mod( playerCellID, 4.0 ), 1.5 ) ); \/\/ gaps in coin placing: 2 gaps, 2 coins\n    cellCoinRND = mix( cellCoinRND, -1.0, step( playerCellID, 5.0 ) ); \/\/ head start\n    float cellCoinCol = floor( 3.0 * cellCoinRND );\n\n    vec2 coinPos = -vec2( 0.0, playerCellID )\t\/\/ cell pos\n        +vec2( 0.5, -0.5 )\t\/\/ move to cell center\n        -vec2( cellCoinCol, 0.0 ); \/\/ move to column\n\n    if ( cellCoinRND >= 0.0 )\n    {        \n        float distCoinPlayer = length( coinPos + s.playerPos );\n\n        if ( distCoinPlayer < 0.5 && s.coin0Taken < 0.5 )\n        {\n            if ( isDemo < 1.0 )\n            \ts.score++;\n            \n            s.coin0Taken = 1.0;\n            s.timeCollected = iTime;\n        }\n    }\n    \/\/ COIN end\n\n    \/\/ OBSTACLE start\n    float cellObsRND = hash11( 100.0 * playerCellID + s.seed );\n    cellObsRND *= mix( 1.0, -1.0, step( mod( playerCellID, 3.0 ), 1.5 ) );\n    cellObsRND = mix( cellObsRND, -1.0, step( playerCellID, 7.0 ) ); \/\/ head start\n    float cellObsCol = floor( 3.0 * cellObsRND );\n\n    if ( cellObsRND >= 0.0 && cellObsCol != cellCoinCol )\n    {   \n        vec2 obstaclePos = -vec2( 0.0, playerCellID )\t\/\/ cell pos\n            +vec2( 0.5, -0.25 )\t\/\/ move to cell center\n            -vec2(cellObsCol, 0.0 ); \/\/ move to column\n\n        float distObstaclePlayer = length( obstaclePos + s.playerPos );\n\n        if ( distObstaclePlayer < 0.5 && isDemo < 1.0 )\n        {\n            s.timeFailed = iTime;\n            s.timeCollected = -1.0;\n            s.highscore = max( s.highscore, s.score );\n        }\n    }\n    \/\/ OBSTACLE end        \n    return s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    if ( fragCoord.x >= 8. || fragCoord.y >= 8. ) \n    {        \n        discard;    \n    }\n    \n    AppState s;\n    loadState( iChannel0, s );\n        \n    s.showUI = mod( s.showUI + texelFetch( iChannel1, ivec2( ASCII_U, 1 ), 0 ).x, 2.0 );\n    float isSpacePressed = texelFetch( iChannel1, ivec2( ASCII_SPACE, 1 ), 0 ).x;\n   \n  \t\/\/ read keys that people usually press\n    \/\/ https:\/\/www.shadertoy.com\/view\/lsXGzf\n    float keyLeft = 0.0;\n    for ( int i = 0; i < keysLeft.length(); ++i )\n        keyLeft = max( keyLeft, texelFetch( iChannel1, ivec2( keysLeft[i], 0 ), 0 ).x );\n    \n\ts.isPressedLeft = keyLeft;    \n            \n    float keyRight = 0.0;\n    for ( int i = 0; i < keysRight.length(); ++i )\n        keyRight = max( keyRight, texelFetch( iChannel1, ivec2( keysRight[i], 0 ), 0 ).x );\n    \n    s.isPressedRight = keyRight;    \n       \n    if ( s.stateID == GS_SPLASH ) \/\/ splash\n    {                             \n        if ( isSpacePressed > 0.5 || s.isPressedLeft > 0.5 || s.isPressedRight > 0.5 )\n        {\n            s = setStateStartGame( s, iTime );\n            s.stateID = GS_GAME;            \n            s.timeStarted = iTime;\n            s.timeAccumulated = 0.0;\n            s.seed += iTime;\n        }\n        else\n        {\n            s = updateGame( s, 1.0 );\n        }        \n    }\n    else if ( s.stateID == GS_GAME ) \/\/ game\n    {\n        if ( s.timeFailed > s.timeStarted )\n        {   \n            if ( iTime > s.timeFailed + 1.0 \n                && ( s.isPressedLeft > 0.5 || s.isPressedRight > 0.5 ) )\n            {            \n            \ts.timeStarted = iTime;\n                s.timeFailed = -1.0;\n            }\n                        \n            if ( iTime > s.timeFailed + 5.0 )\n            {                \n                s = setStateStartGame( s, iTime );\n                s.stateID = GS_SPLASH;\n            }\n            \n            s.isPressedLeft = 0.0;\n            s.isPressedRight = 0.0;\n        }\n        else\n        {\n            s = updateGame( s, 0.0 );\n        }\n    }\n  \n    fragColor = saveState( s, fragCoord, iFrame, iTime );\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\/\/ Copyright \u00a9 2019 Michal Klos\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ Sunset Drive Unlimited\n\/\/  Endless runner with synthwave stylization\n\/\/\t\"Brick Driver\" sequel, because it missed fluent turning and coins:\n\/\/\thttps:\/\/www.shadertoy.com\/view\/wssSD4\n\n\/\/ #define options in Common tab\n\/\/  Some effects can be disabled on low end gpus\n\n\/\/ Gameplay is based on Brick Game Racing,\n\/\/  https:\/\/youtu.be\/EdMyKRC8qyU\n\n\/\/ First draft created in 24h on Game Jam Square 26-28.04.2019\n\/\/\tFinished after couple of spare evenings on 24.06.2019\n\n\/\/ Based on:\n\/\/ - \"80's raymarching\" by villedieumorgan. https:\/\/shadertoy.com\/view\/lsVSRt\n\/\/ - \"[SH16B] Speed Drive 80\" by knarkowicz. https:\/\/shadertoy.com\/view\/4ldGz4\n\/\/ Other snippets credits in comments next to the code\n\/\/ Thank you guys for sharing it, hope you like it :)\n\n\/\/ Music: Lifelike - So Electric\n\/\/  https:\/\/soundcloud.com\/rombo_rama\/lifelike-so-electric\n\n\n\n\/\/ switches, enable\/disable effects:\n#define REFLECTIONS \/\/ needs good gpu\n#define VOLUMETRICS \/\/ needs good gpu\n#define FXAA\n#define GRADE\n#define NOISE\n#define FORCED_RATIO\n\/\/ debug:\n#define SHOW_UI\n\/\/ #define FPS_COUNTER\n\/\/ #define DEBUG_2D\n\/\/ #define DEBUG_CAMERA\n\/\/ #define CAM_STICKED\n\n\n#define ZERO (min(iFrame,0))\n#define R iResolution\n#define F gl_FragCoord\n\/\/ fix by adx\n#define texture(s,u) textureLod(s,u,0.)\n\nconst float g_forceRatio = 2.39;\nconst float PI = float(3.14159);\n\n\/\/ control loop\nconst float keysLeft[] = float[] ( \n\t 37.0,  \/\/ Arrow left\n\t 65.0,  \/\/ A\n\t 197.0  \/\/ a \n);\n\nconst float keysRight[] = float[] ( \n\t 39.0, \/\/ Arrow right\n\t 68.0, \/\/ D\n     100.0 \/\/ d\n);\n\nconst int ASCII_U\t\t= 85;\nconst int ASCII_SPACE\t= 32;\n\n\/\/ Game State\nconst float GS_SPLASH = 0.0;\nconst float GS_GAME   = 1.0;\n\n\/\/ Cell State\nstruct AppState\n{\n\tfloat stateID;\n    float isPressedLeft;\n    float isPressedRight;\n    float timeStarted;\n    \n    vec2 playerPos;\n    float score;\n    float timeFailed;\n    \n    float highscore;\n    float timeCollected;\n    float timeAccumulated;\n    float showUI;\n    \n    float paceScale;\n    float seed;\n    \n    float coin0Pos;\n    float coin0Taken;\n    float coin1Pos;\n    float coin1Taken;\n    float coin2Pos;\n    float coin2Taken;\n    float coin3Pos;\n    float coin3Taken;\n};\n\n   \n\/\/ https:\/\/www.shadertoy.com\/view\/4djSRW\nfloat hash11( float p )\n{\n\tvec3 p3  = fract( vec3( p ) * .1031 );\n    p3 += dot( p3, p3.yzx + 19.19 );\n    return fract( ( p3.x + p3.y) * p3.z );\n}\n\nvec2 hash21( float p )\n{\n\tvec3 p3 = fract( vec3( p ) * vec3( .1031, .1030, .0973 ) );\n\tp3 += dot( p3, p3.yzx + 19.19 );\n    return fract( ( p3.xx + p3.yz ) * p3.zy );\n}\n\nvec2 hash22( vec2 p )\n{\n\tvec3 p3 = fract( vec3( p.xyx ) * vec3( .1031, .1030, .0973 ) );\n    p3 += dot( p3, p3.yzx + 19.19 );\n    return fract( ( p3.xx + p3.yz ) * p3.zy );\n}\n\n\/\/ from Tiny Planet: Earth by morgan3d https:\/\/www.shadertoy.com\/view\/lt3XDM\nfloat hash( float n ) { return fract( sin( n ) * 1e4 ); }\nfloat noise( vec3 x ) { const vec3 step = vec3( 110, 241, 171 ); vec3 i = floor( x ); vec3 f = fract( x ); float n = dot( i, step ); vec3 u = f * f * ( 3.0 - 2.0 * f ); return mix( mix( mix( hash( n + dot( step, vec3( 0, 0, 0 ) ) ), hash( n + dot( step, vec3( 1, 0, 0 ) ) ), u.x ), mix( hash( n + dot( step, vec3( 0, 1, 0 ) ) ), hash( n + dot( step, vec3( 1, 1, 0 ) ) ), u.x ), u.y ), mix( mix( hash( n + dot( step, vec3( 0, 0, 1 ) ) ), hash( n + dot( step, vec3( 1, 0, 1 ) ) ), u.x ), mix( hash( n + dot( step, vec3( 0, 1, 1) ) ), hash( n + dot( step, vec3( 1, 1, 1 ) ) ), u.x ), u.y ), u.z ); }\n\n#define DEFINE_FBM(name, OCTAVES) float name( vec3 x ) { float v = 0.0; float a = 0.5; vec3 shift = vec3( 100 ); for ( int i = 0; i < OCTAVES; ++i ) { v += a * noise( x ); x = x * 2.0 + shift; a *= 0.5; } return v; }\nDEFINE_FBM(fbm3, 3)\n\n\nvec4 loadValue( sampler2D tex, int x, int y )\n{\n    return texelFetch( tex, ivec2( x, y ), 0 );\n}\n\nvoid loadState( sampler2D tex, out AppState s )\n{\n    vec4 data;\n\n\tdata = loadValue( tex, 0, 0 );\n    s.isPressedLeft\t\t= data.x;\n    s.isPressedRight\t= data.y;\n    s.stateID      \t\t= data.z;\n\ts.timeStarted \t\t= data.w;    \n    \n    data = loadValue( tex, 1, 0 );\n    s.playerPos\t\t\t= data.xy;\n    s.score\t\t\t\t= data.z;\n    s.timeFailed \t\t= data.w;\n    \n    data = loadValue( tex, 2, 0 );\n    s.highscore \t\t= data.x;\n    s.timeCollected\t\t= data.y;\n    s.timeAccumulated\t= data.z;\n    s.showUI\t\t\t= data.w;\n    \n    data = loadValue( tex, 3, 0 );\n    s.paceScale\t\t\t= data.x;\n    s.seed\t\t\t\t= data.y;\n   \n    data = loadValue( tex, 0, 1 );\n    s.coin0Pos = data.x;\n    s.coin0Taken = data.y;\n    s.coin1Pos = data.z;\n    s.coin1Taken = data.w;\n    data = loadValue( tex, 1, 1 );\n    s.coin2Pos = data.x;\n    s.coin2Taken = data.y;\n    s.coin3Pos = data.z;\n    s.coin3Taken = data.w;\n}\n\nvoid storeValue( vec2 re, vec4 va, inout vec4 fragColor, vec2 fragCoord )\n{\n    fragCoord = floor( fragCoord );\n    fragColor = ( fragCoord.x == re.x && fragCoord.y == re.y ) ? va : fragColor;\n}\n\nAppState setStateStartGame( in AppState s, float iTime )\n{    \n    s.stateID \t\t\t=  GS_SPLASH;\n    s.timeStarted\t\t=  iTime;\n    s.playerPos\t\t\t=  vec2( 0.5, 0.0 );\n    s.score\t\t\t\t=  0.0;\n    s.timeFailed\t\t= -1.0;\n    s.timeCollected\t\t= -1.0;\n    s.timeAccumulated\t=  0.0;\n    s.showUI\t\t\t=  1.0;\n\n    s.coin0Pos\t\t= 0.0;\n    s.coin0Taken\t= 0.0;\n    s.coin1Pos\t\t= 0.0;        \n    s.coin1Taken\t= 0.0;\n    s.coin2Pos\t\t= 0.0;        \n    s.coin2Taken\t= 0.0;\n    s.coin3Pos\t\t= 0.0;        \n    s.coin3Taken\t= 0.0;    \n    \n    return s;\n}\n\nvec4 saveState( in AppState s, in vec2 fragCoord, int iFrame, float iTime )\n{\n    if (iFrame <= 0)\n    {\n        s.seed = fbm3( iDate.yzw );\n \t\ts = setStateStartGame( s, iTime );\n\t}\n    \n    vec4 ret = vec4( 0.);\n\tstoreValue( vec2( 0., 0. ), vec4( s.isPressedLeft,\t\ts.isPressedRight,\ts.stateID,\t\t\ts.timeStarted),\tret, fragCoord );    \n\tstoreValue( vec2( 1., 0. ), vec4( s.playerPos,\t\t\t\t\t\t\t\ts.score,\t\t\ts.timeFailed),\tret, fragCoord );\n\tstoreValue( vec2( 2., 0. ), vec4( s.highscore,\t\t\ts.timeCollected,\ts.timeAccumulated,\ts.showUI),\t\tret, fragCoord );\n    storeValue( vec2( 3., 0. ), vec4( s.paceScale,\t\t\ts.seed,\t\t\t\t0.0,\t\t\t\t0.0),\t\t\tret, fragCoord );\n    \n    storeValue( vec2( 0., 1. ), vec4( s.coin0Pos, s.coin0Taken, s.coin1Pos, s.coin1Taken ), ret, fragCoord );\n    storeValue( vec2( 1., 1. ), vec4( s.coin2Pos, s.coin2Taken, s.coin3Pos, s.coin3Taken ), ret, fragCoord );\n    return ret;\n}\n\n\/\/ math\n\nfloat saturate( float x ) { return clamp( x, 0., 1. ); }\n\nvec3 saturate( vec3 x ) { return clamp( x, vec3( 0. ), vec3( 1. ) ); }\n\nmat2 rot( float a ) { float s = sin( a ); float c = cos( a ); return mat2( c, -s, s, c ); }\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize( ta - ro );\n\tvec3 cp = vec3( sin( cr ), cos( cr ), 0.0 );\n\tvec3 cu = normalize( cross( cw, cp ) );\n\tvec3 cv =          ( cross( cu, cw ) );\n    return mat3( cu, cv, cw );\n}\n\nfloat impulse( float k, float x ) {\n    float h = k * x;\n    return h * exp( 1.0 - h );\n}\n\n\/\/-----------------------------------------------------------------\n\/\/ Digit drawing function by P_Malin (https:\/\/www.shadertoy.com\/view\/4sf3RN)\n\nfloat sampleDigit( const in float n, const in vec2 vUV )\n{\t\t\n\tif ( vUV.x  < 0.0 ) return 0.0;\n\tif ( vUV.y  < 0.0 ) return 0.0;\n\tif ( vUV.x >= 1.0 ) return 0.0;\n\tif ( vUV.y >= 1.0 ) return 0.0;\n\t\n\tfloat data = 0.0;\n\t\n\t     if( n < 0.5 ) data = 7.0 + 5.0 * 16.0 + 5.0 * 256.0 + 5.0 * 4096.0 + 7.0 * 65536.0;\n\telse if( n < 1.5 ) data = 2.0 + 2.0 * 16.0 + 2.0 * 256.0 + 2.0 * 4096.0 + 2.0 * 65536.0;\n\telse if( n < 2.5 ) data = 7.0 + 1.0 * 16.0 + 7.0 * 256.0 + 4.0 * 4096.0 + 7.0 * 65536.0;\n\telse if( n < 3.5 ) data = 7.0 + 4.0 * 16.0 + 7.0 * 256.0 + 4.0 * 4096.0 + 7.0 * 65536.0;\n\telse if( n < 4.5 ) data = 4.0 + 7.0 * 16.0 + 5.0 * 256.0 + 1.0 * 4096.0 + 1.0 * 65536.0;\n\telse if( n < 5.5 ) data = 7.0 + 4.0 * 16.0 + 7.0 * 256.0 + 1.0 * 4096.0 + 7.0 * 65536.0;\n\telse if( n < 6.5 ) data = 7.0 + 5.0 * 16.0 + 7.0 * 256.0 + 1.0 * 4096.0 + 7.0 * 65536.0;\n\telse if( n < 7.5 ) data = 4.0 + 4.0 * 16.0 + 4.0 * 256.0 + 4.0 * 4096.0 + 7.0 * 65536.0;\n\telse if( n < 8.5 ) data = 7.0 + 5.0 * 16.0 + 7.0 * 256.0 + 5.0 * 4096.0 + 7.0 * 65536.0;\n\telse if( n < 9.5 ) data = 7.0 + 4.0 * 16.0 + 7.0 * 256.0 + 5.0 * 4096.0 + 7.0 * 65536.0;\n\t\n\tvec2 vPixel = floor( vUV * vec2( 4.0, 5.0 ) );\n\tfloat fIndex = vPixel.x + ( vPixel.y * 4.0 );\n\t\n\treturn mod( floor( data \/ pow( 2.0, fIndex ) ), 2.0 );\n}\n\nfloat printInt( const in vec2 uv, const in float value )\n{\n\tfloat res = 0.0;\n\tfloat maxDigits = 1.0 + ceil( log2( value ) \/ log2( 10.0 ) );\n\tfloat digitID = floor( uv.x );\n\tif( digitID > 0.0 && digitID < maxDigits )\n\t{\n        float digitVa = mod( floor( value \/ pow( 10.0, maxDigits - 1.0 - digitID ) ), 10.0 );\n        res = sampleDigit( digitVa, vec2( fract( uv.x ), uv.y ) );\n\t}\n\n\treturn res;\t\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdXGzn","filepath":"\/media\/a\/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"\/media\/ap\/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"\/media\/a\/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"\/media\/ap\/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\/\/ Copyright \u00a9 2019 Michal Klos\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ Sunset Drive Unlimited\n\/\/  Endless runner with synthwave stylization\n\/\/\t\"Brick Driver\" sequel, because it missed fluent turning and coins:\n\/\/\thttps:\/\/www.shadertoy.com\/view\/wssSD4\n\n\/\/ #define options in Common tab\n\/\/  Some effects can be disabled on low end gpus\n\n\/\/ Gameplay is based on Brick Game Racing,\n\/\/  https:\/\/youtu.be\/EdMyKRC8qyU\n\n\/\/ First draft created in 24h on Game Jam Square 26-28.04.2019\n\/\/\tFinished after couple of spare evenings on 24.06.2019\n\n\/\/ Based on:\n\/\/ - \"80's raymarching\" by villedieumorgan. https:\/\/shadertoy.com\/view\/lsVSRt\n\/\/ - \"[SH16B] Speed Drive 80\" by knarkowicz. https:\/\/shadertoy.com\/view\/4ldGz4\n\/\/ Other snippets credits in comments next to the code\n\/\/ Thank you guys for sharing it, hope you like it :)\n\n\/\/ Music: Lifelike - So Electric\n\/\/  https:\/\/soundcloud.com\/rombo_rama\/lifelike-so-electric\n\n\n\nAppState g_S;\n\nfloat g_glowCoin = 1e10;\nfloat g_glowCoinRefl = 1e10;\nfloat g_glowEnemy = 1e10;\nfloat g_glowEnemyRefl = 1e10;\nfloat g_glowPlayer = 1e10;\nfloat g_glowPlayerRefl = 1e10;\nfloat g_glowPlayerFront = 1e10;\nfloat g_glowPlayerLights = 1e10;\nfloat g_cameraMode = 0.0;\n\nconst float GRID_SIZE = 0.5;\nconst float GRID_LINE_SIZE = 1.25;\n\nconst float GRID_CAR_SIZE = 0.5;\nconst float GRID_CAR_LINE_SIZE = 1.5;\n\nconst vec3 GRID_COLOR_1 = vec3(0.00, 0.02, 0.20);\nconst vec3 GRID_COLOR_2 = vec3(26.00, 14.0, 122.0)\/255.;\n\nconst vec3 SUN_DIRECTION = vec3(0.0, 0.025, 0.5);\nconst vec3 SKY_COLOR_1 = vec3(49., 33., 66.)\/255.;\nconst vec3 SKY_COLOR_2 = vec3(0.00,0.02,0.20);\n\nconst vec3 SUN_COLOR_1 = vec3(1.0, 0.3, 0.1) * 0.5;\nconst vec3 SUN_COLOR_2 = vec3(1.0, 1.0, 0.1) * 0.5;\n\nconst vec3 CAR_COLOR_1 = vec3(1.0, 0.5, 0.1) * 0.0;\nconst vec3 CAR_COLOR_2 = vec3(1.0, 0.0, 0.0) * 1.5;\n\nconst vec3 CAR_PLAYER_COLOR_1 = vec3(0.1, 1.0, 0.5) * 0.1;\nconst vec3 CAR_PLAYER_COLOR_2 = vec3(0.1, 1.0, 0.5) * 1.5;\n\nconst vec3 FOG_COLOR = vec3(193.00, 24.0, 123.0)\/255.;\n\n\nstruct sHit {\n    float t;\n    float m;\n    vec3 lPos;\n};\n    \nsHit createHit( float t, float m, vec3 lPos )\n{\n    sHit h;\n    h.t = t;\n    h.m = m;\n    h.lPos = lPos;\n    return h;\n}\n\nvoid drawCoin( inout vec3 color, vec2 p, vec2 coinPos )\n{  \n    float sCoin = length(\n        p\n        -vec2( 0.0, coinPos.y )\t\/\/ cell pos\n        +vec2( 0.5, -0.5 )\t\t\/\/ move to cell center\n        -vec2( coinPos.x, 0.0 ) \/\/ move to column\n    ) - 0.25; \t\t\t\t\t\/\/ radius of coin\n\n    color.rgb = mix( vec3( 1.0, 1.0, 0.0 ), color.rgb, smoothstep( 0.0, 0.1, sCoin ) );\n}\n\nvoid drawGameFlat( inout vec4 color, vec2 p, AppState s )\n{\n    \/\/ game\n\tvec2 p0 = p;    \n    \/\/ float cameraAnim = smoothstep(-0.5, 0.5, sin(iTime) );\n    float cameraAnim = 0.0;\n\tp0 *= mix( 5.0, 10.0, cameraAnim );\t\t\/\/ scale field of view\n    p0.x += 0.25;\t\t\t\t\t\t\t\/\/ fix track centering\n    p0.y += mix( 2.0, 8.0, cameraAnim );\t\/\/ move camera pos\n    p0.y += s.playerPos.y;\n    \n    float playerCellID = floor( s.playerPos.y );\n    float sPlayer = length( p0 - s.playerPos ) - 0.25;\n           \n    vec2 p1 = p0;\n    p1.y += 2.0 * s.playerPos.y;\n    color.rgb = mix( vec3( 1.0 ), color.rgb, smoothstep( 1.5, 1.75, abs( p1.x - 0.5 ) ) );\n    color.rgb = mix( texture( iChannel2, fract( p1 ) ).rgb, color.rgb, 0.5 );\n       \n\t\/\/ COIN start\n    float cellID = floor( p0.y );\n    float cellCoinRND = hash11( cellID + g_S.seed );\t\t\t\t\t\/\/ skip rnd obstacle every second cell to make room for driving    \n    cellCoinRND *= mix( 1.0, -1.0, step( mod( cellID, 4.0 ), 1.5 ) );\t\/\/ gaps in coin placing: 2 gaps, 2 coins\n    cellCoinRND = mix( cellCoinRND, -1.0, step (cellID, 5.0 ) );\t\t\/\/ head start\n    float cellCoinCol = floor( 3.0 * cellCoinRND );\n       \n    if ( cellCoinRND >= 0.0 )\n    {\n        if ( cellID > playerCellID )\n           \tdrawCoin( color.rgb, p0, vec2( cellCoinCol, cellID ) );\n        \n        if ( cellID == playerCellID && s.coin0Taken < 0.5 )\n            drawCoin( color.rgb, p0, vec2( cellCoinCol, cellID ) );\n        \n        if ( cellID == playerCellID - 1.0 && s.coin1Taken < 0.5 )\n            drawCoin( color.rgb, p0, vec2( cellCoinCol, cellID ) );\n        \n        if ( cellID == playerCellID - 2.0 && s.coin2Taken < 0.5 )\n            drawCoin( color.rgb, p0, vec2( cellCoinCol, cellID ) );\n       \n        if ( cellID == playerCellID - 3.0 && s.coin3Taken < 0.5 )\n            drawCoin( color.rgb, p0, vec2( cellCoinCol, cellID ) );\n    }    \n\/\/ COIN end\n\n\/\/ OBSTACLE start\n    float cellObsRND = hash11( 100.0 * cellID + g_S.seed );\t\t\/\/ skip rnd obstacle every second cell to make room for driving\n    cellObsRND *= mix( 1.0, -1.0, step( mod( cellID, 3.0 ), 1.5 ) );\n    cellObsRND = mix( cellObsRND, -1.0, step( cellID, 7.0) );\t\/\/ head start\n    float cellObsCol = floor( 3.0 * cellObsRND );\n    \n\tif ( cellObsRND >= 0.0 && cellObsCol != cellCoinCol )\n    {        \n    \tfloat sObstacle = length(\n            p0\n            -vec2( 0.0, cellID )\t\t\/\/ cell pos\n            +vec2( 0.5, -0.5 )\t\t\t\/\/ move to cell center\n            -vec2( cellObsCol, 0.0 )\t\/\/ move to column\n        ) - 0.25;\t\t\t\t\t\t\/\/ radius of coin\n        \n    \tcolor.rgb = mix( vec3( 1.0, 0.0, 0.0 ), color.rgb, smoothstep( 0.0, 0.1, sObstacle ) );\n        \n        vec2 obstaclePos = -vec2( 0.0, cellID )\t\t\t\/\/ cell pos\n            \t\t\t\t+vec2( 0.5, -0.5 )\t\t\t\/\/ move to cell center\n            \t\t\t\t-vec2( cellObsCol, 0.0 );\t\/\/ move to column\n\n        float distObstaclePlayer = length( obstaclePos + s.playerPos );\n        \n        if ( distObstaclePlayer < 0.5 ) \n        {\n            color.rgb += vec3( 0.5 );\n        }\n    }\n    \n    color.rgb = mix( vec3( 0.0, 1.0, 0.0 ), color.rgb, smoothstep( 0.0, 0.1, sPlayer ) );\n\n\/\/ OBSTACLE end        \n\n}\n\nfloat circle( vec2 p, float r )\n{\n    return ( length( p \/ r ) - 1. ) * r;\n}\n\nvoid opRotate( inout vec2 p, float a ) \n{\n    p = cos( a ) * p + sin( a ) * vec2( p.y, -p.x );\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn ( d1.x < d2.x ) ? d1 : d2;\n}\n\nsHit opUS( sHit d1, sHit d2 )\n{\n    if ( d1.t < d2.t )\n        return d1;\n    else \n        return d2;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n   \tp = vec3( p.z, p.x, -p.y ); \/\/ Coord fix\n    \/\/ n must be normalized\n          \n    vec3 p0 = vec3(p.x, p.y, p.z);\n\n    float fgProf = 0.2 * smoothstep( 1.5, 2.0, abs( p0.y ) );\n    float bgProf = 1.0 * smoothstep( 3.5, 4.5, abs( p0.y ) );\n    float fg = 0.15 * p.y * p.y * fgProf + fgProf * clamp( texture( iChannel2, p0.xy \/ 10. ).r, 0.0, 1.0 );\n    float bg = 0.1 * fgProf + bgProf * clamp( texture( iChannel2, p0.xy \/ 40.).r, 0.0, 1.0 );\n    float displace = 1.5 * fg + 2.5 * bg;\n    \n    float sGround = dot(\n        vec3( p.x, p.y, max( p.z + displace, p.z ) ),\n        n.xyz )\n        + n.w;\n    \n    sGround *= 0.5;\n    \n  \treturn sGround;\n}\n\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length( p ) - s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs( p ) - b;\n    return min( max( d.x, max( d.y, d.z ) ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot( pa, ba ) \/ dot( ba, ba ), 0.0, 1.0 );\n\treturn length( pa - ba * h ) - r;\n}\n\nfloat opUnion( float a, float b )\n{\n    return min( a, b );\n}\n\nfloat opIntersect( float a, float b )\n{\n    return max( a, b );\n}\n\nfloat opSubstract( float a, float b )\n{\n    return max( a, -b );\n}\n\nfloat opSubstractChamfer( float a, float b, float r ) \n{\n    return max( max( a, -b ), ( a + r - b ) * 0.70711 );\n}\n\nfloat plane( vec3 p, vec4 plane ) \n{\n    return dot( p, plane.xyz ) + plane.w;\n}\n\nfloat box( vec3 p, vec3 b )\n{\n    vec3 d = abs( p ) - b;\n    return min( max( d.x, max( d.y, d.z ) ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\nfloat cylinder( vec3 p, float r, float height ) \n{\n    float d = length( p.xz ) - r;\n    d = max( d, abs( p.y ) - height );\n    return d;\n}\n\nfloat sphere( vec3 p, float s )\n{\n    return length( p ) - s;\n}\n\nvec2 sdColumn( vec3 p, float r, float id )\n{\n    return vec2( ( ( abs( p.x ) + abs( p.y ) ) - r ) \/ sqrt( 2.0 ), id );\n}\n\nfloat sdCoin( vec3 p, float id )\n{       \n    float sCyl = cylinder( p.yzx, 0.1, 0.02 );    \n\n    if ( id == 2.0 )\n        g_glowCoin = min( g_glowCoin, sCyl );\n    \n    if ( id == 12.0 )\n    \tg_glowCoinRefl = min( g_glowCoin, sCyl );\n    \n    return sCyl;\n}\n\n\/\/ From \"[SH16B] Speed Drive 80\" by knarkowicz. https:\/\/shadertoy.com\/view\/4ldGz4\nfloat car( vec3 p, float id )\n{        \n    p *= 5.5;\n    \n    p.x = -p.x;     \n    p.y -= 0.3;\n    \n    float a = box( p, vec3( 4.2, 0.9, 1.8 ) );   \n    \n    vec3 t = p + vec3( -6.0, 0.0, 0.0 );\n    opRotate( t.yx, 0.2 );\n    float b = plane( t, vec4( 0.0, -1.0, 0.0, 0.0 ) );\n    \n    t = p + vec3( -5.0, 0.0, 0.0 );\n    opRotate( t.yx, -0.4 );\n    float c = plane( t, vec4( 0.0, 1.0, 0.0, 0.0 ) );    \n    \n    t = p + vec3( 2.0, -0.2, 0.0 );\n    opRotate( t.yx, -0.4 );\n    float d = plane( t, vec4( 0.0, -1.0, 0.0, 0.0 ) );   \n    \n    t = p + vec3( 2.0, -0.3, 0.0 );\n    opRotate( t.yx, -0.05 );\n    float e = plane( t, vec4( 0.0, -1.0, 0.0, 0.0 ) );       \n    \n    t = p + vec3( 2.0, 1.0, 0.0 );\n    opRotate( t.yx, 0.2 );\n    float f = plane( t, vec4( 0.0, 1.0, 0.0, 0.0 ) );     \n        \n    if ( id == 1.0 )\n    {\n        float bloomF = box( t + vec3( -0.5, 0.7, 0.0 ), vec3( 0.1, 0.3, 1.5 ) );\n        t.z = abs( t.z );\n        t.z -= 1.5;       \n        float bloomB = box( t + vec3( -4.4, -0.2, 0.0 ), vec3( 0.2, 0.4, 0.2 ) );\n    \tg_glowPlayer = min( g_glowPlayer, 1.0 \/ 5.5 * min( bloomF, bloomB ) );\n    }\n    \n    if ( id == 3.0 )\n        g_glowEnemy = min( g_glowEnemy, 1.0 \/ 5.5 * box( t + vec3( -2.0, 0.7, 0.0 ), vec3( 3.0, 1.0, 1.0 ) ) );\n\n    t = p + vec3( 1.0, -0.6, 0.0 );\n    opRotate( t.yx, -0.4 );\n    float frontWindow = box( t, vec3( 0.6, 0.05, 1.6 ) );\n    \n    t = p + vec3( -2.5, -0.7, 0.0 );\n    opRotate( t.yx, 0.2 );\n    float backWindow = box( t, vec3( 1.0, 0.05, 1.6 ) );\n    \n    float body = opSubstract( a, opUnion( opUnion( opUnion( b, c ), opIntersect( d, e ) ), f ) );\n    \n    t = p;\n    t.z = -abs( t.z );\n    t += vec3( 0.0, -0.8, 1.2 );\n    opRotate( t.yz, -0.9 );\n    float sideCutPlanes = plane( t, vec4( 0.0, -1.0, 0.0, 0.0 ) );      \n    \n    body = opSubstractChamfer( body, opUnion( backWindow, frontWindow ), 0.1 );\n    body = opSubstractChamfer( body, sideCutPlanes, 0.05 );\n    \n    p.x += 0.1;\n    p.xz = abs( p.xz );\n    t = p.xzy - vec3( 2.4, 1.5, -0.65 );\n    float wheel = cylinder( t, 0.7, 1.0 );\n    body = opSubstract( body, wheel );\n    t.y -= .1;\n    wheel = opSubstract( cylinder( t, 0.6, 0.3 ), sphere( t + vec3( 0.0, -0.45, 0.0 ), 0.45 ) );\n    \n    body = opUnion( body, wheel );\n    \n    body \/= 5.5;\n    \n    return body;\n}\n\nfloat carFront( vec3 p, float id )\n{        \n    \/\/ front lights\n    p.z = abs( p.z );\n    p.z -= 0.2;\n    float front = cylinder( p.zxy + vec3( -0.06, -0.77, -0.02 ), 0.05, 0.01 );\n    \n    if ( id == 1.5 )\n        g_glowPlayerFront = min( g_glowPlayerFront, front );\n       \n    return front;\n}\n\nfloat carLights( vec3 p, float id )\n{        \n    \/\/ back lights\n    p.z = abs( p.z );\n    p.z -= 0.2;\n    float back = box( p + vec3( 0.75, -0.09, 0.0 ), vec3( 0.02, 0.02, 0.075 ) );\n    \n    if ( id == 1.5 )\n    \tg_glowPlayerLights = min( g_glowPlayerLights, back );\n       \n    return back;\n}\n\n\nfloat carRefl( vec3 p, float id )\n{        \n    float body = box( p + vec3( 0.0, -0.07, 0.0 ), vec3( 0.6, 0.02, 0.2) );\n    body = min( body, box( p + vec3( 0.2, -0.1, 0.0 ), vec3( 0.4, 0.02, 0.2 ) ) );\n    \n    \/\/ back lights\n    p.z = abs( p.z );\n    p.z -= 0.2;\n    float bloom = box( p + vec3( 0.75, -0.09, 0.0 ), vec3( 0.02, 0.02, 0.075 ) );    \n    \n    bloom = min( bloom, body );\n    \n    if ( id == 1.5 )\n    \tg_glowPlayerRefl = min( g_glowPlayerRefl, bloom );\n    \n    if ( id == 3.5 )\n        g_glowEnemyRefl = min( g_glowEnemyRefl, bloom );\n       \n    return body;\n}\n\nvec2 getBent()\n{\n    float bentSide\t= sin( g_S.timeAccumulated \/ PI );\n    float bentUp\t= ( ( cos( 0.25 * g_S.timeAccumulated \/ PI ) * 0.5 ) + 0.5 ) * 1.5;\n    return vec2( bentSide, bentUp );\n}\n\nsHit map( in vec3 pos )\n{\n    sHit sRes = createHit( 1e10, 0.0, pos );\n\n\t\/\/ player, in place in fact\n    vec2 bent = getBent();\n    \n    \/\/ game\n    vec3 p0 = pos;    \n    \/\/ bending    \n    p0.x -= 1.5 * sin( 0.05 * p0.z * PI ) * bent.x;\n    p0.y += 1.5 * sin( 0.05 * p0.z * PI ) * bent.y;\n   \n    vec3 pPlayer = pos -vec3( g_S.playerPos.x, 0.25, 0.0 );\n    \n    pPlayer.xz *= rot(  0.2 * bent.x );\n    pPlayer.yz *= rot( -0.2 * bent.y );\n    \/\/ sRes = opUS( sRes, CreateHit( sdBox( pPlayer, vec3(0.5, 0.2, 0.5) ) - 0.01, 1.0, pPlayer) ); \/\/ debug collider\n    \n\tfloat rotY = -.2 * g_S.isPressedLeft + .2 * g_S.isPressedRight;\n    float rotX = -.1 * g_S.isPressedLeft + .1 * g_S.isPressedRight;    \n    pPlayer.xz *= rot( -0.01 * PI * bent.y + rotY -0.5 * PI );\n    pPlayer.yz *= rot( -0.01 * PI * bent.x + rotX );\n    \/\/ pPlayer.yz *= rot( -10.0*iTime ); \/\/ mothman\n    pPlayer.y += 0.05;    \n    sRes = opUS( sRes, createHit( car( pPlayer, 1.0 ), 1.0, pPlayer ) );\n\tsRes = opUS( sRes, createHit( carLights( pPlayer, 1.5 ), 1.5, pPlayer ) );\n    sRes = opUS( sRes, createHit( carFront( pPlayer, 1.6 ), 1.6, pPlayer ) );\n    \n    vec3 pEnv = p0;\n    pEnv.z += 2.0 * g_S.playerPos.y;\n    pEnv.x -= 0.5;\n    sRes = opUS( sRes, createHit( sdPlane( pEnv, vec4( 0, 0, -1, 0 ) ), 0.0, vec3( pEnv.x, 0.0, pEnv.z ) ) );\n    \n    p0.z *= 0.5;\n    p0.z += g_S.playerPos.y;\n    \n    vec3 p0Mod = p0;\n    p0Mod.z = mod( p0.z + 0.5, 1.0 ) - 0.5;\n                \n    float playerCellID = floor( g_S.playerPos.y );\n   \n    \/\/ COIN start\n    float cellID = floor( p0.z + 0.5 );\n    \n    float cellCoinRND = hash11( cellID + g_S.seed ); \/\/ skip rnd obstacle every second cell to make room for driving    \n    cellCoinRND *= mix( 1.0, -1.0, step( mod( cellID, 4.0 ), 1.5 ) ); \/\/ gaps in coin placing: 2 gaps, 2 coins\n    cellCoinRND = mix( cellCoinRND, -1.0, step( cellID, 5.0 ) ); \/\/ head start\n    float cellCoinCol = floor( 3.0 * cellCoinRND );\n    \n    if (cellCoinRND >= 0.0)\n    {\n        vec3 pCoin = p0Mod; \n        float bounce = 0.3 * abs( sin( 5.0 * iTime + cellID ) );\n        vec3 coinOffset = vec3( -0.5  + cellCoinCol, 0.4 + bounce, 0.0 );\n        pCoin -= coinOffset;\n        pCoin.z *= 2.0;\n        pCoin.xz *= rot( 10.0 * iTime );\n                \n        if ( cellID > playerCellID )\n            sRes = opUS( sRes, createHit( sdCoin( pCoin, 2.0 ) - 0.01, 2.0, pCoin ) );\n        \n        if ( cellID == playerCellID && g_S.coin0Taken < 0.5 )\n        \tsRes = opUS( sRes, createHit( sdCoin( pCoin, 2.0 ) - 0.01, 2.0, pCoin ) );\n        \n        if ( cellID == playerCellID - 1.0 && g_S.coin1Taken < 0.5 )\n        \tsRes = opUS( sRes, createHit( sdCoin( pCoin, 2.0 ) - 0.01, 2.0, pCoin ) );\n        \n        if ( cellID == playerCellID - 2.0 && g_S.coin2Taken < 0.5 )\n        \tsRes = opUS( sRes, createHit( sdCoin( pCoin, 2.0 ) - 0.01, 2.0, pCoin ) );\n        \n        if ( cellID == playerCellID - 3.0 && g_S.coin3Taken < 0.5 )\n        \tsRes = opUS( sRes, createHit( sdCoin( pCoin, 2.0 ) - 0.01, 2.0, pCoin ) );\n    }    \n       \n    float cellObsRND = hash11( 100.0 * cellID + g_S.seed ); \/\/ skip rnd obstacle every second cell to make room for driving\n    cellObsRND *= mix( 1.0, -1.0, step( mod( cellID, 3.0 ), 1.5 ) );\n    cellObsRND = mix( cellObsRND, -1.0, step( cellID, 7.0 ) ); \/\/ head start\n    float cellObsCol = floor( 3.0 * cellObsRND );\n\n    if ( cellObsRND >= 0.0 && cellObsCol != cellCoinCol )\n    {            \n        vec3 obstacleOffset = vec3(\n            -0.5 + cellObsCol,  \n             0.2,\n             0.0\n        );\n\n        \/\/ sRes = opUS( sRes, CreateHit( sdBox( p0Mod -obstacleOffset, vec3(0.5, 0.1, 0.5) ) - 0.01, 3.0, p0Mod ) ); \/\/ debug colider\n        p0Mod -= obstacleOffset;\n        p0Mod.z *= 2.0;\n        p0Mod.xz *= rot( -0.5 * PI );\n        sRes = opUS( sRes, createHit( car( p0Mod, 3.0 ), 3.0, p0Mod ) );\n        sRes = opUS( sRes, createHit( carLights( p0Mod, 3.5 ), 3.5, p0Mod ) );\n        sRes = opUS( sRes, createHit( carFront( p0Mod, 3.6 ), 3.6, p0Mod) );\n    }\n\n    return sRes;\n}\n\nsHit mapRefl( in vec3 pos )\n{\n    sHit sRes = createHit( 1e10, -1.0, pos );\n\n    vec2 bent = getBent();\n    vec3 p0 = pos;    \n    p0.x -= 1.5 * sin( 0.05 * p0.z * PI) * bent.x;\n    p0.y += 1.5 * sin( 0.05 * p0.z * PI) * bent.y;\n   \n    float rotY = -.2 * g_S.isPressedLeft + .2 * g_S.isPressedRight;\n    float rotX = -.1 * g_S.isPressedLeft + .1 * g_S.isPressedRight;    \n    vec3 pPlayer = pos - vec3( g_S.playerPos.x, 0.25, 0.0 );\n    pPlayer.xz *= rot(  0.2 * bent.x );\n    pPlayer.yz *= rot( -0.2 * bent.y );\n    pPlayer.xz *= rot( -0.01 * PI * bent.y + rotY -0.5 * PI);\n    pPlayer.yz *= rot( -0.01 * PI * bent.x + rotX);\n    pPlayer.y += 0.05;\n\tsRes = opUS( sRes, createHit( carRefl( pPlayer, 1.5 ), 1.5, pPlayer) );\n\n    p0.z *= 0.5;\n    p0.z += g_S.playerPos.y;      \n    \n    vec3 p0Mod = p0;\n    p0Mod.z = mod( p0.z + 0.5, 1.0 ) -0.5;\n                \n    float playerCellID = floor( g_S.playerPos.y );\n   \n    \/\/ COIN start\n    float cellID = floor( p0.z + 0.5 );\n    \n    float cellCoinRND = hash11( cellID + g_S.seed ); \/\/ skip rnd obstacle every second cell to make room for driving    \n    cellCoinRND *= mix( 1.0, -1.0, step( mod( cellID, 4.0 ), 1.5 ) ); \/\/ gaps in coin placing: 2 gaps, 2 coins\n    cellCoinRND = mix( cellCoinRND, -1.0, step( cellID, 5.0 ) ); \/\/ head start\n    float cellCoinCol = floor( 3.0 * cellCoinRND );\n    \n    if ( cellCoinRND >= 0.0 )\n    {\n        vec3 pCoin = p0Mod; \n        float bounce = 0.3 * abs( sin( 5.0 * iTime + cellID ) );\n        vec3 coinOffset = vec3( -0.5 + cellCoinCol, 0.4 + bounce, 0.0 );\n        pCoin -= coinOffset;\n        pCoin.z *= 2.0;\n        pCoin.xz *= rot( 10.0 * iTime );\n                \n        if ( cellID > playerCellID )\n            sRes = opUS( sRes, createHit( sdCoin( pCoin, 12.0 ) - 0.01, 2.0, pCoin ) );\n        \n        if ( cellID == playerCellID && g_S.coin0Taken < 0.5 )\n        \tsRes = opUS( sRes, createHit( sdCoin( pCoin, 12.0 ) - 0.01, 2.0, pCoin ) );\n        \n        if ( cellID == playerCellID - 1.0 && g_S.coin1Taken < 0.5 )\n        \tsRes = opUS( sRes, createHit( sdCoin( pCoin, 12.0 ) - 0.01, 2.0, pCoin ) );\n        \n        if ( cellID == playerCellID - 2.0 && g_S.coin2Taken < 0.5 )\n        \tsRes = opUS( sRes, createHit( sdCoin( pCoin, 12.0 ) - 0.01, 2.0, pCoin ) );\n        \n        if ( cellID == playerCellID - 3.0 && g_S.coin3Taken < 0.5 )\n        \tsRes = opUS( sRes, createHit( sdCoin( pCoin, 12.0 ) - 0.01, 2.0, pCoin ) );\n    }    \n       \n    float cellObsRND = hash11( 100.0 * cellID + g_S.seed ); \/\/ skip rnd obstacle every second cell to make room for driving\n    cellObsRND *= mix( 1.0, -1.0, step( mod( cellID, 3.0 ), 1.5 ) );\n    cellObsRND = mix( cellObsRND, -1.0, step( cellID, 7.0 ) ); \/\/ head start\n    float cellObsCol = floor( 3.0 * cellObsRND );\n\n    if ( cellObsRND >= 0.0 && cellObsCol != cellCoinCol )\n    {            \n        vec3 obstacleOffset = vec3(\n            -0.5 + cellObsCol,  \n             0.2,\n             0.0\n        );\n\n        p0Mod -= obstacleOffset;\n        p0Mod.z *= 2.0;\n        p0Mod.xz *= rot( -0.5 * PI );\n        sRes = opUS( sRes, createHit( carRefl( p0Mod, 3.5), 3.5, p0Mod ) );\n    }\n\n    return sRes;\n}\n\n\n\/\/ https:\/\/iquilezles.org\/articles\/boxfunctions\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0 \/ rd;\n    vec3 n = m * ro;\n    vec3 k = abs( m ) * rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nsHit castRay( in vec3 ro, in vec3 rd, float tmin, float tmax )\n{\n    sHit sRes = createHit( -1.0, -1.0, rd );\n\n    \/\/ raymarch primitives   \n    vec2 tb = iBox( ro - vec3( 0.0, 0.0, 15.0 ), rd, vec3( 7.0, 4.0, 45.0 ) );\n    \n    if( tb.x < tb.y && tb.y > 0.0 && tb.x < tmax )\n    {\n        tmin = max( tb.x, tmin );\n        tmax = min( tb.y, tmax );       \n\n        float t = tmin;\n        for( int i = ZERO; i < 128 && t < tmax; i++ )\n        {\n            sHit h = map( ro + rd * t );\n            if( abs( h.t ) < ( 0.001 * t ) )\n            { \n                \/\/ res = vec2(t,h.y); \n                sRes = createHit( t, h.m, h.lPos ); \n                break;\n            }\n            t += h.t;\n        }\n    }\n    \n    return sRes;\n}\n\nsHit castRayRefl( in vec3 ro, in vec3 rd, float tmin, float tmax )\n{\n    sHit sRes = createHit( -1.0, -1.0, rd );\n\n    \/\/ raymarch primitives   \n    vec2 tb = iBox( ro - vec3( 0.0, 0.0, 5.0 ), rd, vec3( 4.0, 4.0, 25.0 ) );\n    \n    if( tb.x < tb.y && tb.y > 0.0 && tb.x < tmax )\n    {\n        tmin = max( tb.x, tmin );\n        tmax = min( tb.y, tmax );       \n\n        float t = tmin;\n        for( int i = ZERO; i < 32 && t < tmax; i++ )\n        {\n            sHit h = mapRefl( ro + rd * t );\n            if( abs( h.t ) < ( 0.001 * t ) )\n            { \n                sRes = createHit( t, h.m, h.lPos ); \n                break;\n            }\n            t += h.t;\n        }\n    }\n\n    return sRes;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n#if 1\n    \/\/ vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    vec2 e = vec2( 1.0, -1.0 ) * 0.5773 * 0.01;\n    return normalize( e.xyy*map( pos + e.xyy ).t + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).t + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).t + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).t );\n#else\n    \/\/ inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3( 0.0 );\n    for( int i = ZERO; i < 4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e * map( pos + 0.0005 * e ).x;\n    }\n    return normalize( n );\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i = ZERO; i < 5; i++ )\n    {\n        float hr = 0.01 + 0.12 * float( i ) \/ 4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).t;\n        occ += -( dd - hr ) * sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0 * occ, 0.0, 1.0 ) * (0.5 + 0.5 * nor.y );\n}\n\nvec3 getSkyColor( vec3 rd )\n{\n    vec3 color = mix( SKY_COLOR_1 * 1.4, SKY_COLOR_2, rd.y \/ 9.0 );\n\t\n    float fogFalloff = clamp( 8.0 * rd.y, 0.0, 1.0 );\n    color = mix( FOG_COLOR, color, fogFalloff );\n    color = mix( color, GRID_COLOR_1, smoothstep( -0.1, -0.2, rd.y ) );\n\n    vec3 sunDir = normalize( SUN_DIRECTION );\n    float sunGlow = smoothstep( 0.9, 1.0, dot( rd, sunDir ) );\n        \n    rd = mix( rd, sunDir, -1.0 ); \/\/ easier to bend vectors than fiddle with falloff :P\n    float sun = smoothstep( 0.987, 0.99, dot(rd, sunDir ) );\n    sun -= smoothstep( 0.1, 0.9, 0.5 );\t\t\t        \n    \n    float stripes = mod( 50.0 * ( pow( rd.y + 0.15, 1.5 ) ) + 0.5, 1.0 ) -0.5;\n    stripes = smoothstep( 0.2, 0.21, abs( stripes ) );\n        \n    \n    \/\/ based on https:\/\/www.shadertoy.com\/view\/tssSz7\n    vec2 starTile   = floor( rd.xy * 40.0 );\n    vec2 starPos    = fract( rd.xy * 40.0 ) * 2.0 - 1.0;\n    vec2 starRand = hash22( starTile );\n    starPos += starRand * 2.0 - 1.0;\n    float stars = saturate( 1.0 - ( ( sin( iTime * 1.0 + 50.0 * rd.y ) ) * 0.5 + 6.0 ) * length( starPos ) );\n    stars *= step( 0.0, -sun );\n    stars *= step( 0.9, starRand.x );\n    stars *= 5.0;\n           \n    sun = 2.0 * clamp( sun * stripes, 0.0, 1.0 );\n    \n    vec3 sunCol = 4.0 * mix( SUN_COLOR_1, SUN_COLOR_2, -( rd.y - 0.1 ) \/ 0.3 );\n    color = mix( color, sunCol, sun );\n\n\tcolor = mix( FOG_COLOR, color, 0.8 + 0.2 * fogFalloff );\n    color = mix( color, sunCol, 0.25 * sunGlow );\n    \n    color += stars;\n\n    \/\/ return vec3(stripes);\n    \/\/ return vec3(sun);\n    \/\/ return vec3(sunGlow);\n    return color;\n}\n\nvec4 shade( vec3 wPos, vec3 lPos, vec3 nor, vec3 rd, float m )\n{       \n    vec2 bent = getBent();\n    \/\/ repeat car rotation with fixes\n    float rotY = -.2 * g_S.isPressedLeft + .2 * g_S.isPressedRight;\n    float rotX = -.1 * g_S.isPressedLeft + .1 * g_S.isPressedRight;\n\n    vec3 albedo = vec3( 0.5 );\n    float met = 1.0;\n    vec4 color = vec4( albedo, met );\n    vec3 emissive = vec3( 0.0 );\n        \n    if ( m == 0.0 )\n    {\n        vec2 p0 = lPos.xz;\n        p0.x -= 1.5 * sin( 0.05 * p0.y * PI ) * smoothstep( -0.5, 0.5, sin( iTime ) );\n        vec2 uv = abs( mod( lPos.xz + GRID_SIZE \/ 2.0, GRID_SIZE ) - GRID_SIZE \/ 2.0 );\n        uv \/= fwidth( lPos.xz );\n        float gln = min( min( uv.x, uv.y ), 1.) \/ GRID_SIZE;\n        \n    \talbedo = mix( GRID_COLOR_1, GRID_COLOR_2, 0.7 - smoothstep( 0.0, GRID_LINE_SIZE \/ GRID_SIZE, gln ) );\n        \n        float pSideLine = lPos.x;\n\t\tpSideLine = abs( pSideLine );\n        pSideLine -= 1.45;\n        pSideLine = abs( pSideLine );\n        float sideLine = 1.0 - smoothstep( 0.03, 0.04, pSideLine );\n        \n        float pCenterLine = lPos.x;\n\t\tpCenterLine = abs( pCenterLine );\n        pCenterLine -= 0.55;\n        pCenterLine = abs( pCenterLine );\n        float centerLine = 1.0 - smoothstep( 0.03, 0.04, pCenterLine );\n        \n        float pCenterLineBreak = mod( lPos.z + 0.5, 1.0) - 0.5;\n        float centerLineBreak = smoothstep( 0.15, 0.16, abs( pCenterLineBreak ) );\n        float damage = pow( texture( iChannel1, 0.03 * lPos.xz ).r, 1.5 );\n        albedo = mix( albedo, vec3( 1.0, 1.0, 0.5 ), ( sideLine + centerLine * centerLineBreak ) * damage );\n               \n        vec2 pTrail = vec2( lPos.x - g_S.playerPos.x + 0.5, lPos.z - 2.0 * g_S.playerPos.y );\n        pTrail.x += 4.0 * rotY; \/\/ move the cos\n        pTrail.x -= 4.0 * rotY * ( cos( 0.75 * pTrail.y - 0.1 * PI ) * 0.5 + 0.5 ); \/\/ fake car turns\n        pTrail.x = abs( pTrail.x );\n        pTrail.x -= 0.28;\n        pTrail.x = abs( pTrail.x );\n               \n        float trailMask = exp( -30.0 * pTrail.x );\n        trailMask += 0.2 * saturate( exp( -4.0 * pTrail.x ) );\n        trailMask *= saturate( -pTrail.y + 0.5 );\t\t\/\/ clamp on Y\n        trailMask *= saturate(  pTrail.y * 0.5 + 1.5 );\t\/\/ clamp on Y\n        emissive += vec3( 1.5, 0.2, 0.0 ) * trailMask;       \n    }\n    \n    if ( m == 1.0 )\n    {\n        vec2 p0 = 2.6 * lPos.xz;\n        p0.x -= 1.5 * sin( 0.05 * p0.y * PI ) * smoothstep( -0.5, 0.5, sin( iTime ) );\n        vec2 uv = abs( mod( 3.0 * lPos.xz + GRID_SIZE \/ 2.0, GRID_SIZE ) - GRID_SIZE \/ 2.0 );\n        uv \/= fwidth( lPos.xz );\n        float gln = min( min( uv.x, uv.y ), 1. ) \/ GRID_SIZE;\n        vec3 carCol = mix( CAR_PLAYER_COLOR_1, CAR_PLAYER_COLOR_2, 0.7 - smoothstep( 0.0, GRID_CAR_LINE_SIZE \/ GRID_CAR_SIZE, gln ) );\n        \n        float coinImp = step( 0.0, g_S.timeCollected ) * impulse( 2.0, max( 0.0, iTime - g_S.timeCollected ) * 6.0 );\n        albedo = mix( carCol, vec3( 1.0, 1.0, 0.5 ), sin( 100.0 * iTime ) * coinImp );\n        \n        float obsImp = step( 0.0, g_S.timeFailed ) * max( 0.0, iTime - g_S.timeFailed );\n        albedo = mix( albedo, vec3( 1.0, 0.0, 0.0) , sin( 100.0 * iTime ) * obsImp );\n    }\n    \n    if ( m == 1.5 )\n    {\n        emissive = albedo = vec3( 1.5, 0.5, 0.5 );\n    }\n    \n    if ( m == 1.6 )\n    {\n        emissive = albedo = vec3( 0.5, 0.5, 1.5 );\n    }\n    \n    if ( m == 2.0 )\n    {\n        albedo = vec3( 1.0, 1.0, 0.5 );\n        emissive = 10.0 * albedo;\n    }\n    \n    if ( m == 3.0 )\n    {\n       vec2 p0 = 2.6 * lPos.xz;\n        p0.x -= 1.5 * sin( 0.05 * p0.y * PI) * smoothstep( -0.5, 0.5, sin( iTime ) );\n        vec2 uv = abs( mod( 3.0 * lPos.xz + GRID_SIZE \/ 2.0, GRID_SIZE ) - GRID_SIZE \/ 2.0 );         \n        uv \/= fwidth( lPos.xz );\n        float gln = min( min( uv.x, uv.y ), 1. ) \/ GRID_SIZE;\n        \n        albedo = mix( CAR_COLOR_1, CAR_COLOR_2, 0.7 - smoothstep( 0.0, GRID_CAR_LINE_SIZE \/ GRID_CAR_SIZE, gln ) );\n    }\n    \n    if ( m == 3.5 )\n    {\n        emissive = albedo = vec3( 1.0, 0.5, 0.5 );\n    }\n    \n    if ( m == 3.6 )\n    {\n        emissive = albedo = vec3( 0.5, 0.5, 1.0 );\n    }\n\n    if ( m == 4.0 )\n    {\n        albedo = 0.2 * vec3( 1.0, 0.0, 1.0 );\n    }\n            \n\t\/\/ spotlight, paramteres-\n    vec3 perSpotOffset = vec3( 0.0, 0.05, 0.8 );\n    vec3 pSpot = vec3( wPos.x - g_S.playerPos.x, 0.0, wPos.z );\n    pSpot -= perSpotOffset;\n    vec3 spotDir = normalize( vec3( 0.0, -0.1, 1.0 ) );\n    vec3 spotColor  = 100.0 * vec3( 1.0 );\n    \n    pSpot.yz *= rot( -0.2  * bent.y );\n    pSpot.xz *= rot( -0.01 * bent.y * PI + rotY );\n    pSpot.yz *= rot( -0.01 * bent.x * PI + rotX );\n    spotDir.yz *= rot( 0.2 * bent.y );\n    spotDir.xz *= rot(-0.2 * rotY );\n    spotDir.yz *= rot(-0.2 * rotX );\n    \n    \/\/ spotlight, color\n    float maskDist = fract( ( length( pSpot ) - 1.0 ) );\n    float spotAtt = 1.0 \/ pow( 1.0 * length( pSpot ), 2.0 );\n    spotAtt *= smoothstep( 0.1, 1.1, dot( normalize( pSpot ), spotDir ) );\n    spotAtt *= saturate( dot( -nor, spotDir ) );\n    emissive += albedo * spotColor * spotAtt;    \n        \n    float fre = pow( 0.5 * ( 1.0 + dot( nor, rd ) ), 2.0 );\n    float amb = clamp( 0.5 + 0.5 * nor.y, 0.0, 1.0 );\n    float occ = calcAO( wPos, nor );    \n    vec3  lig = normalize( SUN_DIRECTION + vec3( 0.0, 0.2, 0.0 ) );\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n\tvec3  hal = normalize( lig - rd );\n    float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ), 64.0 )\n        * dif\n        * ( 0.04 + 0.96 * pow( clamp( 1.0 + dot( hal, rd ), 0.0, 1.0 ), 5.0 ) );\n   \n    color.rgb = albedo * ( 0.5 + 0.5 * occ ) * ( 0.7 + 0.3 * dif ) + spe * vec3( 1.0, 0.5, 0.1 );\n\tcolor.rgb += emissive;\n\tcolor.a = fre;\n    \n    return color;\n    \/\/ return vec4(vec3(0.4) * m, 0.5); \/\/ debug material ID\n    \/\/ return vec4(vec3(fre), 0.0);\n}\n\nfloat densityNoise( vec3 pos )\n{\n    vec2 bent = getBent();\n    \n    float noise = 1.0;\n    float noiseDetail = textureLod( iChannel1, vec2( 1.0, 1.0 ) * pos.xz \/ 64.0, 0.0 ).x;        \n    pos.x -= pos.y;\n    vec2 uv1 = vec2( 0.2, 1.5 ) * pos.xz \/ 64.0 + iTime * vec2( 0.01, 0.1 );\n    float noiseBase = textureLod( iChannel1, uv1, 0.0 ).y;\n    noise = step( 0.6, noiseBase );\n    noise *= noiseDetail * 0.5 + 0.5;\n    noise *= smoothstep( 1.5, 0.0, pos.y ); \/\/ height falloff    \n    noise *= ( 1.0 - bent.y ); \/\/ disable on hills    \n\treturn noise;\n}\n\nvoid volumetricFog( inout vec3 color, vec3 rayOrigin, vec3 rayDir, float sceneT )\n{ \/\/ From \"[SH16B] Speed Drive 80\" by knarkowicz. https:\/\/shadertoy.com\/view\/4ldGz4\n    float gFogDensity\t\t= 0.1;\n    rayOrigin.z += 2.0 * g_S.playerPos.y;\n    \n    sceneT = sceneT <= 0.0 ? 100.0 : sceneT;\n    \n    vec3 seed = vec3( 0.06711056, 0.00583715, 52.9829189 );\n    float dither = fract( seed.z * fract( dot( gl_FragCoord.xy, seed.xy ) ) );\n    \n    float fogAlpha = 0.0;\n    for ( int i = ZERO; i < 32; ++i )\n    {\n        float t = ( float( i ) + 0.5 + dither ) * 5.0;\n        if ( t <= sceneT )\n        {\n        \tvec3 p = rayOrigin + t * rayDir;\n            float s = densityNoise( p );\n            fogAlpha += gFogDensity * t * exp( -gFogDensity * t ) * s;\n        }\n    }\n    fogAlpha = 1.0 - saturate( fogAlpha );\n    vec3 fogColor = FOG_COLOR + vec3( 1.0 );\n    color = mix( fogColor, color, fogAlpha );\n    \/\/ color = vec3(0.01)*sceneT;\n}\n\nvec3 Bloom()\n{\n    vec3 bloom = vec3( 0.0 );\n    bloom += vec3( 1.0, 0.2, 0.1 )  * 0.5 * vec3( exp( -g_glowCoin * 10.0 ) );\n    bloom += vec3( 1.0, 0.2, 0.1 )  * 0.3 * vec3( exp( -g_glowCoinRefl * 10.0 ) );\n    bloom += vec3( 1.0, 0.2, 0.0 )  * 1.0 * vec3( exp( -saturate(g_glowPlayer) * 10.0 ) );\n    bloom += vec3( 1.0, 0.2, 0.0 )  * 0.5 * vec3( exp( -saturate(g_glowPlayerRefl) * 10.0 ) );\n    bloom += vec3( 1.0, 0.05, 0.0 ) * 0.3 * vec3( exp( -saturate(g_glowPlayerLights) * 15.0 ) );\n    bloom += vec3( 0.0, 0.05, 1.0 ) * 0.3 * vec3( exp( -saturate(g_glowPlayerFront) * 15.0 ) );\n    bloom += vec3( 1.0, 0.2, 0.0 )  * 0.5 * vec3( exp( -saturate(g_glowEnemy) * 5.0 ) );\n    bloom += vec3( 1.0, 0.2, 0.0 )  * 0.0 * vec3( exp( -saturate(g_glowEnemyRefl) * 5.0 ) );\n    return bloom;\n}\n\nvec4 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 sky = getSkyColor( rd );\n    vec4 col = vec4( sky, 1.0 );\n    sHit sRes = castRay( ro, rd, 1.0, 40.0 );\n    float t = sRes.t;\n\tfloat m = sRes.m;\n    if( m > -0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n\t\t\n        col = shade( pos, sRes.lPos, nor, rd, m );\n\n#ifdef REFLECTIONS\n        vec3 seed = vec3( 0.06711056, 0.00583715, 52.9829189 );\n\t    float dither = fract( seed.z * fract( dot( gl_FragCoord.yx + fract( iTime ), seed.xy ) ) );\n\n        vec4 bounceCol = vec4( getSkyColor( ref ), 0.0 );\n        ref = normalize( mix( ref, vec3(0.0, 1.0, 0.0 ), dither * 0.1 ) );\n        sHit bounceRes = castRayRefl( pos, ref, 0.1, 20.0 ); \/\/ only trace for bloom, do not shade\n        float bounceT = bounceRes.t;\n        if ( bounceRes.m < 0.0 )\n        \tbounceCol = vec4( getSkyColor( ref ), 0.0 );\n\n        col = vec4( mix( col.xyz, bounceCol.xyz, col.w ), 0.0 );\n            \n#endif \/\/ REFLECTIONS\n        \n        col.rgb += Bloom();\n        col.rgb *= 1.5;        \n    }\n        \n    col.rgb = mix( col.rgb, FOG_COLOR, 1.0 - exp( -0.00005 * t * t * t ) );\n\n#ifdef VOLUMETRICS\n    volumetricFog( col.rgb, ro, rd, t );\n#endif \/\/ VOLUMETRICS\n    \n    \/\/ blur mask\n    col.a = 1.0 - ( dot( rd, normalize( SUN_DIRECTION + vec3( 0.0, 0.05, 0.0 ) ) ) * 0.5 + 0.5 );\n    \n\treturn col;\n}\n\nvoid drawGame3D( inout vec4 color, vec2 uv, AppState s )\n{   \n    vec2 mo = iMouse.xy \/ iResolution.xy;\n   \n    vec2 bent = getBent();\n\n    float fbm = fbm3( vec3( 1000.0 * iTime ) );\n    float crash = step( 0.0, g_S.timeFailed ) * impulse( 2.0, max( 0.0, iTime - g_S.timeFailed ) * 6.0 );\n    \/\/ camera\t    \n    float roll = -0.1 * bent.x;\n    float arm = 3.5 + 0.2 * s.paceScale;\n    float angleH = -0.5 * PI + 0.1 * bent.x;\n    float height = 1.2 + bent.y + crash * fbm + 0.05 * g_S.paceScale * fbm;\n    float fov = 2.0 - 0.5 * s.paceScale;\n    \n    vec3 ro = vec3( 0.0 );\n    \n    if ( s.timeFailed > 0.0 )\n    {\n        roll = mix( roll, 0.0, saturate( iTime - s.timeFailed ) );\n        arm = mix( arm, 3.5, saturate( iTime - s.timeFailed ) );\n        angleH += iTime - s.timeFailed;\n    }\n    \n    if ( s.stateID == GS_SPLASH )\n    {\n        arm += 0.5 * sin( iTime ) * 0.5 + 0.5;\n        roll = -0.1 * ( mo.x - 0.5 );\n        angleH += 0.5 * ( mo.x - 0.5 );\n        height += 0.5 * (mo.y - 0.5 );                \n    }\n    \n    ro = vec3( arm * cos( angleH ), height, arm * sin( angleH ) );\n    \n#ifdef DEBUG_CAMERA    \n    roll = 0.0;\n    ro = vec3( 0.5 + 3.5 * cos( 12.0 * mo.x ), 0.5 + 4.0 * mo.y, -0.5 + 3.5 * sin( 12.0 * mo.x ) );\n#endif        \n    \n    vec3 ta = vec3(\n        0.0, \n        mix( 1.0, 0.5, step( 0.0, s.timeFailed ) * saturate( iTime - s.timeFailed ) ),\n        0.0\n    );\n\n#ifdef CAM_STICKED    \n    ro.x += s.playerPos.x;\n    ta.x += s.playerPos.x;\n#endif    \n    \n    \/\/ camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, roll );\n   \n    \/\/ ray direction\n    vec3 rd = ca * normalize( vec3( uv.xy, fov ) );\n    \n    \/\/ render\t\n    vec4 col = render( ro, rd );\n       \n    color = col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4(0.0);\n    \n\tvec2 q = F.xy \/ R.xy;\n    vec2 p = -1. + 2. * q;\n\tp.x *= R.x \/ R.y;\n\n#ifdef FORCED_RATIO\n\tfloat bars = step( abs( p.y ) * g_forceRatio, R.x \/ R.y );\n    if ( bars < 0.5 ) return;\n#endif \/\/ FORCED_RATIO    \n    \n    AppState s;\n    loadState( iChannel0, s );\n    g_S = s;\n\n    vec4 color = vec4( 0.0, 0.0, 0.0, 1.0 );\n       \n    vec2 pGame = p;\n    pGame.x *= -1.0; \/\/ flip axis to match Flat version\n    drawGame3D( color, pGame, s );\n   \n#ifdef DEBUG_2D\n    vec2 p0 = p;    \n    p0 *= 2.0;\n    p0 -= vec2( -3.0, 0.0 );\n    if ( p0.x < 0.7 && p0.y > -1.0 )\n    {\n        \/\/ drawGameFlat( color, p0, s );\n    \t\/\/ drawUI(color, p0, s);\n    }\n#endif    \n    \n\tfragColor = color;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGzr","filepath":"\/media\/a\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"\/media\/ap\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\/\/ Copyright \u00a9 2019 Michal Klos\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ Sunset Drive Unlimited\n\/\/  Endless runner with synthwave stylization\n\/\/\t\"Brick Driver\" sequel, because it missed fluent turning and coins:\n\/\/\thttps:\/\/www.shadertoy.com\/view\/wssSD4\n\n\/\/ #define options in Common tab\n\/\/  Some effects can be disabled on low end gpus\n\n\/\/ Gameplay is based on Brick Game Racing,\n\/\/  https:\/\/youtu.be\/EdMyKRC8qyU\n\n\/\/ First draft created in 24h on Game Jam Square 26-28.04.2019\n\/\/\tFinished after couple of spare evenings on 24.06.2019\n\n\/\/ Based on:\n\/\/ - \"80's raymarching\" by villedieumorgan. https:\/\/shadertoy.com\/view\/lsVSRt\n\/\/ - \"[SH16B] Speed Drive 80\" by knarkowicz. https:\/\/shadertoy.com\/view\/4ldGz4\n\/\/ Other snippets credits in comments next to the code\n\/\/ Thank you guys for sharing it, hope you like it :)\n\n\/\/ Music: Lifelike - So Electric\n\/\/  https:\/\/soundcloud.com\/rombo_rama\/lifelike-so-electric\n\n\n\nfloat textSDF( vec2 p, float glyph )\n{\n    p = abs( p.x - .5 ) > .5 || abs( p.y - .5 ) > .5 ? vec2( 0. ) : p;\n    return 2. * ( texture( iChannel3, p \/ 16. + fract( vec2( glyph, 15. - floor( glyph \/ 16. ) ) \/ 16. ) ).w - 127. \/ 255. );\n}\n\nvoid menuText( inout vec3 color, vec2 p, in AppState s )\n{        \n    vec2 scale = vec2( 4., 8. );\n    vec2 t = floor( p \/ scale );   \n    \n    uint v = 0u;\n\tv = t.y == 2. ? ( t.x < 4. ? 1768452929u : ( t.x < 8. ? 1768777835u : ( t.x < 12. ? 5653614u : 0u ) ) ) : v;\n\tv = t.y == 1. ? ( t.x < 4. ? 1918986307u : ( t.x < 8. ? 1147496812u : ( t.x < 12. ? 1752383839u : ( t.x < 16. ? 1835559785u : 5664361u ) ) ) ) : v;\n\tv = t.y == 0. ? ( t.x < 4. ? 1918986307u : ( t.x < 8. ? 1147496812u : ( t.x < 12. ? 86u : 0u ) ) ) : v;\n\tv = t.x >= 0. && t.x < 20. ? v : 0u;\n    \n\tfloat c = float( ( v >> uint( 8. * t.x ) ) & 255u );\n    \n\tvec3 textColor = vec3( 1.0 );\n\n    p = ( p - t * scale ) \/ scale;\n    p.x = ( p.x - .5 ) * .5 + .5;\n    float sdf = textSDF( p, c );\n    if ( c != 0. )\n    {\n    \tcolor = mix( textColor, color, smoothstep( -.05, +.05, sdf ) );\n    }\n}\n\nfloat titleText( vec2 p )\n{        \n    vec2 scale = vec2( 4., 8. );\n    vec2 t = floor( p \/ scale );   \n    \n    uint v = 0u;\n\tv = t.y == 0. ? ( t.x < 4. ? 1397642579u : ( t.x < 8. ? 1142969413u : ( t.x < 12. ? 1163282770u : ( t.x < 16. ? 1280202016u : ( t.x < 20. ? 1414090057u : 17477u ) ) ) ) ) : v;\n\tv = t.x >= 0. && t.x < 24. ? v : 0u;\n    \n\tfloat c = float( ( v >> uint( 8. * t.x ) ) & 255u );\n    \n    p = ( p - t * scale ) \/ scale;\n    p.x = ( p.x - .5 ) * .5 + .5;\n    float sdf = textSDF( p, c );\n    return ( c != 0. ) ? smoothstep( -.05, +.05, sdf ) : 1.0;\n}\n\nfloat spaceText(vec2 p)\n{        \n    vec2 scale = vec2( 4., 8. );\n    vec2 t = floor( p \/ scale );   \n    \n    uint v = 0u;    \n    v = t.y == 0. ? ( t.x < 4. ? 1936028240u : ( t.x < 8. ? 1935351923u : ( t.x < 12. ? 1701011824u : ( t.x < 16. ? 1869881437u : ( t.x < 20. ? 1635021600u : 29810u ) ) ) ) ) : v;\n\tv = t.x >= 0. && t.x < 24. ? v : 0u;\n    \n\tfloat c = float( ( v >> uint( 8. * t.x ) ) & 255u );\n    \n    p = ( p - t * scale ) \/ scale;\n    p.x = (p.x - .5 ) * .5 + .5;\n    float sdf = textSDF( p, c );\n    return ( c != 0. ) ? smoothstep( -.05, +.05, sdf ) : 1.0;\n}\n\nfloat highscoreText( vec2 p )\n{        \n    vec2 scale = vec2( 4., 8. );\n    vec2 t = floor( p \/ scale );\n    \n    uint v = 0u;    \n\tv = t.y == 0. ? ( t.x < 4. ? 1751607624u : ( t.x < 8. ? 1919902579u : 14949u ) ) : v;\n\tv = t.x >= 0. && t.x < 12. ? v : 0u;\n    \n\tfloat c = float( ( v >> uint( 8. * t.x ) ) & 255u );\n    \n    p = ( p - t * scale ) \/ scale;\n    p.x = ( p.x - .5 ) * .5 + .5;\n    float sdf = textSDF( p, c );\n    return ( c != 0. ) ? smoothstep( -.05, +.05, sdf ) : 1.0;\n}\n\nvoid drawUI(inout vec3 color, vec2 p, AppState s)\n{\n    p *= R.y \/ R.x; \/\/ ratio and resolution indepenent scaling\n    p *= 1.75;\n    \n    \/\/ splash screen   \n    if ( s.stateID == GS_SPLASH )\n    {\n        color.rgb *= 0.1 + 0.9 * smoothstep( 0.75, 0.0, p.y ); \/\/ dark text bg\n\t\tvec2 p2 = p;\n\t\tp2 *= 50.;\n\t\tp2 -= vec2( -45, 27. );\n        \/\/ color.rgb = mix(color.rgb, vec3(0.0), 1.0-smoothstep(0.0, 0.5, abs(p2.y)) ); \/\/ horiz guide\n        \n        float maskTitle = titleText( p2 ); \/\/ Sunset Drive Unlimited\n        color.rgb = mix( vec3( 1.0 ), color.rgb, maskTitle );\n        \n\t\tvec2 p1 = p;\n\t\tp1 *= 60. + 5. * abs( sin( 2.0 * iTime ) );\n\t\tp1 -= vec2( -47., -42. );\n        float maskSpace = spaceText( p1 ); \/\/ press [space] to start\n        color.rgb = mix( vec3( 1.0 ), color.rgb, maskSpace );\n\n\t\tvec2 p3 = p;\n\t\tp3 *= 60.;\n\t\tp3 -= vec2( -30, 25. );\n        float maskHs = highscoreText( p3 ); \/\/ Highscore\n        color.rgb = mix( vec3( 1.0 ), color.rgb, maskHs );\n\n\t\tvec2 pScore = p;\n        pScore *= 12.0;\n        pScore -= vec2( 1.3, 5.3 );\n        float sScore = printInt( pScore, s.highscore );\n        color.rgb = mix( color.rgb, vec3( 1.0 ), sScore );\n    }\n    else\n    {\n        vec2 pScore = p;\n        pScore *= 6.0;\n        pScore -= vec2( -0.9, 3.4 );\n        float maxDigits = ceil( log2( s.score ) \/ log2( 10.0 ) );\n        pScore.x += 0.5 * maxDigits;\n        float sScore = printInt( pScore, s.score );\n        color.rgb = mix( color.rgb, vec3( 1.0 ), sScore );\n    }\n\n\t\/\/ color.rgb = mix(color.rgb, vec3(0.0), 1.0-smoothstep(0.0, 0.01, abs(p.x)) ); \/\/ center guide\n    \/\/ color.rgb = mix(color.rgb, vec3(0.0), 1.0-smoothstep(0.0, 0.01, abs(p.y)) ); \/\/ horiz guide\n}\n\nconst float gaussianWeights[6] = float[] (\n\t0.12801,\n\t0.12299,\n\t0.10908,\n\t0.08931,\n\t0.06750,\n\t0.04709 \n);\n\nvec3 rbg( sampler2D t, vec2 UV, vec2 dir )\n{\n\tvec3 c = vec3( 0 );\n\tvec2 uv = 1.0 - 2.0 * UV;\t\n    vec2 rRcp = 1.0 \/ vec2( 1920.0, 1080.0 );\n\tfor( int i = -5; i < 6; ++i )\n    {\n\t\tc += gaussianWeights[abs( i )] * textureLod( t, 0.5 - 0.5 * ( uv + rRcp * dir * float( i ) ), 0.0 ).rgb;\n\t}\n\treturn c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n \tvec2 uv = F.xy \/ R.xy;\n    vec2 p = -1. + 2. * uv;\n\tp.x *= R.x \/ R.y;\n\n#ifdef FORCED_RATIO\n\tfloat bars = step( abs( p.y ) * g_forceRatio, R.x \/ R.y );\n    if ( bars < 0.5 ) return;\t\n#endif\n    \n    AppState s;\n    loadState( iChannel1, s );\n    \n    float scale = 5.0 * s.paceScale;\n    \n    if ( s.timeFailed > 0.0 )\n    {\n        scale = 1.0;\n    }\n    \n    if ( s.stateID == GS_SPLASH )\n    {\n        scale = 4.0;\n    }\n    \n    scale += 0.1;\n\n\tvec4 beauty = texture( iChannel0, uv );\n    vec2 dir = normalize( vec2( dFdx( beauty.a ), dFdy( beauty.a ) ) );\n    vec3 blurred = rbg( iChannel0, uv, dir * scale );    \n    float blurMask = 0.1 + smoothstep( 0.0, 0.2, beauty.a ); \/\/ 0.1 bias to blur a bit dithered volumetrics at center\n    vec3 color = mix( beauty.rgb, blurred, blurMask ); \n\n#ifdef SHOW_UI\n        drawUI( color, p, s );\n#endif\n        \n    fragColor = vec4( color, 1.0 );\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\/\/ Copyright \u00a9 2019 Michal Klos\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ Sunset Drive Unlimited\n\/\/  Endless runner with synthwave stylization\n\/\/\t\"Brick Driver\" sequel, because it missed fluent turning and coins:\n\/\/\thttps:\/\/www.shadertoy.com\/view\/wssSD4\n\n\/\/ #define options in Common tab\n\/\/  Some effects can be disabled on low end gpus\n\n\/\/ Gameplay is based on Brick Game Racing,\n\/\/  https:\/\/youtu.be\/EdMyKRC8qyU\n\n\/\/ First draft created in 24h on Game Jam Square 26-28.04.2019\n\/\/\tFinished after couple of spare evenings on 24.06.2019\n\n\/\/ Based on:\n\/\/ - \"80's raymarching\" by villedieumorgan. https:\/\/shadertoy.com\/view\/lsVSRt\n\/\/ - \"[SH16B] Speed Drive 80\" by knarkowicz. https:\/\/shadertoy.com\/view\/4ldGz4\n\/\/ Other snippets credits in comments next to the code\n\/\/ Thank you guys for sharing it, hope you like it :)\n\n\/\/ Music: Lifelike - So Electric\n\/\/  https:\/\/soundcloud.com\/rombo_rama\/lifelike-so-electric\n\n\n\nvec2 barrelDistortion( vec2 coord, float amt, float zoom )\n{ \/\/ based on gtoledo3 (XslGz8)\n  \/\/ added zoomimg\n\tvec2 cc = coord - 0.5;\n    vec2 p = cc * zoom;\n    coord = p + 0.5;\n\tfloat dist = dot( cc, cc );\n\treturn coord + cc * dist * amt;\n}\n\nvec3 tonemapACES( vec3 x )\n{\n    \/\/ Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\t        \n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return ( x * ( a * x + b ) ) \/ ( x * ( c * x + d ) + e );\n}\n\nvec3 ca( sampler2D t, vec2 UV )\n{\t\n\tconst int N = 8;\t\n    float scale = 1.0;\n\tvec2 uv = 1.0 - 2.0 * UV;\n\tvec3 c = vec3( 0 );\n\tfloat rf = 1.0;\n\tfloat gf = 1.0;\n    float bf = 1.0;\n\tfloat f = 1.0 \/ float( N );\n\tfor( int i = 0; i < N; ++i )\n    {\n\t\tc.r += f * texture( t, 0.5 - 0.5 * ( ( uv ) * rf ) ).r;\n\t\tc.g += f * texture( t, 0.5 - 0.5 * ( ( uv ) * gf ) ).g;\n\t\tc.b += f * texture( t, 0.5 - 0.5 * ( ( uv ) * bf ) ).b;\n\t\trf *= mix( 1.0, 0.9972, scale );\n\t\tgf *= mix( 1.0, 0.998,  scale );\n        bf \/= mix( 1.0, 0.9988, scale );\n\t}\n\treturn c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    fragColor = vec4(0.0);\n\t\n\tvec2 uv = F.xy \/ R.xy;\n    vec2 q = 1.0 - 2.0 * uv;\n    q.x *= R.x \/ R.y;\n\n#ifdef FORCED_RATIO        \n\tfloat bars = step( abs( q.y ) * g_forceRatio, R.x \/ R.y );\n    if ( bars < 0.5 ) return;\t\n#endif\n\n    \/\/ barrel distortion\n\tvec2 uvb = barrelDistortion( uv, 0.1, 0.97 );\n    \n    \/\/ chromatic aberration\t\n    vec3 color;\n\tcolor.rgb = ca( iChannel0, uv );\n    \/\/ color = texture( iChannel0, uv ).rgb;\n    \n    \/\/ vignette\n\tcolor.rgb *= 0.7 + 0.3 * clamp( pow( 28.0 * uv.x * uv.y * ( 1.0 - uv.x ) * ( 1.0 - uv.y ), 2.0 ), 0.0, 1.0 );\n\t\n\t\/\/ grade\n#ifdef GRADE\n    color.rgb = smoothstep( vec3( -0.05 ), vec3( 0.8 ), color.rgb );\n#endif\n          \n    color.rgb = tonemapACES( color.rgb );\n     \n\tfragColor.rgb = color;\n}","name":"Buffer D","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"XlSBRW","date":"1514685239","viewed":4911,"name":"Crystal Drops","username":"spolsh","description":"Inspired by UE4 Protostar demo and Liquid Carbon by Virgill.\nMouse enabled.\nTested on GTX970 at 1920x1200 on Chrome, Firefox and Opera.\n\nFeel free to feedback how to improve performance and code :)","likes":97,"published":3,"flags":96,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xd2SRD","filepath":"https:\/\/soundcloud.com\/hybridminds\/hybrid-minds-meant-to-be?in=shaniithebunny\/sets\/liqud","previewfilepath":"https:\/\/soundcloud.com\/hybridminds\/hybrid-minds-meant-to-be?in=shaniithebunny\/sets\/liqud","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Crystal Drops\n\/\/ by Michal 'spolsh' Klos 2017\n\n\/\/ Works well with Pulfrich Effect:\n\/\/ https:\/\/en.wikipedia.org\/wiki\/Pulfrich_effect\n\/\/ https:\/\/www.youtube.com\/watch?v=Q-v4LsbFc5c\n\n\/\/ comment line 5 in Buf A to animate camera endlessly\n\n#define R iResolution\n#define T iTime\n#define F gl_FragCoord\n#define M iMouse\n\n\/\/ uncomment to enable FPS counter \n\/\/ #define FPS_COUNTER\n\n\/\/-----------------------------------------------------------------\n\/\/ Digit drawing function by P_Malin (https:\/\/www.shadertoy.com\/view\/4sf3RN)\n\nfloat SampleDigit(const in float n, const in vec2 vUV)\n{\t\t\n\tif(vUV.x  < 0.0) return 0.0;\n\tif(vUV.y  < 0.0) return 0.0;\n\tif(vUV.x >= 1.0) return 0.0;\n\tif(vUV.y >= 1.0) return 0.0;\n\t\n\tfloat data = 0.0;\n\t\n\t     if(n < 0.5) data = 7.0 + 5.0*16.0 + 5.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\telse if(n < 1.5) data = 2.0 + 2.0*16.0 + 2.0*256.0 + 2.0*4096.0 + 2.0*65536.0;\n\telse if(n < 2.5) data = 7.0 + 1.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 3.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 4.5) data = 4.0 + 7.0*16.0 + 5.0*256.0 + 1.0*4096.0 + 1.0*65536.0;\n\telse if(n < 5.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n\telse if(n < 6.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n\telse if(n < 7.5) data = 4.0 + 4.0*16.0 + 4.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 8.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\telse if(n < 9.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\t\n\tvec2 vPixel = floor(vUV * vec2(4.0, 5.0));\n\tfloat fIndex = vPixel.x + (vPixel.y * 4.0);\n\t\n\treturn mod(floor(data \/ pow(2.0, fIndex)), 2.0);\n}\n\nfloat PrintInt(const in vec2 uv, const in float value )\n{\n\tfloat res = 0.0;\n\tfloat maxDigits = 1.0+ceil(log2(value)\/log2(10.0));\n\tfloat digitID = floor(uv.x);\n\tif( digitID>0.0 && digitID<maxDigits )\n\t{\n        float digitVa = mod( floor( value\/pow(10.0,maxDigits-1.0-digitID) ), 10.0 );\n        res = SampleDigit( digitVa, vec2(fract(uv.x), uv.y) );\n\t}\n\n\treturn res;\t\n}\n\nfloat nrand(vec2 n)\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nvec3 filmGrainColor(vec2 uv, float offset)\n{ \/\/ by ma (lstGWn)\n    vec4 uvs;\n    uvs.xy = uv + vec2(offset, offset);\n    uvs.zw = uvs.xy + 0.5*vec2(1.0 \/ iResolution.x, 1.0 \/ iResolution.y);\n\n    uvs = fract(uvs * vec2(21.5932, 21.77156).xyxy);\n\n    vec2 shift = vec2(21.5351, 14.3137);\n    vec2 temp0 = uvs.xy + dot(uvs.yx, uvs.xy + shift);\n    vec2 temp1 = uvs.xw + dot(uvs.wx, uvs.xw + shift);\n    vec2 temp2 = uvs.zy + dot(uvs.yz, uvs.zy + shift);\n    vec2 temp3 = uvs.zw + dot(uvs.wz, uvs.zw + shift);\n\n    vec3 r = vec3(0.0, 0.0, 0.0);\n    r += fract(temp0.x * temp0.y * vec3(95.4337, 96.4337, 97.4337));\n    r += fract(temp1.x * temp1.y * vec3(95.4337, 96.4337, 97.4337));\n    r += fract(temp2.x * temp2.y * vec3(95.4337, 96.4337, 97.4337));\n    r += fract(temp3.x * temp3.y * vec3(95.4337, 96.4337, 97.4337));\n\n    return r * 0.25;\n}\n\nvec2 barrelDistortion(vec2 coord, float amt, float zoom)\n{ \/\/ based on gtoledo3 (XslGz8)\n  \/\/ added zoomimg\n\tvec2 cc = coord-0.5;\n    vec2 p = cc*zoom;\n    coord = p+0.5;\n\tfloat dist = dot(cc, cc);\n\treturn coord +cc*dist*amt;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    fragColor = vec4(0.0);\n    vec2 uv = F.xy\/R.xy;\n    vec2 vv = 2.0*(uv-0.5);\n    vv.x *= R.x\/R.y;\n \n    float cas = step(abs(vv.y)*2.39,R.x\/R.y);\n    if (cas<0.1) return;\n \n    vec3 c = texture(iChannel0, uv).rgb;   \n        \n    uv = barrelDistortion(uv, 0.1, 0.96);\n           \n    \/\/ chromatic abberation inspired by knifa (lsKSDz)\n    vec2 d = abs((uv-0.5)*2.0);    \n    d = pow(d, vec2(1.5, 1.0));\n    d.y *= 0.1;\n    \n    float dScale = 0.01;\n    const int maxSamples = 4;\n    vec4 r, g, b;\n    r = g = b = vec4(0.0);\n    for (int i=0; i<maxSamples; ++i)\n    {\n        float rnd = nrand(uv+vec2(i)+0.001*T);\n    \tr += texture(iChannel0, uv +d*rnd*dScale);\n    \tg += texture(iChannel0, uv);\n    \tb += texture(iChannel0, uv -d*rnd*dScale);\n\t}\n    \n    c = vec3(r.r, g.g, b.b)\/vec3(maxSamples);\n    \n    c *= 1.0 -0.25*filmGrainColor(0.5*uv, T).rgb;\n    \n    c = pow(c, vec3(0.4545));\n    \n    vec2 v = 2.*(uv-.5);\n    v.y *= 2.39 * R.y\/R.x;\n    v = clamp((v*.5)+.5, 0., 1.);\n    \/\/ c.rgb = vec3(1.0); \/\/ uncomment to see only vignette\n    c *= 0.25 + 0.75*pow( 16.0*v.x*v.y*(1.0-v.x)*(1.0-v.y), 0.25);\n    \n#ifdef FPS_COUNTER    \n    vec2 h = F.xy\/R.xy; \n    h.x *= R.x \/ R.y;\n    c += PrintInt( (h -vec2(0.0,0.21))*30.0, iFrameRate );\n#endif \n    \n    fragColor = vec4(c, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3zn","filepath":"\/media\/a\/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"\/media\/ap\/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ Crystal Drops\n\/\/ by Michal 'spolsh' Klos 2017\n\n\/\/ comment to animate camera endlessly\n\/\/ #define SLOMO_LOOP\n\n#define R iResolution\n#define F gl_FragCoord\n#define M iMouse\n\n#define HASHSCALE4 vec4(.1031, .1030, .0973, .1099)\n\nfloat T = 0.0;\n\nvec4 hash41(float p)\n{ \/\/ by Dave_Hoskins\n\tvec4 p4 = fract(vec4(p) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);    \n}\n\n\/\/ polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{ \/\/ by iq\n    float h = clamp( 0.5+0.5*(b-a)\/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat map(vec3 p)\n{\n    float s = length(p -vec3(0.0, .01*sin(8.0*T), 0.0)) - 0.5;\n\ts += 0.005*sin(45.0*p.x+10.0*T);\n    \n    for (int i=0; i<12; ++i) {\n        vec4 rnd = hash41(100.0+float(i));        \n        vec3 rndPos = 2.0*(normalize(rnd.xyz) -vec3(0.5));\n        rndPos.y *= 0.2;\n        float timeOffset = rnd.w;\n        float phase = fract(timeOffset -0.25*T);\n\t\tvec3 offset = mix( 0.1*rndPos, 15.0*rndPos, phase);\n        float rnd2 = fract(rnd.x +rnd.y);\n        float s0 = length(p +offset) -0.25*mix(0.8 +0.2*rnd2, 0.2 +0.8*rnd2, phase);\n        s = smin(s, s0, 0.4);\n    }\n\n    s += 0.002*sin(20.0*p.x +10.0*T);\n        \n    return s;    \n}\n\nvec3 env(vec3 dir) \n{\n    vec3 cubemap = texture(iChannel0, dir).rgb;\n    float ex = mix(6.0, 12.0, 0.5*(sin(0.5*T) +1.0));\n    float t0 = 0.05*pow(1.0 -dot(vec3(0.0, -1.0, 0.0), dir), ex);\n    float t1 = mix(0.2, 2.5, 1.0 -abs(sin(2.0*3.14*dir.y)));    \n    vec3 c = cubemap *t0 *t1;\n    return c * vec3(0.35, 1.2, 2.5);\n}\n\nvec3 calcNormal(vec3 p)\n{ \/\/ by iq\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n\treturn normalize(\te.xyy *map(p + e.xyy) + \n\t\t\t\t\t\te.yxy *map(p + e.yxy) + \t\t\t\t\t  \n\t\t\t\t\t\te.yyx *map(p + e.yyx) + \t\t\t\t\t  \n\t\t\t\t  \t  \te.xxx *map(p + e.xxx) );\n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr)\n{ \/\/ by iq\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = normalize(cross(cu,cw));\n    return mat3(cu, cv, cw);\n}\n\nvec3 tonemapping(vec3 color)\n{ \/\/ by Zavie (lslGzl)\n\tcolor = max(vec3(0.), color-vec3(0.004));\n\tcolor = (color * (6.2*color+.5))\/(color*(6.2*color+1.7)+0.06);\n\treturn color;\n}\n\nfloat spline(float x, float x1, float x2, float y1, float dy1, float y2, float dy2)\n{\n\tfloat t = (x -x1) \/ (x2 -x1);\t\n    float a = 2.0*y1 -2.0*y2 +dy1 +dy2;\n\tfloat b = -3.0*y1 +3.0*y2 -2.0*dy1 -dy2;\n\tfloat c = dy1;\n\tfloat d = y1;\n\tfloat t2 = t*t;\n\tfloat t3 = t2*t;\n\treturn a * t3 +b*t2 +c*t +d;\n}\n\nvoid calcTime()\n{\n    T = iTime;\n#ifdef SLOMO_LOOP\n    \/\/ slomo by Dave (4s23RW)\n    T = mod(iTime, 20.0);\n\tconst float slomoMin = 2.3;\n\tconst float slomoMax = 2.6;\n\tconst float slomoK = 0.2;\n\tconst float slomoDuration = (slomoMax-slomoMin)\/slomoK;\n\tif (T >= slomoMin && T<slomoMin+slomoDuration)\n\t\tT = spline(T, slomoMin, slomoMin+slomoDuration, slomoMin, slomoDuration*0.3, slomoMax, slomoDuration*0.15);\n\telse if ( T >= slomoMin+slomoDuration)\n\t\tT = T -slomoDuration +(slomoMax-slomoMin);\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    calcTime();\n        \n    vec2 u = F.xy\/R.xy;\n    vec2 v = 2.0*(u -0.5);\n    v.x *= R.x\/R.y;\n    vec2 m = M.xy\/R.xy;\n    float cas = step(abs(v.y)*2.39,R.x\/R.y);\n    if (cas<0.1) return;\n        \n\tvec3 ro = vec3(\n        8.0*cos(0.2*T +6.0*m.x),\n        2.0*mix(-1.0,1.0, m.y),\n        8.0*sin(0.2*T +6.0*m.x)\n    );\n    float taAnim = 2.0*(smoothstep(-0.1, 0.1, sin(0.1*T)) -0.5);\n\tvec3 ta = vec3(taAnim, -0.05, 0.0);\n\t\t\n    mat3 ca = setCamera(ro, ta, 0.0);\n    vec3 rd = ca * normalize(vec3(v, mix(4.5, 5.0, taAnim)));    \n    vec3 p, c;\n    vec3 n, rl, rr;\n    p = vec3(0.0);\n    c = env(rd);\n    \n    float t, d, a;\n    t = d = a = 0.0;\n    for(int i=0; i<50; ++i) {\n        t+=(d=map(p=ro+rd*t));\n        if (d<0.01) {\n            break;\n        }                \n    }\n    \n    float depth = length(p-ro);\n    \n    if (t<25.0) { \/\/ if hit scene\n        \n    \tn = calcNormal(p);\n\t    rl = reflect(rd, n);\n\t    rr = refract(rd, n, .19);\n    \n        for(int i=0; i<25; ++i) {\n            d = map(p=ro+rd*t);\n            a += step(d, 0.008) *0.005;\n            t += 0.02;\n    \t}\n        \n        a = exp(-a*25.0);\n        c = env(mix(rr, rl, a));\n\t\t\/\/ c = vec3(a); \/\/ uncomment to see absorbtion mask\n        c *= mix(vec3(1.4, 1.0, 0.9), vec3(1.0), clamp(0.2*length(p), 0.0, 1.0)); \/\/ value        \n        c *= mix(vec3(1.5), vec3(.3), clamp(pow(0.1*depth, 2.0), 0.0, 1.0)); \/\/ fogging\n    }\n              \n    c = tonemapping(c);\n    \n    depth = 0.01*dot(rd, p-ro); \/\/ depth paraller to camera\n\tfragColor = vec4(c, depth);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\/\/ Crystal Drops\n\/\/ by Michal 'spolsh' Klos 2017\n\n#define R iResolution\n#define T iTime\n#define F gl_FragCoord\n\nvec3 sharpen()\n{ \/\/ by NickWest (lslGRr)\n    vec2 uv = F.xy\/R.xy;\n  \tvec2 step = 1.0\/iResolution.xy;\n    float scale = 1.5;\n\tvec3 texA = texture(iChannel0, uv + vec2(-step.x, -step.y) * scale).rgb;\n\tvec3 texB = texture(iChannel0, uv + vec2( step.x, -step.y) * scale).rgb;\n\tvec3 texC = texture(iChannel0, uv + vec2(-step.x,  step.y) * scale).rgb;\n\tvec3 texD = texture(iChannel0, uv + vec2( step.x,  step.y) * scale).rgb;   \n    vec3 around = 0.25 *(texA+texB+texC+texD);\n\tvec3 center = texture(iChannel0, uv).rgb;\n\tvec3 col = center +(center-around)*1.0;\n    return col;\n}\n\nfloat depthToMask(float d)\n{\n\td *= 100.0;\n    d = abs(d -8.5);\n    d = pow(d, 6.0);\n    d = clamp(d, 0.0, 1.0);    \n    return d;\n}\n\nvec2 Hash22(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\n\nvec4 bokeh(vec2 uv, float rad)\n{ \/\/ based on dof by Jochen \"Virgill\" Feldk\u00f6tter, Alcatraz \/ Rhodium 4k Intro liquid carbon\n  \/\/ simplyfied version of Dave Hoskins blur\n  \/\/ now bokeh is not cut within dof mask, added alpha blending based on difference of dof mask samples\n    const float GA =2.399; \n\tconst mat2 rot = mat2(cos(GA),sin(GA),-sin(GA),cos(GA));\n\tvec4 acc = vec4(texture(iChannel0,uv).rgb, rad);\n    float d = rad;\n    vec2 pixel=0.0002*vec2(5.*R.y\/R.x,7.);\n\tvec2 angle=vec2(0,rad);\n\tfor (int j=0;j<80;j++)\n    {  \n        rad += 1.\/rad;\n\t    angle*=rot;\n        vec4 col=texture(iChannel0, uv+pixel*(rad-1.)*angle);\n      \tacc.rgb = max(acc.rgb,col.rgb);\n        acc.a = max(acc.a, abs(d-depthToMask(col.w)));\n\t}\n\treturn acc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{      \n    vec2 uv = F.xy\/R.xy;    \n    vec2 v = 2.0*(uv-0.5);\n    v.x *= R.x\/R.y;\n    \n    float cas = step(abs(v.y)*2.39,R.x\/R.y);\n    if (cas<0.1) return;\n         \n    float d = depthToMask(texture(iChannel0, uv).w);\n    \/\/ fragColor = vec4(d); return; \/\/ uncomment to see dof mask\n    \n    vec3 sharp = sharpen();   \n\tvec4 dof = bokeh(uv, d);\n    fragColor = vec4(mix(sharp, dof.rgb, dof.a), 1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"wssSD4","date":"1551312724","viewed":3103,"name":"Brick Driver","username":"spolsh","description":"TKGJ2019 entry https:\/\/spolsh.itch.io\/bgr\nIn 24h Mixed two briliant retro shaders and created Racer game from Brick Game toys\nCredits to original authors are next to parts of code, thank you guys for sharing it. I have learned a lot making this game :)","likes":67,"published":3,"flags":112,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4tXGD4","filepath":"https:\/\/soundcloud.com\/lazerhawk\/king-of-the-streets","previewfilepath":"https:\/\/soundcloud.com\/lazerhawk\/king-of-the-streets","type":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Copyright \u00a9 2019 Michal Klos\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ Brick Driver\n\/\/  Entry for TK Game Jam 2019\n\/\/  Endless runner with synthwave stylization originally named \"Brick Game Racer\"\n\n\/\/ Awarded by the Jury\n\/\/  and 4th place based on audience votes against 55 other entries\n\/\/  https:\/\/spolsh.itch.io\/bgr\n\n\/\/ TK Game Jam 2019 is Game development challange\n\/\/  about creating game in 48h in Poland, Wroc\u0142aw 22-24.02.2019\n\/\/  https:\/\/itch.io\/jam\/tk-game-jam-2019\n\/\/  https:\/\/web.facebook.com\/events\/185669952375258\/250811702527749\/\n\n\/\/ Game aimed for Retro category\n\/\/  Themes used in game are synt(h)etic and development, \n\/\/  because graphics is inspired by synthwave and car gets faster the longer you play\n\n\/\/ Gameplay is based on Brick Game Racing,\n\/\/  https:\/\/youtu.be\/EdMyKRC8qyU?t=67\n\/\/  \"lagging\" of red cars is somewhat on purpose but can be fixed in future version\n\n\/\/ Based on:\n\/\/ - \"80's raymarching\" by villedieumorgan. https:\/\/shadertoy.com\/view\/lsVSRt\n\/\/ - \"Cloth Shading\" by knarkowicz. https:\/\/shadertoy.com\/view\/4tfBzn\n\/\/ - \"[SH16B] Speed Drive 80\" by knarkowicz. https:\/\/shadertoy.com\/view\/4ldGz4\n\/\/ Uses also snippets from:\n\/\/ - Digit drawing function by P_Malin (https:\/\/www.shadertoy.com\/view\/4sf3RN)\n\/\/ - Tiny Planet: Earth by morgan3d https:\/\/www.shadertoy.com\/view\/lt3XDM\n\/\/ Thnak you guys for sharing it, hope you like the game :)\n\n\/\/ Music: Laserhawk - King of the streets\n\/\/  https:\/\/soundcloud.com\/lazerhawk\/king-of-the-streets\n\n\n\/\/ Fork of \"[SH16B] Speed Drive 80\" by knarkowicz. https:\/\/shadertoy.com\/view\/4ldGz4\n\/\/ 2019-02-24 00:16:15\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tvec2 screenUV = fragCoord.xy \/ iResolution.xy;\n    \n    \/\/ chromatic abberation\n    float caStrength\t= 0.002;\n    vec2 caOffset \t\t= screenUV - 0.5;\n\tvec2 caUVG\t\t\t= screenUV + caOffset * caStrength;\n\tvec2 caUVB\t\t\t= screenUV + caOffset * caStrength * 2.0;\n\n    vec3 color;\n    color.x = texture( iChannel0, screenUV ).x;\n    color.y = texture( iChannel0, caUVG ).y;\n    color.z = texture( iChannel0, caUVB ).z;    \n    \n    fragColor = vec4( color, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"\/presets\/tex00.jpg","previewfilepath":"\/presets\/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ Copyright \u00a9 2019 Michal Klos\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ Brick Driver\n\/\/  Entry for TK Game Jam 2019\n\/\/  Endless runner with synthwave stylization originally named \"Brick Game Racer\"\n\n\/\/ Awarded by the Jury\n\/\/  and 4th place based on audience votes against 55 other entries\n\/\/  https:\/\/spolsh.itch.io\/bgr\n\n\/\/ TK Game Jam 2019 is Game development challange\n\/\/  about creating game in 48h in Poland, Wroc\u0142aw 22-24.02.2019\n\/\/  https:\/\/itch.io\/jam\/tk-game-jam-2019\n\/\/  https:\/\/web.facebook.com\/events\/185669952375258\/250811702527749\/\n\n\/\/ Game aimed for Retro category\n\/\/  Themes used in game are synt(h)etic and development, \n\/\/  because graphics is inspired by synthwave and car gets faster the longer you play\n\n\/\/ Gameplay is based on Brick Game Racing,\n\/\/  https:\/\/youtu.be\/EdMyKRC8qyU?t=67\n\/\/  \"lagging\" of red cars is somewhat on purpose but can be fixed in future version\n\n\/\/ Based on:\n\/\/ - \"80's raymarching\" by villedieumorgan. https:\/\/shadertoy.com\/view\/lsVSRt\n\/\/ - \"Cloth Shading\" by knarkowicz. https:\/\/shadertoy.com\/view\/4tfBzn\n\/\/ - \"[SH16B] Speed Drive 80\" by knarkowicz. https:\/\/shadertoy.com\/view\/4ldGz4\n\/\/ Uses also snippets from:\n\/\/ - Digit drawing function by P_Malin (https:\/\/www.shadertoy.com\/view\/4sf3RN)\n\/\/ - Tiny Planet: Earth by morgan3d https:\/\/www.shadertoy.com\/view\/lt3XDM\n\/\/ Thnak you guys for sharing it, hope you like the game :)\n\n\/\/ Music: Laserhawk - King of the streets\n\/\/  https:\/\/soundcloud.com\/lazerhawk\/king-of-the-streets\n\n\n\n\/\/ Brick Game Racer in shader by Michal Klos\n\n\/\/ control loop\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (fragCoord.x >= 3. || fragCoord.y >= 1.) \n    {\n        discard;    \n    }\n\n    AppState s;\n    LoadState(iChannel0, s); \n\t\n\t\/\/ read keys that people usually press instead of space    \n    float key = 0.0;\n    for (int i = 0; i < keys.length(); ++i)\n        key = max( key, step( 0.1, texture( iChannel1, vec2( keys[i] \/ 256.0, 0.5 ) ).x ) );\n\n\ts.isSpacePressed = key;\n    \n    if (s.stateID == GS_SPLASH) \/\/ splash\n    {        \n        if (s.isSpacePressed > 0.5)\n        {\n            s.stateID = GS_GAME;\n\t\t\ts.isFailed = 0.0;\n            s.timeFailed = 0.0;\n\t\t\ts.timeAccumulated = 0.0;\n            s.score = 0.0;\n\t\t\ts.paceScale = 0.0;\n            s.timeStarted = iTime;\n        }\n    }\n    else if (s.stateID == GS_GAME) \/\/ game\n    {       \n        if (s.isFailed < 0.5)\n        {\n            if (s.isSpacePressed > 0.5)\n                s.isLeftLine = mod(s.isLeftLine + 1.0, 2.0);\n        \n            \/\/ game logic\n            s.paceScale = clamp((s.playerCell - 10.0) \/ 100.0, 0.0, 1.0);\n            float timeMultiplier = mix(1.0, 3.0, pow(s.paceScale, 1.0) );\n            \n            float timeStep = timeMultiplier * iTimeDelta;\n            s.timeAccumulated += timeStep;\n            s.playerCell = floor( 2.0 * s.timeAccumulated );\n            \n#ifdef AI\n            {\n\t\t\t\tfloat playerCellState = GetCellState(s.playerCell + 1.0, s.seed);\n                if (playerCellState < CS_EMPTY_LANE\n                    && s.isLeftLine == playerCellState)\n                {\n                    s.isLeftLine = mod(s.isLeftLine + 1.0, 2.0);\n                }\n            }\n#endif\n            \n            float playerCellState = GetCellState(s.playerCell, s.seed);\n\n            if (playerCellState < CS_EMPTY_LANE\n                && s.isLeftLine == playerCellState)\n            {\n                s.isFailed = 1.0;\n                s.timeFailed = iTime;\n\t\t\t\ts.stateID = GS_SPLASH;\n            }\n            else\n            {\n                s.score = s.playerCell - CELLS_HEADSTART;\n                s.highscore = max(s.score, s.highscore);\n            }\n    \t}\n    }\n  \n    fragColor = SaveState(s, fragCoord, iFrame);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\/\/ Copyright \u00a9 2019 Michal Klos\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ Brick Driver\n\/\/  Entry for TK Game Jam 2019\n\/\/  Endless runner with synthwave stylization originally named \"Brick Game Racer\"\n\n\/\/ Awarded by the Jury\n\/\/  and 4th place based on audience votes against 55 other entries\n\/\/  https:\/\/spolsh.itch.io\/bgr\n\n\/\/ TK Game Jam 2019 is Game development challange\n\/\/  about creating game in 48h in Poland, Wroc\u0142aw 22-24.02.2019\n\/\/  https:\/\/itch.io\/jam\/tk-game-jam-2019\n\/\/  https:\/\/web.facebook.com\/events\/185669952375258\/250811702527749\/\n\n\/\/ Game aimed for Retro category\n\/\/  Themes used in game are synt(h)etic and development, \n\/\/  because graphics is inspired by synthwave and car gets faster the longer you play\n\n\/\/ Gameplay is based on Brick Game Racing,\n\/\/  https:\/\/youtu.be\/EdMyKRC8qyU?t=67\n\/\/  \"lagging\" of red cars is somewhat on purpose but can be fixed in future version\n\n\/\/ Based on:\n\/\/ - \"80's raymarching\" by villedieumorgan. https:\/\/shadertoy.com\/view\/lsVSRt\n\/\/ - \"Cloth Shading\" by knarkowicz. https:\/\/shadertoy.com\/view\/4tfBzn\n\/\/ - \"[SH16B] Speed Drive 80\" by knarkowicz. https:\/\/shadertoy.com\/view\/4ldGz4\n\/\/ Uses also snippets from:\n\/\/ - Digit drawing function by P_Malin (https:\/\/www.shadertoy.com\/view\/4sf3RN)\n\/\/ - Tiny Planet: Earth by morgan3d https:\/\/www.shadertoy.com\/view\/lt3XDM\n\/\/ Thnak you guys for sharing it, hope you like the game :)\n\n\/\/ Music: Laserhawk - King of the streets\n\/\/  https:\/\/soundcloud.com\/lazerhawk\/king-of-the-streets\n\n\n\/\/ from Tiny Planet: Earth by morgan3d https:\/\/www.shadertoy.com\/view\/lt3XDM\nfloat hash(float n) { return fract(sin(n) * 1e4); }\nfloat noise(vec3 x) { const vec3 step = vec3(110, 241, 171); vec3 i = floor(x); vec3 f = fract(x); float n = dot(i, step); vec3 u = f * f * (3.0 - 2.0 * f); return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x), mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y), mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x), mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z); }\n\n#define DEFINE_FBM(name, OCTAVES) float name(vec3 x) { float v = 0.0; float a = 0.5; vec3 shift = vec3(100); for (int i = 0; i < OCTAVES; ++i) { v += a * noise(x); x = x * 2.0 + shift; a *= 0.5; } return v; }\nDEFINE_FBM(fbm3, 3)\n\n\n\/\/ #define DEBUG\t\/\/ enables camera rotation with mouse and draws 2d game on left side of screen\n\/\/ #define AI\t\t\/\/ makes car avoid obstacles on its own\n#define ZERO (min(iFrame,0))\n\nconst float keys[] = float[] ( \n     32.0, \/\/ space\n\t 37.0, \/\/ Arrow left\n\t 38.0, \/\/ Arrow up\n\t 39.0, \/\/ Arrow right\n\t 40.0, \/\/ Arrow down\n\t 65.0, \/\/ A\n\t 68.0, \/\/ D\n\t 87.0, \/\/ W\n\t 83.0, \/\/ S\n\t100.0, \/\/ d\n\t115.0, \/\/ s\n\t119.0, \/\/ w\n\t197.0  \/\/ a \n);\n\n\/\/ Game State\nconst float GS_SPLASH = 0.0;\nconst float GS_GAME   = 1.0;\n\n\/\/ Cell State\nconst float CS_RIGHT_LANE = 0.0;\nconst float CS_LEFT_LANE  = 1.0;\nconst float CS_EMPTY_LANE = 2.0;\n\nconst float CELLS_HEADSTART = 4.0;\n\n\/\/ Based on \"Cloth Shading\" by knarkowicz. https:\/\/shadertoy.com\/view\/4tfBzn\nstruct AppState\n{\n\tfloat stateID;    \n\tfloat isSpacePressed;    \n    float timeFailed;\n\tfloat isLeftLine;\n    \n\tfloat isFailed;\n    float playerCell;\n    float score;\n    float highscore;\n    \n    float timeAccumulated;\n    float paceScale;    \n    float seed;\n    float timeStarted;\n};\n\nvec4 LoadValue(sampler2D tex, int x, int y)\n{\n    return texelFetch(tex, ivec2(x, y), 0);\n}\n\nvoid LoadState(sampler2D tex, out AppState s)\n{\n    vec4 data;\n\n\tdata = LoadValue(tex, 0, 0);\n\ts.isSpacePressed = data.x;\n    s.stateID      = data.y;\n\ts.timeFailed   = data.z;\n    s.isLeftLine   = data.w;\n    \n    data = LoadValue(tex, 1, 0);\n    s.isFailed   = data.x;\n    s.playerCell = data.y;\n    s.score\t\t = data.z;\n    s.highscore\t = data.w;\n    \n    data = LoadValue(tex, 2, 0);\n    s.timeAccumulated = data.x;\n    s.paceScale       = data.y;    \n\ts.seed            = data.z;\n    s.timeStarted     = data.w;\n}\n\nvoid StoreValue(vec2 re, vec4 va, inout vec4 fragColor, vec2 fragCoord)\n{\n    fragCoord = floor(fragCoord);\n    fragColor = (fragCoord.x == re.x && fragCoord.y == re.y) ? va : fragColor;\n}\n\nvec4 SaveState(in AppState s, in vec2 fragCoord, int iFrame)\n{\n    if (iFrame <= 0)\n    {\n\t\ts.stateID = GS_SPLASH;\n\t\ts.isSpacePressed  = 0.0;\n\t\ts.timeFailed      = 0.0;\n        s.isLeftLine      = 0.0;\n        \n        s.isFailed        = 0.0;\n        s.playerCell      = 0.0;\n        s.score           = 0.0;\n        s.highscore       = 0.0;\n        \n        s.paceScale       = 0.0;\n        s.timeAccumulated = 0.0;\n        s.seed            = fbm3(iDate.yzw);\n        s.timeStarted     = 0.0;\n    }\n    \n    vec4 ret = vec4(0.);\n\tStoreValue(vec2(0., 0.), vec4(s.isSpacePressed,  s.stateID,    s.timeFailed,   s.isLeftLine),   ret, fragCoord);\n\tStoreValue(vec2(1., 0.), vec4(s.isFailed,        s.playerCell, s.score,        s.highscore),    ret, fragCoord);\n    StoreValue(vec2(2., 0.), vec4(s.timeAccumulated, s.paceScale,  s.seed,         s.timeStarted),  ret, fragCoord);\n    return ret;\n}\n\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat GetCellRandomValue(float cellID, float seed)\n{\n    return step(0.5, hash11( cellID + seed ));\n}\n\nfloat GetCellState(float cellID, float seed)\n{\n    float rndState = GetCellRandomValue( cellID, seed );\n    rndState = mix(rndState, CS_EMPTY_LANE, step(cellID, CELLS_HEADSTART));\n\n    float cellState = CS_EMPTY_LANE;\n    return mix( cellState, rndState, step(0.5, mod(cellID, 2.0)) );\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Utils\n\nfloat saturate(float x)\n{\n    return clamp(x, 0., 1.);\n}\n\nvoid Rotate(inout vec2 p, float a) \n{\n    p = cos(a) * p + sin(a) * vec2(p.y, -p.x);\n}\n\n\/\/ from http:\/\/mercury.sexy\/hg_sdf\/\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)\/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { \/\/yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\n\/\/ based on https:\/\/www.shadertoy.com\/view\/ll2BWz\nvoid SpriteLeft(inout vec3 color, vec2 p)\n{\n    uint v = 0u;\n\tv = p.y == 31. ? 0u : v;\n\tv = p.y == 30. ? 0u : v;\n\tv = p.y == 29. ? 0u : v;\n\tv = p.y == 28. ? 0u : v;\n\tv = p.y == 27. ? (p.x < 8. ? 0u : (p.x < 16. ? 2004317952u : (p.x < 24. ? 2003828855u : 489335u))) : v;\n\tv = p.y == 26. ? (p.x < 8. ? 0u : (p.x < 16. ? 2004317952u : (p.x < 24. ? 2003830647u : 7829367u))) : v;\n\tv = p.y == 25. ? (p.x < 8. ? 0u : (p.x < 16. ? 30464u : (p.x < 24. ? 124782448u : 7798784u))) : v;\n\tv = p.y == 24. ? (p.x < 8. ? 0u : (p.x < 16. ? 2004317952u : (p.x < 24. ? 2003830647u : 7829367u))) : v;\n\tv = p.y == 23. ? (p.x < 8. ? 0u : (p.x < 16. ? 489216u : (p.x < 24. ? 2003830647u : 7829367u))) : v;\n\tv = p.y == 22. ? (p.x < 8. ? 286326784u : (p.x < 16. ? 139537u : (p.x < 24. ? 124782448u : 7798784u))) : v;\n\tv = p.y == 21. ? (p.x < 8. ? 286330880u : (p.x < 16. ? 1981878545u : (p.x < 24. ? 122685303u : 34672896u))) : v;\n\tv = p.y == 20. ? (p.x < 8. ? 286330880u : (p.x < 16. ? 1628508433u : (p.x < 24. ? 319815799u : 18088209u))) : v;\n\tv = p.y == 19. ? (p.x < 8. ? 286326784u : (p.x < 16. ? 286261248u : (p.x < 24. ? 286326784u : 286326801u))) : v;\n\tv = p.y == 18. ? (p.x < 8. ? 286261248u : (p.x < 16. ? 268435456u : (p.x < 24. ? 286326784u : 286330880u))) : v;\n\tv = p.y == 17. ? (p.x < 8. ? 286326784u : (p.x < 16. ? 268435456u : (p.x < 24. ? 17895425u : 286331136u))) : v;\n\tv = p.y == 16. ? (p.x < 8. ? 286326784u : (p.x < 16. ? 268435456u : (p.x < 24. ? 17895681u : 286331152u))) : v;\n\tv = p.y == 15. ? (p.x < 8. ? 286326784u : (p.x < 16. ? 285212672u : (p.x < 24. ? 286331137u : 285282577u))) : v;\n\tv = p.y == 14. ? (p.x < 8. ? 17891328u : (p.x < 16. ? 286261248u : (p.x < 24. ? 286331137u : 286265617u))) : v;\n\tv = p.y == 13. ? (p.x < 8. ? 17891328u : (p.x < 16. ? 286326784u : (p.x < 24. ? 286330881u : 286261265u))) : v;\n\tv = p.y == 12. ? (p.x < 8. ? 17891328u : (p.x < 16. ? 286330880u : (p.x < 24. ? 286330880u : 286261248u))) : v;\n\tv = p.y == 11. ? (p.x < 8. ? 17891328u : (p.x < 16. ? 17895696u : (p.x < 24. ? 17895680u : 285212672u))) : v;\n\tv = p.y == 10. ? (p.x < 8. ? 286326784u : (p.x < 16. ? 1118481u : (p.x < 24. ? 286331136u : 286261249u))) : v;\n\tv = p.y == 9. ? (p.x < 8. ? 286326784u : (p.x < 16. ? 4369u : (p.x < 24. ? 285282560u : 286261265u))) : v;\n\tv = p.y == 8. ? (p.x < 8. ? 286331136u : (p.x < 16. ? 17u : (p.x < 24. ? 268505344u : 286261521u))) : v;\n\tv = p.y == 7. ? (p.x < 8. ? 286331153u : (p.x < 16. ? 0u : (p.x < 24. ? 69888u : 17830161u))) : v;\n\tv = p.y == 6. ? (p.x < 8. ? 17895697u : (p.x < 16. ? 0u : (p.x < 24. ? 4352u : 17826064u))) : v;\n\tv = p.y == 5. ? (p.x < 8. ? 17895696u : (p.x < 16. ? 0u : (p.x < 24. ? 4368u : 17825792u))) : v;\n\tv = p.y == 4. ? (p.x < 8. ? 17891328u : (p.x < 16. ? 0u : (p.x < 24. ? 4352u : 0u))) : v;\n\tv = p.y == 3. ? 0u : v;\n\tv = p.y == 2. ? 0u : v;\n\tv = p.y == 1. ? 0u : v;\n\tv = p.y == 0. ? 0u : v;\n    v = p.x >= 0. && p.x < 32. ? v : 0u;\n\n    float i = float((v >> uint(4. * p.x)) & 15u);\n    color = i == 1. ? vec3(1, 0, 0.8) : color;\n    color = i == 2. ? vec3(1, 0.2, 0.8) : color;\n    color = i == 3. ? vec3(1, 0.4, 0.8) : color;\n    color = i == 4. ? vec3(1, 0.4, 1) : color;\n    color = i == 5. ? vec3(1, 0.6, 1) : color;\n    color = i == 6. ? vec3(1, 0.8, 1) : color;\n    color = i == 7. ? vec3(1) : color;\n}\n\nvoid SpriteRight(inout vec3 color, vec2 p)\n{\n    uint v = 0u;\n\tv = p.y == 31. ? 0u : v;\n\tv = p.y == 30. ? 0u : v;\n\tv = p.y == 29. ? 0u : v;\n\tv = p.y == 28. ? 0u : v;\n\tv = p.y == 27. ? (p.x < 8. ? 2415919248u : (p.x < 16. ? 629145u : (p.x < 24. ? 2576351241u : 0u))) : v;\n\tv = p.y == 26. ? (p.x < 8. ? 2566914192u : (p.x < 16. ? 629145u : (p.x < 24. ? 10027017u : 0u))) : v;\n\tv = p.y == 25. ? (p.x < 8. ? 160432272u : (p.x < 16. ? 0u : (p.x < 24. ? 626697u : 0u))) : v;\n\tv = p.y == 24. ? (p.x < 8. ? 160432272u : (p.x < 16. ? 0u : (p.x < 24. ? 39321u : 0u))) : v;\n\tv = p.y == 23. ? (p.x < 8. ? 160432272u : (p.x < 16. ? 0u : (p.x < 24. ? 629145u : 0u))) : v;\n\tv = p.y == 22. ? (p.x < 8. ? 2566914192u : (p.x < 16. ? 0u : (p.x < 24. ? 10063881u : 0u))) : v;\n\tv = p.y == 21. ? (p.x < 8. ? 2566914192u : (p.x < 16. ? 629145u : (p.x < 24. ? 142606345u : 17895424u))) : v;\n\tv = p.y == 20. ? (p.x < 8. ? 144u : (p.x < 16. ? 620185u : (p.x < 24. ? 355467273u : 286265636u))) : v;\n\tv = p.y == 19. ? (p.x < 8. ? 272u : (p.x < 16. ? 256u : (p.x < 24. ? 286261248u : 17825809u))) : v;\n\tv = p.y == 18. ? (p.x < 8. ? 272u : (p.x < 16. ? 16u : (p.x < 24. ? 286261248u : 286326784u))) : v;\n\tv = p.y == 17. ? (p.x < 8. ? 273u : (p.x < 16. ? 286326801u : (p.x < 24. ? 17891328u : 17895424u))) : v;\n\tv = p.y == 16. ? (p.x < 8. ? 268435729u : (p.x < 16. ? 286330881u : (p.x < 24. ? 17895425u : 1118464u))) : v;\n\tv = p.y == 15. ? (p.x < 8. ? 285212945u : (p.x < 16. ? 1118465u : (p.x < 24. ? 17895424u : 69905u))) : v;\n\tv = p.y == 14. ? (p.x < 8. ? 285212945u : (p.x < 16. ? 1118464u : (p.x < 24. ? 286330880u : 4369u))) : v;\n\tv = p.y == 13. ? (p.x < 8. ? 17826065u : (p.x < 16. ? 69904u : (p.x < 24. ? 286326784u : 17u))) : v;\n\tv = p.y == 12. ? (p.x < 8. ? 17895696u : (p.x < 16. ? 69904u : (p.x < 24. ? 286330880u : 0u))) : v;\n\tv = p.y == 11. ? (p.x < 8. ? 1118464u : (p.x < 16. ? 17895696u : (p.x < 24. ? 286330880u : 0u))) : v;\n\tv = p.y == 10. ? (p.x < 8. ? 1118464u : (p.x < 16. ? 4368u : (p.x < 24. ? 286330880u : 1u))) : v;\n\tv = p.y == 9. ? (p.x < 8. ? 1118464u : (p.x < 16. ? 272u : (p.x < 24. ? 268505088u : 17u))) : v;\n\tv = p.y == 8. ? (p.x < 8. ? 69888u : (p.x < 16. ? 272u : (p.x < 24. ? 69632u : 273u))) : v;\n\tv = p.y == 7. ? (p.x < 8. ? 69632u : (p.x < 16. ? 268435728u : (p.x < 24. ? 69888u : 4368u))) : v;\n\tv = p.y == 6. ? (p.x < 8. ? 69632u : (p.x < 16. ? 16777488u : (p.x < 24. ? 4352u : 256u))) : v;\n\tv = p.y == 5. ? (p.x < 8. ? 0u : (p.x < 16. ? 69888u : (p.x < 24. ? 4352u : 0u))) : v;\n\tv = p.y == 4. ? (p.x < 8. ? 0u : (p.x < 16. ? 0u : (p.x < 24. ? 256u : 0u))) : v;\n\tv = p.y == 3. ? 0u : v;\n\tv = p.y == 2. ? 0u : v;\n\tv = p.y == 1. ? 0u : v;\n\tv = p.y == 0. ? 0u : v;\n    v = p.x >= 0. && p.x < 32. ? v : 0u;\n\n    float i = float((v >> uint(4. * p.x)) & 15u);\n    color = i == 1. ? vec3(1, 0, 0.73) : color;\n    color = i == 2. ? vec3(1, 0.0039, 0.73) : color;\n    color = i == 3. ? vec3(1, 0.063, 0.75) : color;\n    color = i == 4. ? vec3(1, 0.12, 0.76) : color;\n    color = i == 5. ? vec3(1, 0.41, 0.84) : color;\n    color = i == 6. ? vec3(1, 0.64, 0.9) : color;\n    color = i == 7. ? vec3(1, 0.72, 0.93) : color;\n    color = i == 8. ? vec3(1, 0.81, 0.95) : color;\n    color = i == 9. ? vec3(1) : color;\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"Xdf3zn","filepath":"\/media\/a\/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"\/media\/ap\/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"\/media\/a\/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"\/media\/ap\/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"\/media\/a\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"\/media\/ap\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\/\/ Copyright \u00a9 2019 Michal Klos\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ Brick Driver\n\/\/  Entry for TK Game Jam 2019\n\/\/  Endless runner with synthwave stylization originally named \"Brick Game Racer\"\n\n\/\/ Awarded by the Jury\n\/\/  and 4th place based on audience votes against 55 other entries\n\/\/  https:\/\/spolsh.itch.io\/bgr\n\n\/\/ TK Game Jam 2019 is Game development challange\n\/\/  about creating game in 48h in Poland, Wroc\u0142aw 22-24.02.2019\n\/\/  https:\/\/itch.io\/jam\/tk-game-jam-2019\n\/\/  https:\/\/web.facebook.com\/events\/185669952375258\/250811702527749\/\n\n\/\/ Game aimed for Retro category\n\/\/  Themes used in game are synt(h)etic and development, \n\/\/  because graphics is inspired by synthwave and car gets faster the longer you play\n\n\/\/ Gameplay is based on Brick Game Racing,\n\/\/  https:\/\/youtu.be\/EdMyKRC8qyU?t=67\n\/\/  \"lagging\" of red cars is somewhat on purpose but can be fixed in future version\n\n\/\/ Based on:\n\/\/ - \"80's raymarching\" by villedieumorgan. https:\/\/shadertoy.com\/view\/lsVSRt\n\/\/ - \"Cloth Shading\" by knarkowicz. https:\/\/shadertoy.com\/view\/4tfBzn\n\/\/ - \"[SH16B] Speed Drive 80\" by knarkowicz. https:\/\/shadertoy.com\/view\/4ldGz4\n\/\/ Uses also snippets from:\n\/\/ - Digit drawing function by P_Malin (https:\/\/www.shadertoy.com\/view\/4sf3RN)\n\/\/ - Tiny Planet: Earth by morgan3d https:\/\/www.shadertoy.com\/view\/lt3XDM\n\/\/ Thnak you guys for sharing it, hope you like the game :)\n\n\/\/ Music: Laserhawk - King of the streets\n\/\/  https:\/\/soundcloud.com\/lazerhawk\/king-of-the-streets\n\n\n\n\/\/ Fork of \"80's raymarching\" by villedieumorgan. https:\/\/shadertoy.com\/view\/lsVSRt\n\/\/ 2019-02-24 01:09:41\n\n\nvec3 gBoxPos; \nfloat gCarLampDist = 1000000.0;\nAppState gS;\n\n\/\/-----------------------------------------------------------------\n\/\/ Digit drawing function by P_Malin (https:\/\/www.shadertoy.com\/view\/4sf3RN)\n\nfloat SampleDigit(const in float n, const in vec2 vUV)\n{\t\t\n\tif(vUV.x  < 0.0) return 0.0;\n\tif(vUV.y  < 0.0) return 0.0;\n\tif(vUV.x >= 1.0) return 0.0;\n\tif(vUV.y >= 1.0) return 0.0;\n\t\n\tfloat data = 0.0;\n\t\n\t     if(n < 0.5) data = 7.0 + 5.0*16.0 + 5.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\telse if(n < 1.5) data = 2.0 + 2.0*16.0 + 2.0*256.0 + 2.0*4096.0 + 2.0*65536.0;\n\telse if(n < 2.5) data = 7.0 + 1.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 3.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 4.5) data = 4.0 + 7.0*16.0 + 5.0*256.0 + 1.0*4096.0 + 1.0*65536.0;\n\telse if(n < 5.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n\telse if(n < 6.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n\telse if(n < 7.5) data = 4.0 + 4.0*16.0 + 4.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 8.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\telse if(n < 9.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\t\n\tvec2 vPixel = floor(vUV * vec2(4.0, 5.0));\n\tfloat fIndex = vPixel.x + (vPixel.y * 4.0);\n\t\n\treturn mod(floor(data \/ pow(2.0, fIndex)), 2.0);\n}\n\nfloat PrintInt(const in vec2 uv, const in float value )\n{\n\tfloat res = 0.0;\n\tfloat maxDigits = 1.0+ceil(log2(value)\/log2(10.0));\n\tfloat digitID = floor(uv.x);\n\tif( digitID>0.0 && digitID<maxDigits )\n\t{\n        float digitVa = mod( floor( value\/pow(10.0,maxDigits-1.0-digitID) ), 10.0 );\n        res = SampleDigit( digitVa, vec2(fract(uv.x), uv.y) );\n\t}\n\n\treturn res;\t\n}\n\nfloat TextSDF(vec2 p, float glyph)\n{\n    p = abs(p.x - .5) > .5 || abs(p.y - .5) > .5 ? vec2(0.) : p;\n    return 2. * (texture(iChannel3, p \/ 16. + fract(vec2(glyph, 15. - floor(glyph \/ 16.)) \/ 16.)).w - 127. \/ 255.);\n}\n\nvoid HighscoreText(inout vec3 color, vec2 p, in AppState s)\n{        \n    vec2 scale = vec2(4., 8.);\n    vec2 t = floor(p \/ scale);   \n    \n    uint v = 0u;    \n\tv = t.y == 0. ? ( t.x < 4. ? 1751607624u : ( t.x < 8. ? 1919902579u : 14949u ) ) : v;\n\tv = t.x >= 0. && t.x < 12. ? v : 0u;\n    \n\tfloat c = float((v >> uint(8. * t.x)) & 255u);\n    \n    \/\/ vec3 textColor = vec3(.3);\n\tvec3 textColor = vec3(0.75);\n\n    p = (p - t * scale) \/ scale;\n    p.x = (p.x - .5) * .5 + .5;\n    float sdf = TextSDF(p, c);\n    if (c != 0.)\n    {\n    \tcolor = mix(textColor, color, smoothstep(-.05, +.05, sdf));\n    }\n}\n\nvoid CreditText(inout vec3 color, vec2 p, in AppState s)\n{        \n    vec2 scale = vec2(4., 8.);\n    vec2 t = floor(p \/ scale);   \n    \n    uint v = 0u;    \n\tv = t.y == 0. ? ( t.x < 4. ? 1246186324u : ( t.x < 8. ? 959524914u : ( t.x < 12. ? 2037588026u : ( t.x < 16. ? 1747481710u : ( t.x < 20. ? 1769235753u : ( t.x < 24. ? 539369571u : ( t.x < 28. ? 1702258020u : ( t.x < 32. ? 1836085100u : ( t.x < 36. ? 544501349u : ( t.x < 40. ? 1293973858u : ( t.x < 44. ? 1634231145u : ( t.x < 48. ? 1816862828u : 29551u ) ) ) ) ) ) ) ) ) ) ) ) : v;\n\tv = t.x >= 0. && t.x < 52. ? v : 0u;    \n    \n\tfloat c = float((v >> uint(8. * t.x)) & 255u);\n    \n    \/\/ vec3 textColor = vec3(.3);\n\tvec3 textColor = vec3(0.75);\n\n    p = (p - t * scale) \/ scale;\n    p.x = (p.x - .5) * .5 + .5;\n    float sdf = TextSDF(p, c);\n    if (c != 0.)\n    {\n    \tcolor = mix(textColor, color, smoothstep(-.05, +.05, sdf));\n    }\n}\n\nvoid SpaceText(inout vec3 color, vec2 p, in AppState s)\n{        \n    vec2 scale = vec2(4., 8.);\n    vec2 t = floor(p \/ scale);   \n    \n    uint v = 0u;    \n    v = t.y == 0. ? ( t.x < 4. ? 1936028240u : ( t.x < 8. ? 1935351923u : ( t.x < 12. ? 1701011824u : ( t.x < 16. ? 1869881437u : ( t.x < 20. ? 1635021600u : 29810u ) ) ) ) ) : v;\n\tv = t.x >= 0. && t.x < 24. ? v : 0u;\n    \n\tfloat c = float((v >> uint(8. * t.x)) & 255u);\n    \n    \/\/ vec3 textColor = vec3(.3);\n\tvec3 textColor = vec3(1.0);\n\n    p = (p - t * scale) \/ scale;\n    p.x = (p.x - .5) * .5 + .5;\n    float sdf = TextSDF(p, c);\n    if (c != 0.)\n    {\n    \tcolor = mix(textColor, color, smoothstep(-.05, +.05, sdf));\n    }\n}\n\nvoid DrawGame(inout vec3 color, AppState s, vec2 p)\n{\n    {              \n#ifdef DEBUG\n        \/\/ game\n        vec2 p2 = p;\n        p2 += vec2(1.5, 0.7);\n        p2 *= vec2(7.0, 4.5);\n        p2.y += s.playerCell;\n\n        float cellID = floor(p2.y);\n        float rndState = step( 0.5, hash11(cellID) );\n        if (cellID < CELLS_HEADSTART)\n        {\n            rndState = CS_EMPTY_LANE;\n        }\n\n        float cellState = CS_EMPTY_LANE;\n        cellState = mix( cellState, rndState, step(0.5, mod(cellID, 2.0)) );\n\n        \/\/ draw obstacles\n        if (cellState == CS_RIGHT_LANE)\n        {\n            vec2 p3 = (p2 -vec2(0.5) -vec2(0.0, cellID));\n            color = mix(mix(color, vec3(1.0, 0.0, 0.0), 0.2), color, smoothstep(0.0, 0.01, Circle(p3, 0.5) ));\n        }\n\n        if (cellState == CS_LEFT_LANE)\n        {\n            vec2 p3 = (p2 -vec2(0.5) -vec2(0.0, cellID));\n            p3.x += 1.0;\n            color = mix(mix(color, vec3(1.0, 0.0, 0.0), 0.2), color, smoothstep(0.0, 0.01, Circle(p3, 0.5) ));\n        }\n\n        \/\/ draw player\n        if (cellID == s.playerCell)\n        {\n            vec2 p3 = (p2 -vec2(0.5) -vec2(0.0, cellID));\n            if (s.isLeftLine == CS_LEFT_LANE)\n            {\n                p3.x += 1.0;\n            }\n            color = mix(mix(color, vec3(0.0, 1.0, 0.0), 0.2), color, smoothstep(0.0, 0.01, Circle(p3, 0.45) ));\n        }\n#endif\n    }\n}\n\n\/* \nMADE BY MORGAN VILLEDIEU\nTW : https:\/\/twitter.com\/VilledieuMorgan\nClick and drag to rotate the camera\n*\/\n\n\/\/Raymarch settings\n\n#define MAX_MOVEMENT_SPEED 0.9\n#define MIN_RADIUS 0.01\n#define MAX_RADIUS 0.3\n#define STAR_COUNT 30\n#define PI 3.14159265358979323\n#define TWOPI 6.283185307\n\n#define EPSILON 0.1\n\n#define RADIUS_SEED 1337.0\n#define START_POS_SEED 2468.0\n#define THETA_SEED 1675.0\n\n#define MIN_DIST 0.001\n#define MAX_DIST 32.0\n#define MAX_STEPS 96\n#define STEP_MULT 0.9\n#define FOCAL_LENGTH 0.9\n\n\/\/Scene settings\n\n\/\/#define SHOW_RAY_COST\n\n\/\/Colors\n#define SKY_COLOR_1 vec3(49., 33., 66.)\/255.\n#define SKY_COLOR_2 vec3(0.00,0.05,0.20)\n\n#define SUN_COLOR_2 vec3(87., 33., 73.)\/255.\n#define SUN_COLOR_1 vec3(1.00, 0.20, 0.60)\/2.\n\n#define CAR_COLOR_1 vec3(0.01, 0.2, 0.2)\n#define CAR2_COLOR_1 vec3(1.00, 0.0, 0.0)\n\n#define GRID_COLOR_1 vec3(0.00, 0.05, 0.20)\n#define GRID_COLOR_2 vec3(26.00, 14.0, 122.0)\/255.\n#define FOG_COLOR vec3(193.00, 24.0, 123.0)\/255.\n\n\/\/Parameters\n#define GRID_SIZE 0.50\n#define GRID_LINE_SIZE 1.25\n\n#define SUN_DIRECTION vec3( 0.10,0.0,0.)\n\n#define CLOUD_SCROLL vec2(0.002, 0.001)\n#define CLOUD_BLUR 2.0\n#define CLOUD_SCALE vec2(0.04, 0.10)\n\n#define MOUNTAIN_SCALE 6.0\n#define MOUNTAIN_SHIFT 5.3\n\n#define SPEED 11.\n\nconst vec3 starColor = vec3(1.0, 1.0, 1.0);\n\n\/\/Color modes\n\/\/vec3(#,#,#) Number of bits per channel\n\n\/\/24 bit color\n#define RGB888 vec3(8,8,8)\n\/\/16 bit color\n#define RGB565 vec3(5,6,5)\n#define RGB664 vec3(6,6,4)\n\/\/8 bit color\n#define RGB332 vec3(3,3,2)\n#define RGB242 vec3(2,4,2)\n#define RGB222 vec3(2,2,2) \/\/+2 unused\n\n#define COLOR_MODE RGB242\n\n\/\/Object IDs\n#define SKYDOME 0.\n#define FLOOR 1.\n#define CAR 2.\n#define CAR2 3.\n\nstruct MC\n{\n    vec3 position;\n    vec3 normal;\n    float dist;\n    float steps;\n    float id;\n};\n\/\/==== Distance field operators\/functions by iq. ====\nvec2 opU(vec2 d1, vec2 d2)\n{\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\nvec2 opS(vec2 d1, vec2 d2)\n{\n    return (-d1.x > d2.x) ? d1*vec2(-1,1) : d2;\n}\n\n\nvec2 sdBox(vec3 pos, vec3 size, float id)\n{\n    return vec2(length(max(abs(pos) - size, 0.0)), id);\n}\n\nfloat Box( vec3 p, vec3 b )\n{\n    vec3 d = abs( p ) - b;\n    return min( max( d.x, max( d.y, d.z ) ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\nvec2 sdOct( vec3 p, float r, float id )\n{\n\tvec2 s = vec2(1,-1)\/sqrt(1.0);\n\treturn vec2(max(max(max(\n\t\t\tabs(dot(p,s.xxx)),abs(dot(p,s.yyx))),\n\t\t\tabs(dot(p,s.yxy))),abs(dot(p,s.xyy))) - r*mix(1.0,1.0\/sqrt(3.0),.5), id);\n}\n\nvec2 sdSphere(vec3 p, float s, float id)\n{\n  return vec2(length(p) - s, id);\n}\n\n\nfloat displace(vec3 p) {\n\tfloat height = 10.;\n\treturn ((cos(1.*p.y+0.5)*clamp(sin(1.1*p.x), 0.5, 1.)*sin(0.+2.4)*height*clamp(texture(iChannel0, p.xy\/10.).r*0.4, 0.0, 0.5)));\n}\n\n\/\/float displace(vec3 p) {\n\/\/return ((cos(1.*p.x)*sin(1.1*p.y)\/2.*sin(4.*p.z+1.)))*texture(iChannel2, p.xy\/10.).r+0.1;\n\/\/}\n\nfloat Union( float a, float b )\n{\n    return min( a, b );\n}\n\nfloat Intersect( float a, float b )\n{\n    return max( a, b );\n}\n\nfloat Substract( float a, float b )\n{\n    return max( a, -b );\n}\n\nfloat SubstractChamfer( float a, float b, float r ) \n{\n    return max( max( a, -b ), ( a + r - b ) * 0.70711 );\n}\n\nfloat Plane( vec3 p, vec4 plane ) \n{\n    return dot( p, plane.xyz ) + plane.w;\n}\n\nvec2 sdPlane(vec3 p, vec4 n, float id)\n{\n  \/\/ n must be normalized\n float bounce = (1.0 - gS.isFailed) * 0.05 * abs(sin(6.5*iTime));\n  return vec2( dot(vec3(p.x,p.y, max(p.z + bounce + displace(vec3(p.x, p.y-10., p.z)), p.z)), vec3(n.x, n.y, n.z)) + n.y, id);\n}\n\nfloat Cylinder( vec3 p, float r, float height ) \n{\n    float d = length( p.xz ) - r;\n    d = max( d, abs( p.y ) - height );\n    return d;\n}\n\nfloat Sphere( vec3 p, float s )\n{\n    return length( p ) - s;\n}\n\nvec2 sdColumn(vec3 p, float r, float id)\n{\n    return vec2(((abs(p.x)+abs(p.y))-r)\/sqrt(2.0), id);\n}\n\n\/\/ From \"[SH16B] Speed Drive 80\" by knarkowicz. https:\/\/shadertoy.com\/view\/4ldGz4\nfloat Car( vec3 p, float id )\n{        \n    p *= 3.5;\n    \n    p.x = -p.x;     \n    p.y -= 0.3;\n    \n    float a = Box( p, vec3( 4.2, 0.9, 1.8 ) );   \n    \n    vec3 t = p + vec3( -6.0, 0.0, 0.0 );\n    Rotate( t.yx, 0.2 );\n    float b = Plane( t, vec4( 0.0, -1.0, 0.0, 0.0 ) );\n    \n    t = p + vec3( -5.0, 0.0, 0.0 );\n    Rotate( t.yx, -0.4 );\n    float c = Plane( t, vec4( 0.0, 1.0, 0.0, 0.0 ) );    \n    \n    t = p + vec3( 2.0, -0.2, 0.0 );\n    Rotate( t.yx, -0.4 );\n    float d = Plane( t, vec4( 0.0, -1.0, 0.0, 0.0 ) );   \n    \n    t = p + vec3( 2.0, -0.3, 0.0 );\n    Rotate( t.yx, -0.05 );\n    float e = Plane( t, vec4( 0.0, -1.0, 0.0, 0.0 ) );       \n    \n    t = p + vec3( 2.0, 1.0, 0.0 );\n    Rotate( t.yx, 0.2 );\n    float f = Plane( t, vec4( 0.0, 1.0, 0.0, 0.0 ) );     \n    \n    t = p;\n    t.z = abs( t.z );\n    t += vec3( -3.9, -0.6, 0.0 );\n    float spoiler = Box( t, vec3( 0.2, 0.05, 1.7 ) );\n    spoiler = Union( spoiler, Box( t - vec3( 0.0, -0.25, 1.4 ), vec3( 0.2, 0.3, 0.15 ) ) );\n    \n    float bloom = Box( t + vec3( -0.5, 0.7, 0.0 ), vec3( 0.1, 0.3, 1.5 ) );\t\n    if (id == CAR)\n      gCarLampDist = min( gCarLampDist, bloom );\n        \n    t = p + vec3( 1.0, -0.6, 0.0 );\n    Rotate( t.yx, -0.4 );\n    float frontWindow = Box( t, vec3( 0.6, 0.05, 1.6 ) );\n    \n    t = p + vec3( -2.5, -0.7, 0.0 );\n    Rotate( t.yx, 0.2 );\n    float backWindow = Box( t, vec3( 1.0, 0.05, 1.6 ) );\n    \n    float body = Union( Substract( a, Union( Union( Union( b, c ), Intersect( d, e ) ), f ) ), spoiler );\n    \n    t = p;\n    t.z = -abs( t.z );\n    t += vec3( 0.0, -0.8, 1.2 );\n    Rotate( t.yz, -0.9 );\n    float sideCutPlanes = Plane( t, vec4( 0.0, -1.0, 0.0, 0.0 ) );      \n    \n    body = SubstractChamfer( body, Union( backWindow, frontWindow ), 0.1 );\n    body = SubstractChamfer( body, sideCutPlanes, 0.05 );\n    \n    p.x += 0.1;\n    p.xz = abs( p.xz );\n    t = p.xzy - vec3( 2.4, 1.5, -0.7 );\n    float wheel = Cylinder( t, 0.7, 1.0 );\n    body = Substract( body, wheel );\n    \n    wheel = Substract( Cylinder( t, 0.55, 0.3 ), Sphere( t + vec3( 0.0, -0.15, 0.0 ), 0.35 ) );\n    \n    body = Union( body, wheel );\n    \n    body \/= 3.5;\n    \n    return body;\n}\n\n\/\/Distance to the scene\nvec2 Scene(vec3 p)\n{\t\n    p = vec3(p.x, p.z, -p.y); \/\/ Coord fix\n    \n    vec2 d = vec2(MAX_DIST, SKYDOME);    \n\tvec3 pEnv = p;\n    d = opU(d, sdPlane(pEnv, vec4(0, 0,-1, 0), FLOOR));\n                  \n\tvec3 boxSize = vec3(0.6*vec2(0.9, 0.6), 0.2);\n    vec3 boxSizeObs = boxSize;\n    boxSizeObs.z *= 5.0;\n\n    { \/\/ obstacles \n        vec3 pObs = p - gBoxPos;\t\t\n        float c = pModInterval1(pObs.x, 8.0*boxSize.x, -5.0, 10.0);   \n        float cellID = gS.playerCell + c;        \n\t\tfloat cellState = GetCellState(cellID, gS.seed);                \n\n        if (cellState == CS_EMPTY_LANE)\n\t\t\tpObs.y = -1.0;\n        else\n\t\t\tpObs.y -= mix( -1.0, 1.0, step(cellState, CS_LEFT_LANE - 0.1));\n\n        pObs.y += fbm3(vec3(100000.0*cellID)) * 0.5;       \n        d = opU(d, vec2( Car(vec3(pObs.x, -pObs.z, pObs.y) -vec3(0.0, 0.3, 0.0), CAR2), CAR2 )); \n    }   \n\t\n    { \/\/ player        \n        vec3 pBox = p - gBoxPos - vec3(0.0, gS.isLeftLine == CS_LEFT_LANE ? -0.5 : 0.5, 0.0);\n        pBox.y += fbm3(vec3(100000.0*gS.playerCell)) * 0.2;\n    \td = opU(d, vec2( Car(vec3(pBox.x, -pBox.z, pBox.y) -vec3(0.0, 0.3, 0.0), CAR), CAR )); \n    }\n    \n\treturn d;\n}\n\n\/\/Surface normal at the current position\nvec3 Normal(vec3 p)\n{\n    \/\/ inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*Scene(p+0.0005*e).x;\n    }\n    return normalize(n);\n}\n\n\/\/Raymarch the scene with the given ray\nMC MR(vec3 orig,vec3 dir)\n{\n    float steps = 0.0;\n    float dist = 0.0;\n    float id = 0.0;\n    \n    for(int i = 0;i < MAX_STEPS;i++)\n    {\n        vec2 object = Scene(orig + dir * dist);\n        \n        \/\/Add the sky dome and have it follow the camera.\n        object = opU(object, -sdSphere(dir * dist, MAX_DIST, SKYDOME));        \n        dist += object.x * STEP_MULT;        \n        id = object.y;\n        \n        steps++;\n        \n        if(abs(object.x) < MIN_DIST * dist)\n        {\n            break;\n        }\n    }\n    \n    MC result;\n    \n    result.position = orig + dir * dist;\n    result.normal = Normal(result.position);\n    result.dist = dist;\n    result.steps = steps;\n    result.id = id;\n    \n    return result;\n}\n\n\/\/Scene texturing\/shading\nvec3 Shade(MC hit, vec3 direction, vec3 camera)\n{\n    vec3 color = vec3(0.0);\n    vec3 rd = color;\n    vec3 skydomeColor = color;\n    \n    if(hit.id == SKYDOME)\n    {\n    \tcolor = mix(SKY_COLOR_1*1.4, SKY_COLOR_2, hit.position.y\/9.0);\n       \n        vec3 sunDir = normalize(SUN_DIRECTION);       \n\t\tfloat sun = smoothstep(0.987, 0.99, dot(direction, sunDir));\n        sun -= smoothstep(0.1, 0.9, 0.5);\t\t\t        \n\t\tfloat sunStripesPos = 2.0*pow(0.6*hit.position.y-0.1, 1.5);\n        float stripes = clamp( smoothstep(0.5, 0.51, abs(-1.0+2.0*fract(sunStripesPos))), 0.0, 1.0);\t\t        \n\t\tvec3 sunCol = mix(SUN_COLOR_1, SUN_COLOR_2*1.2, -hit.position.y\/2.5);        \n        color = mix(color, sunCol, min(sun, stripes)) + texture(iChannel2, vec2(2.) * 0.1).rgb * 0.07;\t\t        \n    }      \n\n    if(hit.id == FLOOR)\n    {\n        vec2 uv = abs(mod(hit.position.xz + GRID_SIZE\/2.0, GRID_SIZE) - GRID_SIZE\/2.0); \n        \n        uv \/= fwidth(hit.position.xz);\n                                                       \n        float gln = min(min(uv.x, uv.y), 1.) \/ GRID_SIZE;\n    \tcolor = mix(GRID_COLOR_1, GRID_COLOR_2, 0.7 - smoothstep(0.0, GRID_LINE_SIZE \/ GRID_SIZE, gln));\n        \n\t\tvec3 normal = vec3(0.,0.0,-0.5);\n        vec3 rfld = reflect( direction, normal );\n        float reflectstrength = 1.-abs(dot( direction, normal ));\n        color *= reflectstrength;\n        \n        vec3 spotColor  = vec3( 0.54, 0.42, 0.78 ) * 300.0;\n        vec3 spotPos    = gBoxPos + vec3( 0.5, -0.75, 0.0 ) + vec3(0.0, 0.0, gS.isLeftLine == CS_LEFT_LANE ? -0.5 : 0.5);\n        vec3 spotDir    = normalize( spotPos.xzy - hit.position.xzy );\n        float spotAtt = 1.0 \/ pow( length( spotPos - hit.position ), 2.0 );\n        spotAtt *= saturate( -spotDir.x * 6.0 - 4.0 );\n        color += color * spotColor * spotAtt * saturate( dot( normal, spotDir ) );  \t\n\n        \/\/ red trail      \n        float trailX = hit.position.x - gBoxPos.x -2.0;\n        color += 0.9 * vec3( 1.0, 0.0, 0.0 ) \n            * saturate( exp( -5.2 * abs( hit.position.z -(gS.isLeftLine == CS_LEFT_LANE ? -0.5 : 0.5)) ) )\n            * saturate(  1.0 + trailX * 0.02 )\n            * saturate( -0.6 - trailX * 0.3 );\n    } \n    \n\tif(hit.id == CAR)\n    {\n        vec2 uv = abs(mod(hit.position.xz + GRID_SIZE\/2.0, GRID_SIZE) - GRID_SIZE\/2.0); \n        \n        uv \/= fwidth(hit.position.xz);\n                                                       \n        float gln = min(min(uv.x, uv.y), 1.) \/ GRID_SIZE;\n    \tcolor = mix((0.5*CAR_COLOR_1), (2.0*GRID_COLOR_2), 0.8 - smoothstep(0.0, GRID_LINE_SIZE \/ GRID_SIZE, gln));\n        \n\t\tvec3 normal = vec3(0.,0.0,-0.5);\n        vec3 rfld = reflect( direction, normal );\n        float reflectstrength = 2.-abs(dot( direction, normal ));\n        color *= reflectstrength;\n        \n        vec3 spotColor  = vec3( 0.54, 0.42, 0.78 ) * 300.0;\n        vec3 spotPos    = gBoxPos + vec3( 0.5, -0.75, 0.0 ) + vec3(0.0, 0.0, gS.isLeftLine == CS_LEFT_LANE ? -0.5 : 0.5);\n        vec3 spotDir    = normalize( spotPos.xzy - hit.position.xzy );\n        float spotAtt = 1.0 \/ pow( length( spotPos - hit.position ), 2.0 );\n        spotAtt *= saturate( -spotDir.x * 6.0 - 4.0 );\n        color += color * spotColor * spotAtt * saturate( dot( normal, spotDir ) );         \n    } \n\n\tif(hit.id == CAR2)\n    {\n        vec2 uv = abs(mod(hit.position.xz + GRID_SIZE\/2.0, GRID_SIZE) - GRID_SIZE\/2.0);         \n        uv \/= fwidth(hit.position.xz);                                                       \n        float gln = min(min(uv.x, uv.y), 1.) \/ GRID_SIZE;\n    \tcolor = mix((0.5*CAR2_COLOR_1), (2.0*GRID_COLOR_2), 0.8 - smoothstep(0.0, GRID_LINE_SIZE \/ GRID_SIZE, gln));\n    } \n    \n    \/\/Distance fog\n    color += mix(GRID_COLOR_2, FOG_COLOR, pow(hit.dist, 1.01) )\/70.;\n    \n    return color;\n}\n\n\/\/ Based on \"[SH16B] Speed Drive 80\" by knarkowicz. https:\/\/shadertoy.com\/view\/4ldGz4\nvec3 SceneBloom()\n{\n    return vec3( 1.0, 0.2, 0.1 ) * 1.0 * vec3( exp( -gCarLampDist * 0.5 ) );\n}\n    \nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid DrawScene(inout vec3 color, AppState s, vec2 p)\n{\n    vec2 mo = iMouse.xy\/iResolution.xy;    \n\t   \n    gBoxPos = vec3(8.0 * (s.playerCell + fract(2.0 * s.timeAccumulated)), 0.0, 0.0);\n    \n    float arm = mix(4.0, 8.0, s.paceScale );\n    \n\tvec3 gOrig = gBoxPos;\n   \n#ifdef DEBUG\n    gOrig += vec3(\n        arm*cos(6.0*mo.x),\n        0.0 + 4.0*mo.y,\n        arm*sin(6.0*mo.x)\n    );\n#else\n\tvec3 gameOffset = vec3(\n        arm*cos(1.0*3.14 + 0.1 * sin(0.5*iTime)),\n        1.5 + 0.5 * s.paceScale,\n        arm*sin(1.0*3.14 + 0.1 * sin(0.5*iTime))\n    );\n    vec3 failOffset = vec3(\n        4.0*cos(0.1*iTime),\n        1.5,\n        4.0*sin(0.1*iTime)\n    );\n    \n    gOrig += mix(\n        gameOffset,\n        mix(\n            gameOffset,\n            failOffset,\n            smoothstep(0.0, 2.0, iTime - s.timeFailed)\n        ),\n        step(s.stateID, GS_SPLASH - 0.1)\n    );\n\n#endif\n    \n    gOrig.y += fbm3(100.0*gOrig) * 0.1 * s.paceScale;\n    \n    vec3 gLookat = gBoxPos + vec3( 0.0, 0.1, 0.0 );\t\n     \n    mat3 ca = setCamera( gOrig, gLookat, 0.0);\n    float fov = mix(2.2, 4.0, s.paceScale );\n    vec3 dir = ca * normalize( vec3(vec2(p.x, p.y), fov) );\n        \n    MC hit = MR(gOrig, dir);\n    \n    vec3 shade = Shade(hit, dir, gOrig );\n    vec3 bloom = SceneBloom();                \n    color = 2.5 * shade + bloom;\n    \n    \/\/particles\n    float angle = atan(dir.z, dir.y)\/(atan(iTime)-1.*1.*PI);\n    angle -= floor(angle);\n    float rad = length(vec2(dir.x * 0.02, dir.z));\n \n    if (s.isFailed < 0.5)\n    {\n        float timeScale = mix(20.0, 50.0, s.paceScale);\n        float dist3Scale = mix(100.0, 25.0, s.paceScale);\n        float opacityScale = mix(0.2, 1.0, s.paceScale);\n\n        float angleFract = fract(angle*10.5);\n        float angleRnd = floor(angle*180.);\n        float angleRnd1 = fract(angleRnd*fract(angleRnd*.72035)*1.1);\n        float angleRnd2 = fract(angleRnd*fract(angleRnd*.82657)*1.724);\n        float t = iTime*timeScale+angleRnd1*1000.;\n        float radDist = sqrt(angleRnd2+.1);\n        float adist = radDist\/rad*.2;\n        float dist = (t*.2+adist);\n        dist = abs(fract(dist\/20.)-.5);\n\n        color += opacityScale * max(0.0,.7-dist*dist3Scale\/adist)*(0.5-abs(angleFract-.5))*1.\/adist\/radDist;        \n    }\n    \n    \/\/ score counter text    \n    if (s.isFailed < 0.5)\n    {\n        vec2 p1 = p;\n        p1 *= 7.0;\n        p1 -= vec2(-1.0, 5.5);\n        p1 -= vec2(-0.5 * ceil(log2(s.score)\/log2(10.0)), 0.0);\n        p1 *= mix( 0.9, 1.0, abs(sin(2.0 * 3.14 * iTime)) * step(s.isFailed, 0.5) );\n        color += PrintInt(p1, s.score);\n    }\n}\n\nvoid DrawSplash(inout vec3 color, AppState s, vec2 p)\n{\n    vec2 resMult = floor(iResolution.xy \/ 64.);\n    float resRcp = 1. \/ max(min(resMult.x, resMult.y), 1.);\n    vec2 screenSize = floor(iResolution.xy * resRcp);\n    vec2 pixel      = floor(gl_FragCoord.xy * resRcp - screenSize * .5);\n    SpriteLeft(color, pixel  + vec2(32,8));\n    SpriteRight(color, pixel + vec2(0,8));\n\n    vec2 p2 = p;\n    p2 *= 55. + 5. * abs(sin(2.0*iTime));\n    p2 -= vec2(-40, -25.0);\n    SpaceText(color, p2, s);\n\n    vec2 p4 = p;\n    p4 *= 90.;\n    p4 -= vec2(-100, -80.0);\n    CreditText(color, p4, s);\n\n    if (s.highscore > 0.0)\n    {\n        vec2 p5 = p;\n        p5 *= 50.;\n        p5 -= vec2(-28, -38.0);\n        HighscoreText(color, p5, s);\n    }\n\n    vec2 p3 = p;\n    p3 *= 10.0;\n    p3 -= vec2( 3.5, -7.3);\n    p3 -= vec2(-0.5 * ceil(log2(s.score)\/log2(10.0)), 0.0);\n    float scoreColor = PrintInt(p3, s.highscore);\n    color = mix(color, vec3(1.0), scoreColor);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n\tvec2 q = fragCoord.xy \/ iResolution.xy;\n    vec2 p = -1. + 2. * q;\n\tp.x *= iResolution.x \/ iResolution.y;\n       \n    AppState s;\n    LoadState(iChannel2, s);\n    \n    gS = s;\n    \n    vec3 color = vec3(0.0);\n        \n    DrawScene(color, s, p);\n    DrawGame(color, s, p);    \n     \n    if ( s.stateID == GS_SPLASH )\n\t \tDrawSplash(color, s, p);\n\n\tfragColor = vec4(color, 1.);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\/\/ Copyright \u00a9 2019 Michal Klos\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ Brick Driver\n\/\/  Entry for TK Game Jam 2019\n\/\/  Endless runner with synthwave stylization originally named \"Brick Game Racer\"\n\n\/\/ Awarded by the Jury\n\/\/  and 4th place based on audience votes against 55 other entries\n\/\/  https:\/\/spolsh.itch.io\/bgr\n\n\/\/ TK Game Jam 2019 is Game development challange\n\/\/  about creating game in 48h in Poland, Wroc\u0142aw 22-24.02.2019\n\/\/  https:\/\/itch.io\/jam\/tk-game-jam-2019\n\/\/  https:\/\/web.facebook.com\/events\/185669952375258\/250811702527749\/\n\n\/\/ Game aimed for Retro category\n\/\/  Themes used in game are synt(h)etic and development, \n\/\/  because graphics is inspired by synthwave and car gets faster the longer you play\n\n\/\/ Gameplay is based on Brick Game Racing,\n\/\/  https:\/\/youtu.be\/EdMyKRC8qyU?t=67\n\/\/  \"lagging\" of red cars is somewhat on purpose but can be fixed in future version\n\n\/\/ Based on:\n\/\/ - \"80's raymarching\" by villedieumorgan. https:\/\/shadertoy.com\/view\/lsVSRt\n\/\/ - \"Cloth Shading\" by knarkowicz. https:\/\/shadertoy.com\/view\/4tfBzn\n\/\/ - \"[SH16B] Speed Drive 80\" by knarkowicz. https:\/\/shadertoy.com\/view\/4ldGz4\n\/\/ Uses also snippets from:\n\/\/ - Digit drawing function by P_Malin (https:\/\/www.shadertoy.com\/view\/4sf3RN)\n\/\/ - Tiny Planet: Earth by morgan3d https:\/\/www.shadertoy.com\/view\/lt3XDM\n\/\/ Thnak you guys for sharing it, hope you like the game :)\n\n\/\/ Music: Laserhawk - King of the streets\n\/\/  https:\/\/soundcloud.com\/lazerhawk\/king-of-the-streets\n\n\n\/\/ Fork of \"[SH16B] Speed Drive 80\" by knarkowicz. https:\/\/shadertoy.com\/view\/4ldGz4\n\/\/ 2019-02-24 00:16:15\n\n\/\/ Post processing\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tvec2 screenUV = fragCoord.xy \/ iResolution.xy;\n    \n    \/\/ radial blur\n    vec4 mainSample = texture( iChannel0, screenUV );    \n    vec2 blurOffset = ( screenUV - vec2( 0.5 ) ) * 0.001;;\n    vec3 color = mainSample.xyz;\n\tfor ( int iSample = 1; iSample < 16; ++iSample )\n\t{\n\t\tcolor += texture( iChannel0, screenUV - blurOffset * float( iSample ) ).xyz;\n\t}    \n    color \/= 16.0;\n    \n    \/\/ vignette\n    float vignette = screenUV.x * screenUV.y * ( 1.0 - screenUV.x ) * ( 1.0 - screenUV.y );\n    vignette = clamp( pow( 16.0 * vignette, 0.3 ), 0.0, 1.0 );\n    color *= vignette;\n    \n    float scanline   = clamp( 0.95 + 0.05 * cos( 3.14 * ( screenUV.y + 0.008 * iTime ) * 240.0 * 1.0 ), 0.0, 1.0 );\n    float grille  \t= 0.85 + 0.15 * clamp( 1.5 * cos( 3.14 * screenUV.x * 640.0 * 1.0 ), 0.0, 1.0 );\n    color *= scanline * grille * 1.2;    \n        \n    fragColor = vec4( color, 1.0 );\n}\n\n","name":"Buffer C","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"7ddSD7","date":"1633386597","viewed":2220,"name":"Desperate Distraction","username":"spolsh","description":"04.10.2021 - the day shadertoy was up and facebook was down","likes":59,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"XdX3Rr","filepath":"\/media\/a\/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"\/media\/ap\/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"\/media\/a\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"\/media\/ap\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R iResolution\n#define F gl_FragCoord\n#define T iTime\n#define PI 3.1415\n\n#define DBG vec3(1.0, 0.0, 0.0)\n#define BG  vec3(0.2)\n#define PH0 vec3(0.0)\n#define PH1 vec3(0.1)\n#define FB0 vec3(0.6)\n#define FB1 vec3(0.25, 0.25, 0.5)\n#define FB2 vec3(0.7, 0.7, 0.9)\n#define FB3 vec3(0.2)\n#define FB4 vec3(1.0)\n#define FB5 vec3(0.75)\n\n#define ROUND0 0.01\n#define ROUND1 0.004\n\nfloat sdBox2( vec2 p, vec2 b )\n{\n  vec2 d = abs(p) - b;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nmat2 rot(float a)\n{ \n    float s = sin(a);\n    float c = cos(a);\n    return mat2( c, -s , s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = F.xy\/R.xy;\n\tvec2 p = 2.0*(q-0.5);\n    p.x *= R.x\/R.y;\n    \n    float bounce = sin(fract(2.0*0.35*T-0.5)*2.0*PI);\n    float rotAnim = 2.0*(-0.5+ smoothstep(-0.6, 0.6, bounce) );\n    mat2 r = rot(0.25*0.0174*rotAnim);\n    p *= r;\n    \n    float yAnim = 0.5+0.5*cos(fract(2.0*0.35*T-0.5)*2.0*PI); \/\/ synced with feed scroll anim\n    vec3 tiltTex = texture(iChannel0, vec3(0.0, 0.0, 0.125*0.35*T)).rgb;\n    vec2 tiltAnim = vec2(0.1, 0.1) * (2.0*(smoothstep(0.0, 2.0, tiltTex.xy)-0.5));\n    tiltAnim.y += 0.2*yAnim;    \n    p *= mix( 0.95, 1.0, tiltTex.b);\n    p += tiltAnim;\n        \n    float s0 = abs(p.x) - 0.9; \/\/ phone body\n    float s01 = sdBox2(p +vec2(0.0, -0.95), vec2(0.2, 0.005)); \/\/ phone body speaker\n    float s10 = sdBox2(p +vec2(0.0, 0.1), vec2(0.8, 0.9)); \/\/ phone top bar\n    float s11 = sdBox2(p +vec2(-0.74, -0.72), vec2(0.01, 0.005)); \/\/ phone top bar battery\n    float s12 = sdBox2(p +vec2(-0.69, -0.72), vec2(0.04, 0.02)); \/\/ phone top bar battery\n    float s13 = sdBox2(p +vec2(-0.70, -0.72), vec2(0.035, 0.025)); \/\/ phone top bar battery\n    float s14 = sdBox2(p +vec2( 0.75, -0.700), vec2(0.002, 0.005)); \/\/ phone top bar signal\n    float s15 = sdBox2(p +vec2( 0.72, -0.710), vec2(0.002, 0.015)); \/\/ phone top bar signal\n    float s16 = sdBox2(p +vec2( 0.69, -0.720), vec2(0.002, 0.025)); \/\/ phone top bar signal\n    float s17 = sdBox2(p +vec2( 0.66, -0.728), vec2(0.002, 0.035)); \/\/ phone top bar signal\n    \n    float s2 = sdBox2(p +vec2(0.0, 0.25), vec2(0.8, 0.9)); \/\/ app body bg\n    float s3 = sdBox2(p -vec2(0.0, 0.55), vec2(0.8, 0.11)); \/\/ app top bar\n    \n    float s40 = sdBox2(p +vec2(-0.68, -0.55), vec2(0.07)); \/\/ app top bar icon placeholder\n    float s41 = max(  sdBox2(p +vec2( 0.69, -0.57), vec2(0.06)), \/\/ app top bar icon placeholder    \n                      texture(iChannel1, p*0.35 - vec2(0.36, 0.60)).x );\n    float s42 = sdBox2(p +vec2(-0.3, -0.55), vec2(0.07)); \/\/ app top bar icon placeholder\n    float s43 = sdBox2(p +vec2( 0.0, -0.55), vec2(0.07)); \/\/ app top bar icon placeholder    \n    float s44 = sdBox2(p +vec2( 0.3, -0.55), vec2(0.07)); \/\/ app top bar icon placeholder\n    \n    float s50 = sdBox2(p  -vec2(0.0, 0.3), vec2(0.8, 0.13)); \/\/ app lower bar placeholder\n    float s51 = sdBox2(p +vec2( 0.0, -0.16), vec2(0.80, 0.0001)); \/\/ app lower bar separator line\n    float s52 = sdBox2(p +vec2( 0.27, -0.3), vec2(0.0001, 0.132)); \/\/ app lower bar button separator line\n    float s53 = sdBox2(p +vec2(-0.27, -0.3), vec2(0.0001, 0.132)); \/\/ app lower bar button separator line\n    float s54 = sdBox2(p +vec2(-0.39, -0.3), vec2(0.07, 0.05)); \/\/ app lower bar button\n    float s55 = sdBox2(p +vec2( 0.15, -0.3), vec2(0.07, 0.05)); \/\/ app lower bar button\n    float s56 = sdBox2(p +vec2( 0.67, -0.3), vec2(0.07, 0.05)); \/\/ app lower bar button\n        \n    vec2 animP = p + vec2(0.0, -0.2 + smoothstep(0.5, 1.0, fract(2.0*0.35*T)) + floor(2.0*0.35*T) );\n    animP.y = fract(animP.y)-0.5;\n    \n    float s60 = sdBox2(animP +vec2(0.0, 0.1), vec2(0.75, 0.5)); \/\/ app post top placeholder\n    float s61 = sdBox2(animP +vec2(0.0, -0.14) +vec2( 0.0,   0.47), vec2(0.75 +2.0*ROUND0, 0.001)); \/\/ app post separator line\n    float s62 = sdBox2(animP +vec2(0.0, -0.14) +vec2( 0.5,  -0.02), vec2(0.2, 0.2)); \/\/ app post top avatar\n    float s63 = sdBox2(animP +vec2(0.0, -0.14) +vec2(-0.23, -0.12), vec2(0.42, 0.03)); \/\/ app post top name\n    float s64 = sdBox2(animP +vec2(0.0, -0.14) +vec2(-0.16, -0.02), vec2(0.35, 0.02)); \/\/ app post top timestamp\n    float s65 = sdBox2(animP +vec2(0.0, -0.14) +vec2( 0.1,   0.27), vec2(0.6, 0.02)); \/\/ app post text\n    float s66 = sdBox2(animP +vec2(0.0, -0.14) +vec2( 0.14,  0.37), vec2(0.56, 0.02)); \/\/ app post text\n    \n    float s7 = sdBox2(animP +vec2(0.0, 0.0), vec2(0.1, 0.1)); \/\/ anim test\n    \n    float fadeAnim0 = smoothstep(-0.5, 0.5, sin(5.0*(p.x + 0.5)  + 3.0*T));\n    float fadeAnim1 = smoothstep(-0.5, 0.5, sin(5.0*(p.x + 0.23) + 3.0*T));\n    float fadeAnim2 = smoothstep(-0.5, 0.5, sin(5.0*(p.x + 0.1)  + 3.0*T));\n    \n    vec3 c = mix(PH0, BG, smoothstep(0.0, 0.01, s0 ));\n      \n    c = mix(PH1, c, smoothstep(0.0, 0.01, s01 ));\n    c = mix(PH1, c, smoothstep(0.0, 0.01, s10 ));    \n    c = mix(FB0, c, smoothstep(0.0, 0.01, s2 ));\n    \n    c = mix(FB4, c, smoothstep(0.0, 0.01, max(s2, s60 -ROUND0) ));\n    c = mix(FB0, c, smoothstep(0.0, 0.01, max(s2, s61) ));\n    c = mix(mix(FB0, FB5, fadeAnim0), c, smoothstep(0.0, 0.01, max(s2, s62 -ROUND0) ));\n    c = mix(mix(FB0, FB5, fadeAnim1), c, smoothstep(0.0, 0.01, max(s2, s64) ));\n    c = mix(mix(FB0, FB5, fadeAnim2), c, smoothstep(0.0, 0.01, max(s2, min( min(s63, s65), s66) ) ));\n    \/\/ c = mix(DBG, c, smoothstep(0.0, 0.01, s7 ));\n\n    c = mix(FB1, c, smoothstep(0.0, 0.01, s3 ));    \n    c = mix(FB2, c, smoothstep(0.0, 0.01, s41 -ROUND0 ));\n    c = mix(FB3, c, 0.5+0.5*smoothstep(0.0, 0.01, min( min(s42, s43), s44) -ROUND0 ));    \n    c = mix(FB4, c, smoothstep(0.0, 0.01, s50 ));\n    \n    c = mix(FB0, c, smoothstep(0.0, 0.01, min( min( s51, s52 ), s53) ));\n    c = mix(FB0, c, smoothstep(0.0, 0.01, min( min( s54, s55 ), s56) -ROUND0 ));\n    \n    c = mix(FB0, c, smoothstep(0.0, 0.01, max( -s13 +ROUND1, min(s11 -ROUND1, s12 -ROUND1)) ));\n    float signalAnim = smoothstep(0.3, 0.31, fract(0.35*T));\n    c = mix(FB3, c, smoothstep(0.0, 0.01, min( min(s15, s16), s17) -ROUND1 ));\n    c = mix(mix(FB0, FB3, vec3(signalAnim) ), c, smoothstep(0.0, 0.01, s14 -ROUND1 ));    \n    \n    float glowTex = texture(iChannel0, vec3(0.05*p, 2.0*T)).r;\n    float glowAnim = mix(0.9, 1.0, glowTex);\n    c += 0.1*smoothstep(1.0, 0.0, s2) * glowAnim; \/\/ display glow\n    \n    c = smoothstep(0.1*glowAnim, 1.0, c);\n    c *= 0.25 + 0.75*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.15 );    \n    \n    float grainTex = texture(iChannel0, vec3(20.0*q, T)).r;\n    c *= mix(0.92, 1.0, grainTex);\n    \n    c = pow(c, vec3(0.4545));\n    \n    fragColor = vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"3dK3zR","date":"1570906394","viewed":2070,"name":"Joined Bilateral Filtered SSAO","username":"spolsh","description":"Filterered Screen Space Ambient Obscurance exercise based on first part of article: https:\/\/bartwronski.com\/2019\/09\/22\/local-linear-models-guided-filter\/\nMove mouse horizontally to rotate and vertically to animate filter depth weight","likes":13,"published":3,"flags":32,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"\/media\/previz\/buffer03.png","previewfilepath":"\/media\/previz\/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Copyright \u00a9 2019 Michal 'spolsh' Klos\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/\n\/\/   Filterered Screen Space Ambient Obscurance exercise\n\/\/ based on first part of article: https:\/\/bartwronski.com\/2019\/09\/22\/local-linear-models-guided-filter\/\n\/\/\n\/\/   Move mouse horizontally to rotate and vertically to animate filter depth weight\n\/\/\n\/\/\t Uncomment line 32 to enable comparison Depth Aware Upsampled vs Joined Biliniar Upsampled\n\/\/\n\/\/\n\/\/   From left to right:\n\/\/ 1. Raw half resoultion SSAO\n\/\/ 2. Filtered half resolution SSAO\n\/\/ 3. Depth Aware Upsampled SSAO\n\/\/ 4. Joined Biliniar Upsampled SSAO\n\/\/\n\/\/   Animated weight for depth term in SSAO filter:\n\/\/ specifially sigma for gaussian weight selecting range of depth values picked by kernel\n\/\/\n\/\/   Stages of rendering:\n\/\/ 1. Render scene pass outputing Normal+Z in ViewSpace to BufferA\n\/\/ 2. Downsampling Normal+Z to half resolution to BufferB\n\/\/ 3. Calculate SSAO, hemisphere approach based on Alchemy AO [McGuire et al. 2011] to BufferC \n\/\/ 4. Joined Bilateral Gaussian blur. Raw SSAO samples from BufferC blurred based on depth values\n\/\/ 5. Joined Bilateral Upsampling (JBU) and Depth Aware Upsampling (DAU) comparison\n\/\/\t\tBJU based on: https:\/\/johanneskopf.de\/publications\/jbu\/paper\/FinalPaper_0185.pdf\n\/\/\t\t\t\t\t  https:\/\/bartwronski.com\/2019\/09\/22\/local-linear-models-guided-filter\/\n\/\/      DAU based on: http:\/\/developer.download.nvidia.com\/assets\/gamedev\/files\/sdk\/11\/OpacityMappingSDKWhitePaper.pdf\n\n\n\/\/ #define COMPARE_JBU_VS_DAU\n\n\nconst vec2 c_offset[4] = vec2[](\n    vec2(0., 0.),\n    vec2(0., 1.),\n    vec2(1., 0.),\n    vec2(1., 1.)\n);\n\nvec4 DepthAwareUpsample(vec2 P)\n{ \/\/ based on Nearest-Depth-Filter: http:\/\/developer.download.nvidia.com\/assets\/gamedev\/files\/sdk\/11\/OpacityMappingSDKWhitePaper.pdf\n  \/\/\t\t                        https:\/\/www.shadertoy.com\/view\/MllSzX\n\n    vec2 halfP = 0.5 * P;\n    vec2 c_textureSize = iChannelResolution[2].xy;\n\tvec2 c_texelSize = 1.0 \/ c_textureSize;\n    vec2 pixel = halfP * c_textureSize + 0.5;\n    vec2 f = fract(pixel);\n    pixel = (floor(pixel) \/ c_textureSize) - vec2(c_texelSize\/2.0);\n\n    vec4 I = textureLod(iChannel1, P, 0.0);\n    \n    vec4 Z00 = textureLod(iChannel2, pixel + c_texelSize * c_offset[0], 0.0);\n    vec4 Z01 = textureLod(iChannel2, pixel + c_texelSize * c_offset[1], 0.0);\n    vec4 Z10 = textureLod(iChannel2, pixel + c_texelSize * c_offset[2], 0.0);\n    vec4 Z11 = textureLod(iChannel2, pixel + c_texelSize * c_offset[3], 0.0);\n    \n    float tex00 = textureLod(iChannel0, pixel + c_texelSize * c_offset[0], 0.0).r;\n    float tex01 = textureLod(iChannel0, pixel + c_texelSize * c_offset[1], 0.0).r;\n    float tex10 = textureLod(iChannel0, pixel + c_texelSize * c_offset[2], 0.0).r;\n    float tex11 = textureLod(iChannel0, pixel + c_texelSize * c_offset[3], 0.0).r;\n    \n    float diffZ00 = abs(I.w - Z00.w);\n    float diffZ01 = abs(I.w - Z01.w);\n\tfloat diffZ10 = abs(I.w - Z10.w);\n    float diffZ11 = abs(I.w - Z11.w);\n           \n    \/\/ depth discontinuity (edge) detections\n    float depthThreshold = 0.001;\n    if (diffZ00 < depthThreshold && \n        diffZ01 < depthThreshold && \n        diffZ10 < depthThreshold && \n        diffZ11 < depthThreshold) {\n                \n        \/\/ biliner interpolation\n        return vec4( mix( mix( tex00, tex10, f.x ),\n                          mix( tex01, tex11, f.x ), f.y ));\n\n    } else {\n        \n        \/\/ pick sampler based on closest depth\n        float tex = tex00;\n        float depthMinDiff = diffZ00;\n\n        if (diffZ01 < depthMinDiff) {\n            tex = tex01;\n            depthMinDiff = diffZ01;\n        }\n\n        if (diffZ10 < depthMinDiff) {\n            tex = tex10;\n            depthMinDiff = diffZ10;\n        }\n\n        if (diffZ11 < depthMinDiff) {\n            tex = tex11;\n            depthMinDiff = diffZ11;\n        }\n        \n        return vec4(tex);\n    }\n}\n\nvec4 JoinedBilateralUpsample(vec2 P)\n{ \/\/ based on: https:\/\/johanneskopf.de\/publications\/jbu\/paper\/FinalPaper_0185.pdf\n  \/\/           https:\/\/bartwronski.com\/2019\/09\/22\/local-linear-models-guided-filter\/\n  \/\/\t\t   https:\/\/www.shadertoy.com\/view\/MllSzX\n    \n    vec2 halfP = 0.5 * P;\n    vec2 c_textureSize = iChannelResolution[2].xy;\n\tvec2 c_texelSize = 1.0 \/ c_textureSize;\n    vec2 pixel = halfP * c_textureSize + 0.5;\n    vec2 f = fract(pixel);\n    pixel = (floor(pixel) \/ c_textureSize) - vec2(c_texelSize\/2.0);\n    \n    vec4 I = textureLod(iChannel1, P, 0.0);\n        \n    vec4 Z00 = textureLod(iChannel2, pixel + c_texelSize * c_offset[0], 0.0);\n    vec4 Z01 = textureLod(iChannel2, pixel + c_texelSize * c_offset[1], 0.0);\n    vec4 Z10 = textureLod(iChannel2, pixel + c_texelSize * c_offset[2], 0.0);\n    vec4 Z11 = textureLod(iChannel2, pixel + c_texelSize * c_offset[3], 0.0);\n    \n    float tex00 = textureLod(iChannel0, pixel + c_texelSize * c_offset[0], 0.0).r;\n    float tex01 = textureLod(iChannel0, pixel + c_texelSize * c_offset[1], 0.0).r;\n    float tex10 = textureLod(iChannel0, pixel + c_texelSize * c_offset[2], 0.0).r;\n    float tex11 = textureLod(iChannel0, pixel + c_texelSize * c_offset[3], 0.0).r;\n       \n    float sigmaV = 0.002;\n    \/\/    wXX = bilateral gaussian weight from depth * bilinear weight\n    float w00 = Gaussian( sigmaV, abs(I.w - Z00.w) ) * (1.-f.x) * (1.-f.y);\n    float w01 = Gaussian( sigmaV, abs(I.w - Z01.w) ) * (1.-f.x) *     f.y;\n    float w10 = Gaussian( sigmaV, abs(I.w - Z10.w) ) *     f.x  * (1.-f.y);\n    float w11 = Gaussian( sigmaV, abs(I.w - Z11.w) ) *     f.x  *     f.y;\n        \n\treturn vec4( (w00*tex00 + w01*tex01 + w10*tex10 + w11*tex11) \/ (w00+w01+w10+w11) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = F.xy\/R.xy;\n    float gamma = 0.4545;\n\n#ifdef COMPARE_JBU_VS_DAU\n    \n    \/\/ compare difference between Depth Aware Upsample and Joined Bilateral Upsample\n    float diff = DepthAwareUpsample(uv).x - JoinedBilateralUpsample(uv).x;\n    fragColor = 100.0 * vec4(diff, -diff, 0, 1);\n    \n#else\n    \n    if (F.x < R.x\/4.) {\n    \tfragColor = texture(iChannel3, 0.5*uv).xxxx;\n        \n    } else if (F.x < 2.*R.x\/4.) {\n        fragColor = texture(iChannel0, 0.5*uv);\n        \n    } else if (F.x < 3.*R.x\/4.) {\n    \tfragColor = DepthAwareUpsample(uv);\n        \n    } else {\n        fragColor = JoinedBilateralUpsample(uv);\n    }\n    \n    fragColor *= smoothstep(0.0, 0.001, abs(uv.x -0.25));\n    fragColor *= smoothstep(0.0, 0.001, abs(uv.x -0.50));\n    fragColor *= smoothstep(0.0, 0.001, abs(uv.x -0.75));\n    \n    gamma = 4.0; \/\/ exaggerate AO results   \n    \n#endif\n   \n    fragColor = vec4( pow( fragColor.rgb, vec3(gamma) ), 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R iResolution\n#define F gl_FragCoord\n#define M iMouse\n\n#define CLIP_FAR 100.\n#define CLIP_NEAR 1.\n\n#define COUNT 8\n#define BIAS 0.01\n\n#define PI 3.1415\n#define ZERO (min(iFrame,0))\n\nmat2 rot(float a) { float s = sin(a); float c = cos(a); return mat2(c, -s, s, c); }\n\nmat3 SetCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nmat3 GetCameraToWorld(float iTime, vec4 iMouse, vec2 iResolution, out vec3 ro)\n{\n    ro = vec3(\n        5.0 * cos(5.0 * iMouse.x\/iResolution.x),\n      \t1.5,\n        5.0 * sin(5.0 * iMouse.x\/iResolution.x)),\n\n    ro = iMouse.z > 0.0 ? ro : vec3(1.5,1.5,-10);\n\n    vec3 ta = vec3(0.0, 2.0, 0.0);\n    return SetCamera( ro, ta, 0. );\n}\n\nvec2 hash( vec2 p ) {\n\tp = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat Gaussian(float sigma, float x)\n{\n    return exp(-(x*x) \/ (2.0 * sigma*sigma));\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ Copyright \u00a9 2019 Michal 'spolsh' Klos\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/   Filterered Screen Space Ambient Obscurance exercise\n\/\/ based on first part of article: https:\/\/bartwronski.com\/2019\/09\/22\/local-linear-models-guided-filter\/\n\/\/\n\/\/ Render Normals+Z to fullscreen render target.\n\/\/ Simple raymarching\n\n\/\/ hg\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvec3 rdX(vec3 p)\n{\n    return vec3(p.x, p.z, -p.y);\n}\n\nvec3 rdY(vec3 p)\n{\n    return vec3(-p.z, p.y, p.x);\n}\n\nvec3 rdZ(vec3 p)\n{\n    return vec3(-p.y, p.x, p.z);\n}\n\n\/\/ hg\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n\/\/ hg\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n} \n\nfloat domainRepeat1D(float p, float size)\n{\n    return mod(abs(p) + size * .5, size) - size * .5;\n}\n\n\/\/ hg\nvec2 pModPolar(vec2 p, float repetitions) {\n\tfloat angle = 2.0 * 3.1415 \/ repetitions;\n\tfloat a = atan(p.y, p.x) + angle\/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a\/angle);\n\ta = mod(a,angle) - angle\/2.;\n\treturn vec2(cos(a), sin(a))*r;\n}\n\n\/\/ hg\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\nconst mat4 tr[3] = mat4[3](\n\tmat4(1.0, .0, .0, .0, .0, .0, -1.0, .0, .0, 1.0, .0, .0, .0, .0, .0, 1.0),\n\tmat4(.0, -1.0, .0, .0, 1.0, .0, .0, .0, .0, .0, 1.0, .0, .21, .13, 1.08, 1.0),\n\tmat4(-.493, -.87, .0, .0, .87, -.493, .0, .0, .0, .0, 1.0, .0, .257, .539, 1.08, 1.0)\n);\n\n\/\/ by mmerchnte https:\/\/www.shadertoy.com\/view\/XddBD2\n\/\/ Built with https:\/\/github.com\/mmerchante\/sdf-gen-unity\nfloat sdSponza(vec3 p)\n{\n\tvec3 wsPos = vec3(.0,.0,.0);\n\tvec4 a0 = vec4(p, 1.0);\n\ta0.xz = abs(a0.xz) * vec2(-1.0,1.0);\n\tvec4 a1 = a0 - vec4(6.24,.0,2.5,.0);\n\ta1.xz = pModPolar(a1.xz , 4.0);\n\tfloat d1 = dot(a1.xyz - vec3(11.49,.0,.0), vec3(-1.0,.0,.0));\n\tvec4 a2 = a1 - vec4(11.02,2.15,7.28,.0);\n\ta2.z = domainRepeat1D(a2.z , 2.0);\n\tvec4 a3 = a2;\n\twsPos = a3.xyz - vec3(-2.64,5.05,.0);\n\tfloat d3 = fBox(wsPos,vec3(.5,.5,.228));\n\twsPos = a3.xyz - vec3(-2.275,5.05,.0);\n\td3 = min(d3,fBox(wsPos,vec3(.383,.383,.175)));\n\twsPos = a3.xyz - vec3(-2.64,6.97,.0);\n\td3 = min(d3,fBox(wsPos,vec3(.5,.283,.111)));\n\twsPos = a2.xyz - vec3(-1.28,6.38,.287);\n\tfloat d2 = max(-d3,fBox(wsPos,vec3(1.5,1.893,6.673)));\n\td1 = min(d1,d2);\n\tvec4 a4 = a1 - vec4(9.18,-4.5,-.032,.0);\n\ta4.y = domainRepeat1D(a4.y , 4.5);\n\tvec4 a5 = a4;\n\ta5.z = domainRepeat1D(a5.z , 2.5);\n\tvec4 a6 = a5;\n\ta6.x = -a6.x;\n\tvec4 a7 = a6;\n\tvec4 a8 = a7 - vec4(.05,-.62,.0,.0);\n\ta8.xyz = rdZ(a8.xyz);\n\twsPos = a8.xyz;\n\tfloat d8 = (fCylinder(wsPos, 1.398,1.361)*.75);\n\twsPos = a8.xyz - vec3(.0,.152,.0);\n\td8 = max(-d8,(fCylinder(wsPos, 1.434,.531)*.75));\n\twsPos = a7.xyz - vec3(.786,.46,.0);\n\tfloat d7 = max(d8,fBox(wsPos,vec3(.523,.747,1.415)));\n\tvec4 a9 = a6;\n\twsPos = a9.xyz - vec3(.47,1.953,.0);\n\tfloat d9 = fBox(wsPos,vec3(.5,.075,1.5));\n\twsPos = a9.xyz - vec3(.58,2.03,.0);\n\td9 = min(d9,fBox(wsPos,vec3(.5,.075,1.5)));\n\tvec4 a10 = a9 - vec4(.463,-.51,1.179,.0);\n\ta10.z = domainRepeat1D(a10.z , 2.35);\n\twsPos = a10.xyz;\n\tfloat d10 = fBox(wsPos,vec3(.24,.033,.24));\n\twsPos = a10.xyz - vec3(.0,-.093,.0);\n\td10 = min(d10,fBox(wsPos,vec3(.24,.033,.24)));\n\twsPos = a10.xyz - vec3(-2.8,-.03,.0);\n\td10 = min(d10,fBox(wsPos,vec3(.25,.075,.25)));\n\tvec4 a11 = a10;\n\ta11.xz = pModPolar(a11.xz , 8.0);\n\twsPos = a11.xyz - vec3(.002,-1.07,.0);\n\tfloat d11 = fBox(wsPos,vec3(.17,1.053,.424));\n\td10 = min(d10,d11);\n\td9 = min(d9,d10);\n\tvec4 a12 = a9 - vec4(-1.03,-.518,.0,.0);\n\tvec4 a13 = a12;\n\ta13.xyz = rdZ(a13.xyz);\n\twsPos = (tr[0] * a13).xyz;\n\tfloat d13 = fCylinder(wsPos, 1.225,3.0);\n\twsPos = a13.xyz;\n\td13 = min(d13,fCylinder(wsPos, 1.094,2.061));\n\twsPos = a12.xyz - vec3(.12,1.27,.0);\n\tfloat d12 = max(-d13,fBox(wsPos,vec3(1.5,1.355,1.551)));\n\td9 = min(d9,d12);\n\tfloat d6 = min(d7,d9);\n\tvec4 a14 = a6 - vec4(.463,1.57,1.61,.0);\n\twsPos = (tr[1] * a14).xyz;\n\tfloat d14 = fCylinder(wsPos, .105,.046);\n\twsPos = (tr[2] * a14).xyz;\n\td14 = min(d14,fCylinder(wsPos, .025,.582));\n\td6 = min(d6,d14);\n\tfloat d5 = d6;\n\tfloat d4 = d5;\n\td1 = min(d1,d4);\n\tfloat d0 = min(d1,dot(a0.xyz - vec3(.0,-2.0,.0), vec3(.0,1.0,.0)));\n    d0 = min(d0, -(p.y - 11.15));\n    vec3 p1 = p - vec3(0, 2.26, 0);    \n    p1.x -= 0.25*sign(sin(p.z\/0.75*PI));\n    p1.xz = mod(p1.xz +0.5, 1.0) - 0.5;\n    d0 = min(d0, fBox(p1, vec3(0.44, 0.02, 0.44)) - 0.05);\n    return d0;\n}\n\nfloat map(vec3 p) {    \n\treturn min( p.y, sdSponza(p-vec3(0.0, -2.3, 0.0)) );\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0,0,0, CLIP_FAR);\n    \n    vec2 q = F.xy \/ R.xy * 2.0 - 1.0;\n    q.x *= R.x \/ R.y;    \n    \n\tvec3 rd = normalize( vec3(q.xy, 3.) );\n    vec3 ro;\n    mat3 ca = GetCameraToWorld(iTime, M, R.xy, ro);\n    vec3 cd = ca * rd;\n    \n    float t = CLIP_NEAR;\n    for( int i=ZERO; i<128; i++ )\n    {\n\t    float res = map( ro+cd*t );\n        if ( res<0.0004*t || t>CLIP_FAR ) break;\n        t += res;\n    }\n    \n    if (t < CLIP_FAR)\n    {\n        vec3 pos = ro + t*cd;\n        fragColor.rgb = inverse(ca) * calcNormal( pos ) * vec3(1,1,-1);\n        fragColor.a = rd.z * t \/ CLIP_FAR;\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\/\/ Copyright \u00a9 2019 Michal 'spolsh' Klos\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/   Filterered Screen Space Ambient Obscurance exercise\n\/\/ based on first part of article: https:\/\/bartwronski.com\/2019\/09\/22\/local-linear-models-guided-filter\/\n\/\/\n\/\/ Downsample Normals+Z to half resolution\n\nconst vec2 c_offset[4] = vec2[](\n    vec2(0., 0.),\n    vec2(0., 1.),\n    vec2(1., 0.),\n    vec2(1., 1.)\n);\n\nvec4 MaxDepthDownsample(vec2 P)\n{\n    vec2 scaledP = 2.0*P;\n    vec2 c_textureSize = iChannelResolution[0].xy;\n\tvec2 c_texelSize = 1.0 \/ c_textureSize;\n    vec2 pixel = (floor( scaledP * c_textureSize + 0.5 ) \/ c_textureSize) - vec2(0.5*c_texelSize);\n    \n    float depthMax = 0.0;\n    vec3 normal = vec3(0.0);\n    \n    for (int i = ZERO; i < 4; i++) {\n        vec4 texSample = textureLod(iChannel0, pixel + c_texelSize * c_offset[i], 0.0);\n        \n        if (texSample.w > depthMax) {\n            normal = texSample.rgb;\n            depthMax = texSample.w;\n        }\n    }\n    \n    return vec4(normal, depthMax);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    fragColor = vec4(0.0);\n    vec2 uv = F.xy\/R.xy;\n    if (uv.x > 0.5 || uv.y > 0.5) return;\n    \n    fragColor = MaxDepthDownsample(uv);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"\/media\/a\/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"\/media\/ap\/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\/\/ Copyright \u00a9 2019 Michal 'spolsh' Klos\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/   Filterered Screen Space Ambient Obscurance exercise\n\/\/ based on first part of article: https:\/\/bartwronski.com\/2019\/09\/22\/local-linear-models-guided-filter\/\n\/\/\n\/\/ Calculate SSAO from Normals+Z in half resolutin\n\nfloat SSAO(vec2 uv)\n{ \/\/ based on SSAO Test by Crow https:\/\/www.shadertoy.com\/view\/4ltSz2\n  \/\/ and Alchemy AO [McGuire et al. 2011]\n    vec4 norz = texture(iChannel0, uv);\n    float depth = norz.w * CLIP_FAR;\n    float radius = 0.05;\n    float scale = radius \/ depth;\n    \n    float ao = 0.0;\n    for(int i = ZERO; i < COUNT; i++)\n    {\n        vec2 randUv = (F.xy + 23.71 * float(i)) \/ iChannelResolution[1].xy;\n        vec3 randNor = textureLod(iChannel1, randUv, 0.0).xyz * 2.0 - 1.0;\n        if(dot(norz.xyz, randNor) < 0.0)\n            randNor *= -1.0;\n        \n        vec2 off = randNor.xy * scale;\n        vec4 sampleNorz = textureLod(iChannel0, uv + off, 0.0);\n        float depthDelta = depth - ( sampleNorz.w * CLIP_FAR );\n        \n        vec3 sampleDir = vec3(randNor.xy * radius, depthDelta);\n        float occ = max(0.0, dot(normalize(norz.xyz), normalize(sampleDir)) - BIAS) \/ (length(sampleDir) + 1.0);\n        ao += 1.0 - occ;\n    }\n    ao \/= float(COUNT);\n   \n    return ao;\n}\n    \nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{   \n    fragColor = vec4(vec3(0),1);    \n    vec2 uv = F.xy \/ R.xy;\n    if (uv.x > 0.5 || uv.y > 0.5) return;\n    \n    fragColor = vec4(SSAO(uv), texture(iChannel0, uv).w, 0.0, 1.0);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\/\/ Copyright \u00a9 2019 Michal 'spolsh' Klos\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/   Filterered Screen Space Ambient Obscurance exercise\n\/\/ based on first part of article: https:\/\/bartwronski.com\/2019\/09\/22\/local-linear-models-guided-filter\/\n\/\/\n\/\/   Bilateral Joined Gaussian Blur in half resolution.\n\/\/\n\/\/   This should be done in two passes (horizontal and vertical) \n\/\/ to do less texture samples but I already used all passes.\n\/\/\n\/\/   Gaussian filter is separable so filtering horizontally and then vertically \n\/\/ is equivalent of sampling in both directions like below.\n\/\/   Bilateral filter is not separable but separable approximation\n\/\/ is often used in practice despite some minor artifacts.\n\nfloat g_sigmaX = 3.;\nfloat g_sigmaY = 3.;\nfloat g_sigmaV = 1.;\n\nvec2 g_pixelSize = vec2(0.001);\nvec2 g_pixelSizeGuide = vec2(0.001);\n\nfloat JoinedBilateralGaussianBlur(vec2 uv)\n{   \n    const float c_halfSamplesX = 4.;\n\tconst float c_halfSamplesY = 4.;\n\n    float total = 0.0;\n    float ret = 0.0;\n\n    vec2 pivot = texture(iChannel0, uv).rg;\n    \n    for (float iy = -c_halfSamplesY; iy <= c_halfSamplesY; iy++)\n    {\n        float fy = Gaussian( g_sigmaY, iy );\n        float offsety = iy * g_pixelSize.y;\n\n        for (float ix = -c_halfSamplesX; ix <= c_halfSamplesX; ix++)\n        {\n            float fx = Gaussian( g_sigmaX, ix );\n            float offsetx = ix * g_pixelSize.x;\n            \n            vec2 value = texture(iChannel0, uv + vec2(offsetx, offsety)).rg;\n                        \n            float fv = Gaussian( g_sigmaV, abs(value.y - pivot.y) );\n            \n            total += fx*fy*fv;\n            ret += fx*fy*fv * value.r;\n        }\n    }\n        \n    return ret \/ total;\n}\n  \nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{  \n    vec2 uv = F.xy \/ R.xy;\n    if (uv.x > 0.5 || uv.y > 0.5) return;\n    \n    g_pixelSize      = 1.0 \/ iChannelResolution[0].xy;\n    g_pixelSizeGuide = 1.0 \/ iChannelResolution[0].xy;\n    \n    g_sigmaV      = M.z > 0.0\n        ? 0.03 * pow(clamp(M.y \/ R.y, 0., 1.), 2.0)\n        : 0.03 * smoothstep(0.3, -0.3, cos(iTime));\n    g_sigmaV += 0.001;\n    float sigmaT  = 2.0;\n    \n    float filtered = JoinedBilateralGaussianBlur(uv);    \n    fragColor = vec4(vec3( filtered ), 1.0);\n}\n","name":"Buffer D","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"ltXcWN","date":"1504827844","viewed":1537,"name":"Cell Division","username":"spolsh","description":"use mouse to rotate around!\n\nbased on https:\/\/www.shadertoy.com\/view\/4ll3R7 and some iq shaders.","likes":22,"published":3,"flags":64,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"\/media\/a\/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"\/media\/ap\/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"\/media\/a\/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"\/media\/ap\/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"\/media\/a\/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"\/media\/ap\/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXXDs","filepath":"https:\/\/soundcloud.com\/noisia\/noisia-hybris-crystalline?in=mihau-2\/sets\/deep-bass","previewfilepath":"https:\/\/soundcloud.com\/noisia\/noisia-hybris-crystalline?in=mihau-2\/sets\/deep-bass","type":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ by spolsh 2017, michal klos\n\n\/\/ pun intended\n#define R iResolution\n#define T iTime\n#define F fragCoord\n#define M iMouse\n\nfloat sphere(vec3 p, float r)\n{\n\treturn length(p)-r;   \n}\n\nfloat blob5(float d1, float d2, float d3, float d4, float d5)\n{\n    float k = 2.0;\n\treturn -log(exp(-k*d1)+exp(-k*d2)+exp(-k*d3)+exp(-k*d4)+exp(-k*d5))\/k;\n}\n\nfloat map(vec3 p)\n{  \n    float s = smoothstep( -0.7, 0.7, sin(0.5*T));\n    float a = mix(0.5, 2.0, s);\n    float t = 1.0*T;\n    \n\tfloat s1 = sphere(p +a*vec3(cos(t*1.1),cos(t*1.3),cos(t*1.7)), 1.0);\n    float s2 = sphere(p +a*vec3(cos(t*0.7),cos(t*1.9),cos(t*2.3)), 1.2);\n    float s3 = sphere(p +a*vec3(cos(t*0.3),cos(t*2.9),sin(t*1.1)), 1.5);\n    float s4 = sphere(p +a*vec3(sin(t*1.3),sin(t*1.7),sin(t*0.7)), 0.4);\n    float s5 = sphere(p +a*vec3(sin(t*2.3),sin(t*1.9),sin(t*2.9)), 1.0);\n    \n    return blob5(s1, s2, s3, s4, s5);\n}\n\nfloat calcAO(vec3 p,vec3 n)\n{\n\tfloat dlt=0.5;\n\tfloat oc=0.0, d=1.0;\n\tfor(float i=0.0; i<6.; i++) {\n\t\toc+=(i*dlt-map(p+n*i*dlt))\/d;\n\t\td*=2.0;\n\t}\n\t\n\treturn 1.0-oc;\n}\n\nvec3 calcNormal(vec3 p)\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n\treturn normalize( e.xyy *map(p + e.xyy) + \n\t\t\t\t\t  e.yyx *map(p + e.yyx) + \n\t\t\t\t\t  e.yxy *map(p + e.yxy) + \n\t\t\t\t  \t  e.xxx *map(p + e.xxx) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 q = F.xy\/R.xy;\n    vec2 p = 2.0*(q-0.5);\n\tp.x *= R.x\/R.y;\n    vec2 m = M.xy\/R.xy;\n    \n    \/\/ camera\t\n\tvec3 ro = vec3(\n        15.0*cos(0.1*T + 6.0*m.x),\n        10.0 + 10.0*mix(-1.0,1.0, m.y),\n        15.0*sin(0.1*T + 6.0*m.x)\n    );\n\tvec3 ta = vec3( 0.0, 0.4, 0.0 );\n\t\n\t\/\/ camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n          \n    \/\/ ray direction\n    vec3 rd = ca * normalize(vec3(p, 4.5));\n    vec3 col = texture(iChannel0, rd).rgb;\n    \n    float d, t;\n    vec3 pos = vec3(0.0);\n    for (int i=0; i<150; ++i) {\n        t+=(d=map(pos=ro+rd*t));\n        if (d<0.1||t<10.0) {\n\t\t\t            \n            float s = smoothstep( -0.5, 0.5, sin(0.5*T));\n            float bump = mix(0.05, 0.2, s);            \n    \t\tpos += bump*texture(iChannel2, pos).rgb;\n            \n            vec3 normal = calcNormal(pos);            \n            vec2 uv = vec2( atan( normal.x, normal.z ), acos(normal.y) );\n            vec3 tex = texture(iChannel1, uv).rgb;\n            float ao = calcAO(pos, normal);\n\n            vec3 refl = reflect(rd, normal);\n            float rim = pow(clamp(1.0+dot(normal, rd), 0.0, 1.0), 4.0);\n            vec3 reflSample0 = texture(iChannel0, refl).rgb;\n            vec3 reflSample1 = texture(iChannel0, normal).rgb;\n            vec3 reflSample = mix(reflSample0, vec3(reflSample0.rg,reflSample1.b), mix(0.1, 0.3, s));\n                        \n\t\t\tvec3 col0 = vec3(0.005)*tex;\n            vec3 col1 = pow(1.0-pow(rim, 0.6), 16.0)*vec3(1.8)*pow(tex, vec3(6.0));\n            col.rgb = ao*mix(mix(col0, col1, s), reflSample, rim);\n            \n        \tbreak;\n        } \n    }\n    \n    col *= 0.25 + 0.75*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.15 );\n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"ls2Bzy","date":"1501029789","viewed":1172,"name":"[SH17B] Adventure Time","username":"spolsh","description":"Move the mouse and find out which parts of Jake move.\nBased on Jake of Adventure Time.\nWanted to participate with little time to spare for coding, enjoy!","likes":18,"published":3,"flags":64,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"XdXXDj","filepath":"https:\/\/soundcloud.com\/steven-universeonsc\/adventure-time-everthing-stays-official-prod-rebecca-sugar-sung-by-olivia-olson","previewfilepath":"https:\/\/soundcloud.com\/steven-universeonsc\/adventure-time-everthing-stays-official-prod-rebecca-sugar-sung-by-olivia-olson","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ [SH17B] Adventure Time\n\/\/ by Michal \"spolsh\" Klos 2017\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define BLACK vec3(0.0)\n#define WHITE vec3(1.0)\n#define BG vec3(249.0\/255.0, 192.0\/255.0, 41.0\/255.0)\n#define MOUNTH0 vec3(0.5, 0.0, 0.2)\n#define MOUNTH1 vec3(0.9, 0.4, 0.4)\n#define DBG vec3(1.0, 0.0, 1.0)\n#define STROKE 0.005\n\n#define RES iResolution\n#define FRAG fragCoord\n#define T (40.0*iTime)\n#define t (2.0*iTime)\n#define M (iMouse.xy)\n\nfloat udBox( vec2 p, vec2 b )\n{ \/\/ by iq\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdCapsule( vec2 p, vec2 a, vec2 b, float r )\n{ \/\/ by iq\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = FRAG\/RES.xy-0.5;\n    uv.y *= RES.y\/RES.x; \n    \/\/uv *= vec2(1.5);\n    uv += 0.01*vec2(cos(t),sin(t));\n    uv.y += 0.05;\n        \n    float irisMove = 0.002*sin(T);\n    vec2 facePos\t= vec2(0.0, 0.15);\n    vec2 eyePos0\t= facePos +vec2( 0.14, 0.0);\n    vec2 eyePos1\t= facePos +vec2(-0.14, 0.0);\n    vec2 irisPos0\t= eyePos0 +vec2(0.017 +irisMove, 0.025);\n    vec2 irisPos1\t= eyePos1 +vec2(0.017 +irisMove, 0.025);\n    vec2 irisPos2\t= eyePos0 +vec2(-0.04 +irisMove, -0.052);\n    vec2 irisPos3\t= eyePos1 +vec2(-0.04 +irisMove, -0.052);    \n    vec2 nosePos\t= facePos +vec2(0.0, -0.05);\n    vec2 moustachePos0\t= facePos +vec2(0.0, -0.05);\n    vec2 moustachePos1\t= facePos +vec2(0.0, -0.20);    \n    vec2 handsPos = vec2(0.0, -0.2) + vec2(0.0, 0.01*sin(t));\n    vec2 lidPos\t= vec2(0.0, -0.09);\n    \n    vec2 mouseDir = normalize(((fragCoord.xy-M)\/RES.xy) - facePos);\n       \n    vec2 p0 = uv;\n    p0.y *= 1.6;\n    \n    float s0 = length(uv -eyePos0)\t - 0.1;\n    float s1 = length(uv -eyePos1)\t - 0.1;\n    float s2  = length(uv -irisPos0 +0.008*mouseDir)  - 0.065;\n    float s3  = length(uv -irisPos1 +0.008*mouseDir)  - 0.065;    \n    float s9  = length(uv -irisPos2 +0.008*mouseDir)  - 0.025;\n    float s10 = length(uv -irisPos3 +0.008*mouseDir) - 0.025;\n    float s4 = length(p0 -nosePos - vec2(0.0, 0.015)) - 0.062;\n    float s5 = length(p0 -moustachePos0) - 0.12;\n    float s6 = length(p0 -moustachePos0) - 0.12-STROKE;\n    float s7 = uv.y-0.06;\n    float s11 = sdCapsule(p0, nosePos +vec2( 0.091, -0.098), nosePos +vec2( 0.091, 0.0), 0.034);\n    float s12 = sdCapsule(p0, nosePos +vec2(-0.091, -0.098), nosePos +vec2(-0.091, 0.0), 0.034);\n    float s13 = min(max(-s7, s6), min(s11, s12));\n    float s14 = s13 +STROKE;    \n        \n    vec2 p1 = uv -facePos -handsPos;\n    p1.x = -abs(p1.x) + 0.15;    \n    float s15 = sdCapsule(p1, vec2(0.0,    0.0), vec2(0.0,    -1.8), 0.02);\n    float s16 = sdCapsule(p1, vec2(-0.037, 0.0), vec2(-0.037, -1.8), 0.02);\n    float s17 = sdCapsule(p1, vec2(-0.074, 0.0), vec2(-0.074, -1.8), 0.02);\n    float s18 = udBox(p1      +vec2(0.04, 0.3), vec2(0.04, 0.28));\n    float s19 = min(s15, min(s16, s17));\n    float s20 = min(s18, s19 +STROKE);\n    \n    vec2 p2 = uv -facePos -lidPos; \n    p2.x = -abs(p2.x) + 0.15;        \n    p2 *= vec2(1.0, 2.0);\n    float s21 = length(p2) -0.09;\n    float s22 = length(p2 +vec2(0.001, 0.015)) -0.09;\n        \n    vec2 p3 = uv * vec2(1.0, 1.05);\n    p3.y += 0.001*sin(t);\n    float s23 = length(p3 -facePos -vec2(0.0, -0.085)) - 0.065;\n    float s24 = s23 +STROKE;        \n    float s26 = length(p3 -facePos -vec2( 0.0,  -0.115)) - 0.017;\n    float s27 = length(p3 -facePos -vec2( 0.03, -0.108)) - 0.017;\n    float s28 = length(p3 -facePos -vec2(-0.03, -0.108)) - 0.017;\n    float s29 = min( s28, min(s26, s27));\n    float s30 = min( s28, min(s26, s27)) +0.004;\n    p3.y += 0.002*sin(t);\n    float s25 = max( length(p3 -facePos +0.008*mouseDir -vec2(0.02, -0.16)) - 0.03, s24);\n    \n    vec3 c = BG;    \n    c = mix(BLACK,   c, smoothstep(0.0, 0.002, min( s0, s1 )));\n    c = mix(WHITE,   c, smoothstep(0.0, 0.002, min( min( s9, s10), min(s2, s3))));\n    c = mix(BLACK,   c, smoothstep(0.0, 0.002, min(s21, s23)));\n    c = mix(MOUNTH0, c, smoothstep(0.0, 0.002, s24));        \n    c = mix(MOUNTH1, c, smoothstep(0.0, 0.002, s25));                 \t\n    c = mix(BLACK,   c, smoothstep(0.0, 0.002, s29));\n    c = mix(WHITE,   c, smoothstep(0.0, 0.002, s30));\n    c = mix(BG,      c, smoothstep(0.0, 0.002, s22));     \n    c = mix(BLACK,   c, smoothstep(0.0, 0.002, s13));\n    c = mix(BG,      c, smoothstep(0.0, 0.002, s14));   \n    c = mix(BLACK,   c, smoothstep(0.0, 0.002, min(s4, s19)));    \n    c = mix(BG,      c, smoothstep(0.0, 0.002, s20));                 \t       \n    \n    \/\/ c = mix(DBG,     c, smoothstep(0.0, 0.002, length((fragCoord.xy-M)\/RES.xy) - 0.017));                 \t       \n           \n\tfragColor = vec4(c, 0.0);    \n}","name":"Image","description":"","type":"image"}]}];var gFollow = -1;
    var gUseScreenshots = piIsMobile();
    var gThemeName = "classic";
    </script>

</head>

<body onload="resultsInitStatic(8,null,null)">

<!-- header =================================================================================== -->


<div id="header">

    <div id="headerBlock1">
        <a href="/" id="headerTitle">Shadertoy</a>
        <form name="formSearch" action="/results" method="get" style="display:inline-block;">
        <div  id="headerSearch">
            <input type="search" id="mySearch" name="query" placeholder="Search..." value=""/>
        </div>
        </form>
    </div>

    <div id="headerBlock2">
            <a class="headerLinks" href="/browse">Browse</a>
        <a class="headerLinks" href="/new">New</a>
        <a class="headerLinks" href="/signin">Sign In</a>
        </div>
</div>
<!-- content ================================================================================== -->

<div id="content">

    
    <script>
    function follow()
    {
        if (gFollow < 0) return;
        try
        {
            var req = new XMLHttpRequest();
            req.onload = function()
            {
                var jsn = req.response;
                if( jsn==null ) return;
                let btnFollow = document.getElementById( "btnFollow");
                if (gFollow == 1) {
                    gFollow = 0;
                    btnFollow.value="Follow";
                } else if (gFollow == 0) {
                    gFollow = 1;
                    btnFollow.value="Unfollow";
                }
            }
            req.open( "POST", "/shadertoy", true );
            req.responseType = "json";
            req.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
            if (gFollow == 1) {
                var str = "fu=1&uid=spolsh";
            } else if (gFollow == 0) {
                var str = "fs=1&uid=spolsh";
            }
            req.send( str );
        }
        catch(e)
        {
            alert( "exception: " + e );
        }
    }
    </script>

    <!-- ---------------------------------- --> 

    <div id="divUser">
        <table style="border:0px;border-spacing:0px;border-collapse:collapse;"><tr>
        <td style="vertical-align:top;">
        <img id="userPicture" src="/media/users/spolsh/profile.jpeg"></img>        </td>
        <td style="vertical-align:top;padding-left:16px;">
        <b>Name</b>: spolsh <br/><b>Joined</b>: December 30, 2014 <br/> <br/><b>Shaders</b>: 17<br/><b>Playlists</b>: 0<br/><b>Comments</b>: 45<br/> <br/><b>Following</b>: 1<br/><b>Followers</b>: 14<br/>        </td>
        <td style="vertical-align:top;padding-left:32px;">
        <b>About</b><br><br>https://twitter.com/_spolsh<br/>http://codeklos.wordpress.com/<br/>https://www.pouet.net/user.php?who=102277<br/>https://github.com/sp0lsh<br/>https://www.facebook.com/the.mr.klos        </td>
        <td style="vertical-align:top;padding-left:32px;">
                    </td>
        </tr></table>
    </div>

<!-- --------------------------- -->

  <div id="controls">

    <div>
      <div style="text-align: center; vertical-align: middle; display: inline-block; padding-bottom:5px; padding-top:4px; margin-right:8px; margin-bottom:8px; margin-top:8px;">
      Sort:      </div>
      <div class="controlOptions"><div class="pageButtonsCurrent" href="/user/spolsh/sort=popular">Popular</div><a class="pageButtons" href="/user/spolsh/sort=newest">Newest</a><a class="pageButtons" href="/user/spolsh/sort=love">Love</a></div>
    </div>

    <div id="controlFilter">
      <div style="display:flex;margin-right:8px;align-items:center;">Filter:</div>
      <div class="controlOptions"> <a class="pageButtons" href="/user/spolsh&sort=popular&filter=multipass">Multipass</a><a class="pageButtons" href="/user/spolsh&sort=popular&filter=soundoutput">GPU Sound</a><a class="pageButtons" href="/user/spolsh&sort=popular&filter=vr">VR</a><a class="pageButtons" href="/user/spolsh&sort=popular&filter=soundinput">Microphone</a><a class="pageButtons" href="/user/spolsh&sort=popular&filter=musicstream">Soundcloud</a><a class="pageButtons" href="/user/spolsh&sort=popular&filter=webcam">Webcam</a></div>
    </div>

    <div>
        <div style="text-align: center; vertical-align: middle; display: inline-block; padding-bottom:5px; padding-top:4px; margin-right:8px; margin-bottom:8px; margin-top:8px;">
        Results (17):        </div>

        <div class="controlOptions">
              <div id="pageButton"0 class="pageButtonsCurrent" href="/user/spolsh/sort=popular&from=0&num=8">1</div><a id="pageButton"1 class="pageButtons" href="/user/spolsh/sort=popular&from=8&num=8">2</a><a id="pageButton"2 class="pageButtons" href="/user/spolsh/sort=popular&from=16&num=8">3</a>        </div>
    </div>
  </div>


  <div id="shaderGrid">
    <div class='searchResult'><div class='searchResultContainer' id='Preview_0_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_0_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_0_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_0_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_0_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_0_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_0_Thumnail'>        <img class='previewThumbnailImage' id='Preview_0_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_0_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_0_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_0_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_0_Info'>  <span class='previewText'  id='Preview_0_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_0_TextUser'></span>  <span class='previewStats' id='Preview_0_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_1_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_1_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_1_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_1_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_1_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_1_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_1_Thumnail'>        <img class='previewThumbnailImage' id='Preview_1_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_1_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_1_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_1_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_1_Info'>  <span class='previewText'  id='Preview_1_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_1_TextUser'></span>  <span class='previewStats' id='Preview_1_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_2_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_2_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_2_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_2_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_2_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_2_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_2_Thumnail'>        <img class='previewThumbnailImage' id='Preview_2_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_2_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_2_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_2_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_2_Info'>  <span class='previewText'  id='Preview_2_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_2_TextUser'></span>  <span class='previewStats' id='Preview_2_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_3_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_3_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_3_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_3_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_3_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_3_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_3_Thumnail'>        <img class='previewThumbnailImage' id='Preview_3_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_3_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_3_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_3_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_3_Info'>  <span class='previewText'  id='Preview_3_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_3_TextUser'></span>  <span class='previewStats' id='Preview_3_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_4_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_4_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_4_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_4_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_4_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_4_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_4_Thumnail'>        <img class='previewThumbnailImage' id='Preview_4_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_4_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_4_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_4_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_4_Info'>  <span class='previewText'  id='Preview_4_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_4_TextUser'></span>  <span class='previewStats' id='Preview_4_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_5_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_5_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_5_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_5_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_5_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_5_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_5_Thumnail'>        <img class='previewThumbnailImage' id='Preview_5_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_5_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_5_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_5_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_5_Info'>  <span class='previewText'  id='Preview_5_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_5_TextUser'></span>  <span class='previewStats' id='Preview_5_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_6_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_6_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_6_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_6_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_6_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_6_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_6_Thumnail'>        <img class='previewThumbnailImage' id='Preview_6_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_6_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_6_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_6_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_6_Info'>  <span class='previewText'  id='Preview_6_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_6_TextUser'></span>  <span class='previewStats' id='Preview_6_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_7_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_7_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_7_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_7_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_7_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_7_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_7_Thumnail'>        <img class='previewThumbnailImage' id='Preview_7_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_7_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_7_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_7_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_7_Info'>  <span class='previewText'  id='Preview_7_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_7_TextUser'></span>  <span class='previewStats' id='Preview_7_Stats'></span></div></div>  </div>
</div>

<!-- footer ================================================================================== -->

<div id="footer">
    
    <div><span style="color:#ffffff;">Community Forums</span>
      <ul>
      <li><a class="regular" href="/events">Official Events</a></li>
      <li><a class="regular" href="https://www.facebook.com/groups/147749602472741">In Facebook (english)</a></li>
      <li><a class="regular" href="https://www.facebook.com/groups/1339783682699494">In Facebook (korean)</a></li>
      <li><a class="regular" href="https://discord.gg/XtmMN6E">In Discord</a> (<a class="regular" href="https://discordapp.com/channels/578696555612209173/579531723348639754">direct link</a>)</li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Feedback and Support</span>
      <ul>
      <li><a class="regular" href="https://www.facebook.com/Shadertoy">Facebook</a></li>
      <li><a class="regular" href="https://twitter.com/shadertoy">Twitter</a></li>
      <li><a class="regular" href="https://www.patreon.com/shadertoy">Patreon</a></li>
      <li><a class="regular" href="https://trello.com/b/5hM0CjId">Roadmap</a></li>

      
      </ul>
    </div>

    <div><span style="color:#ffffff;">Shadertoy</span>
      <ul>
      <li><a class="regular" href="/store">Store</a></li>
      <li><a class="regular" href="/howto">Documentation</a></li>
      <li><a class="regular" href="/terms">Terms & Privacy</a></li>
      <li><a class="regular" href="/about">About</a></li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Apps and Plugins</span>
      <ul>
      <li><a class="regular" href="https://itunes.apple.com/us/app/shadertoy/id717961814">Official iPhone App</a> by <a class="user" href="/user/reinder">Reinder</a></li>
      <li><a class="regular" href="https://steamcommunity.com/sharedfiles/filedetails/?id=1726697188">Screensaver</a> by <a class="user" href="/user/kosro">Kosro</a></li>
      <li><a class="regular" href="https://chrome.google.com/webstore/detail/shadertoy-unofficial-plug/ohicbclhdmkhoabobgppffepcopomhgl">Shadertoy plugin</a> by <a class="user" href="/user/patu">Patu</a></li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Tutorials</span>
      <ul>
      <li><a class="regular" href="https://www.youtube.com/watch?v=0ifChJ0nJfM">Shader coding intro</a> by <a class="user" href="/user/iq">iq</a></li>
      <li><a class="regular" href="https://shadertoyunofficial.wordpress.com/">Shadertoy Unofficial</a> by <a class="user" href="/user/FabriceNeyret2">FabriceNeyret2</a></li>
      </ul>
    </div>

</div>

<div id="compliance" style="padding-bottom:6px;visibility:hidden;left:0;top:0px;width:100%;background-color:rgb(200,120,20,0.93);position:absolute;color:#FFFFFF">
    <div style="text-align: center; margin-top:8px">
        We use cookies to give you the best experience on our website. If you continue using Shadertoy, we'll assume that you are happy to receive all cookies on this website. 
        For more information, please review our <a class="regular" href="/terms">Terms & Privacy</a>.
    </div> 
    <div style="text-align: center;margin-top:6px">
        <button type="button" style="width:100px;font-size:inherit" onclick="acceptCompliance()">Accept</button>
    </div>
</div>

<script>
(function runCompliance() 
{
    let showCompliance = 1;
    let allcookies = document.cookie;
    let cookiearray = allcookies.split(';');
    for (var i=0; i<cookiearray.length; i++)
    {
        let name  = cookiearray[i].split('=')[0];
        let value = cookiearray[i].split('=')[1];
        if (name.trim() == "scmp") 
        {
            showCompliance = value;
            break;
        }
    }

    if (showCompliance === 1) 
    {
        var ve = document.getElementById("compliance");
        ve.style.visibility="visible";
    }
})();

function acceptCompliance()
{
    let now = new Date();
    now.setTime( now.getTime() + (5*365*24*60*60*1000) );
    document.cookie="scmp=0;expires=" + now.toUTCString() + ";";

    var ve = document.getElementById("compliance");
    ve.style.visibility="hidden";
}
</script>

<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-44068895-1', 'shadertoy.com');
    ga('send', 'pageview');
</script>
</body>
</html>
