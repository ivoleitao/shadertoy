<!DOCTYPE HTML>
<html lang="en">
<head>
    
<title>knarkowicz - Shadertoy BETA</title>
<meta charset="utf-8" />
<meta name="Keywords" content="shadertoy, shader toy, quilez, inigo, jeremias, pol, fractals, demoscene, computer graphics, mathematics, rendering, demo, 3D, realtime, shader, raytracing, raymarching, webgl, glsl" />
<meta name="Description" content="Build shaders, share them, and learn from the best community." />
<meta name="Author" content="Beautypi" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<link rel="image_src" href="https://www.shadertoy.com/img/logo.png" />
<link rel="apple-touch-icon" href="/img/launch_icon_57.png"/>
<link rel="apple-touch-icon" sizes="72x72" href="/img/launch_icon_72.png"/>
<link rel="apple-touch-icon" sizes="114x114" href="/img/launch_icon_114.png"/>
<link rel="shortcut icon" href="/img/favicon.ico"/>

<style>::-webkit-scrollbar {
    height: 8px;
    width: 8px;
    background: #404040;
}

::-webkit-scrollbar-thumb
{
    background: #909090;
    border-radius: 0ex;
}

::-webkit-scrollbar-corner
{
    background: #000;
}

::-webkit-input-placeholder
{
	font-style:italic;
}
input:-moz-placeholder, textarea:-moz-placeholder
{
	font-style:italic;
}
input.placeholder-text, textarea.placeholder-text
{
	font-style:italic;
}

pre 
{
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
    white-space: -pre-wrap;
    white-space: -o-pre-wrap;
    word-wrap: break-word;
}

@font-face
{
    font-family: Lobster;
    src: url("/img/lobster.otf") format("opentype");
}

div#centerScreen
{
    left: 50%;
    top: 50%;
    position: absolute;
}

a.headerLinks:hover
{
    background-color:#505050;
    color : #ff8020;
}

body
{
    color: #000000;
    font-size:12px;
    font-style:normal;
    font-family:Tahoma,Arial;
    background-repeat: no-repeat;
    //background-attachment: fixed;
    padding:0px;
    margin:0px;
    text-align: left;
    background-color: #d0d0d0;
    background-repeat: repeat;
    user-select: text;
}

a,
a:hover,
a:visited
{
  color : inherit;
}

div#content {
    width: 95%;
    overflow: hidden;
    margin: auto;
    padding: 0px;
    min-height: calc(100vh - 80px);
    //box-sizing: border-box;
}


.notificationCount
{
 background-color:#ff0000;
 padding-left:3px;
 padding-right:1px;
 padding-top:1px;
 padding-bottom:1px;
}

div#header
{
    background-color: #404040;
    top: 0px;
    left: 0px;
    width: 100%;
    padding: 0;
    margin: 0;
    color: #ffffff;
    display: flex;
    flex-direction:row;
}

#headerBlock1
{
    width: 50%;
    display:flex;
    align-items:center;
}

a#headerTitle
{
    font-size: 2.25em;
    font-family: Lobster,Tahoma,Arial;
    text-decoration: none;
    padding-left:32px;
    padding-right:32px;
}

#headerSearch
{
    display: inline-block;
    color: #000000;
    width: 300px;
}

input[type=search]#mySearch
{
    width: 100%;
    border-radius: 6px;
    border: 1px solid black;
    padding:12px;
}

#headerBlock2
{
    width: 50%;
    margin-left: auto;
    display: flex;
    justify-content: flex-end;
}


a#headerTitle:hover
{
    color : #ff8020;
}

a.headerLinks
{
    font-weight: bold;
    padding-top: 14px;
    padding-bottom: 14px;
    padding-left: 14px;
    padding-right: 14px;
    margin:0px;
    text-decoration: none;
    transition: background-color 0.15s linear, color 0.15s linear;
}

#footer
{
    background-color: rgba(64,64,64,0.25);
    color: #000000;
    padding: 0px;
    margin: 0px;
    width: 100%;
    display: flex;
    justify-content: space-between;
    flex-wrap: wrap;
}

#footer div
{
    padding-top:10px;
    padding-bottom:0px;
    padding-left:16px;
    padding-right:16px;
}

#footer div ul
{
    margin-left:0px;
    padding-left:16px;
}

#footer div ul li
{
    padding-top:6px;
}

a.regular
{
    font-weight:bold;
    text-decoration:none
}

a.regular:hover
{
  color : #ff8020;
}

a.user
{
    font-weight:bold;
    text-decoration:none;
}

a.user:hover
{
  color : #ff8020;
  text-decoration: underline;
}

.uiButton
{
    border: none;
    outline: none;
    margin: 0px;
    padding: 0px;
    width: 22px;
    height: 22px;
    position: absolute;
    cursor: pointer;
    border-radius: 4px;
}

.uiButton:hover
{
    box-shadow: inset 0px 0px 1px 1px #808080, 0px 0px 1px 1px #808080;
}

.uiDivBUtton
{
    cursor:pointer;
}

.uiDivBUtton:hover
{
    color: #ffffff;
}


.dialog
{
    display: block;
    background-color: #e0e0e0;
    color: #000000;
    border:1px solid #000;
    padding:0px;
    margin:0px;
    text-align:left;
    border-radius: 4px;
    box-shadow:4px 4px 6px 0px rgba(0,0,0,0.5);
    overflow: hidden;
    z-index:1000;
    visibility: hidden;
    opacity:0;
    -moz-transition: opacity 0.25s linear,visibility 0.25s linear;
    -webkit-transition: opacity 0.25s linear,visibility 0.25s linear;
    transition: opacity 0.25s linear,visibility 0.25s linear;
}

.dialogHeader
{
    left:0px;
    top: 0px;
    width:100%;
    height:32px;
    position: absolute;
    background-color: #808080;
    cursor:move;
}

.dialogTitle
{
    left: 12px;
    top: 4px;
    position: absolute;
    padding: 0px;
    margin: 0px;
    color:#000000;
    font-size:1.5em;
    text-align: left;
    user-select: none;
    -moz-user-select: -moz-none;
    -webkit-user-select: none;
}

.dialogOverlay
{
    z-index:1000;

    visibility: hidden;
    opacity:0;
    -moz-transition: opacity 0.25s linear,visibility 0.25s linear;
    -webkit-transition: opacity 0.25s linear,visibility 0.25s linear;
    transition: opacity 0.25s linear,visibility 0.25s linear;

    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    width:100%;
    height:100%;
    position:absolute;

    background-color:rgba(0,0,0,.4);
}

.viewsIcon, .likesIcon
{
    border: none;
    outline: none;
    display:inline-block;
    background-repeat:no-repeat;
    top:0px;
    left:0px;
    padding:0px;
    padding-right: 2px;
    margin:0px;
    position:relative;
}

.userPictureSmall
{
    background-color:#808080;
    border: 1px solid #000000;
    width:32px;
    height:32px;
}

.dialogCloseButton
{
    right:8px;
    top: 4px;
    width:22px;
    height:22px;
    position: absolute;
    background-image: url("/img/close.png");
    cursor: pointer;
    border-radius: 4px;
}

.dialogCloseButton:hover
{
    box-shadow: inset 0px 0px 4px 2px #ffffff, 0px 0px 4px 2px #ffffff;
}

.dialogContentButtons
{
     padding:0;
     border:0;
     text-align: justify;
     left: 24px;
     bottom:40px;
     position:absolute;
}

.dialogButton
{
    text-align: center;
    vertical-align: middle;
    display: inline-block;
    border-radius: 4px;
    font-weight: bold;
    cursor: pointer;
    padding-bottom:5px;
    padding-top:4px;
    padding-left: 8px;
    padding-right: 8px;
    margin-left:4px;
    margin-right:4px;
    text-decoration: none;
    color:#000000;
    width: 80px;
    -moz-transition:    background-color 0.15s linear, color 0.15s linear;
    -webkit-transition: background-color 0.15s linear, color 0.15s linear;
    transition:         background-color 0.15s linear, color 0.15s linear;
}

.dialogButton:hover
{
  background-color:#808080;
  color : #ff8020;
}

.dialogCloseButton:hover
{
    box-shadow: inset 0px 0px 4px 2px #ffffff, 0px 0px 4px 2px #ffffff;
}

.dialogContent
{
    color: inherit;
    overflow: auto;
    width:100%;
    height:100%;
    left: 0px;
    top: 32px;
    position:absolute
}

.dialogContentBody
{
    color: inherit;
    width:100%;
    height:auto;
    padding-top:24px;
    padding-bottom:24px;
    padding-left:24px;
    padding-right:24px;
    text-align: left;
}

.formButton
{
    font-weight:bold;
	color:#ffffff;
	border:none;
    text-align:center;
	background-color:#808080;
    border-radius: 4px;
	padding-left:8px;
	padding-right:8px;
	padding-top:4px;
	padding-bottom:4px;
    cursor:pointer;
    min-width:80px;
    box-sizing: border-box;
}
.formInput {
    border-radius: 6px;
    border: 1px solid black;
    padding: 4px;
    border: none;
}
.formButton:hover {
    background-color: #e0e0e0;
}
.formButton:disabled
{
	color:#b0b0b0;
	background-color:#808080;
}

.formButtonSmall
{
    color:#ffffff;
    border:none;
    text-align:center;
    background-color:#808080;
    border-radius: 4px;
    padding-left:2px;
    padding-right:2px;
    padding-top:2px;
    padding-bottom:2px;
    cursor:pointer;
    min-width:40px;
}

.formButtonSmall:hover
{
    background-color: #e0e0e0;
}

.formButtonSmall:disabled
{
    color:#b0b0b0;
    background-color:#808080;
}

.formButtonSmall.disabled2,
.formButton.disabled2 { color:#b0b0b0; background-color:#808080; pointer-events: none; }

.inputForm
{
    padding-left:2%;
    padding-right:2%;
    resize: none;
    text-align: left;
    background-color:#e0e0e0;
    outline: none;
    border-radius: 4px;
    border: 1px solid #808080;
    color:inherit;
    box-sizing: border-box;
}

.inputForm:focus
{
    border: 1px solid #AFCDD8;
    background-color: #EBF2F4;
}

.transparentPannel
{
    background-color:rgba(64,64,64,0.1);
    padding:16px;
}

.comment, .commentSelf, .commentNew
{
    border-radius: 4px;
    width: 100%;
    margin-left: 0px;
    margin-right: 0px;
    margin-top: 0px;
    margin-bottom: 6px;

    padding: 14px;
    box-sizing: border-box;
    display: grid;
    grid-template-columns: 32px auto 8px;
    grid-template-rows: 1fr;
    grid-gap:8px;
}

.comment:nth-child(even)
{
    background-color: rgba(64,64,64,0.1);
}

.comment:nth-child(odd)
{
    background-color: rgba(128,128,128,0.1);
}

.commentSelf
{
    background-color: rgba(240,160,64,0.1);
}

.commentNew
{
    padding-right: 0px;
    grid-template-columns: 40px auto;
}

.commentContent
{
    vertical-align: top;
    text-align: left;
    word-break: break-all;
    word-break: break-word;
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
}


/* ----------------------- media resolutions ------------------------ */

@media screen and (max-width:799px)
{
    div#header {flex-direction:column; }
    #headerBlock1 { width:100%; }
    #headerBlock2 { width:100%; justify-content: space-around;}
    div#headerSearch {width:200px;}
    input#mySearch { width:200px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .previewText { width:130px; }
    .transparentPannel { padding:10px; }
}

@media screen and (min-width:800px) and (max-width:1279px)
{
    body { font-size: 9px; }
    div#headerSearch {width: 250px;}
    input#mySearch { width:250px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .previewText { width:130px; }
    .transparentPannel { padding:11px; }
}

@media screen and (min-width:1280px) and (max-width:1439px)
{
    body { font-size: 10px; }
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:28px; }
    .previewText { width:180px; }
    .transparentPannel { padding:12px; }
}

@media screen and (min-width:1440px) and (max-width:1919px)
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:28px; }
    .previewText { width:180px; }
    .transparentPannel { padding:12px; }
}

@media screen and (min-width:1920px) and (max-width:2559px)
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:32px; }
    .previewText { width:220px; }
    .transparentPannel { padding:16px; }
}

@media screen and (min-width:2560px) 
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:32px; }
    .previewText { width:220px; }
    .transparentPannel { padding:16px; }
}
body
{
    background-image: url("/img/themes/classic/background.jpg");
}
</style>


    <script>"use strict"

//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piCamera
//
//==============================================================================

function piCamera()
{
    var mMatrix = setIdentity();
    var mMatrixInv = setIdentity();

    var mPosition = [0.0,0.0,0.0];
    var mXRotation = 0.0;
    var mYRotation = 0.0;

    var mPositionTarget = [0.0,0.0,0.0];
    var mXRotationTarget = 0.0;
    var mYRotationTarget = 0.0;

    var me = {};
/*
    me.Set = function( pos, dir, roll) 
             {
                 mMatrix    = setLookat( pos, add(pos,dir), [Math.sin(roll),Math.cos(roll),Math.sin(roll)] );
                 mMatrixInv = invertFast( mMatrix );
             };
*/
    me.SetPos = function(pos)
                {
                    mPosition = pos;
                    //mMatrix[ 3] = -(mMatrix[0] * pos[0] + mMatrix[1] * pos[1] + mMatrix[ 2] * pos[2]);
                    //mMatrix[ 7] = -(mMatrix[4] * pos[0] + mMatrix[5] * pos[1] + mMatrix[ 6] * pos[2]);
                    //mMatrix[11] = -(mMatrix[8] * pos[0] + mMatrix[9] * pos[1] + mMatrix[10] * pos[2]);
                };
/*
    me.GlobalMove = function(pos)
                    {
                        mMatrix[ 3] -= (mMatrix[0] * pos[0] + mMatrix[1] * pos[1] + mMatrix[ 2] * pos[2]);
                        mMatrix[ 7] -= (mMatrix[4] * pos[0] + mMatrix[5] * pos[1] + mMatrix[ 6] * pos[2]);
                        mMatrix[11] -= (mMatrix[8] * pos[0] + mMatrix[9] * pos[1] + mMatrix[10] * pos[2]);
                        mMatrixInv = invertFast(mMatrix);
                    };
*/
    me.LocalMove = function( dis )
                    {
                        dis = matMulvec( setRotationY(-mYRotation), dis);
                        mPositionTarget = sub(mPositionTarget,dis)
                    };

    me.RotateXY = function( x, y)
                  {
                    mXRotationTarget -= x;
                    mYRotationTarget -= y;
                    mXRotationTarget = Math.min( Math.max( mXRotationTarget, -Math.PI/2), Math.PI/2 );
                  };


    me.CameraExectue = function( dt )
    {
        // smooth position
        mXRotation += (mXRotationTarget-mXRotation) * 12.0*dt;
        mYRotation += (mYRotationTarget-mYRotation) * 12.0*dt;
        mPosition = add(mPosition, mul( sub(mPositionTarget, mPosition), 12.0*dt));

        // Make Camera matrix
        mMatrix = matMul( matMul(setRotationX(mXRotation), 
                                 setRotationY(mYRotation)),  
                                 setTranslation(mPosition));
        mMatrixInv = invertFast(mMatrix);

    }

    me.GetMatrix = function() { return mMatrix; };
    me.GetMatrixInverse = function() { return mMatrixInv; };
    me.SetMatrix = function( mat ) 
                    {
                        mMatrix = mat;
                        mMatrixInv = invertFast(mMatrix);

                        mPosition = getXYZ(matMulpoint(mat, [0.0,0.0,0.0]));
                        mPositionTarget = mPosition;
                    };

    me.GetPos = function() { return getXYZ(matMulpoint(mMatrixInv, [0.0,0.0,0.0])); }
    me.GetDir = function() { return getXYZ(normalize(matMulvec(mMatrixInv, [0.0,0.0,-1.0]))); }

    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piFile
//
//==============================================================================

function piFile( binaryDataArrayBuffer )
{
    // private
    //var mDataView = new DataView( binaryDataArrayBuffer, 0 );
    var mDataView = binaryDataArrayBuffer;
    var mOffset = 0;

    // public members
    var me = {};
    me.mDummy = 0;
/*
    // public functions
    me.Seek = function( off ) { mOffset = off - 3; };
    me.ReadUInt16 = function()  { var res = mDataView.getUint16( mOffset ); mOffset+=2; return res; };
    me.ReadUInt32 = function()  { var res = mDataView.getUint32( mOffset ); mOffset+=4; return res; };
    me.ReadUInt64 = function()  { return me.ReadUInt32() + (me.ReadUInt32()<<32); };
    me.ReadFloat32 = function() { var res = mDataView.getFloat32( mOffset ); mOffset+=4; return res; };
*/

    me.Seek = function( off ) { mOffset = off; };
    me.ReadUInt8  = function()  { var res = (new Uint8Array(mDataView,mOffset))[0]; mOffset+=1; return res; };
    me.ReadUInt16 = function()  { var res = (new Uint16Array(mDataView,mOffset))[0]; mOffset+=2; return res; };
    me.ReadUInt32 = function()  { var res = (new Uint32Array(mDataView,mOffset))[0]; mOffset+=4; return res; };
    me.ReadUInt64 = function()  { return me.ReadUInt32() + (me.ReadUInt32()<<32); };
    me.ReadFloat32 = function() { var res = (new Float32Array(mDataView,mOffset))[0]; mOffset+=4; return res; };
    me.ReadFloat32Array = function(n) 
                          { 
                              var src = new Float32Array(mDataView, mOffset);
                              var res = [];  for( var i=0; i<n; i++ ) { res[i] = src[i]; }
                              mOffset += 4*n;
                              return res;
                          };
    me.ReadFloat32ArrayNative = function(n) { var src = new Float32Array(mDataView, mOffset); mOffset += 4*n; return src; };
    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piMesh
//
//==============================================================================

function piMesh()
{
    this.mChunks = [];
    this.mPrimitiveType = 0;
    this.mVertexFormat = null;
}

/*
piMesh.prototype.normalize = function( ppos, npos )
{
    var numv = this.mVertexData.length;
    var numt = this.mIndices.length;

    for( var i=0; i<numv; i++ )
    {
        //float *v = (float*)piMesh_GetVertexData( me, i, npos );
        //v[0] = 0.0f;
        //v[1] = 0.0f;
        //v[2] = 0.0f;
        this.mVerts[8 * i + 3] = 0.0;
        this.mVerts[8 * i + 4] = 0.0;
        this.mVerts[8 * i + 5] = 0.0;
    }

    for( var i=0; i<numt; i++ )
    {
        piMeshFace *face = me->mFaceData.mIndexArray[0].mBuffer + i;

        const int ft = face->mNum;
        
        vec3 nor = vec3( 0.0f, 0.0f, 0.0f );
        for( int j=0; j<ft; j++ )
        {
            const vec3 va = *((vec3*)piMesh_GetVertexData( me, face->mIndex[ j      ], ppos ));
            const vec3 vb = *((vec3*)piMesh_GetVertexData( me, face->mIndex[(j+1)%ft], ppos ));

            nor += cross( va, vb );
        }

        for( int j=0; j<ft; j++ )
        {
            vec3 *n = (vec3*)piMesh_GetVertexData( me, face->mIndex[j], npos );
            n->x += nor.x;
            n->y += nor.y;
            n->z += nor.z;
        }
    }

    for( var i=0; i<numv; i++ )
    {
        vec3 *v = (vec3*)piMesh_GetVertexData( me, i, npos );
        *v = normalize( *v );
    }
}
*/

piMesh.prototype.createCube = function(renderer)
{
    this.mPrimitiveType = 0;

    this.mChunks[0] = { mVerts : new Float32Array([ -1.0, -1.0, -1.0,
                                       1.0, -1.0, -1.0,
                                      -1.0,  1.0, -1.0,
                                       1.0,  1.0, -1.0,
                                      -1.0, -1.0,  1.0,
                                       1.0, -1.0,  1.0,
                                      -1.0,  1.0,  1.0,
                                       1.0,  1.0,  1.0 ]),

                        mIndices : new Uint16Array([ 0, 2, 1,   1, 2, 3,   5, 1, 3,   5, 3, 7,   4, 5, 7,   4, 7, 6,   4, 6, 2,   4, 2, 0,   6, 7, 3,   6, 3, 2,   4, 0, 1,   4, 1, 5 ]),
                        mNumVertices : 8,
                        mNumFaces : 12, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };

    this.mVertexFormat = { mStride:12, mChannels:[ { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false } ] };

    return true;
}

piMesh.prototype.createCubeSharp = function (renderer)
{
    this.mPrimitiveType = 0;

    this.mChunks[0] = { mVerts : new Float32Array([-1.0, 1.0,-1.0,   0.0, 1.0, 0.0,   0.0, 0.0,
                                    -1.0, 1.0, 1.0,   0.0, 1.0, 0.0,   0.0, 1.0,
                                     1.0, 1.0, 1.0,   0.0, 1.0, 0.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   0.0, 1.0, 0.0,   1.0, 0.0,

                                    -1.0,-1.0, 1.0,   0.0, 0.0, 1.0,   0.0, 0.0,
                                     1.0,-1.0, 1.0,   0.0, 0.0, 1.0,   0.0, 1.0,
                                     1.0, 1.0, 1.0,   0.0, 0.0, 1.0,   1.0, 1.0,
                                    -1.0, 1.0, 1.0,   0.0, 0.0, 1.0,   1.0, 0.0,

                                     1.0, 1.0, 1.0,   1.0, 0.0, 0.0,   0.0, 0.0,
                                     1.0,-1.0, 1.0,   1.0, 0.0, 0.0,   0.0, 1.0,
                                     1.0,-1.0,-1.0,   1.0, 0.0, 0.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   1.0, 0.0, 0.0,   1.0, 0.0,

                                     1.0,-1.0,-1.0,   0.0, 0.0,-1.0,   0.0, 0.0,
                                    -1.0,-1.0,-1.0,   0.0, 0.0,-1.0,   0.0, 1.0,
                                    -1.0, 1.0,-1.0,   0.0, 0.0,-1.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   0.0, 0.0,-1.0,   1.0, 0.0,

                                    -1.0,-1.0, 1.0,   0.0,-1.0, 0.0,   0.0, 0.0,
                                    -1.0,-1.0,-1.0,   0.0,-1.0, 0.0,   0.0, 1.0,
                                     1.0,-1.0,-1.0,   0.0,-1.0, 0.0,   1.0, 1.0,
                                     1.0,-1.0, 1.0,   0.0,-1.0, 0.0,   1.0, 0.0,

                                    -1.0, 1.0, 1.0,  -1.0, 0.0, 0.0,   0.0, 0.0,
                                    -1.0, 1.0,-1.0,  -1.0, 0.0, 0.0,   0.0, 1.0,
                                    -1.0,-1.0,-1.0,  -1.0, 0.0, 0.0,   1.0, 1.0,
                                    -1.0,-1.0, 1.0,  -1.0, 0.0, 0.0,   1.0, 0.0 ]),

                        mIndices : new Uint16Array([0,1,2, 0,2,3,   4,5,6, 4,6,7,    8,9,10,8,10,11,   12,13,14,12,14,15,   16,17,18,16,18,19,   20,21,22,20,22,23]),
                        mNumVertices : 24,
                        mNumFaces : 12, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };


    this.mVertexFormat = { mStride:32, mChannels:[ { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false },
                                                   { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false },
                                                   { mNumComponents:2, mType: renderer.TYPE.FLOAT32, mNormalize: false } ] };

    return true;
}


piMesh.prototype.createUnitQuad = function (renderer)
{
    this.mPrimitiveType = 0;
    this.mVertexFormat = { mStride:8, mChannels: [ {mNumComponents:2, mType: renderer.TYPE.FLOAT32, mNormalize: false} ] };

    this.mChunks[0] = { mVerts : new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0,  1.0, 1.0,  1.0]),
                        mIndices : new Uint16Array([0, 2, 1, 1, 2, 3]),
                        mNumVertices : 4,
                        mNumFaces : 2, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };
 
    return true;
}




piMesh.prototype.destroy = function()
{
    //delete this.mVerts;   this.mVerts = null;
    //delete this.mIndices; this.mIndices = null;
}

piMesh.prototype.scale = function (x, y, z)
{
    var stride = this.mVertexFormat.mStride/4;
    for( var j=0; j<this.mChunks.length; j++ )
    {
        var nv = this.mChunks[j].mNumVertices;
        for (var i = 0; i < nv; i++) 
        {
            this.mChunks[j].mVerts[stride * i + 0] *= x;
            this.mChunks[j].mVerts[stride * i + 1] *= y;
            this.mChunks[j].mVerts[stride * i + 2] *= z;
        }
    }
}

piMesh.prototype.translate = function (x, y, z) 
{
    var stride = this.mVertexFormat.mStride/4;
    for( var j=0; j<this.mChunks.length; j++ )
    {
        var nv = this.mChunks[j].mNumVertices;
        for (var i = 0; i < nv; i++) 
        {
            this.mChunks[j].mVerts[stride * i + 0] += x;
            this.mChunks[j].mVerts[stride * i + 1] += y;
            this.mChunks[j].mVerts[stride * i + 2] += z;
        }
    }
}

piMesh.prototype.GPULoad = function (renderer)
{
    for( var i=0; i<this.mChunks.length; i++ )
    {
        var vbo = renderer.CreateVertexArray(this.mChunks[i].mVerts, renderer.BUFTYPE.STATIC );
        if (vbo == null)
            return false;

        var ibo = renderer.CreateIndexArray(this.mChunks[i].mIndices, renderer.BUFTYPE.STATIC);
        if (ibo == null)
            return false;

        this.mChunks[i].mVBO = vbo;
        this.mChunks[i].mIBO = ibo;
    }
    return true;
}

piMesh.prototype.GPURender = function (renderer, positions )//, matPrj, matCam )
{
    //renderer.SetShaderConstantMat4F("unMPrj", matPrj, false );

    var num = this.mChunks.length;
    for( var i=0; i<num; i++ )
    {
        //var mat =  matMul( matCam, this.mChunks[i].mTransform );
        //renderer.SetShaderConstantMat4F("unMMod", mat, false);

        renderer.AttachVertexArray(this.mChunks[i].mVBO, this.mVertexFormat, positions );
        renderer.AttachIndexArray(this.mChunks[i].mIBO );
        renderer.DrawPrimitive(renderer.PRIMTYPE.TRIANGLES, this.mChunks[i].mNumFaces * 3, true, 1);
        renderer.DetachIndexArray(this.mChunks[i].mIBO);
        renderer.DetachVertexArray(this.mChunks[i].mVBO, this.mVertexFormat );
    }
}
//==============================================================================
//
// piLibs 2014-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piRenderer
//
//==============================================================================

function piRenderer()
{
    // private members

    var mGL = null;
    var mBindedShader = null;
    var mIs20 = false;
    var mFloat32Textures;
    var mFloat32Filter;
    var mFloat16Textures;
    var mDrawBuffers;
    var mDepthTextures;
    var mDerivatives;
    var mFloat16Filter;
    var mShaderTextureLOD;
    var mAnisotropic;
    var mRenderToFloat32F;
    var mDebugShader;
    var mAsynchCompile;

    var mVBO_Quad = null;
    var mVBO_Tri = null;
    var mVBO_CubePosNor = null;
    var mVBO_CubePos = null;
    var mShaderHeader = ["",""];
    var mShaderHeaderLines = [0,0];

    // public members
    var me = {};

    me.CLEAR      = { Color: 1, Zbuffer : 2, Stencil : 4 };
    me.TEXFMT     = { C4I8 : 0, C1I8 : 1, C1F16 : 2, C4F16 : 3, C1F32 : 4, C4F32 : 5, Z16 : 6, Z24 : 7, Z32 : 8, C3F32:9 };
    me.TEXWRP     = { CLAMP : 0, REPEAT : 1 };
    me.BUFTYPE    = { STATIC : 0, DYNAMIC : 1 };
    me.PRIMTYPE   = { POINTS : 0, LINES : 1, LINE_LOOP : 2, LINE_STRIP : 3, TRIANGLES : 4, TRIANGLE_STRIP : 5 };
    me.RENDSTGATE = { WIREFRAME : 0, FRONT_FACE : 1, CULL_FACE : 2, DEPTH_TEST : 3, ALPHA_TO_COVERAGE : 4 };
    me.TEXTYPE    = { T2D : 0, T3D : 1, CUBEMAP : 2 };
    me.FILTER     = { NONE : 0, LINEAR : 1, MIPMAP : 2, NONE_MIPMAP : 3 };
    me.TYPE       = { UINT8 : 0, UINT16 : 1, UINT32 : 2, FLOAT16: 3, FLOAT32 : 4, FLOAT64: 5 };

    // private functions

    var iFormatPI2GL = function( format )
    {
        if( mIs20 )
        {
             if (format === me.TEXFMT.C4I8)  return { mGLFormat: mGL.RGBA8,           mGLExternal: mGL.RGBA,             mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1I8)  return { mGLFormat: mGL.R8,              mGLExternal: mGL.RED,              mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1F16) return { mGLFormat: mGL.R16F,            mGLExternal: mGL.RED,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F16) return { mGLFormat: mGL.RGBA16F,         mGLExternal: mGL.RGBA,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C1F32) return { mGLFormat: mGL.R32F,            mGLExternal: mGL.RED,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F32) return { mGLFormat: mGL.RGBA32F,         mGLExternal: mGL.RGBA,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C3F32) return { mGLFormat: mGL.RGB32F,          mGLExternal: mGL.RGB,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.Z16)   return { mGLFormat: mGL.DEPTH_COMPONENT16, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        else if (format === me.TEXFMT.Z24)   return { mGLFormat: mGL.DEPTH_COMPONENT24, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        else if (format === me.TEXFMT.Z32)   return { mGLFormat: mGL.DEPTH_COMPONENT32F, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        }
        else
        {
             if (format === me.TEXFMT.C4I8)  return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1I8)  return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.LUMINANCE,       mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1F16) return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.LUMINANCE,       mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F16) return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C1F32) return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.RED,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F32) return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.Z16)   return { mGLFormat: mGL.DEPTH_COMPONENT, mGLExternal: mGL.DEPTH_COMPONENT, mGLType: mGL.UNSIGNED_SHORT }
        }

        return null;
     }

    // public functions

    me.Initialize = function( gl )
                    {
                        mGL = gl;

                        mIs20 = !(gl instanceof WebGLRenderingContext);

                        if( mIs20 )
                        {
                            mFloat32Textures  = true;
                            mFloat32Filter    = mGL.getExtension( 'OES_texture_float_linear');
                            mFloat16Textures  = true;
                            mFloat16Filter    = mGL.getExtension( 'OES_texture_half_float_linear' );
                            mDerivatives      = true;
                            mDrawBuffers      = true;
                            mDepthTextures    = true;
                            mShaderTextureLOD = true;
                            mAnisotropic = mGL.getExtension( 'EXT_texture_filter_anisotropic' );
                            mRenderToFloat32F = mGL.getExtension( 'EXT_color_buffer_float');
                            mDebugShader = mGL.getExtension('WEBGL_debug_shaders');
                            mAsynchCompile = mGL.getExtension('KHR_parallel_shader_compile');

							mGL.hint( mGL.FRAGMENT_SHADER_DERIVATIVE_HINT, mGL.NICEST);
                        }
                        else
                        {
                            mFloat32Textures  = mGL.getExtension( 'OES_texture_float' );
                            mFloat32Filter    = mGL.getExtension( 'OES_texture_float_linear');
                            mFloat16Textures  = mGL.getExtension( 'OES_texture_half_float' );
                            mFloat16Filter    = mGL.getExtension( 'OES_texture_half_float_linear' );
                            mDerivatives      = mGL.getExtension( 'OES_standard_derivatives' );
                            mDrawBuffers      = mGL.getExtension( 'WEBGL_draw_buffers' );
                            mDepthTextures    = mGL.getExtension( 'WEBGL_depth_texture' );
                            mShaderTextureLOD = mGL.getExtension( 'EXT_shader_texture_lod' );
                            mAnisotropic      = mGL.getExtension( 'EXT_texture_filter_anisotropic' );
                            mRenderToFloat32F = mFloat32Textures;
                            mDebugShader      = null;
                            mAsynchCompile    = null;
							
							if( mDerivatives !== null) mGL.hint( mDerivatives.FRAGMENT_SHADER_DERIVATIVE_HINT_OES, mGL.NICEST);
                        }
                        
                        
                        var maxTexSize = mGL.getParameter( mGL.MAX_TEXTURE_SIZE );
                        var maxCubeSize = mGL.getParameter( mGL.MAX_CUBE_MAP_TEXTURE_SIZE );
                        var maxRenderbufferSize = mGL.getParameter( mGL.MAX_RENDERBUFFER_SIZE );
                        var extensions = mGL.getSupportedExtensions();
                        var textureUnits = mGL.getParameter( mGL.MAX_TEXTURE_IMAGE_UNITS );
                        console.log("WebGL (2.0=" + mIs20 + "):" +
                                    " Asynch Compile: "  + ((mAsynchCompile !==null) ? "yes" : "no") +
                                    ", Textures: F32 ["   + ((mFloat32Textures !==null) ? "yes" : "no") +
                                    "], F16 ["   + ((mFloat16Textures !==null) ? "yes" : "no") +
                                    "], Depth [" + ((mDepthTextures   !==null) ? "yes" : "no") +
                                    "], LOD ["    + ((mShaderTextureLOD!==null) ? "yes" : "no") +
                                    "], Aniso ["   + ((mAnisotropic     !==null) ? "yes" : "no") +
                                    "], Units [" + textureUnits +
                                    "], Max Size [" + maxTexSize +
                                    "], Cube Max Size [" + maxCubeSize +
                                    "], Targets: MRT ["            + ((mDrawBuffers     !==null) ? "yes" : "no") +
                                    "], F32 ["     + ((mRenderToFloat32F!==null) ? "yes" : "no") +
                                    "], Max Size [" + maxRenderbufferSize + "]");

                        // create a 2D quad Vertex Buffer
                        var vertices = new Float32Array( [ -1.0, -1.0,   1.0, -1.0,    -1.0,  1.0,     1.0, -1.0,    1.0,  1.0,    -1.0,  1.0] );
                        mVBO_Quad = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Quad );
                        mGL.bufferData( mGL.ARRAY_BUFFER, vertices, mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 2D triangle Vertex Buffer
                        mVBO_Tri = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Tri );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0,   3.0, -1.0,    -1.0,  3.0] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 3D cube Vertex Buffer
                        mVBO_CubePosNor = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePosNor );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0, -1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0, -1.0,  1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0,  1.0, -1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0,  1.0,  1.0,  -1.0,  0.0,  0.0,
                                                                               1.0,  1.0, -1.0,   1.0,  0.0,  0.0,
                                                                               1.0,  1.0,  1.0,   1.0,  0.0,  0.0,
                                                                               1.0, -1.0, -1.0,   1.0,  0.0,  0.0,
                                                                               1.0, -1.0,  1.0,   1.0,  0.0,  0.0,
                                                                               1.0,  1.0,  1.0,   0.0,  1.0,  0.0,
                                                                               1.0,  1.0, -1.0,   0.0,  1.0,  0.0,
                                                                              -1.0,  1.0,  1.0,   0.0,  1.0,  0.0,
                                                                              -1.0,  1.0, -1.0,   0.0,  1.0,  0.0,
                                                                               1.0, -1.0, -1.0,   0.0, -1.0,  0.0,
                                                                               1.0, -1.0,  1.0,   0.0, -1.0,  0.0,
                                                                              -1.0, -1.0, -1.0,   0.0, -1.0,  0.0,
                                                                              -1.0, -1.0,  1.0,   0.0, -1.0,  0.0,
                                                                              -1.0,  1.0,  1.0,   0.0,  0.0,  1.0,
                                                                              -1.0, -1.0,  1.0,   0.0,  0.0,  1.0,
                                                                               1.0,  1.0,  1.0,   0.0,  0.0,  1.0,
                                                                               1.0, -1.0,  1.0,   0.0,  0.0,  1.0,
                                                                              -1.0, -1.0, -1.0,   0.0,  0.0, -1.0,
                                                                              -1.0,  1.0, -1.0,   0.0,  0.0, -1.0,
                                                                               1.0, -1.0, -1.0,   0.0,  0.0, -1.0,
                                                                               1.0,  1.0, -1.0,   0.0,  0.0, -1.0 ] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 3D cube Vertex Buffer
                        mVBO_CubePos = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePos );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0, -1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                               1.0,  1.0, -1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0, -1.0,  1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0,  1.0, -1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0, -1.0,  1.0,
                                                                              -1.0, -1.0, -1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0, -1.0,  1.0,
                                                                              -1.0, -1.0, -1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0,  1.0, -1.0 ] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        //-------------------------------------------------------------------

                        mShaderHeader[0] = "";
                        mShaderHeaderLines[0] = 0;
                        if( mIs20 ) 
                        { 
                            mShaderHeader[0] += "#version 300 es\n" +
                                                "#ifdef GL_ES\n"+
                                                "precision highp float;\n" +
                                                "precision highp int;\n"+
                                                "precision mediump sampler3D;\n"+
                                                "#endif\n"; 
                            mShaderHeaderLines[0] += 6;
                        }
                        else
                        {
                            mShaderHeader[0] += "#ifdef GL_ES\n"+
                                                "precision highp float;\n" +
                                                "precision highp int;\n"+
                                                "#endif\n"+
                                                "float round( float x ) { return floor(x+0.5); }\n"+
                                                "vec2 round(vec2 x) { return floor(x + 0.5); }\n"+
                                                "vec3 round(vec3 x) { return floor(x + 0.5); }\n"+
                                                "vec4 round(vec4 x) { return floor(x + 0.5); }\n"+
                                                "float trunc( float x, float n ) { return floor(x*n)/n; }\n"+
                                                "mat3 transpose(mat3 m) { return mat3(m[0].x, m[1].x, m[2].x, m[0].y, m[1].y, m[2].y, m[0].z, m[1].z, m[2].z); }\n"+
                                                "float determinant( in mat2 m ) { return m[0][0]*m[1][1] - m[0][1]*m[1][0]; }\n"+
                                                "float determinant( mat4 m ) { float b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0], b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0], b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0], b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1], b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1], b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2], b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0], b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0], b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0], b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1], b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1], b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;}\n"+
                                                "mat2 inverse(mat2 m) { float det = determinant(m); return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / det; }\n"+
                                                "mat4 inverse(mat4 m ) { float inv0 = m[1].y*m[2].z*m[3].w - m[1].y*m[2].w*m[3].z - m[2].y*m[1].z*m[3].w + m[2].y*m[1].w*m[3].z + m[3].y*m[1].z*m[2].w - m[3].y*m[1].w*m[2].z; float inv4 = -m[1].x*m[2].z*m[3].w + m[1].x*m[2].w*m[3].z + m[2].x*m[1].z*m[3].w - m[2].x*m[1].w*m[3].z - m[3].x*m[1].z*m[2].w + m[3].x*m[1].w*m[2].z; float inv8 = m[1].x*m[2].y*m[3].w - m[1].x*m[2].w*m[3].y - m[2].x  * m[1].y * m[3].w + m[2].x  * m[1].w * m[3].y + m[3].x * m[1].y * m[2].w - m[3].x * m[1].w * m[2].y; float inv12 = -m[1].x  * m[2].y * m[3].z + m[1].x  * m[2].z * m[3].y +m[2].x  * m[1].y * m[3].z - m[2].x  * m[1].z * m[3].y - m[3].x * m[1].y * m[2].z + m[3].x * m[1].z * m[2].y; float inv1 = -m[0].y*m[2].z * m[3].w + m[0].y*m[2].w * m[3].z + m[2].y  * m[0].z * m[3].w - m[2].y  * m[0].w * m[3].z - m[3].y * m[0].z * m[2].w + m[3].y * m[0].w * m[2].z; float inv5 = m[0].x  * m[2].z * m[3].w - m[0].x  * m[2].w * m[3].z - m[2].x  * m[0].z * m[3].w + m[2].x  * m[0].w * m[3].z + m[3].x * m[0].z * m[2].w - m[3].x * m[0].w * m[2].z; float inv9 = -m[0].x  * m[2].y * m[3].w +  m[0].x  * m[2].w * m[3].y + m[2].x  * m[0].y * m[3].w - m[2].x  * m[0].w * m[3].y - m[3].x * m[0].y * m[2].w + m[3].x * m[0].w * m[2].y; float inv13 = m[0].x  * m[2].y * m[3].z - m[0].x  * m[2].z * m[3].y - m[2].x  * m[0].y * m[3].z + m[2].x  * m[0].z * m[3].y + m[3].x * m[0].y * m[2].z - m[3].x * m[0].z * m[2].y; float inv2 = m[0].y  * m[1].z * m[3].w - m[0].y  * m[1].w * m[3].z - m[1].y  * m[0].z * m[3].w + m[1].y  * m[0].w * m[3].z + m[3].y * m[0].z * m[1].w - m[3].y * m[0].w * m[1].z; float inv6 = -m[0].x  * m[1].z * m[3].w + m[0].x  * m[1].w * m[3].z + m[1].x  * m[0].z * m[3].w - m[1].x  * m[0].w * m[3].z - m[3].x * m[0].z * m[1].w + m[3].x * m[0].w * m[1].z; float inv10 = m[0].x  * m[1].y * m[3].w - m[0].x  * m[1].w * m[3].y - m[1].x  * m[0].y * m[3].w + m[1].x  * m[0].w * m[3].y + m[3].x * m[0].y * m[1].w - m[3].x * m[0].w * m[1].y; float inv14 = -m[0].x  * m[1].y * m[3].z + m[0].x  * m[1].z * m[3].y + m[1].x  * m[0].y * m[3].z - m[1].x  * m[0].z * m[3].y - m[3].x * m[0].y * m[1].z + m[3].x * m[0].z * m[1].y; float inv3 = -m[0].y * m[1].z * m[2].w + m[0].y * m[1].w * m[2].z + m[1].y * m[0].z * m[2].w - m[1].y * m[0].w * m[2].z - m[2].y * m[0].z * m[1].w + m[2].y * m[0].w * m[1].z; float inv7 = m[0].x * m[1].z * m[2].w - m[0].x * m[1].w * m[2].z - m[1].x * m[0].z * m[2].w + m[1].x * m[0].w * m[2].z + m[2].x * m[0].z * m[1].w - m[2].x * m[0].w * m[1].z; float inv11 = -m[0].x * m[1].y * m[2].w + m[0].x * m[1].w * m[2].y + m[1].x * m[0].y * m[2].w - m[1].x * m[0].w * m[2].y - m[2].x * m[0].y * m[1].w + m[2].x * m[0].w * m[1].y; float inv15 = m[0].x * m[1].y * m[2].z - m[0].x * m[1].z * m[2].y - m[1].x * m[0].y * m[2].z + m[1].x * m[0].z * m[2].y + m[2].x * m[0].y * m[1].z - m[2].x * m[0].z * m[1].y; float det = m[0].x * inv0 + m[0].y * inv4 + m[0].z * inv8 + m[0].w * inv12; det = 1.0 / det; return det*mat4( inv0, inv1, inv2, inv3,inv4, inv5, inv6, inv7,inv8, inv9, inv10, inv11,inv12, inv13, inv14, inv15);}\n"+                                                
                                                "float sinh(float x)  { return (exp(x)-exp(-x))/2.; }\n"+
                                                "float cosh(float x)  { return (exp(x)+exp(-x))/2.; }\n"+
                                                "float tanh(float x)  { return sinh(x)/cosh(x); }\n"+
                                                "float coth(float x)  { return cosh(x)/sinh(x); }\n"+
                                                "float sech(float x)  { return 1./cosh(x); }\n"+
                                                "float csch(float x)  { return 1./sinh(x); }\n"+
                                                "float asinh(float x) { return    log(x+sqrt(x*x+1.)); }\n"+
                                                "float acosh(float x) { return    log(x+sqrt(x*x-1.)); }\n"+
                                                "float atanh(float x) { return .5*log((1.+x)/(1.-x)); }\n"+
                                                "float acoth(float x) { return .5*log((x+1.)/(x-1.)); }\n"+
                                                "float asech(float x) { return    log((1.+sqrt(1.-x*x))/x); }\n"+
                                                "float acsch(float x) { return    log((1.+sqrt(1.+x*x))/x); }\n";
                            mShaderHeaderLines[0] += 26;
                        }

                        //-------------------------------------------------------

                        mShaderHeader[1] = "";
                        mShaderHeaderLines[1] = 0;
                        if( mIs20 ) 
                        { 
                            mShaderHeader[1] += "#version 300 es\n"+
                                                "#ifdef GL_ES\n"+
                                                "precision highp float;\n"+
                                                "precision highp int;\n"+
                                                "precision mediump sampler3D;\n"+
                                                "#endif\n"; 
                            mShaderHeaderLines[1] += 6;
                        }
                        else
                        {
                            if( mDerivatives ) { mShaderHeader[1] += "#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n"; mShaderHeaderLines[1]+=3; }
                            if( mShaderTextureLOD  ) { mShaderHeader[1] += "#extension GL_EXT_shader_texture_lod : enable\n"; mShaderHeaderLines[1]++; }
                            mShaderHeader[1] += "#ifdef GL_ES\n"+
                                                "precision highp float;\n"+
                                                "precision highp int;\n"+
                                                "#endif\n"+ 
                                                "vec4 texture(     sampler2D   s, vec2 c)                   { return texture2D(s,c); }\n"+
                                                "vec4 texture(     sampler2D   s, vec2 c, float b)          { return texture2D(s,c,b); }\n"+
                                                "vec4 texture(     samplerCube s, vec3 c )                  { return textureCube(s,c); }\n"+
                                                "vec4 texture(     samplerCube s, vec3 c, float b)          { return textureCube(s,c,b); }\n"+
                                                "float round( float x ) { return floor(x+0.5); }\n"+
                                                "vec2 round(vec2 x) { return floor(x + 0.5); }\n"+
                                                "vec3 round(vec3 x) { return floor(x + 0.5); }\n"+
                                                "vec4 round(vec4 x) { return floor(x + 0.5); }\n"+
                                                "float trunc( float x, float n ) { return floor(x*n)/n; }\n"+
                                                "mat3 transpose(mat3 m) { return mat3(m[0].x, m[1].x, m[2].x, m[0].y, m[1].y, m[2].y, m[0].z, m[1].z, m[2].z); }\n"+
                                                "float determinant( in mat2 m ) { return m[0][0]*m[1][1] - m[0][1]*m[1][0]; }\n"+
                                                "float determinant( mat4 m ) { float b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0], b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0], b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0], b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1], b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1], b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2], b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0], b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0], b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0], b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1], b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1], b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;}\n"+
                                                "mat2 inverse(mat2 m) { float det = determinant(m); return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / det; }\n"+
                                                "mat4 inverse(mat4 m ) { float inv0 = m[1].y*m[2].z*m[3].w - m[1].y*m[2].w*m[3].z - m[2].y*m[1].z*m[3].w + m[2].y*m[1].w*m[3].z + m[3].y*m[1].z*m[2].w - m[3].y*m[1].w*m[2].z; float inv4 = -m[1].x*m[2].z*m[3].w + m[1].x*m[2].w*m[3].z + m[2].x*m[1].z*m[3].w - m[2].x*m[1].w*m[3].z - m[3].x*m[1].z*m[2].w + m[3].x*m[1].w*m[2].z; float inv8 = m[1].x*m[2].y*m[3].w - m[1].x*m[2].w*m[3].y - m[2].x  * m[1].y * m[3].w + m[2].x  * m[1].w * m[3].y + m[3].x * m[1].y * m[2].w - m[3].x * m[1].w * m[2].y; float inv12 = -m[1].x  * m[2].y * m[3].z + m[1].x  * m[2].z * m[3].y +m[2].x  * m[1].y * m[3].z - m[2].x  * m[1].z * m[3].y - m[3].x * m[1].y * m[2].z + m[3].x * m[1].z * m[2].y; float inv1 = -m[0].y*m[2].z * m[3].w + m[0].y*m[2].w * m[3].z + m[2].y  * m[0].z * m[3].w - m[2].y  * m[0].w * m[3].z - m[3].y * m[0].z * m[2].w + m[3].y * m[0].w * m[2].z; float inv5 = m[0].x  * m[2].z * m[3].w - m[0].x  * m[2].w * m[3].z - m[2].x  * m[0].z * m[3].w + m[2].x  * m[0].w * m[3].z + m[3].x * m[0].z * m[2].w - m[3].x * m[0].w * m[2].z; float inv9 = -m[0].x  * m[2].y * m[3].w +  m[0].x  * m[2].w * m[3].y + m[2].x  * m[0].y * m[3].w - m[2].x  * m[0].w * m[3].y - m[3].x * m[0].y * m[2].w + m[3].x * m[0].w * m[2].y; float inv13 = m[0].x  * m[2].y * m[3].z - m[0].x  * m[2].z * m[3].y - m[2].x  * m[0].y * m[3].z + m[2].x  * m[0].z * m[3].y + m[3].x * m[0].y * m[2].z - m[3].x * m[0].z * m[2].y; float inv2 = m[0].y  * m[1].z * m[3].w - m[0].y  * m[1].w * m[3].z - m[1].y  * m[0].z * m[3].w + m[1].y  * m[0].w * m[3].z + m[3].y * m[0].z * m[1].w - m[3].y * m[0].w * m[1].z; float inv6 = -m[0].x  * m[1].z * m[3].w + m[0].x  * m[1].w * m[3].z + m[1].x  * m[0].z * m[3].w - m[1].x  * m[0].w * m[3].z - m[3].x * m[0].z * m[1].w + m[3].x * m[0].w * m[1].z; float inv10 = m[0].x  * m[1].y * m[3].w - m[0].x  * m[1].w * m[3].y - m[1].x  * m[0].y * m[3].w + m[1].x  * m[0].w * m[3].y + m[3].x * m[0].y * m[1].w - m[3].x * m[0].w * m[1].y; float inv14 = -m[0].x  * m[1].y * m[3].z + m[0].x  * m[1].z * m[3].y + m[1].x  * m[0].y * m[3].z - m[1].x  * m[0].z * m[3].y - m[3].x * m[0].y * m[1].z + m[3].x * m[0].z * m[1].y; float inv3 = -m[0].y * m[1].z * m[2].w + m[0].y * m[1].w * m[2].z + m[1].y * m[0].z * m[2].w - m[1].y * m[0].w * m[2].z - m[2].y * m[0].z * m[1].w + m[2].y * m[0].w * m[1].z; float inv7 = m[0].x * m[1].z * m[2].w - m[0].x * m[1].w * m[2].z - m[1].x * m[0].z * m[2].w + m[1].x * m[0].w * m[2].z + m[2].x * m[0].z * m[1].w - m[2].x * m[0].w * m[1].z; float inv11 = -m[0].x * m[1].y * m[2].w + m[0].x * m[1].w * m[2].y + m[1].x * m[0].y * m[2].w - m[1].x * m[0].w * m[2].y - m[2].x * m[0].y * m[1].w + m[2].x * m[0].w * m[1].y; float inv15 = m[0].x * m[1].y * m[2].z - m[0].x * m[1].z * m[2].y - m[1].x * m[0].y * m[2].z + m[1].x * m[0].z * m[2].y + m[2].x * m[0].y * m[1].z - m[2].x * m[0].z * m[1].y; float det = m[0].x * inv0 + m[0].y * inv4 + m[0].z * inv8 + m[0].w * inv12; det = 1.0 / det; return det*mat4( inv0, inv1, inv2, inv3,inv4, inv5, inv6, inv7,inv8, inv9, inv10, inv11,inv12, inv13, inv14, inv15);}\n"+
                                                "float sinh(float x)  { return (exp(x)-exp(-x))/2.; }\n"+
                                                "float cosh(float x)  { return (exp(x)+exp(-x))/2.; }\n"+
                                                "float tanh(float x)  { return sinh(x)/cosh(x); }\n"+
                                                "float coth(float x)  { return cosh(x)/sinh(x); }\n"+
                                                "float sech(float x)  { return 1./cosh(x); }\n"+
                                                "float csch(float x)  { return 1./sinh(x); }\n"+
                                                "float asinh(float x) { return    log(x+sqrt(x*x+1.)); }\n"+
                                                "float acosh(float x) { return    log(x+sqrt(x*x-1.)); }\n"+
                                                "float atanh(float x) { return .5*log((1.+x)/(1.-x)); }\n"+
                                                "float acoth(float x) { return .5*log((x+1.)/(x-1.)); }\n"+
                                                "float asech(float x) { return    log((1.+sqrt(1.-x*x))/x); }\n"+
                                                "float acsch(float x) { return    log((1.+sqrt(1.+x*x))/x); }\n";
                            mShaderHeaderLines[1] += 30;
                            if( mShaderTextureLOD )
                            {
                            mShaderHeader[1] += "vec4 textureLod(  sampler2D   s, vec2 c, float b)          { return texture2DLodEXT(s,c,b); }\n";
                            mShaderHeader[1] += "vec4 textureGrad( sampler2D   s, vec2 c, vec2 dx, vec2 dy) { return texture2DGradEXT(s,c,dx,dy); }\n";
                            mShaderHeaderLines[1] += 2;

                            //mShaderHeader[1] += "vec4 texelFetch( sampler2D s, ivec2 c, int l) { return texture2DLodEXT(s,(vec2(c)+0.5)/vec2(800,450),float(l)); }\n";
                            //mShaderHeaderLines[1] += 1;
                            }
                        }

                        return true;
                    };

        me.GetCaps =    function ()
                        {   
                            return { mIsGL20 : mIs20,
                                     mFloat32Textures: mFloat32Textures != null,
                                     mFloat16Textures: mFloat16Textures != null,
                                     mDrawBuffers: mDrawBuffers != null,
                                     mDepthTextures: mDepthTextures != null,
                                     mDerivatives: mDerivatives != null,
                                     mShaderTextureLOD: mShaderTextureLOD != null };
                        };

        me.GetShaderHeaderLines = function (shaderType)
                        {   
                            return mShaderHeaderLines[shaderType];
                        };

        me.CheckErrors = function()
                         {
                                var error = mGL.getError();
                                if( error != mGL.NO_ERROR ) 
                                { 
                                    for( var prop in mGL ) 
                                    {
                                        if( typeof mGL[prop] == 'number' ) 
                                        {
                                            if( mGL[prop] == error )
                                            {
                                                console.log( "GL Error " + error + ": " + prop );
                                                break;
                                            }
                                        }
                                    }
                                }
                         };

        me.Clear =  function( flags, ccolor, cdepth, cstencil )
                    {
                        var mode = 0;
                        if( flags & 1 ) { mode |= mGL.COLOR_BUFFER_BIT;   mGL.clearColor( ccolor[0], ccolor[1], ccolor[2], ccolor[3] ); }
                        if( flags & 2 ) { mode |= mGL.DEPTH_BUFFER_BIT;   mGL.clearDepth( cdepth ); }
                        if( flags & 4 ) { mode |= mGL.STENCIL_BUFFER_BIT; mGL.clearStencil( cstencil ); }
                        mGL.clear( mode );
                    };


        me.CreateTexture = function ( type, xres, yres, format, filter, wrap, buffer)
                           {
                                if( mGL===null ) return null;

                                var id = mGL.createTexture();

                                var glFoTy = iFormatPI2GL( format );
                                var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                if( type===me.TEXTYPE.T2D )
                                {
                                    mGL.bindTexture( mGL.TEXTURE_2D, id );
//if( buffer==null )
    //mGL.texStorage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, xres, yres);
//else
                                    mGL.texImage2D( mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texParameteri( mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap );
                                    mGL.texParameteri( mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap );

                                    if (filter === me.FILTER.NONE)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }

                                    mGL.bindTexture( mGL.TEXTURE_2D, null );
                                }
                                else if( type===me.TEXTYPE.T3D )
                                {
                                    if( mIs20 )
                                    {
                                        mGL.bindTexture( mGL.TEXTURE_3D, id );
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_BASE_LEVEL, 0);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAX_LEVEL, Math.log2(xres));
                                        if (filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                        }
                                        else if (filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        }
                                        else
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_3D);
                                        }
                                        mGL.texImage3D( mGL.TEXTURE_3D, 0, glFoTy.mGLFormat, xres, yres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );

                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_R, glWrap );
                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_S, glWrap );
                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_T, glWrap );

                                        if (filter === me.FILTER.MIPMAP)
                                            mGL.generateMipmap( mGL.TEXTURE_3D );
                                        mGL.bindTexture( mGL.TEXTURE_3D, null );
                                    }
                                    else 
                                    {
                                        return null;
                                    }
                                }
                                else 
                                {
                                    mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );

                                    // this works great if we know the number of required mipmaps in advance (1, or other)
                                   //mGL.texStorage2D( mGL.TEXTURE_CUBE_MAP, 1, glFoTy.mGLFormat, xres, yres );

                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );

                                    if( filter === me.FILTER.NONE)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR)
                                    {
                                        mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR );
                                        mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR );
                                    }
                                    else if (filter === me.FILTER.MIPMAP)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                    }

                                    if (filter === me.FILTER.MIPMAP)
                                        mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );

                                    mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                }
                        return { mObjectID: id, mXres: xres, mYres: yres, mFormat: format, mType: type, mFilter: filter, mWrap: wrap, mVFlip:false };
                        };

        me.CreateTextureFromImage = function ( type, image, format, filter, wrap, flipY) 
                                {
                                    if( mGL===null ) return null;

                                    var id = mGL.createTexture();

                                    var glFoTy = iFormatPI2GL( format );

                                    var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                    if( type===me.TEXTYPE.T2D )
                                    {
                                        mGL.bindTexture(mGL.TEXTURE_2D, id);

                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, flipY);
                                        mGL.pixelStorei(mGL.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                                        if( mIs20 ) mGL.pixelStorei(mGL.UNPACK_COLORSPACE_CONVERSION_WEBGL, mGL.NONE );

                                        mGL.texImage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image);

                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap);

                                        if (filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                        }
                                        else if( filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_2D);
                                        }
                                        else
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_2D);
                                        }
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                        mGL.bindTexture(mGL.TEXTURE_2D, null);
                                    }
                                    else if( type===me.TEXTYPE.T3D )
                                    {
                                        return null;
                                    }
                                    else 
                                    {
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, flipY);
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[0] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[1] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (flipY ? image[3] : image[2]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (flipY ? image[2] : image[3]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[4] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[5] );

                                        if( filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR );
                                            mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR );
                                        }
                                        else if (filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                            mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );
                                        }
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                    }
                                    return { mObjectID: id, mXres: image.width, mYres: image.height, mFormat: format, mType: type, mFilter: filter, mWrap:wrap, mVFlip:flipY };
                                };

        me.SetSamplerFilter = function (te, filter, doGenerateMipsIfNeeded) 
                            {
                                if (te.mFilter === filter) return;

                                if (te.mType === me.TEXTYPE.T2D) 
                                {
                                    mGL.bindTexture(mGL.TEXTURE_2D, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_2D, null);

                                }
                                else if (te.mType === me.TEXTYPE.T3D) 
                                {
                                    mGL.bindTexture(mGL.TEXTURE_3D, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_3D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_3D);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_3D, null);

                                }
                                else
                                {
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_CUBE_MAP);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_CUBE_MAP);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                                }


                                te.mFilter = filter;
                            };

        me.SetSamplerWrap = function (te, wrap)
                            {
                                if (te.mWrap === wrap) return;

                                var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                var id = te.mObjectID;

                                if (te.mType === me.TEXTYPE.T2D)
                                {
                                    mGL.bindTexture(mGL.TEXTURE_2D, id);
                                    mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap);
                                    mGL.bindTexture(mGL.TEXTURE_2D, null);

                                }
                                else if (te.mType === me.TEXTYPE.T3D)
                                {
                                    mGL.bindTexture(mGL.TEXTURE_3D, id);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_R, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_S, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_T, glWrap);
                                    mGL.bindTexture(mGL.TEXTURE_3D, null);
                                }

                                te.mWrap = wrap;
                            };

        me.SetSamplerVFlip = function (te, vflip, image)
                            {
                                if (te.mVFlip === vflip) return;

                                var id = te.mObjectID;

                                if (te.mType === me.TEXTYPE.T2D)
                                {
                                    if( image != null)
                                    {
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture(mGL.TEXTURE_2D, id);
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, vflip);
                                        var glFoTy = iFormatPI2GL( te.mFormat );
                                        mGL.texImage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image);
                                        mGL.bindTexture(mGL.TEXTURE_2D, null);
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
                                }
                                else if (te.mType === me.TEXTYPE.CUBEMAP)
                                {
                                    if( image != null)
                                    {
                                        var glFoTy = iFormatPI2GL( te.mFormat );
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );
                                        mGL.pixelStorei( mGL.UNPACK_FLIP_Y_WEBGL, vflip);
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[0] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[1] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (vflip ? image[3] : image[2]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (vflip ? image[2] : image[3]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[4] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[5] );
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
        
                                }

                                te.mVFlip = vflip;
                            };

        me.CreateMipmaps =  function (te)
                            {
                                if( te.mType===me.TEXTYPE.T2D )
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                    mGL.bindTexture(mGL.TEXTURE_2D, te.mObjectID);
                                    mGL.generateMipmap(mGL.TEXTURE_2D);
                                    mGL.bindTexture(mGL.TEXTURE_2D, null);
                                }
                                else if( te.mType===me.TEXTYPE.CUBEMAP )
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, te.mObjectID);
                                    mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                                }
                            };

        me.UpdateTexture =  function( tex, x0, y0, xres, yres, buffer )
                            {
                                var glFoTy = iFormatPI2GL( tex.mFormat );
                                if( tex.mType===me.TEXTYPE.T2D )
                                {
                                    mGL.activeTexture( mGL.TEXTURE0);
                                    mGL.bindTexture( mGL.TEXTURE_2D, tex.mObjectID );
                                    mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, tex.mVFlip );
                                    mGL.texSubImage2D( mGL.TEXTURE_2D, 0, x0, y0, xres, yres, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.bindTexture( mGL.TEXTURE_2D, null );
                                    mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                }
                            };

        me.UpdateTextureFromImage = function( tex, image )
                                {
                                    var glFoTy = iFormatPI2GL( tex.mFormat );
                                    if( tex.mType===me.TEXTYPE.T2D )
                                    {
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture( mGL.TEXTURE_2D, tex.mObjectID );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, tex.mVFlip );
                                        mGL.texImage2D(  mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image );
                                        mGL.bindTexture( mGL.TEXTURE_2D, null );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
                                };

        me.DestroyTexture = function( te )
                            {
                                 mGL.deleteTexture( te.mObjectID );
                            };

        me.AttachTextures = function (num, t0, t1, t2, t3) 
                            {
                                if (num > 0 && t0 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                         if (t0.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t0.mObjectID);
                                    else if (t0.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t0.mObjectID);
                                    else if (t0.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t0.mObjectID);
                                }

                                if (num > 1 && t1 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE1);
                                         if (t1.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t1.mObjectID);
                                    else if (t1.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t1.mObjectID);
                                    else if (t1.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t1.mObjectID);
                                }

                                if (num > 2 && t2 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE2);
                                         if (t2.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t2.mObjectID);
                                    else if (t2.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t2.mObjectID);
                                    else if (t2.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t2.mObjectID);
                                }

                                if (num > 3 && t3 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE3);
                                         if (t3.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t3.mObjectID);
                                    else if (t3.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t3.mObjectID);
                                    else if (t3.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t3.mObjectID);
                                }
                            };

        me.DettachTextures = function()
                             {
                                mGL.activeTexture(mGL.TEXTURE0);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE1);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE2);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE3);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                             };

        me.CreateRenderTarget = function ( color0, color1, color2, color3, depth, wantZbuffer )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if (depth === null)
                                    {
                                        if( wantZbuffer===true )
                                        {
                                            var zb = mGL.createRenderbuffer();
                                            mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);
                                            mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, color0.mXres, color0.mYres);

                                            mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                        }
                                    }
                                    else
                                    {
                                        mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.TEXTURE_2D, depth.mObjectID, 0);
                                    }

                                    if( color0 !=null ) mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_2D, color0.mObjectID, 0);

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                        return null;

                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mTex0: color0 };
                                };

        me.DestroyRenderTarget = function ( tex )
                                 {
                                     mGL.deleteFramebuffer(tex.mObjectID);
                                 };

        me.SetRenderTarget = function (tex)
                             {
                                if( tex===null )
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                else
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, tex.mObjectID);

                                //mGL.drawBuffers([mGL.COLOR_ATTACHMENT0, mGL.COLOR_ATTACHMENT1]);
                             };

        me.CreateRenderTargetNew = function ( wantColor0, wantZbuffer, xres, yres, samples )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if( wantZbuffer===true )
                                    {
                                        var zb = mGL.createRenderbuffer();
                                        mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);

                                        if( samples==1 )
                                        mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, xres, yres);
                                        else
                                        mGL.renderbufferStorageMultisample(mGL.RENDERBUFFER, samples, mGL.DEPTH_COMPONENT16, xres, yres);
                                        mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                    }

                                    if( wantColor0 )
                                    {
                                        var cb = mGL.createRenderbuffer();
                                        mGL.bindRenderbuffer(mGL.RENDERBUFFER, cb);
                                        if( samples==1 )
                                        mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.RGBA8, xres, yres);
                                        else
                                        mGL.renderbufferStorageMultisample(mGL.RENDERBUFFER, samples, mGL.RGBA8, xres, yres);
                                        mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.RENDERBUFFER, cb);
                                    }

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                    {
                                        return null;
                                    }
                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mXres: xres, mYres:yres, mTex0: color0 };
                                };

        me.CreateRenderTargetCubeMap = function ( color0, depth, wantZbuffer )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if (depth === null)
                                    {
                                        if( wantZbuffer===true )
                                        {
                                            var zb = mGL.createRenderbuffer();
                                            mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);
                                            mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, color0.mXres, color0.mYres);
                                            mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                        }
                                    }
                                    else
                                    {
                                        mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.TEXTURE_2D, depth.mObjectID, 0);
                                    }

                                    if( color0 !=null ) mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_CUBE_MAP_POSITIVE_X, color0.mObjectID, 0);

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                        return null;

                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mTex0: color0 };
                                };

        me.SetRenderTargetCubeMap = function (fbo, face)
                             {
                                if( fbo===null )
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                else
                                {
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, fbo.mObjectID);
                                    mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_CUBE_MAP_POSITIVE_X+face, fbo.mTex0.mObjectID, 0);
                                }
                             };


        me.BlitRenderTarget = function( dst, src )
                                {
                                    mGL.bindFramebuffer(mGL.READ_FRAMEBUFFER, src.mObjectID);
                                    mGL.bindFramebuffer(mGL.DRAW_FRAMEBUFFER, dst.mObjectID);
                                    mGL.clearBufferfv(mGL.COLOR, 0, [0.0, 0.0, 0.0, 1.0]);
                                    mGL.blitFramebuffer( 0, 0, src.mXres, src.mYres,
                                                         0, 0, src.mXres, src.mYres,
                                                         mGL.COLOR_BUFFER_BIT, mGL.LINEAR
                                    );
                                };

        me.SetViewport = function( vp )
                         {
                              mGL.viewport( vp[0], vp[1], vp[2], vp[3] );
                         };

        me.SetWriteMask = function( c0, c1, c2, c3, z )
                          {
                              mGL.depthMask(z);
                              mGL.colorMask(c0,c0,c0,c0);
                          };

        me.SetState = function( stateName, stateValue )
                      {
                            if (stateName === me.RENDSTGATE.WIREFRAME)
                            {
                                if( stateValue ) mGL.polygonMode( mGL.FRONT_AND_BACK, mGL.LINE );
                                else             mGL.polygonMode( mGL.FRONT_AND_BACK, mGL.FILL );
                            }
                            else if (stateName === me.RENDSTGATE.FRONT_FACE)
                            {
                                if( stateValue ) mGL.cullFace( mGL.BACK );
                                else             mGL.cullFace( mGL.FRONT );
                            }
                            else if (stateName === me.RENDSTGATE.CULL_FACE)
                            {
                                if( stateValue ) mGL.enable( mGL.CULL_FACE );
                                else             mGL.disable( mGL.CULL_FACE );
                            }
                            else if (stateName === me.RENDSTGATE.DEPTH_TEST)
                            {
                                if( stateValue ) mGL.enable( mGL.DEPTH_TEST );
                                else             mGL.disable( mGL.DEPTH_TEST );
                            }
                            else if (stateName === me.RENDSTGATE.ALPHA_TO_COVERAGE)
                            {
                                if( stateValue ) { mGL.enable(  mGL.SAMPLE_ALPHA_TO_COVERAGE ); }
                                else             { mGL.disable( mGL.SAMPLE_ALPHA_TO_COVERAGE ); }
                            }
                      };

        me.SetMultisample = function( v)
                    {
                        if( v===true )
                        {
                            mGL.enable(mGL.SAMPLE_COVERAGE);
                            mGL.sampleCoverage(1.0, false);
                        }
                        else
                        {
                            mGL.disable(mGL.SAMPLE_COVERAGE);
                        }
                    };

        me.GetTranslatedShaderSource = function (shader) 
                          {
                            if( mGL===null ) return null;
                            if( mDebugShader===null ) return null;
                            let vfs = mGL.getAttachedShaders(shader.mProgram);
                            let str = mDebugShader.getTranslatedShaderSource(vfs[1]);
                            let parts = str.split("GLSL END"); str = (parts.length<2) ? str : parts[1];
                            return str;
                          };

        me.CreateShader = function (vsSource, fsSource, preventCache, forceSynch, onResolve) 
                          {
                            if( mGL===null ) return;

                            var vs = mGL.createShader( mGL.VERTEX_SHADER   );
                            var fs = mGL.createShader( mGL.FRAGMENT_SHADER );

                            vsSource = mShaderHeader[0] + vsSource;
                            fsSource = mShaderHeader[1] + fsSource;

                            if( preventCache )
                            {
                                let vran = Math.random().toString(36).substring(7);
                                let fran = Math.random().toString(36).substring(7);
                                vsSource += "\n#define K" + vran + "\n";
                                fsSource += "\n#define K" + fran + "\n";
                            }

                            var timeStart = getRealTime();

                            mGL.shaderSource(vs, vsSource);
                            mGL.shaderSource(fs, fsSource);
                            mGL.compileShader(vs);
                            mGL.compileShader(fs);

                            var pr = mGL.createProgram();
                            mGL.attachShader(pr, vs);
                            mGL.attachShader(pr, fs);
                            mGL.linkProgram(pr);

                            //-------------
                            let checkErrors = function()
                            {
                                if (!mGL.getProgramParameter(pr, mGL.LINK_STATUS))
                                {
                                    // vs error
                                    if (!mGL.getShaderParameter(vs, mGL.COMPILE_STATUS))
                                    {
                                        let vsLog = mGL.getShaderInfoLog(vs);
                                        onResolve(false, { mErrorType: 0, mErrorStr: vsLog });
                                        mGL.deleteProgram(pr);
                                    }
                                    // fs error
                                    else if (!mGL.getShaderParameter(fs, mGL.COMPILE_STATUS))
                                    {
                                        let fsLog = mGL.getShaderInfoLog(fs);
                                        onResolve(false, { mErrorType: 1, mErrorStr: fsLog });
                                        mGL.deleteProgram(pr);
                                    }
                                    // link error
                                    else
                                    {
                                        let infoLog = mGL.getProgramInfoLog(pr);
                                        onResolve(false, { mErrorType: 2, mErrorStr: infoLog });
                                        mGL.deleteProgram(pr);
                                    }
                                }
                                // no errors
                                else
                                {
                                    let compilationTime = getRealTime() - timeStart;
                                    onResolve(true, { mProgram: pr, mTime: compilationTime });
                                }
                            };

                            // check compilation
                            if (mAsynchCompile === null || forceSynch===true )
                            {
                                checkErrors();
                            }
                            else
                            {
                                let loopCheckCompletion = function ()
                                {
                                    if( mGL.getProgramParameter(pr, mAsynchCompile.COMPLETION_STATUS_KHR) === true )
                                        checkErrors();
                                    else
                                        setTimeout(loopCheckCompletion, 10);
                                };
                                setTimeout(loopCheckCompletion, 10);
                            }
                        };

        me.AttachShader = function( shader )
                          {
                                if( shader===null )
                                {
                                    mBindedShader = null;
                                    mGL.useProgram( null );
                                }
                                else
                                {
                                    mBindedShader = shader;
                                    mGL.useProgram(shader.mProgram);
                                }
                          };

        me.DetachShader = function ()
                        {
                            mGL.useProgram(null);
                        };

        me.DestroyShader = function( tex )
                        {
                            mGL.deleteProgram(tex.mProgram);
                        };

        me.GetAttribLocation = function (shader, name)
                        {
                            return mGL.getAttribLocation(shader.mProgram, name);
                        };

        me.SetShaderConstantLocation = function (shader, name)
                        {
                            return mGL.getUniformLocation(shader.mProgram, name);
                        };

        me.SetShaderConstantMat4F = function( uname, params, istranspose )
                        {
                            var program = mBindedShader;

                            let pos = mGL.getUniformLocation( program.mProgram, uname );
                            if( pos===null )
                                return false;

                            if( istranspose===false )
                            {
                                var tmp = new Float32Array( [ params[0], params[4], params[ 8], params[12],
                                                              params[1], params[5], params[ 9], params[13],
                                                              params[2], params[6], params[10], params[14],
                                                              params[3], params[7], params[11], params[15] ] );
	                            mGL.uniformMatrix4fv(pos,false,tmp);
                            }
                            else
                                mGL.uniformMatrix4fv(pos,false,new Float32Array(params) );
                            return true;
                        };

        me.SetShaderConstant1F_Pos = function(pos, x)
                        {
                            mGL.uniform1f(pos, x);
                            return true;
                        };

        me.SetShaderConstant1FV_Pos = function(pos, x)
                        {
                            mGL.uniform1fv(pos, x);
                            return true;
                        };

        me.SetShaderConstant1F = function( uname, x )
                        {
                            var pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1f(pos, x);
                            return true;
                        };

        me.SetShaderConstant1I = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1i(pos, x);
                            return true;
                        };
        me.SetShaderConstant1I_Pos = function(pos, x)
                        {
                            mGL.uniform1i(pos, x);
                            return true;
                        };


        me.SetShaderConstant2F = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform2fv(pos, x);
                            return true;
                        };

        me.SetShaderConstant3F = function(uname, x, y, z)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform3f(pos, x, y, z);
                            return true;
                        };

        me.SetShaderConstant1FV = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1fv(pos, new Float32Array(x));
                            return true;
                        };

        me.SetShaderConstant3FV = function(uname, x) 
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform3fv(pos, new Float32Array(x) );
                            return true;
                        };

        me.SetShaderConstant4FV = function(uname, x) 
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform4fv(pos, new Float32Array(x) );
                            return true;
                        };

        me.SetShaderTextureUnit = function( uname, unit )
                        {
                            var program = mBindedShader;
                            let pos = mGL.getUniformLocation(program.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform1i(pos, unit);
                            return true;
                        };

        me.CreateVertexArray = function( data, mode )
                        {
                            let id = mGL.createBuffer();
                            mGL.bindBuffer(mGL.ARRAY_BUFFER, id);
                            if (mode === me.BUFTYPE.STATIC)
                                mGL.bufferData(mGL.ARRAY_BUFFER, data, mGL.STATIC_DRAW);
                            else
                                mGL.bufferData(mGL.ARRAY_BUFFER, data, mGL.DYNAMIC_DRAW);
                            return { mObject: id };
                        };

        me.CreateIndexArray = function( data, mode )
                        {
                            let id = mGL.createBuffer();
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, id );
                            if (mode === me.BUFTYPE.STATIC)
                                mGL.bufferData(mGL.ELEMENT_ARRAY_BUFFER, data, mGL.STATIC_DRAW);
                            else
                                mGL.bufferData(mGL.ELEMENT_ARRAY_BUFFER, data, mGL.DYNAMIC_DRAW);
                            return { mObject: id };
                        };

        me.DestroyArray = function( tex )
                        {
                            mGL.destroyBuffer(tex.mObject);
                        };

        me.AttachVertexArray = function( tex, attribs, pos )
                        {
                            let shader = mBindedShader;

                            mGL.bindBuffer( mGL.ARRAY_BUFFER, tex.mObject);

                            var num = attribs.mChannels.length;
                            var stride = attribs.mStride;

                            var offset = 0;
                            for (var i = 0; i < num; i++)
                            {
                                var id = pos[i];
                                mGL.enableVertexAttribArray(id);
                                var dtype = mGL.FLOAT;
                                var dsize = 4;
                                     if( attribs.mChannels[i].mType === me.TYPE.UINT8   ) { dtype = mGL.UNSIGNED_BYTE;  dsize = 1; }
                                else if( attribs.mChannels[i].mType === me.TYPE.UINT16  ) { dtype = mGL.UNSIGNED_SHORT; dsize = 2; }
                                else if( attribs.mChannels[i].mType === me.TYPE.FLOAT32 ) { dtype = mGL.FLOAT;          dsize = 4; }
                                mGL.vertexAttribPointer(id, attribs.mChannels[i].mNumComponents, dtype, attribs.mChannels[i].mNormalize, stride, offset);
                                offset += attribs.mChannels[i].mNumComponents * dsize;
                            }
                        };

        me.AttachIndexArray = function( tex )
                        {
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, tex.mObject);
                        };

        me.DetachVertexArray = function (tex, attribs)
                        {
                            let num = attribs.mChannels.length;
                            for (let i = 0; i < num; i++)
                                mGL.disableVertexAttribArray(i);
                            mGL.bindBuffer(mGL.ARRAY_BUFFER, null);
                        };

        me.DetachIndexArray = function( tex )
                        {
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, null);
                        };

        me.DrawPrimitive = function( typeOfPrimitive, num, useIndexArray, numInstances )
                        {
                            let glType = mGL.POINTS;
                            if( typeOfPrimitive===me.PRIMTYPE.POINTS ) glType = mGL.POINTS;
                            if( typeOfPrimitive===me.PRIMTYPE.LINES ) glType = mGL.LINES;
                            if( typeOfPrimitive===me.PRIMTYPE.LINE_LOOP ) glType = mGL.LINE_LOOP;
                            if( typeOfPrimitive===me.PRIMTYPE.LINE_STRIP ) glType = mGL.LINE_STRIP;
                            if( typeOfPrimitive===me.PRIMTYPE.TRIANGLES ) glType = mGL.TRIANGLES;
                            if( typeOfPrimitive===me.PRIMTYPE.TRIANGLE_STRIP ) glType = mGL.TRIANGLE_STRIP;

                            if( numInstances<=1 )
                            {
  	                            if( useIndexArray ) mGL.drawElements( glType, num, mGL.UNSIGNED_SHORT, 0 );
	                            else                mGL.drawArrays( glType, 0, num );
                            }
                            else
                            {
                                mGL.drawArraysInstanced(glType, 0, num, numInstances);
                                mGL.drawElementsInstanced( glType, num, mGL.UNSIGNED_SHORT, 0, numInstances);
                            }
                        };


        me.DrawFullScreenTriangle_XY = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Tri );
                            mGL.vertexAttribPointer( vpos, 2, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays( mGL.TRIANGLES, 0, 3 );
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        };


        me.DrawUnitQuad_XY = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Quad );
                            mGL.vertexAttribPointer( vpos, 2, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays( mGL.TRIANGLES, 0, 6 );
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        };

        me.DrawUnitCube_XYZ_NOR = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePosNor );
                            mGL.vertexAttribPointer( vpos[0], 3, mGL.FLOAT, false, 0, 0 );
                            mGL.vertexAttribPointer( vpos[1], 3, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos[0] );
                            mGL.enableVertexAttribArray( vpos[1] );
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 0, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 4, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 8, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 12, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 16, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 20, 4);
                            mGL.disableVertexAttribArray( vpos[0] );
                            mGL.disableVertexAttribArray( vpos[1] );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        }

        me.DrawUnitCube_XYZ = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePos );
                            mGL.vertexAttribPointer( vpos, 3, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 0, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 4, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 8, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 12, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 16, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 20, 4);
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        }

        me.SetBlend = function( enabled )
                    {
                        if( enabled )
                        {
                            mGL.enable( mGL.BLEND );
                            mGL.blendEquationSeparate( mGL.FUNC_ADD, mGL.FUNC_ADD );
                            mGL.blendFuncSeparate( mGL.SRC_ALPHA, mGL.ONE_MINUS_SRC_ALPHA, mGL.ONE, mGL.ONE_MINUS_SRC_ALPHA );
                        }
                        else
                        {
                            mGL.disable( mGL.BLEND );
                        }
                    };

        me.GetPixelData = function( data, offset, xres, yres )
                        {
                            mGL.readPixels(0, 0, xres, yres, mGL.RGBA, mGL.UNSIGNED_BYTE, data, offset);
                        };

        me.GetPixelDataRenderTarget = function( obj, data, xres, yres )
                        {
                            mGL.bindFramebuffer(mGL.FRAMEBUFFER, obj.mObjectID);
                            mGL.readBuffer(mGL.COLOR_ATTACHMENT0);
                            mGL.readPixels(0, 0, xres, yres, mGL.RGBA, mGL.FLOAT, data, 0);
                            mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                        };
    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piShading
//
//==============================================================================

function smoothstep(a, b, x)
{
    x = (x - a) / (b - a);
    if (x < 0) x = 0; else if (x > 1) x = 1;
    return x * x * (3.0 - 2.0 * x);
}

function clamp01(x)
{
    if( x < 0.0 ) x = 0.0;
    if( x > 1.0 ) x = 1.0;
    return x;
}

function clamp(x, a, b)
{
    if( x < a ) x = a;
    if( x > b ) x = b;
    return x;
}

function screen(a, b)
{
    return 1.0 - (1.0 - a) * (1.0 - b);
}

function parabola(x)
{
    return 4.0 * x * (1.0 - x);
}

function min(a, b)
{
    return (a < b) ? a : b;
}

function max(a, b)
{
    return (a > b) ? a : b;
}

function noise( x )
{
    function grad(i, j, x, y)
    {
        var h = 7 * i + 131 * j;
        h = (h << 13) ^ h;
        h = (h * (h * h * 15731 + 789221) + 1376312589);

        var rx = (h & 0x20000000) ? x : -x;
        var ry = (h & 0x10000000) ? y : -y;

        return rx + ry;
    }

    var i = [ Math.floor(x[0]), Math.floor(x[1]) ];
    var f = [ x[0] - i[0], x[1] - i[1] ];
    var w = [ f[0]*f[0]*(3.0-2.0*f[0]), f[1]*f[1]*(3.0-2.0*f[1]) ];

    var a = grad( i[0]+0, i[1]+0, f[0]+0.0, f[1]+0.0 );
    var b = grad( i[0]+1, i[1]+0, f[0]-1.0, f[1]+0.0 );
    var c = grad( i[0]+0, i[1]+1, f[0]+0.0, f[1]-1.0 );
    var d = grad( i[0]+1, i[1]+1, f[0]-1.0, f[1]-1.0 );

    return a + (b-a)*w[0] + (c-a)*w[1] + (a-b-c+d)*w[0]*w[1];
}//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piVecTypes
//
//==============================================================================


function vec3( a, b, c )
{
    return [ a, b, c ];
}

function add( a, b )
{
    return [ a[0]+b[0], a[1]+b[1], a[2]+b[2] ];
}

function sub( a, b )
{
    return [ a[0]-b[0], a[1]-b[1], a[2]-b[2] ];
}

function mul( a, s ) 
{
    return [ a[0]*s, a[1]*s, a[2]*s ];
}

function cross( a, b )
{
    return [ a[1]*b[2] - a[2]*b[1],
             a[2]*b[0] - a[0]*b[2],
             a[0]*b[1] - a[1]*b[0] ];
}

function dot( a, b ) 
{
    return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
}

function normalize( v ) 
{
    var is = 1.0 / Math.sqrt( v[0]*v[0] + v[1]*v[1] + v[2]*v[2] );
    return [ v[0]*is, v[1]*is, v[2]*is ];
}

function createCirclePoint( cen, uuu, vvv, rad, s, t )
{
    return [ cen[0] + rad*(uuu[0]*s + vvv[0]*t),
             cen[1] + rad*(uuu[1]*s + vvv[1]*t),
             cen[2] + rad*(uuu[2]*s + vvv[2]*t) ];
}

function createTangent( a, b, c )
{
    var cb = normalize( [ c[0]-b[0], c[1]-b[1], c[2]-b[2] ] );
    var ba = normalize( [ b[0]-a[0], b[1]-a[1], b[2]-a[2] ] );
    return normalize( [ ba[0]+cb[0], ba[1]+cb[1], ba[2]+cb[2] ] );

}

//===================================

function vec4( a, b, c, d )
{
    return [ a, b, c, d ];
}

function getXYZ( v )
{
    return [ v[0], v[1], v[2] ];
}

//===================================

function setIdentity()
{
    return [ 1.0, 0.0, 0.0, 0.0,
             0.0, 1.0, 0.0, 0.0,
             0.0, 0.0, 1.0, 0.0,
             0.0, 0.0, 0.0, 1.0 ];
}

function setRotationX( t )
{
    var sint = Math.sin(t);
    var cost = Math.cos(t);

    return [ 1.0,   0.0,   0.0, 0.0,
             0.0,  cost, -sint, 0.0, 
             0.0,  sint,  cost, 0.0,
             0.0,   0.0,   0.0, 1.0 ];
}

function setRotationY( t )
{
    var sint = Math.sin(t);
    var cost = Math.cos(t);

    return [ cost, 0.0, -sint, 0.0,
              0.0, 1.0,   0.0, 0.0, 
             sint, 0.0,  cost, 0.0,
              0.0, 0.0,   0.0, 1.0 ];
}

function extractRotationEuler( m)
{
    var res = [];
    if (m[0] == 1.0)
    {
        res[0] = Math.atan2(m[2], m[11]);
        res[1] = 0.0;
        res[2] = 0.0;

    }
    else if (m[0] == -1.0)
    {
        res[0] = Math.atan2( m[2], m[11]);
        res[1] = 0.0;
        res[2] = 0.0;
    }
    else
    {
        res[0] = Math.atan2( -m[9], m[10]);
        res[1] = Math.atan2( m[8], Math.sqrt(m[9]*m[9] + m[10]*m[10]));
        res[2] = Math.atan2( m[4], m[0]);
    }
    return res;
}

function setFromQuaternion( q )
{
    var ww = q[3]*q[3];
    var xx = q[0]*q[0];
    var yy = q[1]*q[1];
    var zz = q[2]*q[2];

    return [ ww+xx-yy-zz,                   2.0*(q[0]*q[1] - q[3]*q[2]), 2.0*(q[0]*q[2] + q[3]*q[1]), 0.0,
               2.0*(q[0]*q[1] + q[3]*q[2]),   ww-xx+yy-zz,                 2.0*(q[1]*q[2] - q[3]*q[0]), 0.0,
               2.0*(q[0]*q[2] - q[3]*q[1]),   2.0*(q[1]*q[2] + q[3]*q[0]), ww-xx-yy+zz,                 0.0,
               0.0,                           0.0,                         0.0,                         1.0 ];
}

function setPerspective( fovy, aspect, znear, zfar )
{
    var tan = Math.tan(fovy * Math.PI/180.0);
    var x = 1.0 / (tan*aspect);
    var y = 1.0 / (tan);
    var c = -(zfar + znear) / ( zfar - znear);
    var d = -(2.0 * zfar * znear) / (zfar - znear);

    return [ x,    0.0,  0.0,  0.0,
             0.0,  y,    0.0,  0.0,
             0.0,  0.0,  c,     d,
             0.0,  0.0, -1.0,  0.0 ];
}

function setLookAt( eye, tar, up )
{
    var dir = [ -tar[0]+eye[0], -tar[1]+eye[1], -tar[2]+eye[2] ];

	var m00 = dir[2]*up[1] - dir[1]*up[2]; 
    var m01 = dir[0]*up[2] - dir[2]*up[0];
    var m02 = dir[1]*up[0] - dir[0]*up[1];
    var im = 1.0/Math.sqrt( m00*m00 + m01*m01 + m02*m02 );
    m00 *= im;
    m01 *= im;
    m02 *= im;

	var m04 = m02*dir[1] - m01*dir[2]; 
    var m05 = m00*dir[2] - m02*dir[0];
    var m06 = m01*dir[0] - m00*dir[1];
    im = 1.0/Math.sqrt( m04*m04 + m05*m05 + m06*m06 );
    m04 *= im;
    m05 *= im;
    m06 *= im;

	var m08 = dir[0];
	var m09 = dir[1];
	var m10 = dir[2];
    im = 1.0/Math.sqrt( m08*m08 + m09*m09 + m10*m10 );
    m08 *= im;
    m09 *= im;
    m10 *= im;

	var m03 = -(m00*eye[0] + m01*eye[1] + m02*eye[2] );
	var m07 = -(m04*eye[0] + m05*eye[1] + m06*eye[2] );
	var m11 = -(m08*eye[0] + m09*eye[1] + m10*eye[2] );

    return [ m00, m01, m02, m03,
             m04, m05, m06, m07,
             m08, m09, m10, m11,
             0.0, 0.0, 0.0, 1.0 ];
}


function setOrtho( left, right, bottom, top, znear, zfar )
{
   var x = 2.0 / (right - left);
   var y = 2.0 / (top - bottom);
   var a = (right + left) / (right - left);
   var b = (top + bottom) / (top - bottom);
   var c = -2.0 / (zfar - znear);
   var d = -(zfar + znear) / ( zfar - znear);

   return [  x, 0.0, 0.0,   a,
           0.0,   y, 0.0,   b,
           0.0, 0.0,   c,   d,
           0.0, 0.0, 0.0, 1.0 ];
}

function setTranslation( p )
{
    return [ 1.0, 0.0, 0.0, p[0],
             0.0, 1.0, 0.0, p[1],
             0.0, 0.0, 1.0, p[2],
             0.0, 0.0, 0.0, 1.0 ];
}

function setScale( s )
{
    return [ s[0], 0.0,  0.0,  0.0,
             0.0,  s[1], 0.0,  0.0,
             0.0,  0.0,  s[2], 0.0,
             0.0,  0.0,  0.0,  1.0];
}

function setProjection( fov, znear, zfar )
{
    var x = 2.0 / (fov[3]+fov[2]);
    var y = 2.0 / (fov[0]+fov[1]);
    var a = (fov[3]-fov[2]) / (fov[3]+fov[2]);
    var b = (fov[0]-fov[1]) / (fov[0]+fov[1]);
    var c = -(zfar + znear) / ( zfar - znear);
    var d = -(2.0*zfar*znear) / (zfar - znear);
    return [   x, 0.0,    a, 0.0,
             0.0,   y,    b, 0.0,
             0.0, 0.0,    c,   d,
             0.0, 0.0, -1.0, 0.0 ];
   // inverse is:
   //return mat4x4( 1.0/x, 0.0f,  0.0f,   a/x,
   //               0.0f,  1.0/y, 0.0f,   b/x,
   //               0.0f,  0.0f,  0.0f,   -1.0,
   //               0.0f,  0.0f,  1.0f/d, c/d );
}


function invertFast( m )
{
    var inv = [
   
             m[5]  * m[10] * m[15] - 
             m[5]  * m[11] * m[14] - 
             m[9]  * m[6]  * m[15] + 
             m[9]  * m[7]  * m[14] +
             m[13] * m[6]  * m[11] - 
             m[13] * m[7]  * m[10],

             -m[1]  * m[10] * m[15] + 
              m[1]  * m[11] * m[14] + 
              m[9]  * m[2] * m[15] - 
              m[9]  * m[3] * m[14] - 
              m[13] * m[2] * m[11] + 
              m[13] * m[3] * m[10],

             m[1]  * m[6] * m[15] - 
             m[1]  * m[7] * m[14] - 
             m[5]  * m[2] * m[15] + 
             m[5]  * m[3] * m[14] + 
             m[13] * m[2] * m[7] - 
             m[13] * m[3] * m[6],

             -m[1] * m[6] * m[11] + 
              m[1] * m[7] * m[10] + 
              m[5] * m[2] * m[11] - 
              m[5] * m[3] * m[10] - 
              m[9] * m[2] * m[7] + 
              m[9] * m[3] * m[6],

             -m[4]  * m[10] * m[15] + 
              m[4]  * m[11] * m[14] + 
              m[8]  * m[6]  * m[15] - 
              m[8]  * m[7]  * m[14] - 
              m[12] * m[6]  * m[11] + 
              m[12] * m[7]  * m[10],

             m[0]  * m[10] * m[15] - 
             m[0]  * m[11] * m[14] - 
             m[8]  * m[2] * m[15] + 
             m[8]  * m[3] * m[14] + 
             m[12] * m[2] * m[11] - 
             m[12] * m[3] * m[10],

             -m[0]  * m[6] * m[15] + 
              m[0]  * m[7] * m[14] + 
              m[4]  * m[2] * m[15] - 
              m[4]  * m[3] * m[14] - 
              m[12] * m[2] * m[7] + 
              m[12] * m[3] * m[6],


             m[0] * m[6] * m[11] - 
             m[0] * m[7] * m[10] - 
             m[4] * m[2] * m[11] + 
             m[4] * m[3] * m[10] + 
             m[8] * m[2] * m[7] - 
             m[8] * m[3] * m[6],


             m[4]  * m[9] * m[15] - 
             m[4]  * m[11] * m[13] - 
             m[8]  * m[5] * m[15] + 
             m[8]  * m[7] * m[13] + 
             m[12] * m[5] * m[11] - 
             m[12] * m[7] * m[9],



             -m[0]  * m[9] * m[15] + 
              m[0]  * m[11] * m[13] + 
              m[8]  * m[1] * m[15] - 
              m[8]  * m[3] * m[13] - 
              m[12] * m[1] * m[11] + 
              m[12] * m[3] * m[9],

              m[0]  * m[5] * m[15] - 
              m[0]  * m[7] * m[13] - 
              m[4]  * m[1] * m[15] + 
              m[4]  * m[3] * m[13] + 
              m[12] * m[1] * m[7] - 
              m[12] * m[3] * m[5],

              -m[0] * m[5] * m[11] + 
               m[0] * m[7] * m[9] + 
               m[4] * m[1] * m[11] - 
               m[4] * m[3] * m[9] - 
               m[8] * m[1] * m[7] + 
               m[8] * m[3] * m[5],

              -m[4]  * m[9] * m[14] + 
               m[4]  * m[10] * m[13] +
               m[8]  * m[5] * m[14] - 
               m[8]  * m[6] * m[13] - 
               m[12] * m[5] * m[10] + 
               m[12] * m[6] * m[9],

              m[0]  * m[9] * m[14] - 
              m[0]  * m[10] * m[13] - 
              m[8]  * m[1] * m[14] + 
              m[8]  * m[2] * m[13] + 
              m[12] * m[1] * m[10] - 
              m[12] * m[2] * m[9],

              -m[0]  * m[5] * m[14] + 
               m[0]  * m[6] * m[13] + 
               m[4]  * m[1] * m[14] - 
               m[4]  * m[2] * m[13] - 
               m[12] * m[1] * m[6] + 
               m[12] * m[2] * m[5],

              m[0] * m[5] * m[10] - 
              m[0] * m[6] * m[9] - 
              m[4] * m[1] * m[10] + 
              m[4] * m[2] * m[9] + 
              m[8] * m[1] * m[6] - 
              m[8] * m[2] * m[5] ];

    var det = m[0] * inv[0] + m[1] * inv[4] + m[2] * inv[8] + m[3] * inv[12];

    det = 1.0/det;

    for( var i = 0; i<16; i++ ) inv[i] = inv[i] * det;

    return inv;
}

function matMul( a, b )
{
    var res = [];
    for( var i=0; i<4; i++ )
    {
        var x = a[4*i+0];
        var y = a[4*i+1];
        var z = a[4*i+2];
        var w = a[4*i+3];

        res[4*i+0] = x * b[ 0] + y * b[ 4] + z * b[ 8] + w * b[12];
        res[4*i+1] = x * b[ 1] + y * b[ 5] + z * b[ 9] + w * b[13];
        res[4*i+2] = x * b[ 2] + y * b[ 6] + z * b[10] + w * b[14];
        res[4*i+3] = x * b[ 3] + y * b[ 7] + z * b[11] + w * b[15];
    }

    return res;
}

function matMulpoint( m, v )
{
    return [ m[0]*v[0] + m[1]*v[1] + m[ 2]*v[2] + m[ 3],
             m[4]*v[0] + m[5]*v[1] + m[ 6]*v[2] + m[ 7],
             m[8]*v[0] + m[9]*v[1] + m[10]*v[2] + m[11] ];
}

function matMulvec( m, v )
{
    return [ m[0]*v[0] + m[1]*v[1] + m[ 2]*v[2],
             m[4]*v[0] + m[5]*v[1] + m[ 6]*v[2],
             m[8]*v[0] + m[9]*v[1] + m[10]*v[2] ];
}


function bound3( infi )
{
    return [ infi, -infi, infi, -infi, infi, -infi ];
}

function bound3_include( a, p )
{
    return [
        (p[0]<a[0]) ? p[0] : a[0],
        (p[0]>a[1]) ? p[0] : a[1],
        (p[1]<a[2]) ? p[1] : a[2],
        (p[1]>a[3]) ? p[1] : a[3],
        (p[2]<a[4]) ? p[2] : a[4],
        (p[2]>a[5]) ? p[2] : a[5] ];
}

function bound3_center( b )
{
    return [ 0.5*(b[0]+b[1]),
             0.5*(b[2]+b[3]),
             0.5*(b[4]+b[5]) ];
}

function bound3_radius( b )
{
    return [ 0.5*(b[1]-b[0]),
             0.5*(b[3]-b[2]),
             0.5*(b[5]-b[4]) ];
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piWebVR
//
//==============================================================================

function WebVR( isVREnabledCallback, canvasElement )
{
    isVREnabledCallback(false);
    /*


    this.mSupportVR = false;
    this.mHMD = null;

    var me = this;
    var listVRDisplays = function (vrdevs) {
        for (var i = 0; i < vrdevs.length; i++)
        {
            if (vrdevs[i] instanceof VRDisplay)
            {
                me.mHMD = vrdevs[i];
                console.log("WebVR is available.");
                console.log(me.mHMD);
                break;
            }
        }

        isVREnabledCallback(true);
        me.mSupportVR = true;
    }

    if (navigator.getVRDisplays)
    {
        navigator.getVRDisplays().then(listVRDisplays);
    }

    isVREnabledCallback(false);
    this.mCanvas = canvasElement;
    */
}

WebVR.prototype.IsSupported = function()
{
    return false;
    //return this.mSupportVR;
}

WebVR.prototype.GetData = function( id )
{
    return {};
    /*
    var frameData = new VRFrameData();
    var s = this.mHMD.getFrameData(frameData);
    var ss = frameData.pose;
    
    var fovL = this.mHMD.getEyeParameters("left");
    var fovR = this.mHMD.getEyeParameters( "right" );

    // camera info
    var cPos = vec3(0.0, 0.0, 0.0);
    if (ss.position)
        cPos = vec3(-ss.position[0], -ss.position[1], -ss.position[2]);
    var rot = vec4(0.0, 0.0, 0.0, 0.0);
    if (ss.orientation)
        rot = vec4(ss.orientation[0], ss.orientation[1], ss.orientation[2], ss.orientation[3]);
    var cRot = setFromQuaternion(rot);
    var cTra = setTranslation(cPos);
    var cMat = matMul(invertFast(cRot), cTra);
    
    // per eye info
    var lTra = setTranslation( vec3(-fovL.offset[0], -fovL.offset[1], -fovL.offset[2]) );
    var lMat = matMul(lTra, cMat);
    var lPrj = [ Math.tan( fovL.fieldOfView.upDegrees * Math.PI/180.0),
                 Math.tan(fovL.fieldOfView.downDegrees * Math.PI / 180.0),
                 Math.tan(fovL.fieldOfView.leftDegrees * Math.PI / 180.0),
                 Math.tan(fovL.fieldOfView.rightDegrees * Math.PI / 180.0)];

    var rTra = setTranslation(vec3(-fovR.offset[0], -fovR.offset[1], -fovR.offset[2]));
    var rMat = matMul(rTra, cMat);
    var rPrj = [Math.tan(fovR.fieldOfView.upDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.downDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.leftDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.rightDegrees * Math.PI / 180.0)];

    return {
        mCamera   : { mCamera: cMat },
        mLeftEye  : { mVP:[0,0,fovL.renderWidth,fovL.renderHeight], mProjection:lPrj, mCamera:lMat },
        mRightEye : { mVP:[fovR.renderWidth/2,0,fovR.renderWidth,fovR.renderHeight], mProjection:rPrj, mCamera:rMat }
           };
    */
}

WebVR.prototype.Enable = function( id )
{
    /*
    this.mHMD.requestPresent([{ source: this.mCanvas }]).then(
        function ()
        {
        },
        function (err)
        {
            console.log("webVR : requestPresent failed.");
        }
    );
    */
}

WebVR.prototype.Disable = function( id )
{
    /*
    if (!this.mHMD.isPresenting)
    {
        return;
    }

    this.mHMD.exitPresent().then(
        function ()
        {
        },
        function (err)
        {
            console.log("webVR : exitPresent failed.");
        }
    );
    */
}

WebVR.prototype.RequestAnimationFrame = function (id)
{
    //this.mHMD.requestAnimationFrame(id);
}

WebVR.prototype.IsPresenting = function (id)
{
    /*
    if (this.mHMD.isPresenting)
    {
        return true;
    }
    */
    return false;
}

WebVR.prototype.Finish = function (id)
{
    /*
    if (this.mHMD.isPresenting)
    {
        this.mHMD.submitFrame();
    }
    */
}

//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piWebUtils
//
//==============================================================================


// RequestAnimationFrame
window.requestAnimFrame = ( function () { return window.requestAnimationFrame    || window.webkitRequestAnimationFrame ||
                                                 window.mozRequestAnimationFrame || window.oRequestAnimationFrame ||
                                                 window.msRequestAnimationFrame  || function( cb ) { window.setTimeout(cb,1000/60); };
                                        } )();

// performance.now
window.getRealTime = ( function() { if ("performance" in window ) return function() { return window.performance.now(); }
                                                                  return function() { return (new Date()).getTime(); }
                                  } )();

window.URL = window.URL || window.webkitURL;

navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;

function htmlEntities(str) 
{
    return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g,'&apos;');
}

function piDisableTouch()
{
    document.body.addEventListener('touchstart', function(e){ e.preventDefault(); });
}

var piGetTime = function ( timestamp )
{
    if (timestamp == 0)
        return "";
    return new Date(timestamp * 1000).toISOString().substr(0, 10);
}

function piGetCoords( obj )
{
    var x = 0;
    var y = 0; 
    do
    {
         x += obj.offsetLeft;
         y += obj.offsetTop;
    }while( obj = obj.offsetParent );

    return { mX:x, mY:y };
}

function piGetMouseCoords( ev, canvasElement )
{
    var pos = piGetCoords(canvasElement );
    var mcx =                        (ev.pageX - pos.mX) * canvasElement.width / canvasElement.offsetWidth;
    var mcy = canvasElement.height - (ev.pageY - pos.mY) * canvasElement.height / canvasElement.offsetHeight;

    return { mX: mcx, mY: mcy };

}

function piGetSourceElement( e )
{
    var ele = null;
    if( e.target )     ele = e.target;
    if( e.srcElement ) ele = e.srcElement;
    return ele;
}

function piRequestFullScreen( ele )
{
    if( ele==null ) ele =   document.documentElement;
         if( ele.requestFullscreen       ) ele.requestFullscreen();
    else if( ele.msRequestFullscreen     ) ele.msRequestFullscreen();
    else if( ele.mozRequestFullScreen    ) ele.mozRequestFullScreen();
    else if( ele.webkitRequestFullscreen ) ele.webkitRequestFullscreen( Element.ALLOW_KEYBOARD_INPUT );
}

function piIsFullScreen()
{
    return document.fullscreen || document.mozFullScreen || document.webkitIsFullScreen || document.msFullscreenElement || false;
}

function piExitFullScreen()
{
       if( document.exitFullscreen       ) document.exitFullscreen();
  else if( document.msExitFullscreen     ) document.msExitFullscreen();
  else if( document.mozCancelFullScreen  ) document.mozCancelFullScreen();
  else if( document.webkitExitFullscreen ) document.webkitExitFullscreen();
}

function piIsMobile()
{
    return (navigator.userAgent.match(/Android/i) ||
            navigator.userAgent.match(/webOS/i) ||
            navigator.userAgent.match(/iPhone/i) ||
            navigator.userAgent.match(/iPad/i) ||
            navigator.userAgent.match(/iPod/i) ||
            navigator.userAgent.match(/BlackBerry/i) ||
            navigator.userAgent.match(/Windows Phone/i)) ? true : false;
}

function piCreateGlContext( cv, useAlpha, useDepth, usePreserveBuffer, useSupersampling )
{
    var opts = { alpha: useAlpha, 
                 depth: useDepth, 
                 stencil: false, 
                 premultipliedAlpha: false, 
                 antialias: useSupersampling, 
                 preserveDrawingBuffer: usePreserveBuffer, 
                 powerPreference: "high-performance" }; // "low_power", "high_performance", "default"

    var gl = null;
    if( gl === null) gl = cv.getContext( "webgl2", opts );
    if( gl === null) gl = cv.getContext( "experimental-webgl2", opts );
    if( gl === null) gl = cv.getContext( "webgl", opts );
    if( gl === null) gl = cv.getContext( "experimental-webgl", opts );

    return gl;
}

function piCreateAudioContext()
{
    var res = null;
    try
    {
        if( window.AudioContext ) res = new AudioContext();
        if( res==null && window.webkitAudioContext ) res = new webkitAudioContext();
    }
    catch( e )
    {
        res = null;
    }
    return res;
}

function piHexColorToRGB(str) // "#ff3041"
{
    var rgb = parseInt(str.slice(1), 16);
    var r = (rgb >> 16) & 255;
    var g = (rgb >> 8) & 255;
    var b = (rgb >> 0) & 255;
    return [r, g, b];
}

function piCreateFPSCounter()
{
    var mFrame;
    var mTo;
    var mFPS;

    var iReset = function( time )
    {
        mFrame = 0;
        mTo = time;
        mFPS = 60.0;
    }

    var iCount = function( time )
    {
        mFrame++;

        if( (time-mTo)>500.0 )
        {
            mFPS = 1000.0*mFrame/(time-mTo);
            mFrame = 0;
            mTo = time;
            return true;
        }
        return false;
    }

    var iGetFPS = function()
    {
        return mFPS;
    }
    
    return { Reset : iReset, Count : iCount, GetFPS : iGetFPS };
}

function piCanMediaRecorded(canvas)
{
    if (typeof window.MediaRecorder !== 'function' || typeof canvas.captureStream !== 'function') {
        return false;
    }
    return true;
}

function piCreateMediaRecorder(isRecordingCallback, canvas) 
{
    if (piCanMediaRecorded(canvas) == false)
    {
        return null;
    }
    
    var options = { audioBitsPerSecond : 0, videoBitsPerSecond : 8000000 }; 
	     if (MediaRecorder.isTypeSupported('video/webm;codecs=h264')) options.mimeType = 'video/webm;codecs=h264';
    else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9' )) options.mimeType = 'video/webm;codecs=vp9';
    else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8' )) options.mimeType = 'video/webm;codecs=vp8';
    else                                                              options.mimeType = 'video/webm;';

    var mediaRecorder = new MediaRecorder(canvas.captureStream(), options);
    var chunks = [];
    
    mediaRecorder.ondataavailable = function(e) 
    {
        if (e.data.size > 0) 
        {
            chunks.push(e.data);
        }
    };
 
    mediaRecorder.onstart = function(){ 
        isRecordingCallback( true );
    };
    
    mediaRecorder.onstop = function()
    {
         isRecordingCallback( false );
         let blob     = new Blob(chunks, {type: "video/webm"});
         chunks       = [];
         let videoURL = window.URL.createObjectURL(blob);
         let url      = window.URL.createObjectURL(blob);
         let a        = document.createElement("a");
         document.body.appendChild(a);
         a.style      = "display: none";
         a.href       = url;
         a.download   = "capture.webm";
         a.click();
         window.URL.revokeObjectURL(url);
     };
    
    return mediaRecorder;
}

function piExportToEXR(width, height, numComponents, type, bytes)
{
    var bytesPerComponent = 0;
    if      (type=="Uint")   bytesPerComponent = 4; 
    else if (type=="Half")   bytesPerComponent = 2;
    else if (type=="Float")  bytesPerComponent = 4;

    var tHeader = 258 + (18 * numComponents + 1);
    var tTable = 8 * height;
    var tScanlines = height * (4 + 4 + (numComponents * bytesPerComponent * width));
    var tTotal = tHeader + tTable + tScanlines;

    //console.log("    header size = " + tHeader);
    //console.log("    table size = " + tTable);
    //console.log("    scanlines size = " + tScanlines);
    //console.log("    total = " + tTotal);

    var buffer = new ArrayBuffer(tTotal); 
    var data = new DataView(buffer);

    // Header
    {
        // Header : 4 bytes -> 0x76, 0x2f, 0x31, 0x01
        var c = 0;
        data.setUint8 (c++, 0x76);
        data.setUint8 (c++, 0x2f);
        data.setUint8 (c++, 0x31);
        data.setUint8 (c++, 0x01);

        // Version : 4 bytes -> 2, 0, 0, 0
        data.setUint8 (c++, 0x02);
        data.setUint8 (c++, 0x0);
        data.setUint8 (c++, 0x0);
        data.setUint8 (c++, 0x0);
        
        // Write channel info
        // Write attribute name : "channels"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x73);
            data.setUint8 (c++, 0x0);

            // Write attribute type : "chlist"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00);

            // Write attribute size : 18 x 3 + 1 = 55
            var attribSize = 18 * numComponents + 1;
            data.setUint8 (c++, attribSize); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            var i;
            for (i = 0; i < numComponents; i++)
            {
                // Attribute : "B" (42) "G" (47) "R" (52)
                if (i==0)       data.setUint8 (c++, 0x42);
                else if (i==1)  data.setUint8 (c++, 0x47);
                else if (i==2)  data.setUint8 (c++, 0x52);
                data.setUint8 (c++, 0x00);
                
                // Value : Float (2), Half (1), Uint (0)
                if      (type=="Uint")   data.setUint8 (c++, 0x00); 
                else if (type=="Half")   data.setUint8 (c++, 0x01);
                else if (type=="Float")  data.setUint8 (c++, 0x02);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);

                // Plinear
                data.setUint8 (c++, 0x01);

                // Reserved
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 

                // X sampling
                data.setUint8 (c++, 0x01); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                
                // Y sampling
                data.setUint8 (c++, 0x01);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
            }
            // End attribute
            data.setUint8 (c++, 0x00);
    
        // Write attribute name : "compression"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6d); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x00);

            // Write attribute type : "compression"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6d); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x00);

            // Write attribute size : "1"
            data.setUint8 (c++, 0x01); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // Write attribute value : "0" (None)
            data.setUint8 (c++, 0x00);

        // datawindow
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x00); 

            // box2i
            data.setUint8 (c++, 0x62); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x00);

            // size 16
            data.setUint8 (c++, 0x10); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0 3 2
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 

            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint32 (c, width-1, true);
            c += 4;
            
            data.setUint32 (c, height-1, true); 
            c += 4;

        // displayWindow
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x79); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x00);

            // box2i
            data.setUint8 (c++, 0x62); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x00); 

            // size 16
            data.setUint8 (c++, 0x10); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0 3 2
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint32 (c, width-1, true);
            c += 4;
            
            data.setUint32 (c, height-1, true); 
            c += 4;

        // lineOrder
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x4f); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00); 
            
            // lineOrder
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x4f); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00); 
            
            // size
            data.setUint8 (c++, 0x01);
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);
            
            // value 
            data.setUint8 (c++, 0x00);

        // PixelAspectRatio
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x41); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x52); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x00); 

            // float
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00);
        
            // size 4
            data.setUint8 (c++, 0x04); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 1.0
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x80); 
            data.setUint8 (c++, 0x3f);
        
        // screenWindowCenter
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x63);
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x43); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e);
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00);

            // v2f
            data.setUint8 (c++, 0x76); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x00);

            // size 8
            data.setUint8 (c++, 0x08); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

        // screenWindowWidth
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x00); 
            
            // float
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00); 

            // size
            data.setUint8 (c++, 0x04); 
            data.setUint8 (c++, 0x00);
            data.setUint8 (c++, 0x00);
            data.setUint8 (c++, 0x00);

            // value
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x80); 
            data.setUint8 (c++, 0x3f);

        // End of header
        data.setUint8 (c++, 0x00);
    }
    //console.log("header size = " + c);

    // Scanline table
    var initc = c + height * 8;
    for (var scanline = 0 ; scanline < height ; scanline ++)
    {
        var jump = initc + scanline * (8 + width * bytesPerComponent * numComponents); 
        data.setUint32 (c, jump, true);
        c += 4; 

        data.setUint32 (c, 0x00, true);
        c += 4;
    }
    //console.log("header + scanlines table size = " + c);

    // Scanlines
    for (var scanline = 0 ; scanline < height ; scanline ++)
    {
        // Scanline
        data.setUint32(c, scanline, true);
        c += 4;

        // size 24
        var size = width * numComponents * bytesPerComponent; 
        data.setUint32(c, size, true);
        c += 4;

        var numComponentsSource = 4; // number of components in the SOURCE image
        for (var component = 0; component < numComponents ; component ++) 
        {
            for (var pixel = 0 ; pixel < width ; pixel ++) 
            {
                // flip vertical, so we read OpenGL buffers without JS image flipping
                var v = bytes[(height-1-scanline) * width *numComponentsSource + pixel * numComponentsSource + (2-component)];
                if      (type=="Float") data.setFloat32(c, v, true);
                else if (type=="Half")  data.setUint16(c, v, true);

                c += bytesPerComponent;
            }
        }
    }
    //console.log("total size = " + c);
    return new Blob([buffer], {type: 'application/octet-stream'});
}


function piExportToWAV(numSamples, rate, bits, numChannels, words)
{
    let numBytes = numSamples * numChannels * bits/8;

    let buffer = new ArrayBuffer(44 + numBytes); 
    let data = new DataView(buffer);

    {
        data.setUint32( 0, 0x46464952, true );  // RIFF
        data.setUint32( 4, numBytes + 36, true);
        {
            data.setUint32( 8, 0x45564157, true );  // WAV_WAVE
            data.setUint32( 12, 0x20746D66, true );  // WAV_FMT
            {
                data.setUint32( 16, 16, true);
                data.setUint16( 20, 1, true ); // WAV_FORMAT_PCM
                data.setUint16( 22, numChannels, true);
                data.setUint32( 24, rate, true);
                data.setUint32( 28, rate*numChannels*bits / 8, true);
                data.setUint16( 32, numChannels*bits / 8, true);
                data.setUint16( 34, bits, true);
            }

            data.setUint32( 36, 0x61746164, true);  // WAV_DATA
            {
                data.setUint32( 40, numBytes, true);
                let numWords = numSamples * numChannels;
                for(let i=0; i<numWords; i++ )
                {
                    data.setInt16( 44 + i*2, words[i], true );
                }
            }
        }
    }


    //console.log("total size = " + c);
    return new Blob([buffer], {type: 'application/octet-stream'});
}

function piTriggerDownload(name, blob)
{
    let url = URL.createObjectURL(blob);
    let aElement = document.createElement("a");
    aElement.href     = url;
    aElement.target   = "_self";
    aElement.download = name;
    document.body.appendChild(aElement);
    aElement.click();
    document.body.removeChild(aElement);
}</script>
    <script>"use strict"

function bufferID_to_assetID( id )
{
    if( id===0 ) return '4dXGR8';
    if( id===1 ) return 'XsXGR8';
    if( id===2 ) return '4sXGR8';
    if( id===3 ) return 'XdfGR8';
    return 'none';
}
function assetID_to_bufferID( id )
{
    if( id==='4dXGR8' ) return 0;
    if( id==='XsXGR8' ) return 1;
    if( id==='4sXGR8' ) return 2;
    if( id==='XdfGR8' ) return 3;
    return -1;
}

function assetID_to_cubemapBuferID( id )
{
    if( id==='4dX3Rr' ) return 0;
    return -1;
}
function cubamepBufferID_to_assetID( id )
{
    if( id===0 ) return '4dX3Rr';
    return 'none';
}

function EffectPass( renderer, is20, isLowEnd, hasShaderTextureLOD, callback, obj, forceMuted, forcePaused, outputGainNode, copyProgram, id, effect  )
{
    this.mID = id;
    this.mInputs  = [null, null, null, null ];
    this.mOutputs = [null, null, null, null ];
    this.mSource = null;

    this.mGainNode = outputGainNode;
    this.mSoundShaderCompiled = false;

    this.mEffect = effect;
    this.mRenderer = renderer;
    this.mProgramCopy = copyProgram; 
    this.mCompilationTime = 0;

    this.mType = "none";
    this.mName = "none";
    this.mFrame = 0;

    this.mShaderTextureLOD = hasShaderTextureLOD;
    this.mIs20 = is20;
    this.mIsLowEnd = isLowEnd;
    this.mTextureCallbackFun = callback;
    this.mTextureCallbackObj = obj;
    this.mForceMuted = forceMuted;
    this.mForcePaused = forcePaused;
}

EffectPass.prototype.MakeHeader_Image = function()
{
    let header = "";

    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for( let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        // old API
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                  header += "uniform sampler2D iChannel" + i + ";\n";

        // new API (see shadertoy.com/view/wtdGW8)
        header += "uniform struct {\n";
             if( inp===null )                  header += "  sampler2D";
        else if( inp.mInfo.mType==="cubemap" ) header += "  samplerCube";
        else if( inp.mInfo.mType==="volume"  ) header += "  sampler3D";
        else                                  header += "  sampler2D";
        header +=        " sampler;\n";
        header += "  vec3  size;\n";
        header += "  float time;\n";
        header += "  int   loaded;\n";
        header += "}iCh" + i + ";\n";
    }
	header += "void mainImage( out vec4 c, in vec2 f );\n";
    header += "void st_assert( bool cond );\n";
    header += "void st_assert( bool cond, int v );\n";

    if( this.mIs20 ) 
    {
        header += "\nout vec4 shadertoy_out_color;\n" +
        "void st_assert( bool cond, int v ) {if(!cond){if(v==0)shadertoy_out_color.x=-1.0;else if(v==1)shadertoy_out_color.y=-1.0;else if(v==2)shadertoy_out_color.z=-1.0;else shadertoy_out_color.w=-1.0;}}\n" +
        "void st_assert( bool cond        ) {if(!cond)shadertoy_out_color.x=-1.0;}\n" +
        "void main( void )" +
        "{" +
            "shadertoy_out_color = vec4(1.0,1.0,1.0,1.0);" + 
            "vec4 color = vec4(0.0,0.0,0.0,1.0);" +
            "mainImage( color, gl_FragCoord.xy );" +
            "if(shadertoy_out_color.x<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(shadertoy_out_color.y<0.0) color=vec4(0.0,1.0,0.0,1.0);" +
            "if(shadertoy_out_color.z<0.0) color=vec4(0.0,0.0,1.0,1.0);" +
            "if(shadertoy_out_color.w<0.0) color=vec4(1.0,1.0,0.0,1.0);" +
            "shadertoy_out_color = vec4(color.xyz,1.0);" +
        "}";
    }
    else
    {
        header += "" +
        "void st_assert( bool cond, int v ) {if(!cond){if(v==0)gl_FragColor.x=-1.0;else if(v==1)gl_FragColor.y=-1.0;else if(v==2)gl_FragColor.z=-1.0;else gl_FragColor.w=-1.0;}}\n" +
        "void st_assert( bool cond        ) {if(!cond)gl_FragColor.x=-1.0;}\n" +
        "void main( void )" +
        "{" +
            "gl_FragColor = vec4(0.0,0.0,0.0,1.0);" + 
            "vec4 color = vec4(0.0,0.0,0.0,1.0);" +
            "mainImage( color, gl_FragCoord.xy );" +
            "color.w = 1.0;" +
            "if(gl_FragColor.w<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(gl_FragColor.x<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(gl_FragColor.y<0.0) color=vec4(0.0,1.0,0.0,1.0);" +
            "if(gl_FragColor.z<0.0) color=vec4(0.0,0.0,1.0,1.0);" +
            "if(gl_FragColor.w<0.0) color=vec4(1.0,1.0,0.0,1.0);" +
            "gl_FragColor = vec4(color.xyz,1.0);"+
        "}";
    }
    header += "\n";

    /*
    this.mImagePassFooterVR = "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 ) 
        this.mImagePassFooterVR += "\nout vec4 outColor;\n";
    this.mImagePassFooterVR += "void main( void )" +
    "{" +
        "vec4 color = vec4(0.0,0.0,0.0,1.0);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainVR( color, gl_FragCoord.xy-unViewport.xy, ro, rd );" +
        "color.w = 1.0;"
    if( this.mIs20 ) 
        this.mImagePassFooterVR +=  "outColor = color;}";
    else
        this.mImagePassFooterVR +=  "gl_FragColor = color;}";
    */
    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Buffer = function()
{
    let header = "";
    
    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                  header += "uniform sampler2D iChannel" + i + ";\n";
    }

	header += "void mainImage( out vec4 c,  in vec2 f );\n"

    if( this.mIs20 )
        header += "\nout vec4 outColor;\n";
    header += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(0.0,0.0,0.0,1.0);" +
        "mainImage( color, gl_FragCoord.xy );";
    if( this.mIs20 )
        header +="outColor = color; }";
    else
        header +="gl_FragColor = color; }";
    header += "\n";

    /*
    this.mImagePassFooterVR = "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 )
    this.mImagePassFooterVR += "\nout vec4 outColor;\n";
    this.mImagePassFooterVR += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(0.0,0.0,0.0,1.0);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainVR( color, gl_FragCoord.xy-unViewport.xy, ro, rd );";
    if( this.mIs20 )
        this.mImagePassFooterVR +="outColor = color; }";
    else
        this.mImagePassFooterVR +="gl_FragColor = color; }";
    */
    this.mHeader = header;
    this.mHeaderLength = 0;
}


EffectPass.prototype.MakeHeader_Cubemap = function()
{
    let header = "";
    
    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                   header += "uniform sampler2D iChannel" + i + ";\n";
    }

	header += "void mainCubemap( out vec4 c, in vec2 f, in vec3 ro, in vec3 rd );\n"

    header += "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 )
        header += "\nout vec4 outColor;\n";
    header += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(0.0,0.0,0.0,1.0);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainCubemap( color, gl_FragCoord.xy-unViewport.xy, ro, rd );";
    if( this.mIs20 )
        header +="outColor = color; }";
    else
        header +="gl_FragColor = color; }";
    header += "\n";

    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Sound = function()
{
    let header = "";

    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform float     iChannelTime[4];\n" +
              "uniform float     iTimeOffset;\n" +
              "uniform int       iSampleOffset;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n";

    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp!==null && inp.mInfo.mType==="cubemap" )
            header += "uniform samplerCube iChannel" + i + ";\n";
        else
            header += "uniform sampler2D iChannel" + i + ";\n";
    }
    header += "\n";
    header += "vec2 mainSound( in int samp, float time );\n";

    if( this.mIs20 )
    {
        header += "out vec4 outColor; void main()" +
            "{" +
            "float t = iTimeOffset + ((gl_FragCoord.x-0.5) + (gl_FragCoord.y-0.5)*512.0)/iSampleRate;" +
            "int   s = iSampleOffset + int(gl_FragCoord.y-0.2)*512 + int(gl_FragCoord.x-0.2);" +
            "vec2 y = mainSound( s, t );" +
            "vec2 v  = floor((0.5+0.5*y)*65536.0);" +
            "vec2 vl =   mod(v,256.0)/255.0;" +
            "vec2 vh = floor(v/256.0)/255.0;" +
            "outColor = vec4(vl.x,vh.x,vl.y,vh.y);" +
            "}";
    }
    else
    {
        header += "void main()" +
            "{" +
            "float t = iTimeOffset + ((gl_FragCoord.x-0.5) + (gl_FragCoord.y-0.5)*512.0)/iSampleRate;" +
            "vec2 y = mainSound( 0, t );" +
            "vec2 v  = floor((0.5+0.5*y)*65536.0);" +
            "vec2 vl =   mod(v,256.0)/255.0;" +
            "vec2 vh = floor(v/256.0)/255.0;" +
            "gl_FragColor = vec4(vl.x,vh.x,vl.y,vh.y);" +
            "}";
    }
    header += "\n";
    this.mHeader = header;
    this.mHeaderLength = 0;
}


EffectPass.prototype.MakeHeader_Common = function ()
{
    let header = "";
    let headerlength = 0;

    header += "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n";
    headerlength += 2;

    if (this.mIs20)
    {
        header += "out vec4 outColor;\n";
        headerlength += 1;
    }
    header += "void main( void )\n";
    headerlength += 1;

    if (this.mIs20)
        header += "{ outColor = vec4(0.0); }";
    else
        header += "{ gl_FragColor = vec4(0.0); }";
    headerlength += 1;
    header += "\n";
    headerlength += 1;

    this.mHeader = header;
    this.mHeaderLength = headerlength;
}

EffectPass.prototype.MakeHeader = function()
{
         if( this.mType==="image" ) this.MakeHeader_Image();
    else if( this.mType==="sound" ) this.MakeHeader_Sound();
    else if( this.mType==="buffer") this.MakeHeader_Buffer();
    else if( this.mType==="common") this.MakeHeader_Common();
    else if( this.mType==="cubemap") this.MakeHeader_Cubemap();
    else console.log("ERROR 4");
}

EffectPass.prototype.Create_Image = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mSupportsVR = false;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    //this.mProgramVR = null;
}
EffectPass.prototype.Destroy_Image = function( wa )
{
}

EffectPass.prototype.Create_Buffer = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mSupportsVR = false;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    //this.mProgramVR = null;
}

EffectPass.prototype.Destroy_Buffer = function( wa )
{
}

EffectPass.prototype.Create_Cubemap = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
}

EffectPass.prototype.Destroy_Cubemap = function( wa )
{
}

EffectPass.prototype.Create_Common = function( wa )
{
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.MakeHeader();
}
EffectPass.prototype.Destroy_Common = function( wa )
{
}

EffectPass.prototype.Create_Sound = function (wa)
{
    this.MakeHeader();


    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    this.mSampleRate = 44100;
    this.mPlayTime = 60*3;
    this.mPlaySamples = this.mPlayTime*this.mSampleRate;
    this.mBuffer = wa.createBuffer( 2, this.mPlaySamples, this.mSampleRate );

    //-------------------
    this.mTextureDimensions = 512;
    this.mRenderTexture = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D, 
                                                       this.mTextureDimensions, this.mTextureDimensions,
                                                       this.mRenderer.TEXFMT.C4I8,
                                                       this.mRenderer.FILTER.NONE,
                                                       this.mRenderer.TEXWRP.CLAMP, null);
    this.mRenderFBO = this.mRenderer.CreateRenderTarget(this.mRenderTexture, null, null, null, null, false);

    //-----------------------------

    // ArrayBufferView pixels;
    this.mTmpBufferSamples = this.mTextureDimensions*this.mTextureDimensions;
    this.mData = new Uint8Array( this.mTmpBufferSamples*4 );

    this.mPlaying = false;
}

EffectPass.prototype.Destroy_Sound = function( wa )
{
    if( this.mPlayNode!==null ) this.mPlayNode.stop();
    this.mPlayNode = null;
    this.mBuffer = null;
    this.mData = null;

    this.mRenderer.DestroyRenderTarget(this.mRenderFBO);
    this.mRenderer.DestroyTexture(this.mRenderTexture);
}

EffectPass.prototype.Create = function( passType, wa )
{
    this.mType = passType;
    this.mSource = null;

         if( passType==="image" ) this.Create_Image( wa );
    else if( passType==="sound" ) this.Create_Sound( wa );
    else if( passType==="buffer") this.Create_Buffer( wa );
    else if( passType==="common") this.Create_Common( wa );
    else if( passType==="cubemap") this.Create_Cubemap( wa );
    else alert("ERROR 1");
}

EffectPass.prototype.SetName = function (passName)
{
    this.mName = passName;
}

EffectPass.prototype.SetCode = function (src)
{
    this.mSource = src;
}

EffectPass.prototype.Destroy = function( wa )
{
    this.mSource = null;
         if( this.mType==="image" ) this.Destroy_Image( wa );
    else if( this.mType==="sound" ) this.Destroy_Sound( wa );
    else if( this.mType==="buffer") this.Destroy_Buffer( wa );
    else if( this.mType==="common") this.Destroy_Common( wa );
    else if( this.mType==="cubemap") this.Destroy_Cubemap( wa );
    else alert("ERROR 2");
}

EffectPass.prototype.NewShader_Sound = function( shaderCode, commonShaderCodes)
{
    let vsSource = null;

    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for( let i=0; i<commonShaderCodes.length; i++ )
    {
        fsSource += commonShaderCodes[i]+'\n';
    }
    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;
    fsSource += shaderCode;

    this.mSoundShaderCompiled = false;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader_Image = function ( shaderCode, commonShaderCodes )
{
    this.mSupportsVR = false;


    let vsSource = null;
    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for (let i = 0; i < commonShaderCodes.length; i++)
    {
        fsSource += commonShaderCodes[i]+'\n';
    }
    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;
    fsSource += shaderCode;

    return [vsSource, fsSource];


    /*
    let n1 = shaderCode.indexOf("mainVR(");
    let n2 = shaderCode.indexOf("mainVR (");
    let n3 = shaderCode.indexOf("mainVR  (");
    if( n1>0 || n2>0 || n3>0 )
    {
        let vsSourceVR;
        if( this.mIs20 )
            vsSourceVR = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        else
            vsSourceVR = "attribute in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

        let fsSourceVR = this.mHeader;
        for (let i = 0; i < commonShaderCodes.length; i++) {
            fsSourceVR += commonShaderCodes[i];
        }
        fsSourceVR += shaderCode;
        fsSourceVR += this.mImagePassFooterVR;

        let res = this.mRenderer.CreateShader(vsSource, fsSourceVR, preventCache);
        if( res.mResult == false )
        {
            return res.mInfo;
        }
        if( this.mProgramVR != null )
            this.mRenderer.DestroyShader( this.mProgramVR );

        this.mSupportsVR = true;
        this.mProgramVR = res;
    }
    */
}

EffectPass.prototype.NewShader_Cubemap = function( shaderCode, commonShaderCodes )
{
    let vsSource = null;
    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for (let i = 0; i < commonShaderCodes.length; i++)
    {
        fsSource += commonShaderCodes[i]+'\n';
    }

    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;

    fsSource += shaderCode;

    return [vsSource, fsSource];
}


EffectPass.prototype.NewShader_Common = function (shaderCode )
{
    let vsSource = null;
    if (this.mIs20)
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader + shaderCode;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader = function ( commonSourceCodes, preventCache, onResolve)
{
    if( this.mRenderer===null ) return;

    let vs_fs = null;

         if( this.mType==="sound"  ) vs_fs = this.NewShader_Sound(   this.mSource, commonSourceCodes );
    else if( this.mType==="image"  ) vs_fs = this.NewShader_Image(   this.mSource, commonSourceCodes );
    else if( this.mType==="buffer" ) vs_fs = this.NewShader_Image(   this.mSource, commonSourceCodes );
    else if( this.mType==="common" ) vs_fs = this.NewShader_Common(  this.mSource,                   );
    else if( this.mType==="cubemap") vs_fs = this.NewShader_Cubemap( this.mSource, commonSourceCodes );
    else { console.log("ERROR 3: \"" + this.mType + "\""); return; }

    let me = this;
    this.mRenderer.CreateShader(vs_fs[0], vs_fs[1], preventCache, false,
        function (worked, info)
        {
            if (worked === true)
            {
                if (me.mType === "sound")
                {
                    me.mSoundShaderCompiled = true;
                }

                me.mCompilationTime = info.mTime;
                me.mError = false;
                me.mErrorStr = "No Errors";
                if (me.mProgram !== null)
                    me.mRenderer.DestroyShader(me.mProgram);
                me.mTranslatedSource = me.mRenderer.GetTranslatedShaderSource(info);
                me.mProgram = info;
            }
            else
            {
                me.mError = true;
                me.mErrorStr = info.mErrorStr;
            }
            onResolve();
        });
}

EffectPass.prototype.DestroyInput = function( id )
{
    if( this.mInputs[id]===null ) return;

    if( this.mInputs[id].mInfo.mType==="texture" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    if( this.mInputs[id].mInfo.mType==="volume" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="webcam" )
    {
        this.mInputs[id].video.pause();
        this.mInputs[id].video.src = "";

        if( this.mInputs[id].video.srcObject!==null )
        {
        let tracks = this.mInputs[id].video.srcObject.getVideoTracks();
        if( tracks ) tracks[0].stop();
        }
        this.mInputs[id].video = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="video" )
    {
        this.mInputs[id].video.pause();
        this.mInputs[id].video = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="music" || this.mInputs[id].mInfo.mType==="musicstream")
    {
        this.mInputs[id].audio.pause();
        this.mInputs[id].audio.mSound.mFreqData = null;
        this.mInputs[id].audio.mSound.mWaveData = null;
        this.mInputs[id].audio = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="cubemap" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="keyboard" )
    {
        //if( this.mInputs[id].globject != null )
          //  this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="mic" )
    {
        this.mInputs[id].mic = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }

    this.mInputs[id] = null;
}

EffectPass.prototype.TooglePauseInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused )
        {
            inp.video.play();
            inp.video.mPaused = false;
        }
        else
        {
            inp.video.pause();
            inp.video.mPaused = true;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        wa.resume()
        if( inp.audio.mPaused )
        {
            if( inp.loaded )
            {
                inp.audio.play();
            }
            inp.audio.mPaused = false;
        }
        else
        {
            inp.audio.pause();
            inp.audio.mPaused = true;
        }
        return inp.audio.mPaused;
    }

    return null;
}

EffectPass.prototype.StopInput = function( id )
{
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused === false )
        {
            inp.video.pause();
            inp.video.mPaused = true;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
    {
        if( inp.audio.mPaused === false )
        {
            inp.audio.pause();
            inp.audio.mPaused = true;
        }
        return inp.audio.mPaused;
    }
    return null;
}

EffectPass.prototype.ResumeInput = function( id )
{
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused )
        {
            inp.video.play();
            inp.video.mPaused = false;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
    {
        if( inp.audio.mPaused )
        {
            inp.audio.play();
            inp.audio.mPaused = false;
        }
        return inp.audio.mPaused;
    }
    return null;
}

EffectPass.prototype.RewindInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];

    if( inp==null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.loaded )
        {
            inp.video.currentTime = 0;
        }
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        wa.resume()
        if( inp.loaded )
        {
            inp.audio.currentTime = 0;
        }
    }
}

EffectPass.prototype.MuteInput = function( wa, id )
{
    let inp = this.mInputs[id];
    if( inp===null ) return;

    if( inp.mInfo.mType==="video" )
    {
        inp.video.muted = true;
        inp.video.mMuted = true;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if (wa !== null) inp.audio.mSound.mGain.gain.value = 0.0;
        inp.audio.mMuted = true;
    }
}

EffectPass.prototype.UnMuteInput = function( wa, id )
{
    let inp = this.mInputs[id];
    if( inp===null ) return;

    if( inp.mInfo.mType==="video" )
    {
        inp.video.muted = false;
        inp.video.mMuted = false;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if (wa !== null) inp.audio.mSound.mGain.gain.value = 1.0;
        inp.audio.mMuted = false;
    }
}

EffectPass.prototype.ToggleMuteInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];
    if( inp===null ) return null;

    if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mMuted ) this.UnMuteInput(wa,id);
        else                   this.MuteInput(wa,id);
        return inp.video.mMuted;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if( inp.audio.mMuted ) this.UnMuteInput(wa,id);
        else                   this.MuteInput(wa,id);
        return inp.audio.mMuted;
    }

    return null;
}

EffectPass.prototype.UpdateInputs = function( wa, forceUpdate, keyboard )
{
   for (let i=0; i<this.mInputs.length; i++ )
   {
        let inp = this.mInputs[i];

        if( inp===null )
        {
            if( forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, null, false, 0, 0, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.image, true, 1, 1, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mPreview, true, 1, 1, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
            if( inp.loaded && forceUpdate )
            {
                if( this.mTextureCallbackFun!==null )
                {
                    let img = (assetID_to_cubemapBuferID(inp.mInfo.mID)===-1) ? inp.image[0] : inp.mImage;
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, img, true, 2, 1, -1.0, this.mID );
                }
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:keyboard.mIcon,mData:keyboard.mData}, false, 6, 0, -1.0, this.mID );
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, -1, this.mID );
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
              if( inp.loaded && inp.audio.mPaused === false && inp.audio.mForceMuted === false )
              {
                  if( wa !== null )
                  {
                      inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                      inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                  }

                  if (this.mTextureCallbackFun!==null)
                  {
                           if (inp.mInfo.mType === "music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:(wa==null)?null:inp.audio.mSound.mFreqData}, false, 4, 1, inp.audio.currentTime, this.mID);
                      else if (inp.mInfo.mType === "musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:(wa==null)?null:inp.audio.mSound.mFreqData, info: inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                  }
              }
              else if( inp.loaded===false )
              {
                  if (this.mTextureCallbackFun!==null)
                      this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:null}, false, 4, 0, -1.0, this.mID);
              }
        }
        else if( inp.mInfo.mType==="mic" )
        {
              if( inp.loaded && inp.mForceMuted === false )
              {
                  if( wa !== null )
                  {
                      inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                      inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
                  }
                  if( this.mTextureCallbackFun!==null )
                      this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave: ((wa==null)?null:inp.mFreqData) }, false, 5, 1, 0, this.mID );
              }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:null}, true, 9, 1, -1.0, this.mID );
            }
        }
    }
}

EffectPass.prototype.Sampler2Renderer = function (sampler)
{
    let filter = this.mRenderer.FILTER.NONE;
    if (sampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
    if (sampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
    let wrap = this.mRenderer.TEXWRP.REPEAT;
    if (sampler.wrap === "clamp") wrap = this.mRenderer.TEXWRP.CLAMP;
    let vflip = false;
    if (sampler.vflip === "true") vflip = true;

    return { mFilter: filter, mWrap: wrap, mVFlip: vflip };
}

EffectPass.prototype.GetSamplerVFlip = function (id)
{
    let inp = this.mInputs[id];
    return inp.mInfo.mSampler.vflip;
}

EffectPass.prototype.GetTranslatedShaderSource = function ()
{
    return this.mTranslatedSource;
}


EffectPass.prototype.SetSamplerVFlip = function (id, str) 
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let filter = false;
    if (str === "true") filter = true;

    if (inp === null)
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
    }
    else if (inp.mInfo.mType === "video")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "webcam")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, null);
            inp.mInfo.mSampler.vflip = str;
        }
    }
}

EffectPass.prototype.GetAcceptsVFlip = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return false;
    if (inp.mInfo.mType === "video")  return true;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return true;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return false;
    return true;
}

EffectPass.prototype.GetSamplerFilter = function (id)
{
    let inp = this.mInputs[id];
    if( inp===null) return;
    return inp.mInfo.mSampler.filter;
}

EffectPass.prototype.SetSamplerFilter = function (id, str, buffers, cubeBuffers) 
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let filter = renderer.FILTER.NONE;
    if (str === "linear") filter = renderer.FILTER.LINEAR;
    if (str === "mipmap") filter = renderer.FILTER.MIPMAP;

    if (inp === null)
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "video")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap")
    {
        if (inp.loaded) 
        {
            if( assetID_to_cubemapBuferID(inp.mInfo.mID)===0)
            {
                renderer.SetSamplerFilter(cubeBuffers[0].mTexture[0], filter, true);
                renderer.SetSamplerFilter(cubeBuffers[0].mTexture[1], filter, true);
                inp.mInfo.mSampler.filter = str;
            }
            else
            {
                renderer.SetSamplerFilter(inp.globject, filter, true);
                inp.mInfo.mSampler.filter = str;
            }
        }
    }
    else if (inp.mInfo.mType === "webcam")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "buffer")
    {
        renderer.SetSamplerFilter(buffers[inp.id].mTexture[0], filter, true);
        renderer.SetSamplerFilter(buffers[inp.id].mTexture[1], filter, true);
        inp.mInfo.mSampler.filter = str;
    }
    else if (inp.mInfo.mType === "keyboard")
    {
        inp.mInfo.mSampler.filter = str;
    }
}



EffectPass.prototype.GetAcceptsMipmapping = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return this.mIs20;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return this.mIs20;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return this.mIs20;
    return false;
}

EffectPass.prototype.GetAcceptsLinear = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return true;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return true;
    if (inp.mInfo.mType === "music")  return true;
    if (inp.mInfo.mType === "musicstream") return true;
    if (inp.mInfo.mType === "mic")  return true;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return true;
    return false;
}


EffectPass.prototype.GetAcceptsWrapRepeat = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return this.mIs20;
    if (inp.mInfo.mType === "cubemap") return false;
    if (inp.mInfo.mType === "webcam")  return this.mIs20;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return this.mIs20;
    return false;
}

EffectPass.prototype.GetSamplerWrap = function (id)
{
    let inp = this.mInputs[id];
    return inp.mInfo.mSampler.wrap;
}
EffectPass.prototype.SetSamplerWrap = function (id, str, buffers)
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let restr = renderer.TEXWRP.REPEAT;
    if (str === "clamp") restr = renderer.TEXWRP.CLAMP;

    if (inp === null) 
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "video") 
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap") 
    {
        if (inp.loaded)
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "webcam") 
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "buffer")
    {
        renderer.SetSamplerWrap(buffers[inp.id].mTexture[0], restr);
        renderer.SetSamplerWrap(buffers[inp.id].mTexture[1], restr);
        inp.mInfo.mSampler.wrap = str;
    }
}


EffectPass.prototype.GetTexture = function( slot )
{
    let inp = this.mInputs[slot];
    if( inp===null ) return null;
    return inp.mInfo;

}

EffectPass.prototype.SetOutputs = function( slot, id )
{
    this.mOutputs[slot] = id;
}

EffectPass.prototype.SetOutputsByBufferID = function( slot, id )
{
    if( this.mType==="buffer" )
    {
        this.mOutputs[slot] = bufferID_to_assetID( id );

        this.mEffect.ResizeBuffer( id, this.mEffect.mXres, this.mEffect.mYres, false );
    }
    else if( this.mType==="cubemap" )
    {
        this.mOutputs[slot] = cubamepBufferID_to_assetID( id );
        this.mEffect.ResizeCubemapBuffer(id, 1024, 1024 );
    }
}

EffectPass.prototype.NewTexture = function( wa, slot, url, buffers, cubeBuffers, keyboard )
{
    var me = this;
    var renderer = this.mRenderer;

    if( renderer===null ) return;

    let texture = null;

    if( url===null || url.mType===null )
    {
        if( me.mTextureCallbackFun!==null )
            me.mTextureCallbackFun( this.mTextureCallbackObj, slot, null, true, 0, 0, -1.0, me.mID );
        me.DestroyInput( slot );
        me.mInputs[slot] = null;
        me.MakeHeader();
        return { mFailed:false, mNeedsShaderCompile:false };
    }
    else if( url.mType==="texture" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.image = new Image();
        texture.image.crossOrigin = '';
        texture.image.onload = function()
        {
            let rti = me.Sampler2Renderer(url.mSampler);

            // O.M.G. FIX THIS
            let channels = renderer.TEXFMT.C4I8;
            if (url.mID === "Xdf3zn" || url.mID === "4sf3Rn" || url.mID === "4dXGzn" || url.mID === "4sf3Rr")
                channels = renderer.TEXFMT.C1I8;
            
            texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.image, channels, rti.mFilter, rti.mWrap, rti.mVFlip);

            texture.loaded = true;
            if( me.mTextureCallbackFun!==null )
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.image, true, 1, 1, -1.0, me.mID );
        }
        texture.image.src = url.mSrc;


        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="volume" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.mImage = { mData:null, mXres:1, mYres:0, mZres:0 };
        texture.mPreview = new Image();
        texture.mPreview.crossOrigin = '';

	    var xmlHttp = new XMLHttpRequest();
        if( xmlHttp===null ) return { mFailed:true };

        xmlHttp.open('GET', url.mSrc, true);
        xmlHttp.responseType = "arraybuffer";
        xmlHttp.onerror = function()
        {
            console.log( "Error 1 loading Volume" );
        }
        xmlHttp.onload = function()
        {
            let data = xmlHttp.response;
            if (!data ) { console.log( "Error 2 loading Volume" ); return; }

            let file = piFile(data);

            let signature = file.ReadUInt32();
            texture.mImage.mXres = file.ReadUInt32();
            texture.mImage.mYres = file.ReadUInt32();
            texture.mImage.mZres = file.ReadUInt32();
            let binNumChannels = file.ReadUInt8();
            let binLayout = file.ReadUInt8();
            let binFormat = file.ReadUInt16();
            let format = renderer.TEXFMT.C1I8;
                 if( binNumChannels===1 && binFormat===0 )  format = renderer.TEXFMT.C1I8;
            else if( binNumChannels===2 && binFormat===0 )  format = renderer.TEXFMT.C2I8;
            else if( binNumChannels===3 && binFormat===0 )  format = renderer.TEXFMT.C3I8;
            else if( binNumChannels===4 && binFormat===0 )  format = renderer.TEXFMT.C4I8;
            else if( binNumChannels===1 && binFormat===10 ) format = renderer.TEXFMT.C1F32;
            else if( binNumChannels===2 && binFormat===10 ) format = renderer.TEXFMT.C2F32;
            else if( binNumChannels===3 && binFormat===10 ) format = renderer.TEXFMT.C3F32;
            else if( binNumChannels===4 && binFormat===10 ) format = renderer.TEXFMT.C4F32;
            else return;

            let buffer = new Uint8Array(data, 20); // skip 16 bytes (header of .bin)

            let rti = me.Sampler2Renderer(url.mSampler);

            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T3D, texture.mImage.mXres, texture.mImage.mYres, format, rti.mFilter, rti.mWrap, buffer);

            if( texture.globject===null )
            {
                console.log( "Error 4: loading Volume" ); 
                return { mFailed:true };
            }

            if (me.mTextureCallbackFun !== null)
            {
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mPreview, true, 1, 1, -1.0, me.mID );
            }

            texture.loaded = true;

            // load icon for it
            texture.mPreview.onload = function()
            {
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mPreview, true, 1, 1, -1.0, me.mID );
            }
            texture.mPreview.src = url.mPreviewSrc;
        }
        xmlHttp.send("");


        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]==null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="volume")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="cubemap" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;

        let rti = me.Sampler2Renderer(url.mSampler);

        if( assetID_to_cubemapBuferID(url.mID)!==-1 )
        {
            texture.mImage = new Image();
            texture.mImage.onload = function()
            {
                texture.loaded = true;
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mImage, true, 2, 1, -1.0, me.mID );
            }
            texture.mImage.src = "/media/previz/cubemap00.png";

            this.mEffect.ResizeCubemapBuffer(0, 1024, 1024 );

        }
        else
        {
            texture.image = [ new Image(), new Image(), new Image(), new Image(), new Image(), new Image() ];

            let numLoaded = 0;
            for (var i=0; i<6; i++ )
            {
                texture.image[i].mId = i;
                texture.image[i].crossOrigin = '';
                texture.image[i].onload = function()
                {
                    var id = this.mId;
                    numLoaded++;
                    if( numLoaded===6 )
                    {
                        texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.CUBEMAP, texture.image, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                        texture.loaded = true;
                        if (me.mTextureCallbackFun !== null)
                            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, texture.image[0], true, 2, 1, -1.0, me.mID);
                    }
                }

                if( i === 0) 
                {
                    texture.image[i].src = url.mSrc;
                } 
                else 
                {
                    let n = url.mSrc.lastIndexOf(".");
                    texture.image[i].src = url.mSrc.substring(0, n) + "_" + i + url.mSrc.substring(n, url.mSrc.length);
                }
            }
        }

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]==null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="cubemap")) };

        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="webcam" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;

        texture.video = document.createElement('video');
    	texture.video.width = 320;
    	texture.video.height = 240;
    	texture.video.autoplay = true;
    	texture.video.loop = true;
        texture.mForceMuted = this.mForceMuted;
        texture.mImage = null;

        let rti = me.Sampler2Renderer(url.mSampler);

        var loadImageInsteadOfWebCam = function()
        {
            texture.mImage = new Image();
            texture.mImage.onload = function()
            {
                texture.loaded = true;
                texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.mImage, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mImage, true, 7, 1, -1.0, me.mID );
            }
            texture.mImage.src = "/media/previz/webcam.png";
        }
        
        loadImageInsteadOfWebCam();

        if( typeof navigator.getUserMedia !== "undefined"  && texture.mForceMuted===false )
        {
            texture.video.addEventListener("canplay", function (e)
            {
				try
				{
                    texture.mImage = null;
                    if( texture.globject != null )
                        renderer.DestroyTexture( texture.globject );
					texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.video, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
					texture.loaded = true;
                }
                catch(e)
                {
                    loadImageInsteadOfWebCam();
	                alert( 'Your browser can not transfer webcam data to the GPU.');
                }
            } );

            navigator.mediaDevices.getUserMedia( 
                                { "video": { width: 1280, height: 720 }, "audio": false } )
                                .then( function(stream)
                                       {
                                            texture.video.srcObject = stream;
    	                               } )
                                .catch( function(error)
                                        {
                                            loadImageInsteadOfWebCam();
    		                                alert( 'Unable to capture WebCam. Please reload the page.' );
    	                                } );
        }
        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]==null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!="music") && 
                                                                (this.mInputs[slot].mInfo.mType!="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="mic" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.mForceMuted = this.mForceMuted;
        texture.mAnalyser = null;
        let num = 512;
        texture.mFreqData = new Uint8Array( num );
        texture.mWaveData = new Uint8Array( num );

        if( wa === null || typeof navigator.getUserMedia === "undefined" )
        {
            if( !texture.mForceMuted ) alert( "Shadertoy: Web Audio not implement in this browser" );
            texture.mForceMuted = true; 
        }

        if( texture.mForceMuted )
        {
            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, num, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null)
            texture.loaded = true;
        }
        else
        {
        navigator.getUserMedia( { "audio": true },
                                function(stream)
                                {
                                  texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, null)
                                  texture.mic = wa.createMediaStreamSource(stream);
                                  texture.mAnalyser = wa.createAnalyser();
                                  texture.mic.connect( texture.mAnalyser );
                                  texture.loaded = true;
    	                        },
                                function(error)
                                {
    		                        alert( 'Unable open Mic. Please reload the page.' );
    	                        } );
        }
        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="video" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.video = document.createElement('video');
    	texture.video.loop = true;
        texture.video.preload = "auto";
        texture.video.mPaused = this.mForcePaused;
        texture.video.mMuted = true;//this.mForceMuted;
    	texture.video.muted  = true;//this.mForceMuted;
        if( this.mForceMuted===true )
            texture.video.volume = 0;
    	texture.video.autoplay = false;
        texture.video.hasFalled = false;
        
        let rti = me.Sampler2Renderer(url.mSampler);

        texture.video.addEventListener("canplay", function (e)
        {
            texture.video.play().then( function()
                                       {
                                           texture.video.mPaused = false;

                                           texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.video, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                                           texture.loaded = true;
            
                                           if( me.mTextureCallbackFun!=null )
                                               me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.video, true, 3, 1, -1.0, me.mID );
                                        } )
                               .catch( function(error)
                                       {
                                           console.log( error );
                                       }
                                );
        } );

        texture.video.addEventListener( "error", function(e)
        {
               if( texture.video.hasFalled===true ) { alert("Error: cannot load video" ); return; }
               let str = texture.video.src;
               str = str.substr(0,str.lastIndexOf('.') ) + ".mp4";
               texture.video.src = str;
               texture.video.hasFalled = true;
        } );

        texture.video.src = url.mSrc;

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]==null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!="music") && 
                                                                (this.mInputs[slot].mInfo.mType!="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="music" || url.mType==="musicstream" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.audio = document.createElement('audio');
    	texture.audio.loop = true;
        texture.audio.mMuted = this.mForceMuted;
        texture.audio.mForceMuted = this.mForceMuted;
        texture.audio.muted = this.mForceMuted;
        if( this.mForceMuted===true )
            texture.audio.volume = 0;
        texture.audio.autoplay = false;
        texture.audio.hasFalled = false;
        texture.audio.mPaused = false;
        texture.audio.mSound = {};

        if( this.mForceMuted===false )
        {
            if(url.mType==="musicstream" && SC === null)
            {
                alert( "Shadertoy: Soundcloud could not be reached" );
                texture.audio.mForceMuted = true;
            }
            }

        if( wa === null && this.mForceMuted===false )
        {
            alert( "Shadertoy: Web Audio not implement in this browser" );
            texture.audio.mForceMuted = true;
        }

        if( texture.audio.mForceMuted )
        {
            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null);
            let num = 512;
            texture.audio.mSound.mFreqData = new Uint8Array( num );
            texture.audio.mSound.mWaveData = new Uint8Array( num );
            texture.loaded = true;
        }

        texture.audio.addEventListener( "canplay", function()
        {
            if( texture===null || texture.audio===null ) return;
            if( this.mForceMuted  ) return;
            if( texture.loaded === true ) return;

            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null)

            texture.audio.mSound.mSource   = wa.createMediaElementSource( texture.audio );
            texture.audio.mSound.mAnalyser = wa.createAnalyser();
            texture.audio.mSound.mGain     = wa.createGain();

            texture.audio.mSound.mSource.connect(   texture.audio.mSound.mAnalyser );
            texture.audio.mSound.mAnalyser.connect( texture.audio.mSound.mGain );
            texture.audio.mSound.mGain.connect(me.mGainNode);

            texture.audio.mSound.mFreqData = new Uint8Array( texture.audio.mSound.mAnalyser.frequencyBinCount );
            texture.audio.mSound.mWaveData = new Uint8Array( texture.audio.mSound.mAnalyser.frequencyBinCount );

            if( texture.audio.mPaused )
            {
                texture.audio.pause();
            }
            else
            {
                texture.audio.play().then( function() {/*console.log("ok");*/} ).catch( function(e){console.log("error " + e);} );
            }
            texture.loaded = true;
        } );

        texture.audio.addEventListener( "error", function(e)
        {
               if( this.mForceMuted  ) return;

               if( texture.audio.hasFalled===true ) { return; }
               let str = texture.audio.src;
               str = str.substr(0,str.lastIndexOf('.') ) + ".ogg";
               texture.audio.src = str;
               texture.audio.hasFalled = true;
        } );

        if( !texture.audio.mForceMuted )
        {
            if(url.mType==="musicstream")
            {
                SC.resolve(url.mSrc, 
                    function(song) 
                    {
                        if( song.streamable===true )
                        {
                            texture.audio.crossOrigin = 'anonymous';
                            texture.audio.src = song.stream_url;
                            texture.audio.soundcloudInfo = song;
                        }
                        else
                        {
                            alert('Shadertoy: Soundcloud 3 - This track cannot be streamed' );
                        }
                    },
                    function(error)
                    {
                        if (me.mTextureCallbackFun!==null)
                        {
                            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null}, false, 4, 0, -1.0, me.mID);
                        }
                    } );
            } 
            else
            {
                texture.audio.src = url.mSrc;
            }
        }

        if (me.mTextureCallbackFun!==null)
        {
            if (url.mType === "music")            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null}, false, 4, 0, -1.0, me.mID);
            else if (url.mType === "musicstream") me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null, info: texture.audio.soundcloudInfo}, false, 8, 0, -1.0, me.mID);
        }

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="keyboard" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = true;

        texture.keyboard = {};

        if( me.mTextureCallbackFun!==null )
            me.mTextureCallbackFun( me.mTextureCallbackObj, slot, {mImage: keyboard.mIcon, mData: keyboard.mData}, false, 6, 1, -1.0, me.mID );

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!="music") && 
                                                                (this.mInputs[slot].mInfo.mType!="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="buffer" )
    {
        texture = {};
        texture.mInfo = url;

        texture.image = new Image();
        texture.image.onload = function()
        {
            if( me.mTextureCallbackFun!=null )
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, {texture: texture.image, data:null}, true, 9, 1, -1.0, me.mID );
        }
        texture.image.src = url.mSrc;
        texture.id = assetID_to_bufferID( url.mID );
        texture.loaded = true;

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!="music") && 
                                                                (this.mInputs[slot].mInfo.mType!="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!="video")) };

        this.DestroyInput( slot );
        this.mInputs[slot] = texture;

        this.mEffect.ResizeBuffer(texture.id, this.mEffect.mXres, this.mEffect.mYres, false );

        this.SetSamplerFilter(slot, url.mSampler.filter, buffers, cubeBuffers, true);
        this.SetSamplerVFlip(slot, url.mSampler.vflip);
        this.SetSamplerWrap(slot, url.mSampler.wrap, buffers);

        this.MakeHeader();
        return returnValue;
    }
    else
    {
        alert( "input type error" );
        return { mFailed: true };
    }

    return { mFailed: true };
}

EffectPass.prototype.Paint_Image = function( vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    let times = [ 0.0, 0.0, 0.0, 0.0 ];

    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds()  + d.getMilliseconds()/1000.0 ];

    let mouse = [  mousePosX, mousePosY, mouseOriX, mouseOriY ];


    //------------------------
    
    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];
    let texIsLoaded = [0, 0, 0, 0 ];
    let texID = [ null, null, null, null];

    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            texID[i] = keyboard.mTexture;
            texIsLoaded[i] = 1;
            resos[3*i+0] = 256;
            resos[3*i+1] = 3;
            resos[3*i+2] = 1;
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
            if (inp.loaded === true)
            {
                let id = assetID_to_cubemapBuferID(inp.mInfo.mID);
                if( id!==-1 )
                {
                    texID[i] = cubeBuffers[id].mTexture[ cubeBuffers[id].mLastRenderDone ];
                    resos[3*i+0] = cubeBuffers[id].mResolution[0];
                    resos[3*i+1] = cubeBuffers[id].mResolution[1];
                    resos[3*i+2] = 1;
                    texIsLoaded[i] = 1;

                    // hack. in webgl2.0 we have samplers, so we don't need this crap here
                    let filter = this.mRenderer.FILTER.NONE;
                         if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                    else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                    this.mRenderer.SetSamplerFilter( texID[i], filter, false);
                }
                else
                {
                    texID[i] = inp.globject;
                    texIsLoaded[i] = 1;
                }
            }
        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mImage, false, 7, 1, -1, this.mID );

                    texID[i] = inp.globject;
                    texIsLoaded[i] = 1;
                    resos[3*i+0] = inp.mImage.width;
                    resos[3*i+1] = inp.mImage.height;
                    resos[3*i+2] = 1;
                }
                else  if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {

                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 7, 1, -1, this.mID );

                    texID[i] = inp.globject;
                    this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                    resos[3*i+0] = inp.video.videoWidth;
                    resos[3*i+1] = inp.video.videoHeight;
                    resos[3*i+2] = 1;
                    texIsLoaded[i] = 1;
                }
            }
            else 
            {
                texID[i] = null;
                texIsLoaded[i] = 0;
                resos[3*i+0] = inp.video.width;
                resos[3*i+1] = inp.video.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.mPaused === false )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, inp.video.currentTime, this.mID );
            }

            if( inp.loaded===true )
            { 
                times[i] = inp.video.currentTime;
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;

      	        if( inp.video.mPaused === false )
      	        {
      	            this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
                resos[3*i+0] = inp.video.videoWidth;
                resos[3*i+1] = inp.video.videoHeight;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.audio.mPaused === false && inp.audio.mForceMuted === false && inp.loaded===true )
            {
                if( wa !== null )
                {
                    inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                    inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                }

                if( this.mTextureCallbackFun!==null )
                {
                         if( inp.mInfo.mType==="music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa === null) ? null : { wave : inp.audio.mSound.mFreqData }, false, 4, 1, inp.audio.currentTime, this.mID);
                    else if( inp.mInfo.mType==="musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa === null) ? null : { wave : inp.audio.mSound.mFreqData, info : inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                }
            }

            if( inp.loaded===true )
            {
                times[i] = inp.audio.currentTime;
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;

                if( inp.audio.mForceMuted === true )
                {
                    times[i] = 10.0 + time;
                    let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.audio.mSound.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                  //let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.audio.mSound.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }

                }

      	        if( inp.audio.mPaused === false )
                {
      	            let waveLen = Math.min(inp.audio.mSound.mWaveData.length, 512);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512, 1, inp.audio.mSound.mFreqData);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 1, 512, 1, inp.audio.mSound.mWaveData);
                }

                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                    times[i] = 10.0 + time;
                    let num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                    //var num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }
            }
            else
            {
                inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
            }

            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave:inp.mFreqData}, false, 5, 1, -1, this.mID );

            if( inp.loaded===true )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                let waveLen = Math.min( inp.mWaveData.length, 512 );
                this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512,     1, inp.mFreqData);
                this.mRenderer.UpdateTexture(inp.globject, 0, 1, waveLen, 1, inp.mWaveData);
                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            let id = inp.id;
            if( inp.loaded===true  )
            {
                texID[i] = buffers[id].mTexture[ buffers[id].mLastRenderDone ];
                texIsLoaded[i] = 1;
                resos[3*i+0] = xres;
                resos[3*i+1] = yres;
                resos[3*i+2] = 1;
                // hack. in webgl2.0 we have samplers, so we don't need this crap here
                let filter = this.mRenderer.FILTER.NONE;
                     if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                this.mRenderer.SetSamplerFilter( texID[i], filter, false);
            }

            if( this.mTextureCallbackFun!==null )
            {
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:buffers[id].mThumbnailBuffer}, false, 9, 1, -1, this.mID );
            }
        }
    }

    this.mRenderer.AttachTextures( 4, texID[0], texID[1], texID[2], texID[3] );

    //-----------------------------------

    let prog = this.mProgram;

    //if( vrData!=null && this.mSupportsVR ) prog = this.mProgramVR;



    this.mRenderer.AttachShader(prog);

    this.mRenderer.SetShaderConstant1F(  "iTime", time);
    this.mRenderer.SetShaderConstant3F(  "iResolution", xres, yres, 1.0);
    this.mRenderer.SetShaderConstant4FV( "iMouse", mouse);
    this.mRenderer.SetShaderConstant1FV( "iChannelTime", times );              // OBSOLETE
    this.mRenderer.SetShaderConstant4FV( "iDate", dates );
    this.mRenderer.SetShaderConstant3FV( "iChannelResolution", resos );        // OBSOLETE
    this.mRenderer.SetShaderConstant1F(  "iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit( "iChannel0", 0 );
    this.mRenderer.SetShaderTextureUnit( "iChannel1", 1 );
    this.mRenderer.SetShaderTextureUnit( "iChannel2", 2 );
    this.mRenderer.SetShaderTextureUnit( "iChannel3", 3 );
    this.mRenderer.SetShaderConstant1I(  "iFrame", this.mFrame );
    this.mRenderer.SetShaderConstant1F(  "iTimeDelta", dtime);
    this.mRenderer.SetShaderConstant1F(  "iFrameRate", fps );

    this.mRenderer.SetShaderConstant1F(  "iCh0.time", times[0] );
    this.mRenderer.SetShaderConstant1F(  "iCh1.time", times[1] );
    this.mRenderer.SetShaderConstant1F(  "iCh2.time", times[2] );
    this.mRenderer.SetShaderConstant1F(  "iCh3.time", times[3] );
    this.mRenderer.SetShaderConstant3F(  "iCh0.size", resos[0], resos[ 1], resos[ 2] );
    this.mRenderer.SetShaderConstant3F(  "iCh1.size", resos[3], resos[ 4], resos[ 5] );
    this.mRenderer.SetShaderConstant3F(  "iCh2.size", resos[6], resos[ 7], resos[ 8] );
    this.mRenderer.SetShaderConstant3F(  "iCh3.size", resos[9], resos[10], resos[11] );
    this.mRenderer.SetShaderConstant1I(  "iCh0.loaded",       texIsLoaded[0] );
    this.mRenderer.SetShaderConstant1I(  "iCh1.loaded",       texIsLoaded[1] );
    this.mRenderer.SetShaderConstant1I(  "iCh2.loaded",       texIsLoaded[2] );
    this.mRenderer.SetShaderConstant1I(  "iCh3.loaded",       texIsLoaded[3] );

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");


    if( (vrData !== null) && this.mSupportsVR )
    {
        for (let i=0; i<2; i++ )
        {
            let ei = (i===0) ? vrData.mLeftEye : vrData.mRightEye;

            let vp = [i * xres / 2, 0, xres / 2, yres];

            this.mRenderer.SetViewport(vp);

            let fov = ei.mProjection;
            let corA = [ -fov[2], -fov[1], -1.0 ];
            let corB = [  fov[3], -fov[1], -1.0 ];
            let corC = [  fov[3],  fov[0], -1.0 ];
            let corD = [ -fov[2],  fov[0], -1.0 ];
            let apex = [ 0.0, 0.0, 0.0 ];

            let ma = invertFast( ei.mCamera );
            corA = matMulpoint( ma, corA ); 
            corB = matMulpoint( ma, corB ); 
            corC = matMulpoint( ma, corC ); 
            corD = matMulpoint( ma, corD ); 
            apex = matMulpoint( ma, apex ); 

            let corners = [ corA[0], corA[1], corA[2], 
                            corB[0], corB[1], corB[2], 
                            corC[0], corC[1], corC[2], 
                            corD[0], corD[1], corD[2],
                            apex[0], apex[1], apex[2]];

            this.mRenderer.SetShaderConstant3FV("unCorners", corners);
            this.mRenderer.SetShaderConstant4FV("unViewport", vp);

            this.mRenderer.DrawUnitQuad_XY(l1);
        }
    }
    else 
    {
        this.mRenderer.SetViewport([0, 0, xres, yres]);
        this.mRenderer.DrawFullScreenTriangle_XY( l1 );
    }

    this.mRenderer.DettachTextures();
}

EffectPass.prototype.iRenderSound = function(d, callback )
{
    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds() ];

    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];

    this.mRenderer.SetRenderTarget(this.mRenderFBO);

    this.mRenderer.SetViewport([0, 0, this.mTextureDimensions, this.mTextureDimensions]);
    this.mRenderer.AttachShader(this.mProgram);
    this.mRenderer.SetBlend( false );

    let texID = [null, null, null, null];
    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
    }

    this.mRenderer.AttachTextures(4, texID[0], texID[1], texID[2], texID[3]);

    let l2 = this.mRenderer.SetShaderConstantLocation(this.mProgram, "iTimeOffset");
    let l3 = this.mRenderer.SetShaderConstantLocation(this.mProgram, "iSampleOffset");
    this.mRenderer.SetShaderConstant4FV("iDate", dates);
    this.mRenderer.SetShaderConstant3FV("iChannelResolution", resos);
    this.mRenderer.SetShaderConstant1F("iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit("iChannel0", 0);
    this.mRenderer.SetShaderTextureUnit("iChannel1", 1);
    this.mRenderer.SetShaderTextureUnit("iChannel2", 2);
    this.mRenderer.SetShaderTextureUnit("iChannel3", 3);

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    //--------------------------------
    let numSamples = this.mTmpBufferSamples;
    let numBlocks = this.mPlaySamples / numSamples;
    for (let j=0; j<numBlocks; j++ )
    {
        let off = j*numSamples;
        
        this.mRenderer.SetShaderConstant1F_Pos(l2, off / this.mSampleRate);
        this.mRenderer.SetShaderConstant1I_Pos(l3, off );
        this.mRenderer.DrawUnitQuad_XY(l1);

        this.mRenderer.GetPixelData(this.mData, 0, this.mTextureDimensions, this.mTextureDimensions);

        callback( off, this.mData, numSamples );
    }

    this.mRenderer.DetachShader();
    this.mRenderer.DettachTextures();
    this.mRenderer.SetRenderTarget(null);
}

EffectPass.prototype.Paint_Sound = function( wa, d )
{
    let bufL = this.mBuffer.getChannelData(0); // Float32Array
    let bufR = this.mBuffer.getChannelData(1); // Float32Array

    this.iRenderSound( d, function(off, data, numSamples)
                         {
                            for( let i=0; i<numSamples; i++ )
                            {
                                bufL[off+i] = -1.0 + 2.0*(data[4*i+0]+256.0*data[4*i+1])/65535.0;
                                bufR[off+i] = -1.0 + 2.0*(data[4*i+2]+256.0*data[4*i+3])/65535.0;
                            }
                         }
                     );
}

EffectPass.prototype.SetUniforms = function(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    let times = [ 0.0, 0.0, 0.0, 0.0 ];

    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds()  + d.getMilliseconds()/1000.0 ];

    let mouse = [  mousePosX, mousePosY, mouseOriX, mouseOriY ];

    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];

    //------------------------
    
    let texID = [ null, null, null, null];

    for( let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            texID[i] = keyboard.mTexture;
        }
        else if( inp.mInfo.mType=="cubemap" )
        {
            if (inp.loaded === true)
            {
                let id = assetID_to_cubemapBuferID(inp.mInfo.mID);
                if( id!==-1 )
                {
                    texID[i] = cubeBuffers[id].mTexture[ cubeBuffers[id].mLastRenderDone ];
                    resos[3*i+0] = cubeBuffers[id].mResolution[0];
                    resos[3*i+1] = cubeBuffers[id].mResolution[1];
                    resos[3*i+2] = 1;
    
                    // hack. in webgl2.0 we have samplers, so we don't need this crap here
                    let filter = this.mRenderer.FILTER.NONE;
                         if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                    else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                    this.mRenderer.SetSamplerFilter( texID[i], filter, false);
                }
                else
                {
                    texID[i] = inp.globject;
                }
            }

        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    texID[i] = inp.globject;
                    resos[3*i+0] = inp.mImage.width;
                    resos[3*i+1] = inp.mImage.height;
                    resos[3*i+2] = 1;
                }
                else  if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {
                    texID[i] = inp.globject;
                    resos[3*i+0] = inp.video.videoWidth;
                    resos[3*i+1] = inp.video.videoHeight;
                    resos[3*i+2] = 1;
                }
            }
            else 
            {
                texID[i] = null;
                resos[3*i+0] = inp.video.width;
                resos[3*i+1] = inp.video.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
           if( inp.loaded===true )
           { 
                times[i] = inp.video.currentTime;
                texID[i] = inp.globject;
                resos[3*i+0] = inp.video.videoWidth;
                resos[3*i+1] = inp.video.videoHeight;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.loaded===true )
            {
                times[i] = inp.audio.currentTime;
                texID[i] = inp.globject;

                if( inp.audio.mForceMuted === true )
                {
                    times[i] = 10.0 + time;
                }

                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                times[i] = 10.0 + time;
            }

            if( inp.loaded===true )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = buffers[inp.id].mTexture[ buffers[inp.id].mLastRenderDone ];
                resos[3*i+0] = buffers[inp.id].mResolution[0];
                resos[3*i+1] = buffers[inp.id].mResolution[1];
                resos[3*i+2] = 1;
            }
        }
    }

    this.mRenderer.AttachTextures( 4, texID[0], texID[1], texID[2], texID[3] );

    //-----------------------------------

    this.mRenderer.AttachShader(this.mProgram);

    this.mRenderer.SetShaderConstant1F(  "iTime", time);
    this.mRenderer.SetShaderConstant3F(  "iResolution", xres, yres, 1.0);
    this.mRenderer.SetShaderConstant4FV( "iMouse", mouse);
    this.mRenderer.SetShaderConstant1FV( "iChannelTime", times );              // OBSOLETE
    this.mRenderer.SetShaderConstant4FV( "iDate", dates );
    this.mRenderer.SetShaderConstant3FV( "iChannelResolution", resos );        // OBSOLETE
    this.mRenderer.SetShaderConstant1F(  "iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit( "iChannel0", 0 );
    this.mRenderer.SetShaderTextureUnit( "iChannel1", 1 );
    this.mRenderer.SetShaderTextureUnit( "iChannel2", 2 );
    this.mRenderer.SetShaderTextureUnit( "iChannel3", 3 );
    this.mRenderer.SetShaderConstant1I(  "iFrame", this.mFrame );
    this.mRenderer.SetShaderConstant1F(  "iTimeDelta", dtime);
    this.mRenderer.SetShaderConstant1F(  "iFrameRate", fps );

    this.mRenderer.SetShaderConstant1F(  "iChannel[0].time",       times[0] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[1].time",       times[1] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[2].time",       times[2] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[3].time",       times[3] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[0].resolution", resos[0], resos[ 1], resos[ 2] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[1].resolution", resos[3], resos[ 4], resos[ 5] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[2].resolution", resos[6], resos[ 7], resos[ 8] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[3].resolution", resos[9], resos[10], resos[11] );
}

EffectPass.prototype.ProcessInputs = function(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
        }
        else if( inp.mInfo.mType==="volume" )
        {
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mImage, false, 7, 1, -1, this.mID );
                }
                else if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 7, 1, -1, this.mID );

                    this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.mPaused === false )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, inp.video.currentTime, this.mID );
            }

            if( inp.loaded===true )
            { 
      	        if( inp.video.mPaused === false )
      	        {
      	            this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.audio.mPaused === false && inp.audio.mForceMuted === false && inp.loaded===true )
            {
                if( wa !== null )
                {
                    inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                    inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                }

                if( this.mTextureCallbackFun!==null )
                {
                         if( inp.mInfo.mType==="music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa == null) ? null : { wave : inp.audio.mSound.mFreqData }, false, 4, 1, inp.audio.currentTime, this.mID);
                    else if( inp.mInfo.mType==="musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa == null) ? null : { wave : inp.audio.mSound.mFreqData, info : inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                }
            }

            if( inp.loaded===true )
            {
                if( inp.audio.mForceMuted === true )
                {
                    let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.audio.mSound.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                  //let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.audio.mSound.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }

                }

      	        if( inp.audio.mPaused === false )
                {
      	            let waveLen = Math.min(inp.audio.mSound.mWaveData.length, 512);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512, 1, inp.audio.mSound.mFreqData);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 1, 512, 1, inp.audio.mSound.mWaveData);
                }
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                    let num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                    for( let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }
            }
            else
            {
                inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
            }

            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave:inp.mFreqData}, false, 5, 1, -1, this.mID );

            if( inp.loaded===true )
            {
                let waveLen = Math.min( inp.mWaveData.length, 512 );
                this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512,     1, inp.mFreqData);
                this.mRenderer.UpdateTexture(inp.globject, 0, 1, waveLen, 1, inp.mWaveData);
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded===true  )
            {
                let id = inp.id;
                let texID = buffers[id].mTexture[ buffers[id].mLastRenderDone ];

                // hack. in webgl2.0 we have samplers, so we don't need this crap here
                let filter = this.mRenderer.FILTER.NONE;
                     if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                this.mRenderer.SetSamplerFilter( texID, filter, false);
            }

            if( this.mTextureCallbackFun!==null )
            {
				let id = inp.id;
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:buffers[id].mThumbnailBuffer}, false, 9, 1, -1, this.mID );
            }
        }
    }
}

EffectPass.prototype.Paint_Cubemap = function( vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face )
{
    this.ProcessInputs(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face );
    this.SetUniforms(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    let vp = [0, 0, xres, yres];

    this.mRenderer.SetViewport(vp);

    let corA = [ -1.0, -1.0, -1.0 ];
    let corB = [  1.0, -1.0, -1.0 ];
    let corC = [  1.0,  1.0, -1.0 ];
    let corD = [ -1.0,  1.0, -1.0 ];
    let apex = [  0.0,  0.0,  0.0 ];

    if( face===0 )
    {
        corA = [  1.0,  1.0,  1.0 ];
        corB = [  1.0,  1.0, -1.0 ];
        corC = [  1.0, -1.0, -1.0 ];
        corD = [  1.0, -1.0,  1.0 ];
    }
    else if( face===1 ) // -X
    {
        corA = [ -1.0,  1.0, -1.0 ];
        corB = [ -1.0,  1.0,  1.0 ];
        corC = [ -1.0, -1.0,  1.0 ];
        corD = [ -1.0, -1.0, -1.0 ];
    }
    else if( face===2 ) // +Y
    {
        corA = [ -1.0,  1.0, -1.0 ];
        corB = [  1.0,  1.0, -1.0 ];
        corC = [  1.0,  1.0,  1.0 ];
        corD = [ -1.0,  1.0,  1.0 ];
    }
    else if( face===3 ) // -Y
    {
        corA = [ -1.0, -1.0,  1.0 ];
        corB = [  1.0, -1.0,  1.0 ];
        corC = [  1.0, -1.0, -1.0 ];
        corD = [ -1.0, -1.0, -1.0 ];
    }
    else if( face===4 ) // +Z
    {
        corA = [ -1.0,  1.0,  1.0 ];
        corB = [  1.0,  1.0,  1.0 ];
        corC = [  1.0, -1.0,  1.0 ];
        corD = [ -1.0, -1.0,  1.0 ];
    }
    else //if( face===5 ) // -Z
    {
        corA = [  1.0,  1.0, -1.0 ];
        corB = [ -1.0,  1.0, -1.0 ];
        corC = [ -1.0, -1.0, -1.0 ];
        corD = [  1.0, -1.0, -1.0 ];
    }

    let corners = [ corA[0], corA[1], corA[2], 
                    corB[0], corB[1], corB[2], 
                    corC[0], corC[1], corC[2], 
                    corD[0], corD[1], corD[2],
                    apex[0], apex[1], apex[2]];

    this.mRenderer.SetShaderConstant3FV("unCorners", corners);
    this.mRenderer.SetShaderConstant4FV("unViewport", vp);

    this.mRenderer.DrawUnitQuad_XY(l1);

    this.mRenderer.DettachTextures();
}


EffectPass.prototype.Paint = function( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, bufferNeedsMimaps, buffers, cubeBuffers, keyboard, effect )
{
    if( this.mType==="sound" )
    {
        if (this.mSoundShaderCompiled === true)
        {
            // make sure all textures are loaded
            for (let i=0; i<this.mInputs.length; i++ )
            {
                let inp = this.mInputs[i];
                if (inp === null) continue;

                if (inp.mInfo.mType === "texture" && !inp.loaded) return;
                if (inp.mInfo.mType === "cubemap" && !inp.loaded) return;
            }

            this.Paint_Sound(wa, da);
            this.mSoundShaderCompiled = false;
        }
        if (this.mFrame === 0)
        {
            if (this.mPlaying===true)
            {
                this.mPlayNode.disconnect();
                this.mPlayNode.stop();
                this.mPlayNode = null;
            }
            this.mPlaying = true;

            this.mPlayNode = wa.createBufferSource();
            this.mPlayNode.buffer = this.mBuffer;
            this.mPlayNode.connect(this.mGainNode);
            this.mPlayNode.start(0);
        }
        this.mFrame++;
    }
    else if( this.mType==="image" )
    {
        this.mRenderer.SetRenderTarget( null );
        this.Paint_Image( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );
        this.mFrame++;
    }
    else if( this.mType==="common" )
    {
        //console.log("rendering common");
    }
    else if( this.mType==="buffer" )
    {
        this.mEffect.ResizeBuffer(bufferID, this.mEffect.mXres, this.mEffect.mYres, false );

        let buffer = buffers[bufferID];

        let dstID = 1 - buffer.mLastRenderDone;

        this.mRenderer.SetRenderTarget( buffer.mTarget[dstID] );
        this.Paint_Image( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );

        // compute mipmaps if needd
        if( bufferNeedsMimaps )
        {
            this.mRenderer.CreateMipmaps( buffer.mTexture[dstID]);
        }

        // make thumbnail
        //if( this.mTextureCallbackFun != null )
        /*
        {
            this.mRenderer.SetRenderTarget( buffer.mThumbnailRenderTarget );
            let v = [0, 0, buffer.mThumbnailRes[0], buffer.mThumbnailRes[1]];
            this.mRenderer.SetBlend(false);
            this.mRenderer.SetViewport(v);
            this.mRenderer.AttachShader(this.mProgramCopy);
            let l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, "pos");
            this.mRenderer.SetShaderConstant4FV("v", v);
            this.mRenderer.AttachTextures(1, buffer.mTexture[dstID], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);
            this.mRenderer.DettachTextures();
            this.mRenderer.DetachShader();
            this.mRenderer.GetPixelData( new Uint8Array(buffer.mThumbnailBuffer.data.buffer), buffer.mThumbnailRes[0], buffer.mThumbnailRes[1] );
            this.mRenderer.SetRenderTarget(null);
        }
        */
        buffers[bufferID].mLastRenderDone = 1 - buffers[bufferID].mLastRenderDone;
        this.mFrame++;
    }
    else if( this.mType==="cubemap" )
    {
        this.mEffect.ResizeCubemapBuffer(bufferID, 1024, 1024, false );

        let buffer = cubeBuffers[bufferID];

        xres = buffer.mResolution[0];
        yres = buffer.mResolution[1];
        let dstID = 1 - buffer.mLastRenderDone;
        for( let face=0; face<6; face++ )
        {
            this.mRenderer.SetRenderTargetCubeMap( buffer.mTarget[dstID], face );
            this.Paint_Cubemap( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face );
        }
        this.mRenderer.SetRenderTargetCubeMap( null, 0 );

        // compute mipmaps if needd
        if( bufferNeedsMimaps )
        {
            this.mRenderer.CreateMipmaps( buffer.mTexture[dstID]);
        }
        cubeBuffers[bufferID].mLastRenderDone = 1 - cubeBuffers[bufferID].mLastRenderDone;

        this.mFrame++;
    }

}

EffectPass.prototype.StopOutput_Sound = function( wa )
{
    if( this.mPlayNode===null ) return;
    this.mPlayNode.disconnect();

};

EffectPass.prototype.ResumeOutput_Sound = function( wa )
{
    if( this.mPlayNode===null ) return;

    wa.resume()
    this.mPlayNode.connect( this.mGainNode );
};

EffectPass.prototype.StopOutput_Image = function( wa )
{
};

EffectPass.prototype.ResumeOutput_Image = function( wa )
{
};

EffectPass.prototype.StopOutput = function( wa )
{
    for (let j=0; j<this.mInputs.length; j++ )
        this.StopInput(j);

    if( this.mType==="sound" )
         this.StopOutput_Sound( wa );
    else
         this.StopOutput_Image( wa );
}

EffectPass.prototype.ResumeOutput = function( wa )
{
    for (let j=0; j<this.mInputs.length; j++ )
        this.ResumeInput(j);

    if( this.mType==="sound" )
         this.ResumeOutput_Sound( wa );
    else
         this.ResumeOutput_Image( wa );
}

EffectPass.prototype.GetCompilationTime = function()
{
    return this.mCompilationTime;
}

//============================================================================================================
function Screenshots()
{
    // private
    let mTexture = null;
    let mTarget = null;
    let mXres = 0;
    let mYres = 0;
    let mCubemapToEquirectProgram;
    let mRenderer = null;

    // public
    var me = {};

    me.Initialize = function(renderer)
    {
        mRenderer = renderer;
        let caps = mRenderer.GetCaps();
        let is20 = caps.mIsGL20;


        let vsSourceC, fsSourceC;
        if( is20 )
        {
            vsSourceC = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
            fsSourceC = "uniform samplerCube t; out vec4 outColor; void main() { vec2 px = gl_FragCoord.xy/vec2(4096.0,2048.0); vec2 an = 3.1415926535898 * (px*vec2(2.0, 1.0) - vec2(0.0,0.5)); vec3 rd = vec3(-cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x)); outColor = texture(t, rd); }";
        }
        else
        {
            vsSourceC = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
            fsSourceC = "uniform samplerCube t; void main() { vec2 px = gl_FragCoord.xy/vec2(4096.0,2048.0); vec2 an = 3.1415926535898 * (px*vec2(2.0, 1.0) - vec2(0.0,0.5)); vec3 rd = vec3(-cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x)); gl_FragColor = texture(t, rd); }";
        }

        let compileShader = function (worked, info)
        {
            if (worked === false)
            {
                console.log("Failed to compile cubemap resample shader (" + errorType + "): " + log);
            }
            else
            {
                mCubemapToEquirectProgram = info;
            }
        }
        mRenderer.CreateShader(vsSourceC, fsSourceC, false, true, compileShader);

        return true;
    };

    me.Allocate = function( xres, yres )
    {
        if( xres>mXres || yres>mYres )
        {
            let texture = mRenderer.CreateTexture(mRenderer.TEXTYPE.T2D, xres, yres, mRenderer.TEXFMT.C4F32, mRenderer.FILTER.NONE, mRenderer.TEXWRP.CLAMP, null);
            let target = mRenderer.CreateRenderTarget( texture, null, null, null, null, false);

            if( mXres!==0 )
            {
                mRenderer.DestroyTexture(mTexture);
                mRenderer.DestroyRenderTarget(mTarget);
            }

            mTexture = texture;
            mTarget = target;
            mXres = xres;
            mYres = yres;
        }
    };

    me.GetProgram = function()
    {
        return mCubemapToEquirectProgram;
    };
    me.GetTarget = function()
    {
        return mTarget;
    };

    return me;
};

//============================================================================================================

function Effect(vr, ac, canvas, callback, obj, forceMuted, forcePaused, resizeCallback, crashCallback )
{
    let xres = canvas.width;
    let yres = canvas.height;

    let me = this;
    this.mCanvas = canvas;
    this.mCreated = false;
    this.mRenderer = null;
    this.mAudioContext = ac;
    this.mGLContext = null;
    this.mWebVR = vr;
    this.mRenderingStereo = false;
    this.mXres = xres;
    this.mYres = yres;
    this.mForceMuted = forceMuted;
    if( ac===null ) this.mForceMuted = true;
    this.mForcePaused = forcePaused;
    this.mGainNode = null;
    this.mPasses = [];
    this.mFrame = 0;
    this.mTextureCallbackFun = callback;
    this.mTextureCallbackObj = obj;
    this.mMaxBuffers = 4;
    this.mMaxCubeBuffers = 1;
    this.mMaxPasses = this.mMaxBuffers + 1 + 1 + 1 + 1; // some day decouple passes from buffers (4 buffers + common + Imagen + sound + cubemap)
    this.mBuffers = [];
    this.mCubeBuffers = [];
    this.mScreenshotSytem = null;
    this.mCompilationTime = 0;
    this.mIsLowEnd = piIsMobile();

    this.mGLContext = piCreateGlContext(canvas, false, false, true, false); // need preserve-buffe to true in order to capture screenshots
    if (this.mGLContext === null)
    {
        return;
    }

    canvas.addEventListener("webglcontextlost", function (event)
        {
            event.preventDefault();
            crashCallback();
        }, false);

    this.mRenderer = piRenderer();
    if (!this.mRenderer.Initialize(this.mGLContext))
        return;

    this.mScreenshotSytem = Screenshots();
    if (!this.mScreenshotSytem.Initialize(this.mRenderer))
        return;

    var caps = this.mRenderer.GetCaps();
    this.mIs20 = caps.mIsGL20;
    this.mShaderTextureLOD = caps.mShaderTextureLOD;
    //-------------
    if( ac!==null )
    {   
        this.mGainNode = ac.createGain();
        if( !forceMuted )
        {
            this.mGainNode.connect( ac.destination);
        }
        if (this.mForceMuted )
            this.mGainNode.gain.value = 0.0;
        else
            this.mGainNode.gain.value = 1.0;
    }

    //-------------
    let vsSourceC, fsSourceC;
    if( this.mIs20 )
    {
        vsSourceC = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceC = "uniform vec4 v; uniform sampler2D t; out vec4 outColor; void main() { outColor = textureLod(t, gl_FragCoord.xy / v.zw, 0.0); }";
    }
    else
    {
        vsSourceC = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceC = "uniform vec4 v; uniform sampler2D t; void main() { gl_FragColor = texture2D(t, gl_FragCoord.xy / v.zw, -100.0); }";
    }

    this.mRenderer.CreateShader(vsSourceC, fsSourceC, false, true, function(worked, info)
        {
            if (worked === false) console.log("Failed to compile shader to copy buffers : " + info.mErrorStr);
            else me.mProgramCopy = info;
        });

    let vsSourceD, fsSourceD;
    if( this.mIs20 )
    {
        vsSourceD = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceD = "uniform vec4 v; uniform sampler2D t; out vec4 outColor; void main() { vec2 uv = gl_FragCoord.xy / v.zw; outColor = texture(t, vec2(uv.x,1.0-uv.y)); }";
    }
    else
    {
        vsSourceD = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceD = "uniform vec4 v; uniform sampler2D t; void main() { vec2 uv = gl_FragCoord.xy / v.zw; gl_FragColor = texture2D(t, vec2(uv.x,1.0-uv.y)); }";
    }

    this.mRenderer.CreateShader(vsSourceD, fsSourceD, false, true, function (worked, info)
        {
            if (worked === false) console.log("Failed to compile shader to downscale buffers : " + info.mErrorStr);
            else me.mProgramDownscale = info;
        });


    // set all buffers and cubemaps to null
    for( let i=0; i<this.mMaxBuffers; i++ )
    {
        this.mBuffers[i] = { mTexture: [null, null], 
                             mTarget:  [null, null], 
                             mResolution: [0, 0],
                             mLastRenderDone: 0,
                             mThumbnailRenderTarget: null,
                             mThumbnailTexture: null,
                             mThumbnailBuffer:  null,
                             mThumbnailRes: [0, 0] };
    }

    for( let i=0; i<this.mMaxCubeBuffers; i++ )
    {
        this.mCubeBuffers[i] = { mTexture: [null, null], 
                                mTarget:  [null, null], 
                                mResolution: [0, 0],
                                mLastRenderDone: 0,
                                mThumbnailRenderTarget: null,
                                mThumbnailTexture: null,
                                mThumbnailBuffer:  null,
                                mThumbnailRes: [0, 0] };
    }

    //-------

    let keyboardData = new Uint8Array( 256*3 );
    for (let j=0; j<(256*3); j++ ) { keyboardData[j] = 0; }
    let kayboardTexture = this.mRenderer.CreateTexture( this.mRenderer.TEXTYPE.T2D, 256, 3, this.mRenderer.TEXFMT.C1I8, this.mRenderer.FILTER.NONE, this.mRenderer.TEXWRP.CLAMP, null);
    let keyboardImage = new Image();
    if( callback!==null )
        keyboardImage.src = "/img/keyboard.png"; // don't load PNG if no UI 
    this.mKeyboard = { mData: keyboardData, mTexture: kayboardTexture, mIcon: keyboardImage };

    let iResize = function( xres, yres )
    {
        me.mCanvas.width = xres;
        me.mCanvas.height = yres;
        me.mXres = xres;
        me.mYres = yres;
        me.ResizeBuffers(xres, yres);
        resizeCallback(xres, yres);
    };

    let bestAttemptFallback = function()
    {
        let devicePixelRatio = window.devicePixelRatio || 1;
        let xres = Math.round(me.mCanvas.offsetWidth  * devicePixelRatio) | 0;
        let yres = Math.round(me.mCanvas.offsetHeight * devicePixelRatio) | 0;
        iResize(xres, yres);
    };

    if(!window.ResizeObserver)
    {
        console.log("WARNING: This browser doesn't support ResizeObserver.");
        bestAttemptFallback();
        window.addEventListener("resize", bestAttemptFallback);
    }
    else
    {
        this.mRO = new ResizeObserver( function(entries, observer)
        {
            var entry = entries[0];
            if (!entry['devicePixelContentBoxSize'])
            {
                observer.unobserve(me.mCanvas);
                console.log("WARNING: This browser doesn't support ResizeObserver + device-pixel-content-box (2)");
                bestAttemptFallback();
                window.addEventListener("resize", bestAttemptFallback);
            }
            else
            {
                let box = entry.devicePixelContentBoxSize[0];
                let xres = box.inlineSize;
                let yres = box.blockSize;
                iResize(xres, yres);
            }
        });
        try
        {
            this.mRO.observe(this.mCanvas, { box: ["device-pixel-content-box"] });
            //this.mRO.observe(this.mCanvas);
        }
        catch (e)
        {
            console.log("WARNING: This browser doesn't support ResizeObserver + device-pixel-content-box (1)");
            bestAttemptFallback();
            window.addEventListener("resize", bestAttemptFallback);
        }
    }

    this.mCreated = true;
}


Effect.prototype.ResizeCubemapBuffer = function(i, xres, yres )
{
    let oldXres = this.mCubeBuffers[i].mResolution[0];
    let oldYres = this.mCubeBuffers[i].mResolution[1];

    if( this.mCubeBuffers[i].mTexture[0]===null || oldXres !== xres || oldYres !== yres )
    {
        let texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.CUBEMAP,
            xres, yres,
            this.mRenderer.TEXFMT.C4F16,
            this.mRenderer.FILTER.LINEAR,
            this.mRenderer.TEXWRP.CLAMP, 
            null);
        let target1 = this.mRenderer.CreateRenderTargetCubeMap( texture1, null, false);

        let texture2 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.CUBEMAP,
            xres, yres,
            this.mRenderer.TEXFMT.C4F16,
            this.mRenderer.FILTER.LINEAR,
            this.mRenderer.TEXWRP.CLAMP, 
            null);

        let target2 = this.mRenderer.CreateRenderTargetCubeMap( texture2, null, false);

        // Store new buffers
        this.mCubeBuffers[i].mTexture = [texture1,texture2], 
        this.mCubeBuffers[i].mTarget =  [target1, target2 ], 
        this.mCubeBuffers[i].mLastRenderDone = 0;
        this.mCubeBuffers[i].mResolution[0] = xres;
        this.mCubeBuffers[i].mResolution[1] = yres;
    }
}


Effect.prototype.ResizeBuffer = function( i, xres, yres, skipIfNotExists )
{
    if( skipIfNotExists && this.mBuffers[i].mTexture[0]===null ) return;

    let oldXres = this.mBuffers[i].mResolution[0];
    let oldYres = this.mBuffers[i].mResolution[1];

    if( oldXres !== xres || oldYres !== yres )
    {
        let needCopy = (this.mBuffers[i].mTexture[0]!==null);

        let texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,
            xres, yres,
            this.mRenderer.TEXFMT.C4F32,
            (needCopy) ? this.mBuffers[i].mTexture[0].mFilter : this.mRenderer.FILTER.NONE,
            (needCopy) ? this.mBuffers[i].mTexture[0].mWrap   : this.mRenderer.TEXWRP.CLAMP, 
            null);

        let texture2 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,
            xres, yres,
            this.mRenderer.TEXFMT.C4F32,
            (needCopy) ? this.mBuffers[i].mTexture[1].mFilter : this.mRenderer.FILTER.NONE,
            (needCopy) ? this.mBuffers[i].mTexture[1].mWrap   : this.mRenderer.TEXWRP.CLAMP, 
            null);

        let target1 = this.mRenderer.CreateRenderTarget( texture1, null, null, null, null, false);
        let target2 = this.mRenderer.CreateRenderTarget( texture2, null, null, null, null, false);

        if( needCopy )
        {
            let v = [0, 0, Math.min(xres, oldXres), Math.min(yres, oldYres)];
            this.mRenderer.SetBlend(false);
            this.mRenderer.SetViewport(v);
            this.mRenderer.AttachShader(this.mProgramCopy);
            let l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, "pos");
            let vOld = [0, 0, oldXres, oldYres];
            this.mRenderer.SetShaderConstant4FV("v", vOld);

            // Copy old buffers 1 to new buffer
            this.mRenderer.SetRenderTarget(target1);
            this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[0], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);

            // Copy old buffers 2 to new buffer
            this.mRenderer.SetRenderTarget(target2);
            this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[1], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);

            // Deallocate old memory
            this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[0]);
            this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[0]);
            this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[1]);
            this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[1]);
            //this.mRenderer.DestroyTexture(this.mBuffers[i].thumbnailTexture);
        }

        // Store new buffers
        this.mBuffers[i].mTexture = [texture1,texture2], 
        this.mBuffers[i].mTarget =  [target1, target2 ], 
        this.mBuffers[i].mLastRenderDone = 0;
        this.mBuffers[i].mResolution[0] = xres;
        this.mBuffers[i].mResolution[1] = yres;
    }
}

Effect.prototype.saveScreenshot = function(passid)
{
    let pass = this.mPasses[passid];

    if( pass.mType === "buffer" )
    {
        let bufferID = assetID_to_bufferID( this.mPasses[passid].mOutputs[0] );

        let texture = this.mBuffers[bufferID].mTarget[ this.mBuffers[bufferID].mLastRenderDone ];

        let numComponents = 3;
        let width = texture.mTex0.mXres;
        let height = texture.mTex0.mYres;
        let type = "Float"; // Other options Float, Half, Uint
        let bytes = new Float32Array(width * height * 4 );//numComponents);
        this.mRenderer.GetPixelDataRenderTarget( texture, bytes, width, height );
        let blob = piExportToEXR(width, height, numComponents, type, bytes);

        // Offer download automatically to the user
        piTriggerDownload("image.exr", blob);
    }
    else if( pass.mType === "cubemap" )
    {
        let xres = 4096;
        let yres = 2048;
        this.mScreenshotSytem.Allocate( xres, yres );

        let cubeBuffer = this.mCubeBuffers[0];

        let target = this.mScreenshotSytem.GetTarget();
        this.mRenderer.SetRenderTarget( target );

        let program = this.mScreenshotSytem.GetProgram();

        this.mRenderer.AttachShader(program);
        let l1 = this.mRenderer.GetAttribLocation(program, "pos");
        this.mRenderer.SetViewport( [0, 0, xres, yres] );
        this.mRenderer.AttachTextures(1, cubeBuffer.mTexture[ cubeBuffer.mLastRenderDone ], null, null, null);
        this.mRenderer.DrawUnitQuad_XY(l1);
        this.mRenderer.DettachTextures();
        this.mRenderer.SetRenderTarget( null );

        let data = new Float32Array(xres*yres*4);
        this.mRenderer.GetPixelDataRenderTarget( target, data, xres, yres );

        let blob = piExportToEXR(xres, yres, 3, "Float", data );
        piTriggerDownload("image.exr", blob);
    }
    else if( pass.mType === "sound" )
    {
        let offset = 0;
        const bits = 16;
        const numChannels = 2;
        let words = new Int16Array(60*pass.mSampleRate*numChannels );

        pass.iRenderSound( new Date(), function(off, data, numSamples)
                                         {
                                            for( let i=0; i<numSamples; i++ )
                                            {
                                                words[offset++] = (data[4*i+0]+256.0*data[4*i+1]) - 32767;
                                                words[offset++] = (data[4*i+2]+256.0*data[4*i+3]) - 32767;
                                            }
                                         }
                                     );

        let blob = piExportToWAV( 60*pass.mSampleRate, pass.mSampleRate, bits, numChannels, words);

        piTriggerDownload("sound.wav", blob);
    }    
}

Effect.prototype.ResizeBuffers = function(xres, yres)
{
    for (let i=0; i<this.mMaxBuffers; i++ )
    {
        this.ResizeBuffer(i, xres, yres, true);
    }
}

Effect.prototype.IsEnabledVR = function ()
{
    if (this.mRenderingStereo) return true;
    return false;
}

Effect.prototype.EnableVR = function()
{
    if( !this.mWebVR.IsSupported() ) return;
    if( this.mRenderingStereo ) return;

    this.mRenderingStereo = true;
    this.mWebVR.Enable();
}

Effect.prototype.DisableVR = function()
{
    if( !this.mWebVR.IsSupported() ) return;
    if( !this.mRenderingStereo ) return;

    this.mRenderingStereo = false;
    this.mWebVR.Disable();
}

Effect.prototype.GetTexture = function( passid, slot )
{
    return this.mPasses[passid].GetTexture( slot );
}

Effect.prototype.NewTexture = function( passid, slot, url )
{
    return this.mPasses[passid].NewTexture( this.mAudioContext, slot, url, this.mBuffers, this.mCubeBuffers, this.mKeyboard );
}

Effect.prototype.SetOutputs = function( passid, slot, url )
{
    this.mPasses[passid].SetOutputs( slot, url );
}

Effect.prototype.SetOutputsByBufferID = function( passid, slot, id )
{
    this.mPasses[passid].SetOutputsByBufferID( slot, id );
}

Effect.prototype.GetAcceptsLinear = function (passid, slot) 
{
    return this.mPasses[passid].GetAcceptsLinear(slot);
}

Effect.prototype.GetAcceptsMipmapping = function (passid, slot) 
{
    return this.mPasses[passid].GetAcceptsMipmapping(slot);
}

Effect.prototype.GetAcceptsWrapRepeat = function (passid, slot) 
{
    return this.mPasses[passid].GetAcceptsWrapRepeat(slot);
}

Effect.prototype.GetAcceptsVFlip = function (passid, slot)
{
    return this.mPasses[passid].GetAcceptsVFlip(slot);
}

Effect.prototype.SetSamplerFilter = function (passid, slot, str) 
{
    this.mPasses[passid].SetSamplerFilter(slot, str, this.mBuffers, this.mCubeBuffers);
}

Effect.prototype.GetTranslatedShaderSource = function (passid)
{
    return this.mPasses[passid].GetTranslatedShaderSource();
}

Effect.prototype.GetSamplerFilter = function (passid, slot) {
    return this.mPasses[passid].GetSamplerFilter(slot);
}

Effect.prototype.SetSamplerWrap = function (passid, slot, str) {
    this.mPasses[passid].SetSamplerWrap(slot, str, this.mBuffers);
}

Effect.prototype.GetSamplerWrap = function (passid, slot) {
    return this.mPasses[passid].GetSamplerWrap(slot);
}

Effect.prototype.SetSamplerVFlip = function (passid, slot, str) {
    this.mPasses[passid].SetSamplerVFlip(slot, str);
}

Effect.prototype.GetSamplerVFlip = function (passid, slot) {
    return this.mPasses[passid].GetSamplerVFlip(slot);
}

Effect.prototype.GetHeaderSize = function (passid)
{
    return this.mPasses[passid].mHeaderLength + 
           this.mRenderer.GetShaderHeaderLines(1);
 
}

Effect.prototype.ToggleVolume = function()
{
    this.mForceMuted = !this.mForceMuted;

    // outp
    if (this.mForceMuted)
        this.mGainNode.gain.value = 0.0;
    else
        this.mGainNode.gain.value = 1.0;

    // inp
    let num = this.mPasses.length;
    for( let j=0; j<num; j++ )
    {
        for( let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            if( this.mForceMuted )
                this.mPasses[j].MuteInput( this.mAudioContext, i );
            else
                this.mPasses[j].UnMuteInput( this.mAudioContext, i );
        }
    }

    return this.mForceMuted;
}

Effect.prototype.SetKeyDown = function( passid, k )
{
    if( this.mKeyboard.mData[ k + 0*256 ] == 255 ) return;

    this.mKeyboard.mData[ k + 0*256 ] = 255;
    this.mKeyboard.mData[ k + 1*256 ] = 255;
    this.mKeyboard.mData[ k + 2*256 ] = 255 - this.mKeyboard.mData[ k + 2*256 ];
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    let num = this.mPasses.length;
    for (let j=0; j<num; j++ )
    {
        for (let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            let inp = this.mPasses[j].mInputs[i];
            if( inp!==null && inp.mInfo.mType==="keyboard" )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:this.mKeyboard.mIcon, mData: this.mKeyboard.mData}, false, 6, 1, -1.0, this.mPasses[j].mID );
            }
        }
    }
}

Effect.prototype.SetKeyUp = function( passid, k )
{
    this.mKeyboard.mData[ k + 0*256 ] = 0;
    this.mKeyboard.mData[ k + 1*256 ] = 0;
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    let num = this.mPasses.length;
    for (let j=0; j<num; j++ )
    {
        for (let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            let inp = this.mPasses[j].mInputs[i];
            if( inp!==null && inp.mInfo.mType==="keyboard" )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:this.mKeyboard.mIcon, mData: this.mKeyboard.mData}, false, 6, 1, -1.0, this.mPasses[j].mID );
            }
        }
    }

}

Effect.prototype.StopOutputs = function()
{
    let wa = this.mAudioContext;

    let num = this.mPasses.length;
    for (let i=0; i<num; i++ )
    {
        this.mPasses[i].StopOutput( wa );
    }
}

Effect.prototype.ResumeOutputs = function()
{
    let wa = this.mAudioContext;

    let num = this.mPasses.length;
    for (let i=0; i<num; i++ )
    {
        this.mPasses[i].ResumeOutput( wa );
    }
}

Effect.prototype.PauseInput = function( passid, id )
{
    return this.mPasses[passid].TooglePauseInput( this.mAudioContext, id );
}

Effect.prototype.ToggleMuteInput = function( passid, id )
{
    return this.mPasses[passid].ToggleMuteInput( this.mAudioContext, id );
}

Effect.prototype.RewindInput = function( passid, id )
{
    this.mPasses[passid].RewindInput( this.mAudioContext, id );
}

Effect.prototype.UpdateInputs = function( passid, forceUpdate )
{
   this.mPasses[passid].UpdateInputs( this.mAudioContext, forceUpdate, this.mKeyboard );
}

Effect.prototype.ResetTime = function()
{
    this.mFrame = 0;
    this.mAudioContext.resume()

    let num = this.mPasses.length;
    for( let i=0; i<num; i++ )
    {
        this.mPasses[i].mFrame = 0;
        for( let j=0; j<this.mPasses[i].mInputs.length; j++ )
            this.mPasses[i].RewindInput(this.mAudioContext, j)
    }
}

Effect.prototype.RequestAnimationFrame = function (id)
{
    if (this.mRenderingStereo && this.mWebVR.IsPresenting())
    {
        this.mWebVR.RequestAnimationFrame(id);
    }
    else
    {
        requestAnimFrame(id);
    }
}

Effect.prototype.Paint = function(time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, isPaused)
{
    let wa = this.mAudioContext;
    let da = new Date();
    let vrData = null; if (this.mRenderingStereo) vrData = this.mWebVR.GetData();
    let xres = this.mXres / 1;
    let yres = this.mYres / 1;

    if( this.mFrame===0 )
    {
        for( let i=0; i<this.mMaxBuffers; i++ )
        {
            if( this.mBuffers[i].mTexture[0]!==null )
            {
                this.mRenderer.SetRenderTarget( this.mBuffers[i].mTarget[0] );
                this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
                this.mRenderer.SetRenderTarget( this.mBuffers[i].mTarget[1] );
                this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
				
				this.mRenderer.CreateMipmaps( this.mBuffers[i].mTexture[0] );
				this.mRenderer.CreateMipmaps( this.mBuffers[i].mTexture[1] );
            }
        }
        for( let i=0; i<this.mMaxCubeBuffers; i++ )
        {
            if( this.mCubeBuffers[i].mTexture[0]!==null )
            {
                for( let face=0; face<6; face++ )
                {
                    this.mRenderer.SetRenderTargetCubeMap( this.mCubeBuffers[i].mTarget[0], face );
                    this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
                    this.mRenderer.SetRenderTargetCubeMap( this.mCubeBuffers[i].mTarget[1], face );
                    this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
					this.mRenderer.CreateMipmaps( this.mCubeBuffers[i].mTexture[0] );
				    this.mRenderer.CreateMipmaps( this.mCubeBuffers[i].mTexture[1] );
                }
            }
        }
    }

    let num = this.mPasses.length;

    // render sound first
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "sound" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, null, false, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render buffers second
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "buffer" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        let bufferID = assetID_to_bufferID( this.mPasses[i].mOutputs[0] );

        // check if any downstream pass needs mipmaps when reading from this buffer
        let needMipMaps = false;
        for (let j=0; j<num; j++ )
        {
            for (let k=0; k<this.mPasses[j].mInputs.length; k++ )
            {
                let inp = this.mPasses[j].mInputs[k];
                if( inp!==null && inp.mInfo.mType==="buffer" && inp.id === bufferID && inp.mInfo.mSampler.filter === "mipmap")
                {
                    needMipMaps = true;
                    break;
                }
            }
        }

        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, needMipMaps, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }


    // render cubemap buffers second
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "cubemap" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        let bufferID = 0;//assetID_to_bufferID( this.mPasses[i].mOutputs[0] );

        // check if any downstream pass needs mipmaps when reading from this buffer
        let needMipMaps = false;

        for (let j=0; j<num; j++ )
        {
            for (let k=0; k<this.mPasses[j].mInputs.length; k++ )
            {
                let inp = this.mPasses[j].mInputs[k];
                if( inp!==null && inp.mInfo.mType==="cubemap" )
                {
                    if( assetID_to_cubemapBuferID(inp.mInfo.mID)===0 && inp.mInfo.mSampler.filter === "mipmap" )
                    {
                        needMipMaps = true;
                        break;
                    }
                }
            }
        }

        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, needMipMaps, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render image last
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "image" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, null, false, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }   

    // erase keypresses
    for (let k=0; k<256; k++ )
    {
       this.mKeyboard.mData[ k + 1*256 ] = 0;
    }
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    if( this.mRenderingStereo ) this.mWebVR.Finish();

    this.mFrame++;
}

Effect.prototype.NewShader = function( passid, preventCache, onResolve )
{
    let commonSourceCodes = [];
    for (let i=0; i<this.mPasses.length; i++ )
    {
        if( this.mPasses[i].mType==="common")
        {
            commonSourceCodes.push(this.mPasses[i].mSource);
        }
    }

    this.mPasses[passid].NewShader(commonSourceCodes, preventCache, onResolve );
}

Effect.prototype.GetNumPasses = function()
{
    return this.mPasses.length;
}

Effect.prototype.GetNumOfType = function(passtype)
{
    let id = 0;
    for (let j=0; j<this.mPasses.length; j++ )
    {
        if( this.mPasses[j].mType===passtype )
        {
            id++;
        }
    }
    return id;
}

Effect.prototype.GetPassType = function( id )
{
    return this.mPasses[id].mType;
}
Effect.prototype.GetPassName = function( id )
{
    return this.mPasses[id].mName;
}
Effect.prototype.GetCode = function( id )
{
    return this.mPasses[id].mSource;
}
Effect.prototype.SetCode = function( id, source )
{
    this.mPasses[id].SetCode(source);
}
Effect.prototype.GetError = function (id)
{
    return this.mPasses[id].mError;
}
Effect.prototype.GetErrorStr = function (id)
{
    return this.mPasses[id].mErrorStr;
}
Effect.prototype.GetErrorGlobal = function()
{
    for (let i = 0; i < this.mPasses.length; i++)
    {
        if (this.mPasses[i].mError)
        {
            return true;
        }
    }
    return false;
}

Effect.prototype.Load = function (jobj )
{
    if (jobj.ver !== "0.1")
    {
        console.log("Wrong Format");
        return false;
    }

    let numPasses = jobj.renderpass.length;

    if( numPasses<1 || numPasses>this.mMaxPasses )
    {
        console.log("Corrupted Shader - " + numPasses);
        return false;
    }

    this.mPasses = [];
    for (let j = 0; j < numPasses; j++)
    {
        let rpass = jobj.renderpass[j];

        // skip sound passes if in thumbnail mode
        if( this.mForceMuted && rpass.type === "sound" ) continue;

        let wpass = new EffectPass(this.mRenderer, this.mIs20, this.mIsLowEnd, this.mShaderTextureLOD,
                                   this.mTextureCallbackFun, this.mTextureCallbackObj, this.mForceMuted, this.mForcePaused, this.mGainNode,
                                   this.mProgramDownscale, j, this);

        wpass.Create(rpass.type, this.mAudioContext);

        let numInputs = rpass.inputs.length;

        for (let i = 0; i < 4; i++)
        {
            wpass.NewTexture(this.mAudioContext, i, null, null, null);
        }
        for (let i = 0; i < numInputs; i++)
        {
            let lid  = rpass.inputs[i].channel;
            let styp = rpass.inputs[i].type;
            let sid  = rpass.inputs[i].id;
            let ssrc = rpass.inputs[i].filepath;
            let psrc = rpass.inputs[i].previewfilepath;
            let samp = rpass.inputs[i].sampler;

            wpass.NewTexture(this.mAudioContext, lid, { mType: styp, mID: sid, mSrc: ssrc, mSampler: samp, mPreviewSrc: psrc }, this.mBuffers, this.mCubeBuffers, this.mKeyboard);
        }

        for (let i = 0; i < 4; i++)
        {
            wpass.SetOutputs(i, null);
        }

        let numOutputs = rpass.outputs.length;
        for (let i = 0; i < numOutputs; i++)
        {
            let outputID = rpass.outputs[i].id;
            let outputCH = rpass.outputs[i].channel;
            wpass.SetOutputs(outputCH, outputID);
        }

        // create some hardcoded names. This should come from the DB
        let rpassName = "";
        if (rpass.type === "common" ) rpassName = "Common";
        if (rpass.type === "sound"  ) rpassName = "Sound";
        if (rpass.type === "image"  ) rpassName = "Image";
        if (rpass.type === "buffer") rpassName = "Buffer " + String.fromCharCode(65 + assetID_to_bufferID(wpass.mOutputs[0]));
        if (rpass.type === "cubemap") rpassName = "Cube A";// " + String.fromCharCode(65 + assetID_to_bufferID(this.mPasses[j].mOutputs[0]));
        wpass.SetName(rpassName);
        wpass.SetCode(rpass.code);

        this.mPasses.push(wpass);
    }
    return true;
}

Effect.prototype.CompileSome = function ( passes, preventCache, onResolve )
{
    let me = this;

    let to = getRealTime();
    let allPromisses = [];
    for (let j = 0; j < passes.length; j++)
    {
        allPromisses.push(new Promise(function (resolve, reject)
        {
            me.NewShader(passes[j], preventCache, function () { resolve(1); });
        }));
    }

    // aggregated callback when all passes have been compiled
    Promise.all(allPromisses).then(function (values)
    {
        let totalError = false;
        for (let j = 0; j < me.mPasses.length; j++)
        {
            if (me.mPasses[j].mError)
            {
                totalError = true;
                break;
            }
        }
        me.mCompilationTime = getRealTime() - to;
        onResolve(!totalError);
    }).catch(console.log);
}

Effect.prototype.Compile = function (preventCache, onResolve )
{
    let me = this;

    let to = getRealTime();
    let allPromisses = [];
    let numPasses = this.mPasses.length;
    for (let j = 0; j < numPasses; j++)
    {
        allPromisses.push(new Promise(function (resolve, reject)
        {
            me.NewShader(j, preventCache, function () { resolve(1); });
        }));
    }

    // aggregated callback when all passes have been compiled
    Promise.all(allPromisses).then(function (values)
    {
        let totalError = false;
        for (let j = 0; j < numPasses; j++)
        {
            if (me.mPasses[j].mError)
            {
                totalError = true;
                break;
            }
        }
        me.mCompilationTime = getRealTime() - to;
        onResolve(!totalError);
    }).catch(console.log);
}

Effect.prototype.GetCompilationTime = function( id )
{
    return this.mPasses[id].GetCompilationTime()/1000.0;
}
Effect.prototype.GetTotalCompilationTime = function()
{
    return this.mCompilationTime/1000.0;
}

Effect.prototype.DestroyPass = function( id )
{
   this.mPasses[id].Destroy( this.mAudioContext );
   this.mPasses.splice(id, 1);
}

Effect.prototype.AddPass = function( passType, passName, onResolve )
{
    let shaderStr = null;

    if( passType==="sound"   ) shaderStr = "vec2 mainSound( int samp, float time )\n{\n    // A 440 Hz wave that attenuates quickly overt time\n    return vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );\n}";
    if( passType==="buffer"  ) shaderStr = "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}";
    if( passType==="common"  ) shaderStr = "vec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}";
    if( passType==="cubemap" ) shaderStr = "void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Ray direction as color\n    vec3 col = 0.5 + 0.5*rayDir;\n\n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}";

    let id = this.GetNumPasses();
    this.mPasses[id] = new EffectPass( this.mRenderer, this.mIs20, this.mIsLowEnd, this.mShaderTextureLOD,
                                       this.mTextureCallbackFun, this.mTextureCallbackObj, this.mForceMuted, this.mForcePaused, this.mGainNode, 
                                       this.mProgramDownscale, id, this );

    this.mPasses[id].Create( passType, this.mAudioContext );
    this.mPasses[id].SetName( passName );
    this.mPasses[id].SetCode( shaderStr );
    this.NewShader(id, false, function ()
    {
        onResolve();
    });

    return { mId : id, mShader : shaderStr };
}

// this should be removed once we have MultiPass 2.0 and passes render to arbitrary buffers
Effect.prototype.IsBufferPassUsed = function( bufferID )
{
    for (let j=0; j<this.mPasses.length; j++ )
    {
        if( this.mPasses[j].mType !== "buffer" ) continue;
        if( this.mPasses[j].mOutputs[0] === bufferID_to_assetID(bufferID) ) return true;
    }
    return false;
}

Effect.prototype.Save = function()
{
    var result = {};

    result.ver = "0.1";

    result.renderpass = [];

    let numPasses = this.mPasses.length;
    for (let j=0; j<numPasses; j++ )
    {
        result.renderpass[j] = {};

        result.renderpass[j].outputs = new Array();
        for (let i = 0; i<4; i++ )
        {
            let outputID = this.mPasses[j].mOutputs[i];
            if( outputID===null ) continue;
            result.renderpass[j].outputs.push( { channel: i, id: outputID } );
        }
        result.renderpass[j].inputs = new Array();
        for (let i = 0; i<4; i++ )
        {
            if( this.mPasses[j].mInputs[i]===null ) continue;
            result.renderpass[j].inputs.push( {channel: i,
                                               type    : this.mPasses[j].mInputs[i].mInfo.mType,
                                               id      : this.mPasses[j].mInputs[i].mInfo.mID,
                                               filepath: this.mPasses[j].mInputs[i].mInfo.mSrc,
                                               sampler : this.mPasses[j].mInputs[i].mInfo.mSampler });
        }

        result.renderpass[j].code = this.mPasses[j].mSource;
        result.renderpass[j].name = this.mPasses[j].mName
        result.renderpass[j].description = "";
        result.renderpass[j].type = this.mPasses[j].mType;
    }

    result.flags = this.calcFlags();

    return result;
}

Effect.prototype.calcFlags = function ()
{
    let flagVR = false;
    let flagWebcam = false;
    let flagSoundInput = false;
    let flagSoundOutput = false;
    let flagKeyboard = false;
    let flagMultipass = false;
    let flagMusicStream = false;

    let numPasses = this.mPasses.length;
    for (let j = 0; j < numPasses; j++)
    {
        let pass = this.mPasses[j];

        if (pass.mType === "sound") flagSoundOutput = true;
        if (pass.mType === "buffer") flagMultipass = true;

        for (let i = 0; i < 4; i++)
        {
            if (pass.mInputs[i] === null) continue;

            if (pass.mInputs[i].mInfo.mType === "webcam") flagWebcam = true;
            else if (pass.mInputs[i].mInfo.mType === "keyboard") flagKeyboard = true;
            else if (pass.mInputs[i].mInfo.mType === "mic") flagSoundInput = true;
            else if (pass.mInputs[i].mInfo.mType === "musicstream") flagMusicStream = true;
        }

        let n1 = pass.mSource.indexOf("mainVR(");
        let n2 = pass.mSource.indexOf("mainVR (");
        if (n1 > 0 || n2 > 0) flagVR = true;
    }

    return {
        mFlagVR: flagVR,
        mFlagWebcam: flagWebcam,
        mFlagSoundInput: flagSoundInput,
        mFlagSoundOutput: flagSoundOutput,
        mFlagKeyboard: flagKeyboard,
        mFlagMultipass: flagMultipass,
        mFlagMusicStream: flagMusicStream
    };
}</script>
    <script>"use strict"

const kMaxCompileTime = 10.0;

function iReportCrash(shaderID)
{
    let req = new XMLHttpRequest();
    req.onload = function ()
    {
        let jsn = req.response;
        if (jsn === null) return;
        if (jsn.result === 0)
        {
            // yep
        }
    };
    req.open("POST", "/shadertoy", true);
    req.responseType = "json";
    req.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    req.send( "s=" + shaderID + "&r=2" );
}
</script>
    <script>"use strict"

var gActive = -1;
var mShaders = [];
var gNumCanvases = 0;

function myrefresh( id, slot, img, forceFrame, gui, guiID, renderID, time )
{
    if( mShaders[id].mReady===false ) return;
    if( forceFrame )
    {
        if (mShaders[id].mScreenshot === false)
        {
            mShaders[id].gEffect.Paint(mShaders[id].mTime / 1000.0, 1.0 / 60.0, 60.0, 0, 0, 0, 0, false);
        }
    }
}

function startRendering()
{
    if( gActive<0 ) return;
    if( mShaders[gActive].mReady===false ) return;
    if( mShaders[gActive].mScreenshot===true ) return;

    let time = getRealTime();

    mShaders[gActive].mFPS.Count( time );
    mShaders[gActive].mTime = mShaders[gActive].mTime0 + (time - mShaders[gActive].mTo);
    let dtime = 1000.0/60.0;
    mShaders[gActive].gEffect.Paint( mShaders[gActive].mTime/1000.0, dtime/1000.0, mShaders[gActive].mFPS.GetFPS(), 0,0,0,0, false);

    requestAnimFrame( startRendering );
}

function iLoadAndCompile(jsn, i )
{
    var shaderObj = jsn[i];
    if (shaderObj === null) return;

    var resizeCB = function (xres, yres) { myrefresh(i, 0, null, true, false, 0, -1.0) };
    var crashCB = function () { alert('crash');/*iReportCrash(gShaderIDs[i])*/ };
    mShaders[i].gEffect = new Effect(null, null, mShaders[i].mPreview.mCanvas, myrefresh, i, true, true, resizeCB, crashCB);

    if (!mShaders[i].gEffect.Load(shaderObj)) return;

    mShaders[i].gEffect.Compile(false, function (worked)
    {
        if (worked === true)
        {
            previewShowRender(mShaders[i].mPreview);

            mShaders[i].mScreenshot = false;
            mShaders[i].mReady = true;
            mShaders[i].mTime = 10.0 * 1000.0;
            mShaders[i].mTime0 = 0.0;
            mShaders[i].mTo = 0.0;
            mShaders[i].mFPS = piCreateFPSCounter();
            mShaders[i].mPreview.mCanvas.addEventListener("mouseout", function (ev) { gActive = -1; }, true);
            mShaders[i].mPreview.mBase.addEventListener("mouseover", function (ev) { if (mShaders[i].mPreview.mUI !== null) mShaders[i].mPreview.mUI.classList.add('isVisible'); }, true);
            mShaders[i].mPreview.mBase.addEventListener("mouseout", function (ev) { if (mShaders[i].mPreview.mUI !== null) mShaders[i].mPreview.mUI.classList.remove('isVisible'); }, true);
            mShaders[i].mPreview.mCanvas.addEventListener("mouseover", function (ev)
            {
                let ele = piGetSourceElement(ev);
                if (ele.mId === undefined) return;

                gActive = ele.mId;
                if (!mShaders[gActive].mReady) return;
                let time = getRealTime();
                mShaders[gActive].mTo = time;
                mShaders[gActive].mTime0 = mShaders[gActive].mTime;
                mShaders[gActive].mFPS.Reset(time);

                startRendering();
            }, true);


            /*
            let compilationTime = mShaders[i].gEffect.GetTotalCompilationTime();
            if (compilationTime > kMaxCompileTime)
            {
                iReportCrash(mShaders[i].mShaderID);
            }*/

            myrefresh(i, null, null, true, false, 0, -1.0);
        }
        else
        {
            mShaders[i].mReady = false;
            previewShowError(mShaders[i].mPreview);
        }
    });
};


function iProcessShader( jsn, i )
{
    var shaderObj = jsn[i];
    if( shaderObj===null ) return;

    if ((shaderObj.info.usePreview === 0 && !gUseScreenshots) || (mShaders[i].mPreviewReady !== 1))
    {
        iLoadAndCompile(jsn, i);
    }
    else
    {
        mShaders[i].mScreenshot = true;
        if( shaderObj.info.usePreview === 1 )
            previewShowScreenshot(mShaders[i].mPreview, 1); // comp
        else if (gUseScreenshots)
            previewShowScreenshot(mShaders[i].mPreview, 2); // sett
    }

    if( i<(jsn.length-1) ) setTimeout( function(){iProcessShader(jsn,i+1);}, 10 );
}

function iInitUI(numCanvases, uiCallback, windowTitle)
{
    gNumCanvases = numCanvases;
    document.getElementById("mySearch").focus();

    //-----------------------------------------------------------------
    // window
    //-----------------------------------------------------------------
    if (windowTitle !== null) {
        document.title = windowTitle;
    }

    //-----------------------------------------------------------------
    // ui
    //-----------------------------------------------------------------
    var num = Math.min(gShaders.length, gNumCanvases);

    //var base = document.getElementsByClassName( "searchResult" );

    for (let i = 0; i < gNumCanvases; i++)
    {
        let pv = createPreview(i);

        if (i >= num) {
            previewHide(pv);
            continue;
        }

        let shaderID = gShaders[i].info.id;
        
        if (pv.mUI !== null && uiCallback !== null) {
            pv.mUI.addEventListener('click', function (ev) {
                uiCallback(shaderID);
                ev.preventDefault();
            }, false);
        }
        
        previewShowLoading(pv);
        
        mShaders[i] = {};
        mShaders[i].mShaderID = shaderID;
        mShaders[i].mPreview = pv;
        mShaders[i].mScreenshot = false;
        mShaders[i].mPreview.mLink.href = "/view/" + shaderID;
        mShaders[i].mPreviewReady = 0;
        mShaders[i].mReady = false;
        mShaders[i].gEffect = null;

        previewLoadScreenshot(mShaders[i].mPreview,
            function () { mShaders[i].mPreviewReady = 1; if (mShaders[i].mReady === false) previewShowScreenshot(mShaders[i].mPreview, 0); },
            function () { mShaders[i].mPreviewReady = 2; },
            shaderID);
    }

    if (num <= 0) {
        return;
    }
}

function iInitShaders(jsn)
{
    for (let i = 0; i < jsn.length; i++)
    {
        let shaderObj = jsn[i];
        if (shaderObj === null) continue;
        let inf = shaderObj.info;
        mShaders[i].mPreview.mTextA.textContent = inf.name;
        mShaders[i].mPreview.mTextB.innerHTML = "<a class='user' href='/user/" + htmlEntities(inf.username) + "'>" + htmlEntities(inf.username) + "</a>";
        mShaders[i].mPreview.mTextC.innerHTML = "<img src='/img/themes/" + gThemeName + "/views.png' class='viewsIcon'></img>" + inf.viewed + "    &nbsp;&nbsp;  <img src='/img/themes/" + gThemeName + "/likes.png' class='likesIcon'></img>" + inf.likes;
    }

    setTimeout(function () { iProcessShader(jsn, 0); }, 10);
}

function resultsInitStatic(numCanvases, uiCallback, windowTitle)
{
    iInitUI(numCanvases, uiCallback, windowTitle);

    iInitShaders(gShaders);
}

function resultsInit(numCanvases, uiCallback, windowTitle)
{	
    iInitUI(numCanvases, uiCallback, windowTitle);

    var num = Math.min(gShaderIDs.length, gNumCanvases);

    var mHttpReq = new XMLHttpRequest();

    mHttpReq.abort();

    var str = "{ \"shaders\" : [";
    for( let i=0; i<num; i++ )
    {
         str += "\"" + gShaderIDs[i] + "\"";
         if( i!==(num-1) ) str += ", ";
    }
    str += "] }";

    str = "s=" + encodeURIComponent( str ) + "&nt=0&nl=0&np=0";

    mHttpReq.open( "POST", "/shadertoy", true );
    mHttpReq.responseType = "json";
    mHttpReq.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    mHttpReq.onload = function ()
    {
        let jsn = this.response;
        if( jsn===null )
        {
            console.log( "Could not load shaders" );
            return;
        }

        iInitShaders(jsn);
    }
    mHttpReq.send( str );
}</script>
    <style>
    .shaderPreview
    {
    display: block;
    background-color: #000000;
    background-image: url("/img/loading.gif");
    background-repeat: no-repeat;
    background-position: center;
    padding: 0px;
    margin: 0px;
    border: 0px solid #000000;
    border-radius: 8px;
    width:100%;
    height:100%;
    position: absolute;
    overflow:hidden;
    }

    .previewInfo
    {
    width: 100%;
    left: 0px;
    top: 2px;
    position: relative;
    visibility: hidden;
    }

    .previewCanvas
    {
    left: 0px;
    top: 0px;
    padding: 0px;
    margin: 0px;
    position: absolute;
    cursor: pointer;
    width:100%;
    height:100%;
    border-radius: 8px;
    border: 0px solid #000000;
    backgroundColor: transparent;
visibility: hidden;
opacity:0;
transition: opacity 1.0s ease;
    }

    .previewText
    {
        text-overflow: ellipsis;
    white-space: nowrap;
    padding-right: 1px;
    }

    .previewTextUser
    {
    text-overflow: ellipsis;
    white-space: nowrap;
    padding-left: 3px;
    }

    .previewStats
    {
    padding-right: 1px;
    right: 0px;
    top: 0px;
    position: absolute;
    }

    .previewErrorContainer
    {
    left:0px;
    top:0px;
    width:100%;
    height:100%;
    padding:0px;
    margin:0px;
    background-color:#000000;
    border-radius:8px;
    cursor:pointer;
    visibility:hidden;
    }

    .previewErrorMessage
    {
    top:50%;
    position:absolute;
    width:100%;
    text-align:center;
    padding:0;
    margin:auto;
    color:#ff0000;
    font-size:2em;
    font-style:italic;
    }

    .previewNoGLContainter
    {
    left:0px;
    top:0px;
    width:100%;
    height:100%;
    padding:0px;
    margin:0px;
    position:absolute;
    background-color:#000000;
    border-radius:8px;
    cursor:pointer;
    pointer-events:none;
    visibility:hidden;
    font-size:2em;
    }

    .previewNoGLMessage
    {
    width:86%;
    height:90%;
    padding-left:7%;
    padding-right:7%;
    padding-top:10%;
    padding-bottom:0px;
    color:#ff0000;
    position:absolute;
    visibility:hidden;
    }

    .previewThumbnailContainer
    {
    width:100%;
    height:100%;
    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    cursor:pointer;
    visibility:hidden;
    border-radius:8px;
    border:0px solid #000000;
    }

    .previewThumbnailImage
    {
    width:100%;
    height:100%;
    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    cursor:pointer;
    border-radius:8px;
    border:0px solid #000000;
opacity: 0.0;
transition: opacity 1.0s ease;
    }

    .previewThumbnailIcon
    {
    width:64px;
    height:32px;
    left:0px;
    top:0px;
    padding:0px;
    padding-top:12px;
    margin:0px;
    position:absolute;
    color:#ffffff;
    background-color:#ff8020;
    font-weight:bold;
    border-radius:0px 0px 8px 0px;
    text-align:center;
    //visibility:hidden;
    }


    .previewUIContainter
    {
    display: block;
    right:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    //cursor:pointer;
    //pointer-events:none;
    //visibility:hidden;
    }
</style>

<script>
    function previewHide(me)
    {
    me.mBase.style.visibility = "hidden";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "hidden";
    }

    function previewShowRender(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "visible";
me.mCanvas.style.opacity = 1.0;
    me.mCanvas.style.borderRadius ="8px;";
//  me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "visible";
    }

    function previewShowScreenshot(me, message)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "visible";
me.mThumbnailImg.style.opacity = 1.0;
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "visible";
    me.mThumbnailWar1.style.visibility = (message===1)?"visible":"hidden";
    me.mThumbnailWar2.style.visibility = (message===2)?"visible":"hidden";
    }

    function previewShowLoading(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "hidden";

    me.mLink.style.visibility = "visible";
    me.mBase.style.backgroundColor = "#ff0000;"
    me.mCont.style.visibility = "visible";
    }

    function previewShowNoWebGL(me, shaderID)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "visible";
    me.mError.style.visibility = "visible";
    me.mThumbnailImgNoWebGL.onerror = function(ev) 
                                      { 
                                            me.mThumbnailImgNoWebGL.style.visibility="hidden"; 
                                            me.mMessageNoWebGL.style.visibility="visible"; 
                                      };
    me.mThumbnailImgNoWebGL.src = "/media/shaders/" + shaderID + ".jpg";
    }

    function previewShowError(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "visible";
    me.mCont.style.visibility = "visible";
    }

    function previewLoadScreenshot( me, cbSuccess, cbError, shaderID )
    {
    var url = "/media/shaders/" + shaderID + ".jpg";
    me.mThumbnailImg.onload = cbSuccess;
    me.mThumbnailImg.onerror = function(ev) { cbError(); };
    me.mThumbnailImg.src = url;
    }
        
    function createPreview(id)
    {
        var bar = document.getElementById( "Preview_"+id+"_Canvas" );
        bar.width = bar.offsetWidth;
        bar.height = bar.offsetHeight;
        bar.mId = id;

        return { mBase: document.getElementById( "Preview_"+id+"_Container" ),
        mLink: document.getElementById( "Preview_"+id+"_Link" ),
        mCanvas: bar,
        mCont: document.getElementById( "Preview_"+id+"_Info" ),
        mTextA: document.getElementById( "Preview_"+id+"_Text" ),
        mTextB: document.getElementById( "Preview_"+id+"_TextUser" ),
        mTextC: document.getElementById( "Preview_"+id+"_Stats" ),
        mNoWebGL: document.getElementById( "Preview_"+id+"_NoWebGL" ),
        mError: document.getElementById( "Preview_"+id+"_Error" ),
        mCanvas2D: document.getElementById( "Preview_"+id+"_Thumnail" ),
        mThumbnailImg: document.getElementById( "Preview_"+id+"_ThumnailImage" ),
        mThumbnailWar1: document.getElementById( "Preview_"+id+"_ThumnailWarning1" ),
        mThumbnailWar2: document.getElementById( "Preview_"+id+"_ThumnailWarning2" ),
        mThumbnailImgNoWebGL: document.getElementById( "Preview_"+id+"_ThumnailImageNoWebGL" ),
        mMessageNoWebGL: document.getElementById( "Preview_"+id+"_MessageNoWebGL"),
        mUI: document.getElementById( "Preview_"+id+"_UI" )
        };
    }
</script>

    <style>

    #content
    {
        user-select: text;
        -moz-user-select: -moz-text;
        -webkit-user-select: text;
        padding:0px;
        margin:0px;
        position:relative;
    }

    #divUser
    {
        padding:0px;
        padding-top:24px;
        padding-bottom:16px;
        width:100%;
    }

    div#controls
    {
        width:100%;
        padding-top:16px;
        padding-bottom:16px;
        display:flex;
        justify-content:space-between; 
        flex-wrap:wrap;
    }

    div#controls > div
    {
        display:inline-flex;
    }

    .controlOptions
    {
        display:inline-block;
    }

    div#shaderGrid
    {
        width:100%;
        padding:0px;
        margin:0px;
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        grid-template-rows: repeat(2, 1fr);
        grid-column-gap: 64px;
        grid-row-gap: 16px;
    }

    .searchResult
    {
        margin: 0px;
        padding: 0px;
        width: 100%;
    }
    .searchResultContainer
    {
        width: 100%;
        padding-bottom:56.25%;
        height: 0;
        position: relative;
    }

    div#navigation
    {
        text-align: center;
        width: 100%;
    }


    #userPicture
    {
        background-color:#808080;
        border: 1px solid #000000;
        padding:0px;
        left:0px;
        top:0px;
        width:128px;
        height:128px;
    }

    a.pageButtons, .pageButtonsCurrent
    {
        
        //background-color: #303030;
        border-style: solid;
        border-width: 1px;
        border-color: #808080;
        text-align: center;
        vertical-align: middle;
        margin-left: 12px;
        display: inline-block;
        border-radius: 4px;
		font-weight:bold;
        cursor: pointer;
        padding-bottom:5px;
        padding-top:4px;
        padding-left: 8px;
        padding-right: 8px;
        margin:8px;
    }

    a.pageButtons
    {
        text-decoration: none;
        -moz-transition:    background-color 0.15s linear, color 0.15s linear;
        -webkit-transition: background-color 0.15s linear, color 0.15s linear;
        transition:         background-color 0.15s linear, color 0.15s linear;
    }

    a.pageButtons:hover
    {
      background-color:#808080;
      color : #ff8020;
    }

    .pageButtonsCurrent
    {
        background-color: #808080;
        color:#000000;
    }

    /* ----------------------- media resolutions ------------------------ */

    @media screen and (max-width:799px) 
    {
        div#shaderGrid  { grid-template-columns: 1fr; grid-template-rows: repeat(8, 1fr); grid-column-gap: 0px; grid-row-gap: 16px; padding-bottom:16px; }

        div#controls
        {
            width:100%;
            display:flex;
            justify-content:flex-start; 
            flex-wrap:wrap;
        }

        div#controls > div
        {
            display:inline-flex;
            width:100%;
            margin-left: 0px;
            margin-right: 0px;
            padding-bottom:16px;
        }
    }
    </style>

    <script>

    var gShaders=[{"ver":"0.1","info":{"id":"XtlSD7","date":"1438211838","viewed":125738,"name":"[SIG15] Mario World 1-1","username":"knarkowicz","description":"NES Super Mario Bros. World 1-1. My favorite game moment (just like for most kids in the early 90s). 20 years later implemented in a single shader.","likes":472,"published":3,"flags":8,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Interesting findings from original NES Super Mario Bros.:\n\/\/ -Clouds and brushes of all sizes are drawn using the same small sprite (32x24)\n\/\/ -Hills, clouds and bushes weren't placed manually. Every background object type is repeated after 768 pixels.\n\/\/ -Overworld (main theme) drum sound uses only the APU noise generator\n\n#define SPRITE_DEC( x, i ) \tmod( floor( i \/ pow( 4.0, mod( x, 8.0 ) ) ), 4.0 )\n#define SPRITE_DEC2( x, i ) mod( floor( i \/ pow( 4.0, mod( x, 11.0 ) ) ), 4.0 )\n#define RGB( r, g, b ) vec3( float( r ) \/ 255.0, float( g ) \/ 255.0, float( b ) \/ 255.0 )\n\nconst float MARIO_SPEED\t = 89.0;\nconst float GOOMBA_SPEED = 32.0;\nconst float INTRO_LENGTH = 2.0;\n\nvoid SpriteBlock( inout vec3 color, float x, float y )\n{\n    \/\/ black\n    float idx = 1.0;\n    \n    \/\/ light orange\n    idx = x < y ? 3.0 : idx;\n    \n    \/\/ dark orange\n    idx = x > 3.0 && x < 12.0 && y > 3.0 && y < 12.0 ? 2.0 : idx;\n    idx = x == 15.0 - y ? 2.0 : idx;\n    \n    color = RGB( 0, 0, 0 );\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\n\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\n}\n\nvoid SpriteHill( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;\n    \n    \/\/ dark green\n    idx = ( x > y && 79.0 - x > y ) && y < 33.0 ? 2.0 : idx;\n    idx = ( x >= 37.0 && x <= 42.0 ) && y == 33.0 ? 2.0 : idx;\n    \n    \/\/ black\n    idx = ( x == y || 79.0 - x == y ) && y < 33.0 ? 1.0 : idx;\n    idx = ( x == 33.0 || x == 46.0 ) && y == 32.0 ? 1.0 : idx;\n    idx = ( x >= 34.0 && x <= 36.0 ) && y == 33.0 ? 1.0 : idx;\n    idx = ( x >= 43.0 && x <= 45.0 ) && y == 33.0 ? 1.0 : idx;\n    idx = ( x >= 37.0 && x <= 42.0 ) && y == 34.0 ? 1.0 : idx;\n    idx = ( x >= 25.0 && x <= 26.0 ) && ( y >= 8.0  && y <= 11.0 ) ? 1.0 : idx;\n    idx = ( x >= 41.0 && x <= 42.0 ) && ( y >= 24.0 && y <= 27.0 ) ? 1.0 : idx;\n    idx = ( x >= 49.0 && x <= 50.0 ) && ( y >= 8.0  && y <= 11.0 ) ? 1.0 : idx;\n    idx = ( x >= 28.0 && x <= 30.0 ) && ( y >= 11.0 && y <= 14.0 ) ? 1.0 : idx;\n    idx = ( x >= 28.0 && x <= 30.0 ) && ( y >= 11.0 && y <= 14.0 ) ? 1.0 : idx;\n    idx = ( x >= 44.0 && x <= 46.0 ) && ( y >= 27.0 && y <= 30.0 ) ? 1.0 : idx;\n    idx = ( x >= 44.0 && x <= 46.0 ) && ( y >= 27.0 && y <= 30.0 ) ? 1.0 : idx;\n    idx = ( x >= 52.0 && x <= 54.0 ) && ( y >= 11.0 && y <= 14.0 ) ? 1.0 : idx;\n    idx = ( x == 29.0 || x == 53.0 ) && ( y >= 10.0 && y <= 15.0 ) ? 1.0 : idx;\n    idx = x == 45.0 && ( y >= 26.0 && y <= 31.0 ) ? 1.0 : idx;\n    \n\tcolor = idx == 1.0 ? RGB( 0,     0,  0 ) : color;\n\tcolor = idx == 2.0 ? RGB( 0,   173,  0 ) : color;\n}\n\nvoid SpritePipe( inout vec3 color, float x, float y, float h )\n{\n    float offset = h * 16.0;\n\n    \/\/ light green\n\tfloat idx = 3.0;\n    \n    \/\/ dark green\n    idx = ( ( x > 5.0 && x < 8.0 ) || ( x == 13.0 ) || ( x > 15.0 && x < 23.0 ) ) && y < 17.0 + offset ? 2.0 : idx;\n    idx = ( ( x > 4.0 && x < 7.0 ) || ( x == 12.0 ) || ( x > 14.0 && x < 24.0 ) ) && ( y > 17.0 + offset && y < 30.0 + offset ) ? 2.0 : idx;    \n    idx = ( x < 5.0 || x > 11.0 ) && y == 29.0 + offset ? 2.0 : idx;\n\tidx = fract( x * 0.5 + y * 0.5 ) == 0.5 && x > 22.0 && ( ( x < 26.0 && y < 17.0 + offset ) || ( x < 28.0 && y > 17.0 + offset && y < 30.0 + offset ) ) ? 2.0 : idx;    \n    \n    \/\/ black\n    idx = y == 31.0 + offset || x == 0.0 || x == 31.0 || y == 17.0 + offset ? 1.0 : idx;\n    idx = ( x == 2.0 || x == 29.0 ) && y < 18.0 + offset ? 1.0 : idx;\n    idx = ( x > 1.0 && x < 31.0 ) && y == 16.0 + offset ? 1.0 : idx;    \n    \n    \/\/ transparent\n    idx = ( x < 2.0 || x > 29.0 ) && y < 17.0 + offset ? 0.0 : idx;\n\n\tcolor = idx == 1.0 ? RGB( 0,     0,  0 ) : color;\n\tcolor = idx == 2.0 ? RGB( 0,   173,  0 ) : color;\n\tcolor = idx == 3.0 ? RGB( 189, 255, 24 ) : color;\n}\n\nvoid SpriteCloud( inout vec3 color, float x, float y, float isBush )\n{\n\tfloat idx = 0.0;\n    \n\tidx = y == 23.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 5440.0 : 0.0 ) ) : idx;\n\tidx = y == 22.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 32720.0 : 0.0 ) ) : idx;\n\tidx = y == 21.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 131061.0 : 0.0 ) ) : idx;\n\tidx = y == 20.0 ? ( x <= 10.0 ? 1048576.0 : ( x <= 21.0 ? 1179647.0 : 0.0 ) ) : idx;\n\tidx = y == 19.0 ? ( x <= 10.0 ? 1048576.0 : ( x <= 21.0 ? 3670015.0 : 1.0 ) ) : idx;\n\tidx = y == 18.0 ? ( x <= 10.0 ? 1048576.0 : ( x <= 21.0 ? 4190207.0 : 7.0 ) ) : idx;\n\tidx = y == 17.0 ? ( x <= 10.0 ? 3407872.0 : ( x <= 21.0 ? 4177839.0 : 7.0 ) ) : idx;\n\tidx = y == 16.0 ? ( x <= 10.0 ? 3997696.0 : ( x <= 21.0 ? 4194299.0 : 7.0 ) ) : idx;\n\tidx = y == 15.0 ? ( x <= 10.0 ? 4150272.0 : ( x <= 21.0 ? 4194303.0 : 1055.0 ) ) : idx;\n\tidx = y == 14.0 ? ( x <= 10.0 ? 4193536.0 : ( x <= 21.0 ? 4194303.0 : 7455.0 ) ) : idx;\n\tidx = y == 13.0 ? ( x <= 10.0 ? 4194112.0 : ( x <= 21.0 ? 4194303.0 : 8063.0 ) ) : idx;\n\tidx = y == 12.0 ? ( x <= 10.0 ? 4194240.0 : ( x <= 21.0 ? 4194303.0 : 73727.0 ) ) : idx;\n\tidx = y == 11.0 ? ( x <= 10.0 ? 4194260.0 : ( x <= 21.0 ? 4194303.0 : 491519.0 ) ) : idx;\n\tidx = y == 10.0 ? ( x <= 10.0 ? 4194301.0 : ( x <= 21.0 ? 4194303.0 : 524287.0 ) ) : idx;\n\tidx = y == 9.0 ? ( x <= 10.0 ? 4194301.0 : ( x <= 21.0 ? 4194303.0 : 524287.0 ) ) : idx;\n\tidx = y == 8.0 ? ( x <= 10.0 ? 4194292.0 : ( x <= 21.0 ? 4194303.0 : 131071.0 ) ) : idx;\n\tidx = y == 7.0 ? ( x <= 10.0 ? 4193232.0 : ( x <= 21.0 ? 4194303.0 : 32767.0 ) ) : idx;\n\tidx = y == 6.0 ? ( x <= 10.0 ? 3927872.0 : ( x <= 21.0 ? 4193279.0 : 131071.0 ) ) : idx;\n\tidx = y == 5.0 ? ( x <= 10.0 ? 2800896.0 : ( x <= 21.0 ? 4193983.0 : 524287.0 ) ) : idx;\n\tidx = y == 4.0 ? ( x <= 10.0 ? 3144960.0 : ( x <= 21.0 ? 3144362.0 : 262143.0 ) ) : idx;\n\tidx = y == 3.0 ? ( x <= 10.0 ? 4150272.0 : ( x <= 21.0 ? 3845099.0 : 98303.0 ) ) : idx;\n\tidx = y == 2.0 ? ( x <= 10.0 ? 3997696.0 : ( x <= 21.0 ? 4107775.0 : 6111.0 ) ) : idx;\n\tidx = y == 1.0 ? ( x <= 10.0 ? 1310720.0 : ( x <= 21.0 ? 4183167.0 : 325.0 ) ) : idx;\n\tidx = y == 0.0 ? ( x <= 10.0 ? 0.0 : ( x <= 21.0 ? 1392661.0 : 0.0 ) ) : idx;\n\n\tidx = SPRITE_DEC2( x, idx );\n\n\tvec3 colorB = isBush == 1.0 ? RGB( 0,   173,  0 ) : RGB(  57, 189, 255 );\n\tvec3 colorC = isBush == 1.0 ? RGB( 189, 255, 24 ) : RGB( 254, 254, 254 );\n\n\tcolor = idx == 1.0 ? RGB( 0, 0, 0 ) : color;\n\tcolor = idx == 2.0 ? colorB \t\t: color;\n\tcolor = idx == 3.0 ? colorC \t\t: color;\n}\n\nvoid SpriteFlag( inout vec3 color, float x, float y )\n{\n\tfloat idx = 0.0;\n\tidx = y == 15.0 ? 43690.0 : idx;\n\tidx = y == 14.0 ? ( x <= 7.0 ? 43688.0 : 42326.0 ) : idx;\n\tidx = y == 13.0 ? ( x <= 7.0 ? 43680.0 : 38501.0 ) : idx;\n\tidx = y == 12.0 ? ( x <= 7.0 ? 43648.0 : 39529.0 ) : idx;\n\tidx = y == 11.0 ? ( x <= 7.0 ? 43520.0 : 39257.0 ) : idx;\n\tidx = y == 10.0 ? ( x <= 7.0 ? 43008.0 : 38293.0 ) : idx;\n\tidx = y == 9.0 ? ( x <= 7.0 ? 40960.0 : 38229.0 ) : idx;\n\tidx = y == 8.0 ? ( x <= 7.0 ? 32768.0 : 43354.0 ) : idx;\n\tidx = y == 7.0 ? ( x <= 7.0 ? 0.0 : 43690.0 ) : idx;\n\tidx = y == 6.0 ? ( x <= 7.0 ? 0.0 : 43688.0 ) : idx;\n\tidx = y == 5.0 ? ( x <= 7.0 ? 0.0 : 43680.0 ) : idx;\n\tidx = y == 4.0 ? ( x <= 7.0 ? 0.0 : 43648.0 ) : idx;\n\tidx = y == 3.0 ? ( x <= 7.0 ? 0.0 : 43520.0 ) : idx;\n\tidx = y == 2.0 ? ( x <= 7.0 ? 0.0 : 43008.0 ) : idx;\n\tidx = y == 1.0 ? ( x <= 7.0 ? 0.0 : 40960.0 ) : idx;\n\tidx = y == 0.0 ? ( x <= 7.0 ? 0.0 : 32768.0 ) : idx;\n\n\tidx = SPRITE_DEC( x, idx );\n\n\tcolor = idx == 1.0 ? RGB(   0, 173,   0 ) : color;\n\tcolor = idx == 2.0 ? RGB( 255, 255, 255 ) : color;\n}\n\nvoid SpriteCastleFlag( inout vec3 color, float x, float y )\n{\n\tfloat idx = 0.0;\n\tidx = y == 13.0 ? ( x <= 10.0 ? 8.0 : 0.0 ) : idx;\n\tidx = y == 12.0 ? ( x <= 10.0 ? 42.0 : 0.0 ) : idx;\n\tidx = y == 11.0 ? ( x <= 10.0 ? 8.0 : 0.0 ) : idx;\n\tidx = y == 10.0 ? ( x <= 10.0 ? 4194292.0 : 15.0 ) : idx;\n\tidx = y == 9.0 ? ( x <= 10.0 ? 4161524.0 : 15.0 ) : idx;\n\tidx = y == 8.0 ? ( x <= 10.0 ? 4161524.0 : 15.0 ) : idx;\n\tidx = y == 7.0 ? ( x <= 10.0 ? 1398260.0 : 15.0 ) : idx;\n\tidx = y == 6.0 ? ( x <= 10.0 ? 3495924.0 : 15.0 ) : idx;\n\tidx = y == 5.0 ? ( x <= 10.0 ? 4022260.0 : 15.0 ) : idx;\n\tidx = y == 4.0 ? ( x <= 10.0 ? 3528692.0 : 15.0 ) : idx;\n\tidx = y == 3.0 ? ( x <= 10.0 ? 3667956.0 : 15.0 ) : idx;\n\tidx = y == 2.0 ? ( x <= 10.0 ? 4194292.0 : 15.0 ) : idx;\n\tidx = y == 1.0 ? ( x <= 10.0 ? 4.0 : 0.0 ) : idx;\n\tidx = y == 0.0 ? ( x <= 10.0 ? 4.0 : 0.0 ) : idx;\n\n\tidx = SPRITE_DEC2( x, idx );\n\n\tcolor = idx == 1.0 ? RGB( 181,  49,  33 ) : color;\n    color = idx == 2.0 ? RGB( 230, 156,  33 ) : color;\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;\n}\n\nvoid SpriteGoomba( inout vec3 color, float x, float y, float frame )\n{\n\tfloat idx = 0.0;\n\n    \/\/ second frame is flipped first frame\n    x = frame == 1.0 ? 15.0 - x : x;\n\n    if ( frame <= 1.0 )\n    {\n        idx = y == 15.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 43008.0 : 42.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 43520.0 : 170.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 43648.0 : 682.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 43360.0 : 2410.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 42920.0 : 10970.0 ) : idx;\n        idx = y ==  9.0 ? ( x <= 7.0 ? 22440.0 : 10965.0 ) : idx;\n        idx = y ==  8.0 ? ( x <= 7.0 ? 47018.0 : 43742.0 ) : idx;\n        idx = y ==  7.0 ? ( x <= 7.0 ? 49066.0 : 43774.0 ) : idx;\n        idx = y ==  6.0 ? 43690.0 : idx;\n        idx = y ==  5.0 ? ( x <= 7.0 ? 65192.0 : 10943.0 ) : idx;\n        idx = y ==  4.0 ? ( x <= 7.0 ? 65280.0 : 255.0 ) : idx;\n        idx = y ==  3.0 ? ( x <= 7.0 ? 65280.0 : 1535.0 ) : idx;\n        idx = y ==  2.0 ? ( x <= 7.0 ? 64832.0 : 5471.0 ) : idx;\n        idx = y ==  1.0 ? ( x <= 7.0 ? 62784.0 : 5463.0 ) : idx;\n        idx = y ==  0.0 ? ( x <= 7.0 ? 5376.0 : 1364.0 ) : idx;\n    }\n    else\n    {\n        idx = y == 7.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\n\t\tidx = y == 6.0 ? ( x <= 7.0 ? 43648.0 : 682.0 ) : idx;\n\t\tidx = y == 5.0 ? ( x <= 7.0 ? 42344.0 : 10586.0 ) : idx;\n\t\tidx = y == 4.0 ? ( x <= 7.0 ? 24570.0 : 45045.0 ) : idx;\n\t\tidx = y == 3.0 ? 43690.0 : idx;\n\t\tidx = y == 2.0 ? ( x <= 7.0 ? 65472.0 : 1023.0 ) : idx;\n\t\tidx = y == 1.0 ? ( x <= 7.0 ? 65280.0 : 255.0 ) : idx;\n\t\tidx = y == 0.0 ? ( x <= 7.0 ? 1364.0 : 5456.0 ) : idx; \n    }\n    \n    idx = SPRITE_DEC( x, idx );\n    \n\tcolor = idx == 1.0 ? RGB( 0,     0,   0 ) : color;\n\tcolor = idx == 2.0 ? RGB( 153,  75,  12 ) : color;\n\tcolor = idx == 3.0 ? RGB( 255, 200, 184 ) : color;\n}\n\nvoid SpriteKoopa( inout vec3 color, float x, float y, float frame )\n{    \n\tfloat idx = 0.0;\n\n\tif ( frame == 0.0 )\n    {\n\t\tidx = y == 23.0 ? ( x <= 7.0 ? 768.0 : 0.0 ) : idx;\n\t\tidx = y == 22.0 ? ( x <= 7.0 ? 4032.0 : 0.0 ) : idx;\n\t\tidx = y == 21.0 ? ( x <= 7.0 ? 4064.0 : 0.0 ) : idx;\n\t\tidx = y == 20.0 ? ( x <= 7.0 ? 12128.0 : 0.0 ) : idx;\n\t\tidx = y == 19.0 ? ( x <= 7.0 ? 12136.0 : 0.0 ) : idx;\n        idx = y == 18.0 ? ( x <= 7.0 ? 12136.0 : 0.0 ) : idx;\n        idx = y == 17.0 ? ( x <= 7.0 ? 12264.0 : 0.0 ) : idx;\n\t\tidx = y == 16.0 ? ( x <= 7.0 ? 11174.0 : 0.0 ) : idx;\n\t\tidx = y == 15.0 ? ( x <= 7.0 ? 10922.0 : 0.0 ) : idx;\n\t\tidx = y == 14.0 ? ( x <= 7.0 ? 10282.0 : 341.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 30730.0 : 1622.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 31232.0 : 1433.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 24192.0 : 8037.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 24232.0 : 7577.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 28320.0 : 9814.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 40832.0 : 6485.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 26496.0 : 9814.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 23424.0 : 5529.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 22272.0 : 5477.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 24320.0 : 64921.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 65024.0 : 12246.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 59904.0 : 11007.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 43008.0 : 10752.0 ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 40960.0 : 2690.0 ) : idx;\n    }\n\telse\n\t{\n        idx = y == 22.0 ? ( x <= 7.0 ? 192.0 : 0.0 ) : idx;\n        idx = y == 21.0 ? ( x <= 7.0 ? 1008.0 : 0.0 ) : idx;\n        idx = y == 20.0 ? ( x <= 7.0 ? 3056.0 : 0.0 ) : idx;\n        idx = y == 19.0 ? ( x <= 7.0 ? 11224.0 : 0.0 ) : idx;\n        idx = y == 18.0 ? ( x <= 7.0 ? 11224.0 : 0.0 ) : idx;\n        idx = y == 17.0 ? ( x <= 7.0 ? 11224.0 : 0.0 ) : idx;\n        idx = y == 16.0 ? ( x <= 7.0 ? 11256.0 : 0.0 ) : idx;\n        idx = y == 15.0 ? ( x <= 7.0 ? 10986.0 : 0.0 ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 10918.0 : 0.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 2730.0 : 341.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 18986.0 : 1622.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 18954.0 : 5529.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 24202.0 : 8037.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 24200.0 : 7577.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 28288.0 : 9814.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 40864.0 : 6485.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 26496.0 : 9814.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 23424.0 : 5529.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 22272.0 : 5477.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 24320.0 : 64921.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 65152.0 : 4054.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 60064.0 : 11007.0 ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 2728.0 : 43520.0 ) : idx;\n\t}\n\n\tidx = SPRITE_DEC( x, idx );\n\n\tcolor = idx == 1.0 ? RGB( 30,  132,   0 ) : color;\n\tcolor = idx == 2.0 ? RGB( 215, 141,  34 ) : color;\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;    \n}\n\nvoid SpriteQuestion( inout vec3 color, float x, float y, float t )\n{\n\tfloat idx = 0.0;\n\tidx = y == 15.0 ? ( x <= 7.0 ? 43688.0 : 10922.0 ) : idx;\n\tidx = y == 14.0 ? ( x <= 7.0 ? 65534.0 : 32767.0 ) : idx;\n\tidx = y == 13.0 ? ( x <= 7.0 ? 65502.0 : 30719.0 ) : idx;\n\tidx = y == 12.0 ? ( x <= 7.0 ? 44030.0 : 32762.0 ) : idx;\n\tidx = y == 11.0 ? ( x <= 7.0 ? 23294.0 : 32745.0 ) : idx;\n\tidx = y == 10.0 ? ( x <= 7.0 ? 56062.0 : 32619.0 ) : idx;\n\tidx = y == 9.0 ? ( x <= 7.0 ? 56062.0 : 32619.0 ) : idx;\n\tidx = y == 8.0 ? ( x <= 7.0 ? 55294.0 : 32618.0 ) : idx;\n\tidx = y == 7.0 ? ( x <= 7.0 ? 49150.0 : 32598.0 ) : idx;\n\tidx = y == 6.0 ? ( x <= 7.0 ? 49150.0 : 32758.0 ) : idx;\n\tidx = y == 5.0 ? ( x <= 7.0 ? 65534.0 : 32757.0 ) : idx;\n\tidx = y == 4.0 ? ( x <= 7.0 ? 49150.0 : 32766.0 ) : idx;\n\tidx = y == 3.0 ? ( x <= 7.0 ? 49150.0 : 32758.0 ) : idx;\n\tidx = y == 2.0 ? ( x <= 7.0 ? 65502.0 : 30709.0 ) : idx;\n\tidx = y == 1.0 ? ( x <= 7.0 ? 65534.0 : 32767.0 ) : idx;\n\tidx = y == 0.0 ? 21845.0 : idx;\n\n\tidx = SPRITE_DEC( x, idx );\n\n\tcolor = idx == 1.0 ? RGB( 0,     0,   0 ) : color;\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\n\tcolor = idx == 3.0 ? mix( RGB( 255,  165, 66 ), RGB( 231,  90,  16 ), t ) : color;\n}\n\nvoid SpriteMushroom( inout vec3 color, float x, float y )\n{\n\tfloat idx = 0.0;\n\tidx = y == 15.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\n\tidx = y == 14.0 ? ( x <= 7.0 ? 43008.0 : 22.0 ) : idx;\n\tidx = y == 13.0 ? ( x <= 7.0 ? 43520.0 : 85.0 ) : idx;\n\tidx = y == 12.0 ? ( x <= 7.0 ? 43648.0 : 341.0 ) : idx;\n\tidx = y == 11.0 ? ( x <= 7.0 ? 43680.0 : 2646.0 ) : idx;\n\tidx = y == 10.0 ? ( x <= 7.0 ? 42344.0 : 10922.0 ) : idx;\n\tidx = y == 9.0 ? ( x <= 7.0 ? 38232.0 : 10922.0 ) : idx;\n\tidx = y == 8.0 ? ( x <= 7.0 ? 38234.0 : 42410.0 ) : idx;\n\tidx = y == 7.0 ? ( x <= 7.0 ? 38234.0 : 38314.0 ) : idx;\n\tidx = y == 6.0 ? ( x <= 7.0 ? 42346.0 : 38570.0 ) : idx;\n\tidx = y == 5.0 ? 43690.0 : idx;\n\tidx = y == 4.0 ? ( x <= 7.0 ? 64856.0 : 9599.0 ) : idx;\n\tidx = y == 3.0 ? ( x <= 7.0 ? 65280.0 : 255.0 ) : idx;\n\tidx = y == 2.0 ? ( x <= 7.0 ? 65280.0 : 239.0 ) : idx;\n\tidx = y == 1.0 ? ( x <= 7.0 ? 65280.0 : 239.0 ) : idx;\n\tidx = y == 0.0 ? ( x <= 7.0 ? 64512.0 : 59.0 ) : idx;\n\n\tidx = SPRITE_DEC( x, idx );\n\n\tcolor = idx == 1.0 ? RGB( 181, 49,   33 ) : color;\n\tcolor = idx == 2.0 ? RGB( 230, 156,  33 ) : color;\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;\n}\n\nvoid SpriteGround( inout vec3 color, float x, float y )\n{   \n\tfloat idx = 0.0;\n\tidx = y == 15.0 ? ( x <= 7.0 ? 65534.0 : 49127.0 ) : idx;\n\tidx = y == 14.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\n\tidx = y == 13.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\n\tidx = y == 12.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\n\tidx = y == 11.0 ? ( x <= 7.0 ? 43691.0 : 27254.0 ) : idx;\n\tidx = y == 10.0 ? ( x <= 7.0 ? 43691.0 : 38246.0 ) : idx;\n\tidx = y == 9.0 ? ( x <= 7.0 ? 43691.0 : 32758.0 ) : idx;\n\tidx = y == 8.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\n\tidx = y == 7.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\n\tidx = y == 6.0 ? ( x <= 7.0 ? 43691.0 : 27318.0 ) : idx;\n\tidx = y == 5.0 ? ( x <= 7.0 ? 43685.0 : 27309.0 ) : idx;\n\tidx = y == 4.0 ? ( x <= 7.0 ? 43615.0 : 27309.0 ) : idx;\n\tidx = y == 3.0 ? ( x <= 7.0 ? 22011.0 : 27307.0 ) : idx;\n\tidx = y == 2.0 ? ( x <= 7.0 ? 32683.0 : 27307.0 ) : idx;\n\tidx = y == 1.0 ? ( x <= 7.0 ? 27307.0 : 23211.0 ) : idx;\n\tidx = y == 0.0 ? ( x <= 7.0 ? 38230.0 : 38231.0 ) : idx;\n\n\tidx = SPRITE_DEC( x, idx );\n\n\tcolor = RGB( 0, 0, 0 );\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\n\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\n}\n\nvoid SpriteFlagpoleEnd( inout vec3 color, float x, float y )\n{   \n\tfloat idx = 0.0;\n\n\tidx = y == 7.0 ? 1360.0  : idx;\n\tidx = y == 6.0 ? 6836.0  : idx;\n\tidx = y == 5.0 ? 27309.0 : idx;\n\tidx = y == 4.0 ? 27309.0 : idx;\n\tidx = y == 3.0 ? 27305.0 : idx;\n\tidx = y == 2.0 ? 27305.0 : idx;\n\tidx = y == 1.0 ? 6820.0  : idx;\n\tidx = y == 0.0 ? 1360.0  : idx;\n\n\tidx = SPRITE_DEC( x, idx );\n\n\tcolor = idx == 1.0 ? RGB( 0,     0,  0 ) : color;\n\tcolor = idx == 2.0 ? RGB( 0,   173,  0 ) : color;\n\tcolor = idx == 3.0 ? RGB( 189, 255, 24 ) : color;\n}\n\nvoid SpriteMario( inout vec3 color, float x, float y, float frame )\n{    \n    float idx = 0.0;\n\n\tif ( frame == 0.0 )\n    {\n        idx = y == 14.0 ? ( x <= 7.0 ? 40960.0 : 42.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 43008.0 : 2730.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 21504.0 : 223.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 56576.0 : 4063.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 23808.0 : 16255.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 62720.0 : 1375.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 61440.0 : 1023.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 21504.0 : 793.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 22272.0 : 4053.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 23488.0 : 981.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 43328.0 : 170.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 43584.0 : 170.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 10832.0 : 42.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 16400.0 : 5.0 ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 16384.0 : 21.0 ) : idx;\n\t}\n    else if ( frame == 1.0 ) \n    {\n        idx = y == 15.0 ? ( x <= 7.0 ? 43008.0 : 10.0 ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 43520.0 : 682.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 54528.0 : 55.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 63296.0 : 1015.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 55104.0 : 4063.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 64832.0 : 343.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 64512.0 : 255.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 25856.0 : 5.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 38208.0 : 22.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 42304.0 : 235.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 38208.0 : 170.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 62848.0 : 171.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 62976.0 : 42.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 43008.0 : 21.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 21504.0 : 85.0 ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 21504.0 : 1.0 ) : idx;\n    }\n    else if ( frame == 2.0 ) \n    {\n        idx = y == 15.0 ? ( x <= 7.0 ? 43008.0 : 10.0 ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 43520.0 : 682.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 54528.0 : 55.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 63296.0 : 1015.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 55104.0 : 4063.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 64832.0 : 343.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 64512.0 : 255.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 42320.0 : 5.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 42335.0 : 16214.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 58687.0 : 15722.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 43535.0 : 1066.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 43648.0 : 1450.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 43680.0 : 1450.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 2708.0 : 1448.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 84.0 : 0.0 ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 336.0 : 0.0 ) : idx;\n    }\n    else if ( frame == 3.0 )\n    {\n        idx = y == 15.0 ? ( x <= 7.0 ? 0.0 : 64512.0 ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 40960.0 : 64554.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 43008.0 : 64170.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 21504.0 : 21727.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 56576.0 : 22495.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 23808.0 : 32639.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 62720.0 : 5471.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 61440.0 : 2047.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 38224.0 : 405.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 21844.0 : 16982.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 21855.0 : 17066.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 39487.0 : 23470.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 43596.0 : 23210.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 43344.0 : 23210.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 43604.0 : 42.0 ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 43524.0 : 0.0 ) : idx;\n    }\n    else if ( frame == 4.0 )\n    {\n        idx = y == 29.0 ? ( x <= 7.0 ? 32768.0 : 170.0 ) : idx;\n        idx = y == 28.0 ? ( x <= 7.0 ? 43008.0 : 234.0 ) : idx;\n        idx = y == 27.0 ? ( x <= 7.0 ? 43520.0 : 250.0 ) : idx;\n        idx = y == 26.0 ? ( x <= 7.0 ? 43520.0 : 10922.0 ) : idx;\n        idx = y == 25.0 ? ( x <= 7.0 ? 54528.0 : 1015.0 ) : idx;\n        idx = y == 24.0 ? ( x <= 7.0 ? 57152.0 : 16343.0 ) : idx;\n        idx = y == 23.0 ? ( x <= 7.0 ? 24384.0 : 65535.0 ) : idx;\n        idx = y == 22.0 ? ( x <= 7.0 ? 24400.0 : 65407.0 ) : idx;\n        idx = y == 21.0 ? ( x <= 7.0 ? 65360.0 : 5463.0 ) : idx;\n        idx = y == 20.0 ? ( x <= 7.0 ? 64832.0 : 5471.0 ) : idx;\n        idx = y == 19.0 ? ( x <= 7.0 ? 62464.0 : 4095.0 ) : idx;\n        idx = y == 18.0 ? ( x <= 7.0 ? 43264.0 : 63.0 ) : idx;\n        idx = y == 17.0 ? ( x <= 7.0 ? 22080.0 : 6.0 ) : idx;\n        idx = y == 16.0 ? ( x <= 7.0 ? 22080.0 : 25.0 ) : idx;\n        idx = y == 15.0 ? ( x <= 7.0 ? 22096.0 : 4005.0 ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 22160.0 : 65365.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 23184.0 : 65365.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 23168.0 : 64853.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 27264.0 : 64853.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 43648.0 : 598.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 43648.0 : 682.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 43648.0 : 426.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 43605.0 : 2666.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 43605.0 : 2710.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 43605.0 : 681.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 10837.0 : 680.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 85.0 : 340.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 5.0 : 340.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 1.0 : 5460.0 ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 0.0 : 5460.0 ) : idx;\n    }\n    else if ( frame == 5.0 )\n    {\n        idx = y == 30.0 ? ( x <= 7.0 ? 40960.0 : 42.0 ) : idx;\n        idx = y == 29.0 ? ( x <= 7.0 ? 43520.0 : 58.0 ) : idx;\n        idx = y == 28.0 ? ( x <= 7.0 ? 43648.0 : 62.0 ) : idx;\n        idx = y == 27.0 ? ( x <= 7.0 ? 43648.0 : 2730.0 ) : idx;\n        idx = y == 26.0 ? ( x <= 7.0 ? 62784.0 : 253.0 ) : idx;\n        idx = y == 25.0 ? ( x <= 7.0 ? 63440.0 : 4085.0 ) : idx;\n        idx = y == 24.0 ? ( x <= 7.0 ? 55248.0 : 16383.0 ) : idx;\n        idx = y == 23.0 ? ( x <= 7.0 ? 55252.0 : 16351.0 ) : idx;\n        idx = y == 22.0 ? ( x <= 7.0 ? 65492.0 : 1365.0 ) : idx;\n        idx = y == 21.0 ? ( x <= 7.0 ? 65360.0 : 1367.0 ) : idx;\n        idx = y == 20.0 ? ( x <= 7.0 ? 64832.0 : 1023.0 ) : idx;\n        idx = y == 19.0 ? ( x <= 7.0 ? 43520.0 : 15.0 ) : idx;\n        idx = y == 18.0 ? ( x <= 7.0 ? 38464.0 : 22.0 ) : idx;\n        idx = y == 17.0 ? ( x <= 7.0 ? 21904.0 : 26.0 ) : idx;\n        idx = y == 16.0 ? ( x <= 7.0 ? 21904.0 : 90.0 ) : idx;\n        idx = y == 15.0 ? ( x <= 7.0 ? 21904.0 : 106.0 ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 21904.0 : 125.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 21904.0 : 255.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 21920.0 : 767.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 22176.0 : 2815.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 23200.0 : 2751.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 43680.0 : 2725.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 43648.0 : 661.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 27136.0 : 341.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 23040.0 : 85.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 26624.0 : 21.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 41984.0 : 86.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 21504.0 : 81.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 21760.0 : 1.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 21760.0 : 21.0 ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 20480.0 : 21.0 ) : idx;\n    }\n    else if ( frame == 6.0 )\n    {\n        idx = y == 31.0 ? ( x <= 7.0 ? 40960.0 : 42.0 ) : idx;\n        idx = y == 30.0 ? ( x <= 7.0 ? 43520.0 : 58.0 ) : idx;\n        idx = y == 29.0 ? ( x <= 7.0 ? 43648.0 : 62.0 ) : idx;\n        idx = y == 28.0 ? ( x <= 7.0 ? 43648.0 : 2730.0 ) : idx;\n        idx = y == 27.0 ? ( x <= 7.0 ? 62784.0 : 253.0 ) : idx;\n        idx = y == 26.0 ? ( x <= 7.0 ? 63440.0 : 4085.0 ) : idx;\n        idx = y == 25.0 ? ( x <= 7.0 ? 55248.0 : 16383.0 ) : idx;\n        idx = y == 24.0 ? ( x <= 7.0 ? 55252.0 : 16351.0 ) : idx;\n        idx = y == 23.0 ? ( x <= 7.0 ? 65492.0 : 1365.0 ) : idx;\n        idx = y == 22.0 ? ( x <= 7.0 ? 65364.0 : 1367.0 ) : idx;\n        idx = y == 21.0 ? ( x <= 7.0 ? 64832.0 : 1023.0 ) : idx;\n        idx = y == 20.0 ? ( x <= 7.0 ? 21504.0 : 15.0 ) : idx;\n        idx = y == 19.0 ? ( x <= 7.0 ? 43520.0 : 12325.0 ) : idx;\n        idx = y == 18.0 ? ( x <= 7.0 ? 38208.0 : 64662.0 ) : idx;\n        idx = y == 17.0 ? ( x <= 7.0 ? 21840.0 : 64922.0 ) : idx;\n        idx = y == 16.0 ? ( x <= 7.0 ? 21844.0 : 65114.0 ) : idx;\n        idx = y == 15.0 ? ( x <= 7.0 ? 21844.0 : 30298.0 ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 38228.0 : 5722.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 42325.0 : 1902.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 43605.0 : 682.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 44031.0 : 682.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 44031.0 : 17066.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 43775.0 : 21162.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 43772.0 : 21866.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 43392.0 : 21866.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 42640.0 : 21866.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 23189.0 : 21866.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 43605.0 : 21824.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 2389.0 : 0.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 84.0 : 0.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 84.0 : 0.0 ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 336.0 : 0.0 ) : idx;\n    }\n    else\n    {\n        idx = y == 31.0 ? ( x <= 7.0 ? 0.0 : 16128.0 ) : idx;\n        idx = y == 30.0 ? ( x <= 7.0 ? 0.0 : 63424.0 ) : idx;\n        idx = y == 29.0 ? ( x <= 7.0 ? 40960.0 : 55274.0 ) : idx;\n        idx = y == 28.0 ? ( x <= 7.0 ? 43520.0 : 65514.0 ) : idx;\n        idx = y == 27.0 ? ( x <= 7.0 ? 43648.0 : 21866.0 ) : idx;\n        idx = y == 26.0 ? ( x <= 7.0 ? 43648.0 : 23210.0 ) : idx;\n        idx = y == 25.0 ? ( x <= 7.0 ? 62784.0 : 22013.0 ) : idx;\n        idx = y == 24.0 ? ( x <= 7.0 ? 63440.0 : 24573.0 ) : idx;\n        idx = y == 23.0 ? ( x <= 7.0 ? 55248.0 : 32767.0 ) : idx;\n        idx = y == 22.0 ? ( x <= 7.0 ? 55248.0 : 32735.0 ) : idx;\n        idx = y == 21.0 ? ( x <= 7.0 ? 65492.0 : 5461.0 ) : idx;\n        idx = y == 20.0 ? ( x <= 7.0 ? 64852.0 : 7511.0 ) : idx;\n        idx = y == 19.0 ? ( x <= 7.0 ? 64832.0 : 6143.0 ) : idx;\n        idx = y == 18.0 ? ( x <= 7.0 ? 43520.0 : 5477.0 ) : idx;\n        idx = y == 17.0 ? ( x <= 7.0 ? 38228.0 : 1382.0 ) : idx;\n        idx = y == 16.0 ? ( x <= 7.0 ? 21845.0 : 1430.0 ) : idx;\n        idx = y == 15.0 ? ( x <= 7.0 ? 21845.0 : 410.0 ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 22005.0 : 602.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 38909.0 : 874.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 43007.0 : 686.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 44031.0 : 682.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 43763.0 : 17066.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 43708.0 : 21162.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 43648.0 : 21930.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 43584.0 : 21930.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 42389.0 : 21930.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 23189.0 : 21930.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 43669.0 : 21920.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 43669.0 : 0.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 10901.0 : 0.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 5.0 : 0.0 ) : idx;\n    }\n    \n    idx = SPRITE_DEC( x, idx );\n    \n\tcolor = idx == 1.0 ? RGB( 106, 107,  4 ) : color;\n\tcolor = idx == 2.0 ? RGB( 177,  52, 37 ) : color;\n\tcolor = idx == 3.0 ? RGB( 227, 157, 37 ) : color;    \n}\n\nvoid SpriteCoin( inout vec3 color, float x, float y, float frame )\n{    \n    float idx = 0.0;\n\tif ( frame == 0.0 )\n    {\n        idx = y == 14.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 28672.0 : 5.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 28672.0 : 5.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 24576.0 : 5.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 32768.0 : 1.0 ) : idx;\n\t}\n    else if ( frame == 1.0 ) \n    {\n        idx = y == 14.0 ? ( x <= 7.0 ? 32768.0 : 2.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 43008.0 : 42.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 59392.0 : 41.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 47616.0 : 166.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 59392.0 : 41.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 43008.0 : 42.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 40960.0 : 10.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 32768.0 : 2.0 ) : idx;;\n    }\n    else if ( frame == 2.0 ) \n    {\n        idx = y == 14.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 61440.0 : 7.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 49152.0 : 1.0 ) : idx;\n    }\n    else\n    {\n        idx = y == 14.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 0.0 : 3.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 0.0 : 3.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 0.0 : 2.0 ) : idx;\n    }\n    \n\tidx = SPRITE_DEC( x, idx );\n\n\tcolor = idx == 1.0 ? RGB( 181, 49,   33 ) : color;\n\tcolor = idx == 2.0 ? RGB( 230, 156,  33 ) : color;\n\tcolor = idx == 3.0 ? RGB( 255, 255, 255 ) : color;    \n}\n\nvoid SpriteBrick( inout vec3 color, float x, float y )\n{    \n\tfloat ymod4 = floor( mod( y, 4.0 ) );    \n    float xmod8 = floor( mod( x, 8.0 ) );\n    float ymod8 = floor( mod( y, 8.0 ) );\n    \n    \/\/ dark orange\n    float idx = 2.0;\n   \n    \/\/ black\n    idx = ymod4 == 0.0 ? 1.0 : idx;\n    idx = xmod8 == ( ymod8 < 4.0 ? 3.0 : 7.0 ) ? 1.0 : idx;\n\n    \/\/ light orange\n    idx = y == 15.0 ? 3.0 : idx;\n\n    color = idx == 1.0 ? RGB( 0,     0,   0 ) : color;\n\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\n\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\n}\n\nvoid DrawCastle( inout vec3 color, float x, float y )\n{\n\tif ( x >= 0.0 && x < 80.0 && y >= 0.0 && y < 80.0 )\n\t{\n\t\tfloat ymod4    = mod( y, 4.0 );\n\t\tfloat xmod8    = mod( x, 8.0 );\n\t\tfloat xmod16_4 = mod( x + 4.0, 16.0 );\n\t\tfloat xmod16_3 = mod( x + 5.0, 16.0 );\n\t\tfloat ymod8    = mod( y, 8.0 );\n\n\t\t\/\/ dark orange\n\t\tfloat idx = 2.0;\n\n\t\t\/\/ black\n\t\tidx = ymod4 == 0.0 && y <= 72.0 && ( y != 44.0 || xmod16_3 > 8.0 ) ? 1.0 : idx;\n\t\tidx = x >= 24.0 && x <= 32.0 && y >= 48.0 && y <= 64.0 ? 1.0 : idx;\n\t\tidx = x >= 48.0 && x <= 56.0 && y >= 48.0 && y <= 64.0 ? 1.0 : idx;\n\t\tidx = x >= 32.0 && x <= 47.0 && y <= 25.0 ? 1.0 : idx;\n\t\tidx = xmod8 == ( ymod8 < 4.0 ? 3.0 : 7.0 ) && y <= 72.0 && ( xmod16_3 > 8.0 || y <= 40.0 || y >= 48.0 ) ? 1.0 : idx;  \n\n\t\t\/\/ white\n\t\tidx = y == ( xmod16_4 < 8.0 ? 47.0 : 40.0 ) ? 3.0 : idx;\n\t\tidx = y == ( xmod16_4 < 8.0 ? 79.0 : 72.0 ) ? 3.0 : idx;\n\t\tidx = xmod8 == 3.0 && y >= 40.0 && y <= 47.0 ? 3.0 : idx;\n\t\tidx = xmod8 == 3.0 && y >= 72.0 ? 3.0 : idx;\n\n\t\t\/\/ transparent\n\t\tidx = ( x < 16.0 || x >= 64.0 ) && y >= 48.0 ? 0.0 : idx;\n\t\tidx = x >= 4.0  && x <= 10.0 && y >= 41.0 && y <= 47.0 ? 0.0 : idx;\n\t\tidx = x >= 68.0 && x <= 74.0 && y >= 41.0 && y <= 47.0 ? 0.0 : idx;             \n\t\tidx = y >= 73.0 && xmod16_3 > 8.0 ? 0.0 : idx;\n\n\t\tcolor = idx == 1.0 ? RGB(   0,   0,   0 ) : color;\n\t\tcolor = idx == 2.0 ? RGB( 231,  90,  16 ) : color;\n\t\tcolor = idx == 3.0 ? RGB( 247, 214, 181 ) : color;\n\t}\n}\n\nvoid DrawKoopa( inout vec3 color, float x, float y, float frame )\n{\n    if ( x >= 0.0 && x <= 15.0 )\n    {\n        SpriteKoopa( color, x, y, frame );\n    }\n}\n\nvoid KoopaWalk( inout vec3 color, float worldX, float worldY, float time, float frame, float startX )\n{\n    float x = worldX - startX + floor( time * GOOMBA_SPEED );\n    DrawKoopa( color, x, worldY - 16.0, frame );    \n}\n\nvoid DrawHitQuestion( inout vec3 color, float questionX, float questionY, float time, float questionT, float questionHitTime )\n{\n\tfloat t = clamp( ( time - questionHitTime ) \/ 0.25, 0.0, 1.0 );\n    t = 1.0 - abs( 2.0 * t - 1.0 );\n\n    questionY -= floor( t * 8.0 );\n    if ( questionX >= 0.0 && questionX <= 15.0 )\n    {            \n    \tif ( time >= questionHitTime )\n        {                \n        \tSpriteQuestion( color, questionX, questionY, 1.0 );\n            if ( questionX >= 3.0 && questionX <= 12.0 && questionY >= 1.0 && questionY <= 15.0 )\n            {\n                color = RGB( 231, 90, 16 );\n            }\n        }\n        else\n        {\n         \tSpriteQuestion( color, questionX, questionY, questionT );\n        }\n    }\n}\n\nvoid DrawW( inout vec3 color, float x, float y )\n{\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\n    {\n        if (    ( x <= 3.0 || x >= 10.0 ) \n             || ( x >= 4.0 && x <= 5.0 && y >= 2.0 && y <= 7.0 )\n             || ( x >= 8.0 && x <= 9.0 && y >= 2.0 && y <= 7.0 )\n             || ( x >= 6.0 && x <= 7.0 && y >= 4.0 && y <= 9.0 )\n           )\n        {\n            color = RGB( 255, 255, 255 );\n        }\n    }\n}\n\nvoid DrawO( inout vec3 color, float x, float y )\n{\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\n    {\n        if (    ( x <= 1.0 || x >= 12.0 ) && ( y >= 2.0 && y <= 11.0 )\n             || ( x >= 2.0 && x <= 4.0 )\n             || ( x >= 9.0 && x <= 11.0 )\n             || ( y <= 1.0 || y >= 11.0 ) && ( x >= 2.0 && x <= 11.0 )\n           )\n        {\n            color = RGB( 255, 255, 255 );\n        }\n    }\n}\n\nvoid DrawR( inout vec3 color, float x, float y )\n{\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\n    {\n        if (    ( x <= 3.0 )\n\t\t\t || ( y >= 12.0 && x <= 11.0 )\n             || ( x >= 10.0 && y >= 6.0 && y <= 11.0 )\n             || ( x >= 8.0  && x <= 9.0 && y <= 7.0 )\n             || ( x <= 9.0  && y >= 4.0 && y <= 5.0 )\n             || ( x >= 8.0  && y <= 1.0 )\n             || ( x >= 6.0  && x <= 11.0 && y >= 2.0 && y <= 3.0 )\n           )\n        {\n            color = RGB( 255, 255, 255 );\n        }\n    }\n}\n\nvoid DrawL( inout vec3 color, float x, float y )\n{\n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\n    {\n        if ( x <= 3.0 || y <= 1.0 )\n        {\n            color = RGB( 255, 255, 255 );\n        }\n    }\n}\n\nvoid DrawD( inout vec3 color, float x, float y )\n{    \n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\n    {\n    \tcolor = RGB( 255, 255, 255 );        \n        \n        if (    ( x >= 4.0 && x <= 7.0 && y >= 2.0 && y <= 11.0 ) \n           \t || ( x >= 8.0 && x <= 9.0 && y >= 4.0 && y <= 9.0 ) \n             || ( x >= 12.0 && ( y <= 3.0 || y >= 10.0 ) )\n             || ( x >= 10.0 && ( y <= 1.0 || y >= 12.0 ) )\n           )\n        {\n            color = RGB( 0, 0, 0 );\n        }\n    }\n}\n\nvoid Draw1( inout vec3 color, float x, float y )\n{    \n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\n    {\n        if (    ( y <= 1.0 )\n             || ( x >= 5.0 && x <= 8.0 )\n             || ( x >= 3.0 && x <= 4.0 && y >= 10.0 && y <= 11.0 )\n           )\n        {\n            color = RGB( 255, 255, 255 );\n        }\n    }\n}\n\nvoid DrawM( inout vec3 color, float x, float y )\n{    \n    if ( x >= 0.0 && x < 14.0 && y >= 0.0 && y < 14.0 )\n    {\n        if ( y >= 4.0 && y <= 7.0 )\n        {\n            color = RGB( 255, 255, 255 );\n        }\n    }\n}\n\nvoid DrawIntro( inout vec3 color, float x, float y, float screenWidth, float screenHeight )\n{\n    color = RGB( 0, 0, 0 );\n        \n    float offset \t= 18.0;     \n    float textX \t= floor( x - ( screenWidth - offset * 8.0 - 7.0 ) \/ 2.0 );\n    float textY \t= floor( y - ( screenHeight - 7.0 ) \/ 2.0 - 16.0 * 2.0 );\n    float marioX\t= textX - offset * 4.0;\n    float marioY\t= textY + 16.0 * 3.0;\n\t\n    DrawW( color, textX - offset * 0.0, textY );\n    DrawO( color, textX - offset * 1.0, textY );\n    DrawR( color, textX - offset * 2.0, textY );\n    DrawL( color, textX - offset * 3.0, textY );\n    DrawD( color, textX - offset * 4.0, textY );\n    Draw1( color, textX - offset * 6.0, textY );\n    DrawM( color, textX - offset * 7.0, textY );\n    Draw1( color, textX - offset * 8.0, textY );\n    \n    if ( marioX >= 0.0 && marioX <= 15.0 )\n    {\n    \tSpriteMario( color, marioX, marioY, 4.0 );\n    }\n}\n\nfloat CoinAnimY( float worldY, float time, float coinTime )\n{\n\treturn worldY - 4.0 * 16.0 - floor( 64.0 * ( 1.0 - abs( 2.0 * ( clamp( ( time - coinTime ) \/ 0.8, 0.0, 1.0 ) ) - 1.0 ) ) );\n}\n\nfloat QuestionAnimY( float worldY, float time, float questionHitTime )\n{\n     return worldY - 4.0 * 16.0 - floor( 8.0 * ( 1.0 - abs( 2.0 * clamp( ( time - questionHitTime ) \/ 0.25, 0.0, 1.0 ) - 1.0 ) ) );\n}\n\nfloat GoombaSWalkX( float worldX, float startX, float time, float goombaLifeTime )\n{\n    return worldX + floor( min( time, goombaLifeTime ) * GOOMBA_SPEED ) - startX;\n}\n\nvoid DrawGame( inout vec3 color, float time, float pixelX, float pixelY, float screenWidth, float screenHeight )\n{\n    float mushroomPauseStart \t= 16.25;    \n    float mushroomPauseLength \t= 2.0;    \n    float flagPauseStart\t\t= 38.95;\n    float flagPauseLength\t\t= 1.5;\n\n    float cameraP1\t\t= clamp( time - mushroomPauseStart, 0.0, mushroomPauseLength );\n    float cameraP2\t\t= clamp( time - flagPauseStart,     0.0, flagPauseLength );\n    float cameraX \t\t= floor( min( ( time - cameraP1 - cameraP2 ) * MARIO_SPEED - 240.0, 3152.0 ) );\n    float worldX \t\t= pixelX + cameraX;\n    float worldY  \t\t= pixelY - 8.0;\n    float tileX\t\t\t= floor( worldX \/ 16.0 );\n    float tileY\t\t\t= floor( worldY \/ 16.0 );\n    float tile2X\t\t= floor( worldX \/ 32.0 );\n    float tile2Y\t\t= floor( worldY \/ 32.0 );    \n    float worldXMod16\t= mod( worldX, 16.0 );\n    float worldYMod16 \t= mod( worldY, 16.0 );\n\n\n    \/\/ default background color\n    color = RGB( 92, 148, 252 );\n\n    \n    \/\/ draw hills\n    float bigHillX \t = mod( worldX, 768.0 );\n    float smallHillX = mod( worldX - 240.0, 768.0 );\n    float hillX \t = min( bigHillX, smallHillX );\n    float hillY      = worldY - ( smallHillX < bigHillX ? 0.0 : 16.0 );\n    SpriteHill( color, hillX, hillY );\n\n\n    \/\/ draw clouds and bushes\n\tfloat sc1CloudX = mod( worldX - 296.0, 768.0 );\n    float sc2CloudX = mod( worldX - 904.0, 768.0 );\n    float mcCloudX  = mod( worldX - 584.0, 768.0 );\n    float lcCloudX  = mod( worldX - 440.0, 768.0 );    \n    float scCloudX  = min( sc1CloudX, sc2CloudX );\n    float sbCloudX \t= mod( worldX - 376.0, 768.0 );\n    float mbCloudX  = mod( worldX - 664.0, 768.0 );  \n\tfloat lbCloudX  = mod( worldX - 184.0, 768.0 );\n    float cCloudX\t= min( min( scCloudX, mcCloudX ), lcCloudX );\n    float bCloudX\t= min( min( sbCloudX, mbCloudX ), lbCloudX );\n    float sCloudX\t= min( scCloudX, sbCloudX );\n    float mCloudX\t= min( mcCloudX, mbCloudX );\n    float lCloudX\t= min( lcCloudX, lbCloudX );\n    float cloudX\t= min( cCloudX, bCloudX );\n    float isBush\t= bCloudX < cCloudX ? 1.0 : 0.0;\n    float cloudSeg\t= cloudX == sCloudX ? 0.0 : ( cloudX == mCloudX ? 1.0 : 2.0 );\n    float cloudY\t= worldY - ( isBush == 1.0 ? 8.0 : ( ( cloudSeg == 0.0 && sc1CloudX < sc2CloudX ) || cloudSeg == 1.0 ? 168.0 : 152.0 ) );\n\tif ( cloudX >= 0.0 && cloudX < 32.0 + 16.0 * cloudSeg )\n    {\n        if ( cloudSeg == 1.0 )\n        {\n        \tcloudX = cloudX < 24.0 ? cloudX : cloudX - 16.0;\n        }\n        if ( cloudSeg == 2.0 )\n        {\n        \tcloudX = cloudX < 24.0 ? cloudX : ( cloudX < 40.0 ? cloudX - 16.0 : cloudX - 32.0 );\n        }\n        \n    \tSpriteCloud( color, cloudX, cloudY, isBush );\n    }\n\n    \n    \n    \/\/ draw flag pole\n    if ( worldX >= 3175.0 && worldX <= 3176.0 && worldY <= 176.0 )        \n    {\n        color = RGB( 189, 255, 24 );\n    }\n    \n    \/\/ draw flag\n    float flagX = worldX - 3160.0;\n    float flagY = worldY - 159.0 + floor( 122.0 * clamp( ( time - 39.0 ) \/ 1.0, 0.0, 1.0 ) );\n    if ( flagX >= 0.0 && flagX <= 15.0 )\n    {\n    \tSpriteFlag( color, flagX, flagY );\n    }     \n    \n    \/\/ draw flagpole end\n    float flagpoleEndX = worldX - 3172.0;\n    float flagpoleEndY = worldY - 176.0;\n    if ( flagpoleEndX >= 0.0 && flagpoleEndX <= 7.0 )\n    {\n    \tSpriteFlagpoleEnd( color, flagpoleEndX, flagpoleEndY );\n    }\n    \n    \n\n    \/\/ draw blocks\n   \tif (    ( tileX >= 134.0 && tileX < 138.0 && tileX - 132.0 > tileY )\n         || ( tileX >= 140.0 && tileX < 144.0 && 145.0 - tileX > tileY )\n         || ( tileX >= 148.0 && tileX < 153.0 && tileX - 146.0 > tileY && tileY < 5.0 )\n         || ( tileX >= 155.0 && tileX < 159.0 && 160.0 - tileX > tileY ) \n         || ( tileX >= 181.0 && tileX < 190.0 && tileX - 179.0 > tileY && tileY < 9.0 )\n         || ( tileX == 198.0 && tileY == 1.0 )\n       )\n    {\n        SpriteBlock( color, worldXMod16, worldYMod16 );\n    }\n    \n    \n    \/\/ draw pipes\n    float pipeY = worldY - 16.0;  \n    float pipeH\t= 0.0;    \n    float pipeX = worldX - 179.0 * 16.0;\n    if ( pipeX < 0.0 )\n    {\n        pipeX = worldX - 163.0 * 16.0;\n        pipeH = 0.0;\n    }\n    if ( pipeX < 0.0 )\n    {\n        pipeX = worldX - 57.0 * 16.0;\n        pipeH = 2.0;\n    }\n    if ( pipeX < 0.0 )\n    {\n        pipeX = worldX - 46.0 * 16.0;\n        pipeH = 2.0;\n    } \n    if ( pipeX < 0.0 )\n    {\n        pipeX = worldX - 38.0 * 16.0;\n        pipeH = 1.0;\n    }         \n    if ( pipeX < 0.0 )\n    {\n        pipeX = worldX - 28.0 * 16.0;\n        pipeH = 0.0;\n    }\n    if ( pipeX >= 0.0 && pipeX <= 31.0 && pipeY >= 0.0 && pipeY <= 31.0 + pipeH * 16.0 )\n\t{\n\t\tSpritePipe( color, pipeX, pipeY, pipeH );\n\t}\n    \n    \n    \/\/ draw mushroom\n    float mushroomStart = 15.7;    \n    if ( time >= mushroomStart && time <= 17.0 )\n    {\n        float jumpTime = 0.5;\n        \n        float mushroomX = worldX - 1248.0;\n        float mushroomY = worldY - 4.0 * 16.0;\n        if ( time >= mushroomStart )\n        {\n            mushroomY = worldY - 4.0 * 16.0 - floor( 16.0 * clamp( ( time - mushroomStart ) \/ 0.5, 0.0, 1.0 ) );\n        }\n        if ( time >= mushroomStart + 0.5 )\n        {\n            mushroomX -= floor( MARIO_SPEED * ( time - mushroomStart - 0.5 ) );\n        }\n        if ( time >= mushroomStart + 0.5 + 0.4 )\n        {\n            mushroomY = mushroomY + floor( sin( ( ( time - mushroomStart - 0.5 - 0.4 ) ) * 3.14 ) * 4.0 * 16.0 );\n        }\n        \n        if ( mushroomX >= 0.0 && mushroomX <= 15.0 )\n        {\n        \tSpriteMushroom( color, mushroomX, mushroomY );\n        }\n    }\n\n    \n    \/\/ draw coins\n    float coinFrame = floor( mod( time * 12.0, 4.0 ) );\n    float coinX \t= worldX - 2720.0;\n    float coinTime \t= 33.9;    \n    float coinY \t= CoinAnimY( worldY, time, coinTime );\n    if ( coinX < 0.0 )\n    {\n    \tcoinX \t\t= worldX - 1696.0;\n    \tcoinTime \t= 22.4;    \n    \tcoinY \t\t= CoinAnimY( worldY, time, coinTime );        \n    }\n    if ( coinX < 0.0 )\n    {\n    \tcoinX \t\t= worldX - 352.0;\n    \tcoinTime \t= 5.4;    \n    \tcoinY \t\t= CoinAnimY( worldY, time, coinTime );\n    } \n    \n    if ( coinX >= 0.0 && coinX <= 15.0 && time >= coinTime + 0.1 )\n    {   \n        SpriteCoin( color, coinX, coinY, coinFrame );\n    }\n\n    \n    \/\/ draw questions\n\tfloat questionT = clamp( sin( time * 6.0 ), 0.0, 1.0 );    \n    if (    ( tileY == 4.0 && ( tileX == 16.0 || tileX == 20.0 || tileX == 109.0 || tileX == 112.0 ) )\n         || ( tileY == 8.0 && ( tileX == 21.0 || tileX == 94.0 || tileX == 109.0 ) )\n         || ( tileY == 8.0 && ( tileX >= 129.0 && tileX <= 130.0 ) )\n       )\n    {\n        SpriteQuestion( color, worldXMod16, worldYMod16, questionT );\n    }\n    \n    \n    \/\/ draw hitted questions\n    float questionHitTime \t= 33.9;\n    float questionX \t\t= worldX - 2720.0;\n    if ( questionX < 0.0 )\n    {\n        questionHitTime = 22.4;\n        questionX\t\t= worldX - 1696.0;\n    }\n    if ( questionX < 0.0 )\n    {\n        questionHitTime = 15.4;\n        questionX\t\t= worldX - 1248.0;\n    }\n    if ( questionX < 0.0 )\n    {\n        questionHitTime = 5.3;\n        questionX\t\t= worldX - 352.0;\n    }    \n    questionT\t\t= time >= questionHitTime ? 1.0 : questionT;    \n    float questionY = QuestionAnimY( worldY, time, questionHitTime );\n    if ( questionX >= 0.0 && questionX <= 15.0 )\n    {\n    \tSpriteQuestion( color, questionX, questionY, questionT );\n    }\n    if ( time >= questionHitTime && questionX >= 3.0 && questionX <= 12.0 && questionY >= 1.0 && questionY <= 15.0 )\n    {\n        color = RGB( 231, 90, 16 );\n    }    \n\n    \n    \/\/ draw bricks\n   \tif (    ( tileY == 4.0 && ( tileX == 19.0 || tileX == 21.0 || tileX == 23.0 || tileX == 77.0 || tileX == 79.0 || tileX == 94.0 || tileX == 118.0 || tileX == 168.0 || tileX == 169.0 || tileX == 171.0 ) )\n         || ( tileY == 8.0 && ( tileX == 128.0 || tileX == 131.0 ) )\n         || ( tileY == 8.0 && ( tileX >= 80.0 && tileX <= 87.0 ) )\n         || ( tileY == 8.0 && ( tileX >= 91.0 && tileX <= 93.0 ) )\n         || ( tileY == 4.0 && ( tileX >= 100.0 && tileX <= 101.0 ) )\n         || ( tileY == 8.0 && ( tileX >= 121.0 && tileX <= 123.0 ) )\n         || ( tileY == 4.0 && ( tileX >= 129.0 && tileX <= 130.0 ) )\n       )\n    {\n        SpriteBrick( color, worldXMod16, worldYMod16 );\n    }   \n    \n    \n    \/\/ draw castle flag\n    float castleFlagX = worldX - 3264.0;\n    float castleFlagY = worldY - 64.0 - floor( 32.0 * clamp( ( time - 44.6 ) \/ 1.0, 0.0, 1.0 ) );\n    if ( castleFlagX > 0.0 && castleFlagX < 14.0 )\n    {\n    \tSpriteCastleFlag( color, castleFlagX, castleFlagY );\n\t}\n    \n    DrawCastle( color, worldX - 3232.0, worldY - 16.0 );\n\n    \/\/ draw ground\n    if ( tileY <= 0.0\n         && !( tileX >= 69.0  && tileX < 71.0 )\n         && !( tileX >= 86.0  && tileX < 89.0 ) \n         && !( tileX >= 153.0 && tileX < 155.0 ) \n       )\n    {\n        SpriteGround( color, worldXMod16, worldYMod16 );\n    }    \n    \n\n    \/\/ draw Koopa\n    float goombaFrame = floor( mod( time * 5.0, 2.0 ) );\n    KoopaWalk( color, worldX, worldY, time, goombaFrame, 2370.0 );\n    \n    \n    \/\/ draw stomped walking Goombas\n    float goombaY \t\t\t= worldY - 16.0;        \n    float goombaLifeTime \t= 26.3;\n    float goombaX \t\t\t= GoombaSWalkX( worldX, 2850.0 + 24.0, time, goombaLifeTime );\n    if ( goombaX < 0.0 )\n    {\n        goombaLifeTime \t= 25.3;\n        goombaX \t\t= GoombaSWalkX( worldX, 2760.0, time, goombaLifeTime );\n    }\n    if ( goombaX < 0.0 ) \n    {\n\t\tgoombaLifeTime \t= 23.5;\n        goombaX \t\t= GoombaSWalkX( worldX, 2540.0, time, goombaLifeTime );\n    }\n    if ( goombaX < 0.0 ) \n    {\n        goombaLifeTime \t= 20.29;\n        goombaX \t\t= GoombaSWalkX( worldX, 2150.0, time, goombaLifeTime );\n    }\n    if ( goombaX < 0.0 )\n    {\n        goombaLifeTime \t= 10.3;\n\t\tgoombaX \t\t= worldX - 790.0 - floor( abs( mod( ( min( time, goombaLifeTime ) + 6.3 ) * GOOMBA_SPEED, 2.0 * 108.0 ) - 108.0 ) );\n    }\n\tgoombaFrame = time > goombaLifeTime ? 2.0 : goombaFrame;\n    if ( goombaX >= 0.0 && goombaX <= 15.0 )\n    {\n        SpriteGoomba( color, goombaX, goombaY, goombaFrame );\n    }    \n    \n    \/\/ draw walking Goombas\n    goombaFrame \t\t= floor( mod( time * 5.0, 2.0 ) );\n    float goombaWalkX \t= worldX + floor( time * GOOMBA_SPEED );\n    goombaX \t\t\t= goombaWalkX - 3850.0 - 24.0;\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 3850.0;\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2850.0;\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2760.0 - 24.0;\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2540.0 - 24.0;\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 2150.0 - 24.0;\n    if ( goombaX < 0.0 ) goombaX = worldX - 766.0 - floor( abs( mod( ( time + 6.3 ) * GOOMBA_SPEED, 2.0 * 108.0 ) - 108.0 ) );\n    if ( goombaX < 0.0 ) goombaX = worldX - 638.0 - floor( abs( mod( ( time + 6.6 ) * GOOMBA_SPEED, 2.0 * 84.0 ) - 84.0 ) );\n    if ( goombaX < 0.0 ) goombaX = goombaWalkX - 435.0;\n    if ( goombaX >= 0.0 && goombaX <= 15.0 )\n    {\n        SpriteGoomba( color, goombaX, goombaY, goombaFrame );\n    }\n    \n\n    \n    \/\/ Mario jump\n    float marioBigJump1 \t= 27.1;\n    float marioBigJump2 \t= 29.75;\n    float marioBigJump3 \t= 35.05;    \n    float marioJumpTime \t= 0.0;\n    float marioJumpScale\t= 0.0;\n    \n    if ( time >= 4.2   ) { marioJumpTime = 4.2;   marioJumpScale = 0.45; }\n    if ( time >= 5.0   ) { marioJumpTime = 5.0;   marioJumpScale = 0.5;  }\n    if ( time >= 6.05  ) { marioJumpTime = 6.05;  marioJumpScale = 0.7;  }\n    if ( time >= 7.8   ) { marioJumpTime = 7.8;   marioJumpScale = 0.8;  }\n    if ( time >= 9.0   ) { marioJumpTime = 9.0;   marioJumpScale = 1.0;  }\n    if ( time >= 10.3  ) { marioJumpTime = 10.3;  marioJumpScale = 0.3;  }\n    if ( time >= 11.05 ) { marioJumpTime = 11.05; marioJumpScale = 1.0;  }\n    if ( time >= 13.62 ) { marioJumpTime = 13.62; marioJumpScale = 0.45; }\n    if ( time >= 15.1  ) { marioJumpTime = 15.1;  marioJumpScale = 0.5;  }\n    if ( time >= 18.7  ) { marioJumpTime = 18.7;  marioJumpScale = 0.6;  }\n    if ( time >= 19.65 ) { marioJumpTime = 19.65; marioJumpScale = 0.45; }\n    if ( time >= 20.29 ) { marioJumpTime = 20.29; marioJumpScale = 0.3;  }\n    if ( time >= 21.8  ) { marioJumpTime = 21.8;  marioJumpScale = 0.35; }\n    if ( time >= 22.3  ) { marioJumpTime = 22.3;  marioJumpScale = 0.35; }\n    if ( time >= 23.0  ) { marioJumpTime = 23.0;  marioJumpScale = 0.40; }\n    if ( time >= 23.5  ) { marioJumpTime = 23.5;  marioJumpScale = 0.3;  }\n    if ( time >= 24.7  ) { marioJumpTime = 24.7;  marioJumpScale = 0.45; }\n    if ( time >= 25.3  ) { marioJumpTime = 25.3;  marioJumpScale = 0.3;  }\n    if ( time >= 25.75 ) { marioJumpTime = 25.75; marioJumpScale = 0.4;  }\n    if ( time >= 26.3  ) { marioJumpTime = 26.3;  marioJumpScale = 0.25; }\n    if ( time >= marioBigJump1 ) \t\t{ marioJumpTime = marioBigJump1; \t\tmarioJumpScale = 1.0; }\n    if ( time >= marioBigJump1 + 1.0 ) \t{ marioJumpTime = marioBigJump1 + 1.0; \tmarioJumpScale = 0.6; }\n    if ( time >= marioBigJump2 ) \t\t{ marioJumpTime = marioBigJump2; \t\tmarioJumpScale = 1.0; }\n    if ( time >= marioBigJump2 + 1.0 ) \t{ marioJumpTime = marioBigJump2 + 1.0;\tmarioJumpScale = 0.6; }    \n    if ( time >= 32.3  ) { marioJumpTime = 32.3;  marioJumpScale = 0.7;  }\n    if ( time >= 33.7  ) { marioJumpTime = 33.7;  marioJumpScale = 0.3;  }\n    if ( time >= 34.15 ) { marioJumpTime = 34.15; marioJumpScale = 0.45; }\n    if ( time >= marioBigJump3 ) \t\t\t\t{ marioJumpTime = marioBigJump3; \t\t\t\tmarioJumpScale = 1.0; }\n    if ( time >= marioBigJump3 + 1.2 ) \t\t\t{ marioJumpTime = marioBigJump3 + 1.2; \t\t\tmarioJumpScale = 0.89; }\n    if ( time >= marioBigJump3 + 1.2 + 0.75 ) \t{ marioJumpTime = marioBigJump3 + 1.2 + 0.75; \tmarioJumpScale = 0.5; }\n    \n    float marioJumpOffset \t\t= 0.0;\n    float marioJumpLength \t\t= 1.5  * marioJumpScale;\n    float marioJumpAmplitude\t= 76.0 * marioJumpScale;\n    if ( time >= marioJumpTime && time <= marioJumpTime + marioJumpLength )\n    {\n        float t = ( time - marioJumpTime ) \/ marioJumpLength;\n        marioJumpOffset = floor( sin( t * 3.14 ) * marioJumpAmplitude );\n    }\n    \n    \n    \/\/ Mario land\n    float marioLandTime \t= 0.0;\n    float marioLandAplitude = 0.0;\n    if ( time >= marioBigJump1 + 1.0 + 0.45 ) \t\t\t{ marioLandTime = marioBigJump1 + 1.0 + 0.45; \t\t\tmarioLandAplitude = 109.0; }\n    if ( time >= marioBigJump2 + 1.0 + 0.45 ) \t\t\t{ marioLandTime = marioBigJump2 + 1.0 + 0.45; \t\t\tmarioLandAplitude = 109.0; }\n\tif ( time >= marioBigJump3 + 1.2 + 0.75 + 0.375 ) \t{ marioLandTime = marioBigJump3 + 1.2 + 0.75 + 0.375; \tmarioLandAplitude = 150.0; }\n    \n    float marioLandLength = marioLandAplitude \/ 120.0;\n\tif ( time >= marioLandTime && time <= marioLandTime + marioLandLength )\n    {\n        float t = 0.5 * ( time - marioLandTime ) \/ marioLandLength + 0.5;\n       \tmarioJumpOffset = floor( sin( t * 3.14 ) * marioLandAplitude );\n    }\n    \n    \n    \/\/ Mario flag jump\n    marioJumpTime \t\t= flagPauseStart - 0.3;\n    marioJumpLength \t= 1.5  * 0.45;\n    marioJumpAmplitude\t= 76.0 * 0.45;\n    if ( time >= marioJumpTime && time <= marioJumpTime + marioJumpLength + flagPauseLength ) \n    {\n        float time2 = time;\n        if ( time >= flagPauseStart && time <= flagPauseStart + flagPauseLength ) \n        {\n            time2 = flagPauseStart;\n        }\n        else if ( time >= flagPauseStart )\n        {\n            time2 = time - flagPauseLength;\n        }\n\t\tfloat t = ( time2 - marioJumpTime ) \/ marioJumpLength;\n        marioJumpOffset = floor( sin( t * 3.14 ) * marioJumpAmplitude );\n    }\n    \n\n    \/\/ Mario base (ground offset)\n    float marioBase = 0.0;\n    if ( time >= marioBigJump1 + 1.0 && time < marioBigJump1 + 1.0 + 0.45 )\n    {\n        marioBase = 16.0 * 4.0;\n    }\n    if ( time >= marioBigJump2 + 1.0 && time < marioBigJump2 + 1.0 + 0.45 )\n    {\n        marioBase = 16.0 * 4.0;\n    }    \n    if ( time >= marioBigJump3 + 1.2 && time < marioBigJump3 + 1.2 + 0.75 )\n    {\n        marioBase = 16.0 * 3.0;\n    }    \n    if ( time >= marioBigJump3 + 1.2 + 0.75 && time < marioBigJump3 + 1.2 + 0.75 + 0.375 )\n    {\n        marioBase = 16.0 * 7.0;\n    }\n\n    float marioX\t\t= pixelX - 112.0;\n    float marioY\t\t= pixelY - 16.0 - 8.0 - marioBase - marioJumpOffset;    \n    float marioFrame \t= marioJumpOffset == 0.0 ? floor( mod( time * 10.0, 3.0 ) ) : 3.0;\n    if ( time >= mushroomPauseStart && time <= mushroomPauseStart + mushroomPauseLength )\n    {\n    \tmarioFrame = 1.0;\n    }    \n    if ( time > mushroomPauseStart + 0.7 )\n    {\n        float t = time - mushroomPauseStart - 0.7;\n    \tif ( mod( t, 0.2 ) <= mix( 0.0, 0.2, clamp( t \/ 1.3, 0.0, 1.0 ) ) )\n        {\n            \/\/ super mario offset\n            marioFrame += 4.0;\n        }\n    }    \n    if ( marioX >= 0.0 && marioX <= 15.0 && cameraX < 3152.0 )\n    {\n        SpriteMario( color, marioX, marioY, marioFrame );\n    }\n}\n\nvec2 CRTCurveUV( vec2 uv )\n{\n    uv = uv * 2.0 - 1.0;\n    vec2 offset = abs( uv.yx ) \/ vec2( 6.0, 4.0 );\n    uv = uv + uv * offset * offset;\n    uv = uv * 0.5 + 0.5;\n    return uv;\n}\n\nvoid DrawVignette( inout vec3 color, vec2 uv )\n{    \n    float vignette = uv.x * uv.y * ( 1.0 - uv.x ) * ( 1.0 - uv.y );\n    vignette = clamp( pow( 16.0 * vignette, 0.3 ), 0.0, 1.0 );\n    color *= vignette;\n}\n\nvoid DrawScanline( inout vec3 color, vec2 uv )\n{\n    float scanline \t= clamp( 0.95 + 0.05 * cos( 3.14 * ( uv.y + 0.008 * iTime ) * 240.0 * 1.0 ), 0.0, 1.0 );\n    float grille \t= 0.85 + 0.15 * clamp( 1.5 * cos( 3.14 * uv.x * 640.0 * 1.0 ), 0.0, 1.0 );    \n    color *= scanline * grille * 1.2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ we want to see at least 224x192 (overscan) and we want multiples of pixel size\n    float resMultX  = floor( iResolution.x \/ 224.0 );\n    float resMultY  = floor( iResolution.y \/ 192.0 );\n    float resRcp\t= 1.0 \/ max( min( resMultX, resMultY ), 1.0 );\n    \n    float time\t\t\t= iTime;\n    float screenWidth\t= floor( iResolution.x * resRcp );\n    float screenHeight\t= floor( iResolution.y * resRcp );\n    float pixelX \t\t= floor( fragCoord.x * resRcp );\n    float pixelY \t\t= floor( fragCoord.y * resRcp );\n\n    vec3 color = RGB( 92, 148, 252 );\n \tDrawGame( color, time, pixelX, pixelY, screenWidth, screenHeight );\n    if ( time < INTRO_LENGTH )\n    {\n        DrawIntro( color, pixelX, pixelY, screenWidth, screenHeight );\n    }    \n\n    \n    \/\/ CRT effects (curvature, vignette, scanlines and CRT grille)\n    vec2 uv    = fragCoord.xy \/ iResolution.xy;\n    vec2 crtUV = CRTCurveUV( uv );\n    if ( crtUV.x < 0.0 || crtUV.x > 1.0 || crtUV.y < 0.0 || crtUV.y > 1.0 )\n    {\n        color = vec3( 0.0, 0.0, 0.0 );\n    }\n    DrawVignette( color, crtUV );\n    DrawScanline( color, uv );\n    \n\tfragColor.xyz \t= color;\n    fragColor.w\t\t= 1.0;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"XsfGRr","channel":0}],"code":"\/\/ Overworld theme based on notes from geoffrey1218's famitracker cover\n\/\/ Level clear theme based on notes from WheeljackDude's famitracker cover\n\nfloat SquareWave25( float f, float x )\n{\n    return floor( 4.0 * floor( f * x ) - floor( 4.0 * f * x ) + 1.0 );\n}\n\nfloat SquareWave50( float f, float x )\n{\n    return floor( 2.0 * floor( f * x ) - floor( 2.0 * f * x ) + 1.0 );\n}\n\nfloat SinWave( float f, float x )\n{\n    return sin( f * x * 2.0 * 3.14 );\n}\n\nfloat SawtoothWave( float q, float x )\n{\n    float f = fract( x ) - q;\n    f \/= (f >= 0.0 ? 1.0 : 0.0) - q;\n    return f * 2.0 - 1.0;\n}\n\nfloat Noise( float x )\n{\n    return fract( sin( 123523.9898 * x ) * 43758.5453 );\n}\n\nfloat Jump( float t )\n{\n    if ( t < 0.0 || t > 0.5 )\n    {\n        return 0.0;\n    }\n    \n\n\tfloat freq = mix( 250.0, 330.0, t \/ 0.5 );\n    \n    float waveSwitchT = 0.068;\n    if ( t < waveSwitchT ) \n    {\n        return SquareWave50( freq, t ) * 0.5;\n    }\n    else\n    {\n        return SquareWave25( freq, t ) * clamp( 1.0 - ( t - 0.1 ) \/ ( 0.5 - 0.1 ), 0.0, 1.0 ) * 0.5;\n    }\n}\n\nfloat Stomp( float t )\n{\n    if ( t < 0.0 || t > 0.25 )\n    {\n        return 0.0;\n    }\n \n    float freq = mix( 200.0, 300.0, t \/ 0.2 );\n\n    if ( t <= 0.1 )\n    {\n    \treturn SquareWave50( freq, t ) * clamp( t \/ 0.1, 0.0, 1.0 );\n    }\n    else\n    {\n        return SquareWave50( freq, t ) * clamp( ( t - 0.1 ) \/ 0.15, 0.0, 1.0 );\n    }\n}\n\nfloat PowerUp( float t )\n{\n    if ( t < 0.0 || t > 0.9 )\n    {\n        return 0.0;\n    }\n    \n    float freq = 250.0 + mod( t, 0.3 ) * 50.0;\n    return mix( SquareWave50( freq, t ), SquareWave25( freq, t ), mod( t, 0.3 ) > 0.2 ? 0.5 : 0.0 ) * 0.5;\n}\n\nfloat Bump( float t )\n{\n    if ( t < 0.0 || t > 0.15 )\n    {\n        return 0.0;\n    }\n    \n    float freq = mix( 150.0, 130.0, abs( t - 0.075 ) \/ 0.075 );\n    return SquareWave50( freq, t ) * 0.5 + SinWave( freq, t ) * 0.5;\n}\n\nfloat Coin( float t )\n{\n    if ( t < 0.0 || t > 0.75 )\n    {\n        return 0.0;\n    }    \n    \n    float freq = t > 0.1 ? 600.0 : 480.0;\n    return SquareWave50( freq, t ) * clamp( 1.0 - ( t - 0.1 ) \/ 0.65, 0.0, 1.0 );\n}\n\nfloat DownTheFlagpole( float t )\n{\n    if ( t < 0.0 || t > 1.0 )\n    {\n        return 0.0;\n    } \n    \n    float freq = floor( mix( 200.0, 600.0, t ) * 0.1 ) * 10.0;\n\treturn SquareWave50( freq, t ) * clamp( 1.0 - ( t - 0.95 ) \/ 0.05, 0.0, 1.0 );\n}\n\nfloat InstrumentMain( float f, float t )\n{\n    float ret = 0.0;\n    ret += SquareWave50( f, t ) * clamp( 1.0 - t \/ 0.250, 0.0, 1.0 ) * 0.5;\n    return ret;\n}\n\nfloat InstrumentBass( float f, float t )\n{\n\treturn SinWave( f, t ) * clamp( 1.0 - ( t - 0.1 ) \/ 0.01, 0.0, 1.0 );\n}\n\nfloat InstrumentDrums( float f, float t )\n{\n    if ( f == 1.0 )\n    {\n        \/\/ open\n    \treturn Noise( t ) * clamp( 1.0 - ( t - 0.08 ) \/ ( 0.001 ), 0.0, 1.0 ) * 0.66;  \n    }\n    else if ( f == 2.0 )\n    {\n        \/\/ close\n        return Noise( t ) * clamp( 1.0 - ( t - 0.0165 ) \/ ( 0.001 ), 0.0, 1.0 ) * 0.66;\n    }\n    else\n    {\n    \t\/\/ kick\n        return SquareWave50( 100.0, t ) * clamp( 1.0 - ( t - 0.0165 ) \/ ( 0.001 ), 0.0, 1.0 );\n    }\n}\n\n\/\/ note frequencies\nconst float E2\t=  82.41;\nconst float F2\t=  87.31;\nconst float G2 \t=  98.00;\nconst float GH2 = 103.83;\nconst float AH2 = 116.54;\nconst float C3 \t= 130.81;\nconst float CH3\t= 138.59;\nconst float D3 \t= 146.83;\nconst float DH3 = 155.56;\nconst float E3 \t= 164.81;\nconst float F3\t= 174.61;\nconst float FH3 = 185.00;\nconst float G3 \t= 196.00;\nconst float GH3 = 207.65;\nconst float A3 \t= 220.00;\nconst float AH3\t= 233.08;\nconst float B3 \t= 246.94;\nconst float C4 \t= 261.63;\nconst float D4  = 293.66;\nconst float DH4 = 311.13;\nconst float E4 \t= 329.63;\nconst float F4 \t= 349.23;\nconst float FH4 = 369.99;\nconst float G4 \t= 392.00;\nconst float GH4 = 415.30;\nconst float A4\t= 440.00;\nconst float AH4 = 466.16;\nconst float C5  = 523.25;\nconst float G5  = 783.99;\n\n#define N( off, freq ) \tif( pos > patternPos + float( off ) ) { notePos = patternPos + float( off ); noteFreq = float( freq ); }\n#define PEND\t\t\tpatternPos += 32.0;\n\nconst float TimeToPos = 1000.0 \/ 75.0;\nconst float PosToTime = 1.0 \/ TimeToPos;\n\nfloat OverworldMelody( float time )\n{\n    float pos\t\t\t= time * TimeToPos;\n    float noteFreq \t\t= 0.0;\n    float notePos\t\t= 0.0;\n    float patternPos\t= 0.0;\n    \n#define P0  N(0,E4)N(2,E4)N(6,E4)N(10,C4)N(12,E4)N(16,G4)PEND\n#define P1  N(0,C4)N(6,G3)N(12,E3)N(18,A3)N(22,B3)N(26,AH3)N(28,A3)PEND\n#define P2  N(0,G3)N(3,E4)N(6,G4)N(8,A4)N(12,F4)N(14,G4)N(18,E4)N(22,C4)N(24,D4)N(26,B3)PEND\n#define P3  N(4,G4)N(6,FH4)N(8,F4)N(10,DH4)N(14,E4)N(18,GH3)N(20,A3)N(22,C4)N(26,A3)N(28,C4)N(30,D4)PEND\n#define P4  N(4,G4)N(6,FH4)N(8,F4)N(10,DH4)N(14,E4)N(18,C5)N(22,C5)N(24,C5)PEND\n#define P5  N(4,DH4)N(10,D4)N(16,C4)PEND\n#define P6  N(0,C4)N(2,C4)N(6,C4)N(10,C4)N(12,D4)N(16,E4)N(18,C4)N(22,A3)N(24,G3)PEND\n#define P7  N(0,C4)N(2,C4)N(6,C4)N(10,C4)N(12,D4)N(14,E4)PEND\n    \n    P0 P1 P2 P1 P2 P3 P4 P3 P5 P3 \n    P4 P3 P5 P6 P7 P6 P0 P1 P2 P1\n        \n#undef P0\n#undef P1\n#undef P2\n#undef P3        \n#undef P4        \n#undef P5\n#undef P6\n#undef P7\n\n\treturn InstrumentMain( noteFreq, ( pos - notePos ) * PosToTime );\n}\n\nfloat OverworldHarmony( float time )\n{\n    float pos\t\t\t= time * TimeToPos;\n    float noteFreq \t\t= 0.0;\n    float notePos\t\t= 0.0;\n    float patternPos\t= 0.0;\n    \n#define P0  N(0,FH3)N(2,FH3)N(6,FH3)N(10,FH3)N(12,FH3)N(16,B3)N(24,G3)PEND\n#define P1  N(0,E3)N(6,C3)N(12,G2)N(18,C3)N(22,D3)N(26,CH3)N(28,C3)PEND\n#define P2  N(0,C3)N(3,G3)N(6,B3)N(8,C4)N(12,A3)N(14,B3)N(18,A3)N(22,E3)N(24,F3)N(26,D3)PEND    \n#define P3  N(4,E4)N(6,DH4)N(8,D4)N(10,B3)N(14,C4)N(18,E3)N(20,F3)N(22,G3)N(26,C3)N(28,E3)N(30,F3)PEND    \n#define P4  N(4,E4)N(6,DH4)N(8,D4)N(10,B3)N(14,C4)N(18,F4)N(22,F4)N(24,F4)PEND\n#define P5  N(4,GH3)N(10,F3)N(16,E3)PEND\n#define P6  N(0,GH3)N(2,GH3)N(6,GH3)N(10,GH3)N(12,AH3)N(16,G3)N(18,E3)N(22,E3)N(24,C3)PEND\n#define P7  N(0,GH3)N(2,GH3)N(6,GH3)N(10,GH3)N(12,AH3)N(14,G3)PEND\n    \n    P0 P1 P2 P1 P2 P3 P4 P3 P5 P3 \n    P4 P3 P5 P6 P7 P6 P0 P1 P2 P1\n        \n#undef P0\n#undef P1\n#undef P2\n#undef P3        \n#undef P4        \n#undef P5\n#undef P6\n#undef P7\n\n    return InstrumentMain( noteFreq, ( pos - notePos ) * PosToTime );\n}\n\n\nfloat OverworldBass( float time )\n{\n    float pos\t\t\t= time * TimeToPos;\n    float noteFreq \t\t= 0.0;\n    float notePos\t\t= 0.0;\n    float patternPos\t= 0.0;\n    \n\n#define P0 N(0,D3)N(2,D3)N(6,D3)N(10,D3)N(12,D3)N(16,G4)N(24,G3)PEND\n#define P1 N(0,G3)N(6,E3)N(12,C3)N(18,F3)N(22,G3)N(26,FH3)N(28,F3)PEND\n#define P2 N(0,E3)N(3,C4)N(6,E4)N(8,F4)N(12,D4)N(14,E4)N(18,C4)N(22,A3)N(24,B3)N(26,G3)PEND    \n#define P3 N(0,C3)N(6,G3)N(12,C4)N(16,F3)N(22,C4)N(24,C4)N(28,F3)PEND\n#define P4 N(0,C3)N(6,E3)N(12,G3)N(14,C4)N(18,G5)N(22,G5)N(24,G5)N(28,G3)PEND\n#define P5 N(0,C3)N(4,GH3)N(10,B3)N(16,C4)N(16,C4)N(22,G3)N(24,G3)N(28,C3)PEND\n#define P6 N(0,GH2)N(6,DH3)N(12,GH3)N(16,G3)N(22,C3)N(28,G2)PEND\n    \n    P0 P1 P2 P1 P2 P3 P4 P3 P5 P3 \n    P4 P3 P5 P6 P6 P6 P0 P1 P2 P1\n        \n#undef P0\n#undef P1\n#undef P2\n#undef P3        \n#undef P4        \n#undef P5\n#undef P6        \n\n    return InstrumentBass( noteFreq, ( pos - notePos ) * PosToTime );\n}\n\nfloat OverworldDrums( float time )\n{\n    float pos\t\t\t= time * TimeToPos;\n    float noteFreq \t\t= 0.0;\n    float notePos\t\t= 0.0;\n    float patternPos\t= 0.0;\n    \n    \/\/ 1 - open\n    \/\/ 2 - close\n    \/\/ 3 - kick\n#define P0 N(0,1)N(4,2)N(6,1)N(10,2)N(12,1)N(16,1)N(24,1)N(26,2)N(28,2)N(30,2)PEND\n#define P1 N(0,3)N(4,2)N(7,2)N(8,1)N(12,2)N(15,2)N(16,3)N(20,2)N(23,2)N(24,1)N(28,2)N(31,2)PEND\n#define P2 N(0,1)N(4,2)N(6,1)N(10,2)N(12,1)N(15,1)N(22,1)N(26,2)N(28,2)N(30,2)PEND    \n    \n    P0 P1 P1 P1 P1 P1 P1 P1 P1 P1\n    P1 P1 P1 P2 P2 P2 P0 P1 P1 P1\n        \n#undef P0\n#undef P1        \n#undef P2\n    \n    return InstrumentDrums( noteFreq, ( pos - notePos ) * PosToTime );\n}\n\nconst float TimeToPos2 = 0.5 * TimeToPos;\nconst float PosToTime2 = 1.0 \/ TimeToPos2;\n\nfloat LevelClearMelody( float time )\n{\n    float pos\t\t\t= time * TimeToPos2;\n    float noteFreq \t\t= 0.0;\n    float notePos\t\t= 0.0;\n    float patternPos\t= 0.0;\n    \n\tN(0,G2)N(1,C3)N(2,E3)N(3,G3)N(4,C4)N(5,E4)N(6,G4)N(9,E4)N(12,GH2)N(13,C3)N(14,DH3)N(15,GH3)N(16,C4)N(17,DH4)N(18,GH4)N(21,DH4)N(24,AH2)N(25,DH3)N(26,F3)N(27,AH3)N(28,D4)N(29,F4)N(30,AH4)N(33,AH4)N(34,AH4)N(35,AH4)N(36,E4)\n\n    return InstrumentMain( noteFreq, ( pos - notePos ) * PosToTime2 );\n}\n\nfloat LevelClearHarmony( float time )\n{\n    float pos\t\t\t= time * TimeToPos2;\n    float noteFreq \t\t= 0.0;\n    float notePos\t\t= 0.0;\n    float patternPos\t= 0.0;\n    \n\tN(1,E2)N(2,G2)N(3,C3)N(4,E3)N(5,G3)N(6,C4)N(9,G3)N(13,E2)N(14,GH2)N(15,C3)N(16,DH3)N(17,GH3)N(18,C4)N(21,GH3)N(25,F2)N(26,AH2)N(27,D3)N(28,F3)N(29,AH3)N(30,D4)N(33,D4)N(36,C5)\n\n    return InstrumentMain( noteFreq, ( pos - notePos ) * PosToTime2 );\n}\n\nfloat LevelClearBass( float time )\n{\n    float pos\t\t\t= time * TimeToPos2;\n    float noteFreq \t\t= 0.0;\n    float notePos\t\t= 0.0;\n    float patternPos\t= 0.0;\n    \n\tN(3,C3)N(4,E3)N(5,G3)N(6,E4)N(9,C4)N(15,C3)N(16,DH3)N(17,GH3)N(18,DH4)N(21,C4)N(27,D3)N(28,F3)N(29,AH3)N(30,F4)N(33,D4)N(34,D4)N(35,D4)N(36,C4)\n\n    return InstrumentBass( noteFreq, ( pos - notePos ) * PosToTime2 );\n}\n\nfloat GameSounds( float time )\n{\n    \/\/ play sounds a bit earlier\n    time += 0.1;\n\n    float ret = 0.0;\n    \n    float marioBigJump1 = 27.1;\n    float marioBigJump2 = 29.75;\n    float marioBigJump3 = 35.05;    \n    \n    \n    \/\/ Jump sounds\n    float jumpTime = time - 38.7;\n    if ( jumpTime <= 0.0 ) { jumpTime = time - marioBigJump3 - 1.2 - 0.75; }    \n    if ( jumpTime <= 0.0 ) { jumpTime = time - marioBigJump3 - 1.2; }\n    if ( jumpTime <= 0.0 ) { jumpTime = time - marioBigJump3; }\n    if ( jumpTime <= 0.0 ) { jumpTime = time - 34.15; }    \n    if ( jumpTime <= 0.0 ) { jumpTime = time - 33.7; }\n    if ( jumpTime <= 0.0 ) { jumpTime = time - 32.3; }    \n    if ( jumpTime <= 0.0 ) { jumpTime = time - marioBigJump2 - 1.0; }    \n    if ( jumpTime <= 0.0 ) { jumpTime = time - marioBigJump2; }    \n    if ( jumpTime <= 0.0 ) { jumpTime = time - marioBigJump1 - 1.0; }    \n    if ( jumpTime <= 0.0 ) { jumpTime = time - marioBigJump1; }    \n    if ( jumpTime <= 0.0 ) { jumpTime = time - 25.75; }    \n\tif ( jumpTime <= 0.0 ) { jumpTime = time - 24.7; }        \n    if ( jumpTime <= 0.0 ) { jumpTime = time - 23.0; } \n    if ( jumpTime <= 0.0 ) { jumpTime = time - 21.7; }    \n    if ( jumpTime <= 0.0 ) { jumpTime = time - 19.65; }   \n    if ( jumpTime <= 0.0 ) { jumpTime = time - 18.7; }    \n    if ( jumpTime <= 0.0 ) { jumpTime = time - 15.1; } \n    if ( jumpTime <= 0.0 ) { jumpTime = time - 13.62; }    \n    if ( jumpTime <= 0.0 ) { jumpTime = time - 11.05; }\n    if ( jumpTime <= 0.0 ) { jumpTime = time - 9.0; }\n    if ( jumpTime <= 0.0 ) { jumpTime = time - 7.8; }\n    if ( jumpTime <= 0.0 ) { jumpTime = time - 6.05; }\n    if ( jumpTime <= 0.0 ) { jumpTime = time - 5.0; }\n    if ( jumpTime <= 0.0 ) { jumpTime = time - 4.2; }\n\tret += Jump( jumpTime );                           \n\n    \/\/ block bump sounds\n    float bumpTime = time - 33.9;\n    if ( bumpTime <= 0.0 ) { bumpTime = time - 22.4; }\n    if ( bumpTime <= 0.0 ) { bumpTime = time - 15.4; }\n    if ( bumpTime <= 0.0 ) { bumpTime = time - 5.3; }\n    ret += Bump( bumpTime );\n    \n    \/\/ coin sounds\n    float coinTime = time - 33.9;\n    if ( coinTime <= 0.0 ) { coinTime = time - 22.4; }\n    if ( coinTime <= 0.0 ) { coinTime = time - 5.4; }    \n    ret += Coin( coinTime );    \n\n    float stompTime = time - 26.3;\n    if ( stompTime <= 0.0 ) { stompTime = time - 25.3; }\n    if ( stompTime <= 0.0 ) { stompTime = time - 23.5; }    \n    if ( stompTime <= 0.0 ) { stompTime = time - 20.29; }    \n    if ( stompTime <= 0.0 ) { stompTime = time - 10.3; }    \n    ret += Stomp( stompTime );\n    \n\tret += PowerUp( time - 17.0 );    \n\n    ret += DownTheFlagpole( time - 38.95 );    \n    \n    return ret;\n}\n\nvec2 mainSound( in int samp, float time )\n{    \n    float ret = 0.0;\n    \n    float overworldTime  = max( time -  1.0, 0.0 );\n    float levelClearTime = max( time - 40.2, 0.0 );\n\n    ret += OverworldMelody( overworldTime ) \t* 0.3;\n    ret += OverworldHarmony( overworldTime ) \t* 0.2;\n    ret += OverworldBass( overworldTime )   \t* 0.2;\n    ret += OverworldDrums( overworldTime )\t\t* 0.15;  \n    \n    \/\/ overworld theme fadout before the castle\n    ret *= 1.0 - smoothstep( 38.0, 40.0, time );\n    \n    ret += LevelClearMelody( levelClearTime ) \t* 0.3;\n    ret += LevelClearHarmony( levelClearTime ) \t* 0.3;\n    ret += LevelClearBass( levelClearTime ) \t* 0.3;\n    \n    ret += GameSounds( time )\t\t\t\t\t* 0.2;\n    \n    \/\/ disable output on first frames\n    ret = time <= 1.0 ? 0.0 : ret;\n    \n    return vec2( ret, ret );\n}","name":"Sound","description":"","type":"sound"}]},{"ver":"0.1","info":{"id":"4ldGz4","date":"1468717669","viewed":38232,"name":"[SH16B] Speed Drive 80","username":"knarkowicz","description":"I was listening to Blood Dragon Theme when the 2nd challenge was announced, so why not mix it with some speed?\nhttps:\/\/www.shadertoy.com\/events\/competition2016","likes":245,"published":3,"flags":96,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tvec2 screenUV = fragCoord.xy \/ iResolution.xy;\n    \n    \/\/ chromatic abberation\n    float caStrength\t= 0.005;\n    vec2 caOffset \t\t= screenUV - 0.5;\n\tvec2 caUVG\t\t\t= screenUV + caOffset * caStrength;\n\tvec2 caUVB\t\t\t= screenUV + caOffset * caStrength * 2.0;\n\n    vec3 color;\n    color.x = texture( iChannel0, screenUV ).x;\n    color.y = texture( iChannel0, caUVG ).y;\n    color.z = texture( iChannel0, caUVB ).z;    \n    \n    fragColor = vec4( color, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3Rn","filepath":"\/media\/a\/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"\/media\/ap\/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"ldSGRR","filepath":"https:\/\/soundcloud.com\/daawatcha-1\/blood-dragon-theme","previewfilepath":"https:\/\/soundcloud.com\/daawatcha-1\/blood-dragon-theme","type":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ Scene traycing\n\n\/\/#define DEBUG_CAMERA\n\/\/#define DEBUG_LIGHTING\n\nconst float MATH_PI = float( 3.14159265359 );\n\nfloat gMaterial     \t\t= 0.0;\nfloat gTime         \t\t= 0.0;\nfloat gCarOffset    \t\t= 0.0;\nfloat gStreetLampDist\t\t= 100000.0;\nfloat gCarLampDist\t\t\t= 100000.0;\nfloat gReflStreetLampDist\t= 100000.0;\nfloat gFogDensity\t\t\t= 0.1;\nfloat gFogHeightFalloff\t\t= 0.1;\n\nconst float MTRL_ROAD           = 1.0;\nconst float MTRL_BUILDING       = 2.0;\nconst float MTRL_CAR            = 3.0;\nconst float MTRL_STREETLAMPS    = 4.0;\nconst float MTRL_TUNNEL\t\t\t= 5.0;\nconst float INTERIOR_START      = 59.0;\nconst float INTERIOR_END        = 67.0;\n\nfloat Saturate( float x )\n{\n    return clamp( x, 0.0, 1.0 );\n}\n\nfloat Cylinder( vec3 p, float r, float height ) \n{\n    float d = length( p.xz ) - r;\n    d = max( d, abs( p.y ) - height );\n    return d;\n}\n\nfloat Torus( vec3 p, float r, float h )\n{\n    vec2 q = vec2( length( p.yz ) - h, p.x );\n    return length( q ) - r;\n}\n\nfloat Plane( vec3 p, vec4 plane ) \n{\n    return dot( p, plane.xyz ) + plane.w;\n}\n\nfloat Sphere( vec3 p, float s )\n{\n    return length( p ) - s;\n}\n\nfloat Box( vec3 p, vec3 b )\n{\n    vec3 d = abs( p ) - b;\n    return min( max( d.x, max( d.y, d.z ) ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\nfloat HexPrism( vec3 p, float h, float r )\n{\n    vec3 q = abs( p );\n    return max( q.z - r, max( ( q.x * 0.866025 + q.y * 0.5 ), q.y ) - h );\n}\n\nfloat Rectangle( vec2 p, vec2 b )\n{\n    vec2 d = abs( p ) - b;\n    return min( max( d.x, d.y ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\nfloat RepeatAngle( inout vec2 p, float n ) \n{\n\tfloat angle = 2.0 * MATH_PI \/ n;\n\tfloat a = atan( p.y, p.x ) + angle \/ 2.0;\n\tfloat r = length( p );\n\tfloat c = floor( a \/ angle );\n\ta = mod( a, angle ) - angle \/ 2.;\n\tp = vec2( cos( a ), sin( a ) ) * r;\n\treturn c;\n}\n\nfloat Circle( vec2 p, float s )\n{\n    return length( p ) - s;\n}\n\nfloat Intersect( float a, float b )\n{\n    return max( a, b );\n}\n\nfloat Substract( float a, float b )\n{\n    return max( a, -b );\n}\n\nfloat SubstractRound( float a, float b, float r ) \n{\n    vec2 u = max( vec2( r + a, r - b ), vec2( 0.0, 0.0 ) );\n    return min( -r, max( a, -b ) ) + length( u );\n}\n\nfloat SubstractChamfer( float a, float b, float r ) \n{\n    return max( max( a, -b ), ( a + r - b ) * 0.70711 );\n}\n\nfloat Union( float a, float b )\n{\n    return min( a, b );\n}\n\nfloat UnionRound( float a, float b, float r ) \n{\n    vec2 u = max( vec2( r - a, r - b ), vec2( 0.0, 0.0 ) );\n    return max( r, min( a, b ) ) - length( u );\n}\n\nvoid Rotate( inout vec2 p, float a ) \n{\n    p = cos( a ) * p + sin( a ) * vec2( p.y, -p.x );\n}\n\nfloat Rand( vec2 co )\n{\n    return fract( sin( dot( co.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );\n}\n\nfloat StreetLamps( vec3 p )\n{\n    p = abs( p );\n    \n    float rx = 50.0;\n    p.x = mod( p.x, rx ) - 0.5 * rx;\n    p.z -= 15.0;\n    \n    float a = Box( p, vec3( 0.3, 12.0, 0.3 ) );\n    \n    p += vec3( 0.0, -12.7, 3.5 );\n    Rotate( p.yz, -0.4 * MATH_PI );\n    float b = Box( p, vec3( 0.5, 4.0, 0.3 ) );\n    \n    float bloom = Box( p + vec3( 0.0, -0.5, 0.6 ), vec3( 0.5, 3.0, 0.1 ) );\n    gStreetLampDist = min( gStreetLampDist, bloom );\n    \n    return Union( a, b );\n}\n\nfloat Pyramid( vec3 p, float h ) \n{\n    vec3 q = abs( p );\n    return max( -p.y, ( q.x + q.y + q.z - h ) \/ 3.0 );\n}\n\nfloat Pyramids( vec3 p )\n{    \n    p += vec3( -1220.0, 0.0, 0.0 );    \n    vec3 t = p;\n\n    float rx = 200.0;\n    float rz = 150.0;\n    t.x = t.x > 0.0 ? mod( t.x, rx ) - 0.5 * rx : t.x;\n    t.z = mod( t.z, rz ) - 0.5 * rz;\n    \n    Rotate( t.xz, 0.5 );        \n    float a = Pyramid( t, 30.0 );\n    \n    t = p;\n\n    rx = 400.0;\n    rz = 300.0;\n    t.x = t.x > 0.0 ? mod( t.x, rx ) - 0.5 * rx : t.x;\n    t.z = mod( t.z, rz ) - 0.5 * rz;\n    \n    Rotate( t.xz, 0.5 );        \n    float b = Pyramid( t, 80.0 );    \n    \n    return Union( a, b );\n}\n\nfloat Obelisks( vec3 p )\n{    \n    p += vec3( -1220.0, -50.0, 0.0 );       \n    \n    float rx = 200.0;\n    float rz = 150.0;\n    p.x = mod( p.x, rx ) - 0.5 * rx;\n    p.z = mod( p.z, rz ) - 0.5 * rz;\n    \n    Rotate( p.xz, 0.5 + gTime * 1.5 );\n    float a = Pyramid( p, 30.0 );\n    Rotate( p.xz, -1.0 - gTime * 3.0 );\n    \n    p.y += 7.0;\n    \n    Rotate( p.yx, -MATH_PI );\n    float b = Pyramid( p, 20.0 );    \n    \n    return Union( a, b );\n}\n\nfloat Buildings( vec3 p )\n{        \n    vec3 t = p;\n    float rx = 200.0;\n    float rz = 100.0;\n    t.x = mod( t.x, rx ) - 0.5 * rx;\n    t.z = mod( t.z, rz ) - 0.5 * rz;\n    float a = HexPrism( t.xzy, 18.0, 40.0 );\n    float at = HexPrism( t.xzy, 12.0, 50.0 );\n    a = Substract( a, at );    \n    \n    t = p + vec3( 100.0, 0.0, 0.0 );\n    t.x = mod( t.x, rx ) - 0.5 * rx;\n    t.z = mod( t.z, rz ) - 0.5 * rz;\n    float b = Box( t, vec3( 20.0, 66.0, 20.0 ) );\n    float bt = Box( t + vec3( 0.0, -66.0, 0.0 ), vec3( 15.0, 6.1, 15.0 ) );\n    b = Substract( b, bt );\n    \n    rz = 200.0;\n    t = p + vec3( 150.0, 0.0, 0.0 );\n    t.x = mod( t.x, rx ) - 0.5 * rx;\n    t.z = mod( t.z, rz ) - 0.5 * rz;\n    float c = Box( t, vec3( 20.0, 99.0, 20.0 ) );\n    \n    rz = 200.0;\n    t = p + vec3( 50.0, 0.0, 0.0 );\n    t.x = mod( t.x, rx ) - 0.5 * rx;\n    t.z = mod( t.z, rz ) - 0.5 * rz;\n    float d = Cylinder( t, 20.0, 4.0 * 33.0 );\n    \n    return Union( Union( Union( a, b ), c ), d );\n}\n\nfloat Car( vec3 p )\n{        \n    p.x = -p.x;     \n    p.y -= 0.3;\n    \n    float a = Box( p, vec3( 4.2, 0.9, 1.8 ) );   \n    \n    vec3 t = p + vec3( -6.0, 0.0, 0.0 );\n    Rotate( t.yx, 0.2 );\n    float b = Plane( t, vec4( 0.0, -1.0, 0.0, 0.0 ) );\n    \n    t = p + vec3( -5.0, 0.0, 0.0 );\n    Rotate( t.yx, -0.4 );\n    float c = Plane( t, vec4( 0.0, 1.0, 0.0, 0.0 ) );    \n    \n    t = p + vec3( 2.0, -0.2, 0.0 );\n    Rotate( t.yx, -0.4 );\n    float d = Plane( t, vec4( 0.0, -1.0, 0.0, 0.0 ) );   \n    \n    t = p + vec3( 2.0, -0.3, 0.0 );\n    Rotate( t.yx, -0.05 );\n    float e = Plane( t, vec4( 0.0, -1.0, 0.0, 0.0 ) );       \n    \n    t = p + vec3( 2.0, 1.0, 0.0 );\n    Rotate( t.yx, 0.2 );\n    float f = Plane( t, vec4( 0.0, 1.0, 0.0, 0.0 ) );     \n    \n    t = p;\n    t.z = abs( t.z );\n    t += vec3( -3.9, -0.6, 0.0 );\n    float spoiler = Box( t, vec3( 0.2, 0.05, 1.7 ) );\n    spoiler = Union( spoiler, Box( t - vec3( 0.0, -0.25, 1.4 ), vec3( 0.2, 0.3, 0.15 ) ) );\n    \n    float bloom = Box( t + vec3( -0.5, 0.7, 0.0 ), vec3( 0.1, 0.3, 1.5 ) );\n    gCarLampDist = min( gCarLampDist, bloom );\n    \n    t = p + vec3( 1.0, -0.6, 0.0 );\n    Rotate( t.yx, -0.4 );\n    float frontWindow = Box( t, vec3( 0.6, 0.05, 1.6 ) );\n    \n    t = p + vec3( -2.5, -0.7, 0.0 );\n    Rotate( t.yx, 0.2 );\n    float backWindow = Box( t, vec3( 1.0, 0.05, 1.6 ) );\n    \n    float body = Union( Substract( a, Union( Union( Union( b, c ), Intersect( d, e ) ), f ) ), spoiler );\n    \n    t = p;\n    t.z = -abs( t.z );\n    t += vec3( 0.0, -0.8, 1.2 );\n    Rotate( t.yz, -0.9 );\n    float sideCutPlanes = Plane( t, vec4( 0.0, -1.0, 0.0, 0.0 ) );      \n    \n    body = SubstractChamfer( body, Union( backWindow, frontWindow ), 0.1 );\n    body = SubstractChamfer( body, sideCutPlanes, 0.05 );\n    \n    p.x += 0.1;\n    p.xz = abs( p.xz );\n    t = p.xzy - vec3( 2.4, 1.5, -0.7 );\n    float wheel = Cylinder( t, 0.7, 1.0 );\n    body = Substract( body, wheel );\n    \n    wheel = Substract( Cylinder( t, 0.55, 0.3 ), Sphere( t + vec3( 0.0, -0.15, 0.0 ), 0.35 ) );\n    \n    body = Union( body, wheel );\n    \n    return body;\n}\n\nfloat Curb( vec3 p )\n{\n    float y = p.y - 0.5;\n    float z = -abs( p.z ) + 14.0;    \n    return max( y, z );   \n}\n\nfloat Tunnel( vec3 p )\n{\n    vec3 t = p;\n    t += vec3( -2510.0, 0.0, 0.0 );\n    float a = Box( t, vec3( 200.0, 16.0, 50.0 ) );\n    float b = Box( t, vec3( 201.0, 14.0, 16.0 ) );    \n    a = Substract( a, b );\n        \n    t = p;\n    t += vec3( -7870.0, 0.0, 0.0 );\n    float c = Box( t, vec3( 200.0, 16.0, 50.0 ) );\n    float d = Box( t, vec3( 201.0, 14.0, 16.0 ) );    \n    c = Substract( c, d );\n    \n    float rx = 12.0;\n    t.x = mod( t.x, rx ) - 0.5 * rx;\n    t.z = abs( t.z );\n    b = Box( t + vec3( 0.0, 0.0, -16.0 ), vec3( 4.0, 12.0, 2.0 ) );   \n    \n    return Substract( Union( a, c ), b );\n}\n\nfloat CarInterior( vec3 p )\n{\n    p.y -= 3.0;\n    \n    vec3 t = p;\n    Rotate( t.xy, -0.7 );\n    float wheel     = Torus( t + vec3( 0.0, 3.2, 2.0 ), 0.24, 2.4 );\n    vec3 s = t + vec3( 0.0, sin( 0.3 * t.z - 1.7 ) * 0.3 + 0.1, 0.0 );\n    float dashboard = Box( s + vec3( -1.6, 2.0, 0.0 ), vec3( 0.8, 2.0, 10.0 ) );\n    Rotate( t.xy, 0.3 );\n    float d         = Box( t + vec3( -0.1, 2.2, 0.8 ), vec3( 1.0, 1.2, 7.0 ) );\n    dashboard = SubstractRound( dashboard, d, 0.4 );\n    \n    return Union( wheel, dashboard );\n}\n\nfloat TerrainAO( vec3 p )\n{\n    float ret = 1.0;\n    \n    vec3 t = p + vec3( -gCarOffset, -1.0, -3.0 );\n    float car = Box( t, vec3( 2.8, 5.0, 1.6 ) );\n    ret = min( ret, smoothstep( 0.0, 1.0, car * 0.9 ) );\n  \n    t = abs( p );\n    float rx = 50.0;\n    t.x = mod( t.x, rx ) - 0.5 * rx;\n    t.y -= 2.0;\n    t.z -= 15.0;\n    float streetLamps = Cylinder( t, 0.2, 2.0 );\n    ret = min( ret, smoothstep( 0.0, 1.0, streetLamps * 0.1 ) );\n    \n    t = p;\n    rx = 200.0;\n    float rz = 100.0;\n    t.x = mod( t.x, rx ) - 0.5 * rx;\n    t.z = mod( t.z, rz ) - 0.5 * rz;\n    float buildings = HexPrism( t.xzy, 18.0, 40.0 );        \n    \n    t = p + vec3( 100.0, 0.0, 0.0 );\n    t.x = mod( t.x, rx ) - 0.5 * rx;\n    t.z = mod( t.z, rz ) - 0.5 * rz;\n    buildings = Union( buildings, Box( t, vec3( 20.0, 66.0, 20.0 ) ) );\n    \n    rz = 200.0;\n    t = p + vec3( 150.0, 0.0, 0.0 );\n    t.x = mod( t.x, rx ) - 0.5 * rx;\n    t.z = mod( t.z, rz ) - 0.5 * rz;\n    buildings = Union( buildings, Box( t, vec3( 20.0, 99.0, 20.0 ) ) );\n    \n    rz = 200.0;\n    t = p + vec3( 50.0, 0.0, 0.0 );\n    t.x = mod( t.x, rx ) - 0.5 * rx;\n    t.z = mod( t.z, rz ) - 0.5 * rz;\n    buildings = Union( buildings, Cylinder( t, 20.0, 4.0 * 33.0 ) );\n    \n    ret = min( ret, smoothstep( 0.0, 1.0, buildings * 0.05 ) );\n    return mix( ret, 1.0, 0.5 );\n}\n\nfloat Scene( vec3 p )\n{    \n    float terrain   = Union( Plane( p, vec4( 0.0, 1.0, 0.0, 0.0 ) ), Curb( p ) );\n    float tunnel    = Tunnel( p );\n    \n    if ( gTime >= 77.0 )\n    {\n        vec3 t = p;\n        t.z = abs( p.z );\n        terrain = Substract( terrain, Plane( t, vec4( 0.0, 0.0, -1.0, 18.0 ) ) );\n        terrain = Union( terrain, Box( t + vec3( -7700.0, 0.0, -20.0 ), vec3( 10000.0, 3.0, 2.0 ) ) );\n    }\n\n    float buildings = gTime <= 25.0 ? Pyramids( p ) : ( gTime < 77.0 ? Buildings( p ) : Obelisks( p ) );\n    float streetLamps = StreetLamps( p );\n    \n    p += vec3( -gCarOffset, -1.0, -3.0 );\n    float car = gTime > INTERIOR_START && gTime < INTERIOR_END ? CarInterior( p ) : Car( p );\n                        \n    float ret = Union( Union( Union( Union( terrain, buildings ), streetLamps ), car ), tunnel );\n\n    gMaterial = MTRL_TUNNEL;    \n\tgMaterial = terrain \t<= ret ? MTRL_ROAD \t\t\t: gMaterial;\n    gMaterial = buildings \t<= ret ? MTRL_BUILDING\t\t: gMaterial;\n    gMaterial = car \t\t<= ret ? MTRL_CAR \t\t\t: gMaterial;\n    gMaterial = streetLamps <= ret ? MTRL_STREETLAMPS \t: gMaterial;\n \n    return ret;\n}\n\nfloat CastRay( in vec3 ro, in vec3 rd )\n{\n    const float maxd = 500.0;\n    \n    float h = 0.5;\n    float t = 0.0;\n   \n    for ( int i = 0; i < 64; ++i )\n    {\n        if ( h < 0.01 || t > maxd ) \n        {\n            break;\n        }\n        \n        h = Scene( ro + rd * t );\n        t += h;\n    }\n\n    if ( t > maxd )\n    {\n        t = -1.0;\n    }\n\n    return t;\n}\n\nvec3 SceneNormal( in vec3 pos )\n{\n    vec3 eps = vec3( 0.01, 0.0, 0.0 );\n    vec3 nor = vec3(\n        Scene( pos + eps.xyy ) - Scene( pos - eps.xyy ),\n        Scene( pos + eps.yxy ) - Scene( pos - eps.yxy ),\n        Scene( pos + eps.yyx ) - Scene( pos - eps.yyx ) );\n    return normalize( -nor );\n}\n\nfloat SpeedMeterY( vec2 p )\n{\n    p -= vec2( 4.0, 3.8 );\n    float d = Circle( p, 0.02 );\n    \n\tvec2 t = p;\n    RepeatAngle( t, 8.0 );\n    d = min( d, Rectangle( t + vec2( -0.7, 0.0 ), vec2( 0.08, 0.01 ) ) );\n    \n    t = p;\n    Rotate( t.xy, 0.4 );\n    RepeatAngle( t, 8.0 );\n    d = min( d, Rectangle( t + vec2( -0.7, 0.0 ), vec2( 0.03, 0.01 ) ) );\n    d = max( d, -Circle( p + vec2( 0.0, 0.71 ), 0.51 ) );\n    \n    return d;\n}\n\nfloat SpeedMeterR( vec2 p, float t )\n{\n    p -= vec2( 4.0, 3.8 );\n\n    Rotate( p.xy, t + 0.5 + 0.5 * sin( t + 2.0 * gTime ) );\n    float d = Rectangle( p + vec2( -0.32, 0.0 ), vec2( 0.18, 0.01 ) );\n    \n    return d;\n}\n\nvec3 Dashboard( vec3 p3 )\n{\n    p3.x -= gCarOffset;\n    \n    vec2 p;\n    p.x = p3.z;\n    p.y = p3.y * 1.3 + 1.8;\n\n\tvec3 color \t= vec3( 0.0 );\n    vec3 yellow = vec3( 0.9, 0.7, 0.1 );\n    vec3 red \t= vec3( 1.0, 0.1, 0.4 );\n    vec3 purple\t= vec3( 0.54, 0.42, 0.78 );\n    \n    float dy = min( SpeedMeterY( p ), SpeedMeterY( p + vec2( 2.0, 0.0 ) ) );\n    \n    float horBarsY = 100000.0;\n    \/\/ yellow horizontal bars\n    for ( int i = 0; i < 4; ++i )\n    {\n        float ampl\t= texture( iChannel3, vec2( ( 2.0 * float( i ) + 1.5 ) \/ 8.0, 0.25 ) ).x;\n        float sizeX = 0.7 * floor( Saturate( 1.4 * sqrt( ampl ) ) * 6.0 ) \/ 6.0;\n        horBarsY = min( horBarsY, Rectangle( p - vec2( 7.3 + sizeX, 3.05 + float( i ) * 0.4 ), vec2( sizeX, 0.03 ) ) );\n    }\n    \n    float dr = 100000.0;\n    \/\/ vertical bars\n    for ( int i = 0; i < 3; ++i )\n    {\n        float sy = 0.45 + floor( ( 0.1 * ( 3.0 * sin( 14.0 * gTime ) + sin( 7.0 * gTime ) ) ) \/ 0.2 ) * 0.2;\n\t\tsy *= i == 1 ? 1.0 : 0.39;\n\t\tdr = min( dr, Rectangle( p - vec2( 5.6 + float( i ) * 0.4, 3.8 ), vec2( 0.1, sy ) ) );\n    }\n    \n    vec2 t = p;\n    t.y = mod( t.y, 0.2 ) - 0.5 * 0.2;\n\tfloat di = Rectangle( t, vec2( 100.0, 0.06 ) );\n    dr = max( dr, -di );\n    \n    dr = min( dr, min( SpeedMeterR( p, 0.0 ), SpeedMeterR( p + vec2( 2.0, 0.0 ), 1.0 ) ) );\n\n    \/\/ red horizontal bars\n    float horBarsR = 100000.0;\n    for ( int i = 0; i < 4; ++i )\n    {\n        float ampl\t= texture( iChannel3, vec2( ( 2.0 * float( i ) + 0.5 ) \/ 8.0, 0.25 ) ).x;\n        float sizeX = 0.7 * floor( Saturate( 1.4 * sqrt( ampl ) ) * 6.0 ) \/ 6.0;\n        sizeX = 0.7 * floor( sizeX * 6.0 ) \/ 6.0;\n        horBarsR = min( horBarsR, Rectangle( p - vec2( 7.3 + sizeX, 3.225 + float( i ) * 0.4 ), vec2( sizeX, 0.03 ) ) );\n    }    \n    \n    \/\/ horizontal bar segments\n    t = p;\n    t.x += 0.2;\n    t.x = mod( t.x, 0.26 ) - 0.5 * 0.26;\n\tdi = Rectangle( t, vec2( 0.06, 100.0 ) );\n    dr = min( dr, max( horBarsR, -di ) );\n    dy = min( dy, max( horBarsY, -di ) );\n    \n    float dp = 100000.0;\n    p.x = mod( p.x, 2.0 ) - 1.0;\n    dp = min( dp, Rectangle( p - vec2( 0.0, 3.8 ), vec2( 0.01, 1.2 ) ) );\n    \n    color += 2.0 * yellow \t* Saturate( exp( -dy * 40.0 ) );\n    color += 1.5 * red \t\t* Saturate( exp( -dr * 40.0 ) );\n    color += 1.0 * purple\t* Saturate( exp( -dp * 40.0 ) );\n    return p3.x - p3.y * 0.3 > -0.7 ? color : vec3( 0.0 );\n}\n\nmat3 CameraLookAt( vec3 ro, vec3 ta, float cr )\n{\n    vec3 cw = normalize( ta - ro);\n    vec3 cp = vec3( sin( cr ), cos( cr ), 0.0 );\n    vec3 cu = normalize( cross( cw, cp ) );\n    vec3 cv = normalize( cross( cu, cw ) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 Sky( vec3 rayDir )\n{\n    \/\/ sky and sun\n    vec3 skyPos     = rayDir;\n    vec2 skyAngle   = vec2( atan( skyPos.z, skyPos.x ), acos( skyPos.y ) );\n\n    float sun = 1.0 - clamp( 6.0 * length( skyAngle - vec2( 0.0, 1.5 ) ) - 1.0, 0.0, 1.0 );\n    float sky = clamp( 1.0 - 1.5 * skyPos.y, 0.0, 1.0 );\n\n    float sunLines = 1.0 - clamp( sin( skyPos.y * skyPos.y * 500.0 ), 0.0, 1.0 );\n    vec3 sunColor = mix( vec3( 1.0, 0.2, 0.5 ), vec3( 1.0, 0.2, 0.0 ) * 4.0, clamp( skyPos.y * 6.0, 0.0, 1.0 ) );\n    sun *= gTime > 0.3 ? 3.0 - 2.0 * smoothstep( 0.0, 1.0, ( gTime - 0.3 ) * 0.5 ) : 1.0;\n    vec3 color = vec3( 0.54, 0.42, 0.78 ) * 0.2 * sky * 4.0 + sunColor * sun * sunLines;\n\n    \/\/ stars\n    vec2 starTile   = floor( skyAngle.xy * 20.0 );\n    vec2 starPos    = fract( skyAngle.xy * 20.0 ) * 2.0 - 1.0;\n    float starRand  = Rand( starTile + vec2( 0.1, 0.3 ) );\n    starRand = starRand > 0.9 ? starRand : 0.0;\n    color += vec3( 2.0 ) * starRand * clamp( 1.0 - ( 6.0 + 3.0 * sin( gTime * 2.0 + 20.0 * skyAngle.y ) ) * length( starPos ), 0.0, 1.0 ) * ( sun > 0.0 ? 0.0 : 1.0 );\n    return color;\n}\n\nfloat SceneRefl( vec3 p )\n{\n    p = abs( p );\n    \n    float rx = 50.0;\n    p.x = mod( p.x, rx ) - 0.5 * rx;\n    p.z -= 15.0;\n    \n    float a = Box( p, vec3( 0.3, 12.0, 0.3 ) );\n    \n    p += vec3( 0.0, -12.7, 3.5 );\n    Rotate( p.yz, -0.4 * MATH_PI );\n    float b = Box( p, vec3( 0.5, 4.0, 0.3 ) );\n    \n    float bloom = Box( p + vec3( 0.0, -0.5, 0.6 ), vec3( 0.5, 3.0, 0.1 ) );\n    gReflStreetLampDist = min( gReflStreetLampDist, bloom );\n    \n    return Union( a, b );\n}\n\nfloat CastReflectionRay( in vec3 ro, in vec3 rd )\n{\n    const float maxd = 100.0;\n    \n    float h = 0.5;\n    float t = 0.0;\n   \n    for ( int i = 0; i < 16; ++i )\n    {\n        if ( h < 0.01 || t > maxd ) \n        {\n            break;\n        }\n        \n        h = SceneRefl( ro + rd * t );\n        t += h;\n    }\n\n    if ( t > maxd )\n    {\n        t = -1.0;\n    }\n    \n    return t;\n}\n\nvec3 SceneReflection( vec3 pos, vec3 normal, vec3 rayDir )\n{\n\tvec3 reflDir = reflect( rayDir, normal );\n    float t = CastReflectionRay( pos + 0.5 * reflDir, reflDir );\n    float w = abs( normal.x - 1.0 ) < 0.5 ? 0.3 : 1.0;    \n    \n    vec3 color = Sky( reflDir ) * mix( 1.0, 0.7, w * float( t >= 0.0 ) );\n    color += w * vec3( 0.54, 0.42, 0.78 ) * 2.0 * vec3( Saturate( exp( -gReflStreetLampDist * 0.6 ) ) );\n    return color;\n}\n\nvec3 SceneBloom( vec3 rayOrigin, vec3 rayDir )\n{\n    vec3 color = vec3( 0.0 );\n\n    vec3 center = vec3( 25.0, 14.0, 16.0 );\n    vec3 left   = vec3( 0.0, 0.0, 1.0 );\n    center += left * clamp( dot( rayOrigin - center, left ), -7.0, 7.0 );   \n    \n\tcolor += vec3( 0.54, 0.42, 0.78 ) * 0.5 * vec3( Saturate( exp( -gStreetLampDist * 0.6 ) ) );\n    color += vec3( 1.2, 0.1, 0.2 ) * 0.3 * vec3( Saturate( exp( -gCarLampDist * 2.0 ) ) );\n\n    return color;\n}\n\nfloat SmoothNoise( vec3 v )\n{\n\tvec3 i = floor( v );\n\tvec3 f = fract( v );\n\n\tf = f * f * ( -2.0 * f + 3.0 );\n\n\tvec2 uv\t\t= ( i.xy + vec2( 7.0, 17.0 ) * i.z ) + f.xy;\n\tfloat lowz\t= textureLod( iChannel0, ( uv.xy + 0.5 ) \/ 64.0, 0.0 ).x;\n\n\tuv\t\t\t= ( i.xy + vec2( 7.0, 17.0 ) * ( i.z + 1.0 ) ) + f.xy;\n\tfloat highz = textureLod( iChannel0, ( uv.xy + 0.5 ) \/ 64.0, 0.0 ).x;\n\tfloat r\t\t= mix( lowz, highz, f.z );\n\n\treturn 2.0 * r - 1.0;\n}\n\nfloat DensityNoise( vec3 pos, vec3 noisePosScale, vec3 noisePosScaleBias, float noiseScale, float noiseBias )\n{\n\tpos = pos * noisePosScale + noisePosScaleBias;\n\n\tfloat noise = SmoothNoise( pos ) + 0.5 * SmoothNoise( pos * 3.07 );\n\tnoise = Saturate( noise * noiseScale + noiseBias );\n\n\treturn noise;\n}\n\nvoid VolumetricFog( inout vec3 color, vec3 rayOrigin, vec3 rayDir, float sceneT, vec2 fragCoord )\n{\n    sceneT = sceneT <= 0.0 ? 200.0 : sceneT;\n    \n    vec3 seed = vec3( 0.06711056, 0.00583715, 52.9829189 );\n    float dither = fract( seed.z * fract( dot( fragCoord.xy, seed.xy ) ) );\n    \n    float fogAlpha = 0.0;\n    for ( int i = 0; i < 32; ++i )\n    {\n        float t = ( float( i ) + 0.5 + dither ) * 5.0;\n        if ( t <= sceneT )\n        {\n        \tvec3 p = rayOrigin + t * rayDir;\n        \tfloat s = DensityNoise( p, vec3( 0.3 ), vec3( 0.0, 0.0, 0.0 ), 1.0, 0.0 ) * exp( -p.y * gFogHeightFalloff );\n            fogAlpha += gFogDensity * t * exp( -gFogDensity * t ) * s;\n        }\n    }\n    fogAlpha = 1.0 - Saturate( fogAlpha );\n    color = color * fogAlpha + vec3( 1.0 ) * ( 1.0 - fogAlpha );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    gTime       = iChannelTime[ 3 ];\n    gCarOffset  = 100.0 * gTime;\n    \n    vec2 screenUV = fragCoord.xy \/ iResolution.xy;\n    vec2 p = -1.0 + 2.0 * screenUV;\n    p.x *= iResolution.x \/ iResolution.y;\n\n    vec2 mo = iMouse.xy \/ iResolution.xy;\n    \n    float mbStrength\t= 1.0;\n    float fov\t\t\t= 1.2;\n    float cameraOffset  = gCarOffset;\n    float theta         = clamp( 10.0 * mo.y, 0.01, 0.55 * MATH_PI );\n    float phi           = 6.0 * mo.x;\n    vec3 target         = vec3( gCarOffset + 1.0, 3.0, 3.0 );    \n    float zoom          = 15.0;\n\n    \/\/ center game camera\n\tgFogDensity\t\t\t= 0.1;\n\tgFogHeightFalloff\t= mix( 0.1, 0.3, Saturate( ( gTime - 13.0 ) * 0.25 ) );\n    mbStrength\t\t\t= 1.0;\n    zoom            \t= 10.0 + 1.2 * sin( gTime );\n    cameraOffset    \t= gCarOffset;\n    target          \t= vec3( gCarOffset + 2.0, 5.0, 3.0 );\n    phi             \t= 2.8;\n    theta           \t= 1.267;    \n\n    if ( gTime > 18.8 )\n    {\n        \/\/ right side near camera\n\t\tgFogDensity\t\t\t= 0.1;\n\t\tgFogHeightFalloff\t= 0.3;        \n        mbStrength\t\t\t= 1.0;\n        float camWeight \t= smoothstep( 0.0, 1.0, Saturate( ( gTime - 18.8 ) * 0.25 ) );\n        zoom            \t= mix( zoom, 8.0 + sin( gTime ), camWeight );\n        cameraOffset    \t= gCarOffset;\n        target          \t= vec3( gCarOffset + 2.0, 5.0, 3.0 );    \n        phi             \t= mix( phi, 2.35, camWeight );\n        theta          \t\t= mix( theta, 1.27, camWeight );\n    }\n    if ( gTime > 33.0 )\n    {\n        \/\/ top chase camera     \n\t\tgFogDensity\t\t\t= 0.1;\n\t\tgFogHeightFalloff\t= 0.01;        \n        mbStrength\t\t\t= 0.0;        \n        zoom            \t= 130.0;\n        cameraOffset    \t= gCarOffset - ( gTime - 38.0 ) * 80.0;\n        target          \t= vec3( cameraOffset + 2.0, 5.0, 0.0 );\n        phi             \t= 2.3;\n        theta           \t= 0.4;\n    }\n    if ( gTime > 43.0 )\n    {\n        \/\/ building camera\n\t\tgFogDensity\t\t\t= 0.1;\n\t\tgFogHeightFalloff\t= 10.0;        \n        mbStrength\t\t\t= 0.0;\n        fov\t\t\t\t\t= 2.0;\n        cameraOffset    \t= gCarOffset - 10.0;\n        target         \t \t= vec3( gCarOffset + 2.0, 15.0, -16.0 );    \n        zoom            \t= 1.0;    \n        phi             \t= 0.0;\n        theta           \t= 0.0;\n    }\n    if ( gTime > 53.5 )\n    {\n        \/\/ left side near low camera  \n\t\tgFogDensity\t\t\t= 0.1;\n\t\tgFogHeightFalloff\t= 0.3;                \n        mbStrength\t\t\t= 1.0;\n        fov\t\t\t\t\t= min( 1.2 + ( gTime - 53.5 ) * 0.2, 0.8 );\n        zoom            \t= 8.0 + 3.0 * cos( gTime );\n        cameraOffset    \t= gCarOffset;\n        target          \t= vec3( gCarOffset + 2.0, 5.0, -1.0 );\n        phi             \t= 3.14;\n        theta           \t= 1.4;\n    }\n    if ( gTime > INTERIOR_START )\n    {\n        \/\/ interior camera\n        mbStrength\t\t= 1.0;\n        fov\t\t\t\t= 2.0;\n        zoom            = 7.0;    \n        cameraOffset    = gCarOffset;\n        target          = vec3( gCarOffset + 1.0, 2.8, 5.5 );        \n        phi             = 2.46;\n        theta           = 1.17;  \n    }\n    if ( gTime > INTERIOR_END )\n    {        \n        \/\/ center game camera and left side near camera     \n        mbStrength\t\t= 1.0;\n        fov\t\t\t\t= 1.2;\n\t\tfloat camWeight = gTime < 95.0 ? smoothstep( 0.0, 1.0, Saturate( ( gTime - 80.0 ) * 0.25 ) ) : smoothstep( 1.0, 0.0, Saturate( ( gTime - 95.0 ) * 0.25 ) );\n        zoom            = mix( 10.0, 6.0, camWeight ) + 1.3 * sin( gTime );\n        cameraOffset    = gCarOffset;\n        target          = vec3( gCarOffset + 2.0, 5.0, mix( 3.0, -1.0, camWeight ) );\n        phi             = mix( 2.8, 3.5, camWeight );\n        theta           = mix( 1.267, 0.8, camWeight );\n    }\n    if ( gTime > 99.5 )\n    {\n        fov\t= max( 1.2 - ( gTime - 99.5 ) * 0.5, 0.5 );\n    }\n    if ( gTime > 100.0 )\n    {\n        gCarOffset += ( gTime - 100.0 ) * 10.0;\n    }\n    \n#ifdef DEBUG_CAMERA\n    \/\/ orbiting debug camera\n    cameraOffset  = gCarOffset;\n    theta         = clamp( 10.0 * mo.y, 0.01, 0.55 * MATH_PI );\n    phi           = 6.0 * mo.x;\n    target        = vec3( gCarOffset + 1.0, 3.0, 3.0 );    \n    zoom          = 5.0;\n#endif\n    \n    vec3 rayOrigin;    \n    rayOrigin.x = zoom * sin( theta ) * cos( phi ) + cameraOffset;\n    rayOrigin.y = zoom * cos( theta );\n    rayOrigin.z = zoom * sin( theta ) * sin( phi );\n\n    mat3 worldToCamera = CameraLookAt( rayOrigin, target, 0.0 );\n    \n    \/\/ ray direction\n    vec3 rayDir = worldToCamera * normalize( vec3(p.xy,fov) );  \n    vec3 color = vec3( 0.0 );\n    \n    float t = CastRay( rayOrigin, rayDir );\n    if ( t > 0.0 )\n    {\n        vec3 pos = rayOrigin + t * rayDir;\n        vec3 normal = SceneNormal( pos );\n        vec3 sunDir = normalize( vec3( -300., -200.0, 0.0 ) ); \/\/ sun pos\n        vec3 sunColor = vec3( 1.0, 0.2, 0.0 ) * 0.5;\n        \n        vec3 posLS  = pos * 0.1;        \n        vec3 nrmLS  = normal;\n        vec3 absNrm = abs( nrmLS );\n\n        float maxAbsNrm = max( max( absNrm.x, absNrm.y ), absNrm.z );\n        vec2 uvXZ   = absNrm.x >= maxAbsNrm ? posLS.zy : posLS.xy; \n        vec2 uvXYZ  = absNrm.y >= maxAbsNrm ? posLS.xz : uvXZ;\n      \n        vec3 diffuseColor = vec3( 1.0 );\n        vec3 specularColor = vec3( 0.04 );\n        vec3 emissive = vec3( 0.0 );\n        \n        \/\/ road\n        diffuseColor = vec3( pos.y > 20.0 ? 0.3 : 0.5 );\n        if ( gMaterial == MTRL_ROAD && abs( pos.z ) < 14.0 )\n        {\n            diffuseColor = vec3( 0.5 );\n            if ( abs( pos.z ) < 0.2 )\n            {\n                diffuseColor = vec3( 1.0 );\n            }\n\n\t\t\tif ( ( abs( pos.z + 7.0 ) < 0.2 || abs( pos.z - 7.0 ) < 0.2 ) )\n            {\n                diffuseColor = vec3( 0.5 + 0.5 * exp( -4.0 * abs( 2.0 * fract( pos.x * 0.1 ) - 1.0 ) ) );\n            }\n            \n            \/\/ red trail\n            float trailX = pos.x - gCarOffset;\n            emissive = 1.2 * vec3( 1.1, 0.0, 0.0 ) \n                * Saturate( exp( -0.4 * abs( pos.z - 3.0 ) ) )\n                * Saturate( 1.0 + trailX * 0.002 )\n                * Saturate( -0.5 - trailX * 0.5 );\n        }\n        \n        \/\/ lamp\n        if ( gMaterial == MTRL_STREETLAMPS )\n        {\n            emissive = pos.y > 11.5 && normal.y > 0.5 ? vec3( 1.0 ) : vec3( 0.0 );\n        }        \n        \n        if ( gMaterial == MTRL_BUILDING && abs( normal.y ) < 0.1 )\n        {\n            diffuseColor = vec3( 0.7 );\n                \n            vec2 tilePos    = fract( uvXZ * 4.0 );\n            vec2 tileId     = uvXZ * 4.0 - tilePos;\n            vec2 edge       = min( clamp( ( tilePos - 0.2 ) * 5.0, 0.0, 1.0 ), clamp( ( 1.0 - tilePos ) * 5.0, 0.0, 1.0 ) );       \n            float bump      = edge.x * edge.y;\n\n            float tileRand = Rand( tileId );\n            vec3 tileColor = vec3( 0.3 );\n            tileColor = tileRand > 0.5 ? vec3( 1.0, 0.3, 0.5 ) * 1.2 : tileColor;\n            tileColor = tileRand > 0.7 ? vec3( 1.0, 0.5, 0.0 ) * 1.2 : tileColor;\n            tileColor = tileRand > 0.9 ? vec3( 1.0, 0.5, 0.9 ) * 1.2 : tileColor;\n            emissive = 1.0 * bump * tileRand * tileColor;\n            \n            emissive *= clamp( 4.0 * abs( tilePos.x - 0.5 ) + 0.5, 0.0, 1.0 );\n            emissive *= clamp( 4.0 * abs( tilePos.y - 0.5 ) + 0.5, 0.0, 1.0 );\n        }\n        \n        if ( gMaterial == MTRL_BUILDING )\n        {\n            float buildingLine = abs( 2.0 * fract( uvXZ.y * 2.0 - 0.05 ) - 1.0 );\n            emissive += 2.0 * vec3( 0.54, 0.42, 0.78 ) * ( exp2( -buildingLine * 4.0 ) );\n            if ( pos.y < 5.0 )\n            {\n                emissive = vec3( 0.0 );\n            }    \n            \n            if ( abs( -normal.y - 1.0 ) < 0.1 )\n            {\n                diffuseColor \t= vec3( 0.3 );\n                emissive \t\t= vec3( 0.0 );\n            }\n        }\n        \n        if ( gMaterial == MTRL_TUNNEL )\n        {\n            diffuseColor = vec3( 0.8 );\n        }        \n        \n        \/\/ car \n        if ( gMaterial == MTRL_CAR )\n        {\n            diffuseColor = vec3( 0.1 );\n            specularColor = vec3( 0.6 );\n            \n            \/\/ car lamp emissive\n            vec2 pl = pos.zy;\n            pl.x = abs( pl.x - 3.0 );\n            float dl = Rectangle( pl + vec2( -1.0, -1.3 ), vec2( 0.4, 0.06 ) );\n            float es = Saturate( exp( -dl * 20.0 ) );\n            emissive = 1.5 * vec3( 1.2, 0.1, 0.3 ) * es;\n            specularColor *= 1.0 - es;\n        }\n        \n        \/\/ car interior\n        if ( gMaterial == MTRL_CAR && gTime > INTERIOR_START && gTime < INTERIOR_END )\n        {\n            diffuseColor    = vec3( 0.2 );\n            specularColor   = vec3( 0.04 );\n            emissive        = Dashboard( pos );\n        }\n        \n        float wrap = 0.5;\n        vec3 diffuse = diffuseColor * sunColor * Saturate( ( dot( normal, sunDir ) + wrap ) \/ ( 1.0 + wrap ) );\n        color = diffuse;\n        \n        vec3 halfVec2       = normalize( sunDir + rayDir );\n        float NdotH2        = dot( normal, halfVec2 );\n        color += sunColor * specularColor * Saturate( dot( normal, sunDir ) ) * pow( clamp( NdotH2, 0.0, 1.0 ), 32.0 );        \n        \n        \/\/ local lights\n        vec3 pos2       = pos;\n        pos2.x = mod( pos2.x, 50.0 );                \n\n        vec3 tubeColor  = vec3( 0.54, 0.42, 0.78 ) * 300.0;\n        vec3 tubePos    = vec3( 25.0, -10.0, 0.0 );\n        vec3 tubeLeft   = vec3( 0.0, 0.0, 1.0 );        \n        tubePos += tubeLeft * clamp( dot( pos2 - tubePos, tubeLeft ), -7.0, 7.0 );        \n        \n        vec3 tubeDir = normalize( tubePos - pos2 );\n        float tubeAtt = 1.0 \/ pow( length( tubePos - pos2 ), 2.0 );\n        color += diffuseColor * tubeColor * tubeAtt * Saturate( dot( normal, tubeDir ) );\n        \n        \/\/ car lights\n        vec3 spotColor  = vec3( 0.54, 0.42, 0.78 ) * 300.0;\n        vec3 spotPos    = vec3( 3.1 + gCarOffset, -1.5, 3.0 );\n        vec3 spotDir    = normalize( spotPos - pos );\n        float spotAtt = 1.0 \/ pow( length( spotPos - pos ), 2.0 );\n        spotAtt *= Saturate( -spotDir.x * 6.0 - 4.0 );\n        color += diffuseColor * spotColor * spotAtt * Saturate( dot( normal, spotDir ) );                \n\n        \/\/ ambient\n        color += 0.1 * vec3( 0.54, 0.42, 0.78 ) * clamp( -normal.y + 0.5, 0.0, 1.0 );        \n        color *= gMaterial == MTRL_ROAD   ? TerrainAO( pos ) : 1.0;\n        \n        \/\/ emissive\n        color += emissive;\n                \n        \/\/ reflection\n        float fresnel = Saturate( pow( 1.0 + dot( rayDir, -normal ), 5.0 ) );\n        specularColor = mix( specularColor, vec3( 1.0 ), fresnel );\n        specularColor = gMaterial == MTRL_ROAD || gMaterial == MTRL_TUNNEL? specularColor * 0.05 : specularColor;        \n        color += specularColor * 0.5 * SceneReflection( pos, normal, rayDir );\n        \n        \/\/ back plane\n        color *= 1.0 - clamp( ( t - 200.0 ) * 0.01, 0.0, 1.0 ) * 0.8;\n        \n        \/\/ wireframe\n        vec2 tilePos = mod( uvXYZ * vec2( gMaterial == MTRL_BUILDING ? 2.0 : 0.5, 2.0 ), 1.0 );\n        tilePos = abs( 2.0 * tilePos - 1.0 );\n        float wireframe = ( exp2( -tilePos.x * 6.0 ) + exp2( -tilePos.y * 6.0 ) );         \n        float wireframeAlpha = gTime > 50.0 ? Saturate( ( pos.x - 7080.0 ) * 0.05 ) * Saturate( ( 8080.0 - pos.x ) * 0.05 ) : Saturate( 1.0 - ( gTime - 13.5 ) \/ 4.0 );\n        wireframeAlpha = gMaterial == MTRL_CAR ? 0.0 : wireframeAlpha;\n        \n        color = mix( color, Sky( rayDir ) + wireframe * vec3( 0.54, 0.42, 0.78 ) * 1.2, wireframeAlpha );\n        mbStrength *= 1.0 - wireframeAlpha;\n        \n#ifdef DEBUG_LIGHTING\n\t\tcolor = mix( vec3( 1.0, 0.5, 0.0 ), vec3( 0.0, 0.0, 1.0 ), 0.5 * normal.y + 0.5 );\n#endif\n    }\n    else\n    {\n        color \t\t= Sky( rayDir );\n        mbStrength \t= 0.0;\n    }\n    \n    VolumetricFog( color, rayOrigin, rayDir, t, fragCoord );\n\tcolor += SceneBloom( rayOrigin, rayDir );\n    color *= Saturate( ( 107.0 - gTime ) \/ 5.0 );\n    \n    fragColor = vec4( color, mbStrength );\n}\n","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\/\/ Post processing\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tvec2 screenUV = fragCoord.xy \/ iResolution.xy;\n    \n    \/\/ radial blur\n    vec4 mainSample = texture( iChannel0, screenUV );    \n    vec2 blurOffset = ( screenUV - vec2( 0.5 ) ) * 0.002 * mainSample.w;\n    vec3 color = mainSample.xyz;\n\tfor ( int iSample = 1; iSample < 16; ++iSample )\n\t{\n\t\tcolor += texture( iChannel0, screenUV - blurOffset * float( iSample ) ).xyz;\n\t}    \n    color \/= 16.0;\n    \n    \/\/ vignette\n    float vignette = screenUV.x * screenUV.y * ( 1.0 - screenUV.x ) * ( 1.0 - screenUV.y );\n    vignette = clamp( pow( 16.0 * vignette, 0.3 ), 0.0, 1.0 );\n    color *= vignette;\n    \n    float scanline   = clamp( 0.95 + 0.05 * cos( 3.14 * ( screenUV.y + 0.008 * iTime ) * 240.0 * 1.0 ), 0.0, 1.0 );\n    float grille  \t= 0.85 + 0.15 * clamp( 1.5 * cos( 3.14 * screenUV.x * 640.0 * 1.0 ), 0.0, 1.0 );\n    color *= scanline * grille * 1.2;    \n        \n    fragColor = vec4( color, 1.0 );\n}\n\n","name":"Buf B","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"4sSfzK","date":"1501466480","viewed":32239,"name":"[SH17C] Physically Based Shading","username":"knarkowicz","description":"Click on menu buttons, use controls, rotate object and learn!","likes":468,"published":3,"flags":48,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"\/media\/a\/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"\/media\/ap\/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3zn","filepath":"\/media\/a\/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"\/media\/ap\/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"\/media\/a\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"\/media\/ap\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float MATH_PI = float(3.14159);\n\nconst float MENU_SURFACE = 0.;\nconst float MENU_METAL = 1.;\nconst float MENU_DIELECTRIC = 2.;\nconst float MENU_ROUGHNESS = 3.;\nconst float MENU_BASE_COLOR = 4.;\nconst float MENU_LIGHTING = 5.;\nconst float MENU_DIFFUSE = 6.;\nconst float MENU_SPECULAR = 7.;\nconst float MENU_DISTR = 8.;\nconst float MENU_FRESNEL = 9.;\nconst float MENU_GEOMETRY = 10.;\n\nconst vec3 BASE_COLORS[6] = vec3[6]\n(\n\tvec3(0.74),\n\tvec3(0.51, 0.72, 0.81),\n\tvec3(0.66, .85, .42),\n\tvec3(0.87, 0.53, 0.66),\n\tvec3(0.51, 0.46, 0.74),\n\tvec3(0.78, 0.71, 0.45)\n\t);\n\nstruct AppState\n{\n\tfloat\tmenuId;\n\tfloat\tmetal;\n\tfloat   roughness;\n\tfloat   baseColor;\n\tfloat   focus;\n\tfloat   focusObjRot;\n\tfloat   objRot;\n};\n\nvec4 LoadValue(int x, int y)\n{\n\treturn texelFetch(iChannel0, ivec2(x, y), 0);\n}\n\nvoid LoadState(out AppState s)\n{\n\tvec4 data;\n\n\tdata = LoadValue(0, 0);\n\ts.menuId = data.x;\n\ts.metal = data.y;\n\ts.roughness = data.z;\n\ts.baseColor = data.w;\n\n\tdata = LoadValue(1, 0);\n\ts.focus = data.x;\n\ts.focusObjRot = data.y;\n\ts.objRot = data.z;\n}\n\nvoid StoreValue(vec2 re, vec4 va, inout vec4 fragColor, vec2 fragCoord)\n{\n\tfragCoord = floor(fragCoord);\n\tfragColor = (fragCoord.x == re.x && fragCoord.y == re.y) ? va : fragColor;\n}\n\nfloat saturate(float x)\n{\n\treturn clamp(x, 0., 1.);\n}\n\nvec3 saturate(vec3 x)\n{\n\treturn clamp(x, vec3(0.), vec3(1.));\n}\n\nfloat Smooth(float x)\n{\n\treturn smoothstep(0., 1., saturate(x));\n}\n\nvoid Repeat(inout float p, float w)\n{\n\tp = mod(p, w) - 0.5f * w;\n}\n\nfloat Circle(vec2 p, float r)\n{\n\treturn (length(p \/ r) - 1.) * r;\n}\n\nfloat Rectangle(vec2 p, vec2 b)\n{\n\tvec2 d = abs(p) - b;\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nvoid Rotate(inout vec2 p, float a)\n{\n\tp = cos(a) * p + sin(a) * vec2(p.y, -p.x);\n}\n\nfloat Capsule(vec2 p, float r, float c)\n{\n\treturn mix(length(p.x) - r, length(vec2(p.x, abs(p.y) - c)) - r, step(c, abs(p.y)));\n}\n\nfloat Arrow(vec2 p, float a, float l, float w)\n{\n\tRotate(p, a);\n\tp.y += l;\n\n\tfloat body = Capsule(p, w, l);\n\tp.y -= w;\n\n\tfloat tip = p.y + l;\n\n\tp.y += l + w;\n\tRotate(p, +2.);\n\ttip = max(tip, p.y - 2. * w);\n\tRotate(p, -4.);\n\ttip = max(tip, p.y - 2. * w);\n\n\treturn min(body, tip);\n}\n\nfloat TextSDF(vec2 p, float glyph)\n{\n\tp = abs(p.x - .5) > .5 || abs(p.y - .5) > .5 ? vec2(0.) : p;\n\treturn 2. * (texture(iChannel3, p \/ 16. + fract(vec2(glyph, 15. - floor(glyph \/ 16.)) \/ 16.)).w - 127. \/ 255.);\n}\n\nvoid Diagram(inout vec3 color, vec2 p, in AppState s)\n{\n\tvec3 surfColor = vec3(0.9, 0.84, 0.8);\n\tvec3 lightColor = vec3(0.88, 0.65, 0.2);\n\tvec3 baseColor = BASE_COLORS[int(s.baseColor)];\n\tvec3 diffuseColor = s.metal == 1. ? vec3(0.) : baseColor;\n\tvec3 specularColor = s.metal == 1. ? baseColor : vec3(0.7);\n\n\tp -= vec2(84., 44.);\n\n\tvec2 t = p - vec2(18., 4.);\n\tfloat r = Rectangle(t, vec2(52., 12.));\n\tcolor = mix(color, surfColor, Smooth(-r * 2.));\n\n\tt.y += s.roughness * sin(t.x);\n\tr = Rectangle(t - vec2(0., 11.), vec2(52., 1.2));\n\tcolor = mix(color, surfColor * 0.6, Smooth(-r * 2.));\n\n\n\t\/\/ refraction\n\tr = 1e4;\n\tt = p - vec2(18., 15.);\n\tfor (int i = 0; i < 3; ++i)\n\t{\n\t\tr = min(r, Arrow(t - vec2(-15. + float(i) * 15., 0.), -0.4, 7., .7));\n\t}\n\tr = min(r, Arrow(t - vec2(9., -15.), 2., 4., .7));\n\tr = min(r, Arrow(t - vec2(17., -10.), 3.8, 18., .7));\n\tr = min(r, Arrow(t - vec2(-6., -14.), 0.9, 3., .7));\n\tr = min(r, Arrow(t - vec2(1., -19.), 2.9, 18., .7));\n\tr = min(r, Arrow(t - vec2(-22., -15.), 4.5, 2., .7));\n\tr = min(r, Arrow(t - vec2(-28., -14.), 2.6, 14., .7));\n\tif (s.metal != 1. && s.menuId < MENU_SPECULAR)\n\t{\n\t\tcolor = mix(color, diffuseColor, Smooth(-r * 2.));\n\t}\n\n\t\/\/ reflection\n\tr = 1e4;\n\tt = p - vec2(18., 15.);\n\tfor (int i = 0; i < 3; ++i)\n\t{\n\t\tfloat off = s.roughness * (1.5 - float(i)) * .45;\n\t\tr = min(r, Arrow(t - vec2(-15. + float(i) * 15., 2.), -0.5 * MATH_PI - 0.9 + off, 12., 1.));\n\t}\n\tif (s.menuId != MENU_DIFFUSE)\n\t{\n\t\tcolor = mix(color, specularColor, Smooth(-r * 2.));\n\t}\n\n\t\/\/ light in\n\tr = 1e4;\n\tt = p - vec2(18., 15.);\n\tfor (int i = 0; i < 3; ++i)\n\t{\n\t\tr = min(r, Arrow(t - vec2(12. + float(i) * 15., 22.), -0.9, 15., 1.));\n\t}\n\tcolor = mix(color, lightColor, Smooth(-r * 2.));\n}\n\nfloat RaySphere(vec3 rayOrigin, vec3 rayDir, vec3 spherePos, float sphereRadius)\n{\n\tvec3 oc = rayOrigin - spherePos;\n\n\tfloat b = dot(oc, rayDir);\n\tfloat c = dot(oc, oc) - sphereRadius * sphereRadius;\n\tfloat h = b * b - c;\n\n\tfloat t;\n\tif (h < 0.0)\n\t{\n\t\tt = -1.0;\n\t}\n\telse\n\t{\n\t\tt = (-b - sqrt(h));\n\t}\n\treturn t;\n}\n\nfloat VisibilityTerm(float roughness, float ndotv, float ndotl)\n{\n\tfloat r2 = roughness * roughness;\n\tfloat gv = ndotl * sqrt(ndotv * (ndotv - ndotv * r2) + r2);\n\tfloat gl = ndotv * sqrt(ndotl * (ndotl - ndotl * r2) + r2);\n\treturn 0.5 \/ max(gv + gl, 0.00001);\n}\n\nfloat DistributionTerm(float roughness, float ndoth)\n{\n\tfloat r2 = roughness * roughness;\n\tfloat d = (ndoth * r2 - ndoth) * ndoth + 1.0;\n\treturn r2 \/ (d * d * MATH_PI);\n}\n\nvec3 FresnelTerm(vec3 specularColor, float vdoth)\n{\n\tvec3 fresnel = specularColor + (1. - specularColor) * pow((1. - vdoth), 5.);\n\treturn fresnel;\n}\n\nfloat Cylinder(vec3 p, float r, float height)\n{\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\nfloat Substract(float a, float b)\n{\n\treturn max(a, -b);\n}\n\nfloat SubstractRound(float a, float b, float r)\n{\n\tvec2 u = max(vec2(r + a, r - b), vec2(0.0, 0.0));\n\treturn min(-r, max(a, -b)) + length(u);\n}\n\nfloat Union(float a, float b)\n{\n\treturn min(a, b);\n}\n\nfloat Box(vec3 p, vec3 b)\n{\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat Sphere(vec3 p, float s)\n{\n\treturn length(p) - s;\n}\n\nfloat Torus(vec3 p, float sr, float lr)\n{\n\treturn length(vec2(length(p.xz) - lr, p.y)) - sr;\n}\n\nfloat Disc(vec3 p, float r, float t)\n{\n\tfloat l = length(p.xz) - r;\n\treturn l < 0. ? abs(p.y) - t : length(vec2(p.y, l)) - t;\n}\n\nfloat UnionRound(float a, float b, float k)\n{\n\tfloat h = clamp(0.5 + 0.5 * (b - a) \/ k, 0.0, 1.0);\n\treturn mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat Scene(vec3 p, mat3 localToWorld)\n{\n\tp = p * localToWorld;\n\n\t\/\/ ring\n\tvec3 t = p;\n\tt.y -= -.7;\n\tfloat r = Substract(Disc(t, 0.9, .1), Cylinder(t, .7, 2.));\n\tvec3 t2 = t - vec3(0., 0., 1.0);\n\tRotate(t2.xz, 0.25 * MATH_PI);\n\tr = Substract(r, Box(t2, vec3(.5)));\n\tr = Union(r, Disc(t + vec3(0., 0.05, 0.), 0.85, .05));\n\n\tt = p;\n\tRotate(t.yz, -.3);\n\n\t\/\/ body\n\tfloat b = Sphere(t, .8);\n\tb = Substract(b, Sphere(t - vec3(0., 0., .5), .5));\n\tb = Substract(b, Sphere(t - vec3(0., 0., -.7), .3));\n\tb = Substract(b, Box(t, vec3(2., .03, 2.)));\n\tb = Union(b, Sphere(t, .7));\n\n\tfloat ret = Union(r, b);\n\treturn ret;\n}\n\nfloat CastRay(in vec3 ro, in vec3 rd, mat3 localToWorld)\n{\n\tconst float maxd = 5.0;\n\n\tfloat h = 0.5;\n\tfloat t = 0.0;\n\n\tfor (int i = 0; i < 50; ++i)\n\t{\n\t\tif (h < 0.001 || t > maxd)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\th = Scene(ro + rd * t, localToWorld);\n\t\tt += h;\n\t}\n\n\tif (t > maxd)\n\t{\n\t\tt = -1.0;\n\t}\n\n\treturn t;\n}\n\nvec3 SceneNormal(in vec3 pos, mat3 localToWorld)\n{\n\tvec3 eps = vec3(0.001, 0.0, 0.0);\n\tvec3 nor = vec3(\n\t\tScene(pos + eps.xyy, localToWorld) - Scene(pos - eps.xyy, localToWorld),\n\t\tScene(pos + eps.yxy, localToWorld) - Scene(pos - eps.yxy, localToWorld),\n\t\tScene(pos + eps.yyx, localToWorld) - Scene(pos - eps.yyx, localToWorld));\n\treturn normalize(nor);\n}\n\nfloat SceneAO(vec3 p, vec3 n, mat3 localToWorld)\n{\n\tfloat ao = 0.0;\n\tfloat s = 1.0;\n\tfor (int i = 0; i < 6; ++i)\n\t{\n\t\tfloat off = 0.001 + 0.2 * float(i) \/ 5.;\n\t\tfloat t = Scene(n * off + p, localToWorld);\n\t\tao += (off - t) * s;\n\t\ts *= 0.4;\n\t}\n\n\treturn Smooth(1.0 - 12.0 * ao);\n}\n\n\/\/ St. Peter's Basilica SH\n\/\/ https:\/\/www.shadertoy.com\/view\/lt2GRD\nstruct SHCoefficients\n{\n\tvec3 l00, l1m1, l10, l11, l2m2, l2m1, l20, l21, l22;\n};\n\nconst SHCoefficients SH_STPETER = SHCoefficients(\n\tvec3(0.3623915, 0.2624130, 0.2326261),\n\tvec3(0.1759131, 0.1436266, 0.1260569),\n\tvec3(-0.0247311, -0.0101254, -0.0010745),\n\tvec3(0.0346500, 0.0223184, 0.0101350),\n\tvec3(0.0198140, 0.0144073, 0.0043987),\n\tvec3(-0.0469596, -0.0254485, -0.0117786),\n\tvec3(-0.0898667, -0.0760911, -0.0740964),\n\tvec3(0.0050194, 0.0038841, 0.0001374),\n\tvec3(-0.0818750, -0.0321501, 0.0033399)\n);\n\nvec3 SHIrradiance(vec3 nrm)\n{\n\tconst SHCoefficients c = SH_STPETER;\n\tconst float c1 = 0.429043;\n\tconst float c2 = 0.511664;\n\tconst float c3 = 0.743125;\n\tconst float c4 = 0.886227;\n\tconst float c5 = 0.247708;\n\treturn (\n\t\tc1 * c.l22 * (nrm.x * nrm.x - nrm.y * nrm.y) +\n\t\tc3 * c.l20 * nrm.z * nrm.z +\n\t\tc4 * c.l00 -\n\t\tc5 * c.l20 +\n\t\t2.0 * c1 * c.l2m2 * nrm.x * nrm.y +\n\t\t2.0 * c1 * c.l21  * nrm.x * nrm.z +\n\t\t2.0 * c1 * c.l2m1 * nrm.y * nrm.z +\n\t\t2.0 * c2 * c.l11  * nrm.x +\n\t\t2.0 * c2 * c.l1m1 * nrm.y +\n\t\t2.0 * c2 * c.l10  * nrm.z\n\t\t);\n}\n\n\/\/ https:\/\/www.unrealengine.com\/en-US\/blog\/physically-based-shading-on-mobile\nvec3 EnvBRDFApprox(vec3 specularColor, float roughness, float ndotv)\n{\n\tconst vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);\n\tconst vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min(r.x * r.x, exp2(-9.28 * ndotv)) * r.x + r.y;\n\tvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\n\nvec3 EnvRemap(vec3 c)\n{\n\treturn pow(2. * c, vec3(2.2));\n}\n\nvoid DrawScene(inout vec3 color, vec2 p, in AppState s)\n{\n\tvec3 lightColor = vec3(2.);\n\tvec3 lightDir = normalize(vec3(.7, .9, -.2));\n\n\tvec3 baseColor = pow(BASE_COLORS[int(s.baseColor)], vec3(2.2));\n\tvec3 diffuseColor = s.metal == 1. ? vec3(0.) : baseColor;\n\tvec3 specularColor = s.metal == 1. ? baseColor : vec3(0.02);\n\tfloat roughnessE = s.roughness * s.roughness;\n\tfloat roughnessL = max(.01, roughnessE);\n\n\tfloat a = -iTime * .5;\n\tmat3 rot = mat3(\n\t\tvec3(cos(a), 0., -sin(a)),\n\t\tvec3(0., 1., 0.),\n\t\tvec3(sin(a), 0., cos(a))\n\t);\n\n\tp -= vec2(-20., 10.);\n\tp *= .011;\n\n\tfloat yaw = 2.7 - s.objRot;\n\tmat3 rotZ = mat3(\n\t\tvec3(cos(yaw), 0.0, -sin(yaw)),\n\t\tvec3(0.0, 1.0, 0.0),\n\t\tvec3(sin(yaw), 0.0, cos(yaw))\n\t);\n\n\tfloat phi = -0.1;\n\tmat3 rotY = mat3(\n\t\tvec3(1.0, 0.0, 0.0),\n\t\tvec3(0.0, cos(phi), sin(phi)),\n\t\tvec3(0.0, -sin(phi), cos(phi))\n\t);\n\n\tmat3 localToWorld = rotY * rotZ;\n\n\tvec3 rayOrigin = vec3(0.0, .5, -3.5);\n\tvec3 rayDir = normalize(vec3(p.x, p.y, 2.0));\n\tfloat t = CastRay(rayOrigin, rayDir, localToWorld);\n\tif (t > 0.0)\n\t{\n\t\tvec3 pos = rayOrigin + t * rayDir;\n\t\tvec3 normal = SceneNormal(pos, localToWorld);\n\t\tvec3 viewDir = -rayDir;\n\t\tvec3 refl = reflect(rayDir, normal);\n\n\t\tvec3 diffuse = vec3(0.);\n\t\tvec3 specular = vec3(0.);\n\n\t\tvec3 halfVec = normalize(viewDir + lightDir);\n\t\tfloat vdoth = saturate(dot(viewDir, halfVec));\n\t\tfloat ndoth = saturate(dot(normal, halfVec));\n\t\tfloat ndotv = saturate(dot(normal, viewDir));\n\t\tfloat ndotl = saturate(dot(normal, lightDir));\n\t\tvec3 envSpecularColor = EnvBRDFApprox(specularColor, roughnessE, ndotv);\n\n\t\tvec3 env1 = EnvRemap(texture(iChannel2, refl).xyz);\n\t\tvec3 env2 = EnvRemap(texture(iChannel1, refl).xyz);\n\t\tvec3 env3 = EnvRemap(SHIrradiance(refl));\n\t\tvec3 env = mix(env1, env2, saturate(roughnessE * 4.));\n\t\tenv = mix(env, env3, saturate((roughnessE - 0.25) \/ 0.75));\n\n\t\tdiffuse += diffuseColor * EnvRemap(SHIrradiance(normal));\n\t\tspecular += envSpecularColor * env;\n\n\t\tdiffuse += diffuseColor * lightColor * saturate(dot(normal, lightDir));\n\n\t\tvec3 lightF = FresnelTerm(specularColor, vdoth);\n\t\tfloat lightD = DistributionTerm(roughnessL, ndoth);\n\t\tfloat lightV = VisibilityTerm(roughnessL, ndotv, ndotl);\n\t\tspecular += lightColor * lightF * (lightD * lightV * MATH_PI * ndotl);\n\n\t\tfloat ao = SceneAO(pos, normal, localToWorld);\n\t\tdiffuse *= ao;\n\t\tspecular *= saturate(pow(ndotv + ao, roughnessE) - 1. + ao);\n\n\t\tcolor = diffuse + specular;\n\t\tif (s.menuId == MENU_DIFFUSE)\n\t\t{\n\t\t\tcolor = diffuse;\n\t\t}\n\t\tif (s.menuId == MENU_SPECULAR)\n\t\t{\n\t\t\tcolor = specular;\n\t\t}\n\t\tif (s.menuId == MENU_DISTR)\n\t\t{\n\t\t\tcolor = vec3(lightD);\n\t\t}\n\t\tif (s.menuId == MENU_FRESNEL)\n\t\t{\n\t\t\tcolor = envSpecularColor;\n\t\t}\n\t\tif (s.menuId == MENU_GEOMETRY)\n\t\t{\n\t\t\tcolor = vec3(lightV) * (4.0f * ndotv * ndotl);\n\t\t}\n\t\tcolor = pow(color * .4, vec3(1. \/ 2.2));\n\t}\n\telse\n\t{\n\t\t\/\/ shadow\n\t\tfloat planeT = -(rayOrigin.y + 1.2) \/ rayDir.y;\n\t\tif (planeT > 0.0)\n\t\t{\n\t\t\tvec3 p = rayOrigin + planeT * rayDir;\n\n\t\t\tfloat radius = .7;\n\t\t\tcolor *= 0.7 + 0.3 * smoothstep(0.0, 1.0, saturate(length(p + vec3(0.0, 1.0, -0.5)) - radius));\n\t\t}\n\t}\n}\n\nvoid InfoText(inout vec3 color, vec2 p, in AppState s)\n{\n\tp -= vec2(52, 12);\n\tvec2 q = p;\n\tif (s.menuId == MENU_METAL || s.menuId == MENU_BASE_COLOR || s.menuId == MENU_DISTR)\n\t{\n\t\tp.y -= 6.;\n\t}\n\tif (s.menuId == MENU_DIELECTRIC || s.menuId == MENU_FRESNEL)\n\t{\n\t\tp.y += 6.;\n\t}\n\tif (s.menuId == MENU_SPECULAR)\n\t{\n\t\tp.y += 6. * 6.;\n\n\t\tif (p.x < 21. && p.y >= 27. && p.y < 30.)\n\t\t{\n\t\t\tp.y = 0.;\n\t\t}\n\t\telse if (s.menuId == MENU_SPECULAR && p.y > 20. && p.y < 28. && p.x < 21.)\n\t\t{\n\t\t\tp.y += 3.;\n\t\t}\n\t}\n\n\tvec2 scale = vec2(3., 6.);\n\tvec2 t = floor(p \/ scale);\n\n\tuint v = 0u;\n\tif (s.menuId == MENU_SURFACE)\n\t{\n\t\tv = t.y == 2. ? (t.x < 4. ? 1702127169u : (t.x < 8. ? 1768431730u : (t.x < 12. ? 1852404852u : (t.x < 16. ? 1752440935u : (t.x < 20. ? 1970479205u : (t.x < 24. ? 1667327602u : (t.x < 28. ? 1768693861u : 7628903u))))))) : v;\n\t\tv = t.y == 1. ? (t.x < 4. ? 1937334642u : (t.x < 8. ? 1717924384u : (t.x < 12. ? 1952671084u : (t.x < 16. ? 1684955424u : (t.x < 20. ? 1717924384u : (t.x < 24. ? 1952670066u : (t.x < 28. ? 32u : 0u))))))) : v;\n\t\tv = t.y == 0. ? (t.x < 4. ? 1868784481u : (t.x < 8. ? 1852400754u : (t.x < 12. ? 1869881447u : (t.x < 16. ? 1701729056u : (t.x < 20. ? 1931963500u : (t.x < 24. ? 2002873376u : 0u)))))) : v;\n\t\tv = t.x >= 0. && t.x < 32. ? v : 0u;\n\t}\n\tif (s.menuId == MENU_METAL)\n\t{\n\t\tv = t.y == 1. ? (t.x < 4. ? 1635018061u : (t.x < 8. ? 1852776556u : (t.x < 12. ? 1914730860u : (t.x < 16. ? 1701602917u : (t.x < 20. ? 544437347u : (t.x < 24. ? 1751607660u : (t.x < 28. ? 1914729332u : (t.x < 32. ? 544438625u : 45u)))))))) : v;\n\t\tv = t.y == 0. ? (t.x < 4. ? 544432488u : (t.x < 8. ? 2037149295u : (t.x < 12. ? 1701868320u : (t.x < 16. ? 1634497891u : (t.x < 20. ? 114u : 0u))))) : v;\n\t\tv = t.x >= 0. && t.x < 36. ? v : 0u;\n\t}\n\tif (s.menuId == MENU_DIELECTRIC)\n\t{\n\t\tv = t.y == 3. ? (t.x < 4. ? 1818585412u : (t.x < 8. ? 1920230245u : (t.x < 12. ? 1914725225u : (t.x < 16. ? 1701602917u : (t.x < 20. ? 544437347u : (t.x < 24. ? 1701868328u : (t.x < 28. ? 1634497891u : (t.x < 32. ? 2107762u : 0u)))))))) : v;\n\t\tv = t.y == 2. ? (t.x < 4. ? 543452769u : (t.x < 8. ? 1935832435u : (t.x < 12. ? 1634103925u : (t.x < 16. ? 1931502947u : (t.x < 20. ? 1953784163u : (t.x < 24. ? 544436837u : (t.x < 28. ? 1718182952u : (t.x < 32. ? 1702065510u : 41u)))))))) : v;\n\t\tv = t.y == 1. ? (t.x < 4. ? 1751607660u : (t.x < 8. ? 1634869364u : (t.x < 12. ? 539915129u : (t.x < 16. ? 1667592275u : (t.x < 20. ? 1918987381u : (t.x < 24. ? 544434464u : (t.x < 28. ? 1936617315u : (t.x < 32. ? 1953390964u : 0u)))))))) : v;\n\t\tv = t.y == 0. ? (t.x < 4. ? 808333438u : (t.x < 8. ? 774909234u : (t.x < 12. ? 13360u : 0u))) : v;\n\t\tv = t.x >= 0. && t.x < 36. ? v : 0u;\n\t}\n\tif (s.menuId == MENU_ROUGHNESS)\n\t{\n\t\tv = t.y == 2. ? (t.x < 4. ? 1735749458u : (t.x < 8. ? 544367976u : (t.x < 12. ? 1718777203u : (t.x < 16. ? 1936024417u : (t.x < 20. ? 1830825248u : (t.x < 24. ? 543519343u : (t.x < 28. ? 1952539507u : (t.x < 32. ? 1701995892u : 100u)))))))) : v;\n\t\tv = t.y == 1. ? (t.x < 4. ? 1818649970u : (t.x < 8. ? 1702126437u : (t.x < 12. ? 1768693860u : (t.x < 16. ? 544499815u : (t.x < 20. ? 1937334642u : (t.x < 24. ? 1851858988u : (t.x < 28. ? 1752440932u : (t.x < 32. ? 2126709u : 0u)))))))) : v;\n\t\tv = t.y == 0. ? (t.x < 4. ? 1920298082u : (t.x < 8. ? 1919248754u : (t.x < 12. ? 1717924384u : (t.x < 16. ? 1952671084u : (t.x < 20. ? 1936617321u : 0u))))) : v;\n\t\tv = t.x >= 0. && t.x < 36. ? v : 0u;\n\t}\n\tif (s.menuId == MENU_BASE_COLOR)\n\t{\n\t\tv = t.y == 1. ? (t.x < 4. ? 544370502u : (t.x < 8. ? 1635018093u : (t.x < 12. ? 1679848300u : (t.x < 16. ? 1852401253u : (t.x < 20. ? 1931506533u : (t.x < 24. ? 1969448304u : (t.x < 28. ? 544366956u : (t.x < 32. ? 1869377379u : 114u)))))))) : v;\n\t\tv = t.y == 0. ? (t.x < 4. ? 544370502u : (t.x < 8. ? 1818585444u : (t.x < 12. ? 1920230245u : (t.x < 16. ? 544433001u : (t.x < 20. ? 1768169517u : (t.x < 24. ? 1937073766u : (t.x < 28. ? 1868767333u : (t.x < 32. ? 7499628u : 0u)))))))) : v;\n\t\tv = t.x >= 0. && t.x < 36. ? v : 0u;\n\t}\n\tif (s.menuId == MENU_LIGHTING)\n\t{\n\t\tv = t.y == 2. ? (t.x < 4. ? 1751607628u : (t.x < 8. ? 1735289204u : (t.x < 12. ? 544434464u : (t.x < 16. ? 1869770849u : (t.x < 20. ? 1634560376u : (t.x < 24. ? 543450484u : 2128226u)))))) : v;\n\t\tv = t.y == 1. ? (t.x < 4. ? 1634755955u : (t.x < 8. ? 1769234802u : (t.x < 12. ? 1679845230u : (t.x < 16. ? 1969645161u : (t.x < 20. ? 1629513075u : (t.x < 24. ? 2122862u : 0u)))))) : v;\n\t\tv = t.y == 0. ? (t.x < 4. ? 1667592307u : (t.x < 8. ? 1918987381u : (t.x < 12. ? 1836016416u : (t.x < 16. ? 1701736304u : (t.x < 20. ? 544437358u : 0u))))) : v;\n\t\tv = t.x >= 0. && t.x < 28. ? v : 0u;\n\t}\n\tif (s.menuId == MENU_DIFFUSE)\n\t{\n\t\tv = t.y == 2. ? (t.x < 4. ? 1818324307u : (t.x < 8. ? 1668489324u : (t.x < 12. ? 543517793u : (t.x < 16. ? 1935832435u : (t.x < 20. ? 1634103925u : (t.x < 24. ? 1931502947u : (t.x < 28. ? 1953784163u : (t.x < 32. ? 1852404325u : 8295u)))))))) : v;\n\t\tv = t.y == 1. ? (t.x < 4. ? 1635087189u : (t.x < 8. ? 981036140u : (t.x < 12. ? 1835093024u : (t.x < 16. ? 1953654114u : (t.x < 20. ? 1146241568u : (t.x < 24. ? 1713388102u : (t.x < 28. ? 824196384u : (t.x < 32. ? 543780911u : 0u)))))))) : v;\n\t\tv = t.y == 0. ? (t.x < 4. ? 1702257960u : (t.x < 8. ? 1914730866u : (t.x < 12. ? 1696627041u : (t.x < 16. ? 1937009016u : (t.x < 20. ? 544106784u : (t.x < 24. ? 1634869345u : (t.x < 28. ? 1679844462u : (t.x < 32. ? 2716265u : 0u)))))))) : v;\n\t\tv = t.x >= 0. && t.x < 36. ? v : 0u;\n\t}\n\tif (s.menuId == MENU_SPECULAR)\n\t{\n\t\tv = t.y == 8. ? (t.x < 4. ? 1818649938u : (t.x < 8. ? 1702126437u : (t.x < 12. ? 1768693860u : (t.x < 16. ? 779380839u : (t.x < 20. ? 1970492704u : (t.x < 24. ? 2037148769u : 8250u)))))) : v;\n\t\tv = t.y == 7. ? (t.x < 4. ? 1802465091u : (t.x < 8. ? 1919898669u : (t.x < 12. ? 1668178290u : (t.x < 16. ? 1998597221u : (t.x < 20. ? 1751345512u : (t.x < 24. ? 1685024032u : 7564389u)))))) : v;\n\t\tv = t.y == 6. ? (t.x < 4. ? 1919117677u : (t.x < 8. ? 1667327599u : (t.x < 12. ? 544437349u : (t.x < 16. ? 1919250472u : (t.x < 20. ? 1952671078u : (t.x < 24. ? 1919511840u : 544370546u)))))) : v;\n\t\tv = t.y == 5. ? (t.x < 4. ? 1734960488u : (t.x < 8. ? 1634563176u : (t.x < 12. ? 3811696u : 0u))) : v;\n\t\tv = t.y == 4. ? (t.x < 4. ? 745285734u : (t.x < 8. ? 1178413430u : (t.x < 12. ? 1747744296u : (t.x < 16. ? 1814578985u : (t.x < 20. ? 1747744300u : (t.x < 24. ? 1747469353u : 41u)))))) : v;\n\t\tv = t.y == 3. ? (t.x < 4. ? 538976288u : (t.x < 8. ? 538976288u : (t.x < 12. ? 1848128544u : (t.x < 16. ? 673803447u : (t.x < 20. ? 695646062u : 0u))))) : v;\n\t\tv = t.y == 2. ? (t.x < 4. ? 539828294u : (t.x < 8. ? 1936028230u : (t.x < 12. ? 7103854u : 0u))) : v;\n\t\tv = t.y == 1. ? (t.x < 4. ? 539828295u : (t.x < 8. ? 1836016967u : (t.x < 12. ? 2037544037u : 0u))) : v;\n\t\tv = t.y == 0. ? (t.x < 4. ? 539828292u : (t.x < 8. ? 1953720644u : (t.x < 12. ? 1969383794u : (t.x < 16. ? 1852795252u : 0u)))) : v;\n\t\tv = t.x >= 0. && t.x < 28. ? v : 0u;\n\t}\n\tif (s.menuId == MENU_DISTR)\n\t{\n\t\tv = t.y == 1. ? (t.x < 4. ? 1702109252u : (t.x < 8. ? 1679846770u : (t.x < 12. ? 1852401253u : (t.x < 16. ? 622883685u : (t.x < 20. ? 543584032u : (t.x < 24. ? 1919117677u : (t.x < 28. ? 1667327599u : 544437349u))))))) : v;\n\t\tv = t.y == 0. ? (t.x < 4. ? 1818649970u : (t.x < 8. ? 1769235301u : (t.x < 12. ? 1814062958u : (t.x < 16. ? 1952999273u : (t.x < 20. ? 1919903264u : (t.x < 24. ? 1730175264u : (t.x < 28. ? 1852143209u : 1919509536u))))))) : v;\n\t\tv = t.x >= 0. && t.x < 32. ? v : 0u;\n\t}\n\tif (s.menuId == MENU_FRESNEL)\n\t{\n\t\tv = t.y == 3. ? (t.x < 4. ? 1702109254u : (t.x < 8. ? 1679846770u : (t.x < 12. ? 1852401253u : (t.x < 16. ? 1629516645u : (t.x < 20. ? 1853189997u : (t.x < 24. ? 1718558836u : 32u)))))) : v;\n\t\tv = t.y == 2. ? (t.x < 4. ? 1818649970u : (t.x < 8. ? 1702126437u : (t.x < 12. ? 1768693860u : (t.x < 16. ? 544499815u : (t.x < 20. ? 544370534u : (t.x < 24. ? 1768366177u : 544105846u)))))) : v;\n\t\tv = t.y == 1. ? (t.x < 4. ? 1935832435u : (t.x < 8. ? 1851880052u : (t.x < 12. ? 539911523u : (t.x < 16. ? 1629516873u : (t.x < 20. ? 1869770864u : (t.x < 24. ? 1701340001u : 3219571u)))))) : v;\n\t\tv = t.y == 0. ? (t.x < 4. ? 544370534u : (t.x < 8. ? 2053206631u : (t.x < 12. ? 543649385u : (t.x < 16. ? 1818717793u : (t.x < 20. ? 29541u : 0u))))) : v;\n\t\tv = t.x >= 0. && t.x < 28. ? v : 0u;\n\t}\n\tif (s.menuId == MENU_GEOMETRY)\n\t{\n\t\tv = t.y == 2. ? (t.x < 4. ? 1702109255u : (t.x < 8. ? 1679846770u : (t.x < 12. ? 1852401253u : (t.x < 16. ? 1931506533u : (t.x < 20. ? 1868849512u : (t.x < 24. ? 1735289207u : (t.x < 28. ? 543584032u : 0u))))))) : v;\n\t\tv = t.y == 1. ? (t.x < 4. ? 1919117677u : (t.x < 8. ? 1667327599u : (t.x < 12. ? 544437349u : (t.x < 16. ? 1701864804u : (t.x < 20. ? 1852400750u : (t.x < 24. ? 1852776551u : (t.x < 28. ? 1701344288u : 2126441u))))))) : v;\n\t\tv = t.y == 0. ? (t.x < 4. ? 1634890337u : (t.x < 8. ? 1835362158u : (t.x < 12. ? 7630437u : 0u))) : v;\n\t\tv = t.x >= 0. && t.x < 32. ? v : 0u;\n\t}\n\n\tfloat c = float((v >> uint(8. * t.x)) & 255u);\n\n\tvec3 textColor = vec3(.3);\n\n\tp = (p - t * scale) \/ scale;\n\tp.x = (p.x - .5) * .45 + .5;\n\tfloat sdf = TextSDF(p, c);\n\tif (c != 0.)\n\t{\n\t\tcolor = mix(textColor, color, smoothstep(-.05, +.05, sdf));\n\t}\n\n\tif (s.menuId == MENU_SPECULAR)\n\t{\n\t\tcolor = mix(color, textColor, smoothstep(.05, -.05, Capsule(q.yx - vec2(-12.3, 48.), .3, 26.)));\n\t}\n}\n\nvoid MenuText(inout vec3 color, vec2 p, in AppState s)\n{\n\tp -= vec2(-160, -1);\n\n\tvec2 scale = vec2(4., 8.);\n\tvec2 t = floor(p \/ scale);\n\n\tfloat tab = 1.;\n\tif (t.y >= 6. && t.y < 10.)\n\t{\n\t\tp.x -= tab * scale.x;\n\t\tt.x -= tab;\n\t}\n\tif (t.y >= 0. && t.y < 5.)\n\t{\n\t\tp.x -= tab * scale.x;\n\t\tt.x -= tab;\n\t}\n\tif (t.y >= 0. && t.y < 3.)\n\t{\n\t\tp.x -= tab * scale.x;\n\t\tt.x -= tab;\n\t}\n\n\tuint v = 0u;\n\tv = t.y == 10. ? (t.x < 4. ? 1718777171u : (t.x < 8. ? 6644577u : 0u)) : v;\n\tv = t.y == 9. ? (t.x < 4. ? 1635018061u : (t.x < 8. ? 108u : 0u)) : v;\n\tv = t.y == 8. ? (t.x < 4. ? 1818585412u : (t.x < 8. ? 1920230245u : 25449u)) : v;\n\tv = t.y == 7. ? (t.x < 4. ? 1735749458u : (t.x < 8. ? 1936027240u : 115u)) : v;\n\tv = t.y == 6. ? (t.x < 4. ? 1702060354u : (t.x < 8. ? 1819231008u : 29295u)) : v;\n\tv = t.y == 5. ? (t.x < 4. ? 1751607628u : (t.x < 8. ? 1735289204u : 0u)) : v;\n\tv = t.y == 4. ? (t.x < 4. ? 1717987652u : (t.x < 8. ? 6648693u : 0u)) : v;\n\tv = t.y == 3. ? (t.x < 4. ? 1667592275u : (t.x < 8. ? 1918987381u : 0u)) : v;\n\tv = t.y == 2. ? (t.x < 4. ? 1953720644u : (t.x < 8. ? 1969383794u : 1852795252u)) : v;\n\tv = t.y == 1. ? (t.x < 4. ? 1936028230u : (t.x < 8. ? 7103854u : 0u)) : v;\n\tv = t.y == 0. ? (t.x < 4. ? 1836016967u : (t.x < 8. ? 2037544037u : 0u)) : v;\n\tv = t.x >= 0. && t.x < 12. ? v : 0u;\n\n\tfloat c = float((v >> uint(8. * t.x)) & 255u);\n\n\tvec3 textColor = vec3(.3);\n\tif (t.y == 10. - s.menuId)\n\t{\n\t\ttextColor = vec3(0.74, 0.5, 0.12);\n\t}\n\n\tp = (p - t * scale) \/ scale;\n\tp.x = (p.x - .5) * .45 + .5;\n\tfloat sdf = TextSDF(p, c);\n\tif (c != 0.)\n\t{\n\t\tcolor = mix(textColor, color, smoothstep(-.05, +.05, sdf));\n\t}\n}\n\nvoid DrawMenuControls(inout vec3 color, vec2 p, in AppState s)\n{\n\tp -= vec2(-110, 74);\n\n\t\/\/ radial\n\tfloat c2 = Capsule(p - vec2(0., -3.5), 3., 4.);\n\tfloat c1 = Circle(p + vec2(0., 7. - 7. * s.metal), 2.5);\n\n\t\/\/ roughness slider\n\tp.y += 15.;\n\tc1 = min(c1, Capsule(p.yx - vec2(0., 20.), 1., 20.));\n\tc1 = min(c1, Circle(p - vec2(40. * s.roughness, 0.), 2.5));\n\n\tp.y += 8.;\n\tc1 = min(c1, Rectangle(p - vec2(19.5, 0.), vec2(21.4, 4.)));\n\tcolor = mix(color, vec3(0.9), Smooth(-c2 * 2.));\n\tcolor = mix(color, vec3(0.3), Smooth(-c1 * 2.));\n\n\tfor (int i = 0; i < 6; ++i)\n\t{\n\t\tvec2 o = vec2(i == int(s.baseColor) ? 2.5 : 3.5);\n\t\tcolor = mix(color, BASE_COLORS[i], Smooth(-2. * Rectangle(p - vec2(2. + float(i) * 7., 0.), o)));\n\t}\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n\tvec2 q = fragCoord.xy \/ iResolution.xy;\n\tvec2 p = -1. + 2. * q;\n\tp.x *= iResolution.x \/ iResolution.y;\n\tp *= 100.;\n\n\tAppState s;\n\tLoadState(s);\n\n\tvec3 color = vec3(1., .98, .94) * mix(1.0, 0.4, Smooth(abs(.5 - uv.y)));\n\tfloat vignette = q.x * q.y * (1.0 - q.x) * (1.0 - q.y);\n\tvignette = saturate(pow(32.0 * vignette, 0.05));\n\tcolor *= vignette;\n\n\tDrawScene(color, p, s);\n\tDiagram(color, p, s);\n\tInfoText(color, p, s);\n\tMenuText(color, p, s);\n\tDrawMenuControls(color, p, s);\n\n\tfragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"\/presets\/tex00.jpg","previewfilepath":"\/presets\/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ control loop\n\nconst float MENU_SURFACE = 0.;\nconst float MENU_METAL = 1.;\nconst float MENU_DIELECTRIC = 2.;\nconst float MENU_ROUGHNESS = 3.;\nconst float MENU_BASE_COLOR = 4.;\nconst float MENU_LIGHTING = 5.;\nconst float MENU_DIFFUSE = 6.;\nconst float MENU_SPECULAR = 7.;\nconst float MENU_DISTR = 8.;\nconst float MENU_FRESNEL = 9.;\nconst float MENU_GEOMETRY = 10.;\n\nconst float FOCUS_SLIDER = 1.;\nconst float FOCUS_OBJ = 2.;\nconst float FOCUS_COLOR = 3.;\n\nstruct AppState\n{\n    float menuId;\n    float metal;\n    float roughness;\n    float baseColor;\n    float focus;\n    float focusObjRot;\n    float objRot;\n};\n\nvec4 LoadValue(int x, int y)\n{\n    return texelFetch(iChannel0, ivec2(x, y), 0);\n}\n\nvoid LoadState(out AppState s)\n{\n    vec4 data;\n\n    data = LoadValue(0, 0);\n    s.menuId = data.x;\n    s.metal = data.y;\n    s.roughness = data.z;\n    s.baseColor = data.w;\n\n    data = LoadValue(1, 0);\n    s.focus = data.x;\n    s.focusObjRot = data.y;\n    s.objRot = data.z;\n}\n\nvoid StoreValue(vec2 re, vec4 va, inout vec4 fragColor, vec2 fragCoord)\n{\n    fragCoord = floor(fragCoord);\n    fragColor = (fragCoord.x == re.x && fragCoord.y == re.y) ? va : fragColor;\n}\n\nvec4 SaveState(in AppState s, in vec2 fragCoord)\n{\n    vec4 ret = vec4(0.);\n    StoreValue(vec2(0., 0.), vec4(s.menuId, s.metal, s.roughness, s.baseColor), ret, fragCoord);\n    StoreValue(vec2(1., 0.), vec4(s.focus, s.focusObjRot, s.objRot, 0.), ret, fragCoord);\n    ret = iFrame >= 1 ? ret : vec4(0.);\n    return ret;\n}\n\nfloat saturate(float x)\n{\n    return clamp(x, 0., 1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (fragCoord.x >= 8. || fragCoord.y >= 8.)\n    {\n        discard;\n    }\n\n    AppState s;\n    LoadState(s);\n\n    vec4 q = iMouse \/ iResolution.xyxy;\n    vec4 m = -1. + 2. * q;\n    m.xz *= iResolution.x \/ iResolution.y;\n    m *= 100.;\n\n    vec4 sliderM = m - vec2(-110, 74).xyxy;\n    if (sliderM.z >= -4. && sliderM.z < 44. && sliderM.w >= -20. && sliderM.w < -10.)\n    {\n        s.focus = FOCUS_SLIDER;\n    }\n    else if (sliderM.z >= -4. && sliderM.z < 44. && sliderM.w >= -30. && sliderM.w < -20.)\n    {\n        s.focus = FOCUS_COLOR;\n    }\n    else if (sliderM.z >= -4. && sliderM.z < 6. && sliderM.w >= -10. && sliderM.w < -4.)\n    {\n        s.metal = 0.;\n        s.menuId = s.menuId == MENU_METAL ? MENU_DIELECTRIC : s.menuId;\n    }\n    else if (sliderM.z >= -4. && sliderM.z < 6. && sliderM.w >= -4. && sliderM.w < 6.)\n    {\n        s.metal = 1.;\n        s.menuId = s.menuId == MENU_DIELECTRIC ? MENU_METAL : s.menuId;\n    }\n    else if (m.w > -100. && m.w < 40. && abs(m.z + 20.) < 70.)\n    {\n        if (s.focus != FOCUS_OBJ)\n        {\n            s.focusObjRot = s.objRot;\n        }\n        s.focus = FOCUS_OBJ;\n    }\n    else\n    {\n        s.focus = 0.;\n        vec2 mp = (m.xy - vec2(-160, -1));\n        float menuId = mp.x < 40. || (mp.x < 60. && (mp.y > 18. && mp.y < 24.)) ? 10. - floor(mp.y \/ 8.) : -1.;\n        if (menuId >= 0. && menuId <= 10.)\n        {\n            s.menuId = menuId;\n        }\n        s.metal = menuId == MENU_METAL ? 1. : s.metal;\n        s.metal = menuId == MENU_DIELECTRIC ? 0. : s.metal;\n    }\n\n    if (s.focus == FOCUS_SLIDER)\n    {\n        s.roughness = saturate(sliderM.x \/ 40.);\n    }\n    if (s.focus == FOCUS_COLOR)\n    {\n        s.baseColor = floor(clamp((sliderM.x * 5.) \/ 32., 0., 5.));\n    }\n    if (s.focus == FOCUS_OBJ)\n    {\n        s.objRot = s.focusObjRot + .04 * (m.x - m.z);\n    }\n\n    fragColor = SaveState(s, fragCoord);\n}","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"Xs2fWD","date":"1500929190","viewed":20326,"name":"[SH17B] Pixel Shader Dungeon","username":"knarkowicz","description":"Greetings adventurer!\nControls: arrow keys\nTIPs:\n-Attack by walking into enemies\n-Walk into a wall to skip a turn\n-Time movement to attack first\n-Lure enemies into traps\nBased on \"Pixel Dungeon\" (http:\/\/pixeldungeon.watabou.ru\/)","likes":190,"published":3,"flags":112,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"\/media\/a\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"\/media\/ap\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"\/media\/previz\/buffer03.png","previewfilepath":"\/media\/previz\/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Based on \"Pixel Dungeon\" (http:\/\/pixeldungeon.watabou.ru\/)\n\nconst float TICK_NUM\t\t\t= 10.;\nconst float TILE_FLOOR\t\t\t= 1.;\nconst float TILE_DOOR_OPEN\t\t= 2.;\nconst float TILE_STAIRS_DOWN\t= 3.;\nconst float TILE_TRAP\t\t\t= 4.;\nconst float TILE_TRAP_OFF\t\t= 5.;\nconst float TILE_WALL\t\t\t= 6.;\nconst float TILE_WALL_HOLE\t\t= 7.;\nconst float TILE_DOOR_LOCKED\t= 8.;\nconst float TILE_STAIRS_UP\t\t= 9.;\nconst float ITEM_KEY\t\t\t= 1.;\nconst float ITEM_POTION\t\t\t= 2.;\nconst float ITEM_SPAWNER\t\t= 3.;\nconst float LOG_ID_DMG\t\t\t= 1.;\nconst float LOG_ID_XP\t\t\t= 2.;\nconst float LOG_ID_LEVEL_UP\t\t= 3.;\nconst float STATE_START\t\t\t= 0.;\nconst float STATE_GAME\t\t\t= 1.;\nconst float STATE_NEXT_LEVEL\t= 2.;\nconst float STATE_GAME_OVER\t\t= 3.;\n\nconst vec2  REF_RES\t            = vec2( 200. );\n\nconst int   ENEMY_NUM\t\t\t= 3;\nconst int   LOG_NUM\t\t\t\t= 4;\n\nstruct GameState\n{\n    \/\/ 0   \n    float\ttick;\n    float \thp;\n    float \tlevel;\n    float \txp;\n    float \tkeyNum;\n    \n\t\/\/ 1\n    vec2 \tplayerPos;\n    float   playerFrame;\n    float   playerDir;\n    vec2\tbodyPos;\n    float   bodyId;\n    \n    \/\/ 2\n    float \tstate;\n    float   keyLock;\n    float \tstateTime;\n    vec2\tdespawnPos;\n    float   despawnId;\n\n    \/\/ 3\n    vec2\tenemyPos[ ENEMY_NUM ];\n    float \tenemyFrame[ ENEMY_NUM ];\n    float \tenemyDir[ ENEMY_NUM ];\n    float \tenemyHP[ ENEMY_NUM ];\n    float \tenemyId[ ENEMY_NUM ];\n    vec2    enemySpawnPos[ ENEMY_NUM ];\n    \n    \/\/ 4\n    vec2\tlogPos[ LOG_NUM ];\n    float   logLife[ LOG_NUM ];\n    float   logId[ LOG_NUM ];\n    float   logVal[ LOG_NUM ];\n};\n\nvec4 LoadValue( int x, int y )\n{\n    return texelFetch( iChannel0, ivec2( x, y ), 0 );\n}    \n\nfloat PackXY( float a, float b )\n{\n    return floor( a ) + floor( b ) \/ 256.;\n}\n\nfloat PackXY( vec2 v )\n{\n    return PackXY( v.x, v.y );\n}\n\nfloat UnpackX( float a )\n{\n    return floor( a );\n}\n\nfloat UnpackY( float a )\n{\n    return fract( a ) * 256.;\n}\n\nvec2 UnpackXY( float a )\n{\n    return vec2( UnpackX( a ), UnpackY( a ) );\n}\n\nvoid LoadState( out GameState s )\n{\n    vec4 data;\n\n    data = LoadValue( 0, 0 );\n    s.tick \t\t= data.x;\n    s.hp    \t= UnpackX( data.y );\n    s.level    \t= UnpackY( data.y );\n    s.xp        = data.z;\n    s.keyNum    = data.w;\n    \n    data = LoadValue( 1, 0 );\n    s.playerPos   = UnpackXY( data.x );\n    s.playerFrame = UnpackX( data.y );\n    s.playerDir   = UnpackY( data.y );\n    s.bodyPos\t  = UnpackXY( data.z );\n    s.bodyId      = data.w;\n    \n    data = LoadValue( 2, 0 );\n    s.state      = UnpackX( data.x );\n    s.keyLock    = UnpackY( data.x );\n    s.stateTime  = data.y;\n    s.despawnPos = UnpackXY( data.z );\n    s.despawnId  = data.w;\n\n    for ( int i = 0; i < ENEMY_NUM; ++i )\n    {\n        data = LoadValue( 3, i );\n        s.enemyPos[ i ]      = UnpackXY( data.x );\n        s.enemyFrame[ i ]    = UnpackX( data.y );\n        s.enemyDir[ i ]      = UnpackY( data.y );\n        s.enemyHP[ i ]       = UnpackX( data.z );\n        s.enemyId[ i ]       = UnpackY( data.z );\n        s.enemySpawnPos[ i ] = UnpackXY( data.w );\n    }\n    \n    for ( int i = 0; i < LOG_NUM; ++i )\n    {\n\t\tdata = LoadValue( 4, i );\n    \ts.logPos[ i ]  = data.xy;\n        s.logLife[ i ] = data.z;\n        s.logId[ i ]   = UnpackX( data.w );\n        s.logVal[ i ]  = UnpackY( data.w );\n    }    \n}\n\nfloat saturate( float x )\n{\n    return clamp( x, 0., 1. );\n}\n\nfloat Smooth( float x )\n{\n\treturn smoothstep( 0., 1., saturate( x ) );   \n}\n\nvoid SpriteKey( inout vec3 color, vec2 p )\n{\n    p -= vec2( 5., 2. );\n    p = p.x < 0. ? vec2( 0. ) : p;    \n    \n    int v = 0;\n\tv = p.y == 11. ? ( p.x < 8. ? 139824 : 0 ) : v;\n\tv = p.y == 10. ? ( p.x < 8. ? 2232611 : 0 ) : v;\n\tv = p.y == 9. ? ( p.x < 8. ? 1179666 : 0 ) : v;\n\tv = p.y == 8. ? ( p.x < 8. ? 1245202 : 0 ) : v;\n\tv = p.y == 7. ? ( p.x < 8. ? 1192482 : 0 ) : v;\n\tv = p.y == 6. ? ( p.x < 8. ? 74256 : 0 ) : v;\n\tv = p.y == 5. ? ( p.x < 8. ? 4608 : 0 ) : v;\n\tv = p.y == 4. ? ( p.x < 8. ? 4608 : 0 ) : v;\n\tv = p.y == 3. ? ( p.x < 8. ? 4608 : 0 ) : v;\n\tv = p.y == 2. ? ( p.x < 8. ? 2232832 : 0 ) : v;\n\tv = p.y == 1. ? ( p.x < 8. ? 135680 : 0 ) : v;\n\tv = p.y == 0. ? ( p.x < 8. ? 2232832 : 0 ) : v;\n    float i = float( ( v >> int( 4. * p.x ) ) & 15 );\n    color = i == 1. ? vec3( 0.45 ) : color;\n    color = i == 2. ? vec3( 0.83 ) : color;\n    color = i == 3. ? vec3( 0.95 ) : color;\n}\n\nvec2 FrameOffset( float frame, float tick )\n{\n    vec2 ret = vec2( 0. );\n    ret.x = frame == 1. ? 1. : ( frame == 2. ? -1. : 0. );\n    ret.y = frame == 3. ? 1. : ( frame == 4. ? -1. : 0. );\n    return floor( 16. * ret * ( tick \/ TICK_NUM ) );\n}\n\nfloat EnemyHP( float id )\n{\n    return 8. + id * 15.;\n}\n\nfloat MaxXP( float level )\n{\n\treturn 10. + level * 5.;\t   \n}\n\nfloat MaxHP( float level )\n{\n\treturn 21. + level * 3.;\t   \n}\n\nfloat TextSDF( vec2 p, float glyph )\n{\n    p = abs( p.x - .5 ) > .5 || abs( p.y - .5 ) > .5 ? vec2( 0. ) : p;\n    return texture( iChannel3, p \/ 16. + fract( vec2( glyph, 15. - floor( glyph \/ 16. ) ) \/ 16. ) ).w - 127. \/ 255.;\n}\n\nvoid PrintChar( inout float sdf, inout vec2 p, float c )\n{\n    p.x -= 4.;\n    sdf = min( sdf, TextSDF( p * .1, c ) );\n}\n\nvoid PrintVal( inout float sdf, inout vec2 p, float val )\n{\n    if ( val > 9. )\n    {\n        p.x -= 4.;\n        float d = floor( val * 0.1 );\n        sdf = min( sdf, TextSDF( p * .1, 48. + d ) );\n        val -= d * 10.;\n    }\n    \n    p.x -= 4.;\n\tsdf = min( sdf, TextSDF( p * .1, 48. + val ) );\n}\n\nvoid RastText( inout vec3 color, float t, float l, vec3 textColor )\n{\n    float alpha = Smooth( 1. - ( 2. * l - 1. ) );\n    color = mix( color, vec3( 0. ), saturate( exp( -t * 20. ) ) * alpha );\n    color = mix( color, textColor, Smooth( -t * 100. ) * alpha );    \n}\n\nvoid DrawText( inout vec3 color, vec2 edge, vec2 center, vec2 world, in GameState s )\n{\n    \/\/ xp\n    if ( s.logPos[ 0 ].x > 0. )\n    {\n        float t = 1e4;\n        \n        vec2 p = world;\n        p -= s.logPos[ 0 ] * 16.;\n        p.x += 8.;\n        p.y -= s.logLife[ 0 ] * 16.;\n        PrintChar( t, p, 43. );\n        PrintVal( t, p, s.logVal[ 0 ] );\n        PrintChar( t, p, 69. );\n        PrintChar( t, p, 88. );\n        PrintChar( t, p, 80. );\n        \n\t\tif ( s.logId[ 0 ] > 0. )\n        {\n            p = world;\n            p -= s.logPos[ 0 ] * 16.;\n            p.x += 16.;\n            p.y -= s.logLife[ 0 ] * 16. - 8.;\n           \tPrintChar( t, p, 76. );\n            PrintChar( t, p, 69. );\n            PrintChar( t, p, 86. );\n            PrintChar( t, p, 69. );\n            PrintChar( t, p, 76. );\n            PrintChar( t, p, 32. );\n            PrintChar( t, p, 85. );\n            PrintChar( t, p, 80. );\n            PrintChar( t, p, 33. );\n        }\n        \n        RastText( color, t, s.logLife[ 0 ], vec3( 1., 1., 0. ) );\n    }    \n    \n    \/\/ heal\n    if ( s.logPos[ 1 ].x > 0. )\n    {\n        float t = 1e4; \n        vec2 p = world;\n        p -= s.logPos[ 1 ] * 16.;\n        p.x += 8.;\n        p.y -= s.logLife[ 1 ] * 16.;      \n        PrintChar( t, p, 43. );\n        PrintVal( t, p, s.logVal[ 1 ] );\n        PrintChar( t, p, 72. );\n        PrintChar( t, p, 80. );\n        RastText( color, t, s.logLife[ 1 ], vec3( 0., 1., 0. ) ); \n    }\n    \n    \/\/ dmg\n    for ( int i = 2; i < LOG_NUM; ++i )\n    {\n\t\tfloat t = 1e4;        \n        \n        if ( s.logPos[ i ].x > 0. )\n        {\n            vec2 p = world;\n            p -= s.logPos[ i ] * 16.;\n            p.y -= s.logLife[ i ] * 16.;        \n            PrintVal( t, p, s.logVal[ i ] );\n        }\n        \n        RastText( color, t, s.logLife[ i ], vec3( 1., 0., 0. ) );     \n    }\n    \n    \/\/ game over\n    if ( s.state == STATE_GAME_OVER )\n    {      \n        float alpha = Smooth( ( s.stateTime - 0.33 ) * 4. );\n        \n        color = mix( color, color.yyy * .5, alpha );\n        \n        float t = 1e4; \n        \n        vec2 p = .25 * center;\n        p.x += 24.;\n        p.y += 6.;\n        PrintChar( t, p, 89. );\n        PrintChar( t, p, 79. );\n        PrintChar( t, p, 85. );\n        p.x -= 4.;\n        PrintChar( t, p, 68. );\n        PrintChar( t, p, 73. );\n        PrintChar( t, p, 69. );\n        PrintChar( t, p, 68. );\n        \n        RastText( color, t, 1. - alpha, vec3( 1., 0., 0. ) );     \n    }\n    \n    \/\/ level\n    vec2 p = edge + vec2( 2.2, 20.8 );\n    float t = 1e4;\n    PrintChar( t, p, 48. + s.level + 1. );\n    color = mix( color, vec3( 1. ), Smooth( -t * 100. ) ); \n}\n\nfloat Rectangle( vec2 p, vec2 b )\n{\n    vec2 d = abs( p ) - b;\n    return min( max( d.x, d.y ), 0. ) + length( max( d, 0. ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    GameState s;\n    LoadState( s );    \n    \n    vec2 playerPos = s.playerPos * 16. + FrameOffset( s.playerFrame, s.tick ); \n    \n    vec2 resMult\t= floor( iResolution.xy \/ REF_RES );\n    float resRcp    = 1. \/ max( min( resMult.x, resMult.y ), 1. );\n    vec2 screenSize = floor( iResolution.xy * resRcp );\n    vec2 pixel      = floor( fragCoord.xy * resRcp );\n\tvec2 camera     = clamp( playerPos - floor( screenSize \/ 2. ), vec2( -32. ), vec2( 32. * 16. + 32. ) - screenSize );\n    vec2 world      = pixel + camera;\n    vec2 tile\t\t= floor( world \/ 16. );\n    vec2 worldMod16 = floor( mod( world, 16. ) );\n    vec4 map\t\t= texelFetch( iChannel1, ivec2( tile ), 0 );\n    vec2 edgeFlt\t= fragCoord.xy * resRcp - vec2( 0., screenSize.y );\n    vec2 centerFlt\t= fragCoord.xy * resRcp - screenSize \/ 2.;\n    vec2 worldFlt\t= fragCoord.xy * resRcp - vec2( 0., 16. ) + camera;\n    float fog\t\t= texture( iChannel1, ( tile + worldMod16 \/ 16. ) \/ iChannelResolution[ 0 ].xy ).w;\n    float tick2     = s.tick > TICK_NUM \/ 2. ? 1. : 0.;\n    \n    vec3 color = texelFetch( iChannel2, ivec2( fragCoord ), 0 ).xyz;\n    \n    color *= fog;    \n    float light = length( playerPos + 8. - world );\n\tcolor *= vec3( Smooth( ( 4. * 16. - light ) * .05 ) * .8 + .2 );\n    \n    for ( int i = 0; i < ENEMY_NUM; ++i )\n    {\n        float maxHP = EnemyHP( s.enemyId[ i ] );\n\t\tvec2 enemy = world - s.enemyPos[ i ] * 16. + FrameOffset( s.enemyFrame[ i ], s.tick );        \n        if ( s.enemyPos[ i ].x > 0.\n             && s.enemyHP[ i ] < maxHP\n             && enemy.x >= 0. && enemy.x < 16. && enemy.y - 16. >= 0. && enemy.y - 16. < 2. )\n        {\n            color = enemy.x < 16. * s.enemyHP[ i ] \/ maxHP ? vec3( 0., 1., 0. ) : vec3( 1., 0., 0. );\n        }\n    }\n    \n\tif ( pixel.x >= screenSize.x - 8. - 16. * s.keyNum && pixel.x < screenSize.x - 8. )\n    {\n        SpriteKey( color, vec2( mod( pixel.x - 8., 16. ), pixel.y - screenSize.y + 24. ) );\n    }\n    \n    if ( pixel.y >= screenSize.y - 9. && pixel.x < 4. * MaxHP( s.level ) + 7. + pixel.y - screenSize.y )\n    {\n       \tcolor = vec3( .33, .35, .31 );\n    }\n    if ( pixel.y >= screenSize.y - 8. && pixel.x < 4. * MaxHP( s.level ) + 6. + pixel.y - screenSize.y )\n    {\n       \tcolor = vec3( .64, .65, .58 );\n    }\n    if ( pixel.y >= screenSize.y - 7. && pixel.x < 4. * MaxHP( s.level ) + 5. + pixel.y - screenSize.y )\n    {\n       \tcolor = vec3( .24, .25, .22 );\n    }    \n    if ( pixel.y >= screenSize.y - 3. )\n    {\n  \t\tcolor = vec3( .33, .35, .31 );\n    }\n    if ( pixel.y >= screenSize.y - 2. )\n    {\n  \t\tcolor = vec3( .48, .5, .45 );\n    }    \n    if ( pixel.y >= screenSize.y - 1. )\n    {\n        color = vec3( .24, .25, .22 );\n    }\n    \n    float rect = floor( Rectangle( pixel - vec2( 6., screenSize.y - 16. ), vec2( 5. ) ) );\n    color = rect == 0. ? vec3( .64, .65, .58 ) : color;\n    color = rect == 1. ? vec3( .33, .35, .31 ) : color;\n    color = rect <  0. ? vec3( .24, .25, .22 ) : color;\n    \n    float xpBar = s.xp \/ MaxXP( s.level );\n    if ( pixel.y >= screenSize.y - 1. && pixel.x < screenSize.x * xpBar )\n    {\n        color = mix( vec3( 1., .8, .4 ), vec3( 1. ), pixel.x \/ screenSize.x );\n    } \n    \n    if ( pixel.y >= screenSize.y - 7. && pixel.y < screenSize.y - 3. && pixel.x < 4. * s.hp + 5. + pixel.y - screenSize.y )\n    {\n       color = mix( vec3( .65, .22, .29 ), vec3( .9, .4, .36 ), ( pixel.y - screenSize.y + 5. ) \/ 3. );\n    }\n    \n    if ( pixel.x == 0. && pixel.y >= screenSize.y - 9. && pixel.y < screenSize.y - 2. )\n    {\n       \tcolor = vec3( .33, .35, .31 );\n    }\n    \n    DrawText( color, edgeFlt, centerFlt, worldFlt, s );\n    \n\tfragColor = vec4( color, 1. );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"\/presets\/tex00.jpg","previewfilepath":"\/presets\/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ gameplay loop\n\n\/\/#define EASY_MODE\n\/\/#define KEY_AUTOREPEAT\n\nconst float TICK_NUM\t\t\t= 10.;\nconst float TILE_FLOOR\t\t\t= 1.;\nconst float TILE_DOOR_OPEN\t\t= 2.;\nconst float TILE_STAIRS_DOWN\t= 3.;\nconst float TILE_TRAP\t\t\t= 4.;\nconst float TILE_TRAP_OFF\t\t= 5.;\nconst float TILE_WALL\t\t\t= 6.;\nconst float TILE_WALL_HOLE\t\t= 7.;\nconst float TILE_DOOR_LOCKED\t= 8.;\nconst float TILE_STAIRS_UP\t\t= 9.;\nconst float ITEM_KEY\t\t\t= 1.;\nconst float ITEM_FOOD\t\t\t= 2.;\nconst float ITEM_POTION\t\t\t= 3.;\nconst float ITEM_SPAWNER\t\t= 4.;\nconst float ITEM_SPAWNER_2\t\t= 5.;\nconst float STATE_START\t\t\t= 0.;\nconst float STATE_GAME\t\t\t= 1.;\nconst float STATE_NEXT_LEVEL\t= 2.;\nconst float STATE_GAME_OVER\t\t= 3.;\n\nconst float KEY_LEFT  \t\t\t= 37.5f \/ 256.0f;\nconst float KEY_UP    \t\t\t= 38.5f \/ 256.0f;\nconst float KEY_RIGHT \t\t\t= 39.5f \/ 256.0f;\nconst float KEY_DOWN  \t\t\t= 40.5f \/ 256.0f;\n\nconst int   ENEMY_NUM\t\t\t= 3;\nconst int   LOG_NUM\t\t\t\t= 4;\n\nstruct GameState\n{\n    \/\/ 0   \n    float\ttick;\n    float \thp;\n    float \tlevel;\n    float \txp;\n    float \tkeyNum;\n    \n\t\/\/ 1\n    vec2 \tplayerPos;\n    float   playerFrame;\n    float   playerDir;\n    vec2\tbodyPos;\n    float   bodyId;\n    \n    \/\/ 2\n    float \tstate;\n    float   keyLock;\n    float \tstateTime;\n    vec2\tdespawnPos;\n    float   despawnId;\n\n    \/\/ 3\n    vec2\tenemyPos[ ENEMY_NUM ];\n    float \tenemyFrame[ ENEMY_NUM ];\n    float \tenemyDir[ ENEMY_NUM ];\n    float \tenemyHP[ ENEMY_NUM ];\n    float \tenemyId[ ENEMY_NUM ];\n    vec2    enemySpawnPos[ ENEMY_NUM ];\n    \n    \/\/ 4\n    vec2\tlogPos[ LOG_NUM ];\n    float   logLife[ LOG_NUM ];\n    float   logId[ LOG_NUM ];\n    float   logVal[ LOG_NUM ];\n};\n\nvec4 LoadValue( int x, int y )\n{\n    return texelFetch( iChannel0, ivec2( x, y ), 0 );\n}    \n\nfloat PackXY( float a, float b )\n{\n    return floor( a ) + floor( b ) \/ 256.;\n}\n\nfloat PackXY( vec2 v )\n{\n    return PackXY( v.x, v.y );\n}\n\nfloat UnpackX( float a )\n{\n    return floor( a );\n}\n\nfloat UnpackY( float a )\n{\n    return fract( a ) * 256.;\n}\n\nvec2 UnpackXY( float a )\n{\n    return vec2( UnpackX( a ), UnpackY( a ) );\n}\n\nvoid LoadState( out GameState s )\n{\n    vec4 data;\n\n    data = LoadValue( 0, 0 );\n    s.tick \t\t= data.x;\n    s.hp    \t= UnpackX( data.y );\n    s.level    \t= UnpackY( data.y );\n    s.xp        = data.z;\n    s.keyNum    = data.w;\n    \n    data = LoadValue( 1, 0 );\n    s.playerPos   = UnpackXY( data.x );\n    s.playerFrame = UnpackX( data.y );\n    s.playerDir   = UnpackY( data.y );\n    s.bodyPos\t  = UnpackXY( data.z );\n    s.bodyId      = data.w;\n    \n    data = LoadValue( 2, 0 );\n    s.state      = UnpackX( data.x );\n    s.keyLock    = UnpackY( data.x );\n    s.stateTime  = data.y;\n    s.despawnPos = UnpackXY( data.z );\n    s.despawnId  = data.w;\n\n    for ( int i = 0; i < ENEMY_NUM; ++i )\n    {\n        data = LoadValue( 3, i );\n        s.enemyPos[ i ]      = UnpackXY( data.x );\n        s.enemyFrame[ i ]    = UnpackX( data.y );\n        s.enemyDir[ i ]      = UnpackY( data.y );\n        s.enemyHP[ i ]       = UnpackX( data.z );\n        s.enemyId[ i ]       = UnpackY( data.z );\n        s.enemySpawnPos[ i ] = UnpackXY( data.w );\n    }\n    \n    for ( int i = 0; i < LOG_NUM; ++i )\n    {\n\t\tdata = LoadValue( 4, i );\n    \ts.logPos[ i ]  = data.xy;\n        s.logLife[ i ] = data.z;\n        s.logId[ i ]   = UnpackX( data.w );\n        s.logVal[ i ]  = UnpackY( data.w );\n    }    \n}\n\nvoid StoreValue( vec2 re, vec4 va, inout vec4 fragColor, vec2 fragCoord )\n{\n    fragCoord = floor( fragCoord );\n    fragColor = ( fragCoord.x == re.x && fragCoord.y == re.y ) ? va : fragColor;\n}\n\nvec4 SaveState( in GameState s, in vec2 fragCoord, bool reset )\n{\n    vec4 ret = vec4( 0. );\n    StoreValue( vec2( 0., 0. ), vec4( s.tick, PackXY( s.hp, s.level ), s.xp, s.keyNum ), ret, fragCoord );\n    StoreValue( vec2( 1., 0. ), vec4( PackXY( s.playerPos ), PackXY( s.playerFrame, s.playerDir ), PackXY( s.bodyPos ), s.bodyId ), ret, fragCoord );\n    StoreValue( vec2( 2., 0. ), vec4( PackXY( s.state, s.keyLock ), s.stateTime, PackXY( s.despawnPos ), s.despawnId ), ret, fragCoord );\n\n    for ( int i = 0; i < ENEMY_NUM; ++i )\n    {\n        StoreValue( vec2( 3., float( i ) ), \n                   vec4( PackXY( s.enemyPos[ i ] ), \n                         PackXY( s.enemyFrame[ i ], s.enemyDir[ i ] ), \n                         PackXY( s.enemyHP[ i ], s.enemyId[ i ] ),\n                         PackXY( s.enemySpawnPos[ i ] ) ), ret, fragCoord );\n    }\n    \n    for ( int i = 0; i < LOG_NUM; ++i )\n    {\n        StoreValue( vec2( 4., float( i ) ), vec4( s.logPos[ i ], s.logLife[ i ], PackXY( s.logId[ i ], s.logVal[ i ] ) ), ret, fragCoord );\n    }\n\n\tif ( reset )    \n    {\n        ret = vec4( 0. );\n\t\tStoreValue( vec2( 0., 0. ), vec4( 0., 21., 0., 0. ), ret, fragCoord );        \n        StoreValue( vec2( 1., 0. ), vec4( PackXY( 3., 2. ), 0., 0., 0. ), ret, fragCoord );\n        StoreValue( vec2( 2., 0. ), vec4( s.state, 0., 0., 0. ), ret, fragCoord );\n    }\n    \n    return ret;\n}\n\nvoid LogDmg( inout GameState s, vec2 pos, float val )\n{\n    float maxLife = -1.;\n    if ( s.logPos[ 2 ].x > 0. && s.logPos[ 3 ].x > 0. )\n    {\n        maxLife = max( s.logLife[ 2 ], s.logLife[ 3 ] );\n    }\n    \n    for ( int i = 2; i < LOG_NUM; ++i )\n    {\n        if ( s.logPos[ i ].x <= 0. || maxLife == s.logLife[ i ] )\n        {\n            s.logPos[ i ]  = pos;\n            s.logLife[ i ] = 0.;\n            s.logId[ i ]   = 0.;\n            s.logVal[ i ]  = val;            \n            break;\n        }\n    }   \n}\n\nvoid LogXP( inout GameState s, vec2 pos, float val )\n{\n    s.logPos[ 0 ]  = pos;\n    s.logLife[ 0 ] = 0.;\n    s.logId[ 0 ]   = 0.;\n\ts.logVal[ 0 ]  = val;\n}\n\nvoid LogHeal( inout GameState s, vec2 pos, float val )\n{\n    s.logPos[ 1 ]  = pos;\n    s.logLife[ 1 ] = 0.;\n    s.logId[ 1 ]   = 0.;\n\ts.logVal[ 1 ]  = val;\n}\n\nvoid LogLevelUp( inout GameState s, vec2 pos )\n{\n    s.logPos[ 0 ]  = pos;\n    s.logLife[ 0 ] = 0.;\n    s.logId[ 0 ]   = 1.;\n}\n\nfloat Rand( vec2 n )\n{\n\treturn fract( sin( dot( n.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );\n}\n\nfloat MaxXP( float level )\n{\n\treturn 10. + level * 5.;\t   \n}\n\nfloat MaxHP( float level )\n{\n\treturn 21. + level * 3.;\t   \n}\n\nfloat EnemyDmg( float id )\n{    \n    float dmg = 1. + 2. * id + floor( ( 4. + 2. * id ) * Rand( vec2( iTime, iTime ) ) );\n#ifdef EASY_MODE\n    dmg = floor( dmg * .5 );\n#endif\n    return dmg;\n}\n\nfloat EnemyHP( float id )\n{\n    return 8. + id * 15.;\n}\n\nfloat EnemyXP( float id )\n{\n    return 3. + id * 5.;\n}\n\nfloat TrapDmg( bool player )\n{\n    float dmg = 10. + floor( 8. * Rand( vec2( iTime, iTime ) ) );\n#ifdef EASY_MODE\n    if ( player )\n    \tdmg = floor( dmg * .5 );\n#endif    \n    return dmg;\n}\n\nfloat PlayerDmg( inout GameState s )\n{\n    return s.level + 1. + floor( 4. * Rand( vec2( iTime + 11.1, iTime + 11.1 ) ) );\n}\n\nvoid UpdateEnemies( inout GameState s )\n{\n    for ( int i = 0; i < ENEMY_NUM; ++i )\n    {\n    \tif ( s.tick == 0. )\n    \t{\n            s.enemyFrame[ i ] = 0.;\n        }\n        \n       \tif ( s.enemyPos[ i ].x > 0. && s.enemyHP[ i ] <= 0. )\n        {\n            float xp = EnemyXP( s.enemyId[ i ] );\n            s.xp += xp;\n            s.bodyPos = s.enemyPos[ i ];\n            s.bodyId  = s.enemyId[ i ] + 1.;\n            s.enemyPos[ i ] = vec2( 0., 0. );\n            LogXP( s, s.playerPos, xp );\n        }        \n\n        vec4 map = texelFetch( iChannel1, ivec2( s.enemyPos[ i ] ), 0 );\n        if ( map.x == TILE_TRAP && s.tick == 1. )\n        {\n            float dmg = TrapDmg( false );\n            s.enemyHP[ i ] -= dmg;\n            LogDmg( s, s.enemyPos[ i ], dmg );\n        }        \n        \n        vec2 move = vec2( 0., 0. );\n    \tvec2 toPlayer = s.playerPos - s.enemyPos[ i ];\n        vec2 moveX = vec2( sign( toPlayer.x ), 0. );\n        vec2 moveY = vec2( 0., sign( toPlayer.y ) );\n        vec4 mapX  = texelFetch( iChannel1, ivec2( s.enemyPos[ i ] + moveX ), 0 );\n        vec4 mapY  = texelFetch( iChannel1, ivec2( s.enemyPos[ i ] + moveY ), 0 );\n        \n        if ( mapX.x >= TILE_WALL )\n        {\n            moveX = vec2( 0. );\n        }\n\n        if ( mapY.x >= TILE_WALL )\n        {\n            moveY = vec2( 0. );\n        }             \n        \n        for ( int j = 0; j < ENEMY_NUM; ++j )\n        {\n            if ( j != i && s.enemyPos[ j ] == s.enemyPos[ i ] + moveX )\n            {\n                moveX = vec2( 0. );\n            }\n            if ( j != i && s.enemyPos[ j ] == s.enemyPos[ i ] + moveY )\n            {\n                moveY = vec2( 0. );\n            }\n        }\n\n        move = moveX.x != 0. ? moveX : moveY;\n        if ( moveX.x != 0. && moveY.y != 0. )\n        {\n            move = abs( toPlayer.x ) > abs( toPlayer.y ) ? moveX : moveY;\n        }\n        \n        if ( s.tick == TICK_NUM )\n        {\n        \tif ( s.enemyPos[ i ] + move == s.playerPos )\n            {\n                float dmg = EnemyDmg( s.enemyId[ i ] );\n                s.hp -= dmg;\n                s.enemyFrame[ i ] = 5.;\n                LogDmg( s, s.playerPos, dmg );\n            }\n\t\t\telse\n            {\n\t\t\t\ts.enemyPos[ i ] += move;\n                s.enemyFrame[ i ] = move.x == 1. ? 1. : ( move.x == -1. ? 2. : ( move.y == 1. ? 3. : ( move.y == -1. ? 4. : 0. ) ) );\n                s.enemyDir[ i ] = move.x > 0. ? 0. : ( move.x < 0. ? 1. : s.enemyDir[ i ] );\n            }\n        }\n    }    \n}\n\nvoid CheckSpawnPos( inout vec2 spawnPos, inout float spawnId, vec2 tile )\n{\n\tvec4 map = texelFetch( iChannel1, ivec2( tile ), 0 );\n    if ( map.y == ITEM_SPAWNER || map.y == ITEM_SPAWNER_2 )\n    {\n        spawnPos = tile;\n        spawnId  = map.y == ITEM_SPAWNER ? 0. : 1.;\n    } \n}\n\nvoid SpawnEnemies( inout GameState s, vec2 playerMove )\n{    \n    \/\/ despawn out of range\n    s.despawnPos = vec2( 0. );\n    for ( int i = 0; i < ENEMY_NUM; ++i )\n    {\n        if ( s.tick == 1. && s.enemyPos[ i ].x > 0. && length( s.playerPos - s.enemyPos[ i ] ) > 5. )\n        {\n            s.despawnPos    = s.enemySpawnPos[ i ];\n            s.despawnId     = s.enemyId[ i ];\n            s.enemyPos[ i ] = vec2( 0. );\n            break;\n        }\n    }    \n    \n    vec2 spawnPos = vec2( 0., 0. );\n    float spawnId = 0.;\n    CheckSpawnPos( spawnPos, spawnId, s.playerPos + playerMove * 4. );\n    CheckSpawnPos( spawnPos, spawnId, s.playerPos + playerMove * 3. - playerMove.yx * 1. );\n    CheckSpawnPos( spawnPos, spawnId, s.playerPos + playerMove * 3. + playerMove.yx * 1. );\n    CheckSpawnPos( spawnPos, spawnId, s.playerPos + playerMove * 2. - playerMove.yx * 2. );\n    CheckSpawnPos( spawnPos, spawnId, s.playerPos + playerMove * 2. + playerMove.yx * 2. );\n    CheckSpawnPos( spawnPos, spawnId, s.playerPos + playerMove * 1. - playerMove.yx * 3. );\n    CheckSpawnPos( spawnPos, spawnId, s.playerPos + playerMove * 1. + playerMove.yx * 3. );\n    CheckSpawnPos( spawnPos, spawnId, s.playerPos + playerMove * 0. - playerMove.yx * 4. );\n    CheckSpawnPos( spawnPos, spawnId, s.playerPos + playerMove * 0. + playerMove.yx * 4. );    \n    \n    if ( spawnPos.x > 0. )\n    {\n        for ( int i = 0; i < ENEMY_NUM; ++i )\n        {        \n            if ( s.enemyPos[ i ].x <= 0. )\n            {\n                s.enemyId[ i ]       = spawnId;\n                s.enemyPos[ i ]      = spawnPos;\n                s.enemyHP[ i ]       = EnemyHP( spawnId );\n                s.enemySpawnPos[ i ] = spawnPos;\n                break;\n            }\n        }    \n    }\n}\n\nvoid UpdateLog( inout GameState s )\n{\n    for ( int i = 0; i < LOG_NUM; ++i )\n    {\n        s.logLife[ i ] += iTimeDelta;\n        if ( s.logLife[ i ] > 1. )\n        {\n            s.logPos[ i ] = vec2( 0. );\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ don't compute gameplay outside of the data area\n    if ( fragCoord.x >= 8. || fragCoord.y >= 8. ) \n    {\n\t\tdiscard;    \n    }\n\n    \/\/ keys\n    bool keyLeft  \t= texture( iChannel2, vec2( KEY_LEFT, .25 ) ).x > .5;\n    bool keyRight \t= texture( iChannel2, vec2( KEY_RIGHT, .25 ) ).x > .5;\n    bool keyUp  \t= texture( iChannel2, vec2( KEY_UP, .25 ) ).x > .5;\n    bool keyDown \t= texture( iChannel2, vec2( KEY_DOWN, .25 ) ).x > .5;    \n    \n    GameState s;\n    LoadState( s );\n    \n    s.tick = max( floor( s.tick - 1. ), 0. );    \n    \n    bool reset = false;\n    if ( iFrame < 1 || s.state == STATE_START )\n    {\n        reset   = true;\n        s.state = STATE_GAME;\n    }\n    else if ( s.state == STATE_GAME )\n    {\n        if ( s.hp <= 0. )\n        {\n            s.state \t= STATE_GAME_OVER;\n\t\t\ts.stateTime = 0.;\n        }\n    }\n    else if ( s.state == STATE_NEXT_LEVEL )\n    {\n        s.state = STATE_GAME;\n        s.playerPos = vec2( 3., 2. );\n    \tfor ( int i = 0; i < ENEMY_NUM; ++i )\n    \t{           \n            s.enemyPos[ i ] = vec2( 0. );\n    \t}\n    }\n    else if ( s.state == STATE_GAME_OVER )\n    {\n        s.stateTime += .33 * iTimeDelta;\n        if ( s.stateTime >= 1. )\n        {\n            s.state = STATE_START;\n        }\n    }\n\n    \n    \/\/ level up\n    if ( s.xp >= MaxXP( s.level ) )\n    {\n        s.xp -= MaxXP( s.level );\n        s.level = min( s.level + 1., 9. );\n        s.hp\t= MaxHP( s.level );\n        LogLevelUp( s, s.playerPos );\n    }\n    \n    \n#ifdef KEY_AUTOREPEAT    \n    s.keyLock = 0.;\n#else\n    s.keyLock = keyLeft || keyRight || keyDown || keyUp ? s.keyLock : 0.;    \n#endif\n\n    vec2 move = vec2( 0., 0. );\n    if ( s.state == STATE_GAME && s.tick == 0. && s.keyLock == 0. )\n    {\n        s.playerFrame = 0.;\n        if ( keyLeft )\n        {\n            move.x = -1.;\n            s.playerDir = 1.;\n        }   \n        else if ( keyRight )\n        {\n            move.x = 1.;\n            s.playerDir = 0.;\n        }   \n        else if ( keyDown )\n        {\n            move.y = -1.;\n        }\n        else if ( keyUp )\n        {\n            move.y = 1.;\n        }             \n    }\n  \n    vec4 map = texelFetch( iChannel1, ivec2( s.playerPos + move ), 0 );\n    if ( abs( move.x + move.y ) > 0. && map.x < TILE_WALL )\n    {\n        bool enemy = false;\n        for ( int i = 0; i < ENEMY_NUM; ++i )\n        {\n            if ( s.enemyPos[ i ] == s.playerPos + move )        \n            {\n                float dmg = PlayerDmg( s );\n                s.playerFrame = 6.;\n                s.enemyHP[ i ] -= dmg;\n                LogDmg( s, s.enemyPos[ i ], dmg );\n            }\n        }\n        \n        if ( s.playerFrame != 6. )\n        {\n    \t\ts.playerPos += move;\n            s.playerFrame = keyLeft ? 1. : ( keyRight ? 2. : ( keyDown ? 3. : 4. ) );\n        \n        \tif ( map.y == ITEM_KEY )\n        \t{\n            \ts.keyNum += 1.;\n        \t}        \n            \n        \tif ( map.y == ITEM_FOOD || map.y == ITEM_POTION )\n        \t{\n                float heal = map.y == ITEM_FOOD ? 5. : 50.;\n                heal = min( heal, MaxHP( s.level ) - s.hp );\n            \ts.hp += heal;\n                LogHeal( s, s.playerPos, heal );\n        \t}      \n            \n            if ( map.x == TILE_TRAP )\n            {\n                float dmg = TrapDmg( true );\n                s.hp -= dmg;\n                LogDmg( s, s.playerPos, dmg );\n            }  \n        }\n        \n        s.tick    = TICK_NUM;\n        s.keyLock = 1.;\n    }\n    else if ( map.x == TILE_DOOR_LOCKED && s.keyNum > 0. )\n    {\n        s.playerFrame = keyLeft ? 1. : ( keyRight ? 2. : ( keyDown ? 3. : 4. ) );\n        s.keyNum -= 1.;\n        s.playerPos += move;\n        s.tick    = TICK_NUM;\n        s.keyLock = 1.;\n    }\n    else if ( map.x >= TILE_WALL )\n    {\n     \t\/\/ wait\n        s.playerFrame = 5.;\n        s.tick        = TICK_NUM;\n        s.keyLock     = 1.;\n    }    \n\n    UpdateEnemies( s );\n    SpawnEnemies( s, move ); \n\tUpdateLog( s );\n    \n\t\/\/ next level\n    if ( map.x == TILE_STAIRS_DOWN )\n    {     \n        s.state = STATE_NEXT_LEVEL;\n    }\n    \n    fragColor = SaveState( s, fragCoord, reset );\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\/\/ map\n\nconst float TICK_NUM\t\t\t= 10.;\nconst float TILE_FLOOR\t\t\t= 1.;\nconst float TILE_DOOR_OPEN\t\t= 2.;\nconst float TILE_STAIRS_DOWN\t= 3.;\nconst float TILE_TRAP\t\t\t= 4.;\nconst float TILE_TRAP_OFF\t\t= 5.;\nconst float TILE_WALL\t\t\t= 6.;\nconst float TILE_WALL_HOLE\t\t= 7.;\nconst float TILE_DOOR_LOCKED\t= 8.;\nconst float TILE_STAIRS_UP\t\t= 9.;\nconst float ITEM_KEY\t\t\t= 1.;\nconst float ITEM_FOOD\t\t\t= 2.;\nconst float ITEM_POTION\t\t\t= 3.;\nconst float ITEM_SPAWNER\t\t= 4.;\nconst float ITEM_SPAWNER_2\t\t= 5.;\nconst float STATE_START\t\t\t= 0.;\nconst float STATE_GAME\t\t\t= 1.;\nconst float STATE_NEXT_LEVEL\t= 2.;\nconst float STATE_GAME_OVER\t\t= 3.;\n\nconst int   ENEMY_NUM\t\t\t= 3;\nconst int   LOG_NUM\t\t\t\t= 4;\n\nstruct GameState\n{\n    \/\/ 0   \n    float\ttick;\n    float \thp;\n    float \tlevel;\n    float \txp;\n    float \tkeyNum;\n    \n\t\/\/ 1\n    vec2 \tplayerPos;\n    float   playerFrame;\n    float   playerDir;\n    vec2\tbodyPos;\n    float   bodyId;\n    \n    \/\/ 2\n    float \tstate;\n    float   keyLock;\n    float \tstateTime;\n    vec2\tdespawnPos;\n    float   despawnId;\n\n    \/\/ 3\n    vec2\tenemyPos[ ENEMY_NUM ];\n    float \tenemyFrame[ ENEMY_NUM ];\n    float \tenemyDir[ ENEMY_NUM ];\n    float \tenemyHP[ ENEMY_NUM ];\n    float \tenemyId[ ENEMY_NUM ];\n    vec2    enemySpawnPos[ ENEMY_NUM ];\n    \n    \/\/ 4\n    vec2\tlogPos[ LOG_NUM ];\n    float   logLife[ LOG_NUM ];\n    float   logId[ LOG_NUM ];\n    float   logVal[ LOG_NUM ];\n};\n\nvec4 LoadValue( int x, int y )\n{\n    return texelFetch( iChannel0, ivec2( x, y ), 0 );\n}    \n\nfloat PackXY( float a, float b )\n{\n    return floor( a ) + floor( b ) \/ 256.;\n}\n\nfloat PackXY( vec2 v )\n{\n    return PackXY( v.x, v.y );\n}\n\nfloat UnpackX( float a )\n{\n    return floor( a );\n}\n\nfloat UnpackY( float a )\n{\n    return fract( a ) * 256.;\n}\n\nvec2 UnpackXY( float a )\n{\n    return vec2( UnpackX( a ), UnpackY( a ) );\n}\n\nvoid LoadState( out GameState s )\n{\n    vec4 data;\n\n    data = LoadValue( 0, 0 );\n    s.tick \t\t= data.x;\n    s.hp    \t= UnpackX( data.y );\n    s.level    \t= UnpackY( data.y );\n    s.xp        = data.z;\n    s.keyNum    = data.w;\n    \n    data = LoadValue( 1, 0 );\n    s.playerPos   = UnpackXY( data.x );\n    s.playerFrame = UnpackX( data.y );\n    s.playerDir   = UnpackY( data.y );\n    s.bodyPos\t  = UnpackXY( data.z );\n    s.bodyId      = data.w;\n    \n    data = LoadValue( 2, 0 );\n    s.state      = UnpackX( data.x );\n    s.keyLock    = UnpackY( data.x );\n    s.stateTime  = data.y;\n    s.despawnPos = UnpackXY( data.z );\n    s.despawnId  = data.w;\n\n    for ( int i = 0; i < ENEMY_NUM; ++i )\n    {\n        data = LoadValue( 3, i );\n        s.enemyPos[ i ]      = UnpackXY( data.x );\n        s.enemyFrame[ i ]    = UnpackX( data.y );\n        s.enemyDir[ i ]      = UnpackY( data.y );\n        s.enemyHP[ i ]       = UnpackX( data.z );\n        s.enemyId[ i ]       = UnpackY( data.z );\n        s.enemySpawnPos[ i ] = UnpackXY( data.w );\n    }\n    \n    for ( int i = 0; i < LOG_NUM; ++i )\n    {\n\t\tdata = LoadValue( 4, i );\n    \ts.logPos[ i ]  = data.xy;\n        s.logLife[ i ] = data.z;\n        s.logId[ i ]   = UnpackX( data.w );\n        s.logVal[ i ]  = UnpackY( data.w );\n    }    \n}\n\nvec4 Map( vec2 p )\n{\n    int v = 0;\n\tv = p.y == 31. ? ( p.x < 8. ? 842150450 : ( p.x < 16. ? 573710370 : ( p.x < 24. ? 8754 : 589443584 ) ) ) : v;\n\tv = p.y == 30. ? ( p.x < 8. ? 286331154 : ( p.x < 16. ? 286335521 : ( p.x < 24. ? 589308177 : 554766882 ) ) ) : v;\n\tv = p.y == 29. ? ( p.x < 8. ? 286331154 : ( p.x < 16. ? 572592401 : ( p.x < 24. ? 287318289 : 554766609 ) ) ) : v;\n\tv = p.y == 28. ? ( p.x < 8. ? 572662306 : ( p.x < 16. ? 539042338 : ( p.x < 24. ? 555753745 : 554766882 ) ) ) : v;\n\tv = p.y == 27. ? ( p.x < 8. ? 0 : ( p.x < 16. ? 590422016 : ( p.x < 24. ? 555754002 : 572662272 ) ) ) : v;\n\tv = p.y == 26. ? ( p.x < 8. ? 589505314 : ( p.x < 16. ? 554770432 : ( p.x < 24. ? 555745810 : 0 ) ) ) : v;\n\tv = p.y == 25. ? ( p.x < 8. ? 554766610 : ( p.x < 16. ? 554770432 : ( p.x < 24. ? 555889170 : 589443634 ) ) ) : v;\n\tv = p.y == 24. ? ( p.x < 8. ? 554766610 : ( p.x < 16. ? 286334976 : ( p.x < 24. ? 286331153 : 554766609 ) ) ) : v;\n\tv = p.y == 23. ? ( p.x < 8. ? 555884834 : ( p.x < 16. ? 554770995 : ( p.x < 24. ? 555885073 : 554836514 ) ) ) : v;\n\tv = p.y == 22. ? ( p.x < 8. ? 287318304 : ( p.x < 16. ? 554770705 : ( p.x < 24. ? 555889169 : 554827776 ) ) ) : v;\n\tv = p.y == 21. ? ( p.x < 8. ? 572530976 : ( p.x < 16. ? 286335266 : ( p.x < 24. ? 555946257 : 555885106 ) ) ) : v;\n\tv = p.y == 20. ? ( p.x < 8. ? 143666 : ( p.x < 16. ? 572727584 : ( p.x < 24. ? 286331425 : 554832145 ) ) ) : v;\n\tv = p.y == 19. ? ( p.x < 8. ? 135442 : ( p.x < 16. ? 539037984 : ( p.x < 24. ? 571613713 : 554766882 ) ) ) : v;\n\tv = p.y == 18. ? ( p.x < 8. ? 135442 : ( p.x < 16. ? 539042336 : ( p.x < 24. ? 34734609 : 554832384 ) ) ) : v;\n\tv = p.y == 17. ? ( p.x < 8. ? 570560786 : ( p.x < 16. ? 539042355 : ( p.x < 24. ? 856896017 : 572662274 ) ) ) : v;\n\tv = p.y == 16. ? ( p.x < 8. ? 305279266 : ( p.x < 16. ? 539042065 : ( p.x < 24. ? 286331409 : 2 ) ) ) : v;\n\tv = p.y == 15. ? ( p.x < 8. ? 286331168 : ( p.x < 16. ? 857809169 : ( p.x < 24. ? 286331427 : 143922 ) ) ) : v;\n\tv = p.y == 14. ? ( p.x < 8. ? 304226592 : ( p.x < 16. ? 286331153 : ( p.x < 24. ? 286331153 : 590483729 ) ) ) : v;\n\tv = p.y == 13. ? ( p.x < 8. ? 570433824 : ( p.x < 16. ? 572596770 : ( p.x < 24. ? 286331426 : 554832418 ) ) ) : v;\n\tv = p.y == 12. ? ( p.x < 8. ? 8480 : ( p.x < 16. ? 287383552 : ( p.x < 24. ? 286331394 : 554832386 ) ) ) : v;\n\tv = p.y == 11. ? ( p.x < 8. ? 840966450 : ( p.x < 16. ? 287383586 : ( p.x < 24. ? 571613698 : 554766850 ) ) ) : v;\n\tv = p.y == 10. ? ( p.x < 8. ? 287318290 : ( p.x < 16. ? 286335009 : ( p.x < 24. ? 34734082 : 572658176 ) ) ) : v;\n\tv = p.y == 9. ? ( p.x < 8. ? 287318290 : ( p.x < 16. ? 572596257 : ( p.x < 24. ? 34746882 : 135680 ) ) ) : v;\n\tv = p.y == 8. ? ( p.x < 8. ? 304095506 : ( p.x < 16. ? 2171682 : ( p.x < 24. ? 571544064 : 36835891 ) ) ) : v;\n\tv = p.y == 7. ? ( p.x < 8. ? 301998354 : ( p.x < 16. ? 2167057 : ( p.x < 24. ? 286331392 : 34672913 ) ) ) : v;\n\tv = p.y == 6. ? ( p.x < 8. ? 570434082 : ( p.x < 16. ? 2171426 : ( p.x < 24. ? 304226816 : 34742818 ) ) ) : v;\n\tv = p.y == 5. ? ( p.x < 8. ? 0 : ( p.x < 16. ? 2170880 : ( p.x < 24. ? 301989888 : 34738450 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 8. ? 36844082 : ( p.x < 16. ? 36778496 : ( p.x < 24. ? 302134048 : 34672914 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 8. ? 571543826 : ( p.x < 16. ? 571544099 : ( p.x < 24. ? 302125346 : 34738449 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 8. ? 286331154 : ( p.x < 16. ? 286331153 : ( p.x < 24. ? 302125329 : 34746930 ) ) ) : v;\n\tv = p.y == 1. ? ( p.x < 8. ? 571543826 : ( p.x < 16. ? 571544098 : ( p.x < 24. ? 302125346 : 34672913 ) ) ) : v;\n\tv = p.y == 0. ? ( p.x < 8. ? 35791394 : ( p.x < 16. ? 35791360 : ( p.x < 24. ? 570565152 : 35791394 ) ) ) : v;\n    float t = float( ( v >> int( 4. * p.x ) ) & 15 );\n    t = t == 2. ? 6. : t;\n    t = t == 3. ? 7. : t;\n    t = p.x == 15. && p.y == 30. ? 2. : t;\n    t = p.x == 9. && p.y == 29. ? 2. : t;\n    t = p.x == 11. && p.y == 29. ? 2. : t;\n    t = p.x == 12. && p.y == 27. ? 2. : t;\n    t = p.x == 17. && p.y == 27. ? 2. : t;\n    t = p.x == 17. && p.y == 25. ? 2. : t;\n    t = p.x == 15. && p.y == 24. ? 2. : t;\n    t = p.x == 18. && p.y == 24. ? 2. : t;\n    t = p.x == 21. && p.y == 24. ? 2. : t;\n    t = p.x == 23. && p.y == 24. ? 2. : t;\n    t = p.x == 28. && p.y == 24. ? 2. : t;\n    t = p.x == 2. && p.y == 23. ? 2. : t;\n    t = p.x == 6. && p.y == 23. ? 2. : t;\n    t = p.x == 15. && p.y == 21. ? 2. : t;\n    t = p.x == 18. && p.y == 21. ? 2. : t;\n    t = p.x == 30. && p.y == 21. ? 2. : t;\n    t = p.x == 16. && p.y == 20. ? 2. : t;\n    t = p.x == 23. && p.y == 20. ? 2. : t;\n    t = p.x == 11. && p.y == 19. ? 2. : t;\n    t = p.x == 21. && p.y == 19. ? 2. : t;\n    t = p.x == 28. && p.y == 19. ? 2. : t;\n    t = p.x == 2. && p.y == 16. ? 2. : t;\n    t = p.x == 6. && p.y == 15. ? 2. : t;\n    t = p.x == 12. && p.y == 15. ? 2. : t;\n    t = p.x == 11. && p.y == 14. ? 2. : t;\n    t = p.x == 24. && p.y == 14. ? 2. : t;\n    t = p.x == 2. && p.y == 11. ? 2. : t;\n    t = p.x == 21. && p.y == 11. ? 2. : t;\n    t = p.x == 28. && p.y == 11. ? 2. : t;\n    t = p.x == 13. && p.y == 10. ? 2. : t;\n    t = p.x == 21. && p.y == 9. ? 2. : t;\n    t = p.x == 7. && p.y == 8. ? 2. : t;\n    t = p.x == 27. && p.y == 8. ? 2. : t;\n    t = p.x == 22. && p.y == 7. ? 2. : t;\n    t = p.x == 28. && p.y == 4. ? 2. : t;\n    t = p.x == 24. && p.y == 3. ? 2. : t;\n    t = p.x == 10. && p.y == 2. ? 2. : t;\n    t = p.x == 14. && p.y == 2. ? 2. : t;\n    t = p.x == 17. && p.y == 2. ? 2. : t;\n    t = p.x == 26. && p.y == 29. ? 8. : t;\n    t = p.x == 22. && p.y == 25. ? 8. : t;\n    t = p.x == 21. && p.y == 17. ? 8. : t;\n    t = p.x == 13. && p.y == 14. ? 8. : t;\n    t = p.x == 18. && p.y == 14. ? 8. : t;\n    t = p.x == 12. && p.y == 4. ? 8. : t;\n    t = p.x == 6. && p.y == 2. ? 8. : t;\n    t = p.x == 17. && p.y == 29. ? 4. : t;\n    t = p.x == 4. && p.y == 24. ? 4. : t;\n    t = p.x == 16. && p.y == 23. ? 4. : t;\n    t = p.x == 29. && p.y == 23. ? 4. : t;\n    t = p.x == 2. && p.y == 18. ? 4. : t;\n    t = p.x == 17. && p.y == 17. ? 4. : t;\n    t = p.x == 8. && p.y == 15. ? 4. : t;\n    t = p.x == 9. && p.y == 15. ? 4. : t;\n    t = p.x == 21. && p.y == 15. ? 4. : t;\n    t = p.x == 20. && p.y == 14. ? 4. : t;\n    t = p.x == 22. && p.y == 14. ? 4. : t;\n    t = p.x == 21. && p.y == 13. ? 4. : t;\n    t = p.x == 29. && p.y == 12. ? 4. : t;\n    t = p.x == 14. && p.y == 11. ? 4. : t;\n    t = p.x == 26. && p.y == 4. ? 4. : t;\n    t = p.x == 12. && p.y == 2. ? 4. : t;\n    t = p.x == 2. && p.y == 2. ? 9. : t;\n    t = p.x == 29. && p.y == 29. ? 3. : t;\n    float i = 0.;\n    i = p.x == 1. && p.y == 30. ? 1. : i;\n    i = p.x == 1. && p.y == 24. ? 1. : i;\n    i = p.x == 17. && p.y == 16. ? 1. : i;\n    i = p.x == 1. && p.y == 7. ? 1. : i;\n    i = p.x == 25. && p.y == 5. ? 1. : i;\n    i = p.x == 1. && p.y == 3. ? 1. : i;\n    i = p.x == 19. && p.y == 3. ? 1. : i;\n    i = p.x == 8. && p.y == 30. ? 2. : i;\n    i = p.x == 18. && p.y == 30. ? 2. : i;\n    i = p.x == 27. && p.y == 28. ? 2. : i;\n    i = p.x == 13. && p.y == 26. ? 2. : i;\n    i = p.x == 14. && p.y == 26. ? 2. : i;\n    i = p.x == 6. && p.y == 25. ? 2. : i;\n    i = p.x == 13. && p.y == 25. ? 2. : i;\n    i = p.x == 14. && p.y == 25. ? 2. : i;\n    i = p.x == 10. && p.y == 22. ? 2. : i;\n    i = p.x == 19. && p.y == 21. ? 2. : i;\n    i = p.x == 3. && p.y == 19. ? 2. : i;\n    i = p.x == 17. && p.y == 19. ? 2. : i;\n    i = p.x == 30. && p.y == 18. ? 2. : i;\n    i = p.x == 10. && p.y == 16. ? 2. : i;\n    i = p.x == 23. && p.y == 16. ? 2. : i;\n    i = p.x == 27. && p.y == 14. ? 2. : i;\n    i = p.x == 14. && p.y == 12. ? 2. : i;\n    i = p.x == 19. && p.y == 12. ? 2. : i;\n    i = p.x == 23. && p.y == 12. ? 2. : i;\n    i = p.x == 1. && p.y == 10. ? 2. : i;\n    i = p.x == 11. && p.y == 3. ? 2. : i;\n    i = p.x == 13. && p.y == 3. ? 2. : i;\n    i = p.x == 27. && p.y == 3. ? 2. : i;\n    i = p.x == 23. && p.y == 1. ? 2. : i;\n    i = p.x == 1. && p.y == 29. ? 3. : i;\n    i = p.x == 8. && p.y == 10. ? 3. : i;\n    i = p.x == 19. && p.y == 7. ? 3. : i;\n    i = p.x == 3. && p.y == 30. ? 4. : i;\n    i = p.x == 12. && p.y == 30. ? 4. : i;\n    i = p.x == 2. && p.y == 25. ? 4. : i;\n    i = p.x == 20. && p.y == 24. ? 4. : i;\n    i = p.x == 22. && p.y == 24. ? 4. : i;\n    i = p.x == 6. && p.y == 22. ? 4. : i;\n    i = p.x == 12. && p.y == 21. ? 4. : i;\n    i = p.x == 19. && p.y == 20. ? 4. : i;\n    i = p.x == 27. && p.y == 20. ? 4. : i;\n    i = p.x == 12. && p.y == 19. ? 4. : i;\n    i = p.x == 1. && p.y == 17. ? 4. : i;\n    i = p.x == 19. && p.y == 16. ? 4. : i;\n    i = p.x == 17. && p.y == 14. ? 4. : i;\n    i = p.x == 15. && p.y == 10. ? 4. : i;\n    i = p.x == 12. && p.y == 9. ? 4. : i;\n    i = p.x == 7. && p.y == 7. ? 4. : i;\n    i = p.x == 20. && p.y == 7. ? 4. : i;\n    i = p.x == 9. && p.y == 2. ? 4. : i;\n    i = p.x == 19. && p.y == 2. ? 4. : i;\n    i = p.x == 10. && p.y == 29. ? 5. : i;\n    i = p.x == 22. && p.y == 29. ? 5. : i;\n    i = p.x == 25. && p.y == 29. ? 5. : i;\n    i = p.x == 13. && p.y == 24. ? 5. : i;\n    i = p.x == 30. && p.y == 24. ? 5. : i;\n    i = p.x == 16. && p.y == 16. ? 5. : i;\n    i = p.x == 30. && p.y == 11. ? 5. : i;\n    i = p.x == 6. && p.y == 10. ? 5. : i;\n    i = p.x == 1. && p.y == 8. ? 5. : i;\n    i = p.x == 21. && p.y == 7. ? 5. : i;\n    i = p.x == 26. && p.y == 5. ? 5. : i;\n    return p.x < 0. || p.y < 0. || p.x > 31. || p.y > 31. ? vec4( 0. ) : vec4( t, i, 0., 0. );\n}\n\nfloat Rand( vec2 n )\n{\n\treturn fract( sin( dot( n.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ don't compute map outside of map area\n    if ( fragCoord.x >= 40. || fragCoord.y >= 40. ) \n    {\n\t\tdiscard;    \n    }    \n    \n    vec2 tile = floor( fragCoord );\n    \n    vec4 map = texelFetch( iChannel1, ivec2( tile ), 0 );\n    \n    GameState s;\n    LoadState( s );    \n    \n    \/\/ create map\n\tif ( s.state == STATE_START || s.state == STATE_NEXT_LEVEL || iFrame < 1 )\n    {\n        map = Map( tile );\n    }   \n    \n    if ( tile == s.playerPos )\n    {\n     \tif ( s.tick == 1. && ( map.y == ITEM_KEY || map.y == ITEM_FOOD || map.y == ITEM_POTION ) )\n        {\n            \/\/ pickup item\n\t\t\tmap.y = 0.;\n        }\n     \tif ( map.x == TILE_DOOR_LOCKED && s.tick == TICK_NUM )\n        {\n\t\t\tmap.x = TILE_DOOR_OPEN;\n        }    \n     \tif ( map.x == TILE_TRAP && s.tick == 1. )\n        {\n\t\t\tmap.x = TILE_TRAP_OFF;\n        }           \n    }\n    \n    for ( int i = 0; i < ENEMY_NUM; ++i )\n    {\n        if ( tile == s.enemyPos[ i ] && map.x == TILE_TRAP && s.tick == 1. )\n        {\n            map.x = TILE_TRAP_OFF;\n        }\n    }\n    \n    if ( tile == s.bodyPos && map.x == TILE_TRAP )\n    {\n\t\tmap.x = TILE_TRAP_OFF;\n    }\n    \n    \/\/ fog of war\n    if ( s.state == STATE_GAME && length( s.playerPos - tile ) < 5. )\n    {    \n        map.w = 1.;\n    }\n    \n    if ( s.state == STATE_GAME && tile == s.bodyPos )\n    {\n        map.z = s.bodyId;\n    }\n\n    if ( tile == s.playerPos && s.hp <= 0. )\n    {\n        map.z = 2.;\n    }\n    \n    for ( int i = 0; i < ENEMY_NUM; ++i )\n    {\n        if ( s.state == STATE_GAME && s.enemyPos[ i ].x > 0. && tile == s.enemySpawnPos[ i ] )\n        {\n            map.y = 0.;\n        }\n    }\n    \n    if ( s.state == STATE_GAME && s.despawnPos.x > 0. && tile == s.despawnPos )\n    {\n        map.y = s.despawnId > 0. ? ITEM_SPAWNER_2 : ITEM_SPAWNER;\n    }\n\n \tfragColor = map;\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\/\/ background\n\nconst float TICK_NUM\t\t\t= 10.;\nconst float TILE_FLOOR\t\t\t= 1.;\nconst float TILE_DOOR_OPEN\t\t= 2.;\nconst float TILE_STAIRS_DOWN\t= 3.;\nconst float TILE_TRAP\t\t\t= 4.;\nconst float TILE_TRAP_OFF\t\t= 5.;\nconst float TILE_WALL\t\t\t= 6.;\nconst float TILE_WALL_HOLE\t\t= 7.;\nconst float TILE_DOOR_LOCKED\t= 8.;\nconst float TILE_STAIRS_UP\t\t= 9.;\nconst float ITEM_KEY\t\t\t= 1.;\nconst float ITEM_FOOD\t\t\t= 2.;\nconst float ITEM_POTION\t\t\t= 3.;\nconst float ITEM_SPAWNER\t\t= 3.;\nconst float STATE_START\t\t\t= 0.;\nconst float STATE_GAME\t\t\t= 1.;\nconst float STATE_NEXT_LEVEL\t= 2.;\nconst float STATE_GAME_OVER\t\t= 3.;\n\nconst vec2  REF_RES\t            = vec2( 200. );\n\nconst int   ENEMY_NUM\t\t\t= 3;\nconst int   LOG_NUM\t\t\t\t= 4;\n\nstruct GameState\n{\n    \/\/ 0   \n    float\ttick;\n    float \thp;\n    float \tlevel;\n    float \txp;\n    float \tkeyNum;\n    \n\t\/\/ 1\n    vec2 \tplayerPos;\n    float   playerFrame;\n    float   playerDir;\n    vec2\tbodyPos;\n    float   bodyId;\n    \n    \/\/ 2\n    float \tstate;\n    float   keyLock;\n    float \tstateTime;\n    vec2\tdespawnPos;\n    float   despawnId;\n\n    \/\/ 3\n    vec2\tenemyPos[ ENEMY_NUM ];\n    float \tenemyFrame[ ENEMY_NUM ];\n    float \tenemyDir[ ENEMY_NUM ];\n    float \tenemyHP[ ENEMY_NUM ];\n    float \tenemyId[ ENEMY_NUM ];\n    vec2    enemySpawnPos[ ENEMY_NUM ];\n    \n    \/\/ 4\n    vec2\tlogPos[ LOG_NUM ];\n    float   logLife[ LOG_NUM ];\n    float   logId[ LOG_NUM ];\n    float   logVal[ LOG_NUM ];\n};\n\nvec4 LoadValue( int x, int y )\n{\n    return texelFetch( iChannel0, ivec2( x, y ), 0 );\n}    \n\nfloat PackXY( float a, float b )\n{\n    return floor( a ) + floor( b ) \/ 256.;\n}\n\nfloat PackXY( vec2 v )\n{\n    return PackXY( v.x, v.y );\n}\n\nfloat UnpackX( float a )\n{\n    return floor( a );\n}\n\nfloat UnpackY( float a )\n{\n    return fract( a ) * 256.;\n}\n\nvec2 UnpackXY( float a )\n{\n    return vec2( UnpackX( a ), UnpackY( a ) );\n}\n\nvoid LoadState( out GameState s )\n{\n    vec4 data;\n\n    data = LoadValue( 0, 0 );\n    s.tick \t\t= data.x;\n    s.hp    \t= UnpackX( data.y );\n    s.level    \t= UnpackY( data.y );\n    s.xp        = data.z;\n    s.keyNum    = data.w;\n    \n    data = LoadValue( 1, 0 );\n    s.playerPos   = UnpackXY( data.x );\n    s.playerFrame = UnpackX( data.y );\n    s.playerDir   = UnpackY( data.y );\n    s.bodyPos\t  = UnpackXY( data.z );\n    s.bodyId      = data.w;\n    \n    data = LoadValue( 2, 0 );\n    s.state      = UnpackX( data.x );\n    s.keyLock    = UnpackY( data.x );\n    s.stateTime  = data.y;\n    s.despawnPos = UnpackXY( data.z );\n    s.despawnId  = data.w;\n\n    for ( int i = 0; i < ENEMY_NUM; ++i )\n    {\n        data = LoadValue( 3, i );\n        s.enemyPos[ i ]      = UnpackXY( data.x );\n        s.enemyFrame[ i ]    = UnpackX( data.y );\n        s.enemyDir[ i ]      = UnpackY( data.y );\n        s.enemyHP[ i ]       = UnpackX( data.z );\n        s.enemyId[ i ]       = UnpackY( data.z );\n        s.enemySpawnPos[ i ] = UnpackXY( data.w );\n    }\n    \n    for ( int i = 0; i < LOG_NUM; ++i )\n    {\n\t\tdata = LoadValue( 4, i );\n    \ts.logPos[ i ]  = data.xy;\n        s.logLife[ i ] = data.z;\n        s.logId[ i ]   = UnpackX( data.w );\n        s.logVal[ i ]  = UnpackY( data.w );\n    }    \n}\n\nfloat saturate( float x )\n{\n    return clamp( x, 0., 1. );\n}\n\nfloat Smooth( float x )\n{\n\treturn smoothstep( 0., 1., saturate( x ) );   \n}\n\nvoid SpriteEarth( inout vec3 color, vec2 p )\n{\n    int v = 0;\n\tv = p.y == 15. ? ( p.x < 8. ? 17961233 : ( p.x < 16. ? 536941073 : 0 ) ) : v;\n\tv = p.y == 14. ? ( p.x < 8. ? 18944274 : ( p.x < 16. ? 269549841 : 0 ) ) : v;\n\tv = p.y == 13. ? ( p.x < 8. ? 269553937 : ( p.x < 16. ? 554766353 : 0 ) ) : v;\n\tv = p.y == 12. ? ( p.x < 8. ? 1118481 : ( p.x < 16. ? 572662032 : 0 ) ) : v;\n\tv = p.y == 11. ? ( p.x < 8. ? 554766609 : ( p.x < 16. ? 555815424 : 0 ) ) : v;\n\tv = p.y == 10. ? ( p.x < 8. ? 572662049 : ( p.x < 16. ? 286261777 : 0 ) ) : v;\n\tv = p.y == 9. ? ( p.x < 8. ? 16781602 : ( p.x < 16. ? 268440097 : 0 ) ) : v;\n\tv = p.y == 8. ? ( p.x < 8. ? 4385 : ( p.x < 16. ? 536875298 : 0 ) ) : v;\n\tv = p.y == 7. ? ( p.x < 8. ? 303108641 : ( p.x < 16. ? 286265617 : 0 ) ) : v;\n\tv = p.y == 6. ? ( p.x < 8. ? 35790865 : ( p.x < 16. ? 304152593 : 0 ) ) : v;\n\tv = p.y == 5. ? ( p.x < 8. ? 16843025 : ( p.x < 16. ? 286327056 : 0 ) ) : v;\n\tv = p.y == 4. ? ( p.x < 8. ? 16781841 : ( p.x < 16. ? 286261521 : 0 ) ) : v;\n\tv = p.y == 3. ? ( p.x < 8. ? 285352193 : ( p.x < 16. ? 287310081 : 0 ) ) : v;\n\tv = p.y == 2. ? ( p.x < 8. ? 70162 : ( p.x < 16. ? 269484049 : 0 ) ) : v;\n\tv = p.y == 1. ? ( p.x < 8. ? 4625 : ( p.x < 16. ? 269488417 : 0 ) ) : v;\n\tv = p.y == 0. ? ( p.x < 8. ? 529 : ( p.x < 16. ? 268505361 : 0 ) ) : v;\n    float i = float( ( v >> int( 4. * p.x ) ) & 15 );\n    color = vec3( 0.16, 0.14, 0.14 );\n    color = i == 1. ? vec3( 0.17, 0.16, 0.15 ) : color;\n    color = i == 2. ? vec3( 0.19, 0.17, 0.16 ) : color;\n}\n\nvoid SpriteEarth2( inout vec3 color, vec2 p )\n{\n    int v = 0;\n\tv = p.y == 13. ? 0 : v;\n\tv = p.y == 12. ? ( p.x < 8. ? 0 : ( p.x < 16. ? 8960 : 0 ) ) : v;\n\tv = p.y == 11. ? ( p.x < 8. ? 0 : ( p.x < 16. ? 69920 : 0 ) ) : v;\n\tv = p.y == 10. ? ( p.x < 8. ? 16 : 0 ) : v;\n\tv = p.y == 9. ? 0 : v;\n\tv = p.y == 8. ? ( p.x < 8. ? 3342336 : 0 ) : v;\n\tv = p.y == 7. ? ( p.x < 8. ? 35794944 : ( p.x < 16. ? 65536 : 0 ) ) : v;\n\tv = p.y == 6. ? ( p.x < 8. ? 17899520 : 0 ) : v;\n\tv = p.y == 5. ? 0 : v;\n\tv = p.y == 4. ? 0 : v;\n\tv = p.y == 3. ? ( p.x < 8. ? 0 : ( p.x < 16. ? 1 : 0 ) ) : v;\n\tv = p.y == 2. ? 0 : v;\n\tv = p.y == 1. ? ( p.x < 8. ? 8192 : ( p.x < 16. ? 12288 : 0 ) ) : v;\n\tv = p.y == 0. ? ( p.x < 8. ? 0 : ( p.x < 16. ? 70144 : 0 ) ) : v;\n    float i = float( ( v >> int( 4. * p.x ) ) & 15 );\n    color = i == 1. ? vec3( 0.42, 0.4, 0.38 ) : color;\n    color = i == 2. ? vec3( 0.55, 0.53, 0.51 ) : color;\n    color = i == 3. ? vec3( 0.72, 0.69, 0.65 ) : color;\n}\n\nvoid SpriteWater( inout vec3 color, vec2 p )\n{\n    int v = 0;\n\tv = p.y == 15. ? ( p.x < 8. ? 286404882 : ( p.x < 16. ? 842142226 : 0 ) ) : v;\n\tv = p.y == 14. ? ( p.x < 8. ? 286261795 : ( p.x < 16. ? 286405169 : 0 ) ) : v;\n\tv = p.y == 13. ? ( p.x < 8. ? 269553970 : ( p.x < 16. ? 286339873 : 0 ) ) : v;\n\tv = p.y == 12. ? ( p.x < 8. ? 17965330 : ( p.x < 16. ? 554840865 : 0 ) ) : v;\n\tv = p.y == 11. ? ( p.x < 8. ? 1179665 : ( p.x < 16. ? 322122513 : 0 ) ) : v;\n\tv = p.y == 10. ? ( p.x < 8. ? 19988481 : ( p.x < 16. ? 858923265 : 0 ) ) : v;\n\tv = p.y == 9. ? ( p.x < 8. ? 303108385 : ( p.x < 16. ? 303116817 : 0 ) ) : v;\n\tv = p.y == 8. ? ( p.x < 8. ? 273 : ( p.x < 16. ? 287449616 : 0 ) ) : v;\n\tv = p.y == 7. ? ( p.x < 8. ? 17826065 : ( p.x < 16. ? 303112464 : 0 ) ) : v;\n\tv = p.y == 6. ? ( p.x < 8. ? 285212945 : ( p.x < 16. ? 285212945 : 0 ) ) : v;\n\tv = p.y == 5. ? ( p.x < 8. ? 16777233 : ( p.x < 16. ? 553648400 : 0 ) ) : v;\n\tv = p.y == 4. ? ( p.x < 8. ? 17825793 : ( p.x < 16. ? 287375360 : 0 ) ) : v;\n\tv = p.y == 3. ? ( p.x < 8. ? 268435457 : ( p.x < 16. ? 571613184 : 0 ) ) : v;\n\tv = p.y == 2. ? ( p.x < 8. ? 268439826 : ( p.x < 16. ? 822153489 : 0 ) ) : v;\n\tv = p.y == 1. ? ( p.x < 8. ? 268439827 : ( p.x < 16. ? 805380369 : 0 ) ) : v;\n\tv = p.y == 0. ? ( p.x < 8. ? 286339345 : ( p.x < 16. ? 841158944 : 0 ) ) : v;\n    float i = float( ( v >> int( 4. * p.x ) ) & 15 );\n    color = vec3( 0.21, 0.38, 0.29 );\n    color = i == 1. ? vec3( 0.24, 0.41, 0.33 ) : color;\n    color = i == 2. ? vec3( 0.27, 0.44, 0.36 ) : color;\n    color = i == 3. ? vec3( 0.3, 0.47, 0.37 ) : color;\n}\n\nvoid SpriteFloor( inout vec3 color, vec2 p )\n{\n    int v = 0;\n\tv = p.y == 15. ? ( p.x < 4. ? 33555717 : ( p.x < 8. ? 84149251 : ( p.x < 12. ? 67371267 : 67437569 ) ) ) : v;\n\tv = p.y == 14. ? ( p.x < 4. ? 16844037 : ( p.x < 8. ? 16777216 : ( p.x < 12. ? 65793 : 50594817 ) ) ) : v;\n\tv = p.y == 13. ? ( p.x < 4. ? 33620997 : ( p.x < 8. ? 197893 : ( p.x < 12. ? 33752323 : 50660608 ) ) ) : v;\n\tv = p.y == 12. ? ( p.x < 4. ? 67109893 : ( p.x < 8. ? 328709 : ( p.x < 12. ? 67306756 : 84149504 ) ) ) : v;\n\tv = p.y == 11. ? ( p.x < 4. ? 83886851 : ( p.x < 8. ? 263428 : ( p.x < 12. ? 50660099 : 84214272 ) ) ) : v;\n\tv = p.y == 10. ? ( p.x < 4. ? 83886337 : ( p.x < 8. ? 17040644 : ( p.x < 12. ? 65537 : 16843009 ) ) ) : v;\n\tv = p.y == 9. ? ( p.x < 4. ? 50397957 : ( p.x < 8. ? 328965 : ( p.x < 12. ? 84215042 : 67371266 ) ) ) : v;\n\tv = p.y == 8. ? ( p.x < 4. ? 83952645 : ( p.x < 8. ? 17106181 : ( p.x < 12. ? 84149508 : 67436547 ) ) ) : v;\n\tv = p.y == 7. ? ( p.x < 4. ? 33620485 : ( p.x < 8. ? 16909317 : ( p.x < 12. ? 84214788 : 67240197 ) ) ) : v;\n\tv = p.y == 6. ? ( p.x < 4. ? 16842752 : ( p.x < 8. ? 257 : ( p.x < 12. ? 84149508 : 65540 ) ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 50594305 : ( p.x < 8. ? 132101 : ( p.x < 12. ? 67372293 : 67371269 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 67437825 : ( p.x < 8. ? 17040645 : ( p.x < 12. ? 50595075 : 67371010 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 67371777 : ( p.x < 8. ? 16974852 : ( p.x < 12. ? 65792 : 84213760 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 16777216 : ( p.x < 8. ? 16843009 : ( p.x < 12. ? 50528256 : 65537 ) ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 33620485 : ( p.x < 8. ? 67437828 : ( p.x < 12. ? 84148226 : 67437312 ) ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 83952645 : ( p.x < 8. ? 84214532 : ( p.x < 12. ? 84148484 : 84215040 ) ) ) : v;\n    float i = float( ( v >> int( 8.0 * p.x ) ) & 255 );\n    color = vec3( 0.21, 0.2, 0.19 );\n    color = i == 1. ? vec3( 0.23, 0.23, 0.21 ) : color;\n    color = i == 2. ? vec3( 0.27, 0.27, 0.25 ) : color;\n    color = i == 3. ? vec3( 0.3, 0.29, 0.28 ) : color;\n    color = i == 4. ? vec3( 0.31, 0.31, 0.29 ) : color;\n    color = i == 5. ? vec3( 0.33, 0.32, 0.31 ) : color;\n}\n\nvoid SpriteWood( inout vec3 color, vec2 p )\n{\n    int v = 0;\n\tv = p.y == 15. ? ( p.x < 8. ? 17830178 : ( p.x < 16. ? 286401058 : 0 ) ) : v;\n\tv = p.y == 14. ? 0 : v;\n\tv = p.y == 13. ? ( p.x < 8. ? 303182643 : ( p.x < 16. ? 806424850 : 0 ) ) : v;\n\tv = p.y == 12. ? 0 : v;\n\tv = p.y == 11. ? ( p.x < 8. ? 807481906 : ( p.x < 16. ? 858993459 : 0 ) ) : v;\n\tv = p.y == 10. ? ( p.x < 8. ? 537989394 : ( p.x < 16. ? 304222738 : 0 ) ) : v;\n\tv = p.y == 9. ? 0 : v;\n\tv = p.y == 8. ? ( p.x < 8. ? 572732211 : ( p.x < 16. ? 34677025 : 0 ) ) : v;\n\tv = p.y == 7. ? ( p.x < 8. ? 554832402 : ( p.x < 16. ? 19013905 : 0 ) ) : v;\n\tv = p.y == 6. ? 0 : v;\n\tv = p.y == 5. ? ( p.x < 8. ? 288568115 : ( p.x < 16. ? 858993410 : 0 ) ) : v;\n\tv = p.y == 4. ? ( p.x < 8. ? 286331426 : ( p.x < 16. ? 286331137 : 0 ) ) : v;\n\tv = p.y == 3. ? 0 : v;\n\tv = p.y == 2. ? ( p.x < 8. ? 572732208 : ( p.x < 16. ? 303174161 : 0 ) ) : v;\n\tv = p.y == 1. ? 0 : v;\n\tv = p.y == 0. ? ( p.x < 8. ? 34677011 : ( p.x < 16. ? 858993459 : 0 ) ) : v;\n    float i = float( ( v >> int( 4. * p.x ) ) & 15 );\n    color = vec3( 0.25, 0.18, 0.098 );\n    color = i == 1. ? vec3( 0.31, 0.23, 0.11 ) : color;\n    color = i == 2. ? vec3( 0.35, 0.26, 0.12 ) : color;\n    color = i == 3. ? vec3( 0.4, 0.29, 0.12 ) : color;\n}\n\nvoid SpriteWall( inout vec3 color, vec2 p )\n{    \n    int v = 0;\n\tv = p.y == 15. ? ( p.x < 4. ? 100927239 : ( p.x < 8. ? 17106437 : ( p.x < 12. ? 67372806 : 328452 ) ) ) : v;\n\tv = p.y == 14. ? ( p.x < 4. ? 117901063 : ( p.x < 8. ? 17171974 : ( p.x < 12. ? 101123847 : 393991 ) ) ) : v;\n\tv = p.y == 13. ? ( p.x < 4. ? 84280838 : ( p.x < 8. ? 329222 : ( p.x < 12. ? 84281094 : 329221 ) ) ) : v;\n\tv = p.y == 12. ? ( p.x < 4. ? 1 : ( p.x < 8. ? 65537 : ( p.x < 12. ? 256 : 16777472 ) ) ) : v;\n\tv = p.y == 11. ? ( p.x < 4. ? 17105926 : ( p.x < 8. ? 117703683 : ( p.x < 12. ? 17171975 : 117901062 ) ) ) : v;\n\tv = p.y == 10. ? ( p.x < 4. ? 17172231 : ( p.x < 8. ? 117835526 : ( p.x < 12. ? 460295 : 117901063 ) ) ) : v;\n\tv = p.y == 9. ? ( p.x < 4. ? 329222 : ( p.x < 8. ? 84346629 : ( p.x < 12. ? 17106437 : 84281093 ) ) ) : v;\n\tv = p.y == 8. ? ( p.x < 4. ? 16842753 : ( p.x < 8. ? 16843009 : ( p.x < 12. ? 16777473 : 65536 ) ) ) : v;\n\tv = p.y == 7. ? ( p.x < 4. ? 67372036 : ( p.x < 8. ? 101058052 : ( p.x < 12. ? 67372545 : 100664836 ) ) ) : v;\n\tv = p.y == 6. ? ( p.x < 4. ? 117900038 : ( p.x < 8. ? 101058311 : ( p.x < 12. ? 67503872 : 100730374 ) ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 84280839 : ( p.x < 8. ? 84215046 : ( p.x < 12. ? 84280577 : 83887366 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 65793 : ( p.x < 8. ? 16777473 : ( p.x < 12. ? 257 : 0 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 84281095 : ( p.x < 8. ? 117703424 : ( p.x < 12. ? 33818119 : 117900032 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 117835270 : ( p.x < 8. ? 117901057 : ( p.x < 12. ? 117900806 : 101122817 ) ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 84280583 : ( p.x < 8. ? 101123328 : ( p.x < 12. ? 84215046 : 101123584 ) ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 16842753 : ( p.x < 8. ? 16842752 : ( p.x < 12. ? 16777472 : 16843008 ) ) ) : v;\n    float i = float( ( v >> int( 8.0 * p.x ) ) & 255 );\n    color = vec3( 0.33 );\n    color = i == 1. ? vec3( 0.38 ) : color;\n    color = i == 2. ? vec3( 0.5, 0.6, 0.56 ) : color;\n    color = i == 3. ? vec3( 0.55, 0.65, 0.6 ) : color;\n    color = i == 4. ? vec3( 0.61, 0.71, 0.66 ) : color;\n    color = i == 5. ? vec3( 0.67 ) : color;\n    color = i == 6. ? vec3( 0.75 ) : color;\n    color = i == 7. ? vec3( 0.85 ) : color;\n}\n\nvoid SpriteWallHole( inout vec3 color, vec2 p )\n{\n    int v = 0;\n\tv = p.y == 15. ? ( p.x < 4. ? 100992775 : ( p.x < 8. ? 50660869 : ( p.x < 12. ? 84215558 : 33883141 ) ) ) : v;\n\tv = p.y == 14. ? ( p.x < 4. ? 117901063 : ( p.x < 8. ? 33817606 : ( p.x < 12. ? 100992261 : 33948679 ) ) ) : v;\n\tv = p.y == 13. ? ( p.x < 4. ? 84280838 : ( p.x < 8. ? 117901060 : ( p.x < 12. ? 67569415 : 33883653 ) ) ) : v;\n\tv = p.y == 12. ? ( p.x < 4. ? 33686019 : ( p.x < 8. ? 101058054 : ( p.x < 12. ? 101058054 : 50463490 ) ) ) : v;\n\tv = p.y == 11. ? ( p.x < 4. ? 100926726 : ( p.x < 8. ? 101058054 : ( p.x < 12. ? 101058054 : 117900550 ) ) ) : v;\n\tv = p.y == 10. ? ( p.x < 4. ? 100927239 : ( p.x < 8. ? 67078 : ( p.x < 12. ? 101056768 : 117900550 ) ) ) : v;\n\tv = p.y == 9. ? ( p.x < 4. ? 100926982 : ( p.x < 8. ? 518 : ( p.x < 12. ? 100794368 : 84280582 ) ) ) : v;\n\tv = p.y == 8. ? ( p.x < 4. ? 100794883 : ( p.x < 8. ? 16777734 : ( p.x < 12. ? 100794369 : 33751558 ) ) ) : v;\n\tv = p.y == 7. ? ( p.x < 4. ? 100926725 : ( p.x < 8. ? 16843014 : ( p.x < 12. ? 100729089 : 100795398 ) ) ) : v;\n\tv = p.y == 6. ? ( p.x < 4. ? 100992006 : ( p.x < 8. ? 33620998 : ( p.x < 12. ? 100925698 : 100860934 ) ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 100926983 : ( p.x < 8. ? 67372550 : ( p.x < 12. ? 101057540 : 84018182 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 16909059 : ( p.x < 8. ? 67503622 : ( p.x < 12. ? 101057542 : 33686017 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 67372807 : ( p.x < 8. ? 67503617 : ( p.x < 12. ? 33949190 : 117900034 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 84280838 : ( p.x < 8. ? 50529026 : ( p.x < 12. ? 84083202 : 101123074 ) ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 84280583 : ( p.x < 8. ? 50594818 : ( p.x < 12. ? 67371779 : 101123586 ) ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 50528771 : ( p.x < 8. ? 33686018 : ( p.x < 12. ? 50463234 : 50529026 ) ) ) : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = vec3( 0.059, 0.059, 0.035 );\n    color = i == 1. ? vec3( 0.18, 0.19, 0.16 ) : color;\n    color = i == 2. ? vec3( 0.28, 0.29, 0.29 ) : color;\n    color = i == 3. ? vec3( 0.4, 0.44, 0.42 ) : color;\n    color = i == 4. ? vec3( 0.54, 0.58, 0.56 ) : color;\n    color = i == 5. ? vec3( 0.64, 0.69, 0.67 ) : color;\n    color = i == 6. ? vec3( 0.75 ) : color;\n    color = i == 7. ? vec3( 0.88 ) : color;\n}\n\nvoid SpriteDoorClosed( inout vec3 color, vec2 p )\n{\n    int v = 0;\n\tv = p.y == 15. ? ( p.x < 4. ? 117769991 : ( p.x < 8. ? 50661125 : ( p.x < 12. ? 84215559 : 50660613 ) ) ) : v;\n\tv = p.y == 14. ? ( p.x < 4. ? 16844551 : ( p.x < 8. ? 16843009 : ( p.x < 12. ? 16843009 : 50790657 ) ) ) : v;\n\tv = p.y == 13. ? ( p.x < 4. ? 67176199 : ( p.x < 8. ? 33686018 : ( p.x < 12. ? 33686018 : 50659586 ) ) ) : v;\n\tv = p.y == 12. ? ( p.x < 4. ? 67175171 : ( p.x < 8. ? 16843010 : ( p.x < 12. ? 33620225 : 50528514 ) ) ) : v;\n\tv = p.y == 11. ? ( p.x < 4. ? 16844039 : ( p.x < 8. ? 258 : ( p.x < 12. ? 33619968 : 117899522 ) ) ) : v;\n\tv = p.y == 10. ? ( p.x < 4. ? 16844295 : ( p.x < 8. ? 258 : ( p.x < 12. ? 33619968 : 117899522 ) ) ) : v;\n\tv = p.y == 9. ? ( p.x < 4. ? 16844295 : ( p.x < 8. ? 16843010 : ( p.x < 12. ? 33620225 : 84345090 ) ) ) : v;\n\tv = p.y == 8. ? ( p.x < 4. ? 33620739 : ( p.x < 8. ? 33686018 : ( p.x < 12. ? 33817090 : 50528514 ) ) ) : v;\n\tv = p.y == 7. ? ( p.x < 4. ? 33621253 : ( p.x < 8. ? 33686018 : ( p.x < 12. ? 16908802 : 100925697 ) ) ) : v;\n\tv = p.y == 6. ? ( p.x < 4. ? 33621255 : ( p.x < 8. ? 33817090 : ( p.x < 12. ? 16909314 : 117702913 ) ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 16844295 : ( p.x < 8. ? 33686018 : ( p.x < 12. ? 33686018 : 84148482 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 16843779 : ( p.x < 8. ? 33686018 : ( p.x < 12. ? 33686018 : 50528514 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 16844295 : ( p.x < 8. ? 33686018 : ( p.x < 12. ? 33686018 : 117899522 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 67176199 : ( p.x < 8. ? 33686018 : ( p.x < 12. ? 33686018 : 117899522 ) ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 67175687 : ( p.x < 8. ? 33686018 : ( p.x < 12. ? 33686018 : 117899522 ) ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 16843523 : ( p.x < 8. ? 16843009 : ( p.x < 12. ? 16843009 : 50528513 ) ) ) : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = vec3( 0 );\n    color = i == 1. ? vec3( 0.19, 0.14, 0.14 ) : color;\n    color = i == 2. ? vec3( 0.4, 0.26, 0.098 ) : color;\n    color = i == 3. ? vec3( 0.35 ) : color;\n    color = i == 4. ? vec3( 0.53, 0.38, 0.19 ) : color;\n    color = i == 5. ? vec3( 0.59, 0.67, 0.64 ) : color;\n    color = i == 6. ? vec3( 0.8, 0.64, 0.49 ) : color;\n    color = i == 7. ? vec3( 0.8 ) : color;\n}\n\nvoid SpriteDoorOpen( inout vec3 color, vec2 p )\n{\n    int v = 0;\n\tv = p.y == 15. ? ( p.x < 4. ? 100927239 : ( p.x < 8. ? 33818116 : ( p.x < 12. ? 67372806 : 33817604 ) ) ) : v;\n\tv = p.y == 14. ? ( p.x < 4. ? 16844551 : ( p.x < 8. ? 16843009 : ( p.x < 12. ? 16843009 : 33947905 ) ) ) : v;\n\tv = p.y == 13. ? ( p.x < 4. ? 67078 : ( p.x < 8. ? 0 : ( p.x < 12. ? 0 : 33816832 ) ) ) : v;\n\tv = p.y == 12. ? ( p.x < 4. ? 66050 : ( p.x < 8. ? 0 : ( p.x < 12. ? 0 : 33685760 ) ) ) : v;\n\tv = p.y == 11. ? ( p.x < 4. ? 66566 : ( p.x < 8. ? 0 : ( p.x < 12. ? 0 : 117899520 ) ) ) : v;\n\tv = p.y == 10. ? ( p.x < 4. ? 66823 : ( p.x < 8. ? 0 : ( p.x < 12. ? 0 : 117899520 ) ) ) : v;\n\tv = p.y == 9. ? ( p.x < 4. ? 66822 : ( p.x < 8. ? 0 : ( p.x < 12. ? 0 : 67502336 ) ) ) : v;\n\tv = p.y == 8. ? ( p.x < 4. ? 66050 : ( p.x < 8. ? 0 : ( p.x < 12. ? 0 : 33685760 ) ) ) : v;\n\tv = p.y == 7. ? ( p.x < 4. ? 66564 : ( p.x < 8. ? 0 : ( p.x < 12. ? 0 : 84082944 ) ) ) : v;\n\tv = p.y == 6. ? ( p.x < 4. ? 66566 : ( p.x < 8. ? 0 : ( p.x < 12. ? 0 : 100860160 ) ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 66823 : ( p.x < 8. ? 0 : ( p.x < 12. ? 0 : 67305728 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 66306 : ( p.x < 8. ? 0 : ( p.x < 12. ? 0 : 33685760 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 66823 : ( p.x < 8. ? 0 : ( p.x < 12. ? 0 : 117899520 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 67078 : ( p.x < 8. ? 0 : ( p.x < 12. ? 0 : 101122304 ) ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 66567 : ( p.x < 8. ? 0 : ( p.x < 12. ? 0 : 101122304 ) ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 66050 : ( p.x < 8. ? 0 : ( p.x < 12. ? 0 : 33685760 ) ) ) : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = i == 1. ? vec3( 0.15, 0.15, 0.14 ) : color;\n    color = i == 2. ? vec3( 0.35 ) : color;\n    color = i == 3. ? vec3( 0.53, 0.37, 0.21 ) : color;\n    color = i == 4. ? vec3( 0.59, 0.67, 0.64 ) : color;\n    color = i == 5. ? vec3( 0.8, 0.64, 0.49 ) : color;\n    color = i == 6. ? vec3( 0.75 ) : color;\n    color = i == 7. ? vec3( 0.85 ) : color;\n}\n\nvoid SpriteDoorLocked( inout vec3 color, vec2 p )\n{\n    int v = 0;\n\tv = p.y == 15. ? ( p.x < 4. ? 117769991 : ( p.x < 8. ? 50661125 : ( p.x < 12. ? 84215559 : 50660613 ) ) ) : v;\n\tv = p.y == 14. ? ( p.x < 4. ? 16844551 : ( p.x < 8. ? 16843009 : ( p.x < 12. ? 16843009 : 50790657 ) ) ) : v;\n\tv = p.y == 13. ? ( p.x < 4. ? 67176199 : ( p.x < 8. ? 33685762 : ( p.x < 12. ? 33686017 : 50659586 ) ) ) : v;\n\tv = p.y == 12. ? ( p.x < 4. ? 67175171 : ( p.x < 8. ? 16843010 : ( p.x < 12. ? 33620225 : 50528514 ) ) ) : v;\n\tv = p.y == 11. ? ( p.x < 4. ? 16844039 : ( p.x < 8. ? 258 : ( p.x < 12. ? 33619968 : 117899522 ) ) ) : v;\n\tv = p.y == 10. ? ( p.x < 4. ? 16844295 : ( p.x < 8. ? 84214017 : ( p.x < 12. ? 16843525 : 117899522 ) ) ) : v;\n\tv = p.y == 9. ? ( p.x < 4. ? 16844295 : ( p.x < 8. ? 50529537 : ( p.x < 12. ? 16974595 : 84345090 ) ) ) : v;\n\tv = p.y == 8. ? ( p.x < 4. ? 33620739 : ( p.x < 8. ? 16974594 : ( p.x < 12. ? 16974593 : 50528513 ) ) ) : v;\n\tv = p.y == 7. ? ( p.x < 4. ? 33621253 : ( p.x < 8. ? 84215045 : ( p.x < 12. ? 84215045 : 100925697 ) ) ) : v;\n\tv = p.y == 6. ? ( p.x < 4. ? 33621255 : ( p.x < 8. ? 50529029 : ( p.x < 12. ? 50529027 : 117702913 ) ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 16844295 : ( p.x < 8. ? 197381 : ( p.x < 12. ? 50529024 : 84148481 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 16843779 : ( p.x < 8. ? 197381 : ( p.x < 12. ? 50529024 : 50528513 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 16844295 : ( p.x < 8. ? 50529029 : ( p.x < 12. ? 50529027 : 117899521 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 33621767 : ( p.x < 8. ? 50529027 : ( p.x < 12. ? 50529027 : 117899521 ) ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 33621255 : ( p.x < 8. ? 16843009 : ( p.x < 12. ? 16843265 : 117899521 ) ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 16843523 : ( p.x < 8. ? 16843009 : ( p.x < 12. ? 16843009 : 50528513 ) ) ) : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = vec3( 0.024, 0.0078, 0 );\n    color = i == 1. ? vec3( 0.19, 0.13, 0.11 ) : color;\n    color = i == 2. ? vec3( 0.38, 0.25, 0.094 ) : color;\n    color = i == 3. ? vec3( 0.42, 0.39, 0.38 ) : color;\n    color = i == 4. ? vec3( 0.53, 0.38, 0.2 ) : color;\n    color = i == 5. ? vec3( 0.59, 0.62, 0.56 ) : color;\n    color = i == 6. ? vec3( 0.8, 0.64, 0.49 ) : color;\n    color = i == 7. ? vec3( 0.8 ) : color;\n}\n\nvoid SpriteStairsDown( inout vec3 color, vec2 p )\n{\n    int v = 0;\n\tv = p.y == 15. ? ( p.x < 4. ? 50529284 : ( p.x < 8. ? 67306243 : ( p.x < 12. ? 67372036 : 50594820 ) ) ) : v;\n\tv = p.y == 14. ? ( p.x < 4. ? 117901060 : ( p.x < 8. ? 117835271 : ( p.x < 12. ? 101123847 : 50726407 ) ) ) : v;\n\tv = p.y == 13. ? ( p.x < 4. ? 33751553 : ( p.x < 8. ? 33751555 : ( p.x < 12. ? 33620483 : 50791170 ) ) ) : v;\n\tv = p.y == 12. ? ( p.x < 4. ? 50529028 : ( p.x < 8. ? 16908548 : ( p.x < 12. ? 16843265 : 67568129 ) ) ) : v;\n\tv = p.y == 11. ? ( p.x < 4. ? 117835523 : ( p.x < 8. ? 16843011 : ( p.x < 12. ? 16842753 : 67567873 ) ) ) : v;\n\tv = p.y == 10. ? ( p.x < 4. ? 117835524 : ( p.x < 8. ? 50463235 : ( p.x < 12. ? 65539 : 67567873 ) ) ) : v;\n\tv = p.y == 9. ? ( p.x < 4. ? 101123844 : ( p.x < 8. ? 84215044 : ( p.x < 12. ? 2 : 50790400 ) ) ) : v;\n\tv = p.y == 8. ? ( p.x < 4. ? 117901060 : ( p.x < 8. ? 84280580 : ( p.x < 12. ? 33620482 : 50790401 ) ) ) : v;\n\tv = p.y == 7. ? ( p.x < 4. ? 117900804 : ( p.x < 8. ? 84215044 : ( p.x < 12. ? 84149250 : 50724866 ) ) ) : v;\n\tv = p.y == 6. ? ( p.x < 4. ? 117900803 : ( p.x < 8. ? 84215044 : ( p.x < 12. ? 84149506 : 50790657 ) ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 101123844 : ( p.x < 8. ? 84215044 : ( p.x < 12. ? 67372034 : 50725890 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 101123844 : ( p.x < 8. ? 100992260 : ( p.x < 12. ? 67372035 : 50725377 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 101123844 : ( p.x < 8. ? 84215043 : ( p.x < 12. ? 67437570 : 67568129 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 67306243 : ( p.x < 8. ? 50529028 : ( p.x < 12. ? 16908546 : 50790658 ) ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 101123588 : ( p.x < 8. ? 117901062 : ( p.x < 12. ? 117835270 : 50792199 ) ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 67371780 : ( p.x < 8. ? 67371779 : ( p.x < 12. ? 67306499 : 67372035 ) ) ) : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = vec3( 0.13 );\n    color = i == 1. ? vec3( 0.2 ) : color;\n    color = i == 2. ? vec3( 0.26 ) : color;\n    color = i == 3. ? vec3( 0.31 ) : color;\n    color = i == 4. ? vec3( 0.35 ) : color;\n    color = i == 5. ? vec3( 0.44 ) : color;\n    color = i == 6. ? vec3( 0.51 ) : color;\n    color = i == 7. ? vec3( 0.56 ) : color;\n}\n\nvoid SpriteStairsUp( inout vec3 color, vec2 p )\n{\n    int v = 0;\n\tv = p.y == 15. ? ( p.x < 4. ? 50529284 : ( p.x < 8. ? 84215045 : ( p.x < 12. ? 84214533 : 84215043 ) ) ) : v;\n\tv = p.y == 14. ? ( p.x < 4. ? 67569412 : ( p.x < 8. ? 50463234 : ( p.x < 12. ? 33751811 : 84215043 ) ) ) : v;\n\tv = p.y == 13. ? ( p.x < 4. ? 50791940 : ( p.x < 8. ? 50594820 : ( p.x < 12. ? 67437829 : 84215042 ) ) ) : v;\n\tv = p.y == 12. ? ( p.x < 4. ? 50726404 : ( p.x < 8. ? 50791943 : ( p.x < 12. ? 84215045 : 84215042 ) ) ) : v;\n\tv = p.y == 11. ? ( p.x < 4. ? 67503875 : ( p.x < 8. ? 50726662 : ( p.x < 12. ? 67371780 : 84214786 ) ) ) : v;\n\tv = p.y == 10. ? ( p.x < 4. ? 67503876 : ( p.x < 8. ? 67503878 : ( p.x < 12. ? 50791943 : 50529027 ) ) ) : v;\n\tv = p.y == 9. ? ( p.x < 4. ? 50792196 : ( p.x < 8. ? 50792199 : ( p.x < 12. ? 67569414 : 50594819 ) ) ) : v;\n\tv = p.y == 8. ? ( p.x < 4. ? 16843009 : ( p.x < 8. ? 67569415 : ( p.x < 12. ? 67503878 : 50791942 ) ) ) : v;\n\tv = p.y == 7. ? ( p.x < 4. ? 17105665 : ( p.x < 8. ? 67503623 : ( p.x < 12. ? 67569158 : 50726663 ) ) ) : v;\n\tv = p.y == 6. ? ( p.x < 4. ? 17105664 : ( p.x < 8. ? 65793 : ( p.x < 12. ? 67503878 : 50791942 ) ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 50529025 : ( p.x < 8. ? 16974597 : 50726663 ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 50529025 : ( p.x < 8. ? 16974595 : ( p.x < 12. ? 257 : 50726406 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 50529025 : ( p.x < 8. ? 50529027 : ( p.x < 12. ? 197379 : 67569158 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 50397440 : ( p.x < 8. ? 50529027 : ( p.x < 12. ? 196865 : 65536 ) ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 16974080 : ( p.x < 8. ? 16974593 : ( p.x < 12. ? 50397441 : 197377 ) ) ) : v;\n\tv = p.y == 0. ? 0 : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = vec3( 0.12 );\n    color = i == 1. ? vec3( 0.17 ) : color;\n    color = i == 2. ? vec3( 0.21, 0.2, 0.19 ) : color;\n    color = i == 3. ? vec3( 0.23, 0.23, 0.22 ) : color;\n    color = i == 4. ? vec3( 0.26, 0.26, 0.25 ) : color;\n    color = i == 5. ? vec3( 0.31, 0.31, 0.29 ) : color;\n    color = i == 6. ? vec3( 0.5 ) : color;\n    color = i == 7. ? vec3( 0.53 ) : color;\n}\n\nvoid SpriteKey( inout vec3 color, vec2 p )\n{\n    p -= vec2( 5., 2. );\n    p = p.x < 0. ? vec2( 0. ) : p;    \n    \n    int v = 0;\n\tv = p.y == 11. ? ( p.x < 8. ? 139824 : 0 ) : v;\n\tv = p.y == 10. ? ( p.x < 8. ? 2232611 : 0 ) : v;\n\tv = p.y == 9. ? ( p.x < 8. ? 1179666 : 0 ) : v;\n\tv = p.y == 8. ? ( p.x < 8. ? 1245202 : 0 ) : v;\n\tv = p.y == 7. ? ( p.x < 8. ? 1192482 : 0 ) : v;\n\tv = p.y == 6. ? ( p.x < 8. ? 74256 : 0 ) : v;\n\tv = p.y == 5. ? ( p.x < 8. ? 4608 : 0 ) : v;\n\tv = p.y == 4. ? ( p.x < 8. ? 4608 : 0 ) : v;\n\tv = p.y == 3. ? ( p.x < 8. ? 4608 : 0 ) : v;\n\tv = p.y == 2. ? ( p.x < 8. ? 2232832 : 0 ) : v;\n\tv = p.y == 1. ? ( p.x < 8. ? 135680 : 0 ) : v;\n\tv = p.y == 0. ? ( p.x < 8. ? 2232832 : 0 ) : v;\n    float i = float( ( v >> int( 4. * p.x ) ) & 15 );\n    color = i == 1. ? vec3( 0.45 ) : color;\n    color = i == 2. ? vec3( 0.83 ) : color;\n    color = i == 3. ? vec3( 0.95 ) : color;\n}\n\nvoid SpriteFood( inout vec3 color, vec2 p )\n{\n    p -= vec2( 4., 4. );\n    p = p.x < 0. ? vec2( 0. ) : p;\n    \n    int v = 0;\n\tv = p.y == 7. ? ( p.x < 8. ? 3355392 : 0 ) : v;\n\tv = p.y == 6. ? ( p.x < 8. ? 52498736 : 0 ) : v;\n\tv = p.y == 5. ? ( p.x < 8. ? 839979795 : 0 ) : v;\n\tv = p.y == 4. ? ( p.x < 8. ? 839979283 : 0 ) : v;\n\tv = p.y == 3. ? ( p.x < 8. ? 839979283 : 0 ) : v;\n\tv = p.y == 2. ? ( p.x < 8. ? 841027875 : 0 ) : v;\n\tv = p.y == 1. ? ( p.x < 8. ? 52568624 : 0 ) : v;\n\tv = p.y == 0. ? ( p.x < 8. ? 3355392 : 0 ) : v;\n    float i = float( ( v >> int( 4. * p.x ) ) & 15 );\n    color = i == 1. ? vec3( 0.24 ) : color;\n    color = i == 2. ? vec3( 0.29, 0.74, 0.79 ) : color;\n    color = i == 3. ? vec3( 0.91 ) : color;\n}\n\nvoid SpritePotion( inout vec3 color, vec2 p )\n{\n    p -= vec2( 4., 2. );\n    p = p.x < 0. ? vec2( 0. ) : p;\n    \n    int v = 0;\n\tv = p.y == 11. ? ( p.x < 4. ? 50331648 : ( p.x < 8. ? 4 : 0 ) ) : v;\n\tv = p.y == 10. ? ( p.x < 4. ? 84280832 : ( p.x < 8. ? 394757 : 0 ) ) : v;\n\tv = p.y == 9. ? ( p.x < 4. ? 50724864 : ( p.x < 8. ? 1540 : 0 ) ) : v;\n\tv = p.y == 8. ? ( p.x < 4. ? 17170432 : ( p.x < 8. ? 1537 : 0 ) ) : v;\n\tv = p.y == 7. ? ( p.x < 4. ? 17170432 : ( p.x < 8. ? 1537 : 0 ) ) : v;\n\tv = p.y == 6. ? ( p.x < 4. ? 16844288 : ( p.x < 8. ? 393473 : 0 ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 16843014 : ( p.x < 8. ? 100729089 : 0 ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 33686022 : ( p.x < 8. ? 100796162 : 0 ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 33686022 : ( p.x < 8. ? 100796162 : 0 ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 33686022 : ( p.x < 8. ? 100794882 : 0 ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 33687040 : ( p.x < 8. ? 393730 : 0 ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 101056512 : ( p.x < 8. ? 1542 : 0 ) ) : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = i == 1. ? vec3( 0.24 ) : color;\n    color = i == 2. ? vec3( 0.91, 0, 0.12 ) : color;\n    color = i == 3. ? vec3( 0.6, 0.38, 0.2 ) : color;\n    color = i == 4. ? vec3( 0.71, 0.49, 0.31 ) : color;\n    color = i == 5. ? vec3( 0.83, 0.76, 0.71 ) : color;\n    color = i == 6. ? vec3( 0.85 ) : color;\n    color = i == 7. ? vec3( 1 ) : color;\n}\n\nvoid SpriteRatDead( inout vec3 color, vec2 p )\n{\n    p -= vec2( 2., 1. );\n    p = p.x < 0. ? vec2( 9. ) : p;  \n    \n    int v = 0;\n\tv = p.y == 8. ? ( p.x < 4. ? 33685504 : ( p.x < 8. ? 5 : 0 ) ) : v;\n\tv = p.y == 7. ? ( p.x < 4. ? 67371520 : ( p.x < 8. ? 1 : ( p.x < 12. ? 131586 : 0 ) ) ) : v;\n\tv = p.y == 6. ? ( p.x < 4. ? 67371522 : ( p.x < 8. ? 50397442 : ( p.x < 12. ? 84149252 : 0 ) ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 67372034 : ( p.x < 8. ? 67240452 : ( p.x < 12. ? 33817604 : 0 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 67371521 : ( p.x < 8. ? 50594308 : ( p.x < 12. ? 16843268 : 0 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 67372033 : ( p.x < 8. ? 67372036 : ( p.x < 12. ? 84149250 : 0 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 67371264 : ( p.x < 8. ? 67371524 : ( p.x < 12. ? 50594818 : 0 ) ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 16844289 : ( p.x < 8. ? 67240450 : ( p.x < 12. ? 16908804 : 0 ) ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 257 : ( p.x < 8. ? 16843009 : ( p.x < 12. ? 100729089 : 460551 ) ) ) : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = i == 1. ? vec3( 0.16, 0.11, 0.071 ) : color;\n    color = i == 2. ? vec3( 0.33, 0.26, 0.18 ) : color;\n    color = i == 3. ? vec3( 0.58, 0.25, 0.24 ) : color;\n    color = i == 4. ? vec3( 0.51, 0.44, 0.35 ) : color;\n    color = i == 5. ? vec3( 0.81, 0.31, 0.33 ) : color;\n    color = i == 6. ? vec3( 0.8, 0.49, 0.51 ) : color;\n    color = i == 7. ? vec3( 0.93, 0.58, 0.6 ) : color;\n}\n\nvoid SpriteSkeletonDead( inout vec3 color, vec2 p )\n{\n    p -= vec2( 4., 1. );\n    p = p.x < 0. ? vec2( 0. ) : p;    \n    \n    int v = 0;\n\tv = p.y == 6. ? ( p.x < 4. ? 84215040 : ( p.x < 8. ? 328965 : 0 ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 101058053 : ( p.x < 8. ? 84280838 : 0 ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 67372547 : ( p.x < 8. ? 33817604 : 0 ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 17171971 : ( p.x < 8. ? 83953158 : 0 ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 101057024 : ( p.x < 8. ? 84280326 : 0 ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 50462720 : ( p.x < 8. ? 197893 : 0 ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 33554432 : ( p.x < 8. ? 131072 : 0 ) ) : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = i == 1. ? vec3( 0 ) : color;\n    color = i == 2. ? vec3( 0.49 ) : color;\n    color = i == 3. ? vec3( 0.64 ) : color;\n    color = i == 4. ? vec3( 0.7 ) : color;\n    color = i == 5. ? vec3( 0.81 ) : color;\n    color = i == 6. ? vec3( 0.9 ) : color;\n}\n\nvoid SpriteTrap( inout vec3 color, vec2 p, float pulse )\n{\n    int v = 0;\n\tv = p.y == 15. ? 0 : v;\n\tv = p.y == 14. ? 0 : v;\n\tv = p.y == 13. ? ( p.x < 4. ? 33554432 : ( p.x < 8. ? 16777218 : ( p.x < 12. ? 33554434 : 1 ) ) ) : v;\n\tv = p.y == 12. ? ( p.x < 4. ? 117506048 : ( p.x < 8. ? 84017157 : ( p.x < 12. ? 84017157 : 5 ) ) ) : v;\n\tv = p.y == 11. ? ( p.x < 4. ? 117440512 : ( p.x < 8. ? 83887621 : ( p.x < 12. ? 83887621 : 1543 ) ) ) : v;\n\tv = p.y == 10. ? ( p.x < 4. ? 100663296 : ( p.x < 8. ? 67108870 : ( p.x < 12. ? 67108868 : 4 ) ) ) : v;\n\tv = p.y == 9. ? ( p.x < 4. ? 33554432 : ( p.x < 8. ? 16777218 : ( p.x < 12. ? 33554434 : 2 ) ) ) : v;\n\tv = p.y == 8. ? ( p.x < 4. ? 83951616 : ( p.x < 8. ? 84017157 : ( p.x < 12. ? 117571589 : 517 ) ) ) : v;\n\tv = p.y == 7. ? ( p.x < 4. ? 83886080 : ( p.x < 8. ? 83887623 : ( p.x < 12. ? 117638661 : 1029 ) ) ) : v;\n\tv = p.y == 6. ? ( p.x < 4. ? 67108864 : ( p.x < 8. ? 67108868 : ( p.x < 12. ? 100664070 : 6 ) ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 33554432 : ( p.x < 8. ? 16777218 : ( p.x < 12. ? 33554434 : 2 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 117571584 : ( p.x < 8. ? 117571589 : ( p.x < 12. ? 84017157 : 5 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 83886080 : ( p.x < 8. ? 83887621 : ( p.x < 12. ? 84018181 : 1031 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 67108864 : ( p.x < 8. ? 67108868 : ( p.x < 12. ? 100663300 : 516 ) ) ) : v;\n\tv = p.y == 1. ? 0 : v;\n\tv = p.y == 0. ? 0 : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = i == 1. ? vec3( 0.13, 0.13, 0.12 ) : color;\n    color = i == 2. ? vec3( 0.21, 0.2, 0.19 ) : color;\n    color = i == 3. ? vec3( 0.33, 0.32, 0.31 ) : color;\n    color = i == 4. ? vec3( 0.37, 0.37, 0.36 ) : color;\n    color = i == 5. ? pulse * vec3( 0.93, 0.35, 0 ) : color;\n    color = i == 6. ? vec3( 0.44, 0.43, 0.42 ) : color;\n    color = i == 7. ? pulse * vec3( 1, 0.47, 0.051 ) : color;\n}\n\nvoid SpriteMoss( inout vec3 color, vec2 p )\n{\n    int v = 0;\n\tv = p.y == 15. ? 0 : v;\n\tv = p.y == 14. ? 0 : v;\n\tv = p.y == 13. ? 0 : v;\n\tv = p.y == 12. ? ( p.x < 8. ? 318767104 : ( p.x < 16. ? 3145731 : 0 ) ) : v;\n\tv = p.y == 11. ? ( p.x < 8. ? 318767360 : ( p.x < 16. ? 52428851 : 0 ) ) : v;\n\tv = p.y == 10. ? ( p.x < 8. ? 321912832 : ( p.x < 16. ? 1114129 : 0 ) ) : v;\n\tv = p.y == 9. ? ( p.x < 8. ? 322109440 : ( p.x < 16. ? 51523586 : 0 ) ) : v;\n\tv = p.y == 8. ? ( p.x < 8. ? 322109440 : ( p.x < 16. ? 51589120 : 0 ) ) : v;\n\tv = p.y == 7. ? ( p.x < 8. ? 305135616 : ( p.x < 16. ? 34799667 : 0 ) ) : v;\n\tv = p.y == 6. ? ( p.x < 8. ? 285212672 : ( p.x < 16. ? 819 : 0 ) ) : v;\n\tv = p.y == 5. ? ( p.x < 8. ? 0 : ( p.x < 16. ? 819 : 0 ) ) : v;\n\tv = p.y == 4. ? ( p.x < 8. ? 196608 : 0 ) : v;\n\tv = p.y == 3. ? ( p.x < 8. ? 3354624 : ( p.x < 16. ? 256 : 0 ) ) : v;\n\tv = p.y == 2. ? ( p.x < 8. ? 1118464 : 0 ) : v;\n\tv = p.y == 1. ? ( p.x < 8. ? 204800 : 0 ) : v;\n\tv = p.y == 0. ? 0 : v;\n    float i = float( ( v >> int( 4. * p.x ) ) & 15 );\n    color = i == 1. ? vec3( 0.37, 0.39, 0.14 ) : color;\n    color = i == 2. ? vec3( 0.39, 0.41, 0.16 ) : color;\n    color = i == 3. ? vec3( 0.41, 0.42, 0.18 ) : color;\n}\n\nvec2 FrameOffset( float frame, float tick )\n{\n    vec2 ret = vec2( 0. );\n    ret.x = frame == 1. ? 1. : ( frame == 2. ? -1. : 0. );\n    ret.y = frame == 3. ? 1. : ( frame == 4. ? -1. : 0. );\n    return floor( 16. * ret * ( tick \/ TICK_NUM ) );\n}\n\nfloat Rand( vec2 n )\n{\n\treturn fract( sin( dot( n.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );\n}\n\nfloat WaterSDF( vec2 p )\n{\n    float ret = length( p - vec2( 16., 16. ) ) - 16.;\n    ret = min( ret, length( p - vec2( 20., 60. ) ) - 16. );\n    ret = min( ret, length( p - vec2( 18., 38. ) ) - 12. );\n    \n    ret = min( ret, length( p - vec2( 286., 20. ) ) - 36. );\n    \n    ret = min( ret, length( p - vec2( 20., 120. ) ) - 16. );\n    ret = min( ret, length( p - vec2( 20., 160. ) ) - 16. );\n    \n    ret = min( ret, length( p - vec2( 16., 400. ) ) - 20. );\n    \n    ret = min( ret, length( p - vec2( 470., 30. ) ) - 20. );\n    ret = min( ret, length( p - vec2( 480., 80. ) ) - 20. );\n    ret = min( ret, length( p - vec2( 430., 10. ) ) - 20. );\n    \n    ret = min( ret, length( p - vec2( 415., 320. ) ) - 30. );\n    \n    ret = min( ret, length( p - vec2( 130., 320. ) ) - 40. );\n    \n\tret = min( ret, length( p - vec2( 300., 100. ) ) - 50. );    \n    \n    ret = min( ret, length( p - vec2( 80., 480. ) ) - 50. ); \n    \n    ret = min( ret, length( p - vec2( 80., 224. ) ) - 50. ); \n    \n    ret = min( ret, length( p - vec2( 200., 360. ) ) - 50. ); \n    \n    ret += sin( p.y * .75 ) * 1.;    \n    return floor( ret );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    GameState s;\n    LoadState( s );    \n    \n    vec2 playerPos = s.playerPos * 16. + FrameOffset( s.playerFrame, s.tick ); \n    \n    vec2 resMult\t= floor( iResolution.xy \/ REF_RES );\n    float resRcp    = 1. \/ max( min( resMult.x, resMult.y ), 1. );\n    vec2 screenSize = floor( iResolution.xy * resRcp );\n    vec2 pixel      = floor( fragCoord.xy * resRcp );\n    vec2 camera     = clamp( playerPos - floor( screenSize \/ 2. ), vec2( -32. ), vec2( 32. * 16. + 32. ) - screenSize );\n    vec2 world      = pixel + camera;\n    vec2 tile\t\t= floor( world \/ 16. );\n    vec2 worldMod16 = floor( mod( world, 16. ) );\n    vec4 map\t\t= texelFetch( iChannel1, ivec2( tile ), 0 );\n    \n    vec3 color = vec3( 0. );\n    SpriteEarth( color, worldMod16 );\n    if ( Rand( tile \/ 32. ) > .8 )\n    {\n    \tSpriteEarth2( color, worldMod16 );\n    }\n\n    float waterSDF = WaterSDF( world );\n    if ( map.x != 0. )\n    {\n\t\tSpriteFloor( color, worldMod16 );\n        \n \t\tvec3 water;\n        SpriteWater( water, floor( mod( floor( world + vec2( 0., float( iFrame ) * .2 ) ), 16. ) ) );\n        \n        float alpha = waterSDF >= 0. ? 0. : 1.;\n        alpha = waterSDF == -1. ? 0.25 : alpha;\n        alpha = waterSDF == -2. ? 0.5 : alpha;\n        \n    \tcolor = mix( color, water, alpha );\n    }\n    \n    \/\/ decoration\n    if ( map.x == TILE_FLOOR && waterSDF >= 0. )\n    {\n\t\tif ( Rand( tile \/ 32. - 3.15 ) > .8 )\n    \t{\n       \t\t SpriteMoss( color, worldMod16 );\n        } \n        else if ( Rand( tile \/ 32. - 7.19 ) > .9 )\n        {\n            SpriteEarth2( color, worldMod16 );\n        }\n        else if ( Rand( tile \/ 32. - 13.19 ) > .95 )\n        {\n            SpriteTrap( color, worldMod16, 0. );\n        }   \n    }\n    \n    if ( map.x == TILE_STAIRS_UP )\n    {\n        SpriteStairsUp( color, worldMod16 );\n    }\n    if ( map.x == TILE_STAIRS_DOWN )\n    {\n        SpriteStairsDown( color, worldMod16 );\n    }     \n    \n    if ( map.x == TILE_WALL )\n    {\n    \tSpriteWall( color, worldMod16 );\n    }\n    if ( map.x == TILE_WALL_HOLE )\n    {\n    \tSpriteWallHole( color, worldMod16 );\n    }       \n    if ( map.x == TILE_DOOR_LOCKED )\n    {\n        SpriteDoorLocked( color, worldMod16 );\n    }\n    if ( map.x == TILE_DOOR_OPEN )\n    {\n        bool open = s.playerPos == tile || map.z > 0.;\n\t\tfor ( int i = 0; i < ENEMY_NUM; ++i )        \n        {\n            if ( tile == s.enemyPos[ i ] )\n            {\n                open = true;\n            }\n        }\n\n        if ( open )\n        {\n        \tSpriteDoorOpen( color, worldMod16 );\n        }\n        else\n        {\n            SpriteDoorClosed( color, worldMod16 );\n        }\n    }\n    if ( map.x == TILE_TRAP || map.x == TILE_TRAP_OFF )\n    {\n        SpriteTrap( color, worldMod16, map.x == TILE_TRAP ? sin( iTime * 2. ) * .25 + .75 : 0. );\n    }\n\n    if ( map.y == ITEM_KEY )\n    {\n        SpriteKey( color, worldMod16 );\n    }\n    if ( map.y == ITEM_FOOD )\n    {\n        SpriteFood( color, worldMod16 );\n    }\n    if ( map.y == ITEM_POTION )\n    {\n        SpritePotion( color, worldMod16 );\n    }\n    \n    if ( map.z == 1. )\n    {\n        SpriteRatDead( color, worldMod16 );\n    }\n    \n    if ( map.z == 2. )\n    {\n        SpriteSkeletonDead( color, worldMod16 );\n    }\n    \n\tfragColor = vec4( color, 1. );\n}","name":"Buf C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"MssXDB","filepath":"https:\/\/soundcloud.com\/space_lion\/diablo-ost-matt-uelmen-into-town","previewfilepath":"https:\/\/soundcloud.com\/space_lion\/diablo-ost-matt-uelmen-into-town","type":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\/\/ items and enemies\n\nconst float TICK_NUM\t\t\t= 10.;\nconst float TILE_FLOOR\t\t\t= 1.;\nconst float TILE_DOOR_OPEN\t\t= 2.;\nconst float TILE_STAIRS_DOWN\t= 3.;\nconst float TILE_TRAP\t\t\t= 4.;\nconst float TILE_TRAP_OFF\t\t= 5.;\nconst float TILE_WALL\t\t\t= 6.;\nconst float TILE_WALL_HOLE\t\t= 7.;\nconst float TILE_DOOR_LOCKED\t= 8.;\nconst float TILE_STAIRS_UP\t\t= 9.;\nconst float ITEM_KEY\t\t\t= 1.;\nconst float ITEM_POTION\t\t\t= 2.;\nconst float ITEM_SPAWNER\t\t= 3.;\nconst float LOG_ID_DMG\t\t\t= 1.;\nconst float LOG_ID_XP\t\t\t= 2.;\nconst float LOG_ID_LEVEL_UP\t\t= 3.;\nconst float STATE_START\t\t\t= 0.;\nconst float STATE_GAME\t\t\t= 1.;\nconst float STATE_NEXT_LEVEL\t= 2.;\nconst float STATE_GAME_OVER\t\t= 3.;\n\nconst vec2  REF_RES\t            = vec2( 200. );\n\nconst int   ENEMY_NUM\t\t\t= 3;\nconst int   LOG_NUM\t\t\t\t= 4;\n\nstruct GameState\n{\n    \/\/ 0   \n    float\ttick;\n    float \thp;\n    float \tlevel;\n    float \txp;\n    float \tkeyNum;\n    \n\t\/\/ 1\n    vec2 \tplayerPos;\n    float   playerFrame;\n    float   playerDir;\n    vec2\tbodyPos;\n    float   bodyId;\n    \n    \/\/ 2\n    float \tstate;\n    float   keyLock;\n    float \tstateTime;\n    vec2\tdespawnPos;\n    float   despawnId;\n\n    \/\/ 3\n    vec2\tenemyPos[ ENEMY_NUM ];\n    float \tenemyFrame[ ENEMY_NUM ];\n    float \tenemyDir[ ENEMY_NUM ];\n    float \tenemyHP[ ENEMY_NUM ];\n    float \tenemyId[ ENEMY_NUM ];\n    vec2    enemySpawnPos[ ENEMY_NUM ];\n    \n    \/\/ 4\n    vec2\tlogPos[ LOG_NUM ];\n    float   logLife[ LOG_NUM ];\n    float   logId[ LOG_NUM ];\n    float   logVal[ LOG_NUM ];\n};\n\nvec4 LoadValue( int x, int y )\n{\n    return texelFetch( iChannel0, ivec2( x, y ), 0 );\n}    \n\nfloat PackXY( float a, float b )\n{\n    return floor( a ) + floor( b ) \/ 256.;\n}\n\nfloat PackXY( vec2 v )\n{\n    return PackXY( v.x, v.y );\n}\n\nfloat UnpackX( float a )\n{\n    return floor( a );\n}\n\nfloat UnpackY( float a )\n{\n    return fract( a ) * 256.;\n}\n\nvec2 UnpackXY( float a )\n{\n    return vec2( UnpackX( a ), UnpackY( a ) );\n}\n\nvoid LoadState( out GameState s )\n{\n    vec4 data;\n\n    data = LoadValue( 0, 0 );\n    s.tick \t\t= data.x;\n    s.hp    \t= UnpackX( data.y );\n    s.level    \t= UnpackY( data.y );\n    s.xp        = data.z;\n    s.keyNum    = data.w;\n    \n    data = LoadValue( 1, 0 );\n    s.playerPos   = UnpackXY( data.x );\n    s.playerFrame = UnpackX( data.y );\n    s.playerDir   = UnpackY( data.y );\n    s.bodyPos\t  = UnpackXY( data.z );\n    s.bodyId      = data.w;\n    \n    data = LoadValue( 2, 0 );\n    s.state      = UnpackX( data.x );\n    s.keyLock    = UnpackY( data.x );\n    s.stateTime  = data.y;\n    s.despawnPos = UnpackXY( data.z );\n    s.despawnId  = data.w;\n\n    for ( int i = 0; i < ENEMY_NUM; ++i )\n    {\n        data = LoadValue( 3, i );\n        s.enemyPos[ i ]      = UnpackXY( data.x );\n        s.enemyFrame[ i ]    = UnpackX( data.y );\n        s.enemyDir[ i ]      = UnpackY( data.y );\n        s.enemyHP[ i ]       = UnpackX( data.z );\n        s.enemyId[ i ]       = UnpackY( data.z );\n        s.enemySpawnPos[ i ] = UnpackXY( data.w );\n    }\n    \n    for ( int i = 0; i < LOG_NUM; ++i )\n    {\n\t\tdata = LoadValue( 4, i );\n    \ts.logPos[ i ]  = data.xy;\n        s.logLife[ i ] = data.z;\n        s.logId[ i ]   = UnpackX( data.w );\n        s.logVal[ i ]  = UnpackY( data.w );\n    }    \n}\n\nfloat saturate( float x )\n{\n    return clamp( x, 0., 1. );\n}\n\nfloat Smooth( float x )\n{\n\treturn smoothstep( 0., 1., saturate( x ) );   \n}\n\nvoid SpriteRat( inout vec3 color, vec2 p )\n{\n\tp -= vec2( 0., 1. );    \n    \n    int v = 0;\n\tv = p.y == 11. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 33554946 : ( p.x < 12. ? 131586 : 0 ) ) ) : v;\n\tv = p.y == 10. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 67241730 : ( p.x < 12. ? 33817604 : 0 ) ) ) : v;\n\tv = p.y == 9. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 67371520 : ( p.x < 12. ? 33948678 : 0 ) ) ) : v;\n\tv = p.y == 8. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 67371520 : ( p.x < 12. ? 67372036 : 2 ) ) ) : v;\n\tv = p.y == 7. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 67372034 : ( p.x < 12. ? 67372036 : 2 ) ) ) : v;\n\tv = p.y == 6. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 67372034 : ( p.x < 12. ? 16843010 : 5 ) ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 33554432 : ( p.x < 8. ? 67372036 : ( p.x < 12. ? 66052 : 0 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 33554432 : ( p.x < 8. ? 67372036 : ( p.x < 12. ? 197635 : 0 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 16777216 : ( p.x < 8. ? 33686532 : ( p.x < 12. ? 33817604 : 0 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 16777216 : ( p.x < 8. ? 67372034 : ( p.x < 12. ? 33817602 : 0 ) ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 16777216 : ( p.x < 8. ? 67371522 : ( p.x < 12. ? 16909313 : 0 ) ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 117901063 : ( p.x < 8. ? 50397441 : ( p.x < 12. ? 83951877 : 0 ) ) ) : v;\n    float i = float( ( v >> int( 8.0 * p.x ) ) & 255 );\n    color = i == 1. ? vec3( 0.16, 0.11, 0.071 ) : color;\n    color = i == 2. ? vec3( 0.33, 0.26, 0.18 ) : color;\n    color = i == 3. ? vec3( 0.58, 0.25, 0.24 ) : color;\n    color = i == 4. ? vec3( 0.51, 0.44, 0.35 ) : color;\n    color = i == 5. ? vec3( 0.81, 0.31, 0.33 ) : color;\n    color = i == 6. ? vec3( 1, 0.4, 0.3 ) : color;\n    color = i == 7. ? vec3( 0.86, 0.53, 0.55 ) : color;\n}\n\nvoid SpriteRatAttack( inout vec3 color, vec2 p )\n{\n\tp -= vec2( 0., 1. );    \n    \n    int v = 0;\n\tv = p.y == 10. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 33685504 : ( p.x < 12. ? 33686016 : 2 ) ) ) : v;\n\tv = p.y == 9. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 117571584 : ( p.x < 12. ? 67372034 : 516 ) ) ) : v;\n\tv = p.y == 8. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 67240448 : ( p.x < 12. ? 67503108 : 518 ) ) ) : v;\n\tv = p.y == 7. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 67372034 : ( p.x < 12. ? 67372036 : 132100 ) ) ) : v;\n\tv = p.y == 6. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 67372034 : ( p.x < 12. ? 67372036 : 132100 ) ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 33554432 : ( p.x < 8. ? 67372036 : ( p.x < 12. ? 83952644 : 393477 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 33554432 : ( p.x < 8. ? 67372036 : ( p.x < 12. ? 50397953 : 0 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 16777216 : ( p.x < 8. ? 33686532 : ( p.x < 12. ? 33817604 : 0 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 16777216 : ( p.x < 8. ? 67372034 : ( p.x < 12. ? 33817602 : 0 ) ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 16777216 : ( p.x < 8. ? 67371522 : ( p.x < 12. ? 16909313 : 0 ) ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 117901063 : ( p.x < 8. ? 50397441 : ( p.x < 12. ? 100729094 : 0 ) ) ) : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = i == 1. ? vec3( 0.16, 0.11, 0.071 ) : color;\n    color = i == 2. ? vec3( 0.33, 0.26, 0.18 ) : color;\n    color = i == 3. ? vec3( 0.58, 0.25, 0.24 ) : color;\n    color = i == 4. ? vec3( 0.51, 0.44, 0.35 ) : color;\n    color = i == 5. ? vec3( 1, 0.09, 0.09 ) : color;\n    color = i == 6. ? vec3( 0.9, 0.36, 0.31 ) : color;\n    color = i == 7. ? vec3( 0.86, 0.53, 0.55 ) : color;\n}\n\nvoid SpriteRatWalk( inout vec3 color, vec2 p )\n{\n    p -= vec2( 0., 1. );\n    \n    int v = 0;\n\tv = p.y == 12. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 33554946 : ( p.x < 12. ? 131586 : 0 ) ) ) : v;\n\tv = p.y == 11. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 67241730 : ( p.x < 12. ? 33817604 : 0 ) ) ) : v;\n\tv = p.y == 10. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 67371520 : ( p.x < 12. ? 33948678 : 0 ) ) ) : v;\n\tv = p.y == 9. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 67371520 : ( p.x < 12. ? 67372036 : 2 ) ) ) : v;\n\tv = p.y == 8. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 67372034 : ( p.x < 12. ? 67372036 : 2 ) ) ) : v;\n\tv = p.y == 7. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 67372034 : ( p.x < 12. ? 16843010 : 5 ) ) ) : v;\n\tv = p.y == 6. ? ( p.x < 4. ? 33554432 : ( p.x < 8. ? 67372036 : ( p.x < 12. ? 66052 : 0 ) ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 33554432 : ( p.x < 8. ? 67372036 : ( p.x < 12. ? 197635 : 0 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 16777216 : ( p.x < 8. ? 33686532 : ( p.x < 12. ? 33817604 : 0 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 16777216 : ( p.x < 8. ? 67372034 : ( p.x < 12. ? 33817602 : 0 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 16777216 : ( p.x < 8. ? 67371522 : ( p.x < 12. ? 16909313 : 0 ) ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 117440512 : ( p.x < 8. ? 16974081 : ( p.x < 12. ? 65793 : 0 ) ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 460551 : ( p.x < 8. ? 83886080 : ( p.x < 12. ? 327680 : 0 ) ) ) : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = i == 1. ? vec3( 0.16, 0.11, 0.071 ) : color;\n    color = i == 2. ? vec3( 0.33, 0.26, 0.18 ) : color;\n    color = i == 3. ? vec3( 0.58, 0.25, 0.24 ) : color;\n    color = i == 4. ? vec3( 0.51, 0.44, 0.35 ) : color;\n    color = i == 5. ? vec3( 0.81, 0.31, 0.33 ) : color;\n    color = i == 6. ? vec3( 1, 0.4, 0.3 ) : color;\n    color = i == 7. ? vec3( 0.86, 0.53, 0.55 ) : color;\n}\n\nvoid SpriteSkeleton( inout vec3 color, vec2 p )\n{\n    p -= vec2( 4., 1. );\n    p = p.x < 0. ? vec2( 8. ) : p;        \n    \n    int v = 0;\n\tv = p.y == 13. ? ( p.x < 4. ? 101056512 : ( p.x < 8. ? 101058054 : 0 ) ) : v;\n\tv = p.y == 12. ? ( p.x < 4. ? 117900800 : ( p.x < 8. ? 117901063 : ( p.x < 12. ? 6 : 0 ) ) ) : v;\n\tv = p.y == 11. ? ( p.x < 4. ? 67568384 : ( p.x < 8. ? 67372036 : ( p.x < 12. ? 2 : 0 ) ) ) : v;\n\tv = p.y == 10. ? ( p.x < 4. ? 117900032 : ( p.x < 8. ? 17237761 : ( p.x < 12. ? 6 : 0 ) ) ) : v;\n\tv = p.y == 9. ? ( p.x < 4. ? 117571584 : ( p.x < 8. ? 117704455 : ( p.x < 12. ? 6 : 0 ) ) ) : v;\n\tv = p.y == 8. ? ( p.x < 4. ? 33554432 : ( p.x < 8. ? 50726403 : 0 ) ) : v;\n\tv = p.y == 7. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 33554434 : 0 ) ) : v;\n\tv = p.y == 6. ? ( p.x < 4. ? 117835264 : ( p.x < 8. ? 101123847 : 0 ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 67108870 : ( p.x < 8. ? 328965 : ( p.x < 12. ? 2 : 0 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 1539 : ( p.x < 8. ? 33554944 : ( p.x < 12. ? 2 : 0 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 101057282 : ( p.x < 8. ? 101058054 : ( p.x < 12. ? 2 : 0 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 196608 : ( p.x < 8. ? 393216 : 0 ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 1536 : ( p.x < 8. ? 393216 : 0 ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 771 : ( p.x < 8. ? 50528256 : 0 ) ) : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = i == 1. ? vec3( 0 ) : color;\n    color = i == 2. ? vec3( 0.49 ) : color;\n    color = i == 3. ? vec3( 0.64 ) : color;\n    color = i == 4. ? vec3( 0.7 ) : color;\n    color = i == 5. ? vec3( 0.8 ) : color;\n    color = i == 6. ? vec3( 0.81 ) : color;\n    color = i == 7. ? vec3( 0.9 ) : color;\n}\n\nvoid SpriteSkeletonWalk( inout vec3 color, vec2 p )\n{\n    p -= vec2( 4., 1. );\n    p = p.x < 0. ? vec2( 8. ) : p;     \n    \n    int v = 0;\n\tv = p.y == 13. ? ( p.x < 4. ? 101056512 : ( p.x < 8. ? 101058054 : 0 ) ) : v;\n\tv = p.y == 12. ? ( p.x < 4. ? 117900800 : ( p.x < 8. ? 117901063 : ( p.x < 12. ? 6 : 0 ) ) ) : v;\n\tv = p.y == 11. ? ( p.x < 4. ? 67568384 : ( p.x < 8. ? 67372036 : ( p.x < 12. ? 2 : 0 ) ) ) : v;\n\tv = p.y == 10. ? ( p.x < 4. ? 117900032 : ( p.x < 8. ? 17237761 : ( p.x < 12. ? 6 : 0 ) ) ) : v;\n\tv = p.y == 9. ? ( p.x < 4. ? 117571584 : ( p.x < 8. ? 117704455 : ( p.x < 12. ? 6 : 0 ) ) ) : v;\n\tv = p.y == 8. ? ( p.x < 4. ? 33554432 : ( p.x < 8. ? 50726403 : 0 ) ) : v;\n\tv = p.y == 7. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 33554434 : 0 ) ) : v;\n\tv = p.y == 6. ? ( p.x < 4. ? 117835264 : ( p.x < 8. ? 101123847 : 0 ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 67108870 : ( p.x < 8. ? 328965 : ( p.x < 12. ? 2 : 0 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 393984 : ( p.x < 8. ? 33554944 : ( p.x < 12. ? 2 : 0 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 100860416 : ( p.x < 8. ? 101058054 : ( p.x < 12. ? 2 : 0 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 196608 : ( p.x < 8. ? 100990976 : 0 ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 1536 : ( p.x < 8. ? 393984 : 0 ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 197376 : 0 ) : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = i == 1. ? vec3( 0 ) : color;\n    color = i == 2. ? vec3( 0.49 ) : color;\n    color = i == 3. ? vec3( 0.64 ) : color;\n    color = i == 4. ? vec3( 0.7 ) : color;\n    color = i == 5. ? vec3( 0.8 ) : color;\n    color = i == 6. ? vec3( 0.81 ) : color;\n    color = i == 7. ? vec3( 0.9 ) : color;\n}\n\nvoid SpriteSkeletonAttack( inout vec3 color, vec2 p )\n{\n    p -= vec2( 4., 1. );\n    p = p.x < 0. ? vec2( 10. ) : p;    \n    \n    int v = 0;\n\tv = p.y == 13. ? ( p.x < 4. ? 100663296 : ( p.x < 8. ? 101058054 : ( p.x < 12. ? 6 : 0 ) ) ) : v;\n\tv = p.y == 12. ? ( p.x < 4. ? 117833728 : ( p.x < 8. ? 117901063 : ( p.x < 12. ? 1543 : 0 ) ) ) : v;\n\tv = p.y == 11. ? ( p.x < 4. ? 117637120 : ( p.x < 8. ? 67372036 : ( p.x < 12. ? 516 : 0 ) ) ) : v;\n\tv = p.y == 10. ? ( p.x < 4. ? 117637120 : ( p.x < 8. ? 117899527 : ( p.x < 12. ? 1537 : 0 ) ) ) : v;\n\tv = p.y == 9. ? ( p.x < 4. ? 33554432 : ( p.x < 8. ? 67569415 : ( p.x < 12. ? 1543 : 0 ) ) ) : v;\n\tv = p.y == 8. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 101057794 : ( p.x < 12. ? 3 : 0 ) ) ) : v;\n\tv = p.y == 7. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 512 : ( p.x < 12. ? 2 : 0 ) ) ) : v;\n\tv = p.y == 6. ? ( p.x < 4. ? 101058048 : ( p.x < 8. ? 100861446 : 0 ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 84213760 : ( p.x < 8. ? 50464005 : ( p.x < 12. ? 2 : 0 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 33554944 : ( p.x < 12. ? 2 : 0 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 101056512 : ( p.x < 8. ? 101058054 : 0 ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 196608 : ( p.x < 8. ? 393216 : 0 ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 1536 : ( p.x < 8. ? 393216 : 0 ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 771 : ( p.x < 8. ? 50528256 : 0 ) ) : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = i == 1. ? vec3( 0 ) : color;\n    color = i == 2. ? vec3( 0.49 ) : color;\n    color = i == 3. ? vec3( 0.64 ) : color;\n    color = i == 4. ? vec3( 0.7 ) : color;\n    color = i == 5. ? vec3( 0.8 ) : color;\n    color = i == 6. ? vec3( 0.81 ) : color;\n    color = i == 7. ? vec3( 0.9 ) : color;\n}\n\nvoid SpriteWarriorHead( inout vec3 color, vec2 p )\n{\n    int v = 0;\n\tv = p.y == 7. ? ( p.x < 4. ? 0 : ( p.x < 8. ? 33686016 : ( p.x < 12. ? 2 : 0 ) ) ) : v;\n\tv = p.y == 6. ? ( p.x < 4. ? 33685504 : ( p.x < 8. ? 67372034 : ( p.x < 12. ? 516 : 0 ) ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 67371520 : ( p.x < 8. ? 67372036 : ( p.x < 12. ? 132100 : 0 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 67239936 : ( p.x < 8. ? 117901062 : ( p.x < 12. ? 132103 : 0 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 84148736 : ( p.x < 8. ? 84214021 : ( p.x < 12. ? 769 : 0 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 84148992 : ( p.x < 8. ? 101057798 : ( p.x < 12. ? 1029 : 0 ) ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 67239936 : ( p.x < 8. ? 67372038 : ( p.x < 12. ? 1028 : 0 ) ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 67239936 : ( p.x < 8. ? 33686020 : ( p.x < 12. ? 514 : 0 ) ) ) : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = i == 1. ? vec3( 0 ) : color;\n    color = i == 2. ? vec3( 0.64, 0.2, 0.047 ) : color;\n    color = i == 3. ? vec3( 0.52, 0.35, 0.22 ) : color;\n    color = i == 4. ? vec3( 0.77, 0.47, 0.29 ) : color;\n    color = i == 5. ? vec3( 0.72, 0.59, 0.47 ) : color;\n    color = i == 6. ? vec3( 0.86, 0.71, 0.59 ) : color;\n    color = i == 7. ? vec3( 1, 0.85, 0.75 ) : color;\n}\n\nvoid SpriteWarriorStand( inout vec3 color, vec2 p )\n{\n    int v = 0;\n\tv = p.y == 6. ? ( p.x < 4. ? 101057536 : ( p.x < 8. ? 33620485 : ( p.x < 12. ? 770 : 0 ) ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 16908802 : ( p.x < 8. ? 117901061 : ( p.x < 12. ? 261 : 0 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 17040897 : ( p.x < 8. ? 33686018 : ( p.x < 12. ? 258 : 0 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 33620736 : ( p.x < 8. ? 117901061 : ( p.x < 12. ? 770 : 0 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 33619968 : ( p.x < 8. ? 33685761 : ( p.x < 12. ? 1 : 0 ) ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 16908544 : ( p.x < 8. ? 33619968 : ( p.x < 12. ? 1 : 0 ) ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 16843008 : ( p.x < 8. ? 16842752 : ( p.x < 12. ? 1 : 0 ) ) ) : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = i == 1. ? vec3( 0.09, 0.11, 0.18 ) : color;\n    color = i == 2. ? vec3( 0.28, 0.35, 0.45 ) : color;\n    color = i == 3. ? vec3( 1, 0.36, 0.043 ) : color;\n    color = i == 4. ? vec3( 1, 0.65, 0.25 ) : color;\n    color = i == 5. ? vec3( 0.54, 0.67, 0.73 ) : color;\n    color = i == 6. ? vec3( 1, 0.85, 0.56 ) : color;\n    color = i == 7. ? vec3( 0.91, 1, 1 ) : color;\n}\n\nvoid SpriteWarriorWalk( inout vec3 color, vec2 p )\n{\n    int v = 0;\n\tv = p.y == 6. ? ( p.x < 4. ? 101057536 : ( p.x < 8. ? 33620485 : ( p.x < 12. ? 770 : 0 ) ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 33620481 : ( p.x < 8. ? 117901061 : ( p.x < 12. ? 261 : 0 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 67371521 : ( p.x < 8. ? 33686018 : ( p.x < 12. ? 257 : 0 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 33751296 : ( p.x < 8. ? 33687301 : ( p.x < 12. ? 1797 : 0 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 33619968 : ( p.x < 8. ? 33620225 : ( p.x < 12. ? 1 : 0 ) ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 16842752 : ( p.x < 8. ? 16842752 : 0 ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 16842752 : 0 ) : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = i == 1. ? vec3( 0.09, 0.11, 0.18 ) : color;\n    color = i == 2. ? vec3( 0.29, 0.34, 0.45 ) : color;\n    color = i == 3. ? vec3( 1, 0.36, 0.043 ) : color;\n    color = i == 4. ? vec3( 1, 0.62, 0.23 ) : color;\n    color = i == 5. ? vec3( 0.54, 0.67, 0.73 ) : color;\n    color = i == 6. ? vec3( 1, 0.91, 0.62 ) : color;\n    color = i == 7. ? vec3( 0.87, 1, 1 ) : color;\n}\n\nvoid SpriteWarriorAttack( inout vec3 color, vec2 p )\n{\n    int v = 0;\n\tv = p.y == 6. ? ( p.x < 4. ? 101057536 : ( p.x < 8. ? 16910085 : ( p.x < 12. ? 1026 : 0 ) ) ) : v;\n\tv = p.y == 5. ? ( p.x < 4. ? 33687298 : ( p.x < 8. ? 117901061 : ( p.x < 12. ? 67503367 : 0 ) ) ) : v;\n\tv = p.y == 4. ? ( p.x < 4. ? 16844292 : ( p.x < 8. ? 33686018 : ( p.x < 12. ? 50528770 : 0 ) ) ) : v;\n\tv = p.y == 3. ? ( p.x < 4. ? 16777987 : ( p.x < 8. ? 117901058 : ( p.x < 12. ? 261 : 0 ) ) ) : v;\n\tv = p.y == 2. ? ( p.x < 4. ? 16777216 : ( p.x < 8. ? 33620226 : ( p.x < 12. ? 263 : 0 ) ) ) : v;\n\tv = p.y == 1. ? ( p.x < 4. ? 33619968 : ( p.x < 8. ? 16777217 : ( p.x < 12. ? 258 : 0 ) ) ) : v;\n\tv = p.y == 0. ? ( p.x < 4. ? 16842752 : ( p.x < 8. ? 16777217 : ( p.x < 12. ? 257 : 0 ) ) ) : v;\n    float i = float( ( v >> int( 8. * p.x ) ) & 255 );\n    color = i == 1. ? vec3( 0.09, 0.11, 0.18 ) : color;\n    color = i == 2. ? vec3( 0.28, 0.35, 0.45 ) : color;\n    color = i == 3. ? vec3( 1, 0.36, 0.043 ) : color;\n    color = i == 4. ? vec3( 1, 0.65, 0.25 ) : color;\n    color = i == 5. ? vec3( 0.54, 0.67, 0.73 ) : color;\n    color = i == 6. ? vec3( 1, 0.85, 0.56 ) : color;\n    color = i == 7. ? vec3( 0.91, 1, 1 ) : color;\n}\n\nvec2 FrameOffset( float frame, float tick )\n{\n    vec2 ret = vec2( 0. );\n    ret.x = frame == 1. ? 1. : ( frame == 2. ? -1. : 0. );\n    ret.y = frame == 3. ? 1. : ( frame == 4. ? -1. : 0. );\n    return floor( 16. * ret * ( tick \/ TICK_NUM ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    GameState s;\n    LoadState( s );    \n    \n    vec2 playerPos = s.playerPos * 16. + FrameOffset( s.playerFrame, s.tick ); \n    \n    vec2 resMult\t= floor( iResolution.xy \/ REF_RES );\n    float resRcp    = 1. \/ max( min( resMult.x, resMult.y ), 1. );\n    vec2 screenSize = floor( iResolution.xy * resRcp );\n    vec2 pixel      = floor( fragCoord.xy * resRcp );\n\tvec2 camera     = clamp( playerPos - floor( screenSize \/ 2. ), vec2( -32. ), vec2( 32. * 16. + 32. ) - screenSize );\n    vec2 world      = pixel + camera;\n    vec2 tile\t\t= floor( world \/ 16. );\n    vec2 worldMod16 = floor( mod( world, 16. ) );\n    vec4 map\t\t= texelFetch( iChannel1, ivec2( tile ), 0 );\n    float tick2     = s.tick > TICK_NUM \/ 2. ? 1. : 0.;\n    \n    vec3 color = texelFetch( iChannel2, ivec2( fragCoord ), 0 ).xyz;\n    \n    vec2 warrior = world - playerPos;\n    warrior.x = s.playerDir > 0. ? 13. - warrior.x : warrior.x - 2.;\n    warrior.y -= 1.;\n    if ( warrior.x >= 0. && warrior.y >= 0. && warrior.x < 16. && warrior.y < 16. \n         && s.hp > 0. )\n    {\n        float walk = s.playerFrame > 0. && tick2 == 1. ? 1. : 0.;\n        if ( warrior.x >= 1. - walk )\n        {\n        \tSpriteWarriorHead( color, warrior - vec2( 1. - walk, 7. ) );   \n        }\n\n        if ( s.playerFrame == 6. && tick2 == 1. )\n        {\n            SpriteWarriorAttack( color, warrior );\n        }        \n        else if ( walk == 1. )\n        {\n\t\t\tSpriteWarriorWalk( color, warrior );\n        }\n        else if ( warrior.x >= 1. )\n        {\n\t\t\tSpriteWarriorStand( color, warrior - vec2( 1., 0. ) );\n        }\n    }\n    \n    for ( int i = 0; i < ENEMY_NUM; ++i )\n    {\n    \tvec3 enemyColor = color;\n        \n        vec2 enemy = world - s.enemyPos[ i ] * 16. + FrameOffset( s.enemyFrame[ i ], s.tick );\n\t\tenemy.x = s.enemyDir[ i ] > 0. ? 15. - enemy.x : enemy.x;\n        if ( enemy.x >= 0. && enemy.y >= 0. && enemy.x < 16. && enemy.y < 16. && s.enemyPos[ i ].x > 0. )\n    \t{\n            if ( s.enemyFrame[ i ] == 5. && tick2 == 1. )\n            {\n                if ( s.enemyId[ i ] == 0. )\n                \tSpriteRatAttack( enemyColor, enemy );\n                else\n                    SpriteSkeletonAttack( enemyColor, enemy );\n            }\n            else if ( s.enemyFrame[ i ] > 0. && tick2 == 1. )\n            {\n                if ( s.enemyId[ i ] == 0. )\n                \tSpriteRatWalk( enemyColor, enemy );\n                else\n                \tSpriteSkeletonWalk( enemyColor, enemy );\n            }\n            else\n            {\n                if ( s.enemyId[ i ] == 0. )\n        \t\t\tSpriteRat( enemyColor, enemy );\n                else\n                    SpriteSkeleton( enemyColor, enemy );\n\t\t\t}\n        }\n        \n        \/\/ fog of war\n        float dist = length( playerPos - s.enemyPos[ i ] * 16. );\n\t\tcolor = mix( color, enemyColor, saturate( ( 64. + 16. - dist ) \/ 32. ) );\n    }\n    \n\tfragColor = vec4( color, 1. );\n}","name":"Buf D","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"XltGDr","date":"1469367906","viewed":18684,"name":"[SH16C] Contra","username":"knarkowicz","description":"Brings me back memories of the 90s in grim Eastern Europe (just after Soviet Union fell). Loved to watch western action movies (Rambo!) and of course to play Contra! Can you finish 1st lvl?\nA\/Q - fire S\/W - jump Arrows - move, jump, lie down, dive","likes":156,"published":3,"flags":112,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"\/media\/previz\/buffer03.png","previewfilepath":"\/media\/previz\/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"lsjGzR","filepath":"https:\/\/soundcloud.com\/somari_musics\/nes_contra_jungle-stage","previewfilepath":"https:\/\/soundcloud.com\/somari_musics\/nes_contra_jungle-stage","type":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define POST_PROCESS\n\nvec2 CRTCurveUV( vec2 uv, float str )\n{\n    uv = uv * 2.0 - 1.0;\n    vec2 offset = ( str * abs( uv.yx ) ) \/ vec2( 6.0, 4.0 );\n    uv = uv + uv * offset * offset;\n    uv = uv * 0.5 + 0.5;\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 baseUV = fragCoord.xy \/ iResolution.xy;\n    \n#ifdef POST_PROCESS    \n    vec2 uv = CRTCurveUV( baseUV, 0.5 );\n    \n    \/\/ chromatic abberation\n\tfloat caStrength    = 0.003;\n    vec2 caOffset       = uv - 0.5;\n    \/\/caOffset = vec2( 1.0, 0.0 ) * 0.3;\n    vec2 caUVG          = uv + caOffset * caStrength;\n    vec2 caUVB          = uv + caOffset * caStrength * 2.0;\n    \n    vec3 color;\n    color.x = texture( iChannel0, uv ).x;\n    color.y = texture( iChannel0, caUVG ).y;\n    color.z = texture( iChannel0, caUVB ).z;\n    \n    uv = CRTCurveUV( baseUV, 1.0 );\n    if ( uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0 )\n    {\n        color = vec3( 0.0, 0.0, 0.0 );\n    }    \n    float vignette = uv.x * uv.y * ( 1.0 - uv.x ) * ( 1.0 - uv.y );\n    vignette = clamp( pow( 16.0 * vignette, 0.3 ), 0.0, 1.0 );\n    color *= vignette * 1.1;\n    \n#else\n    vec3 color = texture( iChannel0, baseUV ).xyz;\n    \n#endif\n    \n    fragColor = vec4( color, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"\/presets\/tex00.jpg","previewfilepath":"\/presets\/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ Gameplay\n\n\/\/ debug cheats\n\/\/#define KONAMI_CODE\n\/\/#define SPEED_RUN\n\/\/#define GOD_MODE\n\n\/\/ storage\nconst vec2 txPlayer \t\t\t= vec2( 0.0, 0.0 ); \t\/\/ xy - pos, z - jump start, w - jump dir\nconst vec2 txPlayerState\t\t= vec2( 1.0, 0.0 ); \t\/\/ x - state, y - frame, z - jump tick, w - lifes\nconst vec2 txPlayerDir\t\t\t= vec2( 2.0, 0.0 ); \t\/\/ xy - dir, z - flip, w - immortality\nconst vec2 txPlayerWeapon\t\t= vec2( 3.0, 0.0 ); \t\/\/ x - weapon, y - weapon cooldown, z - weapon fire rate, w - weapon bullet num\nconst vec2 txCamera \t\t\t= vec2( 4.0, 0.0 ); \t\/\/ x - cam offset, y - spawn counter, z - soldier spawn counter\nconst vec2 txSoldier0 \t\t\t= vec2( 5.0, 0.0 ); \t\/\/ xy - pos, z - flip\nconst vec2 txSoldier1 \t\t\t= vec2( 5.0, 1.0 ); \t\/\/ xy - pos, z - flip\nconst vec2 txSoldier2 \t\t\t= vec2( 5.0, 2.0 ); \t\/\/ xy - pos, z - flip\nconst vec2 txSoldier0State \t\t= vec2( 6.0, 0.0 ); \t\/\/ x - state, y - frame, z - jump tick\nconst vec2 txSoldier1State \t\t= vec2( 6.0, 1.0 ); \t\/\/ x - state, y - frame, z - jump tick\nconst vec2 txSoldier2State \t\t= vec2( 6.0, 2.0 ); \t\/\/ x - state, y - frame, z - jump tick\nconst vec2 txSniper\t \t\t\t= vec2( 7.0, 0.0 ); \t\/\/ xy - pos, z - flip, w - weapon cooldown\nconst vec2 txPlayerBullet0 \t\t= vec2( 8.0, 0.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txPlayerBullet1 \t\t= vec2( 8.0, 1.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txPlayerBullet2 \t\t= vec2( 8.0, 2.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txPlayerBullet3 \t\t= vec2( 8.0, 3.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txPlayerBullet4 \t\t= vec2( 8.0, 4.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txPlayerBullet5 \t\t= vec2( 8.0, 5.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txEnemyBullet0 \t\t= vec2( 9.0, 0.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txEnemyBullet1 \t\t= vec2( 9.0, 1.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txEnemyBullet2 \t\t= vec2( 9.0, 2.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txEnemyBullet3 \t\t= vec2( 9.0, 3.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txExplosion \t\t\t= vec2( 10.0, 0.0 ); \t\/\/ xy - pos, z - frame\nconst vec2 txHit \t\t\t\t= vec2( 11.0, 0.0 ); \t\/\/ xy - pos, z - frame\nconst vec2 txTurret0\t\t\t= vec2( 12.0, 0.0 ); \t\/\/ xy - pos, z - angle\nconst vec2 txTurret1\t\t\t= vec2( 12.0, 1.0 ); \t\/\/ xy - pos, z - angle\nconst vec2 txTurret0State\t\t= vec2( 13.0, 0.0 ); \t\/\/ x - HP, y - weapon cooldown\nconst vec2 txTurret1State\t\t= vec2( 13.0, 1.0 ); \t\/\/ x - HP, y - weapon cooldown\nconst vec2 txPowerUp\t\t\t= vec2( 14.0, 0.0 ); \t\/\/ xy - pos, z - frame\nconst vec2 txPowerUpState\t\t= vec2( 15.0, 0.0 ); \t\/\/ x - state, y - initial height, z - jump tick\nconst vec2 txBossCore\t\t\t= vec2( 16.0, 0.0 ); \t\/\/ xy - pos, z - HP\nconst vec2 txBossCannon0\t\t= vec2( 17.0, 0.0 ); \t\/\/ xy - pos, z - cooldown, w - HP\nconst vec2 txBossCannon1\t\t= vec2( 17.0, 1.0 ); \t\/\/ xy - pos, z - cooldown, w - HP\nconst vec2 txBossBullet0\t\t= vec2( 18.0, 0.0 ); \t\/\/ xy - pos, zw - velocity\nconst vec2 txBossBullet1\t\t= vec2( 18.0, 1.0 ); \t\/\/ xy - pos, zw - velocity\nconst vec2 txGameState\t\t\t= vec2( 19.0, 0.0 ); \t\/\/ x - state, y - state tick\nconst vec2 txBridge\t\t\t\t= vec2( 20.0, 0.0 ); \t\/\/ x - draw start, y - explode tick\n\n#ifdef KONAMI_CODE\n\tconst float PLAYER_LIFE_NUM\t\t= 10.0;\n#else\n\tconst float PLAYER_LIFE_NUM\t\t= 3.0;\n#endif\n\n#ifdef SPEED_RUN\n\tconst float PLAYER_RUN_SPEED \t= 5.0;\n#else\n\tconst float PLAYER_RUN_SPEED \t= 1.0;\n#endif\n\nconst float MATH_PI \t\t\t\t= 3.14159265359;\nconst float NES_RES_X\t\t\t\t= 224.0;\nconst float NES_RES_Y \t\t\t\t= 192.0;\nconst float KEY_A    \t\t\t\t= 65.5 \/ 256.0;\nconst float KEY_Q    \t\t\t\t= 81.5 \/ 256.0;\nconst float KEY_S    \t\t\t\t= 83.5 \/ 256.0;\nconst float KEY_W    \t\t\t\t= 87.5 \/ 256.0;\nconst float KEY_LEFT  \t\t\t\t= 37.5 \/ 256.0;\nconst float KEY_UP    \t\t\t\t= 38.5 \/ 256.0;\nconst float KEY_RIGHT \t\t\t\t= 39.5 \/ 256.0;\nconst float KEY_DOWN  \t\t\t\t= 40.5 \/ 256.0;\nconst float STATE_RUN\t\t\t\t= 0.0;\nconst float STATE_PRONE \t\t\t= 1.0;\nconst float STATE_JUMP \t\t\t\t= 2.0;\nconst float STATE_FALL \t\t\t\t= 3.0;\nconst float STATE_WATER \t\t\t= 4.0;\nconst float STATE_UNDER_WATER \t\t= 5.0;\nconst float WEAPON_RIFLE\t\t\t= 0.0;\nconst float WEAPON_MACHINE_GUN\t\t= 1.0;\nconst float RIFLE_FIRE_RATE\t\t\t= 20.0;\nconst float RIFLE_BULLET_NUM\t\t= 4.0;\nconst float MACHINE_GUN_FIRE_RATE\t= 10.0;\nconst float MACHINE_GUN_BULLET_NUM\t= 6.0;\nconst float SNIPER_FIRE_RATE\t\t= 160.0;\nconst float TURRET_FIRE_RATE\t\t= 100.0;\nconst float PLAYER_SPAWN_HEIGHT\t\t= 200.0;\nconst float PLAYER_JUMP_HEIGHT\t\t= 16.0 * 3.0;\nconst float PLAYER_IMMORTALITY_LEN\t= 60.0 * 3.0;\nconst float PLAYER_RUN_ANIM_SPEED \t= 0.13;\nconst float PLAYER_JUMP_ANIM_SPEED\t= 0.13;\nconst float PLAYER_FALL_SPEED \t\t= 3.0;\nconst float PLAYER_BULLET_SPEED\t\t= 3.0;\nconst float PLAYER_HIT_BOX_SIZE_MUL\t= 0.7;\nconst float ENEMY_RUN_SPEED \t\t= 1.0;\nconst float ENEMY_BULLET_SPEED \t\t= 1.0;\nconst float ENEMY_ANIM_SPEED\t\t= 0.13;\nconst float SOLDIER_SPAWN_RATE\t\t= 180.0;\nconst float BOSS_CORE_HP\t\t\t= 32.0;\nconst float BOSS_CANNON_HP\t\t\t= 8.0;\nconst float BOSS_CANNON_FIRE_RATE\t= 120.0;\nconst float WATER_HEIGHT\t\t\t= 8.0;\nconst float WATER_END\t\t\t\t= 32.0 * 63.0;\nconst float BRIDGE_0_START_TILE\t\t= 30.0;\nconst float BRIDGE_0_END_TILE\t\t= 35.0;\nconst float BRIDGE_1_START_TILE\t\t= 40.0;\nconst float BRIDGE_1_END_TILE\t\t= 45.0;\nconst float BRIGDE_EXPLODE_TIME\t\t= 70.0;\nconst float CAMERA_END\t\t\t\t= 32.0 * 102.0;\nconst float PLAYER_END\t\t\t\t= 32.0 * 108.0 + 16.0;\nconst float SOLDIER_SPAWN_END\t\t= 32.0 * 99.0 - 32.0 * 2.0;\nconst vec2 \tBILL_PRONE_SIZE\t\t\t= vec2( 32.0, 18.0 );\nconst vec2 \tBILL_RUN_SIZE\t\t\t= vec2( 24.0, 34.0 );\nconst vec2 \tBILL_JUMP_SIZE\t\t\t= vec2( 20.0, 20.0 );\nconst vec2 \tSOLDIER_SIZE \t\t\t= vec2( 16.0, 32.0 );\nconst vec2 \tSNIPER_SIZE\t\t\t\t= vec2( 24.0, 32.0 );\nconst vec2 \tBULLET_SIZE\t\t\t\t= vec2( 3.0,  3.0  );\nconst vec2 \tPOWER_BULLET_SIZE\t\t= vec2( 5.0,  5.0  );\nconst vec2 \tTURRET_SIZE\t\t\t\t= vec2( 32.0, 32.0 );\nconst vec2 \tPOWER_UP_SIZE\t\t\t= vec2( 24.0, 14.0 );\nconst vec2 \tBOSS_CORE_SIZE\t\t\t= vec2( 24.0, 31.0 );\nconst vec2 \tBOSS_CANNON_SIZE\t\t= vec2( 14.0, 6.0 );\nconst float TURRET_HP\t\t\t\t= 8.0;\nconst float GAME_STATE_TITLE\t\t= 0.0;\nconst float GAME_STATE_LEVEL\t\t= 1.0;\nconst float GAME_STATE_LEVEL_DIE\t= 2.0;\nconst float GAME_STATE_LEVEL_WIN\t= 3.0;\nconst float GAME_STATE_GAME_OVER\t= 4.0;\nconst float GAME_STATE_VICTORY\t\t= 5.0;\nconst float UI_TITLE_TIME\t\t\t= 120.0;\nconst float UI_GAME_START_TIME\t\t= 60.0;\nconst float UI_VICTORY_TIME\t\t\t= 300.0;\n\nvec4 gPlayer;\nvec4 gPlayerState;\nvec4 gPlayerDir;\nvec4 gPlayerWeapon;\nvec4 gCamera;\nvec4 gSoldier0;\nvec4 gSoldier1;\nvec4 gSoldier2;\nvec4 gSoldier0State;\nvec4 gSoldier1State;\nvec4 gSoldier2State;\nvec4 gSniper;\nvec4 gPlayerBullet0;\nvec4 gPlayerBullet1;\nvec4 gPlayerBullet2;\nvec4 gPlayerBullet3;\nvec4 gPlayerBullet4;\nvec4 gPlayerBullet5;\nvec4 gEnemyBullet0;\nvec4 gEnemyBullet1;\nvec4 gEnemyBullet2;\nvec4 gEnemyBullet3;\nvec4 gExplosion;\nvec4 gHit;\nvec4 gTurret0;\nvec4 gTurret1;\nvec4 gTurret0State;\nvec4 gTurret1State;\nvec4 gPowerUp;\nvec4 gPowerUpState;\nvec4 gBossCore;\nvec4 gBossCannon0;\nvec4 gBossCannon1;\nvec4 gBossBullet0;\nvec4 gBossBullet1;\nvec4 gGameState;\nvec4 gBridge;\n\nfloat IsInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\n\nfloat Rand()\n{\n    vec2 co = vec2( iTime, iTime );\n    return fract( sin( dot( co.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );\n}\n\nvec4 LoadValue( vec2 tx )\n{\n    return texture( iChannel0, ( tx + 0.5 ) \/ iChannelResolution[ 0 ].xy );\n}\n\nvoid StoreValue( vec2 re, vec4 va, inout vec4 fragColor, vec2 fragCoord )\n{\n    fragCoord = floor( fragCoord );\n    fragColor = ( fragCoord.x == re.x && fragCoord.y == re.y ) ? va : fragColor;\n}\n\nbool Collide( vec2 p0, vec2 s0, vec2 p1, vec2 s1 )\n{\n    \/\/ pivot x in the middle, and y in the bottom\n    p0.x -= s0.x * 0.5;\n    p1.x -= s1.x * 0.5;\n    \n    return \t\tp0.x <= p1.x + s1.x\n        \t&& \tp0.y <= p1.y + s1.y\n        \t&& \tp1.x <= p0.x + s0.x\n        \t&& \tp1.y <= p0.y + s0.y;\n}\n\nfloat GetSupport( vec2 p )\n{\n    float tileX\t= floor( p.x \/ 32.0 );\n    float tileY\t= floor( p.y \/ 16.0 );\n    \n    bool grass0 = false;\n    bool grass2 = false;\n    bool grass3 = false;\n    bool grass4 = false;\n    bool grass6 = false;\n    bool grass8 = false;\n    \n\tif ( \t\t( tileX >= 52.0 && tileX < 67.0 ) \n\t\t\t|| \t( tileX >= 72.0 && tileX < 77.0 )   \n\t\t\t|| \t( tileX >= 86.0 && tileX < 88.0 ) )\n    {\n        grass8 = true;\n    }\n    \n\tif ( \t\t( tileX >= 3.0   && tileX < 30.0 ) \n        \t|| \t( tileX >= 35.0  && tileX < 40.0 ) \n        \t|| \t( tileX >= 45.0  && tileX < 53.0 ) \n        \t|| \t( tileX >= 66.0  && tileX < 73.0 )\n            || \t( tileX >= 78.0  && tileX < 80.0 )\n            || \t( tileX >= 85.0  && tileX < 87.0 )\n            || \t( tileX >= 89.0  && tileX < 91.0 )\n            ||  ( tileX >= 102.0 && tileX < 106.0 ) )\n    {\n        grass6 = true;\n    }\n    \n\tif ( \t\t( tileX >= 10.0 && tileX < 13.0 )\n\t\t\t||\t( tileX >= 18.0 && tileX < 20.0 )\n        \t|| \t( tileX >= 58.0 && tileX < 65.0 )\n\t\t\t|| \t( tileX >= 76.0 && tileX < 79.0 )\n            || \t( tileX >= 81.0 && tileX < 83.0 )\n            || \t( tileX >= 90.0 && tileX < 95.0 )\n            ||  ( tileX >= 100.0 && tileX < 102.0 )\n            || \t( tileX == 106.0 ) )\n    {\n        grass4 = true;\n    }\n    \n    if ( \t\t( tileX >= 26.0 && tileX < 29.0 )\n            ||  ( tileX >= 55.0 && tileX < 57.0 )\n            || \t( tileX == 74.0 )\n\t\t\t||  ( tileX == 87.0 )\n\t\t\t|| \t( tileX >= 103.0 && tileX < 106.0 ) )\n    {\n        grass3 = true;\n    }\n        \n\tif ( \t\t( tileX == 13.0 || tileX == 16.0 )\n            ||  ( tileX >= 68.0 && tileX < 70.0 )\n            ||  ( tileX >= 71.0 && tileX < 73.0 )\n            || \t( tileX >= 82.0 && tileX < 85.0 )\n            ||  ( tileX >= 97.0 && tileX < 99.0 )\n            || \t( tileX == 107.0 ) )\n    {\n        grass2 = true;\n    }\n        \n\tif ( \t\t( tileX >= 14.0 && tileX < 16.0 ) \n            || \t( tileX >= 24.0 && tileX < 26.0 ) \n            || \t( tileX >= 52.0 && tileX < 55.0 ) \n            || \t( tileX >= 62.0 && tileX < 68.0 )\n            || \t( tileX == 81.0 )\n\t\t\t||  ( tileX == 86.0 )\n            || \t( tileX >= 93.0 && tileX < 96.0 )\n            ||  ( tileX >= 102.0 ) )      \n\t{\n        grass0 = true;\n    }\n    \n\tif ( tileX >= BRIDGE_0_START_TILE && tileX < BRIDGE_0_END_TILE && gBridge.x < tileX )\n    {\n        grass6 = true;\n    }\n\n\tif ( tileX >= BRIDGE_1_START_TILE && tileX < BRIDGE_1_END_TILE && gBridge.x < tileX )\n    {\n        grass6 = true;\n    } \n    \n    float height = 8.0;\n    if ( grass0 )\n    {\n        height = 1.0 * 16.0;\n    }    \n    if ( grass2 && tileY >= 2.0 )\n    {\n        height = 3.0 * 16.0;\n    }\n    if ( grass3 && tileY >= 3.0 )\n    {\n        height = 4.0 * 16.0;\n    }    \n    if ( grass4 && tileY >= 4.0 )\n    {\n        height = 5.0 * 16.0;\n    }\n    if ( grass6 && tileY >= 6.0 )\n    {\n        height = 7.0 * 16.0;\n    } \n   \tif ( grass8 && tileY >= 8.0 )\n    {\n        height = 9.0 * 16.0;\n    }     \n    \n    return height - 4.0;\n}\n\nvoid SpawnSniper( float tileX, float tileY, float screenWidth )\n{\n    float spawnX = tileX * 32.0 - screenWidth;\n    if ( gCamera.x > spawnX && gCamera.y < spawnX )\n    {\n\t\tgSniper = vec4( tileX * 32.0, tileY * 32.0 + 12.0, 0.0, 0.0 );\n        gCamera.y = spawnX;\n    }\n}\n\nvoid SpawnTurret( float tileX, float tileY, float screenWidth )\n{\n    float spawnX = tileX * 32.0 - screenWidth;\n    if ( gCamera.x >= spawnX && gCamera.y < spawnX )\n    {\n        if ( gTurret0.x == 0.0 || ( gTurret1.x > 0.0 && gTurret0.x < gTurret1.x ) )\n        {\n\t\t\tgTurret0 \t\t= vec4( tileX * 32.0 + 16.0, tileY * 32.0, 0.0, 0.0 );\n        \tgTurret0State\t= vec4( TURRET_HP, 0.0, 0.0, 0.0 );\n        }\n        else\n        {\n\t\t\tgTurret1 \t\t= vec4( tileX * 32.0 + 16.0, tileY * 32.0, 0.0, 0.0 );\n        \tgTurret1State\t= vec4( TURRET_HP, 0.0, 0.0, 0.0 );\n        }\n\n        gCamera.y = spawnX;\n    }\n}\n\nvoid SpawnPowerUp( float tileX, float screenWidth )\n{\n    float spawnX = tileX * 32.0 - screenWidth;\n    if ( gCamera.x > spawnX && gCamera.y < spawnX )\n    {\n    \tgPowerUp \t\t= vec4( spawnX, 150.0, 0.0, 0.0 );\n        gPowerUpState\t= vec4( STATE_RUN, 150.0, 0.0, 0.0 );  \n        gCamera.y = spawnX;\n    }\n}\n\nvoid UpdateSpawner( float screenWidth )\n{\n    SpawnSniper( 15.0, 0.0, screenWidth );\n    SpawnPowerUp( 23.0, screenWidth );    \n    SpawnSniper( 25.0, 0.0, screenWidth );\n    SpawnTurret( 47.0, 2.0, screenWidth );\n    SpawnSniper( 48.0, 3.0, screenWidth );\n    SpawnSniper( 56.0, 4.0, screenWidth );\n    SpawnPowerUp( 55.0, screenWidth ); \n    SpawnTurret( 59.0, 3.0, screenWidth );\n    SpawnTurret( 65.0, 3.0, screenWidth );\n    SpawnTurret( 72.0, 2.0, screenWidth );\n    SpawnTurret( 76.0, 5.0, screenWidth );\n    SpawnSniper( 82.0, 2.0, screenWidth );\n    SpawnPowerUp( 89.0, screenWidth );    \n    SpawnTurret( 94.0, 3.0, screenWidth );\n    SpawnTurret( 101.0, 1.0, screenWidth );\n    SpawnTurret( 105.0, 1.0, screenWidth );\n    SpawnSniper( 109.8, 4.875, screenWidth );\n\n    if ( gCamera.z == 0.0 && Rand() > 0.5 )\n    {\n        gCamera.z = SOLDIER_SPAWN_RATE - 20.0;\n    }\n\n    ++gCamera.z;\n    vec4 newSoldier \t\t= vec4( gCamera.x + screenWidth, 300.0, -1.0, 0.0 );\n    vec4 newSoldierState \t= vec4( 0.0, 0.0, 0.0, 0.0 );\n\tnewSoldier.y = GetSupport( newSoldier.xy );    \n    if ( gCamera.x < SOLDIER_SPAWN_END && gCamera.z > SOLDIER_SPAWN_RATE && newSoldier.y > WATER_HEIGHT )\n    {\n        gCamera.z = 0.0;\n        \n        if ( gSoldier0.x <= 0.0 )\n        {\n            gSoldier0 \t\t= newSoldier;\n            gSoldier0State \t= newSoldierState;\n        }\n\t\telse if ( gSoldier1.x <= 0.0 )\n        {\n            gSoldier1 \t\t= newSoldier;\n            gSoldier1State \t= newSoldierState;\n        }\n\t\telse if ( gSoldier2.x <= 0.0 )\n        {\n            gSoldier2 \t\t= newSoldier;\n            gSoldier2State \t= newSoldierState;\n        }        \n    }\n}\n\nvoid SpawnEnemyBullet( vec2 pos, vec2 dir )\n{\n    if ( gEnemyBullet0.x <= 0.0 )\n    {\n\t\tgEnemyBullet0 = vec4( pos, dir );\n    }\n    else if ( gEnemyBullet1.x <= 0.0 )\n    {\n        gEnemyBullet1 = vec4( pos, dir );\n    }\n    else if ( gEnemyBullet2.x <= 0.0 )\n    {\n        gEnemyBullet2 = vec4( pos, dir );\n    }\n    else if ( gEnemyBullet3.x <= 0.0 )\n    {\n        gEnemyBullet3 = vec4( pos, dir );\n    }    \n}\n\nvoid UpdateSniper( inout vec4 sniper, vec2 playerTarget )\n{\n    if ( sniper.x + SNIPER_SIZE.x * 0.5 < gCamera.x )\n    {\n        sniper.x = 0.0;\n    }  \n    \n    ++sniper.w;\n\tif ( sniper.x > 0.0 && sniper.w > SNIPER_FIRE_RATE )\n    {\n        sniper.w = 0.0;\n        vec2 pos = sniper.xy + vec2( 0.0, 24.0 );\n        SpawnEnemyBullet( pos, normalize( playerTarget - pos ) );\n    }\n    sniper.z = playerTarget.x > sniper.x ? 1.0 : -1.0;    \n}\n\nvoid UpdateTurret( inout vec4 turret, inout vec4 turretState, vec2 playerTarget )\n{\n    if ( turret.x + TURRET_SIZE.x * 0.5 < gCamera.x )\n    {\n        turret.x = 0.0;\n    }    \n    \n\tvec2 turretAim = normalize( playerTarget - turret.xy );\n\n    \/\/ constrain barrel to one of the 12 possible rotations\n    float turretAimAngle = atan( -turretAim.y, turretAim.x );    \n    turretAimAngle = turretAimAngle \/ ( 2.0 * MATH_PI );\n    turretAimAngle = floor( turretAimAngle * 12.0 + 0.5 );\n    turret.z = mod( turretAimAngle + 6.0, 12.0 );\n    turretAimAngle = turretAimAngle * 2.0 * MATH_PI \/ 12.0;\n    turretAim = vec2( cos( turretAimAngle ), -sin( turretAimAngle ) );\n    \n    ++turretState.y;\n\tif ( turret.x > 0.0 && turretState.y > TURRET_FIRE_RATE )\n    {\n        turretState.y = 0.0;\n\t\tSpawnEnemyBullet( turret.xy, turretAim );\n    }\n}\n\nvoid UpdateBossCannon( inout vec4 bossCannon )\n{\n    float accX \t\t= -fract( iTime * 1.069 + bossCannon.x * 7.919 ) * 5.0;\n    vec4 newBullet\t= vec4( bossCannon.xy - vec2( BOSS_CANNON_SIZE.x * 0.5, 0.0), accX, 0.0 );\n    \n    ++bossCannon.z;\n    if ( bossCannon.z > BOSS_CANNON_FIRE_RATE )\n    {\n        bossCannon.z = 0.0;\n        if ( gBossBullet0.x <= 0.0 )\n        {\n            gBossBullet0 = newBullet;\n        }\n        else if ( gBossBullet1.x <= 0.0 )\n        {\n            gBossBullet1 = newBullet;\n        }\n    }\n}\n\nvoid PlayerBulletSoldierTest( inout vec4 playerBullet, inout vec4 soldier )\n{\n    if ( playerBullet.x > 0.0 && Collide( playerBullet.xy, BULLET_SIZE, soldier.xy, SOLDIER_SIZE ) )\n    {\n        gExplosion \t\t= vec4( soldier.xy + vec2( 0.0, SOLDIER_SIZE.y * 0.5 ), 0.0, 0.0 );\n        gHit\t\t \t= vec4( playerBullet.xy, 0.0, 0.0 );\n\t\tsoldier.x \t\t= 0.0;\n        playerBullet.x \t= 0.0;\n    }\n}\n\nvoid PlayerBulletSniperTest( inout vec4 playerBullet, inout vec4 sniper )\n{\n\tif ( playerBullet.x > 0.0 && Collide( playerBullet.xy, BULLET_SIZE, sniper.xy, SNIPER_SIZE ) )\n    {\n        gExplosion\t\t= vec4( sniper.xy + vec2( 0.0, SNIPER_SIZE.y * 0.5 ), 0.0, 0.0 );\n        gHit\t\t  \t= vec4( playerBullet.xy, 0.0, 0.0 );\n\t\tsniper.x\t\t= 0.0;\n        playerBullet.x \t= 0.0;\n    }\n}\n\nvoid PlayerBulletTurretTest( inout vec4 playerBullet, inout vec4 turret, inout vec4 turretState )\n{\n\tif ( playerBullet.x > 0.0 && Collide( playerBullet.xy, BULLET_SIZE, turret.xy + vec2( 0.0, -TURRET_SIZE.y * 0.5 ), TURRET_SIZE ) )\n    {\n        gHit\t\t\t= vec4( playerBullet.xy, 0.0, 0.0 );\n        playerBullet.x \t= 0.0;\n        \n        --turretState.x;        \n        if ( turretState.x <= 0.0 )\n        {\n\t\t\tgExplosion = vec4( turret.xy, 0.0, 0.0 );\n        \tturret.x = 0.0;\n        }\n    }\n}\n\nvoid PlayerBulletPowerUpTest( inout vec4 playerBullet )\n{\n\tif ( playerBullet.x > 0.0 && gPowerUpState.x == STATE_RUN && Collide( playerBullet.xy, BULLET_SIZE, gPowerUp.xy, POWER_UP_SIZE ) )\n    {\n\t\tgHit\t\t\t= vec4( playerBullet.xy, 0.0, 0.0 );\n        gExplosion \t\t= vec4( gPowerUp.xy + vec2( 0.0, POWER_UP_SIZE.y * 0.5 ), 0.0, 0.0 );        \n        playerBullet.x \t= 0.0;\n        gPowerUpState.x = STATE_JUMP;\n        gPowerUp.z\t\t= 1.0;\n    }\n}\n\nvoid PlayerBulletBossCoreTest( inout vec4 playerBullet )\n{\n\tif ( playerBullet.x > 0.0 && Collide( playerBullet.xy, BULLET_SIZE, gBossCore.xy + vec2( 0.0, BOSS_CORE_SIZE.y * 0.25 ), BOSS_CORE_SIZE * 0.5 ) )\n    {\n\t\tgHit\t\t\t= vec4( playerBullet.xy, 0.0, 0.0 );\n        playerBullet.x \t= 0.0;\n\t\t--gBossCore.z;\n        if ( gBossCore.z < 0.0 )\n        {\n            gExplosion \t\t= vec4( gBossCore.xy + vec2( 0.0, BOSS_CORE_SIZE.y * 0.5 ), 0.0, 0.0 );\n            gBossCore.x \t= 0.0;\n            gGameState.x \t= GAME_STATE_LEVEL_WIN;\n\t\t\tgGameState.y \t= 0.0;\n        }\n    }\n}\n\nvoid PlayerBulletBossCannonTest( inout vec4 playerBullet, inout vec4 bossCannon )\n{\n\tif ( playerBullet.x > 0.0 && Collide( playerBullet.xy, BULLET_SIZE, bossCannon.xy, BOSS_CANNON_SIZE ) )\n    {\n\t\tgHit\t\t\t= vec4( playerBullet.xy, 0.0, 0.0 );\n        playerBullet.x \t= 0.0;\n\t\t--bossCannon.w;\n        if ( bossCannon.w < 0.0 )\n        {\n            gExplosion \t\t= vec4( bossCannon.xy + vec2( 0.0, BOSS_CANNON_SIZE.y * 0.5 ), 0.0, 0.0 );\n            bossCannon.x \t= 0.0;\n        }\n    }\n}\n\nvoid UpdatePlayerBullet( inout vec4 playerBullet, float screenWidth, float screenHeight )\n{\n    if ( !Collide( playerBullet.xy, BULLET_SIZE, vec2( gCamera.x + screenWidth * 0.5, 0.0 ), vec2( screenWidth, screenHeight ) ) )\n    {\n        playerBullet.x = 0.0;\n    }\n    if ( playerBullet.x > 0.0 )\n    {\n    \tplayerBullet.xy += playerBullet.zw * PLAYER_BULLET_SPEED;\n    }\n}\n\nvoid PlayerHit( vec4 playerHitBox )\n{\n#ifndef GOD_MODE\n    if ( gGameState.x == GAME_STATE_LEVEL && gGameState.y > UI_GAME_START_TIME )\n    {\n        gPlayerState.x \t= STATE_JUMP;\n        gPlayerState.y \t= 0.0;        \n        gPlayerState.z \t= 1.0;\n        gPlayerState.w -= 1.0;    \n        gExplosion \t\t= vec4( gPlayer.xy + vec2( 0.0, playerHitBox.z * 0.5 ), 0.0, 0.0 );\n        gPlayer \t\t= vec4( gCamera.x + 32.0 * 2.0 + 24.0, PLAYER_SPAWN_HEIGHT, PLAYER_SPAWN_HEIGHT, 0.0 );\n        gPlayerDir\t\t= vec4( 1.0, 0.0, 0.0, PLAYER_IMMORTALITY_LEN );\n        gPlayerWeapon \t= vec4( WEAPON_RIFLE, 0.0, RIFLE_FIRE_RATE, RIFLE_BULLET_NUM );\n\n        if ( gPlayerState.w <= 0.0 )\n        {\n            gGameState.x \t= GAME_STATE_LEVEL_DIE;\n            gGameState.y \t= 0.0;\n            gPlayer\t\t\t= vec4( 0.0, 1000000.0, 0.0, 0.0 );\n            gPlayerState.x \t= STATE_FALL;\n        }\n    }\n#endif\n}\n\nvoid UpdateEnemyBullet( inout vec4 enemyBullet, vec4 playerHitBox, float screenWidth, float screenHeight )\n{\n    if ( !Collide( enemyBullet.xy, BULLET_SIZE, vec2( gCamera.x + screenWidth * 0.5, 0.0 ), vec2( screenWidth, screenHeight ) ) )\n    {\n        enemyBullet.x = 0.0;\n    }\n    \n\tif ( enemyBullet.x > 0.0 )\n    {\n    \tenemyBullet.xy += enemyBullet.zw * ENEMY_BULLET_SPEED;\n    }\n   \n\tif ( Collide( playerHitBox.xy, playerHitBox.zw, enemyBullet.xy, BULLET_SIZE ) )\n    {\n        PlayerHit( playerHitBox );\n        enemyBullet.x = 0.0;\n    }        \n}\n\nvoid UpdateBossBullet( inout vec4 bossBullet, vec4 playerHitBox, float screenWidth, float screenHeight )\n{\n    if ( !Collide( bossBullet.xy, POWER_BULLET_SIZE, vec2( gCamera.x + screenWidth * 0.5, 0.0 ), vec2( screenWidth, screenHeight ) ) )\n    {\n        bossBullet.x = 0.0;\n    }\n    \n\tif ( bossBullet.x > 0.0 )\n    {\n        bossBullet.xy += bossBullet.zw;\n        bossBullet.w -= 1.0 \/ 10.0;\n    }\n   \n\tif ( Collide( playerHitBox.xy, playerHitBox.zw, bossBullet.xy, POWER_BULLET_SIZE ) )\n    {\n        PlayerHit( playerHitBox );\n        bossBullet.x = 0.0;\n    }        \n}\n\nvoid UpdateSoldier( inout vec4 soldier, inout vec4 soldierState, vec4 playerHitBox, float screenWidth, float screenHeight )\n{\n    float soldierSupport = GetSupport( soldier.xy );    \n    if ( soldierState.x == STATE_RUN )\n    {\n\t\tsoldierState.y = mod( soldierState.y + ENEMY_ANIM_SPEED, 2.0 );        \n        \n        if ( soldier.y != soldierSupport )\n        {\n            \/\/ lost support - either jump or go back\n            if ( Rand() > 0.3 )\n            {\n            \tsoldierState.x = STATE_JUMP;\n            \tsoldierState.y = 1.0;\n            \tsoldierState.z = 0.0;\n\t\t\t}\n            else\n            {\n            \tsoldier.z = -soldier.z;\n            }\n        }\n    }\n    else if ( soldierState.x == STATE_JUMP )\n    {\n\t\tsoldierState.z += 1.0 \/ 20.0;\n        soldier.y += 3.0 * ( 1.0 - soldierState.z );\n        if ( soldierState.z > 1.0 && soldier.y <= soldierSupport )\n        {\n            soldier.y = soldierSupport;\n            soldierState.x = STATE_RUN;\n        }\n    }\n\tsoldier.x += soldier.z * ENEMY_RUN_SPEED;\n\n    if ( soldier.x > gCamera.x + screenWidth || soldier.x < gCamera.x )\n    {\n    \tsoldier.x = -1.0;        \n    }\n\n    \/\/ soldier death\n    if ( soldier.x > 0.0 && soldier.y < WATER_HEIGHT )   \n    {\n        gExplosion \t= vec4( soldier.xy + vec2( 0.0, SOLDIER_SIZE.y * 0.5 ), 0.0, 0.0 );\n\t\tsoldier \t= vec4( 0.0, 0.0, 0.0, 0.0 );\n    }\n    \n\tif ( soldier.x > 0.0 && Collide( playerHitBox.xy, playerHitBox.zw, soldier.xy, SOLDIER_SIZE ) )\n    {\n        PlayerHit( playerHitBox );\n    }    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ don't compute gameplay outside of the data area\n    if ( fragCoord.x > 32.0 || fragCoord.y > 32.0 ) \n    {\n        discard;    \n    }\n\n    float resMultX  \t= floor( iResolution.x \/ NES_RES_X );\n    float resMultY  \t= floor( iResolution.y \/ NES_RES_Y );\n    float resRcp\t\t= 1.0 \/ max( min( resMultX, resMultY ), 1.0 );\n    float screenWidth\t= floor( iResolution.x * resRcp );\n    float screenHeight\t= floor( iResolution.y * resRcp );\n    \n    \/\/ keys\n    bool keyLeft  \t= texture( iChannel1, vec2( KEY_LEFT, 0.25 ) ).x > 0.5;\n    bool keyRight \t= texture( iChannel1, vec2( KEY_RIGHT, 0.25 ) ).x > 0.5;\n    bool keyUp  \t= texture( iChannel1, vec2( KEY_UP, 0.25 ) ).x > 0.5;\n    bool keyDown \t= texture( iChannel1, vec2( KEY_DOWN, 0.25 ) ).x > 0.5;    \n    bool keyShoot\t= texture( iChannel1, vec2( KEY_A, 0.25 ) ).x > 0.5 || texture( iChannel1, vec2( KEY_Q, 0.25 ) ).x > 0.5;\n    bool keyJump \t= texture( iChannel1, vec2( KEY_S, 0.25 ) ).x > 0.5 || texture( iChannel1, vec2( KEY_W, 0.25 ) ).x > 0.5;\n    \n\tgPlayer        \t= LoadValue( txPlayer );\n\tgPlayerState   \t= LoadValue( txPlayerState );\n\tgPlayerDir    \t= LoadValue( txPlayerDir );\n    gPlayerWeapon  \t= LoadValue( txPlayerWeapon );\n\tgCamera       \t= LoadValue( txCamera );\n\tgSoldier0     \t= LoadValue( txSoldier0 );\n    gSoldier1      \t= LoadValue( txSoldier1 );\n    gSoldier2      \t= LoadValue( txSoldier2 );\n\tgSoldier0State \t= LoadValue( txSoldier0State );\n    gSoldier1State \t= LoadValue( txSoldier1State );\n    gSoldier2State \t= LoadValue( txSoldier2State );\n\tgSniper        \t= LoadValue( txSniper );\n\tgPlayerBullet0 \t= LoadValue( txPlayerBullet0 );\n    gPlayerBullet1 \t= LoadValue( txPlayerBullet1 );\n    gPlayerBullet2 \t= LoadValue( txPlayerBullet2 );\n\tgPlayerBullet3 \t= LoadValue( txPlayerBullet3 );\n    gPlayerBullet4 \t= LoadValue( txPlayerBullet4 );\n    gPlayerBullet5 \t= LoadValue( txPlayerBullet5 );    \n\tgEnemyBullet0  \t= LoadValue( txEnemyBullet0 );\n\tgEnemyBullet1  \t= LoadValue( txEnemyBullet1 );\n    gEnemyBullet2  \t= LoadValue( txEnemyBullet2 );\n    gEnemyBullet3  \t= LoadValue( txEnemyBullet3 );\n\tgExplosion     \t= LoadValue( txExplosion );\n\tgHit           \t= LoadValue( txHit );\n\tgTurret0       \t= LoadValue( txTurret0 );\n\tgTurret1       \t= LoadValue( txTurret1 );\n\tgTurret0State   = LoadValue( txTurret0State );\n\tgTurret1State   = LoadValue( txTurret1State );    \n    gPowerUp\t\t= LoadValue( txPowerUp );\n    gPowerUpState\t= LoadValue( txPowerUpState );\n    gBossCore\t\t= LoadValue( txBossCore );\n    gBossCannon0\t= LoadValue( txBossCannon0 );\n    gBossCannon1\t= LoadValue( txBossCannon1 );\n    gBossBullet0\t= LoadValue( txBossBullet0 );\n    gBossBullet1\t= LoadValue( txBossBullet1 );\n    gGameState\t\t= LoadValue( txGameState );\n    gBridge\t\t\t= LoadValue( txBridge );\n\n    \/\/ game state machine\n    ++gGameState.y;    \n    if ( gGameState.x == GAME_STATE_TITLE )\n    {\n        if ( gGameState.y > UI_TITLE_TIME )\n        {\n            gGameState.x = GAME_STATE_LEVEL;\n            gGameState.y = 0.0;\n        }\n    }\n    else if ( gGameState.x == GAME_STATE_LEVEL )\n    {\n\t\tif ( gGameState.y <= UI_GAME_START_TIME )\n    \t{\n        \tgCamera \t\t= vec4( 32.0, -100.0, 0.0, 0.0 );\n\t\t\tgPlayer \t\t= vec4( gCamera.x + 32.0 * 2.0 + 24.0, PLAYER_SPAWN_HEIGHT, PLAYER_SPAWN_HEIGHT, 0.0 );\n    \t\tgPlayerState.x \t= STATE_JUMP;\n        \tgPlayerState.y \t= 0.0;        \n        \tgPlayerState.z \t= 1.0;\n        \tgPlayerState.w \t= PLAYER_LIFE_NUM;\n        \tgPlayerWeapon \t= vec4( WEAPON_RIFLE, 0.0, RIFLE_FIRE_RATE, RIFLE_BULLET_NUM );\n        \tgBossCore\t\t= vec4( 32.0 * 108.0 + 23.0 + 12.0, 34.0, BOSS_CORE_HP, 0.0 );\n            gBossCannon0\t= vec4( 3478.0, 92.0, 0.0, BOSS_CANNON_HP );\n            gBossCannon1\t= gBossCannon0 + vec4( 22.0, 0.0, 0.0, 0.0 );\n            gSoldier0\t\t= vec4( 0.0, 0.0, 0.0, 0.0 );\n            gSoldier1\t\t= vec4( 0.0, 0.0, 0.0, 0.0 );\n            gSoldier2\t\t= vec4( 0.0, 0.0, 0.0, 0.0 );\n            gBridge\t\t\t= vec4( 0.0, 0.0, 0.0, 0.0 );\n            gPowerUp\t\t= vec4( 0.0, 0.0, 0.0, 0.0 );\n            gTurret0\t\t= vec4( 0.0, 0.0, 0.0, 0.0 );\n            gTurret1\t\t= vec4( 0.0, 0.0, 0.0, 0.0 );\n    \t}\n    }\n    else if ( gGameState.x == GAME_STATE_LEVEL_DIE )\n    {\n        if ( gGameState.y > UI_TITLE_TIME )\n        {\n            gGameState.x = GAME_STATE_GAME_OVER;\n            gGameState.y = 0.0;\n        }\n    }    \n    else if ( gGameState.x == GAME_STATE_LEVEL_WIN )\n    {\n        if ( gGameState.y > UI_TITLE_TIME )\n        {\n            gGameState.x = GAME_STATE_VICTORY;\n            gGameState.y = 0.0;\n        }\n    }\n    else if ( gGameState.x == GAME_STATE_VICTORY )\n    {\n        if ( gGameState.y > UI_VICTORY_TIME )\n        {\n            gGameState.x = GAME_STATE_TITLE;\n            gGameState.y = 0.0;\n        }\n    } \n\tif ( gGameState.x == GAME_STATE_GAME_OVER )\n    {\n\t\tif ( gGameState.y > UI_TITLE_TIME )\n        {\n            gGameState.x = GAME_STATE_TITLE;\n            gGameState.y = 0.0;\n        }\n    }\n\n \n\tUpdateSpawner( screenWidth );\n        \n    \/\/ player state machine\n\tfloat playerSupport = GetSupport( gPlayer.xy );\n    if ( gPlayerState.x == STATE_RUN )\n    {\n        if ( keyJump )\n    \t{\n            gPlayer.z\t\t= gPlayer.y;\n            gPlayer.w\t\t= 0.0;\n\t        gPlayerState.x \t= STATE_JUMP;\n            gPlayerState.y \t= 0.0;\n\t\t\tgPlayerState.z \t= 0.0;\n    \t}\n        else if ( keyRight || keyLeft )\n        {\n    \t\tgPlayerState.y = mod( gPlayerState.y + PLAYER_RUN_ANIM_SPEED, 3.0 );\n        }        \n        else\n        {\n            if ( keyDown )\n            {\n                gPlayerState.x = STATE_PRONE;\n            }\n            gPlayerState.y = 0.0;\n        }\n\n        if ( gPlayer.y != playerSupport )\n        {\n\t\t\tgPlayerState.x = STATE_FALL;\n        }\n        if ( gPlayer.y <= WATER_HEIGHT )\n        {\n            if ( gPlayer.x < WATER_END )\n            {\n            \tgPlayerState.x = STATE_WATER;\n            }\n            else\n            {\n                PlayerHit( vec4( gPlayer.xy, BILL_PRONE_SIZE ) );\n            }\n        }\n    }        \n    else if ( gPlayerState.x == STATE_PRONE )\n    {\n        if ( !keyDown || keyRight || keyLeft )\n        {\n            gPlayerState.x = STATE_RUN;\n        }\n        else if ( keyJump )\n    \t{\n     \t\tgPlayerState.x = STATE_FALL;\n        \tgPlayer.y -= PLAYER_FALL_SPEED + 20.0;\n\t\t}        \n    }\n    else if ( gPlayerState.x == STATE_JUMP )\n    {\n        if ( keyRight )\n        {\n            gPlayer.w = 1.0;\n        }\n        else if ( keyLeft )\n        {\n            gPlayer.w = -1.0;\n        }\n        \n        gPlayerState.y = mod( gPlayerState.y + PLAYER_JUMP_ANIM_SPEED, 2.0 );\n\t\tgPlayerState.z += 1.0 \/ 30.0;\n        gPlayer.x += gPlayer.w * PLAYER_RUN_SPEED;\n        gPlayer.y += 4.5 * ( 1.0 - gPlayerState.z );\n        if ( gPlayerState.z > 1.0 && gPlayer.y <= playerSupport && gPlayer.y - gPlayer.z < PLAYER_JUMP_HEIGHT )\n        {\n            gPlayer.y = playerSupport;\n            gPlayerState.x = STATE_RUN;\n        }\n    }\n    else if ( gPlayerState.x == STATE_FALL )\n    {\n        if ( gPlayer.y <= playerSupport )\n        {\n            gPlayer.y = playerSupport;\n            gPlayerState.x = STATE_RUN;\n        }\n        else\n        {\n            gPlayer.y -= PLAYER_FALL_SPEED;\n        }\n    }    \n    else if ( gPlayerState.x == STATE_WATER )\n    {\n        if ( keyDown )\n        {\n\t\t\tgPlayerState.x = STATE_UNDER_WATER;\n        }\n        \n\t\tif ( playerSupport > WATER_HEIGHT )\n        {\n            gPlayerState.x \t= STATE_RUN;\n            gPlayer.y\t\t= playerSupport;\n        }\n    }\n    else if ( gPlayerState.x == STATE_UNDER_WATER )\n    {\n        if ( !keyDown )\n        {\n        \tgPlayerState.x = STATE_WATER;\n        }\n    }\n    \n    \/\/ importality tick\n    --gPlayerDir.w;\n    \n    \/\/ look dir\n    vec2 newDir;\n    gPlayerDir.x = keyRight ? 1.0 : ( keyLeft ? -1.0 : 0.0 );\n\tgPlayerDir.y = keyUp \t? 1.0 : ( keyDown ? -1.0 : 0.0 );\n    if ( ( gPlayerDir.x == 0.0 && gPlayerDir.y == 0.0 ) || gPlayerState.x == STATE_PRONE )\n    {\n        gPlayerDir.xy = gPlayerDir.z < 0.0 ? vec2( -1.0, 0.0 ) : vec2( 1.0, 0.0 );\n    }\n    \n    \/\/ flip\n    if ( keyRight && gPlayerState.x != STATE_UNDER_WATER )\n    {\n        gPlayerDir.z = 1.0;\n    }\n    else if ( keyLeft && gPlayerState.x != STATE_UNDER_WATER )\n    {\n        gPlayerDir.z = -1.0;\n    }    \n    \n    \/\/ move\n    if ( gPlayerState.x != STATE_PRONE && gPlayerState.x != STATE_UNDER_WATER && gPlayerState.x != STATE_JUMP )\n    {\n        if ( keyLeft )\n        {\n            gPlayer.x -= PLAYER_RUN_SPEED;\n        }\n        else if ( keyRight )\n        {\n            gPlayer.x += PLAYER_RUN_SPEED;\n        }\n    }\n    \n\n    \/\/ clamp player to edge of the screen\n    gPlayer.x = clamp( gPlayer.x, gCamera.x, PLAYER_END );\n    \n    \/\/ scroll camera\n   \tif ( gPlayer.x - screenWidth * 0.5 + 24.0 > gCamera.x )\n    {\n        gCamera.x = min( gPlayer.x - screenWidth * 0.5 + 24.0, CAMERA_END );\n    }\n        \n    \n    \/\/ player size and center\n    vec4 playerHitBox \t\t= vec4( 0.0, 0.0, BILL_RUN_SIZE );\n    vec2 playerWeaponOffset = gPlayerDir.y == 1.0 && gPlayerDir.x != 0.0 ? vec2( 6.0, 30.0 ) : ( gPlayerDir.y == 1.0 ? vec2( -2.0, 40.0 ) : ( gPlayerDir.y == -1.0 ? vec2( 7.0, 14.0 ) : vec2( 10.0, 19.0 ) ) );    \n    if ( gPlayerState.x == STATE_PRONE )\n    {\n        playerHitBox.zw\t\t= BILL_PRONE_SIZE;\n        playerWeaponOffset \t= vec2( 14.0, 7.0 );\n    }\n    else if ( gPlayerState.x == STATE_JUMP )\n    {    \n        playerHitBox.zw \t= BILL_JUMP_SIZE;\n        playerWeaponOffset \t= vec2( 0.0, BILL_JUMP_SIZE.y * 0.5 );\n    }\n    else if ( gPlayerState.x == STATE_WATER )\n    {\n        playerWeaponOffset.y -= 12.0;\n    }\n\n    playerHitBox.x = gPlayer.x;\n    playerHitBox.y = floor( gPlayer.y + playerHitBox.w * 0.5 * ( 1.0 - PLAYER_HIT_BOX_SIZE_MUL ) + 0.5 );\n    playerHitBox.zw *= PLAYER_HIT_BOX_SIZE_MUL;\n\n    if ( gPlayerDir.w > 0.0 || gPlayerState.x == STATE_UNDER_WATER )\n    {\n    \t\/\/ player is immortal        \n        playerHitBox = vec4( -1000000.0 );\n    }\n\n    playerWeaponOffset.x = gPlayerDir.z < 0.0 ? -playerWeaponOffset.x : playerWeaponOffset.x;\n    vec2 playerWeapon = gPlayer.xy + playerWeaponOffset;\n    vec2 playerTarget = gPlayer.xy + vec2( 0.0, BILL_RUN_SIZE.y * 0.5 );\n    \n    \/\/ player shooting\n    ++gPlayerWeapon.y;\n    float playerBulletNum = \tfloat( gPlayerBullet0.x > 0.0 ) \n        \t\t\t\t\t+ \tfloat( gPlayerBullet1.x > 0.0 )\n    \t\t\t\t\t\t+ \tfloat( gPlayerBullet2.x > 0.0 )\n    \t\t\t\t\t\t+ \tfloat( gPlayerBullet3.x > 0.0 )\n    \t\t\t\t\t\t+ \tfloat( gPlayerBullet4.x > 0.0 )\n    \t\t\t\t\t\t+ \tfloat( gPlayerBullet5.x > 0.0 );\n\n    if ( keyShoot && gPlayerWeapon.y > gPlayerWeapon.z && playerBulletNum < gPlayerWeapon.w && gPlayerState.x != STATE_UNDER_WATER )\n    {\n        gPlayerWeapon.y = 0.0;\n        if ( gPlayerBullet0.x <= 0.0 )\n        {\n        \tgPlayerBullet0.xy = playerWeapon;\n            gPlayerBullet0.zw = normalize( gPlayerDir.xy );\n        }\n        else if ( gPlayerBullet1.x <= 0.0 )\n        {\n        \tgPlayerBullet1.xy = playerWeapon;\n            gPlayerBullet1.zw = normalize( gPlayerDir.xy );\n        }\n        else if ( gPlayerBullet2.x <= 0.0 )\n        {\n        \tgPlayerBullet2.xy = playerWeapon;\n            gPlayerBullet2.zw = normalize( gPlayerDir.xy );\n        }     \n        else if ( gPlayerBullet3.x <= 0.0 )\n        {\n        \tgPlayerBullet3.xy = playerWeapon;\n            gPlayerBullet3.zw = normalize( gPlayerDir.xy );\n        }\n        else if ( gPlayerBullet4.x <= 0.0 )\n        {\n        \tgPlayerBullet4.xy = playerWeapon;\n            gPlayerBullet4.zw = normalize( gPlayerDir.xy );\n        }  \n        else if ( gPlayerBullet5.x <= 0.0 )\n        {\n        \tgPlayerBullet5.xy = playerWeapon;\n            gPlayerBullet5.zw = normalize( gPlayerDir.xy );\n        }          \n    }\n    \n    UpdatePlayerBullet( gPlayerBullet0, screenWidth, screenHeight );\n    UpdatePlayerBullet( gPlayerBullet1, screenWidth, screenHeight );\n    UpdatePlayerBullet( gPlayerBullet2, screenWidth, screenHeight );\n    UpdatePlayerBullet( gPlayerBullet3, screenWidth, screenHeight );\n    UpdatePlayerBullet( gPlayerBullet4, screenWidth, screenHeight );\n    UpdatePlayerBullet( gPlayerBullet5, screenWidth, screenHeight );    \n    UpdateEnemyBullet( gEnemyBullet0, playerHitBox, screenWidth, screenHeight );\n    UpdateEnemyBullet( gEnemyBullet1, playerHitBox, screenWidth, screenHeight );\n    UpdateEnemyBullet( gEnemyBullet2, playerHitBox, screenWidth, screenHeight );\n    UpdateEnemyBullet( gEnemyBullet3, playerHitBox, screenWidth, screenHeight );\n    UpdateBossBullet( gBossBullet0, playerHitBox, screenWidth, screenHeight );\n    UpdateBossBullet( gBossBullet1, playerHitBox, screenWidth, screenHeight );\n    UpdateSoldier( gSoldier0, gSoldier0State, playerHitBox, screenWidth, screenHeight );\n    UpdateSoldier( gSoldier1, gSoldier1State, playerHitBox, screenWidth, screenHeight );\n    UpdateSoldier( gSoldier2, gSoldier2State, playerHitBox, screenWidth, screenHeight );\n\n    PlayerBulletSoldierTest( gPlayerBullet0, gSoldier0 );\n    PlayerBulletSoldierTest( gPlayerBullet1, gSoldier0 );\n    PlayerBulletSoldierTest( gPlayerBullet2, gSoldier0 );\n    PlayerBulletSoldierTest( gPlayerBullet3, gSoldier0 );\n    PlayerBulletSoldierTest( gPlayerBullet4, gSoldier0 );\n    PlayerBulletSoldierTest( gPlayerBullet5, gSoldier0 );    \n    \n    PlayerBulletSoldierTest( gPlayerBullet0, gSoldier1 );\n    PlayerBulletSoldierTest( gPlayerBullet1, gSoldier1 );\n    PlayerBulletSoldierTest( gPlayerBullet2, gSoldier1 );\n    PlayerBulletSoldierTest( gPlayerBullet3, gSoldier1 );\n    PlayerBulletSoldierTest( gPlayerBullet4, gSoldier1 );\n    PlayerBulletSoldierTest( gPlayerBullet5, gSoldier1 );    \n    \n    PlayerBulletSoldierTest( gPlayerBullet0, gSoldier2 );\n    PlayerBulletSoldierTest( gPlayerBullet1, gSoldier2 );\n    PlayerBulletSoldierTest( gPlayerBullet2, gSoldier2 );\n    PlayerBulletSoldierTest( gPlayerBullet3, gSoldier2 );\n    PlayerBulletSoldierTest( gPlayerBullet4, gSoldier2 );\n    PlayerBulletSoldierTest( gPlayerBullet5, gSoldier2 );    \n    \n    PlayerBulletSniperTest( gPlayerBullet0, gSniper );\n    PlayerBulletSniperTest( gPlayerBullet1, gSniper );\n    PlayerBulletSniperTest( gPlayerBullet2, gSniper );\n    PlayerBulletSniperTest( gPlayerBullet3, gSniper );\n    PlayerBulletSniperTest( gPlayerBullet4, gSniper );\n    PlayerBulletSniperTest( gPlayerBullet5, gSniper );    \n    \n    PlayerBulletTurretTest( gPlayerBullet0, gTurret0, gTurret0State );\n    PlayerBulletTurretTest( gPlayerBullet1, gTurret0, gTurret0State );\n    PlayerBulletTurretTest( gPlayerBullet2, gTurret0, gTurret0State );\n    PlayerBulletTurretTest( gPlayerBullet3, gTurret0, gTurret0State );\n    PlayerBulletTurretTest( gPlayerBullet4, gTurret0, gTurret0State );\n    PlayerBulletTurretTest( gPlayerBullet5, gTurret0, gTurret0State );    \n    \n    PlayerBulletTurretTest( gPlayerBullet0, gTurret1, gTurret1State );\n    PlayerBulletTurretTest( gPlayerBullet1, gTurret1, gTurret1State );\n    PlayerBulletTurretTest( gPlayerBullet2, gTurret1, gTurret1State );\n    PlayerBulletTurretTest( gPlayerBullet3, gTurret1, gTurret1State );\n    PlayerBulletTurretTest( gPlayerBullet4, gTurret1, gTurret1State );\n    PlayerBulletTurretTest( gPlayerBullet5, gTurret1, gTurret1State );    \n    \n    PlayerBulletPowerUpTest( gPlayerBullet0 );\n    PlayerBulletPowerUpTest( gPlayerBullet1 );\n    PlayerBulletPowerUpTest( gPlayerBullet2 );\n    PlayerBulletPowerUpTest( gPlayerBullet3 );\n    PlayerBulletPowerUpTest( gPlayerBullet4 );\n    PlayerBulletPowerUpTest( gPlayerBullet5 );    \n    \n    PlayerBulletBossCoreTest( gPlayerBullet0 );\n    PlayerBulletBossCoreTest( gPlayerBullet1 );\n    PlayerBulletBossCoreTest( gPlayerBullet2 );\n    PlayerBulletBossCoreTest( gPlayerBullet3 );\n    PlayerBulletBossCoreTest( gPlayerBullet4 );\n    PlayerBulletBossCoreTest( gPlayerBullet5 );  \n    \n    PlayerBulletBossCannonTest( gPlayerBullet0, gBossCannon0 );\n    PlayerBulletBossCannonTest( gPlayerBullet1, gBossCannon0 );\n    PlayerBulletBossCannonTest( gPlayerBullet2, gBossCannon0 );\n    PlayerBulletBossCannonTest( gPlayerBullet3, gBossCannon0 );\n    PlayerBulletBossCannonTest( gPlayerBullet4, gBossCannon0 );\n\tPlayerBulletBossCannonTest( gPlayerBullet5, gBossCannon0 );  \n\n    PlayerBulletBossCannonTest( gPlayerBullet0, gBossCannon1 );\n    PlayerBulletBossCannonTest( gPlayerBullet1, gBossCannon1 );\n    PlayerBulletBossCannonTest( gPlayerBullet2, gBossCannon1 );\n    PlayerBulletBossCannonTest( gPlayerBullet3, gBossCannon1 );\n    PlayerBulletBossCannonTest( gPlayerBullet4, gBossCannon1 );\n\tPlayerBulletBossCannonTest( gPlayerBullet5, gBossCannon1 );  \t    \n     \n    \n    \/\/ powerup state machine\n\tfloat powerUpSupport = GetSupport( gPowerUp.xy );    \n    if ( gPowerUp.x > 0.0 )\n    {\n        if( gPowerUpState.x == STATE_RUN )\n        {        \n            gPowerUp.x += 2.0;\n            gPowerUp.y = gPowerUpState.y + 32.0 * sin( 5.0 * iTime );\n        }\n        else if( gPowerUpState.x == STATE_JUMP )\n        {\n            gPowerUpState.z += 1.0 \/ 30.0;\n            gPowerUp.x += 1.0;\n            gPowerUp.y += 4.5 * ( 1.0 - gPowerUpState.z );\n            if ( gPowerUpState.z > 1.0 && gPowerUp.y <= powerUpSupport )\n            {\n                if ( gPowerUp.y <= WATER_HEIGHT )\n                {\n                    gPowerUp.x = 0.0;\n                    gExplosion = vec4( gPowerUp.xy + vec2( 0.0, POWER_UP_SIZE.y * 0.5 ), 0.0, 0.0 );\n                }\n                else\n                {\t\n                    gPowerUp.y = powerUpSupport;\n                \tgPowerUpState.x = STATE_WATER;\n                }\n            } \n        }\n        \n        if ( gPowerUpState.x != STATE_RUN )\n        {\n            if ( Collide( gPlayer.xy, BILL_RUN_SIZE, gPowerUp.xy, POWER_UP_SIZE ) )\n            {\n                gPowerUp.x \t\t= 0.0;\n\t\t\t\tgPlayerWeapon \t= vec4( WEAPON_MACHINE_GUN, 0.0, MACHINE_GUN_FIRE_RATE, MACHINE_GUN_BULLET_NUM );\n            }  \n        }\n    }\n    \n    \/\/ first exploding bridge\n    if ( gPlayer.x > BRIDGE_0_START_TILE * 32.0 - 16.0 && gBridge.x == 0.0 )\n    {\n        gBridge.x \t= BRIDGE_0_START_TILE;\n        gBridge.y \t= 0.0;\n        gExplosion \t= vec4( gBridge.x * 32.0 + 16.0, 16.0 * 6.0, 0.0, 0.0 );\n    }\n    if ( gBridge.x > 0.0 && gBridge.x < BRIDGE_0_END_TILE - 1.0 )\n    {\n        ++gBridge.y;\n        if ( gBridge.y > BRIGDE_EXPLODE_TIME )\n        {\n            ++gBridge.x;\n            gBridge.y = 0.0;\n            gExplosion = vec4( gBridge.x * 32.0 + 16.0, 16.0 * 6.0, 0.0, 0.0 );\n        }\n    }\n    \n    \/\/ second exploding bridge\n    if ( gPlayer.x > BRIDGE_1_START_TILE * 32.0 - 16.0 && gBridge.x == BRIDGE_0_END_TILE - 1.0 )\n    {\n        gBridge.x \t= BRIDGE_1_START_TILE;\n        gBridge.y \t= 0.0;\n        gExplosion \t= vec4( gBridge.x * 32.0 + 16.0, 16.0 * 6.0, 0.0, 0.0 );\n    }\n    if ( gBridge.x >= BRIDGE_1_START_TILE - 1.0 && gBridge.x < BRIDGE_1_END_TILE - 1.0 )\n    {\n        ++gBridge.y;\n        if ( gBridge.y > BRIGDE_EXPLODE_TIME )\n        {\n            ++gBridge.x;\n            gBridge.y = 0.0;\n            gExplosion = vec4( gBridge.x * 32.0 + 16.0, 16.0 * 6.0, 0.0, 0.0 );\n        }\n    }    \n    \n\tUpdateSniper( gSniper, playerTarget );    \n\tUpdateTurret( gTurret0, gTurret0State, playerTarget );\n    UpdateTurret( gTurret1, gTurret1State, playerTarget );\n    UpdateBossCannon( gBossCannon0 );\n    UpdateBossCannon( gBossCannon1 );\n    \n    \/\/ explosion\n    if ( gExplosion.z >= 3.0 )\n    {\n        gExplosion.xy = vec2( 0.0 );\n    }\n    else\n    {\n        gExplosion.z += 0.2;\n    }\n    \n    \/\/ hits\n    if ( gHit.z >= 1.0 )\n    {\n\t\tgHit.xy = vec2( 0.0 );\n    }\n    else\n    {\n        gHit.z += 0.2;\n    }    \n    \n    fragColor = vec4( 0.0 );\n    StoreValue( txPlayer, gPlayer, fragColor, fragCoord );\n    StoreValue( txPlayerState, gPlayerState, fragColor, fragCoord );\n    StoreValue( txPlayerWeapon, gPlayerWeapon, fragColor, fragCoord );\n    StoreValue( txPlayerDir, gPlayerDir, fragColor, fragCoord );\n    StoreValue( txCamera, gCamera, fragColor, fragCoord );\n    StoreValue( txSoldier0, gSoldier0, fragColor, fragCoord );\n    StoreValue( txSoldier1, gSoldier1, fragColor, fragCoord );\n    StoreValue( txSoldier2, gSoldier2, fragColor, fragCoord );\n    StoreValue( txSoldier0State, gSoldier0State, fragColor, fragCoord );\n    StoreValue( txSoldier1State, gSoldier1State, fragColor, fragCoord );\n    StoreValue( txSoldier2State, gSoldier2State, fragColor, fragCoord );\n    StoreValue( txSniper, gSniper, fragColor, fragCoord );\n    StoreValue( txPlayerBullet0, gPlayerBullet0, fragColor, fragCoord );\n    StoreValue( txPlayerBullet1, gPlayerBullet1, fragColor, fragCoord );\n    StoreValue( txPlayerBullet2, gPlayerBullet2, fragColor, fragCoord );\n    StoreValue( txPlayerBullet3, gPlayerBullet3, fragColor, fragCoord );\n    StoreValue( txPlayerBullet4, gPlayerBullet4, fragColor, fragCoord );\n    StoreValue( txPlayerBullet5, gPlayerBullet5, fragColor, fragCoord );    \n    StoreValue( txEnemyBullet0, gEnemyBullet0, fragColor, fragCoord );\n    StoreValue( txEnemyBullet1, gEnemyBullet1, fragColor, fragCoord );\n    StoreValue( txEnemyBullet2, gEnemyBullet2, fragColor, fragCoord );\n    StoreValue( txEnemyBullet3, gEnemyBullet3, fragColor, fragCoord );\n    StoreValue( txExplosion, gExplosion, fragColor, fragCoord );\n    StoreValue( txHit, gHit, fragColor, fragCoord );\n    StoreValue( txTurret0, gTurret0, fragColor, fragCoord );\n    StoreValue( txTurret1, gTurret1, fragColor, fragCoord );\n    StoreValue( txTurret0State, gTurret0State, fragColor, fragCoord );\n    StoreValue( txTurret1State, gTurret1State, fragColor, fragCoord );    \n    StoreValue( txPowerUp, gPowerUp, fragColor, fragCoord );\n    StoreValue( txPowerUpState, gPowerUpState, fragColor, fragCoord );\n    StoreValue( txBossCore, gBossCore, fragColor, fragCoord );\n    StoreValue( txBossCannon0, gBossCannon0, fragColor, fragCoord );\n    StoreValue( txBossCannon1, gBossCannon1, fragColor, fragCoord );\n    StoreValue( txBossBullet0, gBossBullet0, fragColor, fragCoord );\n    StoreValue( txBossBullet1, gBossBullet1, fragColor, fragCoord );    \n    StoreValue( txGameState, gGameState, fragColor, fragCoord );\n    StoreValue( txBridge, gBridge, fragColor, fragCoord );\n    \n    \/\/ clear to 0 on first frame\n    fragColor = iFrame < 1 ? vec4( 0.0 ) : fragColor;\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\/\/ Background\n\n#define SPRITE_DEC_2( x, i ) mod( floor( i \/ pow( 2.0, mod( x, 24.0 ) ) ), 2.0 )\n#define SPRITE_DEC_3( x, i ) mod( floor( i \/ pow( 4.0, mod( x, 11.0 ) ) ), 4.0 )\n#define SPRITE_DEC_4( x, i ) mod( floor( i \/ pow( 4.0, mod( x, 8.0 ) ) ), 4.0 )\n#define RGB( r, g, b ) vec3( float( r ) \/ 255.0, float( g ) \/ 255.0, float( b ) \/ 255.0 )\n\nconst float NES_RES_X           = 224.0;\nconst float NES_RES_Y           = 192.0;\nconst float JUNGLE_START        = 32.0 * 52.0;\nconst float JUNGLE_END          = 32.0 * 108.0 + 16.0;\nconst float WATER_END           = 32.0 * 63.0;\nconst vec2  BOSS_CORE_SIZE      = vec2( 24.0, 31.0 );\nconst vec2  BOSS_CANNON_SIZE    = vec2( 14.0, 6.0 );\nconst float BRIDGE_0_START_TILE = 30.0;\nconst float BRIDGE_0_END_TILE   = 35.0;\nconst float BRIDGE_1_START_TILE = 40.0;\nconst float BRIDGE_1_END_TILE   = 45.0;\n\n\/\/ storage\nconst vec2 txPlayer \t\t\t= vec2( 0.0, 0.0 ); \t\/\/ xy - pos, z - jump start, w - jump dir\nconst vec2 txPlayerState\t\t= vec2( 1.0, 0.0 ); \t\/\/ x - state, y - frame, z - jump tick, w - lifes\nconst vec2 txPlayerDir\t\t\t= vec2( 2.0, 0.0 ); \t\/\/ xy - dir, z - flip, w - immortality\nconst vec2 txPlayerWeapon\t\t= vec2( 3.0, 0.0 ); \t\/\/ x - weapon, y - weapon cooldown, z - weapon fire rate, w - weapon bullet num\nconst vec2 txCamera \t\t\t= vec2( 4.0, 0.0 ); \t\/\/ x - cam offset, y - spawn counter, z - soldier spawn counter\nconst vec2 txSoldier0 \t\t\t= vec2( 5.0, 0.0 ); \t\/\/ xy - pos, z - flip\nconst vec2 txSoldier1 \t\t\t= vec2( 5.0, 1.0 ); \t\/\/ xy - pos, z - flip\nconst vec2 txSoldier2 \t\t\t= vec2( 5.0, 2.0 ); \t\/\/ xy - pos, z - flip\nconst vec2 txSoldier0State \t\t= vec2( 6.0, 0.0 ); \t\/\/ x - state, y - frame, z - jump tick\nconst vec2 txSoldier1State \t\t= vec2( 6.0, 1.0 ); \t\/\/ x - state, y - frame, z - jump tick\nconst vec2 txSoldier2State \t\t= vec2( 6.0, 2.0 ); \t\/\/ x - state, y - frame, z - jump tick\nconst vec2 txSniper\t \t\t\t= vec2( 7.0, 0.0 ); \t\/\/ xy - pos, z - flip, w - weapon cooldown\nconst vec2 txPlayerBullet0 \t\t= vec2( 8.0, 0.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txPlayerBullet1 \t\t= vec2( 8.0, 1.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txPlayerBullet2 \t\t= vec2( 8.0, 2.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txPlayerBullet3 \t\t= vec2( 8.0, 3.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txPlayerBullet4 \t\t= vec2( 8.0, 4.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txPlayerBullet5 \t\t= vec2( 8.0, 5.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txEnemyBullet0 \t\t= vec2( 9.0, 0.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txEnemyBullet1 \t\t= vec2( 9.0, 1.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txEnemyBullet2 \t\t= vec2( 9.0, 2.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txEnemyBullet3 \t\t= vec2( 9.0, 3.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txExplosion \t\t\t= vec2( 10.0, 0.0 ); \t\/\/ xy - pos, z - frame\nconst vec2 txHit \t\t\t\t= vec2( 11.0, 0.0 ); \t\/\/ xy - pos, z - frame\nconst vec2 txTurret0\t\t\t= vec2( 12.0, 0.0 ); \t\/\/ xy - pos, z - angle\nconst vec2 txTurret1\t\t\t= vec2( 12.0, 1.0 ); \t\/\/ xy - pos, z - angle\nconst vec2 txTurret0State\t\t= vec2( 13.0, 0.0 ); \t\/\/ x - HP, y - weapon cooldown\nconst vec2 txTurret1State\t\t= vec2( 13.0, 1.0 ); \t\/\/ x - HP, y - weapon cooldown\nconst vec2 txPowerUp\t\t\t= vec2( 14.0, 0.0 ); \t\/\/ xy - pos, z - frame\nconst vec2 txPowerUpState\t\t= vec2( 15.0, 0.0 ); \t\/\/ x - state, y - initial height, z - jump tick\nconst vec2 txBossCore\t\t\t= vec2( 16.0, 0.0 ); \t\/\/ xy - pos, z - HP\nconst vec2 txBossCannon0\t\t= vec2( 17.0, 0.0 ); \t\/\/ xy - pos, z - cooldown, w - HP\nconst vec2 txBossCannon1\t\t= vec2( 17.0, 1.0 ); \t\/\/ xy - pos, z - cooldown, w - HP\nconst vec2 txBossBullet0\t\t= vec2( 18.0, 0.0 ); \t\/\/ xy - pos, zw - velocity\nconst vec2 txBossBullet1\t\t= vec2( 18.0, 1.0 ); \t\/\/ xy - pos, zw - velocity\nconst vec2 txGameState\t\t\t= vec2( 19.0, 0.0 ); \t\/\/ x - state, y - state tick\nconst vec2 txBridge\t\t\t\t= vec2( 20.0, 0.0 ); \t\/\/ x - draw start, y - explode tick\n\nfloat Rand( vec2 co )\n{\n    return fract( sin( dot( co.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );\n}\n\nvec4 LoadValue( vec2 tx )\n{\n    return floor( texture( iChannel0, ( tx + 0.5 ) \/ iChannelResolution[ 0 ].xy ) );\n}\n\nvoid SpriteBush( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;    \n    \n    idx = y == 8.0 ? ( x <= 10.0 ? 1419584.0 : ( x <= 21.0 ? 1.0 : 1360.0 ) ) : idx;\n    idx = y == 7.0 ? ( x <= 10.0 ? 2796196.0 : ( x <= 21.0 ? 21.0 : 22176.0 ) ) : idx;\n    idx = y == 6.0 ? ( x <= 10.0 ? 2796201.0 : ( x <= 21.0 ? 87125.0 : 87721.0 ) ) : idx;\n    idx = y == 5.0 ? ( x <= 10.0 ? 2534058.0 : ( x <= 21.0 ? 436310.0 : 88681.0 ) ) : idx;\n    idx = y == 4.0 ? ( x <= 10.0 ? 1681065.0 : ( x <= 21.0 ? 365637.0 : 71061.0 ) ) : idx;\n    idx = y == 3.0 ? ( x <= 10.0 ? 1464937.0 : ( x <= 21.0 ? 91137.0 : 1381.0 ) ) : idx;\n    idx = y == 2.0 ? ( x <= 10.0 ? 1332565.0 : ( x <= 21.0 ? 283908.0 : 266564.0 ) ) : idx;\n    idx = y == 1.0 ? ( x <= 10.0 ? 332884.0 : ( x <= 21.0 ? 267328.0 : 65616.0 ) ) : idx;\n\n    idx = SPRITE_DEC_3( x, idx );\n\n    color = y >= 0.0 && y < 9.0 ? RGB( 0, 0, 0 ) : color;\n    color = idx == 1.0 ? RGB( 0,   144, 0 ) : color;\n    color = idx == 2.0 ? RGB( 144, 213, 0 ) : color;\n}\n\nvoid SpriteRockTop( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;    \n    \n    idx = y == 7.0 ? ( x <= 7.0 ? 20480.0 : ( x <= 15.0 ? 89.0 : ( x <= 23.0 ? 0.0 : 341.0 ) ) ) : idx;\n    idx = y == 6.0 ? ( x <= 7.0 ? 38144.0 : ( x <= 15.0 ? 5466.0 : ( x <= 23.0 ? 20480.0 : 5466.0 ) ) ) : idx;\n    idx = y == 5.0 ? ( x <= 7.0 ? 43604.0 : ( x <= 15.0 ? 21851.0 : ( x <= 23.0 ? 42305.0 : 1386.0 ) ) ) : idx;\n    idx = y == 4.0 ? ( x <= 7.0 ? 65168.0 : ( x <= 15.0 ? 21866.0 : ( x <= 23.0 ? 43345.0 : 1387.0 ) ) ) : idx;\n    idx = y == 3.0 ? ( x <= 7.0 ? 47680.0 : ( x <= 15.0 ? 21914.0 : ( x <= 23.0 ? 64144.0 : 5547.0 ) ) ) : idx;\n    idx = y == 2.0 ? ( x <= 7.0 ? 43269.0 : ( x <= 15.0 ? 5718.0 : ( x <= 23.0 ? 65188.0 : 5526.0 ) ) ) : idx;\n    idx = y == 1.0 ? ( x <= 7.0 ? 20584.0 : ( x <= 15.0 ? 1.0 : ( x <= 23.0 ? 60329.0 : 22102.0 ) ) ) : idx;\n    idx = y == 0.0 ? ( x <= 7.0 ? 5860.0 : ( x <= 15.0 ? 0.0 : ( x <= 23.0 ? 43769.0 : 22101.0 ) ) ) : idx;\n    \n    idx = SPRITE_DEC_4( x, idx );\n    idx = x >= 0.0 && x < 32.0 ? idx : 0.0;\n    \n    color = x >= 0.0 && x < 32.0 && y >= 0.0 && y < 8.0 ? RGB( 0, 0, 0 ) : color;\n    color = idx == 1.0 ? RGB( 68,  80,  0 ) : color;\n    color = idx == 2.0 ? RGB( 126, 126, 0 ) : color;\n    color = idx == 3.0 ? RGB( 208, 190, 0 ) : color;\n}\n\nvoid SpriteRock( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;    \n    \n    idx = y == 31.0 ? ( x <= 7.0 ? 5860.0 : ( x <= 15.0 ? 0.0 : ( x <= 23.0 ? 43769.0 : 22101.0 ) ) ) : idx;\n    idx = y == 30.0 ? ( x <= 7.0 ? 1444.0 : ( x <= 15.0 ? 1365.0 : ( x <= 23.0 ? 45049.0 : 22869.0 ) ) ) : idx;\n    idx = y == 29.0 ? ( x <= 7.0 ? 17809.0 : ( x <= 15.0 ? 6826.0 : ( x <= 23.0 ? 32420.0 : 22869.0 ) ) ) : idx;\n    idx = y == 28.0 ? ( x <= 7.0 ? 37201.0 : ( x <= 15.0 ? 27311.0 : ( x <= 23.0 ? 27284.0 : 25941.0 ) ) ) : idx;\n    idx = y == 27.0 ? ( x <= 7.0 ? 57669.0 : ( x <= 15.0 ? 27327.0 : ( x <= 23.0 ? 43668.0 : 25941.0 ) ) ) : idx;\n    idx = y == 26.0 ? ( x <= 7.0 ? 58373.0 : ( x <= 15.0 ? 43695.0 : ( x <= 23.0 ? 43601.0 : 38229.0 ) ) ) : idx;\n    idx = y == 25.0 ? ( x <= 7.0 ? 63765.0 : ( x <= 15.0 ? 43695.0 : ( x <= 23.0 ? 43345.0 : 38230.0 ) ) ) : idx;\n    idx = y == 24.0 ? ( x <= 7.0 ? 63764.0 : ( x <= 15.0 ? 43695.0 : ( x <= 23.0 ? 42322.0 : 38234.0 ) ) ) : idx;\n    idx = y == 23.0 ? ( x <= 7.0 ? 63748.0 : ( x <= 15.0 ? 43695.0 : ( x <= 23.0 ? 42310.0 : 21866.0 ) ) ) : idx;\n    idx = y == 22.0 ? ( x <= 7.0 ? 65088.0 : ( x <= 15.0 ? 43711.0 : ( x <= 23.0 ? 42266.0 : 5486.0 ) ) ) : idx;\n    idx = y == 21.0 ? ( x <= 7.0 ? 65092.0 : ( x <= 15.0 ? 43711.0 : ( x <= 23.0 ? 37914.0 : 5566.0 ) ) ) : idx;\n    idx = y == 20.0 ? ( x <= 7.0 ? 65088.0 : ( x <= 15.0 ? 43775.0 : ( x <= 23.0 ? 20570.0 : 5886.0 ) ) ) : idx;\n    idx = y == 19.0 ? ( x <= 7.0 ? 65089.0 : ( x <= 15.0 ? 43775.0 : ( x <= 23.0 ? 20570.0 : 5881.0 ) ) ) : idx;\n    idx = y == 18.0 ? ( x <= 7.0 ? 64145.0 : ( x <= 15.0 ? 44031.0 : ( x <= 23.0 ? 20570.0 : 1445.0 ) ) ) : idx;\n    idx = y == 17.0 ? ( x <= 7.0 ? 43664.0 : ( x <= 15.0 ? 44031.0 : ( x <= 23.0 ? 16730.0 : 1429.0 ) ) ) : idx;\n    idx = y == 16.0 ? ( x <= 7.0 ? 43664.0 : ( x <= 15.0 ? 44798.0 : ( x <= 23.0 ? 16730.0 : 18005.0 ) ) ) : idx;\n    idx = y == 15.0 ? ( x <= 7.0 ? 44004.0 : ( x <= 15.0 ? 22266.0 : ( x <= 23.0 ? 16741.0 : 18005.0 ) ) ) : idx;\n    idx = y == 14.0 ? ( x <= 7.0 ? 45049.0 : ( x <= 15.0 ? 21930.0 : ( x <= 23.0 ? 1381.0 : 1621.0 ) ) ) : idx;\n    idx = y == 13.0 ? ( x <= 7.0 ? 49065.0 : ( x <= 15.0 ? 21930.0 : ( x <= 23.0 ? 1429.0 : 1365.0 ) ) ) : idx;\n    idx = y == 12.0 ? ( x <= 7.0 ? 60073.0 : ( x <= 15.0 ? 21867.0 : ( x <= 23.0 ? 1429.0 : 340.0 ) ) ) : idx;\n    idx = y == 11.0 ? ( x <= 7.0 ? 43689.0 : ( x <= 15.0 ? 21846.0 : ( x <= 23.0 ? 1109.0 : 340.0 ) ) ) : idx;\n    idx = y == 10.0 ? ( x <= 7.0 ? 43690.0 : ( x <= 15.0 ? 21846.0 : ( x <= 23.0 ? 357.0 : 340.0 ) ) ) : idx;\n    idx = y == 9.0 ? ( x <= 7.0 ? 38566.0 : ( x <= 15.0 ? 21849.0 : ( x <= 23.0 ? 1049.0 : 336.0 ) ) ) : idx;\n    idx = y == 8.0 ? ( x <= 7.0 ? 25941.0 : ( x <= 15.0 ? 21849.0 : ( x <= 23.0 ? 4101.0 : 256.0 ) ) ) : idx;\n    idx = y == 7.0 ? ( x <= 7.0 ? 25941.0 : ( x <= 15.0 ? 21861.0 : ( x <= 23.0 ? 1.0 : 21.0 ) ) ) : idx;\n    idx = y == 6.0 ? ( x <= 7.0 ? 22868.0 : ( x <= 15.0 ? 23141.0 : ( x <= 23.0 ? 20480.0 : 361.0 ) ) ) : idx;\n    idx = y == 5.0 ? ( x <= 7.0 ? 21840.0 : ( x <= 15.0 ? 5525.0 : ( x <= 23.0 ? 42240.0 : 5546.0 ) ) ) : idx;\n    idx = y == 4.0 ? ( x <= 7.0 ? 20800.0 : ( x <= 15.0 ? 5377.0 : ( x <= 23.0 ? 64080.0 : 1451.0 ) ) ) : idx;\n    idx = y == 3.0 ? ( x <= 7.0 ? 4096.0 : ( x <= 15.0 ? 1024.0 : ( x <= 23.0 ? 65428.0 : 1391.0 ) ) ) : idx;\n    idx = y == 2.0 ? ( x <= 7.0 ? 16464.0 : ( x <= 15.0 ? 1024.0 : ( x <= 23.0 ? 65188.0 : 5531.0 ) ) ) : idx;\n    idx = y == 1.0 ? ( x <= 7.0 ? 5541.0 : ( x <= 15.0 ? 4097.0 : ( x <= 23.0 ? 60069.0 : 5526.0 ) ) ) : idx;\n    idx = y == 0.0 ? ( x <= 7.0 ? 23288.0 : ( x <= 15.0 ? 0.0 : ( x <= 23.0 ? 43705.0 : 22101.0 ) ) ) : idx;\n\n    idx = SPRITE_DEC_4( x, idx );\n    idx = x >= 0.0 && x < 32.0 ? idx : 0.0;\n    \n    color = x >= 0.0 && x < 32.0 && y >= 0.0 && y < 32.0 ? RGB( 0, 0, 0 ) : color;\n    color = idx == 1.0 ? RGB( 68,  80,  0 ) : color;\n    color = idx == 2.0 ? RGB( 126, 126, 0 ) : color;\n    color = idx == 3.0 ? RGB( 208, 190, 0 ) : color;\n}\n\nvoid SpriteTreeTrunk( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;\n    \n    idx = y == 1.0 ? 2918701.0 : idx;\n    idx = y == 0.0 ? 1263122.0 : idx;\n    \n    idx = SPRITE_DEC_2( x, idx );\n    \n    color = idx == 1.0 ? RGB( 64,  44,  0 ) : RGB( 0,  0,  0 );\n}\n\nvoid SpriteTreeStart( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;\n    \n\tidx = y == 22.0 ? 32768.0 : idx;\n\tidx = y == 21.0 ? 10240.0 : idx;\n\tidx = y == 20.0 ? 9088.0 : idx;\n\tidx = y == 19.0 ? 10976.0 : idx;\n\tidx = y == 18.0 ? 9016.0 : idx;\n\tidx = y == 17.0 ? 33580.0 : idx;\n\tidx = y == 16.0 ? 2874.0 : idx;\n\tidx = y == 15.0 ? 41644.0 : idx;\n\tidx = y == 14.0 ? 13240.0 : idx;\n\tidx = y == 13.0 ? 824.0 : idx;\n\tidx = y == 12.0 ? 4128.0 : idx;\n\tidx = y == 11.0 ? 17408.0 : idx;\n\tidx = y == 10.0 ? 1024.0 : idx;\n\tidx = y == 9.0 ? 34048.0 : idx;\n\tidx = y == 8.0 ? 33024.0 : idx;\n\tidx = y == 7.0 ? 0.0 : idx;\n\tidx = y == 6.0 ? 51840.0 : idx;\n\tidx = y == 5.0 ? 44000.0 : idx;\n\tidx = y == 4.0 ? 1760.0 : idx;\n\tidx = y == 3.0 ? 17584.0 : idx;\n\tidx = y == 2.0 ? 17440.0 : idx;\n\tidx = y == 1.0 ? 17440.0 : idx;\n\tidx = y == 0.0 ? 16384.0 : idx;\n    \n    idx = SPRITE_DEC_4( x, idx );\n    idx = x >= 0.0 && x < 8.0 ? idx : 0.0;\n\n    color = x >= 0.0 && x < 8.0 && y >= 0.0 && y < 24.0 ? RGB( 0, 0, 0 ) : color;\n    color = idx == 1.0 ? RGB( 64, 44, 0 ) : color;\n    color = idx == 2.0 ? RGB( 0, 148, 0 ) : color;    \n    color = idx == 3.0 ? RGB( 128, 208, 16 ) : color;\n}\n\nvoid SpriteTreeMiddle( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;\n    \n    idx = y == 23.0 ? ( x <= 7.0 ? 10240.0 : 0.0 ) : idx;\n    idx = y == 22.0 ? ( x <= 7.0 ? 48770.0 : 2688.0 ) : idx;\n    idx = y == 21.0 ? ( x <= 7.0 ? 10283.0 : 12266.0 ) : idx;\n    idx = y == 20.0 ? ( x <= 7.0 ? 32959.0 : 48059.0 ) : idx;\n    idx = y == 19.0 ? ( x <= 7.0 ? 58080.0 : 44782.0 ) : idx;\n    idx = y == 18.0 ? ( x <= 7.0 ? 35470.0 : 12012.0 ) : idx;\n    idx = y == 17.0 ? ( x <= 7.0 ? 8763.0 : 2248.0 ) : idx;\n    idx = y == 16.0 ? ( x <= 7.0 ? 35723.0 : 32898.0 ) : idx;\n    idx = y == 15.0 ? ( x <= 7.0 ? 11835.0 : 57866.0 ) : idx;\n    idx = y == 14.0 ? ( x <= 7.0 ? 15155.0 : 57896.0 ) : idx;\n    idx = y == 13.0 ? ( x <= 7.0 ? 60450.0 : 45240.0 ) : idx;\n    idx = y == 12.0 ? ( x <= 7.0 ? 60480.0 : 8930.0 ) : idx;\n    idx = y == 11.0 ? ( x <= 7.0 ? 60481.0 : 930.0 ) : idx;\n    idx = y == 10.0 ? ( x <= 7.0 ? 51280.0 : 4738.0 ) : idx;\n    idx = y == 9.0 ? ( x <= 7.0 ? 49234.0 : 4226.0 ) : idx;\n    idx = y == 8.0 ? ( x <= 7.0 ? 32848.0 : 4096.0 ) : idx;\n    idx = y == 7.0 ? ( x <= 7.0 ? 32852.0 : 16416.0 ) : idx;\n    idx = y == 6.0 ? ( x <= 7.0 ? 23.0 : 18528.0 ) : idx;\n    idx = y == 5.0 ? ( x <= 7.0 ? 30.0 : 18536.0 ) : idx;\n    idx = y == 4.0 ? ( x <= 7.0 ? 17464.0 : 18536.0 ) : idx;\n    idx = y == 3.0 ? ( x <= 7.0 ? 1064.0 : 18504.0 ) : idx;\n    idx = y == 2.0 ? ( x <= 7.0 ? 1312.0 : 16448.0 ) : idx;\n    idx = y == 1.0 ? ( x <= 7.0 ? 17668.0 : 18496.0 ) : idx;\n    idx = y == 0.0 ? ( x <= 7.0 ? 16660.0 : 16448.0 ) : idx;\n    \n    idx = SPRITE_DEC_4( x, idx );\n    idx = x >= 0.0 && x < 16.0 ? idx : 0.0;\n\n    color = x >= 0.0 && x < 16.0 && y >= 0.0 && y < 24.0 ? RGB( 0, 0, 0 ) : color;\n    color = idx == 1.0 ? RGB( 64, 44, 0 ) : color;\n    color = idx == 2.0 ? RGB( 0, 148, 0 ) : color;    \n    color = idx == 3.0 ? RGB( 128, 208, 16 ) : color;\n}\n\nvoid SpriteTreeEnd( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;\n    \n\tidx = y == 17.0 ? 960.0 : idx;\n\tidx = y == 16.0 ? 2744.0 : idx;\n\tidx = y == 15.0 ? 8227.0 : idx;\n\tidx = y == 14.0 ? 3022.0 : idx;\n\tidx = y == 13.0 ? 48674.0 : idx;\n\tidx = y == 12.0 ? 41136.0 : idx;\n\tidx = y == 11.0 ? 52192.0 : idx;\n\tidx = y == 10.0 ? 36516.0 : idx;\n\tidx = y == 9.0 ? 15140.0 : idx;\n\tidx = y == 8.0 ? 15108.0 : idx;\n\tidx = y == 7.0 ? 12292.0 : idx;\n\tidx = y == 6.0 ? 8452.0 : idx;\n\tidx = y == 5.0 ? 68.0 : idx;\n\tidx = y == 4.0 ? 68.0 : idx;\n\tidx = y == 3.0 ? 68.0 : idx;\n\tidx = y == 2.0 ? 20.0 : idx;\n\tidx = y == 1.0 ? 20.0 : idx;\n\tidx = y == 0.0 ? 20.0 : idx;\n    \n    idx = SPRITE_DEC_4( x, idx );\n    idx = x >= 0.0 && x < 8.0 ? idx : 0.0;\n\n    color = x >= 0.0 && x < 8.0 && y >= 0.0 && y < 24.0 ? RGB( 0, 0, 0 ) : color;\n    color = idx == 1.0 ? RGB( 64, 44, 0 ) : color;\n    color = idx == 2.0 ? RGB( 0, 148, 0 ) : color;    \n    color = idx == 3.0 ? RGB( 128, 208, 16 ) : color;\n}\n\nvoid SpriteBridge( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;\n    \n\tidx = y == 26.0 ? ( x <= 10.0 ? 349509.0 : ( x <= 21.0 ? 1381717.0 : 349269.0 ) ) : idx;\n\tidx = y == 25.0 ? ( x <= 10.0 ? 349573.0 : ( x <= 21.0 ? 1447254.0 : 350293.0 ) ) : idx;\n\tidx = y == 24.0 ? ( x <= 10.0 ? 2184545.0 : ( x <= 21.0 ? 1410389.0 : 349717.0 ) ) : idx;\n\tidx = y == 23.0 ? ( x <= 10.0 ? 2184545.0 : ( x <= 21.0 ? 1410389.0 : 349717.0 ) ) : idx;\n\tidx = y == 22.0 ? ( x <= 10.0 ? 1594712.0 : ( x <= 21.0 ? 1401173.0 : 349573.0 ) ) : idx;\n\tidx = y == 21.0 ? ( x <= 10.0 ? 1594712.0 : ( x <= 21.0 ? 1401173.0 : 349573.0 ) ) : idx;\n\tidx = y == 20.0 ? ( x <= 10.0 ? 2730665.0 : ( x <= 21.0 ? 2795178.0 : 699034.0 ) ) : idx;\n\tidx = y == 19.0 ? ( x <= 10.0 ? 1594712.0 : ( x <= 21.0 ? 1398101.0 : 349573.0 ) ) : idx;\n\tidx = y == 18.0 ? ( x <= 10.0 ? 546136.0 : ( x <= 21.0 ? 0.0 : 349576.0 ) ) : idx;\n\tidx = y == 17.0 ? ( x <= 10.0 ? 524288.0 : ( x <= 21.0 ? 0.0 : 8.0 ) ) : idx;\n\tidx = y == 16.0 ? ( x <= 10.0 ? 567976.0 : ( x <= 21.0 ? 0.0 : 699016.0 ) ) : idx;\n\tidx = y == 15.0 ? ( x <= 10.0 ? 2643288.0 : ( x <= 21.0 ? 2796202.0 : 349578.0 ) ) : idx;\n\tidx = y == 14.0 ? ( x <= 10.0 ? 1594712.0 : ( x <= 21.0 ? 1398101.0 : 349573.0 ) ) : idx;\n\tidx = y == 11.0 ? ( x <= 10.0 ? 26729.0 : ( x <= 21.0 ? 2204672.0 : 6.0 ) ) : idx;\n\tidx = y == 10.0 ? ( x <= 10.0 ? 5140.0 : ( x <= 21.0 ? 1069056.0 : 1.0 ) ) : idx;\n\tidx = y == 9.0 ? ( x <= 10.0 ? 1397865.0 : ( x <= 21.0 ? 1156437.0 : 349525.0 ) ) : idx;\n\tidx = y == 8.0 ? ( x <= 10.0 ? 2791700.0 : ( x <= 21.0 ? 2380458.0 : 699049.0 ) ) : idx;\n\tidx = y == 7.0 ? ( x <= 10.0 ? 1393769.0 : ( x <= 21.0 ? 1156437.0 : 349524.0 ) ) : idx;\n\tidx = y == 6.0 ? ( x <= 10.0 ? 20.0 : ( x <= 21.0 ? 20480.0 : 0.0 ) ) : idx;\n\tidx = y == 5.0 ? ( x <= 10.0 ? 105.0 : ( x <= 21.0 ? 107520.0 : 0.0 ) ) : idx;\n\tidx = y == 4.0 ? ( x <= 10.0 ? 20.0 : ( x <= 21.0 ? 20480.0 : 0.0 ) ) : idx;\n\tidx = y == 3.0 ? ( x <= 10.0 ? 1398149.0 : ( x <= 21.0 ? 1447253.0 : 349525.0 ) ) : idx;\n\tidx = y == 2.0 ? ( x <= 10.0 ? 2796193.0 : ( x <= 21.0 ? 2786986.0 : 699050.0 ) ) : idx;\n\tidx = y == 1.0 ? ( x <= 10.0 ? 1398113.0 : ( x <= 21.0 ? 1410389.0 : 349525.0 ) ) : idx;\n\tidx = y == 0.0 ? ( x <= 10.0 ? 1398085.0 : ( x <= 21.0 ? 1381717.0 : 349525.0 ) ) : idx;  \n\n    idx = SPRITE_DEC_3( x, idx );\n    idx = x >= 0.0 && x < 32.0 ? idx : 0.0;\n    \n    color = x >= 0.0 && x < 32.0 && y >= 0.0 && y < 13.0 ? RGB( 0, 0, 0 ) : color;\n    \n    float blink = abs( sin( iTime * 3.0 ) ) + 0.5;\n    color = x >= 12.0 && x < 24.0 && y >= 17.0 && y < 19.0 ? blink * RGB( 228, 68, 52 ) : color;\n    color = idx == 1.0 ? RGB( 179, 179, 179 ) : color;\n    color = idx == 2.0 ? RGB( 255, 255, 255 ) : color;    \n}\n\nvoid SpriteGrass( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;\n    \n    idx = y == 15.0 ? ( x <= 10.0 ? 1398096.0 : ( x <= 21.0 ? 1398101.0 : 87381.0 ) ) : idx;\n    idx = y == 14.0 ? ( x <= 10.0 ? 1398101.0 : ( x <= 21.0 ? 1398101.0 : 349525.0 ) ) : idx;\n    idx = y == 13.0 ? ( x <= 10.0 ? 1398101.0 : ( x <= 21.0 ? 1398101.0 : 349525.0 ) ) : idx;\n    idx = y == 12.0 ? ( x <= 10.0 ? 1398101.0 : ( x <= 21.0 ? 1398101.0 : 349525.0 ) ) : idx;\n    idx = y == 11.0 ? ( x <= 10.0 ? 1398102.0 : ( x <= 21.0 ? 1398101.0 : 349525.0 ) ) : idx;\n    idx = y == 10.0 ? ( x <= 10.0 ? 1418921.0 : ( x <= 21.0 ? 1398102.0 : 419158.0 ) ) : idx;\n    idx = y == 9.0 ? ( x <= 10.0 ? 2779749.0 : ( x <= 21.0 ? 2796202.0 : 285353.0 ) ) : idx;\n    idx = y == 8.0 ? ( x <= 10.0 ? 2796197.0 : ( x <= 21.0 ? 2791078.0 : 345494.0 ) ) : idx;\n    idx = y == 7.0 ? ( x <= 10.0 ? 1681049.0 : ( x <= 21.0 ? 1468826.0 : 70997.0 ) ) : idx;\n    idx = y == 6.0 ? ( x <= 10.0 ? 2517412.0 : ( x <= 21.0 ? 2463126.0 : 280153.0 ) ) : idx;\n    idx = y == 5.0 ? ( x <= 10.0 ? 1681057.0 : ( x <= 21.0 ? 2459241.0 : 71013.0 ) ) : idx;\n    idx = y == 4.0 ? ( x <= 10.0 ? 2468240.0 : ( x <= 21.0 ? 1448218.0 : 267413.0 ) ) : idx;\n    idx = y == 3.0 ? ( x <= 10.0 ? 1137172.0 : ( x <= 21.0 ? 332905.0 : 20818.0 ) ) : idx;\n    idx = y == 2.0 ? ( x <= 10.0 ? 1148161.0 : ( x <= 21.0 ? 332900.0 : 325.0 ) ) : idx;\n    idx = y == 1.0 ? ( x <= 10.0 ? 16640.0 : ( x <= 21.0 ? 69648.0 : 68.0 ) ) : idx;\n    \n    idx = SPRITE_DEC_3( x, idx );\n    idx = x >= 0.0 && x < 32.0 ? idx : 0.0;\n\n    color = x >= 0.0 && x < 32.0 && y >= 0.0 && y < 16.0 ? RGB( 0, 0, 0 ) : color;\n    color = idx == 1.0 ? RGB( 0,   144, 0 ) : color;\n    color = idx == 2.0 ? RGB( 144, 213, 0 ) : color;\n}\n\nvoid SpriteLeaves( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;\n    \n    idx = y == 29.0 ? ( x <= 7.0 ? 8224.0 : ( x <= 15.0 ? 514.0 : ( x <= 23.0 ? 10400.0 : 41122.0 ) ) ) : idx;\n    idx = y == 28.0 ? ( x <= 7.0 ? 35330.0 : ( x <= 15.0 ? 2110.0 : ( x <= 23.0 ? 14496.0 : 35723.0 ) ) ) : idx;\n    idx = y == 27.0 ? ( x <= 7.0 ? 41090.0 : ( x <= 15.0 ? 995.0 : ( x <= 23.0 ? 12996.0 : 11788.0 ) ) ) : idx;\n    idx = y == 26.0 ? ( x <= 7.0 ? 14466.0 : ( x <= 15.0 ? 3595.0 : ( x <= 23.0 ? 58256.0 : 14380.0 ) ) ) : idx;\n    idx = y == 25.0 ? ( x <= 7.0 ? 36352.0 : ( x <= 15.0 ? 2223.0 : ( x <= 23.0 ? 57860.0 : 47928.0 ) ) ) : idx;\n    idx = y == 24.0 ? ( x <= 7.0 ? 58240.0 : ( x <= 15.0 ? 8958.0 : ( x <= 23.0 ? 57424.0 : 64312.0 ) ) ) : idx;\n    idx = y == 23.0 ? ( x <= 7.0 ? 47810.0 : ( x <= 15.0 ? 2956.0 : ( x <= 23.0 ? 12288.0 : 51772.0 ) ) ) : idx;\n    idx = y == 22.0 ? ( x <= 7.0 ? 14338.0 : ( x <= 15.0 ? 3631.0 : ( x <= 23.0 ? 0.0 : 52012.0 ) ) ) : idx;\n    idx = y == 21.0 ? ( x <= 7.0 ? 35842.0 : ( x <= 15.0 ? 2091.0 : ( x <= 23.0 ? 10250.0 : 776.0 ) ) ) : idx;\n    idx = y == 20.0 ? ( x <= 7.0 ? 51200.0 : ( x <= 15.0 ? 50.0 : ( x <= 23.0 ? 8352.0 : 712.0 ) ) ) : idx;\n    idx = y == 19.0 ? ( x <= 7.0 ? 34818.0 : ( x <= 15.0 ? 40992.0 : ( x <= 23.0 ? 43650.0 : 32896.0 ) ) ) : idx;\n    idx = y == 18.0 ? ( x <= 7.0 ? 40.0 : ( x <= 15.0 ? 2048.0 : ( x <= 23.0 ? 552.0 : 2570.0 ) ) ) : idx;\n    idx = y == 17.0 ? ( x <= 7.0 ? 128.0 : ( x <= 15.0 ? 11256.0 : ( x <= 23.0 ? 8367.0 : 8232.0 ) ) ) : idx;\n    idx = y == 16.0 ? ( x <= 7.0 ? 42.0 : ( x <= 15.0 ? 64010.0 : ( x <= 23.0 ? 35458.0 : 35328.0 ) ) ) : idx;\n    idx = y == 15.0 ? ( x <= 7.0 ? 128.0 : ( x <= 15.0 ? 44960.0 : ( x <= 23.0 ? 34863.0 : 49282.0 ) ) ) : idx;\n    idx = y == 14.0 ? ( x <= 7.0 ? 32783.0 : ( x <= 15.0 ? 3055.0 : ( x <= 23.0 ? 12472.0 : 63522.0 ) ) ) : idx;\n    idx = y == 13.0 ? ( x <= 7.0 ? 63544.0 : ( x <= 15.0 ? 63738.0 : ( x <= 23.0 ? 58080.0 : 52736.0 ) ) ) : idx;\n    idx = y == 12.0 ? ( x <= 7.0 ? 11778.0 : ( x <= 15.0 ? 33772.0 : ( x <= 23.0 ? 52111.0 : 50050.0 ) ) ) : idx;\n    idx = y == 11.0 ? ( x <= 7.0 ? 49195.0 : ( x <= 15.0 ? 16014.0 : ( x <= 23.0 ? 2606.0 : 45187.0 ) ) ) : idx;\n    idx = y == 10.0 ? ( x <= 7.0 ? 64686.0 : ( x <= 15.0 ? 14383.0 : ( x <= 23.0 ? 3128.0 : 60419.0 ) ) ) : idx;\n    idx = y == 9.0 ? ( x <= 7.0 ? 11020.0 : ( x <= 15.0 ? 57599.0 : ( x <= 23.0 ? 3248.0 : 58114.0 ) ) ) : idx;\n    idx = y == 8.0 ? ( x <= 7.0 ? 35532.0 : ( x <= 15.0 ? 50419.0 : ( x <= 23.0 ? 35040.0 : 12800.0 ) ) ) : idx;\n    idx = y == 7.0 ? ( x <= 7.0 ? 57480.0 : ( x <= 15.0 ? 50050.0 : ( x <= 23.0 ? 227.0 : 12304.0 ) ) ) : idx;\n    idx = y == 6.0 ? ( x <= 7.0 ? 45232.0 : ( x <= 15.0 ? 35595.0 : ( x <= 23.0 ? 131.0 : 8257.0 ) ) ) : idx;\n    idx = y == 5.0 ? ( x <= 7.0 ? 59428.0 : ( x <= 15.0 ? 3640.0 : ( x <= 23.0 ? 258.0 : 20.0 ) ) ) : idx;\n    idx = y == 4.0 ? ( x <= 7.0 ? 35361.0 : ( x <= 15.0 ? 10272.0 : ( x <= 23.0 ? 1104.0 : 32833.0 ) ) ) : idx;\n    idx = y == 3.0 ? ( x <= 7.0 ? 33284.0 : ( x <= 15.0 ? 8354.0 : ( x <= 23.0 ? 261.0 : 8212.0 ) ) ) : idx;\n    idx = y == 2.0 ? ( x <= 7.0 ? 1105.0 : ( x <= 15.0 ? 8706.0 : ( x <= 23.0 ? 1104.0 : 10305.0 ) ) ) : idx;\n    idx = y == 1.0 ? ( x <= 7.0 ? 260.0 : ( x <= 15.0 ? 532.0 : ( x <= 23.0 ? 261.0 : 8212.0 ) ) ) : idx;\n    idx = y == 0.0 ? ( x <= 7.0 ? 1105.0 : ( x <= 15.0 ? 16449.0 : ( x <= 23.0 ? 1104.0 : 2113.0 ) ) ) : idx;\n    \n    idx = SPRITE_DEC_4( x, idx );\n\n    color = RGB( 0, 0, 0 );\n    color = idx == 1.0 ? RGB( 64,  44,  0  ) : color;\n    color = idx == 2.0 ? RGB( 0,   148, 0  ) : color;    \n    color = idx == 3.0 ? RGB( 128, 208, 16 ) : color;\n}\n\nvoid SpriteShoreSide( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;    \n    \n\tidx = y == 19.0 ? 43.0 : idx;\n\tidx = y == 18.0 ? 190.0 : idx;\n\tidx = y == 17.0 ? 2025.0 : idx;\n\tidx = y == 16.0 ? 3773.0 : idx;\n\tidx = y == 15.0 ? 3050.0 : idx;\n\tidx = y == 14.0 ? 445.0 : idx;\n\tidx = y == 13.0 ? 2981.0 : idx;\n\tidx = y == 12.0 ? 765.0 : idx;\n\tidx = y == 11.0 ? 4005.0 : idx;\n\tidx = y == 10.0 ? 6869.0 : idx;\n\tidx = y == 9.0 ? 3669.0 : idx;\n\tidx = y == 8.0 ? 15189.0 : idx;\n\tidx = y == 7.0 ? 3029.0 : idx;\n\tidx = y == 6.0 ? 16037.0 : idx;\n\tidx = y == 5.0 ? 11221.0 : idx;\n\tidx = y == 4.0 ? 32341.0 : idx;\n\tidx = y == 3.0 ? 43989.0 : idx;\n\tidx = y == 2.0 ? 64853.0 : idx;\n\tidx = y == 1.0 ? 22869.0 : idx;\n\tidx = y == 0.0 ? 21850.0 : idx;\n    \n    idx = SPRITE_DEC_4( x, idx );\n    \n    float blink = fract( iTime * 3.0 );\n    idx = blink > 0.5 && ( idx == 2.0 || idx == 3.0 ) ? 5.0 - idx : idx;\n    \n    color = y >= 0.0 && y < 20.0 ? RGB( 0, 0, 0 ) : color;\n    color = idx == 1.0 ? RGB( 0,   112, 236 ) : color;\n    color = idx == 2.0 ? RGB( 60,  188, 252 ) : color;\n    color = idx == 3.0 ? RGB( 255, 255, 255 ) : color;\n}\n\nvoid SpriteShore( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;    \n    \n    idx = y == 6.0 ? 0.0 : idx;\n    idx = y == 5.0 ? ( x <= 7.0 ? 65024.0 : ( x <= 15.0 ? 2.0 : ( x <= 23.0 ? 760.0 : 188.0 ) ) ) : idx;\n    idx = y == 4.0 ? ( x <= 7.0 ? 43904.0 : ( x <= 15.0 ? 60143.0 : ( x <= 23.0 ? 2990.0 : 3051.0 ) ) ) : idx;\n    idx = y == 3.0 ? ( x <= 7.0 ? 24303.0 : ( x <= 15.0 ? 49061.0 : ( x <= 23.0 ? 48789.0 : 61095.0 ) ) ) : idx;\n    idx = y == 2.0 ? ( x <= 7.0 ? 21926.0 : ( x <= 15.0 ? 21909.0 : ( x <= 23.0 ? 58709.0 : 42902.0 ) ) ) : idx;\n    idx = y == 1.0 ? ( x <= 7.0 ? 38229.0 : ( x <= 15.0 ? 22869.0 : ( x <= 23.0 ? 21845.0 : 21925.0 ) ) ) : idx;\n    idx = y == 0.0 ? ( x <= 7.0 ? 21865.0 : ( x <= 15.0 ? 22137.0 : 21845.0 ) ) : idx;\n    \n    idx = SPRITE_DEC_4( x, idx );\n    \n    float blink = fract( iTime * 3.0 );\n    idx = blink > 0.5 && ( idx == 2.0 || idx == 3.0 ) ? 5.0 - idx : idx;\n    \n    color = RGB( 0, 0, 0 );\n    color = idx == 1.0 ? RGB( 0,   112, 236 ) : color;\n    color = idx == 2.0 ? RGB( 60,  188, 252 ) : color;\n    color = idx == 3.0 ? RGB( 255, 255, 255 ) : color;\n}\n\nvoid SpriteBossCore( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;\n    \n    idx = y == 30.0 ? ( x <= 7.0 ? 21844.0 : ( x <= 15.0 ? 85.0 : 0.0 ) ) : idx;\n    idx = y == 29.0 ? ( x <= 7.0 ? 65533.0 : ( x <= 15.0 ? 21845.0 : 5461.0 ) ) : idx;\n    idx = y == 28.0 ? ( x <= 7.0 ? 43689.0 : ( x <= 15.0 ? 65345.0 : 28671.0 ) ) : idx;\n    idx = y == 27.0 ? ( x <= 7.0 ? 43689.0 : ( x <= 15.0 ? 43861.0 : 21930.0 ) ) : idx;\n    idx = y == 26.0 ? ( x <= 7.0 ? 43685.0 : ( x <= 15.0 ? 43841.0 : 21610.0 ) ) : idx;\n    idx = y == 25.0 ? ( x <= 7.0 ? 43665.0 : ( x <= 15.0 ? 43861.0 : 21850.0 ) ) : idx;\n    idx = y == 24.0 ? ( x <= 7.0 ? 43605.0 : ( x <= 15.0 ? 43841.0 : 27462.0 ) ) : idx;\n    idx = y == 23.0 ? ( x <= 7.0 ? 43293.0 : ( x <= 15.0 ? 43861.0 : 27605.0 ) ) : idx;\n    idx = y == 22.0 ? ( x <= 7.0 ? 42361.0 : ( x <= 15.0 ? 27457.0 : 23476.0 ) ) : idx;\n    idx = y == 21.0 ? ( x <= 7.0 ? 20969.0 : ( x <= 15.0 ? 23381.0 : 27565.0 ) ) : idx;\n    idx = y == 20.0 ? ( x <= 7.0 ? 38825.0 : ( x <= 15.0 ? 17855.0 : 23467.0 ) ) : idx;\n    idx = y == 19.0 ? ( x <= 7.0 ? 26281.0 : ( x <= 15.0 ? 55009.0 : 27562.0 ) ) : idx;\n    idx = y == 18.0 ? ( x <= 7.0 ? 26276.0 : ( x <= 15.0 ? 38592.0 : 32746.0 ) ) : idx;\n    idx = y == 17.0 ? ( x <= 7.0 ? 22928.0 : ( x <= 15.0 ? 39808.0 : 23162.0 ) ) : idx;\n    idx = y == 16.0 ? ( x <= 7.0 ? 6544.0 : ( x <= 15.0 ? 39808.0 : 23390.0 ) ) : idx;\n    idx = y == 15.0 ? ( x <= 7.0 ? 6544.0 : ( x <= 15.0 ? 39808.0 : 23390.0 ) ) : idx;\n    idx = y == 14.0 ? ( x <= 7.0 ? 6544.0 : ( x <= 15.0 ? 39808.0 : 23390.0 ) ) : idx;\n    idx = y == 13.0 ? ( x <= 7.0 ? 6564.0 : ( x <= 15.0 ? 39808.0 : 23390.0 ) ) : idx;\n    idx = y == 12.0 ? ( x <= 7.0 ? 22953.0 : ( x <= 15.0 ? 39808.0 : 23162.0 ) ) : idx;\n    idx = y == 11.0 ? ( x <= 7.0 ? 26281.0 : ( x <= 15.0 ? 38592.0 : 32746.0 ) ) : idx;\n    idx = y == 10.0 ? ( x <= 7.0 ? 26281.0 : ( x <= 15.0 ? 38625.0 : 27562.0 ) ) : idx;\n    idx = y == 9.0 ? ( x <= 7.0 ? 38569.0 : ( x <= 15.0 ? 17850.0 : 23466.0 ) ) : idx;\n    idx = y == 8.0 ? ( x <= 7.0 ? 20905.0 : ( x <= 15.0 ? 24405.0 : 27561.0 ) ) : idx;\n    idx = y == 7.0 ? ( x <= 7.0 ? 46441.0 : ( x <= 15.0 ? 27457.0 : 23460.0 ) ) : idx;\n    idx = y == 6.0 ? ( x <= 7.0 ? 44313.0 : ( x <= 15.0 ? 43861.0 : 27541.0 ) ) : idx;\n    idx = y == 5.0 ? ( x <= 7.0 ? 43861.0 : ( x <= 15.0 ? 43841.0 : 27462.0 ) ) : idx;\n    idx = y == 4.0 ? ( x <= 7.0 ? 43729.0 : ( x <= 15.0 ? 43861.0 : 21850.0 ) ) : idx;\n    idx = y == 3.0 ? ( x <= 7.0 ? 45045.0 : ( x <= 15.0 ? 43841.0 : 21610.0 ) ) : idx;\n    idx = y == 2.0 ? ( x <= 7.0 ? 62804.0 : ( x <= 15.0 ? 65365.0 : 21930.0 ) ) : idx;\n    idx = y == 1.0 ? ( x <= 7.0 ? 21504.0 : ( x <= 15.0 ? 21845.0 : 27391.0 ) ) : idx;\n    idx = y == 0.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 20480.0 : 5461.0 ) ) : idx;\n    \n    idx = SPRITE_DEC_4( x, idx );\n    idx = x >= 0.0 && x < 24.0 ? idx : 0.0;\n\n    float blink = abs( sin( iTime * 3.0 ) ) + 0.5;\n    color = idx == 1.0 ? RGB( 0,   0,   0   ) : color;\n    color = idx == 2.0 ? RGB( 192, 192, 192 ) : color;\n    color = idx == 3.0 ? RGB( 255, 255, 255 ) : color;\n    color = idx == 0.0 && x >= 1.0 && x < 21.0 && y >= 3.0 && y < 30.0 ? blink * RGB( 228, 68, 52 ) : color;\n}\n\nvoid SpriteBossCannonBase( inout vec3 color, float x, float y )\n{\n\tfloat idx = 0.0;\n    \n\tidx = y == 41.0 ? ( x <= 7.0 ? 11606.0 : ( x <= 15.0 ? 395.0 : ( x <= 23.0 ? 43584.0 : 21946.0 ) ) ) : idx;\n\tidx = y == 40.0 ? ( x <= 7.0 ? 11611.0 : ( x <= 15.0 ? 32774.0 : ( x <= 23.0 ? 43595.0 : 22250.0 ) ) ) : idx;\n\tidx = y == 39.0 ? ( x <= 7.0 ? 6491.0 : ( x <= 15.0 ? 11520.0 : ( x <= 23.0 ? 43298.0 : 22250.0 ) ) ) : idx;\n\tidx = y == 38.0 ? ( x <= 7.0 ? 366.0 : ( x <= 15.0 ? 35042.0 : ( x <= 23.0 ? 43275.0 : 23466.0 ) ) ) : idx;\n\tidx = y == 37.0 ? ( x <= 7.0 ? 5486.0 : ( x <= 15.0 ? 11532.0 : ( x <= 23.0 ? 42082.0 : 43946.0 ) ) ) : idx;\n\tidx = y == 36.0 ? ( x <= 7.0 ? 5562.0 : ( x <= 15.0 ? 35042.0 : ( x <= 23.0 ? 41995.0 : 21850.0 ) ) ) : idx;\n\tidx = y == 35.0 ? ( x <= 7.0 ? 5866.0 : ( x <= 15.0 ? 11532.0 : ( x <= 23.0 ? 20578.0 : 5.0 ) ) ) : idx;\n\tidx = y == 34.0 ? ( x <= 7.0 ? 5866.0 : ( x <= 15.0 ? 35042.0 : ( x <= 23.0 ? 11.0 : 27744.0 ) ) ) : idx;\n\tidx = y == 33.0 ? ( x <= 7.0 ? 11178.0 : ( x <= 15.0 ? 11532.0 : ( x <= 23.0 ? 24674.0 : 27756.0 ) ) ) : idx;\n\tidx = y == 32.0 ? ( x <= 7.0 ? 5466.0 : ( x <= 15.0 ? 35042.0 : ( x <= 23.0 ? 24587.0 : 27756.0 ) ) ) : idx;\n\tidx = y == 31.0 ? ( x <= 7.0 ? 21.0 : ( x <= 15.0 ? 11532.0 : ( x <= 23.0 ? 24674.0 : 27756.0 ) ) ) : idx;\n\tidx = y == 30.0 ? ( x <= 7.0 ? 11264.0 : ( x <= 15.0 ? 35042.0 : ( x <= 23.0 ? 24587.0 : 27756.0 ) ) ) : idx;\n\tidx = y == 29.0 ? ( x <= 7.0 ? 11372.0 : ( x <= 15.0 ? 11532.0 : ( x <= 23.0 ? 24674.0 : 27756.0 ) ) ) : idx;\n\tidx = y == 28.0 ? ( x <= 7.0 ? 11372.0 : ( x <= 15.0 ? 35042.0 : ( x <= 23.0 ? 24587.0 : 27756.0 ) ) ) : idx;\n\tidx = y == 27.0 ? ( x <= 7.0 ? 11372.0 : ( x <= 15.0 ? 11532.0 : ( x <= 23.0 ? 24674.0 : 21612.0 ) ) ) : idx;\n\tidx = y == 26.0 ? ( x <= 7.0 ? 11372.0 : ( x <= 15.0 ? 35042.0 : ( x <= 23.0 ? 20491.0 : 84.0 ) ) ) : idx;\n\tidx = y == 25.0 ? ( x <= 7.0 ? 11372.0 : ( x <= 15.0 ? 11532.0 : ( x <= 23.0 ? 98.0 : 27648.0 ) ) ) : idx;\n\tidx = y == 24.0 ? ( x <= 7.0 ? 5228.0 : ( x <= 15.0 ? 35042.0 : ( x <= 23.0 ? 24587.0 : 27756.0 ) ) ) : idx;\n\tidx = y == 23.0 ? ( x <= 7.0 ? 84.0 : ( x <= 15.0 ? 11532.0 : ( x <= 23.0 ? 24674.0 : 27756.0 ) ) ) : idx;\n\tidx = y == 22.0 ? ( x <= 7.0 ? 11264.0 : ( x <= 15.0 ? 35042.0 : ( x <= 23.0 ? 24587.0 : 27756.0 ) ) ) : idx;\n\tidx = y == 21.0 ? ( x <= 7.0 ? 11372.0 : ( x <= 15.0 ? 11532.0 : ( x <= 23.0 ? 24674.0 : 27756.0 ) ) ) : idx;\n\tidx = y == 20.0 ? ( x <= 7.0 ? 11372.0 : ( x <= 15.0 ? 35042.0 : ( x <= 23.0 ? 24587.0 : 27756.0 ) ) ) : idx;\n\tidx = y == 19.0 ? ( x <= 7.0 ? 11372.0 : ( x <= 15.0 ? 11532.0 : ( x <= 23.0 ? 24674.0 : 21612.0 ) ) ) : idx;\n\tidx = y == 18.0 ? ( x <= 7.0 ? 11372.0 : ( x <= 15.0 ? 35042.0 : ( x <= 23.0 ? 20491.0 : 84.0 ) ) ) : idx;\n\tidx = y == 17.0 ? ( x <= 7.0 ? 11372.0 : ( x <= 15.0 ? 11532.0 : ( x <= 23.0 ? 98.0 : 27648.0 ) ) ) : idx;\n\tidx = y == 16.0 ? ( x <= 7.0 ? 5228.0 : ( x <= 15.0 ? 35042.0 : ( x <= 23.0 ? 24587.0 : 27756.0 ) ) ) : idx;\n\tidx = y == 15.0 ? ( x <= 7.0 ? 11348.0 : ( x <= 15.0 ? 11532.0 : ( x <= 23.0 ? 24674.0 : 27756.0 ) ) ) : idx;\n\tidx = y == 14.0 ? ( x <= 7.0 ? 11264.0 : ( x <= 15.0 ? 35042.0 : ( x <= 23.0 ? 24587.0 : 11372.0 ) ) ) : idx;\n\tidx = y == 13.0 ? ( x <= 7.0 ? 11372.0 : ( x <= 15.0 ? 11532.0 : ( x <= 23.0 ? 24674.0 : 35948.0 ) ) ) : idx;\n\tidx = y == 12.0 ? ( x <= 7.0 ? 11372.0 : ( x <= 15.0 ? 35042.0 : ( x <= 23.0 ? 24587.0 : 34924.0 ) ) ) : idx;\n\tidx = y == 11.0 ? ( x <= 7.0 ? 11372.0 : ( x <= 15.0 ? 11532.0 : ( x <= 23.0 ? 24674.0 : 57452.0 ) ) ) : idx;\n\tidx = y == 10.0 ? ( x <= 7.0 ? 11372.0 : ( x <= 15.0 ? 35042.0 : ( x <= 23.0 ? 20491.0 : 57428.0 ) ) ) : idx;\n\tidx = y == 9.0 ? ( x <= 7.0 ? 5228.0 : ( x <= 15.0 ? 11532.0 : ( x <= 23.0 ? 98.0 : 47104.0 ) ) ) : idx;\n\tidx = y == 8.0 ? ( x <= 7.0 ? 108.0 : ( x <= 15.0 ? 35042.0 : ( x <= 23.0 ? 4107.0 : 47125.0 ) ) ) : idx;\n\tidx = y == 7.0 ? ( x <= 7.0 ? 84.0 : ( x <= 15.0 ? 11532.0 : ( x <= 23.0 ? 98.0 : 44544.0 ) ) ) : idx;\n\tidx = y == 6.0 ? ( x <= 7.0 ? 16128.0 : ( x <= 15.0 ? 0.0 : ( x <= 23.0 ? 0.0 : 45044.0 ) ) ) : idx;\n\tidx = y == 5.0 ? ( x <= 7.0 ? 10752.0 : ( x <= 15.0 ? 43689.0 : ( x <= 23.0 ? 5467.0 : 47780.0 ) ) ) : idx;\n\tidx = y == 4.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 43689.0 : ( x <= 23.0 ? 5467.0 : 0.0 ) ) ) : idx;\n\tidx = y == 3.0 ? ( x <= 7.0 ? 10896.0 : ( x <= 15.0 ? 43689.0 : ( x <= 23.0 ? 5467.0 : 64169.0 ) ) ) : idx;\n\tidx = y == 2.0 ? ( x <= 7.0 ? 10916.0 : ( x <= 15.0 ? 43689.0 : ( x <= 23.0 ? 17755.0 : 44714.0 ) ) ) : idx;\n\tidx = y == 1.0 ? ( x <= 7.0 ? 15017.0 : ( x <= 15.0 ? 43689.0 : ( x <= 23.0 ? 37211.0 : 43946.0 ) ) ) : idx;\n\tidx = y == 0.0 ? ( x <= 7.0 ? 15017.0 : ( x <= 15.0 ? 43689.0 : ( x <= 23.0 ? 37211.0 : 43946.0 ) ) ) : idx;\n\n    idx = SPRITE_DEC_4( x, idx );\n    idx = x >= 0.0 && x < 32.0 ? idx : 0.0;    \n    \n    color = idx == 0.0 && x >= 0.0 && x < 32.0 && y >= 0.0 && y < 42.0 ? RGB( 0, 0, 0 ) : color;\n    color = idx == 1.0 ? RGB( 4,   88,  180 ) : color;\n    color = idx == 2.0 ? RGB( 192, 192, 192 ) : color;\n    color = idx == 3.0 ? RGB( 255, 255, 255 ) : color;    \n}\n\nvoid SpriteBossTopPanel( inout vec3 color, float x, float y )\n{\n\tfloat idx = 0.0;    \n\n\tidx = y == 51.0 ? ( x <= 7.0 ? 16384.0 : 10922.0 ) : idx;\n\tidx = y == 50.0 ? ( x <= 7.0 ? 62464.0 : 9558.0 ) : idx;\n\tidx = y == 49.0 ? ( x <= 7.0 ? 61248.0 : 9558.0 ) : idx;\n\tidx = y == 48.0 ? ( x <= 7.0 ? 60148.0 : 9558.0 ) : idx;\n\tidx = y == 47.0 ? ( x <= 7.0 ? 60078.0 : 9558.0 ) : idx;\n\tidx = y == 46.0 ? ( x <= 7.0 ? 58793.0 : 9558.0 ) : idx;\n\tidx = y == 45.0 ? ( x <= 7.0 ? 57433.0 : 9558.0 ) : idx;\n\tidx = y == 44.0 ? ( x <= 7.0 ? 57353.0 : 9558.0 ) : idx;\n\tidx = y == 43.0 ? ( x <= 7.0 ? 61193.0 : 9558.0 ) : idx;\n\tidx = y == 42.0 ? ( x <= 7.0 ? 60153.0 : 9558.0 ) : idx;\n\tidx = y == 41.0 ? ( x <= 7.0 ? 58761.0 : 9558.0 ) : idx;\n\tidx = y == 40.0 ? ( x <= 7.0 ? 57609.0 : 9558.0 ) : idx;\n\tidx = y == 39.0 ? ( x <= 7.0 ? 61193.0 : 9558.0 ) : idx;\n\tidx = y == 38.0 ? ( x <= 7.0 ? 60153.0 : 9558.0 ) : idx;\n\tidx = y == 37.0 ? ( x <= 7.0 ? 58761.0 : 9558.0 ) : idx;\n\tidx = y == 36.0 ? ( x <= 7.0 ? 57609.0 : 9558.0 ) : idx;\n\tidx = y == 35.0 ? ( x <= 7.0 ? 61193.0 : 9558.0 ) : idx;\n\tidx = y == 34.0 ? ( x <= 7.0 ? 60153.0 : 9558.0 ) : idx;\n\tidx = y == 33.0 ? ( x <= 7.0 ? 58761.0 : 9558.0 ) : idx;\n\tidx = y == 32.0 ? ( x <= 7.0 ? 57609.0 : 9558.0 ) : idx;\n\tidx = y == 31.0 ? ( x <= 7.0 ? 61193.0 : 9558.0 ) : idx;\n\tidx = y == 30.0 ? ( x <= 7.0 ? 60153.0 : 9558.0 ) : idx;\n\tidx = y == 29.0 ? ( x <= 7.0 ? 58761.0 : 9558.0 ) : idx;\n\tidx = y == 28.0 ? ( x <= 7.0 ? 57609.0 : 9558.0 ) : idx;\n\tidx = y == 27.0 ? ( x <= 7.0 ? 61193.0 : 9558.0 ) : idx;\n\tidx = y == 26.0 ? ( x <= 7.0 ? 60153.0 : 9558.0 ) : idx;\n\tidx = y == 25.0 ? ( x <= 7.0 ? 58761.0 : 9558.0 ) : idx;\n\tidx = y == 24.0 ? ( x <= 7.0 ? 57609.0 : 9558.0 ) : idx;\n\tidx = y == 23.0 ? ( x <= 7.0 ? 61193.0 : 10582.0 ) : idx;\n\tidx = y == 22.0 ? ( x <= 7.0 ? 60153.0 : 11606.0 ) : idx;\n\tidx = y == 21.0 ? ( x <= 7.0 ? 58761.0 : 11606.0 ) : idx;\n\tidx = y == 20.0 ? ( x <= 7.0 ? 57609.0 : 11606.0 ) : idx;\n\tidx = y == 19.0 ? ( x <= 7.0 ? 61193.0 : 11606.0 ) : idx;\n\tidx = y == 18.0 ? ( x <= 7.0 ? 60153.0 : 11606.0 ) : idx;\n\tidx = y == 17.0 ? ( x <= 7.0 ? 58761.0 : 11606.0 ) : idx;\n\tidx = y == 16.0 ? ( x <= 7.0 ? 57609.0 : 11606.0 ) : idx;\n\tidx = y == 15.0 ? ( x <= 7.0 ? 61193.0 : 11606.0 ) : idx;\n\tidx = y == 14.0 ? ( x <= 7.0 ? 60153.0 : 11606.0 ) : idx;\n\tidx = y == 13.0 ? ( x <= 7.0 ? 58761.0 : 11606.0 ) : idx;\n\tidx = y == 12.0 ? ( x <= 7.0 ? 57609.0 : 11606.0 ) : idx;\n\tidx = y == 11.0 ? ( x <= 7.0 ? 59913.0 : 11606.0 ) : idx;\n\tidx = y == 10.0 ? ( x <= 7.0 ? 60073.0 : 11606.0 ) : idx;\n\tidx = y == 9.0 ? ( x <= 7.0 ? 65449.0 : 11611.0 ) : idx;\n\tidx = y == 8.0 ? ( x <= 7.0 ? 60158.0 : 6491.0 ) : idx;\n\tidx = y == 7.0 ? ( x <= 7.0 ? 43684.0 : 366.0 ) : idx;\n\tidx = y == 6.0 ? ( x <= 7.0 ? 43684.0 : 5486.0 ) : idx;\n\tidx = y == 5.0 ? ( x <= 7.0 ? 43664.0 : 5562.0 ) : idx;\n\tidx = y == 4.0 ? ( x <= 7.0 ? 43664.0 : 5866.0 ) : idx;\n\tidx = y == 3.0 ? ( x <= 7.0 ? 43584.0 : 5866.0 ) : idx;\n\tidx = y == 2.0 ? ( x <= 7.0 ? 43264.0 : 11178.0 ) : idx;\n\tidx = y == 1.0 ? ( x <= 7.0 ? 43264.0 : 5466.0 ) : idx;\n\tidx = y == 0.0 ? ( x <= 7.0 ? 21504.0 : 21.0 ) : idx;\n    \n    idx = SPRITE_DEC_4( x, idx );\n    idx = x >= 0.0 && x < 15.0 ? idx : 0.0;    \n    \n    color = idx == 0.0 && x >= 0.0 && x < 15.0 && y >= 8.0 && y < 48.0 ? RGB( 0, 0, 0 ) : color;\n    color = idx == 1.0 ? RGB( 4,   88,  180 ) : color;\n    color = idx == 2.0 ? RGB( 192, 192, 192 ) : color;\n    color = idx == 3.0 ? RGB( 255, 255, 255 ) : color;        \n}\n\nvoid SpriteBossCannon0( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;\n    \n\tidx = y == 5.0 ? ( x <= 7.0 ? 39340.0 : 1706.0 ) : idx;\n\tidx = y == 4.0 ? ( x <= 7.0 ? 30663.0 : 2044.0 ) : idx;\n\tidx = y == 3.0 ? ( x <= 7.0 ? 17415.0 : 1024.0 ) : idx;\n\tidx = y == 2.0 ? ( x <= 7.0 ? 30663.0 : 2044.0 ) : idx;\n\tidx = y == 1.0 ? ( x <= 7.0 ? 26615.0 : 2047.0 ) : idx;\n\tidx = y == 0.0 ? ( x <= 7.0 ? 39340.0 : 682.0 ) : idx;\n\n    idx = SPRITE_DEC_4( x, idx );\n    idx = x >= 0.0 && x < 14.0 ? idx : 0.0;\n\n    color = idx == 0.0 && x >= 1.0 && x < 11.0 && y >= 0.0 && y < 6.0 ? RGB( 255, 255, 255 ) : color;    \n    color = idx == 1.0 ? RGB( 0,   0,   0 )   : color;\n    color = idx == 2.0 ? RGB( 4,   88,  180 ) : color;\n    color = idx == 3.0 ? RGB( 192, 192, 192 ) : color;\n}\n\nvoid SpriteBossCannon1( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;\n    \n\tidx = y == 5.0 ? ( x <= 7.0 ? 39340.0 : 1706.0 ) : idx;\n\tidx = y == 4.0 ? ( x <= 7.0 ? 30663.0 : 2044.0 ) : idx;\n\tidx = y == 3.0 ? ( x <= 7.0 ? 17415.0 : 256.0 ) : idx;\n\tidx = y == 2.0 ? ( x <= 7.0 ? 30663.0 : 508.0 ) : idx;\n\tidx = y == 1.0 ? ( x <= 7.0 ? 26615.0 : 127.0 ) : idx;\n\tidx = y == 0.0 ? ( x <= 7.0 ? 39340.0 : 106.0 ) : idx;\n\n    idx = SPRITE_DEC_4( x, idx );\n    idx = x >= 0.0 && x < 14.0 ? idx : 0.0;\n\n    color = idx == 0.0 && x >= 1.0 && x < 12.0 && y >= 0.0 && y < 6.0 ? RGB( 255, 255, 255 ) : color;    \n    color = idx == 1.0 ? RGB( 0,   0,   0 )   : color;\n    color = idx == 2.0 ? RGB( 4,   88,  180 ) : color;\n    color = idx == 3.0 ? RGB( 192, 192, 192 ) : color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float resMultX      = floor( iResolution.x \/ NES_RES_X );\n    float resMultY      = floor( iResolution.y \/ NES_RES_Y );\n    float resRcp        = 1.0 \/ max( min( resMultX, resMultY ), 1.0 );\n    float screenWidth   = floor( iResolution.x * resRcp );\n    float screenHeight  = floor( iResolution.y * resRcp );\n    float pixelX        = floor( fragCoord.x * resRcp );\n    float pixelY        = floor( fragCoord.y * resRcp );\n    \n    vec4 camera         = LoadValue( txCamera );\n    vec4 bridge         = LoadValue( txBridge );\n    vec4 bossCore       = LoadValue( txBossCore );\n    vec4 bossCannon0    = LoadValue( txBossCannon0 );\n    vec4 bossCannon1    = LoadValue( txBossCannon1 );\n    \n    float worldX        = pixelX + camera.x;\n    float worldY        = pixelY - 8.0;\n    float tileX         = floor( worldX \/ 32.0 );\n    float tile8X        = floor( worldX \/ 8.0 );\n    float tile32Y       = floor( worldY \/ 32.0 );\n    float tile16Y       = floor( worldY \/ 16.0 );\n    float tile8Y        = floor( worldY \/ 8.0 );\n    float worldXMod16   = mod( worldX, 16.0 );\n    float worldYMod16   = mod( worldY, 16.0 );    \n    float worldYMod8    = mod( worldY,  8.0 );\n    float worldXMod32   = mod( worldX, 32.0 );\n    float worldYMod32   = mod( worldY, 32.0 );\n    \n\n    vec3 color = RGB( 0, 0, 0 );\n    \n    \/\/ stars\n    float starRand = Rand( vec2( worldX * 0.01, worldY * 0.01 ) );\n    if ( starRand > 0.998 && worldY > 160.0 )\n    {\n        color = fract( iTime + starRand * 113.17 + worldX * 3.14 ) < 0.5 ? RGB( 255, 255, 255 ) : RGB( 0, 112, 236 );\n    }\n    \n    \/\/ background water\n    if ( worldY < 80.0 && worldX < WATER_END )\n    {\n        color = RGB( 0, 112, 236 );\n    }\n   \n    if ( worldX >= JUNGLE_START + 3.0 && worldX < JUNGLE_END )\n    {\n        SpriteTreeTrunk( color, mod( worldX - 3.0, 16.0 ), mod( worldY, 2.0 ) );    \n        \n    }\n\n    if ( worldX >= JUNGLE_START + 3.0 && worldX < JUNGLE_END && floor( ( worldY + 5.0 ) \/ 32.0 ) == 6.0 )\n    {\n        SpriteLeaves( color, mod( worldX - 3.0, 32.0 ), mod( worldY + 5.0, 32.0 ) );\n    }\n    \n    bool grass0 = false;\n    bool grass2 = false;\n    bool grass3 = false;\n    bool grass4 = false;\n    bool grass6 = false;\n    bool grass8 = false;\n    \n    if (        ( tileX >= 52.0 && tileX < 67.0 ) \n            ||  ( tileX >= 72.0 && tileX < 77.0 )   \n            ||  ( tileX >= 86.0 && tileX < 88.0 ) )\n    {\n        grass8 = true;\n    }\n    \n    if (        ( tileX >= 3.0   && tileX < 30.0 ) \n            ||  ( tileX >= 35.0  && tileX < 40.0 ) \n            ||  ( tileX >= 45.0  && tileX < 53.0 ) \n            ||  ( tileX >= 66.0  && tileX < 73.0 )\n            ||  ( tileX >= 78.0  && tileX < 80.0 )\n            ||  ( tileX >= 85.0  && tileX < 87.0 )\n            ||  ( tileX >= 89.0  && tileX < 91.0 )\n            ||  ( tileX >= 102.0 && tileX < 106.0 ) )\n    {\n        grass6 = true;\n    }\n    \n    if (        ( tileX >= 10.0 && tileX < 13.0 )\n            ||  ( tileX >= 18.0 && tileX < 20.0 )\n            ||  ( tileX >= 58.0 && tileX < 65.0 )\n            ||  ( tileX >= 76.0 && tileX < 79.0 )\n            ||  ( tileX >= 81.0 && tileX < 83.0 )\n            ||  ( tileX >= 90.0 && tileX < 95.0 )\n            ||  ( tileX >= 100.0 && tileX < 102.0 )\n            ||  ( tileX == 106.0 ) )\n    {\n        grass4 = true;\n    }\n    \n    if (        ( tileX >= 26.0 && tileX < 29.0 )\n            ||  ( tileX >= 55.0 && tileX < 57.0 )\n            ||  ( tileX == 74.0 )\n            ||  ( tileX == 87.0 )\n            ||  ( tileX >= 103.0 && tileX < 106.0 ) )\n    {\n        grass3 = true;\n    }\n        \n    if (        ( tileX == 13.0 || tileX == 16.0 )\n            ||  ( tileX >= 68.0 && tileX < 70.0 )\n            ||  ( tileX >= 71.0 && tileX < 73.0 )\n            ||  ( tileX >= 82.0 && tileX < 85.0 )\n            ||  ( tileX >= 97.0 && tileX < 99.0 )\n            ||  ( tileX == 107.0 ) )\n    {\n        grass2 = true;\n    }\n        \n    if (        ( tileX >= 14.0 && tileX < 16.0 ) \n            ||  ( tileX >= 24.0 && tileX < 26.0 ) \n            ||  ( tileX >= 52.0 && tileX < 55.0 ) \n            ||  ( tileX >= 62.0 && tileX < 68.0 )\n            ||  ( tileX == 81.0 )\n            ||  ( tileX == 86.0 )\n            ||  ( tileX >= 93.0 && tileX < 96.0 )\n            ||  ( tileX >= 102.0 ) )      \n    {\n        grass0 = true;\n    }\n    \n    float rockTile32Y = -1.0;\n    if ( grass2 )\n    {\n        rockTile32Y = 1.0;\n    }       \n    if ( grass4 )\n    {\n        rockTile32Y = 2.0;\n    }        \n    if ( grass6 )\n    {\n        rockTile32Y = 3.0;\n    }\n    if ( grass8 )\n    {\n        rockTile32Y = 4.0;\n    }    \n    \n    if ( tile32Y < rockTile32Y )\n    {\n        SpriteRock( color, worldXMod32, mod( worldY + 8.0, 32.0 ) );    \n    }\n    \n    if (        ( tile8Y == -1.0 && grass0 ) \n            ||  ( tile8Y == 3.0 && grass2 )\n            ||  ( tile8Y == 5.0 && grass3 )\n            ||  ( tile8Y == 7.0 && grass4 )\n            ||  ( tile8Y == 11.0 && grass6 )\n            ||  ( tile8Y == 15.0 && grass8 ) )\n    {\n        SpriteRockTop( color, worldXMod32, worldYMod8 );\n    }    \n    \n    \/\/ foreground water\n    if ( ( worldY < 16.0 && worldX < WATER_END ) \n        || ( tile16Y < 2.0 && (\n                    ( tileX < 10.0 ) \n                ||  ( tileX == 17.0 )\n                ||  ( tileX >= 20.0 && tileX < 23.0 )\n                ||  ( tileX >= 33.0 && tileX < 47.0 )\n                ||  ( tileX == 57.0 ) \n           ) )\n       )\n    {\n        color = RGB( 0, 112, 236 );\n    }    \n    \n    if (    ( floor( ( worldY - 1.0 ) \/ 8.0 ) == 3.0 && ( ( tileX >= 3.0 && tileX < 10.0 ) || ( tileX == 17.0 ) || ( tileX >= 20.0 && tileX < 23.0 ) || ( tileX >= 35.0 && tileX < 40.0 ) || ( tileX >= 45.0 && tileX < 47.0 ) || ( tileX == 57.0 ) ) )\n         || ( floor( ( worldY - 1.0 ) \/ 8.0 ) == 1.0 && ( ( tileX >= 10.0 && tileX < 17.0 ) || ( tileX >= 18.0 && tileX < 20.0 ) || ( tileX >= 23.0 && tileX < 30.0 ) || ( tileX >= 47.0 && tileX < 57.0 ) || ( tileX >= 58.0 && tileX < 63.0 ) ) )\n         || ( floor( ( worldY - 1.0 ) \/ 8.0 ) == -1.0 && ( ( tileX >= 14.0 && tileX < 16.0 ) || ( tileX >= 24.0 && tileX < 26.0 ) || ( tileX >= 52.0 && tileX < 55.0 ) || ( tileX == 62.0 ) ) )\n       )\n    {\n        SpriteShore( color, mod( worldX, 32.0 ), mod( worldY - 1.0, 8.0 ) );  \n    }    \n    \n    if ( floor( ( worldY ) \/ 24.0 ) == 1.0 && ( tile8X == 11.0 || tile8X == 139.0 || tile8X == 160.0 || tile8X == 179.0 ) )\n    {\n        float shoreX = ( tile8X == 160.0 ) ? 7.0 - worldX : worldX;\n        SpriteShoreSide( color, mod( shoreX, 8.0 ), mod( worldY, 24.0 ) );\n    }        \n    \n\tif ( floor( ( worldY + 14.0 ) \/ 24.0 ) == 1.0 && ( tile8X == 39.0 || tile8X == 68.0 || tile8X == 72.0 || tile8X == 80.0 || tile8X == 91.0 || tile8X == 120.0 || tile8X == 187.0 || tile8X == 228.0 || tile8X == 231.0 ) )\n    {\n        float shoreX = ( tile8X == 68.0 || tile8X == 80.0 || tile8X == 120.0 || tile8X == 228.0 ) ? 7.0 - worldX : worldX;\n        SpriteShoreSide( color, mod( shoreX, 8.0 ), mod( worldY + 14.0, 24.0 ) );\n    }    \n    \n    if ( floor( ( worldY + 6.0 ) \/ 24.0 ) == 0.0 && ( tile8X == 55.0 || tile8X == 64.0 || tile8X == 95.0 || tile8X == 104.0 || tile8X == 207.0 || tile8X == 220.0 || tile8X == 247.0 ) )\n    {\n        float shoreX = ( tile8X == 64.0 || tile8X == 104.0 || tile8X == 220.0 ) ? 7.0 - worldX : worldX;\n    \tSpriteShoreSide( color, mod( shoreX, 8.0 ), mod( worldY + 6.0, 24.0 ) );\n    }\n    \n    if (        ( tile16Y == 0.0 && grass0 ) \n            ||  ( tile16Y == 2.0 && grass2 )\n            ||  ( tile16Y == 3.0 && grass3 )\n            ||  ( tile16Y == 4.0 && grass4 )\n            ||  ( tile16Y == 6.0 && grass6 )\n            ||  ( tile16Y == 8.0 && grass8 ) )\n    {\n        SpriteGrass( color, worldXMod32, worldYMod16 );\n    }\n    \n    if (        ( grass8 && tile16Y == 9.0 )\n            ||  ( !grass8 && grass6 && tile16Y == 7.0 )\n            ||  ( !grass8 && !grass6 && grass4 && tile16Y == 5.0 )\n            ||  ( !grass8 && !grass6 && !grass4 && grass2 && tile16Y == 3.0 )\n            ||  ( !grass8 && !grass6 && !grass4 && !grass2 && grass0 && tile16Y == 1.0 ) )\n    {\n        SpriteBush( color, worldXMod32, worldYMod16 );\n    }\n    \n    if ( floor( ( worldY - 1.0 ) \/ 24.0 ) == 5.0 && ( \n                ( tileX >= 3.0 && tileX < 30.0 ) \n            ||  ( tileX >= 35.0 && tileX < 40.0 )\n            ||  ( tileX >= 45.0 && tileX < 52.0 )) )\n    {\n\t\tSpriteTreeMiddle( color, mod( worldX + 8.0, 16.0 ), mod( worldY - 1.0, 24.0 ) );\n    }\n    \n    if ( floor( ( worldY - 1.0 ) \/ 24.0 ) == 5.0 && \n        ( ( tile8X == 12.0 || tile8X == 34.0 || tile8X == 140.0 || tile8X == 180.0 )\n        || ( mod( tile8X, 16.0 ) == 0.0 ) && tile8X < 119.0 ) )\n    {\n    \tSpriteTreeStart( color, mod( worldX, 8.0 ), mod( worldY - 1.0, 24.0 ) );\n    }\n    \n    if ( floor( ( worldY - 1.0 ) \/ 24.0 ) == 5.0 && \n        ( ( tile8X == 119.0 || tile8X == 159.0 || tile8X == 207.0 )\n        || ( mod( tile8X + 1.0, 16.0 ) == 0.0 ) && tile8X < 119.0 ) )\n    {\n    \tSpriteTreeEnd( color, mod( worldX, 8.0 ), mod( worldY - 1.0, 24.0 ) );\n    }    \n    \n    if ( floor( ( worldY + 12.0 ) \/ 32.0 ) == 3.0 && bridge.x < tileX && (\n            ( tileX >= BRIDGE_0_START_TILE && tileX < BRIDGE_0_END_TILE )\n        ||  ( tileX >= BRIDGE_1_START_TILE && tileX < BRIDGE_1_END_TILE )\n       ) )\n    {\n        SpriteBridge( color, worldXMod32, mod( worldY + 12.0, 32.0 ) );\n    }  \n    \n    \/\/ boss back\n    if ( worldX > 3506.0 && worldY < 168.0 )\n    {\n        float idx = 2.0;\n                \n        \/\/ horizontal bars\n        idx = mod( worldX, 16.0 ) == 0.0 && mod( worldY + 8.0, 88.0 ) < 76.0 ? 3.0 : idx;\n        idx = mod( worldX + 8.0, 16.0 ) == 0.0 && mod( worldY + 8.0, 88.0 ) < 76.0 ? 1.0 : idx;\n        idx = mod( worldX, 16.0 ) > 8.0 && mod( worldY + 8.0, 88.0 ) == 76.0 ? 1.0 : idx;\n        \n        \/\/ vertical bars\n        idx = mod( worldY + 8.0, 88.0 ) == 0.0 ? 1.0 : idx;\n        idx = mod( worldY + 9.0, 88.0 ) == 0.0 ? 3.0 : idx;\n        idx = mod( worldY + 10.0, 88.0 ) == 0.0 ? 4.0 : idx;\n        idx = mod( worldY + 11.0, 88.0 ) == 0.0 ? 3.0 : idx;\n        idx = mod( worldY + 12.0, 88.0 ) == 0.0 ? 3.0 : idx;\n        idx = mod( worldY + 13.0, 88.0 ) == 0.0 ? 1.0 : idx;\n        idx = worldX == 3506.0 + 1.0 ? 3.0 : idx;\n        idx = worldX == 3506.0 + 2.0 ? 4.0 : idx;\n        \n        color = idx == 1.0 ? RGB( 0,   0,   0   ) : color;\n        color = idx == 2.0 ? RGB( 4,   88,  180 ) : color;\n        color = idx == 3.0 ? RGB( 192, 192, 192 ) : color;\n        color = idx == 4.0 ? RGB( 255, 255, 255 ) : color;\n    }\n    \n    \/\/ boss front\n    if ( worldX >= 3476.0 && worldX <= 3506.0 && worldY >= 16.0 && worldY <= 152.0 + floor( 0.5 * ( worldX - 3476.0 ) ) )\n    {\n        float idx = 3.0;\n        \n        \/\/ vertical bars\n        idx = mod( worldX, 4.0 ) == 0.0       ? 1.0 : idx;\n        idx = mod( worldX - 1.0, 8.0 ) == 0.0 ? 4.0 : idx;\n        idx = mod( worldX - 3.0, 8.0 ) == 0.0 ? 2.0 : idx;\n        \n        \/\/ top\n        idx = worldY == 152.0 + floor( 0.5 * ( worldX - 3476.0 ) ) ? 2.0 : idx;\n        \n        \/\/ middle\n        idx = worldY == 83.0 && worldX < 3504.0 ? 1.0 : idx;\n        idx = worldY == 82.0 && worldX >= 3477.0 && worldX < 3504.0 ? 3.0 : idx;\n        idx = worldY == 81.0 && worldX >= 3477.0 && worldX < 3504.0 ? 3.0 : idx;\n        idx = worldY == 81.0 && mod( worldX + 4.0, 8.0 ) > 4.0 && worldX < 3504.0 ? 1.0 : idx;\n        \n        \/\/ bottom\n        idx = worldY < 20.0 - floor( 0.2 * ( worldX - 3476.0 ) ) ? 1.0 : idx;\n        idx = worldY == 20.0 - floor( 0.2 * ( worldX - 3476.0 ) ) ? 2.0 : idx;\n        \n        \n        color = idx == 1.0 ? RGB( 0,   0,   0   ) : color;\n        color = idx == 2.0 ? RGB( 4,   88,  180 ) : color;\n        color = idx == 3.0 ? RGB( 192, 192, 192 ) : color;\n        color = idx == 4.0 ? RGB( 255, 255, 255 ) : color;        \n    }\n    \n    SpriteBossCore( color, worldX - bossCore.x + BOSS_CORE_SIZE.x * 0.5, worldY - bossCore.y );\n    SpriteBossCannonBase( color, worldX - 3477.0, worldY - 84.0 );\n    SpriteBossTopPanel( color, worldX - 3469.0, worldY - 116.0 );\n    SpriteBossTopPanel( color, worldX - 3493.0, worldY - 120.0 );\n    SpriteBossCannon0( color, worldX - bossCannon0.x + BOSS_CANNON_SIZE.x * 0.5, worldY - bossCannon0.y );\n    SpriteBossCannon1( color, worldX - bossCannon1.x + BOSS_CANNON_SIZE.x * 0.5, worldY - bossCannon1.y );\n    \n    fragColor = vec4( color, 1.0 );\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\/\/ Foreground\n\n#define SPRITE_DEC_2( x, i ) mod( floor( i \/ pow( 2.0, mod( x, 24.0 ) ) ), 2.0 )\n#define SPRITE_DEC_3( x, i ) mod( floor( i \/ pow( 4.0, mod( x, 11.0 ) ) ), 4.0 )\n#define SPRITE_DEC_4( x, i ) mod( floor( i \/ pow( 4.0, mod( x, 8.0 ) ) ), 4.0 )\n#define RGB( r, g, b ) vec3( float( r ) \/ 255.0, float( g ) \/ 255.0, float( b ) \/ 255.0 )\n\nconst float NES_RES_X           = 224.0;\nconst float NES_RES_Y           = 192.0;\nconst float STATE_RUN           = 0.0;\nconst float STATE_PRONE         = 1.0;\nconst float STATE_JUMP          = 2.0;\nconst float STATE_FALL          = 3.0;\nconst float STATE_WATER         = 4.0;\nconst float STATE_UNDER_WATER   = 5.0;\nconst vec2  BILL_PRONE_SIZE     = vec2( 32.0, 18.0 );\nconst vec2  BILL_RUN_SIZE       = vec2( 24.0, 34.0 );\nconst vec2  BILL_JUMP_SIZE      = vec2( 20.0, 20.0 );\nconst vec2  SOLDIER_SIZE        = vec2( 18.0, 32.0 );\nconst vec2  SNIPER_SIZE         = vec2( 24.0, 32.0 );\nconst vec2  TURRET_SIZE         = vec2( 32.0, 32.0 );\nconst vec2  BOSS_CORE_SIZE      = vec2( 24.0, 31.0 );\n\n\/\/ storage\nconst vec2 txPlayer \t\t\t= vec2( 0.0, 0.0 ); \t\/\/ xy - pos, z - jump start, w - jump dir\nconst vec2 txPlayerState\t\t= vec2( 1.0, 0.0 ); \t\/\/ x - state, y - frame, z - jump tick, w - lifes\nconst vec2 txPlayerDir\t\t\t= vec2( 2.0, 0.0 ); \t\/\/ xy - dir, z - flip, w - immortality\nconst vec2 txPlayerWeapon\t\t= vec2( 3.0, 0.0 ); \t\/\/ x - weapon, y - weapon cooldown, z - weapon fire rate, w - weapon bullet num\nconst vec2 txCamera \t\t\t= vec2( 4.0, 0.0 ); \t\/\/ x - cam offset, y - spawn counter, z - soldier spawn counter\nconst vec2 txSoldier0 \t\t\t= vec2( 5.0, 0.0 ); \t\/\/ xy - pos, z - flip\nconst vec2 txSoldier1 \t\t\t= vec2( 5.0, 1.0 ); \t\/\/ xy - pos, z - flip\nconst vec2 txSoldier2 \t\t\t= vec2( 5.0, 2.0 ); \t\/\/ xy - pos, z - flip\nconst vec2 txSoldier0State \t\t= vec2( 6.0, 0.0 ); \t\/\/ x - state, y - frame, z - jump tick\nconst vec2 txSoldier1State \t\t= vec2( 6.0, 1.0 ); \t\/\/ x - state, y - frame, z - jump tick\nconst vec2 txSoldier2State \t\t= vec2( 6.0, 2.0 ); \t\/\/ x - state, y - frame, z - jump tick\nconst vec2 txSniper\t \t\t\t= vec2( 7.0, 0.0 ); \t\/\/ xy - pos, z - flip, w - weapon cooldown\nconst vec2 txPlayerBullet0 \t\t= vec2( 8.0, 0.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txPlayerBullet1 \t\t= vec2( 8.0, 1.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txPlayerBullet2 \t\t= vec2( 8.0, 2.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txPlayerBullet3 \t\t= vec2( 8.0, 3.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txPlayerBullet4 \t\t= vec2( 8.0, 4.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txPlayerBullet5 \t\t= vec2( 8.0, 5.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txEnemyBullet0 \t\t= vec2( 9.0, 0.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txEnemyBullet1 \t\t= vec2( 9.0, 1.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txEnemyBullet2 \t\t= vec2( 9.0, 2.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txEnemyBullet3 \t\t= vec2( 9.0, 3.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txExplosion \t\t\t= vec2( 10.0, 0.0 ); \t\/\/ xy - pos, z - frame\nconst vec2 txHit \t\t\t\t= vec2( 11.0, 0.0 ); \t\/\/ xy - pos, z - frame\nconst vec2 txTurret0\t\t\t= vec2( 12.0, 0.0 ); \t\/\/ xy - pos, z - angle\nconst vec2 txTurret1\t\t\t= vec2( 12.0, 1.0 ); \t\/\/ xy - pos, z - angle\nconst vec2 txTurret0State\t\t= vec2( 13.0, 0.0 ); \t\/\/ x - HP, y - weapon cooldown\nconst vec2 txTurret1State\t\t= vec2( 13.0, 1.0 ); \t\/\/ x - HP, y - weapon cooldown\nconst vec2 txPowerUp\t\t\t= vec2( 14.0, 0.0 ); \t\/\/ xy - pos, z - frame\nconst vec2 txPowerUpState\t\t= vec2( 15.0, 0.0 ); \t\/\/ x - state, y - initial height, z - jump tick\nconst vec2 txBossCore\t\t\t= vec2( 16.0, 0.0 ); \t\/\/ xy - pos, z - HP\nconst vec2 txBossCannon0\t\t= vec2( 17.0, 0.0 ); \t\/\/ xy - pos, z - cooldown, w - HP\nconst vec2 txBossCannon1\t\t= vec2( 17.0, 1.0 ); \t\/\/ xy - pos, z - cooldown, w - HP\nconst vec2 txBossBullet0\t\t= vec2( 18.0, 0.0 ); \t\/\/ xy - pos, zw - velocity\nconst vec2 txBossBullet1\t\t= vec2( 18.0, 1.0 ); \t\/\/ xy - pos, zw - velocity\nconst vec2 txGameState\t\t\t= vec2( 19.0, 0.0 ); \t\/\/ x - state, y - state tick\nconst vec2 txBridge\t\t\t\t= vec2( 20.0, 0.0 ); \t\/\/ x - draw start, y - explode tick\n\nvoid Swap( inout float a, inout float b )\n{\n    float tmp = a;\n    a = b;\n    b = tmp;\n}\n\nvec4 LoadValue( vec2 tx )\n{\n    return floor( texture( iChannel0, ( tx + 0.5 ) \/ iChannelResolution[ 0 ].xy ) );\n}\n\nvoid SpriteTurret( inout vec3 color, float x, float y, float frame )\n{\n    float idx = 0.0;    \n    \n    if ( frame == 0.0 )\n    {\n        \/\/ left\n        idx = y == 13.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 21844.0 : 0.0 ) ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 65533.0 : 21.0 ) ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 16384.0 : ( x <= 15.0 ? 48927.0 : 127.0 ) ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 16384.0 : ( x <= 15.0 ? 44922.0 : 426.0 ) ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 21780.0 : ( x <= 15.0 ? 27621.0 : 425.0 ) ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 43625.0 : ( x <= 15.0 ? 11162.0 : 681.0 ) ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 65469.0 : ( x <= 15.0 ? 11127.0 : 681.0 ) ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 43625.0 : ( x <= 15.0 ? 11262.0 : 681.0 ) ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 21845.0 : ( x <= 15.0 ? 27509.0 : 425.0 ) ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 21844.0 : ( x <= 15.0 ? 44650.0 : 427.0 ) ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 17680.0 : ( x <= 15.0 ? 47642.0 : 362.0 ) ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 16384.0 : ( x <= 15.0 ? 43689.0 : 341.0 ) ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 21845.0 : 85.0 ) ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 21844.0 : 5.0 ) ) : idx; \n    }\n    else if ( frame == 1.0 )\n    {\n        \/\/ up - left\n        idx = y == 14.0 ? ( x <= 7.0 ? 276.0 : ( x <= 15.0 ? 64.0 : 0.0 ) ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 361.0 : ( x <= 15.0 ? 1488.0 : 0.0 ) ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 5753.0 : ( x <= 15.0 ? 24564.0 : 0.0 ) ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 27541.0 : ( x <= 15.0 ? 48253.0 : 1.0 ) ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 47701.0 : ( x <= 15.0 ? 65014.0 : 7.0 ) ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 58708.0 : ( x <= 15.0 ? 45018.0 : 30.0 ) ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 38208.0 : ( x <= 15.0 ? 43766.0 : 106.0 ) ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 25856.0 : ( x <= 15.0 ? 27381.0 : 169.0 ) ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 41984.0 : ( x <= 15.0 ? 10939.0 : 169.0 ) ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 41984.0 : ( x <= 15.0 ? 19129.0 : 169.0 ) ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 41984.0 : ( x <= 15.0 ? 19124.0 : 170.0 ) ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 37888.0 : ( x <= 15.0 ? 38587.0 : 106.0 ) ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 20480.0 : ( x <= 15.0 ? 44713.0 : 106.0 ) ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 43669.0 : 90.0 ) ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 21844.0 : 85.0 ) ) : idx;   \n    }\n    else\n    {\n        \/\/ down - left\n        idx = y == 14.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 21824.0 : 5.0 ) ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 65428.0 : 27.0 ) ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 16384.0 : ( x <= 15.0 ? 45053.0 : 106.0 ) ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 53248.0 : ( x <= 15.0 ? 38591.0 : 106.0 ) ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 62464.0 : ( x <= 15.0 ? 19188.0 : 170.0 ) ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 58368.0 : ( x <= 15.0 ? 19133.0 : 169.0 ) ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 41984.0 : ( x <= 15.0 ? 10938.0 : 169.0 ) ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 25600.0 : ( x <= 15.0 ? 27365.0 : 169.0 ) ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 37888.0 : ( x <= 15.0 ? 43750.0 : 107.0 ) ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 58624.0 : ( x <= 15.0 ? 44954.0 : 90.0 ) ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 47680.0 : ( x <= 15.0 ? 47526.0 : 86.0 ) ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 27540.0 : ( x <= 15.0 ? 43113.0 : 85.0 ) ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 22137.0 : ( x <= 15.0 ? 23205.0 : 5.0 ) ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 38249.0 : ( x <= 15.0 ? 21909.0 : 1.0 ) ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 21844.0 : ( x <= 15.0 ? 21845.0 : 0.0 ) ) : idx;      \n    }\n\n    idx = SPRITE_DEC_4( x, idx );    \n    idx = x >= 0.0 && x < 21.0 ? idx : 0.0;\n\n    float blink = abs( sin( iTime * 3.0 ) ) + 0.5;\n    \n    color = idx == 0.0 && x >= 8.0 && x < 16.0 && y >= 3.0 && y < 12.0 ? blink * RGB( 228, 68, 52 ) : color;\n    color = idx == 1.0 ? RGB( 0,   0,   0   ) : color;\n    color = idx == 2.0 ? RGB( 192, 192, 192 ) : color;\n    color = idx == 3.0 ? RGB( 255, 255, 255 ) : color;\n}\n\nvoid SpriteTurretBase( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;    \n    \n    idx = y == 31.0 ? ( x <= 10.0 ? 2796201.0 : ( x <= 21.0 ? 2796202.0 : 174762.0 ) ) : idx;\n    idx = y == 30.0 ? ( x <= 10.0 ? 1398102.0 : ( x <= 21.0 ? 1398101.0 : 349525.0 ) ) : idx;\n    idx = y == 29.0 ? ( x <= 10.0 ? 2796182.0 : ( x <= 21.0 ? 2796202.0 : 289450.0 ) ) : idx;\n    idx = y == 28.0 ? ( x <= 10.0 ? 2796198.0 : ( x <= 21.0 ? 2796202.0 : 285354.0 ) ) : idx;\n    idx = y == 27.0 ? ( x <= 10.0 ? 1398182.0 : ( x <= 21.0 ? 1398101.0 : 279893.0 ) ) : idx;\n    idx = y == 26.0 ? ( x <= 10.0 ? 1397158.0 : ( x <= 21.0 ? 1398101.0 : 279637.0 ) ) : idx;\n    idx = y == 25.0 ? ( x <= 10.0 ? 1399206.0 : ( x <= 21.0 ? 1398101.0 : 280149.0 ) ) : idx;\n    idx = y == 24.0 ? ( x <= 10.0 ? 21926.0 : ( x <= 21.0 ? 0.0 : 279888.0 ) ) : idx;\n    idx = y == 23.0 ? ( x <= 10.0 ? 2692518.0 : ( x <= 21.0 ? 2796202.0 : 279905.0 ) ) : idx;\n    idx = y == 22.0 ? ( x <= 10.0 ? 1709478.0 : ( x <= 21.0 ? 1398101.0 : 279905.0 ) ) : idx;\n    idx = y == 21.0 ? ( x <= 10.0 ? 1447334.0 : ( x <= 21.0 ? 1398101.0 : 279905.0 ) ) : idx;\n    idx = y == 20.0 ? ( x <= 10.0 ? 1447334.0 : ( x <= 21.0 ? 1398101.0 : 279905.0 ) ) : idx;\n    idx = y == 19.0 ? ( x <= 10.0 ? 1447334.0 : ( x <= 21.0 ? 1398101.0 : 279905.0 ) ) : idx;\n    idx = y == 18.0 ? ( x <= 10.0 ? 1447334.0 : ( x <= 21.0 ? 1398101.0 : 279905.0 ) ) : idx;\n    idx = y == 17.0 ? ( x <= 10.0 ? 1447334.0 : ( x <= 21.0 ? 1398101.0 : 279905.0 ) ) : idx;\n    idx = y == 16.0 ? ( x <= 10.0 ? 1447334.0 : ( x <= 21.0 ? 1398101.0 : 279905.0 ) ) : idx;\n    idx = y == 15.0 ? ( x <= 10.0 ? 1447334.0 : ( x <= 21.0 ? 1398101.0 : 279905.0 ) ) : idx;\n    idx = y == 14.0 ? ( x <= 10.0 ? 1447334.0 : ( x <= 21.0 ? 1398101.0 : 279905.0 ) ) : idx;\n    idx = y == 13.0 ? ( x <= 10.0 ? 1447334.0 : ( x <= 21.0 ? 1398101.0 : 279905.0 ) ) : idx;\n    idx = y == 12.0 ? ( x <= 10.0 ? 1447334.0 : ( x <= 21.0 ? 1398101.0 : 279905.0 ) ) : idx;\n    idx = y == 11.0 ? ( x <= 10.0 ? 1447334.0 : ( x <= 21.0 ? 1398101.0 : 279905.0 ) ) : idx;\n    idx = y == 10.0 ? ( x <= 10.0 ? 1447334.0 : ( x <= 21.0 ? 1398101.0 : 279905.0 ) ) : idx;\n    idx = y == 9.0 ? ( x <= 10.0 ? 1381798.0 : ( x <= 21.0 ? 1398101.0 : 279905.0 ) ) : idx;\n    idx = y == 8.0 ? ( x <= 10.0 ? 5542.0 : ( x <= 21.0 ? 0.0 : 279904.0 ) ) : idx;\n    idx = y == 7.0 ? ( x <= 10.0 ? 2774438.0 : ( x <= 21.0 ? 2796202.0 : 279898.0 ) ) : idx;\n    idx = y == 6.0 ? ( x <= 10.0 ? 1398182.0 : ( x <= 21.0 ? 1398101.0 : 279893.0 ) ) : idx;\n    idx = y == 5.0 ? ( x <= 10.0 ? 1397158.0 : ( x <= 21.0 ? 1398101.0 : 279637.0 ) ) : idx;\n    idx = y == 4.0 ? ( x <= 10.0 ? 1399206.0 : ( x <= 21.0 ? 1398101.0 : 280149.0 ) ) : idx;\n    idx = y == 3.0 ? ( x <= 10.0 ? 102.0 : ( x <= 21.0 ? 0.0 : 278528.0 ) ) : idx;\n    idx = y == 2.0 ? ( x <= 10.0 ? 1398102.0 : ( x <= 21.0 ? 1398101.0 : 283989.0 ) ) : idx;\n    idx = y == 1.0 ? ( x <= 10.0 ? 6.0 : ( x <= 21.0 ? 0.0 : 262144.0 ) ) : idx;\n    idx = y == 0.0 ? ( x <= 10.0 ? 1398100.0 : ( x <= 21.0 ? 1398101.0 : 87381.0 ) ) : idx;\n\n    idx = SPRITE_DEC_3( x, idx );    \n    if ( x >= 0.0 && x < 32.0 && y >= 0.0 && y < 32.0 )\n    {\n        color = RGB( 0, 0, 0 );\n        color = idx == 1.0 ? RGB( 192, 192, 192 ) : color;\n        color = idx == 2.0 ? RGB( 255, 255, 255 ) : color;  \n    }\n}\n\nvoid SpriteSniper( inout vec3 color, float x, float y )\n{\n    float idx = 0.0; \n    \n    idx = y == 30.0 ? ( x <= 7.0 ? 21504.0 : 0.0 ) : idx;\n    idx = y == 29.0 ? ( x <= 7.0 ? 43264.0 : ( x <= 15.0 ? 1.0 : 0.0 ) ) : idx;\n    idx = y == 28.0 ? ( x <= 7.0 ? 48704.0 : ( x <= 15.0 ? 6.0 : 0.0 ) ) : idx;\n    idx = y == 27.0 ? ( x <= 7.0 ? 23104.0 : ( x <= 15.0 ? 5125.0 : ( x <= 23.0 ? 20821.0 : 0.0 ) ) ) : idx;\n    idx = y == 26.0 ? ( x <= 7.0 ? 62720.0 : ( x <= 15.0 ? 32085.0 : ( x <= 23.0 ? 30711.0 : 0.0 ) ) ) : idx;\n    idx = y == 25.0 ? ( x <= 7.0 ? 30032.0 : ( x <= 15.0 ? 65021.0 : ( x <= 23.0 ? 20863.0 : 0.0 ) ) ) : idx;\n    idx = y == 24.0 ? ( x <= 7.0 ? 21924.0 : ( x <= 15.0 ? 21855.0 : ( x <= 23.0 ? 117.0 : 0.0 ) ) ) : idx;\n    idx = y == 23.0 ? ( x <= 7.0 ? 55993.0 : ( x <= 15.0 ? 58869.0 : ( x <= 23.0 ? 21.0 : 0.0 ) ) ) : idx;\n    idx = y == 22.0 ? ( x <= 7.0 ? 22185.0 : ( x <= 15.0 ? 63997.0 : ( x <= 23.0 ? 1.0 : 0.0 ) ) ) : idx;\n    idx = y == 21.0 ? ( x <= 7.0 ? 64917.0 : ( x <= 15.0 ? 23903.0 : 0.0 ) ) : idx;\n    idx = y == 20.0 ? ( x <= 7.0 ? 64852.0 : ( x <= 15.0 ? 1893.0 : 0.0 ) ) : idx;\n    idx = y == 19.0 ? ( x <= 7.0 ? 21860.0 : ( x <= 15.0 ? 342.0 : 0.0 ) ) : idx;\n    idx = y == 18.0 ? ( x <= 7.0 ? 27280.0 : ( x <= 15.0 ? 5.0 : 0.0 ) ) : idx;\n    idx = y == 17.0 ? ( x <= 7.0 ? 54608.0 : ( x <= 15.0 ? 23.0 : 0.0 ) ) : idx;\n    idx = y == 16.0 ? ( x <= 7.0 ? 21824.0 : ( x <= 15.0 ? 26.0 : 0.0 ) ) : idx;\n    idx = y == 15.0 ? ( x <= 7.0 ? 43664.0 : ( x <= 15.0 ? 90.0 : 0.0 ) ) : idx;\n    idx = y == 14.0 ? ( x <= 7.0 ? 43664.0 : ( x <= 15.0 ? 105.0 : 0.0 ) ) : idx;\n    idx = y == 13.0 ? ( x <= 7.0 ? 27200.0 : ( x <= 15.0 ? 426.0 : 0.0 ) ) : idx;\n    idx = y == 12.0 ? ( x <= 7.0 ? 28304.0 : ( x <= 15.0 ? 490.0 : 0.0 ) ) : idx;\n    idx = y == 11.0 ? ( x <= 7.0 ? 7824.0 : ( x <= 15.0 ? 489.0 : 0.0 ) ) : idx;\n    idx = y == 10.0 ? ( x <= 7.0 ? 7824.0 : ( x <= 15.0 ? 421.0 : 0.0 ) ) : idx;\n    idx = y == 9.0 ? ( x <= 7.0 ? 1956.0 : ( x <= 15.0 ? 1700.0 : 0.0 ) ) : idx;\n    idx = y == 8.0 ? ( x <= 7.0 ? 420.0 : ( x <= 15.0 ? 1700.0 : 0.0 ) ) : idx;\n    idx = y == 7.0 ? ( x <= 7.0 ? 420.0 : ( x <= 15.0 ? 1680.0 : 0.0 ) ) : idx;\n    idx = y == 6.0 ? ( x <= 7.0 ? 404.0 : ( x <= 15.0 ? 1680.0 : 0.0 ) ) : idx;\n    idx = y == 5.0 ? ( x <= 7.0 ? 84.0 : ( x <= 15.0 ? 1360.0 : 0.0 ) ) : idx;\n    idx = y == 4.0 ? ( x <= 7.0 ? 84.0 : ( x <= 15.0 ? 1344.0 : 0.0 ) ) : idx;\n    idx = y == 3.0 ? ( x <= 7.0 ? 21.0 : ( x <= 15.0 ? 1344.0 : 0.0 ) ) : idx;\n    idx = y == 2.0 ? ( x <= 7.0 ? 53.0 : ( x <= 15.0 ? 7488.0 : 0.0 ) ) : idx;\n    idx = y == 1.0 ? ( x <= 7.0 ? 213.0 : ( x <= 15.0 ? 30016.0 : 0.0 ) ) : idx;\n    idx = y == 0.0 ? ( x <= 7.0 ? 340.0 : ( x <= 15.0 ? 21824.0 : 0.0 ) ) : idx;\n\n    idx = SPRITE_DEC_4( x, idx );\n    idx = x >= 0.0 && x < 24.0 ? idx : 0.0;\n\n    color = idx == 1.0 ? RGB( 0,   0,  0 ) : color;\n    color = idx == 2.0 ? RGB( 248, 56, 0 ) : color;\n    color = idx == 3.0 ? y > 16.0 ? RGB( 240, 208, 176 ) : RGB( 255, 255, 255 ) : color;      \n}\n\nvoid SpriteSoldier( inout vec3 color, float x, float y, float frame )\n{\n    float idx = 0.0;    \n    \n    if ( frame == 0.0 )\n    {\n        idx = y == 31.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 1344.0 : 0.0 ) ) : idx;\n        idx = y == 30.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 6804.0 : 0.0 ) ) : idx;\n        idx = y == 29.0 ? ( x <= 7.0 ? 21504.0 : ( x <= 15.0 ? 27621.0 : 0.0 ) ) : idx;\n        idx = y == 28.0 ? ( x <= 7.0 ? 64768.0 : ( x <= 15.0 ? 5781.0 : 0.0 ) ) : idx;\n        idx = y == 27.0 ? ( x <= 7.0 ? 65344.0 : ( x <= 15.0 ? 7510.0 : 0.0 ) ) : idx;\n        idx = y == 26.0 ? ( x <= 7.0 ? 65492.0 : ( x <= 15.0 ? 7514.0 : 0.0 ) ) : idx;\n        idx = y == 25.0 ? ( x <= 7.0 ? 65497.0 : ( x <= 15.0 ? 5542.0 : 0.0 ) ) : idx;\n        idx = y == 24.0 ? ( x <= 7.0 ? 49113.0 : ( x <= 15.0 ? 5561.0 : 0.0 ) ) : idx;\n        idx = y == 23.0 ? ( x <= 7.0 ? 28629.0 : ( x <= 15.0 ? 30125.0 : 0.0 ) ) : idx;\n        idx = y == 22.0 ? ( x <= 7.0 ? 27229.0 : ( x <= 15.0 ? 29802.0 : 0.0 ) ) : idx;\n        idx = y == 21.0 ? ( x <= 7.0 ? 38260.0 : ( x <= 15.0 ? 21845.0 : 0.0 ) ) : idx;\n        idx = y == 20.0 ? ( x <= 7.0 ? 38388.0 : ( x <= 15.0 ? 62973.0 : ( x <= 23.0 ? 1.0 : 0.0 ) ) ) : idx;\n        idx = y == 19.0 ? ( x <= 7.0 ? 27088.0 : ( x <= 15.0 ? 65525.0 : ( x <= 23.0 ? 1.0 : 0.0 ) ) ) : idx;\n        idx = y == 18.0 ? ( x <= 7.0 ? 43328.0 : ( x <= 15.0 ? 21845.0 : ( x <= 23.0 ? 1.0 : 0.0 ) ) ) : idx;\n        idx = y == 17.0 ? ( x <= 7.0 ? 21760.0 : ( x <= 15.0 ? 29701.0 : 0.0 ) ) : idx;\n        idx = y == 16.0 ? ( x <= 7.0 ? 21760.0 : ( x <= 15.0 ? 21509.0 : 0.0 ) ) : idx;\n        idx = y == 15.0 ? ( x <= 7.0 ? 21504.0 : ( x <= 15.0 ? 23.0 : 0.0 ) ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 21504.0 : ( x <= 15.0 ? 87.0 : 0.0 ) ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 20480.0 : ( x <= 15.0 ? 93.0 : 0.0 ) ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 20480.0 : ( x <= 15.0 ? 93.0 : 0.0 ) ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 20480.0 : ( x <= 15.0 ? 93.0 : 0.0 ) ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 21504.0 : ( x <= 15.0 ? 93.0 : 0.0 ) ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 21504.0 : ( x <= 15.0 ? 87.0 : 0.0 ) ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 21504.0 : ( x <= 15.0 ? 23.0 : 0.0 ) ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 23808.0 : ( x <= 15.0 ? 5.0 : 0.0 ) ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 23808.0 : ( x <= 15.0 ? 5.0 : 0.0 ) ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 55104.0 : ( x <= 15.0 ? 7.0 : 0.0 ) ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 57296.0 : ( x <= 15.0 ? 7.0 : 0.0 ) ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 55104.0 : ( x <= 15.0 ? 5.0 : 0.0 ) ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 62720.0 : ( x <= 15.0 ? 23.0 : 0.0 ) ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 62464.0 : ( x <= 15.0 ? 127.0 : 0.0 ) ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 21504.0 : ( x <= 15.0 ? 85.0 : 0.0 ) ) : idx;\n    }\n    else\n    {\n        idx = y == 30.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 5376.0 : 0.0 ) ) : idx;\n        idx = y == 29.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 27200.0 : 0.0 ) ) : idx;\n        idx = y == 28.0 ? ( x <= 7.0 ? 20480.0 : ( x <= 15.0 ? 44949.0 : ( x <= 23.0 ? 1.0 : 0.0 ) ) ) : idx;\n        idx = y == 27.0 ? ( x <= 7.0 ? 62464.0 : ( x <= 15.0 ? 23127.0 : ( x <= 23.0 ? 1.0 : 0.0 ) ) ) : idx;\n        idx = y == 26.0 ? ( x <= 7.0 ? 64768.0 : ( x <= 15.0 ? 30107.0 : 0.0 ) ) : idx;\n        idx = y == 25.0 ? ( x <= 7.0 ? 65344.0 : ( x <= 15.0 ? 30038.0 : 0.0 ) ) : idx;\n        idx = y == 24.0 ? ( x <= 7.0 ? 65344.0 : ( x <= 15.0 ? 21925.0 : 0.0 ) ) : idx;\n        idx = y == 23.0 ? ( x <= 7.0 ? 48960.0 : ( x <= 15.0 ? 5561.0 : 0.0 ) ) : idx;\n        idx = y == 22.0 ? ( x <= 7.0 ? 28224.0 : ( x <= 15.0 ? 7597.0 : 0.0 ) ) : idx;\n        idx = y == 21.0 ? ( x <= 7.0 ? 26880.0 : ( x <= 15.0 ? 7530.0 : 0.0 ) ) : idx;\n        idx = y == 20.0 ? ( x <= 7.0 ? 21760.0 : ( x <= 15.0 ? 21845.0 : 0.0 ) ) : idx;\n        idx = y == 19.0 ? ( x <= 7.0 ? 54272.0 : ( x <= 15.0 ? 32095.0 : 0.0 ) ) : idx;\n        idx = y == 18.0 ? ( x <= 7.0 ? 25600.0 : ( x <= 15.0 ? 32767.0 : 0.0 ) ) : idx;\n        idx = y == 17.0 ? ( x <= 7.0 ? 20480.0 : ( x <= 15.0 ? 21845.0 : 0.0 ) ) : idx;\n        idx = y == 16.0 ? ( x <= 7.0 ? 20480.0 : ( x <= 15.0 ? 7509.0 : 0.0 ) ) : idx;\n        idx = y == 15.0 ? ( x <= 7.0 ? 16384.0 : ( x <= 15.0 ? 1397.0 : 0.0 ) ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 16384.0 : ( x <= 15.0 ? 1525.0 : 0.0 ) ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 16469.0 : ( x <= 15.0 ? 6101.0 : 0.0 ) ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 22013.0 : ( x <= 15.0 ? 23893.0 : 0.0 ) ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 63485.0 : ( x <= 15.0 ? 30039.0 : 0.0 ) ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 21885.0 : ( x <= 15.0 ? 30021.0 : 0.0 ) ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 93.0 : ( x <= 15.0 ? 29952.0 : 0.0 ) ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 93.0 : ( x <= 15.0 ? 23808.0 : 0.0 ) ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 21.0 : ( x <= 15.0 ? 5440.0 : 0.0 ) ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 5440.0 : 0.0 ) ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 5952.0 : 0.0 ) ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 8144.0 : 0.0 ) ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 2000.0 : 0.0 ) ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 24564.0 : 0.0 ) ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 65360.0 : ( x <= 23.0 ? 1.0 : 0.0 ) ) ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 21760.0 : ( x <= 23.0 ? 1.0 : 0.0 ) ) ) : idx;\n    }\n    \n    idx = SPRITE_DEC_4( x, idx );\n    idx = x >= 0.0 && x < 18.0 ? idx : 0.0;\n\n    color = idx == 1.0 ? RGB( 0,   0,     0 ) : color;\n    color = idx == 2.0 ? RGB( 248, 56,    0 ) : color;\n    color = idx == 3.0 ? y > 16.0 ? RGB( 240, 208, 176 ) : RGB( 255, 255, 255 ) : color;  \n}\n\nvoid SpriteBillTorsoR( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;\n    \n    idx = y == 13.0 ? ( x <= 7.0 ? 20480.0 : ( x <= 15.0 ? 5.0 : 0.0 ) ) : idx;\n    idx = y == 12.0 ? ( x <= 7.0 ? 42240.0 : ( x <= 15.0 ? 6.0 : 0.0 ) ) : idx;\n    idx = y == 11.0 ? ( x <= 7.0 ? 21824.0 : ( x <= 15.0 ? 21.0 : 0.0 ) ) : idx;\n    idx = y == 10.0 ? ( x <= 7.0 ? 58688.0 : ( x <= 15.0 ? 23.0 : 0.0 ) ) : idx;\n    idx = y == 9.0 ? ( x <= 7.0 ? 58624.0 : ( x <= 15.0 ? 7.0 : 0.0 ) ) : idx;\n    idx = y == 8.0 ? ( x <= 7.0 ? 28240.0 : ( x <= 15.0 ? 87.0 : 0.0 ) ) : idx;\n    idx = y == 7.0 ? ( x <= 7.0 ? 44004.0 : ( x <= 15.0 ? 117.0 : 0.0 ) ) : idx;\n    idx = y == 6.0 ? ( x <= 7.0 ? 61433.0 : ( x <= 15.0 ? 494.0 : 0.0 ) ) : idx;\n    idx = y == 5.0 ? ( x <= 7.0 ? 61433.0 : ( x <= 15.0 ? 491.0 : 0.0 ) ) : idx;\n    idx = y == 4.0 ? ( x <= 7.0 ? 56313.0 : ( x <= 15.0 ? 1947.0 : 1024.0 ) ) : idx;\n    idx = y == 3.0 ? ( x <= 7.0 ? 63165.0 : ( x <= 15.0 ? 21867.0 : 6485.0 ) ) : idx;\n    idx = y == 2.0 ? ( x <= 7.0 ? 23540.0 : ( x <= 15.0 ? 57301.0 : 31671.0 ) ) : idx;\n    idx = y == 1.0 ? ( x <= 7.0 ? 65488.0 : ( x <= 15.0 ? 21851.0 : 5461.0 ) ) : idx;\n    idx = y == 0.0 ? ( x <= 7.0 ? 64848.0 : ( x <= 15.0 ? 39515.0 : 425.0 ) ) : idx;\n    \n    idx = SPRITE_DEC_4( x, idx );\n    idx = x >= 0.0 && x < 24.0 ? idx : 0.0;    \n    color = idx == 1.0 ? RGB( 0,   0,     0 ) : color;\n    color = idx == 2.0 ? RGB( 248, 56,    0 ) : color;\n    color = idx == 3.0 ? RGB( 240, 208, 176 ) : color;\n}\n\nvoid SpriteBillTorsoT( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;\n    \n    idx = y == 25.0 ? ( x <= 7.0 ? 0.0 : 16.0 ) : idx;\n    idx = y == 24.0 ? ( x <= 7.0 ? 0.0 : 116.0 ) : idx;\n    idx = y == 23.0 ? ( x <= 7.0 ? 0.0 : 105.0 ) : idx;\n    idx = y == 22.0 ? ( x <= 7.0 ? 0.0 : 116.0 ) : idx;\n    idx = y == 21.0 ? ( x <= 7.0 ? 0.0 : 356.0 ) : idx;\n    idx = y == 20.0 ? ( x <= 7.0 ? 0.0 : 1652.0 ) : idx;\n    idx = y == 19.0 ? ( x <= 7.0 ? 0.0 : 1652.0 ) : idx;\n    idx = y == 18.0 ? ( x <= 7.0 ? 0.0 : 1636.0 ) : idx;\n    idx = y == 17.0 ? ( x <= 7.0 ? 0.0 : 1397.0 ) : idx;\n    idx = y == 16.0 ? ( x <= 7.0 ? 16384.0 : 1654.0 ) : idx;\n    idx = y == 15.0 ? ( x <= 7.0 ? 16384.0 : 1382.0 ) : idx;\n    idx = y == 14.0 ? ( x <= 7.0 ? 16384.0 : 1655.0 ) : idx;\n    idx = y == 13.0 ? ( x <= 7.0 ? 16384.0 : 1399.0 ) : idx;\n    idx = y == 12.0 ? ( x <= 7.0 ? 36928.0 : 1654.0 ) : idx;\n    idx = y == 11.0 ? ( x <= 7.0 ? 57744.0 : 1639.0 ) : idx;\n    idx = y == 10.0 ? ( x <= 7.0 ? 55140.0 : 1398.0 ) : idx;\n    idx = y == 9.0 ? ( x <= 7.0 ? 40921.0 : 2038.0 ) : idx;\n    idx = y == 8.0 ? ( x <= 7.0 ? 40868.0 : 2038.0 ) : idx;\n    idx = y == 7.0 ? ( x <= 7.0 ? 26256.0 : 1957.0 ) : idx;\n    idx = y == 6.0 ? ( x <= 7.0 ? 39908.0 : 505.0 ) : idx;\n    idx = y == 5.0 ? ( x <= 7.0 ? 31737.0 : 510.0 ) : idx;\n    idx = y == 4.0 ? ( x <= 7.0 ? 65529.0 : 123.0 ) : idx;\n    idx = y == 3.0 ? ( x <= 7.0 ? 64116.0 : 127.0 ) : idx;\n    idx = y == 2.0 ? ( x <= 7.0 ? 21968.0 : 21.0 ) : idx;\n    idx = y == 1.0 ? ( x <= 7.0 ? 27600.0 : 0.0 ) : idx;\n    idx = y == 0.0 ? ( x <= 7.0 ? 44880.0 : 1.0 ) : idx;\n    \n    idx = SPRITE_DEC_4( x, idx );\n    idx = x >= 0.0 && x < 14.0 ? idx : 0.0;    \n    color = idx == 1.0 ? RGB( 0,   0,     0 ) : color;\n    color = idx == 2.0 ? RGB( 248, 56,    0 ) : color;\n    color = idx == 3.0 ? RGB( 240, 208, 176 ) : color;\n}\n\nvoid SpriteBillTorsoTR( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;\n    \n    idx = y == 15.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 16384.0 : 0.0 ) ) : idx;\n    idx = y == 14.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 54272.0 : 1.0 ) ) : idx;\n    idx = y == 13.0 ? ( x <= 7.0 ? 1280.0 : ( x <= 15.0 ? 47360.0 : 1.0 ) ) : idx;\n    idx = y == 12.0 ? ( x <= 7.0 ? 6736.0 : ( x <= 15.0 ? 26964.0 : 0.0 ) ) : idx;\n    idx = y == 11.0 ? ( x <= 7.0 ? 1445.0 : ( x <= 15.0 ? 7037.0 : 0.0 ) ) : idx;\n    idx = y == 10.0 ? ( x <= 7.0 ? 24405.0 : ( x <= 15.0 ? 1757.0 : 0.0 ) ) : idx;\n    idx = y == 9.0 ? ( x <= 7.0 ? 24485.0 : ( x <= 15.0 ? 6583.0 : 0.0 ) ) : idx;\n    idx = y == 8.0 ? ( x <= 7.0 ? 43348.0 : ( x <= 15.0 ? 6765.0 : 0.0 ) ) : idx;\n    idx = y == 7.0 ? ( x <= 7.0 ? 26356.0 : ( x <= 15.0 ? 6747.0 : 0.0 ) ) : idx;\n    idx = y == 6.0 ? ( x <= 7.0 ? 56317.0 : ( x <= 15.0 ? 1654.0 : 0.0 ) ) : idx;\n    idx = y == 5.0 ? ( x <= 7.0 ? 23549.0 : ( x <= 15.0 ? 1657.0 : 0.0 ) ) : idx;\n    idx = y == 4.0 ? ( x <= 7.0 ? 32509.0 : ( x <= 15.0 ? 509.0 : 0.0 ) ) : idx;\n    idx = y == 3.0 ? ( x <= 7.0 ? 49005.0 : ( x <= 15.0 ? 507.0 : 0.0 ) ) : idx;\n    idx = y == 2.0 ? ( x <= 7.0 ? 64953.0 : ( x <= 15.0 ? 95.0 : 0.0 ) ) : idx;\n    idx = y == 1.0 ? ( x <= 7.0 ? 63161.0 : ( x <= 15.0 ? 7.0 : 0.0 ) ) : idx;\n    idx = y == 0.0 ? ( x <= 7.0 ? 42724.0 : ( x <= 15.0 ? 1.0 : 0.0 ) ) : idx;\n    \n    idx = SPRITE_DEC_4( x, idx );\n    idx = x >= 0.0 && x < 18.0 ? idx : 0.0;    \n    color = idx == 1.0 ? RGB( 0,   0,     0 ) : color;\n    color = idx == 2.0 ? RGB( 248, 56,    0 ) : color;\n    color = idx == 3.0 ? RGB( 240, 208, 176 ) : color;\n}\n\nvoid SpriteBillTorsoBR( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;\n    \n    idx = y == 21.0 ? ( x <= 7.0 ? 16384.0 : ( x <= 15.0 ? 1.0 : 0.0 ) ) : idx;\n    idx = y == 20.0 ? ( x <= 7.0 ? 38208.0 : ( x <= 15.0 ? 6.0 : 0.0 ) ) : idx;\n    idx = y == 19.0 ? ( x <= 7.0 ? 25680.0 : ( x <= 15.0 ? 26.0 : 0.0 ) ) : idx;\n    idx = y == 18.0 ? ( x <= 7.0 ? 59648.0 : ( x <= 15.0 ? 5.0 : 0.0 ) ) : idx;\n    idx = y == 17.0 ? ( x <= 7.0 ? 59984.0 : ( x <= 15.0 ? 7.0 : 0.0 ) ) : idx;\n    idx = y == 16.0 ? ( x <= 7.0 ? 63460.0 : ( x <= 15.0 ? 1.0 : 0.0 ) ) : idx;\n    idx = y == 15.0 ? ( x <= 7.0 ? 22521.0 : ( x <= 15.0 ? 21.0 : 0.0 ) ) : idx;\n    idx = y == 14.0 ? ( x <= 7.0 ? 49145.0 : ( x <= 15.0 ? 118.0 : 0.0 ) ) : idx;\n    idx = y == 13.0 ? ( x <= 7.0 ? 64505.0 : ( x <= 15.0 ? 474.0 : 0.0 ) ) : idx;\n    idx = y == 12.0 ? ( x <= 7.0 ? 64505.0 : ( x <= 15.0 ? 1946.0 : 0.0 ) ) : idx;\n    idx = y == 11.0 ? ( x <= 7.0 ? 63396.0 : ( x <= 15.0 ? 1894.0 : 0.0 ) ) : idx;\n    idx = y == 10.0 ? ( x <= 7.0 ? 39908.0 : ( x <= 15.0 ? 7653.0 : 0.0 ) ) : idx;\n    idx = y == 9.0 ? ( x <= 7.0 ? 32720.0 : ( x <= 15.0 ? 1951.0 : 0.0 ) ) : idx;\n    idx = y == 8.0 ? ( x <= 7.0 ? 49104.0 : ( x <= 15.0 ? 6783.0 : 0.0 ) ) : idx;\n    idx = y == 7.0 ? ( x <= 7.0 ? 60736.0 : ( x <= 15.0 ? 30063.0 : 0.0 ) ) : idx;\n    idx = y == 6.0 ? ( x <= 7.0 ? 37888.0 : ( x <= 15.0 ? 58970.0 : 1.0 ) ) : idx;\n    idx = y == 5.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 39504.0 : 22.0 ) ) : idx;\n    idx = y == 4.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 26896.0 : 109.0 ) ) : idx;\n    idx = y == 3.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 41984.0 : 105.0 ) ) : idx;\n    idx = y == 2.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 36864.0 : 485.0 ) ) : idx;\n    idx = y == 1.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 16384.0 : 400.0 ) ) : idx;\n    idx = y == 0.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 0.0 : 64.0 ) ) : idx;\n    \n    idx = SPRITE_DEC_4( x, idx );\n    idx = x >= 0.0 && x < 21.0 ? idx : 0.0;    \n    color = idx == 1.0 ? RGB( 0,   0,     0 ) : color;\n    color = idx == 2.0 ? RGB( 248, 56,    0 ) : color;\n    color = idx == 3.0 ? RGB( 240, 208, 176 ) : color;\n}\n\nvoid SpriteBillLegs( inout vec3 color, float x, float y, float frame )\n{\n    \/\/ lower body\n    float idx = 0.0;\n    \n    if ( frame == 0.0 )\n    {\n        x -= 2.0;\n        idx = y == 19.0 ? ( x <= 7.0 ? 62800.0 : 1.0 ) : idx;\n        idx = y == 18.0 ? ( x <= 7.0 ? 43664.0 : 1.0 ) : idx;\n        idx = y == 17.0 ? ( x <= 7.0 ? 43664.0 : 1.0 ) : idx;\n        idx = y == 16.0 ? ( x <= 7.0 ? 64080.0 : 1.0 ) : idx;\n        idx = y == 15.0 ? ( x <= 7.0 ? 42320.0 : 6.0 ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 43328.0 : 27.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 42560.0 : 26.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 22848.0 : 110.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 38144.0 : 26.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 39168.0 : 26.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 42560.0 : 7.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 43344.0 : 6.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 63892.0 : 1.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 27241.0 : 0.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 32357.0 : 0.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 6756.0 : 0.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 27216.0 : 0.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 43584.0 : 5.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 43584.0 : 26.0 ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 21824.0 : 21.0 ) : idx;\n        idx = x >= 0.0 && x < 12.0 ? idx : 0.0;\n    }\n    else if ( frame == 1.0 )\n    {\n        idx = y == 19.0 ? ( x <= 7.0 ? 20480.0 : ( x <= 15.0 ? 341.0 : 0.0 ) ) : idx;\n        idx = y == 18.0 ? ( x <= 7.0 ? 36864.0 : ( x <= 15.0 ? 1466.0 : 0.0 ) ) : idx;\n        idx = y == 17.0 ? ( x <= 7.0 ? 36864.0 : ( x <= 15.0 ? 6570.0 : 0.0 ) ) : idx;\n        idx = y == 16.0 ? ( x <= 7.0 ? 16384.0 : ( x <= 15.0 ? 27246.0 : 0.0 ) ) : idx;\n        idx = y == 15.0 ? ( x <= 7.0 ? 16384.0 : ( x <= 15.0 ? 43626.0 : 1.0 ) ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 36864.0 : ( x <= 15.0 ? 43374.0 : 6.0 ) ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 36864.0 : ( x <= 15.0 ? 42090.0 : 6.0 ) ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 20480.0 : ( x <= 15.0 ? 42267.0 : 1.0 ) ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 41984.0 : ( x <= 15.0 ? 43610.0 : 1.0 ) ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 59648.0 : ( x <= 15.0 ? 27206.0 : 0.0 ) ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 43264.0 : ( x <= 15.0 ? 6721.0 : 0.0 ) ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 28224.0 : ( x <= 15.0 ? 1616.0 : 0.0 ) ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 6800.0 : ( x <= 15.0 ? 1700.0 : 0.0 ) ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 2000.0 : ( x <= 15.0 ? 425.0 : 0.0 ) ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 420.0 : ( x <= 15.0 ? 420.0 : 0.0 ) ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 425.0 : ( x <= 15.0 ? 1680.0 : 0.0 ) ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 1961.0 : ( x <= 15.0 ? 6720.0 : 0.0 ) ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 5796.0 : ( x <= 15.0 ? 1280.0 : 0.0 ) ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 31376.0 : 0.0 ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 21824.0 : 0.0 ) : idx;\n        idx = x >= 0.0 && x < 18.0 ? idx : 0.0;\n    }\n    else\n    {   \n        idx = y == 18.0 ? ( x <= 7.0 ? 37888.0 : ( x <= 15.0 ? 422.0 : 0.0 ) ) : idx;\n        idx = y == 17.0 ? ( x <= 7.0 ? 36864.0 : ( x <= 15.0 ? 342.0 : 0.0 ) ) : idx;\n        idx = y == 16.0 ? ( x <= 7.0 ? 36880.0 : ( x <= 15.0 ? 362.0 : 0.0 ) ) : idx;\n        idx = y == 15.0 ? ( x <= 7.0 ? 21860.0 : ( x <= 15.0 ? 489.0 : 0.0 ) ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 43428.0 : ( x <= 15.0 ? 421.0 : 0.0 ) ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 44457.0 : ( x <= 15.0 ? 1962.0 : 0.0 ) ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 54377.0 : ( x <= 15.0 ? 1710.0 : 0.0 ) ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 16489.0 : ( x <= 15.0 ? 1765.0 : 0.0 ) ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 25.0 : ( x <= 15.0 ? 6480.0 : 0.0 ) ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 25.0 : ( x <= 15.0 ? 27200.0 : 0.0 ) ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 25.0 : ( x <= 15.0 ? 26880.0 : 0.0 ) ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 4.0 : ( x <= 15.0 ? 30976.0 : 0.0 ) ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 43264.0 : 1.0 ) ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 41984.0 : 1.0 ) ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 21504.0 : 0.0 ) ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 41984.0 : 5.0 ) ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 41984.0 : 90.0 ) ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 41984.0 : 426.0 ) ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 20480.0 : 85.0 ) ) : idx;\n        idx = x >= 0.0 && x < 22.0 ? idx : 0.0;\n    }\n    \n    idx = SPRITE_DEC_4( x, idx );\n    \n\n    color = idx == 1.0 ? RGB( 0,   0,   0   ) : color;\n    color = idx == 2.0 ? RGB( 0,   88,  248 ) : color;\n    color = idx == 3.0 ? RGB( 255, 224, 168 ) : color;   \n}\n\nvoid SpriteBillProne( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;\n    \n    idx = y == 16.0 ? ( x <= 7.0 ? 64.0 : 0.0 ) : idx;\n    idx = y == 15.0 ? ( x <= 7.0 ? 400.0 : 0.0 ) : idx;\n    idx = y == 14.0 ? ( x <= 7.0 ? 1940.0 : 0.0 ) : idx;\n    idx = y == 13.0 ? ( x <= 7.0 ? 6745.0 : ( x <= 15.0 ? 0.0 : ( x <= 23.0 ? 84.0 : 0.0 ) ) ) : idx;\n    idx = y == 12.0 ? ( x <= 7.0 ? 27044.0 : ( x <= 15.0 ? 0.0 : ( x <= 23.0 ? 425.0 : 0.0 ) ) ) : idx;\n    idx = y == 11.0 ? ( x <= 7.0 ? 27024.0 : ( x <= 15.0 ? 0.0 : ( x <= 23.0 ? 341.0 : 1280.0 ) ) ) : idx;\n    idx = y == 10.0 ? ( x <= 7.0 ? 7744.0 : ( x <= 15.0 ? 20480.0 : ( x <= 23.0 ? 22005.0 : 6485.0 ) ) ) : idx;\n    idx = y == 9.0 ? ( x <= 7.0 ? 6800.0 : ( x <= 15.0 ? 41984.0 : ( x <= 23.0 ? 62966.0 : 31710.0 ) ) ) : idx;\n    idx = y == 8.0 ? ( x <= 7.0 ? 18128.0 : ( x <= 15.0 ? 64773.0 : ( x <= 23.0 ? 38747.0 : 27306.0 ) ) ) : idx;\n    idx = y == 7.0 ? ( x <= 7.0 ? 38564.0 : ( x <= 15.0 ? 65370.0 : ( x <= 23.0 ? 65435.0 : 5461.0 ) ) ) : idx;\n    idx = y == 6.0 ? ( x <= 7.0 ? 59833.0 : ( x <= 15.0 ? 65390.0 : ( x <= 23.0 ? 49051.0 : 501.0 ) ) ) : idx;\n    idx = y == 5.0 ? ( x <= 7.0 ? 60009.0 : ( x <= 15.0 ? 48602.0 : ( x <= 23.0 ? 44774.0 : 101.0 ) ) ) : idx;\n    idx = y == 4.0 ? ( x <= 7.0 ? 44718.0 : ( x <= 15.0 ? 64986.0 : ( x <= 23.0 ? 22267.0 : 126.0 ) ) ) : idx;\n    idx = y == 3.0 ? ( x <= 7.0 ? 43753.0 : ( x <= 15.0 ? 63125.0 : ( x <= 23.0 ? 43454.0 : 31.0 ) ) ) : idx;\n    idx = y == 2.0 ? ( x <= 7.0 ? 22185.0 : ( x <= 15.0 ? 62784.0 : ( x <= 23.0 ? 58495.0 : 5.0 ) ) ) : idx;\n    idx = y == 1.0 ? ( x <= 7.0 ? 340.0 : ( x <= 15.0 ? 54272.0 : ( x <= 23.0 ? 20511.0 : 0.0 ) ) ) : idx;\n    idx = y == 0.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 16384.0 : ( x <= 23.0 ? 5.0 : 0.0 ) ) ) : idx;\n    \n    idx = SPRITE_DEC_4( x, idx );\n    \n    idx = x >= 0.0 && x < 32.0 ? idx : 0.0;\n    color = idx == 1.0 ? RGB( 0,   0,   0   ) : color;\n    color = idx == 2.0 ? x < 15.0 ? RGB( 0,   88,  248 ) : RGB( 248, 56,  0   ) : color;\n    color = idx == 3.0 ? x < 15.0 ? RGB( 255, 224, 168 ) : RGB( 240, 208, 176 ) : color;   \n}\n\nvoid SpriteBillJump( inout vec3 color, float x, float y, float frame )\n{\n    float idx = 0.0;\n    bool colorA;\n    \n    if ( frame == 0.0 )\n    {   \n        colorA = x > 10.0;\n        idx = y == 15.0 ? ( x <= 7.0 ? 16384.0 : ( x <= 15.0 ? 5.0 : 0.0 ) ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 53312.0 : ( x <= 15.0 ? 95.0 : 0.0 ) ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 53648.0 : ( x <= 15.0 ? 415.0 : 16.0 ) ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 25956.0 : ( x <= 15.0 ? 1947.0 : 100.0 ) ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 38745.0 : ( x <= 15.0 ? 7787.0 : 109.0 ) ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 24549.0 : ( x <= 15.0 ? 27247.0 : 107.0 ) ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 38825.0 : ( x <= 15.0 ? 43375.0 : 26.0 ) ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 59748.0 : ( x <= 15.0 ? 38527.0 : 26.0 ) ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 65428.0 : ( x <= 15.0 ? 27295.0 : 5.0 ) ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 49124.0 : ( x <= 15.0 ? 27287.0 : 0.0 ) ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 49120.0 : ( x <= 15.0 ? 43737.0 : 1.0 ) ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 27600.0 : ( x <= 15.0 ? 43882.0 : 1.0 ) ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 48960.0 : ( x <= 15.0 ? 27247.0 : 0.0 ) ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 64768.0 : ( x <= 15.0 ? 27263.0 : 0.0 ) ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 54272.0 : ( x <= 15.0 ? 5759.0 : 0.0 ) ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 16384.0 : ( x <= 15.0 ? 341.0 : 0.0 ) ) : idx;\n        idx = x >= 0.0 && x < 20.0 ? idx : 0.0;\n    }\n    else\n    {\n        colorA = y < 9.0;\n        idx = y == 19.0 ? ( x <= 7.0 ? 0.0 : 84.0 ) : idx;\n        idx = y == 18.0 ? ( x <= 7.0 ? 20480.0 : 409.0 ) : idx;\n        idx = y == 17.0 ? ( x <= 7.0 ? 26880.0 : 1642.0 ) : idx;\n        idx = y == 16.0 ? ( x <= 7.0 ? 48960.0 : 6521.0 ) : idx;\n        idx = y == 15.0 ? ( x <= 7.0 ? 65488.0 : 1533.0 ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 65268.0 : 374.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 65268.0 : 5718.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 59837.0 : 32155.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 63229.0 : 32767.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 56061.0 : 32447.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 22205.0 : 5547.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 44373.0 : 6741.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 43945.0 : 1958.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 43684.0 : 489.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 43684.0 : 105.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 23120.0 : 26.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 17664.0 : 122.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 16384.0 : 490.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 0.0 : 1701.0 ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 0.0 : 336.0 ) : idx;\n        idx = x >= 0.0 && x < 16.0 ? idx : 0.0;\n    }\n    \n    idx = SPRITE_DEC_4( x, idx );\n    \n    color = idx == 1.0 ? RGB( 0,   0,   0   ) : color;\n    color = idx == 2.0 ? colorA ? RGB( 0,   88,  248 ) : RGB( 248, 56,  0   ) : color;\n    color = idx == 3.0 ? colorA ? RGB( 255, 224, 168 ) : RGB( 240, 208, 176 ) : color;   \n}\n\nvoid SpriteWaterCircle( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;\n    \n    idx = y == 6.0 ? ( x <= 7.0 ? 14336.0 : 44.0 ) : idx;\n    idx = y == 5.0 ? ( x <= 7.0 ? 49360.0 : 1795.0 ) : idx;\n    idx = y == 4.0 ? ( x <= 7.0 ? 31874.0 : 33341.0 ) : idx;\n    idx = y == 3.0 ? ( x <= 7.0 ? 819.0 : 52416.0 ) : idx;\n    idx = y == 2.0 ? ( x <= 7.0 ? 47112.0 : 8238.0 ) : idx;\n    idx = y == 1.0 ? ( x <= 7.0 ? 4144.0 : 3076.0 ) : idx;\n    idx = y == 0.0 ? ( x <= 7.0 ? 36352.0 : 178.0 ) : idx;\n\n    idx = SPRITE_DEC_4( x, idx );\n    idx = x >= 0.0 && x < 16.0 ? idx : 0.0;\n    \n    color = idx == 1.0 ? RGB( 0,    0,   0   ) : color;\n    color = idx == 2.0 ? RGB( 248,  56,  0   ) : color;\n    color = idx == 3.0 ? RGB( 240,  208, 176 ) : color;\n}\n\nvoid DrawTurret( inout vec3 color, vec4 turret, float worldX, float worldY )\n{\n    SpriteTurretBase( color, worldX - turret.x + TURRET_SIZE.x * 0.5, worldY - turret.y + TURRET_SIZE.y * 0.5 );\n    \n    \/\/ left \n    float frame     = 0.0;\n    float turretX   = worldX - turret.x;\n    float turretY   = worldY - turret.y;\n\n    if ( turret.z == 0.0 )\n    {\n        frame = 0.0;\n        turretX += 14.0;\n        turretY += 7.0;\n    }\n    else if ( turret.z == 1.0 )\n    {\n        frame = 1.0;\n        turretX += 13.0;\n        turretY += 7.0;\n    }\n    else if ( turret.z == 2.0 )\n    {\n        frame = 2.0;\n        turretX += 8.0;\n        turretY += 3.0;\n        Swap( turretX, turretY );\n        turretX = 15.0 - turretX;\n    }     \n    else if ( turret.z == 3.0 )\n    {\n        frame = 0.0;\n        turretX += 15.0;\n        turretY += 2.0;\n        Swap( turretX, turretY );\n        turretX = 15.0 - turretX;\n        turretY = 21.0 - turretY;\n    }\n    else if ( turret.z == 4.0 )\n    {\n        frame = 2.0;\n        turretX += 14.0;\n        turretY += 3.0;\n        Swap( turretX, turretY );\n        turretX = 15.0 - turretX;\n        turretY = 21.0 - turretY;\n    }\n    else if ( turret.z == 5.0 )\n    {\n        frame = 1.0;\n        turretX += 4.0;\n        turretY += 7.0;\n        turretX = 15.0 - turretX;        \n    }    \n    else if ( turret.z == 6.0 )\n    {\n        frame = 0.0;\n        turretX += 9.0;\n        turretY += 7.0;\n        turretX = 21.0 - turretX;       \n    }     \n    else if ( turret.z == 7.0 )\n    {\n        frame = 2.0;\n        turretX += 10.0;\n        turretY += 7.0;\n        turretX = 21.0 - turretX;       \n    }    \n    else if ( turret.z == 8.0 )\n    {\n        frame = 1.0;\n        turretX += 8.0;\n        turretY += 12.0;\n        Swap( turretX, turretY );       \n    }  \n    else if ( turret.z == 9.0 )\n    {\n        frame = 0.0;\n        turretX += 15.0;\n        turretY += 13.0;\n        Swap( turretX, turretY );\n        turretY = 21.0 - turretY;        \n    }          \n    else if ( turret.z == 10.0 )\n    {\n        frame = 1.0;\n        turretX += 15.0;\n        turretY += 12.0;\n        Swap( turretX, turretY );\n        turretY = 21.0 - turretY;        \n    }\n    else\n    {\n        frame = 2.0;\n        turretX += 13.0;\n        turretY += 8.0;        \n    }      \n\n    SpriteTurret( color, turretX, turretY, frame );\n}\n\nvoid DrawSoldier( inout vec3 color, vec4 soldier, vec4 soldierState, float worldX, float worldY )\n{\n    float soldierX = worldX - soldier.x + SOLDIER_SIZE.x * 0.5;\n    float soldierY = worldY - soldier.y;\n    soldierX = soldier.z < 0.0 ? SOLDIER_SIZE.x - soldierX : soldierX;\n    SpriteSoldier( color, soldierX, soldierY, soldierState.y );        \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ we want 224x192 (overscan) and we want multiples of pixel size\n    float resMultX      = floor( iResolution.x \/ NES_RES_X );\n    float resMultY      = floor( iResolution.y \/ NES_RES_Y );\n    float resRcp        = 1.0 \/ max( min( resMultX, resMultY ), 1.0 );\n    float screenWidth   = floor( iResolution.x * resRcp );\n    float screenHeight  = floor( iResolution.y * resRcp );\n    float pixelX        = floor( fragCoord.x * resRcp );\n    float pixelY        = floor( fragCoord.y * resRcp );  \n    \n    vec4 player         = LoadValue( txPlayer );\n    vec4 playerState    = LoadValue( txPlayerState );\n    vec4 playerDir      = LoadValue( txPlayerDir );\n    vec4 camera         = LoadValue( txCamera );\n    vec4 soldier0       = LoadValue( txSoldier0 );\n    vec4 soldier1       = LoadValue( txSoldier1 );\n    vec4 soldier2       = LoadValue( txSoldier2 );\n    vec4 soldier0State  = LoadValue( txSoldier0State );\n    vec4 soldier1State  = LoadValue( txSoldier1State );\n    vec4 soldier2State  = LoadValue( txSoldier2State );\n    vec4 sniper         = LoadValue( txSniper );\n    vec4 turret0        = LoadValue( txTurret0 );\n    vec4 turret1        = LoadValue( txTurret1 );\n\n    float worldX        = pixelX + camera.x;\n    float worldY        = pixelY - 8.0;\n    \n    vec2 screenUV = fragCoord.xy \/ iResolution.xy;\n    vec3 color = texture( iChannel1, screenUV ).xyz;\n            \n    float sniperX = worldX - sniper.x + SNIPER_SIZE.x * 0.5;\n    float sniperY = worldY - sniper.y;\n    sniperX = sniper.z < 0.0 ? 24.0 - sniperX : sniperX;\n    SpriteSniper( color, sniperX, sniperY );\n    \n    DrawTurret( color, turret0, worldX, worldY );\n    DrawTurret( color, turret1, worldX, worldY );\n    DrawSoldier( color, soldier0, soldier0State, worldX, worldY );\n    DrawSoldier( color, soldier1, soldier1State, worldX, worldY );\n    DrawSoldier( color, soldier2, soldier2State, worldX, worldY );\n   \n    \/\/ draw player\n    float billX = worldX - player.x;\n    float billY = worldY - player.y;\n    billX = playerDir.w > 0.0 && fract( 3.0 * iTime ) < 0.5 ? 100.0 : billX;\n    if ( playerState.x == STATE_PRONE )\n    {\n        billX += BILL_PRONE_SIZE.x * 0.5;\n        billX = playerDir.z < 0.0 ? BILL_PRONE_SIZE.x - billX : billX;\n        SpriteBillProne( color, billX, billY );\n    }\n    else if ( playerState.x == STATE_JUMP )\n    {\n        billX += BILL_JUMP_SIZE.x * 0.5;\n        billX = playerDir.z < 0.0 ? BILL_JUMP_SIZE.x - billX : billX;\n        SpriteBillJump( color, billX, billY, playerState.y );\n    }\n    else\n    {           \n        billX += BILL_RUN_SIZE.x * 0.5;\n        billX = playerDir.z < 0.0 ? BILL_RUN_SIZE.x - billX : billX;        \n\n        if ( playerState.x == STATE_WATER || playerState.x == STATE_UNDER_WATER )\n        {\n            SpriteWaterCircle( color, billX, billY - 4.0 );\n        }\n        \n        if ( playerState.x != STATE_WATER && playerState.x != STATE_UNDER_WATER )\n        {\n            SpriteBillLegs( color, billX, billY, playerState.y );            \n        }\n\n        float torsoX = billX + ( playerState.y == 0.0 ? 0.0 : -2.0 );\n        float torsoY = billY + ( playerState.x == STATE_WATER ? -8.0 : -20.0 );\n        if ( playerState.x != STATE_UNDER_WATER )\n        {\n            if ( playerDir.y > 0.0 && abs( playerDir.x ) > 0.0 )\n            {\n                SpriteBillTorsoTR( color, torsoX - 2.0, torsoY + 1.0 );            \n            }\n            else if ( playerDir.y > 0.0 )        \n            {\n                SpriteBillTorsoT( color, torsoX, torsoY + 1.0 );\n            }\n            else if ( playerDir.y < 0.0 )\n            {\n                SpriteBillTorsoBR( color, torsoX, torsoY + 7.0 );\n            }\n            else\n            {\n                SpriteBillTorsoR( color, torsoX, torsoY + 1.0 );\n            }\n        }\n    }\n\n    fragColor = vec4( color, 1.0 );\n}","name":"Buf C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\/\/ UI and some foreground stuff\n\n#define SPRITE_DEC_2( x, i ) mod( floor( i \/ pow( 2.0, mod( x, 24.0 ) ) ), 2.0 )\n#define SPRITE_DEC_3( x, i ) mod( floor( i \/ pow( 4.0, mod( x, 11.0 ) ) ), 4.0 )\n#define SPRITE_DEC_4( x, i ) mod( floor( i \/ pow( 4.0, mod( x, 8.0 ) ) ), 4.0 )\n#define RGB( r, g, b ) vec3( float( r ) \/ 255.0, float( g ) \/ 255.0, float( b ) \/ 255.0 )\n\nconst float NES_RES_X               = 224.0;\nconst float NES_RES_Y               = 192.0;\nconst float GAME_STATE_TITLE\t\t= 0.0;\nconst float GAME_STATE_LEVEL\t\t= 1.0;\nconst float GAME_STATE_LEVEL_DIE\t= 2.0;\nconst float GAME_STATE_LEVEL_WIN\t= 3.0;\nconst float GAME_STATE_GAME_OVER\t= 4.0;\nconst float GAME_STATE_VICTORY\t\t= 5.0;\nconst float WEAPON_RIFLE        \t= 0.0;\nconst vec2  BULLET_SIZE         \t= vec2( 3.0,  3.0  );\nconst vec2  POWER_UP_SIZE       \t= vec2( 24.0, 14.0 );\nconst float UI_VICTORY_TIME\t\t\t= 300.0;\n\n\/\/ storage\nconst vec2 txPlayer \t\t\t= vec2( 0.0, 0.0 ); \t\/\/ xy - pos, z - jump start, w - jump dir\nconst vec2 txPlayerState\t\t= vec2( 1.0, 0.0 ); \t\/\/ x - state, y - frame, z - jump tick, w - lifes\nconst vec2 txPlayerDir\t\t\t= vec2( 2.0, 0.0 ); \t\/\/ xy - dir, z - flip, w - immortality\nconst vec2 txPlayerWeapon\t\t= vec2( 3.0, 0.0 ); \t\/\/ x - weapon, y - weapon cooldown, z - weapon fire rate, w - weapon bullet num\nconst vec2 txCamera \t\t\t= vec2( 4.0, 0.0 ); \t\/\/ x - cam offset, y - spawn counter, z - soldier spawn counter\nconst vec2 txSoldier0 \t\t\t= vec2( 5.0, 0.0 ); \t\/\/ xy - pos, z - flip\nconst vec2 txSoldier1 \t\t\t= vec2( 5.0, 1.0 ); \t\/\/ xy - pos, z - flip\nconst vec2 txSoldier2 \t\t\t= vec2( 5.0, 2.0 ); \t\/\/ xy - pos, z - flip\nconst vec2 txSoldier0State \t\t= vec2( 6.0, 0.0 ); \t\/\/ x - state, y - frame, z - jump tick\nconst vec2 txSoldier1State \t\t= vec2( 6.0, 1.0 ); \t\/\/ x - state, y - frame, z - jump tick\nconst vec2 txSoldier2State \t\t= vec2( 6.0, 2.0 ); \t\/\/ x - state, y - frame, z - jump tick\nconst vec2 txSniper\t \t\t\t= vec2( 7.0, 0.0 ); \t\/\/ xy - pos, z - flip, w - weapon cooldown\nconst vec2 txPlayerBullet0 \t\t= vec2( 8.0, 0.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txPlayerBullet1 \t\t= vec2( 8.0, 1.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txPlayerBullet2 \t\t= vec2( 8.0, 2.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txPlayerBullet3 \t\t= vec2( 8.0, 3.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txPlayerBullet4 \t\t= vec2( 8.0, 4.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txPlayerBullet5 \t\t= vec2( 8.0, 5.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txEnemyBullet0 \t\t= vec2( 9.0, 0.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txEnemyBullet1 \t\t= vec2( 9.0, 1.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txEnemyBullet2 \t\t= vec2( 9.0, 2.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txEnemyBullet3 \t\t= vec2( 9.0, 3.0 ); \t\/\/ xy - pos, xy - dir\nconst vec2 txExplosion \t\t\t= vec2( 10.0, 0.0 ); \t\/\/ xy - pos, z - frame\nconst vec2 txHit \t\t\t\t= vec2( 11.0, 0.0 ); \t\/\/ xy - pos, z - frame\nconst vec2 txTurret0\t\t\t= vec2( 12.0, 0.0 ); \t\/\/ xy - pos, z - angle\nconst vec2 txTurret1\t\t\t= vec2( 12.0, 1.0 ); \t\/\/ xy - pos, z - angle\nconst vec2 txTurret0State\t\t= vec2( 13.0, 0.0 ); \t\/\/ x - HP, y - weapon cooldown\nconst vec2 txTurret1State\t\t= vec2( 13.0, 1.0 ); \t\/\/ x - HP, y - weapon cooldown\nconst vec2 txPowerUp\t\t\t= vec2( 14.0, 0.0 ); \t\/\/ xy - pos, z - frame\nconst vec2 txPowerUpState\t\t= vec2( 15.0, 0.0 ); \t\/\/ x - state, y - initial height, z - jump tick\nconst vec2 txBossCore\t\t\t= vec2( 16.0, 0.0 ); \t\/\/ xy - pos, z - HP\nconst vec2 txBossCannon0\t\t= vec2( 17.0, 0.0 ); \t\/\/ xy - pos, z - cooldown, w - HP\nconst vec2 txBossCannon1\t\t= vec2( 17.0, 1.0 ); \t\/\/ xy - pos, z - cooldown, w - HP\nconst vec2 txBossBullet0\t\t= vec2( 18.0, 0.0 ); \t\/\/ xy - pos, zw - velocity\nconst vec2 txBossBullet1\t\t= vec2( 18.0, 1.0 ); \t\/\/ xy - pos, zw - velocity\nconst vec2 txGameState\t\t\t= vec2( 19.0, 0.0 ); \t\/\/ x - state, y - state tick\nconst vec2 txBridge\t\t\t\t= vec2( 20.0, 0.0 ); \t\/\/ x - draw start, y - explode tick\n\nvec4 LoadValue( vec2 tx )\n{\n    return floor( texture( iChannel0, ( tx + 0.5 ) \/ iChannelResolution[ 0 ].xy ) );\n}\n\nfloat Rand( vec2 co )\n{\n    return fract( sin( dot( co.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );\n}\n\nvoid SpritePowerBullet( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;\n    \n    idx = y == 4.0 ? ( x <= 7.0 ? 84.0 : 0.0 ) : idx;\n    idx = y == 3.0 ? ( x <= 7.0 ? 349.0 : 0.0 ) : idx;\n    idx = y == 2.0 ? ( x <= 7.0 ? 405.0 : 0.0 ) : idx;\n    idx = y == 1.0 ? ( x <= 7.0 ? 361.0 : 0.0 ) : idx;\n    idx = y == 0.0 ? ( x <= 7.0 ? 84.0 : 0.0 ) : idx;\n\n    idx = SPRITE_DEC_4( x, idx );\n    idx = x >= 0.0 && x < 5.0 ? idx : 0.0;\n    \n    color = idx == 1.0 ? RGB( 255,  46,   0 ) : color;\n    color = idx == 2.0 ? RGB( 255, 112,  78 ) : color;\n    color = idx == 3.0 ? RGB( 255, 255, 255 ) : color;\n}\n\nvoid SpriteBullet( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;\n    \n    idx = y == 2.0 ? ( x <= 7.0 ? 4.0 : 0.0 ) : idx;\n    idx = y == 1.0 ? ( x <= 7.0 ? 21.0 : 0.0 ) : idx;\n    idx = y == 0.0 ? ( x <= 7.0 ? 4.0 : 0.0 ) : idx;\n\n    idx = SPRITE_DEC_4( x, idx );\n    idx = x >= 0.0 && x < 3.0 ? idx : 0.0;\n    \n    color = idx == 1.0 ? RGB( 255, 255, 255 ) : color;\n}\n\nvoid SpriteHit( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;    \n    \n    idx = y == 6.0 ? 608.0 : idx;\n    idx = y == 5.0 ? 2056.0 : idx;\n    idx = y == 4.0 ? 8194.0 : idx;\n    idx = y == 3.0 ? 4097.0 : idx;\n    idx = y == 2.0 ? 8194.0 : idx;\n    idx = y == 1.0 ? 2056.0 : idx;\n    idx = y == 0.0 ? 608.0 : idx;\n\n    idx = SPRITE_DEC_3( x, idx );\n    idx = x >= 0.0 && x < 7.0 ? idx : 0.0;\n    \n    color = idx == 1.0 ? RGB( 228,  68,  52 ) : color;\n    color = idx == 2.0 ? RGB( 255, 140, 124 ) : color;\n}\n\nvoid SpriteExplosion( inout vec3 color, float x, float y, float frame )\n{\n    float idx = 0.0;\n    \n    x = abs( x );\n    y = abs( y );\n\n    if ( frame == 0.0 )\n    {\n        idx = y == 11.0 ? ( x <= 7.0 ? 21.0 : 0.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 342.0 : 0.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 5541.0 : 0.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 26990.0 : 0.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 32182.0 : ( x <= 15.0 ? 1.0 : 0.0 ) ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 39595.0 : ( x <= 15.0 ? 5.0 : 0.0 ) ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 64183.0 : ( x <= 15.0 ? 6.0 : 0.0 ) ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 44783.0 : ( x <= 15.0 ? 23.0 : 0.0 ) ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 48127.0 : ( x <= 15.0 ? 22.0 : 0.0 ) ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 44799.0 : ( x <= 15.0 ? 103.0 : 0.0 ) ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 64511.0 : ( x <= 15.0 ? 90.0 : 0.0 ) ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 49151.0 : ( x <= 15.0 ? 90.0 : 0.0 ) ) : idx;\n    }\n    else if ( frame == 1.0 )\n    {\n        idx = y == 13.0 ? ( x <= 7.0 ? 25.0 : 0.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 1705.0 : 0.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 23295.0 : 0.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 32682.0 : ( x <= 15.0 ? 5.0 : 0.0 ) ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 65232.0 : ( x <= 15.0 ? 22.0 : 0.0 ) ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 58384.0 : ( x <= 15.0 ? 27.0 : 0.0 ) ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 57600.0 : ( x <= 15.0 ? 107.0 : 0.0 ) ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 41216.0 : ( x <= 15.0 ? 110.0 : 0.0 ) ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 430.0 : 0.0 ) ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 32768.0 : ( x <= 15.0 ? 430.0 : 0.0 ) ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 16384.0 : ( x <= 15.0 ? 442.0 : 0.0 ) ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 4096.0 : ( x <= 15.0 ? 1462.0 : 0.0 ) ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 1520.0 : 0.0 ) ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 1460.0 : 0.0 ) ) : idx;\n    }\n    else\n    {   \n        idx = y == 15.0 ? ( x <= 7.0 ? 68.0 : 0.0 ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 1280.0 : 0.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 16384.0 : 0.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 5.0 : 0.0 ) ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 16.0 : 0.0 ) ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 64.0 : 0.0 ) ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 256.0 : 0.0 ) ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 4096.0 : 0.0 ) ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 16384.0 : 0.0 ) ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 16384.0 : 0.0 ) ) : idx;\n        \n    }\n\n    idx = SPRITE_DEC_4( x, idx );\n    idx = x >= 0.0 && x < 12.0 + frame * 2.0 ? idx : 0.0;\n    \n    color = idx == 1.0 ? RGB( 228,  68,  52 ) : color;\n    color = idx == 2.0 ? RGB( 255, 140, 124 ) : color;\n    color = idx == 3.0 ? RGB( 255, 255, 255 ) : color;\n}\n\nvoid SpritePowerUp( inout vec3 color, float x, float y, float frame )\n{\n    float idx = 0.0;    \n    \n    if ( frame == 0.0 )\n    {\n        idx = y == 13.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 5460.0 : 0.0 ) ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 16384.0 : ( x <= 15.0 ? 32765.0 : 1.0 ) ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 54272.0 : ( x <= 15.0 ? 54615.0 : 23.0 ) ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 23808.0 : ( x <= 15.0 ? 31421.0 : 117.0 ) ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 55104.0 : ( x <= 15.0 ? 65215.0 : 471.0 ) ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 40276.0 : ( x <= 15.0 ? 43690.0 : 5494.0 ) ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 57193.0 : ( x <= 15.0 ? 43690.0 : 27127.0 ) ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 57193.0 : ( x <= 15.0 ? 64175.0 : 27127.0 ) ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 56660.0 : ( x <= 15.0 ? 65215.0 : 5495.0 ) ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 55104.0 : ( x <= 15.0 ? 64175.0 : 471.0 ) ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 23808.0 : ( x <= 15.0 ? 27305.0 : 117.0 ) ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 54272.0 : ( x <= 15.0 ? 54615.0 : 23.0 ) ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 16384.0 : ( x <= 15.0 ? 32765.0 : 1.0 ) ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 5460.0 : 0.0 ) ) : idx;\n    }\n    else\n    {\n        idx = y == 14.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 320.0 : 0.0 ) ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 1744.0 : 0.0 ) ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 6836.0 : 0.0 ) ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 2389.0 : ( x <= 15.0 ? 1680.0 : 21856.0 ) ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 8123.0 : ( x <= 15.0 ? 21845.0 : 61172.0 ) ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 31078.0 : ( x <= 15.0 ? 26969.0 : 39277.0 ) ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 42669.0 : ( x <= 15.0 ? 27241.0 : 31386.0 ) ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 39252.0 : ( x <= 15.0 ? 27305.0 : 5478.0 ) ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 27344.0 : ( x <= 15.0 ? 27305.0 : 1961.0 ) ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 42304.0 : ( x <= 15.0 ? 27033.0 : 346.0 ) ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 44288.0 : ( x <= 15.0 ? 26969.0 : 122.0 ) ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 21504.0 : ( x <= 15.0 ? 26969.0 : 21.0 ) ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 26969.0 : 0.0 ) ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 26969.0 : 0.0 ) ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 0.0 : ( x <= 15.0 ? 21845.0 : 0.0 ) ) : idx;\n    }\n\n    idx = SPRITE_DEC_4( x, idx );\n    idx = x >= 0.0 && x < 24.0 ? idx : 0.0;    \n    \n    color = idx == 1.0 ? RGB( 0,    0,   0   ) : color;\n    color = idx == 2.0 ? RGB( 228,  68,  52  ) : color;\n    color = idx == 3.0 ? RGB( 255,  184, 168 ) : color;\n}\n\nvoid SpriteLife( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;\n    \n    idx = y == 15.0 ? 21845.0 : idx;\n    idx = y == 14.0 ? 26985.0 : idx;\n    idx = y == 13.0 ? 26985.0 : idx;\n    idx = y == 12.0 ? 26985.0 : idx;\n    idx = y == 11.0 ? 26985.0 : idx;\n    idx = y == 10.0 ? 6500.0 : idx;\n    idx = y == 9.0 ? 1360.0 : idx;\n    idx = y == 8.0 ? 1744.0 : idx;\n    idx = y == 7.0 ? 1360.0 : idx;\n    idx = y == 6.0 ? 7140.0 : idx;\n    idx = y == 5.0 ? 28345.0 : idx;\n    idx = y == 4.0 ? 31725.0 : idx;\n    idx = y == 3.0 ? 31725.0 : idx;\n    idx = y == 2.0 ? 28345.0 : idx;\n    idx = y == 1.0 ? 7140.0 : idx;\n    idx = y == 0.0 ? 1360.0 : idx;    \n    \n    idx = SPRITE_DEC_4( x, idx );\n    \n    color = idx == 1.0 ? RGB( 0,    0,   0   ) : color;\n    color = idx == 2.0 ? RGB( 48,   31,  252 ) : color;\n    color = idx == 3.0 ? RGB( 255,  218, 144 ) : color;\n}\n\nvoid SpriteStage1( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;\n\n    idx = y == 6.0 ? ( x <= 23.0 ? 4095806.0 : ( x <= 47.0 ? 32574.0 : 30.0 ) ) : idx;\n    idx = y == 5.0 ? ( x <= 23.0 ? 8330311.0 : ( x <= 47.0 ? 1895.0 : 28.0 ) ) : idx;\n    idx = y == 4.0 ? ( x <= 23.0 ? 7412743.0 : ( x <= 47.0 ? 1799.0 : 28.0 ) ) : idx;\n    idx = y == 3.0 ? ( x <= 23.0 ? 7412798.0 : ( x <= 47.0 ? 32631.0 : 28.0 ) ) : idx;\n    idx = y == 2.0 ? ( x <= 23.0 ? 8330352.0 : ( x <= 47.0 ? 1895.0 : 28.0 ) ) : idx;\n    idx = y == 1.0 ? ( x <= 23.0 ? 7412851.0 : ( x <= 47.0 ? 1911.0 : 28.0 ) ) : idx;\n    idx = y == 0.0 ? ( x <= 23.0 ? 7412798.0 : ( x <= 47.0 ? 32606.0 : 62.0 ) ) : idx;\n    \n    idx = SPRITE_DEC_2( x, idx );\n    idx = x >= 0.0 && x < 54.0 ? idx : 0.0;\n\n    color = idx == 1.0 ? RGB( 255, 255, 255 ) : color;\n}\n\nvoid SpriteJungle( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;\n\n    idx = y == 6.0 ? ( x <= 23.0 ? 6776700.0 : 8324926.0 ) : idx;\n    idx = y == 5.0 ? ( x <= 23.0 ? 7300920.0 : 460647.0 ) : idx;\n    idx = y == 4.0 ? ( x <= 23.0 ? 8087352.0 : 460551.0 ) : idx;\n    idx = y == 3.0 ? ( x <= 23.0 ? 7563064.0 : 8324983.0 ) : idx;\n    idx = y == 2.0 ? ( x <= 23.0 ? 6514489.0 : 460647.0 ) : idx;\n    idx = y == 1.0 ? ( x <= 23.0 ? 6514489.0 : 460663.0 ) : idx;\n    idx = y == 0.0 ? ( x <= 23.0 ? 6503966.0 : 8355678.0 ) : idx;\n\n    idx = SPRITE_DEC_2( x, idx );\n    idx = x >= 0.0 && x < 47.0 ? idx : 0.0;\n\n    color = idx == 1.0 ? RGB( 255, 255, 255 ) : color;\n}\n\nvoid SpriteGameOver( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;\n\n    idx = y == 6.0 ? ( x <= 23.0 ? 6503998.0 : ( x <= 47.0 ? 4063359.0 : 4161399.0 ) ) : idx;\n    idx = y == 5.0 ? ( x <= 23.0 ? 7831399.0 : ( x <= 47.0 ? 7536647.0 : 6752119.0 ) ) : idx;\n    idx = y == 4.0 ? ( x <= 23.0 ? 8352007.0 : ( x <= 47.0 ? 7536647.0 : 6752054.0 ) ) : idx;\n    idx = y == 3.0 ? ( x <= 23.0 ? 6123895.0 : ( x <= 47.0 ? 7536767.0 : 4161334.0 ) ) : idx;\n    idx = y == 2.0 ? ( x <= 23.0 ? 4816743.0 : ( x <= 47.0 ? 7536647.0 : 3606300.0 ) ) : idx;\n    idx = y == 1.0 ? ( x <= 23.0 ? 4288887.0 : ( x <= 47.0 ? 8323079.0 : 6752028.0 ) ) : idx;\n    idx = y == 0.0 ? ( x <= 23.0 ? 4288862.0 : ( x <= 47.0 ? 4063359.0 : 6782728.0 ) ) : idx;\n\n    idx = SPRITE_DEC_2( x, idx );\n    idx = x >= 0.0 && x < 71.0 ? idx : 0.0;\n\n    color = idx == 1.0 ? RGB( 255, 255, 255 ) : color;\n}\n\nvoid SpriteHelicopter( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;    \n    \n\tidx = y == 10.0 ? ( x <= 7.0 ? 0.0 : 32768.0 ) : idx;\n\tidx = y == 9.0 ? ( x <= 7.0 ? 0.0 : 28672.0 ) : idx;\n\tidx = y == 8.0 ? ( x <= 7.0 ? 0.0 : 24672.0 ) : idx;\n\tidx = y == 7.0 ? ( x <= 7.0 ? 0.0 : 6155.0 ) : idx;\n\tidx = y == 6.0 ? ( x <= 7.0 ? 57344.0 : 1600.0 ) : idx;\n\tidx = y == 5.0 ? ( x <= 7.0 ? 6400.0 : 424.0 ) : idx;\n\tidx = y == 4.0 ? ( x <= 7.0 ? 36944.0 : 106.0 ) : idx;\n\tidx = y == 3.0 ? ( x <= 7.0 ? 58373.0 : 27.0 ) : idx;\n\tidx = y == 2.0 ? ( x <= 7.0 ? 57600.0 : 26.0 ) : idx;\n\tidx = y == 1.0 ? ( x <= 7.0 ? 43264.0 : 5.0 ) : idx;\n\tidx = y == 0.0 ? ( x <= 7.0 ? 21760.0 : 0.0 ) : idx;\n    \n    idx = SPRITE_DEC_4( x, idx );\n    idx = x >= 0.0 && x < 16.0 ? idx : 0.0;\n\n    color = idx == 1.0 ? RGB( 0,   91,  0 )   : color;\n    color = idx == 2.0 ? RGB( 0,   171, 71 )  : color;\n    color = idx == 3.0 ? RGB( 184, 248, 216 ) : color;\n}\n\nvoid SpriteVictory( inout vec3 color, float x, float y )\n{\n    float idx = 0.0;\n\n    idx = y == 6.0 ? ( x <= 23.0 ? 6766142.0 : ( x <= 47.0 ? 4079422.0 : ( x <= 71.0 ? 485247.0 : ( x <= 95.0 ? 4095806.0 : ( x <= 119.0 ? 4089662.0 : 28.0 ) ) ) ) ) : idx;\n    idx = y == 5.0 ? ( x <= 23.0 ? 7304039.0 : ( x <= 47.0 ? 8349543.0 : ( x <= 71.0 ? 485148.0 : ( x <= 95.0 ? 1842303.0 : ( x <= 119.0 ? 4681587.0 : 28.0 ) ) ) ) ) : idx;\n    idx = y == 4.0 ? ( x <= 23.0 ? 8090471.0 : ( x <= 47.0 ? 7431943.0 : ( x <= 71.0 ? 485148.0 : ( x <= 95.0 ? 1842289.0 : ( x <= 119.0 ? 490355.0 : 28.0 ) ) ) ) ) : idx;\n    idx = y == 3.0 ? ( x <= 23.0 ? 7566087.0 : ( x <= 47.0 ? 7421815.0 : ( x <= 71.0 ? 485148.0 : ( x <= 95.0 ? 1842289.0 : ( x <= 119.0 ? 4092787.0 : 28.0 ) ) ) ) ) : idx;\n    idx = y == 2.0 ? ( x <= 23.0 ? 6517607.0 : ( x <= 47.0 ? 8337255.0 : ( x <= 71.0 ? 485148.0 : ( x <= 95.0 ? 1842303.0 : ( x <= 119.0 ? 7365491.0 : 0.0 ) ) ) ) ) : idx;\n    idx = y == 1.0 ? ( x <= 23.0 ? 6520679.0 : ( x <= 47.0 ? 7432055.0 : ( x <= 71.0 ? 485148.0 : ( x <= 95.0 ? 1842289.0 : ( x <= 119.0 ? 7562111.0 : 0.0 ) ) ) ) ) : idx;\n    idx = y == 0.0 ? ( x <= 23.0 ? 6503998.0 : ( x <= 47.0 ? 7432030.0 : ( x <= 71.0 ? 8338972.0 : ( x <= 95.0 ? 4070513.0 : ( x <= 119.0 ? 4088638.0 : 28.0 ) ) ) ) ) : idx;\n\n    idx = SPRITE_DEC_2( x, idx );\n    idx = x >= 0.0 && x < 125.0 ? idx : 0.0;\n\n    color = idx == 1.0 ? RGB( 255, 255, 255 ) : color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    \/\/ we want 224x192 (overscan) and we want multiples of pixel size\n    float resMultX      = floor( iResolution.x \/ NES_RES_X );\n    float resMultY      = floor( iResolution.y \/ NES_RES_Y );\n    float resRcp        = 1.0 \/ max( min( resMultX, resMultY ), 1.0 );\n    float screenWidth   = floor( iResolution.x * resRcp );\n    float screenHeight  = floor( iResolution.y * resRcp );\n    float pixelX        = floor( fragCoord.x * resRcp );\n    float pixelY        = floor( fragCoord.y * resRcp );   \n    \n    vec4 playerState    = LoadValue( txPlayerState );\n    vec4 playerWeapon   = LoadValue( txPlayerWeapon );    \n    vec4 camera         = LoadValue( txCamera );\n    vec4 playerBullet0  = LoadValue( txPlayerBullet0 );\n    vec4 playerBullet1  = LoadValue( txPlayerBullet1 );\n    vec4 playerBullet2  = LoadValue( txPlayerBullet2 );\n    vec4 playerBullet3  = LoadValue( txPlayerBullet3 );\n    vec4 playerBullet4  = LoadValue( txPlayerBullet4 );\n    vec4 playerBullet5  = LoadValue( txPlayerBullet5 );\n    vec4 enemyBullet0   = LoadValue( txEnemyBullet0 );\n    vec4 enemyBullet1   = LoadValue( txEnemyBullet1 );\n    vec4 enemyBullet2   = LoadValue( txEnemyBullet2 );\n    vec4 enemyBullet3   = LoadValue( txEnemyBullet3 );\n    vec4 bossBullet0\t= LoadValue( txBossBullet0 );\n    vec4 bossBullet1\t= LoadValue( txBossBullet1 );\n    vec4 powerUp        = LoadValue( txPowerUp );    \n    vec4 explosion      = LoadValue( txExplosion );\n    vec4 hit            = LoadValue( txHit );    \n    vec4 gameState      = LoadValue( txGameState );\n\n    float worldX        = pixelX + camera.x;\n    float worldY        = pixelY - 8.0;    \n\n    vec2 screenUV = fragCoord.xy \/ iResolution.xy;\n    vec3 color = texture( iChannel1, screenUV ).xyz; \n    \n    SpritePowerUp( color, worldX - powerUp.x + POWER_UP_SIZE.x * 0.5, worldY - powerUp.y, powerUp.z );\n    if ( playerWeapon.x == WEAPON_RIFLE )\n    {\n        SpriteBullet( color, worldX - playerBullet0.x + 1.0, worldY - playerBullet0.y );\n        SpriteBullet( color, worldX - playerBullet1.x + 1.0, worldY - playerBullet1.y );\n        SpriteBullet( color, worldX - playerBullet2.x + 1.0, worldY - playerBullet2.y );\n        SpriteBullet( color, worldX - playerBullet3.x + 1.0, worldY - playerBullet3.y );\n        SpriteBullet( color, worldX - playerBullet4.x + 1.0, worldY - playerBullet4.y );\n        SpriteBullet( color, worldX - playerBullet5.x + 1.0, worldY - playerBullet5.y );\n    }\n    else\n    {\n        SpritePowerBullet( color, worldX - playerBullet0.x + 2.0, worldY - playerBullet0.y );\n        SpritePowerBullet( color, worldX - playerBullet1.x + 2.0, worldY - playerBullet1.y );\n        SpritePowerBullet( color, worldX - playerBullet2.x + 2.0, worldY - playerBullet2.y );\n        SpritePowerBullet( color, worldX - playerBullet3.x + 2.0, worldY - playerBullet3.y );\n        SpritePowerBullet( color, worldX - playerBullet4.x + 2.0, worldY - playerBullet4.y );\n        SpritePowerBullet( color, worldX - playerBullet5.x + 2.0, worldY - playerBullet5.y );\n    }\n    SpriteBullet( color, worldX - enemyBullet0.x + 1.0, worldY - enemyBullet0.y );\n    SpriteBullet( color, worldX - enemyBullet1.x + 1.0, worldY - enemyBullet1.y );\n    SpriteBullet( color, worldX - enemyBullet2.x + 1.0, worldY - enemyBullet2.y );\n    SpriteBullet( color, worldX - enemyBullet3.x + 1.0, worldY - enemyBullet3.y );\n\tSpritePowerBullet( color, worldX - bossBullet0.x + 2.0, worldY - bossBullet0.y );\n\tSpritePowerBullet( color, worldX - bossBullet1.x + 2.0, worldY - bossBullet1.y );    \n    SpriteExplosion( color, worldX - explosion.x, worldY - explosion.y, explosion.z );\n    SpriteHit( color, worldX - hit.x, worldY - hit.y );      \n    \n    if ( pixelX > 32.0 && pixelX < 32.0 + 8.0 * ( playerState.w - 1.0 ) )\n    {\n        SpriteLife( color, pixelX, pixelY - screenHeight + 32.0 );\n    }\n    \n    if ( gameState.x == GAME_STATE_TITLE )\n    {\n        color = vec3( 0.0 );\n        SpriteStage1( color, pixelX - floor( screenWidth * 0.5 - 30.5 ), pixelY - floor( screenHeight * 0.5 - 10.5 ) );\n        SpriteJungle( color, pixelX - floor( screenWidth * 0.5 - 30.5 ), pixelY - floor( screenHeight * 0.5 + 10.5 ) );\n    }\n    else if ( gameState.x == GAME_STATE_GAME_OVER )\n    {\n        color = vec3( 0.0 );\n        SpriteGameOver( color, pixelX - floor( screenWidth * 0.5 - 36.5 ), pixelY - floor( screenHeight * 0.5 ) );\n    }\n    else if ( gameState.x == GAME_STATE_VICTORY )\n    {\n        \/\/ water \/ sky\n        color = pixelY < 80.0 ? RGB( 0, 112, 236 ) : vec3( 0.0 );\n        \n        \/\/ stars\n        float starRand = Rand( vec2( worldX * 0.01, worldY * 0.01 ) );\n        if ( starRand > 0.998 && worldY > 130.0 )\n        {\n            color = fract( iTime + starRand * 113.17 + worldX * 3.14 ) < 0.5 ? RGB( 255, 255, 255 ) : RGB( 0, 112, 236 );\n        }        \n        \n        SpriteVictory( color, pixelX - floor( screenWidth * 0.5 - 63.5 ), pixelY - floor( screenHeight * 0.5 ) - 20.0 );\n        SpriteHelicopter( color, floor( pixelX - screenWidth * ( 0.25 + 0.5 * ( 1.0 - gameState.y \/ UI_VICTORY_TIME ) ) ), pixelY - 90.0 );\n    }\n    else if ( gameState.x == GAME_STATE_LEVEL )\n    {\n\t\tfloat fadeAlpha = clamp( ( gameState.y - 30.0 ) \/ 30.0, 0.0, 1.0 );\n        color = pixelX < fadeAlpha * screenWidth ? color : vec3( 0.0 );\n    }\n    \n    fragColor = vec4( color, 1.0 );\n}","name":"Buf D","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"4s2yW1","date":"1492029808","viewed":9767,"name":"Bokeh Paralax","username":"knarkowicz","description":"Feeling artsy","likes":154,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float MATH_PI\t= float( 3.14159265359 );\n\nvoid Rotate( inout vec2 p, float a ) \n{\n\tp = cos( a ) * p + sin( a ) * vec2( p.y, -p.x );\n}\n\nfloat Circle( vec2 p, float r )\n{\n    return ( length( p \/ r ) - 1.0 ) * r;\n}\n\nfloat Rand( vec2 c )\n{\n\treturn fract( sin( dot( c.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );\n}\n\nfloat saturate( float x )\n{\n\treturn clamp( x, 0.0, 1.0 );\n}\n\nvoid BokehLayer( inout vec3 color, vec2 p, vec3 c )   \n{\n    float wrap = 450.0;    \n    if ( mod( floor( p.y \/ wrap + 0.5 ), 2.0 ) == 0.0 )\n    {\n        p.x += wrap * 0.5;\n    }    \n    \n    vec2 p2 = mod( p + 0.5 * wrap, wrap ) - 0.5 * wrap;\n    vec2 cell = floor( p \/ wrap + 0.5 );\n    float cellR = Rand( cell );\n        \n    c *= fract( cellR * 3.33 + 3.33 );    \n    float radius = mix( 30.0, 70.0, fract( cellR * 7.77 + 7.77 ) );\n    p2.x *= mix( 0.9, 1.1, fract( cellR * 11.13 + 11.13 ) );\n    p2.y *= mix( 0.9, 1.1, fract( cellR * 17.17 + 17.17 ) );\n    \n    float sdf = Circle( p2, radius );\n    float circle = 1.0 - smoothstep( 0.0, 1.0, sdf * 0.04 );\n    float glow\t = exp( -sdf * 0.025 ) * 0.3 * ( 1.0 - circle );\n    color += c * ( circle + glow );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n\tvec2 p = ( 2.0 * fragCoord - iResolution.xy ) \/ iResolution.x * 1000.0;\n    \n    \/\/ background\n\tvec3 color = mix( vec3( 0.3, 0.1, 0.3 ), vec3( 0.1, 0.4, 0.5 ), dot( uv, vec2( 0.2, 0.7 ) ) );\n\n    float time = iTime - 15.0;\n    \n    Rotate( p, 0.2 + time * 0.03 );\n    BokehLayer( color, p + vec2( -50.0 * time +  0.0, 0.0  ), 3.0 * vec3( 0.4, 0.1, 0.2 ) );\n\tRotate( p, 0.3 - time * 0.05 );\n    BokehLayer( color, p + vec2( -70.0 * time + 33.0, -33.0 ), 3.5 * vec3( 0.6, 0.4, 0.2 ) );\n\tRotate( p, 0.5 + time * 0.07 );\n    BokehLayer( color, p + vec2( -60.0 * time + 55.0, 55.0 ), 3.0 * vec3( 0.4, 0.3, 0.2 ) );\n    Rotate( p, 0.9 - time * 0.03 );\n    BokehLayer( color, p + vec2( -25.0 * time + 77.0, 77.0 ), 3.0 * vec3( 0.4, 0.2, 0.1 ) );    \n    Rotate( p, 0.0 + time * 0.05 );\n    BokehLayer( color, p + vec2( -15.0 * time + 99.0, 99.0 ), 3.0 * vec3( 0.2, 0.0, 0.4 ) );     \n\n\tfragColor = vec4( color, 1.0 );\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4dKXDy","date":"1466577438","viewed":9693,"name":"Quake Logo","username":"knarkowicz","description":"Quake logo made for 20th Quake anniversary","likes":67,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"\/media\/a\/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"\/media\/ap\/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float MATH_PI = float( 3.14159265359 );\n\nfloat VisibilityTerm( float roughness, float ndotv, float ndotl )\n{\n\tfloat m2\t= roughness * roughness;\n\tfloat visV\t= ndotl * sqrt( ndotv * ( ndotv - ndotv * m2 ) + m2 );\n\tfloat visL\t= ndotv * sqrt( ndotl * ( ndotl - ndotl * m2 ) + m2 );\n\treturn 0.5 \/ max( visV + visL, 0.00001 );\n}\n\nfloat DistributionTerm( float roughness, float ndoth )\n{\n\tfloat m2\t= roughness * roughness;\n\tfloat d\t\t= ( ndoth * m2 - ndoth ) * ndoth + 1.0;\n\treturn m2 \/ ( d * d * MATH_PI );\n}\n\nvec3 FresnelTerm( vec3 specularColor, float vdoth )\n{\n\tvec3 fresnel = clamp( 50.0 * specularColor.y, 0.0, 1.0 ) * specularColor + ( 1.0 - specularColor ) * pow( ( 1.0 - vdoth ), 5.0 );\n\treturn fresnel;\n}\n\nvec3 LightSpecular( vec3 normal, vec3 viewDir, vec3 lightDir, vec3 lightColor, float roughness, vec3 specularColor )\n{\n\tvec3 halfVec = normalize( viewDir + lightDir );\n\n\tfloat vdoth = clamp( dot( viewDir,\thalfVec\t ), 0.0, 1.0 );\n\tfloat ndoth\t= clamp( dot( normal,\thalfVec\t ), 0.0, 1.0 );\n\tfloat ndotv = clamp( dot( normal,\tviewDir  ), 0.0, 1.0 );\n\tfloat ndotl = clamp( dot( normal,\tlightDir ), 0.0, 1.0 );\n    \n   \tvec3\tf = FresnelTerm( specularColor, vdoth );\n\tfloat\td = DistributionTerm( roughness, ndoth );\n\tfloat\tv = VisibilityTerm( roughness, ndotv, ndotl );\n    \n    vec3 specular;\n\tspecular = lightColor * f * ( d * v * MATH_PI * ndotl );\n\treturn specular;\n}\n\nfloat Cylinder( vec3 p, float r, float height ) \n{\n\tfloat d = length( p.xz ) - r;\n\td = max( d, abs( p.y ) - height );\n\treturn d;\n}\n\nfloat Sphere( vec3 p, float s )\n{\n\treturn length( p ) - s;\n}\n\nfloat Box( vec3 p, vec3 b )\n{\n\tvec3 d = abs( p ) - b;\n\treturn min( max( d.x, max( d.y, d.z ) ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\nfloat Substract( float a, float b )\n{\n    return max( a, -b );\n}\n\nfloat SubstractRound( float a, float b, float r ) \n{\n\tvec2 u = max( vec2( r + a, r - b ), vec2( 0.0, 0.0 ) );\n\treturn min( -r, max( a, -b ) ) + length( u );\n}\n\nfloat Union( float a, float b )\n{\n    return min( a, b );\n}\n\nfloat UnionRound( float a, float b, float k )\n{\n    float h = clamp( 0.5 + 0.5 * ( b - a ) \/ k, 0.0, 1.0 );\n    return mix( b, a, h ) - k * h * ( 1.0 - h );\n}\n\nfloat TriPrism( vec3 p, vec3 h )\n{        \n    vec3 q = abs( p );\n    return max( q.y - h.y, max( q.z * 0.866025 + p.x * h.z, -p.x ) - h.x * 0.5 );\n}\n\nfloat Scene( vec3 p, mat3 localToWorld )\n{\n    p = p * localToWorld;\n    \n    \/\/ ring\n    float a = Cylinder( p, 1.0, 0.1 );\n    float b = Cylinder( p + vec3( 0.12, 0.0, 0.0 ), 0.9, 0.2 ); \n    float ring = Substract( a, b );\n    \n    \/\/ nail\n    float c = Box( p + vec3( -0.8, 0.0, 0.0 ), vec3( 0.4, 0.1, 0.1 ) );\n    float d = Box( p + vec3( -0.4, 0.0, 0.0 ), vec3( 0.02, 0.1, 0.25 ) );\n    float e = TriPrism( p + vec3( -1.274, 0.0, 0.0 ), vec3( 0.149, 0.1, 0.16 ) );\n    float nail = Union( UnionRound( c, d, 0.1 ), e );\n    \n    \/\/ dents\n    float f = TriPrism( p + vec3( +0.08, 0.0, -0.85 ), vec3( 0.1, 0.2, 0.5 ) );\n    float g = TriPrism( p + vec3( -0.45, 0.0, -0.4 ), vec3( 0.1, 0.2, 0.16 ) );\n    float h = TriPrism( p + vec3( -0.8, 0.0, -0.65 ), vec3( 0.08, 0.2, 0.16 ) );\n    float i = TriPrism( p + vec3( -0.9, 0.0, 0.3 ), vec3( 0.04, 0.2, 0.16 ) );\n    float j = TriPrism( p + vec3( +0.3, 0.0, 0.68 ), vec3( 0.28, 0.2, 0.16 ) );\n    float k = TriPrism( p + vec3( -0.45, 0.0, -0.94 ), vec3( 0.07, 0.2, 0.5 ) );\n    float l = TriPrism( p + vec3( 0.0, 0.0, 1.06 ), vec3( 0.1, 0.2, 0.5 ) );\n\n    float dents = Union( Union( Union( Union( Union( Union( f, g ), h ), i ), j ), k ), l );\n    ring = SubstractRound( ring, dents, 0.03 );\n    \n    float ret = Union( ring, nail );\n\treturn ret;\n}\n\nfloat CastRay( in vec3 ro, in vec3 rd, mat3 localToWorld )\n{\n    const float maxd = 5.0;\n    \n\tfloat h = 0.5;\n    float t = 0.0;\n   \n    for ( int i = 0; i < 50; ++i )\n    {\n        if ( h < 0.001 || t > maxd ) \n        {\n            break;\n        }\n        \n\t    h = Scene( ro + rd * t, localToWorld );\n        t += h;\n    }\n\n    if ( t > maxd )\n    {\n        t = -1.0;\n    }\n\t\n    return t;\n}\n\nvec3 SceneNormal( in vec3 pos, mat3 localToWorld )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    Scene( pos + eps.xyy, localToWorld ) - Scene( pos - eps.xyy, localToWorld ),\n\t    Scene( pos + eps.yxy, localToWorld ) - Scene( pos - eps.yxy, localToWorld ),\n\t    Scene( pos + eps.yyx, localToWorld ) - Scene( pos - eps.yyx, localToWorld ) );\n\treturn normalize( -nor );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy \/ iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n\tp.x *= iResolution.x \/ iResolution.y;\n\n\tvec3 rayOrigin \t= vec3( 0.0, -0.28, -3.5 );\n    vec3 rayDir \t= normalize( vec3( p.x, p.y, 2.0 ) );\n    \n    float theta = -0.5 * MATH_PI;\n    mat3 rotX = mat3(\n        vec3( cos( theta ), sin( theta ), 0.0 ),\n        vec3( -sin( theta ), cos( theta ), 0.0 ),\n\t\tvec3( 0.0, 0.0, 1.0 )\n        );    \n    \n    vec2 mo = iMouse.xy \/ iResolution.xy;    \n    float phi = 0.25 * MATH_PI + 2.0 * iTime + 10.0 * mo.x;    \n    mat3 rotY = mat3(\n        vec3( 1.0, 0.0, 0.0 ),\n        vec3( 0.0, cos( phi ), sin( phi ) ),\n        vec3( 0.0, -sin( phi ), cos( phi ) )\n        );\n    \n    mat3 localToWorld = rotX * rotY;    \n\n\n\tvec3 color = texture( iChannel0, q ).yyy * 0.3;\n    \n\tfloat t = CastRay( rayOrigin, rayDir, localToWorld );\n    if ( t > 0.0 )\n    {\n        vec3 pos = rayOrigin + t * rayDir;\n        vec3 normal = SceneNormal( pos, localToWorld );\n        vec3 lightDir = normalize( vec3( 0.5, 0.3, 1.0 ) );\n        vec3 lightColor = vec3( 1.6 );\n        \n        vec3 posLS = pos * localToWorld;\n        vec3 nrmLS = normal * localToWorld;\n        vec2 uvX = posLS.yz;\n        vec2 uvY = posLS.xz;\n        vec2 uvZ = posLS.xy;\n        \n        vec3 textureX = texture( iChannel0, uvX ).xyz;\n        vec3 textureY = texture( iChannel0, uvY ).xyz;\n        vec3 textureZ = texture( iChannel0, uvZ ).xyz;\n        \n        vec3 weights = max( abs( nrmLS ), 0.00001 );\n\t\tweights \/= weights.x + weights.y + weights.z;\n        \n        vec3 texture = textureX * weights.x + textureY * weights.y + textureZ * weights.z;\n        \n        float rustMask = clamp( texture.x * 3.0 - 0.5, 0.0, 1.0 );\n                \n        vec3 diffuseColor = mix( vec3( 0.0 ), texture, rustMask );\n        diffuseColor *= diffuseColor * vec3( 0.94, 0.72, 0.47 ) * 1.5;\n        vec3 specularColor = mix( texture, vec3( 0.04 ), rustMask );\n        float roughness = mix( 0.2, 0.6, rustMask );\n        \n        vec3 diffuse = lightColor * clamp( dot( normal, lightDir ), 0.0, 1.0 );\n        color = diffuseColor * ( diffuse + 0.2 );\n        color += LightSpecular( normal, rayDir, lightDir, lightColor, roughness, specularColor );\n    }\n    \n    fragColor = vec4( color, 1.0 );\n}\n\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"MljXzz","date":"1470073761","viewed":8045,"name":"Isometric City 2.5D","username":"knarkowicz","description":"No raymarching, raytraycing or rasterization was harmed in the making of this Shadertoy","likes":150,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"\/media\/a\/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"\/media\/ap\/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define RGB( r, g, b ) vec3( float( r ) \/ 255.0, float( g ) \/ 255.0, float( b ) \/ 255.0 )\nconst vec3 RGB_WATER\t\t= RGB( 52, 166, 202 );\nconst vec3 RGB_BUILDING \t= RGB( 219, 180, 144 );\nconst vec3 RGB_RIGHT_WALL\t= RGB_BUILDING * 1.1;\nconst vec3 RGB_LEFT_WALL\t= RGB_BUILDING * 0.7;\nconst vec3 RGB_WINDOWS \t\t= RGB( 90, 100, 180 );\nconst vec3 RGB_ROAD \t\t= RGB( 110, 125, 120 ) * 0.7;\nconst vec3 RGB_LANE \t\t= RGB( 255, 255, 255 ) * 0.8;\nconst vec3 RGB_GRASS\t\t= RGB( 129, 164, 66 );\nconst vec3 RGB_TREE_LEAVES\t= RGB( 129, 164, 66 ) * 0.6;\nconst vec3 RGB_TREE_TRUNK\t= RGB( 80, 42, 42 );\nconst float TILE_WATER\t\t= 0.0;\nconst float TILE_GRASS\t\t= 1.0;\nconst float TILE_ISLAND\t\t= 2.0;\nconst float TILE_ROAD_X\t\t= 3.0;\nconst float TILE_ROAD_Y\t\t= 4.0;\nconst float TILE_ROAD_XY\t= 5.0;\nconst float ISO_TILE\t\t= 13.0 * 8.0;\nconst float LARGE_FLOAT\t\t= 1e8;\n\nvoid DrawBuilding( inout vec3 color, inout float zbuffer, vec2 tile, vec2 pixel, vec2 buildingTile, float h )\n{\n    float depth = buildingTile.x + buildingTile.y;\n    if ( depth > zbuffer )\n    {\n        return;\n    }    \n    \n    buildingTile.x += h;\n    buildingTile.y += h;    \n    \n    pixel.y -= ISO_TILE * 0.25;\n    vec2 iso = vec2( ( pixel.x + 2.0 * pixel.y ) \/ ISO_TILE, ( pixel.x - 2.0 * pixel.y ) \/ -ISO_TILE );\n    tile = floor( iso );\n    vec2 off = iso - tile;\n    \n\t\/\/ roof\n    if ( tile.x == buildingTile.x && tile.y == buildingTile.y && off.x > 0.2 && off.y > 0.2 && off.x < 0.98 && off.y < 0.98 )\n    {\n        zbuffer = depth;\n        color = RGB_BUILDING;\n\n        if ( off.x < 0.28 || off.y < 0.28 || off.x > 1.0 - 0.08 || off.y > 1.0 - 0.08 )\n        {\n            color *= 1.2;\n        }\n    }\n    \n    float px = ( buildingTile.x - buildingTile.y ) * ISO_TILE * 0.5;\n    \n    \/\/ right wall\n    if ( pixel.x >= px && pixel.x < px + 0.39 * ISO_TILE && iso.y < buildingTile.y + 0.20 && iso.y > buildingTile.y - h - 0.4 )\n    {\n\t\tzbuffer = depth;\n\t\tcolor = RGB_RIGHT_WALL;\n        \n\t\tif ( mod( iso.y + 0.2, 0.5 ) < 0.25 )\n\t\t{\n\t\t\tcolor *= RGB_WINDOWS;\n\t\t\tcolor *= mod( pixel.x, 16.0 ) < 8.0 ? 1.0 : 0.8;\n\t\t}\n    }\n    \n    \/\/ left wall\n    if ( pixel.x >= px - 0.39 * ISO_TILE && pixel.x < px && iso.x < buildingTile.x + 0.20 && iso.x > buildingTile.x - h - 0.4 )\n    {\n        zbuffer = depth;        \n\t\tcolor = RGB_LEFT_WALL;        \n        \n\t\tif ( mod( iso.x + 0.2, 0.5 ) < 0.25 )\n\t\t{\n\t\t\tcolor *= RGB_WINDOWS;\n\t\t\tcolor *= mod( pixel.x, 16.0 ) < 8.0 ? 1.0 : 0.8;\n\t\t}\n    }\n}\n\nvoid DrawTree( inout vec3 color, inout float zbuffer, vec2 tile, vec2 pixel, vec2 treeTile )\n{        \n    float depth = treeTile.x + treeTile.y;\n    if ( depth > zbuffer )\n    {\n        return;\n    }\n    \n    pixel.y -= ISO_TILE * 0.25;\n    vec2 iso = vec2( ( pixel.x + 2.0 * pixel.y ) \/ ISO_TILE, ( pixel.x - 2.0 * pixel.y ) \/ -ISO_TILE );\n    tile = floor( iso );\n    vec2 off = iso - tile;\n    \n    float px = ( treeTile.x - treeTile.y ) * ISO_TILE * 0.5;\n    \n    \/\/ top leaves\n    if ( iso.x > treeTile.x + 0.2 && iso.y > treeTile.y + 0.2 && iso.x < treeTile.x + 0.45 && iso.y < treeTile.y + 0.45 )\n    {\n\t\tzbuffer = depth;\n\t\tcolor = RGB_TREE_LEAVES * 1.0;\n    }\n    \n\t\/\/ left leaves\n    if ( pixel.x >= px - 0.125 * ISO_TILE && pixel.x < px && iso.x > treeTile.x - 0.1 && iso.x < treeTile.x + 0.2 && iso.x > treeTile.x - 0.1 )\n    {\n\t\tzbuffer = depth;\n\t\tcolor = RGB_TREE_LEAVES * 0.8;\n    }\n    \n\t\/\/ right leaves\n    if ( pixel.x >= px && pixel.x < px + 0.125 * ISO_TILE && iso.y < treeTile.y + 0.2 && iso.y > treeTile.y - 0.1 )\n    {\n\t\tzbuffer = depth;\n\t\tcolor = RGB_TREE_LEAVES * 1.2;\n    }    \n    \n    \/\/ left trunk\n    if ( pixel.x >= px - 0.039 * ISO_TILE && pixel.x < px && iso.x <= treeTile.x - 0.1 && iso.x > treeTile.x - 0.4 )\n    {\n        zbuffer = depth;        \n\t\tcolor = RGB_TREE_TRUNK * 0.8;\n    }    \n    \n    \/\/ right trunk\n    if ( pixel.x >= px && pixel.x < px + 0.039 * ISO_TILE && iso.y <= treeTile.y - 0.1 && iso.y > treeTile.y - 0.4 )\n    {\n\t\tzbuffer = depth;\n\t\tcolor = RGB_TREE_TRUNK * 1.1;\n    }\n}\n\nfloat TileID( vec2 tile )\n{\n    float id = TILE_WATER;\n    vec4 tex = texture( iChannel0, tile \/ ( iChannelResolution[ 0 ].xy * 4.0 ) );\n    id = tex.y > 0.5 ? TILE_WATER \t: TILE_GRASS;\n    id = tex.y > 0.9 ? TILE_ISLAND \t: id;\n    \n    if ( id == TILE_GRASS && mod( tile.x + 1.0, 4.0 ) == 0.0 )\n    {\n        id = TILE_ROAD_X;\n    }\n    \n    if ( mod( tile.y + 1.0, 4.0 ) == 0.0 )\n    {\n        if ( id == TILE_GRASS ) \n        {\n        \tid = TILE_ROAD_Y;\n    \t}\n        \n        if ( id == TILE_ROAD_X ) \n        {\n        \tid = TILE_ROAD_XY;\n    \t}        \n    }\n    \n    return id;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float resMult      \t= floor( max( iResolution.x, iResolution.y ) \/ 800.0 );\n    float resRcp        = 1.0 \/ max( resMult, 1.0 );\n    \/\/float cameraOffset\t= floor( iTime * 60.0 + 0.5 );\n    float cameraOffset\t= float( iFrame );\n    vec2 pixel \t\t\t= fragCoord * resRcp + cameraOffset - iMouse.xy + vec2( -2000, -2000.0 );\n    \n    vec2 iso\t\t= vec2( ( pixel.x + 2.0 * pixel.y ) \/ ISO_TILE, ( pixel.x - 2.0 * pixel.y ) \/ -ISO_TILE );\n    vec2 waterIso\t= vec2( ( pixel.x + 2.0 * pixel.y + 0.15625 * ISO_TILE ) \/ ISO_TILE, ( pixel.x - 2.0 * pixel.y - 0.15625 * ISO_TILE ) \/ -ISO_TILE );\n    vec2 isoR\t\t= vec2( ( pixel.x + 2.0 * pixel.y - ISO_TILE * 0.5 ) \/ ISO_TILE, ( pixel.x - 2.0 * pixel.y + ISO_TILE * 0.5 ) \/ -ISO_TILE );\n    vec2 tile\t\t= floor( iso );\n    vec2 tileR\t\t= floor( isoR );\n    vec2 waterTile\t= floor( waterIso );\n    vec2 off\t\t= iso - tile;\n    vec2 offR \t\t= isoR - tileR;\n    vec2 waterOff  \t= waterIso - waterTile;\n    \n    vec2 buildingTile0 \t= 2.0 * floor( tile \/ 2.0 );\n    vec2 buildingTile1 \t= 3.0 * floor( tile \/ 3.0 );\n    vec2 buildingTile2 \t= 4.0 * floor( tile \/ 4.0 );\n    vec2 buildingTile3 \t= 5.0 * floor( tile \/ 5.0 );\n\n    float tileId\t= TileID( tile );\n    float tileLId\t= TileID( vec2( tile.x - 1.0, tile.y ) );\n    float tileRId\t= TileID( vec2( tile.x + 1.0, tile.y ) );\n    float tileTId\t= TileID( vec2( tile.x, tile.y - 1.0 ) );\n    float tileBId\t= TileID( vec2( tile.x, tile.y + 1.0 ) );\n    float tileB0Id\t= TileID( buildingTile0 );\n    float tileB1Id\t= TileID( buildingTile1 );\n    float tileB2Id\t= TileID( buildingTile2 );\n    float tileB3Id\t= TileID( buildingTile3 );\n  \n    \/\/ water\n    vec3 waterTexNoise = texture( iChannel0, waterTile \/  iChannelResolution[ 0 ].xy + fract( iTime * 0.005 ) ).xyz;    \n    vec3 color = RGB_WATER * mix( 0.8, 1.1, waterTexNoise.z );\n\n    float waterTileId\t= TileID( waterTile );\n    float waterTileLId\t= TileID( vec2( waterTile.x - 1.0, waterTile.y ) );\n    float waterTileRId\t= TileID( vec2( waterTile.x + 1.0, waterTile.y ) );\n    float waterTileTId\t= TileID( vec2( waterTile.x, waterTile.y - 1.0 ) );\n    float waterTileBId\t= TileID( vec2( waterTile.x, waterTile.y + 1.0 ) );\n    float waterTileLTId\t= TileID( vec2( waterTile.x - 1.0, waterTile.y - 1.0 ) );\n    float waterTileLBId\t= TileID( vec2( waterTile.x - 1.0, waterTile.y + 1.0 ) );\n    float waterTileRTId\t= TileID( vec2( waterTile.x + 1.0, waterTile.y - 1.0 ) );\n    float waterTileRBId\t= TileID( vec2( waterTile.x + 1.0, waterTile.y + 1.0 ) );    \n    \n    \/\/ water shore shadow\n    if ( waterTileId == TILE_WATER )\n    {\n        if ( ( waterTileLId != TILE_WATER && waterOff.x < 8.0 \/ 32.0 ) \n            || ( waterTileRId != TILE_WATER && waterOff.x > 24.0 \/ 32.0 )\n            || ( waterTileTId != TILE_WATER && waterOff.y < 8.0 \/ 32.0 )\n            || ( waterTileBId != TILE_WATER && waterOff.y > 24.0 \/ 32.0 )\n            || ( waterTileLTId != TILE_WATER && waterOff.x < 8.0 \/ 32.0 && waterOff.y < 8.0 \/ 32.0 )\n            || ( waterTileLBId != TILE_WATER && waterOff.x < 8.0 \/ 32.0 && waterOff.y > 24.0 \/ 32.0 )\n            || ( waterTileRTId != TILE_WATER && waterOff.x > 24.0 \/ 32.0 && waterOff.y < 8.0 \/ 32.0 )\n            || ( waterTileRBId != TILE_WATER && waterOff.x > 24.0 \/ 32.0 && waterOff.y > 24.0 \/ 32.0 )            \n           )\n        {\n            color *= vec3( 0.8 );\n        }\n    }\n    \n    \/\/ shores\n    float waterPX = ( waterTile.x - waterTile.y ) * ISO_TILE * 0.5;\n    if ( ( waterTileId != TILE_WATER && pixel.x <= waterPX && waterTileLId == TILE_WATER ) \n        || ( waterTileTId != TILE_WATER && pixel.x > waterPX && waterOff.x < 5.0 \/ 32.0 ) )\n    {\n\t\tcolor = RGB_GRASS * 0.7;\n\t}\n    if ( ( waterTileId != TILE_WATER && pixel.x > waterPX && waterTileTId == TILE_WATER ) \n        || ( waterTileLId != TILE_WATER && pixel.x <= waterPX && waterOff.x < 5.0 \/ 32.0 ) )\n    {\n\t\tcolor = RGB_GRASS * 0.9;\n\t}    \n        \n    \/\/ grass and road\n    if ( tileId != TILE_WATER )\n    {\n    \tcolor = RGB_GRASS;\n    }\n    \n    float roadWidth = 0.3;\n\tfloat laneWidth = 0.03;\n    if ( ( ( tileId == TILE_ROAD_X || tileId == TILE_ROAD_XY ) && abs( 0.5 - off.x ) < roadWidth ) \n        && ( tileTId != TILE_WATER || tileBId != TILE_WATER ) \n        && ( tileTId != TILE_WATER || off.y >= 0.20 )\n       \t&& ( tileBId != TILE_WATER || off.y <= 0.80 )\n       )\n    {\n\t\tcolor = RGB_ROAD;\n\t\tif ( abs( 0.5 - off.x ) < laneWidth && mod( off.y, 0.5 ) < 0.2 && tileId != TILE_ROAD_XY )\n\t\t{\n\t\t\tcolor = RGB_LANE;\n\t\t}\n    }\n\tif ( ( tileId == TILE_ROAD_Y || tileId == TILE_ROAD_XY ) && abs( 0.5 - off.y ) < roadWidth \n        && ( tileLId != TILE_WATER || tileRId != TILE_WATER )\n        && ( tileLId != TILE_WATER || off.x >= 0.20 ) \n        && ( tileRId != TILE_WATER || off.x <= 0.80 ) )\n    {\n\t\tcolor = RGB_ROAD;\n        if ( abs( 0.5 - off.y ) < laneWidth && mod( off.x, 0.5 ) < 0.2 && tileId != TILE_ROAD_XY )\n        {\n        \tcolor = RGB_LANE;\n\t\t}\n    }\n    \n    if ( tileId == TILE_GRASS && (\n\t\t\t( buildingTile0.x == tile.x && buildingTile0.y == tile.y ) \n        || \t( buildingTile1.x == tile.x && buildingTile1.y == tile.y ) \n        || \t( buildingTile2.x == tile.x && buildingTile2.y == tile.y ) \n        || \t( buildingTile3.x == tile.x && buildingTile3.y == tile.y ) ) )\n    {\n        \/\/ building AO\n        vec2 offAO = 7.0 * clamp( ( abs( 0.5 - off ) - 0.35 ), 0.0, 1.0 );\n        color *= clamp( max( offAO.x, offAO.y ), 0.0, 1.0 );\n    }\n    else if ( tileId == TILE_GRASS || tileId == TILE_ISLAND )\n    {\n        \/\/ tree AO\n\t\tcolor *= clamp( max( 8.0 * abs( 0.15 - off.x ), 8.0 * abs( 0.15 - off.y ) ), 0.0, 1.0 );        \n    }\n\n    float zbuffer = LARGE_FLOAT;\n    if ( tileB0Id == TILE_GRASS )\n    {\n    \tDrawBuilding( color, zbuffer, tile, pixel, buildingTile0, 0.0 );\n    }\n\n    if ( tileB1Id == TILE_GRASS )\n    {\n    \tDrawBuilding( color, zbuffer, tile, pixel, buildingTile1, 1.0 );\n    }\n    \n    if ( tileB2Id == TILE_GRASS )    \n    {           \n    \tDrawBuilding( color, zbuffer, tile, pixel, buildingTile2, 2.0 );\n    }\n    \n    if ( tileB3Id == TILE_GRASS )\n    {\n    \tDrawBuilding( color, zbuffer, tile, pixel, buildingTile3, 3.0 );\n    }\n    \n    if ( ( tileId == TILE_GRASS || tileId == TILE_ISLAND ) && zbuffer >= LARGE_FLOAT )\n    {    \n        DrawTree( color, zbuffer, tile, pixel, tile );\n    }\n    \n    fragColor = vec4( sqrt( color ), 1.0 );  \n}","name":"Image","description":"","type":"image"}]}];var gFollow = -1;
    var gUseScreenshots = piIsMobile();
    var gThemeName = "classic";
    </script>

</head>

<body onload="resultsInitStatic(8,null,null)">

<!-- header =================================================================================== -->


<div id="header">

    <div id="headerBlock1">
        <a href="/" id="headerTitle">Shadertoy</a>
        <form name="formSearch" action="/results" method="get" style="display:inline-block;">
        <div  id="headerSearch">
            <input type="search" id="mySearch" name="query" placeholder="Search..." value=""/>
        </div>
        </form>
    </div>

    <div id="headerBlock2">
            <a class="headerLinks" href="/browse">Browse</a>
        <a class="headerLinks" href="/new">New</a>
        <a class="headerLinks" href="/signin">Sign In</a>
        </div>
</div>
<!-- content ================================================================================== -->

<div id="content">

    
    <script>
    function follow()
    {
        if (gFollow < 0) return;
        try
        {
            var req = new XMLHttpRequest();
            req.onload = function()
            {
                var jsn = req.response;
                if( jsn==null ) return;
                let btnFollow = document.getElementById( "btnFollow");
                if (gFollow == 1) {
                    gFollow = 0;
                    btnFollow.value="Follow";
                } else if (gFollow == 0) {
                    gFollow = 1;
                    btnFollow.value="Unfollow";
                }
            }
            req.open( "POST", "/shadertoy", true );
            req.responseType = "json";
            req.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
            if (gFollow == 1) {
                var str = "fu=1&uid=knarkowicz";
            } else if (gFollow == 0) {
                var str = "fs=1&uid=knarkowicz";
            }
            req.send( str );
        }
        catch(e)
        {
            alert( "exception: " + e );
        }
    }
    </script>

    <!-- ---------------------------------- --> 

    <div id="divUser">
        <table style="border:0px;border-spacing:0px;border-collapse:collapse;"><tr>
        <td style="vertical-align:top;">
        <img id="userPicture" src="/media/users/knarkowicz/profile.jpeg"></img>        </td>
        <td style="vertical-align:top;padding-left:16px;">
        <b>Name</b>: knarkowicz <br/><b>Joined</b>: July 17, 2015 <br/> <br/><b>Shaders</b>: 23<br/><b>Playlists</b>: 0<br/><b>Comments</b>: 208<br/> <br/><b>Following</b>: 0<br/><b>Followers</b>: 62<br/>        </td>
        <td style="vertical-align:top;padding-left:32px;">
        <b>About</b><br><br>Krzysztof Narkowicz @knarkowicz        </td>
        <td style="vertical-align:top;padding-left:32px;">
                    </td>
        </tr></table>
    </div>

<!-- --------------------------- -->

  <div id="controls">

    <div>
      <div style="text-align: center; vertical-align: middle; display: inline-block; padding-bottom:5px; padding-top:4px; margin-right:8px; margin-bottom:8px; margin-top:8px;">
      Sort:      </div>
      <div class="controlOptions"><div class="pageButtonsCurrent" href="/user/knarkowicz/sort=popular">Popular</div><a class="pageButtons" href="/user/knarkowicz/sort=newest">Newest</a><a class="pageButtons" href="/user/knarkowicz/sort=love">Love</a></div>
    </div>

    <div id="controlFilter">
      <div style="display:flex;margin-right:8px;align-items:center;">Filter:</div>
      <div class="controlOptions"> <a class="pageButtons" href="/user/knarkowicz&sort=popular&filter=multipass">Multipass</a><a class="pageButtons" href="/user/knarkowicz&sort=popular&filter=soundoutput">GPU Sound</a><a class="pageButtons" href="/user/knarkowicz&sort=popular&filter=vr">VR</a><a class="pageButtons" href="/user/knarkowicz&sort=popular&filter=soundinput">Microphone</a><a class="pageButtons" href="/user/knarkowicz&sort=popular&filter=musicstream">Soundcloud</a><a class="pageButtons" href="/user/knarkowicz&sort=popular&filter=webcam">Webcam</a></div>
    </div>

    <div>
        <div style="text-align: center; vertical-align: middle; display: inline-block; padding-bottom:5px; padding-top:4px; margin-right:8px; margin-bottom:8px; margin-top:8px;">
        Results (23):        </div>

        <div class="controlOptions">
              <div id="pageButton"0 class="pageButtonsCurrent" href="/user/knarkowicz/sort=popular&from=0&num=8">1</div><a id="pageButton"1 class="pageButtons" href="/user/knarkowicz/sort=popular&from=8&num=8">2</a><a id="pageButton"2 class="pageButtons" href="/user/knarkowicz/sort=popular&from=16&num=8">3</a>        </div>
    </div>
  </div>


  <div id="shaderGrid">
    <div class='searchResult'><div class='searchResultContainer' id='Preview_0_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_0_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_0_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_0_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_0_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_0_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_0_Thumnail'>        <img class='previewThumbnailImage' id='Preview_0_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_0_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_0_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_0_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_0_Info'>  <span class='previewText'  id='Preview_0_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_0_TextUser'></span>  <span class='previewStats' id='Preview_0_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_1_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_1_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_1_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_1_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_1_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_1_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_1_Thumnail'>        <img class='previewThumbnailImage' id='Preview_1_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_1_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_1_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_1_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_1_Info'>  <span class='previewText'  id='Preview_1_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_1_TextUser'></span>  <span class='previewStats' id='Preview_1_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_2_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_2_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_2_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_2_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_2_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_2_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_2_Thumnail'>        <img class='previewThumbnailImage' id='Preview_2_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_2_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_2_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_2_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_2_Info'>  <span class='previewText'  id='Preview_2_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_2_TextUser'></span>  <span class='previewStats' id='Preview_2_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_3_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_3_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_3_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_3_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_3_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_3_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_3_Thumnail'>        <img class='previewThumbnailImage' id='Preview_3_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_3_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_3_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_3_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_3_Info'>  <span class='previewText'  id='Preview_3_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_3_TextUser'></span>  <span class='previewStats' id='Preview_3_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_4_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_4_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_4_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_4_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_4_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_4_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_4_Thumnail'>        <img class='previewThumbnailImage' id='Preview_4_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_4_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_4_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_4_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_4_Info'>  <span class='previewText'  id='Preview_4_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_4_TextUser'></span>  <span class='previewStats' id='Preview_4_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_5_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_5_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_5_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_5_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_5_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_5_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_5_Thumnail'>        <img class='previewThumbnailImage' id='Preview_5_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_5_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_5_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_5_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_5_Info'>  <span class='previewText'  id='Preview_5_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_5_TextUser'></span>  <span class='previewStats' id='Preview_5_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_6_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_6_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_6_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_6_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_6_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_6_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_6_Thumnail'>        <img class='previewThumbnailImage' id='Preview_6_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_6_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_6_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_6_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_6_Info'>  <span class='previewText'  id='Preview_6_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_6_TextUser'></span>  <span class='previewStats' id='Preview_6_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_7_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_7_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_7_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_7_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_7_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_7_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_7_Thumnail'>        <img class='previewThumbnailImage' id='Preview_7_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_7_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_7_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_7_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_7_Info'>  <span class='previewText'  id='Preview_7_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_7_TextUser'></span>  <span class='previewStats' id='Preview_7_Stats'></span></div></div>  </div>
</div>

<!-- footer ================================================================================== -->

<div id="footer">
    
    <div><span style="color:#ffffff;">Community Forums</span>
      <ul>
      <li><a class="regular" href="/events">Official Events</a></li>
      <li><a class="regular" href="https://www.facebook.com/groups/147749602472741">In Facebook (english)</a></li>
      <li><a class="regular" href="https://www.facebook.com/groups/1339783682699494">In Facebook (korean)</a></li>
      <li><a class="regular" href="https://discord.gg/XtmMN6E">In Discord</a> (<a class="regular" href="https://discordapp.com/channels/578696555612209173/579531723348639754">direct link</a>)</li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Feedback and Support</span>
      <ul>
      <li><a class="regular" href="https://www.facebook.com/Shadertoy">Facebook</a></li>
      <li><a class="regular" href="https://twitter.com/shadertoy">Twitter</a></li>
      <li><a class="regular" href="https://www.patreon.com/shadertoy">Patreon</a></li>
      <li><a class="regular" href="https://trello.com/b/5hM0CjId">Roadmap</a></li>

      
      </ul>
    </div>

    <div><span style="color:#ffffff;">Shadertoy</span>
      <ul>
      <li><a class="regular" href="/store">Store</a></li>
      <li><a class="regular" href="/howto">Documentation</a></li>
      <li><a class="regular" href="/terms">Terms & Privacy</a></li>
      <li><a class="regular" href="/about">About</a></li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Apps and Plugins</span>
      <ul>
      <li><a class="regular" href="https://itunes.apple.com/us/app/shadertoy/id717961814">Official iPhone App</a> by <a class="user" href="/user/reinder">Reinder</a></li>
      <li><a class="regular" href="https://steamcommunity.com/sharedfiles/filedetails/?id=1726697188">Screensaver</a> by <a class="user" href="/user/kosro">Kosro</a></li>
      <li><a class="regular" href="https://chrome.google.com/webstore/detail/shadertoy-unofficial-plug/ohicbclhdmkhoabobgppffepcopomhgl">Shadertoy plugin</a> by <a class="user" href="/user/patu">Patu</a></li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Tutorials</span>
      <ul>
      <li><a class="regular" href="https://www.youtube.com/watch?v=0ifChJ0nJfM">Shader coding intro</a> by <a class="user" href="/user/iq">iq</a></li>
      <li><a class="regular" href="https://shadertoyunofficial.wordpress.com/">Shadertoy Unofficial</a> by <a class="user" href="/user/FabriceNeyret2">FabriceNeyret2</a></li>
      </ul>
    </div>

</div>

<div id="compliance" style="padding-bottom:6px;visibility:hidden;left:0;top:0px;width:100%;background-color:rgb(200,120,20,0.93);position:absolute;color:#FFFFFF">
    <div style="text-align: center; margin-top:8px">
        We use cookies to give you the best experience on our website. If you continue using Shadertoy, we'll assume that you are happy to receive all cookies on this website. 
        For more information, please review our <a class="regular" href="/terms">Terms & Privacy</a>.
    </div> 
    <div style="text-align: center;margin-top:6px">
        <button type="button" style="width:100px;font-size:inherit" onclick="acceptCompliance()">Accept</button>
    </div>
</div>

<script>
(function runCompliance() 
{
    let showCompliance = 1;
    let allcookies = document.cookie;
    let cookiearray = allcookies.split(';');
    for (var i=0; i<cookiearray.length; i++)
    {
        let name  = cookiearray[i].split('=')[0];
        let value = cookiearray[i].split('=')[1];
        if (name.trim() == "scmp") 
        {
            showCompliance = value;
            break;
        }
    }

    if (showCompliance === 1) 
    {
        var ve = document.getElementById("compliance");
        ve.style.visibility="visible";
    }
})();

function acceptCompliance()
{
    let now = new Date();
    now.setTime( now.getTime() + (5*365*24*60*60*1000) );
    document.cookie="scmp=0;expires=" + now.toUTCString() + ";";

    var ve = document.getElementById("compliance");
    ve.style.visibility="hidden";
}
</script>

<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-44068895-1', 'shadertoy.com');
    ga('send', 'pageview');
</script>
</body>
</html>
