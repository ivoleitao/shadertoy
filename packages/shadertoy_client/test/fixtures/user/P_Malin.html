<!DOCTYPE HTML>
<html lang="en">
<head>
    
<title>P_Malin - Shadertoy BETA</title>
<meta charset="utf-8" />
<meta name="Keywords" content="shadertoy, shader toy, quilez, inigo, jeremias, pol, fractals, demoscene, computer graphics, mathematics, rendering, demo, 3D, realtime, shader, raytracing, raymarching, webgl, glsl" />
<meta name="Description" content="Build shaders, share them, and learn from the best community." />
<meta name="Author" content="Beautypi" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<link rel="image_src" href="https://www.shadertoy.com/img/logo.png" />
<link rel="apple-touch-icon" href="/img/launch_icon_57.png"/>
<link rel="apple-touch-icon" sizes="72x72" href="/img/launch_icon_72.png"/>
<link rel="apple-touch-icon" sizes="114x114" href="/img/launch_icon_114.png"/>
<link rel="shortcut icon" href="/img/favicon.ico"/>

<style>::-webkit-scrollbar {
    height: 8px;
    width: 8px;
    background: #404040;
}

::-webkit-scrollbar-thumb
{
    background: #909090;
    border-radius: 0ex;
}

::-webkit-scrollbar-corner
{
    background: #000;
}

::-webkit-input-placeholder
{
	font-style:italic;
}
input:-moz-placeholder, textarea:-moz-placeholder
{
	font-style:italic;
}
input.placeholder-text, textarea.placeholder-text
{
	font-style:italic;
}

pre 
{
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
    white-space: -pre-wrap;
    white-space: -o-pre-wrap;
    word-wrap: break-word;
}

@font-face
{
    font-family: Lobster;
    src: url("/img/lobster.otf") format("opentype");
}

div#centerScreen
{
    left: 50%;
    top: 50%;
    position: absolute;
}

a.headerLinks:hover
{
    background-color:#505050;
    color : #ff8020;
}

body
{
    color: #000000;
    font-size:12px;
    font-style:normal;
    font-family:Tahoma,Arial;
    background-repeat: no-repeat;
    //background-attachment: fixed;
    padding:0px;
    margin:0px;
    text-align: left;
    background-color: #d0d0d0;
    background-repeat: repeat;
    user-select: text;
}

a,
a:hover,
a:visited
{
  color : inherit;
}

div#content {
    width: 95%;
    overflow: hidden;
    margin: auto;
    padding: 0px;
    min-height: calc(100vh - 80px);
    //box-sizing: border-box;
}


.notificationCount
{
 background-color:#ff0000;
 padding-left:3px;
 padding-right:1px;
 padding-top:1px;
 padding-bottom:1px;
}

div#header
{
    background-color: #404040;
    top: 0px;
    left: 0px;
    width: 100%;
    padding: 0;
    margin: 0;
    color: #ffffff;
    display: flex;
    flex-direction:row;
}

#headerBlock1
{
    width: 50%;
    display:flex;
    align-items:center;
}

a#headerTitle
{
    font-size: 2.25em;
    font-family: Lobster,Tahoma,Arial;
    text-decoration: none;
    padding-left:32px;
    padding-right:32px;
}

#headerSearch
{
    display: inline-block;
    color: #000000;
    width: 300px;
}

input[type=search]#mySearch
{
    width: 100%;
    border-radius: 6px;
    border: 1px solid black;
    padding:12px;
}

#headerBlock2
{
    width: 50%;
    margin-left: auto;
    display: flex;
    justify-content: flex-end;
}


a#headerTitle:hover
{
    color : #ff8020;
}

a.headerLinks
{
    font-weight: bold;
    padding-top: 14px;
    padding-bottom: 14px;
    padding-left: 14px;
    padding-right: 14px;
    margin:0px;
    text-decoration: none;
    transition: background-color 0.15s linear, color 0.15s linear;
}

#footer
{
    background-color: rgba(64,64,64,0.25);
    color: #000000;
    padding: 0px;
    margin: 0px;
    width: 100%;
    display: flex;
    justify-content: space-between;
    flex-wrap: wrap;
}

#footer div
{
    padding-top:10px;
    padding-bottom:0px;
    padding-left:16px;
    padding-right:16px;
}

#footer div ul
{
    margin-left:0px;
    padding-left:16px;
}

#footer div ul li
{
    padding-top:6px;
}

a.regular
{
    font-weight:bold;
    text-decoration:none
}

a.regular:hover
{
  color : #ff8020;
}

a.user
{
    font-weight:bold;
    text-decoration:none;
}

a.user:hover
{
  color : #ff8020;
  text-decoration: underline;
}

.uiButton
{
    border: none;
    outline: none;
    margin: 0px;
    padding: 0px;
    width: 22px;
    height: 22px;
    position: absolute;
    cursor: pointer;
    border-radius: 4px;
}

.uiButton:hover
{
    box-shadow: inset 0px 0px 1px 1px #808080, 0px 0px 1px 1px #808080;
}

.uiDivBUtton
{
    cursor:pointer;
}

.uiDivBUtton:hover
{
    color: #ffffff;
}


.dialog
{
    display: block;
    background-color: #e0e0e0;
    color: #000000;
    border:1px solid #000;
    padding:0px;
    margin:0px;
    text-align:left;
    border-radius: 4px;
    box-shadow:4px 4px 6px 0px rgba(0,0,0,0.5);
    overflow: hidden;
    z-index:1000;
    visibility: hidden;
    opacity:0;
    -moz-transition: opacity 0.25s linear,visibility 0.25s linear;
    -webkit-transition: opacity 0.25s linear,visibility 0.25s linear;
    transition: opacity 0.25s linear,visibility 0.25s linear;
}

.dialogHeader
{
    left:0px;
    top: 0px;
    width:100%;
    height:32px;
    position: absolute;
    background-color: #808080;
    cursor:move;
}

.dialogTitle
{
    left: 12px;
    top: 4px;
    position: absolute;
    padding: 0px;
    margin: 0px;
    color:#000000;
    font-size:1.5em;
    text-align: left;
    user-select: none;
    -moz-user-select: -moz-none;
    -webkit-user-select: none;
}

.dialogOverlay
{
    z-index:1000;

    visibility: hidden;
    opacity:0;
    -moz-transition: opacity 0.25s linear,visibility 0.25s linear;
    -webkit-transition: opacity 0.25s linear,visibility 0.25s linear;
    transition: opacity 0.25s linear,visibility 0.25s linear;

    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    width:100%;
    height:100%;
    position:absolute;

    background-color:rgba(0,0,0,.4);
}

.viewsIcon, .likesIcon
{
    border: none;
    outline: none;
    display:inline-block;
    background-repeat:no-repeat;
    top:0px;
    left:0px;
    padding:0px;
    padding-right: 2px;
    margin:0px;
    position:relative;
}

.userPictureSmall
{
    background-color:#808080;
    border: 1px solid #000000;
    width:32px;
    height:32px;
}

.dialogCloseButton
{
    right:8px;
    top: 4px;
    width:22px;
    height:22px;
    position: absolute;
    background-image: url("/img/close.png");
    cursor: pointer;
    border-radius: 4px;
}

.dialogCloseButton:hover
{
    box-shadow: inset 0px 0px 4px 2px #ffffff, 0px 0px 4px 2px #ffffff;
}

.dialogContentButtons
{
     padding:0;
     border:0;
     text-align: justify;
     left: 24px;
     bottom:40px;
     position:absolute;
}

.dialogButton
{
    text-align: center;
    vertical-align: middle;
    display: inline-block;
    border-radius: 4px;
    font-weight: bold;
    cursor: pointer;
    padding-bottom:5px;
    padding-top:4px;
    padding-left: 8px;
    padding-right: 8px;
    margin-left:4px;
    margin-right:4px;
    text-decoration: none;
    color:#000000;
    width: 80px;
    -moz-transition:    background-color 0.15s linear, color 0.15s linear;
    -webkit-transition: background-color 0.15s linear, color 0.15s linear;
    transition:         background-color 0.15s linear, color 0.15s linear;
}

.dialogButton:hover
{
  background-color:#808080;
  color : #ff8020;
}

.dialogCloseButton:hover
{
    box-shadow: inset 0px 0px 4px 2px #ffffff, 0px 0px 4px 2px #ffffff;
}

.dialogContent
{
    color: inherit;
    overflow: auto;
    width:100%;
    height:100%;
    left: 0px;
    top: 32px;
    position:absolute
}

.dialogContentBody
{
    color: inherit;
    width:100%;
    height:auto;
    padding-top:24px;
    padding-bottom:24px;
    padding-left:24px;
    padding-right:24px;
    text-align: left;
}

.formButton
{
    font-weight:bold;
	color:#ffffff;
	border:none;
    text-align:center;
	background-color:#808080;
    border-radius: 4px;
	padding-left:8px;
	padding-right:8px;
	padding-top:4px;
	padding-bottom:4px;
    cursor:pointer;
    min-width:80px;
    box-sizing: border-box;
}
.formInput {
    border-radius: 6px;
    border: 1px solid black;
    padding: 4px;
    border: none;
}
.formButton:hover {
    background-color: #e0e0e0;
}
.formButton:disabled
{
	color:#b0b0b0;
	background-color:#808080;
}

.formButtonSmall
{
    color:#ffffff;
    border:none;
    text-align:center;
    background-color:#808080;
    border-radius: 4px;
    padding-left:2px;
    padding-right:2px;
    padding-top:2px;
    padding-bottom:2px;
    cursor:pointer;
    min-width:40px;
}

.formButtonSmall:hover
{
    background-color: #e0e0e0;
}

.formButtonSmall:disabled
{
    color:#b0b0b0;
    background-color:#808080;
}

.formButtonSmall.disabled2,
.formButton.disabled2 { color:#b0b0b0; background-color:#808080; pointer-events: none; }

.inputForm
{
    padding-left:2%;
    padding-right:2%;
    resize: none;
    text-align: left;
    background-color:#e0e0e0;
    outline: none;
    border-radius: 4px;
    border: 1px solid #808080;
    color:inherit;
    box-sizing: border-box;
}

.inputForm:focus
{
    border: 1px solid #AFCDD8;
    background-color: #EBF2F4;
}

.transparentPannel
{
    background-color:rgba(64,64,64,0.1);
    padding:16px;
}

.comment, .commentSelf, .commentNew
{
    border-radius: 4px;
    width: 100%;
    margin-left: 0px;
    margin-right: 0px;
    margin-top: 0px;
    margin-bottom: 6px;

    padding: 14px;
    box-sizing: border-box;
    display: grid;
    grid-template-columns: 32px auto 8px;
    grid-template-rows: 1fr;
    grid-gap:8px;
}

.comment:nth-child(even)
{
    background-color: rgba(64,64,64,0.1);
}

.comment:nth-child(odd)
{
    background-color: rgba(128,128,128,0.1);
}

.commentSelf
{
    background-color: rgba(240,160,64,0.1);
}

.commentNew
{
    padding-right: 0px;
    grid-template-columns: 40px auto;
}

.commentContent
{
    vertical-align: top;
    text-align: left;
    word-break: break-all;
    word-break: break-word;
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
}


/* ----------------------- media resolutions ------------------------ */

@media screen and (max-width:799px)
{
    div#header {flex-direction:column; }
    #headerBlock1 { width:100%; }
    #headerBlock2 { width:100%; justify-content: space-around;}
    div#headerSearch {width:200px;}
    input#mySearch { width:200px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .previewText { width:130px; }
    .transparentPannel { padding:10px; }
}

@media screen and (min-width:800px) and (max-width:1279px)
{
    body { font-size: 9px; }
    div#headerSearch {width: 250px;}
    input#mySearch { width:250px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .previewText { width:130px; }
    .transparentPannel { padding:11px; }
}

@media screen and (min-width:1280px) and (max-width:1439px)
{
    body { font-size: 10px; }
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:28px; }
    .previewText { width:180px; }
    .transparentPannel { padding:12px; }
}

@media screen and (min-width:1440px) and (max-width:1919px)
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:28px; }
    .previewText { width:180px; }
    .transparentPannel { padding:12px; }
}

@media screen and (min-width:1920px) and (max-width:2559px)
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:32px; }
    .previewText { width:220px; }
    .transparentPannel { padding:16px; }
}

@media screen and (min-width:2560px) 
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:32px; }
    .previewText { width:220px; }
    .transparentPannel { padding:16px; }
}
body
{
    background-image: url("/img/themes/classic/background.jpg");
}
</style>


    <script>"use strict"

//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piCamera
//
//==============================================================================

function piCamera()
{
    var mMatrix = setIdentity();
    var mMatrixInv = setIdentity();

    var mPosition = [0.0,0.0,0.0];
    var mXRotation = 0.0;
    var mYRotation = 0.0;

    var mPositionTarget = [0.0,0.0,0.0];
    var mXRotationTarget = 0.0;
    var mYRotationTarget = 0.0;

    var me = {};
/*
    me.Set = function( pos, dir, roll) 
             {
                 mMatrix    = setLookat( pos, add(pos,dir), [Math.sin(roll),Math.cos(roll),Math.sin(roll)] );
                 mMatrixInv = invertFast( mMatrix );
             };
*/
    me.SetPos = function(pos)
                {
                    mPosition = pos;
                    //mMatrix[ 3] = -(mMatrix[0] * pos[0] + mMatrix[1] * pos[1] + mMatrix[ 2] * pos[2]);
                    //mMatrix[ 7] = -(mMatrix[4] * pos[0] + mMatrix[5] * pos[1] + mMatrix[ 6] * pos[2]);
                    //mMatrix[11] = -(mMatrix[8] * pos[0] + mMatrix[9] * pos[1] + mMatrix[10] * pos[2]);
                };
/*
    me.GlobalMove = function(pos)
                    {
                        mMatrix[ 3] -= (mMatrix[0] * pos[0] + mMatrix[1] * pos[1] + mMatrix[ 2] * pos[2]);
                        mMatrix[ 7] -= (mMatrix[4] * pos[0] + mMatrix[5] * pos[1] + mMatrix[ 6] * pos[2]);
                        mMatrix[11] -= (mMatrix[8] * pos[0] + mMatrix[9] * pos[1] + mMatrix[10] * pos[2]);
                        mMatrixInv = invertFast(mMatrix);
                    };
*/
    me.LocalMove = function( dis )
                    {
                        dis = matMulvec( setRotationY(-mYRotation), dis);
                        mPositionTarget = sub(mPositionTarget,dis)
                    };

    me.RotateXY = function( x, y)
                  {
                    mXRotationTarget -= x;
                    mYRotationTarget -= y;
                    mXRotationTarget = Math.min( Math.max( mXRotationTarget, -Math.PI/2), Math.PI/2 );
                  };


    me.CameraExectue = function( dt )
    {
        // smooth position
        mXRotation += (mXRotationTarget-mXRotation) * 12.0*dt;
        mYRotation += (mYRotationTarget-mYRotation) * 12.0*dt;
        mPosition = add(mPosition, mul( sub(mPositionTarget, mPosition), 12.0*dt));

        // Make Camera matrix
        mMatrix = matMul( matMul(setRotationX(mXRotation), 
                                 setRotationY(mYRotation)),  
                                 setTranslation(mPosition));
        mMatrixInv = invertFast(mMatrix);

    }

    me.GetMatrix = function() { return mMatrix; };
    me.GetMatrixInverse = function() { return mMatrixInv; };
    me.SetMatrix = function( mat ) 
                    {
                        mMatrix = mat;
                        mMatrixInv = invertFast(mMatrix);

                        mPosition = getXYZ(matMulpoint(mat, [0.0,0.0,0.0]));
                        mPositionTarget = mPosition;
                    };

    me.GetPos = function() { return getXYZ(matMulpoint(mMatrixInv, [0.0,0.0,0.0])); }
    me.GetDir = function() { return getXYZ(normalize(matMulvec(mMatrixInv, [0.0,0.0,-1.0]))); }

    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piFile
//
//==============================================================================

function piFile( binaryDataArrayBuffer )
{
    // private
    //var mDataView = new DataView( binaryDataArrayBuffer, 0 );
    var mDataView = binaryDataArrayBuffer;
    var mOffset = 0;

    // public members
    var me = {};
    me.mDummy = 0;
/*
    // public functions
    me.Seek = function( off ) { mOffset = off - 3; };
    me.ReadUInt16 = function()  { var res = mDataView.getUint16( mOffset ); mOffset+=2; return res; };
    me.ReadUInt32 = function()  { var res = mDataView.getUint32( mOffset ); mOffset+=4; return res; };
    me.ReadUInt64 = function()  { return me.ReadUInt32() + (me.ReadUInt32()<<32); };
    me.ReadFloat32 = function() { var res = mDataView.getFloat32( mOffset ); mOffset+=4; return res; };
*/

    me.Seek = function( off ) { mOffset = off; };
    me.ReadUInt8  = function()  { var res = (new Uint8Array(mDataView,mOffset))[0]; mOffset+=1; return res; };
    me.ReadUInt16 = function()  { var res = (new Uint16Array(mDataView,mOffset))[0]; mOffset+=2; return res; };
    me.ReadUInt32 = function()  { var res = (new Uint32Array(mDataView,mOffset))[0]; mOffset+=4; return res; };
    me.ReadUInt64 = function()  { return me.ReadUInt32() + (me.ReadUInt32()<<32); };
    me.ReadFloat32 = function() { var res = (new Float32Array(mDataView,mOffset))[0]; mOffset+=4; return res; };
    me.ReadFloat32Array = function(n) 
                          { 
                              var src = new Float32Array(mDataView, mOffset);
                              var res = [];  for( var i=0; i<n; i++ ) { res[i] = src[i]; }
                              mOffset += 4*n;
                              return res;
                          };
    me.ReadFloat32ArrayNative = function(n) { var src = new Float32Array(mDataView, mOffset); mOffset += 4*n; return src; };
    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piMesh
//
//==============================================================================

function piMesh()
{
    this.mChunks = [];
    this.mPrimitiveType = 0;
    this.mVertexFormat = null;
}

/*
piMesh.prototype.normalize = function( ppos, npos )
{
    var numv = this.mVertexData.length;
    var numt = this.mIndices.length;

    for( var i=0; i<numv; i++ )
    {
        //float *v = (float*)piMesh_GetVertexData( me, i, npos );
        //v[0] = 0.0f;
        //v[1] = 0.0f;
        //v[2] = 0.0f;
        this.mVerts[8 * i + 3] = 0.0;
        this.mVerts[8 * i + 4] = 0.0;
        this.mVerts[8 * i + 5] = 0.0;
    }

    for( var i=0; i<numt; i++ )
    {
        piMeshFace *face = me->mFaceData.mIndexArray[0].mBuffer + i;

        const int ft = face->mNum;
        
        vec3 nor = vec3( 0.0f, 0.0f, 0.0f );
        for( int j=0; j<ft; j++ )
        {
            const vec3 va = *((vec3*)piMesh_GetVertexData( me, face->mIndex[ j      ], ppos ));
            const vec3 vb = *((vec3*)piMesh_GetVertexData( me, face->mIndex[(j+1)%ft], ppos ));

            nor += cross( va, vb );
        }

        for( int j=0; j<ft; j++ )
        {
            vec3 *n = (vec3*)piMesh_GetVertexData( me, face->mIndex[j], npos );
            n->x += nor.x;
            n->y += nor.y;
            n->z += nor.z;
        }
    }

    for( var i=0; i<numv; i++ )
    {
        vec3 *v = (vec3*)piMesh_GetVertexData( me, i, npos );
        *v = normalize( *v );
    }
}
*/

piMesh.prototype.createCube = function(renderer)
{
    this.mPrimitiveType = 0;

    this.mChunks[0] = { mVerts : new Float32Array([ -1.0, -1.0, -1.0,
                                       1.0, -1.0, -1.0,
                                      -1.0,  1.0, -1.0,
                                       1.0,  1.0, -1.0,
                                      -1.0, -1.0,  1.0,
                                       1.0, -1.0,  1.0,
                                      -1.0,  1.0,  1.0,
                                       1.0,  1.0,  1.0 ]),

                        mIndices : new Uint16Array([ 0, 2, 1,   1, 2, 3,   5, 1, 3,   5, 3, 7,   4, 5, 7,   4, 7, 6,   4, 6, 2,   4, 2, 0,   6, 7, 3,   6, 3, 2,   4, 0, 1,   4, 1, 5 ]),
                        mNumVertices : 8,
                        mNumFaces : 12, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };

    this.mVertexFormat = { mStride:12, mChannels:[ { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false } ] };

    return true;
}

piMesh.prototype.createCubeSharp = function (renderer)
{
    this.mPrimitiveType = 0;

    this.mChunks[0] = { mVerts : new Float32Array([-1.0, 1.0,-1.0,   0.0, 1.0, 0.0,   0.0, 0.0,
                                    -1.0, 1.0, 1.0,   0.0, 1.0, 0.0,   0.0, 1.0,
                                     1.0, 1.0, 1.0,   0.0, 1.0, 0.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   0.0, 1.0, 0.0,   1.0, 0.0,

                                    -1.0,-1.0, 1.0,   0.0, 0.0, 1.0,   0.0, 0.0,
                                     1.0,-1.0, 1.0,   0.0, 0.0, 1.0,   0.0, 1.0,
                                     1.0, 1.0, 1.0,   0.0, 0.0, 1.0,   1.0, 1.0,
                                    -1.0, 1.0, 1.0,   0.0, 0.0, 1.0,   1.0, 0.0,

                                     1.0, 1.0, 1.0,   1.0, 0.0, 0.0,   0.0, 0.0,
                                     1.0,-1.0, 1.0,   1.0, 0.0, 0.0,   0.0, 1.0,
                                     1.0,-1.0,-1.0,   1.0, 0.0, 0.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   1.0, 0.0, 0.0,   1.0, 0.0,

                                     1.0,-1.0,-1.0,   0.0, 0.0,-1.0,   0.0, 0.0,
                                    -1.0,-1.0,-1.0,   0.0, 0.0,-1.0,   0.0, 1.0,
                                    -1.0, 1.0,-1.0,   0.0, 0.0,-1.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   0.0, 0.0,-1.0,   1.0, 0.0,

                                    -1.0,-1.0, 1.0,   0.0,-1.0, 0.0,   0.0, 0.0,
                                    -1.0,-1.0,-1.0,   0.0,-1.0, 0.0,   0.0, 1.0,
                                     1.0,-1.0,-1.0,   0.0,-1.0, 0.0,   1.0, 1.0,
                                     1.0,-1.0, 1.0,   0.0,-1.0, 0.0,   1.0, 0.0,

                                    -1.0, 1.0, 1.0,  -1.0, 0.0, 0.0,   0.0, 0.0,
                                    -1.0, 1.0,-1.0,  -1.0, 0.0, 0.0,   0.0, 1.0,
                                    -1.0,-1.0,-1.0,  -1.0, 0.0, 0.0,   1.0, 1.0,
                                    -1.0,-1.0, 1.0,  -1.0, 0.0, 0.0,   1.0, 0.0 ]),

                        mIndices : new Uint16Array([0,1,2, 0,2,3,   4,5,6, 4,6,7,    8,9,10,8,10,11,   12,13,14,12,14,15,   16,17,18,16,18,19,   20,21,22,20,22,23]),
                        mNumVertices : 24,
                        mNumFaces : 12, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };


    this.mVertexFormat = { mStride:32, mChannels:[ { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false },
                                                   { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false },
                                                   { mNumComponents:2, mType: renderer.TYPE.FLOAT32, mNormalize: false } ] };

    return true;
}


piMesh.prototype.createUnitQuad = function (renderer)
{
    this.mPrimitiveType = 0;
    this.mVertexFormat = { mStride:8, mChannels: [ {mNumComponents:2, mType: renderer.TYPE.FLOAT32, mNormalize: false} ] };

    this.mChunks[0] = { mVerts : new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0,  1.0, 1.0,  1.0]),
                        mIndices : new Uint16Array([0, 2, 1, 1, 2, 3]),
                        mNumVertices : 4,
                        mNumFaces : 2, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };
 
    return true;
}




piMesh.prototype.destroy = function()
{
    //delete this.mVerts;   this.mVerts = null;
    //delete this.mIndices; this.mIndices = null;
}

piMesh.prototype.scale = function (x, y, z)
{
    var stride = this.mVertexFormat.mStride/4;
    for( var j=0; j<this.mChunks.length; j++ )
    {
        var nv = this.mChunks[j].mNumVertices;
        for (var i = 0; i < nv; i++) 
        {
            this.mChunks[j].mVerts[stride * i + 0] *= x;
            this.mChunks[j].mVerts[stride * i + 1] *= y;
            this.mChunks[j].mVerts[stride * i + 2] *= z;
        }
    }
}

piMesh.prototype.translate = function (x, y, z) 
{
    var stride = this.mVertexFormat.mStride/4;
    for( var j=0; j<this.mChunks.length; j++ )
    {
        var nv = this.mChunks[j].mNumVertices;
        for (var i = 0; i < nv; i++) 
        {
            this.mChunks[j].mVerts[stride * i + 0] += x;
            this.mChunks[j].mVerts[stride * i + 1] += y;
            this.mChunks[j].mVerts[stride * i + 2] += z;
        }
    }
}

piMesh.prototype.GPULoad = function (renderer)
{
    for( var i=0; i<this.mChunks.length; i++ )
    {
        var vbo = renderer.CreateVertexArray(this.mChunks[i].mVerts, renderer.BUFTYPE.STATIC );
        if (vbo == null)
            return false;

        var ibo = renderer.CreateIndexArray(this.mChunks[i].mIndices, renderer.BUFTYPE.STATIC);
        if (ibo == null)
            return false;

        this.mChunks[i].mVBO = vbo;
        this.mChunks[i].mIBO = ibo;
    }
    return true;
}

piMesh.prototype.GPURender = function (renderer, positions )//, matPrj, matCam )
{
    //renderer.SetShaderConstantMat4F("unMPrj", matPrj, false );

    var num = this.mChunks.length;
    for( var i=0; i<num; i++ )
    {
        //var mat =  matMul( matCam, this.mChunks[i].mTransform );
        //renderer.SetShaderConstantMat4F("unMMod", mat, false);

        renderer.AttachVertexArray(this.mChunks[i].mVBO, this.mVertexFormat, positions );
        renderer.AttachIndexArray(this.mChunks[i].mIBO );
        renderer.DrawPrimitive(renderer.PRIMTYPE.TRIANGLES, this.mChunks[i].mNumFaces * 3, true, 1);
        renderer.DetachIndexArray(this.mChunks[i].mIBO);
        renderer.DetachVertexArray(this.mChunks[i].mVBO, this.mVertexFormat );
    }
}
//==============================================================================
//
// piLibs 2014-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piRenderer
//
//==============================================================================

function piRenderer()
{
    // private members

    var mGL = null;
    var mBindedShader = null;
    var mIs20 = false;
    var mFloat32Textures;
    var mFloat32Filter;
    var mFloat16Textures;
    var mDrawBuffers;
    var mDepthTextures;
    var mDerivatives;
    var mFloat16Filter;
    var mShaderTextureLOD;
    var mAnisotropic;
    var mRenderToFloat32F;
    var mDebugShader;
    var mAsynchCompile;

    var mVBO_Quad = null;
    var mVBO_Tri = null;
    var mVBO_CubePosNor = null;
    var mVBO_CubePos = null;
    var mShaderHeader = ["",""];
    var mShaderHeaderLines = [0,0];

    // public members
    var me = {};

    me.CLEAR      = { Color: 1, Zbuffer : 2, Stencil : 4 };
    me.TEXFMT     = { C4I8 : 0, C1I8 : 1, C1F16 : 2, C4F16 : 3, C1F32 : 4, C4F32 : 5, Z16 : 6, Z24 : 7, Z32 : 8, C3F32:9 };
    me.TEXWRP     = { CLAMP : 0, REPEAT : 1 };
    me.BUFTYPE    = { STATIC : 0, DYNAMIC : 1 };
    me.PRIMTYPE   = { POINTS : 0, LINES : 1, LINE_LOOP : 2, LINE_STRIP : 3, TRIANGLES : 4, TRIANGLE_STRIP : 5 };
    me.RENDSTGATE = { WIREFRAME : 0, FRONT_FACE : 1, CULL_FACE : 2, DEPTH_TEST : 3, ALPHA_TO_COVERAGE : 4 };
    me.TEXTYPE    = { T2D : 0, T3D : 1, CUBEMAP : 2 };
    me.FILTER     = { NONE : 0, LINEAR : 1, MIPMAP : 2, NONE_MIPMAP : 3 };
    me.TYPE       = { UINT8 : 0, UINT16 : 1, UINT32 : 2, FLOAT16: 3, FLOAT32 : 4, FLOAT64: 5 };

    // private functions

    var iFormatPI2GL = function( format )
    {
        if( mIs20 )
        {
             if (format === me.TEXFMT.C4I8)  return { mGLFormat: mGL.RGBA8,           mGLExternal: mGL.RGBA,             mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1I8)  return { mGLFormat: mGL.R8,              mGLExternal: mGL.RED,              mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1F16) return { mGLFormat: mGL.R16F,            mGLExternal: mGL.RED,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F16) return { mGLFormat: mGL.RGBA16F,         mGLExternal: mGL.RGBA,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C1F32) return { mGLFormat: mGL.R32F,            mGLExternal: mGL.RED,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F32) return { mGLFormat: mGL.RGBA32F,         mGLExternal: mGL.RGBA,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C3F32) return { mGLFormat: mGL.RGB32F,          mGLExternal: mGL.RGB,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.Z16)   return { mGLFormat: mGL.DEPTH_COMPONENT16, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        else if (format === me.TEXFMT.Z24)   return { mGLFormat: mGL.DEPTH_COMPONENT24, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        else if (format === me.TEXFMT.Z32)   return { mGLFormat: mGL.DEPTH_COMPONENT32F, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        }
        else
        {
             if (format === me.TEXFMT.C4I8)  return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1I8)  return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.LUMINANCE,       mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1F16) return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.LUMINANCE,       mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F16) return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C1F32) return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.RED,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F32) return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.Z16)   return { mGLFormat: mGL.DEPTH_COMPONENT, mGLExternal: mGL.DEPTH_COMPONENT, mGLType: mGL.UNSIGNED_SHORT }
        }

        return null;
     }

    // public functions

    me.Initialize = function( gl )
                    {
                        mGL = gl;

                        mIs20 = !(gl instanceof WebGLRenderingContext);

                        if( mIs20 )
                        {
                            mFloat32Textures  = true;
                            mFloat32Filter    = mGL.getExtension( 'OES_texture_float_linear');
                            mFloat16Textures  = true;
                            mFloat16Filter    = mGL.getExtension( 'OES_texture_half_float_linear' );
                            mDerivatives      = true;
                            mDrawBuffers      = true;
                            mDepthTextures    = true;
                            mShaderTextureLOD = true;
                            mAnisotropic = mGL.getExtension( 'EXT_texture_filter_anisotropic' );
                            mRenderToFloat32F = mGL.getExtension( 'EXT_color_buffer_float');
                            mDebugShader = mGL.getExtension('WEBGL_debug_shaders');
                            mAsynchCompile = mGL.getExtension('KHR_parallel_shader_compile');

							mGL.hint( mGL.FRAGMENT_SHADER_DERIVATIVE_HINT, mGL.NICEST);
                        }
                        else
                        {
                            mFloat32Textures  = mGL.getExtension( 'OES_texture_float' );
                            mFloat32Filter    = mGL.getExtension( 'OES_texture_float_linear');
                            mFloat16Textures  = mGL.getExtension( 'OES_texture_half_float' );
                            mFloat16Filter    = mGL.getExtension( 'OES_texture_half_float_linear' );
                            mDerivatives      = mGL.getExtension( 'OES_standard_derivatives' );
                            mDrawBuffers      = mGL.getExtension( 'WEBGL_draw_buffers' );
                            mDepthTextures    = mGL.getExtension( 'WEBGL_depth_texture' );
                            mShaderTextureLOD = mGL.getExtension( 'EXT_shader_texture_lod' );
                            mAnisotropic      = mGL.getExtension( 'EXT_texture_filter_anisotropic' );
                            mRenderToFloat32F = mFloat32Textures;
                            mDebugShader      = null;
                            mAsynchCompile    = null;
							
							if( mDerivatives !== null) mGL.hint( mDerivatives.FRAGMENT_SHADER_DERIVATIVE_HINT_OES, mGL.NICEST);
                        }
                        
                        
                        var maxTexSize = mGL.getParameter( mGL.MAX_TEXTURE_SIZE );
                        var maxCubeSize = mGL.getParameter( mGL.MAX_CUBE_MAP_TEXTURE_SIZE );
                        var maxRenderbufferSize = mGL.getParameter( mGL.MAX_RENDERBUFFER_SIZE );
                        var extensions = mGL.getSupportedExtensions();
                        var textureUnits = mGL.getParameter( mGL.MAX_TEXTURE_IMAGE_UNITS );
                        console.log("WebGL (2.0=" + mIs20 + "):" +
                                    " Asynch Compile: "  + ((mAsynchCompile !==null) ? "yes" : "no") +
                                    ", Textures: F32 ["   + ((mFloat32Textures !==null) ? "yes" : "no") +
                                    "], F16 ["   + ((mFloat16Textures !==null) ? "yes" : "no") +
                                    "], Depth [" + ((mDepthTextures   !==null) ? "yes" : "no") +
                                    "], LOD ["    + ((mShaderTextureLOD!==null) ? "yes" : "no") +
                                    "], Aniso ["   + ((mAnisotropic     !==null) ? "yes" : "no") +
                                    "], Units [" + textureUnits +
                                    "], Max Size [" + maxTexSize +
                                    "], Cube Max Size [" + maxCubeSize +
                                    "], Targets: MRT ["            + ((mDrawBuffers     !==null) ? "yes" : "no") +
                                    "], F32 ["     + ((mRenderToFloat32F!==null) ? "yes" : "no") +
                                    "], Max Size [" + maxRenderbufferSize + "]");

                        // create a 2D quad Vertex Buffer
                        var vertices = new Float32Array( [ -1.0, -1.0,   1.0, -1.0,    -1.0,  1.0,     1.0, -1.0,    1.0,  1.0,    -1.0,  1.0] );
                        mVBO_Quad = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Quad );
                        mGL.bufferData( mGL.ARRAY_BUFFER, vertices, mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 2D triangle Vertex Buffer
                        mVBO_Tri = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Tri );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0,   3.0, -1.0,    -1.0,  3.0] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 3D cube Vertex Buffer
                        mVBO_CubePosNor = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePosNor );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0, -1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0, -1.0,  1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0,  1.0, -1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0,  1.0,  1.0,  -1.0,  0.0,  0.0,
                                                                               1.0,  1.0, -1.0,   1.0,  0.0,  0.0,
                                                                               1.0,  1.0,  1.0,   1.0,  0.0,  0.0,
                                                                               1.0, -1.0, -1.0,   1.0,  0.0,  0.0,
                                                                               1.0, -1.0,  1.0,   1.0,  0.0,  0.0,
                                                                               1.0,  1.0,  1.0,   0.0,  1.0,  0.0,
                                                                               1.0,  1.0, -1.0,   0.0,  1.0,  0.0,
                                                                              -1.0,  1.0,  1.0,   0.0,  1.0,  0.0,
                                                                              -1.0,  1.0, -1.0,   0.0,  1.0,  0.0,
                                                                               1.0, -1.0, -1.0,   0.0, -1.0,  0.0,
                                                                               1.0, -1.0,  1.0,   0.0, -1.0,  0.0,
                                                                              -1.0, -1.0, -1.0,   0.0, -1.0,  0.0,
                                                                              -1.0, -1.0,  1.0,   0.0, -1.0,  0.0,
                                                                              -1.0,  1.0,  1.0,   0.0,  0.0,  1.0,
                                                                              -1.0, -1.0,  1.0,   0.0,  0.0,  1.0,
                                                                               1.0,  1.0,  1.0,   0.0,  0.0,  1.0,
                                                                               1.0, -1.0,  1.0,   0.0,  0.0,  1.0,
                                                                              -1.0, -1.0, -1.0,   0.0,  0.0, -1.0,
                                                                              -1.0,  1.0, -1.0,   0.0,  0.0, -1.0,
                                                                               1.0, -1.0, -1.0,   0.0,  0.0, -1.0,
                                                                               1.0,  1.0, -1.0,   0.0,  0.0, -1.0 ] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 3D cube Vertex Buffer
                        mVBO_CubePos = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePos );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0, -1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                               1.0,  1.0, -1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0, -1.0,  1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0,  1.0, -1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0, -1.0,  1.0,
                                                                              -1.0, -1.0, -1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0, -1.0,  1.0,
                                                                              -1.0, -1.0, -1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0,  1.0, -1.0 ] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        //-------------------------------------------------------------------

                        mShaderHeader[0] = "";
                        mShaderHeaderLines[0] = 0;
                        if( mIs20 ) 
                        { 
                            mShaderHeader[0] += "#version 300 es\n" +
                                                "#ifdef GL_ES\n"+
                                                "precision highp float;\n" +
                                                "precision highp int;\n"+
                                                "precision mediump sampler3D;\n"+
                                                "#endif\n"; 
                            mShaderHeaderLines[0] += 6;
                        }
                        else
                        {
                            mShaderHeader[0] += "#ifdef GL_ES\n"+
                                                "precision highp float;\n" +
                                                "precision highp int;\n"+
                                                "#endif\n"+
                                                "float round( float x ) { return floor(x+0.5); }\n"+
                                                "vec2 round(vec2 x) { return floor(x + 0.5); }\n"+
                                                "vec3 round(vec3 x) { return floor(x + 0.5); }\n"+
                                                "vec4 round(vec4 x) { return floor(x + 0.5); }\n"+
                                                "float trunc( float x, float n ) { return floor(x*n)/n; }\n"+
                                                "mat3 transpose(mat3 m) { return mat3(m[0].x, m[1].x, m[2].x, m[0].y, m[1].y, m[2].y, m[0].z, m[1].z, m[2].z); }\n"+
                                                "float determinant( in mat2 m ) { return m[0][0]*m[1][1] - m[0][1]*m[1][0]; }\n"+
                                                "float determinant( mat4 m ) { float b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0], b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0], b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0], b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1], b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1], b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2], b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0], b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0], b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0], b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1], b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1], b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;}\n"+
                                                "mat2 inverse(mat2 m) { float det = determinant(m); return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / det; }\n"+
                                                "mat4 inverse(mat4 m ) { float inv0 = m[1].y*m[2].z*m[3].w - m[1].y*m[2].w*m[3].z - m[2].y*m[1].z*m[3].w + m[2].y*m[1].w*m[3].z + m[3].y*m[1].z*m[2].w - m[3].y*m[1].w*m[2].z; float inv4 = -m[1].x*m[2].z*m[3].w + m[1].x*m[2].w*m[3].z + m[2].x*m[1].z*m[3].w - m[2].x*m[1].w*m[3].z - m[3].x*m[1].z*m[2].w + m[3].x*m[1].w*m[2].z; float inv8 = m[1].x*m[2].y*m[3].w - m[1].x*m[2].w*m[3].y - m[2].x  * m[1].y * m[3].w + m[2].x  * m[1].w * m[3].y + m[3].x * m[1].y * m[2].w - m[3].x * m[1].w * m[2].y; float inv12 = -m[1].x  * m[2].y * m[3].z + m[1].x  * m[2].z * m[3].y +m[2].x  * m[1].y * m[3].z - m[2].x  * m[1].z * m[3].y - m[3].x * m[1].y * m[2].z + m[3].x * m[1].z * m[2].y; float inv1 = -m[0].y*m[2].z * m[3].w + m[0].y*m[2].w * m[3].z + m[2].y  * m[0].z * m[3].w - m[2].y  * m[0].w * m[3].z - m[3].y * m[0].z * m[2].w + m[3].y * m[0].w * m[2].z; float inv5 = m[0].x  * m[2].z * m[3].w - m[0].x  * m[2].w * m[3].z - m[2].x  * m[0].z * m[3].w + m[2].x  * m[0].w * m[3].z + m[3].x * m[0].z * m[2].w - m[3].x * m[0].w * m[2].z; float inv9 = -m[0].x  * m[2].y * m[3].w +  m[0].x  * m[2].w * m[3].y + m[2].x  * m[0].y * m[3].w - m[2].x  * m[0].w * m[3].y - m[3].x * m[0].y * m[2].w + m[3].x * m[0].w * m[2].y; float inv13 = m[0].x  * m[2].y * m[3].z - m[0].x  * m[2].z * m[3].y - m[2].x  * m[0].y * m[3].z + m[2].x  * m[0].z * m[3].y + m[3].x * m[0].y * m[2].z - m[3].x * m[0].z * m[2].y; float inv2 = m[0].y  * m[1].z * m[3].w - m[0].y  * m[1].w * m[3].z - m[1].y  * m[0].z * m[3].w + m[1].y  * m[0].w * m[3].z + m[3].y * m[0].z * m[1].w - m[3].y * m[0].w * m[1].z; float inv6 = -m[0].x  * m[1].z * m[3].w + m[0].x  * m[1].w * m[3].z + m[1].x  * m[0].z * m[3].w - m[1].x  * m[0].w * m[3].z - m[3].x * m[0].z * m[1].w + m[3].x * m[0].w * m[1].z; float inv10 = m[0].x  * m[1].y * m[3].w - m[0].x  * m[1].w * m[3].y - m[1].x  * m[0].y * m[3].w + m[1].x  * m[0].w * m[3].y + m[3].x * m[0].y * m[1].w - m[3].x * m[0].w * m[1].y; float inv14 = -m[0].x  * m[1].y * m[3].z + m[0].x  * m[1].z * m[3].y + m[1].x  * m[0].y * m[3].z - m[1].x  * m[0].z * m[3].y - m[3].x * m[0].y * m[1].z + m[3].x * m[0].z * m[1].y; float inv3 = -m[0].y * m[1].z * m[2].w + m[0].y * m[1].w * m[2].z + m[1].y * m[0].z * m[2].w - m[1].y * m[0].w * m[2].z - m[2].y * m[0].z * m[1].w + m[2].y * m[0].w * m[1].z; float inv7 = m[0].x * m[1].z * m[2].w - m[0].x * m[1].w * m[2].z - m[1].x * m[0].z * m[2].w + m[1].x * m[0].w * m[2].z + m[2].x * m[0].z * m[1].w - m[2].x * m[0].w * m[1].z; float inv11 = -m[0].x * m[1].y * m[2].w + m[0].x * m[1].w * m[2].y + m[1].x * m[0].y * m[2].w - m[1].x * m[0].w * m[2].y - m[2].x * m[0].y * m[1].w + m[2].x * m[0].w * m[1].y; float inv15 = m[0].x * m[1].y * m[2].z - m[0].x * m[1].z * m[2].y - m[1].x * m[0].y * m[2].z + m[1].x * m[0].z * m[2].y + m[2].x * m[0].y * m[1].z - m[2].x * m[0].z * m[1].y; float det = m[0].x * inv0 + m[0].y * inv4 + m[0].z * inv8 + m[0].w * inv12; det = 1.0 / det; return det*mat4( inv0, inv1, inv2, inv3,inv4, inv5, inv6, inv7,inv8, inv9, inv10, inv11,inv12, inv13, inv14, inv15);}\n"+                                                
                                                "float sinh(float x)  { return (exp(x)-exp(-x))/2.; }\n"+
                                                "float cosh(float x)  { return (exp(x)+exp(-x))/2.; }\n"+
                                                "float tanh(float x)  { return sinh(x)/cosh(x); }\n"+
                                                "float coth(float x)  { return cosh(x)/sinh(x); }\n"+
                                                "float sech(float x)  { return 1./cosh(x); }\n"+
                                                "float csch(float x)  { return 1./sinh(x); }\n"+
                                                "float asinh(float x) { return    log(x+sqrt(x*x+1.)); }\n"+
                                                "float acosh(float x) { return    log(x+sqrt(x*x-1.)); }\n"+
                                                "float atanh(float x) { return .5*log((1.+x)/(1.-x)); }\n"+
                                                "float acoth(float x) { return .5*log((x+1.)/(x-1.)); }\n"+
                                                "float asech(float x) { return    log((1.+sqrt(1.-x*x))/x); }\n"+
                                                "float acsch(float x) { return    log((1.+sqrt(1.+x*x))/x); }\n";
                            mShaderHeaderLines[0] += 26;
                        }

                        //-------------------------------------------------------

                        mShaderHeader[1] = "";
                        mShaderHeaderLines[1] = 0;
                        if( mIs20 ) 
                        { 
                            mShaderHeader[1] += "#version 300 es\n"+
                                                "#ifdef GL_ES\n"+
                                                "precision highp float;\n"+
                                                "precision highp int;\n"+
                                                "precision mediump sampler3D;\n"+
                                                "#endif\n"; 
                            mShaderHeaderLines[1] += 6;
                        }
                        else
                        {
                            if( mDerivatives ) { mShaderHeader[1] += "#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n"; mShaderHeaderLines[1]+=3; }
                            if( mShaderTextureLOD  ) { mShaderHeader[1] += "#extension GL_EXT_shader_texture_lod : enable\n"; mShaderHeaderLines[1]++; }
                            mShaderHeader[1] += "#ifdef GL_ES\n"+
                                                "precision highp float;\n"+
                                                "precision highp int;\n"+
                                                "#endif\n"+ 
                                                "vec4 texture(     sampler2D   s, vec2 c)                   { return texture2D(s,c); }\n"+
                                                "vec4 texture(     sampler2D   s, vec2 c, float b)          { return texture2D(s,c,b); }\n"+
                                                "vec4 texture(     samplerCube s, vec3 c )                  { return textureCube(s,c); }\n"+
                                                "vec4 texture(     samplerCube s, vec3 c, float b)          { return textureCube(s,c,b); }\n"+
                                                "float round( float x ) { return floor(x+0.5); }\n"+
                                                "vec2 round(vec2 x) { return floor(x + 0.5); }\n"+
                                                "vec3 round(vec3 x) { return floor(x + 0.5); }\n"+
                                                "vec4 round(vec4 x) { return floor(x + 0.5); }\n"+
                                                "float trunc( float x, float n ) { return floor(x*n)/n; }\n"+
                                                "mat3 transpose(mat3 m) { return mat3(m[0].x, m[1].x, m[2].x, m[0].y, m[1].y, m[2].y, m[0].z, m[1].z, m[2].z); }\n"+
                                                "float determinant( in mat2 m ) { return m[0][0]*m[1][1] - m[0][1]*m[1][0]; }\n"+
                                                "float determinant( mat4 m ) { float b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0], b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0], b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0], b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1], b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1], b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2], b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0], b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0], b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0], b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1], b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1], b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;}\n"+
                                                "mat2 inverse(mat2 m) { float det = determinant(m); return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / det; }\n"+
                                                "mat4 inverse(mat4 m ) { float inv0 = m[1].y*m[2].z*m[3].w - m[1].y*m[2].w*m[3].z - m[2].y*m[1].z*m[3].w + m[2].y*m[1].w*m[3].z + m[3].y*m[1].z*m[2].w - m[3].y*m[1].w*m[2].z; float inv4 = -m[1].x*m[2].z*m[3].w + m[1].x*m[2].w*m[3].z + m[2].x*m[1].z*m[3].w - m[2].x*m[1].w*m[3].z - m[3].x*m[1].z*m[2].w + m[3].x*m[1].w*m[2].z; float inv8 = m[1].x*m[2].y*m[3].w - m[1].x*m[2].w*m[3].y - m[2].x  * m[1].y * m[3].w + m[2].x  * m[1].w * m[3].y + m[3].x * m[1].y * m[2].w - m[3].x * m[1].w * m[2].y; float inv12 = -m[1].x  * m[2].y * m[3].z + m[1].x  * m[2].z * m[3].y +m[2].x  * m[1].y * m[3].z - m[2].x  * m[1].z * m[3].y - m[3].x * m[1].y * m[2].z + m[3].x * m[1].z * m[2].y; float inv1 = -m[0].y*m[2].z * m[3].w + m[0].y*m[2].w * m[3].z + m[2].y  * m[0].z * m[3].w - m[2].y  * m[0].w * m[3].z - m[3].y * m[0].z * m[2].w + m[3].y * m[0].w * m[2].z; float inv5 = m[0].x  * m[2].z * m[3].w - m[0].x  * m[2].w * m[3].z - m[2].x  * m[0].z * m[3].w + m[2].x  * m[0].w * m[3].z + m[3].x * m[0].z * m[2].w - m[3].x * m[0].w * m[2].z; float inv9 = -m[0].x  * m[2].y * m[3].w +  m[0].x  * m[2].w * m[3].y + m[2].x  * m[0].y * m[3].w - m[2].x  * m[0].w * m[3].y - m[3].x * m[0].y * m[2].w + m[3].x * m[0].w * m[2].y; float inv13 = m[0].x  * m[2].y * m[3].z - m[0].x  * m[2].z * m[3].y - m[2].x  * m[0].y * m[3].z + m[2].x  * m[0].z * m[3].y + m[3].x * m[0].y * m[2].z - m[3].x * m[0].z * m[2].y; float inv2 = m[0].y  * m[1].z * m[3].w - m[0].y  * m[1].w * m[3].z - m[1].y  * m[0].z * m[3].w + m[1].y  * m[0].w * m[3].z + m[3].y * m[0].z * m[1].w - m[3].y * m[0].w * m[1].z; float inv6 = -m[0].x  * m[1].z * m[3].w + m[0].x  * m[1].w * m[3].z + m[1].x  * m[0].z * m[3].w - m[1].x  * m[0].w * m[3].z - m[3].x * m[0].z * m[1].w + m[3].x * m[0].w * m[1].z; float inv10 = m[0].x  * m[1].y * m[3].w - m[0].x  * m[1].w * m[3].y - m[1].x  * m[0].y * m[3].w + m[1].x  * m[0].w * m[3].y + m[3].x * m[0].y * m[1].w - m[3].x * m[0].w * m[1].y; float inv14 = -m[0].x  * m[1].y * m[3].z + m[0].x  * m[1].z * m[3].y + m[1].x  * m[0].y * m[3].z - m[1].x  * m[0].z * m[3].y - m[3].x * m[0].y * m[1].z + m[3].x * m[0].z * m[1].y; float inv3 = -m[0].y * m[1].z * m[2].w + m[0].y * m[1].w * m[2].z + m[1].y * m[0].z * m[2].w - m[1].y * m[0].w * m[2].z - m[2].y * m[0].z * m[1].w + m[2].y * m[0].w * m[1].z; float inv7 = m[0].x * m[1].z * m[2].w - m[0].x * m[1].w * m[2].z - m[1].x * m[0].z * m[2].w + m[1].x * m[0].w * m[2].z + m[2].x * m[0].z * m[1].w - m[2].x * m[0].w * m[1].z; float inv11 = -m[0].x * m[1].y * m[2].w + m[0].x * m[1].w * m[2].y + m[1].x * m[0].y * m[2].w - m[1].x * m[0].w * m[2].y - m[2].x * m[0].y * m[1].w + m[2].x * m[0].w * m[1].y; float inv15 = m[0].x * m[1].y * m[2].z - m[0].x * m[1].z * m[2].y - m[1].x * m[0].y * m[2].z + m[1].x * m[0].z * m[2].y + m[2].x * m[0].y * m[1].z - m[2].x * m[0].z * m[1].y; float det = m[0].x * inv0 + m[0].y * inv4 + m[0].z * inv8 + m[0].w * inv12; det = 1.0 / det; return det*mat4( inv0, inv1, inv2, inv3,inv4, inv5, inv6, inv7,inv8, inv9, inv10, inv11,inv12, inv13, inv14, inv15);}\n"+
                                                "float sinh(float x)  { return (exp(x)-exp(-x))/2.; }\n"+
                                                "float cosh(float x)  { return (exp(x)+exp(-x))/2.; }\n"+
                                                "float tanh(float x)  { return sinh(x)/cosh(x); }\n"+
                                                "float coth(float x)  { return cosh(x)/sinh(x); }\n"+
                                                "float sech(float x)  { return 1./cosh(x); }\n"+
                                                "float csch(float x)  { return 1./sinh(x); }\n"+
                                                "float asinh(float x) { return    log(x+sqrt(x*x+1.)); }\n"+
                                                "float acosh(float x) { return    log(x+sqrt(x*x-1.)); }\n"+
                                                "float atanh(float x) { return .5*log((1.+x)/(1.-x)); }\n"+
                                                "float acoth(float x) { return .5*log((x+1.)/(x-1.)); }\n"+
                                                "float asech(float x) { return    log((1.+sqrt(1.-x*x))/x); }\n"+
                                                "float acsch(float x) { return    log((1.+sqrt(1.+x*x))/x); }\n";
                            mShaderHeaderLines[1] += 30;
                            if( mShaderTextureLOD )
                            {
                            mShaderHeader[1] += "vec4 textureLod(  sampler2D   s, vec2 c, float b)          { return texture2DLodEXT(s,c,b); }\n";
                            mShaderHeader[1] += "vec4 textureGrad( sampler2D   s, vec2 c, vec2 dx, vec2 dy) { return texture2DGradEXT(s,c,dx,dy); }\n";
                            mShaderHeaderLines[1] += 2;

                            //mShaderHeader[1] += "vec4 texelFetch( sampler2D s, ivec2 c, int l) { return texture2DLodEXT(s,(vec2(c)+0.5)/vec2(800,450),float(l)); }\n";
                            //mShaderHeaderLines[1] += 1;
                            }
                        }

                        return true;
                    };

        me.GetCaps =    function ()
                        {   
                            return { mIsGL20 : mIs20,
                                     mFloat32Textures: mFloat32Textures != null,
                                     mFloat16Textures: mFloat16Textures != null,
                                     mDrawBuffers: mDrawBuffers != null,
                                     mDepthTextures: mDepthTextures != null,
                                     mDerivatives: mDerivatives != null,
                                     mShaderTextureLOD: mShaderTextureLOD != null };
                        };

        me.GetShaderHeaderLines = function (shaderType)
                        {   
                            return mShaderHeaderLines[shaderType];
                        };

        me.CheckErrors = function()
                         {
                                var error = mGL.getError();
                                if( error != mGL.NO_ERROR ) 
                                { 
                                    for( var prop in mGL ) 
                                    {
                                        if( typeof mGL[prop] == 'number' ) 
                                        {
                                            if( mGL[prop] == error )
                                            {
                                                console.log( "GL Error " + error + ": " + prop );
                                                break;
                                            }
                                        }
                                    }
                                }
                         };

        me.Clear =  function( flags, ccolor, cdepth, cstencil )
                    {
                        var mode = 0;
                        if( flags & 1 ) { mode |= mGL.COLOR_BUFFER_BIT;   mGL.clearColor( ccolor[0], ccolor[1], ccolor[2], ccolor[3] ); }
                        if( flags & 2 ) { mode |= mGL.DEPTH_BUFFER_BIT;   mGL.clearDepth( cdepth ); }
                        if( flags & 4 ) { mode |= mGL.STENCIL_BUFFER_BIT; mGL.clearStencil( cstencil ); }
                        mGL.clear( mode );
                    };


        me.CreateTexture = function ( type, xres, yres, format, filter, wrap, buffer)
                           {
                                if( mGL===null ) return null;

                                var id = mGL.createTexture();

                                var glFoTy = iFormatPI2GL( format );
                                var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                if( type===me.TEXTYPE.T2D )
                                {
                                    mGL.bindTexture( mGL.TEXTURE_2D, id );
//if( buffer==null )
    //mGL.texStorage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, xres, yres);
//else
                                    mGL.texImage2D( mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texParameteri( mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap );
                                    mGL.texParameteri( mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap );

                                    if (filter === me.FILTER.NONE)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }

                                    mGL.bindTexture( mGL.TEXTURE_2D, null );
                                }
                                else if( type===me.TEXTYPE.T3D )
                                {
                                    if( mIs20 )
                                    {
                                        mGL.bindTexture( mGL.TEXTURE_3D, id );
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_BASE_LEVEL, 0);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAX_LEVEL, Math.log2(xres));
                                        if (filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                        }
                                        else if (filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        }
                                        else
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_3D);
                                        }
                                        mGL.texImage3D( mGL.TEXTURE_3D, 0, glFoTy.mGLFormat, xres, yres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );

                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_R, glWrap );
                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_S, glWrap );
                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_T, glWrap );

                                        if (filter === me.FILTER.MIPMAP)
                                            mGL.generateMipmap( mGL.TEXTURE_3D );
                                        mGL.bindTexture( mGL.TEXTURE_3D, null );
                                    }
                                    else 
                                    {
                                        return null;
                                    }
                                }
                                else 
                                {
                                    mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );

                                    // this works great if we know the number of required mipmaps in advance (1, or other)
                                   //mGL.texStorage2D( mGL.TEXTURE_CUBE_MAP, 1, glFoTy.mGLFormat, xres, yres );

                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );

                                    if( filter === me.FILTER.NONE)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR)
                                    {
                                        mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR );
                                        mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR );
                                    }
                                    else if (filter === me.FILTER.MIPMAP)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                    }

                                    if (filter === me.FILTER.MIPMAP)
                                        mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );

                                    mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                }
                        return { mObjectID: id, mXres: xres, mYres: yres, mFormat: format, mType: type, mFilter: filter, mWrap: wrap, mVFlip:false };
                        };

        me.CreateTextureFromImage = function ( type, image, format, filter, wrap, flipY) 
                                {
                                    if( mGL===null ) return null;

                                    var id = mGL.createTexture();

                                    var glFoTy = iFormatPI2GL( format );

                                    var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                    if( type===me.TEXTYPE.T2D )
                                    {
                                        mGL.bindTexture(mGL.TEXTURE_2D, id);

                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, flipY);
                                        mGL.pixelStorei(mGL.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                                        if( mIs20 ) mGL.pixelStorei(mGL.UNPACK_COLORSPACE_CONVERSION_WEBGL, mGL.NONE );

                                        mGL.texImage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image);

                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap);

                                        if (filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                        }
                                        else if( filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_2D);
                                        }
                                        else
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_2D);
                                        }
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                        mGL.bindTexture(mGL.TEXTURE_2D, null);
                                    }
                                    else if( type===me.TEXTYPE.T3D )
                                    {
                                        return null;
                                    }
                                    else 
                                    {
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, flipY);
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[0] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[1] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (flipY ? image[3] : image[2]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (flipY ? image[2] : image[3]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[4] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[5] );

                                        if( filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR );
                                            mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR );
                                        }
                                        else if (filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                            mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );
                                        }
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                    }
                                    return { mObjectID: id, mXres: image.width, mYres: image.height, mFormat: format, mType: type, mFilter: filter, mWrap:wrap, mVFlip:flipY };
                                };

        me.SetSamplerFilter = function (te, filter, doGenerateMipsIfNeeded) 
                            {
                                if (te.mFilter === filter) return;

                                if (te.mType === me.TEXTYPE.T2D) 
                                {
                                    mGL.bindTexture(mGL.TEXTURE_2D, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_2D, null);

                                }
                                else if (te.mType === me.TEXTYPE.T3D) 
                                {
                                    mGL.bindTexture(mGL.TEXTURE_3D, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_3D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_3D);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_3D, null);

                                }
                                else
                                {
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_CUBE_MAP);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_CUBE_MAP);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                                }


                                te.mFilter = filter;
                            };

        me.SetSamplerWrap = function (te, wrap)
                            {
                                if (te.mWrap === wrap) return;

                                var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                var id = te.mObjectID;

                                if (te.mType === me.TEXTYPE.T2D)
                                {
                                    mGL.bindTexture(mGL.TEXTURE_2D, id);
                                    mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap);
                                    mGL.bindTexture(mGL.TEXTURE_2D, null);

                                }
                                else if (te.mType === me.TEXTYPE.T3D)
                                {
                                    mGL.bindTexture(mGL.TEXTURE_3D, id);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_R, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_S, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_T, glWrap);
                                    mGL.bindTexture(mGL.TEXTURE_3D, null);
                                }

                                te.mWrap = wrap;
                            };

        me.SetSamplerVFlip = function (te, vflip, image)
                            {
                                if (te.mVFlip === vflip) return;

                                var id = te.mObjectID;

                                if (te.mType === me.TEXTYPE.T2D)
                                {
                                    if( image != null)
                                    {
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture(mGL.TEXTURE_2D, id);
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, vflip);
                                        var glFoTy = iFormatPI2GL( te.mFormat );
                                        mGL.texImage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image);
                                        mGL.bindTexture(mGL.TEXTURE_2D, null);
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
                                }
                                else if (te.mType === me.TEXTYPE.CUBEMAP)
                                {
                                    if( image != null)
                                    {
                                        var glFoTy = iFormatPI2GL( te.mFormat );
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );
                                        mGL.pixelStorei( mGL.UNPACK_FLIP_Y_WEBGL, vflip);
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[0] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[1] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (vflip ? image[3] : image[2]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (vflip ? image[2] : image[3]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[4] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[5] );
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
        
                                }

                                te.mVFlip = vflip;
                            };

        me.CreateMipmaps =  function (te)
                            {
                                if( te.mType===me.TEXTYPE.T2D )
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                    mGL.bindTexture(mGL.TEXTURE_2D, te.mObjectID);
                                    mGL.generateMipmap(mGL.TEXTURE_2D);
                                    mGL.bindTexture(mGL.TEXTURE_2D, null);
                                }
                                else if( te.mType===me.TEXTYPE.CUBEMAP )
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, te.mObjectID);
                                    mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                                }
                            };

        me.UpdateTexture =  function( tex, x0, y0, xres, yres, buffer )
                            {
                                var glFoTy = iFormatPI2GL( tex.mFormat );
                                if( tex.mType===me.TEXTYPE.T2D )
                                {
                                    mGL.activeTexture( mGL.TEXTURE0);
                                    mGL.bindTexture( mGL.TEXTURE_2D, tex.mObjectID );
                                    mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, tex.mVFlip );
                                    mGL.texSubImage2D( mGL.TEXTURE_2D, 0, x0, y0, xres, yres, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.bindTexture( mGL.TEXTURE_2D, null );
                                    mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                }
                            };

        me.UpdateTextureFromImage = function( tex, image )
                                {
                                    var glFoTy = iFormatPI2GL( tex.mFormat );
                                    if( tex.mType===me.TEXTYPE.T2D )
                                    {
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture( mGL.TEXTURE_2D, tex.mObjectID );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, tex.mVFlip );
                                        mGL.texImage2D(  mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image );
                                        mGL.bindTexture( mGL.TEXTURE_2D, null );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
                                };

        me.DestroyTexture = function( te )
                            {
                                 mGL.deleteTexture( te.mObjectID );
                            };

        me.AttachTextures = function (num, t0, t1, t2, t3) 
                            {
                                if (num > 0 && t0 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                         if (t0.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t0.mObjectID);
                                    else if (t0.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t0.mObjectID);
                                    else if (t0.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t0.mObjectID);
                                }

                                if (num > 1 && t1 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE1);
                                         if (t1.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t1.mObjectID);
                                    else if (t1.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t1.mObjectID);
                                    else if (t1.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t1.mObjectID);
                                }

                                if (num > 2 && t2 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE2);
                                         if (t2.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t2.mObjectID);
                                    else if (t2.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t2.mObjectID);
                                    else if (t2.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t2.mObjectID);
                                }

                                if (num > 3 && t3 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE3);
                                         if (t3.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t3.mObjectID);
                                    else if (t3.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t3.mObjectID);
                                    else if (t3.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t3.mObjectID);
                                }
                            };

        me.DettachTextures = function()
                             {
                                mGL.activeTexture(mGL.TEXTURE0);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE1);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE2);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE3);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                             };

        me.CreateRenderTarget = function ( color0, color1, color2, color3, depth, wantZbuffer )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if (depth === null)
                                    {
                                        if( wantZbuffer===true )
                                        {
                                            var zb = mGL.createRenderbuffer();
                                            mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);
                                            mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, color0.mXres, color0.mYres);

                                            mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                        }
                                    }
                                    else
                                    {
                                        mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.TEXTURE_2D, depth.mObjectID, 0);
                                    }

                                    if( color0 !=null ) mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_2D, color0.mObjectID, 0);

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                        return null;

                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mTex0: color0 };
                                };

        me.DestroyRenderTarget = function ( tex )
                                 {
                                     mGL.deleteFramebuffer(tex.mObjectID);
                                 };

        me.SetRenderTarget = function (tex)
                             {
                                if( tex===null )
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                else
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, tex.mObjectID);

                                //mGL.drawBuffers([mGL.COLOR_ATTACHMENT0, mGL.COLOR_ATTACHMENT1]);
                             };

        me.CreateRenderTargetNew = function ( wantColor0, wantZbuffer, xres, yres, samples )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if( wantZbuffer===true )
                                    {
                                        var zb = mGL.createRenderbuffer();
                                        mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);

                                        if( samples==1 )
                                        mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, xres, yres);
                                        else
                                        mGL.renderbufferStorageMultisample(mGL.RENDERBUFFER, samples, mGL.DEPTH_COMPONENT16, xres, yres);
                                        mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                    }

                                    if( wantColor0 )
                                    {
                                        var cb = mGL.createRenderbuffer();
                                        mGL.bindRenderbuffer(mGL.RENDERBUFFER, cb);
                                        if( samples==1 )
                                        mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.RGBA8, xres, yres);
                                        else
                                        mGL.renderbufferStorageMultisample(mGL.RENDERBUFFER, samples, mGL.RGBA8, xres, yres);
                                        mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.RENDERBUFFER, cb);
                                    }

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                    {
                                        return null;
                                    }
                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mXres: xres, mYres:yres, mTex0: color0 };
                                };

        me.CreateRenderTargetCubeMap = function ( color0, depth, wantZbuffer )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if (depth === null)
                                    {
                                        if( wantZbuffer===true )
                                        {
                                            var zb = mGL.createRenderbuffer();
                                            mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);
                                            mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, color0.mXres, color0.mYres);
                                            mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                        }
                                    }
                                    else
                                    {
                                        mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.TEXTURE_2D, depth.mObjectID, 0);
                                    }

                                    if( color0 !=null ) mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_CUBE_MAP_POSITIVE_X, color0.mObjectID, 0);

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                        return null;

                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mTex0: color0 };
                                };

        me.SetRenderTargetCubeMap = function (fbo, face)
                             {
                                if( fbo===null )
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                else
                                {
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, fbo.mObjectID);
                                    mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_CUBE_MAP_POSITIVE_X+face, fbo.mTex0.mObjectID, 0);
                                }
                             };


        me.BlitRenderTarget = function( dst, src )
                                {
                                    mGL.bindFramebuffer(mGL.READ_FRAMEBUFFER, src.mObjectID);
                                    mGL.bindFramebuffer(mGL.DRAW_FRAMEBUFFER, dst.mObjectID);
                                    mGL.clearBufferfv(mGL.COLOR, 0, [0.0, 0.0, 0.0, 1.0]);
                                    mGL.blitFramebuffer( 0, 0, src.mXres, src.mYres,
                                                         0, 0, src.mXres, src.mYres,
                                                         mGL.COLOR_BUFFER_BIT, mGL.LINEAR
                                    );
                                };

        me.SetViewport = function( vp )
                         {
                              mGL.viewport( vp[0], vp[1], vp[2], vp[3] );
                         };

        me.SetWriteMask = function( c0, c1, c2, c3, z )
                          {
                              mGL.depthMask(z);
                              mGL.colorMask(c0,c0,c0,c0);
                          };

        me.SetState = function( stateName, stateValue )
                      {
                            if (stateName === me.RENDSTGATE.WIREFRAME)
                            {
                                if( stateValue ) mGL.polygonMode( mGL.FRONT_AND_BACK, mGL.LINE );
                                else             mGL.polygonMode( mGL.FRONT_AND_BACK, mGL.FILL );
                            }
                            else if (stateName === me.RENDSTGATE.FRONT_FACE)
                            {
                                if( stateValue ) mGL.cullFace( mGL.BACK );
                                else             mGL.cullFace( mGL.FRONT );
                            }
                            else if (stateName === me.RENDSTGATE.CULL_FACE)
                            {
                                if( stateValue ) mGL.enable( mGL.CULL_FACE );
                                else             mGL.disable( mGL.CULL_FACE );
                            }
                            else if (stateName === me.RENDSTGATE.DEPTH_TEST)
                            {
                                if( stateValue ) mGL.enable( mGL.DEPTH_TEST );
                                else             mGL.disable( mGL.DEPTH_TEST );
                            }
                            else if (stateName === me.RENDSTGATE.ALPHA_TO_COVERAGE)
                            {
                                if( stateValue ) { mGL.enable(  mGL.SAMPLE_ALPHA_TO_COVERAGE ); }
                                else             { mGL.disable( mGL.SAMPLE_ALPHA_TO_COVERAGE ); }
                            }
                      };

        me.SetMultisample = function( v)
                    {
                        if( v===true )
                        {
                            mGL.enable(mGL.SAMPLE_COVERAGE);
                            mGL.sampleCoverage(1.0, false);
                        }
                        else
                        {
                            mGL.disable(mGL.SAMPLE_COVERAGE);
                        }
                    };

        me.GetTranslatedShaderSource = function (shader) 
                          {
                            if( mGL===null ) return null;
                            if( mDebugShader===null ) return null;
                            let vfs = mGL.getAttachedShaders(shader.mProgram);
                            let str = mDebugShader.getTranslatedShaderSource(vfs[1]);
                            let parts = str.split("GLSL END"); str = (parts.length<2) ? str : parts[1];
                            return str;
                          };

        me.CreateShader = function (vsSource, fsSource, preventCache, forceSynch, onResolve) 
                          {
                            if( mGL===null ) return;

                            var vs = mGL.createShader( mGL.VERTEX_SHADER   );
                            var fs = mGL.createShader( mGL.FRAGMENT_SHADER );

                            vsSource = mShaderHeader[0] + vsSource;
                            fsSource = mShaderHeader[1] + fsSource;

                            if( preventCache )
                            {
                                let vran = Math.random().toString(36).substring(7);
                                let fran = Math.random().toString(36).substring(7);
                                vsSource += "\n#define K" + vran + "\n";
                                fsSource += "\n#define K" + fran + "\n";
                            }

                            var timeStart = getRealTime();

                            mGL.shaderSource(vs, vsSource);
                            mGL.shaderSource(fs, fsSource);
                            mGL.compileShader(vs);
                            mGL.compileShader(fs);

                            var pr = mGL.createProgram();
                            mGL.attachShader(pr, vs);
                            mGL.attachShader(pr, fs);
                            mGL.linkProgram(pr);

                            //-------------
                            let checkErrors = function()
                            {
                                if (!mGL.getProgramParameter(pr, mGL.LINK_STATUS))
                                {
                                    // vs error
                                    if (!mGL.getShaderParameter(vs, mGL.COMPILE_STATUS))
                                    {
                                        let vsLog = mGL.getShaderInfoLog(vs);
                                        onResolve(false, { mErrorType: 0, mErrorStr: vsLog });
                                        mGL.deleteProgram(pr);
                                    }
                                    // fs error
                                    else if (!mGL.getShaderParameter(fs, mGL.COMPILE_STATUS))
                                    {
                                        let fsLog = mGL.getShaderInfoLog(fs);
                                        onResolve(false, { mErrorType: 1, mErrorStr: fsLog });
                                        mGL.deleteProgram(pr);
                                    }
                                    // link error
                                    else
                                    {
                                        let infoLog = mGL.getProgramInfoLog(pr);
                                        onResolve(false, { mErrorType: 2, mErrorStr: infoLog });
                                        mGL.deleteProgram(pr);
                                    }
                                }
                                // no errors
                                else
                                {
                                    let compilationTime = getRealTime() - timeStart;
                                    onResolve(true, { mProgram: pr, mTime: compilationTime });
                                }
                            };

                            // check compilation
                            if (mAsynchCompile === null || forceSynch===true )
                            {
                                checkErrors();
                            }
                            else
                            {
                                let loopCheckCompletion = function ()
                                {
                                    if( mGL.getProgramParameter(pr, mAsynchCompile.COMPLETION_STATUS_KHR) === true )
                                        checkErrors();
                                    else
                                        setTimeout(loopCheckCompletion, 10);
                                };
                                setTimeout(loopCheckCompletion, 10);
                            }
                        };

        me.AttachShader = function( shader )
                          {
                                if( shader===null )
                                {
                                    mBindedShader = null;
                                    mGL.useProgram( null );
                                }
                                else
                                {
                                    mBindedShader = shader;
                                    mGL.useProgram(shader.mProgram);
                                }
                          };

        me.DetachShader = function ()
                        {
                            mGL.useProgram(null);
                        };

        me.DestroyShader = function( tex )
                        {
                            mGL.deleteProgram(tex.mProgram);
                        };

        me.GetAttribLocation = function (shader, name)
                        {
                            return mGL.getAttribLocation(shader.mProgram, name);
                        };

        me.SetShaderConstantLocation = function (shader, name)
                        {
                            return mGL.getUniformLocation(shader.mProgram, name);
                        };

        me.SetShaderConstantMat4F = function( uname, params, istranspose )
                        {
                            var program = mBindedShader;

                            let pos = mGL.getUniformLocation( program.mProgram, uname );
                            if( pos===null )
                                return false;

                            if( istranspose===false )
                            {
                                var tmp = new Float32Array( [ params[0], params[4], params[ 8], params[12],
                                                              params[1], params[5], params[ 9], params[13],
                                                              params[2], params[6], params[10], params[14],
                                                              params[3], params[7], params[11], params[15] ] );
	                            mGL.uniformMatrix4fv(pos,false,tmp);
                            }
                            else
                                mGL.uniformMatrix4fv(pos,false,new Float32Array(params) );
                            return true;
                        };

        me.SetShaderConstant1F_Pos = function(pos, x)
                        {
                            mGL.uniform1f(pos, x);
                            return true;
                        };

        me.SetShaderConstant1FV_Pos = function(pos, x)
                        {
                            mGL.uniform1fv(pos, x);
                            return true;
                        };

        me.SetShaderConstant1F = function( uname, x )
                        {
                            var pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1f(pos, x);
                            return true;
                        };

        me.SetShaderConstant1I = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1i(pos, x);
                            return true;
                        };
        me.SetShaderConstant1I_Pos = function(pos, x)
                        {
                            mGL.uniform1i(pos, x);
                            return true;
                        };


        me.SetShaderConstant2F = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform2fv(pos, x);
                            return true;
                        };

        me.SetShaderConstant3F = function(uname, x, y, z)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform3f(pos, x, y, z);
                            return true;
                        };

        me.SetShaderConstant1FV = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1fv(pos, new Float32Array(x));
                            return true;
                        };

        me.SetShaderConstant3FV = function(uname, x) 
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform3fv(pos, new Float32Array(x) );
                            return true;
                        };

        me.SetShaderConstant4FV = function(uname, x) 
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform4fv(pos, new Float32Array(x) );
                            return true;
                        };

        me.SetShaderTextureUnit = function( uname, unit )
                        {
                            var program = mBindedShader;
                            let pos = mGL.getUniformLocation(program.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform1i(pos, unit);
                            return true;
                        };

        me.CreateVertexArray = function( data, mode )
                        {
                            let id = mGL.createBuffer();
                            mGL.bindBuffer(mGL.ARRAY_BUFFER, id);
                            if (mode === me.BUFTYPE.STATIC)
                                mGL.bufferData(mGL.ARRAY_BUFFER, data, mGL.STATIC_DRAW);
                            else
                                mGL.bufferData(mGL.ARRAY_BUFFER, data, mGL.DYNAMIC_DRAW);
                            return { mObject: id };
                        };

        me.CreateIndexArray = function( data, mode )
                        {
                            let id = mGL.createBuffer();
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, id );
                            if (mode === me.BUFTYPE.STATIC)
                                mGL.bufferData(mGL.ELEMENT_ARRAY_BUFFER, data, mGL.STATIC_DRAW);
                            else
                                mGL.bufferData(mGL.ELEMENT_ARRAY_BUFFER, data, mGL.DYNAMIC_DRAW);
                            return { mObject: id };
                        };

        me.DestroyArray = function( tex )
                        {
                            mGL.destroyBuffer(tex.mObject);
                        };

        me.AttachVertexArray = function( tex, attribs, pos )
                        {
                            let shader = mBindedShader;

                            mGL.bindBuffer( mGL.ARRAY_BUFFER, tex.mObject);

                            var num = attribs.mChannels.length;
                            var stride = attribs.mStride;

                            var offset = 0;
                            for (var i = 0; i < num; i++)
                            {
                                var id = pos[i];
                                mGL.enableVertexAttribArray(id);
                                var dtype = mGL.FLOAT;
                                var dsize = 4;
                                     if( attribs.mChannels[i].mType === me.TYPE.UINT8   ) { dtype = mGL.UNSIGNED_BYTE;  dsize = 1; }
                                else if( attribs.mChannels[i].mType === me.TYPE.UINT16  ) { dtype = mGL.UNSIGNED_SHORT; dsize = 2; }
                                else if( attribs.mChannels[i].mType === me.TYPE.FLOAT32 ) { dtype = mGL.FLOAT;          dsize = 4; }
                                mGL.vertexAttribPointer(id, attribs.mChannels[i].mNumComponents, dtype, attribs.mChannels[i].mNormalize, stride, offset);
                                offset += attribs.mChannels[i].mNumComponents * dsize;
                            }
                        };

        me.AttachIndexArray = function( tex )
                        {
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, tex.mObject);
                        };

        me.DetachVertexArray = function (tex, attribs)
                        {
                            let num = attribs.mChannels.length;
                            for (let i = 0; i < num; i++)
                                mGL.disableVertexAttribArray(i);
                            mGL.bindBuffer(mGL.ARRAY_BUFFER, null);
                        };

        me.DetachIndexArray = function( tex )
                        {
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, null);
                        };

        me.DrawPrimitive = function( typeOfPrimitive, num, useIndexArray, numInstances )
                        {
                            let glType = mGL.POINTS;
                            if( typeOfPrimitive===me.PRIMTYPE.POINTS ) glType = mGL.POINTS;
                            if( typeOfPrimitive===me.PRIMTYPE.LINES ) glType = mGL.LINES;
                            if( typeOfPrimitive===me.PRIMTYPE.LINE_LOOP ) glType = mGL.LINE_LOOP;
                            if( typeOfPrimitive===me.PRIMTYPE.LINE_STRIP ) glType = mGL.LINE_STRIP;
                            if( typeOfPrimitive===me.PRIMTYPE.TRIANGLES ) glType = mGL.TRIANGLES;
                            if( typeOfPrimitive===me.PRIMTYPE.TRIANGLE_STRIP ) glType = mGL.TRIANGLE_STRIP;

                            if( numInstances<=1 )
                            {
  	                            if( useIndexArray ) mGL.drawElements( glType, num, mGL.UNSIGNED_SHORT, 0 );
	                            else                mGL.drawArrays( glType, 0, num );
                            }
                            else
                            {
                                mGL.drawArraysInstanced(glType, 0, num, numInstances);
                                mGL.drawElementsInstanced( glType, num, mGL.UNSIGNED_SHORT, 0, numInstances);
                            }
                        };


        me.DrawFullScreenTriangle_XY = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Tri );
                            mGL.vertexAttribPointer( vpos, 2, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays( mGL.TRIANGLES, 0, 3 );
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        };


        me.DrawUnitQuad_XY = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Quad );
                            mGL.vertexAttribPointer( vpos, 2, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays( mGL.TRIANGLES, 0, 6 );
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        };

        me.DrawUnitCube_XYZ_NOR = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePosNor );
                            mGL.vertexAttribPointer( vpos[0], 3, mGL.FLOAT, false, 0, 0 );
                            mGL.vertexAttribPointer( vpos[1], 3, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos[0] );
                            mGL.enableVertexAttribArray( vpos[1] );
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 0, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 4, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 8, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 12, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 16, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 20, 4);
                            mGL.disableVertexAttribArray( vpos[0] );
                            mGL.disableVertexAttribArray( vpos[1] );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        }

        me.DrawUnitCube_XYZ = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePos );
                            mGL.vertexAttribPointer( vpos, 3, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 0, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 4, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 8, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 12, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 16, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 20, 4);
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        }

        me.SetBlend = function( enabled )
                    {
                        if( enabled )
                        {
                            mGL.enable( mGL.BLEND );
                            mGL.blendEquationSeparate( mGL.FUNC_ADD, mGL.FUNC_ADD );
                            mGL.blendFuncSeparate( mGL.SRC_ALPHA, mGL.ONE_MINUS_SRC_ALPHA, mGL.ONE, mGL.ONE_MINUS_SRC_ALPHA );
                        }
                        else
                        {
                            mGL.disable( mGL.BLEND );
                        }
                    };

        me.GetPixelData = function( data, offset, xres, yres )
                        {
                            mGL.readPixels(0, 0, xres, yres, mGL.RGBA, mGL.UNSIGNED_BYTE, data, offset);
                        };

        me.GetPixelDataRenderTarget = function( obj, data, xres, yres )
                        {
                            mGL.bindFramebuffer(mGL.FRAMEBUFFER, obj.mObjectID);
                            mGL.readBuffer(mGL.COLOR_ATTACHMENT0);
                            mGL.readPixels(0, 0, xres, yres, mGL.RGBA, mGL.FLOAT, data, 0);
                            mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                        };
    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piShading
//
//==============================================================================

function smoothstep(a, b, x)
{
    x = (x - a) / (b - a);
    if (x < 0) x = 0; else if (x > 1) x = 1;
    return x * x * (3.0 - 2.0 * x);
}

function clamp01(x)
{
    if( x < 0.0 ) x = 0.0;
    if( x > 1.0 ) x = 1.0;
    return x;
}

function clamp(x, a, b)
{
    if( x < a ) x = a;
    if( x > b ) x = b;
    return x;
}

function screen(a, b)
{
    return 1.0 - (1.0 - a) * (1.0 - b);
}

function parabola(x)
{
    return 4.0 * x * (1.0 - x);
}

function min(a, b)
{
    return (a < b) ? a : b;
}

function max(a, b)
{
    return (a > b) ? a : b;
}

function noise( x )
{
    function grad(i, j, x, y)
    {
        var h = 7 * i + 131 * j;
        h = (h << 13) ^ h;
        h = (h * (h * h * 15731 + 789221) + 1376312589);

        var rx = (h & 0x20000000) ? x : -x;
        var ry = (h & 0x10000000) ? y : -y;

        return rx + ry;
    }

    var i = [ Math.floor(x[0]), Math.floor(x[1]) ];
    var f = [ x[0] - i[0], x[1] - i[1] ];
    var w = [ f[0]*f[0]*(3.0-2.0*f[0]), f[1]*f[1]*(3.0-2.0*f[1]) ];

    var a = grad( i[0]+0, i[1]+0, f[0]+0.0, f[1]+0.0 );
    var b = grad( i[0]+1, i[1]+0, f[0]-1.0, f[1]+0.0 );
    var c = grad( i[0]+0, i[1]+1, f[0]+0.0, f[1]-1.0 );
    var d = grad( i[0]+1, i[1]+1, f[0]-1.0, f[1]-1.0 );

    return a + (b-a)*w[0] + (c-a)*w[1] + (a-b-c+d)*w[0]*w[1];
}//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piVecTypes
//
//==============================================================================


function vec3( a, b, c )
{
    return [ a, b, c ];
}

function add( a, b )
{
    return [ a[0]+b[0], a[1]+b[1], a[2]+b[2] ];
}

function sub( a, b )
{
    return [ a[0]-b[0], a[1]-b[1], a[2]-b[2] ];
}

function mul( a, s ) 
{
    return [ a[0]*s, a[1]*s, a[2]*s ];
}

function cross( a, b )
{
    return [ a[1]*b[2] - a[2]*b[1],
             a[2]*b[0] - a[0]*b[2],
             a[0]*b[1] - a[1]*b[0] ];
}

function dot( a, b ) 
{
    return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
}

function normalize( v ) 
{
    var is = 1.0 / Math.sqrt( v[0]*v[0] + v[1]*v[1] + v[2]*v[2] );
    return [ v[0]*is, v[1]*is, v[2]*is ];
}

function createCirclePoint( cen, uuu, vvv, rad, s, t )
{
    return [ cen[0] + rad*(uuu[0]*s + vvv[0]*t),
             cen[1] + rad*(uuu[1]*s + vvv[1]*t),
             cen[2] + rad*(uuu[2]*s + vvv[2]*t) ];
}

function createTangent( a, b, c )
{
    var cb = normalize( [ c[0]-b[0], c[1]-b[1], c[2]-b[2] ] );
    var ba = normalize( [ b[0]-a[0], b[1]-a[1], b[2]-a[2] ] );
    return normalize( [ ba[0]+cb[0], ba[1]+cb[1], ba[2]+cb[2] ] );

}

//===================================

function vec4( a, b, c, d )
{
    return [ a, b, c, d ];
}

function getXYZ( v )
{
    return [ v[0], v[1], v[2] ];
}

//===================================

function setIdentity()
{
    return [ 1.0, 0.0, 0.0, 0.0,
             0.0, 1.0, 0.0, 0.0,
             0.0, 0.0, 1.0, 0.0,
             0.0, 0.0, 0.0, 1.0 ];
}

function setRotationX( t )
{
    var sint = Math.sin(t);
    var cost = Math.cos(t);

    return [ 1.0,   0.0,   0.0, 0.0,
             0.0,  cost, -sint, 0.0, 
             0.0,  sint,  cost, 0.0,
             0.0,   0.0,   0.0, 1.0 ];
}

function setRotationY( t )
{
    var sint = Math.sin(t);
    var cost = Math.cos(t);

    return [ cost, 0.0, -sint, 0.0,
              0.0, 1.0,   0.0, 0.0, 
             sint, 0.0,  cost, 0.0,
              0.0, 0.0,   0.0, 1.0 ];
}

function extractRotationEuler( m)
{
    var res = [];
    if (m[0] == 1.0)
    {
        res[0] = Math.atan2(m[2], m[11]);
        res[1] = 0.0;
        res[2] = 0.0;

    }
    else if (m[0] == -1.0)
    {
        res[0] = Math.atan2( m[2], m[11]);
        res[1] = 0.0;
        res[2] = 0.0;
    }
    else
    {
        res[0] = Math.atan2( -m[9], m[10]);
        res[1] = Math.atan2( m[8], Math.sqrt(m[9]*m[9] + m[10]*m[10]));
        res[2] = Math.atan2( m[4], m[0]);
    }
    return res;
}

function setFromQuaternion( q )
{
    var ww = q[3]*q[3];
    var xx = q[0]*q[0];
    var yy = q[1]*q[1];
    var zz = q[2]*q[2];

    return [ ww+xx-yy-zz,                   2.0*(q[0]*q[1] - q[3]*q[2]), 2.0*(q[0]*q[2] + q[3]*q[1]), 0.0,
               2.0*(q[0]*q[1] + q[3]*q[2]),   ww-xx+yy-zz,                 2.0*(q[1]*q[2] - q[3]*q[0]), 0.0,
               2.0*(q[0]*q[2] - q[3]*q[1]),   2.0*(q[1]*q[2] + q[3]*q[0]), ww-xx-yy+zz,                 0.0,
               0.0,                           0.0,                         0.0,                         1.0 ];
}

function setPerspective( fovy, aspect, znear, zfar )
{
    var tan = Math.tan(fovy * Math.PI/180.0);
    var x = 1.0 / (tan*aspect);
    var y = 1.0 / (tan);
    var c = -(zfar + znear) / ( zfar - znear);
    var d = -(2.0 * zfar * znear) / (zfar - znear);

    return [ x,    0.0,  0.0,  0.0,
             0.0,  y,    0.0,  0.0,
             0.0,  0.0,  c,     d,
             0.0,  0.0, -1.0,  0.0 ];
}

function setLookAt( eye, tar, up )
{
    var dir = [ -tar[0]+eye[0], -tar[1]+eye[1], -tar[2]+eye[2] ];

	var m00 = dir[2]*up[1] - dir[1]*up[2]; 
    var m01 = dir[0]*up[2] - dir[2]*up[0];
    var m02 = dir[1]*up[0] - dir[0]*up[1];
    var im = 1.0/Math.sqrt( m00*m00 + m01*m01 + m02*m02 );
    m00 *= im;
    m01 *= im;
    m02 *= im;

	var m04 = m02*dir[1] - m01*dir[2]; 
    var m05 = m00*dir[2] - m02*dir[0];
    var m06 = m01*dir[0] - m00*dir[1];
    im = 1.0/Math.sqrt( m04*m04 + m05*m05 + m06*m06 );
    m04 *= im;
    m05 *= im;
    m06 *= im;

	var m08 = dir[0];
	var m09 = dir[1];
	var m10 = dir[2];
    im = 1.0/Math.sqrt( m08*m08 + m09*m09 + m10*m10 );
    m08 *= im;
    m09 *= im;
    m10 *= im;

	var m03 = -(m00*eye[0] + m01*eye[1] + m02*eye[2] );
	var m07 = -(m04*eye[0] + m05*eye[1] + m06*eye[2] );
	var m11 = -(m08*eye[0] + m09*eye[1] + m10*eye[2] );

    return [ m00, m01, m02, m03,
             m04, m05, m06, m07,
             m08, m09, m10, m11,
             0.0, 0.0, 0.0, 1.0 ];
}


function setOrtho( left, right, bottom, top, znear, zfar )
{
   var x = 2.0 / (right - left);
   var y = 2.0 / (top - bottom);
   var a = (right + left) / (right - left);
   var b = (top + bottom) / (top - bottom);
   var c = -2.0 / (zfar - znear);
   var d = -(zfar + znear) / ( zfar - znear);

   return [  x, 0.0, 0.0,   a,
           0.0,   y, 0.0,   b,
           0.0, 0.0,   c,   d,
           0.0, 0.0, 0.0, 1.0 ];
}

function setTranslation( p )
{
    return [ 1.0, 0.0, 0.0, p[0],
             0.0, 1.0, 0.0, p[1],
             0.0, 0.0, 1.0, p[2],
             0.0, 0.0, 0.0, 1.0 ];
}

function setScale( s )
{
    return [ s[0], 0.0,  0.0,  0.0,
             0.0,  s[1], 0.0,  0.0,
             0.0,  0.0,  s[2], 0.0,
             0.0,  0.0,  0.0,  1.0];
}

function setProjection( fov, znear, zfar )
{
    var x = 2.0 / (fov[3]+fov[2]);
    var y = 2.0 / (fov[0]+fov[1]);
    var a = (fov[3]-fov[2]) / (fov[3]+fov[2]);
    var b = (fov[0]-fov[1]) / (fov[0]+fov[1]);
    var c = -(zfar + znear) / ( zfar - znear);
    var d = -(2.0*zfar*znear) / (zfar - znear);
    return [   x, 0.0,    a, 0.0,
             0.0,   y,    b, 0.0,
             0.0, 0.0,    c,   d,
             0.0, 0.0, -1.0, 0.0 ];
   // inverse is:
   //return mat4x4( 1.0/x, 0.0f,  0.0f,   a/x,
   //               0.0f,  1.0/y, 0.0f,   b/x,
   //               0.0f,  0.0f,  0.0f,   -1.0,
   //               0.0f,  0.0f,  1.0f/d, c/d );
}


function invertFast( m )
{
    var inv = [
   
             m[5]  * m[10] * m[15] - 
             m[5]  * m[11] * m[14] - 
             m[9]  * m[6]  * m[15] + 
             m[9]  * m[7]  * m[14] +
             m[13] * m[6]  * m[11] - 
             m[13] * m[7]  * m[10],

             -m[1]  * m[10] * m[15] + 
              m[1]  * m[11] * m[14] + 
              m[9]  * m[2] * m[15] - 
              m[9]  * m[3] * m[14] - 
              m[13] * m[2] * m[11] + 
              m[13] * m[3] * m[10],

             m[1]  * m[6] * m[15] - 
             m[1]  * m[7] * m[14] - 
             m[5]  * m[2] * m[15] + 
             m[5]  * m[3] * m[14] + 
             m[13] * m[2] * m[7] - 
             m[13] * m[3] * m[6],

             -m[1] * m[6] * m[11] + 
              m[1] * m[7] * m[10] + 
              m[5] * m[2] * m[11] - 
              m[5] * m[3] * m[10] - 
              m[9] * m[2] * m[7] + 
              m[9] * m[3] * m[6],

             -m[4]  * m[10] * m[15] + 
              m[4]  * m[11] * m[14] + 
              m[8]  * m[6]  * m[15] - 
              m[8]  * m[7]  * m[14] - 
              m[12] * m[6]  * m[11] + 
              m[12] * m[7]  * m[10],

             m[0]  * m[10] * m[15] - 
             m[0]  * m[11] * m[14] - 
             m[8]  * m[2] * m[15] + 
             m[8]  * m[3] * m[14] + 
             m[12] * m[2] * m[11] - 
             m[12] * m[3] * m[10],

             -m[0]  * m[6] * m[15] + 
              m[0]  * m[7] * m[14] + 
              m[4]  * m[2] * m[15] - 
              m[4]  * m[3] * m[14] - 
              m[12] * m[2] * m[7] + 
              m[12] * m[3] * m[6],


             m[0] * m[6] * m[11] - 
             m[0] * m[7] * m[10] - 
             m[4] * m[2] * m[11] + 
             m[4] * m[3] * m[10] + 
             m[8] * m[2] * m[7] - 
             m[8] * m[3] * m[6],


             m[4]  * m[9] * m[15] - 
             m[4]  * m[11] * m[13] - 
             m[8]  * m[5] * m[15] + 
             m[8]  * m[7] * m[13] + 
             m[12] * m[5] * m[11] - 
             m[12] * m[7] * m[9],



             -m[0]  * m[9] * m[15] + 
              m[0]  * m[11] * m[13] + 
              m[8]  * m[1] * m[15] - 
              m[8]  * m[3] * m[13] - 
              m[12] * m[1] * m[11] + 
              m[12] * m[3] * m[9],

              m[0]  * m[5] * m[15] - 
              m[0]  * m[7] * m[13] - 
              m[4]  * m[1] * m[15] + 
              m[4]  * m[3] * m[13] + 
              m[12] * m[1] * m[7] - 
              m[12] * m[3] * m[5],

              -m[0] * m[5] * m[11] + 
               m[0] * m[7] * m[9] + 
               m[4] * m[1] * m[11] - 
               m[4] * m[3] * m[9] - 
               m[8] * m[1] * m[7] + 
               m[8] * m[3] * m[5],

              -m[4]  * m[9] * m[14] + 
               m[4]  * m[10] * m[13] +
               m[8]  * m[5] * m[14] - 
               m[8]  * m[6] * m[13] - 
               m[12] * m[5] * m[10] + 
               m[12] * m[6] * m[9],

              m[0]  * m[9] * m[14] - 
              m[0]  * m[10] * m[13] - 
              m[8]  * m[1] * m[14] + 
              m[8]  * m[2] * m[13] + 
              m[12] * m[1] * m[10] - 
              m[12] * m[2] * m[9],

              -m[0]  * m[5] * m[14] + 
               m[0]  * m[6] * m[13] + 
               m[4]  * m[1] * m[14] - 
               m[4]  * m[2] * m[13] - 
               m[12] * m[1] * m[6] + 
               m[12] * m[2] * m[5],

              m[0] * m[5] * m[10] - 
              m[0] * m[6] * m[9] - 
              m[4] * m[1] * m[10] + 
              m[4] * m[2] * m[9] + 
              m[8] * m[1] * m[6] - 
              m[8] * m[2] * m[5] ];

    var det = m[0] * inv[0] + m[1] * inv[4] + m[2] * inv[8] + m[3] * inv[12];

    det = 1.0/det;

    for( var i = 0; i<16; i++ ) inv[i] = inv[i] * det;

    return inv;
}

function matMul( a, b )
{
    var res = [];
    for( var i=0; i<4; i++ )
    {
        var x = a[4*i+0];
        var y = a[4*i+1];
        var z = a[4*i+2];
        var w = a[4*i+3];

        res[4*i+0] = x * b[ 0] + y * b[ 4] + z * b[ 8] + w * b[12];
        res[4*i+1] = x * b[ 1] + y * b[ 5] + z * b[ 9] + w * b[13];
        res[4*i+2] = x * b[ 2] + y * b[ 6] + z * b[10] + w * b[14];
        res[4*i+3] = x * b[ 3] + y * b[ 7] + z * b[11] + w * b[15];
    }

    return res;
}

function matMulpoint( m, v )
{
    return [ m[0]*v[0] + m[1]*v[1] + m[ 2]*v[2] + m[ 3],
             m[4]*v[0] + m[5]*v[1] + m[ 6]*v[2] + m[ 7],
             m[8]*v[0] + m[9]*v[1] + m[10]*v[2] + m[11] ];
}

function matMulvec( m, v )
{
    return [ m[0]*v[0] + m[1]*v[1] + m[ 2]*v[2],
             m[4]*v[0] + m[5]*v[1] + m[ 6]*v[2],
             m[8]*v[0] + m[9]*v[1] + m[10]*v[2] ];
}


function bound3( infi )
{
    return [ infi, -infi, infi, -infi, infi, -infi ];
}

function bound3_include( a, p )
{
    return [
        (p[0]<a[0]) ? p[0] : a[0],
        (p[0]>a[1]) ? p[0] : a[1],
        (p[1]<a[2]) ? p[1] : a[2],
        (p[1]>a[3]) ? p[1] : a[3],
        (p[2]<a[4]) ? p[2] : a[4],
        (p[2]>a[5]) ? p[2] : a[5] ];
}

function bound3_center( b )
{
    return [ 0.5*(b[0]+b[1]),
             0.5*(b[2]+b[3]),
             0.5*(b[4]+b[5]) ];
}

function bound3_radius( b )
{
    return [ 0.5*(b[1]-b[0]),
             0.5*(b[3]-b[2]),
             0.5*(b[5]-b[4]) ];
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piWebVR
//
//==============================================================================

function WebVR( isVREnabledCallback, canvasElement )
{
    isVREnabledCallback(false);
    /*


    this.mSupportVR = false;
    this.mHMD = null;

    var me = this;
    var listVRDisplays = function (vrdevs) {
        for (var i = 0; i < vrdevs.length; i++)
        {
            if (vrdevs[i] instanceof VRDisplay)
            {
                me.mHMD = vrdevs[i];
                console.log("WebVR is available.");
                console.log(me.mHMD);
                break;
            }
        }

        isVREnabledCallback(true);
        me.mSupportVR = true;
    }

    if (navigator.getVRDisplays)
    {
        navigator.getVRDisplays().then(listVRDisplays);
    }

    isVREnabledCallback(false);
    this.mCanvas = canvasElement;
    */
}

WebVR.prototype.IsSupported = function()
{
    return false;
    //return this.mSupportVR;
}

WebVR.prototype.GetData = function( id )
{
    return {};
    /*
    var frameData = new VRFrameData();
    var s = this.mHMD.getFrameData(frameData);
    var ss = frameData.pose;
    
    var fovL = this.mHMD.getEyeParameters("left");
    var fovR = this.mHMD.getEyeParameters( "right" );

    // camera info
    var cPos = vec3(0.0, 0.0, 0.0);
    if (ss.position)
        cPos = vec3(-ss.position[0], -ss.position[1], -ss.position[2]);
    var rot = vec4(0.0, 0.0, 0.0, 0.0);
    if (ss.orientation)
        rot = vec4(ss.orientation[0], ss.orientation[1], ss.orientation[2], ss.orientation[3]);
    var cRot = setFromQuaternion(rot);
    var cTra = setTranslation(cPos);
    var cMat = matMul(invertFast(cRot), cTra);
    
    // per eye info
    var lTra = setTranslation( vec3(-fovL.offset[0], -fovL.offset[1], -fovL.offset[2]) );
    var lMat = matMul(lTra, cMat);
    var lPrj = [ Math.tan( fovL.fieldOfView.upDegrees * Math.PI/180.0),
                 Math.tan(fovL.fieldOfView.downDegrees * Math.PI / 180.0),
                 Math.tan(fovL.fieldOfView.leftDegrees * Math.PI / 180.0),
                 Math.tan(fovL.fieldOfView.rightDegrees * Math.PI / 180.0)];

    var rTra = setTranslation(vec3(-fovR.offset[0], -fovR.offset[1], -fovR.offset[2]));
    var rMat = matMul(rTra, cMat);
    var rPrj = [Math.tan(fovR.fieldOfView.upDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.downDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.leftDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.rightDegrees * Math.PI / 180.0)];

    return {
        mCamera   : { mCamera: cMat },
        mLeftEye  : { mVP:[0,0,fovL.renderWidth,fovL.renderHeight], mProjection:lPrj, mCamera:lMat },
        mRightEye : { mVP:[fovR.renderWidth/2,0,fovR.renderWidth,fovR.renderHeight], mProjection:rPrj, mCamera:rMat }
           };
    */
}

WebVR.prototype.Enable = function( id )
{
    /*
    this.mHMD.requestPresent([{ source: this.mCanvas }]).then(
        function ()
        {
        },
        function (err)
        {
            console.log("webVR : requestPresent failed.");
        }
    );
    */
}

WebVR.prototype.Disable = function( id )
{
    /*
    if (!this.mHMD.isPresenting)
    {
        return;
    }

    this.mHMD.exitPresent().then(
        function ()
        {
        },
        function (err)
        {
            console.log("webVR : exitPresent failed.");
        }
    );
    */
}

WebVR.prototype.RequestAnimationFrame = function (id)
{
    //this.mHMD.requestAnimationFrame(id);
}

WebVR.prototype.IsPresenting = function (id)
{
    /*
    if (this.mHMD.isPresenting)
    {
        return true;
    }
    */
    return false;
}

WebVR.prototype.Finish = function (id)
{
    /*
    if (this.mHMD.isPresenting)
    {
        this.mHMD.submitFrame();
    }
    */
}

//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piWebUtils
//
//==============================================================================


// RequestAnimationFrame
window.requestAnimFrame = ( function () { return window.requestAnimationFrame    || window.webkitRequestAnimationFrame ||
                                                 window.mozRequestAnimationFrame || window.oRequestAnimationFrame ||
                                                 window.msRequestAnimationFrame  || function( cb ) { window.setTimeout(cb,1000/60); };
                                        } )();

// performance.now
window.getRealTime = ( function() { if ("performance" in window ) return function() { return window.performance.now(); }
                                                                  return function() { return (new Date()).getTime(); }
                                  } )();

window.URL = window.URL || window.webkitURL;

navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;

function htmlEntities(str) 
{
    return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g,'&apos;');
}

function piDisableTouch()
{
    document.body.addEventListener('touchstart', function(e){ e.preventDefault(); });
}

var piGetTime = function ( timestamp )
{
    if (timestamp == 0)
        return "";
    return new Date(timestamp * 1000).toISOString().substr(0, 10);
}

function piGetCoords( obj )
{
    var x = 0;
    var y = 0; 
    do
    {
         x += obj.offsetLeft;
         y += obj.offsetTop;
    }while( obj = obj.offsetParent );

    return { mX:x, mY:y };
}

function piGetMouseCoords( ev, canvasElement )
{
    var pos = piGetCoords(canvasElement );
    var mcx =                        (ev.pageX - pos.mX) * canvasElement.width / canvasElement.offsetWidth;
    var mcy = canvasElement.height - (ev.pageY - pos.mY) * canvasElement.height / canvasElement.offsetHeight;

    return { mX: mcx, mY: mcy };

}

function piGetSourceElement( e )
{
    var ele = null;
    if( e.target )     ele = e.target;
    if( e.srcElement ) ele = e.srcElement;
    return ele;
}

function piRequestFullScreen( ele )
{
    if( ele==null ) ele =   document.documentElement;
         if( ele.requestFullscreen       ) ele.requestFullscreen();
    else if( ele.msRequestFullscreen     ) ele.msRequestFullscreen();
    else if( ele.mozRequestFullScreen    ) ele.mozRequestFullScreen();
    else if( ele.webkitRequestFullscreen ) ele.webkitRequestFullscreen( Element.ALLOW_KEYBOARD_INPUT );
}

function piIsFullScreen()
{
    return document.fullscreen || document.mozFullScreen || document.webkitIsFullScreen || document.msFullscreenElement || false;
}

function piExitFullScreen()
{
       if( document.exitFullscreen       ) document.exitFullscreen();
  else if( document.msExitFullscreen     ) document.msExitFullscreen();
  else if( document.mozCancelFullScreen  ) document.mozCancelFullScreen();
  else if( document.webkitExitFullscreen ) document.webkitExitFullscreen();
}

function piIsMobile()
{
    return (navigator.userAgent.match(/Android/i) ||
            navigator.userAgent.match(/webOS/i) ||
            navigator.userAgent.match(/iPhone/i) ||
            navigator.userAgent.match(/iPad/i) ||
            navigator.userAgent.match(/iPod/i) ||
            navigator.userAgent.match(/BlackBerry/i) ||
            navigator.userAgent.match(/Windows Phone/i)) ? true : false;
}

function piCreateGlContext( cv, useAlpha, useDepth, usePreserveBuffer, useSupersampling )
{
    var opts = { alpha: useAlpha, 
                 depth: useDepth, 
                 stencil: false, 
                 premultipliedAlpha: false, 
                 antialias: useSupersampling, 
                 preserveDrawingBuffer: usePreserveBuffer, 
                 powerPreference: "high-performance" }; // "low_power", "high_performance", "default"

    var gl = null;
    if( gl === null) gl = cv.getContext( "webgl2", opts );
    if( gl === null) gl = cv.getContext( "experimental-webgl2", opts );
    if( gl === null) gl = cv.getContext( "webgl", opts );
    if( gl === null) gl = cv.getContext( "experimental-webgl", opts );

    return gl;
}

function piCreateAudioContext()
{
    var res = null;
    try
    {
        if( window.AudioContext ) res = new AudioContext();
        if( res==null && window.webkitAudioContext ) res = new webkitAudioContext();
    }
    catch( e )
    {
        res = null;
    }
    return res;
}

function piHexColorToRGB(str) // "#ff3041"
{
    var rgb = parseInt(str.slice(1), 16);
    var r = (rgb >> 16) & 255;
    var g = (rgb >> 8) & 255;
    var b = (rgb >> 0) & 255;
    return [r, g, b];
}

function piCreateFPSCounter()
{
    var mFrame;
    var mTo;
    var mFPS;

    var iReset = function( time )
    {
        mFrame = 0;
        mTo = time;
        mFPS = 60.0;
    }

    var iCount = function( time )
    {
        mFrame++;

        if( (time-mTo)>500.0 )
        {
            mFPS = 1000.0*mFrame/(time-mTo);
            mFrame = 0;
            mTo = time;
            return true;
        }
        return false;
    }

    var iGetFPS = function()
    {
        return mFPS;
    }
    
    return { Reset : iReset, Count : iCount, GetFPS : iGetFPS };
}

function piCanMediaRecorded(canvas)
{
    if (typeof window.MediaRecorder !== 'function' || typeof canvas.captureStream !== 'function') {
        return false;
    }
    return true;
}

function piCreateMediaRecorder(isRecordingCallback, canvas) 
{
    if (piCanMediaRecorded(canvas) == false)
    {
        return null;
    }
    
    var options = { audioBitsPerSecond : 0, videoBitsPerSecond : 8000000 }; 
	     if (MediaRecorder.isTypeSupported('video/webm;codecs=h264')) options.mimeType = 'video/webm;codecs=h264';
    else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9' )) options.mimeType = 'video/webm;codecs=vp9';
    else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8' )) options.mimeType = 'video/webm;codecs=vp8';
    else                                                              options.mimeType = 'video/webm;';

    var mediaRecorder = new MediaRecorder(canvas.captureStream(), options);
    var chunks = [];
    
    mediaRecorder.ondataavailable = function(e) 
    {
        if (e.data.size > 0) 
        {
            chunks.push(e.data);
        }
    };
 
    mediaRecorder.onstart = function(){ 
        isRecordingCallback( true );
    };
    
    mediaRecorder.onstop = function()
    {
         isRecordingCallback( false );
         let blob     = new Blob(chunks, {type: "video/webm"});
         chunks       = [];
         let videoURL = window.URL.createObjectURL(blob);
         let url      = window.URL.createObjectURL(blob);
         let a        = document.createElement("a");
         document.body.appendChild(a);
         a.style      = "display: none";
         a.href       = url;
         a.download   = "capture.webm";
         a.click();
         window.URL.revokeObjectURL(url);
     };
    
    return mediaRecorder;
}

function piExportToEXR(width, height, numComponents, type, bytes)
{
    var bytesPerComponent = 0;
    if      (type=="Uint")   bytesPerComponent = 4; 
    else if (type=="Half")   bytesPerComponent = 2;
    else if (type=="Float")  bytesPerComponent = 4;

    var tHeader = 258 + (18 * numComponents + 1);
    var tTable = 8 * height;
    var tScanlines = height * (4 + 4 + (numComponents * bytesPerComponent * width));
    var tTotal = tHeader + tTable + tScanlines;

    //console.log("    header size = " + tHeader);
    //console.log("    table size = " + tTable);
    //console.log("    scanlines size = " + tScanlines);
    //console.log("    total = " + tTotal);

    var buffer = new ArrayBuffer(tTotal); 
    var data = new DataView(buffer);

    // Header
    {
        // Header : 4 bytes -> 0x76, 0x2f, 0x31, 0x01
        var c = 0;
        data.setUint8 (c++, 0x76);
        data.setUint8 (c++, 0x2f);
        data.setUint8 (c++, 0x31);
        data.setUint8 (c++, 0x01);

        // Version : 4 bytes -> 2, 0, 0, 0
        data.setUint8 (c++, 0x02);
        data.setUint8 (c++, 0x0);
        data.setUint8 (c++, 0x0);
        data.setUint8 (c++, 0x0);
        
        // Write channel info
        // Write attribute name : "channels"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x73);
            data.setUint8 (c++, 0x0);

            // Write attribute type : "chlist"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00);

            // Write attribute size : 18 x 3 + 1 = 55
            var attribSize = 18 * numComponents + 1;
            data.setUint8 (c++, attribSize); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            var i;
            for (i = 0; i < numComponents; i++)
            {
                // Attribute : "B" (42) "G" (47) "R" (52)
                if (i==0)       data.setUint8 (c++, 0x42);
                else if (i==1)  data.setUint8 (c++, 0x47);
                else if (i==2)  data.setUint8 (c++, 0x52);
                data.setUint8 (c++, 0x00);
                
                // Value : Float (2), Half (1), Uint (0)
                if      (type=="Uint")   data.setUint8 (c++, 0x00); 
                else if (type=="Half")   data.setUint8 (c++, 0x01);
                else if (type=="Float")  data.setUint8 (c++, 0x02);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);

                // Plinear
                data.setUint8 (c++, 0x01);

                // Reserved
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 

                // X sampling
                data.setUint8 (c++, 0x01); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                
                // Y sampling
                data.setUint8 (c++, 0x01);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
            }
            // End attribute
            data.setUint8 (c++, 0x00);
    
        // Write attribute name : "compression"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6d); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x00);

            // Write attribute type : "compression"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6d); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x00);

            // Write attribute size : "1"
            data.setUint8 (c++, 0x01); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // Write attribute value : "0" (None)
            data.setUint8 (c++, 0x00);

        // datawindow
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x00); 

            // box2i
            data.setUint8 (c++, 0x62); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x00);

            // size 16
            data.setUint8 (c++, 0x10); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0 3 2
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 

            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint32 (c, width-1, true);
            c += 4;
            
            data.setUint32 (c, height-1, true); 
            c += 4;

        // displayWindow
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x79); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x00);

            // box2i
            data.setUint8 (c++, 0x62); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x00); 

            // size 16
            data.setUint8 (c++, 0x10); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0 3 2
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint32 (c, width-1, true);
            c += 4;
            
            data.setUint32 (c, height-1, true); 
            c += 4;

        // lineOrder
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x4f); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00); 
            
            // lineOrder
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x4f); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00); 
            
            // size
            data.setUint8 (c++, 0x01);
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);
            
            // value 
            data.setUint8 (c++, 0x00);

        // PixelAspectRatio
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x41); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x52); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x00); 

            // float
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00);
        
            // size 4
            data.setUint8 (c++, 0x04); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 1.0
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x80); 
            data.setUint8 (c++, 0x3f);
        
        // screenWindowCenter
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x63);
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x43); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e);
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00);

            // v2f
            data.setUint8 (c++, 0x76); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x00);

            // size 8
            data.setUint8 (c++, 0x08); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

        // screenWindowWidth
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x00); 
            
            // float
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00); 

            // size
            data.setUint8 (c++, 0x04); 
            data.setUint8 (c++, 0x00);
            data.setUint8 (c++, 0x00);
            data.setUint8 (c++, 0x00);

            // value
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x80); 
            data.setUint8 (c++, 0x3f);

        // End of header
        data.setUint8 (c++, 0x00);
    }
    //console.log("header size = " + c);

    // Scanline table
    var initc = c + height * 8;
    for (var scanline = 0 ; scanline < height ; scanline ++)
    {
        var jump = initc + scanline * (8 + width * bytesPerComponent * numComponents); 
        data.setUint32 (c, jump, true);
        c += 4; 

        data.setUint32 (c, 0x00, true);
        c += 4;
    }
    //console.log("header + scanlines table size = " + c);

    // Scanlines
    for (var scanline = 0 ; scanline < height ; scanline ++)
    {
        // Scanline
        data.setUint32(c, scanline, true);
        c += 4;

        // size 24
        var size = width * numComponents * bytesPerComponent; 
        data.setUint32(c, size, true);
        c += 4;

        var numComponentsSource = 4; // number of components in the SOURCE image
        for (var component = 0; component < numComponents ; component ++) 
        {
            for (var pixel = 0 ; pixel < width ; pixel ++) 
            {
                // flip vertical, so we read OpenGL buffers without JS image flipping
                var v = bytes[(height-1-scanline) * width *numComponentsSource + pixel * numComponentsSource + (2-component)];
                if      (type=="Float") data.setFloat32(c, v, true);
                else if (type=="Half")  data.setUint16(c, v, true);

                c += bytesPerComponent;
            }
        }
    }
    //console.log("total size = " + c);
    return new Blob([buffer], {type: 'application/octet-stream'});
}


function piExportToWAV(numSamples, rate, bits, numChannels, words)
{
    let numBytes = numSamples * numChannels * bits/8;

    let buffer = new ArrayBuffer(44 + numBytes); 
    let data = new DataView(buffer);

    {
        data.setUint32( 0, 0x46464952, true );  // RIFF
        data.setUint32( 4, numBytes + 36, true);
        {
            data.setUint32( 8, 0x45564157, true );  // WAV_WAVE
            data.setUint32( 12, 0x20746D66, true );  // WAV_FMT
            {
                data.setUint32( 16, 16, true);
                data.setUint16( 20, 1, true ); // WAV_FORMAT_PCM
                data.setUint16( 22, numChannels, true);
                data.setUint32( 24, rate, true);
                data.setUint32( 28, rate*numChannels*bits / 8, true);
                data.setUint16( 32, numChannels*bits / 8, true);
                data.setUint16( 34, bits, true);
            }

            data.setUint32( 36, 0x61746164, true);  // WAV_DATA
            {
                data.setUint32( 40, numBytes, true);
                let numWords = numSamples * numChannels;
                for(let i=0; i<numWords; i++ )
                {
                    data.setInt16( 44 + i*2, words[i], true );
                }
            }
        }
    }


    //console.log("total size = " + c);
    return new Blob([buffer], {type: 'application/octet-stream'});
}

function piTriggerDownload(name, blob)
{
    let url = URL.createObjectURL(blob);
    let aElement = document.createElement("a");
    aElement.href     = url;
    aElement.target   = "_self";
    aElement.download = name;
    document.body.appendChild(aElement);
    aElement.click();
    document.body.removeChild(aElement);
}</script>
    <script>"use strict"

function bufferID_to_assetID( id )
{
    if( id===0 ) return '4dXGR8';
    if( id===1 ) return 'XsXGR8';
    if( id===2 ) return '4sXGR8';
    if( id===3 ) return 'XdfGR8';
    return 'none';
}
function assetID_to_bufferID( id )
{
    if( id==='4dXGR8' ) return 0;
    if( id==='XsXGR8' ) return 1;
    if( id==='4sXGR8' ) return 2;
    if( id==='XdfGR8' ) return 3;
    return -1;
}

function assetID_to_cubemapBuferID( id )
{
    if( id==='4dX3Rr' ) return 0;
    return -1;
}
function cubamepBufferID_to_assetID( id )
{
    if( id===0 ) return '4dX3Rr';
    return 'none';
}

function EffectPass( renderer, is20, isLowEnd, hasShaderTextureLOD, callback, obj, forceMuted, forcePaused, outputGainNode, copyProgram, id, effect  )
{
    this.mID = id;
    this.mInputs  = [null, null, null, null ];
    this.mOutputs = [null, null, null, null ];
    this.mSource = null;

    this.mGainNode = outputGainNode;
    this.mSoundShaderCompiled = false;

    this.mEffect = effect;
    this.mRenderer = renderer;
    this.mProgramCopy = copyProgram; 
    this.mCompilationTime = 0;

    this.mType = "none";
    this.mName = "none";
    this.mFrame = 0;

    this.mShaderTextureLOD = hasShaderTextureLOD;
    this.mIs20 = is20;
    this.mIsLowEnd = isLowEnd;
    this.mTextureCallbackFun = callback;
    this.mTextureCallbackObj = obj;
    this.mForceMuted = forceMuted;
    this.mForcePaused = forcePaused;
}

EffectPass.prototype.MakeHeader_Image = function()
{
    let header = "";

    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for( let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        // old API
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                  header += "uniform sampler2D iChannel" + i + ";\n";

        // new API (see shadertoy.com/view/wtdGW8)
        header += "uniform struct {\n";
             if( inp===null )                  header += "  sampler2D";
        else if( inp.mInfo.mType==="cubemap" ) header += "  samplerCube";
        else if( inp.mInfo.mType==="volume"  ) header += "  sampler3D";
        else                                  header += "  sampler2D";
        header +=        " sampler;\n";
        header += "  vec3  size;\n";
        header += "  float time;\n";
        header += "  int   loaded;\n";
        header += "}iCh" + i + ";\n";
    }
	header += "void mainImage( out vec4 c, in vec2 f );\n";
    header += "void st_assert( bool cond );\n";
    header += "void st_assert( bool cond, int v );\n";

    if( this.mIs20 ) 
    {
        header += "\nout vec4 shadertoy_out_color;\n" +
        "void st_assert( bool cond, int v ) {if(!cond){if(v==0)shadertoy_out_color.x=-1.0;else if(v==1)shadertoy_out_color.y=-1.0;else if(v==2)shadertoy_out_color.z=-1.0;else shadertoy_out_color.w=-1.0;}}\n" +
        "void st_assert( bool cond        ) {if(!cond)shadertoy_out_color.x=-1.0;}\n" +
        "void main( void )" +
        "{" +
            "shadertoy_out_color = vec4(1.0,1.0,1.0,1.0);" + 
            "vec4 color = vec4(0.0,0.0,0.0,1.0);" +
            "mainImage( color, gl_FragCoord.xy );" +
            "if(shadertoy_out_color.x<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(shadertoy_out_color.y<0.0) color=vec4(0.0,1.0,0.0,1.0);" +
            "if(shadertoy_out_color.z<0.0) color=vec4(0.0,0.0,1.0,1.0);" +
            "if(shadertoy_out_color.w<0.0) color=vec4(1.0,1.0,0.0,1.0);" +
            "shadertoy_out_color = vec4(color.xyz,1.0);" +
        "}";
    }
    else
    {
        header += "" +
        "void st_assert( bool cond, int v ) {if(!cond){if(v==0)gl_FragColor.x=-1.0;else if(v==1)gl_FragColor.y=-1.0;else if(v==2)gl_FragColor.z=-1.0;else gl_FragColor.w=-1.0;}}\n" +
        "void st_assert( bool cond        ) {if(!cond)gl_FragColor.x=-1.0;}\n" +
        "void main( void )" +
        "{" +
            "gl_FragColor = vec4(0.0,0.0,0.0,1.0);" + 
            "vec4 color = vec4(0.0,0.0,0.0,1.0);" +
            "mainImage( color, gl_FragCoord.xy );" +
            "color.w = 1.0;" +
            "if(gl_FragColor.w<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(gl_FragColor.x<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(gl_FragColor.y<0.0) color=vec4(0.0,1.0,0.0,1.0);" +
            "if(gl_FragColor.z<0.0) color=vec4(0.0,0.0,1.0,1.0);" +
            "if(gl_FragColor.w<0.0) color=vec4(1.0,1.0,0.0,1.0);" +
            "gl_FragColor = vec4(color.xyz,1.0);"+
        "}";
    }
    header += "\n";

    /*
    this.mImagePassFooterVR = "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 ) 
        this.mImagePassFooterVR += "\nout vec4 outColor;\n";
    this.mImagePassFooterVR += "void main( void )" +
    "{" +
        "vec4 color = vec4(0.0,0.0,0.0,1.0);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainVR( color, gl_FragCoord.xy-unViewport.xy, ro, rd );" +
        "color.w = 1.0;"
    if( this.mIs20 ) 
        this.mImagePassFooterVR +=  "outColor = color;}";
    else
        this.mImagePassFooterVR +=  "gl_FragColor = color;}";
    */
    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Buffer = function()
{
    let header = "";
    
    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                  header += "uniform sampler2D iChannel" + i + ";\n";
    }

	header += "void mainImage( out vec4 c,  in vec2 f );\n"

    if( this.mIs20 )
        header += "\nout vec4 outColor;\n";
    header += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(0.0,0.0,0.0,1.0);" +
        "mainImage( color, gl_FragCoord.xy );";
    if( this.mIs20 )
        header +="outColor = color; }";
    else
        header +="gl_FragColor = color; }";
    header += "\n";

    /*
    this.mImagePassFooterVR = "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 )
    this.mImagePassFooterVR += "\nout vec4 outColor;\n";
    this.mImagePassFooterVR += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(0.0,0.0,0.0,1.0);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainVR( color, gl_FragCoord.xy-unViewport.xy, ro, rd );";
    if( this.mIs20 )
        this.mImagePassFooterVR +="outColor = color; }";
    else
        this.mImagePassFooterVR +="gl_FragColor = color; }";
    */
    this.mHeader = header;
    this.mHeaderLength = 0;
}


EffectPass.prototype.MakeHeader_Cubemap = function()
{
    let header = "";
    
    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                   header += "uniform sampler2D iChannel" + i + ";\n";
    }

	header += "void mainCubemap( out vec4 c, in vec2 f, in vec3 ro, in vec3 rd );\n"

    header += "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 )
        header += "\nout vec4 outColor;\n";
    header += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(0.0,0.0,0.0,1.0);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainCubemap( color, gl_FragCoord.xy-unViewport.xy, ro, rd );";
    if( this.mIs20 )
        header +="outColor = color; }";
    else
        header +="gl_FragColor = color; }";
    header += "\n";

    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Sound = function()
{
    let header = "";

    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform float     iChannelTime[4];\n" +
              "uniform float     iTimeOffset;\n" +
              "uniform int       iSampleOffset;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n";

    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp!==null && inp.mInfo.mType==="cubemap" )
            header += "uniform samplerCube iChannel" + i + ";\n";
        else
            header += "uniform sampler2D iChannel" + i + ";\n";
    }
    header += "\n";
    header += "vec2 mainSound( in int samp, float time );\n";

    if( this.mIs20 )
    {
        header += "out vec4 outColor; void main()" +
            "{" +
            "float t = iTimeOffset + ((gl_FragCoord.x-0.5) + (gl_FragCoord.y-0.5)*512.0)/iSampleRate;" +
            "int   s = iSampleOffset + int(gl_FragCoord.y-0.2)*512 + int(gl_FragCoord.x-0.2);" +
            "vec2 y = mainSound( s, t );" +
            "vec2 v  = floor((0.5+0.5*y)*65536.0);" +
            "vec2 vl =   mod(v,256.0)/255.0;" +
            "vec2 vh = floor(v/256.0)/255.0;" +
            "outColor = vec4(vl.x,vh.x,vl.y,vh.y);" +
            "}";
    }
    else
    {
        header += "void main()" +
            "{" +
            "float t = iTimeOffset + ((gl_FragCoord.x-0.5) + (gl_FragCoord.y-0.5)*512.0)/iSampleRate;" +
            "vec2 y = mainSound( 0, t );" +
            "vec2 v  = floor((0.5+0.5*y)*65536.0);" +
            "vec2 vl =   mod(v,256.0)/255.0;" +
            "vec2 vh = floor(v/256.0)/255.0;" +
            "gl_FragColor = vec4(vl.x,vh.x,vl.y,vh.y);" +
            "}";
    }
    header += "\n";
    this.mHeader = header;
    this.mHeaderLength = 0;
}


EffectPass.prototype.MakeHeader_Common = function ()
{
    let header = "";
    let headerlength = 0;

    header += "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n";
    headerlength += 2;

    if (this.mIs20)
    {
        header += "out vec4 outColor;\n";
        headerlength += 1;
    }
    header += "void main( void )\n";
    headerlength += 1;

    if (this.mIs20)
        header += "{ outColor = vec4(0.0); }";
    else
        header += "{ gl_FragColor = vec4(0.0); }";
    headerlength += 1;
    header += "\n";
    headerlength += 1;

    this.mHeader = header;
    this.mHeaderLength = headerlength;
}

EffectPass.prototype.MakeHeader = function()
{
         if( this.mType==="image" ) this.MakeHeader_Image();
    else if( this.mType==="sound" ) this.MakeHeader_Sound();
    else if( this.mType==="buffer") this.MakeHeader_Buffer();
    else if( this.mType==="common") this.MakeHeader_Common();
    else if( this.mType==="cubemap") this.MakeHeader_Cubemap();
    else console.log("ERROR 4");
}

EffectPass.prototype.Create_Image = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mSupportsVR = false;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    //this.mProgramVR = null;
}
EffectPass.prototype.Destroy_Image = function( wa )
{
}

EffectPass.prototype.Create_Buffer = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mSupportsVR = false;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    //this.mProgramVR = null;
}

EffectPass.prototype.Destroy_Buffer = function( wa )
{
}

EffectPass.prototype.Create_Cubemap = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
}

EffectPass.prototype.Destroy_Cubemap = function( wa )
{
}

EffectPass.prototype.Create_Common = function( wa )
{
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.MakeHeader();
}
EffectPass.prototype.Destroy_Common = function( wa )
{
}

EffectPass.prototype.Create_Sound = function (wa)
{
    this.MakeHeader();


    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    this.mSampleRate = 44100;
    this.mPlayTime = 60*3;
    this.mPlaySamples = this.mPlayTime*this.mSampleRate;
    this.mBuffer = wa.createBuffer( 2, this.mPlaySamples, this.mSampleRate );

    //-------------------
    this.mTextureDimensions = 512;
    this.mRenderTexture = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D, 
                                                       this.mTextureDimensions, this.mTextureDimensions,
                                                       this.mRenderer.TEXFMT.C4I8,
                                                       this.mRenderer.FILTER.NONE,
                                                       this.mRenderer.TEXWRP.CLAMP, null);
    this.mRenderFBO = this.mRenderer.CreateRenderTarget(this.mRenderTexture, null, null, null, null, false);

    //-----------------------------

    // ArrayBufferView pixels;
    this.mTmpBufferSamples = this.mTextureDimensions*this.mTextureDimensions;
    this.mData = new Uint8Array( this.mTmpBufferSamples*4 );

    this.mPlaying = false;
}

EffectPass.prototype.Destroy_Sound = function( wa )
{
    if( this.mPlayNode!==null ) this.mPlayNode.stop();
    this.mPlayNode = null;
    this.mBuffer = null;
    this.mData = null;

    this.mRenderer.DestroyRenderTarget(this.mRenderFBO);
    this.mRenderer.DestroyTexture(this.mRenderTexture);
}

EffectPass.prototype.Create = function( passType, wa )
{
    this.mType = passType;
    this.mSource = null;

         if( passType==="image" ) this.Create_Image( wa );
    else if( passType==="sound" ) this.Create_Sound( wa );
    else if( passType==="buffer") this.Create_Buffer( wa );
    else if( passType==="common") this.Create_Common( wa );
    else if( passType==="cubemap") this.Create_Cubemap( wa );
    else alert("ERROR 1");
}

EffectPass.prototype.SetName = function (passName)
{
    this.mName = passName;
}

EffectPass.prototype.SetCode = function (src)
{
    this.mSource = src;
}

EffectPass.prototype.Destroy = function( wa )
{
    this.mSource = null;
         if( this.mType==="image" ) this.Destroy_Image( wa );
    else if( this.mType==="sound" ) this.Destroy_Sound( wa );
    else if( this.mType==="buffer") this.Destroy_Buffer( wa );
    else if( this.mType==="common") this.Destroy_Common( wa );
    else if( this.mType==="cubemap") this.Destroy_Cubemap( wa );
    else alert("ERROR 2");
}

EffectPass.prototype.NewShader_Sound = function( shaderCode, commonShaderCodes)
{
    let vsSource = null;

    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for( let i=0; i<commonShaderCodes.length; i++ )
    {
        fsSource += commonShaderCodes[i]+'\n';
    }
    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;
    fsSource += shaderCode;

    this.mSoundShaderCompiled = false;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader_Image = function ( shaderCode, commonShaderCodes )
{
    this.mSupportsVR = false;


    let vsSource = null;
    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for (let i = 0; i < commonShaderCodes.length; i++)
    {
        fsSource += commonShaderCodes[i]+'\n';
    }
    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;
    fsSource += shaderCode;

    return [vsSource, fsSource];


    /*
    let n1 = shaderCode.indexOf("mainVR(");
    let n2 = shaderCode.indexOf("mainVR (");
    let n3 = shaderCode.indexOf("mainVR  (");
    if( n1>0 || n2>0 || n3>0 )
    {
        let vsSourceVR;
        if( this.mIs20 )
            vsSourceVR = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        else
            vsSourceVR = "attribute in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

        let fsSourceVR = this.mHeader;
        for (let i = 0; i < commonShaderCodes.length; i++) {
            fsSourceVR += commonShaderCodes[i];
        }
        fsSourceVR += shaderCode;
        fsSourceVR += this.mImagePassFooterVR;

        let res = this.mRenderer.CreateShader(vsSource, fsSourceVR, preventCache);
        if( res.mResult == false )
        {
            return res.mInfo;
        }
        if( this.mProgramVR != null )
            this.mRenderer.DestroyShader( this.mProgramVR );

        this.mSupportsVR = true;
        this.mProgramVR = res;
    }
    */
}

EffectPass.prototype.NewShader_Cubemap = function( shaderCode, commonShaderCodes )
{
    let vsSource = null;
    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for (let i = 0; i < commonShaderCodes.length; i++)
    {
        fsSource += commonShaderCodes[i]+'\n';
    }

    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;

    fsSource += shaderCode;

    return [vsSource, fsSource];
}


EffectPass.prototype.NewShader_Common = function (shaderCode )
{
    let vsSource = null;
    if (this.mIs20)
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader + shaderCode;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader = function ( commonSourceCodes, preventCache, onResolve)
{
    if( this.mRenderer===null ) return;

    let vs_fs = null;

         if( this.mType==="sound"  ) vs_fs = this.NewShader_Sound(   this.mSource, commonSourceCodes );
    else if( this.mType==="image"  ) vs_fs = this.NewShader_Image(   this.mSource, commonSourceCodes );
    else if( this.mType==="buffer" ) vs_fs = this.NewShader_Image(   this.mSource, commonSourceCodes );
    else if( this.mType==="common" ) vs_fs = this.NewShader_Common(  this.mSource,                   );
    else if( this.mType==="cubemap") vs_fs = this.NewShader_Cubemap( this.mSource, commonSourceCodes );
    else { console.log("ERROR 3: \"" + this.mType + "\""); return; }

    let me = this;
    this.mRenderer.CreateShader(vs_fs[0], vs_fs[1], preventCache, false,
        function (worked, info)
        {
            if (worked === true)
            {
                if (me.mType === "sound")
                {
                    me.mSoundShaderCompiled = true;
                }

                me.mCompilationTime = info.mTime;
                me.mError = false;
                me.mErrorStr = "No Errors";
                if (me.mProgram !== null)
                    me.mRenderer.DestroyShader(me.mProgram);
                me.mTranslatedSource = me.mRenderer.GetTranslatedShaderSource(info);
                me.mProgram = info;
            }
            else
            {
                me.mError = true;
                me.mErrorStr = info.mErrorStr;
            }
            onResolve();
        });
}

EffectPass.prototype.DestroyInput = function( id )
{
    if( this.mInputs[id]===null ) return;

    if( this.mInputs[id].mInfo.mType==="texture" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    if( this.mInputs[id].mInfo.mType==="volume" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="webcam" )
    {
        this.mInputs[id].video.pause();
        this.mInputs[id].video.src = "";

        if( this.mInputs[id].video.srcObject!==null )
        {
        let tracks = this.mInputs[id].video.srcObject.getVideoTracks();
        if( tracks ) tracks[0].stop();
        }
        this.mInputs[id].video = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="video" )
    {
        this.mInputs[id].video.pause();
        this.mInputs[id].video = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="music" || this.mInputs[id].mInfo.mType==="musicstream")
    {
        this.mInputs[id].audio.pause();
        this.mInputs[id].audio.mSound.mFreqData = null;
        this.mInputs[id].audio.mSound.mWaveData = null;
        this.mInputs[id].audio = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="cubemap" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="keyboard" )
    {
        //if( this.mInputs[id].globject != null )
          //  this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="mic" )
    {
        this.mInputs[id].mic = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }

    this.mInputs[id] = null;
}

EffectPass.prototype.TooglePauseInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused )
        {
            inp.video.play();
            inp.video.mPaused = false;
        }
        else
        {
            inp.video.pause();
            inp.video.mPaused = true;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        wa.resume()
        if( inp.audio.mPaused )
        {
            if( inp.loaded )
            {
                inp.audio.play();
            }
            inp.audio.mPaused = false;
        }
        else
        {
            inp.audio.pause();
            inp.audio.mPaused = true;
        }
        return inp.audio.mPaused;
    }

    return null;
}

EffectPass.prototype.StopInput = function( id )
{
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused === false )
        {
            inp.video.pause();
            inp.video.mPaused = true;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
    {
        if( inp.audio.mPaused === false )
        {
            inp.audio.pause();
            inp.audio.mPaused = true;
        }
        return inp.audio.mPaused;
    }
    return null;
}

EffectPass.prototype.ResumeInput = function( id )
{
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused )
        {
            inp.video.play();
            inp.video.mPaused = false;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
    {
        if( inp.audio.mPaused )
        {
            inp.audio.play();
            inp.audio.mPaused = false;
        }
        return inp.audio.mPaused;
    }
    return null;
}

EffectPass.prototype.RewindInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];

    if( inp==null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.loaded )
        {
            inp.video.currentTime = 0;
        }
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        wa.resume()
        if( inp.loaded )
        {
            inp.audio.currentTime = 0;
        }
    }
}

EffectPass.prototype.MuteInput = function( wa, id )
{
    let inp = this.mInputs[id];
    if( inp===null ) return;

    if( inp.mInfo.mType==="video" )
    {
        inp.video.muted = true;
        inp.video.mMuted = true;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if (wa !== null) inp.audio.mSound.mGain.gain.value = 0.0;
        inp.audio.mMuted = true;
    }
}

EffectPass.prototype.UnMuteInput = function( wa, id )
{
    let inp = this.mInputs[id];
    if( inp===null ) return;

    if( inp.mInfo.mType==="video" )
    {
        inp.video.muted = false;
        inp.video.mMuted = false;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if (wa !== null) inp.audio.mSound.mGain.gain.value = 1.0;
        inp.audio.mMuted = false;
    }
}

EffectPass.prototype.ToggleMuteInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];
    if( inp===null ) return null;

    if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mMuted ) this.UnMuteInput(wa,id);
        else                   this.MuteInput(wa,id);
        return inp.video.mMuted;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if( inp.audio.mMuted ) this.UnMuteInput(wa,id);
        else                   this.MuteInput(wa,id);
        return inp.audio.mMuted;
    }

    return null;
}

EffectPass.prototype.UpdateInputs = function( wa, forceUpdate, keyboard )
{
   for (let i=0; i<this.mInputs.length; i++ )
   {
        let inp = this.mInputs[i];

        if( inp===null )
        {
            if( forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, null, false, 0, 0, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.image, true, 1, 1, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mPreview, true, 1, 1, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
            if( inp.loaded && forceUpdate )
            {
                if( this.mTextureCallbackFun!==null )
                {
                    let img = (assetID_to_cubemapBuferID(inp.mInfo.mID)===-1) ? inp.image[0] : inp.mImage;
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, img, true, 2, 1, -1.0, this.mID );
                }
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:keyboard.mIcon,mData:keyboard.mData}, false, 6, 0, -1.0, this.mID );
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, -1, this.mID );
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
              if( inp.loaded && inp.audio.mPaused === false && inp.audio.mForceMuted === false )
              {
                  if( wa !== null )
                  {
                      inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                      inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                  }

                  if (this.mTextureCallbackFun!==null)
                  {
                           if (inp.mInfo.mType === "music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:(wa==null)?null:inp.audio.mSound.mFreqData}, false, 4, 1, inp.audio.currentTime, this.mID);
                      else if (inp.mInfo.mType === "musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:(wa==null)?null:inp.audio.mSound.mFreqData, info: inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                  }
              }
              else if( inp.loaded===false )
              {
                  if (this.mTextureCallbackFun!==null)
                      this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:null}, false, 4, 0, -1.0, this.mID);
              }
        }
        else if( inp.mInfo.mType==="mic" )
        {
              if( inp.loaded && inp.mForceMuted === false )
              {
                  if( wa !== null )
                  {
                      inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                      inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
                  }
                  if( this.mTextureCallbackFun!==null )
                      this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave: ((wa==null)?null:inp.mFreqData) }, false, 5, 1, 0, this.mID );
              }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:null}, true, 9, 1, -1.0, this.mID );
            }
        }
    }
}

EffectPass.prototype.Sampler2Renderer = function (sampler)
{
    let filter = this.mRenderer.FILTER.NONE;
    if (sampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
    if (sampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
    let wrap = this.mRenderer.TEXWRP.REPEAT;
    if (sampler.wrap === "clamp") wrap = this.mRenderer.TEXWRP.CLAMP;
    let vflip = false;
    if (sampler.vflip === "true") vflip = true;

    return { mFilter: filter, mWrap: wrap, mVFlip: vflip };
}

EffectPass.prototype.GetSamplerVFlip = function (id)
{
    let inp = this.mInputs[id];
    return inp.mInfo.mSampler.vflip;
}

EffectPass.prototype.GetTranslatedShaderSource = function ()
{
    return this.mTranslatedSource;
}


EffectPass.prototype.SetSamplerVFlip = function (id, str) 
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let filter = false;
    if (str === "true") filter = true;

    if (inp === null)
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
    }
    else if (inp.mInfo.mType === "video")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "webcam")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, null);
            inp.mInfo.mSampler.vflip = str;
        }
    }
}

EffectPass.prototype.GetAcceptsVFlip = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return false;
    if (inp.mInfo.mType === "video")  return true;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return true;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return false;
    return true;
}

EffectPass.prototype.GetSamplerFilter = function (id)
{
    let inp = this.mInputs[id];
    if( inp===null) return;
    return inp.mInfo.mSampler.filter;
}

EffectPass.prototype.SetSamplerFilter = function (id, str, buffers, cubeBuffers) 
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let filter = renderer.FILTER.NONE;
    if (str === "linear") filter = renderer.FILTER.LINEAR;
    if (str === "mipmap") filter = renderer.FILTER.MIPMAP;

    if (inp === null)
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "video")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap")
    {
        if (inp.loaded) 
        {
            if( assetID_to_cubemapBuferID(inp.mInfo.mID)===0)
            {
                renderer.SetSamplerFilter(cubeBuffers[0].mTexture[0], filter, true);
                renderer.SetSamplerFilter(cubeBuffers[0].mTexture[1], filter, true);
                inp.mInfo.mSampler.filter = str;
            }
            else
            {
                renderer.SetSamplerFilter(inp.globject, filter, true);
                inp.mInfo.mSampler.filter = str;
            }
        }
    }
    else if (inp.mInfo.mType === "webcam")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "buffer")
    {
        renderer.SetSamplerFilter(buffers[inp.id].mTexture[0], filter, true);
        renderer.SetSamplerFilter(buffers[inp.id].mTexture[1], filter, true);
        inp.mInfo.mSampler.filter = str;
    }
    else if (inp.mInfo.mType === "keyboard")
    {
        inp.mInfo.mSampler.filter = str;
    }
}



EffectPass.prototype.GetAcceptsMipmapping = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return this.mIs20;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return this.mIs20;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return this.mIs20;
    return false;
}

EffectPass.prototype.GetAcceptsLinear = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return true;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return true;
    if (inp.mInfo.mType === "music")  return true;
    if (inp.mInfo.mType === "musicstream") return true;
    if (inp.mInfo.mType === "mic")  return true;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return true;
    return false;
}


EffectPass.prototype.GetAcceptsWrapRepeat = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return this.mIs20;
    if (inp.mInfo.mType === "cubemap") return false;
    if (inp.mInfo.mType === "webcam")  return this.mIs20;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return this.mIs20;
    return false;
}

EffectPass.prototype.GetSamplerWrap = function (id)
{
    let inp = this.mInputs[id];
    return inp.mInfo.mSampler.wrap;
}
EffectPass.prototype.SetSamplerWrap = function (id, str, buffers)
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let restr = renderer.TEXWRP.REPEAT;
    if (str === "clamp") restr = renderer.TEXWRP.CLAMP;

    if (inp === null) 
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "video") 
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap") 
    {
        if (inp.loaded)
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "webcam") 
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "buffer")
    {
        renderer.SetSamplerWrap(buffers[inp.id].mTexture[0], restr);
        renderer.SetSamplerWrap(buffers[inp.id].mTexture[1], restr);
        inp.mInfo.mSampler.wrap = str;
    }
}


EffectPass.prototype.GetTexture = function( slot )
{
    let inp = this.mInputs[slot];
    if( inp===null ) return null;
    return inp.mInfo;

}

EffectPass.prototype.SetOutputs = function( slot, id )
{
    this.mOutputs[slot] = id;
}

EffectPass.prototype.SetOutputsByBufferID = function( slot, id )
{
    if( this.mType==="buffer" )
    {
        this.mOutputs[slot] = bufferID_to_assetID( id );

        this.mEffect.ResizeBuffer( id, this.mEffect.mXres, this.mEffect.mYres, false );
    }
    else if( this.mType==="cubemap" )
    {
        this.mOutputs[slot] = cubamepBufferID_to_assetID( id );
        this.mEffect.ResizeCubemapBuffer(id, 1024, 1024 );
    }
}

EffectPass.prototype.NewTexture = function( wa, slot, url, buffers, cubeBuffers, keyboard )
{
    var me = this;
    var renderer = this.mRenderer;

    if( renderer===null ) return;

    let texture = null;

    if( url===null || url.mType===null )
    {
        if( me.mTextureCallbackFun!==null )
            me.mTextureCallbackFun( this.mTextureCallbackObj, slot, null, true, 0, 0, -1.0, me.mID );
        me.DestroyInput( slot );
        me.mInputs[slot] = null;
        me.MakeHeader();
        return { mFailed:false, mNeedsShaderCompile:false };
    }
    else if( url.mType==="texture" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.image = new Image();
        texture.image.crossOrigin = '';
        texture.image.onload = function()
        {
            let rti = me.Sampler2Renderer(url.mSampler);

            // O.M.G. FIX THIS
            let channels = renderer.TEXFMT.C4I8;
            if (url.mID === "Xdf3zn" || url.mID === "4sf3Rn" || url.mID === "4dXGzn" || url.mID === "4sf3Rr")
                channels = renderer.TEXFMT.C1I8;
            
            texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.image, channels, rti.mFilter, rti.mWrap, rti.mVFlip);

            texture.loaded = true;
            if( me.mTextureCallbackFun!==null )
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.image, true, 1, 1, -1.0, me.mID );
        }
        texture.image.src = url.mSrc;


        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="volume" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.mImage = { mData:null, mXres:1, mYres:0, mZres:0 };
        texture.mPreview = new Image();
        texture.mPreview.crossOrigin = '';

	    var xmlHttp = new XMLHttpRequest();
        if( xmlHttp===null ) return { mFailed:true };

        xmlHttp.open('GET', url.mSrc, true);
        xmlHttp.responseType = "arraybuffer";
        xmlHttp.onerror = function()
        {
            console.log( "Error 1 loading Volume" );
        }
        xmlHttp.onload = function()
        {
            let data = xmlHttp.response;
            if (!data ) { console.log( "Error 2 loading Volume" ); return; }

            let file = piFile(data);

            let signature = file.ReadUInt32();
            texture.mImage.mXres = file.ReadUInt32();
            texture.mImage.mYres = file.ReadUInt32();
            texture.mImage.mZres = file.ReadUInt32();
            let binNumChannels = file.ReadUInt8();
            let binLayout = file.ReadUInt8();
            let binFormat = file.ReadUInt16();
            let format = renderer.TEXFMT.C1I8;
                 if( binNumChannels===1 && binFormat===0 )  format = renderer.TEXFMT.C1I8;
            else if( binNumChannels===2 && binFormat===0 )  format = renderer.TEXFMT.C2I8;
            else if( binNumChannels===3 && binFormat===0 )  format = renderer.TEXFMT.C3I8;
            else if( binNumChannels===4 && binFormat===0 )  format = renderer.TEXFMT.C4I8;
            else if( binNumChannels===1 && binFormat===10 ) format = renderer.TEXFMT.C1F32;
            else if( binNumChannels===2 && binFormat===10 ) format = renderer.TEXFMT.C2F32;
            else if( binNumChannels===3 && binFormat===10 ) format = renderer.TEXFMT.C3F32;
            else if( binNumChannels===4 && binFormat===10 ) format = renderer.TEXFMT.C4F32;
            else return;

            let buffer = new Uint8Array(data, 20); // skip 16 bytes (header of .bin)

            let rti = me.Sampler2Renderer(url.mSampler);

            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T3D, texture.mImage.mXres, texture.mImage.mYres, format, rti.mFilter, rti.mWrap, buffer);

            if( texture.globject===null )
            {
                console.log( "Error 4: loading Volume" ); 
                return { mFailed:true };
            }

            if (me.mTextureCallbackFun !== null)
            {
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mPreview, true, 1, 1, -1.0, me.mID );
            }

            texture.loaded = true;

            // load icon for it
            texture.mPreview.onload = function()
            {
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mPreview, true, 1, 1, -1.0, me.mID );
            }
            texture.mPreview.src = url.mPreviewSrc;
        }
        xmlHttp.send("");


        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]==null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="volume")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="cubemap" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;

        let rti = me.Sampler2Renderer(url.mSampler);

        if( assetID_to_cubemapBuferID(url.mID)!==-1 )
        {
            texture.mImage = new Image();
            texture.mImage.onload = function()
            {
                texture.loaded = true;
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mImage, true, 2, 1, -1.0, me.mID );
            }
            texture.mImage.src = "/media/previz/cubemap00.png";

            this.mEffect.ResizeCubemapBuffer(0, 1024, 1024 );

        }
        else
        {
            texture.image = [ new Image(), new Image(), new Image(), new Image(), new Image(), new Image() ];

            let numLoaded = 0;
            for (var i=0; i<6; i++ )
            {
                texture.image[i].mId = i;
                texture.image[i].crossOrigin = '';
                texture.image[i].onload = function()
                {
                    var id = this.mId;
                    numLoaded++;
                    if( numLoaded===6 )
                    {
                        texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.CUBEMAP, texture.image, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                        texture.loaded = true;
                        if (me.mTextureCallbackFun !== null)
                            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, texture.image[0], true, 2, 1, -1.0, me.mID);
                    }
                }

                if( i === 0) 
                {
                    texture.image[i].src = url.mSrc;
                } 
                else 
                {
                    let n = url.mSrc.lastIndexOf(".");
                    texture.image[i].src = url.mSrc.substring(0, n) + "_" + i + url.mSrc.substring(n, url.mSrc.length);
                }
            }
        }

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]==null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="cubemap")) };

        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="webcam" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;

        texture.video = document.createElement('video');
    	texture.video.width = 320;
    	texture.video.height = 240;
    	texture.video.autoplay = true;
    	texture.video.loop = true;
        texture.mForceMuted = this.mForceMuted;
        texture.mImage = null;

        let rti = me.Sampler2Renderer(url.mSampler);

        var loadImageInsteadOfWebCam = function()
        {
            texture.mImage = new Image();
            texture.mImage.onload = function()
            {
                texture.loaded = true;
                texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.mImage, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mImage, true, 7, 1, -1.0, me.mID );
            }
            texture.mImage.src = "/media/previz/webcam.png";
        }
        
        loadImageInsteadOfWebCam();

        if( typeof navigator.getUserMedia !== "undefined"  && texture.mForceMuted===false )
        {
            texture.video.addEventListener("canplay", function (e)
            {
				try
				{
                    texture.mImage = null;
                    if( texture.globject != null )
                        renderer.DestroyTexture( texture.globject );
					texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.video, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
					texture.loaded = true;
                }
                catch(e)
                {
                    loadImageInsteadOfWebCam();
	                alert( 'Your browser can not transfer webcam data to the GPU.');
                }
            } );

            navigator.mediaDevices.getUserMedia( 
                                { "video": { width: 1280, height: 720 }, "audio": false } )
                                .then( function(stream)
                                       {
                                            texture.video.srcObject = stream;
    	                               } )
                                .catch( function(error)
                                        {
                                            loadImageInsteadOfWebCam();
    		                                alert( 'Unable to capture WebCam. Please reload the page.' );
    	                                } );
        }
        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]==null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!="music") && 
                                                                (this.mInputs[slot].mInfo.mType!="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="mic" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.mForceMuted = this.mForceMuted;
        texture.mAnalyser = null;
        let num = 512;
        texture.mFreqData = new Uint8Array( num );
        texture.mWaveData = new Uint8Array( num );

        if( wa === null || typeof navigator.getUserMedia === "undefined" )
        {
            if( !texture.mForceMuted ) alert( "Shadertoy: Web Audio not implement in this browser" );
            texture.mForceMuted = true; 
        }

        if( texture.mForceMuted )
        {
            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, num, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null)
            texture.loaded = true;
        }
        else
        {
        navigator.getUserMedia( { "audio": true },
                                function(stream)
                                {
                                  texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, null)
                                  texture.mic = wa.createMediaStreamSource(stream);
                                  texture.mAnalyser = wa.createAnalyser();
                                  texture.mic.connect( texture.mAnalyser );
                                  texture.loaded = true;
    	                        },
                                function(error)
                                {
    		                        alert( 'Unable open Mic. Please reload the page.' );
    	                        } );
        }
        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="video" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.video = document.createElement('video');
    	texture.video.loop = true;
        texture.video.preload = "auto";
        texture.video.mPaused = this.mForcePaused;
        texture.video.mMuted = true;//this.mForceMuted;
    	texture.video.muted  = true;//this.mForceMuted;
        if( this.mForceMuted===true )
            texture.video.volume = 0;
    	texture.video.autoplay = false;
        texture.video.hasFalled = false;
        
        let rti = me.Sampler2Renderer(url.mSampler);

        texture.video.addEventListener("canplay", function (e)
        {
            texture.video.play().then( function()
                                       {
                                           texture.video.mPaused = false;

                                           texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.video, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                                           texture.loaded = true;
            
                                           if( me.mTextureCallbackFun!=null )
                                               me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.video, true, 3, 1, -1.0, me.mID );
                                        } )
                               .catch( function(error)
                                       {
                                           console.log( error );
                                       }
                                );
        } );

        texture.video.addEventListener( "error", function(e)
        {
               if( texture.video.hasFalled===true ) { alert("Error: cannot load video" ); return; }
               let str = texture.video.src;
               str = str.substr(0,str.lastIndexOf('.') ) + ".mp4";
               texture.video.src = str;
               texture.video.hasFalled = true;
        } );

        texture.video.src = url.mSrc;

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]==null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!="music") && 
                                                                (this.mInputs[slot].mInfo.mType!="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="music" || url.mType==="musicstream" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.audio = document.createElement('audio');
    	texture.audio.loop = true;
        texture.audio.mMuted = this.mForceMuted;
        texture.audio.mForceMuted = this.mForceMuted;
        texture.audio.muted = this.mForceMuted;
        if( this.mForceMuted===true )
            texture.audio.volume = 0;
        texture.audio.autoplay = false;
        texture.audio.hasFalled = false;
        texture.audio.mPaused = false;
        texture.audio.mSound = {};

        if( this.mForceMuted===false )
        {
            if(url.mType==="musicstream" && SC === null)
            {
                alert( "Shadertoy: Soundcloud could not be reached" );
                texture.audio.mForceMuted = true;
            }
            }

        if( wa === null && this.mForceMuted===false )
        {
            alert( "Shadertoy: Web Audio not implement in this browser" );
            texture.audio.mForceMuted = true;
        }

        if( texture.audio.mForceMuted )
        {
            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null);
            let num = 512;
            texture.audio.mSound.mFreqData = new Uint8Array( num );
            texture.audio.mSound.mWaveData = new Uint8Array( num );
            texture.loaded = true;
        }

        texture.audio.addEventListener( "canplay", function()
        {
            if( texture===null || texture.audio===null ) return;
            if( this.mForceMuted  ) return;
            if( texture.loaded === true ) return;

            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null)

            texture.audio.mSound.mSource   = wa.createMediaElementSource( texture.audio );
            texture.audio.mSound.mAnalyser = wa.createAnalyser();
            texture.audio.mSound.mGain     = wa.createGain();

            texture.audio.mSound.mSource.connect(   texture.audio.mSound.mAnalyser );
            texture.audio.mSound.mAnalyser.connect( texture.audio.mSound.mGain );
            texture.audio.mSound.mGain.connect(me.mGainNode);

            texture.audio.mSound.mFreqData = new Uint8Array( texture.audio.mSound.mAnalyser.frequencyBinCount );
            texture.audio.mSound.mWaveData = new Uint8Array( texture.audio.mSound.mAnalyser.frequencyBinCount );

            if( texture.audio.mPaused )
            {
                texture.audio.pause();
            }
            else
            {
                texture.audio.play().then( function() {/*console.log("ok");*/} ).catch( function(e){console.log("error " + e);} );
            }
            texture.loaded = true;
        } );

        texture.audio.addEventListener( "error", function(e)
        {
               if( this.mForceMuted  ) return;

               if( texture.audio.hasFalled===true ) { return; }
               let str = texture.audio.src;
               str = str.substr(0,str.lastIndexOf('.') ) + ".ogg";
               texture.audio.src = str;
               texture.audio.hasFalled = true;
        } );

        if( !texture.audio.mForceMuted )
        {
            if(url.mType==="musicstream")
            {
                SC.resolve(url.mSrc, 
                    function(song) 
                    {
                        if( song.streamable===true )
                        {
                            texture.audio.crossOrigin = 'anonymous';
                            texture.audio.src = song.stream_url;
                            texture.audio.soundcloudInfo = song;
                        }
                        else
                        {
                            alert('Shadertoy: Soundcloud 3 - This track cannot be streamed' );
                        }
                    },
                    function(error)
                    {
                        if (me.mTextureCallbackFun!==null)
                        {
                            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null}, false, 4, 0, -1.0, me.mID);
                        }
                    } );
            } 
            else
            {
                texture.audio.src = url.mSrc;
            }
        }

        if (me.mTextureCallbackFun!==null)
        {
            if (url.mType === "music")            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null}, false, 4, 0, -1.0, me.mID);
            else if (url.mType === "musicstream") me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null, info: texture.audio.soundcloudInfo}, false, 8, 0, -1.0, me.mID);
        }

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="keyboard" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = true;

        texture.keyboard = {};

        if( me.mTextureCallbackFun!==null )
            me.mTextureCallbackFun( me.mTextureCallbackObj, slot, {mImage: keyboard.mIcon, mData: keyboard.mData}, false, 6, 1, -1.0, me.mID );

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!="music") && 
                                                                (this.mInputs[slot].mInfo.mType!="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="buffer" )
    {
        texture = {};
        texture.mInfo = url;

        texture.image = new Image();
        texture.image.onload = function()
        {
            if( me.mTextureCallbackFun!=null )
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, {texture: texture.image, data:null}, true, 9, 1, -1.0, me.mID );
        }
        texture.image.src = url.mSrc;
        texture.id = assetID_to_bufferID( url.mID );
        texture.loaded = true;

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!="music") && 
                                                                (this.mInputs[slot].mInfo.mType!="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!="video")) };

        this.DestroyInput( slot );
        this.mInputs[slot] = texture;

        this.mEffect.ResizeBuffer(texture.id, this.mEffect.mXres, this.mEffect.mYres, false );

        this.SetSamplerFilter(slot, url.mSampler.filter, buffers, cubeBuffers, true);
        this.SetSamplerVFlip(slot, url.mSampler.vflip);
        this.SetSamplerWrap(slot, url.mSampler.wrap, buffers);

        this.MakeHeader();
        return returnValue;
    }
    else
    {
        alert( "input type error" );
        return { mFailed: true };
    }

    return { mFailed: true };
}

EffectPass.prototype.Paint_Image = function( vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    let times = [ 0.0, 0.0, 0.0, 0.0 ];

    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds()  + d.getMilliseconds()/1000.0 ];

    let mouse = [  mousePosX, mousePosY, mouseOriX, mouseOriY ];


    //------------------------
    
    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];
    let texIsLoaded = [0, 0, 0, 0 ];
    let texID = [ null, null, null, null];

    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            texID[i] = keyboard.mTexture;
            texIsLoaded[i] = 1;
            resos[3*i+0] = 256;
            resos[3*i+1] = 3;
            resos[3*i+2] = 1;
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
            if (inp.loaded === true)
            {
                let id = assetID_to_cubemapBuferID(inp.mInfo.mID);
                if( id!==-1 )
                {
                    texID[i] = cubeBuffers[id].mTexture[ cubeBuffers[id].mLastRenderDone ];
                    resos[3*i+0] = cubeBuffers[id].mResolution[0];
                    resos[3*i+1] = cubeBuffers[id].mResolution[1];
                    resos[3*i+2] = 1;
                    texIsLoaded[i] = 1;

                    // hack. in webgl2.0 we have samplers, so we don't need this crap here
                    let filter = this.mRenderer.FILTER.NONE;
                         if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                    else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                    this.mRenderer.SetSamplerFilter( texID[i], filter, false);
                }
                else
                {
                    texID[i] = inp.globject;
                    texIsLoaded[i] = 1;
                }
            }
        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mImage, false, 7, 1, -1, this.mID );

                    texID[i] = inp.globject;
                    texIsLoaded[i] = 1;
                    resos[3*i+0] = inp.mImage.width;
                    resos[3*i+1] = inp.mImage.height;
                    resos[3*i+2] = 1;
                }
                else  if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {

                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 7, 1, -1, this.mID );

                    texID[i] = inp.globject;
                    this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                    resos[3*i+0] = inp.video.videoWidth;
                    resos[3*i+1] = inp.video.videoHeight;
                    resos[3*i+2] = 1;
                    texIsLoaded[i] = 1;
                }
            }
            else 
            {
                texID[i] = null;
                texIsLoaded[i] = 0;
                resos[3*i+0] = inp.video.width;
                resos[3*i+1] = inp.video.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.mPaused === false )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, inp.video.currentTime, this.mID );
            }

            if( inp.loaded===true )
            { 
                times[i] = inp.video.currentTime;
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;

      	        if( inp.video.mPaused === false )
      	        {
      	            this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
                resos[3*i+0] = inp.video.videoWidth;
                resos[3*i+1] = inp.video.videoHeight;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.audio.mPaused === false && inp.audio.mForceMuted === false && inp.loaded===true )
            {
                if( wa !== null )
                {
                    inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                    inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                }

                if( this.mTextureCallbackFun!==null )
                {
                         if( inp.mInfo.mType==="music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa === null) ? null : { wave : inp.audio.mSound.mFreqData }, false, 4, 1, inp.audio.currentTime, this.mID);
                    else if( inp.mInfo.mType==="musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa === null) ? null : { wave : inp.audio.mSound.mFreqData, info : inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                }
            }

            if( inp.loaded===true )
            {
                times[i] = inp.audio.currentTime;
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;

                if( inp.audio.mForceMuted === true )
                {
                    times[i] = 10.0 + time;
                    let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.audio.mSound.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                  //let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.audio.mSound.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }

                }

      	        if( inp.audio.mPaused === false )
                {
      	            let waveLen = Math.min(inp.audio.mSound.mWaveData.length, 512);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512, 1, inp.audio.mSound.mFreqData);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 1, 512, 1, inp.audio.mSound.mWaveData);
                }

                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                    times[i] = 10.0 + time;
                    let num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                    //var num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }
            }
            else
            {
                inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
            }

            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave:inp.mFreqData}, false, 5, 1, -1, this.mID );

            if( inp.loaded===true )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                let waveLen = Math.min( inp.mWaveData.length, 512 );
                this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512,     1, inp.mFreqData);
                this.mRenderer.UpdateTexture(inp.globject, 0, 1, waveLen, 1, inp.mWaveData);
                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            let id = inp.id;
            if( inp.loaded===true  )
            {
                texID[i] = buffers[id].mTexture[ buffers[id].mLastRenderDone ];
                texIsLoaded[i] = 1;
                resos[3*i+0] = xres;
                resos[3*i+1] = yres;
                resos[3*i+2] = 1;
                // hack. in webgl2.0 we have samplers, so we don't need this crap here
                let filter = this.mRenderer.FILTER.NONE;
                     if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                this.mRenderer.SetSamplerFilter( texID[i], filter, false);
            }

            if( this.mTextureCallbackFun!==null )
            {
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:buffers[id].mThumbnailBuffer}, false, 9, 1, -1, this.mID );
            }
        }
    }

    this.mRenderer.AttachTextures( 4, texID[0], texID[1], texID[2], texID[3] );

    //-----------------------------------

    let prog = this.mProgram;

    //if( vrData!=null && this.mSupportsVR ) prog = this.mProgramVR;



    this.mRenderer.AttachShader(prog);

    this.mRenderer.SetShaderConstant1F(  "iTime", time);
    this.mRenderer.SetShaderConstant3F(  "iResolution", xres, yres, 1.0);
    this.mRenderer.SetShaderConstant4FV( "iMouse", mouse);
    this.mRenderer.SetShaderConstant1FV( "iChannelTime", times );              // OBSOLETE
    this.mRenderer.SetShaderConstant4FV( "iDate", dates );
    this.mRenderer.SetShaderConstant3FV( "iChannelResolution", resos );        // OBSOLETE
    this.mRenderer.SetShaderConstant1F(  "iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit( "iChannel0", 0 );
    this.mRenderer.SetShaderTextureUnit( "iChannel1", 1 );
    this.mRenderer.SetShaderTextureUnit( "iChannel2", 2 );
    this.mRenderer.SetShaderTextureUnit( "iChannel3", 3 );
    this.mRenderer.SetShaderConstant1I(  "iFrame", this.mFrame );
    this.mRenderer.SetShaderConstant1F(  "iTimeDelta", dtime);
    this.mRenderer.SetShaderConstant1F(  "iFrameRate", fps );

    this.mRenderer.SetShaderConstant1F(  "iCh0.time", times[0] );
    this.mRenderer.SetShaderConstant1F(  "iCh1.time", times[1] );
    this.mRenderer.SetShaderConstant1F(  "iCh2.time", times[2] );
    this.mRenderer.SetShaderConstant1F(  "iCh3.time", times[3] );
    this.mRenderer.SetShaderConstant3F(  "iCh0.size", resos[0], resos[ 1], resos[ 2] );
    this.mRenderer.SetShaderConstant3F(  "iCh1.size", resos[3], resos[ 4], resos[ 5] );
    this.mRenderer.SetShaderConstant3F(  "iCh2.size", resos[6], resos[ 7], resos[ 8] );
    this.mRenderer.SetShaderConstant3F(  "iCh3.size", resos[9], resos[10], resos[11] );
    this.mRenderer.SetShaderConstant1I(  "iCh0.loaded",       texIsLoaded[0] );
    this.mRenderer.SetShaderConstant1I(  "iCh1.loaded",       texIsLoaded[1] );
    this.mRenderer.SetShaderConstant1I(  "iCh2.loaded",       texIsLoaded[2] );
    this.mRenderer.SetShaderConstant1I(  "iCh3.loaded",       texIsLoaded[3] );

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");


    if( (vrData !== null) && this.mSupportsVR )
    {
        for (let i=0; i<2; i++ )
        {
            let ei = (i===0) ? vrData.mLeftEye : vrData.mRightEye;

            let vp = [i * xres / 2, 0, xres / 2, yres];

            this.mRenderer.SetViewport(vp);

            let fov = ei.mProjection;
            let corA = [ -fov[2], -fov[1], -1.0 ];
            let corB = [  fov[3], -fov[1], -1.0 ];
            let corC = [  fov[3],  fov[0], -1.0 ];
            let corD = [ -fov[2],  fov[0], -1.0 ];
            let apex = [ 0.0, 0.0, 0.0 ];

            let ma = invertFast( ei.mCamera );
            corA = matMulpoint( ma, corA ); 
            corB = matMulpoint( ma, corB ); 
            corC = matMulpoint( ma, corC ); 
            corD = matMulpoint( ma, corD ); 
            apex = matMulpoint( ma, apex ); 

            let corners = [ corA[0], corA[1], corA[2], 
                            corB[0], corB[1], corB[2], 
                            corC[0], corC[1], corC[2], 
                            corD[0], corD[1], corD[2],
                            apex[0], apex[1], apex[2]];

            this.mRenderer.SetShaderConstant3FV("unCorners", corners);
            this.mRenderer.SetShaderConstant4FV("unViewport", vp);

            this.mRenderer.DrawUnitQuad_XY(l1);
        }
    }
    else 
    {
        this.mRenderer.SetViewport([0, 0, xres, yres]);
        this.mRenderer.DrawFullScreenTriangle_XY( l1 );
    }

    this.mRenderer.DettachTextures();
}

EffectPass.prototype.iRenderSound = function(d, callback )
{
    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds() ];

    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];

    this.mRenderer.SetRenderTarget(this.mRenderFBO);

    this.mRenderer.SetViewport([0, 0, this.mTextureDimensions, this.mTextureDimensions]);
    this.mRenderer.AttachShader(this.mProgram);
    this.mRenderer.SetBlend( false );

    let texID = [null, null, null, null];
    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
    }

    this.mRenderer.AttachTextures(4, texID[0], texID[1], texID[2], texID[3]);

    let l2 = this.mRenderer.SetShaderConstantLocation(this.mProgram, "iTimeOffset");
    let l3 = this.mRenderer.SetShaderConstantLocation(this.mProgram, "iSampleOffset");
    this.mRenderer.SetShaderConstant4FV("iDate", dates);
    this.mRenderer.SetShaderConstant3FV("iChannelResolution", resos);
    this.mRenderer.SetShaderConstant1F("iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit("iChannel0", 0);
    this.mRenderer.SetShaderTextureUnit("iChannel1", 1);
    this.mRenderer.SetShaderTextureUnit("iChannel2", 2);
    this.mRenderer.SetShaderTextureUnit("iChannel3", 3);

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    //--------------------------------
    let numSamples = this.mTmpBufferSamples;
    let numBlocks = this.mPlaySamples / numSamples;
    for (let j=0; j<numBlocks; j++ )
    {
        let off = j*numSamples;
        
        this.mRenderer.SetShaderConstant1F_Pos(l2, off / this.mSampleRate);
        this.mRenderer.SetShaderConstant1I_Pos(l3, off );
        this.mRenderer.DrawUnitQuad_XY(l1);

        this.mRenderer.GetPixelData(this.mData, 0, this.mTextureDimensions, this.mTextureDimensions);

        callback( off, this.mData, numSamples );
    }

    this.mRenderer.DetachShader();
    this.mRenderer.DettachTextures();
    this.mRenderer.SetRenderTarget(null);
}

EffectPass.prototype.Paint_Sound = function( wa, d )
{
    let bufL = this.mBuffer.getChannelData(0); // Float32Array
    let bufR = this.mBuffer.getChannelData(1); // Float32Array

    this.iRenderSound( d, function(off, data, numSamples)
                         {
                            for( let i=0; i<numSamples; i++ )
                            {
                                bufL[off+i] = -1.0 + 2.0*(data[4*i+0]+256.0*data[4*i+1])/65535.0;
                                bufR[off+i] = -1.0 + 2.0*(data[4*i+2]+256.0*data[4*i+3])/65535.0;
                            }
                         }
                     );
}

EffectPass.prototype.SetUniforms = function(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    let times = [ 0.0, 0.0, 0.0, 0.0 ];

    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds()  + d.getMilliseconds()/1000.0 ];

    let mouse = [  mousePosX, mousePosY, mouseOriX, mouseOriY ];

    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];

    //------------------------
    
    let texID = [ null, null, null, null];

    for( let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            texID[i] = keyboard.mTexture;
        }
        else if( inp.mInfo.mType=="cubemap" )
        {
            if (inp.loaded === true)
            {
                let id = assetID_to_cubemapBuferID(inp.mInfo.mID);
                if( id!==-1 )
                {
                    texID[i] = cubeBuffers[id].mTexture[ cubeBuffers[id].mLastRenderDone ];
                    resos[3*i+0] = cubeBuffers[id].mResolution[0];
                    resos[3*i+1] = cubeBuffers[id].mResolution[1];
                    resos[3*i+2] = 1;
    
                    // hack. in webgl2.0 we have samplers, so we don't need this crap here
                    let filter = this.mRenderer.FILTER.NONE;
                         if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                    else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                    this.mRenderer.SetSamplerFilter( texID[i], filter, false);
                }
                else
                {
                    texID[i] = inp.globject;
                }
            }

        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    texID[i] = inp.globject;
                    resos[3*i+0] = inp.mImage.width;
                    resos[3*i+1] = inp.mImage.height;
                    resos[3*i+2] = 1;
                }
                else  if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {
                    texID[i] = inp.globject;
                    resos[3*i+0] = inp.video.videoWidth;
                    resos[3*i+1] = inp.video.videoHeight;
                    resos[3*i+2] = 1;
                }
            }
            else 
            {
                texID[i] = null;
                resos[3*i+0] = inp.video.width;
                resos[3*i+1] = inp.video.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
           if( inp.loaded===true )
           { 
                times[i] = inp.video.currentTime;
                texID[i] = inp.globject;
                resos[3*i+0] = inp.video.videoWidth;
                resos[3*i+1] = inp.video.videoHeight;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.loaded===true )
            {
                times[i] = inp.audio.currentTime;
                texID[i] = inp.globject;

                if( inp.audio.mForceMuted === true )
                {
                    times[i] = 10.0 + time;
                }

                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                times[i] = 10.0 + time;
            }

            if( inp.loaded===true )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = buffers[inp.id].mTexture[ buffers[inp.id].mLastRenderDone ];
                resos[3*i+0] = buffers[inp.id].mResolution[0];
                resos[3*i+1] = buffers[inp.id].mResolution[1];
                resos[3*i+2] = 1;
            }
        }
    }

    this.mRenderer.AttachTextures( 4, texID[0], texID[1], texID[2], texID[3] );

    //-----------------------------------

    this.mRenderer.AttachShader(this.mProgram);

    this.mRenderer.SetShaderConstant1F(  "iTime", time);
    this.mRenderer.SetShaderConstant3F(  "iResolution", xres, yres, 1.0);
    this.mRenderer.SetShaderConstant4FV( "iMouse", mouse);
    this.mRenderer.SetShaderConstant1FV( "iChannelTime", times );              // OBSOLETE
    this.mRenderer.SetShaderConstant4FV( "iDate", dates );
    this.mRenderer.SetShaderConstant3FV( "iChannelResolution", resos );        // OBSOLETE
    this.mRenderer.SetShaderConstant1F(  "iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit( "iChannel0", 0 );
    this.mRenderer.SetShaderTextureUnit( "iChannel1", 1 );
    this.mRenderer.SetShaderTextureUnit( "iChannel2", 2 );
    this.mRenderer.SetShaderTextureUnit( "iChannel3", 3 );
    this.mRenderer.SetShaderConstant1I(  "iFrame", this.mFrame );
    this.mRenderer.SetShaderConstant1F(  "iTimeDelta", dtime);
    this.mRenderer.SetShaderConstant1F(  "iFrameRate", fps );

    this.mRenderer.SetShaderConstant1F(  "iChannel[0].time",       times[0] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[1].time",       times[1] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[2].time",       times[2] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[3].time",       times[3] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[0].resolution", resos[0], resos[ 1], resos[ 2] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[1].resolution", resos[3], resos[ 4], resos[ 5] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[2].resolution", resos[6], resos[ 7], resos[ 8] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[3].resolution", resos[9], resos[10], resos[11] );
}

EffectPass.prototype.ProcessInputs = function(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
        }
        else if( inp.mInfo.mType==="volume" )
        {
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mImage, false, 7, 1, -1, this.mID );
                }
                else if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 7, 1, -1, this.mID );

                    this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.mPaused === false )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, inp.video.currentTime, this.mID );
            }

            if( inp.loaded===true )
            { 
      	        if( inp.video.mPaused === false )
      	        {
      	            this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.audio.mPaused === false && inp.audio.mForceMuted === false && inp.loaded===true )
            {
                if( wa !== null )
                {
                    inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                    inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                }

                if( this.mTextureCallbackFun!==null )
                {
                         if( inp.mInfo.mType==="music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa == null) ? null : { wave : inp.audio.mSound.mFreqData }, false, 4, 1, inp.audio.currentTime, this.mID);
                    else if( inp.mInfo.mType==="musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa == null) ? null : { wave : inp.audio.mSound.mFreqData, info : inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                }
            }

            if( inp.loaded===true )
            {
                if( inp.audio.mForceMuted === true )
                {
                    let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.audio.mSound.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                  //let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.audio.mSound.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }

                }

      	        if( inp.audio.mPaused === false )
                {
      	            let waveLen = Math.min(inp.audio.mSound.mWaveData.length, 512);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512, 1, inp.audio.mSound.mFreqData);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 1, 512, 1, inp.audio.mSound.mWaveData);
                }
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                    let num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                    for( let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }
            }
            else
            {
                inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
            }

            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave:inp.mFreqData}, false, 5, 1, -1, this.mID );

            if( inp.loaded===true )
            {
                let waveLen = Math.min( inp.mWaveData.length, 512 );
                this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512,     1, inp.mFreqData);
                this.mRenderer.UpdateTexture(inp.globject, 0, 1, waveLen, 1, inp.mWaveData);
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded===true  )
            {
                let id = inp.id;
                let texID = buffers[id].mTexture[ buffers[id].mLastRenderDone ];

                // hack. in webgl2.0 we have samplers, so we don't need this crap here
                let filter = this.mRenderer.FILTER.NONE;
                     if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                this.mRenderer.SetSamplerFilter( texID, filter, false);
            }

            if( this.mTextureCallbackFun!==null )
            {
				let id = inp.id;
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:buffers[id].mThumbnailBuffer}, false, 9, 1, -1, this.mID );
            }
        }
    }
}

EffectPass.prototype.Paint_Cubemap = function( vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face )
{
    this.ProcessInputs(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face );
    this.SetUniforms(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    let vp = [0, 0, xres, yres];

    this.mRenderer.SetViewport(vp);

    let corA = [ -1.0, -1.0, -1.0 ];
    let corB = [  1.0, -1.0, -1.0 ];
    let corC = [  1.0,  1.0, -1.0 ];
    let corD = [ -1.0,  1.0, -1.0 ];
    let apex = [  0.0,  0.0,  0.0 ];

    if( face===0 )
    {
        corA = [  1.0,  1.0,  1.0 ];
        corB = [  1.0,  1.0, -1.0 ];
        corC = [  1.0, -1.0, -1.0 ];
        corD = [  1.0, -1.0,  1.0 ];
    }
    else if( face===1 ) // -X
    {
        corA = [ -1.0,  1.0, -1.0 ];
        corB = [ -1.0,  1.0,  1.0 ];
        corC = [ -1.0, -1.0,  1.0 ];
        corD = [ -1.0, -1.0, -1.0 ];
    }
    else if( face===2 ) // +Y
    {
        corA = [ -1.0,  1.0, -1.0 ];
        corB = [  1.0,  1.0, -1.0 ];
        corC = [  1.0,  1.0,  1.0 ];
        corD = [ -1.0,  1.0,  1.0 ];
    }
    else if( face===3 ) // -Y
    {
        corA = [ -1.0, -1.0,  1.0 ];
        corB = [  1.0, -1.0,  1.0 ];
        corC = [  1.0, -1.0, -1.0 ];
        corD = [ -1.0, -1.0, -1.0 ];
    }
    else if( face===4 ) // +Z
    {
        corA = [ -1.0,  1.0,  1.0 ];
        corB = [  1.0,  1.0,  1.0 ];
        corC = [  1.0, -1.0,  1.0 ];
        corD = [ -1.0, -1.0,  1.0 ];
    }
    else //if( face===5 ) // -Z
    {
        corA = [  1.0,  1.0, -1.0 ];
        corB = [ -1.0,  1.0, -1.0 ];
        corC = [ -1.0, -1.0, -1.0 ];
        corD = [  1.0, -1.0, -1.0 ];
    }

    let corners = [ corA[0], corA[1], corA[2], 
                    corB[0], corB[1], corB[2], 
                    corC[0], corC[1], corC[2], 
                    corD[0], corD[1], corD[2],
                    apex[0], apex[1], apex[2]];

    this.mRenderer.SetShaderConstant3FV("unCorners", corners);
    this.mRenderer.SetShaderConstant4FV("unViewport", vp);

    this.mRenderer.DrawUnitQuad_XY(l1);

    this.mRenderer.DettachTextures();
}


EffectPass.prototype.Paint = function( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, bufferNeedsMimaps, buffers, cubeBuffers, keyboard, effect )
{
    if( this.mType==="sound" )
    {
        if (this.mSoundShaderCompiled === true)
        {
            // make sure all textures are loaded
            for (let i=0; i<this.mInputs.length; i++ )
            {
                let inp = this.mInputs[i];
                if (inp === null) continue;

                if (inp.mInfo.mType === "texture" && !inp.loaded) return;
                if (inp.mInfo.mType === "cubemap" && !inp.loaded) return;
            }

            this.Paint_Sound(wa, da);
            this.mSoundShaderCompiled = false;
        }
        if (this.mFrame === 0)
        {
            if (this.mPlaying===true)
            {
                this.mPlayNode.disconnect();
                this.mPlayNode.stop();
                this.mPlayNode = null;
            }
            this.mPlaying = true;

            this.mPlayNode = wa.createBufferSource();
            this.mPlayNode.buffer = this.mBuffer;
            this.mPlayNode.connect(this.mGainNode);
            this.mPlayNode.start(0);
        }
        this.mFrame++;
    }
    else if( this.mType==="image" )
    {
        this.mRenderer.SetRenderTarget( null );
        this.Paint_Image( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );
        this.mFrame++;
    }
    else if( this.mType==="common" )
    {
        //console.log("rendering common");
    }
    else if( this.mType==="buffer" )
    {
        this.mEffect.ResizeBuffer(bufferID, this.mEffect.mXres, this.mEffect.mYres, false );

        let buffer = buffers[bufferID];

        let dstID = 1 - buffer.mLastRenderDone;

        this.mRenderer.SetRenderTarget( buffer.mTarget[dstID] );
        this.Paint_Image( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );

        // compute mipmaps if needd
        if( bufferNeedsMimaps )
        {
            this.mRenderer.CreateMipmaps( buffer.mTexture[dstID]);
        }

        // make thumbnail
        //if( this.mTextureCallbackFun != null )
        /*
        {
            this.mRenderer.SetRenderTarget( buffer.mThumbnailRenderTarget );
            let v = [0, 0, buffer.mThumbnailRes[0], buffer.mThumbnailRes[1]];
            this.mRenderer.SetBlend(false);
            this.mRenderer.SetViewport(v);
            this.mRenderer.AttachShader(this.mProgramCopy);
            let l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, "pos");
            this.mRenderer.SetShaderConstant4FV("v", v);
            this.mRenderer.AttachTextures(1, buffer.mTexture[dstID], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);
            this.mRenderer.DettachTextures();
            this.mRenderer.DetachShader();
            this.mRenderer.GetPixelData( new Uint8Array(buffer.mThumbnailBuffer.data.buffer), buffer.mThumbnailRes[0], buffer.mThumbnailRes[1] );
            this.mRenderer.SetRenderTarget(null);
        }
        */
        buffers[bufferID].mLastRenderDone = 1 - buffers[bufferID].mLastRenderDone;
        this.mFrame++;
    }
    else if( this.mType==="cubemap" )
    {
        this.mEffect.ResizeCubemapBuffer(bufferID, 1024, 1024, false );

        let buffer = cubeBuffers[bufferID];

        xres = buffer.mResolution[0];
        yres = buffer.mResolution[1];
        let dstID = 1 - buffer.mLastRenderDone;
        for( let face=0; face<6; face++ )
        {
            this.mRenderer.SetRenderTargetCubeMap( buffer.mTarget[dstID], face );
            this.Paint_Cubemap( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face );
        }
        this.mRenderer.SetRenderTargetCubeMap( null, 0 );

        // compute mipmaps if needd
        if( bufferNeedsMimaps )
        {
            this.mRenderer.CreateMipmaps( buffer.mTexture[dstID]);
        }
        cubeBuffers[bufferID].mLastRenderDone = 1 - cubeBuffers[bufferID].mLastRenderDone;

        this.mFrame++;
    }

}

EffectPass.prototype.StopOutput_Sound = function( wa )
{
    if( this.mPlayNode===null ) return;
    this.mPlayNode.disconnect();

};

EffectPass.prototype.ResumeOutput_Sound = function( wa )
{
    if( this.mPlayNode===null ) return;

    wa.resume()
    this.mPlayNode.connect( this.mGainNode );
};

EffectPass.prototype.StopOutput_Image = function( wa )
{
};

EffectPass.prototype.ResumeOutput_Image = function( wa )
{
};

EffectPass.prototype.StopOutput = function( wa )
{
    for (let j=0; j<this.mInputs.length; j++ )
        this.StopInput(j);

    if( this.mType==="sound" )
         this.StopOutput_Sound( wa );
    else
         this.StopOutput_Image( wa );
}

EffectPass.prototype.ResumeOutput = function( wa )
{
    for (let j=0; j<this.mInputs.length; j++ )
        this.ResumeInput(j);

    if( this.mType==="sound" )
         this.ResumeOutput_Sound( wa );
    else
         this.ResumeOutput_Image( wa );
}

EffectPass.prototype.GetCompilationTime = function()
{
    return this.mCompilationTime;
}

//============================================================================================================
function Screenshots()
{
    // private
    let mTexture = null;
    let mTarget = null;
    let mXres = 0;
    let mYres = 0;
    let mCubemapToEquirectProgram;
    let mRenderer = null;

    // public
    var me = {};

    me.Initialize = function(renderer)
    {
        mRenderer = renderer;
        let caps = mRenderer.GetCaps();
        let is20 = caps.mIsGL20;


        let vsSourceC, fsSourceC;
        if( is20 )
        {
            vsSourceC = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
            fsSourceC = "uniform samplerCube t; out vec4 outColor; void main() { vec2 px = gl_FragCoord.xy/vec2(4096.0,2048.0); vec2 an = 3.1415926535898 * (px*vec2(2.0, 1.0) - vec2(0.0,0.5)); vec3 rd = vec3(-cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x)); outColor = texture(t, rd); }";
        }
        else
        {
            vsSourceC = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
            fsSourceC = "uniform samplerCube t; void main() { vec2 px = gl_FragCoord.xy/vec2(4096.0,2048.0); vec2 an = 3.1415926535898 * (px*vec2(2.0, 1.0) - vec2(0.0,0.5)); vec3 rd = vec3(-cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x)); gl_FragColor = texture(t, rd); }";
        }

        let compileShader = function (worked, info)
        {
            if (worked === false)
            {
                console.log("Failed to compile cubemap resample shader (" + errorType + "): " + log);
            }
            else
            {
                mCubemapToEquirectProgram = info;
            }
        }
        mRenderer.CreateShader(vsSourceC, fsSourceC, false, true, compileShader);

        return true;
    };

    me.Allocate = function( xres, yres )
    {
        if( xres>mXres || yres>mYres )
        {
            let texture = mRenderer.CreateTexture(mRenderer.TEXTYPE.T2D, xres, yres, mRenderer.TEXFMT.C4F32, mRenderer.FILTER.NONE, mRenderer.TEXWRP.CLAMP, null);
            let target = mRenderer.CreateRenderTarget( texture, null, null, null, null, false);

            if( mXres!==0 )
            {
                mRenderer.DestroyTexture(mTexture);
                mRenderer.DestroyRenderTarget(mTarget);
            }

            mTexture = texture;
            mTarget = target;
            mXres = xres;
            mYres = yres;
        }
    };

    me.GetProgram = function()
    {
        return mCubemapToEquirectProgram;
    };
    me.GetTarget = function()
    {
        return mTarget;
    };

    return me;
};

//============================================================================================================

function Effect(vr, ac, canvas, callback, obj, forceMuted, forcePaused, resizeCallback, crashCallback )
{
    let xres = canvas.width;
    let yres = canvas.height;

    let me = this;
    this.mCanvas = canvas;
    this.mCreated = false;
    this.mRenderer = null;
    this.mAudioContext = ac;
    this.mGLContext = null;
    this.mWebVR = vr;
    this.mRenderingStereo = false;
    this.mXres = xres;
    this.mYres = yres;
    this.mForceMuted = forceMuted;
    if( ac===null ) this.mForceMuted = true;
    this.mForcePaused = forcePaused;
    this.mGainNode = null;
    this.mPasses = [];
    this.mFrame = 0;
    this.mTextureCallbackFun = callback;
    this.mTextureCallbackObj = obj;
    this.mMaxBuffers = 4;
    this.mMaxCubeBuffers = 1;
    this.mMaxPasses = this.mMaxBuffers + 1 + 1 + 1 + 1; // some day decouple passes from buffers (4 buffers + common + Imagen + sound + cubemap)
    this.mBuffers = [];
    this.mCubeBuffers = [];
    this.mScreenshotSytem = null;
    this.mCompilationTime = 0;
    this.mIsLowEnd = piIsMobile();

    this.mGLContext = piCreateGlContext(canvas, false, false, true, false); // need preserve-buffe to true in order to capture screenshots
    if (this.mGLContext === null)
    {
        return;
    }

    canvas.addEventListener("webglcontextlost", function (event)
        {
            event.preventDefault();
            crashCallback();
        }, false);

    this.mRenderer = piRenderer();
    if (!this.mRenderer.Initialize(this.mGLContext))
        return;

    this.mScreenshotSytem = Screenshots();
    if (!this.mScreenshotSytem.Initialize(this.mRenderer))
        return;

    var caps = this.mRenderer.GetCaps();
    this.mIs20 = caps.mIsGL20;
    this.mShaderTextureLOD = caps.mShaderTextureLOD;
    //-------------
    if( ac!==null )
    {   
        this.mGainNode = ac.createGain();
        if( !forceMuted )
        {
            this.mGainNode.connect( ac.destination);
        }
        if (this.mForceMuted )
            this.mGainNode.gain.value = 0.0;
        else
            this.mGainNode.gain.value = 1.0;
    }

    //-------------
    let vsSourceC, fsSourceC;
    if( this.mIs20 )
    {
        vsSourceC = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceC = "uniform vec4 v; uniform sampler2D t; out vec4 outColor; void main() { outColor = textureLod(t, gl_FragCoord.xy / v.zw, 0.0); }";
    }
    else
    {
        vsSourceC = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceC = "uniform vec4 v; uniform sampler2D t; void main() { gl_FragColor = texture2D(t, gl_FragCoord.xy / v.zw, -100.0); }";
    }

    this.mRenderer.CreateShader(vsSourceC, fsSourceC, false, true, function(worked, info)
        {
            if (worked === false) console.log("Failed to compile shader to copy buffers : " + info.mErrorStr);
            else me.mProgramCopy = info;
        });

    let vsSourceD, fsSourceD;
    if( this.mIs20 )
    {
        vsSourceD = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceD = "uniform vec4 v; uniform sampler2D t; out vec4 outColor; void main() { vec2 uv = gl_FragCoord.xy / v.zw; outColor = texture(t, vec2(uv.x,1.0-uv.y)); }";
    }
    else
    {
        vsSourceD = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceD = "uniform vec4 v; uniform sampler2D t; void main() { vec2 uv = gl_FragCoord.xy / v.zw; gl_FragColor = texture2D(t, vec2(uv.x,1.0-uv.y)); }";
    }

    this.mRenderer.CreateShader(vsSourceD, fsSourceD, false, true, function (worked, info)
        {
            if (worked === false) console.log("Failed to compile shader to downscale buffers : " + info.mErrorStr);
            else me.mProgramDownscale = info;
        });


    // set all buffers and cubemaps to null
    for( let i=0; i<this.mMaxBuffers; i++ )
    {
        this.mBuffers[i] = { mTexture: [null, null], 
                             mTarget:  [null, null], 
                             mResolution: [0, 0],
                             mLastRenderDone: 0,
                             mThumbnailRenderTarget: null,
                             mThumbnailTexture: null,
                             mThumbnailBuffer:  null,
                             mThumbnailRes: [0, 0] };
    }

    for( let i=0; i<this.mMaxCubeBuffers; i++ )
    {
        this.mCubeBuffers[i] = { mTexture: [null, null], 
                                mTarget:  [null, null], 
                                mResolution: [0, 0],
                                mLastRenderDone: 0,
                                mThumbnailRenderTarget: null,
                                mThumbnailTexture: null,
                                mThumbnailBuffer:  null,
                                mThumbnailRes: [0, 0] };
    }

    //-------

    let keyboardData = new Uint8Array( 256*3 );
    for (let j=0; j<(256*3); j++ ) { keyboardData[j] = 0; }
    let kayboardTexture = this.mRenderer.CreateTexture( this.mRenderer.TEXTYPE.T2D, 256, 3, this.mRenderer.TEXFMT.C1I8, this.mRenderer.FILTER.NONE, this.mRenderer.TEXWRP.CLAMP, null);
    let keyboardImage = new Image();
    if( callback!==null )
        keyboardImage.src = "/img/keyboard.png"; // don't load PNG if no UI 
    this.mKeyboard = { mData: keyboardData, mTexture: kayboardTexture, mIcon: keyboardImage };

    let iResize = function( xres, yres )
    {
        me.mCanvas.width = xres;
        me.mCanvas.height = yres;
        me.mXres = xres;
        me.mYres = yres;
        me.ResizeBuffers(xres, yres);
        resizeCallback(xres, yres);
    };

    let bestAttemptFallback = function()
    {
        let devicePixelRatio = window.devicePixelRatio || 1;
        let xres = Math.round(me.mCanvas.offsetWidth  * devicePixelRatio) | 0;
        let yres = Math.round(me.mCanvas.offsetHeight * devicePixelRatio) | 0;
        iResize(xres, yres);
    };

    if(!window.ResizeObserver)
    {
        console.log("WARNING: This browser doesn't support ResizeObserver.");
        bestAttemptFallback();
        window.addEventListener("resize", bestAttemptFallback);
    }
    else
    {
        this.mRO = new ResizeObserver( function(entries, observer)
        {
            var entry = entries[0];
            if (!entry['devicePixelContentBoxSize'])
            {
                observer.unobserve(me.mCanvas);
                console.log("WARNING: This browser doesn't support ResizeObserver + device-pixel-content-box (2)");
                bestAttemptFallback();
                window.addEventListener("resize", bestAttemptFallback);
            }
            else
            {
                let box = entry.devicePixelContentBoxSize[0];
                let xres = box.inlineSize;
                let yres = box.blockSize;
                iResize(xres, yres);
            }
        });
        try
        {
            this.mRO.observe(this.mCanvas, { box: ["device-pixel-content-box"] });
            //this.mRO.observe(this.mCanvas);
        }
        catch (e)
        {
            console.log("WARNING: This browser doesn't support ResizeObserver + device-pixel-content-box (1)");
            bestAttemptFallback();
            window.addEventListener("resize", bestAttemptFallback);
        }
    }

    this.mCreated = true;
}


Effect.prototype.ResizeCubemapBuffer = function(i, xres, yres )
{
    let oldXres = this.mCubeBuffers[i].mResolution[0];
    let oldYres = this.mCubeBuffers[i].mResolution[1];

    if( this.mCubeBuffers[i].mTexture[0]===null || oldXres !== xres || oldYres !== yres )
    {
        let texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.CUBEMAP,
            xres, yres,
            this.mRenderer.TEXFMT.C4F16,
            this.mRenderer.FILTER.LINEAR,
            this.mRenderer.TEXWRP.CLAMP, 
            null);
        let target1 = this.mRenderer.CreateRenderTargetCubeMap( texture1, null, false);

        let texture2 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.CUBEMAP,
            xres, yres,
            this.mRenderer.TEXFMT.C4F16,
            this.mRenderer.FILTER.LINEAR,
            this.mRenderer.TEXWRP.CLAMP, 
            null);

        let target2 = this.mRenderer.CreateRenderTargetCubeMap( texture2, null, false);

        // Store new buffers
        this.mCubeBuffers[i].mTexture = [texture1,texture2], 
        this.mCubeBuffers[i].mTarget =  [target1, target2 ], 
        this.mCubeBuffers[i].mLastRenderDone = 0;
        this.mCubeBuffers[i].mResolution[0] = xres;
        this.mCubeBuffers[i].mResolution[1] = yres;
    }
}


Effect.prototype.ResizeBuffer = function( i, xres, yres, skipIfNotExists )
{
    if( skipIfNotExists && this.mBuffers[i].mTexture[0]===null ) return;

    let oldXres = this.mBuffers[i].mResolution[0];
    let oldYres = this.mBuffers[i].mResolution[1];

    if( oldXres !== xres || oldYres !== yres )
    {
        let needCopy = (this.mBuffers[i].mTexture[0]!==null);

        let texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,
            xres, yres,
            this.mRenderer.TEXFMT.C4F32,
            (needCopy) ? this.mBuffers[i].mTexture[0].mFilter : this.mRenderer.FILTER.NONE,
            (needCopy) ? this.mBuffers[i].mTexture[0].mWrap   : this.mRenderer.TEXWRP.CLAMP, 
            null);

        let texture2 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,
            xres, yres,
            this.mRenderer.TEXFMT.C4F32,
            (needCopy) ? this.mBuffers[i].mTexture[1].mFilter : this.mRenderer.FILTER.NONE,
            (needCopy) ? this.mBuffers[i].mTexture[1].mWrap   : this.mRenderer.TEXWRP.CLAMP, 
            null);

        let target1 = this.mRenderer.CreateRenderTarget( texture1, null, null, null, null, false);
        let target2 = this.mRenderer.CreateRenderTarget( texture2, null, null, null, null, false);

        if( needCopy )
        {
            let v = [0, 0, Math.min(xres, oldXres), Math.min(yres, oldYres)];
            this.mRenderer.SetBlend(false);
            this.mRenderer.SetViewport(v);
            this.mRenderer.AttachShader(this.mProgramCopy);
            let l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, "pos");
            let vOld = [0, 0, oldXres, oldYres];
            this.mRenderer.SetShaderConstant4FV("v", vOld);

            // Copy old buffers 1 to new buffer
            this.mRenderer.SetRenderTarget(target1);
            this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[0], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);

            // Copy old buffers 2 to new buffer
            this.mRenderer.SetRenderTarget(target2);
            this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[1], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);

            // Deallocate old memory
            this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[0]);
            this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[0]);
            this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[1]);
            this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[1]);
            //this.mRenderer.DestroyTexture(this.mBuffers[i].thumbnailTexture);
        }

        // Store new buffers
        this.mBuffers[i].mTexture = [texture1,texture2], 
        this.mBuffers[i].mTarget =  [target1, target2 ], 
        this.mBuffers[i].mLastRenderDone = 0;
        this.mBuffers[i].mResolution[0] = xres;
        this.mBuffers[i].mResolution[1] = yres;
    }
}

Effect.prototype.saveScreenshot = function(passid)
{
    let pass = this.mPasses[passid];

    if( pass.mType === "buffer" )
    {
        let bufferID = assetID_to_bufferID( this.mPasses[passid].mOutputs[0] );

        let texture = this.mBuffers[bufferID].mTarget[ this.mBuffers[bufferID].mLastRenderDone ];

        let numComponents = 3;
        let width = texture.mTex0.mXres;
        let height = texture.mTex0.mYres;
        let type = "Float"; // Other options Float, Half, Uint
        let bytes = new Float32Array(width * height * 4 );//numComponents);
        this.mRenderer.GetPixelDataRenderTarget( texture, bytes, width, height );
        let blob = piExportToEXR(width, height, numComponents, type, bytes);

        // Offer download automatically to the user
        piTriggerDownload("image.exr", blob);
    }
    else if( pass.mType === "cubemap" )
    {
        let xres = 4096;
        let yres = 2048;
        this.mScreenshotSytem.Allocate( xres, yres );

        let cubeBuffer = this.mCubeBuffers[0];

        let target = this.mScreenshotSytem.GetTarget();
        this.mRenderer.SetRenderTarget( target );

        let program = this.mScreenshotSytem.GetProgram();

        this.mRenderer.AttachShader(program);
        let l1 = this.mRenderer.GetAttribLocation(program, "pos");
        this.mRenderer.SetViewport( [0, 0, xres, yres] );
        this.mRenderer.AttachTextures(1, cubeBuffer.mTexture[ cubeBuffer.mLastRenderDone ], null, null, null);
        this.mRenderer.DrawUnitQuad_XY(l1);
        this.mRenderer.DettachTextures();
        this.mRenderer.SetRenderTarget( null );

        let data = new Float32Array(xres*yres*4);
        this.mRenderer.GetPixelDataRenderTarget( target, data, xres, yres );

        let blob = piExportToEXR(xres, yres, 3, "Float", data );
        piTriggerDownload("image.exr", blob);
    }
    else if( pass.mType === "sound" )
    {
        let offset = 0;
        const bits = 16;
        const numChannels = 2;
        let words = new Int16Array(60*pass.mSampleRate*numChannels );

        pass.iRenderSound( new Date(), function(off, data, numSamples)
                                         {
                                            for( let i=0; i<numSamples; i++ )
                                            {
                                                words[offset++] = (data[4*i+0]+256.0*data[4*i+1]) - 32767;
                                                words[offset++] = (data[4*i+2]+256.0*data[4*i+3]) - 32767;
                                            }
                                         }
                                     );

        let blob = piExportToWAV( 60*pass.mSampleRate, pass.mSampleRate, bits, numChannels, words);

        piTriggerDownload("sound.wav", blob);
    }    
}

Effect.prototype.ResizeBuffers = function(xres, yres)
{
    for (let i=0; i<this.mMaxBuffers; i++ )
    {
        this.ResizeBuffer(i, xres, yres, true);
    }
}

Effect.prototype.IsEnabledVR = function ()
{
    if (this.mRenderingStereo) return true;
    return false;
}

Effect.prototype.EnableVR = function()
{
    if( !this.mWebVR.IsSupported() ) return;
    if( this.mRenderingStereo ) return;

    this.mRenderingStereo = true;
    this.mWebVR.Enable();
}

Effect.prototype.DisableVR = function()
{
    if( !this.mWebVR.IsSupported() ) return;
    if( !this.mRenderingStereo ) return;

    this.mRenderingStereo = false;
    this.mWebVR.Disable();
}

Effect.prototype.GetTexture = function( passid, slot )
{
    return this.mPasses[passid].GetTexture( slot );
}

Effect.prototype.NewTexture = function( passid, slot, url )
{
    return this.mPasses[passid].NewTexture( this.mAudioContext, slot, url, this.mBuffers, this.mCubeBuffers, this.mKeyboard );
}

Effect.prototype.SetOutputs = function( passid, slot, url )
{
    this.mPasses[passid].SetOutputs( slot, url );
}

Effect.prototype.SetOutputsByBufferID = function( passid, slot, id )
{
    this.mPasses[passid].SetOutputsByBufferID( slot, id );
}

Effect.prototype.GetAcceptsLinear = function (passid, slot) 
{
    return this.mPasses[passid].GetAcceptsLinear(slot);
}

Effect.prototype.GetAcceptsMipmapping = function (passid, slot) 
{
    return this.mPasses[passid].GetAcceptsMipmapping(slot);
}

Effect.prototype.GetAcceptsWrapRepeat = function (passid, slot) 
{
    return this.mPasses[passid].GetAcceptsWrapRepeat(slot);
}

Effect.prototype.GetAcceptsVFlip = function (passid, slot)
{
    return this.mPasses[passid].GetAcceptsVFlip(slot);
}

Effect.prototype.SetSamplerFilter = function (passid, slot, str) 
{
    this.mPasses[passid].SetSamplerFilter(slot, str, this.mBuffers, this.mCubeBuffers);
}

Effect.prototype.GetTranslatedShaderSource = function (passid)
{
    return this.mPasses[passid].GetTranslatedShaderSource();
}

Effect.prototype.GetSamplerFilter = function (passid, slot) {
    return this.mPasses[passid].GetSamplerFilter(slot);
}

Effect.prototype.SetSamplerWrap = function (passid, slot, str) {
    this.mPasses[passid].SetSamplerWrap(slot, str, this.mBuffers);
}

Effect.prototype.GetSamplerWrap = function (passid, slot) {
    return this.mPasses[passid].GetSamplerWrap(slot);
}

Effect.prototype.SetSamplerVFlip = function (passid, slot, str) {
    this.mPasses[passid].SetSamplerVFlip(slot, str);
}

Effect.prototype.GetSamplerVFlip = function (passid, slot) {
    return this.mPasses[passid].GetSamplerVFlip(slot);
}

Effect.prototype.GetHeaderSize = function (passid)
{
    return this.mPasses[passid].mHeaderLength + 
           this.mRenderer.GetShaderHeaderLines(1);
 
}

Effect.prototype.ToggleVolume = function()
{
    this.mForceMuted = !this.mForceMuted;

    // outp
    if (this.mForceMuted)
        this.mGainNode.gain.value = 0.0;
    else
        this.mGainNode.gain.value = 1.0;

    // inp
    let num = this.mPasses.length;
    for( let j=0; j<num; j++ )
    {
        for( let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            if( this.mForceMuted )
                this.mPasses[j].MuteInput( this.mAudioContext, i );
            else
                this.mPasses[j].UnMuteInput( this.mAudioContext, i );
        }
    }

    return this.mForceMuted;
}

Effect.prototype.SetKeyDown = function( passid, k )
{
    if( this.mKeyboard.mData[ k + 0*256 ] == 255 ) return;

    this.mKeyboard.mData[ k + 0*256 ] = 255;
    this.mKeyboard.mData[ k + 1*256 ] = 255;
    this.mKeyboard.mData[ k + 2*256 ] = 255 - this.mKeyboard.mData[ k + 2*256 ];
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    let num = this.mPasses.length;
    for (let j=0; j<num; j++ )
    {
        for (let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            let inp = this.mPasses[j].mInputs[i];
            if( inp!==null && inp.mInfo.mType==="keyboard" )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:this.mKeyboard.mIcon, mData: this.mKeyboard.mData}, false, 6, 1, -1.0, this.mPasses[j].mID );
            }
        }
    }
}

Effect.prototype.SetKeyUp = function( passid, k )
{
    this.mKeyboard.mData[ k + 0*256 ] = 0;
    this.mKeyboard.mData[ k + 1*256 ] = 0;
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    let num = this.mPasses.length;
    for (let j=0; j<num; j++ )
    {
        for (let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            let inp = this.mPasses[j].mInputs[i];
            if( inp!==null && inp.mInfo.mType==="keyboard" )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:this.mKeyboard.mIcon, mData: this.mKeyboard.mData}, false, 6, 1, -1.0, this.mPasses[j].mID );
            }
        }
    }

}

Effect.prototype.StopOutputs = function()
{
    let wa = this.mAudioContext;

    let num = this.mPasses.length;
    for (let i=0; i<num; i++ )
    {
        this.mPasses[i].StopOutput( wa );
    }
}

Effect.prototype.ResumeOutputs = function()
{
    let wa = this.mAudioContext;

    let num = this.mPasses.length;
    for (let i=0; i<num; i++ )
    {
        this.mPasses[i].ResumeOutput( wa );
    }
}

Effect.prototype.PauseInput = function( passid, id )
{
    return this.mPasses[passid].TooglePauseInput( this.mAudioContext, id );
}

Effect.prototype.ToggleMuteInput = function( passid, id )
{
    return this.mPasses[passid].ToggleMuteInput( this.mAudioContext, id );
}

Effect.prototype.RewindInput = function( passid, id )
{
    this.mPasses[passid].RewindInput( this.mAudioContext, id );
}

Effect.prototype.UpdateInputs = function( passid, forceUpdate )
{
   this.mPasses[passid].UpdateInputs( this.mAudioContext, forceUpdate, this.mKeyboard );
}

Effect.prototype.ResetTime = function()
{
    this.mFrame = 0;
    this.mAudioContext.resume()

    let num = this.mPasses.length;
    for( let i=0; i<num; i++ )
    {
        this.mPasses[i].mFrame = 0;
        for( let j=0; j<this.mPasses[i].mInputs.length; j++ )
            this.mPasses[i].RewindInput(this.mAudioContext, j)
    }
}

Effect.prototype.RequestAnimationFrame = function (id)
{
    if (this.mRenderingStereo && this.mWebVR.IsPresenting())
    {
        this.mWebVR.RequestAnimationFrame(id);
    }
    else
    {
        requestAnimFrame(id);
    }
}

Effect.prototype.Paint = function(time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, isPaused)
{
    let wa = this.mAudioContext;
    let da = new Date();
    let vrData = null; if (this.mRenderingStereo) vrData = this.mWebVR.GetData();
    let xres = this.mXres / 1;
    let yres = this.mYres / 1;

    if( this.mFrame===0 )
    {
        for( let i=0; i<this.mMaxBuffers; i++ )
        {
            if( this.mBuffers[i].mTexture[0]!==null )
            {
                this.mRenderer.SetRenderTarget( this.mBuffers[i].mTarget[0] );
                this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
                this.mRenderer.SetRenderTarget( this.mBuffers[i].mTarget[1] );
                this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
				
				this.mRenderer.CreateMipmaps( this.mBuffers[i].mTexture[0] );
				this.mRenderer.CreateMipmaps( this.mBuffers[i].mTexture[1] );
            }
        }
        for( let i=0; i<this.mMaxCubeBuffers; i++ )
        {
            if( this.mCubeBuffers[i].mTexture[0]!==null )
            {
                for( let face=0; face<6; face++ )
                {
                    this.mRenderer.SetRenderTargetCubeMap( this.mCubeBuffers[i].mTarget[0], face );
                    this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
                    this.mRenderer.SetRenderTargetCubeMap( this.mCubeBuffers[i].mTarget[1], face );
                    this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
					this.mRenderer.CreateMipmaps( this.mCubeBuffers[i].mTexture[0] );
				    this.mRenderer.CreateMipmaps( this.mCubeBuffers[i].mTexture[1] );
                }
            }
        }
    }

    let num = this.mPasses.length;

    // render sound first
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "sound" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, null, false, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render buffers second
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "buffer" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        let bufferID = assetID_to_bufferID( this.mPasses[i].mOutputs[0] );

        // check if any downstream pass needs mipmaps when reading from this buffer
        let needMipMaps = false;
        for (let j=0; j<num; j++ )
        {
            for (let k=0; k<this.mPasses[j].mInputs.length; k++ )
            {
                let inp = this.mPasses[j].mInputs[k];
                if( inp!==null && inp.mInfo.mType==="buffer" && inp.id === bufferID && inp.mInfo.mSampler.filter === "mipmap")
                {
                    needMipMaps = true;
                    break;
                }
            }
        }

        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, needMipMaps, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }


    // render cubemap buffers second
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "cubemap" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        let bufferID = 0;//assetID_to_bufferID( this.mPasses[i].mOutputs[0] );

        // check if any downstream pass needs mipmaps when reading from this buffer
        let needMipMaps = false;

        for (let j=0; j<num; j++ )
        {
            for (let k=0; k<this.mPasses[j].mInputs.length; k++ )
            {
                let inp = this.mPasses[j].mInputs[k];
                if( inp!==null && inp.mInfo.mType==="cubemap" )
                {
                    if( assetID_to_cubemapBuferID(inp.mInfo.mID)===0 && inp.mInfo.mSampler.filter === "mipmap" )
                    {
                        needMipMaps = true;
                        break;
                    }
                }
            }
        }

        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, needMipMaps, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render image last
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "image" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, null, false, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }   

    // erase keypresses
    for (let k=0; k<256; k++ )
    {
       this.mKeyboard.mData[ k + 1*256 ] = 0;
    }
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    if( this.mRenderingStereo ) this.mWebVR.Finish();

    this.mFrame++;
}

Effect.prototype.NewShader = function( passid, preventCache, onResolve )
{
    let commonSourceCodes = [];
    for (let i=0; i<this.mPasses.length; i++ )
    {
        if( this.mPasses[i].mType==="common")
        {
            commonSourceCodes.push(this.mPasses[i].mSource);
        }
    }

    this.mPasses[passid].NewShader(commonSourceCodes, preventCache, onResolve );
}

Effect.prototype.GetNumPasses = function()
{
    return this.mPasses.length;
}

Effect.prototype.GetNumOfType = function(passtype)
{
    let id = 0;
    for (let j=0; j<this.mPasses.length; j++ )
    {
        if( this.mPasses[j].mType===passtype )
        {
            id++;
        }
    }
    return id;
}

Effect.prototype.GetPassType = function( id )
{
    return this.mPasses[id].mType;
}
Effect.prototype.GetPassName = function( id )
{
    return this.mPasses[id].mName;
}
Effect.prototype.GetCode = function( id )
{
    return this.mPasses[id].mSource;
}
Effect.prototype.SetCode = function( id, source )
{
    this.mPasses[id].SetCode(source);
}
Effect.prototype.GetError = function (id)
{
    return this.mPasses[id].mError;
}
Effect.prototype.GetErrorStr = function (id)
{
    return this.mPasses[id].mErrorStr;
}
Effect.prototype.GetErrorGlobal = function()
{
    for (let i = 0; i < this.mPasses.length; i++)
    {
        if (this.mPasses[i].mError)
        {
            return true;
        }
    }
    return false;
}

Effect.prototype.Load = function (jobj )
{
    if (jobj.ver !== "0.1")
    {
        console.log("Wrong Format");
        return false;
    }

    let numPasses = jobj.renderpass.length;

    if( numPasses<1 || numPasses>this.mMaxPasses )
    {
        console.log("Corrupted Shader - " + numPasses);
        return false;
    }

    this.mPasses = [];
    for (let j = 0; j < numPasses; j++)
    {
        let rpass = jobj.renderpass[j];

        // skip sound passes if in thumbnail mode
        if( this.mForceMuted && rpass.type === "sound" ) continue;

        let wpass = new EffectPass(this.mRenderer, this.mIs20, this.mIsLowEnd, this.mShaderTextureLOD,
                                   this.mTextureCallbackFun, this.mTextureCallbackObj, this.mForceMuted, this.mForcePaused, this.mGainNode,
                                   this.mProgramDownscale, j, this);

        wpass.Create(rpass.type, this.mAudioContext);

        let numInputs = rpass.inputs.length;

        for (let i = 0; i < 4; i++)
        {
            wpass.NewTexture(this.mAudioContext, i, null, null, null);
        }
        for (let i = 0; i < numInputs; i++)
        {
            let lid  = rpass.inputs[i].channel;
            let styp = rpass.inputs[i].type;
            let sid  = rpass.inputs[i].id;
            let ssrc = rpass.inputs[i].filepath;
            let psrc = rpass.inputs[i].previewfilepath;
            let samp = rpass.inputs[i].sampler;

            wpass.NewTexture(this.mAudioContext, lid, { mType: styp, mID: sid, mSrc: ssrc, mSampler: samp, mPreviewSrc: psrc }, this.mBuffers, this.mCubeBuffers, this.mKeyboard);
        }

        for (let i = 0; i < 4; i++)
        {
            wpass.SetOutputs(i, null);
        }

        let numOutputs = rpass.outputs.length;
        for (let i = 0; i < numOutputs; i++)
        {
            let outputID = rpass.outputs[i].id;
            let outputCH = rpass.outputs[i].channel;
            wpass.SetOutputs(outputCH, outputID);
        }

        // create some hardcoded names. This should come from the DB
        let rpassName = "";
        if (rpass.type === "common" ) rpassName = "Common";
        if (rpass.type === "sound"  ) rpassName = "Sound";
        if (rpass.type === "image"  ) rpassName = "Image";
        if (rpass.type === "buffer") rpassName = "Buffer " + String.fromCharCode(65 + assetID_to_bufferID(wpass.mOutputs[0]));
        if (rpass.type === "cubemap") rpassName = "Cube A";// " + String.fromCharCode(65 + assetID_to_bufferID(this.mPasses[j].mOutputs[0]));
        wpass.SetName(rpassName);
        wpass.SetCode(rpass.code);

        this.mPasses.push(wpass);
    }
    return true;
}

Effect.prototype.CompileSome = function ( passes, preventCache, onResolve )
{
    let me = this;

    let to = getRealTime();
    let allPromisses = [];
    for (let j = 0; j < passes.length; j++)
    {
        allPromisses.push(new Promise(function (resolve, reject)
        {
            me.NewShader(passes[j], preventCache, function () { resolve(1); });
        }));
    }

    // aggregated callback when all passes have been compiled
    Promise.all(allPromisses).then(function (values)
    {
        let totalError = false;
        for (let j = 0; j < me.mPasses.length; j++)
        {
            if (me.mPasses[j].mError)
            {
                totalError = true;
                break;
            }
        }
        me.mCompilationTime = getRealTime() - to;
        onResolve(!totalError);
    }).catch(console.log);
}

Effect.prototype.Compile = function (preventCache, onResolve )
{
    let me = this;

    let to = getRealTime();
    let allPromisses = [];
    let numPasses = this.mPasses.length;
    for (let j = 0; j < numPasses; j++)
    {
        allPromisses.push(new Promise(function (resolve, reject)
        {
            me.NewShader(j, preventCache, function () { resolve(1); });
        }));
    }

    // aggregated callback when all passes have been compiled
    Promise.all(allPromisses).then(function (values)
    {
        let totalError = false;
        for (let j = 0; j < numPasses; j++)
        {
            if (me.mPasses[j].mError)
            {
                totalError = true;
                break;
            }
        }
        me.mCompilationTime = getRealTime() - to;
        onResolve(!totalError);
    }).catch(console.log);
}

Effect.prototype.GetCompilationTime = function( id )
{
    return this.mPasses[id].GetCompilationTime()/1000.0;
}
Effect.prototype.GetTotalCompilationTime = function()
{
    return this.mCompilationTime/1000.0;
}

Effect.prototype.DestroyPass = function( id )
{
   this.mPasses[id].Destroy( this.mAudioContext );
   this.mPasses.splice(id, 1);
}

Effect.prototype.AddPass = function( passType, passName, onResolve )
{
    let shaderStr = null;

    if( passType==="sound"   ) shaderStr = "vec2 mainSound( int samp, float time )\n{\n    // A 440 Hz wave that attenuates quickly overt time\n    return vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );\n}";
    if( passType==="buffer"  ) shaderStr = "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}";
    if( passType==="common"  ) shaderStr = "vec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}";
    if( passType==="cubemap" ) shaderStr = "void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Ray direction as color\n    vec3 col = 0.5 + 0.5*rayDir;\n\n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}";

    let id = this.GetNumPasses();
    this.mPasses[id] = new EffectPass( this.mRenderer, this.mIs20, this.mIsLowEnd, this.mShaderTextureLOD,
                                       this.mTextureCallbackFun, this.mTextureCallbackObj, this.mForceMuted, this.mForcePaused, this.mGainNode, 
                                       this.mProgramDownscale, id, this );

    this.mPasses[id].Create( passType, this.mAudioContext );
    this.mPasses[id].SetName( passName );
    this.mPasses[id].SetCode( shaderStr );
    this.NewShader(id, false, function ()
    {
        onResolve();
    });

    return { mId : id, mShader : shaderStr };
}

// this should be removed once we have MultiPass 2.0 and passes render to arbitrary buffers
Effect.prototype.IsBufferPassUsed = function( bufferID )
{
    for (let j=0; j<this.mPasses.length; j++ )
    {
        if( this.mPasses[j].mType !== "buffer" ) continue;
        if( this.mPasses[j].mOutputs[0] === bufferID_to_assetID(bufferID) ) return true;
    }
    return false;
}

Effect.prototype.Save = function()
{
    var result = {};

    result.ver = "0.1";

    result.renderpass = [];

    let numPasses = this.mPasses.length;
    for (let j=0; j<numPasses; j++ )
    {
        result.renderpass[j] = {};

        result.renderpass[j].outputs = new Array();
        for (let i = 0; i<4; i++ )
        {
            let outputID = this.mPasses[j].mOutputs[i];
            if( outputID===null ) continue;
            result.renderpass[j].outputs.push( { channel: i, id: outputID } );
        }
        result.renderpass[j].inputs = new Array();
        for (let i = 0; i<4; i++ )
        {
            if( this.mPasses[j].mInputs[i]===null ) continue;
            result.renderpass[j].inputs.push( {channel: i,
                                               type    : this.mPasses[j].mInputs[i].mInfo.mType,
                                               id      : this.mPasses[j].mInputs[i].mInfo.mID,
                                               filepath: this.mPasses[j].mInputs[i].mInfo.mSrc,
                                               sampler : this.mPasses[j].mInputs[i].mInfo.mSampler });
        }

        result.renderpass[j].code = this.mPasses[j].mSource;
        result.renderpass[j].name = this.mPasses[j].mName
        result.renderpass[j].description = "";
        result.renderpass[j].type = this.mPasses[j].mType;
    }

    result.flags = this.calcFlags();

    return result;
}

Effect.prototype.calcFlags = function ()
{
    let flagVR = false;
    let flagWebcam = false;
    let flagSoundInput = false;
    let flagSoundOutput = false;
    let flagKeyboard = false;
    let flagMultipass = false;
    let flagMusicStream = false;

    let numPasses = this.mPasses.length;
    for (let j = 0; j < numPasses; j++)
    {
        let pass = this.mPasses[j];

        if (pass.mType === "sound") flagSoundOutput = true;
        if (pass.mType === "buffer") flagMultipass = true;

        for (let i = 0; i < 4; i++)
        {
            if (pass.mInputs[i] === null) continue;

            if (pass.mInputs[i].mInfo.mType === "webcam") flagWebcam = true;
            else if (pass.mInputs[i].mInfo.mType === "keyboard") flagKeyboard = true;
            else if (pass.mInputs[i].mInfo.mType === "mic") flagSoundInput = true;
            else if (pass.mInputs[i].mInfo.mType === "musicstream") flagMusicStream = true;
        }

        let n1 = pass.mSource.indexOf("mainVR(");
        let n2 = pass.mSource.indexOf("mainVR (");
        if (n1 > 0 || n2 > 0) flagVR = true;
    }

    return {
        mFlagVR: flagVR,
        mFlagWebcam: flagWebcam,
        mFlagSoundInput: flagSoundInput,
        mFlagSoundOutput: flagSoundOutput,
        mFlagKeyboard: flagKeyboard,
        mFlagMultipass: flagMultipass,
        mFlagMusicStream: flagMusicStream
    };
}</script>
    <script>"use strict"

const kMaxCompileTime = 10.0;

function iReportCrash(shaderID)
{
    let req = new XMLHttpRequest();
    req.onload = function ()
    {
        let jsn = req.response;
        if (jsn === null) return;
        if (jsn.result === 0)
        {
            // yep
        }
    };
    req.open("POST", "/shadertoy", true);
    req.responseType = "json";
    req.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    req.send( "s=" + shaderID + "&r=2" );
}
</script>
    <script>"use strict"

var gActive = -1;
var mShaders = [];
var gNumCanvases = 0;

function myrefresh( id, slot, img, forceFrame, gui, guiID, renderID, time )
{
    if( mShaders[id].mReady===false ) return;
    if( forceFrame )
    {
        if (mShaders[id].mScreenshot === false)
        {
            mShaders[id].gEffect.Paint(mShaders[id].mTime / 1000.0, 1.0 / 60.0, 60.0, 0, 0, 0, 0, false);
        }
    }
}

function startRendering()
{
    if( gActive<0 ) return;
    if( mShaders[gActive].mReady===false ) return;
    if( mShaders[gActive].mScreenshot===true ) return;

    let time = getRealTime();

    mShaders[gActive].mFPS.Count( time );
    mShaders[gActive].mTime = mShaders[gActive].mTime0 + (time - mShaders[gActive].mTo);
    let dtime = 1000.0/60.0;
    mShaders[gActive].gEffect.Paint( mShaders[gActive].mTime/1000.0, dtime/1000.0, mShaders[gActive].mFPS.GetFPS(), 0,0,0,0, false);

    requestAnimFrame( startRendering );
}

function iLoadAndCompile(jsn, i )
{
    var shaderObj = jsn[i];
    if (shaderObj === null) return;

    var resizeCB = function (xres, yres) { myrefresh(i, 0, null, true, false, 0, -1.0) };
    var crashCB = function () { alert('crash');/*iReportCrash(gShaderIDs[i])*/ };
    mShaders[i].gEffect = new Effect(null, null, mShaders[i].mPreview.mCanvas, myrefresh, i, true, true, resizeCB, crashCB);

    if (!mShaders[i].gEffect.Load(shaderObj)) return;

    mShaders[i].gEffect.Compile(false, function (worked)
    {
        if (worked === true)
        {
            previewShowRender(mShaders[i].mPreview);

            mShaders[i].mScreenshot = false;
            mShaders[i].mReady = true;
            mShaders[i].mTime = 10.0 * 1000.0;
            mShaders[i].mTime0 = 0.0;
            mShaders[i].mTo = 0.0;
            mShaders[i].mFPS = piCreateFPSCounter();
            mShaders[i].mPreview.mCanvas.addEventListener("mouseout", function (ev) { gActive = -1; }, true);
            mShaders[i].mPreview.mBase.addEventListener("mouseover", function (ev) { if (mShaders[i].mPreview.mUI !== null) mShaders[i].mPreview.mUI.classList.add('isVisible'); }, true);
            mShaders[i].mPreview.mBase.addEventListener("mouseout", function (ev) { if (mShaders[i].mPreview.mUI !== null) mShaders[i].mPreview.mUI.classList.remove('isVisible'); }, true);
            mShaders[i].mPreview.mCanvas.addEventListener("mouseover", function (ev)
            {
                let ele = piGetSourceElement(ev);
                if (ele.mId === undefined) return;

                gActive = ele.mId;
                if (!mShaders[gActive].mReady) return;
                let time = getRealTime();
                mShaders[gActive].mTo = time;
                mShaders[gActive].mTime0 = mShaders[gActive].mTime;
                mShaders[gActive].mFPS.Reset(time);

                startRendering();
            }, true);


            /*
            let compilationTime = mShaders[i].gEffect.GetTotalCompilationTime();
            if (compilationTime > kMaxCompileTime)
            {
                iReportCrash(mShaders[i].mShaderID);
            }*/

            myrefresh(i, null, null, true, false, 0, -1.0);
        }
        else
        {
            mShaders[i].mReady = false;
            previewShowError(mShaders[i].mPreview);
        }
    });
};


function iProcessShader( jsn, i )
{
    var shaderObj = jsn[i];
    if( shaderObj===null ) return;

    if ((shaderObj.info.usePreview === 0 && !gUseScreenshots) || (mShaders[i].mPreviewReady !== 1))
    {
        iLoadAndCompile(jsn, i);
    }
    else
    {
        mShaders[i].mScreenshot = true;
        if( shaderObj.info.usePreview === 1 )
            previewShowScreenshot(mShaders[i].mPreview, 1); // comp
        else if (gUseScreenshots)
            previewShowScreenshot(mShaders[i].mPreview, 2); // sett
    }

    if( i<(jsn.length-1) ) setTimeout( function(){iProcessShader(jsn,i+1);}, 10 );
}

function iInitUI(numCanvases, uiCallback, windowTitle)
{
    gNumCanvases = numCanvases;
    document.getElementById("mySearch").focus();

    //-----------------------------------------------------------------
    // window
    //-----------------------------------------------------------------
    if (windowTitle !== null) {
        document.title = windowTitle;
    }

    //-----------------------------------------------------------------
    // ui
    //-----------------------------------------------------------------
    var num = Math.min(gShaders.length, gNumCanvases);

    //var base = document.getElementsByClassName( "searchResult" );

    for (let i = 0; i < gNumCanvases; i++)
    {
        let pv = createPreview(i);

        if (i >= num) {
            previewHide(pv);
            continue;
        }

        let shaderID = gShaders[i].info.id;
        
        if (pv.mUI !== null && uiCallback !== null) {
            pv.mUI.addEventListener('click', function (ev) {
                uiCallback(shaderID);
                ev.preventDefault();
            }, false);
        }
        
        previewShowLoading(pv);
        
        mShaders[i] = {};
        mShaders[i].mShaderID = shaderID;
        mShaders[i].mPreview = pv;
        mShaders[i].mScreenshot = false;
        mShaders[i].mPreview.mLink.href = "/view/" + shaderID;
        mShaders[i].mPreviewReady = 0;
        mShaders[i].mReady = false;
        mShaders[i].gEffect = null;

        previewLoadScreenshot(mShaders[i].mPreview,
            function () { mShaders[i].mPreviewReady = 1; if (mShaders[i].mReady === false) previewShowScreenshot(mShaders[i].mPreview, 0); },
            function () { mShaders[i].mPreviewReady = 2; },
            shaderID);
    }

    if (num <= 0) {
        return;
    }
}

function iInitShaders(jsn)
{
    for (let i = 0; i < jsn.length; i++)
    {
        let shaderObj = jsn[i];
        if (shaderObj === null) continue;
        let inf = shaderObj.info;
        mShaders[i].mPreview.mTextA.textContent = inf.name;
        mShaders[i].mPreview.mTextB.innerHTML = "<a class='user' href='/user/" + htmlEntities(inf.username) + "'>" + htmlEntities(inf.username) + "</a>";
        mShaders[i].mPreview.mTextC.innerHTML = "<img src='/img/themes/" + gThemeName + "/views.png' class='viewsIcon'></img>" + inf.viewed + "    &nbsp;&nbsp;  <img src='/img/themes/" + gThemeName + "/likes.png' class='likesIcon'></img>" + inf.likes;
    }

    setTimeout(function () { iProcessShader(jsn, 0); }, 10);
}

function resultsInitStatic(numCanvases, uiCallback, windowTitle)
{
    iInitUI(numCanvases, uiCallback, windowTitle);

    iInitShaders(gShaders);
}

function resultsInit(numCanvases, uiCallback, windowTitle)
{	
    iInitUI(numCanvases, uiCallback, windowTitle);

    var num = Math.min(gShaderIDs.length, gNumCanvases);

    var mHttpReq = new XMLHttpRequest();

    mHttpReq.abort();

    var str = "{ \"shaders\" : [";
    for( let i=0; i<num; i++ )
    {
         str += "\"" + gShaderIDs[i] + "\"";
         if( i!==(num-1) ) str += ", ";
    }
    str += "] }";

    str = "s=" + encodeURIComponent( str ) + "&nt=0&nl=0&np=0";

    mHttpReq.open( "POST", "/shadertoy", true );
    mHttpReq.responseType = "json";
    mHttpReq.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    mHttpReq.onload = function ()
    {
        let jsn = this.response;
        if( jsn===null )
        {
            console.log( "Could not load shaders" );
            return;
        }

        iInitShaders(jsn);
    }
    mHttpReq.send( str );
}</script>
    <style>
    .shaderPreview
    {
    display: block;
    background-color: #000000;
    background-image: url("/img/loading.gif");
    background-repeat: no-repeat;
    background-position: center;
    padding: 0px;
    margin: 0px;
    border: 0px solid #000000;
    border-radius: 8px;
    width:100%;
    height:100%;
    position: absolute;
    overflow:hidden;
    }

    .previewInfo
    {
    width: 100%;
    left: 0px;
    top: 2px;
    position: relative;
    visibility: hidden;
    }

    .previewCanvas
    {
    left: 0px;
    top: 0px;
    padding: 0px;
    margin: 0px;
    position: absolute;
    cursor: pointer;
    width:100%;
    height:100%;
    border-radius: 8px;
    border: 0px solid #000000;
    backgroundColor: transparent;
visibility: hidden;
opacity:0;
transition: opacity 1.0s ease;
    }

    .previewText
    {
        text-overflow: ellipsis;
    white-space: nowrap;
    padding-right: 1px;
    }

    .previewTextUser
    {
    text-overflow: ellipsis;
    white-space: nowrap;
    padding-left: 3px;
    }

    .previewStats
    {
    padding-right: 1px;
    right: 0px;
    top: 0px;
    position: absolute;
    }

    .previewErrorContainer
    {
    left:0px;
    top:0px;
    width:100%;
    height:100%;
    padding:0px;
    margin:0px;
    background-color:#000000;
    border-radius:8px;
    cursor:pointer;
    visibility:hidden;
    }

    .previewErrorMessage
    {
    top:50%;
    position:absolute;
    width:100%;
    text-align:center;
    padding:0;
    margin:auto;
    color:#ff0000;
    font-size:2em;
    font-style:italic;
    }

    .previewNoGLContainter
    {
    left:0px;
    top:0px;
    width:100%;
    height:100%;
    padding:0px;
    margin:0px;
    position:absolute;
    background-color:#000000;
    border-radius:8px;
    cursor:pointer;
    pointer-events:none;
    visibility:hidden;
    font-size:2em;
    }

    .previewNoGLMessage
    {
    width:86%;
    height:90%;
    padding-left:7%;
    padding-right:7%;
    padding-top:10%;
    padding-bottom:0px;
    color:#ff0000;
    position:absolute;
    visibility:hidden;
    }

    .previewThumbnailContainer
    {
    width:100%;
    height:100%;
    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    cursor:pointer;
    visibility:hidden;
    border-radius:8px;
    border:0px solid #000000;
    }

    .previewThumbnailImage
    {
    width:100%;
    height:100%;
    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    cursor:pointer;
    border-radius:8px;
    border:0px solid #000000;
opacity: 0.0;
transition: opacity 1.0s ease;
    }

    .previewThumbnailIcon
    {
    width:64px;
    height:32px;
    left:0px;
    top:0px;
    padding:0px;
    padding-top:12px;
    margin:0px;
    position:absolute;
    color:#ffffff;
    background-color:#ff8020;
    font-weight:bold;
    border-radius:0px 0px 8px 0px;
    text-align:center;
    //visibility:hidden;
    }


    .previewUIContainter
    {
    display: block;
    right:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    //cursor:pointer;
    //pointer-events:none;
    //visibility:hidden;
    }
</style>

<script>
    function previewHide(me)
    {
    me.mBase.style.visibility = "hidden";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "hidden";
    }

    function previewShowRender(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "visible";
me.mCanvas.style.opacity = 1.0;
    me.mCanvas.style.borderRadius ="8px;";
//  me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "visible";
    }

    function previewShowScreenshot(me, message)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "visible";
me.mThumbnailImg.style.opacity = 1.0;
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "visible";
    me.mThumbnailWar1.style.visibility = (message===1)?"visible":"hidden";
    me.mThumbnailWar2.style.visibility = (message===2)?"visible":"hidden";
    }

    function previewShowLoading(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "hidden";

    me.mLink.style.visibility = "visible";
    me.mBase.style.backgroundColor = "#ff0000;"
    me.mCont.style.visibility = "visible";
    }

    function previewShowNoWebGL(me, shaderID)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "visible";
    me.mError.style.visibility = "visible";
    me.mThumbnailImgNoWebGL.onerror = function(ev) 
                                      { 
                                            me.mThumbnailImgNoWebGL.style.visibility="hidden"; 
                                            me.mMessageNoWebGL.style.visibility="visible"; 
                                      };
    me.mThumbnailImgNoWebGL.src = "/media/shaders/" + shaderID + ".jpg";
    }

    function previewShowError(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "visible";
    me.mCont.style.visibility = "visible";
    }

    function previewLoadScreenshot( me, cbSuccess, cbError, shaderID )
    {
    var url = "/media/shaders/" + shaderID + ".jpg";
    me.mThumbnailImg.onload = cbSuccess;
    me.mThumbnailImg.onerror = function(ev) { cbError(); };
    me.mThumbnailImg.src = url;
    }
        
    function createPreview(id)
    {
        var bar = document.getElementById( "Preview_"+id+"_Canvas" );
        bar.width = bar.offsetWidth;
        bar.height = bar.offsetHeight;
        bar.mId = id;

        return { mBase: document.getElementById( "Preview_"+id+"_Container" ),
        mLink: document.getElementById( "Preview_"+id+"_Link" ),
        mCanvas: bar,
        mCont: document.getElementById( "Preview_"+id+"_Info" ),
        mTextA: document.getElementById( "Preview_"+id+"_Text" ),
        mTextB: document.getElementById( "Preview_"+id+"_TextUser" ),
        mTextC: document.getElementById( "Preview_"+id+"_Stats" ),
        mNoWebGL: document.getElementById( "Preview_"+id+"_NoWebGL" ),
        mError: document.getElementById( "Preview_"+id+"_Error" ),
        mCanvas2D: document.getElementById( "Preview_"+id+"_Thumnail" ),
        mThumbnailImg: document.getElementById( "Preview_"+id+"_ThumnailImage" ),
        mThumbnailWar1: document.getElementById( "Preview_"+id+"_ThumnailWarning1" ),
        mThumbnailWar2: document.getElementById( "Preview_"+id+"_ThumnailWarning2" ),
        mThumbnailImgNoWebGL: document.getElementById( "Preview_"+id+"_ThumnailImageNoWebGL" ),
        mMessageNoWebGL: document.getElementById( "Preview_"+id+"_MessageNoWebGL"),
        mUI: document.getElementById( "Preview_"+id+"_UI" )
        };
    }
</script>

    <style>

    #content
    {
        user-select: text;
        -moz-user-select: -moz-text;
        -webkit-user-select: text;
        padding:0px;
        margin:0px;
        position:relative;
    }

    #divUser
    {
        padding:0px;
        padding-top:24px;
        padding-bottom:16px;
        width:100%;
    }

    div#controls
    {
        width:100%;
        padding-top:16px;
        padding-bottom:16px;
        display:flex;
        justify-content:space-between; 
        flex-wrap:wrap;
    }

    div#controls > div
    {
        display:inline-flex;
    }

    .controlOptions
    {
        display:inline-block;
    }

    div#shaderGrid
    {
        width:100%;
        padding:0px;
        margin:0px;
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        grid-template-rows: repeat(2, 1fr);
        grid-column-gap: 64px;
        grid-row-gap: 16px;
    }

    .searchResult
    {
        margin: 0px;
        padding: 0px;
        width: 100%;
    }
    .searchResultContainer
    {
        width: 100%;
        padding-bottom:56.25%;
        height: 0;
        position: relative;
    }

    div#navigation
    {
        text-align: center;
        width: 100%;
    }


    #userPicture
    {
        background-color:#808080;
        border: 1px solid #000000;
        padding:0px;
        left:0px;
        top:0px;
        width:128px;
        height:128px;
    }

    a.pageButtons, .pageButtonsCurrent
    {
        
        //background-color: #303030;
        border-style: solid;
        border-width: 1px;
        border-color: #808080;
        text-align: center;
        vertical-align: middle;
        margin-left: 12px;
        display: inline-block;
        border-radius: 4px;
		font-weight:bold;
        cursor: pointer;
        padding-bottom:5px;
        padding-top:4px;
        padding-left: 8px;
        padding-right: 8px;
        margin:8px;
    }

    a.pageButtons
    {
        text-decoration: none;
        -moz-transition:    background-color 0.15s linear, color 0.15s linear;
        -webkit-transition: background-color 0.15s linear, color 0.15s linear;
        transition:         background-color 0.15s linear, color 0.15s linear;
    }

    a.pageButtons:hover
    {
      background-color:#808080;
      color : #ff8020;
    }

    .pageButtonsCurrent
    {
        background-color: #808080;
        color:#000000;
    }

    /* ----------------------- media resolutions ------------------------ */

    @media screen and (max-width:799px) 
    {
        div#shaderGrid  { grid-template-columns: 1fr; grid-template-rows: repeat(8, 1fr); grid-column-gap: 0px; grid-row-gap: 16px; padding-bottom:16px; }

        div#controls
        {
            width:100%;
            display:flex;
            justify-content:flex-start; 
            flex-wrap:wrap;
        }

        div#controls > div
        {
            display:inline-flex;
            width:100%;
            margin-left: 0px;
            margin-right: 0px;
            padding-bottom:16px;
        }
    }
    </style>

    <script>

    var gShaders=[{"ver":"0.1","info":{"id":"lsSXzD","date":"1410462817","viewed":70265,"name":"E1M1 - Hangar","username":"P_Malin","description":"The start area of Doom E1M1.\nHold down the mouse button and drag the mouse to move.\nWhere you click relative to the center of the screen sets the view direction.\n\nAlso, check out Reinder's excellent Doom2 shader: https:\/\/www.shadertoy.com\/view\/lsB3zD","likes":167,"published":3,"flags":9,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ E1M1 - Hangar\n\/\/ by @P_Malin\n\n\/\/ Procedural version of Doom E1M1\n\n\/\/ The start area of Doom E1M1.\n\/\/ Click and drag the mouse to move.\n\/\/ Where you click relative to the center of the screen sets the view direction.\n\n\/\/ This is the single pass version. A multi-pass playable version is here: https:\/\/www.shadertoy.com\/view\/lldGDr\n\n\/\/ Also, check out Reinder's excellent Doom2 shader: https:\/\/www.shadertoy.com\/view\/lsB3zD\n\n\/\/ The sectors we draw by default\n#define ENABLE_NUKAGE_SECTORS\n#define ENABLE_START_SECTORS\n\n\/\/ Adding this compiles with \"Unknown Error\" on some machines. Uncomment if you are feeling lucky.\n\/\/#define ENABLE_SECTOR_31\n\n\/\/ Some additional sectors, may need to comment out some of the default ones\n\/\/#define ENABLE_EXTRA_NUKAGE_SECTORS\n\/\/#define ENABLE_MISC_SECTORS\n\n#define ENABLE_SPRITES\n\n#define DEMO_CAMERA\n#define INTRO_EFFECT\n#define DRAW_SKY\n#define HEAD_BOB\n\n#define PIXELATE_IMAGE\n#define QUANTIZE_FINAL_IMAGE\n#define QUANTIZE_TEXTURES\n#define PIXELATE_TEXTURES\n\n\/\/#define DISCARD_BACKGROUND\n\n\/\/#define DRAW_COMPASS\n\n\/\/ Add walls to close entrances to sectors we are not rendering\n#ifndef ENABLE_EXTRA_NUKAGE_SECTORS\n\t#define CLOSE_NUKAGE_SECTOR\n#endif\n#ifndef ENABLE_SECTOR_31\n\t#define CLOSE_START_SECTOR\n#endif\n\n#define FAR_CLIP 10000.0\n\nconst vec2 vFakeResolution = vec2(320.0, 240.0);\n\nconst float kDepthFadeScale = (1.0 \/ 3500.0);\nconst float kExtraLight = 0.0;\n\n\/\/ Light level adjustment to East-West and North-South walls\nconst float kC = (1.0 \/ 16.0);\n\n\nstruct Ray\n{\n    vec3 vRayOrigin;\n    vec3 vRayDir;\n    vec2 vSpriteDir;\n};\n\nvec3 SampleTexture( const in float fTexture, const in vec2 vUV );\nvoid MapIntersect( out float fClosestT, out vec4 vHitInfo, Ray r );\nfloat hash(float p);\n\nvec3 GetCameraRayDir( const in vec2 vWindow, const in vec3 vCameraPos, const in vec3 vCameraTarget )\n{\n\tvec3 vForward = normalize(vCameraTarget - vCameraPos);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n\t\n    const float kFOV = 1.8;\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * kFOV);\n\n\treturn vDir;\n}\n\nvec3 Quantize( const in vec3 col )\n{\n\treturn floor( col * 48.0 + 0.5 ) * (1.0 \/ 48.0);\n}\n\nfloat Cross2d( const in vec2 vA, const in vec2 vB )\n{   \n    \/\/return cross( vec3(vA, 0.0), vec3(vB, 0.0) ).z;\n  \treturn vA.x * vB.y - vA.y * vB.x;\n\n    \/\/return dot(vA * vB.yx, vec2(1.0, -1.0)); \n}\n\nvoid BeginSector( out vec4 vSectorState, const in vec2 vSectorHeights, Ray r )\n{\n    \/\/ store the infinite floor-ceiling plane intersect depth in vSectorState.xy\n    vSectorState.xy = (vSectorHeights - r.vRayOrigin.y) \/ r.vRayDir.y;   \n    vSectorState.zw = vec2(0.0,0.0);\n}\n\n\/\/ Intersect a sidedef that meets another sector with the same floor and ceiling height\nvoid Null( inout vec4 vSectorState, const in int iAx, const in int iAy, const in int iBx, const in int iBy, Ray r )\n{\n    vec2 vA = vec2(iAx, iAy);\n    vec2 vB = vec2(iBx, iBy);\n    \n    vec2 vD = vB - vA;\n    vec2 vOA = vA - r.vRayOrigin.xz;\n\tfloat fDenom = Cross2d( r.vRayDir.xz, vD );\n    float fRcpDenom = 1.0 \/ fDenom;\n    float fHitT = Cross2d( vOA, vD ) * fRcpDenom;\n    float fHitU = Cross2d( vOA, r.vRayDir.xz ) * fRcpDenom;\n\n   \tif((fHitT > 0.0) && (fHitU >= 0.0) && (fHitU < 1.0))\n    {\n        \/\/ If we crossed the sector edge further away than the floor-ceiling intersection\n        \/\/ then we increment the in-out test value\n        \/\/ This is like doing a ray-casting point in polygon test \n        \/\/ http:\/\/en.wikipedia.org\/wiki\/Point_in_polygon\n        \/\/ from the floor\/ceiling intersection depth to far clip depth\n    \tvSectorState.zw += step(vSectorState.xy, vec2(fHitT,fHitT));\n    }\n}\n\nvoid Wall( inout float fClosestT, inout vec4 vHitInfo, inout vec4 vSectorState, const in int iAx, const in int iAy, const in int iBx, const in int iBy, const in int iLen, const in float fLightLevel, const in vec2 vSectorHeights, const in float fTexture, Ray r )\n{\n    vec2 vA = vec2(iAx, iAy);\n    vec2 vB = vec2(iBx, iBy);\n\tfloat fLen = float(iLen);\n    \n    vec2 vD = vB - vA;\n    vec2 vOA = vA - r.vRayOrigin.xz;\n\tfloat fDenom = Cross2d( r.vRayDir.xz, vD );\n    float fRcpDenom = 1.0 \/ fDenom;\n    float fHitT = Cross2d( vOA, vD ) * fRcpDenom;\n    float fHitU = Cross2d( vOA, r.vRayDir.xz ) * fRcpDenom;\n\n    if((fHitT > 0.0) && (fHitU >= 0.0) && (fHitU < 1.0))\n    {\n        \/\/ If we crossed the sector edge further away than the floor-ceiling intersection\n        \/\/ then we increment the in-out test value\n        \/\/ This is like doing a ray-casting point in polygon test \n        \/\/ http:\/\/en.wikipedia.org\/wiki\/Point_in_polygon\n        \/\/ from the floor\/ceiling intersection depth to far clip depth\n        vSectorState.zw += step(vSectorState.xy, vec2(fHitT,fHitT));\n\n        if((fHitT < fClosestT) && (fDenom < 0.0))\n        {        \n            float fHitY = r.vRayDir.y * fHitT + r.vRayOrigin.y;\n            if( (fHitY > vSectorHeights.x) && (fHitY < vSectorHeights.y) )\n            {\n                fClosestT = fHitT;\n                vHitInfo = vec4(fHitU * fLen, fHitY, fLightLevel, fTexture);            \n            }\n        }\n    }\n}\n\nvoid Open( inout float fClosestT, inout vec4 vHitInfo, inout vec4 vSectorState, const in int iAx, const in int iAy, const in int iBx, const in int iBy, const in int iLen, const in float fLightLevel, const in vec2 vSectorHeights, const in int iLowerHeight, const in int iUpperHeight, const in float fLowerTexture, const in float fUpperTexture, Ray r )\n{ \n    vec2 vA = vec2(iAx, iAy);\n    vec2 vB = vec2(iBx, iBy);\n\tfloat fLen = float(iLen);\n    float fUpperHeight = float(iUpperHeight);\n    float fLowerHeight = float(iLowerHeight);\n\t\n    vec2 vD = vB - vA;\n    vec2 vOA = vA - r.vRayOrigin.xz;\n\tfloat fDenom = Cross2d( r.vRayDir.xz, vD );\n    float fRcpDenom = 1.0 \/ fDenom;\n    float fHitT = Cross2d( vOA, vD ) * fRcpDenom;\n    float fHitU = Cross2d( vOA, r.vRayDir.xz ) * fRcpDenom;\n\n    if((fHitT > 0.0) && (fHitU >= 0.0) && (fHitU < 1.0))\n    {\n        \/\/ If we crossed the sector edge further away than the floor-ceiling intersection\n        \/\/ then we increment the in-out test value\n        \/\/ This is like doing a ray-casting point in polygon test \n        \/\/ http:\/\/en.wikipedia.org\/wiki\/Point_in_polygon\n        \/\/ from the floor\/ceiling intersection depth to far clip depth\n        vSectorState.zw += step(vSectorState.xy, vec2(fHitT,fHitT));\n        \n        if((fHitT < fClosestT) && (fDenom < 0.0))\n        {\n            float fHitY = r.vRayDir.y * fHitT + r.vRayOrigin.y;\n            if( (fHitY > vSectorHeights.x) && (fHitY < vSectorHeights.y) )\n            {\n                if(fHitY < fLowerHeight)\n                {\n                    fClosestT = fHitT;\n                    vHitInfo = vec4(fHitU * fLen, fHitY - fLowerHeight, fLightLevel, fLowerTexture);                   \n                }            \n                if(fHitY > fUpperHeight)\n                {\n                    fClosestT = fHitT;\n                    vHitInfo = vec4(fHitU * fLen, fHitY - fUpperHeight, fLightLevel, fUpperTexture);                   \n                }\n            }\n        }\n    }\n}\n\nvoid Upper( inout float fClosestT, inout vec4 vHitInfo, inout vec4 vSectorState, const in int iAx, const in int iAy, const in int iBx, const in int iBy, const in int iLen, const in float fLightLevel, const in vec2 vSectorHeights, const in int iUpperHeight, const in float fUpperTexture, Ray r )\n{ \n    vec2 vA = vec2(iAx, iAy);\n    vec2 vB = vec2(iBx, iBy);\n\tfloat fLen = float(iLen);\n    float fUpperHeight = float(iUpperHeight);\n    \n    vec2 vD = vB - vA;\n    vec2 vOA = vA - r.vRayOrigin.xz;\n\tfloat fDenom = Cross2d( r.vRayDir.xz, vD );\n    float fRcpDenom = 1.0 \/ fDenom;\n    float fHitT = Cross2d( vOA, vD ) * fRcpDenom;\n    float fHitU = Cross2d( vOA, r.vRayDir.xz ) * fRcpDenom;\n\n    if((fHitT > 0.0) && (fHitU >= 0.0) && (fHitU < 1.0))\n    {\n        \/\/ If we crossed the sector edge further away than the floor-ceiling intersection\n        \/\/ then we increment the in-out test value\n        \/\/ This is like doing a ray-casting point in polygon test \n        \/\/ http:\/\/en.wikipedia.org\/wiki\/Point_in_polygon\n        \/\/ from the floor\/ceiling intersection depth to far clip depth\n        vSectorState.zw += step(vSectorState.xy, vec2(fHitT,fHitT));\n        \n        if((fHitT < fClosestT) && (fDenom < 0.0))\n        {\n            float fHitY = r.vRayDir.y * fHitT + r.vRayOrigin.y;\n            if( fHitY < vSectorHeights.y )\n            {           \n                if(fHitY > fUpperHeight)\n                {\n                    fClosestT = fHitT;\n                    vHitInfo = vec4(fHitU * fLen, fHitY - fUpperHeight, fLightLevel, fUpperTexture);                   \n                }\n            }\n        }\n    }\n}\n\n\nvoid Lower( inout float fClosestT, inout vec4 vHitInfo, inout vec4 vSectorState, const in int iAx, const in int iAy, const in int iBx, const in int iBy, const in int iLen, const in float fLightLevel, const in vec2 vSectorHeights, const in int iLowerHeight, const in float fLowerTexture, Ray r )\n{ \n    vec2 vA = vec2(iAx, iAy);\n    vec2 vB = vec2(iBx, iBy);\n\tfloat fLen = float(iLen);\n    float fLowerHeight = float(iLowerHeight);\n    \n    vec2 vD = vB - vA;\n    vec2 vOA = vA - r.vRayOrigin.xz;\n\tfloat fDenom = Cross2d( r.vRayDir.xz, vD );\n    float fRcpDenom = 1.0 \/ fDenom;\n    float fHitT = Cross2d( vOA, vD ) * fRcpDenom;\n    float fHitU = Cross2d( vOA, r.vRayDir.xz ) * fRcpDenom;\n\n    if((fHitT > 0.0) && (fHitU >= 0.0) && (fHitU < 1.0))\n    {\n        \/\/ If we crossed the sector edge further away than the floor-ceiling intersection\n        \/\/ then we increment the in-out test value\n        \/\/ This is like doing a ray-casting point in polygon test \n        \/\/ http:\/\/en.wikipedia.org\/wiki\/Point_in_polygon\n        \/\/ from the floor\/ceiling intersection depth to far clip depth\n        vSectorState.zw += step(vSectorState.xy, vec2(fHitT,fHitT));\n        \n        if((fHitT < fClosestT) && (fDenom < 0.0))\n        {\n            float fHitY = r.vRayDir.y * fHitT + r.vRayOrigin.y;\n            if( fHitY > vSectorHeights.x )\n            {           \n                if(fHitY < fLowerHeight)\n                {\n                    fClosestT = fHitT;\n                    vHitInfo = vec4(fHitU * fLen, fHitY - fLowerHeight, fLightLevel, fLowerTexture);                   \n                }            \n            }\n        }\n    }\n}\n\nvoid EndSector( inout float fClosestT, inout vec4 vHitInfo, in vec4 vSectorState, const in float fLightLevel, const in vec2 vFloorCeilingTextures, Ray r )\n{\n    \/\/ Test the even-odd state of our sector floor\/ceiling in-out values\n    vec2 vInOutTest = fract( vSectorState.zw * 0.5 ) * 2.0;\n\n    if( fClosestT > vSectorState.x )\n    {\n        if((vInOutTest.x > 0.5) && (vSectorState.x > 0.0))\n        {\n            vec3 vFloorPos = r.vRayOrigin + r.vRayDir * vSectorState.x;        \n            if( r.vRayOrigin.y > vFloorPos.y )\n            {\n                fClosestT = vSectorState.x;\n                vHitInfo = vec4( vFloorPos.xz, fLightLevel, vFloorCeilingTextures.x);\n            }\n        }\n    }\n\n    if( fClosestT > vSectorState.y )\n    {\n        if((vInOutTest.y > 0.5) && (vSectorState.y > 0.0))\n        {\n            vec3 vCeilingPos = r.vRayOrigin + r.vRayDir * vSectorState.y;        \n            if( r.vRayOrigin.y < vCeilingPos.y )\n            {\n                fClosestT = vSectorState.y;\n                vHitInfo = vec4( vCeilingPos.xz, fLightLevel, vFloorCeilingTextures.y);\n            }\n        }            \n    }\n}\n\n#ifdef ENABLE_SPRITES\n\nvoid Sprite( out float fClosestT, out vec4 vHitInfo, const in vec2 vSpriteDir, const in int iX, const in int iY, const in int iZ, vec2 vSize, float fLightLevel, float fTexture, Ray r )\n{\n\tvec3 vPos = vec3(iX, iY, iZ);\n\tfClosestT = FAR_CLIP;\n\tvHitInfo = vec4(0.0,0.0,0.0,0.0);\n\tvec2 vA = vPos.xz - vSpriteDir * 0.5 * vSize.x;\n\tvec2 vB = vPos.xz + vSpriteDir * 0.5 * vSize.x;\n    vec2 vD = vB - vA;\n    vec2 vOA = vA - r.vRayOrigin.xz;\n    float rcpdenom = 1.0 \/ Cross2d( r.vRayDir.xz, vD ); \n    float fHitT = Cross2d( vOA, vD ) * rcpdenom;\n\n    if(fHitT > 0.0)\n    {\n\t    float fHitU = Cross2d( vOA, r.vRayDir.xz ) * rcpdenom;\n        if((fHitU >= 0.0) && (fHitU < 1.0))\n        {\n            float fHitY = r.vRayDir.y * fHitT + r.vRayOrigin.y;\n            if( (fHitT < fClosestT) && (fHitY > vPos.y) && (fHitY < (vPos.y + vSize.y)) )\n            {\n                fClosestT = fHitT;\n                vHitInfo = vec4(fHitU * vSize.x, fHitY - vPos.y, fLightLevel, fTexture);            \n            }\n        }\n    }\n}\n\nbool MaskBarrel(vec2 vTexCoord)\n{\n\tvec2 vSize = vec2(23.0, 32.0);\n\t\n\tvTexCoord = floor(vTexCoord);\n\t\n\t\/\/ remove corner pixels\n\tvec2 vWrapCoord = fract((vTexCoord + vec2(2.0, 1.0) ) \/ vSize) * vSize;\n\t\n\treturn ( (vWrapCoord.x >= 4.0) || (vWrapCoord.y >= 2.0) );\n}\n\n\nvec4 CosApprox( vec4 x )\n{\n\tx = abs(fract(x * (0.5))*2.0 - 1.0);\n\tvec4 x2 = x*x;\n\treturn( ( x2 * 3.0) - ( 2.0 * x2*x) );\n}\n\nbool MaskCorpseSprite(vec2 vTexCoord)\n{\n\t\/\/vTexCoord = floor(vTexCoord);\n    \n    vec2 vUV = vTexCoord.xy \/ vec2(57.0, 22.0);\n    vec2 vOffset = vUV;\n    vOffset = vOffset * 2.0 -vec2(1.0, 0.8);\n    float fDist = dot(vOffset, vOffset);\n    fDist += dot(CosApprox(vTexCoord.xyxy * vec4(0.55, 0.41, 0.25, 0.1)), vec4(0.2 * -vOffset.yyyy));\n\treturn fDist < 0.4;\n}\n\n#define TEX_BAR1A 32.0\n#define TEX_PLAYW 33.0\n\nvoid BarrelSprite(inout float fClosestT, inout vec4 vHitInfo, const in vec2 vSpriteDir, const in int iX, const in int iY, const in int iZ, const in float fLightLevel, Ray r )\n{\n\tfloat fSpriteT;\n\tvec4 vSpriteHitInfo;\t\t\n\tSprite( fSpriteT, vSpriteHitInfo, vSpriteDir, iX, iY, iZ, vec2(23.0, 32.0), fLightLevel, TEX_BAR1A, r);\n\t\n\tif(fSpriteT < fClosestT)\n\t{\n\t\tif(MaskBarrel(vSpriteHitInfo.xy))\n\t\t{\n\t\t\tfClosestT = fSpriteT;\n\t\t\tvHitInfo = vSpriteHitInfo;\n\t\t}\n\t}\n}\n\nvoid CorpseSprite(inout float fClosestT, inout vec4 vHitInfo, const in vec2 vSpriteDir, const in int iX, const in int iY, const in int iZ, const in float fLightLevel, Ray r )\n{\n\tfloat fSpriteT;\n\tvec4 vSpriteHitInfo;\t\t\n\tSprite( fSpriteT, vSpriteHitInfo, vSpriteDir, iX, iY, iZ, vec2(57.0, 22.0), fLightLevel, TEX_PLAYW, r );\n\n\tif(fSpriteT < fClosestT)\n\t{\n\t\tif(MaskCorpseSprite(vSpriteHitInfo.xy))\n\t\t{\n\t\t\tfClosestT = fSpriteT;\n\t\t\tvHitInfo = vSpriteHitInfo;\n\t\t}\n\t}\n}\n#endif\n\nvec3 DrawScene(vec3 vForwards, vec2 vUV, Ray r )\n{\n    \n    vec4 vHitInfo;\n    float fClosestT;\n\tfloat fNoFog = 0.0;\n\n\t\n    MapIntersect( fClosestT, vHitInfo, r );\n\n\n    #ifdef ENABLE_SPRITES\n\tvec2 vSpriteDir = -normalize(vec2(-vForwards.z, vForwards.x));\n    BarrelSprite(fClosestT, vHitInfo, vSpriteDir, 1088, 0, -2944, 0.565, r);\n    BarrelSprite(fClosestT, vHitInfo, vSpriteDir, 864, 0, -3328, 0.565, r);\n    BarrelSprite(fClosestT, vHitInfo, vSpriteDir, 1312, -16, -3264, 0.878, r);\n    CorpseSprite(fClosestT, vHitInfo, vSpriteDir, 1024, -16, -3264, 0.878, r);\n    #endif\t\n\t\n\tvHitInfo.z = clamp(vHitInfo.z + kExtraLight, 0.0, 1.0);\n\n    \/\/ sky\n    #ifdef DRAW_SKY\n    float fDoSky = step(0.9, vHitInfo.w) * step(vHitInfo.w, 1.1);\n    \n    fNoFog = max(fNoFog, fDoSky);\n    float fSkyU = (atan(vForwards.x, vForwards.z) * 512.0 \/ radians(180.0)) + vUV.x * 320.0;\n    float fSkyV = vUV.y * 240.0;\n    vHitInfo = mix(vHitInfo, vec4(fSkyU, fSkyV, 1.0, 1.0), fDoSky);\n    #endif\n    \n    \/\/ fade in effect\n\t#ifdef INTRO_EFFECT\n    float fEffectOffset = max(iTime - 1.0, 0.0) - hash(vUV.x);\n    vec2 vEffectUV = vUV;\n    vEffectUV.y += clamp(fEffectOffset, 0.0, 1.0);\n    \n    float fDoEffect = step(vEffectUV.y, 1.0);       \n    vHitInfo = mix(vHitInfo, vec4(vEffectUV * 128.0, 1.0, 3.0), fDoEffect);\n    fNoFog = max(fNoFog, fDoEffect);\n    #endif    \n\n\t#ifdef DISCARD_BACKGROUND    \n    if(vHitInfo.w == 0.0) discard;\n\t#endif\n    \n    float fLightLevel = clamp( vHitInfo.z, 0.0, 1.0 );\n    float fDepth = dot(r.vRayDir, vForwards) * fClosestT;\n    float fDepthFade = fDepth * kDepthFadeScale;\n    float fApplyFog = 1.0 - fNoFog;\n    fLightLevel = clamp( fLightLevel - fDepthFade * fApplyFog, 0.0, 1.0 );\n    \n    vec3 vResult = SampleTexture( vHitInfo.w, vHitInfo.xy ) * fLightLevel;\n    \n    vResult = clamp(vResult * 1.2, 0.0, 1.0);\n    \n    #ifdef QUANTIZE_FINAL_IMAGE\n    vResult = Quantize(vResult);\n    #endif    \n    \n    return vResult;\n}\n\nvoid DemoCamera( float time, inout vec3 vCameraPos, inout vec3 vCameraTarget )\n{\n    vCameraPos = vec3(1050, 30, -3616);\n    vCameraTarget = vec3(1050, 30, -3500);\n\n    #ifdef DEMO_CAMERA\n    float fCamTime = time - 5.0;\n    if(fCamTime > 0.0) fCamTime = mod(fCamTime, 33.0 - 5.0) + 5.0;\n    if(iTime==10.0) fCamTime = 0.0; \/\/ hack for shadertoy preview screen\n    vCameraTarget = mix( vCameraTarget, vec3(1834, 30, -3264), smoothstep(5.0, 10.0, fCamTime));\n    vCameraPos = mix( vCameraPos, vec3(1280, 30, -3350), smoothstep(8.0, 13.0, fCamTime));\n\n    vCameraTarget = mix( vCameraTarget, vec3(1280, 30, -2976), smoothstep(11.0, 16.0, fCamTime));\n    vCameraPos = mix( vCameraPos, vec3(1280, 30, -2976), smoothstep(13.0, 19.0, fCamTime));\n\n    vCameraTarget = mix( vCameraTarget, vec3(768, 30, -3050), smoothstep(16.0, 20.0, fCamTime));\n    vCameraPos = mix( vCameraPos, vec3(832, 30, -3020), smoothstep(19.0, 23.0, fCamTime));\n\n    vCameraTarget = mix( vCameraTarget, vec3(1256, 30, -3648), smoothstep(20.0, 25.0, fCamTime));\n    vCameraPos = mix( vCameraPos, vec3(768, 30, -3424), smoothstep(23.0, 28.0, fCamTime));\n\n    vCameraPos = mix( vCameraPos, vec3(1050, 30, -3616), smoothstep(25.0, 30.0, fCamTime));\n    vCameraTarget = mix( vCameraTarget, vec3(1050, 30, -3500), smoothstep(28.0, 33.0, fCamTime));\n    #endif    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vOrigUV = fragCoord.xy \/ iResolution.xy;\n    \n    #ifdef PIXELATE_IMAGE\n    vec2 vUV = floor(vOrigUV * vFakeResolution + 0.5) * (1.0 \/ vFakeResolution);\n    #else\n    vec2 vUV = vOrigUV;\n    #endif\n    \n\tvec3 vCameraPos = vec3(0.0);\n\tvec3 vCameraTarget = vec3(0.0);\n        \n    vec2 vMouse = (iMouse.xy \/ iResolution.xy);\n\t\n\tconst vec2 vStart = vec2(1050, -3616);\n\n\tif(iMouse.z > 0.0)\n    {\n        vec2 vDir = normalize((abs(iMouse.zw) \/ iResolution.xy) - 0.5);\n        vec2 vOffset = (iMouse.xy - abs(iMouse.zw)) \/ iResolution.xy;\n\t\tvCameraPos.y = 30.0;\n    \tvCameraPos.xz = (vDir.yx * vec2(1.0, -1.0) * vOffset.x + vDir * vOffset.y) * 5000.0;\n        vCameraPos.xz += vStart;\n        vCameraTarget.xz = vCameraPos.xz + vDir * 10.0;\n\t    vCameraTarget.y = vCameraPos.y;\n    }\n    else\n    {\n\t\tDemoCamera( iTime, vCameraPos, vCameraTarget );\n    }\n    \n    #ifdef HEAD_BOB\n\tfloat fBob = sin(length(vCameraPos.xz - vStart) * 0.04) * 4.0; \/\/ head bob\n    vCameraPos.y += fBob;\n    vCameraTarget.y += fBob;\n    #endif\n\n    vec2 vWindowCoord =\t(vUV * 2.0 - 1.0) * vec2(iResolution.x \/ iResolution.y, 1.0);\n\t\n    Ray r;\n    \n    \n    r.vRayOrigin = vCameraPos;\n    r.vRayDir = GetCameraRayDir( vWindowCoord, vCameraPos, vCameraTarget );\n\n    vec3 vForwards = normalize(vCameraTarget - vCameraPos); \n    \n\tvec3 vResult = DrawScene(vForwards, vUV, r);\n    \n    #ifdef DRAW_COMPASS\n    \/\/ a hack - assume we have never clicked the mouse before if coordinate is zero\n    if((iMouse.x > 0.5) && (iMouse.y > 0.5))\n    {\n        if(iMouse.z <= 0.0)\n        {\n            vec2 vCompassUV = vOrigUV - 0.5;\n            vCompassUV.x *= iResolution.x \/ iResolution.y;\n            float fDistNS = ((abs(vCompassUV.x) * 10.0) + abs(vCompassUV.y) - 0.05);\n            float fDistEW = ((abs(vCompassUV.y) * 10.0) + abs(vCompassUV.x) - 0.025);\n            float fDistCircle = abs(0.045 - length(vCompassUV)) * 10.0;\n            float fDist = min(min(fDistNS, fDistEW), fDistCircle);\n            \n            float fAmount = clamp(fDist * 20.0, 0.0, 1.0);\n            float fCol = step(fract((floor(vCompassUV.x) + floor(vCompassUV.y)) * 0.5), 0.25);\n            vResult = mix(vec3(fCol * 0.75 + 0.25), vResult, fAmount);\n        }\n    }\n    #endif\n    \n\tfragColor = vec4(vResult, 1.0);\n}\n\n\/\/ Generated code follows\n\/\/ ----------------- 8< -------------------------- 8< -------------------------- 8< --------------\n\n\/\/ Textures\n#define TEX_X 0.0\n#define TEX_F_SKY1 1.0\n#define TEX_NUKAGE3 2.0\n#define TEX_FLOOR7_1 3.0\n#define TEX_FLAT5_5 4.0\n#define TEX_FLOOR4_8 5.0\n#define TEX_CEIL3_5 6.0\n#define TEX_TLITE6_4 7.0\n#define TEX_FLAT14 8.0\n#define TEX_FLOOR7_2 9.0\n#define TEX_STEP2 10.0\n#define TEX_TLITE6_1 11.0\n#define TEX_DOOR3 12.0\n#define TEX_LITE3 13.0\n#define TEX_STARTAN3 14.0\n#define TEX_BROWN1 15.0\n#define TEX_DOORSTOP 16.0\n#define TEX_COMPUTE2 17.0\n#define TEX_STEP6 18.0\n#define TEX_BROWN144 19.0\n#define TEX_SUPPORT2 20.0\n#define TEX_STARG3 21.0\n#define TEX_DOORTRAK 22.0\n#define TEX_SLADWALL 23.0\n#define TEX_TEKWALL4 24.0\n#define TEX_SW1COMP 25.0\n#define TEX_BIGDOOR2 26.0\n\n\/\/ Sectors\n\nvoid Sector0( inout float fT, inout vec4 vInf, Ray r )\n{\n    vec4 vSS;\n    const float fLt=1.000;\n    const vec2 vSH=vec2(-80.0, 216.0);\n\n    BeginSector( vSS, vSH, r );\n    Lower( fT, vInf, vSS, 1520, -3168, 1672, -3104, 164, fLt, vSH, -56, TEX_BROWN144, r );\n    Lower( fT, vInf, vSS, 1672, -3104, 1896, -3104, 224, fLt-kC, vSH, -56, TEX_BROWN144, r );\n    Lower( fT, vInf, vSS, 1896, -3104, 2040, -3144, 149, fLt, vSH, -56, TEX_BROWN144, r );\n    Lower( fT, vInf, vSS, 2040, -3144, 2128, -3272, 155, fLt, vSH, -56, TEX_BROWN144, r );\n    Lower( fT, vInf, vSS, 2128, -3272, 2064, -3408, 150, fLt, vSH, -56, TEX_BROWN144, r );\n    Lower( fT, vInf, vSS, 2064, -3408, 1784, -3448, 282, fLt, vSH, -56, TEX_BROWN144, r );\n    Lower( fT, vInf, vSS, 1784, -3448, 1544, -3384, 248, fLt, vSH, -56, TEX_BROWN144, r );\n    Lower( fT, vInf, vSS, 1544, -3384, 1520, -3168, 217, fLt, vSH, -56, TEX_BROWN144, r );\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_NUKAGE3, TEX_F_SKY1), r );\n}\n\nvoid Sector1( inout float fT, inout vec4 vInf, Ray r )\n{\n    vec4 vSS;\n    const float fLt=1.000;\n    const vec2 vSH=vec2(-56.0, 216.0);\n\t\/\/ merge walls from ultimate doom secret\n\n    BeginSector( vSS, vSH, r );\n    Open( fT, vInf, vSS, 1376, -3200, 1376, -3104, 96, fLt+kC, vSH, 8, 192, TEX_STARTAN3, TEX_STARTAN3, r );\n    Open( fT, vInf, vSS, 1376, -3360, 1376, -3264, 96, fLt+kC, vSH, 8, 192, TEX_STARTAN3, TEX_STARTAN3, r );\n    Wall( fT, vInf, vSS, 1376, -3264, 1376, -3200, 64, fLt+kC, vSH, TEX_STARTAN3, r);\n\tWall( fT, vInf, vSS, 1376, -3104, 1376, -2944, 160, fLt+kC, vSH, TEX_STARTAN3, r);\n    Wall( fT, vInf, vSS, 1376, -2944, 1472, -2880, 115, fLt, vSH, TEX_STARTAN3, r);\n    Wall( fT, vInf, vSS, 1856, -2880, 1920, -2920, 75, fLt, vSH, TEX_STARTAN3, r);\n    Null( vSS, 1520, -3168, 1672, -3104, r );\n    Null( vSS, 1672, -3104, 1896, -3104, r );\n    Null( vSS, 1896, -3104, 2040, -3144, r );\n    Null( vSS, 2040, -3144, 2128, -3272, r );\n    Null( vSS, 2128, -3272, 2064, -3408, r );\n    Null( vSS, 2064, -3408, 1784, -3448, r );\n    Null( vSS, 1784, -3448, 1544, -3384, r );\n    Null( vSS, 1544, -3384, 1520, -3168, r );\n    Wall( fT, vInf, vSS, 2736, -3360, 2736, -3648, 288, fLt+kC, vSH, TEX_STARTAN3, r);\n#ifdef CLOSE_NUKAGE_SECTOR\n    Wall( fT, vInf, vSS, 2736, -3648, 1376, -3648, 2736-1376, fLt, vSH, TEX_STARTAN3, r);\n#else\n\tNull( vSS, 2736, -3648, 2240, -3648, r );\n    Null( vSS, 2240, -3648, 1984, -3648, r );\n    Null( vSS, 1984, -3648, 1376, -3648, r );\n#endif \n    Wall( fT, vInf, vSS, 2240, -2920, 2272, -3008, 93, fLt, vSH, TEX_STARTAN3, r);\n    Wall( fT, vInf, vSS, 2272, -3008, 2432, -3112, 190, fLt, vSH, TEX_STARTAN3, r);\n    Wall( fT, vInf, vSS, 2432, -3112, 2736, -3112, 304, fLt-kC, vSH, TEX_STARTAN3, r);\n    Open( fT, vInf, vSS, 2736, -3112, 2736, -3360, 248, fLt+kC, vSH, 0, 136, TEX_STARTAN3, TEX_STARTAN3, r );\n    \n\t\/\/ Merge walls from Ultimate Doom secret\n\tWall( fT, vInf, vSS, 1376, -3648, 1376, -3360, 3648-3360, fLt+kC, vSH, TEX_STARTAN3, r);\n\t\/\/Wall( fT, vInf, vSS, 1376, -3648, 1376, -3520, 128, fLt+kC, vSH, TEX_STARTAN3);\n    \/\/Wall( fT, vInf, vSS, 1376, -3392, 1376, -3360, 32, fLt+kC, vSH, TEX_STARTAN3);\n    \/\/Wall( fT, vInf, vSS, 1376, -3520, 1376, -3392, 128, fLt+kC, vSH, TEX_STARTAN3);\n    \n\t\/\/ Merge walls from Ultimate Doom secret\n\tWall( fT, vInf, vSS, 1472, -2880, 1856, -2880, 1856-1472, fLt-kC, vSH, TEX_STARTAN3, r);\n    \/\/Wall( fT, vInf, vSS, 1472, -2880, 1664, -2880, 192, fLt-kC, vSH, TEX_STARTAN3);\n    \/\/Wall( fT, vInf, vSS, 1664, -2880, 1856, -2880, 192, fLt-kC, vSH, TEX_STARTAN3);\n\t\n\t\/\/ Merge walls\n    Wall( fT, vInf, vSS, 1920, -2920, 2240, -2920, 2240-1920, fLt-kC, vSH, TEX_STARTAN3, r);\n    \/\/Wall( fT, vInf, vSS, 1920, -2920, 2176, -2920, 256, fLt-kC, vSH, TEX_STARTAN3);\n    \/\/Wall( fT, vInf, vSS, 2176, -2920, 2240, -2920, 64, fLt-kC, vSH, TEX_STARTAN3);\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLOOR7_1, TEX_F_SKY1), r );\n}\n\nvoid Sector3( inout float fT, inout vec4 vInf, Ray r )\n{\n    vec4 vSS;\n    const float fLt=1.000;\n    const vec2 vSH=vec2(8.0, 192.0);\n\n    BeginSector( vSS, vSH, r );\n    Null( vSS, 1344, -3264, 1344, -3360, r );\n    Null( vSS, 1376, -3360, 1376, -3264, r );\n    Wall( fT, vInf, vSS, 1344, -3264, 1376, -3264, 32, fLt-kC, vSH, TEX_DOORSTOP, r);\n    Wall( fT, vInf, vSS, 1376, -3360, 1344, -3360, 32, fLt-kC, vSH, TEX_DOORSTOP, r);\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLAT5_5, TEX_FLAT5_5), r );\n}\n\nvoid Sector5( inout float fT, inout vec4 vInf, Ray r)\n{\n    vec4 vSS;\n    const float fLt=1.000;\n    const vec2 vSH=vec2(8.0, 192.0);\n\n    BeginSector( vSS, vSH, r );\n    Null( vSS, 1344, -3104, 1344, -3200, r );\n    Null( vSS, 1376, -3200, 1376, -3104, r );\n    Wall( fT, vInf, vSS, 1376, -3200, 1344, -3200, 32, fLt-kC, vSH, TEX_DOORSTOP, r);\n    Wall( fT, vInf, vSS, 1344, -3104, 1376, -3104, 32, fLt-kC, vSH, TEX_DOORSTOP, r);\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLAT5_5, TEX_FLAT5_5), r );\n}\n\nvoid Sector11( inout float fT, inout vec4 vInf, Ray r )\n{\n    vec4 vSS;\n    const float fLt=1.000;\n    const vec2 vSH=vec2(-56.0, 24.0);\n\n    BeginSector( vSS, vSH, r );\n    Wall( fT, vInf, vSS, 1528, -3680, 1376, -3648, 155, fLt, vSH, TEX_BROWN144, r);\n    Wall( fT, vInf, vSS, 1672, -3744, 1528, -3680, 157, fLt, vSH, TEX_BROWN144, r);\n    Wall( fT, vInf, vSS, 1984, -3776, 1672, -3744, 313, fLt, vSH, TEX_BROWN144, r);\n    Null( vSS, 1984, -3648, 1376, -3648, r );\n    Null( vSS, 1984, -3648, 1984, -3776, r );\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLOOR7_1, TEX_F_SKY1), r );\n}\n\nvoid Sector12( inout float fT, inout vec4 vInf, Ray r )\n{\n    vec4 vSS;\n    const float fLt=1.000;\n    const vec2 vSH=vec2(-56.0, 64.0);\n\n    BeginSector( vSS, vSH, r );\n    Wall( fT, vInf, vSS, 2240, -3776, 2208, -3680, 101, fLt, vSH, TEX_BROWN1, r);\n    Wall( fT, vInf, vSS, 2208, -3680, 2176, -3680, 32, fLt-kC, vSH, TEX_BROWN1, r);\n    Wall( fT, vInf, vSS, 2016, -3680, 1984, -3776, 101, fLt, vSH, TEX_BROWN1, r);\n    Wall( fT, vInf, vSS, 2048, -3680, 2016, -3680, 32, fLt-kC, vSH, TEX_BROWN1, r);\n    Upper( fT, vInf, vSS, 2176, -3680, 2048, -3680, 128, fLt-kC, vSH, 16, TEX_BROWN1, r );\n    Null( vSS, 2240, -3648, 1984, -3648, r );\n    Null( vSS, 1984, -3648, 1984, -3776, r );\n    Null( vSS, 2240, -3776, 2240, -3648, r );\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLOOR7_1, TEX_F_SKY1), r );\n}\n\nvoid Sector24( inout float fT, inout vec4 vInf, Ray r )\n{\n    vec4 vSS;\n    const float fLt=0.565;\n    const vec2 vSH=vec2(0.0, 144.0);\n\n    BeginSector( vSS, vSH ,r);\n    Wall( fT, vInf, vSS, 1216, -2880, 1248, -2528, 353, fLt, vSH, TEX_STARTAN3,r);\n    Wall( fT, vInf, vSS, 1384, -2592, 1344, -2880, 290, fLt, vSH, TEX_STARTAN3,r);\n    Wall( fT, vInf, vSS, 1472, -2560, 1384, -2592, 93, fLt, vSH, TEX_STARTAN3,r);\n    Wall( fT, vInf, vSS, 1248, -2528, 1472, -2432, 243, fLt, vSH, TEX_STARTAN3,r);\n    Upper( fT, vInf, vSS, 1344, -2880, 1216, -2880, 128, fLt-kC, vSH, 72, TEX_STARTAN3 ,r);\n    Upper( fT, vInf, vSS, 1472, -2432, 1472, -2560, 128, fLt+kC, vSH, 88, TEX_STARTAN3 ,r);\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLOOR4_8, TEX_CEIL3_5) ,r);\n}\n\nvoid Sector25( inout float fT, inout vec4 vInf, Ray r )\n{\n    vec4 vSS;\n    const float fLt=1.000;\n    const vec2 vSH=vec2(0.0, 88.0);\n\n    BeginSector( vSS, vSH , r);\n    Null( vSS, 1472, -2432, 1472, -2560 , r);\n    Wall( fT, vInf, vSS, 1536, -2432, 1536, -2560, 128, fLt+kC, vSH, TEX_BIGDOOR2, r);\n    Wall( fT, vInf, vSS, 1536, -2560, 1472, -2560, 64, fLt-kC, vSH, TEX_STARTAN3, r);\n    Wall( fT, vInf, vSS, 1472, -2432, 1536, -2432, 64, fLt-kC, vSH, TEX_STARTAN3, r);\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLOOR4_8, TEX_TLITE6_4) , r);\n}\n\nvoid Sector27( inout float fT, inout vec4 vInf, Ray r )\n{\n    vec4 vSS;\n    const float fLt=0.878;\n    const vec2 vSH=vec2(-16.0, 200.0);\n\n    BeginSector( vSS, vSH ,r);\n    Wall( fT, vInf, vSS, 1216, -3392, 1216, -3360, 32, fLt+kC, vSH, TEX_BROWN1,r);\n    Wall( fT, vInf, vSS, 1216, -3360, 1184, -3360, 32, fLt-kC, vSH, TEX_BROWN1,r);\n    Wall( fT, vInf, vSS, 1184, -3104, 1216, -3104, 32, fLt-kC, vSH, TEX_BROWN1,r);\n    Wall( fT, vInf, vSS, 1216, -3104, 1216, -3072, 32, fLt+kC, vSH, TEX_BROWN1,r);\n    Open( fT, vInf, vSS, 1344, -3264, 1344, -3360, 96, fLt+kC, vSH, 8, 192, TEX_STARTAN3, TEX_STARTAN3 ,r);\n    Wall( fT, vInf, vSS, 1344, -3200, 1344, -3264, 64, fLt+kC, vSH, TEX_STARTAN3,r);\n    Open( fT, vInf, vSS, 1344, -3104, 1344, -3200, 96, fLt+kC, vSH, 8, 192, TEX_STARTAN3, TEX_STARTAN3 ,r);\n    Open( fT, vInf, vSS, 1344, -3360, 1216, -3392, 131, fLt, vSH, 0, 72, TEX_STEP6, TEX_STARTAN3 ,r);\n    Open( fT, vInf, vSS, 1216, -3072, 1344, -3104, 131, fLt, vSH, 0, 72, TEX_STEP6, TEX_STARTAN3 ,r);\n    Open( fT, vInf, vSS, 928, -3104, 1184, -3104, 256, fLt-kC, vSH, -8, 120, TEX_STEP6, TEX_STARTAN3 ,r);\n    Open( fT, vInf, vSS, 1184, -3360, 928, -3360, 256, fLt-kC, vSH, -8, 120, TEX_STEP6, TEX_STARTAN3 ,r);\n    Open( fT, vInf, vSS, 928, -3360, 928, -3104, 256, fLt+kC, vSH, -8, 120, TEX_STEP6, TEX_STARTAN3 ,r);\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLAT14, TEX_CEIL3_5) ,r);\n}\n\nvoid Sector28( inout float fT, inout vec4 vInf, Ray r )\n{\n    vec4 vSS;\n    const float fLt=0.753;\n    const vec2 vSH=vec2(-8.0, 120.0);\n\n    BeginSector( vSS, vSH , r);\n    Wall( fT, vInf, vSS, 928, -3392, 928, -3360, 32, fLt+kC, vSH, TEX_BROWN1, r);\n    Wall( fT, vInf, vSS, 928, -3360, 896, -3360, 32, fLt-kC, vSH, TEX_BROWN1, r);\n    Wall( fT, vInf, vSS, 1184, -3360, 1184, -3392, 32, fLt+kC, vSH, TEX_BROWN1, r);\n    Wall( fT, vInf, vSS, 896, -3104, 928, -3104, 32, fLt-kC, vSH, TEX_BROWN1, r);\n    Wall( fT, vInf, vSS, 928, -3104, 928, -3072, 32, fLt+kC, vSH, TEX_BROWN1, r);\n    Wall( fT, vInf, vSS, 1184, -3072, 1184, -3104, 32, fLt+kC, vSH, TEX_BROWN1, r);\n    Open( fT, vInf, vSS, 1184, -3392, 928, -3392, 256, fLt-kC, vSH, 0, 72, TEX_STEP6, TEX_COMPUTE2 , r);\n    Null( vSS, 928, -3104, 1184, -3104 , r);\n    Null( vSS, 1184, -3360, 928, -3360 , r);\n    Null( vSS, 928, -3360, 928, -3104 , r);\n    Open( fT, vInf, vSS, 896, -3360, 896, -3104, 256, fLt+kC, vSH, 0, 72, TEX_STEP6, TEX_COMPUTE2 , r);\n    Open( fT, vInf, vSS, 928, -3072, 1184, -3072, 256, fLt-kC, vSH, 0, 72, TEX_STEP6, TEX_COMPUTE2 , r);\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLAT14, TEX_CEIL3_5) , r);\n}\n\nvoid Sector29( inout float fT, inout vec4 vInf, Ray r )\n{\n    vec4 vSS;\n    const float fLt=0.565;\n    const vec2 vSH=vec2(0.0, 72.0);\n\n    BeginSector( vSS, vSH ,r);\n    Wall( fT, vInf, vSS, 1152, -3648, 1088, -3648, 64, fLt-kC, vSH, TEX_STARTAN3,r);\n    Wall( fT, vInf, vSS, 1024, -3648, 960, -3648, 64, fLt-kC, vSH, TEX_STARTAN3,r);\n    Wall( fT, vInf, vSS, 1280, -3552, 1152, -3648, 160, fLt, vSH, TEX_STARTAN3,r);\n    Wall( fT, vInf, vSS, 960, -3648, 832, -3552, 160, fLt, vSH, TEX_STARTAN3,r);\n    Wall( fT, vInf, vSS, 1344, -3552, 1280, -3552, 64, fLt-kC, vSH, TEX_STARTAN3,r);\n    Wall( fT, vInf, vSS, 832, -3552, 704, -3552, 128, fLt-kC, vSH, TEX_STARTAN3,r);\n    Wall( fT, vInf, vSS, 896, -3392, 928, -3392, 32, fLt-kC, vSH, TEX_BROWN1,r);\n    Wall( fT, vInf, vSS, 896, -3360, 896, -3392, 32, fLt+kC, vSH, TEX_BROWN1,r);\n    Wall( fT, vInf, vSS, 1184, -3392, 1216, -3392, 32, fLt-kC, vSH, TEX_BROWN1,r);\n    Wall( fT, vInf, vSS, 896, -3072, 896, -3104, 32, fLt+kC, vSH, TEX_BROWN1,r);\n    Wall( fT, vInf, vSS, 928, -3072, 896, -3072, 32, fLt-kC, vSH, TEX_BROWN1,r);\n    Wall( fT, vInf, vSS, 1216, -3072, 1184, -3072, 32, fLt-kC, vSH, TEX_BROWN1,r);\n    Wall( fT, vInf, vSS, 1344, -2880, 1344, -3104, 224, fLt+kC, vSH, TEX_STARTAN3,r);\n    Null( vSS, 1184, -3392, 928, -3392 ,r);\n    Null( vSS, 1344, -3360, 1216, -3392 ,r);\n    Null( vSS, 1216, -3072, 1344, -3104 ,r);\n    Wall( fT, vInf, vSS, 704, -2944, 832, -2944, 128, fLt-kC, vSH, TEX_STARTAN3,r);\n    Wall( fT, vInf, vSS, 832, -2944, 968, -2880, 150, fLt, vSH, TEX_STARTAN3,r);\n    Wall( fT, vInf, vSS, 968, -2880, 1216, -2880, 248, fLt-kC, vSH, TEX_STARTAN3,r);\n    Null( vSS, 1088, -3648, 1024, -3648 ,r);\n    Null( vSS, 896, -3360, 896, -3104 ,r);\n    Null( vSS, 928, -3072, 1184, -3072 ,r);\n#ifdef CLOSE_START_SECTOR\t\n    Wall( fT, vInf, vSS, 704, -3552, 704, -2944, 3552-2944, fLt+kC, vSH, TEX_STARTAN3,r);\n#else\n    Wall( fT, vInf, vSS, 704, -3552, 704, -3360, 192, fLt+kC, vSH, TEX_STARTAN3,r);\n    Wall( fT, vInf, vSS, 704, -3104, 704, -2944, 160, fLt+kC, vSH, TEX_STARTAN3,r);\n    Null( vSS, 704, -3104, 704, -3360,r );\n#endif\n    Null( vSS, 1344, -2880, 1216, -2880,r );\n    Wall( fT, vInf, vSS, 1344, -3360, 1344, -3392, 32, fLt+kC, vSH, TEX_STARTAN3,r);\n    \n\t\/\/ Merge walls from Ultimate Doom secret\n\tWall( fT, vInf, vSS, 1344, -3392, 1344, -3552, 3552 - 3392, fLt+kC, vSH, TEX_STARTAN3,r);\n\t\/\/Wall( fT, vInf, vSS, 1344, -3520, 1344, -3552, 32, fLt+kC, vSH, TEX_STARTAN3);\n    \/\/Wall( fT, vInf, vSS, 1344, -3392, 1344, -3520, 128, fLt+kC, vSH, TEX_STARTAN3);\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLOOR4_8, TEX_CEIL3_5),r );\n}\n\nvoid Sector30( inout float fT, inout vec4 vInf, Ray r )\n{\n    vec4 vSS;\n    float fLt=(hash(floor(iTime * 10.0)) > 0.3) ? 0.565 : 1.0;\n    const vec2 vSH=vec2(0.0, 72.0);\n\n    BeginSector( vSS, vSH ,r);\n    Wall( fT, vInf, vSS, 1088, -3680, 1024, -3680, 64, fLt-kC, vSH, TEX_DOOR3,r);\n    Wall( fT, vInf, vSS, 1024, -3680, 1024, -3648, 32, fLt+kC, vSH, TEX_LITE3,r);\n    Wall( fT, vInf, vSS, 1088, -3648, 1088, -3680, 32, fLt+kC, vSH, TEX_LITE3,r);\n    Null( vSS, 1088, -3648, 1024, -3648 ,r);\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLOOR4_8, TEX_CEIL3_5) ,r);\n}\n\nvoid Sector31( inout float fT, inout vec4 vInf, Ray r )\n{\n    vec4 vSS;\n    const float fLt=0.502;\n    const vec2 vSH=vec2(-8.0, 120.0);\n\n    BeginSector( vSS, vSH , r);\n    Open( fT, vInf, vSS, 704, -3104, 704, -3360, 256, fLt+kC, vSH, 0, 72, TEX_STEP6, TEX_STARTAN3 , r);\n    Wall( fT, vInf, vSS, 512, -3328, 512, -3304, 24, fLt+kC, vSH, TEX_STARTAN3, r);\n    Wall( fT, vInf, vSS, 512, -3160, 512, -3136, 24, fLt+kC, vSH, TEX_STARTAN3, r);\n    Wall( fT, vInf, vSS, 512, -3136, 680, -3104, 171, fLt, vSH, TEX_STARTAN3, r);\n    Wall( fT, vInf, vSS, 680, -3104, 704, -3104, 24, fLt-kC, vSH, TEX_SUPPORT2, r);\n    Wall( fT, vInf, vSS, 704, -3360, 680, -3360, 24, fLt-kC, vSH, TEX_SUPPORT2, r);\n    Wall( fT, vInf, vSS, 680, -3360, 512, -3328, 171, fLt, vSH, TEX_STARTAN3, r);\n    Null( vSS, 496, -3160, 496, -3304 , r);\n    Wall( fT, vInf, vSS, 512, -3304, 496, -3304, 16, fLt-kC, vSH, TEX_DOORTRAK, r);\n    Wall( fT, vInf, vSS, 496, -3160, 512, -3160, 16, fLt-kC, vSH, TEX_DOORTRAK, r);\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLOOR4_8, TEX_CEIL3_5) , r);\n}\n\nvoid Sector32( inout float fT, inout vec4 vInf, Ray r )\n{\n    vec4 vSS;\n    const float fLt=0.502;\n    const vec2 vSH=vec2(-8.0, 224.0);\n\n    BeginSector( vSS, vSH , r);\n    Upper( fT, vInf, vSS, 496, -3160, 496, -3304, 144, fLt+kC, vSH, 120, TEX_STARG3 , r);\n    Wall( fT, vInf, vSS, 496, -3304, 496, -3328, 24, fLt+kC, vSH, TEX_STARG3, r);\n    Wall( fT, vInf, vSS, 496, -3328, 448, -3456, 136, fLt, vSH, TEX_STARG3, r);\n    Wall( fT, vInf, vSS, 448, -3456, 128, -3456, 320, fLt-kC, vSH, TEX_STARG3, r);\n    Wall( fT, vInf, vSS, 128, -3008, 448, -3008, 320, fLt-kC, vSH, TEX_STARG3, r);\n    Wall( fT, vInf, vSS, 496, -3136, 496, -3160, 24, fLt+kC, vSH, TEX_STARG3, r);\n    Wall( fT, vInf, vSS, 448, -3008, 496, -3136, 136, fLt, vSH, TEX_STARG3, r);\n    Lower( fT, vInf, vSS, 128, -3264, 160, -3264, 32, fLt-kC, vSH, 88, TEX_SLADWALL , r);\n    Lower( fT, vInf, vSS, 160, -3264, 192, -3264, 32, fLt-kC, vSH, 72, TEX_SLADWALL , r);\n    Lower( fT, vInf, vSS, 192, -3264, 224, -3264, 32, fLt-kC, vSH, 56, TEX_SLADWALL , r);\n    Lower( fT, vInf, vSS, 224, -3264, 256, -3264, 32, fLt-kC, vSH, 40, TEX_SLADWALL , r);\n    Lower( fT, vInf, vSS, 256, -3264, 288, -3264, 32, fLt-kC, vSH, 24, TEX_SLADWALL , r);\n    Lower( fT, vInf, vSS, 288, -3264, 320, -3264, 32, fLt-kC, vSH, 8, TEX_SLADWALL , r);\n    Lower( fT, vInf, vSS, 320, -3264, 320, -3200, 64, fLt+kC, vSH, 8, TEX_STEP6 , r);\n    Lower( fT, vInf, vSS, 320, -3200, 288, -3200, 32, fLt-kC, vSH, 8, TEX_SLADWALL , r);\n    Lower( fT, vInf, vSS, 288, -3200, 256, -3200, 32, fLt-kC, vSH, 24, TEX_SLADWALL , r);\n    Lower( fT, vInf, vSS, 256, -3200, 224, -3200, 32, fLt-kC, vSH, 40, TEX_SLADWALL , r);\n    Lower( fT, vInf, vSS, 224, -3200, 192, -3200, 32, fLt-kC, vSH, 56, TEX_SLADWALL , r);\n    Lower( fT, vInf, vSS, 192, -3200, 160, -3200, 32, fLt-kC, vSH, 72, TEX_SLADWALL , r);\n    Lower( fT, vInf, vSS, 160, -3200, 128, -3200, 32, fLt-kC, vSH, 88, TEX_SLADWALL , r);\n    Open( fT, vInf, vSS, 128, -3200, 64, -3072, 143, fLt, vSH, 104, 192, TEX_STARG3, TEX_STARG3 , r);\n    Wall( fT, vInf, vSS, 64, -3072, 128, -3008, 90, fLt, vSH, TEX_STARG3, r);\n    Wall( fT, vInf, vSS, 128, -3456, 64, -3392, 90, fLt, vSH, TEX_STARG3, r);\n    Open( fT, vInf, vSS, 64, -3392, 128, -3264, 143, fLt, vSH, 104, 192, TEX_STARG3, TEX_STARG3 , r);\n    Open( fT, vInf, vSS, 256, -3136, 320, -3136, 64, fLt-kC, vSH, 40, 184, TEX_TEKWALL4, TEX_TEKWALL4 , r);\n    Open( fT, vInf, vSS, 320, -3136, 320, -3072, 64, fLt+kC, vSH, 40, 184, TEX_TEKWALL4, TEX_TEKWALL4 , r);\n    Open( fT, vInf, vSS, 320, -3072, 256, -3072, 64, fLt-kC, vSH, 40, 184, TEX_SW1COMP, TEX_TEKWALL4 , r);\n    Open( fT, vInf, vSS, 256, -3072, 256, -3136, 64, fLt+kC, vSH, 40, 184, TEX_TEKWALL4, TEX_TEKWALL4 , r);\n    Open( fT, vInf, vSS, 256, -3392, 320, -3392, 64, fLt-kC, vSH, 40, 184, TEX_TEKWALL4, TEX_TEKWALL4 , r);\n    Open( fT, vInf, vSS, 320, -3392, 320, -3328, 64, fLt+kC, vSH, 40, 184, TEX_TEKWALL4, TEX_TEKWALL4 , r);\n    Open( fT, vInf, vSS, 320, -3328, 256, -3328, 64, fLt-kC, vSH, 40, 184, TEX_TEKWALL4, TEX_TEKWALL4 , r);\n    Open( fT, vInf, vSS, 256, -3328, 256, -3392, 64, fLt+kC, vSH, 40, 184, TEX_TEKWALL4, TEX_TEKWALL4 , r);\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLOOR4_8, TEX_FLOOR7_2) , r);\n}\n\nvoid Sector35( inout float fT, inout vec4 vInf, Ray r )\n{\n    vec4 vSS;\n    const float fLt=1.000;\n    const vec2 vSH=vec2(40.0, 184.0);\n\n    BeginSector( vSS, vSH, r );\n    Null( vSS, 256, -3392, 320, -3392, r );\n    Null( vSS, 320, -3392, 320, -3328, r );\n    Null( vSS, 320, -3328, 256, -3328, r );\n    Null( vSS, 256, -3328, 256, -3392, r );\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_STEP2, TEX_TLITE6_1), r );\n}\n\nvoid Sector36( inout float fT, inout vec4 vInf, Ray r )\n{\n    vec4 vSS;\n    const float fLt=1.000;\n    const vec2 vSH=vec2(40.0, 184.0);\n\n    BeginSector( vSS, vSH, r );\n    Null( vSS, 256, -3136, 320, -3136, r );\n    Null( vSS, 320, -3136, 320, -3072, r );\n    Null( vSS, 320, -3072, 256, -3072, r );\n    Null( vSS, 256, -3072, 256, -3136, r );\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_STEP2, TEX_TLITE6_1), r );\n}\n\nvoid Sector63( inout float fT, inout vec4 vInf, Ray r )\n{\n    vec4 vSS;\n    const float fLt=1.000;\n    const vec2 vSH=vec2(-56.0, 24.0);\n\n    BeginSector( vSS, vSH, r );\n    Wall( fT, vInf, vSS, 2736, -3648, 2488, -3744, 265, fLt, vSH, TEX_BROWN144, r);\n    Wall( fT, vInf, vSS, 2488, -3744, 2240, -3776, 250, fLt, vSH, TEX_BROWN144, r);\n    Null( vSS, 2736, -3648, 2240, -3648, r );\n    Null( vSS, 2240, -3776, 2240, -3648, r );\n    EndSector( fT, vInf, vSS, fLt, vec2(TEX_FLOOR7_1, TEX_F_SKY1), r );\n}\n\nvoid MapIntersect( out float fClosestT, out vec4 vHitInfo, Ray r )\n{\n    vHitInfo = vec4(0.0);\n    fClosestT = 10000.0;\n\n#ifdef ENABLE_NUKAGE_SECTORS\n    Sector0( fClosestT, vHitInfo, r );\n    Sector1( fClosestT, vHitInfo, r );\n#endif\n#ifdef ENABLE_START_SECTORS\n    Sector3( fClosestT, vHitInfo, r );\n    Sector5( fClosestT, vHitInfo, r );\n#endif\n#ifdef ENABLE_EXTRA_NUKAGE_SECTORS\n    Sector11( fClosestT, vHitInfo, r );\n    Sector12( fClosestT, vHitInfo, r );\n#endif\n#ifdef ENABLE_START_SECTORS\n    Sector24( fClosestT, vHitInfo, r );\n#endif\n#ifdef ENABLE_MISC_SECTORS\t\n    Sector25( fClosestT, vHitInfo, r );\n#endif\n#ifdef ENABLE_START_SECTORS\n\tSector27( fClosestT, vHitInfo, r );\n    Sector28( fClosestT, vHitInfo, r );\n    Sector29( fClosestT, vHitInfo, r );\n    Sector30( fClosestT, vHitInfo, r );\n#endif\n#ifdef ENABLE_SECTOR_31\n    Sector31( fClosestT, vHitInfo, r );\n#endif\n#ifdef ENABLE_MISC_SECTORS\n    Sector32( fClosestT, vHitInfo, r );\n    Sector35( fClosestT, vHitInfo, r );\n    Sector36( fClosestT, vHitInfo, r );\n#endif\n#ifdef ENABLE_EXTRA_NUKAGE_SECTORS\n    Sector63( fClosestT, vHitInfo, r );\n#endif\n}\n\n\n\n\/\/ ----------------- 8< -------------------------- 8< -------------------------- 8< --------------\n\/\/ End of generated code\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Texture Helpers\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nfloat hash(float p)\n{\n\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\n\nfloat hash2D(vec2 p)\n{\n\treturn hash( dot( p, vec2(1.0, 41.0) ) );\t\n}\n\nfloat noise1D( float p )\n{\n\tfloat fl = floor(p);\n\t\n\tfloat h0 = hash( fl );\n\tfloat h1 = hash( fl + 1.0 );\n\t\n\tfloat fr = p - fl;\n\tfloat fr2 = fr * fr;\n\tfloat fr3 = fr2 * fr;\n\t\n\tfloat t1 = 3.0 * fr2 - 2.0 * fr3;\t\n\tfloat t0 = 1.0 - t1;\n\t\n\treturn h0 * t0\n\t\t + h1 * t1;\n}\n\nfloat noise2D( vec2 p, float r )\n{\n\tvec2 fl = floor(p);\n\n\tfloat h00 = hash2D( mod(fl + vec2(0.0, 0.0), r) );\n\tfloat h10 = hash2D( mod(fl + vec2(1.0, 0.0), r) );\n\tfloat h01 = hash2D( mod(fl + vec2(0.0, 1.0), r) );\n\tfloat h11 = hash2D( mod(fl + vec2(1.0, 1.0), r) );\n\t\n\tvec2 fr = p - fl;\n\t\n\tvec2 fr2 = fr * fr;\n\tvec2 fr3 = fr2 * fr;\n\t\n\tvec2 t1 = 3.0 * fr2 - 2.0 * fr3;\t\n\tvec2 t0 = 1.0 - t1;\n\t\n\treturn h00 * t0.x * t0.y\n\t\t + h10 * t1.x * t0.y\n\t\t + h01 * t0.x * t1.y\n\t\t + h11 * t1.x * t1.y;\n}\n\nfloat fbm( vec2 p, float per )\n{\n\tfloat val = 0.0;\n\tfloat tot = 0.0;\n\tfloat mag = 0.5;\n\n\tp += 0.5;\n\tp = p * (1.0 \/ 8.0);\n\tval += noise2D(p, 4.0) * mag; tot+=mag; p=p*2.0 + 1.234; mag*=per;\t\n\tval += noise2D(p, 8.0) * mag; tot+=mag; p=p*2.0 + 2.456; mag*=per;\n\tval += noise2D(p, 16.0) * mag; tot+=mag; p=p*2.0 + 3.678; mag*=per;\n\tval += noise2D(p, 32.0) * mag; tot+=mag;\n\n\treturn val * (1.0 \/ tot);\n}\n\nfloat Indent(vec2 vTexCoord, vec2 vHigh, vec2 vLow, float fHighIntensity, float fLowIntensity)\n{\n\tvec2 vMin = min(vLow, vHigh);\n\tvec2 vMax = max(vLow, vHigh);\n\tif((vTexCoord.x < vMin.x) || (vTexCoord.x > vMax.x) || (vTexCoord.y < vMin.y) || (vTexCoord.y > vMax.y))\n\t\treturn 1.0;\n\n\tif((vTexCoord.x == vHigh.x) || (vTexCoord.y == vHigh.y))\n\t{\n\t\treturn fHighIntensity;\n\t}\n\t\n\tif((vTexCoord.x == vLow.x) || (vTexCoord.y == vLow.y))\n\t{\n\t\treturn fLowIntensity;\n\t}\n\t\n\treturn 1.0;\n}\n\nvec4 SmoothBump(const in vec2 vTexCoord, const in vec2 vMin, const in vec2 vMax, const in vec2 vLightDir, const in float fSize)\n{\n\tvec2 vNearest = min( max(vTexCoord, vMin), vMax );\n\tvec2 vDelta = vNearest - vTexCoord;\n    float fDeltaLen = length(vDelta);\n\tfloat fDist = (fDeltaLen - fSize) \/ fSize;\n\tvec2 vDir = vDelta;\n    if(fDeltaLen > 0.0) vDir = vDir \/ fDeltaLen;\n\tfloat fShade = dot(vDir, vLightDir);\n\t\/\/return clamp(1.0 - (fDist \/ fSize), 0.0, 1.0) * fShade;\n\tfShade *= clamp(1.0 - abs((fDist)), 0.0, 1.0);\n\treturn vec4( fShade, fDist, (vTexCoord - vMin + fSize) \/ (vMax - vMin + fSize * 2.0) );\n}\n\n\nfloat wrap( const in float x , const in float r )\n{\n\treturn fract( x * (1.0 \/ r) ) * r;\n}\n\nvec4 Hexagon( vec2 vUV )\n{\n\tvec2 vIndex;\n\t\n\tfloat fRow = floor(vUV.y);\n\t\n\tvec2 vLocalUV = vUV;\n\tfloat fRowEven = wrap(fRow, 2.0);\n\tif(fRowEven < 0.5)\n\t{\n\t\tvLocalUV.x += 0.5;\n\t}\n\t\n\tvIndex = floor(vLocalUV);\n\t\n\tvec2 vTileUV = fract(vLocalUV);\n\t{\n\t\tfloat m = 2.0 \/ 3.0;\n\t\tfloat c = 2.0 \/ 3.0;\n\t\tif((vTileUV.x *m + c) < vTileUV.y)\n\t\t{\n\t\t\tif(fRowEven < 0.5)\n\t\t\t{\n\t\t\t\tvIndex.x -= 1.0;\n\t\t\t}\n\t\t\tfRowEven = 1.0 - fRowEven;\t\t\t\t\n\t\t\tvIndex.y += 1.0;\n\t\t}\n\t}\n\t\n\t{\n\t\tfloat m = -2.0 \/ 3.0;\n\t\tfloat c = 4.0 \/ 3.0;\n\t\tif((vTileUV.x *m + c) < vTileUV.y)\n\t\t{\n\t\t\tif(fRowEven >= 0.5)\n\t\t\t{\n\t\t\t\tvIndex.x += 1.0;\n\t\t\t}\n\t\t\tfRowEven = 1.0 - fRowEven;\t\t\t\t\n\t\t\tvIndex.y += 1.0;\n\t\t}\n\t}\n\t\n\tvec2 vCenter = vIndex - vec2(0.0, -1.0 \/ 3.0);\n\tif(fRowEven > 0.5)\n\t{\n\t\tvCenter.x += 0.5;\n\t}\n\t\n\tvec2 vDelta = vUV - vCenter;\n\t\n\t\/\/vDelta = abs(vDelta);\n\t\n\tfloat d1 = vDelta.x;\n\tfloat d2 = dot(vDelta, normalize(vec2(2.0\/3.0, 1.0)));\n\tfloat d3 = dot(vDelta, normalize(vec2(-2.0\/3.0, 1.0)));\n\t\n\td2 *= 0.9;\n\td3 *= 0.9;\n\t\n\tfloat fDist = max( abs(d1), abs(d2) );\n\tfDist = max( fDist, abs(d3) );\n\t\n\tfloat fTest = max(max(-d1, -d2), d3);\n\t\n\treturn vec4(vIndex, abs(fDist), fTest);\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Textures\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec3 TexNukage3( vec2 vTexCoord, float fRandom)\n{\n\tfloat fBlend = 0.0;\n\tfBlend = smoothstep(0.8, 0.0, fRandom);\n\tfBlend = min(fBlend, smoothstep(1.0, 0.8, fRandom));\n\tfBlend *= 1.5;\n\tvec3 col = mix( vec3(11.0, 23.0, 7.0), vec3(46.0, 83, 39.0), fBlend) \/ 255.0;\n\t\n\treturn col;\n}\n\nvoid AddMountain( inout float fShade, const in vec2 vUV, const in float fRandom, const in float fHRandom, const in float fXPos, const in float fWidth, const in float fHeight, const in float fFog)\n{\n\tfloat fYPos = 1.0 - smoothstep( 0.0, 1.0, abs(fract(fXPos - vUV.x + vUV.y * 0.05 + 0.5) - 0.5) * fWidth );\n\tfYPos += fHRandom * 0.05 + fRandom * 0.05;\n\tfYPos *= fHeight;\n\tfloat fDist = fYPos - vUV.y;\n\tif(fDist > 0.0)\n\t{\n\t\tfShade = fRandom * ((1.0 - clamp(sqrt(fDist) * 2.0, 0.0, 1.0)) * 0.3 + 0.1);\n\t\tfShade = mix(fShade, 0.6 + 0.1 * fRandom, fFog);\n\t}\t\n}\n\nvec3 TexFSky1(vec2 vTexCoord, float fRandom, float fHRandom)\n{\n\tfloat fShade = 0.6 + 0.1 * fRandom;\n\t\n\tvec2 vUV = vTexCoord * (1.0 \/ vec2(256.0, 128.0));\n\tvUV.y = 1.0 - vUV.y;\n\t\n\tAddMountain( fShade, vUV, fRandom, fHRandom, 0.25, 1.0, 0.85, 0.5 );\n\tAddMountain( fShade, vUV, fRandom, fHRandom, 1.5, 4.0, 0.78, 0.2 );\n\tAddMountain( fShade, vUV, fRandom, fHRandom, 1.94, 2.51, 0.8, 0.0 );\n\n\t\n\treturn vec3(fShade);\n}\n\nvec3 TexFloor7_1( vec2 vTexCoord, float fRandom )\n{\n\tvec3 col = mix( vec3(51.0, 43.0, 19.0), vec3(79.0, 59, 35.0), fRandom * fRandom * 2.5) \/ 255.0;\n\t\n\treturn col;\n}\n\nvec3 TexFlat5_5( vec2 vTexCoord, float fRandom )\n{\n\tvec3 col = mix( vec3(63.0, 47.0, 23.0), vec3(147.0, 123.0, 99.0), fRandom) \/ 255.0;\n\t\n\tcol *= mod(vTexCoord.x, 2.0) * 0.15 + 0.85;\n\t\n\treturn col;\n}\n\nvec3 TexFloor4_8( vec2 vTexCoord, float fRandom )\n{\n\tvec3 col = mix( vec3(30.0, 30.0, 30.0), vec3(150.0, 150.0, 150.0), fRandom * fRandom) \/ 255.0;\n\n\tvec4 vHex = Hexagon( vTexCoord.yx \/ 32.0 );\n    \n    float fShadow = (clamp((0.5 - vHex.z) * 15.0, 0.0, 1.0) * 0.5 + 0.5);\n    float fHighlight = 1.0 + clamp(1.0 - (abs(0.45 - vHex.w)) * 32.0, 0.0, 1.0) * 0.5;\n    \n\tcol = col * (clamp((0.5 - vHex.z) * 2.0, 0.0, 1.0) * 0.25 + 0.75);\n    col = col * fHighlight;\n\tcol = col * fShadow;\n\t\n\treturn col;\n}\n\nvec3 TexCeil3_5( vec2 vTexCoord, float fRandom )\n{\n\tvec3 col = vec3(1.0);\n\t\n\tvec2 vTileCoord = vTexCoord;\n\tvTileCoord.x -= 17.0;\n\tif( (vTileCoord.x >= 0.0) && (vTileCoord.x < 32.0) ) \n\t\tvTileCoord.y -= 58.0;\n\telse \n\t\tvTileCoord.y -= 11.0;\n\tvTileCoord.x = mod(vTileCoord.x, 32.0);\n\tvTileCoord.y = mod(vTileCoord.y, 64.0);\n\t\t\n\tvec2 vBoxClosest = clamp(vTileCoord, vec2(4.0, 4.0), vec2(28.0, 60.0));\n\tvec2 vDelta = vTileCoord - vBoxClosest;\n\tfloat fDist2 = dot(vDelta, vDelta);\n\n\tconst float fLight1 = 59.0 \/ 255.0;\n\tconst float fMed1 = 55.0 \/ 255.0;\n\tconst float fDark1 = 47.0 \/ 255.0;\n\tconst float fDark2 = 39.0 \/ 255.0;\n\n\tfloat fShade = fMed1;\t\n\tfShade = mix( fShade, fLight1, smoothstep(0.6, 0.45, fRandom) );\n\tfShade = mix( fShade, fDark1, smoothstep(0.45, 0.35, fRandom) );\n\t\n\tfShade = mix( fShade, fDark1, step(1.5, fDist2) );\n\tfShade = mix( fShade, fDark2, step(13.5, fDist2) );\n\t\t\n\tcol *= fShade;\n\t\n\tif((vTileCoord.x < 12.0) || (vTileCoord.x > 20.0) || (vTileCoord.y < 12.0) || (vTileCoord.y > 52.0))\n\t{\n\t\tfloat fRRow = floor(mod(vTileCoord.y - 3.5, 7.5));\n\t\tfloat fRColumn = mod(vTileCoord.x - 15.0, 10.0);\n\t\tif((fRRow == 2.0) && (fRColumn == 0.0))\n\t\t{\n\t\t\tcol -= 0.05;\n\t\t}\n\t\tif((fRRow <= 2.0) && (fRColumn <= 2.0))\n\t\t{\n\t\t\tvec2 vOffset = vec2(fRRow - 1.0, fRColumn - 1.0);\n\t\t\tfloat fDist2 = dot(vOffset, vOffset) \/ 2.0;\n\t\t\tcol += clamp(1.0 - fDist2, 0.0, 1.0) * 0.05;\n\t\t}\n\t}\n\t\n\treturn col;\n}\n\nvec3 TexFlat14( vec2 vTexCoord, float fRandom )\n{\n\treturn mix( vec3(0.0, 0.0, 35.0 \/ 255.0), vec3(0.0, 0.0, 200.0 \/ 255.0), fRandom * fRandom);\n}\n\nvec3 TexDoor3(vec2 vTexCoord, float fRandom, float fHRandom)\n{\n\tfloat fVNoise = fHRandom + fRandom;\n\tfloat fStreak = clamp(abs(fract(fVNoise) - 0.5) * 3.0, 0.0, 1.0);\n\tfStreak = fStreak * fStreak;\n\t\n\tfloat fShade = 1.0;\n\t\n\tfShade = 1.0 - abs((vTexCoord.y \/ 72.0) - 0.5) * 2.0;\n\tfShade = fShade * fShade;\n\tfShade = fShade * 0.2 + 0.3;\n\t\n\tfShade = fShade * (fHRandom * 0.2 + 0.8);\n\t\n\tfShade *= Indent( vTexCoord, vec2(8.0, 8.0), vec2(64.0 - 8.0, 72.0 - 16.0), 0.8, 1.2);\n\tfShade *= Indent( vTexCoord, vec2(8.0, 72.0 - 15.0), vec2(64.0 - 8.0, 72.0 - 8.0), 0.8, 1.2);\n\t\n\tfShade *= Indent( vTexCoord, vec2(64.0 - 11.0, 46.0), vec2(46.0, 32.0), 0.8, 1.2);\n\tfShade *= Indent( vTexCoord, vec2(64.0 - 11.0, 56.0), vec2(46.0, 52.0), 0.8, 1.2);\n\t\n\tfShade += fRandom * 0.1;\n\n\tfloat fStreakTopAmount = smoothstep( 32.0, 0.0, vTexCoord.y );\n\tfloat fStreakBottomAmount = smoothstep( 72.0 -32.0, 72.0, vTexCoord.y );\n\t\n\tfShade *= 1.0 - fStreak * max(fStreakTopAmount, fStreakBottomAmount) * 0.2;\n\t\n\tif( (vTexCoord.x > 8.0) && (vTexCoord.x < 52.0) )\n\t{\n\t\tvec2 vRepeatCoord = mod( vTexCoord, vec2( 8.0, 48.0 ) );\n\t\tvRepeatCoord += vec2(4.0, -12.0);\n\t\tif( vRepeatCoord.x == 4.0 )\n\t\t{\n\t\t\tif(vRepeatCoord.y == 0.0)\n\t\t\t{\n\t\t\t\tfShade += 0.1;\n\t\t\t}\n\t\t\tif(vRepeatCoord.y > 0.0)\n\t\t\t{\n\t\t\t\tfShade *= clamp(vRepeatCoord.y \/ 16.0, 0.0, 1.0) * 0.3 + 0.7;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn vec3(fShade);\n}\n\nvec3 TexLite3( vec2 vTexCoord )\n{\n\tvec2 vLocalCoord = vTexCoord;\n\tvLocalCoord.y = mod(vLocalCoord.y, 8.0 );\n\t\n\tvec2 vClosest = min( max( vLocalCoord, vec2(4.0, 3.5) ), vec2(32.0 - 5.0, 3.5) );\n\tvec2 vDelta = vLocalCoord - vClosest;\n\tfloat fDist = max(abs(vDelta.x), abs(vDelta.y)) \/ 3.9;\n\t\n\treturn vec3(1.0 - fDist * 0.65);\n}\n\nvec3 TexStartan3( vec2 vTexCoord, float fRandom )\n{\n\tvec3 col = vec3(0.6);\n\t\n\tfloat fVNoise = noise1D(vTexCoord.x * 0.5) - ((vTexCoord.y) \/ 128.0) + fRandom;\n\tfloat fStreak = clamp(abs(fract(fVNoise) - 0.5) * 3.0, 0.0, 1.0);\n\tfStreak = fStreak * fStreak;\n\t\t\n\tfloat fBlend2 = smoothstep( 0.0, 32.0, abs(vTexCoord.x - 64.0) );\n\tfBlend2 *= fBlend2;\n\tfBlend2 *= fStreak * 0.5 + 0.5;\n\tcol = mix( col, vec3(119.0, 79.0, 43.0) \/ 255.0, fBlend2 * 0.5);\n\t\n\tfloat fBlend = smoothstep( 24.0, 56.0, abs(vTexCoord.x - 64.0) );\n\tfBlend *= fBlend;\n\tfBlend *= fStreak * 0.7 + 0.3;\n\tcol = mix( col, vec3(119.0, 79.0, 43.0) * 1.1 \/ 255.0, fBlend);\n\t\n\tcol *= fRandom * fRandom * 0.3 + 0.7;\n\n\tvec2 vCoord = vTexCoord;\n\tvCoord.x = mod(vCoord.x, 32.0);\n\t\n\tfloat fStreakHL = fStreak * 0.075 + 0.075;\n\t\n\tfloat fDistMin = 1.0;\n\tfloat fShade = 0.0;\n\t\n\tvec4 vBump = SmoothBump( vCoord, vec2(6.0, 8.0), vec2(32.0 - 5.0, 9.0), normalize(vec2(0.0, 1.0)), 3.0 );\n\tfShade += vBump.x * 0.1;\n\tfDistMin = min(fDistMin, vBump.y);\n\tfShade += ((vBump.w >= 0.0) && (vBump.w <= 1.0)) ? (1.0 - vBump.w) * fStreakHL : 0.0;\n\tvBump = SmoothBump( vCoord, vec2(6.0, 20.0), vec2(32.0 - 6.0, 40.0), normalize(vec2(0.0, 1.0)), 3.0 ); \n\tfShade += vBump.x * 0.1;\n\tfShade += ((vBump.w >= 0.0) && (vBump.w <= 1.0)) ? (1.0 - vBump.w) * fStreakHL : 0.0;\n\tfDistMin = min(fDistMin, vBump.y);\n\n\tvBump = SmoothBump( vCoord, vec2(6.0, 64.0), vec2(32.0 - 6.0, 65.0), normalize(vec2(0.0, 1.0)), 3.0 );\n\tfShade += vBump.x * 0.1;\n\tfShade += ((vBump.w >= 0.0) && (vBump.w <= 1.0)) ? (1.0 - vBump.w) * fStreakHL : 0.0;\n\tfDistMin = min(fDistMin, vBump.y);\n\tvBump = SmoothBump( vCoord, vec2(6.0, 76.0), vec2(32.0 - 6.0, 110.0), normalize(vec2(0.0, 1.0)), 3.0 ) ;\n\tfShade += vBump.x * 0.1;\n\tfShade += ((vBump.w >= 0.0) && (vBump.w <= 1.0)) ? (1.0 - vBump.w) * fStreakHL : 0.0;\n\tfDistMin = min(fDistMin, vBump.y);\n\n\tvBump = SmoothBump( vTexCoord, vec2(-16.0, 50.0), vec2(256.0, 52.0), normalize(vec2(0.0, 1.0)), 3.0 );\n\tfShade += vBump.x * 0.1;\n\tfShade += ((vBump.w >= 0.0) && (vBump.w <= 1.0)) ? (1.0 - vBump.w) * fStreakHL : 0.0;\n\tfDistMin = min(fDistMin, vBump.y);\n\tvBump = SmoothBump( vTexCoord, vec2(-16.0, 122.0), vec2(256.0, 200.0), normalize(vec2(0.0, 1.0)), 3.0 );\n\tfShade += vBump.x * 0.05;\n\tfDistMin = min(fDistMin, vBump.y);\n\n\tcol *= 1.0 + fShade * 3.0;\n\n\tcol *= clamp((1.0 - fDistMin) * 1.0, 0.0, 1.0) * 0.3 + 0.7;\n\n\treturn col;\n}\n\nvec3 TexBrown1( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n\tvec3 col = mix( vec3(119.0, 95.0, 63.0), vec3(147.0, 123.0, 99.0), fRandom * fRandom) \/ 255.0;\n\n\tif(vTexCoord.x >= 64.0)\n\t{\n\t\tcol = col * vec3(1.0, 0.848, 0.646);\n\t\t\n\t\tcol = mix( col, vec3( 0.111, 0.414, 0.3), clamp((fRandom -0.5) * 2.0, 0.0, 1.0)); \/\/ green bits\n\t}\n\t\n\tfloat fVNoise = fHRandom + fRandom;\n\t\n\tfloat fStreak = clamp(abs(fract(fVNoise) - 0.5) * 3.0, 0.0, 1.0);\n\tfStreak = fStreak * fStreak;\n\n\tvec2 vRepeatCoord = vTexCoord;\n\tvRepeatCoord.x = mod(vRepeatCoord.x, 13.0);\n\t\n\tvec4 vBump = SmoothBump( vRepeatCoord, vec2( 5.0, 6.0 ), vec2( 5.0, 12.0), vec2(0.0, 1.0), 1.5);\n\tfloat fMask = clamp(1.0 - vBump.y, 0.0, 1.0);\n\t\n\tfloat fStreakAmount = 1.0;\n\tfStreakAmount *= smoothstep( 0.0, 8.0, vRepeatCoord.y );\n\tfloat fStreakWidth = smoothstep( 64.0, 12.0, vRepeatCoord.y );\n\tfloat fBase1Dist = smoothstep( 24.0, 75.0, vRepeatCoord.y ) * step(vRepeatCoord.y, 75.0);\n\tfloat fBase2Dist = smoothstep( 96.0, 127.0, vRepeatCoord.y );\/\/ * step(75.0, vRepeatCoord.y);\n\tfloat fBaseDist = max(fBase1Dist, fBase2Dist);\n\tfStreakWidth = max( fStreakWidth, fBaseDist);\n\tfloat fTop2Dist = smoothstep( 127.0, 75.0, vRepeatCoord.y ) * step(75.0, vRepeatCoord.y);\n\tfStreakWidth = max(fStreakWidth, fTop2Dist);\n\tfloat fStreakX = abs(vRepeatCoord.x - 5.0) \/ 8.0;\n\tfStreakAmount *= fStreakWidth;\n\tfStreakAmount *= smoothstep( fStreakWidth, 0.0, fStreakX);\n\tfStreakAmount = max(fStreakAmount, (fBaseDist - 0.75) * 4.0);\n\tfStreakAmount *= 1.0 - fMask; \n\tcol = mix(col, vec3(0.3, 0.2, 0.1), fStreakAmount * (fStreak * 0.5 + 0.5) );\n\t\n\tcol += ((vBump.w >= 0.0) && (vBump.w <= 1.0)) ? (vBump.w) * (1.0-vBump.y) * 0.05 : 0.0;\n\t\n\tif((vTexCoord.y == 17.0) || (vTexCoord.y == 73.0)) col *= 0.9;\n\tif((vTexCoord.y == 19.0) || (vTexCoord.y == 75.0)) col *= 1.2;\n\n\tcol *= 1.0 + clamp(vBump.x, -1.0, 0.0) * 0.6;\n\t\t\n\treturn col;\n}\n\nvec3 TexDoorstop( vec2 vTexCoord, float fRandom )\n{\n\tfloat fShade = 1.0 - abs(vTexCoord.x - 3.4) \/ 4.0;\n\t\n\tfShade = fShade * 0.2 + 0.2;\n\t\n\tfloat fSin = sin((vTexCoord.y - 16.0) * 3.14150 * 4.0 \/ 128.0) * 0.5 + 0.5;\n\tfShade *= 0.8 + fRandom * 1.2 * fSin;\n\t\n\treturn vec3(fShade);\n}\n\nvoid DrawScreen(inout vec3 col, const in vec2 vTexCoord, const in vec2 vPos, const in vec2 vSize, const in vec3 vCol)\n{\n\tvec2 vScreenCoord = vTexCoord - vPos;\n\tcol *= Indent( vScreenCoord, vSize, vec2(-1.0), 1.2, 0.5);\n\n\tif((vScreenCoord.x >= 0.0) && (vScreenCoord.y >= 0.0) && (vScreenCoord.x < vSize.x) && (vScreenCoord.y < vSize.y))\n\t{\n\t\tcol = vCol;\n\t}\n}\n\nvec3 TexCompute2( vec2 vTexCoord, float fRandom )\n{\n    fRandom = 1.0 - fRandom * fRandom;\n\tvec3 col = vec3(35.0 \/ 255.0);\n\t\n\tcol *= Indent( vTexCoord, vec2( -8.0, 0.0), vec2(300.0, 10.0), 1.3, 0.5);\n\tcol *= Indent( vTexCoord, vec2( -8.0, 11.0), vec2(300.0, 27.0), 1.3, 0.5);\n\tcol *= Indent( vTexCoord, vec2( -8.0, 28.0), vec2(300.0, 43.0), 1.3, 0.5);\n\t{\n\t\tvec2 vLocalCoord = vTexCoord;\n\t\tvLocalCoord.x = mod(vLocalCoord.x, 21.0);\n\t\tcol *= Indent( vLocalCoord, vec2( 0.0, 44.0), vec2(20.0, 55.0), 1.3, 0.5);\n\t}\n\n\tif(vTexCoord.y < 40.0)\n\t{\n\t\tvec2 vTileSize = vec2(48.0, 14.0);\n\t\tvec2 vIndex = floor(vTexCoord \/ vTileSize);\n\n\t\tfloat fIndex = vIndex.x + vIndex.y * 13.0;\n\t\tvec2 vMin = vIndex * vTileSize + vec2(hash(fIndex) * 32.0, 4.0);\n\t\tvec2 vSize = vec2(8.0 + hash(fIndex + 1.0) * 32.0, 4.0);\n\n\t\tvec3 vCol = vec3(0.0);\n\t\tfloat iIndex = floor(mod(fIndex, 5.0));\n\t\tif( iIndex < 0.5 ) \n\t\t{\n\t\t\tvCol = mix(vec3(0.0, 0.5, 0.0), vec3(0.0, 0.25, 0.0), fRandom);\n\t\t}\n\t\telse if(iIndex < 1.5)\n\t\t{\n\t\t\tvCol = mix(vec3(1.0, 0.6, 0.02), vec3(0.1), fRandom);\n\t\t}\n\t\telse if(iIndex < 2.5)\n\t\t{\n\t\t\tvCol = vec3(fRandom * 0.5);\n\t\t}\n\t\telse if(iIndex < 3.5)\n\t\t{\n\t\t\tvCol = vec3(fRandom * 0.25);\n\t\t}\n\t\telse if(iIndex < 4.5)\n\t\t{\n\t\t\tvCol = mix(vec3(0.0, 0.0, 0.5), vec3(0.1), fRandom);\n\t\t}\n\t\tDrawScreen(col, vTexCoord, vMin, vSize, vCol);\n\t}\n\n\treturn col;\n}\n\nvec3 TexStep6( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n\tvec3 col = mix( vec3(87.0, 67.0, 51.0), vec3(119.0, 95.0, 75.0), fRandom) \/ 255.0;\n\n\tcol *= Indent( vTexCoord, vec2(-1.0, 3.0), vec2(32.0, 1.0), 1.3, 0.7);\n\tcol *= Indent( vTexCoord, vec2(-1.0, 8.0), vec2(32.0, 0.0), 1.3, 0.9);\n\n\tfloat fStreak = clamp((vTexCoord.y \/ 16.0) * 1.5 - fHRandom, 0.0, 1.0);\n\n\tcol *= fStreak * 0.3 + 0.7;\n\t\n\treturn col;\n}\n\nvec3 TexSupport2( vec2 vTexCoord, float fRandom )\n{\n\tvec3 col;\n\tfloat fShade = 0.5;\n\t\n\tfloat f1 = abs(fract((vTexCoord.y + 32.0) \/ 70.0) - 0.5) * 2.0;\n\tfloat f2 = abs(fract((vTexCoord.x + 16.0) \/ 16.0) - 0.5) * 2.0;\n\tfShade += f1 * 0.75 + f2 * 0.25;\n\tfShade = fShade * fShade;\n\n\tfShade = fShade * 0.2 + 0.05;\n\tfShade *= 1.0 + fRandom * 0.4;\n\n\tvec2 vLocalCoord = vTexCoord;\n\tif((vLocalCoord.y < 64.0) || (vLocalCoord.y > 75.0))\n\t{\n\t\tif(vLocalCoord.y > 64.0) vLocalCoord.y -= 8.0;\n\t\tvLocalCoord = mod( vLocalCoord, vec2(20.0, 16.0));\n\t\tfloat fIndent = Indent( vLocalCoord, vec2(8.0, 8.0), vec2(16.0, 15.0), 0.9, 1.1);\n\t\tfShade += fIndent - 1.0;\n\t}\n\t\n\tcol = vec3(fShade);\n\t\n\treturn col;\n}\n\nvec3 TexDoorTrak( vec2 vTexCoord, float fRandom )\n{\n\tfloat fShade = fRandom * 0.5;\n\tfShade *= mod(vTexCoord.x, 2.0) * 0.6 + 0.4;\n\treturn vec3(fShade);\n}\n\nvec3 TexBrown144( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n\tvec3 col = mix( vec3(39.0, 39.0, 39.0), vec3(51.0, 43.0, 19.0), fRandom) \/ 255.0;\n\t\n\tfloat fBlend = fHRandom - 0.1;\n\tfBlend = clamp(fBlend, 0.0, 1.0);\n\tcol = mix( col, col * 2.0 * vec3(0.893, 0.725, 0.161), fBlend);\n\treturn col;\n}\n\n#ifdef ENABLE_SPRITES\n\nvec3 TexBar1A( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n\tvec3 col = vec3(123.0, 127.0, 99.0) \/ 255.0;\n\t\n\tfloat fBrownStreakBlend = smoothstep( 2.0, 1.0, abs(vTexCoord.x - 3.5));\n\tcol = mix(col, vec3(0.724, 0.736, 0.438), fBrownStreakBlend);\n\t\n\tif( (vTexCoord.y == 1.0) && (vTexCoord.x > 3.0) && (vTexCoord.x < 18.0) )\n\t{\n\t\tcol = col * clamp(((vTexCoord.x \/ 18.0)), 0.0, 1.0);\t\t\n\t}\n\telse\n\t{\n\t\tcol = col * clamp((1.0 - (vTexCoord.x \/ 18.0)), 0.0, 1.0);\t\t\n\t}\n\t\n\tfloat fNukageBlend = 0.0;\n\tif( (vTexCoord.y == 1.0) && (vTexCoord.x > 8.0) && (vTexCoord.x < 14.0) )\n\t{\n\t\tfNukageBlend = 1.0;\n\t}\t\n\tif( (vTexCoord.y == 2.0) && (vTexCoord.x > 2.0) && (vTexCoord.x < 20.0) )\n\t{\n\t\tfNukageBlend = 1.0;\n\t}\t\n\tcol = mix(col, vec3(0.172, 0.560, 0.144) * fRandom, fNukageBlend);\n\t\n\t\n\tif(vTexCoord.x < 1.0)\n\t{\n\t\tcol += 0.1;\n\t}\n\t\n\tfloat fBlend = clamp(((vTexCoord.x - 20.0) \/ 3.0), 0.0, 1.0);\n\tcol += fBlend * 0.2;\n\t\n\tfloat fBumpY = 8.0;\n\tif(vTexCoord.y > 14.0) fBumpY += 9.0;\n\tif(vTexCoord.y > 23.0) fBumpY += 8.0;\n\n\tvec4 vBump = SmoothBump( vTexCoord, vec2(2.0, fBumpY), vec2(23.0 - 2.0, fBumpY), normalize(vec2(-0.2, 1.0)), 1.25 );\t\n\tcol += vBump.x * 0.2;\n\n\t\/\/ rim highlights\n\t{\n\t\tvec2 vOffset = (vTexCoord - vec2(17.0, 0.0)) \/ vec2(8.0, 2.0);\n\t\tcol += clamp(1.0 - dot(vOffset, vOffset), 0.0, 1.0) * 0.2;\n\t}\t\n\t{\n\t\tvec2 vOffset = (vTexCoord - vec2(20.0, 1.0)) \/ vec2(4.0, 1.0);\n\t\tcol += clamp(1.0 - dot(vOffset, vOffset), 0.0, 1.0) * 0.2;\n\t}\t\n\t{\n\t\tvec2 vOffset = (vTexCoord - vec2(3.0, 2.0)) \/ vec2(4.0, 2.0);\n\t\tcol += clamp(1.0 - dot(vOffset, vOffset), 0.0, 1.0) * 0.2;\n\t}\t\n\t\n\tcol *= 0.5 + fRandom * 0.5;\n\t\n\treturn col;\n}\n\nvec3 TexPlayW( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n    vec3 col = mix(vec3(190.0, 10.0, 10.0), vec3(50, 16.0, 16.0 ), fRandom * vTexCoord.y\/18.0) \/ 255.0;\n\treturn col;\n}\n\n#endif \n\nvec3 SampleTexture( const in float fTexture, const in vec2 _vUV )\n{\n    vec3 col = vec3(1.0, 0.0, 1.0);\n    vec2 vUV = _vUV;\n    \n    vec2 vSize = vec2(64.0);\n    float fPersistence = 0.8;\n\tfloat fNoise2Freq = 0.5;\n\n\tif(fTexture == TEX_NUKAGE3)\n\t{\n        float fTest = fract(floor(iTime * 6.0) * (1.0 \/ 3.0));\n        if( fTest < 0.3 )\n        {\n\t        vUV += 0.3 * vSize;\n        }\n        else if(fTest < 0.6)\n        {\n            vUV = vUV.yx - 0.3; \n        }\n        else\n        {\n            vUV = vUV + 0.45;\n        }\n\t}\n\t\n\t     if(fTexture == TEX_NUKAGE3) { fPersistence = 1.0; }\n\telse if(fTexture == TEX_F_SKY1) { vSize = vec2(256.0, 128.0); fNoise2Freq = 0.3; }\n    else if(fTexture == TEX_FLOOR7_1) { vSize = vec2(64.0, 32.0); fPersistence = 1.0; }\t\n    else if(fTexture == TEX_FLAT5_5) { fPersistence = 3.0; }\n    else if(fTexture == TEX_FLOOR4_8) { fPersistence = 0.3; }\n    else if(fTexture == TEX_CEIL3_5) { fPersistence = 0.9; }\t\n    else if(fTexture == TEX_FLAT14) { fPersistence = 2.0; }\n    else if(fTexture == TEX_DOOR3) { vSize = vec2(64.0, 72.0); }\t\n    else if(fTexture == TEX_LITE3) { vSize = vec2(32.0, 128.0); }\t\n    else if(fTexture == TEX_STARTAN3) { vSize = vec2(128.0); fPersistence = 1.0; }\t\n\telse if(fTexture == TEX_BROWN1) { vSize = vec2(128.0); fPersistence = 0.7; }\t\n    else if(fTexture == TEX_DOORSTOP) { vSize = vec2(8.0, 128.0); fPersistence = 0.7; }\n    else if(fTexture == TEX_COMPUTE2) { vSize = vec2(256.0, 56.0); fPersistence = 1.5; }\n    else if(fTexture == TEX_STEP6) { vSize = vec2(32.0, 16.0); fPersistence = 0.9; }\n    else if(fTexture == TEX_SUPPORT2) { vSize = vec2(64.0, 128.0); }\n    else if(fTexture == TEX_DOORTRAK) { vSize = vec2(8.0, 128.0); }\n#ifdef ENABLE_SPRITES\t\n\telse if(fTexture == TEX_BAR1A) { vSize = vec2(23.0, 32.0); }\n\telse if(fTexture == TEX_PLAYW) { vSize = vec2(57.0, 22.0); fPersistence = 1.0; }\n#endif\n\t\n#ifdef PREVIEW\n\t     if(fTexture == TEX_DOOR3) {\tvSize = vec2(128.0, 128.0); }\t\n\telse if(fTexture == TEX_COMPUTE2) { vSize = vec2(256.0, 64.0); }\n#ifdef ENABLE_SPRITES\t\n\telse if(fTexture == TEX_BAR1A) { vSize = vec2(32.0, 32.0); }\n\telse if(fTexture == TEX_PLAYW) { vSize = vec2(64.0, 32.0); }\t\n#endif\n#endif\n\t\n\t\n#ifdef PREVIEW\n    vec2 vTexCoord = floor(fract(vUV) * vSize);\n#else\n    vec2 vTexCoord = fract(vUV \/ vSize) * vSize;\n    #ifdef PIXELATE_TEXTURES\n    vTexCoord = floor(vTexCoord);\n    #endif\n    vTexCoord.y = vSize.y - vTexCoord.y - 1.0;\n#endif\n\tfloat fRandom = fbm( vTexCoord, fPersistence );\n\tfloat fHRandom = noise1D(vTexCoord.x * fNoise2Freq) - ((vTexCoord.y) \/ vSize.y);\n    \n\t     if(fTexture == TEX_NUKAGE3) \tcol = TexNukage3( vTexCoord, fRandom );\n\telse if(fTexture == TEX_F_SKY1) \tcol = TexFSky1( vTexCoord, fRandom, fHRandom );\n    else if(fTexture == TEX_FLOOR7_1) \tcol = TexFloor7_1( vTexCoord, fRandom );\n    else if(fTexture == TEX_FLAT5_5) \tcol = TexFlat5_5( vTexCoord, fRandom );\n    else if(fTexture == TEX_FLOOR4_8) \tcol = TexFloor4_8( vTexCoord, fRandom );\n    else if(fTexture == TEX_CEIL3_5) \tcol = TexCeil3_5( vTexCoord, fRandom );\n\telse if(fTexture == TEX_FLAT14) \tcol = TexFlat14( vTexCoord, fRandom );\n\telse if(fTexture == TEX_DOOR3) \t\tcol = TexDoor3( vTexCoord, fRandom, fHRandom );\n\telse if(fTexture == TEX_LITE3) \t\tcol = TexLite3( vTexCoord );\n    else if(fTexture == TEX_STARTAN3) \tcol = TexStartan3( vTexCoord, fRandom );\n    else if(fTexture == TEX_BROWN1) \tcol = TexBrown1( vTexCoord, fRandom, fHRandom );\n    else if(fTexture == TEX_DOORSTOP) \tcol = TexDoorstop( vTexCoord, fRandom );\n    else if(fTexture == TEX_COMPUTE2) \tcol = TexCompute2( vTexCoord, fRandom );\n    else if(fTexture == TEX_STEP6) \t\tcol = TexStep6( vTexCoord, fRandom, fHRandom );\n    else if(fTexture == TEX_SUPPORT2) \tcol = TexSupport2( vTexCoord, fRandom );\n\telse if(fTexture == TEX_DOORTRAK) \tcol = TexDoorTrak( vTexCoord, fRandom );\n\telse if(fTexture == TEX_BROWN144) \tcol = TexBrown144( vTexCoord, fRandom, fHRandom );\n#ifdef ENABLE_SPRITES\t\n\telse if(fTexture == TEX_BAR1A) \t\tcol = TexBar1A( vTexCoord, fRandom, fHRandom );\n\telse if(fTexture == TEX_PLAYW) \t\tcol = TexPlayW( vTexCoord, fRandom, fHRandom );\t\n#endif\n\t\n    #ifdef QUANTIZE_TEXTURES\n    col = Quantize(col);\n    #endif\n\n    return col;\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n\tconst vec2 vStart = vec2(1050, -3616);\n    \n    fragRayOri.z *= -1.0;\n    fragRayDir.z *= -1.0;\n    \n    fragRayOri *= 48.0;\n    \n    vec3 vCameraPos;\n    vec3 vCameraTarget;\n\tDemoCamera( iTime * 0.25, vCameraPos, vCameraTarget );\n    \n    if ( false )\n    {\n    \tfragRayOri += vCameraPos;\n    }\n    else\n    {\n    \tfragRayOri.xz += vStart;\n    \tfragRayOri.y += 48.0;        \n    }\n    \n    Ray r;\n    r.vRayOrigin = fragRayOri;\n    r.vRayDir = fragRayDir;\n    \n    vec3 vForwards = fragRayDir; \n    \n\tvec3 vResult = DrawScene(vForwards, fragCoord \/ iResolution.xy,r);\n    \n    fragColor = vec4( vResult, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"XsfGRr","channel":0}],"code":"#define N(T,N) t+=float(T); if(x>t) r=vec2(N,t);\n#define L(T,N,X) t+=float(T); if((x>t) && (x<(t+float(X)))) r=vec2(N,t);\n\nvec2 GetTrack1Note(float x)\n{\n    vec2 r = vec2(-1.0);\n    float t = 0.0;\n    L(1628,40,8)N(24,40)N(28,52)L(24,40,8)N(26,40)N(26,50)L(24,40,8)N(26,40)N(26,48)L(24,40,8)N(26,40)N(26,46)L(24,40,12)N(28,40)N(24,47)N(26,48)L(26,40,4)N(24,40)N(26,52)L(26,40,8)N(24,40)N(26,50)L(26,40,8)N(24,40)N(28,48)L(24,40,10)N(26,40)N(26,46)L(126,40,10)N(26,40)N(24,52)L(28,40,8)N(24,40)N(26,50)L(26,40,10)N(24,40)N(26,48)L(26,40,8)N(24,40)N(26,46)L(26,40,8)N(24,40)N(28,47)N(24,48)L(26,40,8)N(26,40)N(24,52)L(26,40,10)N(26,40)N(24,50)L(26,40,8)N(26,40)L(24,63,14)L(14,60,14)L(14,59,12)L(12,63,12)L(12,66,12)L(12,64,14)L(14,63,12)L(12,59,14)L(14,63,12)L(12,64,12)L(12,66,12)L(12,67,14)L(14,66,14)L(14,64,12)L(12,63,12)L(12,59,12)L(12,40,8)N(26,40)N(26,52)L(24,40,8)N(28,40)N(24,50)L(26,40,8)N(26,40)N(24,48)L(26,40,8)N(26,40)N(24,46)L(26,40,10)N(26,40)N(24,47)N(28,48)L(24,40,4)N(26,40)N(26,52)L(24,40,8)N(26,40)N(26,50)L(24,40,8)N(26,40)N(26,48)L(24,40,10)N(28,40)N(24,46)L(128,40,8)N(24,40)N(26,52)L(26,40,8)N(24,40)N(28,50)L(24,40,10)N(26,40)N(26,48)L(24,40,8)N(26,40)N(26,46)L(24,40,8)N(26,40)N(26,47)N(24,48)L(28,40,8)N(24,40)N(26,52)L(26,40,8)N(24,40)N(26,50)L(26,40,8)N(24,40)L(26,67,14)L(14,64,12)L(12,59,12)L(12,64,12)L(12,67,14)L(14,64,14)L(14,67,12)L(12,71,12)L(12,67,12)L(12,64,14)\n    return r;\n}\n\nvec2 GetTrack2Note(float x)\n{\n    vec2 r = vec2(-1.0);\n    float t = 0.0;\n    L(0,40,8)N(24,40)N(26,52)L(26,40,8)N(26,40)N(26,50)L(24,40,8)N(26,40)N(26,48)L(24,40,8)N(26,40)N(26,46)L(24,40,12)N(26,40)N(26,47)N(26,48)L(26,40,4)N(24,40)N(26,52)L(26,40,8)N(24,40)N(26,50)L(26,40,8)N(24,40)N(26,48)L(26,40,10)N(26,40)N(26,46)L(126,40,10)N(26,40)N(24,52)L(26,40,10)N(26,40)N(26,50)L(26,40,10)N(24,40)N(26,48)L(26,40,8)N(24,40)N(26,46)L(26,40,8)N(24,40)N(26,47)N(26,48)L(26,40,8)N(26,40)N(24,52)L(26,40,10)N(26,40)N(24,50)L(26,40,8)N(26,40)N(24,48)L(26,40,10)N(26,40)N(26,46)L(126,40,8)N(26,40)N(26,52)L(24,40,8)N(26,40)N(26,50)L(26,40,8)N(26,40)N(24,48)L(26,40,8)N(26,40)N(24,46)L(26,40,10)N(26,40)N(24,47)N(26,48)L(26,40,4)N(26,40)N(26,52)L(24,40,8)N(26,40)N(26,50)L(24,40,8)N(26,40)N(26,48)L(24,40,10)N(26,40)N(26,46)L(128,40,8)N(24,40)N(26,52)L(26,40,8)N(24,40)N(26,50)L(26,40,10)N(26,40)N(26,48)L(24,40,8)N(26,40)N(26,46)L(24,40,8)N(26,40)N(26,47)N(24,48)L(26,40,10)N(26,40)N(26,52)L(26,40,8)N(24,40)N(26,50)L(26,40,8)N(24,40)L(26,66,14)L(14,64,12)L(12,63,12)L(12,66,12)L(12,69,14)L(14,67,12)L(12,66,14)L(14,63,12)L(12,66,12)L(12,67,14)L(14,69,12)L(12,71,14)L(14,69,12)L(12,67,12)L(12,66,12)L(12,63,14)L(14,40,6)N(26,40)N(24,52)L(26,40,8)N(26,40)N(24,50)L(26,40,10)N(26,40)N(26,48)L(26,40,8)N(24,40)N(26,46)L(26,40,10)N(24,40)N(26,47)N(26,48)L(24,40,6)N(26,40)N(26,52)L(26,40,8)N(26,40)N(24,50)L(26,40,8)N(26,40)N(24,48)L(26,40,10)N(26,40)N(24,46)L(128,40,8)N(26,40)N(26,52)L(24,40,8)N(26,40)N(26,50)L(24,40,12)N(26,40)N(26,48)L(26,40,8)N(26,40)N(24,46)L(26,40,8)N(26,40)N(24,47)N(26,48)L(26,40,8)N(24,40)N(26,52)L(26,40,8)N(26,40)N(26,50)L(24,40,8)L(26,40,14)L(26,71,12)L(12,67,12)L(12,64,14)L(14,67,12)L(12,71,14)L(14,67,12)L(12,71,12)L(12,76,12)L(12,71,14)L(14,67,12)\n    return r;\n}\n\nvec2 GetTrack3Note(float x)\n{\n    vec2 r = vec2(-1.0);\n    float t = 0.0;\n    N(0,40)N(406,40)N(406,40)N(408,40)N(408,40)N(408,40)N(406,40)N(408,40)N(406,40)N(52,40)N(52,40)N(50,40)N(50,40)N(52,40)N(50,40)N(50,40)N(52,40)N(52,40)N(50,40)N(50,40)N(52,40)N(52,40)N(50,40)N(50,40)N(52,40)N(50,40)N(50,40)N(52,40)N(52,40)N(50,40)N(50,40)N(52,40)N(52,40)N(50,40)N(50,40)N(52,40)N(50,40)N(50,40)N(52,40)\n    return r;\n}\n\nvec2 GetTrack4ANote(float x)\n{\n    vec2 r = vec2(-1.0);\n    float t = 0.0;\n    N(0,36)N(406,36)N(406,36)N(408,36)N(408,36)L(38,49,8)N(370,36)L(36,49,10)N(370,36)L(38,49,8)N(370,36)L(38,49,8)L(164,36,12)L(28,36,10)L(24,36,12)L(26,36,14)L(26,36,10)L(24,36,12)L(26,36,10)L(26,36,12)N(24,36)N(2,46)N(50,40)N(2,46)L(50,36,12)N(2,46)N(22,36)N(26,40)N(2,46)N(48,36)N(2,46)N(50,40)N(4,46)L(46,36,14)N(2,46)N(24,36)N(24,40)N(4,46)N(48,36)N(2,46)N(50,40)N(2,46)L(48,36,14)N(6,46)N(20,36)N(24,40)N(4,46)N(48,36)N(52,40)N(48,46)L(2,36,14)N(26,36)N(24,40)N(2,46)N(48,46)N(2,36)N(50,46)N(50,46)L(28,36,14)N(24,46)N(52,36)N(50,40)N(2,46)N(48,36)N(52,40)N(2,46)N(50,36)N(48,46)N(2,40)N(50,46)N(26,36)N(26,40)L(50,36,6)L(2,50,8)L(24,36,8)L(24,36,8)L(4,40,6)L(24,36,8)L(24,36,8)L(4,45,8)L(2,40,6)\n    return r;\n}\n\nvec2 GetTrack4BNote(float x)\n{\n    vec2 r = vec2(-1.0);\n    float t = 0.0;\n    N(0,40)N(406,40)N(406,40)N(408,40)N(408,40)L(38,57,8)N(370,40)L(36,57,10)N(370,40)L(38,57,8)N(370,40)L(38,57,8)L(164,40,12)L(28,40,8)L(24,40,14)L(26,40,12)L(26,40,12)L(24,40,12)L(26,40,14)L(26,40,12)N(636,46)N(52,46)N(202,40)N(50,36)N(52,40)N(52,46)N(100,46)N(104,46)L(100,36,14)N(52,46)L(52,40,8)L(52,47,8)\n    return r;\n}\n\nvec2 GetTrack4CNote(float x)\n{\n    vec2 r = vec2(-1.0);\n    float t = 0.0;\n    N(0,41)N(406,41)N(406,41)N(408,41)N(408,41)N(408,41)N(406,41)N(408,41)L(202,41,12)L(28,41,8)L(24,41,12)L(26,41,10)L(26,41,12)L(24,41,12)L(26,41,12)L(26,41,12)\n    return r;\n}\n\nvec2 GetTrack4DNote(float x)\n{\n    vec2 r = vec2(-1.0);\n    float t = 0.0;\n    N(1628,49)N(408,49)N(406,49)N(408,49)\n    return r;\n}\n\nvec2 GetTrack4ENote(float x)\n{\n    vec2 r = vec2(-1.0);\n    float t = 0.0;\n    N(1628,57)N(408,57)L(406,57,14)L(408,57,14)\n    return r;\n}\n\n\n\/\/ ------------------- 8< ------------------- 8< ------------------- 8< -------------------\n\n#define PI radians(180.0)\n#define TWO_PI radians(360.0)\n\nfloat NoteToHz(float n)\n{  \t\n\treturn 440.0*pow( 2.0, (n-69.0)\/12.0 );\n}\n\nfloat Tri( float t )\n{\n\treturn abs(fract( t ) * 4.0 - 2.0) - 1.0;\n}\n\nfloat Saw( float t )\n{\n\treturn fract( t ) * 2.0 - 1.0;\n}\n\nvec4 Saw4( vec4 x )\n{\n\treturn fract( x ) * 2.0 - 1.0;\n}\n\nfloat Cos( float t )\n{\n\treturn cos( t * radians(360.0) );\n}\n\nvec4 Cos4( vec4 x )\n{\n\tx = abs(fract(x) * 2.0 - 1.0);\n\tvec4 x2 = x*x;\n\treturn x2 * 6.0 - x2*x * 4.0  - 1.0;\n}\n\nfloat Square( float t )\n{\n\treturn step( fract(t), 0.5 ) * 2.0 - 1.0;\n}\n\n\/\/ Thanks to Dave_Hoskins for the hash\nfloat Hash(float p)\n{\n\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\n\nfloat Noise( float x )\n{\n\treturn Hash( floor(x * 32.0) ) * 2.0 - 1.0;\n}\n\nfloat SmoothNoise( float t )\n{\n\tfloat noiset = t * 32.0;\n\tfloat tfloor = floor(noiset);\n\tfloat ffract = fract(noiset);\n\t\n\tfloat n0 = Hash(tfloor);\n\tfloat n1 = Hash(tfloor + 1.0);\n\tfloat blend = ffract*ffract*(3.0 - 2.0*ffract);\n\treturn mix(n0, n1, blend) * 2.0 - 1.0;\n}\n\nfloat FBM( float t, float persistence )\n{\n    float result = 0.0;\n    \n    float a = 1.0;\n    float tot = 0.0;\n    result += SmoothNoise(t) * a; tot += a; t *= 2.02; a *= persistence;\n    result += SmoothNoise(t) * a; tot += a; t *= 2.02; a *= persistence; \n    result += SmoothNoise(t) * a; tot += a; t *= 2.02; a *= persistence; \n    result += SmoothNoise(t) * a; tot += a; t *= 2.02; a *= persistence; \n    tot += a; \n    return result \/ tot;\n}\n\n\nfloat StepNoise( float t, float freq )\n{\n\tfloat noiset = t * freq;\n\tfloat tfloor = floor(noiset);\n\t\n\tfloat n = Hash(tfloor);\n\treturn n * 2.0 - 1.0;\n}\n\nfloat Cos4(float x, vec4 phase, vec4 freq, vec4 amp)\n{\n\treturn dot(Cos4((x+phase) * freq), amp);\n}\n\nfloat Saw4(float x, vec4 phase, vec4 freq, vec4 amp)\n{\n\treturn dot(Saw4((x+phase) * freq), amp);\n}\n\n\nfloat Test( float t )\n{\n\treturn Saw4(t, vec4(0.0, 0.5, 0.1, 0.4), vec4(1.0, 1.50, 2.00, -3.00), vec4(1.0, 0.5, 0.25, 0.125));\n}\n\nfloat Envelope( float time, float decay )\n{\t\n\treturn exp2( -time * (5.0 \/ decay) );\n}\n\nfloat Envelope( float time, float attack, float decay )\n{\n\tif( time < attack )\n\t{\n\t\treturn time\/attack;\n\t}\n\n\ttime -= attack;\n\n\treturn Envelope( time, decay );\n}\n\nfloat Test2(float f)\n{\n    return Test(f) + Test(f - 0.0454) * 0.4 + Test(f - 0.1123) * 0.3 + Test(f - 0.1523) * 0.1;\n}\nfloat Instrument( const in vec2 vFreqTime )\n{\n    return Test2( vFreqTime.x * vFreqTime.y ) * Envelope( vFreqTime.y, 0.01, 1.0 );    \n}\n\nfloat Track1Instrument( const in vec2 vFreqTime )\n{\n    return Instrument( vFreqTime * vec2(2.0, 1.0) ) * 0.75;\n}\n\nfloat Track2Instrument( const in vec2 vFreqTime )\n{\n    return Instrument( vFreqTime );\n}\n\nfloat Track3Basic(float x)\n{\n    return FBM(x, 0.5);\n}\n\nfloat Track3Instrument( const in vec2 vFreqTime )\n{\n    return Track3Basic(vFreqTime.y * vFreqTime.x) * Envelope(vFreqTime.y, 0.4) * 2.0;\n}\n\nfloat kick(float freq, float fNoteTime){\n    float a = clamp(1.0-fNoteTime,0.0,1.0);\n    float osc = sin(pow(a,5.0)*freq);\n    return osc * pow(a, 2.0);\n}\n\nfloat Track4Instrument( const in vec2 vFreqTime )\n{\n    return FBM(vFreqTime.y * vFreqTime.x * 8.0, 2.0) * Envelope(vFreqTime.y, 0.5);\n}\n\n\nconst float kMidiTimebase = 200.0;\nconst float kInvMidiTimebase = 1.0 \/ kMidiTimebase;\n\nvec2 GetNoteData( const in vec2 vMidiResult, const in float fMidiTime )\n{\n    return vec2( NoteToHz(vMidiResult.x), abs(fMidiTime - vMidiResult.y) * kInvMidiTimebase );\n}\n\nfloat PlayMidi( const in float time )\n{\n    if(time < 0.0)\n\t\treturn 0.0;\n    \n    float fMidiTime = time * kMidiTimebase;\n    \n    float fResult = 0.0;\n    \n    fResult += Track1Instrument( GetNoteData( GetTrack1Note(fMidiTime), fMidiTime ) );\n    fResult += Track2Instrument( GetNoteData( GetTrack2Note(fMidiTime), fMidiTime ) );\n    fResult += Track3Instrument( GetNoteData( GetTrack3Note(fMidiTime), fMidiTime ) );\n    fResult += Track4Instrument( GetNoteData( GetTrack4ANote(fMidiTime), fMidiTime ) );\n    fResult += Track4Instrument( GetNoteData( GetTrack4BNote(fMidiTime), fMidiTime ) );\n    fResult += Track4Instrument( GetNoteData( GetTrack4CNote(fMidiTime), fMidiTime ) );\n    fResult += Track4Instrument( GetNoteData( GetTrack4DNote(fMidiTime), fMidiTime ) );\n    fResult += Track4Instrument( GetNoteData( GetTrack4ENote(fMidiTime), fMidiTime ) );\n    \n    fResult = clamp(fResult * 0.1, -1.0, 1.0);\n    \n    float fFadeEnd = 20.0 * 240.0 \/ kMidiTimebase;\n    float fFadeTime = 5.0;\n    float fFade = (time - (fFadeEnd - fFadeTime)) \/ fFadeTime;    \n    fResult *= clamp(1.0 - fFade, 0.0, 1.0);\n    \n    return fResult;\n}\n\nvec2 mainSound( in int samp,float time)\n{\n    return vec2( PlayMidi(time - 3.0) );\n}\n\n\/\/#define IMAGE_SHADER\n\n#ifdef IMAGE_SHADER\n\nfloat Function( float x )\n{\n\treturn mainSound( in int samp, iTime + x \/ (44100.0 \/ 60.0) ).x * 0.5 + 0.5;\n}\n\nfloat Plot( vec2 uv )\n{\n\tfloat y = Function(uv.x);\n\t\n\treturn abs(y - uv.y) * iResolution.y;\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n\t\n\tvec3 vResult = vec3(0.0);\n\t\n\tvResult += Plot(uv);\n\t\n\tfragColor = vec4((vResult),1.0);\n}\n#endif\n\n","name":"Sound","description":"","type":"sound"}]},{"ver":"0.1","info":{"id":"Xl2XRW","date":"1442094288","viewed":49786,"name":"Where the River Goes","username":"P_Malin","description":"What started as a hacked flow and advection experiment turned into something nice.\n\nIf you have a (very) fast GPU, try uncommenting #define ENABLE_ULTRA_QUALITY","likes":368,"published":3,"flags":1,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"\/media\/a\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"\/media\/ap\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Where the River Goes\n\/\/ @P_Malin\n\n\/\/ What started as a hacked flow and advection experiment turned into something nice.\n\n\/\/ Placeholder audio https:\/\/www.youtube.com\/watch?v=gmar4gh5nIw suggested by @qthund on twitter\n\n\/\/#define ENABLE_ULTRA_QUALITY\n\n#define ENABLE_WATER\n#define ENABLE_FOAM\n#define ENABLE_WATER_RECEIVE_SHADOW\n#define ENABLE_CONE_STEPPING\n\n\n\/\/ Textureless version\n\/\/#define ENABLE_NIMITZ_TRIANGLE_NOISE\n\n\/\/#define ENABLE_LANDSCAPE_RECEIVE_SHADOW\n\n\/\/#define ENABLE_SCREENSHOT_MODE\nconst float k_screenshotTime = 13.0;\n\n#if defined(ENABLE_SCREENSHOT_MODE) || defined(ENABLE_ULTRA_QUALITY)\n#define ENABLE_SUPERSAMPLE_MODE\n#endif\n\n#ifndef ENABLE_SCREENSHOT_MODE\n#ifdef ENABLE_ULTRA_QUALITY\nconst int k_raymarchSteps = 96;\nconst int k_fmbSteps = 6;\nconst int k_superSampleCount = 6;\n#else\nconst int k_raymarchSteps = 64;\nconst int k_fmbSteps = 3;\n#endif\n#else\nconst int k_raymarchSteps = 96;\nconst int k_fmbSteps = 5;\nconst int k_superSampleCount = 10;\n#endif\n\nconst int k_fmbWaterSteps = 4;\n\n#define OBJ_ID_SKY 0.0\n#define OBJ_ID_GROUND 1.0\n\nfloat g_fTime;\n\nconst vec3 g_vSunDir = vec3( -1.0, 0.7, 0.25 );\nvec3 GetSunDir() { return normalize( g_vSunDir ); }\n\nconst vec3 g_sunColour = vec3( 1.0, 0.85, 0.5 ) * 5.0;\nconst vec3 g_skyColour = vec3( 0.1, 0.5, 1.0 ) * 1.0;\n\nconst vec3 k_bgSkyColourUp = g_skyColour * 4.0;\nconst vec3 k_bgSkyColourDown = g_skyColour * 6.0;\n\nconst vec3 k_envFloorColor = vec3(0.3, 0.2, 0.2);\n\nconst vec3 k_vFogExt = vec3(0.01, 0.015, 0.015) * 3.0;\nconst vec3 k_vFogIn = vec3(1.0, 0.9, 0.8) * 0.015;\n\n\nconst float k_fFarClip = 20.0;\n\n#define MOD2 vec2(4.438975,3.972973)\n\nfloat Hash( float p ) \n{\n    \/\/ https:\/\/www.shadertoy.com\/view\/4djSRW - Dave Hoskins\n\tvec2 p2 = fract(vec2(p) * MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);    \n\t\/\/return fract(sin(n)*43758.5453);\n}\n\nvec2 Hash2( float p ) \n{\n    \/\/ https:\/\/www.shadertoy.com\/view\/4djSRW - Dave Hoskins\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat SmoothNoise(in vec2 o) \n{\n\tvec2 p = floor(o);\n\tvec2 f = fract(o);\n\t\t\n\tfloat n = p.x + p.y*57.0;\n\n\tfloat a = Hash(n+  0.0);\n\tfloat b = Hash(n+  1.0);\n\tfloat c = Hash(n+ 57.0);\n\tfloat d = Hash(n+ 58.0);\n\t\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\t\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\t\n\tfloat u = t.x;\n\tfloat v = t.y;\n\n\tfloat res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n    \n    return res;\n}\n\nfloat FBM( vec2 p, float ps ) {\n\tfloat f = 0.0;\n    float tot = 0.0;\n    float a = 1.0;\n    for( int i=0; i<k_fmbSteps; i++)\n    {\n        f += SmoothNoise( p ) * a;\n        p *= 2.0;\n        tot += a;\n        a *= ps;\n    }\n    return f \/ tot;\n}\n\nfloat FBM_Simple( vec2 p, float ps ) {\n\tfloat f = 0.0;\n    float tot = 0.0;\n    float a = 1.0;\n    for( int i=0; i<3; i++)\n    {\n        f += SmoothNoise( p ) * a;\n        p *= 2.0;\n        tot += a;\n        a *= ps;\n    }\n    return f \/ tot;\n}\n\nvec3 SmoothNoise_DXY(in vec2 o) \n{\n\tvec2 p = floor(o);\n\tvec2 f = fract(o);\n\t\t\n\tfloat n = p.x + p.y*57.0;\n\n\tfloat a = Hash(n+  0.0);\n\tfloat b = Hash(n+  1.0);\n\tfloat c = Hash(n+ 57.0);\n\tfloat d = Hash(n+ 58.0);\n\t\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\t\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\tvec2 dt = 6.0 * f - 6.0 * f2;\n\t\n\tfloat u = t.x;\n\tfloat v = t.y;\n\tfloat du = dt.x;\t\n\tfloat dv = dt.y;\t\n\n\tfloat res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n    \n\tfloat dx = (b-a)*du + (a-b+d-c)*du*v;\n\tfloat dy = (c-a)*dv + (a-b+d-c)*u*dv;    \n    \n    return vec3(dx, dy, res);\n}\n\nvec3 FBM_DXY( vec2 p, vec2 flow, float ps, float df ) {\n\tvec3 f = vec3(0.0);\n    float tot = 0.0;\n    float a = 1.0;\n    \/\/flow *= 0.6;\n    for( int i=0; i<k_fmbWaterSteps; i++)\n    {\n        p += flow;\n        flow *= -0.75; \/\/ modify flow for each octave - negating this is fun\n        vec3 v = SmoothNoise_DXY( p );\n        f += v * a;\n        p += v.xy * df;\n        p *= 2.0;\n        tot += a;\n        a *= ps;\n    }\n    return f \/ tot;\n}\n\nfloat GetRiverMeander( const float x )\n{\n    return sin(x * 0.3) * 1.5;\n}\n\nfloat GetRiverMeanderDx( const float x )\n{\n    return cos(x * 0.3) * 1.5 * 0.3;\n}\n\nfloat GetRiverBedOffset( const vec3 vPos )\n{\n    float fRiverBedDepth = 0.3 + (0.5 + 0.5 * sin( vPos.x * 0.001 + 3.0)) * 0.4;\n    float fRiverBedWidth = 2.0 + cos( vPos.x * 0.1 ) * 1.0;;\n    \n    float fRiverBedAmount = smoothstep( fRiverBedWidth, fRiverBedWidth * 0.5, abs(vPos.z - GetRiverMeander(vPos.x)) );\n        \n    return fRiverBedAmount * fRiverBedDepth;    \n}\n\nfloat GetTerrainHeight( const vec3 vPos )\n{    \n    float fbm = FBM( vPos.xz * vec2(0.5, 1.0), 0.5 );\n    float fTerrainHeight = fbm * fbm;\n    \n    fTerrainHeight -= GetRiverBedOffset(vPos);\n        \n    return fTerrainHeight;\n}\n\nfloat GetTerrainHeightSimple( const vec3 vPos )\n{    \n    float fbm = FBM_Simple( vPos.xz * vec2(0.5, 1.0), 0.5 );\n    float fTerrainHeight = fbm * fbm;\n    \n    fTerrainHeight -= GetRiverBedOffset(vPos);\n        \n    return fTerrainHeight;\n}\n\n\nfloat GetSceneDistance( const vec3 vPos )\n{\n    return vPos.y - GetTerrainHeight( vPos );\n}\n\nfloat GetFlowDistance( const vec2 vPos )\n{\n    return -GetTerrainHeightSimple( vec3( vPos.x, 0.0, vPos.y ) );\n}\n\nvec2 GetBaseFlow( const vec2 vPos )\n{\n    return vec2( 1.0, GetRiverMeanderDx(vPos.x) );\n}\n\nvec2 GetGradient( const vec2 vPos )\n{\n    vec2 vDelta = vec2(0.01, 0.00);\n    float dx = GetFlowDistance( vPos + vDelta.xy ) - GetFlowDistance( vPos - vDelta.xy );\n    float dy = GetFlowDistance( vPos + vDelta.yx ) - GetFlowDistance( vPos - vDelta.yx );\n    return vec2( dx, dy );\n}\n\nvec3 GetFlowRate( const vec2 vPos )\n{\n    vec2 vBaseFlow = GetBaseFlow( vPos );\n\n    vec2 vFlow = vBaseFlow;\n    \n    float fFoam = 0.0;\n\n\tfloat fDepth = -GetTerrainHeightSimple( vec3(vPos.x, 0.0, vPos.y) );\n    float fDist = GetFlowDistance( vPos );\n    vec2 vGradient = GetGradient( vPos );\n    \n    vFlow += -vGradient * 40.0 \/ (1.0 + fDist * 1.5);\n    vFlow *= 1.0 \/ (1.0 + fDist * 0.5);\n\n#if 1\n    float fBehindObstacle = 0.5 - dot( normalize(vGradient), -normalize(vFlow)) * 0.5;\n    float fSlowDist = clamp( fDepth * 5.0, 0.0, 1.0);\n    fSlowDist = mix(fSlowDist * 0.9 + 0.1, 1.0, fBehindObstacle * 0.9);\n    \/\/vFlow += vGradient * 10.0 * (1.0 - fSlowDist);\n    fSlowDist = 0.5 + fSlowDist * 0.5;\n    vFlow *= fSlowDist;\n#endif    \n    \n    float fFoamScale1 =0.5;\n    float fFoamCutoff = 0.4;\n    float fFoamScale2 = 0.35;\n    \n    fFoam = abs(length( vFlow )) * fFoamScale1;\/\/ - length( vBaseFlow ));\n\tfFoam += clamp( fFoam - fFoamCutoff, 0.0, 1.0 );\n    \/\/fFoam = fFoam* fFoam;\n    fFoam = 1.0 - pow( fDist, fFoam * fFoamScale2 );\n    \/\/fFoam = fFoam \/ fDist;\n    return vec3( vFlow * 0.6, fFoam  );\n}\n\nvec4 SampleWaterNormal( vec2 vUV, vec2 vFlowOffset, float fMag, float fFoam )\n{    \n    vec2 vFilterWidth = max(abs(dFdx(vUV)), abs(dFdy(vUV)));\n  \tfloat fFilterWidth= max(vFilterWidth.x, vFilterWidth.y);\n    \n    float fScale = (1.0 \/ (1.0 + fFilterWidth * fFilterWidth * 2000.0));\n    float fGradientAscent = 0.25 + (fFoam * -1.5);\n    vec3 dxy = FBM_DXY(vUV * 20.0, vFlowOffset * 20.0, 0.75 + fFoam * 0.25, fGradientAscent);\n    fScale *= max(0.25, 1.0 - fFoam * 5.0); \/\/ flatten normal in foam\n    vec3 vBlended = mix( vec3(0.0, 1.0, 0.0), normalize( vec3(dxy.x, fMag, dxy.y) ), fScale );\n    return vec4( normalize( vBlended ), dxy.z * fScale );\n}\n\nfloat SampleWaterFoam( vec2 vUV, vec2 vFlowOffset, float fFoam )\n{\n    float f =  FBM_DXY(vUV * 30.0, vFlowOffset * 50.0, 0.8, -0.5 ).z;\n    float fAmount = 0.2;\n    f = max( 0.0, (f - fAmount) \/ fAmount );\n    return pow( 0.5, f );\n}\n    \n\nvec4 SampleFlowingNormal( const vec2 vUV, const vec2 vFlowRate, const float fFoam, const float time, out float fOutFoamTex )\n{\n    float fMag = 2.5 \/ (1.0 + dot( vFlowRate, vFlowRate ) * 5.0);\n    float t0 = fract( time );\n    float t1 = fract( time + 0.5 );\n    \n    float i0 = floor( time );\n    float i1 = floor( time + 0.5 );\n    \n    float o0 = t0 - 0.5;\n    float o1 = t1 - 0.5;\n    \n    vec2 vUV0 = vUV + Hash2(i0);\n    vec2 vUV1 = vUV + Hash2(i1);\n    \n    vec4 sample0 = SampleWaterNormal( vUV0, vFlowRate * o0, fMag, fFoam );\n    vec4 sample1 = SampleWaterNormal( vUV1, vFlowRate * o1, fMag, fFoam );\n\n    float weight = abs( t0 - 0.5 ) * 2.0;\n    \/\/weight = smoothstep( 0.0, 1.0, weight );\n\n    float foam0 = SampleWaterFoam( vUV0, vFlowRate * o0 * 0.25, fFoam );\n    float foam1 = SampleWaterFoam( vUV1, vFlowRate * o1 * 0.25, fFoam );\n    \n    vec4 result=  mix( sample0, sample1, weight );\n    result.xyz = normalize(result.xyz);\n\n    fOutFoamTex = mix( foam0, foam1, weight );\n\n    return result;\n}\n\nvec2 GetWindowCoord( const in vec2 vUV )\n{\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= iResolution.x \/ iResolution.y;\n\n\treturn vWindow;\t\n}\n\nvec3 GetCameraRayDir( const in vec2 vWindow, const in vec3 vCameraPos, const in vec3 vCameraTarget )\n{\n\tvec3 vForward = normalize(vCameraTarget - vCameraPos);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n\t\t\t\t\t\t\t  \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * 2.0);\n\n\treturn vDir;\n}\n\nvec3 ApplyVignetting( const in vec2 vUV, const in vec3 vInput )\n{\n\tvec2 vOffset = (vUV - 0.5) * sqrt(2.0);\n\t\n\tfloat fDist = dot(vOffset, vOffset);\n\t\n\tconst float kStrength = 0.8;\n\t\n\tfloat fShade = mix( 1.0, 1.0 - kStrength, fDist );\t\n\n\treturn vInput * fShade;\n}\n\nvec3 Tonemap( vec3 x )\n{\n    float a = 0.010;\n    float b = 0.132;\n    float c = 0.010;\n    float d = 0.163;\n    float e = 0.101;\n\n    return ( x * ( a * x + b ) ) \/ ( x * ( c * x + d ) + e );\n}\n\nstruct Intersection\n{\n    float m_dist;\n    float m_objId;\n    vec3 m_pos;\n};\n    \nvoid RaymarchScene( vec3 vRayOrigin, vec3 vRayDir, out Intersection intersection )\n{\n    float stepScale = 1.0;\n#ifdef ENABLE_CONE_STEPPING\n    vec2 vRayProfile = vec2( sqrt(dot(vRayDir.xz, vRayDir.xz) ), vRayDir.y );\n    vec2 vGradVec = normalize( vec2( 1.0, 2.0 ) ); \/\/ represents the biggest gradient in our heightfield\n    vec2 vGradPerp = vec2( vGradVec.y, -vGradVec.x );\n\n    float fRdotG = dot( vRayProfile, vGradPerp );\n    float fOdotG = dot( vec2(0.0, 1.0), vGradPerp );\n\n    stepScale = -fOdotG \/ fRdotG;\n\n    if ( stepScale < 0.0 )\n    {\n        intersection.m_objId = OBJ_ID_SKY;\n        intersection.m_dist = k_fFarClip;\n        return;\n    }\n#endif\n    \n    intersection.m_dist = 0.01;\n    intersection.m_objId = OBJ_ID_SKY;\n    \n    float fSceneDist = 0.0;\n    \n    float oldT = 0.01;\n    for( int iter = 0; iter < k_raymarchSteps; iter++ )\n    {\n        vec3 vPos = vRayOrigin + vRayDir * intersection.m_dist;\n      \n        \/\/ into sky - early out\n        if ( vRayDir.y > 0.0 )\n        {\n            if( vPos.y > 1.0 )\n            {\n                intersection.m_objId = OBJ_ID_SKY;\n                intersection.m_dist = k_fFarClip;\n                break;\n            }\n        }\n\n      \n        fSceneDist = GetSceneDistance( vPos );\n\n        oldT = intersection.m_dist;\n        intersection.m_dist += fSceneDist * stepScale;\n                \n        intersection.m_objId = OBJ_ID_GROUND;\n        if ( fSceneDist <= 0.01 )\n        {\n            break;\n        }\n\n        if ( intersection.m_dist > k_fFarClip )\n        {\n            intersection.m_objId = OBJ_ID_SKY;\n            intersection.m_dist = k_fFarClip;\n            break;\n        }        \n\n        \n    }    \n    \n    intersection.m_pos = vRayOrigin + vRayDir * intersection.m_dist;\n}\n\nvec3 GetSceneNormal(const in vec3 vPos)\n{\n    const float fDelta = 0.001;\n\n    vec3 vDir1 = vec3( 1.0, 0.0, -1.0);\n    vec3 vDir2 = vec3(-1.0, 0.0,  1.0);\n    vec3 vDir3 = vec3(-1.0, 0.0, -1.0);\n\t\n    vec3 vOffset1 = vDir1 * fDelta;\n    vec3 vOffset2 = vDir2 * fDelta;\n    vec3 vOffset3 = vDir3 * fDelta;\n\n    vec3 vPos1 = vPos + vOffset1;\n    vec3 vPos2 = vPos + vOffset2;\n    vec3 vPos3 = vPos + vOffset3;\n \n    float f1 = GetSceneDistance( vPos1 );\n    float f2 = GetSceneDistance( vPos2 );\n    float f3 = GetSceneDistance( vPos3 );\n    \n    vPos1.y -= f1;\n    vPos2.y -= f2;\n    vPos3.y -= f3;\n    \n    vec3 vNormal = cross( vPos1 - vPos2, vPos3 - vPos2 );\n    \n    return normalize( vNormal );\n}\n\n\nvoid TraceWater( vec3 vRayOrigin, vec3 vRayDir, out Intersection intersection )\n{\n \tintersection.m_dist = k_fFarClip;\n    \n    float t = -vRayOrigin.y \/ vRayDir.y;\n    if ( t > 0.0 )\n    {\n        intersection.m_dist = t;\n    }\n    \n    intersection.m_pos = vRayOrigin + vRayDir * intersection.m_dist;\n}\n\nstruct Surface\n{\n    vec3 m_pos;\n    vec3 m_normal;\n    vec3 m_albedo;\n    vec3 m_specR0;\n    float m_gloss;\n    float m_specScale;\n};\n    \n#ifdef ENABLE_NIMITZ_TRIANGLE_NOISE\n\/\/ https:\/\/www.shadertoy.com\/view\/4ts3z2\n\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y)), tri(p.z+tri(p.x)), tri(p.y+tri(p.x)));}\n\nfloat triNoise(in vec3 p)\n{\n    float z=1.4;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (float i=0.; i<=4.; i++ )\n\t{\n        vec3 dg = tri3(bp*2.);\n        p += dg;\n\n        bp *= 1.8;\n\t\tz *= 1.5;\n\t\tp *= 1.2;\n           \n        rz+= (tri(p.z+tri(p.x+tri(p.y))))\/z;\n        bp += 0.14;\n\t}\n\treturn rz;\n}    \n#endif\n    \nvoid GetSurfaceInfo( Intersection intersection, out Surface surface )\n{\n    surface.m_pos = intersection.m_pos;\n    surface.m_normal = GetSceneNormal(intersection.m_pos);\n\n#ifdef ENABLE_NIMITZ_TRIANGLE_NOISE\n    vec3 vNoisePos = surface.m_pos * vec3(0.4, 0.3, 1.0);\n\tsurface.m_normal = normalize(surface.m_normal +triNoise(vNoisePos));\n    float fNoise = triNoise(vNoisePos);\n    fNoise = pow( fNoise, 0.15);\n    surface.m_albedo = mix(vec3(.7,.8,.95), vec3(.1, .1,.05), fNoise );    \n#else\n    #if 0\n    surface.m_albedo = texture( iChannel0, intersection.m_pos.xz ).rgb;\n    surface.m_albedo = surface.m_albedo * surface.m_albedo;\n    #else\n    vec3 vWeights = surface.m_normal * surface.m_normal;\n    vec3 col = vec3(0.0);\n    vec3 _sample;\n    _sample = texture( iChannel0, intersection.m_pos.xz ).rgb;\n    col += _sample * _sample * vWeights.y;\n    _sample = texture( iChannel0, intersection.m_pos.xy ).rgb;\n    col += _sample * _sample * vWeights.z;\n    _sample = texture( iChannel0, intersection.m_pos.yz ).rgb;\n    col += _sample * _sample * vWeights.x;\n    col \/= vWeights.x + vWeights.y + vWeights.z;\n    surface.m_albedo = col;\n    #endif\n#endif    \n    \n    surface.m_specR0 = vec3(0.001);\n    surface.m_gloss = 0.0;\n    surface.m_specScale = 1.0;\n}\n   \nfloat GIV( float dotNV, float k)\n{\n\treturn 1.0 \/ ((dotNV + 0.0001) * (1.0 - k)+k);\n}\n\nfloat GetSunShadow( const vec3 vPos )\n{\n    vec3 vSunDir = GetSunDir();\n\n    Intersection shadowInt;\n    float k_fShadowDist = 2.0;\n    RaymarchScene( vPos + vSunDir * k_fShadowDist, -vSunDir, shadowInt );\n    \n    float fShadowFactor = 1.0;\n    if( shadowInt.m_dist < (k_fShadowDist - 0.1) )\n    {\n        fShadowFactor = 0.0;\n    }\n\n    return fShadowFactor;\n}\n\nvoid AddSunLight( Surface surf, const vec3 vViewDir, const float fShadowFactor, inout vec3 vDiffuse, inout vec3 vSpecular )\n{\n    vec3 vSunDir = GetSunDir();\n\n\tvec3 vH = normalize( vViewDir + vSunDir );\n\tfloat fNdotL = clamp(dot(GetSunDir(), surf.m_normal), 0.0, 1.0);\n\tfloat fNdotV = clamp(dot(vViewDir, surf.m_normal), 0.0, 1.0);\n\tfloat fNdotH = clamp(dot(surf.m_normal, vH), 0.0, 1.0);\n    \n    float diffuseIntensity = fNdotL;\n    \n    vDiffuse += g_sunColour * diffuseIntensity * fShadowFactor;\n\t\/\/vDiffuse = fShadowFactor * vec3(100.0);\n\t\n\tfloat alpha = 1.0 - surf.m_gloss;\n\t\/\/ D\n\n\tfloat alphaSqr = alpha * alpha;\n\tfloat pi = 3.14159;\n\tfloat denom = fNdotH * fNdotH * (alphaSqr - 1.0) + 1.0;\n\tfloat d = alphaSqr \/ (pi * denom * denom);\n\n\tfloat k = alpha \/ 2.0;\n\tfloat vis = GIV(fNdotL, k) * GIV(fNdotV, k);\n\n\tfloat fSpecularIntensity = d * vis * fNdotL;\n\tvSpecular += g_sunColour * fSpecularIntensity * fShadowFactor;\n}\n    \nvoid AddSkyLight( Surface surf, inout vec3 vDiffuse, inout vec3 vSpecular )\n{\n    float skyIntensity = max( 0.0, surf.m_normal.y * 0.3 + 0.7 );\n    vDiffuse += g_skyColour * skyIntensity;       \n}\n\nvec3 GetFresnel( vec3 vView, vec3 vNormal, vec3 vR0, float fGloss )\n{\n    float NdotV = max( 0.0, dot( vView, vNormal ) );\n\n    return vR0 + (vec3(1.0) - vR0) * pow( 1.0 - NdotV, 5.0 ) * pow( fGloss, 20.0 );\n}\n\nvec3 GetWaterExtinction( float dist )\n{\n    float fOpticalDepth = dist * 6.0;\n\n    vec3 vExtinctCol = 1.0 - vec3(0.5, 0.4, 0.1);           \n    vec3 vExtinction = exp2( -fOpticalDepth * vExtinctCol );\n    \n    return vExtinction;\n}\n\nvec3 GetSkyColour( vec3 vRayDir )\n{    \n\tvec3 vSkyColour = mix( k_bgSkyColourDown, k_bgSkyColourUp, clamp( vRayDir.y, 0.0, 1.0 ) );\n    float fSunDotV = dot(GetSunDir(), vRayDir);    \n    float fDirDot = clamp(fSunDotV * 0.5 + 0.5, 0.0, 1.0);\n    vSkyColour += g_sunColour * (1.0 - exp2(fDirDot * -0.5)) * 2.0;\n    \n    return vSkyColour;\n}\n\nvec3 GetEnvColour( vec3 vRayDir, float fGloss )\n{\n\treturn mix( k_envFloorColor, k_bgSkyColourUp, clamp( vRayDir.y * (1.0 - fGloss * 0.5) * 0.5 + 0.5, 0.0, 1.0 ) );\n}\n\n\nvec3 GetRayColour( const in vec3 vRayOrigin, const in vec3 vRayDir, out Intersection intersection )\n{\n    RaymarchScene( vRayOrigin, vRayDir, intersection );        \n\n    if ( intersection.m_objId == OBJ_ID_SKY )\n    {\n        return GetSkyColour( vRayDir );\n    }\n    \n    Surface surface;\n    GetSurfaceInfo( intersection, surface );\n\n    vec3 vIgnore = vec3(0.0);\n    vec3 vResult = vec3(0.0);\n    float fSunShadow = 1.0;\n    AddSunLight( surface, -vRayDir, fSunShadow, vResult, vIgnore );\n    AddSkyLight( surface, vResult, vIgnore);\n    return vResult * surface.m_albedo;\n}\n\nvec3 GetRayColour( const in vec3 vRayOrigin, const in vec3 vRayDir )\n{\n\tIntersection intersection;\n    return GetRayColour( vRayOrigin, vRayDir, intersection );\n}\n\nvec3 GetSceneColour( const in vec3 vRayOrigin,  const in vec3 vRayDir )\n{\n\tIntersection primaryInt;\n    RaymarchScene( vRayOrigin, vRayDir, primaryInt );\n\n     float fFogDistance = 0.0;\n    vec3 vResult = vec3( 0.0 );\n    \n    float fSunDotV = dot(GetSunDir(), vRayDir);    \n\n    if ( primaryInt.m_objId == OBJ_ID_SKY )\n    {\n        vResult = GetSkyColour( vRayDir );\n        fFogDistance = k_fFarClip;\n    }\n    else\n    {\n        Intersection waterInt;\n        TraceWater( vRayOrigin, vRayDir, waterInt );\n\n        vec3 vReflectRayOrigin;\n        vec3 vSpecNormal;\n        vec3 vTransmitLight;\n\n        Surface specSurface;\n        vec3 vSpecularLight = vec3(0.0);\n\n    #ifdef ENABLE_WATER\n        vec3 vFlowRateAndFoam = GetFlowRate( waterInt.m_pos.xz );\n        vec2 vFlowRate = vFlowRateAndFoam.xy;\n        #ifdef ENABLE_FOAM\n        float fFoam = vFlowRateAndFoam.z;\n        float fFoamScale = 1.5;\n        float fFoamOffset = 0.2;\n        fFoam = clamp( (fFoam - fFoamOffset) * fFoamScale, 0.0, 1.0 );\n        fFoam = fFoam * fFoam * 0.5;\n        #else\n        float fFoam = 0.0;\n        #endif            \n\n        float fWaterFoamTex = 1.0;\n        vec4 vWaterNormalAndHeight = SampleFlowingNormal( waterInt.m_pos.xz, vFlowRate, fFoam, g_fTime, fWaterFoamTex );\n        \n        if( vRayDir.y < -0.01 )\n        {\n            \/\/ lie about the water intersection depth\n            waterInt.m_dist -= (0.04 * (1.0 - vWaterNormalAndHeight.w) \/ vRayDir.y);\n        }\n        \n        if( waterInt.m_dist < primaryInt.m_dist )\n        {\n            fFogDistance = waterInt.m_dist;\n            vec3 vWaterNormal = vWaterNormalAndHeight.xyz;\n\n            vReflectRayOrigin = waterInt.m_pos;\n            vSpecNormal = vWaterNormal;\n\n            vec3 vRefractRayOrigin = waterInt.m_pos;\n            vec3 vRefractRayDir = refract( vRayDir, vWaterNormal, 1.0 \/ 1.3333 );\n\n            Intersection refractInt;\n            vec3 vRefractLight = GetRayColour( vRefractRayOrigin, vRefractRayDir, refractInt ); \/\/ note : dont need sky\n\n            float fEdgeAlpha = clamp( (1.0 + vWaterNormalAndHeight.w * 0.25) - refractInt.m_dist * 10.0, 0.0, 1.0 );\n            fFoam *= 1.0 - fEdgeAlpha;\n            \n            \/\/ add extra extinction for the light travelling to the point underwater\n            vec3 vExtinction = GetWaterExtinction( refractInt.m_dist + abs( refractInt.m_pos.y ) );\n\n            specSurface.m_pos = waterInt.m_pos;\n            specSurface.m_normal = normalize( vWaterNormal + GetSunDir() * fFoam ); \/\/ would rather have SSS for foam\n            specSurface.m_albedo = vec3(1.0);\n            specSurface.m_specR0 = vec3( 0.01, 0.01, 0.01 );\n\n            vec2 vFilterWidth = max(abs(dFdx(waterInt.m_pos.xz)), abs(dFdy(waterInt.m_pos.xz)));\n  \t\t\tfloat fFilterWidth= max(vFilterWidth.x, vFilterWidth.y);\n            float fGlossFactor = exp2( -fFilterWidth * 0.3 );\n            specSurface.m_gloss = 0.99 * fGlossFactor;            \n            specSurface.m_specScale = 1.0;\n            \n            vec3 vSurfaceDiffuse = vec3(0.0);\n\n            float fSunShadow = 1.0;\n        #ifdef ENABLE_WATER_RECEIVE_SHADOW\n            fSunShadow = GetSunShadow( waterInt.m_pos );\n        #endif\n            AddSunLight( specSurface, -vRayDir, fSunShadow, vSurfaceDiffuse, vSpecularLight);\n            AddSkyLight( specSurface, vSurfaceDiffuse, vSpecularLight);\n\n            vec3 vInscatter = vSurfaceDiffuse * (1.0 - exp( -refractInt.m_dist * 0.1 )) * (1.0 + fSunDotV);\n            vTransmitLight = vRefractLight.rgb;\n            vTransmitLight += vInscatter;\n            vTransmitLight *= vExtinction;   \n\n\n    #ifdef ENABLE_FOAM\n            float fFoamBlend = 1.0 - pow( fWaterFoamTex, fFoam * 5.0);\/\/ * (1.0 - fWaterFoamTex));\n            vTransmitLight = mix(vTransmitLight, vSurfaceDiffuse * 0.8, fFoamBlend );\n            specSurface.m_specScale = clamp(1.0 - fFoamBlend * 4.0, 0.0, 1.0);\n    #endif\n        }\n        else\n    #endif \/\/ #ifdef ENABLE_WATER\n        {\n            fFogDistance = primaryInt.m_dist;\n\n            Surface primarySurface;\n            GetSurfaceInfo( primaryInt, primarySurface );\n\n            vSpecNormal = primarySurface.m_normal;\n            vReflectRayOrigin = primaryInt.m_pos;\n            \n            float fWetness = 1.0 - clamp( (vReflectRayOrigin.y + 0.025) * 5.0, 0.0, 1.0);\n            primarySurface.m_gloss = mix( primarySurface.m_albedo.r, 1.0, fWetness );\n            primarySurface.m_albedo = mix( primarySurface.m_albedo, primarySurface.m_albedo * 0.8, fWetness );\n\n            vTransmitLight = vec3(0.0);\n            float fSunShadow = 1.0;\n       #ifdef ENABLE_LANDSCAPE_RECEIVE_SHADOW\n            fSunShadow = GetSunShadow( primaryInt.m_pos );\n       #endif\n            AddSunLight( primarySurface, -vRayDir, fSunShadow, vTransmitLight, vSpecularLight);\n            AddSkyLight( primarySurface, vTransmitLight, vSpecularLight);\n            vTransmitLight *= primarySurface.m_albedo;\n            specSurface = primarySurface;\n        }\n\n        vec3 vReflectRayDir = reflect( vRayDir, vSpecNormal );\n        vec3 vReflectLight = GetRayColour( vReflectRayOrigin, vReflectRayDir );\n\n        vReflectLight = mix( GetEnvColour(vReflectRayDir, specSurface.m_gloss), vReflectLight, pow( specSurface.m_gloss, 40.0) );\n        \n        vec3 vFresnel = GetFresnel( -vRayDir, vSpecNormal, specSurface.m_specR0, specSurface.m_gloss );\n\n        vSpecularLight += vReflectLight;\n        vResult = mix(vTransmitLight, vSpecularLight, vFresnel * specSurface.m_specScale );\n    }\n    \n    \n    if ( fFogDistance >= k_fFarClip )\n    {\n        fFogDistance = 100.0;\n        vResult = smoothstep( 0.9995, 0.9999, fSunDotV ) * g_sunColour * 200.0;\n    }    \n    \n    vec3 vFogColour = GetSkyColour(vRayDir);\n    \n    vec3 vFogExtCol = exp2( k_vFogExt * -fFogDistance );\n    vec3 vFogInCol = exp2( k_vFogIn * -fFogDistance );\n    vResult = vResult*(vFogExtCol) + vFogColour*(1.0-vFogInCol);\n    \n    return vResult;\n}\n\n\/\/ Code from https:\/\/www.shadertoy.com\/view\/ltlSWf \nvoid BlockRender(in vec2 fragCoord)\n{\n    const float blockRate = 15.0;\n    const float blockSize = 64.0;\n    float frame = floor(iTime * blockRate);\n    vec2 blockRes = floor(iResolution.xy \/ blockSize) + vec2(1.0);\n    float blockX = fract(frame \/ blockRes.x) * blockRes.x;\n    float blockY = fract(floor(frame \/ blockRes.x) \/ blockRes.y) * blockRes.y;\n    \/\/ Don't draw anything outside the current block.\n    if ((fragCoord.x - blockX * blockSize >= blockSize) ||\n    \t(fragCoord.x - (blockX - 1.0) * blockSize < blockSize) ||\n    \t(fragCoord.y - blockY * blockSize >= blockSize) ||\n    \t(fragCoord.y - (blockY - 1.0) * blockSize < blockSize))\n    {\n        discard;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    g_fTime = iTime;\n\n#ifdef ENABLE_SCREENSHOT_MODE\n    BlockRender( fragCoord.xy );\n    float fBaseTime = k_screenshotTime;\n#else\n    float fBaseTime = iTime;\n#endif\n    g_fTime = fBaseTime;\n    \n    float fCameraTime = g_fTime;\n    \n\t\/\/ Static camera locations\n    \/\/fCameraTime = 146.0; \/\/ some rocks\n    \n    vec2 vUV = fragCoord.xy \/ iResolution.xy;\n\n\tvec3 vCameraTarget = vec3(0.0, -0.5, 0.0);\n\n    vCameraTarget.x -= fCameraTime * 0.5;\n    \n    vec3 vCameraPos = vCameraTarget + vec3(0.0, 0.0, 0.0);\n    \n    float fHeading = fCameraTime * 0.1;\n    float fDist = 1.5 - cos(fCameraTime * 0.1 + 2.0) * 0.8;\n    \n    if( iMouse.z > 0.0 )\n    {\n        fHeading = iMouse.x * 10.0 \/ iResolution.x;\n        fDist = 5.0 - iMouse.y * 5.0 \/ iResolution.y;\n    }\n    \n    vCameraPos.y += 1.0 + fDist * fDist * 0.01;\n        \n    vCameraPos.x += sin( fHeading ) * fDist;\n    vCameraPos.z += cos( fHeading ) * fDist;\n    \n    vCameraTarget.z += GetRiverMeander( vCameraTarget.x );\n    vCameraPos.z += GetRiverMeander( vCameraPos.x );\n\n    vCameraPos.y = max( vCameraPos.y, GetTerrainHeightSimple( vCameraPos ) + 0.2 );\n    \n    vec3 vRayOrigin = vCameraPos;\n\tvec3 vRayDir = GetCameraRayDir( GetWindowCoord(vUV), vCameraPos, vCameraTarget );\n\t\n#ifndef ENABLE_SUPERSAMPLE_MODE\n\tvec3 vResult = GetSceneColour(vRayOrigin, vRayDir);\n#else\n\tvec3 vResult = vec3(0.0);\n    float fTot = 0.0;\n    for(int i=0; i<k_superSampleCount; i++)\n    {\n        g_fTime = fBaseTime + (fTot \/ 10.0) \/ 30.0;\n        vec3 vCurrRayDir = vRayDir;\n        vec3 vRandom = vec3( SmoothNoise( fragCoord.xy + fTot ), \n                        SmoothNoise( fragCoord.yx + fTot + 42.0 ),\n                        SmoothNoise( fragCoord.xx + fragCoord.yy + fTot + 42.0 ) ) * 2.0 - 1.0;\n        vRandom = normalize( vRandom );\n        vCurrRayDir += vRandom * 0.001;\n        vCurrRayDir = normalize(vCurrRayDir);\n    \tvResult += GetSceneColour(vRayOrigin, vCurrRayDir);\n        fTot += 1.0;\n    }\n    vResult \/= fTot;\n#endif    \n    \n\tvResult = ApplyVignetting( vUV, vResult );\t\n\t\n\tvec3 vFinal = Tonemap(vResult * 3.0);\n\t\n    vFinal = vFinal * 1.1 - 0.1;\n    \n\tfragColor = vec4(vFinal, 1.0);\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    g_fTime = iTime;\n    \n    fragRayOri = fragRayOri.zyx;\n    fragRayDir = fragRayDir.zyx;\n    \n    fragRayOri.z *= -1.0;\n    fragRayDir.z *= -1.0;\n    \n    fragRayOri *= 0.1;\n    \n    fragRayOri.y += 0.2;\n    \n    fragRayOri.x -= g_fTime * 0.1;\n    fragRayOri.z += GetRiverMeander( fragRayOri.x );\n    \n    \n    vec3 vResult = GetSceneColour(fragRayOri, fragRayDir);\n    \n\tvec3 vFinal = Tonemap(vResult * 3.0);\n\t\n    vFinal = vFinal * 1.1 - 0.1;\n    \n\tfragColor = vec4(vFinal, 1.0);    \n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"lsXGzH","date":"1362694021","viewed":35085,"name":"Spout","username":"P_Malin","description":"An experiment with raymarching and refraction.\nClick window and move mouse to rotate. ","likes":301,"published":3,"flags":1,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"\/media\/a\/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"\/media\/ap\/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Spout - @P_Malin\n\n\/\/#define LOW_QUALITY\n\n#ifdef LOW_QUALITY\n    #define kRaymarchMaxIter 16\n#else\n    #define kRaymarchMaxIter 32\n    \n    #define ENABLE_AMBIENT_OCCLUSION\n    #define DOUBLE_SIDED_TRANSPARENCY\n#endif\n\n#define ENABLE_SPECULAR\n#define ENABLE_REFLECTIONS\n#define ENABLE_TRANSPARENCY\n#define ENABLE_SHADOWS\n#define ENABLE_FOG\n\n#define ENABLE_DIRECTIONAL_LIGHT\n#define ENABLE_DIRECTIONAL_LIGHT_FLARE\n\n\/\/#define ENABLE_POINT_LIGHT\n\/\/#define ENABLE_POINT_LIGHT_FLARE\n\nconst float kPipeRadius = 0.4;\nconst float kPipeThickness = 0.15;\nconst float kPipeHeight = 2.0;\n\/\/float kPipeHeight = 2.0 + sin(iTime);\n\nconst float kWaterNoiseScale = 0.025;\n\nconst float kWaterVelocity = 1.0;\n\nconst float kWaterAccel = -1.0;\n\nconst float kWaterAnimSpeed = 80.0;\nconst float kTrenchWaterAnimSpeed = 20.0;\n\n\n\nfloat kRipplePos = sqrt(abs(2.0 * kPipeHeight \/ kWaterAccel)) * kWaterVelocity;\n\nconst float kPI = 3.141592654;\nconst float kTwoPI = kPI * 2.0;\n\nconst float kNoTransparency = -1.0;\nconst float kTransparency = 1.0;\nconst float kInverseTransparency = 0.0;\n\nstruct C_Ray\n{\n    vec3 vOrigin;\n    vec3 vDir;\n    float fStartDistance;\n    float fLength;\n};\n\nstruct C_HitInfo\n{\n    vec3 vPos;\n    float fDistance;\n    vec3 vObjectId;\n};\n    \nstruct C_Surface\n{\n    vec3 vNormal;\n    vec3 cReflection;\n    vec3 cTransmission;    \n};\n\nstruct C_Material\n{\n    vec3 cAlbedo;\n    float fR0;\n    float fSmoothness;\n    vec2 vParam;\n\n    float fTransparency;\n    float fRefractiveIndex;\n};\n\nstruct C_Shading\n{\n    vec3 cDiffuse;\n    vec3 cSpecular;\n};\n\nstruct C_PointLight\n{\n    vec3 vPos;\n    vec3 cColour;\n};\n\nstruct C_DirectionalLight\n{\n    vec3 vDir;\n    vec3 cColour;\n};\n\nvec3 RotateX( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n    \n    vec3 vResult = vec3( vPos.x, c * vPos.y + s * vPos.z, -s * vPos.y + c * vPos.z);\n    \n    return vResult;\n}\n\nvec3 RotateY( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n    \n    vec3 vResult = vec3( c * vPos.x + s * vPos.z, vPos.y, -s * vPos.x + c * vPos.z);\n    \n    return vResult;\n}\n\nvec3 RotateZ( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n    \n    vec3 vResult = vec3( c * vPos.x + s * vPos.y, -s * vPos.x + c * vPos.y, vPos.z);\n    \n    return vResult;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Distance Field CSG\n\/\/ These carry with them the material parameters in yzw\n\nvec4 DistCombineUnion( const in vec4 v1, const in vec4 v2 )\n{\n    \/\/if(v1.x < v2.x) return v1; else return v2;\n    return mix(v1, v2, step(v2.x, v1.x));\n}\n\nvec4 DistCombineUnionTransparent( const in vec4 v1, const in vec4 v2, const in float fTransparentScale )\n{    \n\t\/\/if( fCondition < 0.0 )\n\t\/\/            return v1;\n\t\n\t\/\/ Negate the distance to the transparency object if transparent scale is 0.0     \n\t\/\/ This allows us to ratrace \"out\" of transparency\n\t\n\tvec4 vScaled = vec4(v2.x * (fTransparentScale * 2.0 - 1.0), v2.yzw);\n                \n\t\/\/ The condition allows us to ignore transparency for secondary rays\n    return mix(v1, vScaled, step(vScaled.x, v1.x) * step(0.0, fTransparentScale));\n}\n\nvec4 DistCombineIntersect( const in vec4 v1, const in vec4 v2 )\n{\n    return mix(v2, v1, step(v2.x,v1.x));\n}\n\nvec4 DistCombineSubtract( const in vec4 v1, const in vec4 v2 )\n{\n    return DistCombineIntersect(v1, vec4(-v2.x, v2.yzw));\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Scene Description \n\nconst float kMaterialIdWall = 1.0;\nconst float kMaterialIdPipe = 2.0;\nconst float kMaterialIdWater = 3.0;\n\nfloat Noise(vec2 p)\n{\n    vec2 s = sin(p * 0.6345) + sin(p * 1.62423);\n    return dot(s, vec2(0.125)) + 0.5;\n}\n\n\/\/ result is x=scene distance y=material or object id; zw are material specific parameters (maybe uv co-ordinates)\nvec4 GetDistanceScene( const in vec3 vPos, const in float fTransparentScale )\n{          \n    vec4 vResult = vec4(10000.0, -1.0, 0.0, 0.0);\n            \n\tfloat fDistFloor = vPos.y;\n\tfloat fDistBrick = fDistFloor;\n\t\n\tfloat fDistTrench = length(vPos.yz + vec2(-0.4, 0.0)) - 1.0;\n\tfDistBrick = max(fDistBrick, -(fDistTrench));\n\t\n\tfloat fDistWall = vPos.x + 1.0;\n\tfDistBrick = min(fDistBrick, fDistWall);\n\t\n    vec4 vDistFloor = vec4(fDistBrick, kMaterialIdWall, vPos.xz + vec2(vPos.y, 0.0));\n    vResult = DistCombineUnion(vResult, vDistFloor);    \n\n    vec3 vWaterDomain = vPos - vec3(0.0, kPipeHeight, 0.0);\n\n    float t= max(vWaterDomain.x \/ kWaterVelocity, 0.0);\n\t\n\t\/\/ Equations of motion\n\tfloat s = 0.5 * kWaterAccel * t * t;\n\tfloat v = -kWaterAccel * t;\n\t\n\tvWaterDomain.y -= s;    \n                \n    float fDistWater = (length(vWaterDomain.yz) - kPipeRadius);\n                \n    float fDistPipe = max(fDistWater - kPipeThickness, vWaterDomain.x);\n    fDistPipe = max(fDistPipe, -fDistWater); \/\/ subtract the water from the pipe to make the hole\n    vec4 vDistPipe = vec4(fDistPipe, kMaterialIdPipe, vPos.xy);        \n        \n    vResult = DistCombineUnion(vResult, vDistPipe);    \n\t\n\t\/\/ compensate for domain distortion of water, otherwise ray sometimes misses\n\tfDistWater \/= (1.0 + v * 0.5);\n\t\n    vec2 vNoiseDomain = vPos.xz;\n                \n\t\/\/ modify noise for water in trench\n\tfloat fInTrench = step(vPos.y, (-0.1 + 0.05));        \n\tvec2 vRippleCentre1 = vPos.xz - vec2(kRipplePos, 0.0);\n\tvNoiseDomain.x = mix(vNoiseDomain.x, length(vRippleCentre1), fInTrench);\n\tfloat fNoiseScale = mix(t * t, 1.0 \/ (1.0 + vNoiseDomain.x), fInTrench) * kWaterNoiseScale;\n\tfloat fWaterSpeed = mix(kWaterAnimSpeed * kWaterVelocity, kTrenchWaterAnimSpeed, fInTrench);\n\t\n\tvNoiseDomain *= 30.0; \n\tvNoiseDomain.x += -iTime * fWaterSpeed;\n\t\n\tfloat fTrenchWaterDist = vPos.y + 0.1;\n\tfDistWater = min(fDistWater, fTrenchWaterDist);\n\t\n\tfDistWater += Noise(vNoiseDomain) * fNoiseScale;\n\t\n\tvec4 vDistWater = vec4(fDistWater, kMaterialIdWater, vPos.xy);        \n\tvResult = DistCombineUnionTransparent(vResult, vDistWater, fTransparentScale);\n              \n    return vResult;\n}\n\nfloat GetRayFirstStep( const in C_Ray ray )\n{\n    return ray.fStartDistance;  \n}\n\nC_Material GetObjectMaterial( const in C_HitInfo hitInfo )\n{\n    C_Material mat;\n              \n    if(hitInfo.vObjectId.x == kMaterialIdWall)\n    {\n        \/\/ floor\n        mat.fR0 = 0.02;\n                                \n\t\t\/\/ Textureless version\n\t\t\/\/vec2 vTile = step(vec2(0.15), fract(hitInfo.vObjectId.yz));\n\t\t\/\/float fTile = vTile.x * vTile.y;\n        \/\/mat.cAlbedo = vec3(1.0) * (fTile * 0.8 + 0.2);\n        \/\/mat.fSmoothness = 1.0;\n        \n        vec3 cTexture = texture(iChannel0, hitInfo.vObjectId.yz * 0.25).rgb;\n        mat.cAlbedo = cTexture * cTexture;\n        mat.fSmoothness = mat.cAlbedo.r;\n        mat.fTransparency = 0.0;\n    }\n    else\n    if(hitInfo.vObjectId.x == kMaterialIdPipe)\n    {\n        \/\/ pipe\n        mat.fR0 = 0.8;\n        mat.fSmoothness = 1.0;\n        mat.cAlbedo = vec3(0.5);\n        mat.fTransparency = 0.0;\n    }\n    else\n    {\n        \/\/ water\n        mat.fR0 = 0.01;\n        mat.fSmoothness = 1.0;\n        mat.fTransparency = 1.0;\n        mat.fRefractiveIndex = 1.0 \/ 1.3330;\n        const float fExtinctionScale = 2.0;\n\t\tconst vec3 vExtinction = vec3(0.3, 0.7, 0.9);\n        mat.cAlbedo = (vec3(1.0) - vExtinction) * fExtinctionScale; \/\/ becomes extinction for transparency\n    }\n    \n    return mat;\n}\n\nvec3 GetSkyGradient( const in vec3 vDir )\n{\n    const vec3 cColourTop = vec3(0.7, 0.8, 1.0);\n    const vec3 cColourHorizon = cColourTop * 0.5;\n\n    float fBlend = clamp(vDir.y, 0.0, 1.0);\n    return mix(cColourHorizon, cColourTop, fBlend);\n}\n\nC_PointLight GetPointLight()\n{\n    C_PointLight result;\n\n    result.vPos = vec3(0.5, 1.0, -2.0);\n    result.cColour = vec3(32.0, 6.0, 1.0) * 10.0;\n\n    return result;\n}\n\nC_DirectionalLight GetDirectionalLight()\n{\n    C_DirectionalLight result;\n\n    result.vDir = normalize(vec3(-0.2, -0.3, 0.5));\n    result.cColour = vec3(8.0, 7.5, 7.0);\n\n    return result;\n}\n\nvec3 GetAmbientLight(const in vec3 vNormal)\n{\n    return GetSkyGradient(vNormal);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Raymarching \n\nvec3 GetSceneNormal( const in vec3 vPos, const in float fTransparentScale )\n{\n    \/\/ tetrahedron normal\n    const float fDelta = 0.025;\n\n    vec3 vOffset1 = vec3( fDelta, -fDelta, -fDelta);\n    vec3 vOffset2 = vec3(-fDelta, -fDelta,  fDelta);\n    vec3 vOffset3 = vec3(-fDelta,  fDelta, -fDelta);\n    vec3 vOffset4 = vec3( fDelta,  fDelta,  fDelta);\n\n    float f1 = GetDistanceScene( vPos + vOffset1, fTransparentScale ).x;\n    float f2 = GetDistanceScene( vPos + vOffset2, fTransparentScale ).x;\n    float f3 = GetDistanceScene( vPos + vOffset3, fTransparentScale ).x;\n    float f4 = GetDistanceScene( vPos + vOffset4, fTransparentScale ).x;\n\n    vec3 vNormal = vOffset1 * f1 + vOffset2 * f2 + vOffset3 * f3 + vOffset4 * f4;\n\n    return normalize( vNormal );\n}\n\n#define kRaymarchEpsilon 0.01\n\/\/ This is an excellent resource on ray marching -> https:\/\/iquilezles.org\/articles\/distfunctions\nvoid Raymarch( const in C_Ray ray, out C_HitInfo result, const int maxIter, const float fTransparentScale )\n{        \n    result.fDistance = GetRayFirstStep( ray );\n    result.vObjectId.x = 0.0;\n        \n    for(int i=0;i<=kRaymarchMaxIter;i++)              \n    {\n        result.vPos = ray.vOrigin + ray.vDir * result.fDistance;\n        vec4 vSceneDist = GetDistanceScene( result.vPos, fTransparentScale );\n        result.vObjectId = vSceneDist.yzw;\n        \n        \/\/ abs allows backward stepping - should only be necessary for non uniform distance functions\n        if((abs(vSceneDist.x) <= kRaymarchEpsilon) || (result.fDistance >= ray.fLength) || (i > maxIter))\n        {\n            break;\n        }                        \n\n        result.fDistance = result.fDistance + vSceneDist.x; \n    }\n\n\n    if(result.fDistance >= ray.fLength)\n    {\n        result.fDistance = 1000.0;\n        result.vPos = ray.vOrigin + ray.vDir * result.fDistance;\n        result.vObjectId.x = 0.0;\n    }\n}\n\nfloat GetShadow( const in vec3 vPos, const in vec3 vNormal, const in vec3 vLightDir, const in float fLightDistance )\n{\n    #ifdef ENABLE_SHADOWS\n\t\tC_Ray shadowRay;\n\t\tshadowRay.vDir = vLightDir;\n\t\tshadowRay.vOrigin = vPos;\n\t\tconst float fShadowBias = 0.05;\n\t\tshadowRay.fStartDistance = fShadowBias \/ abs(dot(vLightDir, vNormal));\n\t\tshadowRay.fLength = fLightDistance - shadowRay.fStartDistance;\n\t\n\t\tC_HitInfo shadowIntersect;\n\t\tRaymarch(shadowRay, shadowIntersect, 32, kNoTransparency);\n\t\t\n\t\tfloat fShadow = step(0.0, shadowIntersect.fDistance) * step(fLightDistance, shadowIntersect.fDistance );\n\t\t\n\t\treturn fShadow;          \n    #else\n    \treturn 1.0;\n    #endif\n}\n\n\/\/ use distance field to evaluate ambient occlusion\nfloat GetAmbientOcclusion(const in C_HitInfo intersection, const in C_Surface surface)\n{\n    #ifdef ENABLE_AMBIENT_OCCLUSION    \n\t\tvec3 vPos = intersection.vPos;\n\t\tvec3 vNormal = surface.vNormal;\n\t\n\t\tfloat fAmbientOcclusion = 1.0;\n\t\n\t\tfloat fDist = 0.0;\n\t\tfor(int i=0; i<=5; i++)\n\t\t{\n\t\t\tfDist += 0.1;\n\t\n\t\t\tvec4 vSceneDist = GetDistanceScene(vPos + vNormal * fDist, kNoTransparency);\n\t\n\t\t\tfAmbientOcclusion *= 1.0 - max(0.0, (fDist - vSceneDist.x) * 0.2 \/ fDist );                                  \n\t\t}\n\t\n\t\treturn fAmbientOcclusion;\n    #else\n\t    return 1.0;\n    #endif    \n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Lighting and Shading\n\n#define kFogDensity 0.05\n\nvoid ApplyAtmosphere(inout vec3 col, const in C_Ray ray, const in C_HitInfo hitInfo)\n{\n    #ifdef ENABLE_FOG\n    \/\/ fog\n    float fFogAmount = exp(hitInfo.fDistance * -kFogDensity);\n    vec3 cFog = GetSkyGradient(ray.vDir);\n\n    #ifdef ENABLE_DIRECTIONAL_LIGHT_FLARE\n    C_DirectionalLight directionalLight = GetDirectionalLight();\n    float fDirDot = clamp(dot(-directionalLight.vDir, ray.vDir), 0.0, 1.0);\n    cFog += directionalLight.cColour * pow(fDirDot, 10.0);\n    #endif \n\n    col = mix(cFog, col, fFogAmount);\n    #endif\n\n    \/\/ glare from light (a bit hacky - use length of closest approach from ray to light)\n    #ifdef ENABLE_POINT_LIGHT_FLARE\n    C_PointLight pointLight = GetPointLight();\n\n    vec3 vToLight = pointLight.vPos - ray.vOrigin;\n    float fPointDot = dot(vToLight, ray.vDir);\n    fPointDot = clamp(fPointDot, 0.0, hitInfo.fDistance);\n\n    vec3 vClosestPoint = ray.vOrigin + ray.vDir * fPointDot;\n    float fDist = length(vClosestPoint - pointLight.vPos);\n    col += pointLight.cColour * 0.01\/ (fDist * fDist);\n    #endif    \n}\n\n\/\/ http:\/\/en.wikipedia.org\/wiki\/Schlick's_approximation\nfloat Schlick( const in vec3 vHalf, const in vec3 vView, const in float fR0, const in float fSmoothFactor)\n{\n    float fDot = dot(vHalf, -vView);\n    fDot = clamp((1.0 - fDot), 0.0, 1.0);\n    float fDotPow = pow(fDot, 5.0);\n    return fR0 + (1.0 - fR0) * fDotPow * fSmoothFactor;\n}\n\nvec3 ApplyFresnel(const in vec3 vDiffuse, const in vec3 vSpecular, const in vec3 vNormal, const in vec3 vView, const in C_Material material)\n{\n\tvec3 vReflect = reflect(vView, vNormal);\n\tvec3 vHalf = normalize(vReflect + -vView);\n    float fFresnel = Schlick(vHalf, vView, material.fR0, material.fSmoothness * 0.9 + 0.1);\n    return mix(vDiffuse, vSpecular, fFresnel);    \n}\n\nfloat GetBlinnPhongIntensity(const in vec3 vIncidentDir, const in vec3 vLightDir, const in vec3 vNormal, const in float fSmoothness)\n{          \n    vec3 vHalf = normalize(vLightDir - vIncidentDir);\n    float fNdotH = max(0.0, dot(vHalf, vNormal));\n\n    float fSpecPower = exp2(4.0 + 6.0 * fSmoothness);\n    float fSpecIntensity = (fSpecPower + 2.0) * 0.125;\n\n    return pow(fNdotH, fSpecPower) * fSpecIntensity;\n}\n\nC_Shading ApplyPointLight( const in C_PointLight light, const in vec3 vSurfacePos, const in vec3 vIncidentDir, const in vec3 vNormal, const in C_Material material )\n{\n    C_Shading shading;\n    \n    vec3 vToLight = light.vPos - vSurfacePos;\n    vec3 vLightDir = normalize(vToLight);\n    float fLightDistance = length(vToLight);\n    \n    float fAttenuation = 1.0 \/ (fLightDistance * fLightDistance);\n    \n    float fShadowFactor = GetShadow( vSurfacePos, vNormal, vLightDir, fLightDistance );\n    vec3 vIncidentLight = light.cColour * fShadowFactor * fAttenuation * max(0.0, dot(vLightDir, vNormal));\n    \n    shading.cDiffuse = vIncidentLight;                                  \n    shading.cSpecular = GetBlinnPhongIntensity( vIncidentDir, vLightDir, vNormal, material.fSmoothness ) * vIncidentLight;\n    \n    return shading;\n}  \n\nC_Shading ApplyDirectionalLight( const in C_DirectionalLight light, const in vec3 vSurfacePos, const in vec3 vIncidentDir, const in vec3 vNormal, const in C_Material material )\n{\n    C_Shading shading;\n\n    const float kShadowRayLength = 10.0;      \n    vec3 vLightDir = -light.vDir;\n    float fShadowFactor = GetShadow( vSurfacePos, vNormal, vLightDir, kShadowRayLength );\n    vec3 vIncidentLight = light.cColour * fShadowFactor * max(0.0, dot(vLightDir, vNormal));\n    \n    shading.cDiffuse = vIncidentLight;                                  \n    shading.cSpecular = GetBlinnPhongIntensity( vIncidentDir, vLightDir, vNormal, material.fSmoothness ) * vIncidentLight;\n    \n    return shading;\n}  \n\n\nvec3 ShadeSurface(const in C_Ray ray, const in C_HitInfo hitInfo, const in C_Surface surface, const in C_Material material)\n{\n    vec3 cScene;\n    \n    C_Shading shading;\n\n    shading.cDiffuse = vec3(0.0);\n    shading.cSpecular = vec3(0.0);\n    \n    float fAmbientOcclusion = GetAmbientOcclusion(hitInfo, surface);\n    vec3 vAmbientLight = GetAmbientLight(surface.vNormal) * fAmbientOcclusion;\n    \n    shading.cDiffuse += vAmbientLight;\n    shading.cSpecular += surface.cReflection;\n              \n    #ifdef ENABLE_POINT_LIGHT\n    C_PointLight pointLight = GetPointLight(); \n    C_Shading pointLighting = ApplyPointLight(pointLight, hitInfo.vPos,ray.vDir, surface.vNormal, material);\n    shading.cDiffuse += pointLighting.cDiffuse;\n    shading.cSpecular += pointLighting.cSpecular;\n    #endif\n\n    #ifdef ENABLE_DIRECTIONAL_LIGHT\n\tC_DirectionalLight directionalLight = GetDirectionalLight();\n    C_Shading directionLighting = ApplyDirectionalLight(directionalLight, hitInfo.vPos, ray.vDir, surface.vNormal, material);\n    shading.cDiffuse += directionLighting.cDiffuse;\n    shading.cSpecular += directionLighting.cSpecular;\n    #endif\n\n    vec3 vDiffuseReflection = shading.cDiffuse * material.cAlbedo;              \n\n    \/\/ swap diffuse for transmission\n    vDiffuseReflection = mix(vDiffuseReflection, surface.cTransmission, material.fTransparency);    \n\n    #ifdef ENABLE_SPECULAR\n    cScene = ApplyFresnel(vDiffuseReflection , shading.cSpecular, surface.vNormal, ray.vDir, material);\n    #else\n    cScene = vDiffuseReflection;\n    #endif\n    \n    return cScene;\n}\n\nvec3 GetSceneColourSecondary( const in C_Ray ray );\n\nvec3 GetReflection( const in C_Ray ray, const in C_HitInfo hitInfo, const in C_Surface surface )\n{\n    #ifdef ENABLE_REFLECTIONS    \n    {\n        \/\/ get colour from reflected ray\n        const float fSeparation    = 0.1;\n\n        C_Ray reflectRay;\n        reflectRay.vDir = reflect(ray.vDir, surface.vNormal);\n        reflectRay.vOrigin = hitInfo.vPos;\n        reflectRay.fLength = 16.0;\n        reflectRay.fStartDistance = fSeparation \/ abs(dot(reflectRay.vDir, surface.vNormal));\n        \n        return GetSceneColourSecondary(reflectRay);      \n    }\n    #else\n        return GetSkyGradient(reflect(ray.vDir, surface.vNormal));                              \n    #endif\n}\n\nvec3 GetTransmission( const in C_Ray ray, const in C_HitInfo hitInfo, const in C_Surface surface, const in C_Material material )\n{\n    #ifdef ENABLE_TRANSPARENCY  \n    {\n        const float fSeparation = 0.05;\n\n        \/\/ Trace until outside transparent object\n        C_Ray refractRay;\n        \/\/ we dont handle total internal reflection (in that case refract returns a zero length vector)\n        refractRay.vDir = refract(ray.vDir, surface.vNormal, material.fRefractiveIndex);\n        refractRay.vOrigin = hitInfo.vPos;\n        refractRay.fLength = 16.0;\n        refractRay.fStartDistance = fSeparation \/ abs(dot(refractRay.vDir, surface.vNormal));\n\n\t\t#ifdef DOUBLE_SIDED_TRANSPARENCY\n\t\t\n\t\t\tC_HitInfo hitInfo2;\n\t\t\tRaymarch(refractRay, hitInfo2, 32, kInverseTransparency);\n\t\t\tvec3 vNormal = GetSceneNormal(hitInfo2.vPos, kInverseTransparency);\n\t\t\t\n\t\t\t\/\/ get colour from rest of scene\n\t\t\tC_Ray refractRay2;\n\t\t\trefractRay2.vDir = refract(refractRay.vDir, vNormal, 1.0 \/ material.fRefractiveIndex);\n\t\t\trefractRay2.vOrigin = hitInfo2.vPos;\n\t\t\trefractRay2.fLength = 16.0;\n\t\t\trefractRay2.fStartDistance = 0.0;\/\/fSeparation \/ abs(dot(refractRay2.vDir, vNormal));\n\t\t\t\n\t\t\tfloat fExtinctionDist = hitInfo2.fDistance;\n\t\t\tvec3 vSceneColour = GetSceneColourSecondary(refractRay2);\n\t\t\n\t\t#else\n\t\t\n\t\t\tvec3 vSceneColour = GetSceneColourSecondary(refractRay);                                                                        \n\t\t\tfloat fExtinctionDist = 0.5;\n\t\t\n\t\t#endif\n                                \n        vec3 cMaterialExtinction = material.cAlbedo;\n        \/\/ extinction should really be exp(-) but this is a nice hack to get RGB\n        vec3 cExtinction = (1.0 \/ (1.0 + (cMaterialExtinction * fExtinctionDist)));\t\t\n\t\t\n\t\t\/\/vec3 cExtinction = exp2(-cMaterialExtinction * fExtinctionDist);\n                                \n        return vSceneColour * cExtinction;\n    }\n    #else\n        return GetSkyGradient(reflect(ray.vDir, surface.vNormal));                              \n    #endif\n}\n\n\/\/ no reflections, no transparency, used for secondary rays\nvec3 GetSceneColourSecondary( const in C_Ray ray )\n{\n    C_HitInfo hitInfo;\n    Raymarch(ray, hitInfo, 32, kNoTransparency);\n                        \n    vec3 cScene;\n\n    if(hitInfo.vObjectId.x < 0.5)\n    {\n        cScene = GetSkyGradient(ray.vDir);\n    }\n    else\n    {\n        C_Surface surface;        \n        surface.vNormal = GetSceneNormal(hitInfo.vPos, kNoTransparency);\n\n        C_Material material = GetObjectMaterial(hitInfo);\n\n        \/\/ use sky gradient instead of reflection\n        surface.cReflection = GetSkyGradient(reflect(ray.vDir, surface.vNormal));\n        \n        material.fTransparency = 0.0;\n\n        \/\/ apply lighting\n        cScene = ShadeSurface(ray, hitInfo, surface, material);\n    }\n\n    ApplyAtmosphere(cScene, ray, hitInfo);\n\n    return cScene;\n}\n\nvec3 GetSceneColourPrimary( const in C_Ray ray )\n{                                                          \n    C_HitInfo intersection;\n    Raymarch(ray, intersection, 256, kTransparency);\n                \n    vec3 cScene;\n\n    if(intersection.vObjectId.x < 0.5)\n    {\n        cScene = GetSkyGradient(ray.vDir);\n    }\n    else\n    {\n        C_Surface surface;\n        \n        surface.vNormal = GetSceneNormal(intersection.vPos, kTransparency);\n\n        C_Material material = GetObjectMaterial(intersection);\n\n        surface.cReflection = GetReflection(ray, intersection, surface);\n\n        if(material.fTransparency > 0.0)\n        {    \n            surface.cTransmission = GetTransmission(ray, intersection, surface, material);\n        }\n\n        \/\/ apply lighting\n        cScene = ShadeSurface(ray, intersection, surface, material);\n    }\n\n    ApplyAtmosphere(cScene, ray, intersection);\n\n    return cScene;\n}\n\nfloat kFarClip = 30.0;\n\nvoid GetCameraRay( const in vec3 vPos, const in vec3 vForwards, const in vec3 vWorldUp, const in vec2 fragCoord, out C_Ray ray)\n{\n    vec2 vUV = ( fragCoord.xy \/ iResolution.xy );\n    vec2 vViewCoord = vUV * 2.0 - 1.0;\n\n    float fRatio = iResolution.x \/ iResolution.y;\n    vViewCoord.y \/= fRatio;                          \n\n    ray.vOrigin = vPos;\n\n    vec3 vRight = normalize(cross(vForwards, vWorldUp));\n    vec3 vUp = cross(vRight, vForwards);\n        \n    ray.vDir = normalize( vRight * vViewCoord.x + vUp * vViewCoord.y + vForwards); \n    ray.fStartDistance = 0.0;\n    ray.fLength = kFarClip;      \n}\n\nvoid GetCameraRayLookat( const in vec3 vPos, const in vec3 vInterest, const in vec2 fragCoord, out C_Ray ray)\n{\n    vec3 vForwards = normalize(vInterest - vPos);\n    vec3 vUp = vec3(0.0, 1.0, 0.0);\n\n    GetCameraRay(vPos, vForwards, vUp, fragCoord, ray);\n}\n\nvec3 OrbitPoint( const in float fHeading, const in float fElevation )\n{\n    return vec3(sin(fHeading) * cos(fElevation), sin(fElevation), cos(fHeading) * cos(fElevation));\n}\n\nvec3 Tonemap( const in vec3 cCol )\n{ \n    vec3 vResult = 1.0 -exp2(-cCol);\n\n    return vResult;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    C_Ray ray;\n\n    vec2 vMouseUV = iMouse.xy \/ iResolution.xy;    \n    \n    if(iMouse.z < 0.5)\n    {\n        vMouseUV = vec2(0.2, 0.8);\n    }\n\n    float fHeading = mix(-0.5, kPI + 0.5, vMouseUV.x);\n    float fElevation = mix(1.5, -0.25, vMouseUV.y);\n    float fCameraDist = mix(4.0, 2.5, vMouseUV.y);\n    \n    vec3 vCameraPos = OrbitPoint(fHeading, fElevation) * fCameraDist;\n    vec3 vCameraIntrest = vec3(1.0, 0.9, 0.0);\n\n    GetCameraRayLookat( vCameraIntrest + vCameraPos, vCameraIntrest, fragCoord, ray);\n\n    vec3 cScene = GetSceneColourPrimary( ray );  \n\n    const float fExposure = 1.5;    \n    fragColor = vec4( Tonemap(cScene * fExposure), 1.0 );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\t\n    C_Ray ray;\n    \n    fragRayOri.x += 2.0;\n    fragRayOri.y += 1.5;\n    fragRayOri.z += 3.0;\n    \n\n    ray.vOrigin = fragRayOri;\n    ray.vDir = fragRayDir;\n    ray.fStartDistance = 0.0;\n    ray.fLength = kFarClip;\n        \n    vec3 cScene = GetSceneColourPrimary( ray );  \n\n    const float fExposure = 1.5;    \n    fragColor = vec4( Tonemap(cScene * fExposure), 1.0 );\n    \n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"ldB3Rz","date":"1401316141","viewed":22291,"name":"Larval","username":"P_Malin","description":"Some kind of alien fractal thingy.\nA hacked together KIFS doodle.\nThe fractal parameters aren't that exciting but I like the pretty colours :D","likes":142,"published":3,"flags":1,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"\/media\/a\/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"\/media\/ap\/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Larval - @P_Malin\n\/\/ https:\/\/www.shadertoy.com\/view\/ldB3Rz\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/ \n\/\/ Some kind of alien fractal thingy.\n\/\/ A hacked together KIFS doodle.\n\/\/ The fractal parameters aren't that exciting but I like the pretty colours :D\n\n#define kRaymarchIterations 24\n#define kIFSIterations 16\n\nvec3 vGlowColour = vec3(1.0, 0.075, 0.01) * 5.0;\nvec3 vEnvColour = vec3(0.1, 0.5, 1.0) * 2.0;\n\nfloat kExposure = 0.1;\n\n\/\/ KIFS parameters\nconst float fScale=1.25;\nvec3 vOffset = vec3(-1.0,-2.0,-0.2);\t\nmat3 m;\n\nconst float kFarClip = 30.0;\n\nvec2 GetSceneDistance( in vec3 vPos )\n{\n\tfloat fTrap = kFarClip;\n\t\n\tfloat fTotalScale = 1.0;\n\tfor(int i=0; i<kIFSIterations; i++)\n\t{\t\n\t\tvPos.xyz = abs(vPos.xyz);\n\t\tvPos *= fScale;\n\t\tfTotalScale *= fScale;\n\t\tvPos += vOffset;\n\t\tvPos.xyz = (vPos.xyz) * m;\n\t\t\n\t\tfloat fCurrDist = length(vPos.xyz) * fTotalScale;\n\t\t\/\/float fCurrDist = max(max(vPos.x, vPos.y), vPos.z) * fTotalScale;\n\t\t\/\/float fCurrDist = dot(vPos.xyz, vPos.xyz);\/\/ * fTotalScale;\t\t\n\t\tfTrap = min(fTrap, fCurrDist);\n\t}\n\n\tfloat l = length(vPos.xyz) \/ fTotalScale;\n\t\n\tfloat fDist = l - 0.1;\n\treturn vec2(fDist, fTrap);\n}\n\nvec4 Raycast( const in vec3 vOrigin, const in vec3 vDir )\n{\n\tfloat fClosest = kFarClip;\n\tvec2 d = vec2(0.0);\n\tfloat t = 0.01;\n\tfor(int i=0; i<kRaymarchIterations; i++)\n\t{\n\t\td = GetSceneDistance(vOrigin + vDir * t);\n\t\tfClosest = min(fClosest, d.x \/ t);\n\t\tif(abs(d.x) < 0.0001)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tt += d.x;\n\t\tif(t > kFarClip)\n\t\t{\n\t\t\tt = kFarClip;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn vec4(t, d.x, d.y, fClosest);\n}\n\nvec3 GetSceneNormal( const in vec3 vPos )\n{\n    const float fDelta = 0.000001;\n\n    vec3 vOffset1 = vec3( fDelta, -fDelta, -fDelta);\n    vec3 vOffset2 = vec3(-fDelta, -fDelta,  fDelta);\n    vec3 vOffset3 = vec3(-fDelta,  fDelta, -fDelta);\n    vec3 vOffset4 = vec3( fDelta,  fDelta,  fDelta);\n\n    float f1 = GetSceneDistance( vPos + vOffset1 ).x;\n    float f2 = GetSceneDistance( vPos + vOffset2 ).x;\n    float f3 = GetSceneDistance( vPos + vOffset3 ).x;\n    float f4 = GetSceneDistance( vPos + vOffset4 ).x;\n\n    vec3 vNormal = vOffset1 * f1 + vOffset2 * f2 + vOffset3 * f3 + vOffset4 * f4;\n\n    return normalize( vNormal );\n}\n\nvec3 TraceRay( const in vec3 vOrigin, const in vec3 vDir )\n{\t\n\tvec4 vHit = Raycast(vOrigin, vDir);\n\t\n\tvec3 vHitPos = vOrigin + vDir * vHit.x;\n\tvec3 vHitNormal = GetSceneNormal(vHitPos);\n\t\n\tfloat fShade = 1.0;\n\tfloat fGlow = 0.0;\n\tvec3 vEnvDir = vDir;\n\tif(vHit.x < kFarClip)\n\t{\n\t\tvEnvDir = reflect(vDir, vHitNormal);\n\t\tfGlow = clamp(vHit.z * 0.1, 0.0, 1.0);\n\t\tfGlow = pow(fGlow, 3.0);\n\t\tfShade = fGlow;\n\t}\n\t\n\tvec3 vEnv = texture(iChannel0, vEnvDir).rgb;\n\tvEnv = vEnv * vEnv;\t\n\tvEnv = -log2(1.0 - min(vEnv, 0.99));\n\n\tvEnv *= vEnvColour;\n\t\n\tvec3 vColour = vEnv * (0.25 + fShade * 0.75);\n\t\n\t\/\/ inner glow\n\tif(vHit.x < kFarClip)\n\t{\t\n\t\tvColour += vGlowColour * 10.0 * fGlow;\n\t}\n\n\t\/\/ outer glow\n\t{\t\t\t\t\n\t\tfloat f = 1.0 - clamp(vHit.w * 0.5, 0.0, 1.0);\t\t\n\t\t\n\t\tfloat fGlowAmount = 0.0;\n\t\t\n\t\t\/\/ big glow\n\t\tfloat f1 = pow(f, 20.0);\n\t\tfGlowAmount += f1 * 2.0 * (0.5 + fShade * 0.5);\n\t\n\t\t\/\/ small glow\n\t\tfloat f2 = pow(f, 200.0);\n\t\tfGlowAmount += f2 * 5.0 * fShade;\n\t\t\n\t\tvColour += vGlowColour * fGlowAmount;\n\t}\n\t\n\treturn vColour;\n}\n\n\n\/\/ mat3 from quaternion\nmat3 SetRot( const in vec4 q )\n{\n\tvec4 qSq = q * q;\n\tfloat xy2 = q.x * q.y * 2.0;\n\tfloat xz2 = q.x * q.z * 2.0;\n\tfloat yz2 = q.y * q.z * 2.0;\n\tfloat wx2 = q.w * q.x * 2.0;\n\tfloat wy2 = q.w * q.y * 2.0;\n\tfloat wz2 = q.w * q.z * 2.0;\n \n\treturn mat3 (\t\n     qSq.w + qSq.x - qSq.y - qSq.z, xy2 - wz2, xz2 + wy2,\n     xy2 + wz2, qSq.w - qSq.x + qSq.y - qSq.z, yz2 - wx2,\n     xz2 - wy2, yz2 + wx2, qSq.w - qSq.x - qSq.y + qSq.z );\n}\n\n\/\/ mat3 from axis \/ angle\nmat3 SetRot( vec3 vAxis, float fAngle )\n{\t\n\treturn SetRot( vec4(normalize(vAxis) * sin(fAngle), cos(fAngle)) );\n}\n\nvec3 ApplyPostFx( const in vec3 vIn, const in vec2 fragCoord )\n{\n\tvec2 vUV = fragCoord.xy \/ iResolution.xy;\n\tvec2 vCentreOffset = (vUV - 0.5) * 2.0;\n\t\n\tvec3 vResult = vIn;\n\tvResult.xyz *= clamp(1.0 - dot(vCentreOffset, vCentreOffset) * 0.4, 0.0, 1.0);\n\n\tvResult.xyz = 1.0 - exp(vResult.xyz * -kExposure);\n\t\n\tvResult.xyz = pow(vResult.xyz, vec3(1.0 \/ 2.2));\n\t\n\treturn vResult;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vUV = fragCoord.xy \/ iResolution.xy;\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= iResolution.x \/ iResolution.y;\n\t\n\tvec2 vMouse = iMouse.xy \/ iResolution.xy;\n\t\n\tfloat fHeading = iTime * 0.21;\n\tfloat fElevation = cos(iTime * 0.1) * 0.5;\n\tfloat fCameraDistance = 15.0 + sin(iTime * 0.05) * 5.0;\n\t\n\tfloat fSinElevation = sin(fElevation);\n\tfloat fCosElevation = cos(fElevation);\n\tfloat fSinHeading = sin(fHeading);\n\tfloat fCosHeading = cos(fHeading);\n\t\n\tvec3 vCameraOffset;\n\tvCameraOffset.x = fSinHeading * fCosElevation;\n\tvCameraOffset.y = fSinElevation;\n\tvCameraOffset.z = fCosHeading * fCosElevation;\n\t\n\tvec3 vCameraPos = vCameraOffset * fCameraDistance;\n\n\tvec3 vCameraTarget = vec3(0.0, 0.0, 0.0);\n\t\n\tvec3 vForward = normalize(vCameraTarget - vCameraPos);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n\t\n\tfloat fFov = 2.0;\n\t\n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fFov);\n\t\n\tvec3 vRotationAxis = vec3(1.0, 4.0, 2.0);\n\n\t\/\/ Rotate the rotation axis\n\tmat3 m2 = SetRot( vec3(0.1, 1.0, 0.01), iTime * 0.3 );\t\t\n\t\n\tvRotationAxis = vRotationAxis * m2;\n\t\n\tfloat fRotationAngle = sin(iTime * 0.5);\n\t\n\tif( iMouse.z > 0.0 )\n\t{\n\t\tvec2 vMouseOffset = vMouse * 2.0 - 1.0;\n\t\tvRotationAxis = vec3(vMouseOffset.x, 1.0, vMouseOffset.y);\n\t\tfRotationAngle = length(vRotationAxis);\n\t}\n\t\n\tm = SetRot(vRotationAxis, fRotationAngle);\n\t\n\tvec3 vResult = TraceRay(vCameraPos, vDir);\n\t\n\tvResult = ApplyPostFx(vResult,fragCoord);\n\t\n\tfragColor = vec4(vResult,1.0);\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n\tvec2 vMouse = iMouse.xy \/ iResolution.xy;\n    \n\tvec3 vRotationAxis = vec3(1.0, 4.0, 2.0);\n\n\t\/\/ Rotate the rotation axis\n\tmat3 m2 = SetRot( vec3(0.1, 1.0, 0.01), iTime * 0.3 );\t\t\n\t\n\tvRotationAxis = vRotationAxis * m2;\n\t\n\tfloat fRotationAngle = sin(iTime * 0.5);\n\t\n\tif( iMouse.z > 0.0 )\n\t{\n\t\tvec2 vMouseOffset = vMouse * 2.0 - 1.0;\n\t\tvRotationAxis = vec3(vMouseOffset.x, 1.0, vMouseOffset.y);\n\t\tfRotationAngle = length(vRotationAxis);\n\t}    \n\tm = SetRot(vRotationAxis, fRotationAngle);\n\n    fragRayOri *= 40.0;\n    \n    fragRayOri.z *= -1.0;\n    fragRayDir.z *= -1.0;\n    \n    fragRayOri.z -= 20.0;\n    fragRayOri.y += 5.0;\n\tvec3 vResult = TraceRay(fragRayOri, fragRayDir);\n\t\n\tvResult = ApplyPostFx(vResult,vec2(0.5));\n\t\n\tfragColor = vec4(vResult,1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"ldBfDR","date":"1500040573","viewed":19609,"name":"[SH17A] Lava Planet","username":"P_Malin","description":"280 character entry for Round 1 of the 2017 Shadertoy competition https:\/\/www.shadertoy.com\/events\/competition\n\nThere was more potential in this code so I made a variation without the 280 character limit here: https:\/\/www.shadertoy.com\/view\/4dBBDD","likes":86,"published":3,"flags":64,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"\/media\/a\/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"\/media\/ap\/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"\/media\/a\/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"\/media\/ap\/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdsSRs","filepath":"https:\/\/soundcloud.com\/eat-static-official\/uforic-undulance","previewfilepath":"https:\/\/soundcloud.com\/eat-static-official\/uforic-undulance","type":"musicstream","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ [SH17A] Lava Planet\n\/\/ @P_Malin\n\/\/ https:\/\/www.shadertoy.com\/view\/ldBfDR\n\n\n\/\/ There was more potential in this code so I made a variation without the 280 character limit here:\n\/\/ https:\/\/www.shadertoy.com\/view\/4dBBDD\n\n\/\/ Also see the annotated version by @morgan3d explaining what is going on a bit more here:\n\/\/ https:\/\/www.shadertoy.com\/view\/Mdjfzd\n\n#define T texture(iChannel0,c*.1)\n\nvoid mainImage( out vec4 f, vec2 c )\n{\n    vec4 d = vec4( c \/ iResolution.x, 1, 1 ) - .5, \/\/ 'view' (d)irection\n        o, \/\/ (o)ffset from camera\n        g, \/\/ (g)low amount\n        t, \/\/ '(t)exture'\n        l; \/\/ '(l)andscape'\n\t\n\t\/\/d.z += d.y * .5; \/\/ More dramatic camera projection\n    \n    o = f *= 0.; \/\/ required for GL\n    \n    for ( float h=0.; h<.6; h+=.001 ) \/\/ terrain slice (h)eight\n        f += \/\/ accumulate \"volumetric lighting\" into final output\n        \to.y < T.x \/\/ loop condition\n        \t\t?\n                    o = d * h \/ -abs(d.y), \/\/ calculate offset of slice intersection\n                    c = o.xz - iTime * .2,\n                    l = T, \/\/ terrain sample 1\n                    t = texture(iChannel1,c), \/\/ terrain \/ lava texture sample\n                       \/\/t = textureLod(iChannel1,c, 12. * (T.x-o.y) ), \/\/ comment in for better glow\n                    g = pow( l*t,t+7. \/\/ glow color\n                                   \/\/+sin(iTime) \/\/ comment in for pulse effect\n                                ) * o.y \/\/ change color of sky\n\t        \t: g; \/\/ should be zero not g but g looks ok\n            \n            \n \tc-=.1; \/\/ offset UV for lighting\n    l -= T-.4; \/\/ terrain lighting\n    \n    \n    f += \/\/ f already contains \"volumetric lighting\"\n         t * l \/\/ terrain texture * lighting\n        + g * 6e2 \/\/ add glow,\n        \t* o.y \/\/ fiddle with sky color some more\n        +o.z*.03; \/\/ \"depth fog\"\n    \n    \/\/f = 1. - exp(-f * 1.5); \/\/ tonemap    \n}\n\n\/*\n\/\/ minified..\n\n#define T texture(iChannel0,c*.1)\nvoid mainImage(out vec4 f, vec2 c){vec4 d=vec4(c\/iResolution.x,1,1)-.5,o,g,t,l;o=f*=0.;\nfor(float h=0.;h<.6;h+=.001)f+=o.y<T.x?o=d*h\/-abs(d.y),c=o.xz-iTime*.1,l=T,\nt=texture(iChannel1,c),g=pow(l*t,t+7.)*o.y:g;c-=.1;l-=T-.4-d.y;f+=t*l+g*2e2+o.z*.03;}\n\n*\/\n\n\n\/*\n\/\/ New and improved - backup\n\n#define T texture(iChannel0,c*.1)\n\nvoid mainImage( out vec4 f, vec2 c )\n{\n    vec4 o = vec4( c \/ iResolution.x, 1, 1 ) - .5, d=o, g, t, l;\n\t\n    f*=0.;\n    for ( float h=0.; h<.6; h+=.001)\n        if ( o.y < T.x )\n            l = T,\n            t = texture(iChannel1,c -= .1),\n            f -= g = pow( l*t,t+7. \n                       \/\/ +sin(iTime)\n                        ) * d.y,\n            l -= T-.2,\n            o = d * h\/-abs(d.y),\n            c = o.xz - iTime * .1;\n    \n    \n    f += t * l\n        - g * 3e2\n        +o.z*.01;\n}\n*\/\n\n\/*\n\n#define T texture(iChannel0,c*.07)\n\nvoid mainImage( out vec4 r, vec2 c )\n{\n    vec4 o = vec4( c \/ iResolution.x, 1, 1 ) - .5, d=o, g, l, f;\n\n    for ( float h=0.; h<.6 && o.y < T.x; h+=.001)\n\t\tr = T,\n        l = texture(iChannel1,c -= .1),\n        f += g = pow( r*l,l+8.+sin(iTime) ) * o.y, \n        r -= T-.2,\n        o = d * h \/ -abs(d.y),\n        c = o.xz - iTime * .1;\n    \n    r = l * r\n        + g * 3e2 \n        + f\n        + o.z \/ 1e2;\n}\n\n*\/\n\n\/*\n\/\/ Move condition into for loop (thanks lherm)\n\n#define T texture(iChannel0,c*.1)\n\nvoid mainImage( out vec4 f, vec2 c )\n{\n    vec3 o = vec3( c \/ iResolution.x, 1 ) - .5, d=o;\n        \n    for ( float h=0.; h<.6 &&  o.y < T.x; h+=.001)\n        o = d * h \/ -abs(d.y), \/\/ Intersect slice\n        c = o.xz - iTime * .1, \/\/ Get terrain UV\n        f = T; \/\/ Sample terrain texture    \n    \n    f = 1. -exp( - \/\/ tonemap\n          texture(iChannel1,c+=.1)  \/\/ texture (and offet uv for lighting)\n        * ( \n              .2 - f + T \/\/ terrain lighting - should be max(0., ...\n            - exp( vec4(16, 14, 9, 1) * f - 9. + sin(iTime))  \/\/ lava glow\n            * d.y            \n          )\n          \n          -o.z * .01 \/\/ \"fog\"\n                \n          \/\/+o.z * f *.1\/\/ fog effect 2\n                \n    );    \n}\n*\/\n\n\/*\n\n#define T texture(iChannel0,c*.1)\n\nvoid mainImage( out vec4 f, vec2 c )\n{\n    vec3 o = vec3( c \/ iResolution.x, 1 ) - .5, d=o;\n        \n\tf=T;\n    \n    for ( float h=0.; h<.6 &&  o.y < f.x; h+=.001)\n        o = d * h \/ -abs(d.y), \/\/ Intersect slice\n        c = o.xz - iTime * .1, \/\/ Get terrain UV\n        f = T; \/\/ Sample terrain texture    \n    \n    f = 1. -exp( - \/\/ tonemap\n          texture(iChannel1,c+=.1)  \/\/ texture (and offet uv for lighting)\n        * ( \n              .2 - f + T \/\/ terrain lighting - should be max(0., ...\n            - exp( vec4(16, 14, 9, 1) * f - 9. + sin(iTime))  \/\/ lava glow\n            * d.y            \n          )\n          \n          -o.z * .01 \/\/ \"fog\"\n                \n          \/\/+o.z * f *.1\/\/ fog effect 2\n                \n    );    \n}\n*\/\n\n\/\/ backup \n\n\/*\n\n#define T texture(iChannel0,c*.1)\n\n\/\/ lava pulse\n\nvoid mainImage( out vec4 f, vec2 c )\n{\n    vec3 d = vec3( c \/ iResolution.x, 1 ) - .5, o=d;\n\t    \n    f *= 0.;\n    \/\/d.y *=sign(d.y)+2.; f=iDate;\n    \n    for ( float h=0.; h<.6; h+=.001)\n        if ( o.y < f.x) \/\/ break out of loop\n            o = d * h \/ d.y, \/\/ Intersect slice\n            c = o.xz - iTime * .1, \/\/ Get terrain UV\n            f = T; \/\/ Sample terrain texture    \n    \n    f = 1. -exp( - \/\/ tonemap\n          texture(iChannel1,c+=.05)  \/\/ texture (and offet uv for lighting)\n        * ( \n              .2 + f.x -T.x \/\/ terrain lighting - should be max(0., ...\n            + exp( vec4(16, 13, 9, 1) * f - 9. + sin(iTime)) \/\/ lava glow\n          )\n          -o.z * .01 \/\/ \"fog\"\n    );    \n}\n*\/\n\n\/*\n\/\/ plane slices version\n\n#define T texture(iChannel0,c*.1)\n\nvoid mainImage( out vec4 f, vec2 c )\n{\n    vec3 d = vec3( c \/ iResolution.x, 1 ) - .5, o=d;\n\n    f = vec4(0);\n    for ( float h=0.; h<.6; h+=.001)\n        if ( o.y < f.x) \/\/ break out of loop\n            o = d * h \/ d.y, \/\/ Intersect slice\n            c = o.xz - iTime * .1, \/\/ Get terrain UV\n            f = T; \/\/ Sample terrain texture\n    \n    \n    f = 1. -exp( - \/\/ tonemap\n          texture(iChannel1,c+=.05)  \/\/ texture (and offet uv for lighting)\n        * ( \n              max(0., .2 + f.x -T.x) \/\/ terrain lighting\n            + exp( vec4(16, 13, 9, 1) * f - 9.) \/\/ lava glow\n          )\n          -o.z * .01 \/\/ \"fog\"\n        \/\/+ dot(o,o) * .001\/\/ \"fog\"\n    );    \n}\n*\/\n\n\n\/\/ first version @ 279\n\n\/*\n#define T texture(iChannel0,c*.1)\n\nvoid mainImage( out vec4 f, vec2 c )\n{\n    vec3 d = vec3( c \/ iResolution.x, 1 ) - .5, o = d \/= 2e2;\n    \n    do\n\t\to += d, \/\/ Step along ray\n        c = o.xz + iTime * .1, \/\/ Get terrain UV\n        f = T; \/\/ Sample terrain texture\n    while(\n        o.z < 8. && \/\/ far clip\n        o.y > -min(.6,f.x)); \/\/ hit terrain\n\n    f = 1. -exp( - \/\/ tonemap\n          texture(iChannel1,c+=.05)  \/\/ texture\n        * ( \n              max(0., .2 + f.x -T.x) \/\/ terrain lighting\n            + exp( vec4(16, 13, 9, 1) * f.x - 9.) \/\/ lava glow\n          )\n        * step(o.z, 8.) \/\/ far clip\n        + o.z * .03 \/\/ \"fog\"\n    );    \n}\n\n*\/\n\n\n\n\n\/*\n\/\/hacks\n\n#define T texture(iChannel0,c*.1)\n\n\/\/ lava pulse\n\nvoid mainImage( out vec4 f, vec2 c )\n{\n    vec4 o = vec4( c \/ iResolution.x, 1, 0 ) - .5, d=o\/1e3\/o.y;\n    \n    o=f=o-o;\n    for(int i=0;i<600;i++)\n        if ( o.y <= f.x) \/\/ break out of loop\n            o += d, \/\/ Intersect slice\n            c = o.xz - iTime * .1, \/\/ Get terrain UV\n            f = T; \/\/ Sample terrain texture    \n    \n    f = 1. -exp( - \/\/ tonemap\n          texture(iChannel1,c+=.05)  \/\/ texture (and offet uv for lighting)\n        * ( \n              .2 + f -T \/\/ terrain lighting - should be max(0., ...\n            + exp( vec4(16, 13, 9, 1) * f - 9. + sin(iTime)) \/\/ lava glow\n          )\n          -o.z * .01 \/\/ \"fog\"\n    );    \n}\n\n*\/","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"4dlyWX","date":"1490827365","viewed":16931,"name":"Meta CRT","username":"P_Malin","description":"Experiments with CRT screen material with scanlines and RGB elements.\nPost FX include temporal AA, depth of field and motion blur.","likes":338,"published":3,"flags":48,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"\/media\/previz\/buffer03.png","previewfilepath":"\/media\/previz\/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Meta CRT - @P_Malin\n\/\/ https:\/\/www.shadertoy.com\/view\/4dlyWX#\n\/\/ In which I add and remove aliasing\n\n\/\/ Uncomment different defines in Buf B to run different shaders on TV\n\n\/\/ Postprocessing Pass\n\/\/ Motion blur, Depth of Field, Vignetting & Tonemap\n\n\n#define ENABLE_DOF\n#define ENABLE_MOTION_BLUR\n\n\n\nvec3 Tonemap( vec3 x )\n{\n#if 0 \n    \n    vec3 luminanceCoeffsBT709 = vec3( 0.2126f, 0.7152f, 0.0722f );\n    float f = dot( x, luminanceCoeffsBT709 );\n    x \/= f;        \n    f = 1.0f - exp(-f);    \n    x *= f;    \n    x = mix( x, vec3(f), f*f );\n    \n    return x;\n#else       \n    float a = 0.010;\n    float b = 0.132;\n    float c = 0.010;\n    float d = 0.163;\n    float e = 0.101;\n\n    return ( x * ( a * x + b ) ) \/ ( x * ( c * x + d ) + e );    \n#endif    \n}\n\n\nfloat GetVignetting( const in vec2 vUV, float fScale, float fPower, float fStrength )\n{\n\tvec2 vOffset = (vUV - 0.5) * sqrt(2.0) * fScale;\n\t\n\tfloat fDist = max( 0.0, 1.0 - length( vOffset ) );\n    \n\tfloat fShade = 1.0 - pow( fDist, fPower );\n    \n    fShade = 1.0 - fShade * fStrength;\n\n\treturn fShade;\n}\n\n\n\n\nfloat GetCoC( float fDistance, float fPlaneInFocus )\n{\n#ifdef ENABLE_DOF    \n\t\/\/ http:\/\/http.developer.nvidia.com\/GPUGems\/gpugems_ch23.html\n\n    float fAperture = min(1.0, fPlaneInFocus * fPlaneInFocus * 0.5);\n    float fFocalLength = 0.03;\n    \n\treturn abs(fAperture * (fFocalLength * (fDistance - fPlaneInFocus)) \/\n          (fDistance * (fPlaneInFocus - fFocalLength)));  \n#else\n    return 0.0f;\n#endif    \n}\n\n\/\/ Depth of field pass\n\n#define BLUR_TAPS 64\nfloat fGolden = 3.141592 * (3.0 - sqrt(5.0));\n\n#define MOD2 vec2(4.438975,3.972973)\n\nfloat Hash( float p ) \n{\n    \/\/ https:\/\/www.shadertoy.com\/view\/4djSRW - Dave Hoskins\n\tvec2 p2 = fract(vec2(p) * MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    CameraState camCurr;\n\tCam_LoadState( camCurr, iChannel0, ivec2(0) );\n\n    CameraState camPrev;\n\tCam_LoadState( camPrev, iChannel0, ivec2(3,0) );\n    \n\tvec2 vUV = fragCoord.xy \/ iResolution.xy;\n \t\/\/vUV -= camCurr.vJitter \/ iResolution.xy;    \/\/ TAA has removed jitter\n\n    vec4 vSample = texelFetch( iChannel0, ivec2(fragCoord.xy), 0 ).rgba;\n    \n    int iObjectId;\n    float fDepth = DecodeDepthAndObjectId( vSample.w, iObjectId );\n    \n    vec3 vRayOrigin, vRayDir;\n    \n    Cam_GetCameraRay( vUV, iResolution.xy, camCurr, vRayOrigin, vRayDir );    \n    vec3 vWorldPos = vRayOrigin + vRayDir * fDepth;\n        \n    vec2 vPrevUV = Cam_GetUVFromWindowCoord( Cam_WorldToWindowCoord(vWorldPos, camPrev), iResolution.xy );\/\/ - camPrev.vJitter \/ iResolution.xy;\n        \n\tvec3 vResult = vec3(0.0);\n    \n    float fTot = 0.0;\n    \n    float fPlaneInFocus = camCurr.fPlaneInFocus;\n        \n\tfloat fCoC = GetCoC( fDepth, camCurr.fPlaneInFocus );\n        \n    float r = 1.0;\n    vec2 vangle = vec2(0.0,fCoC); \/\/ Start angle\n    \n    float fWeight = max( 0.001, fCoC );    \n    vResult.rgb = vSample.rgb * fWeight;\n    fTot += fWeight;\n    \n#if defined(ENABLE_DOF) || defined(ENABLE_MOTION_BLUR)    \n    float fMotionBlurTaps = float(BLUR_TAPS);\n    \n    float fShutterAngle = 0.5;\n    \n    float f = 0.0;\n    float fIndex = 0.0;\n    for(int i=1; i<BLUR_TAPS; i++)\n    {\n        float fRandomT = Hash( iTime + fIndex + vUV.x + vUV.y * 12.345);\n        float fOrderedT = fIndex \/ fMotionBlurTaps;\n        \n        float fDofT = fOrderedT;\n        float fMotionT = fRandomT;\n        \n        vec2 vTapUV = vUV;\n        #ifdef ENABLE_MOTION_BLUR\n        vTapUV = mix( vTapUV, vPrevUV, (fMotionT - 0.5) * fShutterAngle );\n        #endif\n                \n        \/\/ http:\/\/blog.marmakoide.org\/?p=1\n        \n        float fTheta = fDofT * fGolden * fMotionBlurTaps;\n        float fRadius = fCoC * sqrt( fDofT * fMotionBlurTaps ) \/ sqrt( fMotionBlurTaps );        \n        \n        vTapUV += vec2( sin(fTheta), cos(fTheta) ) * fRadius;\n        \n        vec4 vTapSample = textureLod( iChannel0, vTapUV, 0.0 ).rgba;\n\t    \/\/vec4 vTapTexel = texelFetch( iChannel0, ivec2(vTapUV.xy * iResolution.xy), 0 ).rgba;\n        \n        int iTapObjectId;\n        float fTapDepth = DecodeDepthAndObjectId( vTapSample.w, iTapObjectId );\n        \n        if ( fTapDepth > 0.0 )\n        {            \n  \t\t  \tfloat fCurrCoC = GetCoC( fTapDepth, fPlaneInFocus );\n            \n            float fCurrWeight = max( 0.001, fCurrCoC );\n            \n    \t\tvResult += vTapSample.rgb * fCurrWeight;\n        \tfTot += fCurrWeight;\n        }\n        f += 1.0;\n        fIndex += 1.0;\n    }\n#endif    \n    vResult \/= fTot;\n    \n\tfragColor = vec4(vResult, 1.0);    \n    \n    float fShade = GetVignetting( vUV, 0.7, 2.0, 1.0 );\n    \n    fragColor.rgb *= fShade;\n    \n    fragColor.rgb = Tonemap( fragColor.rgb );\n    fragColor.a = 1.0;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"\/presets\/tex00.jpg","previewfilepath":"\/presets\/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ Update Logic for Commodore 64 by hubbe\n\/\/ https:\/\/www.shadertoy.com\/view\/Xs3XW4\n\n\/\/ TODO: break\n\n#define CURSOR 0\n#define STATE 1\n#define MEMORY 2\n\nvec4 old_memory[MEMORY];\nvec4 memory[MEMORY];\n\n#define STATE_READY 0\n#define STATE_PRINT_READY 1\n#define STATE_PRINT_READY_NL 2\n#define STATE_LISTING 3\n#define STATE_RUNNING 4\n#define STATE_BREAK 5\n\n#define LINE_ZERO 30\n#define MAX_LINES 200\n\nfloat vec4pick(int c, vec4 v) {\n    if (c == 0) return v.x;\n    if (c == 1) return v.y;\n    if (c == 2) return v.z;\n    return v.w;\n}\n\nint vec4toint(int c, vec4 v) {\n    c = int(mod(float(c), 8.0));\n    float tmp = vec4pick(c \/ 2, v);\n    if (c != (c\/2) * 2) {\n        return int(mod(tmp, 256.0));\n    } else {\n        return int(tmp) \/ 256;\n    }\n}\n\nvec4 vec4tochar(int c, vec4 v) {\n    return vec4(vec4toint(c, v), 14\/* fg *\/, 6 \/* bg *\/, 0);\n}\n\n\nvoid init_screen(out vec4 fragColor, int x, int y) {\n    fragColor = vec4(96, 14, 6, 0);\n\n    if(y == 1) {\n        if (x > 3 && x < 35) fragColor.x = 42.0;\n        if (x > 7 && x < 31) fragColor.x = 96.0;\n        x -= 9;\n        vec4 tmp;\n        if (x < 0) return;\n        if (x > 20) return;\n        int n = x \/ 8;\n        if (n == 0) tmp = vec4(0x030F, 0x0D0D, 0x0F04, 0x0F12);  \/\/ COMMODOR\n        if (n == 1) tmp = vec4(0x0560, 0x3634, 0x6002, 0x0113);  \/\/ E 64 BAS\n        if (n == 2) tmp = vec4(0x0903, 0x6016, 0x3200, 0x0000);  \/\/ IC V2\n        fragColor = vec4tochar(x, tmp);\n    }\n    if (y == 3) {\n        int n = x \/ 8;\n        vec4 tmp;\n        if (n == 0) tmp = vec4(0x6036, 0x340B, 0x6012, 0x010D); \/\/  64K RAM\n        if (n == 1) tmp = vec4(0x6013, 0x1913, 0x1405, 0x0D60); \/\/  SYSTEM \n        if (n == 2) tmp = vec4(0x6033, 0x3839, 0x3131, 0x6002); \/\/  38911 B\n        if (n == 3) tmp = vec4(0x0113, 0x0903, 0x6002, 0x1914); \/\/ ASIC BYT\n        if (n == 4) tmp = vec4(0x0513, 0x6006, 0x1205, 0x0560); \/\/ ES FREE\n        fragColor = vec4tochar(x, tmp);\n    }\n}\n\nint key = -1;\nint scroll = 0;\n\nvoid NL() {\n   memory[CURSOR].x = 0.0;\n   memory[CURSOR].y += 1.0;\n   if (memory[CURSOR].y >= 20.0) {\n       scroll += 1;\n       memory[CURSOR].y -= 1.0;\n   }\n}\n\nvoid putc(int c) {\n    key = c;\n    memory[CURSOR].x += 1.0;\n    if (memory[CURSOR].x > 40.0) NL();\n}\n\nint screen_pos(vec4 v) {\n    int x = int(v.x + 0.5);\n    int y = int(v.y + 0.5);\n    return x + y * 40;\n}\n\nvec4 peek(int x, int y) {\n    return texelFetch(iChannel0, ivec2(x, y), 0 );\n}\n\nvec4 peek(int pos) {\n    int y = pos \/ 40;\n    int x = pos - y * 40;\n    return peek(x, y);\n}\n\nvec4 itoa(int x, int p) {\n\tint c = 96;\n    int len = 1;\n    if (x > 9) len = 2;\n    if (x > 99) len = 3;\n    if (p < len) {\n        int power10 = 1;\n        if (len - p == 2) power10 = 10;\n        if (len - p == 3) power10 = 100;\n        c = 48 + int(mod(float(x \/ power10), 10.0));        \n    }\n    return vec4(c, 14, 6, 0);\n}\n\nint copy_from;\nint copy_to;\nint copy_length;\n\n#define MSG_SYNTAX_ERROR -1\n#define MSG_READY -2\n#define MSG_ZERO -3\n#define MSG_BREAK -4\n\nvoid copy(int pos, inout vec4 tmp) {\n    int c = pos - copy_to;\n    if (c >= 0 && c < copy_length) {\n        tmp = vec4(0,0,0,0);\n        if (copy_from == MSG_SYNTAX_ERROR) {\n            vec4 ch;\n            if (c \/ 8 == 0)\n              ch = vec4(0x3F13, 0x190E, 0x1401, 0x1860);  \/\/ ?SYNTAX \n            if (c \/ 8 == 1)\n              ch = vec4(0x6005, 0x1212, 0x0F12, 0x0000);  \/\/ ERROR\n            tmp = vec4tochar(c, ch);\n        } else if (copy_from == MSG_READY) {\n            vec4 ch = vec4(0x1205, 0x0104, 0x192E, 0);\n            tmp = vec4tochar(c, ch) ; \n        } else if (copy_from == MSG_ZERO) {\n            tmp = vec4(0);\n        } else if (copy_from == MSG_BREAK) {\n            vec4 ch;\n            if (c < 8)\n              tmp = vec4tochar(c, vec4(0x0212, 0x0501, 0x0B60, 0x090E));  \/\/ BREAK IN\n            if (c == 8)\n              tmp = vec4(96, 14, 6, 0);\n            if (c > 8)\n              tmp = itoa(int(memory[STATE].y), c - 9);\n        } else {\n\t        tmp = peek(copy_from + c);\n            if (tmp.x >= 128.0) tmp.x -= 128.0;\n        }\n    }\n}\n\nvoid memcpy(int dst, int src, int len) {\n    copy_from = src;\n    copy_to = dst;\n    copy_length = len;\n}\n\n\nvoid print(int msg, int msg_len) {\n    NL();\n    memcpy(screen_pos(memory[CURSOR]) - 40, msg, msg_len);\n}\n\nvoid list() {\n      memory[STATE].x = float(STATE_LISTING);\n      memory[STATE].y = float(0);\n}\n\nint getchar(int x, int y) {\n    int c = int(peek(x, y).x);\n    if (c > 128) c -= 128;\n    return c;\n}\n\nint getchar(int pos) {\n    int c = int(peek(pos).x);\n    if (c > 128) c -= 128;\n    return c;\n}\n\nvoid skipwhite(inout int pos) {\n    int c = getchar(pos);\n    if (c == 96) pos = pos + 1;    \n    c = getchar(pos);\n    if (c == 96) pos = pos + 1;    \n    c = getchar(pos);\n    if (c == 96) pos = pos + 1;    \n}\n\nbool strtod(inout int pos, inout int value) {\n  skipwhite(pos);\n  int c = getchar(pos);\n  int num = c - 48;\n  if (num < 0 || num > 9) return false;\n  value = num;\n  pos = pos + 1;\n  c = getchar(pos);\n  num = c - 48;\n  if (num < 0 || num > 9) return true;\n  value = value * 10 + num;\n  pos = pos + 1;\n  c = getchar(pos);\n  num = c - 48;\n  if (num < 0 || num > 9) return true;\n  value = value * 10 + num;\n  return true;  \n}\n\nvoid skipnum(inout int pos) {\n    int value;\n    strtod(pos, value);\n}\n\nvoid parse(int pos) {\n    skipwhite(pos);\n    int c1 = getchar(pos);\n    int c2 = getchar(pos + 1);\n    int c3 = getchar(pos + 2);\n    int c4 = getchar(pos + 3);\n    if (c1 == 12 && c2 == 9 && c3 == 19 && c4 == 20) { \/\/ list\n        list();\n        \n    } else if (c1 == 18 && c2 == 21 && c3 == 14) { \/\/ run\n        memory[STATE].x = float(STATE_RUNNING);\n        int line = 0;\n        int p = pos + 3;\n        strtod(p, line);\n        memory[STATE].y = float(line);\n    } else if (c1 == 7 && c2 == 15 && c3 == 20 && c2 == 15) { \/\/ goto\n        memory[STATE].x = float(STATE_RUNNING);\n        int line = 0;\n        int p = pos + 4;\n        strtod(p, line);\n        memory[STATE].y = float(line);\n    } else if (c1 == 16 && c2 == 18 && c3 == 9 && c4 == 14) {\n        \/\/ print\n        NL();\n        int p = pos + 7;\n        int len = 0;\n        for (int l = 0; l < 33; l++) {\n            if (len == 0 && int(peek(p + l).x) == 34)\n                len = l;\n        }\n        \n        memcpy(screen_pos(memory[CURSOR]) - 40, pos + 7, len);\n    } else if (c1 == 96 && c2 == 96 && c3 == 96 && c4 == 96) {\n        \/\/ Do nothing\n    } else {\n        int value = 0;\n        int p = pos;\n        if (strtod(p, value)) {\n            if (getchar(p) == 96 && getchar(p+1) == 96 && getchar(p+2) == 96) {\n\t\t\t\tmemcpy((LINE_ZERO + value) * 40, MSG_ZERO, 10);\n            } else {\n\t          memcpy((LINE_ZERO + value) * 40, pos, 40);\n            }\n        } else {\n          NL();\n          NL();\n          \/\/ ?SYNTAX ERROR\n          memcpy(screen_pos(memory[CURSOR]) - 40, MSG_SYNTAX_ERROR, 14);\n          memory[STATE].x = float(STATE_PRINT_READY);\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    copy_length = 0;\n\tint x = int(fragCoord.x);\n    int y = int(fragCoord.y);\n    if (x > 40 && y > 25) discard;\n    \n    if (iFrame < 3) {\n    \tmemory[CURSOR] = vec4(0, 5, 0, 0);\n        memory[STATE].x = float(STATE_PRINT_READY);\n    } else {\n\t    for (int i = 0; i < MEMORY; i++) {\n    \t\tmemory[i] = peek(i + 40, 0);\n            old_memory[i] = memory[i];\n   \t\t}\n    } \n\n    fragColor = peek(x, y);\n\n    if (memory[STATE].x == float(STATE_LISTING)) {\n        int line = int(memory[STATE].y);\n        memory[STATE].x = float(STATE_PRINT_READY_NL);\n        \n        for (int i = 0; i < 50; i++) {\n            if (getchar(0, LINE_ZERO + line + i) != 0) {\n                memory[STATE].x = float(STATE_LISTING);\n                memory[STATE].y = float(line + i + 1);\n                NL();\n                memcpy(screen_pos(memory[CURSOR]) - 40, 40 * (LINE_ZERO + line + i), 40);\n                break;\n            }\n        }\n    } else if (memory[STATE].x == float(STATE_RUNNING)) {\n        bool esc = texture(iChannel1, vec2(27.5 \/ 256.0, 0.5\/3.0)).x > 0.5;\n        if (esc) {\n            NL();\n            memory[STATE].x = float(STATE_BREAK);\n        } else {\n           \tint line = int(memory[STATE].y);\n\t        memory[STATE].x = float(STATE_PRINT_READY_NL);\n        \n    \t    for (int i = 0; i < 50; i++) {\n        \t    if (getchar(0, LINE_ZERO + line + i) != 0) {\n            \t    memory[STATE].x = float(STATE_RUNNING);\n                \tmemory[STATE].y = float(line + i + 1);\n    \t            int pos = 40 * (LINE_ZERO + line + i);\n\t                skipnum(pos);\n        \t        parse(pos);\n            \t    break;\n        \t    }\n     \t   }\n        }\n    } else if (memory[STATE].x == float(STATE_BREAK)) {\n  \t\tmemory[STATE].x = float(STATE_PRINT_READY);\n        print(MSG_BREAK, 12);\n    } else if (memory[STATE].x == float(STATE_PRINT_READY)) {\n  \t\tmemory[STATE].x = float(STATE_READY);\n        print(MSG_READY, 6);\n    } else if (memory[STATE].x == float(STATE_PRINT_READY_NL)) {\n  \t\tmemory[STATE].x = float(STATE_READY);\n        NL();\n        print(MSG_READY, 6);\n    } else {\n \t   bool shift = texture(iChannel1, vec2(16.5 \/ 256.0, 0.5\/3.0)).x > 0.5;\n\n    \tfor (int key = 0; key < 64; key++) {\n        \tfloat key_val = texture(iChannel1, vec2((float(key) + 32.5)\/256.0, 0.5)).x;\n\t        if (key_val > 0.6) {\n    \t        if (key > 32)\n        \t        putc(key - 32 + (shift ? 64 : 0));\n            \telse if (key == 0)\n                \tputc(96);\n\t            else if (key >= 16)\n    \t            putc(key + 32 + (shift ? -16 : 0));\n        \t}\n \t   }\n    \n  \t  if (texture(iChannel1, vec2(13.5\/256.0, 0.5)).x > 0.6) {\n          int y = int(memory[CURSOR].y);\n    \t    NL();\n     \t   parse(y * 40);\n  \t      \/\/ Enter\n  \t  }\n        if (texture(iChannel1, vec2(8.5\/256.0, 0.5)).x > 0.6) {\n            int x = int(memory[CURSOR].x);\n            if (x > 0) {\n                x = x - 1;\n                int p = screen_pos(memory[CURSOR]);\n                memcpy(p - 1, p, 40 - x);\n                memory[CURSOR].x = float(x);\n            }\n        }\n    }\n     \n    if (x >= 0 && x < 40 && y >=0 && y < 20) {\n      if (iFrame < 2) {\n        init_screen(fragColor, x, y);\n        return;\n      }\n      fragColor = peek(x, y + scroll);\n      int sp = x + y * 40;\n      \n      if (sp + 40 * scroll == screen_pos(old_memory[CURSOR])) {\n          fragColor.x = mod(fragColor.x, 128.0);\n          if (key != -1)\n          {\n              fragColor.x = float(key);\n          }\n      }\n\n      if (sp == screen_pos(memory[CURSOR])) {\n          if (fract(iTime) > 0.5) {\n            fragColor.x += 128.0;\n         }\n      }\n      copy(sp, fragColor);\n      return;\n    }\n    copy(x + y * 40, fragColor);\n    if (x >= 0 && x < 40 && y >= 20 && y <= 25) {\n       fragColor = vec4(96, 14, 6, 0);\n    }\n    if (y == 0) {\n \t\tfor (int i = 0; i < MEMORY; i++) {\n \t    \tif (i + 40 == x) {\n\t\t\t\tfragColor = memory[i];\n            \treturn;\n          \t}\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsfGRn","filepath":"\/media\/a\/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"\/media\/ap\/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"\/presets\/tex00.jpg","previewfilepath":"\/presets\/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\/\/ Meta CRT - @P_Malin\n\/\/ https:\/\/www.shadertoy.com\/view\/4dlyWX#\n\/\/ In which I add and remove aliasing\n\n\/\/ Screen image rendering\n\n\n\/\/ https:\/\/www.shadertoy.com\/view\/lslGDn\n#define SHADERTOY\n\n\/\/ Commodore 64 by hubbe\n\/\/ https:\/\/www.shadertoy.com\/view\/Xs3XW4\n\/\/#define C64\n\n\/\/ https:\/\/www.shadertoy.com\/view\/lsl3Rn\n\/\/#define SPECTRUM\n\n\/\/ https:\/\/www.shadertoy.com\/view\/MdsGzr\n\/\/#define ELITE\n\n\/\/ https:\/\/www.shadertoy.com\/view\/4lG3Wz\n\/\/#define MANDELBROT\n\n#ifdef ELITE\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Settings\n\n#define EMULATE_8BIT\n\n#ifdef EMULATE_8BIT\n\t#define LIMIT_FRAMERATE\n\t\/\/#define SCANLINE_EFFECT\n\t#define NON_AA_LINES\n\t#define LOW_RESOLUTION\n\t#define XOR_PIXELS\n#endif\n\n#ifndef NON_AA_LINES\n#ifdef XOR_PIXELS\n#undef XOR_PIXELS\n#endif\n#endif\n\nfloat kFramesPerSecond = 7.5;\n\n#ifdef LOW_RESOLUTION\nvec2 kWindowResolution = vec2(256.0, 192.0);\n#else\nvec2 kWindowResolution = iResolution.xy;\n#endif\n\nfloat kAALineWidth = 1.0;\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Time\n\nfloat GetSceneTime()\n{\n\t#ifdef LIMIT_FRAMERATE\n\t\treturn (floor(iTime * kFramesPerSecond) \/ kFramesPerSecond);\n\t#else\n\t\treturn iTime;\n\t#endif\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Line Rasterization\n\n#ifdef NON_AA_LINES\nfloat RasterizeLine(const in vec2 vPixel, const in vec2 vA, const in vec2 vB)\n{\n\t\/\/ vPixel is the centre of the pixel to be rasterized\n\t\n\tvec2 vAB = vB - vA;\t\n\tvec2 vAbsAB = abs(vAB);\n\tfloat fGradientSelect = step(vAbsAB.y, vAbsAB.x);\n\n\tvec2 vAP = vPixel - vA;\n\n\tfloat fAB = mix(vAB.y, vAB.x, fGradientSelect);\n\tfloat fAP = mix(vAP.y, vAP.x, fGradientSelect);\n\t\n\t\/\/ figure out the co-ordinates we intersect the vPixelCentre x or y axis\n\tfloat t = fAP \/ fAB;\t\n\tvec2 vIntersection = vA + (vB - vA) * t;\n\tvec2 vIntersectionDist = abs(vIntersection - vPixel);\n\t\n\tvec2 vResult = step(vIntersectionDist, vec2(0.5));\n\n\t\/\/ mask out parts of the line beyond the beginning or end\n\tfloat fClipSpan = step(t, 1.0) * step(0.0, t);\t\n\t\n\t\/\/ select the x or y axis result based on the gradient of the line\n\treturn mix(vResult.x, vResult.y, fGradientSelect) * fClipSpan;\n}\n#else\nfloat RasterizeLine(const in vec2 vPixel, const in vec2 vA, const in vec2 vB)\n{\n\t\/\/ AA version based on distance to line\n\t\n\t\/\/ vPixel is the co-ordinate within the pixel to be rasterized\n\t\n\tvec2 vAB = vB - vA;\t\n\tvec2 vAP = vPixel - vA;\n\t\n\tvec2 vDir = normalize(vAB);\n\tfloat fLength = length(vAB);\n\t\n\tfloat t = clamp(dot(vDir, vAP), 0.0, fLength);\n\tvec2 vClosest = vA + t * vDir;\n\t\n\tfloat fDistToClosest = 1.0 - (length(vClosest - vPixel) \/ kAALineWidth);\n\n\tfloat i =  clamp(fDistToClosest, 0.0, 1.0);\n\t\n\treturn sqrt(i);\n}\n#endif\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Matrix Fun\n\nmat4 SetRotTrans( vec3 r, vec3 t )\n{\n    float a = sin(r.x); float b = cos(r.x); \n    float c = sin(r.y); float d = cos(r.y); \n    float e = sin(r.z); float f = cos(r.z); \n\n    float ac = a*c;\n    float bc = b*c;\n\n    return mat4( d*f,      d*e,       -c, 0.0,\n                 ac*f-b*e, ac*e+b*f, a*d, 0.0,\n                 bc*f+a*e, bc*e-a*f, b*d, 0.0,\n                 t.x,      t.y,      t.z, 1.0 );\n}\n\nmat4 SetProjection( float d )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, d,\n\t\t\t\t 0.0, 0.0, 0.0, 0.0 );\n}\n\nmat4 SetWindow( vec2 s, vec2 t )\n{\n    return mat4( s.x, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, s.y, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t t.x, t.y, 0.0, 1.0 );\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Window Border Setup\n\nconst vec2 kWindowMin = vec2(0.1, 0.1);\nconst vec2 kWindowMax = vec2(0.9, 0.9);\nconst vec2 kWindowRange = kWindowMax - kWindowMin;\n\nvec2 ScreenUvToWindowPixel(vec2 vUv)\n{\n\t#ifdef LOW_RESOLUTION\n\t\tvUv = ((vUv - kWindowMin) \/ kWindowRange);\n\t#endif\n\treturn vUv * kWindowResolution;\n}\n\nfloat IsPixelInWindow(vec2 vPixel)\n{\n\tvec2 vResult = step(vPixel, kWindowResolution)\n\t\t\t\t* step(vec2(0.0), vPixel);\n\treturn min(vResult.x, vResult.y);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nconst int kVertexCount = 30;\nvec3 kVertices[kVertexCount];\n\nvoid SetupVertices()\n{\n\tkVertices[0] = vec3(40, 0.0, 95);\n    kVertices[1] = vec3(-40, 0.0, 95);\n    kVertices[2] = vec3(00, 32.5, 30);\n    kVertices[3] = vec3(-150,-3.8,-10);\n    kVertices[4] = vec3(150,-3.8,-10);\n    kVertices[5] = vec3(-110, 20,-50);\n    kVertices[6] = vec3(110, 20,-50);\n    kVertices[7] = vec3(160,-10,-50);\n    kVertices[8] = vec3(-160,-10,-50);\n    kVertices[9] = vec3(0, 32.5,-50);\n    kVertices[10] = vec3(-40,-30,-50);\n    kVertices[11] = vec3(40,-30,-50);\n    kVertices[12] = vec3(-45, 10,-50);\n    kVertices[13] = vec3(-10, 15,-50);\n    kVertices[14] = vec3( 10, 15,-50);\n    kVertices[15] = vec3(45, 10,-50);      \n    kVertices[16] = vec3(45,-15,-50);\n    kVertices[17] = vec3(10,-20,-50);\n    kVertices[18] = vec3(-10,-20,-50);\n    kVertices[19] = vec3(-45,-15,-50);\n    kVertices[20] = vec3(-2,-2, 95);\n    kVertices[21] = vec3(-2,-2, 112.5);\n    kVertices[22] = vec3(-100,-7.5,-50);\n    kVertices[23] = vec3(-100, 7.5,-50);\n    kVertices[24] = vec3(-110, 0,-50);\n    kVertices[25] = vec3( 100, 7.5,-50);\n    kVertices[26] = vec3( 110, 0,-50);\n    kVertices[27] = vec3( 100,-7.5,-50);\n    kVertices[28] = vec3(  0,0, 95);\n    kVertices[29] = vec3(  0,0, 112.5);    \n}\n\nfloat BackfaceCull(vec2 A, vec2 B, vec2 C)\n{\n\tvec2 AB = B - A;\n\tvec2 AC = C - A;\n\tfloat c = AB.x * AC.y - AB.y * AC.x;\n\treturn step(c, 0.0);\n}\n\nfloat Accumulate( const float x, const float y )\n{\n#ifdef XOR_PIXELS\n\treturn x + y;\n#else\n\treturn max(x, y);\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n\t\n\t\/\/ get window pixel co-ordinates for centre of current pixel\n\tvec2 vWindowPixelCords = ScreenUvToWindowPixel(uv);\n\tvec2 vPixel = floor(vWindowPixelCords) + 0.5;\n\t\n\t\/\/ Setup Transform\n\tmat4 mTransform;\n\n\t{\n\t\tvec3 vRot = vec3(0.1, 0.2, 0.3) * GetSceneTime();\n\t\t\n\t\t\/*if(iMouse.z > 0.0)\n\t\t{\n\t\t\tvec2 vUnitMouse = iMouse.xy \/ iResolution.xy;\n\t\t\tvRot= vec3(vUnitMouse.yx * vec2(1.0, 1.0) + vec2(1.5, 0.5), 0.0) * 3.14159 * 2.0;\n\t\t}*\/\n\t\t\n\t\tvec3 vTrans = vec3(0.0, 0.0, 350.0);\n\t\tmat4 mRotTrans = SetRotTrans( vRot, vTrans );\n\t\tmat4 mProjection = SetProjection( 1.0 );\n\t\tmat4 mWindow = SetWindow( vec2(1.0, iResolution.x\/iResolution.y) * kWindowResolution, vec2(0.5) * kWindowResolution );\n\t\n\t\tmTransform = mWindow * mProjection * mRotTrans;\n\t}\n\n\t\/\/ Transform Vertices to Window Pixel Co-ordinates\n\tSetupVertices();\n\t\n\tvec2 vScrVtx[kVertexCount];\n\tfor(int i=0; i<kVertexCount; i++)\n\t{\n\t\tvec4 vhPos = mTransform * vec4(kVertices[i], 1.0);\n\t\tvScrVtx[i] = vhPos.xy \/ vhPos.w;\n\t}\n\n\t\/\/ Cull Faces\n\tconst int kFaceCount = 14;\n\tfloat fFaceVisible[kFaceCount];\n\t\n\t\/\/ hull \n\tfFaceVisible[0] = BackfaceCull( vScrVtx[2], vScrVtx[1], vScrVtx[0] );\n\tfFaceVisible[1] = BackfaceCull( vScrVtx[0], vScrVtx[1], vScrVtx[10] );\n\tfFaceVisible[2] = BackfaceCull( vScrVtx[6], vScrVtx[2], vScrVtx[0] );\n\tfFaceVisible[3] = BackfaceCull( vScrVtx[0], vScrVtx[4], vScrVtx[6] );\n\tfFaceVisible[4] = BackfaceCull( vScrVtx[0], vScrVtx[11], vScrVtx[7] );\n\tfFaceVisible[5] = BackfaceCull( vScrVtx[1], vScrVtx[2], vScrVtx[5] );\n\n\tfFaceVisible[6] = BackfaceCull( vScrVtx[5], vScrVtx[3], vScrVtx[1] );\n\tfFaceVisible[7] = BackfaceCull( vScrVtx[1], vScrVtx[3], vScrVtx[8] );\n\tfFaceVisible[8] = BackfaceCull( vScrVtx[5], vScrVtx[2], vScrVtx[9] );\n\tfFaceVisible[9] = BackfaceCull( vScrVtx[2], vScrVtx[6], vScrVtx[9] );\n\tfFaceVisible[10] = BackfaceCull( vScrVtx[5], vScrVtx[8], vScrVtx[3] );\n\tfFaceVisible[11] = BackfaceCull( vScrVtx[7], vScrVtx[6], vScrVtx[4] );\n\tfFaceVisible[12] = BackfaceCull( vScrVtx[9], vScrVtx[6], vScrVtx[7] );\n\t\n\t\/\/ engines - all culled together\n\tfFaceVisible[13] = BackfaceCull( vScrVtx[14], vScrVtx[15], vScrVtx[16] );\n\n\t\/\/ Draw Lines\n\t\n\tfloat fResult = 0.0;\n\t\n\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[0], vScrVtx[2]) * max(fFaceVisible[0], fFaceVisible[2]));\n\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[0], vScrVtx[4]) * max(fFaceVisible[3], fFaceVisible[4]));\n\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[0], vScrVtx[6]) * max(fFaceVisible[2], fFaceVisible[3]));\n\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[1], vScrVtx[0]) * max(fFaceVisible[0], fFaceVisible[1]));\n\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[1], vScrVtx[10]) * max(fFaceVisible[1], fFaceVisible[7]));\n\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[2], vScrVtx[1]) * max(fFaceVisible[0], fFaceVisible[5]));\n\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[2], vScrVtx[5]) * max(fFaceVisible[5], fFaceVisible[8]));\n\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[2], vScrVtx[9]) * max(fFaceVisible[8], fFaceVisible[9]));\n\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[3], vScrVtx[1]) * max(fFaceVisible[6], fFaceVisible[7]));\n\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[3], vScrVtx[8]) * max(fFaceVisible[7], fFaceVisible[10]));\n\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[4], vScrVtx[6]) * max(fFaceVisible[3], fFaceVisible[11]));\n\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[5], vScrVtx[1]) * max(fFaceVisible[5], fFaceVisible[6]));\n\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[5], vScrVtx[3]) * max(fFaceVisible[6], fFaceVisible[10]));\n\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[5], vScrVtx[8]) * max(fFaceVisible[10], fFaceVisible[12]));\n\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[6], vScrVtx[2]) * max(fFaceVisible[2], fFaceVisible[9]));\n\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[6], vScrVtx[9]) * max(fFaceVisible[9], fFaceVisible[12]));\n\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[7], vScrVtx[4]) * max(fFaceVisible[4], fFaceVisible[11]));\n\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[7], vScrVtx[6]) * max(fFaceVisible[11], fFaceVisible[12]));\n\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[8], vScrVtx[10]) * max(fFaceVisible[7], fFaceVisible[12]));\n\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[9], vScrVtx[5]) * max(fFaceVisible[8], fFaceVisible[12]));\n\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[10], vScrVtx[11]) * max(fFaceVisible[1], fFaceVisible[12]));\n\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[11], vScrVtx[0]) * max(fFaceVisible[1], fFaceVisible[4]));\n\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[11], vScrVtx[7]) * max(fFaceVisible[4], fFaceVisible[12]));\n\n\tif(fFaceVisible[13] > 0.0)\t\n\t{\n\t\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[12], vScrVtx[13] ));\n\t\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[13], vScrVtx[18] ));\n\t\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[14], vScrVtx[15] ));\n\t\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[15], vScrVtx[16] ));\n\t\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[16], vScrVtx[17] ));\n\t\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[17], vScrVtx[14] ));\n\t\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[18], vScrVtx[19] ));\n\t\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[19], vScrVtx[12] ));\n\t\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[25], vScrVtx[26] ));\n\t\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[26], vScrVtx[27] ));\n\t\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[27], vScrVtx[25] ));\n\t\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[22], vScrVtx[23] ));\n\t\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[23], vScrVtx[24] ));\n\t\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[24], vScrVtx[22] ));\n\t}\n\t\n\t\/\/ gun\n\tfResult = Accumulate(fResult, RasterizeLine( vPixel, vScrVtx[28], vScrVtx[29]));\n\n\t#ifdef XOR_PIXELS\t\n\tfResult = mod(fResult, 2.0);\n\t#endif\n\t\n\t\/\/ Clip pixel to window border\n\tfResult *= IsPixelInWindow(vPixel);\n\t\n\t\/\/ Scanline Effect\n\t#ifdef SCANLINE_EFFECT\t\n\t\tfloat fScanlineEffect = cos((vWindowPixelCords.y + 0.5) * 3.1415 * 2.0) * 0.5 + 0.5;\n\t\tfResult = (fResult * 0.9 + 0.1) * (fScanlineEffect * 0.2 + 0.8);\n\t#endif\n\t\t\n\tfragColor = vec4(vec3(fResult),1.0);\n}\n\n#endif\n\n#ifdef SPECTRUM\n\n\/\/ Screen Image - @P_Malin\n\n\/\/#define LOADING_LOOP\n \nvec2 kResolution = vec2(256.0, 192.0);\n \n\/\/ Border phases\n\nconst float kPhaseBlank = 0.0;\nconst float kPhaseSilent = 1.0;\nconst float kPhaseHeader = 2.0;\nconst float kPhaseData = 3.0;\nconst float kPhaseRunning = 4.0;\n \n\/\/ Loading phases\n\nconst vec3 vTimeSilent1  = vec3(1.0,\t5.0,                       kPhaseSilent);\nconst vec3 vTimeHeader1  = vec3(2.0,  vTimeSilent1.y + 2.0,      kPhaseHeader);\nconst vec3 vTimeData1    = vec3(3.0,  vTimeHeader1.y + 0.125,    kPhaseData);\n \nconst vec3 vTimeBlank2   = vec3(4.0,  vTimeData1.y + 1.0,        kPhaseBlank);\nconst vec3 vTimeSilent2  = vec3(5.0,  vTimeBlank2.y + 2.0,       kPhaseSilent);\nconst vec3 vTimeHeader2  = vec3(6.0,  vTimeSilent2.y + 2.0,      kPhaseHeader);\nconst vec3 vTimeData2    = vec3(7.0,  vTimeHeader2.y + 1.0,      kPhaseData);\n \nconst vec3 vTimeSilent3  = vec3(8.0,  vTimeData2.y + 2.0,        kPhaseSilent);\nconst vec3 vTimeHeader3  = vec3(9.0,  vTimeSilent3.y + 2.0,      kPhaseHeader);\nconst vec3 vTimeData3    = vec3(10.0, vTimeHeader3.y + 0.125,    kPhaseData);\n \nconst vec3 vTimeSilent4  = vec3(11.0, vTimeData3.y + 2.0,        kPhaseSilent);\nconst vec3 vTimeHeader4  = vec3(12.0, vTimeSilent4.y + 2.0,      kPhaseHeader);\nconst vec3 vTimeData4    = vec3(13.0, vTimeHeader4.y + 38.0,     kPhaseData);\n \nconst vec3 vTimeRunning  = vec3(14.0, vTimeData4.y + 10.0,       kPhaseRunning);\n \nconst vec3 vTimeTotal    = vec3(15.0, vTimeRunning.y,            kPhaseBlank);\n       \nvec4 GetPhase(float fTime)\n{             \n        vec3 vResult = vTimeRunning;\n                \n        vResult = mix( vResult, vTimeData4, step(fTime, vTimeData4.y ) );\n        vResult = mix( vResult, vTimeHeader4, step(fTime, vTimeHeader4.y ) );\n        vResult = mix( vResult, vTimeSilent4, step(fTime, vTimeSilent4.y ) );\n \n        vResult = mix( vResult, vTimeData3, step(fTime, vTimeData3.y ) );\n        vResult = mix( vResult, vTimeHeader3, step(fTime, vTimeHeader3.y ) );\n        vResult = mix( vResult, vTimeSilent3, step(fTime, vTimeSilent3.y ) );\n               \n        vResult = mix( vResult, vTimeData2, step(fTime, vTimeData2.y ) );\n        vResult = mix( vResult, vTimeHeader2, step(fTime, vTimeHeader2.y ) );\n        vResult = mix( vResult, vTimeSilent2, step(fTime, vTimeSilent2.y ) );\n        vResult = mix( vResult, vTimeBlank2, step(fTime, vTimeBlank2.y ) );\n \n        vResult = mix( vResult, vTimeData1, step(fTime, vTimeData1.y ) );\n        vResult = mix( vResult, vTimeHeader1, step(fTime, vTimeHeader1.y ) );\n        vResult = mix( vResult, vTimeSilent1, step(fTime, vTimeSilent1.y ) );\n               \n        return vec4(vResult.z, vResult.x, fTime - vResult.y, vResult.y);\n}\n \nfloat GetRasterPosition(in vec2 fragCoord)\n{\n        return (fragCoord.x + fragCoord.y * iResolution.x) \/ (iResolution.x * iResolution.y);\n}\n \nfloat IsBorder(vec2 vScreenUV)\n{\n        if(vScreenUV.x < 0.0)\n                        return 1.0;\n        if(vScreenUV.x >= 1.0)\n                        return 1.0;\n        if(vScreenUV.y < 0.0)\n                        return 1.0;\n        if(vScreenUV.y >= 1.0)\n                        return 1.0;\n       \n        return 0.0;\n}\n \n \nvec3 GetBorderColour(float fPhase,in vec2 fragCoord)\n{\n\tfloat raster = GetRasterPosition(fragCoord);\n\t\n\tvec3 vCol = vec3(0.0);\n\t\n\tif(fPhase == kPhaseBlank)\n\t{                       \n\t\tvCol = vec3(1.0);           \n\t}\n\telse  \n\tif(fPhase == kPhaseSilent)\n\t{\n\t\tfloat fBlend = step(fract(iTime * 0.5), 0.5);\n\t\tvCol = mix( vec3(0.0, 1.0, 1.0), vec3(1.0, 0.0, 0.0), fBlend);           \n\t}\n\telse\n\tif(fPhase == kPhaseHeader)\n\t{\n\t\tfloat fBarSize = 12.0;\n\t\tfloat fScrollSpeed = 10.0;\n\t\tfloat fBlend = step(fract(raster * fBarSize + iTime * fScrollSpeed), 0.5);\n\t\tvCol = mix( vec3(0.0, 1.0, 1.0), vec3(1.0, 0.0, 0.0), fBlend);           \n\t}\n\telse\n\tif(fPhase == kPhaseData)\n\t{\n\t\tfloat fBarSize = 25.0;\n\t\tfloat fScrollSpeed = 1.0;\n\t\tfloat fBlend = step(fract(raster * fBarSize + iTime * fScrollSpeed + sin(iTime * 20.0 + raster * 16.0)), 0.5);\n\t\tvCol = mix(vec3(1.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0), fBlend);                     \n\t}\n\t\n\treturn vCol;\n}\n \n \nfloat GetLoadingScreenIntensity( vec2 vPos )\n{\n\tvec2 vUV = vPos \/ kResolution;\n\tfloat r = 0.25;\n\tvec2 vDist = (vUV - 0.5) \/ r;\n\tfloat len = length(vDist);\n\tvec3 vNormal = vec3(vDist.x, sqrt(1.0 - len * len), vDist.y);\n\tvec3 vLight = normalize( vec3(1.0, 1.0, -1.0) );\n\tif(len < 1.0)\n\t{\n\t\treturn max(0.0, dot(vNormal, vLight));\n\t}\n\t\n\treturn 0.7 - vUV.y * 0.6;\n}\n \nfloat CrossHatch(float fIntensity, vec2 vPos)\n{\n\tvec2 vGridPos = mod(vPos, 4.0);\n\t\n\tfloat fThreshold = fract(vGridPos.x * 0.25 + vGridPos.y * 0.5) * 0.75 + fract(vGridPos.y * 0.25 + vGridPos.x * 0.5) * 0.25;\n\t\n\treturn step(fIntensity, fThreshold);\n}\n \nfloat GetLoadingScreenPixel( vec2 vPos )\n{\n        return CrossHatch(GetLoadingScreenIntensity(vPos), vPos);\n}\n \nvec2 GetScreenPixelCoord( vec2 vScreenUV )\n{\n        vec2 vPixelPos = floor(vScreenUV * kResolution);\n        vPixelPos.y = 192.0 - vPixelPos.y;\n       \n        return vPixelPos;\n}\n \nfloat PixelAddress( vec2 vPixelPos )\n{               \n        float fBand = floor(vPixelPos.y \/ 64.0);\n       \n        float fBandPos = mod(vPixelPos.y, 64.0);\n \n        float fCharRow = mod(fBandPos, 8.0);\n        float fCharPos = floor(fBandPos \/ 8.0);\n \n        float fBytePos = floor(vPixelPos.x \/ 8.0);\n \n        float fLineTime = fBand * 64.0 + fCharRow * 8.0 + fCharPos;\n        return (fBytePos + fLineTime * (256.0 \/ 8.0));\n}\n \nfloat AttributeAddress(vec2 vCharPos)\n{             \n\tfloat kAttributeStart = 256.0 * 192.0 \/ 8.0;\n\treturn kAttributeStart + vCharPos.x + vCharPos.y * 32.0;\n}\n \nfloat GetCharByte(const in float value)\n{\n        float result = 0.0;\n        result = mix(result, 0.0, step(value, 919.0) );\n        result = mix(result, 32.0, step(value, 918.5) );\n        result = mix(result, 28.0, step(value, 914.5) );\n        result = mix(result, 0.0, step(value, 913.5) );\n        result = mix(result, 56.0, step(value, 894.5) );\n        result = mix(result, 68.0, step(value, 893.5) );\n        result = mix(result, 56.0, step(value, 890.5) );\n        result = mix(result, 0.0, step(value, 889.5) );\n        result = mix(result, 84.0, step(value, 878.5) );\n        result = mix(result, 104.0, step(value, 874.5) );\n        result = mix(result, 0.0, step(value, 873.5) );\n        result = mix(result, 56.0, step(value, 851.5) );\n        result = mix(result, 4.0, step(value, 830.5) );\n        result = mix(result, 60.0, step(value, 829.5) );\n        result = mix(result, 68.0, step(value, 828.5) );\n        result = mix(result, 60.0, step(value, 826.5) );\n        result = mix(result, 0.0, step(value, 825.5) );\n        result = mix(result, 60.0, step(value, 782.5) );\n        result = mix(result, 68.0, step(value, 781.5) );\n        result = mix(result, 60.0, step(value, 780.5) );\n        result = mix(result, 4.0, step(value, 779.5) );\n        result = mix(result, 56.0, step(value, 778.5) );\n        result = mix(result, 0.0, step(value, 777.5) );\n        result = mix(result, 60.0, step(value, 670.5) );\n        result = mix(result, 66.0, step(value, 669.5) );\n        result = mix(result, 2.0, step(value, 668.5) );\n        result = mix(result, 60.0, step(value, 667.5) );\n        result = mix(result, 64.0, step(value, 666.5) );\n        result = mix(result, 60.0, step(value, 665.5) );\n        result = mix(result, 0.0, step(value, 664.5) );\n        result = mix(result, 64.0, step(value, 646.5) );\n        result = mix(result, 124.0, step(value, 644.5) );\n        result = mix(result, 66.0, step(value, 643.5) );\n        result = mix(result, 124.0, step(value, 641.5) );\n        result = mix(result, 0.0, step(value, 640.5) );\n        result = mix(result, 60.0, step(value, 638.5) );\n        result = mix(result, 66.0, step(value, 637.5) );\n        result = mix(result, 60.0, step(value, 633.5) );\n        result = mix(result, 0.0, step(value, 632.5) );\n        result = mix(result, 66.0, step(value, 630.5) );\n        result = mix(result, 70.0, step(value, 629.5) );\n        result = mix(result, 74.0, step(value, 628.5) );\n        result = mix(result, 82.0, step(value, 627.5) );\n        result = mix(result, 98.0, step(value, 626.5) );\n        result = mix(result, 66.0, step(value, 625.5) );\n        result = mix(result, 0.0, step(value, 624.5) );\n        result = mix(result, 126.0, step(value, 614.5) );\n        result = mix(result, 64.0, step(value, 613.5) );\n        result = mix(result, 0.0, step(value, 608.5) );\n        result = mix(result, 62.0, step(value, 590.5) );\n        result = mix(result, 8.0, step(value, 589.5) );\n        result = mix(result, 62.0, step(value, 585.5) );\n        result = mix(result, 0.0, step(value, 584.5) );\n        result = mix(result, 60.0, step(value, 574.5) );\n        result = mix(result, 66.0, step(value, 573.5) );\n        result = mix(result, 78.0, step(value, 572.5) );\n        result = mix(result, 64.0, step(value, 571.5) );\n        result = mix(result, 66.0, step(value, 570.5) );\n        result = mix(result, 60.0, step(value, 569.5) );\n        result = mix(result, 0.0, step(value, 568.5) );\n        result = mix(result, 120.0, step(value, 550.5) );\n        result = mix(result, 68.0, step(value, 549.5) );\n        result = mix(result, 66.0, step(value, 548.5) );\n        result = mix(result, 68.0, step(value, 546.5) );\n        result = mix(result, 120.0, step(value, 545.5) );\n        result = mix(result, 0.0, step(value, 544.5) );\n        result = mix(result, 66.0, step(value, 526.5) );\n        result = mix(result, 126.0, step(value, 524.5) );\n        result = mix(result, 66.0, step(value, 523.5) );\n        result = mix(result, 60.0, step(value, 521.5) );\n        result = mix(result, 0.0, step(value, 520.5) );\n        result = mix(result, 16.0, step(value, 470.5) );\n        result = mix(result, 0.0, step(value, 469.5) );\n        result = mix(result, 16.0, step(value, 467.5) );\n        result = mix(result, 0.0, step(value, 466.5) );\n        return result;   \n}\n \nfloat GetBit( float fByte, float fBit )\n{\n        return mod(floor(fByte \/ pow(2.0, 7.0-fBit)), 2.0) ;\n}\n \nfloat GetCharPixel( float fChar, vec2 vPos )\n{\n        float fCharAddress = fChar * 8.0 + vPos.y;\n       \n        float fCharBin = GetCharByte(fCharAddress);\n       \n        return GetBit(fCharBin, vPos.x);\n}\n \nfloat GetProgramStringChar(float fPos)\n{\n        float fChar = 32.0;    \n        fChar = mix(fChar, 76.0, step(fPos, 12.5) );\n        fChar = mix(fChar, 83.0, step(fPos, 11.5) );\n        fChar = mix(fChar, 76.0, step(fPos, 10.5) );\n        fChar = mix(fChar, 71.0, step(fPos, 9.5) );\n        fChar = mix(fChar, 32.0, step(fPos, 8.5) );\n        fChar = mix(fChar, 58.0, step(fPos, 7.5) );\n        fChar = mix(fChar, 109.0, step(fPos, 6.5) );\n        fChar = mix(fChar, 97.0, step(fPos, 5.5) );\n        fChar = mix(fChar, 114.0, step(fPos, 4.5) );\n        fChar = mix(fChar, 103.0, step(fPos, 3.5) );\n        fChar = mix(fChar, 111.0, step(fPos, 2.5) );\n        fChar = mix(fChar, 114.0, step(fPos, 1.5) );\n        fChar = mix(fChar, 80.0, step(fPos, 0.5) );\n        return fChar;\n}\n \nfloat GetLoadingStringChar(float fPos)\n{\n        float fChar = 32.0;    \n        fChar = mix(fChar, 76.0, step(fPos, 11.0) );\n        fChar = mix(fChar, 83.0, step(fPos, 10.5) );\n        fChar = mix(fChar, 76.0, step(fPos, 9.5) );\n        fChar = mix(fChar, 71.0, step(fPos, 8.5) );\n        fChar = mix(fChar, 32.0, step(fPos, 7.5) );\n        fChar = mix(fChar, 71.0, step(fPos, 6.5) );\n        fChar = mix(fChar, 78.0, step(fPos, 5.5) );\n        fChar = mix(fChar, 73.0, step(fPos, 4.5) );\n        fChar = mix(fChar, 68.0, step(fPos, 3.5) );\n        fChar = mix(fChar, 65.0, step(fPos, 2.5) );\n        fChar = mix(fChar, 79.0, step(fPos, 1.5) );\n        fChar = mix(fChar, 76.0, step(fPos, 0.5) );\n        return fChar;\n}\n \nfloat GetProgramText(vec2 vPixelPos)\n{     \n        vec2 vCharCoord = floor(vPixelPos \/ 8.0);\n       \n        float fChar = GetProgramStringChar(vCharCoord.x);\n       \n        if(vCharCoord.y != 0.0)\n                fChar = 32.0;\n       \n        return GetCharPixel(fChar, mod(vPixelPos, 8.0));\n}\n \nfloat GetLoadingText(vec2 vPixelPos)\n{     \n        vec2 vCharCoord = floor(vPixelPos \/ 8.0);\n       \n        float fChar = GetLoadingStringChar(vCharCoord.x);\n       \n        float inString = 1.0;\n        if(vCharCoord.x < 0.0)\n                fChar = 32.0;\n       \n        if(vCharCoord.y != 0.0)\n                fChar = 32.0;\n       \n        return GetCharPixel(fChar, mod(vPixelPos, 8.0));\n}\n \nfloat GetScreenPixel(vec2 vScreenPixel)\n{\n\t\/\/ plasma thing\n\tfloat f = sin(vScreenPixel.x *0.0432 + sin(vScreenPixel.y * 0.0423)+ iTime * 3.0);\n\tf = f + sin(vScreenPixel.y * 0.0454513 + sin(vScreenPixel.x * 0.07213) + iTime * 5.0);\n\tf = f + sin(vScreenPixel.x * 0.043353 + sin(vScreenPixel.y * 0.043413) + iTime * 8.0);\n\tf = f + sin(vScreenPixel.y * 0.0443513 + sin(vScreenPixel.x * 0.036313) + iTime * 10.0);\n\tf = f * 0.125 + 0.5;\n\t\n\treturn CrossHatch(f, vScreenPixel);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{           \n\tfloat fSequenceTime = iTime;\n\t\n\t#ifdef LOADING_LOOP\n\tfSequenceTime = mod(fSequenceTime, vTimeTotal.y);\n\t#endif\n\t\n\tvec3 col = vec3(1.0);\n\t\n\tvec4 vPhase = GetPhase(fSequenceTime);\n\t\n\tvec2 vUV = ( fragCoord.xy \/ iResolution.xy );\n\tvec2 vScreenUV = (vUV - 0.1) \/ 0.8;\n\tif(IsBorder(vScreenUV) > 0.0)\n\t{\n\t\tcol = GetBorderColour(vPhase.x, fragCoord);\n\t}\n\telse\n\t{\n\t\tvec2 vScreenCoord = GetScreenPixelCoord(vScreenUV);\n\t\tvec2 vAttribCoord = floor(vScreenCoord \/ 8.0);\n\n\t\tfloat fPixelValue = 0.0;\n\t\tvec3 vInk = vec3(0.0);\n\t\tvec3 vPaper = vec3(1.0);\n\t\t\n\t\tif(vPhase.x != kPhaseRunning)\n\t\t{\n\t\t\t\/\/ loading\n\t\t\tfloat fLoadScreenTime = fSequenceTime - vTimeHeader4.y;\n\t\t\t\t\t\t\t\t\t\t       \n\t\t\tfloat fAddressLoaded = fLoadScreenTime * 192.0;\n\t\t\tif(PixelAddress(vScreenCoord) > fAddressLoaded)\n\t\t\t{\n\t\t\t\tif(vPhase.y < 4.0)\n\t\t\t\t{\n\t\t\t\t\tcol = vec3(1.0);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\tif(vPhase.y < 8.0)\n\t\t\t\t{\n\t\t\t\t\tvec2 vTextPos = vec2(0.0, 8.0);\n\t\t\t\t\tfPixelValue = GetProgramText(vScreenCoord - vTextPos);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvec2 vTextPos = vec2(10.0 * 8.0, 19.0 * 8.0);\n\t\t\t\t\tfPixelValue = GetLoadingText(vScreenCoord - vTextPos);\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t\/\/ loading screen\n\t\t\t\tfPixelValue = GetLoadingScreenPixel(vScreenCoord);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t}\n\t\t\n\t\t\tif(AttributeAddress(vAttribCoord) < fAddressLoaded)\n\t\t\t{\n\t\t\t\tvInk = vec3(0.0, 0.0, 1.0);\n\t\t\t\tvPaper = vec3(1.0, 1.0, 0.0);\n\t\t\t}\t\t\n\t\t}\n\t\telse\n\t\t{\n\t\t\t\/\/ running\n\t\t\tfPixelValue = GetScreenPixel(vScreenCoord);\n\t\t\t\n\t\t\tvec2 vTextPos = vec2(-8.0 * 8.0, 8.0);\n\t\t\tfloat fAttribValue = GetLoadingText(vAttribCoord - vTextPos );\n\t\t\tvPaper = mix(vec3(0.0, 1.0, 1.0), vec3(1.0, 0.0, 0.0), fAttribValue);\n\t\t\tvInk = vec3(0.0, 0.0, 1.0);\n\t\t}     \n\t\n\t\t\/\/fPixelValue = GetScreenPixel(vScreenCoord); \/\/ force final effect\t\t\t\n\t\t\/\/fPixelValue = GetLoadingScreenPixel( vScreenCoord); \/\/ force loading screen\n\t\n\t\tcol = mix(vPaper, vInk, fPixelValue);\n\t\t\n\t}\n\n\tfloat kBrightness = 0.8;\n\tfragColor = vec4( col * kBrightness, 1.0 );  \n}\n\n#endif\n\n#ifdef C64\nhighp vec4 font2(int c) {\n  vec4 v = vec4(0);\n  v=mix(v, vec4(0x3c66, 0x6e6e, 0x6062, 0x3c00), step(-0.500, float(c)));\n  v=mix(v, vec4(0x183c, 0x667e, 0x6666, 0x6600), step(0.500, float(c)));\n  v=mix(v, vec4(0x7c66, 0x667c, 0x6666, 0x7c00), step(1.500, float(c)));\n  v=mix(v, vec4(0x3c66, 0x6060, 0x6066, 0x3c00), step(2.500, float(c)));\n  v=mix(v, vec4(0x786c, 0x6666, 0x666c, 0x7800), step(3.500, float(c)));\n  v=mix(v, vec4(0x7e60, 0x6078, 0x6060, 0x7e00), step(4.500, float(c)));\n  v=mix(v, vec4(0x7e60, 0x6078, 0x6060, 0x6000), step(5.500, float(c)));\n  v=mix(v, vec4(0x3c66, 0x606e, 0x6666, 0x3c00), step(6.500, float(c)));\n  v=mix(v, vec4(0x6666, 0x667e, 0x6666, 0x6600), step(7.500, float(c)));\n  v=mix(v, vec4(0x3c18, 0x1818, 0x1818, 0x3c00), step(8.500, float(c)));\n  v=mix(v, vec4(0x1e0c, 0xc0c, 0xc6c, 0x3800), step(9.500, float(c)));\n  v=mix(v, vec4(0x666c, 0x7870, 0x786c, 0x6600), step(10.500, float(c)));\n  v=mix(v, vec4(0x6060, 0x6060, 0x6060, 0x7e00), step(11.500, float(c)));\n  v=mix(v, vec4(0x6377, 0x7f6b, 0x6363, 0x6300), step(12.500, float(c)));\n  v=mix(v, vec4(0x6676, 0x7e7e, 0x6e66, 0x6600), step(13.500, float(c)));\n  v=mix(v, vec4(0x3c66, 0x6666, 0x6666, 0x3c00), step(14.500, float(c)));\n  v=mix(v, vec4(0x7c66, 0x667c, 0x6060, 0x6000), step(15.500, float(c)));\n  v=mix(v, vec4(0x3c66, 0x6666, 0x663c, 0xe00), step(16.500, float(c)));\n  v=mix(v, vec4(0x7c66, 0x667c, 0x786c, 0x6600), step(17.500, float(c)));\n  v=mix(v, vec4(0x3c66, 0x603c, 0x666, 0x3c00), step(18.500, float(c)));\n  v=mix(v, vec4(0x7e18, 0x1818, 0x1818, 0x1800), step(19.500, float(c)));\n  v=mix(v, vec4(0x6666, 0x6666, 0x6666, 0x3c00), step(20.500, float(c)));\n  v=mix(v, vec4(0x6666, 0x6666, 0x663c, 0x1800), step(21.500, float(c)));\n  v=mix(v, vec4(0x6363, 0x636b, 0x7f77, 0x6300), step(22.500, float(c)));\n  v=mix(v, vec4(0x6666, 0x3c18, 0x3c66, 0x6600), step(23.500, float(c)));\n  v=mix(v, vec4(0x6666, 0x663c, 0x1818, 0x1800), step(24.500, float(c)));\n  v=mix(v, vec4(0x7e06, 0xc18, 0x3060, 0x7e00), step(25.500, float(c)));\n  v=mix(v, vec4(0x3c30, 0x3030, 0x3030, 0x3c00), step(26.500, float(c)));\n  v=mix(v, vec4(0xc12, 0x307c, 0x3062, 0xfc00), step(27.500, float(c)));\n  v=mix(v, vec4(0x3c0c, 0xc0c, 0xc0c, 0x3c00), step(28.500, float(c)));\n  v=mix(v, vec4(0x18, 0x3c7e, 0x1818, 0x1818), step(29.500, float(c)));\n  v=mix(v, vec4(0x10, 0x307f, 0x7f30, 0x1000), step(30.500, float(c)));\n  v=mix(v, vec4(0x0, 0x0, 0x0, 0x0), step(31.500, float(c)));\n  v=mix(v, vec4(0x1818, 0x1818, 0x0, 0x1800), step(32.500, float(c)));\n  v=mix(v, vec4(0x6666, 0x6600, 0x0, 0x0), step(33.500, float(c)));\n  v=mix(v, vec4(0x6666, 0xff66, 0xff66, 0x6600), step(34.500, float(c)));\n  v=mix(v, vec4(0x183e, 0x603c, 0x67c, 0x1800), step(35.500, float(c)));\n  v=mix(v, vec4(0x6266, 0xc18, 0x3066, 0x4600), step(36.500, float(c)));\n  v=mix(v, vec4(0x3c66, 0x3c38, 0x6766, 0x3f00), step(37.500, float(c)));\n  v=mix(v, vec4(0x60c, 0x1800, 0x0, 0x0), step(38.500, float(c)));\n  v=mix(v, vec4(0xc18, 0x3030, 0x3018, 0xc00), step(39.500, float(c)));\n  v=mix(v, vec4(0x3018, 0xc0c, 0xc18, 0x3000), step(40.500, float(c)));\n  v=mix(v, vec4(0x66, 0x3cff, 0x3c66, 0x0), step(41.500, float(c)));\n  v=mix(v, vec4(0x18, 0x187e, 0x1818, 0x0), step(42.500, float(c)));\n  v=mix(v, vec4(0x0, 0x0, 0x18, 0x1830), step(43.500, float(c)));\n  v=mix(v, vec4(0x0, 0x7e, 0x0, 0x0), step(44.500, float(c)));\n  v=mix(v, vec4(0x0, 0x0, 0x18, 0x1800), step(45.500, float(c)));\n  v=mix(v, vec4(0x3, 0x60c, 0x1830, 0x6000), step(46.500, float(c)));\n  v=mix(v, vec4(0x3c66, 0x6e76, 0x6666, 0x3c00), step(47.500, float(c)));\n  v=mix(v, vec4(0x1818, 0x3818, 0x1818, 0x7e00), step(48.500, float(c)));\n  v=mix(v, vec4(0x3c66, 0x60c, 0x3060, 0x7e00), step(49.500, float(c)));\n  v=mix(v, vec4(0x3c66, 0x61c, 0x666, 0x3c00), step(50.500, float(c)));\n  v=mix(v, vec4(0x60e, 0x1e66, 0x7f06, 0x600), step(51.500, float(c)));\n  v=mix(v, vec4(0x7e60, 0x7c06, 0x666, 0x3c00), step(52.500, float(c)));\n  v=mix(v, vec4(0x3c66, 0x607c, 0x6666, 0x3c00), step(53.500, float(c)));\n  v=mix(v, vec4(0x7e66, 0xc18, 0x1818, 0x1800), step(54.500, float(c)));\n  v=mix(v, vec4(0x3c66, 0x663c, 0x6666, 0x3c00), step(55.500, float(c)));\n  v=mix(v, vec4(0x3c66, 0x663e, 0x666, 0x3c00), step(56.500, float(c)));\n  v=mix(v, vec4(0x0, 0x1800, 0x18, 0x0), step(57.500, float(c)));\n  v=mix(v, vec4(0x0, 0x1800, 0x18, 0x1830), step(58.500, float(c)));\n  v=mix(v, vec4(0xe18, 0x3060, 0x3018, 0xe00), step(59.500, float(c)));\n  v=mix(v, vec4(0x0, 0x7e00, 0x7e00, 0x0), step(60.500, float(c)));\n  v=mix(v, vec4(0x7018, 0xc06, 0xc18, 0x7000), step(61.500, float(c)));\n  v=mix(v, vec4(0x3c66, 0x60c, 0x1800, 0x1800), step(62.500, float(c)));\n  v=mix(v, vec4(0x0, 0xff, 0xff00, 0x0), step(63.500, float(c)));\n  v=mix(v, vec4(0x81c, 0x3e7f, 0x7f1c, 0x3e00), step(64.500, float(c)));\n  v=mix(v, vec4(0x1818, 0x1818, 0x1818, 0x1818), step(65.500, float(c)));\n  v=mix(v, vec4(0x0, 0xff, 0xff00, 0x0), step(66.500, float(c)));\n  v=mix(v, vec4(0x0, 0xffff, 0x0, 0x0), step(67.500, float(c)));\n  v=mix(v, vec4(0xff, 0xff00, 0x0, 0x0), step(68.500, float(c)));\n  v=mix(v, vec4(0x0, 0x0, 0xffff, 0x0), step(69.500, float(c)));\n  v=mix(v, vec4(0x3030, 0x3030, 0x3030, 0x3030), step(70.500, float(c)));\n  v=mix(v, vec4(0xc0c, 0xc0c, 0xc0c, 0xc0c), step(71.500, float(c)));\n  v=mix(v, vec4(0x0, 0xe0, 0xf038, 0x1818), step(72.500, float(c)));\n  v=mix(v, vec4(0x1818, 0x1c0f, 0x700, 0x0), step(73.500, float(c)));\n  v=mix(v, vec4(0x1818, 0x38f0, 0xe000, 0x0), step(74.500, float(c)));\n  v=mix(v, vec4(0xc0c0, 0xc0c0, 0xc0c0, 0xffff), step(75.500, float(c)));\n  v=mix(v, vec4(0xc0e0, 0x7038, 0x1c0e, 0x703), step(76.500, float(c)));\n  v=mix(v, vec4(0x307, 0xe1c, 0x3870, 0xe0c0), step(77.500, float(c)));\n  v=mix(v, vec4(0xffff, 0xc0c0, 0xc0c0, 0xc0c0), step(78.500, float(c)));\n  v=mix(v, vec4(0xffff, 0x303, 0x303, 0x303), step(79.500, float(c)));\n  v=mix(v, vec4(0x3c, 0x7e7e, 0x7e7e, 0x3c00), step(80.500, float(c)));\n  v=mix(v, vec4(0x0, 0x0, 0xff, 0xff00), step(81.500, float(c)));\n  v=mix(v, vec4(0x367f, 0x7f7f, 0x3e1c, 0x800), step(82.500, float(c)));\n  v=mix(v, vec4(0x6060, 0x6060, 0x6060, 0x6060), step(83.500, float(c)));\n  v=mix(v, vec4(0x0, 0x7, 0xf1c, 0x1818), step(84.500, float(c)));\n  v=mix(v, vec4(0xc3e7, 0x7e3c, 0x3c7e, 0xe7c3), step(85.500, float(c)));\n  v=mix(v, vec4(0x3c, 0x7e66, 0x667e, 0x3c00), step(86.500, float(c)));\n  v=mix(v, vec4(0x1818, 0x6666, 0x1818, 0x3c00), step(87.500, float(c)));\n  v=mix(v, vec4(0x606, 0x606, 0x606, 0x606), step(88.500, float(c)));\n  v=mix(v, vec4(0x81c, 0x3e7f, 0x3e1c, 0x800), step(89.500, float(c)));\n  v=mix(v, vec4(0x1818, 0x18ff, 0xff18, 0x1818), step(90.500, float(c)));\n  v=mix(v, vec4(0xc0c0, 0x3030, 0xc0c0, 0x3030), step(91.500, float(c)));\n  v=mix(v, vec4(0x1818, 0x1818, 0x1818, 0x1818), step(92.500, float(c)));\n  v=mix(v, vec4(0x0, 0x33e, 0x7636, 0x3600), step(93.500, float(c)));\n  v=mix(v, vec4(0xff7f, 0x3f1f, 0xf07, 0x301), step(94.500, float(c)));\n  v=mix(v, vec4(0x0, 0x0, 0x0, 0x0), step(95.500, float(c)));\n  v=mix(v, vec4(0xf0f0, 0xf0f0, 0xf0f0, 0xf0f0), step(96.500, float(c)));\n  v=mix(v, vec4(0x0, 0x0, 0xffff, 0xffff), step(97.500, float(c)));\n  v=mix(v, vec4(0xff00, 0x0, 0x0, 0x0), step(98.500, float(c)));\n  v=mix(v, vec4(0x0, 0x0, 0x0, 0xff), step(99.500, float(c)));\n  v=mix(v, vec4(0xc0c0, 0xc0c0, 0xc0c0, 0xc0c0), step(100.500, float(c)));\n  v=mix(v, vec4(0xcccc, 0x3333, 0xcccc, 0x3333), step(101.500, float(c)));\n  v=mix(v, vec4(0x303, 0x303, 0x303, 0x303), step(102.500, float(c)));\n  v=mix(v, vec4(0x0, 0x0, 0xcccc, 0x3333), step(103.500, float(c)));\n  v=mix(v, vec4(0xfffe, 0xfcf8, 0xf0e0, 0xc080), step(104.500, float(c)));\n  v=mix(v, vec4(0x303, 0x303, 0x303, 0x303), step(105.500, float(c)));\n  v=mix(v, vec4(0x1818, 0x181f, 0x1f18, 0x1818), step(106.500, float(c)));\n  v=mix(v, vec4(0x0, 0x0, 0xf0f, 0xf0f), step(107.500, float(c)));\n  v=mix(v, vec4(0x1818, 0x181f, 0x1f00, 0x0), step(108.500, float(c)));\n  v=mix(v, vec4(0x0, 0xf8, 0xf818, 0x1818), step(109.500, float(c)));\n  v=mix(v, vec4(0x0, 0x0, 0x0, 0xffff), step(110.500, float(c)));\n  v=mix(v, vec4(0x0, 0x1f, 0x1f18, 0x1818), step(111.500, float(c)));\n  v=mix(v, vec4(0x1818, 0x18ff, 0xff00, 0x0), step(112.500, float(c)));\n  v=mix(v, vec4(0x0, 0xff, 0xff18, 0x1818), step(113.500, float(c)));\n  v=mix(v, vec4(0x1818, 0x18f8, 0xf818, 0x1818), step(114.500, float(c)));\n  v=mix(v, vec4(0xc0c0, 0xc0c0, 0xc0c0, 0xc0c0), step(115.500, float(c)));\n  v=mix(v, vec4(0xe0e0, 0xe0e0, 0xe0e0, 0xe0e0), step(116.500, float(c)));\n  v=mix(v, vec4(0x707, 0x707, 0x707, 0x707), step(117.500, float(c)));\n  v=mix(v, vec4(0xffff, 0x0, 0x0, 0x0), step(118.500, float(c)));\n  v=mix(v, vec4(0xffff, 0xff00, 0x0, 0x0), step(119.500, float(c)));\n  v=mix(v, vec4(0x0, 0x0, 0xff, 0xffff), step(120.500, float(c)));\n  v=mix(v, vec4(0x303, 0x303, 0x303, 0xffff), step(121.500, float(c)));\n  v=mix(v, vec4(0x0, 0x0, 0xf0f0, 0xf0f0), step(122.500, float(c)));\n  v=mix(v, vec4(0xf0f, 0xf0f, 0x0, 0x0), step(123.500, float(c)));\n  v=mix(v, vec4(0x1818, 0x18f8, 0xf800, 0x0), step(124.500, float(c)));\n  v=mix(v, vec4(0xf0f0, 0xf0f0, 0x0, 0x0), step(125.500, float(c)));\n  v=mix(v, vec4(0xf0f0, 0xf0f0, 0xf0f, 0xf0f), step(126.500, float(c)));\n  return v;\n}\n\nhighp vec4 font(int c) {\n    if (c < 128) return font2(c);\n    return vec4(0xffff) - font2(c - 128);\n}\n\nvec4 colors(int c) {\n    if (c ==  0) return vec4(0x00,0x00,0x00,1);\n    if (c ==  1) return vec4(0xFF,0xFF,0xFF,1);\n    if (c ==  2) return vec4(0x68,0x37,0x2B,1);\n    if (c ==  3) return vec4(0x70,0xA4,0xB2,1);\n    if (c ==  4) return vec4(0x6F,0x3D,0x86,1);\n    if (c ==  5) return vec4(0x58,0x8D,0x43,1);\n    if (c ==  6) return vec4(0x35,0x28,0x79,1);\n    if (c ==  7) return vec4(0xB8,0xC7,0x6F,1);\n    if (c ==  8) return vec4(0x6F,0x4F,0x25,1);\n    if (c ==  9) return vec4(0x43,0x39,0x00,1);\n    if (c == 10) return vec4(0x9A,0x67,0x59,1);\n    if (c == 11) return vec4(0x44,0x44,0x44,1);\n    if (c == 12) return vec4(0x6C,0x6C,0x6C,1);\n    if (c == 13) return vec4(0x9A,0xD2,0x84,1);\n    if (c == 14) return vec4(0x6C,0x5E,0xB5,1);\n    if (c == 15) return vec4(0x95,0x95,0x95,1);\n    return vec4(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    uv = uv * 1.1 - 0.05;\n    if ( any( lessThan( uv, vec2(0) ) ) || any( greaterThanEqual( uv, vec2(1) ) ) )\n    {\n        fragColor = colors(14) \/ 180.0;\n        return;\n    }\n    vec2 sz = vec2(40.0, 20.0);\n    vec2 fb_pos = floor(uv * sz) + vec2(0.5, 0.5);\n    fb_pos.y = sz.y - fb_pos.y;\n    fb_pos \/= iResolution.xy;\n    \n\tvec4 fb = texture(iChannel0, fb_pos);\n    highp vec4 char = font(int(fb.x));\n\n    vec2 p = mod(uv * sz * 8.0, 8.0);\n\tint line = 7 - int(p.y);\n    highp float pixels = 0.0;\n    if (line == 0) pixels = char.x \/ 256.0;\n    if (line == 1) pixels = char.x;\n    if (line == 2) pixels = char.y \/ 256.0;\n    if (line == 3) pixels = char.y;\n    if (line == 4) pixels = char.z \/ 256.0;\n    if (line == 5) pixels = char.z;\n    if (line == 6) pixels = char.w \/ 256.0;\n    if (line == 7) pixels = char.w;\n\n    if (mod(pixels * pow(2.0, floor(p.x)), 256.0) > 127.5) {\n        fragColor = colors(int(fb.y)) \/ 180.0;\n    } else {\n        fragColor = colors(int(fb.z)) \/ 180.0;\n    }\n}\n#endif\n\n#ifdef MANDELBROT\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Keyboard\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nconst float KEY_SPACE = 32.5\/256.0;\nconst float KEY_LEFT  = 37.5\/256.0;\nconst float KEY_UP    = 38.5\/256.0;\nconst float KEY_RIGHT = 39.5\/256.0;\nconst float KEY_DOWN  = 40.5\/256.0;\n\nconst float KEY_PLUS \t= 187.5\/256.0;\nconst float KEY_MINUS  \t= 189.5\/256.0;\n\nbool Key_IsPressed(float key)\n{\n    return texture( iChannel1, vec2(key, 0.0) ).x > 0.0;\n}\n\nbool Key_IsToggled(float key)\n{\n    return texture( iChannel1, vec2(key, 1.0) ).x > 0.0;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\nfloat VGARainbowChannel( float i, float a, float b, float c, float d, float e )\n{    \n    if ( i >= 8.0 ) i = 16.0 - i;\n    if ( i <= 0.0 ) return a;\n    if ( i == 1.0 ) return b;\n    if ( i == 2.0 ) return c;\n    if ( i == 3.0 ) return d;\n    if ( i >= 4.0 ) return e;\n    return a;\n}\n\nvec3 VGARainbow( float i, float a, float e )\n{\n    vec3 vi = mod( vec3( i ) + vec3(0,16,8), vec3(24) );\n\n    float b = floor(a * 3.\/4. + e * 1.0 \/ 4.0 + 0.25);\n    float c = floor(a * 2.\/4. + e * 2.0 \/ 4.0 + 0.25);\n    float d = floor(a * 1.\/4. + e * 3.0 \/ 4.0 + 0.25);\n    \n    vec3 col;\n    col.r = VGARainbowChannel( vi.r, a, b, c, d, e );\n    col.g = VGARainbowChannel( vi.g, a, b, c, d, e );\n    col.b = VGARainbowChannel( vi.b, a, b, c, d, e );\n\n    return col;\n}\n\nvec3 VGAPaletteEntry( float i )\n{\n    i = floor( i );\n    \n    \/\/ EGA\n    if ( i < 16.0 )\n    {\n        vec3 col;\n        col.b  = floor( mod( i \/ 1.0, 2.0  )) * 2.0;\n        col.g  = floor( mod( i \/ 2.0, 2.0  )) * 2.0;\n        col.r  = floor( mod( i \/ 4.0, 2.0  )) * 2.0;        \n        \n        col += floor( mod( i \/ 8.0, 2.0  ) );\n        \n        if ( i == 6.0 ) col = vec3(2,1,0); \/\/ Special brown!\n\n        return col * 21.;\n    }\n\n    \/\/ Greys\n    if ( i == 16.0 ) return vec3(0.0);\n    \n    if ( i < 32.0 )\n    {        \n        float x = (i - 17.0);        \n        return vec3( floor( .00084 * x * x * x * x - .01662 * x * x * x + .1859 * x * x + 2.453 * x + 5.6038 ) );\n    }\n    \n    \/\/ Rainbows\n    float rainbowIndex = mod( i - 32.0, 24.0 );\n    float rainbowType = floor( (i - 32.0) \/ 24.0 );\n    \n    float rainbowTypeMod = floor( mod( rainbowType, 3.0 ) );\n    float rainbowTypeDiv = floor( rainbowType \/ 3.0 );\n    \n    float rainbowLow = 0.;\n    if ( rainbowTypeMod == 1.0 ) rainbowLow = 31.0;\n    if ( rainbowTypeMod == 2.0 ) rainbowLow = 45.0;\n    \n    float rainbowHigh = 63.;\n    if ( rainbowTypeDiv == 1.0 )\n    {\n        rainbowHigh = 28.0;\n        rainbowLow = floor( rainbowLow \/ 2.2 );\n    }\n    if ( rainbowTypeDiv == 2.0 )\n    {\n        rainbowHigh = 16.0;\n        rainbowLow = floor( rainbowLow \/ 3.8 );\n    }\n    \n    if ( rainbowType < 9.0 )\n    {\n\t    return VGARainbow( rainbowIndex, rainbowLow, rainbowHigh );\n    }\n    \n    return vec3( 0.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vUV = fragCoord.xy \/ iResolution.xy;\n    \n    vec2 vFakeResolution = vec2(640,480);\n    vUV = floor(vUV * vFakeResolution) \/ vFakeResolution;\n    \n    vec2 vFocus = vec2(-0.5, 0.0);\n    vec2 vScale = vec2(2.0);\n    \n    if ( false )  \/\/ disable mouse control\n    if ( iMouse.z > 0.0 )\n    {\n    \tvFocus += 2.0 * ((iMouse.xy \/ iResolution.xy) * 2.0 - 1.0);\n    \tvScale *= 0.02;\n    }\n    \n    vScale.y \/= iResolution.x \/ iResolution.y;\n    \n    vec2 z = vec2(0);\n    vec2 c = vFocus + (vUV * 2.0 - 1.0) * vScale;\n    \n    bool bInside = true;\n    \n    float fIter = 0.0;\n    for(int iter = 0; iter < 512; iter++)\n    {        \n \t\tz = mat2(z,-z.y,z.x) * z + c;\n     \n        if ( dot(z,z) > 4.0 )            \n        {\n            bInside = false;\n            break;\n        }       \n        \n        fIter++;\n    }\n    \n    float fIndex = 0.0;\n    if ( bInside ) \n    {\n        \/\/fIndex = 0.0; \/\/ black set\n        fIndex = 1.0; \/\/ blue set\n    }\n    else\n    {\n \n        if ( Key_IsToggled( KEY_PLUS ) || Key_IsToggled( KEY_RIGHT ) )\n        {\n        \tfIter += iTime * 10.0;\n        }\n        else\n        if ( Key_IsToggled( KEY_MINUS ) || Key_IsToggled( KEY_LEFT ) )\n        {\n        \tfIter -= iTime * 10.0;\n        }\n        \n    \tfIndex = 1.0 + mod( fIter, 255.0 );\n    }\n    \n\tfragColor.rgb = VGAPaletteEntry( fIndex ) \/ 63.0;\n    fragColor.a = 1.0;\n}\n\n#endif\n\n#ifdef SHADERTOY\n\/\/ Shadertoy font shader - @P_Malin\n\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ ----------------------------------------------------------------------------------------\n\n\/\/#define LOW_QUALITY\n\n\/\/ The main characters are made up from a number of curve segments.\n\/\/ I made another shader to illustrate how these work:\n\/\/\n\/\/     https:\/\/www.shadertoy.com\/view\/Xds3Dn\n\/\/\n\/\/ The middle of the characters are filled in triangles or convex quadrilaterals\n\/\/ Enable this define to see just the curved sections:\n\n\/\/#define CURVES_ONLY\n\n\/\/ Initially I made most of characters this way but I ran into the constant register limit. \n\/\/ To avoid this, the curved sections of the \u00e2\u20ac\u02dco\u00e2\u20ac\u2122, \u00e2\u20ac\u02dca\u00e2\u20ac\u2122 and \u00e2\u20ac\u02dcd\u00e2\u20ac\u2122 are oval shapes. \n\/\/ Also I managed to cut the constant data down dramatically by sharing a lot of\n\/\/ the shapes in the font (see the comments in the function Shadertoy() ). \n\/\/ For example the tails for \u00e2\u20ac\u02dch\u00e2\u20ac\u2122, \u00e2\u20ac\u2122a\u00e2\u20ac\u2122, \u00e2\u20ac\u02dcd\u00e2\u20ac\u2122, \u00e2\u20ac\u02dct\u00e2\u20ac\u2122, the left hand side of the \u00e2\u20ac\u02dcy\u00e2\u20ac\u2122 and the \n\/\/ top of the \u00e2\u20ac\u02dch\u00e2\u20ac\u2122 all use the same shape! \n\/\/ I was probably more happy that I should have been when I realised I could share\n\/\/ the shape making the curve of the \u00e2\u20ac\u02dcr\u00e2\u20ac\u2122 with the little loop on the \u00e2\u20ac\u02dco\u00e2\u20ac\u2122.\n\/\/\n\/\/ I experimented with a distance field version but it looked like it would involve \n\/\/ a lot more work and I thought I\u00e2\u20ac\u2122d already spent too much time on this shader :)\n\n#ifdef LOW_QUALITY\n\n\t#define AA_X 1\n\t#define AA_Y 1\n\n#else\n\n\t#define AA_X 2\n\t#define AA_Y 2\n\n#endif\n\n\nfloat TestCurve(vec2 uv)\n{\n\tuv = 1.0 - uv;\n    return 1.0 - dot(uv, uv);\n}\n\nfloat Cross( const in vec2 A, const in vec2 B )\n{\n    return A.x * B.y - A.y * B.x;\n}\n\nvec2 GetUV(const in vec2 A, const in vec2 B, const in vec2 C, const in vec2 P)\n{\n    vec2 vPB = B - P;\n    float f1 = Cross(A-B, vPB);\n    float f2 = Cross(B-C, vPB);\n    float f3 = Cross(C-A, C-P);\n    \n    return vec2(f1, f2) \/ (f1 + f2 + f3);\n}\n\nfloat InCurve( const in vec2 A, const in vec2 B, const in vec2 C, const in vec2 P )\n{\n    vec2 vCurveUV = GetUV(A, B, C, P);\n    \n    float fResult = -1.0;\n\n\tfResult = max(fResult, (-vCurveUV.x));\n\tfResult = max(fResult, (-vCurveUV.y));\n\tfResult = max(fResult, (vCurveUV.x + vCurveUV.y - 1.0));\n\n\tfloat fCurveResult = TestCurve(vCurveUV);\n\t\t\n\tfResult = max(fResult, fCurveResult);\t\n\t\n    return fResult;\n}\n\nfloat InCurve2( const in vec2 A, const in vec2 B, const in vec2 C, const in vec2 P )\n{\n    vec2 vCurveUV = GetUV(A, B, C, P);\n\t\n    float fResult = -1.0;\n\n\tfResult = max(fResult, (vCurveUV.x + vCurveUV.y - 1.0));\n\t\n\tfloat fCurveResult = -TestCurve(vCurveUV);\n\t\n\tfResult = max(fResult, fCurveResult);\t\n\t\n    return fResult;\n}\n\nfloat InTri( const in vec2 A, const in vec2 B, const in vec2 C, const in vec2 P )\n{\n\t#ifdef CURVES_ONLY\n\treturn 1.0;\n\t#endif\n\t\n    float f1 = Cross(B-A, A-P);\n    float f2 = Cross(C-B, B-P);\n    float f3 = Cross(A-C, C-P);\n\t\n    return (max(max(f1, f2), f3));\n}\n\nfloat InQuad( const in vec2 A, const in vec2 B, const in vec2 C, const in vec2 D, const in vec2 P )\n{\n\t#ifdef CURVES_ONLY\n\treturn 1.0;\n\t#endif\n\t\n    float f1 = Cross(B-A, A-P);\n    float f2 = Cross(C-B, B-P);\n    float f3 = Cross(D-C, C-P);\n    float f4 = Cross(A-D, D-P);\n    \n    return (max(max(max(f1, f2), f3), f4));\n}\n\n\nfloat Glyph0(const in vec2 uv)\n{\n    const vec2  vP0 = vec2 ( 0.112, 0.056 );\n    const vec2  vP1 = vec2 ( 0.136, 0.026 );\n    const vec2  vP2 = vec2 ( 0.108, 0.022 );\n    const vec2  vP3 = vec2 ( 0.083, 0.017 ); \n    const vec2  vP4 = vec2 ( 0.082, 0.036 ); \n    const vec2  vP5 = vec2 ( 0.088, 0.062 ); \n    const vec2  vP6 = vec2 ( 0.115, 0.086 ); \n    const vec2  vP7 = vec2 ( 0.172, 0.147 ); \n    const vec2  vP8 = vec2 ( 0.100, 0.184 ); \n    const vec2  vP9 = vec2 ( 0.034, 0.206 ); \n    const vec2 vP10 = vec2 ( 0.021, 0.160 ); \n    const vec2 vP11 = vec2 ( 0.011, 0.114 ); \n    const vec2 vP12 = vec2 ( 0.052, 0.112 ); \n    const vec2 vP13 = vec2 ( 0.070, 0.108 ); \n    const vec2 vP14 = vec2 ( 0.075, 0.126 );\n    const vec2 vP15 = vec2 ( 0.049, 0.124 );\n    const vec2 vP16 = vec2 ( 0.047, 0.148 );\n    const vec2 vP17 = vec2 ( 0.046, 0.169 );\n    const vec2 vP18 = vec2 ( 0.071, 0.171 );\n    const vec2 vP19 = vec2 ( 0.098, 0.171 ); \n    const vec2 vP20 = vec2 ( 0.097, 0.143 ); \n    const vec2 vP21 = vec2 ( 0.100, 0.118 ); \n    const vec2 vP22 = vec2 ( 0.080, 0.100 ); \n    const vec2 vP23 = vec2 ( 0.055, 0.083 ); \n    const vec2 vP24 = vec2 ( 0.050, 0.052 ); \n    const vec2 vP25 = vec2 ( 0.052, 0.004 ); \n    const vec2 vP26 = vec2 ( 0.107, 0.010 ); \n    const vec2 vP27 = vec2 ( 0.148, 0.011 ); \n    const vec2 vP28 = vec2 ( 0.140, 0.041 ); \n    const vec2 vP29 = vec2 ( 0.139, 0.069 ); \n\n    float fDist = 1.0;\n\n\tfDist = min( fDist, InCurve2(vP6,vP7,vP8, uv) );\n    fDist = min( fDist, InCurve2(vP8,vP9,vP10, uv) );\n\tfDist = min( fDist, InCurve2(vP10,vP11,vP12, uv) );\n    fDist = min( fDist, InCurve2(vP12,vP13,vP14, uv) );\n\tfDist = min( fDist, InCurve(vP14,vP15,vP16, uv) );\n    fDist = min( fDist, InCurve(vP16,vP17,vP18, uv) );\n    fDist = min( fDist, InCurve(vP18,vP19,vP20, uv) );\n    fDist = min( fDist, InCurve(vP20,vP21,vP22, uv) );\n\tfDist = min( fDist, InCurve2(vP22,vP23,vP24, uv) );\n    fDist = min( fDist, InCurve2(vP24,vP25,vP26, uv) );\n    fDist = min( fDist, InCurve2(vP26,vP27,vP28, uv) );\n    fDist = min( fDist, InCurve2(vP28,vP29,vP0, uv) );\n\tfDist = min( fDist, InCurve(vP0,vP1,vP2, uv) );\n\tfDist = min( fDist, InCurve(vP2,vP3,vP4, uv) );\n    fDist = min( fDist, InCurve(vP4,vP5,vP6, uv) );\n\n\n    fDist = min( fDist, InTri(vP0, vP1, vP28, uv) );\n\tfDist = min( fDist, InQuad(vP26, vP1, vP2, vP3, uv) );\n    fDist = min( fDist, InTri(vP3, vP4, vP24, uv) );\n    fDist = min( fDist, InTri(vP4, vP5, vP24, uv) );\n    fDist = min( fDist, InTri(vP24, vP5, vP22, uv) );\n    fDist = min( fDist, InTri(vP5, vP6, vP22, uv) );\n    fDist = min( fDist, InTri(vP22, vP6, vP21, uv) );\n    fDist = min( fDist, InTri(vP6, vP8, vP21, uv) );\n    fDist = min( fDist, InTri(vP21, vP8, vP20, uv) );\n    fDist = min( fDist, InTri(vP20, vP8, vP19, uv) );\n    fDist = min( fDist, InTri(vP19, vP8, vP18, uv) );\n    fDist = min( fDist, InTri(vP18, vP8, vP10, uv) );\n    fDist = min( fDist, InTri(vP10, vP16, vP17, uv) );\n    fDist = min( fDist, InTri(vP10, vP15, vP16, uv) );\n    fDist = min( fDist, InTri(vP10, vP12, vP16, uv) );\n    fDist = min( fDist, InTri(vP12, vP14, vP15, uv) );\n\n    return fDist;\n}\n\nfloat Glyph1(const in vec2 uv, const in vec2 vOffset)\n{\n    vec2 vP0 = vec2 ( 0.171, 0.026 ) + vOffset;\n    vec2 vP1 = vec2 ( 0.204, 0.022 ) + vOffset;\n    const vec2 vP2 = vec2 ( 0.170, 0.185 );\n    const vec2 vP3 = vec2 ( 0.137, 0.185 );\n    \n    return InQuad(vP0, vP1, vP2, vP3, uv);\n}\n\nfloat Glyph3(const in vec2 uv, vec2 vOffset)\n{\n    vec2 vP0 = vec2 ( 0.212, 0.112 ) + vOffset;\n    vec2 vP2 = vec2 ( 0.243, 0.112 ) + vOffset;\n    const vec2  vP4 = vec2 ( 0.234, 0.150 );\n    const vec2  vP5 = vec2 ( 0.230, 0.159 );\n    const vec2  vP6 = vec2 ( 0.243, 0.164 );\n    const vec2  vP7 = vec2 ( 0.257, 0.164 );\n    const vec2  vP8 = vec2 ( 0.261, 0.148 );\n    const vec2 vP10 = vec2 ( 0.265, 0.164 );\n    const vec2 vP11 = vec2 ( 0.256, 0.180 );\n    const vec2 vP12 = vec2 ( 0.239, 0.185 );\n    const vec2 vP13 = vec2 ( 0.194, 0.194 );\n    const vec2 vP14 = vec2 ( 0.203, 0.150 );\n    const vec2 vP16 = vec2 ( 0.212, 0.113 );\n\n    float fDist = 1.0;\n    fDist = min( fDist, InCurve(vP4,vP5,vP6, uv) );\n    fDist = min( fDist, InCurve(vP6,vP7,vP8, uv) );\n    fDist = min( fDist, InCurve2(vP10,vP11,vP12, uv) );\n    fDist = min( fDist, InCurve2(vP12,vP13,vP14, uv) );\n\n    fDist = min( fDist, InQuad(vP0, vP2, vP4, vP14, uv) );\n    fDist = min( fDist, InTri(vP14, vP4, vP5, uv) );\n    fDist = min( fDist, InTri(vP14, vP5, vP12, uv) );\n    fDist = min( fDist, InTri(vP5, vP6, vP12, uv) );\n    fDist = min( fDist, InTri(vP6, vP7, vP12, uv) );\n    fDist = min( fDist, InTri(vP6, vP10, vP12, uv) );\n    fDist = min( fDist, InTri(vP8, vP10, vP7, uv) );\n    \n    return fDist;\n}\n\nfloat Glyph4(const in vec2 uv)\n{\n    vec2 vP = uv - vec2(0.305, 0.125);\n    vP \/= 0.065;\n    vP.x *= 1.5;\n    vP.x += vP.y * 0.25;\n    \n    vec2 vP2 = vP;\n\n    vP.y = abs(vP.y);\n    vP.y = pow(vP.y, 1.2);\n    float f= length(vP);\n    \n    vP2.x *= 1.2;\n    float f2 = length(vP2 * 1.5 - vec2(0.6, 0.0));\n        \n    return max(f - 1.0, 1.0 - f2) \/ 20.0;\n} \n\nfloat Glyph5(const in vec2 uv)\n{\n    const vec2  vP0 = vec2 ( 0.507, 0.138 );\n    const vec2  vP1 = vec2 ( 0.510, 0.065 );\n    const vec2  vP2 = vec2 ( 0.570, 0.066 );\n    const vec2  vP3 = vec2 ( 0.598, 0.066 );\n    const vec2  vP4 = vec2 ( 0.594, 0.092 );\n    const vec2  vP5 = vec2 ( 0.599, 0.131 );\n    const vec2  vP6 = vec2 ( 0.537, 0.137 );\n    const vec2  vP8 = vec2 ( 0.538, 0.125 );\n    const vec2  vP9 = vec2 ( 0.564, 0.129 );\n    const vec2 vP10 = vec2 ( 0.574, 0.100 );\n    const vec2 vP11 = vec2 ( 0.584, 0.085 );\n    const vec2 vP12 = vec2 ( 0.571, 0.079 );\n    const vec2 vP13 = vec2 ( 0.557, 0.081 );\n    const vec2 vP14 = vec2 ( 0.549, 0.103 );\n    const vec2 vP15 = vec2 ( 0.518, 0.166 );\n    const vec2 vP16 = vec2 ( 0.557, 0.166 );\n    const vec2 vP17 = vec2 ( 0.589, 0.163 );\n    const vec2 vP18 = vec2 ( 0.602, 0.137 );\n    const vec2 vP20 = vec2 ( 0.602, 0.152 );\n    const vec2 vP21 = vec2 ( 0.572, 0.194 );\n    const vec2 vP22 = vec2 ( 0.537, 0.185 );\n    const vec2 vP23 = vec2 ( 0.503, 0.189 );\n    \n    float fDist = 1.0;\n    fDist = min( fDist, InCurve2(vP0,vP1,vP2, uv) ); \n    fDist = min( fDist, InCurve2(vP2,vP3,vP4, uv) ); \n    fDist = min( fDist, InCurve2(vP4,vP5,vP6, uv) );\n    fDist = min( fDist, InCurve(vP8,vP9,vP10, uv) ); \n    fDist = min( fDist, InCurve(vP10,vP11,vP12, uv) ); \n    fDist = min( fDist, InCurve(vP12,vP13,vP14, uv) );\n    fDist = min( fDist, InCurve(vP14,vP15,vP16, uv) );\n    fDist = min( fDist, InCurve(vP16,vP17,vP18, uv) ); \n    fDist = min( fDist, InCurve2(vP20,vP21,vP22, uv) ); \n    fDist = min( fDist, InCurve2(vP22,vP23,vP0, uv) );\n\n    fDist = min( fDist, InTri(vP0, vP2, vP13, uv) );\n    fDist = min( fDist, InTri(vP13, vP2, vP12, uv) );\n    fDist = min( fDist, InTri(vP2, vP11, vP12, uv) );\n    fDist = min( fDist, InTri(vP2, vP4, vP11, uv) );\n    fDist = min( fDist, InTri(vP11, vP4, vP10, uv) );\n    fDist = min( fDist, InTri(vP10, vP4, vP9, uv) );\n    fDist = min( fDist, InTri(vP6, vP8, vP9, uv) );\n    fDist = min( fDist, InTri(vP0, vP13, vP14, uv) );\n    fDist = min( fDist, InTri(vP0, vP14, vP15, uv) );\n    fDist = min( fDist, InTri(vP15, vP16, vP22, uv) );\n    fDist = min( fDist, InTri(vP16, vP17, vP22, uv) );\n    fDist = min( fDist, InTri(vP17, vP18, vP20, uv) );\n    \n    return fDist;\n}\n\nfloat Glyph6(const in vec2 uv)\n{\n    const vec2  vP0 = vec2 ( 0.638 , 0.087 ); \n    const vec2  vP1 = vec2 ( 0.648 , 0.073 ); \n    const vec2  vP2 = vec2 ( 0.673 , 0.068 ); \n    const vec2  vP3 = vec2 ( 0.692 , 0.069 ); \n    const vec2  vP4 = vec2 ( 0.687 , 0.086 ); \n    const vec2  vP5 = vec2 ( 0.688 , 0.104 ); \n    const vec2  vP6 = vec2 ( 0.672 , 0.102 ); \n    const vec2  vP7 = vec2 ( 0.659 , 0.099 ); \n    const vec2  vP8 = vec2 ( 0.663 , 0.092 ); \n    const vec2  vP9 = vec2 ( 0.662 , 0.086 ); \n    const vec2 vP10 = vec2 ( 0.655 , 0.086 ); \n    const vec2 vP11 = vec2 ( 0.644 , 0.087 ); \n    const vec2 vP12 = vec2 ( 0.637 , 0.102 ); \n    const vec2 vP13 = vec2 ( 0.638 , 0.094 ); \n\n    float fDist = 1.0;\n    fDist = min( fDist, InCurve2(vP0,vP1,vP2, uv) ); \n    fDist = min( fDist, InCurve2(vP2,vP3,vP4, uv) ); \n    fDist = min( fDist, InCurve2(vP4,vP5,vP6, uv) ); \n    fDist = min( fDist, InCurve2(vP6,vP7,vP8, uv) ); \n    fDist = min( fDist, InCurve(vP8,vP9,vP10, uv) ); \n    fDist = min( fDist, InCurve(vP10,vP11,vP12, uv) );\n\n    fDist = min( fDist, InQuad(vP2, vP4, vP6, vP8, uv) );\n    fDist = min( fDist, InTri(vP9, vP2, vP8, uv) );\n    fDist = min( fDist, InTri(vP10, vP2, vP9, uv) );\n    fDist = min( fDist, InQuad(vP0, vP2, vP10, vP11, uv) );\n    fDist = min( fDist, InTri(vP11, vP12, vP0, uv) );\n    \n    return fDist;\n}\n\nfloat Glyph7(const in vec2 uv)\n{\n    const vec2 vP0 = vec2 ( 0.693 , 0.068 );\n    const vec2 vP1 = vec2 ( 0.748 , 0.069 );\n    const vec2 vP2 = vec2 ( 0.747 , 0.078 );\n    const vec2 vP3 = vec2 ( 0.691 , 0.077 );\n    \n    return InQuad(vP0, vP1, vP2, vP3, uv);\n}\n\n\nfloat Glyph8(const in vec2 uv)\n{ \n    vec2 vP = uv - vec2(0.788, 0.125);\n    vP \/= 0.065;\n    vP.x *= 1.4;\n    vP.x += vP.y * 0.25;\n    \n    vec2 vP2 = vP;\n    \n    vP.y = abs(vP.y);\n    vP.y = pow(vP.y, 1.2);\n    float f= length(vP);\n    \n    vP2.x *= 1.5;\n    float f2 = length(vP2 * 1.5 - vec2(0.3, 0.0));\n    \n    \n    return max(f - 1.0, 1.0 - f2) \/ 20.0;\n}\n\nfloat Glyph11(const in vec2 uv)\n{\n    const vec2  vP0 = vec2 ( 0.921 , 0.070 );\n    const vec2  vP2 = vec2 ( 0.955 , 0.070 );\n    const vec2  vP4 = vec2 ( 0.926 , 0.202 );\n    const vec2  vP5 = vec2 ( 0.926 , 0.240 );\n    const vec2  vP6 = vec2 ( 0.885 , 0.243 );\n    const vec2  vP7 = vec2 ( 0.852 , 0.239 );\n    const vec2  vP8 = vec2 ( 0.859 , 0.219 );\n    const vec2  vP9 = vec2 ( 0.862 , 0.192 );\n    const vec2 vP10 = vec2 ( 0.889 , 0.189 );\n    const vec2 vP12 = vec2 ( 0.928 , 0.178 );\n    const vec2 vP13 = vec2 ( 0.949 , 0.173 );\n    const vec2 vP14 = vec2 ( 0.951 , 0.162 );\n    const vec2 vP15 = vec2 ( 0.960 , 0.150 );\n    const vec2 vP16 = vec2 ( 0.960 , 0.144 );\n    const vec2 vP18 = vec2 ( 0.971 , 0.144 );\n    const vec2 vP19 = vec2 ( 0.968 , 0.157 );\n    const vec2 vP20 = vec2 ( 0.957 , 0.171 );\n    const vec2 vP21 = vec2 ( 0.949 , 0.182 );\n    const vec2 vP22 = vec2 ( 0.922 , 0.189 );\n    const vec2 vP24 = vec2 ( 0.900 , 0.196 );\n    const vec2 vP25 = vec2 ( 0.866 , 0.205 );\n    const vec2 vP26 = vec2 ( 0.871 , 0.217 );\n    const vec2 vP27 = vec2 ( 0.871 , 0.225 );\n    const vec2 vP28 = vec2 ( 0.880 , 0.224 );\n    const vec2 vP29 = vec2 ( 0.889 , 0.218 );\n    const vec2 vP30 = vec2 ( 0.893 , 0.203 );\n\n    float fDist = 1.0;\n    fDist = min( fDist, InCurve2(vP4,vP5,vP6, uv) );\n    fDist = min( fDist, InCurve2(vP6,vP7,vP8, uv) );\n    fDist = min( fDist, InCurve2(vP8,vP9,vP10, uv) );\n    fDist = min( fDist, InCurve(vP12,vP13,vP14, uv) );\n\n    fDist = min( fDist, InCurve(vP14,vP15,vP16, uv) );\n    fDist = min( fDist, InCurve2(vP18,vP19,vP20, uv) );\n    fDist = min( fDist, InCurve2(vP20,vP21,vP22, uv) );\n\n    fDist = min( fDist, InCurve(vP24,vP25,vP26, uv) );\n    fDist = min( fDist, InCurve(vP26,vP27,vP28, uv) );\n    fDist = min( fDist, InCurve(vP28,vP29,vP30, uv) );\n    \n    fDist = min( fDist, InQuad(vP0, vP2, vP4, vP30, uv) );\n\n    fDist = min( fDist, InQuad(vP10, vP12, vP22, vP24, uv) );\n        \n    fDist = min( fDist, InTri(vP30, vP4, vP6, uv) );\n    fDist = min( fDist, InTri(vP30, vP6, vP29, uv) );\n    fDist = min( fDist, InTri(vP28, vP29, vP6, uv) );\n    fDist = min( fDist, InTri(vP28, vP6, vP27, uv) );\n    \n    fDist = min( fDist, InTri(vP8, vP27, vP6, uv) );\n    \n    fDist = min( fDist, InTri(vP8, vP26, vP27, uv) );\n    fDist = min( fDist, InTri(vP8, vP25, vP26, uv) );\n    fDist = min( fDist, InTri(vP25, vP10, vP24, uv) );\n    \n    fDist = min( fDist, InTri(vP12, vP13, vP20, uv) );\n    fDist = min( fDist, InTri(vP12, vP20, vP22, uv) );\n    fDist = min( fDist, InTri(vP13, vP14, vP20, uv) );\n    fDist = min( fDist, InTri(vP15, vP20, vP14, uv) );\n    fDist = min( fDist, InTri(vP15, vP18, vP20, uv) );\n    fDist = min( fDist, InTri(vP15, vP16, vP18, uv) );\n    \n    return fDist;\n}\n\nfloat Shadertoy(in vec2 uv)\n{\n    float fResult = 1.0;\n    \n    fResult = min(fResult, Glyph0(uv)); \/\/ S\n\n    vec2 vUVOffset = vec2(0.001, 0.0); \/\/ tail of h\n    vec2 vTailOffset = vec2(0.0, 0.0);  \n    float fUVScale = 1.0;\n\n    if(uv.x < 0.3)\n    {\n        if(uv.y < 0.12)\n        {\n            \/\/ top of h\n            fUVScale = -1.0;\n            vUVOffset = vec2(0.448, 0.25);  \n            vTailOffset = vec2(0.0, 0.0);   \n        }\n    }\n    else if(uv.x < 0.4)    \n    {\n        \/\/ tail of a\n        vUVOffset = vec2(-0.124, 0.0);  \n        vTailOffset = vec2(0.01, -0.04);    \n    }\n    else if(uv.x < 0.6)\n    {\n        \/\/ tail of d\n        vUVOffset = vec2(-0.248, 0.0);  \n        vTailOffset = vec2(0.02, -0.1); \n    }\n    else if(uv.x < 0.83)\n    {\n        \/\/ stalk of t\n        vUVOffset = vec2(-0.48, 0.0);   \n        vTailOffset = vec2(0.02, -0.1); \n    }\n    else\n    {\n        \/\/ start of y\n        vUVOffset = vec2(-0.645, 0.0);  \n        vTailOffset = vec2(0.005, -0.042);  \n    }\n    \n    fResult = min(fResult, Glyph3(uv * fUVScale + vUVOffset, vTailOffset)); \/\/ tails h, a, d, t, start of y and top of h\n\n\n    vec2 vUVOffset3 = vec2(0.0, 0.0);   \/\/ vertical of h\n    vec2 vTailOffset3 = vec2(0.0, 0.0);\n    \n    if(uv.x > 0.5)\n    {\n        \/\/ vertical of r\n        vUVOffset3 = vec2(-0.45, 0.0);  \n        vTailOffset3 = vec2(-0.01, 0.04);   \n    }\n    \n    fResult = min(fResult, Glyph1(uv + vUVOffset3, vTailOffset3)); \/\/ vertical of h, r\n\n    vec2 vUVOffset2 = vec2(0.0, 0.0); \/\/ curve of a\n    if(uv.x > 0.365)\n    {\n        vUVOffset2 = vec2(-0.125, 0.0); \/\/ curve of d\n    }\n\n    fResult = min(fResult, Glyph4(uv + vUVOffset2)); \/\/ curve of a, d\n    \n    fResult = min(fResult, Glyph5(uv)); \/\/ e\n\n    vec2 vUVOffset4 = vec2(0.001, 0.0); \/\/ top of r\n    vec2 vUVScale4 = vec2(1.0, 1.0);        \n    \n    if(uv.x > 0.7)\n    {\n        \/\/ o loop\n        vUVOffset4.x = 1.499;\n        vUVOffset4.y = 0.19;\n        \n        vUVScale4.x = -1.0;\n        vUVScale4.y = -1.0;\n    }\n    \n    fResult = min(fResult, Glyph6(uv * vUVScale4 + vUVOffset4)); \/\/ top of r and o loop\n\n    fResult = min(fResult, Glyph7(uv)); \/\/ cross t    \n    \n    fResult = min(fResult, Glyph8(uv)); \/\/ o1\n    \n    fResult = min(fResult, Glyph11(uv)); \/\/ y2        \n\n    return fResult; \n}\n\nvec2 GetUVCentre(const vec2 vInputUV)\n{\n\tvec2 vFontUV = vInputUV;\n    vFontUV.y -= 0.35;\n\t\t\n\treturn vFontUV;\n}\n\nvec2 GetUVScroll(const vec2 vInputUV, float t)\n{\n\tvec2 vFontUV = vInputUV;\n\tvFontUV *= 0.25;\n\t\n    vFontUV.y -= 0.005;\n\tvFontUV.x += t * 3.0 - 1.5;\n\t\n\treturn vFontUV;\n}\n\nvec2 GetUVRepeat(const vec2 vInputUV, float t2)\n{\n\tvec2 vFontUV = vInputUV;\n\t\n\tvFontUV *= vec2(1.0, 4.0);\n\t\n\tvFontUV.x += floor(vFontUV.y) * t2;\n\t\n\tvFontUV = fract(vFontUV);\n\t\n\tvFontUV \/= vec2(1.0, 4.0);\n\t\t\n\treturn vFontUV;\n}\n\nvec2 GetUVRotate(const vec2 vInputUV, float t)\n{\n\tvec2 vFontUV = vInputUV - 0.5;\n\t\n\tfloat s = sin(t);\n\tfloat c = cos(t);\n\t\n\tvFontUV = vec2(  vFontUV.x * c + vFontUV.y * s,\n\t\t\t        -vFontUV.x * s + vFontUV.y * c );\n\t\n\tvFontUV += 0.5;\n\t\n\treturn vFontUV;\n}\n\nvec3 StyleDefault( float f )\n{\n\treturn mix(vec3(0.25), vec3(1.0), f);\n}\n\nvec3 StyleScanline( float f, in vec2 fragCoord )\n{\n\tfloat fShade = f * 0.8 + 0.2;\n\t\n    \/\/ disable\n\t\/\/fShade *= mod(fragCoord.y, 2.0);\n\t\n\treturn mix(vec3(0.01, 0.2, 0.01), vec3(0.01, 1.0, 0.02), fShade);\n}\n\nvec3 StyleStamp( float fFont, vec2 uv )\n{\n\tvec3 t1 = texture(iChannel2, uv + 0.005).rgb;\n\tvec3 t2 = texture(iChannel2, uv).rgb;\n\tfloat dt = clamp(0.5 + (t1.x - t2.x), 0.0, 1.0);\n\tfloat fWear = clamp((0.9 - t2.x) * 4.0, 0.0, 1.0);\n\tfloat f =  clamp(fFont * fWear, 0.0, 1.0);\n\treturn mix( vec3(1.0, 0.98, 0.9) * (dt * 0.1 + 0.9), vec3(0.7, 0.0, 0.0), f);\n}\n\nvec3 StyleWood( float fFont, vec2 uv )\n{\n\tvec3 t = texture(iChannel2, uv).rgb;\n\tfloat fWear = fFont * smoothstep(0.0, 0.4, t.b);\n\treturn mix(t, vec3(0.0), fWear);\n}\n\nvec4 GetRandom4(float x)\n{\n\treturn fract(vec4(987.65, 432.10, 765.43, 210.98) * sin(vec4(123.456, 789.123, 456.789, 567.890) * x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tfloat fSequenceLength = 5.0;\n\t\n\tfloat fTime = iTime;\n\t\n\tfloat fBlendSpeed = 0.05;\n\t\n\t\/\/ Skip the initial fade-in\n\tfTime += fBlendSpeed * fSequenceLength;\n\t\n\tfloat fInt = floor(fTime \/ fSequenceLength);\n\tfloat fFract = fract(fTime \/ fSequenceLength);\n\t\n\tvec4 vRandom4 = GetRandom4(fInt);\n\tvec2 vRandom2 = floor(vRandom4.xy * vec2(1234.56, 123.45));\n\t\n\tfloat fUVEffect = mod(vRandom2.x, 4.0);\n\tfloat fScreenEffect = mod(vRandom2.y, 4.0);\n\n\tif(fInt < 0.5)\n\t{\n\t\tfUVEffect = 0.0;\n\t\tfScreenEffect = 0.0;\n\t}\n\n\tvec4 vResult = vec4(0.0);\n\t\t\n\tfloat fX = 0.0;\n\tfor(int iX=0; iX<AA_X; iX++)\n\t{\n\t\tfloat fY = 0.0;\n\t\tfor(int y=0; y<AA_Y; y++)\n\t\t{\n\t\n\t\t\tvec2 vUV = (fragCoord.xy + vec2(fX, fY)) \/ iResolution.xy;\n\t\t\tvUV.x = ((vUV.x - 0.5) * (iResolution.x \/ iResolution.y)) + 0.5;    \n\t\t\tvUV.y = 1.0 - vUV.y;\n\t\t\t\t\n\t\t\tvec2 vFontUV = vUV;\n\t\t\tvec2 vBgUV = vUV;\n\t\t\t\n            if ( false ) \n\t\t\tif(iMouse.z > 0.0)\n\t\t\t{\n\t\t\t\tfUVEffect = 999.0;\n\t\t\t\tfScreenEffect = 0.0;\n\t\t\t\tfFract = 0.5;\n\t\t\t\t\n\t\t\t\tvFontUV *= 0.25;\n\t\t\t\tvFontUV += iMouse.xy \/ iResolution.xy;\n\t\t\t\tvFontUV.y -= 0.5;\n\t\t\t\tvBgUV = vFontUV;\n\t\t\t}\t\n\t\t\t\n\t\t\tif(fUVEffect < 0.5)\n\t\t\t{\n\t\t\t\tvFontUV = GetUVCentre(vBgUV);\n\t\t\t}\n\t\t\telse\n\t\t\tif(fUVEffect < 1.5)\n\t\t\t{\n\t\t\t\tvBgUV = GetUVScroll(vBgUV, fFract);\n\t\t\t\tvFontUV = vBgUV;\n\t\t\t}\n\t\t\telse\n\t\t\tif(fUVEffect < 2.5)\n\t\t\t{\n\t\t\t\tfloat fSpeed = 0.1 + vRandom4.z;\n\t\t\t\tvBgUV.x += fFract * fSpeed;\n\t\t\t\tvFontUV = GetUVRepeat(vBgUV, 0.25);\n\t\t\t}\n\t\t\telse\n\t\t\tif(fUVEffect < 3.5)\n\t\t\t{\n\t\t\t\tfloat fSpeed = 1.0 + vRandom4.z * 2.0;\n\t\t\t\tif(vRandom4.w > 0.5)\n\t\t\t\t{\n\t\t\t\t\tfSpeed = -fSpeed;\n\t\t\t\t}\n\t\t\t\tvBgUV = GetUVRotate(vBgUV, 1.0 + fSpeed * fFract);\n\t\t\t\tvFontUV = GetUVRepeat(vBgUV, 0.0);\n\t\t\t}\n\t\t\t\n\t\t\tfloat fShadertoy = step(Shadertoy(vFontUV), 0.0);\n\t\t\t\t\n\t\t\tif(fScreenEffect < 0.5)\n\t\t\t{\n\t\t\t\tvResult += vec4(StyleDefault(fShadertoy), 1.0);\n\t\t\t}\n\t\t\telse if(fScreenEffect < 1.5)\n\t\t\t{\n\t\t\t\tvResult += vec4(StyleScanline(fShadertoy, fragCoord), 1.0);\n\t\t\t}\n\t\t\telse if(fScreenEffect < 2.5)\n\t\t\t{\n\t\t\t\tvResult += vec4(StyleStamp(fShadertoy, vBgUV), 1.0);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvResult += vec4(StyleWood(fShadertoy, vBgUV), 1.0);\n\t\t\t}\n\n\t\t\tfY += 1.0 \/ float(AA_Y);\n\t\t}\n\t\t\n\t\tfX += 1.0 \/ float(AA_X);\n\t}\n\t\n\tvResult.xyz \/= vResult.w;\n\n\tfloat fFade = 0.0;\t\n\tif(fFract > (1.0 - fBlendSpeed))\n\t{\n\t\tfFade = smoothstep(1.0 - fBlendSpeed, 1.0, fFract);\n\t}\n\n\tif(fFract < fBlendSpeed)\n\t{\n\t\tfFade = smoothstep(fBlendSpeed, 0.0, fFract);\n\t}\n\n\tvResult = mix(vResult, vec4(1.0), fFade);\n\t\n    fragColor = vec4(vResult.xyz, 1.0);\n}\n#endif\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dX3Rr","filepath":"\/media\/a\/\/media\/previz\/cubemap00.png","previewfilepath":"\/media\/ap\/\/media\/previz\/cubemap00.png","type":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"\/media\/a\/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"\/media\/ap\/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\/\/ Meta CRT - @P_Malin\n\/\/ https:\/\/www.shadertoy.com\/view\/4dlyWX#\n\/\/ In which I add and remove aliasing\n\n\/\/ Scene Rendering\n\n#define ENABLE_TAA_JITTER\n\n#define kMaxTraceDist 1000.0\n#define kFarDist 1100.0\n\n#define MAT_FG_BEGIN \t10\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Scene\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nstruct SceneResult\n{\n\tfloat fDist;\n\tint iObjectId;\n    vec3 vUVW;\n};\n    \nvoid Scene_Union( inout SceneResult a, in SceneResult b )\n{\n    if ( b.fDist < a.fDist )\n    {\n        a = b;\n    }\n}\n\n    \nvoid Scene_Subtract( inout SceneResult a, in SceneResult b )\n{\n    if ( a.fDist < -b.fDist )\n    {\n        a.fDist = -b.fDist;\n        a.iObjectId = b.iObjectId;\n        a.vUVW = b.vUVW;\n    }\n}\n\nSceneResult Scene_GetDistance( vec3 vPos );    \n\nvec3 Scene_GetNormal(const in vec3 vPos)\n{\n    const float fDelta = 0.0001;\n    vec2 e = vec2( -1, 1 );\n    \n    vec3 vNormal = \n        Scene_GetDistance( e.yxx * fDelta + vPos ).fDist * e.yxx + \n        Scene_GetDistance( e.xxy * fDelta + vPos ).fDist * e.xxy + \n        Scene_GetDistance( e.xyx * fDelta + vPos ).fDist * e.xyx + \n        Scene_GetDistance( e.yyy * fDelta + vPos ).fDist * e.yyy;\n    \n    return normalize( vNormal );\n}    \n    \nSceneResult Scene_Trace( const in vec3 vRayOrigin, const in vec3 vRayDir, float minDist, float maxDist )\n{\t\n    SceneResult result;\n    result.fDist = 0.0;\n    result.vUVW = vec3(0.0);\n    result.iObjectId = -1;\n    \n\tfloat t = minDist;\n\tconst int kRaymarchMaxIter = 128;\n\tfor(int i=0; i<kRaymarchMaxIter; i++)\n\t{\t\t\n        float epsilon = 0.0001 * t;\n\t\tresult = Scene_GetDistance( vRayOrigin + vRayDir * t );\n        if ( abs(result.fDist) < epsilon )\n\t\t{\n\t\t\tbreak;\n\t\t}\n                        \n        if ( t > maxDist )\n        {\n            result.iObjectId = -1;\n\t        t = maxDist;\n            break;\n        }       \n        \n        if ( result.fDist > 1.0 )\n        {\n            result.iObjectId = -1;            \n        }    \n        \n        t += result.fDist;        \n\t}\n    \n    result.fDist = t;\n\n\n    return result;\n}    \n\nfloat Scene_TraceShadow( const in vec3 vRayOrigin, const in vec3 vRayDir, const in float fMinDist, const in float fLightDist )\n{\n    \/\/return 1.0;\n    \/\/return ( Scene_Trace( vRayOrigin, vRayDir, 0.1, fLightDist ).fDist < fLightDist ? 0.0 : 1.0;\n    \n\tfloat res = 1.0;\n    float t = fMinDist;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = Scene_GetDistance( vRayOrigin + vRayDir * t ).fDist;\n        res = min( res, 8.0*h\/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.0001 || t>fLightDist ) break;\n    }\n    return clamp( res, 0.0, 1.0 );    \n}\n\nfloat Scene_GetAmbientOcclusion( const in vec3 vPos, const in vec3 vDir )\n{\n    float fOcclusion = 0.0;\n    float fScale = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float fOffsetDist = 0.001 + 0.1*float(i)\/4.0;\n        vec3 vAOPos = vDir * fOffsetDist + vPos;\n        float fDist = Scene_GetDistance( vAOPos ).fDist;\n        fOcclusion += (fOffsetDist - fDist) * fScale;\n        fScale *= 0.4;\n    }\n    \n    return clamp( 1.0 - 30.0*fOcclusion, 0.0, 1.0 );\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Lighting\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \nstruct SurfaceInfo\n{\n    vec3 vPos;\n    vec3 vNormal;\n    vec3 vBumpNormal;    \n    vec3 vAlbedo;\n    vec3 vR0;\n    float fSmoothness;\n    vec3 vEmissive;\n};\n    \nSurfaceInfo Scene_GetSurfaceInfo( const in vec3 vRayOrigin,  const in vec3 vRayDir, SceneResult traceResult );\n\nstruct SurfaceLighting\n{\n    vec3 vDiffuse;\n    vec3 vSpecular;\n};\n    \nSurfaceLighting Scene_GetSurfaceLighting( const in vec3 vRayDir, in SurfaceInfo surfaceInfo );\n\nfloat Light_GIV( float dotNV, float k)\n{\n\treturn 1.0 \/ ((dotNV + 0.0001) * (1.0 - k)+k);\n}\n\nvoid Light_Add(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\n\tfloat fNDotL = clamp(dot(vLightDir, surface.vBumpNormal), 0.0, 1.0);\n\t\n\tlighting.vDiffuse += vLightColour * fNDotL;\n    \n\tvec3 vH = normalize( -vViewDir + vLightDir );\n\tfloat fNdotV = clamp(dot(-vViewDir, surface.vBumpNormal), 0.0, 1.0);\n\tfloat fNdotH = clamp(dot(surface.vBumpNormal, vH), 0.0, 1.0);\n    \n\tfloat alpha = 1.0 - surface.fSmoothness;\n\t\/\/ D\n\n\tfloat alphaSqr = alpha * alpha;\n\tfloat denom = fNdotH * fNdotH * (alphaSqr - 1.0) + 1.0;\n\tfloat d = alphaSqr \/ (PI * denom * denom);\n\n\tfloat k = alpha \/ 2.0;\n\tfloat vis = Light_GIV(fNDotL, k) * Light_GIV(fNdotV, k);\n\n\tfloat fSpecularIntensity = d * vis * fNDotL;    \n\tlighting.vSpecular += vLightColour * fSpecularIntensity;    \n}\n\nvoid Light_AddPoint(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightPos, const in vec3 vLightColour)\n{    \n    vec3 vPos = surface.vPos;\n\tvec3 vToLight = vLightPos - vPos;\t\n    \n\tvec3 vLightDir = normalize(vToLight);\n\tfloat fDistance2 = dot(vToLight, vToLight);\n\tfloat fAttenuation = 100.0 \/ (fDistance2);\n\t\n\tfloat fShadowFactor = Scene_TraceShadow( surface.vPos, vLightDir, 0.1, length(vToLight) );\n\t\n\tLight_Add( lighting, surface, vViewDir, vLightDir, vLightColour * fShadowFactor * fAttenuation);\n}\n\nvoid Light_AddDirectional(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\t\n\tfloat fAttenuation = 1.0;\n\tfloat fShadowFactor = Scene_TraceShadow( surface.vPos, vLightDir, 0.1, 10.0 );\n\t\n\tLight_Add( lighting, surface, vViewDir, vLightDir, vLightColour * fShadowFactor * fAttenuation);\n}\n\nvec3 Light_GetFresnel( vec3 vView, vec3 vNormal, vec3 vR0, float fGloss )\n{\n    float NdotV = max( 0.0, dot( vView, vNormal ) );\n\n    return vR0 + (vec3(1.0) - vR0) * pow( 1.0 - NdotV, 5.0 ) * pow( fGloss, 20.0 );\n}\n\nvoid Env_AddPointLightFlare(inout vec3 vEmissiveGlow, const in vec3 vRayOrigin, const in vec3 vRayDir, const in float fIntersectDistance, const in vec3 vLightPos, const in vec3 vLightColour)\n{\n    vec3 vToLight = vLightPos - vRayOrigin;\n    float fPointDot = dot(vToLight, vRayDir);\n    fPointDot = clamp(fPointDot, 0.0, fIntersectDistance);\n\n    vec3 vClosestPoint = vRayOrigin + vRayDir * fPointDot;\n    float fDist = length(vClosestPoint - vLightPos);\n\tvEmissiveGlow += sqrt(vLightColour * 0.05 \/ (fDist * fDist));\n}\n\nvoid Env_AddDirectionalLightFlareToFog(inout vec3 vFogColour, const in vec3 vRayDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\n\tfloat fDirDot = clamp(dot(vLightDir, vRayDir) * 0.5 + 0.5, 0.0, 1.0);\n\tfloat kSpreadPower = 2.0;\n\tvFogColour += vLightColour * pow(fDirDot, kSpreadPower) * 0.25;\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Rendering\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec4 Env_GetSkyColor( const vec3 vViewPos, const vec3 vViewDir );\nvec3 Env_ApplyAtmosphere( const in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist );\nvec3 FX_Apply( in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist);\n\nvec4 Scene_GetColorAndDepth( vec3 vRayOrigin, vec3 vRayDir )\n{\n\tvec3 vResultColor = vec3(0.0);\n            \n\tSceneResult firstTraceResult;\n    \n    float fStartDist = 0.0f;\n    float fMaxDist = 10.0f;\n    \n    vec3 vRemaining = vec3(1.0);\n    \n\tfor( int iPassIndex=0; iPassIndex < 3; iPassIndex++ )\n    {\n    \tSceneResult traceResult = Scene_Trace( vRayOrigin, vRayDir, fStartDist, fMaxDist );\n\n        if ( iPassIndex == 0 )\n        {\n            firstTraceResult = traceResult;\n        }\n        \n        vec3 vColor = vec3(0);\n        vec3 vReflectAmount = vec3(0);\n        \n\t\tif( traceResult.iObjectId < 0 )\n\t\t{\n            vColor = Env_GetSkyColor( vRayOrigin, vRayDir ).rgb;\n        }\n        else\n        {\n            \n            SurfaceInfo surfaceInfo = Scene_GetSurfaceInfo( vRayOrigin, vRayDir, traceResult );\n            SurfaceLighting surfaceLighting = Scene_GetSurfaceLighting( vRayDir, surfaceInfo );\n                \n            \/\/ calculate reflectance (Fresnel)\n\t\t\tvReflectAmount = Light_GetFresnel( -vRayDir, surfaceInfo.vBumpNormal, surfaceInfo.vR0, surfaceInfo.fSmoothness );\n\t\t\t\n\t\t\tvColor = (surfaceInfo.vAlbedo * surfaceLighting.vDiffuse + surfaceInfo.vEmissive) * (vec3(1.0) - vReflectAmount); \n            \n            vec3 vReflectRayOrigin = surfaceInfo.vPos;\n            vec3 vReflectRayDir = normalize( reflect( vRayDir, surfaceInfo.vBumpNormal ) );\n            fStartDist = 0.001 \/ max(0.0000001,abs(dot( vReflectRayDir, surfaceInfo.vNormal ))); \n\n            vColor += surfaceLighting.vSpecular * vReflectAmount;            \n\n\t\t\tvColor = Env_ApplyAtmosphere( vColor, vRayOrigin, vRayDir, traceResult.fDist );\n\t\t\tvColor = FX_Apply( vColor, vRayOrigin, vRayDir, traceResult.fDist );\n            \n            vRayOrigin = vReflectRayOrigin;\n            vRayDir = vReflectRayDir;\n        }\n        \n        vResultColor += vColor * vRemaining;\n        vRemaining *= vReflectAmount;        \n    }\n \n    return vec4( vResultColor, EncodeDepthAndObject( firstTraceResult.fDist, firstTraceResult.iObjectId ) );\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Scene Description\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ Materials\n\n#define MAT_SKY\t\t \t-1\n#define MAT_DEFAULT \t 0\n#define MAT_SCREEN\t\t 1\n#define MAT_TV_CASING    2\n#define MAT_TV_TRIM      3\n#define MAT_CHROME       4\n\n\nvec3 PulseIntegral( vec3 x, float s1, float s2 )\n{\n    \/\/ Integral of function where result is 1.0 between s1 and s2 and 0 otherwise        \n\n    \/\/ V1\n    \/\/if ( x > s2 ) return s2 - s1;\n\t\/\/else if ( x > s1 ) return x - s1;\n\t\/\/return 0.0f; \n    \n    \/\/ V2\n    \/\/return clamp( (x - s1), 0.0f, s2 - s1);\n    \/\/return t;\n    \n    return clamp( (x - s1), vec3(0.0f), vec3(s2 - s1));\n}\n\nfloat PulseIntegral( float x, float s1, float s2 )\n{\n    \/\/ Integral of function where result is 1.0 between s1 and s2 and 0 otherwise        \n\n    \/\/ V1\n    \/\/if ( x > s2 ) return s2 - s1;\n\t\/\/else if ( x > s1 ) return x - s1;\n\t\/\/return 0.0f; \n    \n    \/\/ V2\n    \/\/return clamp( (x - s1), 0.0f, s2 - s1);\n    \/\/return t;\n    \n    return clamp( (x - s1), (0.0f), (s2 - s1));\n}\n\nvec3 Bayer( vec2 vUV, vec2 vBlur )\n{\n    vec3 x = vec3(vUV.x);\n    vec3 y = vec3(vUV.y);           \n\n    x += vec3(0.66, 0.33, 0.0);\n    y += 0.5 * step( fract( x * 0.5 ), vec3(0.5) );\n        \n    \/\/x -= 0.5f;\n    \/\/y -= 0.5f;\n    \n    x = fract( x );\n    y = fract( y );\n    \n    \/\/ cell centered at 0.5\n    \n    vec2 vSize = vec2(0.16f, 0.75f);\n    \n    vec2 vMin = 0.5 - vSize * 0.5;\n    vec2 vMax = 0.5 + vSize * 0.5;\n    \n    vec3 vResult= vec3(0.0);\n    \n    vec3 vResultX = (PulseIntegral( x + vBlur.x, vMin.x, vMax.x) - PulseIntegral( x - vBlur.x, vMin.x, vMax.x)) \/ min( vBlur.x, 1.0);\n    vec3 vResultY = (PulseIntegral(y + vBlur.y, vMin.y, vMax.y) - PulseIntegral(y - vBlur.y, vMin.y, vMax.y))  \/ min( vBlur.y, 1.0);\n    \n    vResult = min(vResultX,vResultY)  * 5.0;\n        \n    \/\/vResult = vec3(1.0);\n    \n    return vResult;\n}\n\nvec3 GetPixelMatrix( vec2 vUV )\n{\n#if 1\n    vec2 dx = dFdx( vUV );\n    vec2 dy = dFdy( vUV );\n    float dU = length( vec2( dx.x, dy.x ) );\n    float dV = length( vec2( dx.y, dy.y ) );\n    if (dU <= 0.0 || dV <= 0.0 ) return vec3(1.0);\n    return Bayer( vUV, vec2(dU, dV) * 1.0);\n#else\n    return vec3(1.0);\n#endif\n}\n\nfloat Scanline( float y, float fBlur )\n{   \n    float fResult = sin( y * 10.0 ) * 0.45 + 0.55;\n    return mix( fResult, 1.0f, min( 1.0, fBlur ) );\n}\n\n\nfloat GetScanline( vec2 vUV )\n{\n#if 1\n    vUV.y *= 0.25;\n    vec2 dx = dFdx( vUV );\n    vec2 dy = dFdy( vUV );\n    float dV = length( vec2( dx.y, dy.y ) );\n    if (dV <= 0.0 ) return 1.0;\n    return Scanline( vUV.y, dV * 1.3 );\n#else\n    return 1.0;\n#endif\n}\n\n\nvec2 kScreenRsolution = vec2(480.0f, 576.0f);\n\nstruct Interference\n{\n    float noise;\n    float scanLineRandom;\n};\n\nfloat InterferenceHash(float p)\n{\n    float hashScale = 0.1031;\n\n    vec3 p3  = fract(vec3(p, p, p) * hashScale);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nfloat InterferenceSmoothNoise1D( float x )\n{\n    float f0 = floor(x);\n    float fr = fract(x);\n\n    float h0 = InterferenceHash( f0 );\n    float h1 = InterferenceHash( f0 + 1.0 );\n\n    return h1 * fr + h0 * (1.0 - fr);\n}\n\n\nfloat InterferenceNoise( vec2 uv )\n{\n\tfloat displayVerticalLines = 483.0;\n    float scanLine = floor(uv.y * displayVerticalLines); \n    float scanPos = scanLine + uv.x;\n\tfloat timeSeed = fract( iTime * 123.78 );\n    \n    return InterferenceSmoothNoise1D( scanPos * 234.5 + timeSeed * 12345.6 );\n}\n    \nInterference GetInterference( vec2 vUV )\n{\n    Interference interference;\n        \n    interference.noise = InterferenceNoise( vUV );\n    interference.scanLineRandom = InterferenceHash(vUV.y * 100.0 + fract(iTime * 1234.0) * 12345.0);\n    \n    return interference;\n}\n    \nvec3 SampleScreen( vec3 vUVW )\n{   \n    vec3 vAmbientEmissive = vec3(0.1);\n    vec3 vBlackEmissive = vec3(0.02);\n    float fBrightness = 1.75;\n    vec2 vResolution = vec2(480.0f, 576.0f);\n    vec2 vPixelCoord = vUVW.xy * vResolution;\n    \n    vec3 vPixelMatrix = GetPixelMatrix( vPixelCoord );\n    float fScanline = GetScanline( vPixelCoord );\n      \n    vec2 vTextureUV = vUVW.xy;\n    \/\/vec2 vTextureUV = vPixelCoord;\n    vTextureUV = floor(vTextureUV * vResolution * 2.0) \/ (vResolution * 2.0f);\n    \n    Interference interference = GetInterference( vTextureUV );\n\n    float noiseIntensity = 0.1;\n    \n    \/\/vTextureUV.x += (interference.scanLineRandom * 2.0f - 1.0f) * 0.025f * noiseIntensity;\n    \n    \n    vec3 vPixelEmissive = textureLod( iChannel0, vTextureUV.xy, 0.0 ).rgb;\n        \n    vPixelEmissive = clamp( vPixelEmissive + (interference.noise - 0.5) * 2.0 * noiseIntensity, 0.0, 1.0 );\n    \n\tvec3 vResult = (vPixelEmissive * vPixelEmissive * fBrightness + vBlackEmissive) * vPixelMatrix * fScanline + vAmbientEmissive;\n    \n    \/\/ TODO: feather edge?\n    if( any( greaterThanEqual( vUVW.xy, vec2(1.0) ) ) || any ( lessThan( vUVW.xy, vec2(0.0) ) ) || ( vUVW.z > 0.0 ) )\n    {\n        return vec3(0.0);\n    }\n    \n    return vResult;\n    \n}\n\nSurfaceInfo Scene_GetSurfaceInfo( const in vec3 vRayOrigin,  const in vec3 vRayDir, SceneResult traceResult )\n{\n    SurfaceInfo surfaceInfo;\n    \n    surfaceInfo.vPos = vRayOrigin + vRayDir * (traceResult.fDist);\n    \n    surfaceInfo.vNormal = Scene_GetNormal( surfaceInfo.vPos ); \n    surfaceInfo.vBumpNormal = surfaceInfo.vNormal;\n    surfaceInfo.vAlbedo = vec3(1.0);\n    surfaceInfo.vR0 = vec3( 0.02 );\n    surfaceInfo.fSmoothness = 1.0;\n    surfaceInfo.vEmissive = vec3( 0.0 );\n    \/\/return surfaceInfo;\n        \n    if ( traceResult.iObjectId == MAT_DEFAULT )\n    {\n    \tsurfaceInfo.vR0 = vec3( 0.02 );\n\t    surfaceInfo.vAlbedo = textureLod( iChannel2, traceResult.vUVW.xz * 2.0, 0.0 ).rgb;\n        surfaceInfo.vAlbedo = surfaceInfo.vAlbedo * surfaceInfo.vAlbedo;\n                        \n    \tsurfaceInfo.fSmoothness = clamp( 1.0 - surfaceInfo.vAlbedo.r * surfaceInfo.vAlbedo.r * 2.0, 0.0, 1.0);\n        \n    }\n    \n    if ( traceResult.iObjectId == MAT_SCREEN )\n    {\n        surfaceInfo.vAlbedo = vec3(0.02); \n        surfaceInfo.vEmissive = SampleScreen( traceResult.vUVW );        \n    }\n\n    if ( traceResult.iObjectId == MAT_TV_CASING )\n    {\n        surfaceInfo.vAlbedo = vec3(0.5, 0.4, 0.3); \n\t    surfaceInfo.fSmoothness = 0.4;        \n    }\n    \n    if ( traceResult.iObjectId == MAT_TV_TRIM )\n    {\n        surfaceInfo.vAlbedo = vec3(0.03, 0.03, 0.05); \n\t    surfaceInfo.fSmoothness = 0.5;\n    }    \n\n    if ( traceResult.iObjectId == MAT_CHROME )\n    {\n        surfaceInfo.vAlbedo = vec3(0.01, 0.01, 0.01); \n\t    surfaceInfo.fSmoothness = 0.9;\n    \tsurfaceInfo.vR0 = vec3( 0.8 );\n    }    \n \n    return surfaceInfo;\n}\n\n\/\/ Scene Description\n\nfloat SmoothMin( float a, float b, float k )\n{\n\t\/\/return min(a,b);\n\t\n\t\n    \/\/float k = 0.06;\n\tfloat h = clamp( 0.5 + 0.5*(b-a)\/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat UdRoundBox( vec3 p, vec3 b, float r )\n{\n    \/\/vec3 vToFace = abs(p) - b;\n    \/\/vec3 vConstrained = max( vToFace, 0.0 );\n    \/\/return length( vConstrained ) - r;\n    return length(max(abs(p)-b,0.0))-r;\n}\n\nSceneResult Scene_GetCRT( vec3 vScreenDomain, vec2 vScreenWH, float fScreenCurveRadius, float fBevel, float fDepth )\n{\n    SceneResult resultScreen;\n#if 1\n    vec3 vScreenClosest;\n    vScreenClosest.xy = max(abs(vScreenDomain.xy)-vScreenWH,0.0);\n    vec2 vCurveScreenDomain = vScreenDomain.xy;\n    vCurveScreenDomain = clamp( vCurveScreenDomain, -vScreenWH, vScreenWH );\n    float fCurveScreenProjection2 = fScreenCurveRadius * fScreenCurveRadius - vCurveScreenDomain.x * vCurveScreenDomain.x - vCurveScreenDomain.y * vCurveScreenDomain.y;\n    float fCurveScreenProjection = sqrt( fCurveScreenProjection2 ) - fScreenCurveRadius;\n    vScreenClosest.z = vScreenDomain.z - clamp( vScreenDomain.z, -fCurveScreenProjection, fDepth );\n    resultScreen.vUVW.z = vScreenDomain.z + fCurveScreenProjection;        \n    resultScreen.fDist = (length( vScreenClosest ) - fBevel) * 0.95;\n    \/\/resultScreen.fDist = (length( vScreenDomain - vec3(0,0,fScreenCurveRadius)) - fScreenCurveRadius - fBevel);    \n#endif    \n    \n#if 0\n    vec3 vScreenClosest;\n    vScreenClosest.xyz = max(abs(vScreenDomain.xyz)-vec3(vScreenWH, fDepth),0.0);\n    float fRoundDist = length( vScreenClosest.xyz ) - fBevel;\n    float fSphereDist = length( vScreenDomain - vec3(0,0,fScreenCurveRadius) ) - (fScreenCurveRadius + fBevel);    \n    resultScreen.fDist = max(fRoundDist, fSphereDist);\n#endif    \n    \n    resultScreen.vUVW.xy = (vScreenDomain.xy \/ vScreenWH) * 0.5 + 0.5f;\n\tresultScreen.iObjectId = MAT_SCREEN;\n    return resultScreen;\n}\n\nSceneResult Scene_GetComputer( vec3 vPos )\n{\n    SceneResult resultComputer;\n    resultComputer.vUVW = vPos.xzy;\n\t\n    float fXSectionStart = -0.2;\n    float fXSectionLength = 0.15;\n    float fXSectionT = clamp( (vPos.z - fXSectionStart) \/ fXSectionLength, 0.0, 1.0);\n    float fXSectionR1 = 0.03;\n    float fXSectionR2 = 0.05;\n    float fXSectionR = mix( fXSectionR1, fXSectionR2, fXSectionT );\n    float fXSectionZ = fXSectionStart + fXSectionT * fXSectionLength;\n    \n    vec2 vXSectionCentre = vec2(fXSectionR, fXSectionZ );\n    vec2 vToPos = vPos.yz - vXSectionCentre;\n    float l = length( vToPos );\n    if ( l > fXSectionR ) l = fXSectionR;\n    vec2 vXSectionClosest = vXSectionCentre + normalize(vToPos) * l;\n    \/\/float fXSectionDist = length( vXSectionClosest ) - fXSectionR;\n    \n    float x = max( abs( vPos.x ) - 0.2f, 0.0 );\n\n    resultComputer.fDist = length( vec3(x, vXSectionClosest - vPos.yz) )-0.01;\n    \/\/resultComputer.fDist = x;\n        \n    resultComputer.iObjectId = MAT_TV_CASING;\n\/*\n    vec3 vKeyPos = vPos.xyz - vec3(0,0.125,0);\n    vKeyPos.y -= vKeyPos.z * (fXSectionR2 - fXSectionR1) * 2.0 \/ fXSectionLength;\n    float fDomainRepeatScale = 0.02;\n    if ( fract(vKeyPos.z * 0.5 \/ fDomainRepeatScale + 0.25) > 0.5) vKeyPos.x += fDomainRepeatScale * 0.5;\n    vec2 vKeyIndex = round(vKeyPos.xz \/ fDomainRepeatScale);\n    vKeyIndex.x = clamp( vKeyIndex.x, -8.0, 8.0 );\n    vKeyIndex.y = clamp( vKeyIndex.y, -10.0, -5.0 );\n    \/\/vKeyPos.xz = (fract( vKeyPos.xz \/ fDomainRepeatScale ) - 0.5) * fDomainRepeatScale;\n    vKeyPos.xz = (vKeyPos.xz - (vKeyIndex) * fDomainRepeatScale);\n    vKeyPos.xz \/= 0.7 + vKeyPos.y;\n    SceneResult resultKey;    \n    resultKey.vUVW = vPos.xzy;\n    resultKey.fDist = UdRoundBox( vKeyPos, vec3(0.01), 0.001 );\n    resultKey.iObjectId = MAT_TV_TRIM;\n    Scene_Union( resultComputer, resultKey );\n*\/    \n    return resultComputer;\n}\n\nSceneResult Scene_GetDistance( vec3 vPos )\n{\n    SceneResult result;\n    \n\t\/\/result.fDist = vPos.y;\n    float fBenchBevel = 0.01;\n    result.fDist = UdRoundBox( vPos - vec3(0,-0.02-fBenchBevel,0.0), vec3(2.0, 0.02, 1.0), fBenchBevel );\n    result.vUVW = vPos;\n\tresult.iObjectId = MAT_DEFAULT;        \n    \n    vec3 vSetPos = vec3(0.0, 0.0, 0.0);\n    vec3 vScreenPos = vSetPos + vec3(0.0, 0.25, 0.00);\n    \n    \/\/vPos.x = fract( vPos.x - 0.5) - 0.5;\n    \n    vec2 vScreenWH = vec2(4.0, 3.0) \/ 25.0;\n\n    SceneResult resultSet;\n    resultSet.vUVW = vPos.xzy;\n\tresultSet.fDist = UdRoundBox( vPos - vScreenPos - vec3(0.0,-0.01,0.2), vec3(.21, 0.175, 0.18), 0.01 );\n    resultSet.iObjectId = MAT_TV_CASING;\n    Scene_Union( result, resultSet );\n\n    SceneResult resultSetRecess;\n    resultSetRecess.vUVW = vPos.xzy;\n    resultSetRecess.fDist = UdRoundBox( vPos - vScreenPos - vec3(0.0,-0.0, -0.05), vec3(vScreenWH + 0.01, 0.05) + 0.005, 0.015 );\n    resultSetRecess.iObjectId = MAT_TV_TRIM;\n\tScene_Subtract( result, resultSetRecess );\n    \n    SceneResult resultSetBase;\n    resultSetBase.vUVW = vPos.xzy;\n    float fBaseBevel = 0.03;\n\tresultSetBase.fDist = UdRoundBox( vPos - vSetPos - vec3(0.0,0.04,0.22), vec3(0.2, 0.04, 0.17) - fBaseBevel, fBaseBevel );\n    resultSetBase.iObjectId = MAT_TV_CASING;\n    Scene_Union( result, resultSetBase );\n\n\tSceneResult resultScreen = Scene_GetCRT( vPos - vScreenPos, vScreenWH, 0.75f, 0.02f, 0.1f );\n    Scene_Union( result, resultScreen );    \n    \n    \/\/SceneResult resultComputer = Scene_GetComputer( vPos - vec3(0.0, 0.0, -0.1) );\n    \/\/Scene_Union( result, resultComputer );\n\n    SceneResult resultSphere;\n    resultSet.vUVW = vPos.xzy;\n\tresultSet.fDist = length(vPos - vec3(0.35,0.075,-0.1)) - 0.075;\n    resultSet.iObjectId = MAT_CHROME;\n    Scene_Union( result, resultSet );    \n    \n    return result;\n}\n\n\n\n\/\/ Scene Lighting\n\nvec3 g_vSunDir = normalize(vec3(0.3, 0.4, -0.5));\nvec3 g_vSunColor = vec3(1, 0.95, 0.8) * 3.0;\nvec3 g_vAmbientColor = vec3(0.8, 0.8, 0.8) * 1.0;\n\nSurfaceLighting Scene_GetSurfaceLighting( const in vec3 vViewDir, in SurfaceInfo surfaceInfo )\n{\n    SurfaceLighting surfaceLighting;\n    \n    surfaceLighting.vDiffuse = vec3(0.0);\n    surfaceLighting.vSpecular = vec3(0.0);    \n    \n    Light_AddDirectional( surfaceLighting, surfaceInfo, vViewDir, g_vSunDir, g_vSunColor );\n    \n    Light_AddPoint( surfaceLighting, surfaceInfo, vViewDir, vec3(1.4, 2.0, 0.8), vec3(1,1,1) * 0.2 );\n    \n    float fAO = Scene_GetAmbientOcclusion( surfaceInfo.vPos, surfaceInfo.vNormal );\n    \/\/ AO\n    surfaceLighting.vDiffuse += fAO * (surfaceInfo.vBumpNormal.y * 0.5 + 0.5) * g_vAmbientColor;\n    \n    return surfaceLighting;\n}\n\n\/\/ Environment\n\nvec4 Env_GetSkyColor( const vec3 vViewPos, const vec3 vViewDir )\n{\n\tvec4 vResult = vec4( 0.0, 0.0, 0.0, kFarDist );\n\n#if 1\n    vec3 vEnvMap = textureLod( iChannel1, vViewDir.zyx, 0.0 ).rgb;\n    vResult.rgb = vEnvMap;\n#endif    \n    \n#if 0\n    vec3 vEnvMap = textureLod( iChannel1, vViewDir.zyx, 0.0 ).rgb;\n    vEnvMap = vEnvMap * vEnvMap;\n    float kEnvmapExposure = 0.999;\n    vResult.rgb = -log2(1.0 - vEnvMap * kEnvmapExposure);\n\n#endif\n    \n    \/\/ Sun\n    \/\/float NdotV = dot( g_vSunDir, vViewDir );\n    \/\/vResult.rgb += smoothstep( cos(radians(.7)), cos(radians(.5)), NdotV ) * g_vSunColor * 5000.0;\n\n    return vResult;\t\n}\n\nfloat Env_GetFogFactor(const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist )\n{    \n\tfloat kFogDensity = 0.00001;\n\treturn exp(fDist * -kFogDensity);\t\n}\n\nvec3 Env_GetFogColor(const in vec3 vDir)\n{    \n\treturn vec3(0.2, 0.5, 0.6) * 2.0;\t\t\n}\n\nvec3 Env_ApplyAtmosphere( const in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist )\n{\n    \/\/return vColor;\n    vec3 vResult = vColor;\n    \n    \n\tfloat fFogFactor = Env_GetFogFactor( vRayOrigin, vRayDir, fDist );\n\tvec3 vFogColor = Env_GetFogColor( vRayDir );\t\n\t\/\/Env_AddDirectionalLightFlareToFog( vFogColor, vRayDir, g_vSunDir, g_vSunColor * 3.0);    \n    vResult = mix( vFogColor, vResult, fFogFactor );\n\n    return vResult;\t    \n}\n\n\nvec3 FX_Apply( in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist)\n{    \n    return vColor;\n}\n\n\nvec4 MainCommon( vec3 vRayOrigin, vec3 vRayDir )\n{\n\tvec4 vColorLinAndDepth = Scene_GetColorAndDepth( vRayOrigin, vRayDir );    \n    vColorLinAndDepth.rgb = max( vColorLinAndDepth.rgb, vec3(0.0) );\n    \n    vec4 vFragColor = vColorLinAndDepth;\n    \n    float fExposure = 2.0f;\n    \n    vFragColor.rgb *= fExposure;\n    \n    vFragColor.a = vColorLinAndDepth.w;\n    \n    return vFragColor;\n}\n\nCameraState GetCameraPosition( int index )\n{\n    CameraState cam;\n\n    vec3 vFocus = vec3(0,0.25,-0.012);   \n    \n    if ( index > 9 )\n    {\n    \tindex = int(hash11(float(index) \/ 10.234) * 100.0);\n    \tindex = index % 10;\n    }\n\n    \/\/index=2;\n    \n    if ( index == 0 )\n    {\n        cam.vPos = vec3(-0.1,0.2,-0.08);\n        cam.vTarget = vec3(0,0.25,0.1);\n        cam.fFov = 10.0;\n    }\n    if ( index == 1 )\n    {\n        cam.vPos = vec3(0.01,0.334,-0.03);\n        cam.vTarget = vec3(0,0.3,0.1);\n        cam.fFov = 10.0;\n    }\n    if ( index == 2 )\n    {\n        cam.vPos = vec3(-0.8,0.3,-1.0);\n        cam.vTarget = vec3(0.4,0.18,0.5);\n        cam.fFov = 10.0;\n    }\n    if ( index == 3 )\n    {\n        cam.vPos = vec3(-0.8,1.0,-1.5);\n        cam.vTarget = vec3(0.2,0.0,0.5);\n        cam.fFov = 10.0;\n    }\n    if ( index == 4 )\n    {\n        cam.vPos = vec3(-0.8,0.3,-1.0);\n        cam.vTarget = vec3(0.4,0.18,0.5);\n        cam.fFov = 20.0;\n    }\n    if ( index == 5 )\n    {\n        cam.vPos = vec3(-0.244,0.334,-0.0928);\n        cam.vTarget = vec3(0,0.25,0.1);\n        cam.fFov = 20.0;\n    }\n    if ( index == 6 )\n    {\n        cam.vPos = vec3(0.0,0.1,-0.5);\n        cam.vTarget = vec3(0.2,0.075,-0.1);\n        vFocus = cam.vTarget; \n        cam.fFov = 15.0;\n    }\n    if ( index == 7 )\n    {\n        cam.vPos = vec3(-0.01,0.01,-0.25);\n        cam.vTarget = vec3(0.01,0.27,0.1);\n        vFocus = cam.vTarget; \n        cam.fFov = 23.0;\n    }\n    if ( index == 8 )\n    {\n        cam.vPos = vec3(-0.23,0.3,-0.05);\n        cam.vTarget = vec3(0.1,0.2,0.1);\n        cam.fFov = 15.0;\n    }\n    if ( index == 9 )\n    {\n        cam.vPos = vec3(0.4,0.2,-0.2);\n        cam.vTarget = vec3(-0.1,0.25,0.1);\n        cam.fFov = 12.0;\n    }\n    \n    cam.fPlaneInFocus = length( vFocus - cam.vPos);\n    cam.vJitter = vec2(0.0);        \n    \n    return cam;\n}\n\nvoid mainImage( out vec4 vFragColor, in vec2 vFragCoord )\n{\n    vec2 vUV = vFragCoord.xy \/ iResolution.xy; \n\n    CameraState cam;\n    \n    {\n    \tCameraState camA;\n    \tCameraState camB;\n    \n        float fSeqTime = iTime;\n        float fSequenceSegLength = 5.0;\n        float fSeqIndex = floor(fSeqTime \/ fSequenceSegLength);\n        float fSeqPos = fract(fSeqTime \/ fSequenceSegLength);\n        int iIndex = int(fSeqIndex);\n\t\tint iIndexNext = int(fSeqIndex) + 1;\n        camA = GetCameraPosition(iIndex);\n        camB = GetCameraPosition(iIndexNext);\n        \n        float t = smoothstep(0.3, 1.0, fSeqPos);\n        cam.vPos = mix(camA.vPos, camB.vPos, t );\n        cam.vTarget = mix(camA.vTarget, camB.vTarget, t );\n        cam.fFov = mix(camA.fFov, camB.fFov, t );\n        cam.fPlaneInFocus = mix(camA.fPlaneInFocus, camB.fPlaneInFocus, t );\n    }\n    \n    if ( iMouse.z > 0.0 )\n    {\n        float fDist = 0.01 + 3.0 * (iMouse.y \/ iResolution.y);\n\n        float fAngle = (iMouse.x \/ iResolution.x) * radians(360.0);\n    \t\/\/float fElevation = (iMouse.y \/ iResolution.y) * radians(90.0);\n    \tfloat fElevation = 0.15f * radians(90.0);    \n\n        cam.vPos = vec3(sin(fAngle) * fDist * cos(fElevation),sin(fElevation) * fDist,cos(fAngle) * fDist * cos(fElevation));\n        cam.vTarget = vec3(0,0.25,0.1);\n        cam.vPos +=cam.vTarget;\n        cam.fFov = 20.0 \/ (1.0 + fDist * 0.5);\n    \tvec3 vFocus = vec3(0,0.25,-0.012);\t    \n\t    cam.fPlaneInFocus = length( vFocus - cam.vPos );\n    }\n    \n#if 0\n    {\n        float fDist = 0.5;\n\n        float fAngle = 0.6 * PI * 2.0f;\n        float fElevation = 0.2;\n        \n        cam.vPos = vec3(sin(fAngle) * fDist * cos(fElevation),sin(fElevation) * fDist,cos(fAngle) * fDist * cos(fElevation));\n        cam.vTarget = vec3(0.05,0.25,0.1);\n        cam.vPos +=cam.vTarget;\n        cam.fFov = 22.0;\n    \tvec3 vFocus = vec3(0,0.25,-0.012);\t    \n\t    cam.fPlaneInFocus = length( vFocus - cam.vPos );\n    }\n#endif\n    \n#ifdef ENABLE_TAA_JITTER\n    cam.vJitter = hash21( fract( iTime ) ) - 0.5f;\n#endif\n    \n            \n    vec3 vRayOrigin, vRayDir;\n    vec2 vJitterUV = vUV + cam.vJitter \/ iResolution.xy;\n    Cam_GetCameraRay( vJitterUV, iResolution.xy, cam, vRayOrigin, vRayDir );\n \n    float fHitDist = 0.0f;\n    vFragColor = MainCommon( vRayOrigin, vRayDir );\n    \n    \n\tCam_StoreState( ivec2(0), cam, vFragColor, ivec2(vFragCoord.xy) );    \n}\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"\/media\/previz\/buffer03.png","previewfilepath":"\/media\/previz\/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\/\/ Meta CRT - @P_Malin\n\/\/ https:\/\/www.shadertoy.com\/view\/4dlyWX#\n\/\/ In which I add and remove aliasing\n\n\/\/ Temporal Anti-aliasing Pass\n\n#define ENABLE_TAA\n\n#define iChannelCurr iChannel0\n#define iChannelHistory iChannel1\n\nvec3 Tonemap( vec3 x )\n{\n    float a = 0.010;\n    float b = 0.132;\n    float c = 0.010;\n    float d = 0.163;\n    float e = 0.101;\n\n    return ( x * ( a * x + b ) ) \/ ( x * ( c * x + d ) + e );\n}\n\nvec3 TAA_ColorSpace( vec3 color )\n{\n    return Tonemap(color);\n}\n\n\nvoid mainImage( out vec4 vFragColor, in vec2 vFragCoord )\n{\n    CameraState camCurr;\n\tCam_LoadState( camCurr, iChannelCurr, ivec2(0) );\n    \n    CameraState camPrev;\n\tCam_LoadState( camPrev, iChannelHistory, ivec2(0) );\n\n    vec2 vUV = vFragCoord.xy \/ iResolution.xy;\n \tvec2 vUnJitterUV = vUV - camCurr.vJitter \/ iResolution.xy;    \n    \n    vFragColor = textureLod(iChannelCurr, vUnJitterUV, 0.0);\n    \n    \n#ifdef ENABLE_TAA\n    vec3 vRayOrigin, vRayDir;\n    Cam_GetCameraRay( vUV, iResolution.xy, camCurr, vRayOrigin, vRayDir );    \n    float fDepth;\n    int iObjectId;\n    vec4 vCurrTexel = texelFetch( iChannelCurr, ivec2(vFragCoord.xy), 0);\n    fDepth = DecodeDepthAndObjectId( vCurrTexel.w, iObjectId );\n    vec3 vWorldPos = vRayOrigin + vRayDir * fDepth;\n    \n    vec2 vPrevUV = Cam_GetUVFromWindowCoord( Cam_WorldToWindowCoord(vWorldPos, camPrev), iResolution.xy );\/\/ + camPrev.vJitter \/ iResolution.xy;\n        \n    if ( all( greaterThanEqual( vPrevUV, vec2(0) )) && all( lessThan( vPrevUV, vec2(1) )) )\n\t{\n        vec3 vMin = vec3( 10000);\n        vec3 vMax = vec3(-10000);\n        \n\t    ivec2 vCurrXY = ivec2(floor(vFragCoord.xy));    \n        \n        int iNeighborhoodSize = 1;\n        for ( int iy=-iNeighborhoodSize; iy<=iNeighborhoodSize; iy++)\n        {\n            for ( int ix=-iNeighborhoodSize; ix<=iNeighborhoodSize; ix++)\n            {\n                ivec2 iOffset = ivec2(ix, iy);\n\t\t        vec3 vTest = TAA_ColorSpace( texelFetch( iChannelCurr, vCurrXY + iOffset, 0 ).rgb );\n                                \n                vMin = min( vMin, vTest );\n                vMax = max( vMax, vTest );\n            }\n        }\n        \n        float epsilon = 0.001;\n        vMin -= epsilon;\n        vMax += epsilon;\n        \n        float fBlend = 0.0f;\n        \n        \/\/ivec2 vPrevXY = ivec2(floor(vPrevUV.xy * iResolution.xy));\n        vec4 vHistory = textureLod( iChannelHistory, vPrevUV, 0.0 );\n\n        vec3 vPrevTest = TAA_ColorSpace( vHistory.rgb );\n        if( all( greaterThanEqual(vPrevTest, vMin ) ) && all( lessThanEqual( vPrevTest, vMax ) ) )\n        {\n            fBlend = 0.9;\n            \/\/vFragColor.r *= 0.0;\n        }\n        \n        vFragColor.rgb = mix( vFragColor.rgb, vHistory.rgb, fBlend);\n    }  \n    else\n    {\n        \/\/vFragColor.gb *= 0.0;\n    }\n\n#endif\n    \n    vFragColor.rgb += (hash13( vec3( vFragCoord, iTime ) ) * 2.0 - 1.0) * 0.03;\n    \n\tCam_StoreState( ivec2(0), camCurr, vFragColor, ivec2(vFragCoord.xy) );    \n\tCam_StoreState( ivec2(3,0), camPrev, vFragColor, ivec2(vFragCoord.xy) );    \n}\n","name":"Buffer D","description":"","type":"buffer"},{"inputs":[{"id":"XdX3zn","filepath":"\/media\/a\/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"\/media\/ap\/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"\/\/    _    _ _____  _____     _____      _                                \n\/\/   | |  | |  __ \\|  __ \\   \/ ____|    | |                               \n\/\/   | |__| | |  | | |__) | | |    _   _| |__   ___ _ __ ___   __ _ _ __  \n\/\/   |  __  | |  | |  _  \/  | |   | | | | '_ \\ \/ _ \\ '_ ` _ \\ \/ _` | '_ \\ \n\/\/   | |  | | |__| | | \\ \\  | |___| |_| | |_) |  __\/ | | | | | (_| | |_) |\n\/\/   |_|  |_|_____\/|_|  \\_\\  \\_____\\__,_|_.__\/ \\___|_| |_| |_|\\__,_| .__\/ \n\/\/                                                                 | |    \n\/\/                                                                 |_|    \n\n\/\/ Convert a shadertoy LDR cubemap to HDR\n\/\/ This at least gives us linear HDR filtering and mipmaps\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    if ( iFrame > 120 )\n        discard;\n    fragColor = textureLod( iChannel0, rayDir, 0.0 );\n    fragColor = fragColor * fragColor;\n    float kEnvmapExposure = 0.999;\n    fragColor = -log2(1.0 - fragColor * kEnvmapExposure);    \n    return;\n}","name":"Cube A","description":"","type":"cubemap"},{"inputs":[],"outputs":[],"code":"#define PI 3.141592654\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Hash Functions\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ From: Hash without Sine by Dave Hoskins\n\/\/ https:\/\/www.shadertoy.com\/view\/4djSRW\n\n\/\/ *** Use this for integer stepped ranges, ie Value-Noise\/Perlin noise functions.\n\/\/#define HASHSCALE1 .1031\n\/\/#define HASHSCALE3 vec3(.1031, .1030, .0973)\n\/\/#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\n\/\/ For smaller input rangers like audio tick or 0-1 UVs use these...\n#define HASHSCALE1 443.8975\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n#define HASHSCALE4 vec3(443.897, 441.423, 437.195, 444.129)\n\n\n\/\/----------------------------------------------------------------------------------------\n\/\/  1 out, 1 in...\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\/\/  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n\/\/\/  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n\/\/  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Data Storage\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec4 LoadVec4( sampler2D sampler, in ivec2 vAddr )\n{\n    return texelFetch( sampler, vAddr, 0 );\n}\n\nvec3 LoadVec3( sampler2D sampler, in ivec2 vAddr )\n{\n    return LoadVec4( sampler, vAddr ).xyz;\n}\n\nbool AtAddress( ivec2 p, ivec2 c ) { return all( equal( p, c ) ); }\n\nvoid StoreVec4( in ivec2 vAddr, in vec4 vValue, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    fragColor = AtAddress( fragCoord, vAddr ) ? vValue : fragColor;\n}\n\nvoid StoreVec3( in ivec2 vAddr, in vec3 vValue, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    StoreVec4( vAddr, vec4( vValue, 0.0 ), fragColor, fragCoord);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Camera\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nstruct CameraState\n{\n    vec3 vPos;\n    vec3 vTarget;\n    float fFov;\n    vec2 vJitter;\n    float fPlaneInFocus;\n};\n    \nvoid Cam_LoadState( out CameraState cam, sampler2D sampler, ivec2 addr )\n{\n    vec4 vPos = LoadVec4( sampler, addr + ivec2(0,0) );\n    cam.vPos = vPos.xyz;\n    vec4 targetFov = LoadVec4( sampler, addr + ivec2(1,0) );\n    cam.vTarget = targetFov.xyz;\n    cam.fFov = targetFov.w;\n    vec4 jitterDof = LoadVec4( sampler, addr + ivec2(2,0) );\n    cam.vJitter = jitterDof.xy;\n    cam.fPlaneInFocus = jitterDof.z;\n}\n\nvoid Cam_StoreState( ivec2 addr, const in CameraState cam, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    StoreVec4( addr + ivec2(0,0), vec4( cam.vPos, 0 ), fragColor, fragCoord );\n    StoreVec4( addr + ivec2(1,0), vec4( cam.vTarget, cam.fFov ), fragColor, fragCoord );    \n    StoreVec4( addr + ivec2(2,0), vec4( cam.vJitter, cam.fPlaneInFocus, 0 ), fragColor, fragCoord );    \n}\n\nmat3 Cam_GetWorldToCameraRotMatrix( const CameraState cameraState )\n{\n    vec3 vForward = normalize( cameraState.vTarget - cameraState.vPos );\n\tvec3 vRight = normalize( cross(vec3(0, 1, 0), vForward) );\n\tvec3 vUp = normalize( cross(vForward, vRight) );\n    \n    return mat3( vRight, vUp, vForward );\n}\n\nvec2 Cam_GetViewCoordFromUV( vec2 vUV, vec2 res )\n{\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= res.x \/ res.y;\n\n\treturn vWindow;\t\n}\n\nvoid Cam_GetCameraRay( vec2 vUV, vec2 res, CameraState cam, out vec3 vRayOrigin, out vec3 vRayDir )\n{\n    vec2 vView = Cam_GetViewCoordFromUV( vUV, res );\n    vRayOrigin = cam.vPos;\n    float fPerspDist = 1.0 \/ tan( radians( cam.fFov ) );\n    vRayDir = normalize( Cam_GetWorldToCameraRotMatrix( cam ) * vec3( vView, fPerspDist ) );\n}\n\nvec2 Cam_GetUVFromWindowCoord( vec2 vWindow, vec2 res )\n{\n    vec2 vScaledWindow = vWindow;\n    vScaledWindow.x *= res.y \/ res.x;\n\n    return (vScaledWindow * 0.5 + 0.5);\n}\n\nvec2 Cam_WorldToWindowCoord(const in vec3 vWorldPos, const in CameraState cameraState )\n{\n    vec3 vOffset = vWorldPos - cameraState.vPos;\n    vec3 vCameraLocal;\n\n    vCameraLocal = vOffset * Cam_GetWorldToCameraRotMatrix( cameraState );\n\t\n    vec2 vWindowPos = vCameraLocal.xy \/ (vCameraLocal.z * tan( radians( cameraState.fFov ) ));\n    \n    return vWindowPos;\n}\n\nfloat EncodeDepthAndObject( float depth, int objectId )\n{\n    \/\/depth = max( 0.0, depth );\n    \/\/objectId = max( 0, objectId + 1 );\n    \/\/return exp2(-depth) + float(objectId);\n    return depth;\n}\n\nfloat DecodeDepthAndObjectId( float value, out int objectId )\n{\n    objectId = 0;\n    return max(0.0, value);\n    \/\/objectId = int( floor( value ) ) - 1; \n    \/\/return abs( -log2(fract(value)) );\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"XdcGWS","date":"1452730410","viewed":16925,"name":"Shader Rally","username":"P_Malin","description":"Physics Hackery using the new mutipass things.\nWASD to drive. Space = brake\nClick mouse to orbit camera\nG toggle gravity\nV toggle wheels (vehicle forces)\n. and , flip car","likes":203,"published":3,"flags":49,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Shader Rally - @P_Malin\n\n\/\/ (Uncomment FAST_VERSION in \"Buf C\" for a framerate boost)\n\n\/\/ Physics Hackery using the new mutipass things.\n\n\/\/ WASD to drive. Space = brake\n\/\/ G toggle gravity\n\/\/ V toggle wheels (vehicle forces)\n\/\/ . and , flip car\n\n\/\/ Restart shader to reset car\n\n\/\/ I'll add more soon (including a fast version of the rendering code maybe :)\n\n\/\/ Image shader - final postprocessing\n\n#define MOTION_BLUR_TAPS 32\n\nivec2 addrVehicle = ivec2( 0.0, 0.0 );\n\nivec2 offsetVehicleParam0 = ivec2( 0.0, 0.0 );\n\nivec2 offsetVehicleBody = ivec2( 1.0, 0.0 );\nivec2 offsetBodyPos = ivec2( 0.0, 0.0 );\nivec2 offsetBodyRot = ivec2( 1.0, 0.0 );\nivec2 offsetBodyMom = ivec2( 2.0, 0.0 );\nivec2 offsetBodyAngMom = ivec2( 3.0, 0.0 );\n\nivec2 offsetVehicleWheel0 = ivec2( 5.0, 0.0 );\nivec2 offsetVehicleWheel1 = ivec2( 7.0, 0.0 );\nivec2 offsetVehicleWheel2 = ivec2( 9.0, 0.0 );\nivec2 offsetVehicleWheel3 = ivec2( 11.0, 0.0 );\n\nivec2 offsetWheelState = ivec2( 0.0, 0.0 );\nivec2 offsetWheelContactState = ivec2( 1.0, 0.0 );\n\n\nivec2 addrCamera = ivec2( 0.0, 1.0 );\nivec2 offsetCameraPos = ivec2( 0.0, 0.0 );\nivec2 offsetCameraTarget = ivec2( 1.0, 0.0 );\n\nivec2 addrPrevCamera = ivec2( 0.0, 2.0 );\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Storage\n\nvec4 LoadVec4( in ivec2 vAddr )\n{\n    return texelFetch( iChannel0, vAddr, 0 );\n}\n\nvec3 LoadVec3( in ivec2 vAddr )\n{\n    return LoadVec4( vAddr ).xyz;\n}\n\nbool AtAddress( vec2 p, ivec2 c ) { return all( equal( floor(p), vec2(c) ) ); }\n\nvoid StoreVec4( in ivec2 vAddr, in vec4 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = AtAddress( fragCoord, vAddr ) ? vValue : fragColor;\n}\n\nvoid StoreVec3( in ivec2 vAddr, in vec3 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec4( vAddr, vec4( vValue, 0.0 ), fragColor, fragCoord);\n}\n\n\nvec3 ApplyPostFX( const in vec2 vUV, const in vec3 vInput );\n\n\/\/ CAMERA\n\nvec2 GetWindowCoord( const in vec2 vUV )\n{\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= iResolution.x \/ iResolution.y;\n\n\treturn vWindow;\t\n}\n\nvec2 GetUVFromWindowCoord( const in vec2 vWindow )\n{\n\tvec2 vScaledWindow = vWindow;\n    vScaledWindow.x *= iResolution.y \/ iResolution.x;\n    \n\t return vScaledWindow * 0.5 + 0.5;\n}\n\n\nvec3 GetCameraRayDir( const in vec2 vWindow, const in vec3 vCameraPos, const in vec3 vCameraTarget )\n{\n\tvec3 vForward = normalize(vCameraTarget - vCameraPos);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n\t\t\t\t\t\t\t  \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * 2.0);\n\n\treturn vDir;\n}\n\nvec2 GetCameraWindowCoord(const in vec3 vWorldPos, const in vec3 vCameraPos, const in vec3 vCameraTarget)\n{\n\tvec3 vForward = normalize(vCameraTarget - vCameraPos);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n\t\n    vec3 vOffset = vWorldPos - vCameraPos;\n    vec3 vCameraLocal;\n    vCameraLocal.x = dot(vOffset, vRight);\n    vCameraLocal.y = dot(vOffset, vUp);\n    vCameraLocal.z = dot(vOffset, vForward);\n\n    vec2 vWindowPos = vCameraLocal.xy \/ (vCameraLocal.z \/ 2.0);\n    \n    return vWindowPos;\n}\n\nfloat GetCoC( float fDistance, float fPlaneInFocus )\n{\n\t\/\/ http:\/\/http.developer.nvidia.com\/GPUGems\/gpugems_ch23.html\n\n    float fAperture = 0.03;\n    float fFocalLength = 1.0;\n    \n\treturn abs(fAperture * (fFocalLength * (fDistance - fPlaneInFocus)) \/\n          (fDistance * (fPlaneInFocus - fFocalLength)));  \n}\n\n\n\/\/ Random\n\n#define MOD2 vec2(4.438975,3.972973)\n\nfloat Hash( float p ) \n{\n    \/\/ https:\/\/www.shadertoy.com\/view\/4djSRW - Dave Hoskins\n\tvec2 p2 = fract(vec2(p) * MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);    \n}\n\n\nfloat fGolden = 3.141592 * (3.0 - sqrt(5.0));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vUV = fragCoord.xy \/ iResolution.xy;\n\n    vec4 vSample = textureLod( iChannel1, vUV, 0.0 ).rgba;\n\t\n    float fDepth = abs(vSample.w);\n    \n\tvec3 vCameraPos = LoadVec3( addrCamera + offsetCameraPos );\n\tvec3 vCameraTarget = LoadVec3( addrCamera + offsetCameraTarget );\n    \n\tvec3 vRayOrigin = vCameraPos;\n\tvec3 vRayDir = GetCameraRayDir( GetWindowCoord(vUV), vCameraPos, vCameraTarget );\n        \n    vec3 vWorldPos = vRayOrigin + vRayDir * fDepth;\n    \n\tvec3 vPrevCameraPos = LoadVec3( addrPrevCamera + offsetCameraPos );\n\tvec3 vPrevCameraTarget = LoadVec3( addrPrevCamera + offsetCameraTarget );\n    vec2 vPrevWindow = GetCameraWindowCoord( vWorldPos, vPrevCameraPos, vPrevCameraTarget );\n    vec2 vPrevUV = GetUVFromWindowCoord(vPrevWindow);\n    \n    if( vSample.a < 0.0 ) \n    {\n        vPrevUV = vUV;\n    }\n        \n\tvec3 vResult = vec3(0.0);\n    \n    float fTot = 0.0;\n    \n    float fPlaneInFocus = length(vCameraPos - vCameraTarget);\n    \n    float fCoC = GetCoC( abs(fDepth), fPlaneInFocus );\n    \n    float r = 1.0;\n    vec2 vangle = vec2(0.0,fCoC); \/\/ Start angle\n    \n    vResult.rgb = vSample.rgb * fCoC;\n    fTot += fCoC;\n    \n    float fMotionBlurTaps = float(MOTION_BLUR_TAPS);\n    \n    float f = 0.0;\n    float fIndex = 0.0;\n    for(int i=1; i<MOTION_BLUR_TAPS; i++)\n    {\n        vec2 vTapUV = mix( vUV, vPrevUV, f \/ fMotionBlurTaps - 0.5 );\n                \n        float fRand = Hash( iTime + fIndex + vUV.x + vUV.y * 12.345);\n        \n        \/\/ http:\/\/blog.marmakoide.org\/?p=1\n        \n        float fTheta = fRand * fGolden * fMotionBlurTaps;\n        float fRadius = fCoC * sqrt( fRand * fMotionBlurTaps ) \/ sqrt( fMotionBlurTaps );        \n        \n        vTapUV += vec2( sin(fTheta), cos(fTheta) ) * fRadius;\n        \n        vec4 vTapSample = textureLod( iChannel1, vTapUV, 0.0 ).rgba;\n        if( sign(vTapSample.a) == sign(vSample.a) )\n        {\n  \t\t  \tfloat fCurrCoC = GetCoC( abs(vTapSample.a), fPlaneInFocus );\n            \n            float fWeight = fCurrCoC + 1.0;\n            \n    \t\tvResult += vTapSample.rgb * fWeight;\n        \tfTot += fWeight;\n        }\n        f += 1.0;\n        fIndex += 1.0;\n    }\n    vResult \/= fTot;\n        \n\tvec3 vFinal = ApplyPostFX( vUV, vResult );\n\n    \/\/ Draw depth\n    \/\/vFinal = vec3(1.0) \/ abs(vSample.a);    \n    \n\tfragColor = vec4(vFinal, 1.0);\n}\n\n\/\/ POSTFX\n\nvec3 ApplyVignetting( const in vec2 vUV, const in vec3 vInput )\n{\n\tvec2 vOffset = (vUV - 0.5) * sqrt(2.0);\n\t\n\tfloat fDist = dot(vOffset, vOffset);\n\t\n\tconst float kStrength = 0.75;\n\t\n\tfloat fShade = mix( 1.0, 1.0 - kStrength, fDist );\t\n\n\treturn vInput * fShade;\n}\n\nvec3 Tonemap( vec3 x )\n{\n    float a = 0.010;\n    float b = 0.132;\n    float c = 0.010;\n    float d = 0.163;\n    float e = 0.101;\n\n    return ( x * ( a * x + b ) ) \/ ( x * ( c * x + d ) + e );\n}\n\nvec3 ColorGrade( vec3 vColor )\n{\n    vec3 vHue = vec3(1.0, .7, .2);\n    \n    vec3 vGamma = 1.0 + vHue * 0.6;\n    vec3 vGain = vec3(.9) + vHue * vHue * 8.0;\n    \n    vColor *= 1.5;\n    \n    float fMaxLum = 100.0;\n    vColor \/= fMaxLum;\n    vColor = pow( vColor, vGamma );\n    vColor *= vGain;\n    vColor *= fMaxLum;  \n    return vColor;\n}\n\nvec3 ApplyGamma( const in vec3 vLinear )\n{\n\tconst float kGamma = 2.2;\n\n\treturn pow(vLinear, vec3(1.0\/kGamma));\t\n}\n\nvec3 ApplyPostFX( const in vec2 vUV, const in vec3 vInput )\n{\n\tvec3 vTemp = ApplyVignetting( vUV, vInput );\t\n\t\n\tvTemp = vTemp * 2.0;\n    \n    vTemp = ColorGrade( vTemp );\n    \n\treturn Tonemap( vTemp );\t\t\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"\/presets\/tex00.jpg","previewfilepath":"\/presets\/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ Shader Rally - @P_Malin\n\n\/\/ Physics Hackery using the new mutipass things.\n\n\/\/ WASD to drive. Space = brake\n\/\/ G toggle gravity\n\/\/ V toggle wheels (vehicle forces)\n\/\/ . and , flip car\n\n\/\/ Simulation Shader\n\n\/\/#define ENABLE_DEBUG_FORCES\n#define ENABLE_GRAVITY_TOGGLE\n\nivec2 addrVehicle = ivec2( 0.0, 0.0 );\n\nivec2 offsetVehicleParam0 = ivec2( 0.0, 0.0 );\n\nivec2 offsetVehicleBody = ivec2( 1.0, 0.0 );\nivec2 offsetBodyPos = ivec2( 0.0, 0.0 );\nivec2 offsetBodyRot = ivec2( 1.0, 0.0 );\nivec2 offsetBodyMom = ivec2( 2.0, 0.0 );\nivec2 offsetBodyAngMom = ivec2( 3.0, 0.0 );\n\nivec2 offsetVehicleWheel0 = ivec2( 5.0, 0.0 );\nivec2 offsetVehicleWheel1 = ivec2( 7.0, 0.0 );\nivec2 offsetVehicleWheel2 = ivec2( 9.0, 0.0 );\nivec2 offsetVehicleWheel3 = ivec2( 11.0, 0.0 );\n\nivec2 offsetWheelState = ivec2( 0.0, 0.0 );\nivec2 offsetWheelContactState = ivec2( 1.0, 0.0 );\n\n\nivec2 addrCamera = ivec2( 0.0, 1.0 );\nivec2 offsetCameraPos = ivec2( 0.0, 0.0 );\nivec2 offsetCameraTarget = ivec2( 1.0, 0.0 );\n\nivec2 addrPrevCamera = ivec2( 0.0, 2.0 );\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Constants\n\nfloat PI = acos(-1.0);\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Storage\n\nvec4 LoadVec4( in ivec2 vAddr )\n{\n    return texelFetch( iChannel0, vAddr, 0 );\n}\n\nvec3 LoadVec3( in ivec2 vAddr )\n{\n    return LoadVec4( vAddr ).xyz;\n}\n\nbool AtAddress( vec2 p, ivec2 c ) { return all( equal( floor(p), vec2(c) ) ); }\n\nvoid StoreVec4( in ivec2 vAddr, in vec4 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = AtAddress( fragCoord, vAddr ) ? vValue : fragColor;\n}\n\nvoid StoreVec3( in ivec2 vAddr, in vec3 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec4( vAddr, vec4( vValue, 0.0 ), fragColor, fragCoord);\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ Keyboard \n\n\n\/\/ Keyboard constants definition\nconst int KEY_SPACE = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\nconst int KEY_COMMA = 188;\nconst int KEY_PER   = 190;\n\nbool KeyIsPressed(int key)\n{\n\treturn texelFetch( iChannel1, ivec2(key, 0), 0 ).x > 0.0;\n}\n\nbool KeyIsToggled(int key)\n{\n\treturn texelFetch( iChannel1, ivec2(key, 2), 0 ).x > 0.0;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Rotation\n\nvec2 Rotate( const in vec2 vPos, const in float t )\n{\n    float s = sin(t);\n    float c = cos(t);\n    \n    return vec2( c * vPos.x + s * vPos.y, -s * vPos.x + c * vPos.y);\n}\n\nvec3 RotX( const in vec3 vPos, float t )\n{\n    vec3 result;\n    result.x = vPos.x;\n  \tresult.yz = Rotate( vPos.yz, t );\n    return result;\n}\n\nvec3 RotY( const in vec3 vPos, float t )\n{\n    vec3 result;\n    result.y = vPos.y;\n  \tresult.xz = Rotate( vPos.xz, t );\n    return result;\n}\n\nvec3 RotZ( const in vec3 vPos, float t )\n{\n    vec3 result;\n    result.z = vPos.z;\n  \tresult.xy = Rotate( vPos.xy, t );\n    return result;\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Vec\n\nvec3 Vec3Parallel( vec3 x, vec3 n )\n{\n    float d = dot( x, n );\n    \n    return x - n * d;    \n}\n\nvec3 Vec3Perp( vec3 x, vec3 n )\n{\n    return x - Vec3Parallel( x, n );\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Quaternions\n\nvec4 QuatMul(const in vec4 lhs, const in vec4 rhs) \n{\n      return vec4( lhs.y*rhs.z - lhs.z*rhs.y + lhs.x*rhs.w + lhs.w*rhs.x,\n                   lhs.z*rhs.x - lhs.x*rhs.z + lhs.y*rhs.w + lhs.w*rhs.y,\n                   lhs.x*rhs.y - lhs.y*rhs.x + lhs.z*rhs.w + lhs.w*rhs.z,\n                   lhs.w*rhs.w - lhs.x*rhs.x - lhs.y*rhs.y - lhs.z*rhs.z);\n}\n\nvec4 QuatFromAxisAngle( vec3 vAxis, float fAngle )\n{\n\treturn vec4( normalize(vAxis) * sin(fAngle), cos(fAngle) );    \n}\n\nvec4 QuatFromVec3( vec3 vRot )\n{\n    float l = length( vRot );\n    if ( l <= 0.0 )\n    {\n        return vec4( 0.0, 0.0, 0.0, 1.0 );\n    }\n    return QuatFromAxisAngle( vRot, l );\n}\n\nmat3 QuatToMat3( const in vec4 q )\n{\n\tvec4 qSq = q * q;\n\tfloat xy2 = q.x * q.y * 2.0;\n\tfloat xz2 = q.x * q.z * 2.0;\n\tfloat yz2 = q.y * q.z * 2.0;\n\tfloat wx2 = q.w * q.x * 2.0;\n\tfloat wy2 = q.w * q.y * 2.0;\n\tfloat wz2 = q.w * q.z * 2.0;\n \n\treturn mat3 (\t\n     qSq.w + qSq.x - qSq.y - qSq.z, xy2 - wz2, xz2 + wy2,\n     xy2 + wz2, qSq.w - qSq.x + qSq.y - qSq.z, yz2 - wx2,\n     xz2 - wy2, yz2 + wx2, qSq.w - qSq.x - qSq.y + qSq.z );\n}\n\nvec3 QuatMul( vec3 v, vec4 q )\n{\n    \/\/ TODO Validate vs other quat code\n    vec3 t = 2.0 * cross(q.xyz, v);\n\treturn v + q.w * t + cross(q.xyz, t);\n}\n\nvec3 ObjToWorld( vec3 v, mat3 m )\n{\n    return v * m;\n}\n\nvec3 WorldToObj( vec3 v, mat3 m )\n{\n    return m * v;\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\n\/\/ RAYTRACE\n\nfloat kFarClip=10.0;\n\nstruct SurfaceInfo\n{\n    vec3 vUVW;\n    int iId;\n};\n\nstruct ClosestSurface\n{\n    float fDist;\n    SurfaceInfo surface;\n};\n    \nvoid ClosestSurfaceInit( inout ClosestSurface closest, int iId, vec3 vUVW )\n{\n    closest.fDist = 10000.0;\n    closest.surface.vUVW = vUVW;\n    closest.surface.iId = iId;\n}\n\n\nClosestSurface ClosestSurfaceUnion( const in ClosestSurface a, const in ClosestSurface b )\n{\n    if ( a.fDist < b.fDist )\n    {\n        return a;\n    }\n\n    return b;        \n}\n    \nstruct C_Intersection\n{\n\tvec3 vPos;\n\tfloat fDist;\t\n\tvec3 vNormal;\n    SurfaceInfo surface;\n};\n    \n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Random\n\n#define MOD2 vec2(4.438975,3.972973)\n#define MOD3 vec3(.1031,.11369,.13787)\n#define MOD4 vec4(.1031,.11369,.13787, .09987)\n\nfloat Hash( float p ) \n{\n    \/\/ https:\/\/www.shadertoy.com\/view\/4djSRW - Dave Hoskins\n\tvec2 p2 = fract(vec2(p) * MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);    \n}\n\nvec3 Hash31(float p)\n{\n    \/\/ https:\/\/www.shadertoy.com\/view\/4djSRW - Dave Hoskins\n   vec3 p3 = fract(vec3(p) * MOD3);\n   p3 += dot(p3, p3.yzx + 19.19);\n   return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nfloat SmoothNoise(in vec2 o) \n{\n\tvec2 p = floor(o);\n\tvec2 f = fract(o);\n\t\t\n\tfloat n = p.x + p.y*57.0;\n\n\tfloat a = Hash(n+  0.0);\n\tfloat b = Hash(n+  1.0);\n\tfloat c = Hash(n+ 57.0);\n\tfloat d = Hash(n+ 58.0);\n\t\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\t\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\t\n\tfloat u = t.x;\n\tfloat v = t.y;\n\n\tfloat res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n    \n    return res;\n}\n\nfloat FBM( vec2 p, float ps ) {\n\tfloat f = 0.0;\n    float tot = 0.0;\n    float a = 1.0;\n    for( int i=0; i<3; i++)\n    {\n        f += SmoothNoise( p ) * a;\n        p *= 2.0;\n        tot += a;\n        a *= ps;\n    }\n    return f \/ tot;\n}\n    \n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Scene\n\n#define MAT_TERRAIN 1\n#define MAT_CAR_BODY 4\n#define MAT_CAR_WINDOW 3\n#define MAT_CHROME 3\n#define MAT_GRILL 2\n#define MAT_BLACK_PLASTIC 2\n#define MAT_AXLE 2\n#define MAT_WHEEL 5\n#define MAT_REAR 2\n#define MAT_SUSPENSION 6\n#define MAT_WOOD 7\n\nfloat GetTerrainDistance( const vec3 vPos )\n{    \n    float fbm = FBM( vPos.xz * vec2(0.5, 1.0), 0.5 );\n    float fTerrainHeight = fbm * fbm;\n    fTerrainHeight = fTerrainHeight * (sin(vPos.x * 0.1) + 1.0) * 0.5 + vPos.y + 3.0;    \n    \n    \/\/float h = 1.0 - exp(-abs(vPos.x + 15.0) * 0.01);\n    \n    \/\/fTerrainHeight += sin(vPos.x * 0.05) * 5.0 * h;\n    \/\/fTerrainHeight += sin(vPos.z * 0.05) * 5.0 * h;\n\n\treturn fTerrainHeight;\n}\n\nClosestSurface GetRampClosestSurface( const vec3 vPos, const float fRampSeed )\n{\n    ClosestSurface closest;\n    \n    vec3 vHash = Hash31( fRampSeed );\n    \n    closest.surface.iId = MAT_WOOD;\n    closest.surface.vUVW = vPos.xyz;\n    \n    float fHeight = 2.0 + vHash.x * 6.0;\n    float fRadius = 10.0 + vHash.y * 20.0;\n    float fLedge = 2.0 + vHash.z * 3.0;\n        \n    float h2 = fRadius - fHeight;\n    float fLength = sqrt(fRadius * fRadius - h2 * h2);\n    fLength = fLength + fLedge;\n    closest.fDist = sdBox( vPos - vec3( 0.0, fHeight * 0.5, fLength * 0.5 ), vec3(3.0, fHeight * 0.5, fLength * 0.5));\n    \n\n    vec3 vCylDomain = vPos - vec3( 0.0, fRadius, 0.0 );\n    float fCylDist = length(vCylDomain.yz) - fRadius;\n    \n    \/\/closest.fDist = fCylDist;\n    \n    closest.fDist = max( closest.fDist, -fCylDist);\n    \n    return closest;\n}\n\nClosestSurface GetEnvironmentClosestSurface( const vec3 vPos )\n{\n    ClosestSurface terrainClosest;\n    terrainClosest.surface.iId = MAT_TERRAIN;\n    terrainClosest.surface.vUVW = vec3(vPos.xz,0.0);\n    terrainClosest.fDist = GetTerrainDistance( vPos );\n\n    \/\/return terrainClosest;\n    \n    float fRepeat = 100.0;\n    vec3 vRampDomain = vPos - vec3(-15.0, -3.0, 0.0);\n    float fRampUnitZ = vRampDomain.z \/ fRepeat + 0.5;\n    float fRampSeed = floor( fRampUnitZ );\n    vRampDomain.z = (fract(fRampUnitZ) - 0.5) * fRepeat;\n    ClosestSurface rampClosest = GetRampClosestSurface( vRampDomain, fRampSeed );\n\n    return ClosestSurfaceUnion( terrainClosest, rampClosest );\n}\n\nClosestSurface GetSceneClosestSurface( const vec3 vPos )\n{    \n    ClosestSurface closest = GetEnvironmentClosestSurface( vPos );\n    \n    return closest;\n}\n\nvec3 GetSceneNormal( const in vec3 vPos )\n{\n    const float fDelta = 0.0001;\n\n    vec3 vDir1 = vec3( 1.0, -1.0, -1.0);\n    vec3 vDir2 = vec3(-1.0, -1.0,  1.0);\n    vec3 vDir3 = vec3(-1.0,  1.0, -1.0);\n    vec3 vDir4 = vec3( 1.0,  1.0,  1.0);\n\t\n    vec3 vOffset1 = vDir1 * fDelta;\n    vec3 vOffset2 = vDir2 * fDelta;\n    vec3 vOffset3 = vDir3 * fDelta;\n    vec3 vOffset4 = vDir4 * fDelta;\n\n    ClosestSurface c1 = GetSceneClosestSurface( vPos + vOffset1 );\n    ClosestSurface c2 = GetSceneClosestSurface( vPos + vOffset2 );\n    ClosestSurface c3 = GetSceneClosestSurface( vPos + vOffset3 );\n    ClosestSurface c4 = GetSceneClosestSurface( vPos + vOffset4 );\n\t\n    vec3 vNormal = vDir1 * c1.fDist + vDir2 * c2.fDist + vDir3 * c3.fDist + vDir4 * c4.fDist;\t\n\t\t\n    return normalize( vNormal );\n}\n\nvoid TraceScene( out C_Intersection outIntersection, const in vec3 vOrigin, const in vec3 vDir )\n{\t\n\tvec3 vPos = vec3(0.0);\n\t\n\tfloat t = 0.1;\n\tconst int kRaymarchMaxIter = 32;\n\tfor(int i=0; i<kRaymarchMaxIter; i++)\n\t{\n\t\tfloat fClosestDist = GetSceneClosestSurface( vOrigin + vDir * t ).fDist;\n\t\tt += fClosestDist;\n\t\tif(abs(fClosestDist) < 0.01)\n\t\t{\n\t\t\tbreak;\n\t\t}\t\t\n\t\tif(t > kFarClip)\n\t\t{\n\t\t\tt = kFarClip;\n\t\t\tbreak;\n\t\t}\n\t}\n    \n\toutIntersection.fDist = t;\n\toutIntersection.vPos = vOrigin + vDir * t;\n    \n    if( t >= kFarClip )\n    {\n        outIntersection.surface.iId = 0;\n        outIntersection.surface.vUVW = vec3( 0.0 );\n        outIntersection.vNormal = vec3(0.0, 1.0, 0.0);\n    }\n    else\n    {\n\t\toutIntersection.vNormal = GetSceneNormal( outIntersection.vPos );\n        outIntersection.surface = GetSceneClosestSurface( outIntersection.vPos ).surface;\n    }\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nstruct Body\n{\n    \/\/ Persistent State\n    vec3 vPos;\n    vec4 qRot;\n    vec3 vMomentum;\n    vec3 vAngularMomentum;\n    \n    \/\/ Derived\n    mat3 mRot;\n    \n    \/\/ Constant\n    float fMass;\n    float fIT; \/\/ Hacky scalar for inertia tensor\n    \n    \/\/ Per frame\n    vec3 vForce;\n    vec3 vTorque;\n};\n\nvoid BodyLoadState( out Body body, ivec2 addr )\n{\n    body.vPos = LoadVec3( addr + offsetBodyPos );\n    body.qRot = LoadVec4( addr + offsetBodyRot );\n    body.vMomentum = LoadVec3( addr + offsetBodyMom );\n    body.vAngularMomentum = LoadVec3( addr + offsetBodyAngMom );\n}\n\nvoid BodyStoreState( ivec2 addr, const in Body body, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec3( addr + offsetBodyPos, body.vPos, fragColor, fragCoord );\n    StoreVec4( addr + offsetBodyRot, body.qRot, fragColor, fragCoord );\n    StoreVec3( addr + offsetBodyMom, body.vMomentum, fragColor, fragCoord );\n    StoreVec3( addr + offsetBodyAngMom, body.vAngularMomentum, fragColor, fragCoord );\n}\n\nvoid BodyResetForFrame( inout Body body )\n{\n    body.vForce = vec3(0.0);\n    body.vTorque = vec3(0.0);\n}\n\nvoid BodyCalculateDerivedState( inout Body body )\n{\n    body.mRot = QuatToMat3( body.qRot );    \n}\n\nvoid BodyApplyGravity( inout Body body, float dT )\n{\n    float fAccel_MpS = -9.81;\n    body.vForce.y += body.fMass * fAccel_MpS;\n}\n\nvoid BodyIntegrate( inout Body body, float dT )\n{\n#ifdef ENABLE_GRAVITY_TOGGLE    \n    if( !KeyIsToggled( KEY_G ) )\n#endif \/\/ ENABLE_GRAVITY_TOGGLE        \n    {\n    \tBodyApplyGravity( body, dT );\n    }\n    \n    body.vMomentum += body.vForce * dT;\n    body.vAngularMomentum += body.vTorque * dT;\n    \n    vec3 vVel = body.vMomentum \/ body.fMass;\n    vec3 vAngVel = body.vAngularMomentum \/ body.fIT;\n\n    body.vPos += vVel * dT;\n    vec4 qAngDelta = QuatFromVec3( vAngVel * dT );\n    body.qRot = QuatMul( qAngDelta, body.qRot );\n\n    body.qRot = normalize( body.qRot );\n}\n\nvoid BodyApplyForce( inout Body body, vec3 vPos, vec3 vForce )\n{    \n    body.vForce += vForce;\n    body.vTorque += cross(vPos - body.vPos, vForce);     \n}\n\nvoid BodyApplyImpulse( inout Body body, vec3 vPos, vec3 vImpulse )\n{    \n    body.vMomentum += vImpulse;\n    body.vAngularMomentum += cross(vPos - body.vPos, vImpulse);     \n}\n\nvec3 BodyPointVelocity( const in Body body, vec3 vWorldPos )\n{\n    vec3 vVel = body.vMomentum \/ body.fMass;\n    vec3 vAngVel = body.vAngularMomentum \/ body.fIT;\n    \n    return vVel + cross( vAngVel, vWorldPos - body.vPos );\n}\n\n\nvoid BodyApplyDebugForces( inout Body body )\n{\n#ifdef ENABLE_DEBUG_FORCES    \n    float debugForceMag = 20000.0;\n    if ( KeyIsPressed( KEY_LEFT ) )\n    {\n        vec3 vForcePos = body.vPos;\n        vec3 vForce = vec3(-debugForceMag, 0.0, 0.0);\n        BodyApplyForce( body, vForcePos, vForce );\n    }\n    if ( KeyIsPressed( KEY_RIGHT ) )\n    {\n        vec3 vForcePos = body.vPos;\n        vec3 vForce = vec3(debugForceMag, 0.0, 0.0);\n        BodyApplyForce( body, vForcePos, vForce );\n    }\n    if ( KeyIsPressed( KEY_UP ) )\n    {\n        vec3 vForcePos = body.vPos;\n        vec3 vForce = vec3(0.0, 0.0, debugForceMag);\n        BodyApplyForce( body, vForcePos, vForce );\n    }\n    if ( KeyIsPressed( KEY_DOWN ) )\n    {\n        vec3 vForcePos = body.vPos;\n        vec3 vForce = vec3(0.0, 0.0, -debugForceMag);\n        BodyApplyForce( body, vForcePos, vForce );\n    }\n#endif \/\/ ENABLE_DEBUG_FORCES                \n    \n    float debugTorqueMag = 4000.0;\n    if ( KeyIsPressed( KEY_COMMA ) )\n    {\n        vec3 vForcePos = body.vPos;\n        vec3 vForce = vec3(0.0, -debugTorqueMag, 0.0);\n\t\tvForcePos.x += 2.0;\n        BodyApplyForce( body, vForcePos, vForce );\n\t\t\/\/vForcePos.x -= 4.0;\n        \/\/vForce = -vForce;\n        \/\/BodyApplyForce( body, vForcePos, vForce );\n    }\n    if ( KeyIsPressed( KEY_PER ) )\n    {\n        vec3 vForcePos = body.vPos;\n        vec3 vForce = vec3(0.0, debugTorqueMag, 0.0);\n\t\tvForcePos.x += 2.0;\n        BodyApplyForce( body, vForcePos, vForce );\n\t\t\/\/vForcePos.x -= 4.0;\n        \/\/vForce = -vForce;\n        \/\/BodyApplyForce( body, vForcePos, vForce );\n    }        \n}\n\nvoid BodyCollideShapeSphere( inout Body body, vec3 vSphereOrigin, float fSphereRadius, float dT )\n{    \n    vec3 vSphereWorld = ObjToWorld( vSphereOrigin, body.mRot) + body.vPos;\n    \n    ClosestSurface closest = GetSceneClosestSurface( vSphereWorld );\n    \n    float fDepth = fSphereRadius - closest.fDist;\n    \n    if ( fDepth < 0.0 )\n        return;\n    \n    vec3 vNormal = GetSceneNormal( vSphereWorld );\n    vec3 vHitPos = vSphereWorld - vNormal * closest.fDist;    \n    vec3 vPointVel = BodyPointVelocity( body, vHitPos );\n    \n    float fDot = dot( vPointVel, vNormal );\n    \n    if( fDot >= 0.0 )\n        return;\n    \n    float fRestitution = 0.5;\n    \n    vec3 vRelativePos = (vHitPos - body.vPos);\n    float fDenom = (1.0\/body.fMass );\n    float fCr = dot( cross( cross( vRelativePos, vNormal ), vRelativePos), vNormal);\n    fDenom += fCr \/ body.fIT;\n    \n    float fImpulse = -((1.0 + fRestitution) * fDot) \/ fDenom;\n    \n    fImpulse += fDepth \/ fDenom;\n    \n    vec3 vImpulse = vNormal * fImpulse;\n    \n    vec3 vFriction = Vec3Perp( vPointVel, vNormal ) * body.fMass;\n    float fLimit = 100000.0;\n    float fMag = length(vFriction);\n    if( fMag > 0.0 )\n    {\t        \n        vFriction = normalize( vFriction );\n\n        fMag = min( fMag, fLimit );\n        vFriction = vFriction * fMag;\n\n        \/\/BodyApplyForce( body, vHitPos, vFriction );\n        vImpulse += vFriction * dT;        \n    }\n    else\n    {\n        vFriction = vec3(0.0);\n    }\n    \n    BodyApplyImpulse( body, vHitPos, vImpulse );\n}\n    \nvoid BodyCollide( inout Body body, float dT )\n{\n    BodyCollideShapeSphere( body, vec3( 0.7, 0.7,  1.5), 0.5, dT );\n    BodyCollideShapeSphere( body, vec3(-0.7, 0.7,  1.5), 0.5, dT );\n    BodyCollideShapeSphere( body, vec3( 0.7, 0.7, -1.5), 0.5, dT );\n    BodyCollideShapeSphere( body, vec3(-0.7, 0.7, -1.5), 0.5, dT );\n    BodyCollideShapeSphere( body, vec3( 0.5, 1.0,  0.0), 0.7, dT );\n    BodyCollideShapeSphere( body, vec3(-0.5, 1.0,  0.0), 0.7, dT );\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nstruct Engine\n{\n    float fAngularMomentum;\n};\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nstruct Wheel\n{\n    \/\/ Persistent State\n    float fSteer;\n    float fRotation;\n    float fExtension;\n    float fAngularVelocity;\n    \n    \/\/ Results\n    vec2 vContactPos;\n    float fOnGround;\n    float fSkid;    \n    \n    \/\/ Constant\n\tvec3 vBodyPos;    \n    float fRadius;\n    bool bIsDriven;\n    bool bSteering;   \n};\n    \nvoid WheelLoadState( out Wheel wheel, ivec2 addr )\n{    \n    vec4 vState = LoadVec4( addr + offsetWheelState );\n    \n    wheel.fSteer = vState.x;\n    wheel.fRotation = vState.y;\n    wheel.fExtension = vState.z;\n    wheel.fAngularVelocity = vState.w;\n    \n    \/\/ output data\n    wheel.vContactPos = vec2( 0.0 );\n    wheel.fOnGround = 0.0;\n    wheel.fSkid = 0.0;\n}\n    \nvoid WheelStoreState( ivec2 addr, const in Wheel wheel, inout vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 vState = vec4( wheel.fSteer, wheel.fRotation, wheel.fExtension, wheel.fAngularVelocity );\n    StoreVec4( addr + offsetWheelState, vState, fragColor, fragCoord );\n\n    vec4 vState2 = vec4( wheel.vContactPos.xy, wheel.fOnGround, wheel.fSkid );\n    StoreVec4( addr + offsetWheelContactState , vState2, fragColor, fragCoord );\n}\n\nC_Intersection WheelTrace( vec3 vPos, vec3 vDir, Wheel wheel )\n{\n    C_Intersection intersection;\n\tTraceScene( intersection, vPos - vDir * wheel.fRadius, vDir );\n    \n    return intersection;\n}\n\n\nfloat ClampTyreForce( inout vec3 vVel, float fLimit )\n{\n    \/\/ Square clamp\n    \/\/vVelWheel.x = clamp( vVelWheel.x, -fLimit, fLimit);\n    \/\/vVelWheel.z = clamp( vVelWheel.z, -fLimit, fLimit);\n\tfloat fSkid = 0.0;\n    \n    \/\/ Circluar clamp\n    float fMag = length(vVel);\n    if( fMag > 0.0 )\n    {\t        \n        vVel = normalize( vVel );\n    }\n    else\n    {\n        vVel = vec3(0.0);\n    }\n    if ( fMag > fLimit )\n    {\n        fSkid = fMag - fLimit;\n\t    fMag = fLimit;        \n    }\n    vVel = vVel * fMag;\n    \n    return fSkid;\n}\n\nvoid WheelUpdate( inout Engine engine, inout Body body, inout Wheel wheel, float dT )\n{\n    vec3 vWheelWorld = ObjToWorld( wheel.vBodyPos, body.mRot) + body.vPos;\n    vec3 vWheelDown = ObjToWorld( vec3(0.0, -1.0, 0.0), body.mRot);\n    \n    float fSuspensionTravel = 0.25;\n    C_Intersection intersection = WheelTrace( vWheelWorld, vWheelDown, wheel );\n    \n    float fTravel = clamp( intersection.fDist - wheel.fRadius, 0.0, fSuspensionTravel);\n        \n    \/\/ Apply suspension force\n    \/\/ Simple spring-damper\n    \/\/ (No anti-roll bar)\n    float fWheelExt = fTravel \/ fSuspensionTravel;\n\n    wheel.fOnGround = 1.0 - fWheelExt;\n    \n    float delta = (wheel.fExtension - fTravel) \/ fSuspensionTravel;\n\n    float fForce = (1.0 - fWheelExt) * 5000.0 + delta * 15000.0;\n\n    vec3 vForce = Vec3Perp( intersection.vNormal, vWheelDown) * fForce;\n    \/\/BodyApplyForce( body, vWheelWorld, vForce );                \n\n    \/\/ Apply Tyre force\n\n    \/\/ Super simplification of wheel \/ drivetrain \/ engine \/ tyre contact\n    \/\/ ignoring engine \/ wheel angular momentum       \n\n    \/\/ Figure out how contact patch is moving in world space\n    vec3 vIntersectWorld = intersection.vPos;\n    wheel.vContactPos = vIntersectWorld.xz;\n    vec3 vVelWorld = BodyPointVelocity( body, vIntersectWorld );\n\n    \/\/ Transform to body space\n    vec3 vVelBody = WorldToObj( vVelWorld, body.mRot );\n\n    \/\/ Transform to wheel space\n    vec3 vVelWheel = RotY( vVelBody, wheel.fSteer );\n\n    float fWScale = wheel.fRadius;\n\n    float fWheelMOI = 20.0;\n    if ( wheel.bIsDriven )\n    {\n        fWheelMOI = 30.0;\n\n        \/\/ consta-torque mega engine\n        if( KeyIsPressed( KEY_W ) )\n        {\n            wheel.fAngularVelocity += 2.0;\n        }        \n\n        if( KeyIsPressed( KEY_S ) )\n        {\n            wheel.fAngularVelocity -= 2.0;\n        }        \n    }\n\n    if( KeyIsPressed( KEY_SPACE ) )\n    {\n        wheel.fAngularVelocity = 0.0; \/\/ insta-grip super brake\n    }        \n\n    vVelWheel.z -= wheel.fAngularVelocity * fWScale;\n\n    vec3 vForceWheel = vVelWheel * body.fMass;\n\n    \/\/ Hacked 'slip angle'\n    \/\/vForceWheel.x \/=  1.0 + abs(wheel.fAngularVelocity * fWScale) * 0.1;\n\n    float fLimit = 9000.0 * (1.0 - fWheelExt);\n\n    wheel.fSkid = ClampTyreForce( vForceWheel, fLimit );    \n    \n    \/\/vVelWheel.z += wheel.fAngularVelocity * fWScale;\n    vec3 vForceBody = RotY( vForceWheel, -wheel.fSteer );\n\n    \/\/ Apply force back on wheel\n\n    wheel.fAngularVelocity += ((vForceWheel.z \/ fWScale) \/ fWheelMOI) * dT;\n\n    vec3 vForceWorld = ObjToWorld( vForceBody, body.mRot );\n\n    \/\/ cancel in normal dir\n    vForceWorld = Vec3Parallel( vForceWorld, intersection.vNormal );\n\n    vForce -= vForceWorld;\n    \/\/BodyApplyForce( body, vIntersectWorld, -vForceWorld );        \n    \n    BodyApplyForce( body, vIntersectWorld, vForce );        \n\n    wheel.fExtension = fTravel;\n    wheel.fRotation += wheel.fAngularVelocity * dT;    \n}\n\nvoid WheelUpdateSteerAngle( float fSteerAngle, inout Wheel wheel )\n{\n    if ( !wheel.bSteering )\n    {\n        wheel.fSteer = 0.0;\n    }\n    else\n    {\n        \/\/ figure out turning circle if wheel was central\n        float turningCircle = wheel.vBodyPos.z \/ tan( fSteerAngle );\n        float wheelTurningCircle = turningCircle - wheel.vBodyPos.x;\n        wheel.fSteer = atan( abs(wheel.vBodyPos.z) \/ wheelTurningCircle);\n    }\n}\n\nstruct Vechicle\n{\n    Body body;    \n    Engine engine;\n    Wheel wheel[4];\n    \n    float fSteerAngle;\n};\n\nvoid VehicleLoadState( out Vechicle vehicle, ivec2 addr )\n{    \n    BodyLoadState( vehicle.body, addr + offsetVehicleBody );\n    WheelLoadState( vehicle.wheel[0], addr + offsetVehicleWheel0 );\n    WheelLoadState( vehicle.wheel[1], addr + offsetVehicleWheel1 );\n    WheelLoadState( vehicle.wheel[2], addr + offsetVehicleWheel2 );\n    WheelLoadState( vehicle.wheel[3], addr + offsetVehicleWheel3 );\n    \n    vec4 vParam0;\n    vParam0 = LoadVec4( addr + offsetVehicleParam0 );\n    vehicle.fSteerAngle = vParam0.x;\n}\n\nvoid VehicleStoreState( ivec2 addr, const in Vechicle vehicle, inout vec4 fragColor, in vec2 fragCoord )\n{\n    BodyStoreState( addr + offsetVehicleBody, vehicle.body, fragColor, fragCoord );\n    WheelStoreState( addr + offsetVehicleWheel0, vehicle.wheel[0], fragColor, fragCoord );\n    WheelStoreState( addr + offsetVehicleWheel1, vehicle.wheel[1], fragColor, fragCoord );\n    WheelStoreState( addr + offsetVehicleWheel2, vehicle.wheel[2], fragColor, fragCoord );\n    WheelStoreState( addr + offsetVehicleWheel3, vehicle.wheel[3], fragColor, fragCoord );\n\n    vec4 vParam0 = vec4( vehicle.fSteerAngle, 0.0, 0.0, 0.0 );\n    StoreVec4( addr + offsetVehicleParam0, vParam0, fragColor, fragCoord);\n}\n\nvoid VehicleResetForFrame( inout Vechicle vehicle )\n{\n    BodyResetForFrame( vehicle.body );\n}\n\nvoid VehicleSetup( inout Vechicle vehicle )\n{\n    vehicle.body.fMass = 1000.0;\n    vehicle.body.fIT = 1000.0;\n\n    vehicle.engine.fAngularMomentum = 0.0; \/\/ TODO : Move to state\n    \n    vehicle.wheel[0].vBodyPos = vec3( -0.9, -0.1, 1.25 );\n    vehicle.wheel[1].vBodyPos = vec3(  0.9, -0.1, 1.25 );\n    vehicle.wheel[2].vBodyPos = vec3( -0.9, -0.1, -1.25 );\n    vehicle.wheel[3].vBodyPos = vec3(  0.9, -0.1, -1.25 );\n    \n    vehicle.wheel[0].fRadius = 0.45;\n    vehicle.wheel[1].fRadius = 0.45;\n    vehicle.wheel[2].fRadius = 0.45;\n    vehicle.wheel[3].fRadius = 0.45; \n    \n    vehicle.wheel[0].bIsDriven = false;\n    vehicle.wheel[1].bIsDriven = false;\n    vehicle.wheel[2].bIsDriven = true;\n    vehicle.wheel[3].bIsDriven = true;    \n    \n    vehicle.wheel[0].bSteering = true;\n    vehicle.wheel[1].bSteering = true;\n    vehicle.wheel[2].bSteering = false;\n    vehicle.wheel[3].bSteering = false;   \n}\n\n\nstruct Camera\n{\n    vec3 vPos;\n    vec3 vTarget;\n};\n\nvoid CameraLoadState( out Camera cam, in ivec2 addr )\n{\n\tcam.vPos = LoadVec3( addr + offsetCameraPos );\n\tcam.vTarget = LoadVec3( addr + offsetCameraTarget );\n}\n\nvoid CameraStoreState( Camera cam, in ivec2 addr, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec3( addr + offsetCameraPos, cam.vPos, fragColor, fragCoord );\n    StoreVec3( addr + offsetCameraTarget, cam.vTarget, fragColor, fragCoord );    \n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (( fragCoord.x > 13.0 ) || ( fragCoord.y > 3.0 ) )\n    {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    \n    Vechicle vehicle;\n    \n    VehicleLoadState( vehicle, addrVehicle );\n    VehicleSetup( vehicle );\n    VehicleResetForFrame( vehicle );\n\n    if ( iFrame < 1 )\n    {        \n        vehicle.body.vPos = vec3( 0.0, -2.5, 0.0 );\n        vehicle.body.vMomentum = vec3( 0.0 );\n        vehicle.body.qRot = vec4( 0.0, 0.0, 0.0, 1.0 );\n        vehicle.body.vAngularMomentum = vec3( 0.0, 0.5, 0.0 );        \n        \n        vehicle.fSteerAngle = 0.0;\n    }\n\n    BodyCalculateDerivedState( vehicle.body );\n    \n    \/\/ TODO: dT for steering\n    if ( KeyIsPressed( KEY_A ) )\n    {\n        vehicle.fSteerAngle += 0.05;\n    }    \n    if ( KeyIsPressed( KEY_D ) )\n    {\n        vehicle.fSteerAngle -= 0.05;\n    }    \n    \n    vehicle.fSteerAngle *= 0.9;\n    \n    float fSteerAngle = vehicle.fSteerAngle \/ ( 1.0 + length(vehicle.body.vMomentum) * 0.0001 );\n    \n    WheelUpdateSteerAngle( fSteerAngle, vehicle.wheel[0] );\n    WheelUpdateSteerAngle( fSteerAngle, vehicle.wheel[1] );\n    WheelUpdateSteerAngle( fSteerAngle, vehicle.wheel[2] );\n    WheelUpdateSteerAngle( fSteerAngle, vehicle.wheel[3] );\n    \n    float dT = 1.0 \/ 60.0;\n\n\tif ( !KeyIsToggled( KEY_V ) )\n    {\n        WheelUpdate( vehicle.engine, vehicle.body, vehicle.wheel[0], dT );\n        WheelUpdate( vehicle.engine, vehicle.body, vehicle.wheel[1], dT );\n        WheelUpdate( vehicle.engine, vehicle.body, vehicle.wheel[2], dT );\n        WheelUpdate( vehicle.engine, vehicle.body, vehicle.wheel[3], dT );\n    }\n    \n\tBodyApplyDebugForces( vehicle.body );\n    BodyCollide( vehicle.body, dT );\n    BodyIntegrate( vehicle.body, dT );\n\n    fragColor = vec4( 0.0 );\n    \n    VehicleStoreState( addrVehicle, vehicle, fragColor, fragCoord );\n    \n  \n    Camera prevCam;\n    \n    \/\/ load old camera data\n    CameraLoadState( prevCam, addrCamera );\n\n    \/\/ store in addrPrevCamera\n    CameraStoreState( prevCam, addrPrevCamera, fragColor, fragCoord );\n    \n    Camera cam;\n    \n\tvec2 vMouse = iMouse.xy \/ iResolution.xy;\n\tfloat fAngle = (-vMouse.x * 2.0 + 1.0) * 3.14;\n   \tfloat fDistance = 8.0 - vMouse.y * 6.0;\n    \n    cam.vTarget = vec3( 0.0, 1.0, 0.0 ) * vehicle.body.mRot + vehicle.body.vPos;\n    cam.vPos = vec3( 0.0, 0.0, -fDistance ) * vehicle.body.mRot + vehicle.body.vPos + vec3(0.0, 2.0, 0.0);\n    \n    cam.vPos -= cam.vTarget;\n    cam.vPos = RotY( cam.vPos, fAngle );\n    cam.vPos += cam.vTarget;\n            \n    CameraStoreState( cam, addrCamera, fragColor, fragCoord );\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\/\/ Tyre track buffer rendering shader\n\nivec2 addrVehicle = ivec2( 0.0, 0.0 );\n\nivec2 offsetVehicleParam0 = ivec2( 0.0, 0.0 );\n\nivec2 offsetVehicleBody = ivec2( 1.0, 0.0 );\nivec2 offsetBodyPos = ivec2( 0.0, 0.0 );\nivec2 offsetBodyRot = ivec2( 1.0, 0.0 );\nivec2 offsetBodyMom = ivec2( 2.0, 0.0 );\nivec2 offsetBodyAngMom = ivec2( 3.0, 0.0 );\n\nivec2 offsetVehicleWheel0 = ivec2( 5.0, 0.0 );\nivec2 offsetVehicleWheel1 = ivec2( 7.0, 0.0 );\nivec2 offsetVehicleWheel2 = ivec2( 9.0, 0.0 );\nivec2 offsetVehicleWheel3 = ivec2( 11.0, 0.0 );\n\nivec2 offsetWheelState = ivec2( 0.0, 0.0 );\nivec2 offsetWheelContactState = ivec2( 1.0, 0.0 );\n\n\nivec2 addrCamera = ivec2( 0.0, 1.0 );\nivec2 offsetCameraPos = ivec2( 0.0, 0.0 );\nivec2 offsetCameraTarget = ivec2( 1.0, 0.0 );\n\nivec2 addrPrevCamera = ivec2( 0.0, 2.0 );\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Storage\n\nvec4 LoadVec4( in ivec2 vAddr )\n{\n    return texelFetch( iChannel0, vAddr, 0 );\n}\n\nvec3 LoadVec3( in ivec2 vAddr )\n{\n    return LoadVec4( vAddr ).xyz;\n}\n\nbool AtAddress( vec2 p, ivec2 c ) { return all( equal( floor(p), vec2(c) ) ); }\n\nvoid StoreVec4( in ivec2 vAddr, in vec4 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = AtAddress( fragCoord, vAddr ) ? vValue : fragColor;\n}\n\nvoid StoreVec3( in ivec2 vAddr, in vec3 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec4( vAddr, vec4( vValue, 0.0 ), fragColor, fragCoord);\n}\n\n\n\nstruct Camera\n{\n    vec3 vPos;\n    vec3 vTarget;\n};\n\nvoid CameraLoadState( out Camera cam, in ivec2 addr )\n{\n\tcam.vPos = LoadVec3( addr + offsetCameraPos );\n\tcam.vTarget = LoadVec3( addr + offsetCameraTarget );\n}\n\n\n\n\nvoid UpdateTyreTracks( vec3 vCamPosPrev, vec3 vCamPos, inout vec4 fragColor, in vec2 fragCoord )\n{\n    float fRange = 20.0;\n    vec2 vPrevOrigin = floor( vCamPosPrev.xz );\n    vec2 vCurrOrigin = floor( vCamPos.xz );\n\n    vec2 vFragOffset = ((fragCoord \/ iResolution.xy) * 2.0 - 1.0) * fRange;\n    vec2 vFragWorldPos = vFragOffset + vCurrOrigin;\n\t\n    vec2 vPrevFragOffset = vFragWorldPos - vPrevOrigin;\n\tvec2 vPrevUV = ( (vPrevFragOffset \/ fRange) + 1.0 ) \/ 2.0;\n    vec4 vPrevSample = textureLod( iChannel1, vPrevUV, 0.0 );\n    \n    vec4 vWheelContactState[4];\n    vWheelContactState[0] = LoadVec4( addrVehicle + offsetVehicleWheel0 + offsetWheelContactState );\n    vWheelContactState[1] = LoadVec4( addrVehicle + offsetVehicleWheel1 + offsetWheelContactState );\n    vWheelContactState[2] = LoadVec4( addrVehicle + offsetVehicleWheel2 + offsetWheelContactState );\n    vWheelContactState[3] = LoadVec4( addrVehicle + offsetVehicleWheel3 + offsetWheelContactState );\n    \n    fragColor = vPrevSample;\n    \n    if ( vPrevUV.x < 0.0 || vPrevUV.x >= 1.0 || vPrevUV.y < 0.0 || vPrevUV.y >= 1.0 )\n    {\n        fragColor = vec4(0.0);\n    }\n    \n    for ( int w=0; w<4; w++ )\n    {        \n        vec2 vContactPos = vWheelContactState[w].xy;\n        \n        float fDist = length( vFragWorldPos - vContactPos );\n        \n        if ( vWheelContactState[w].z > 0.01 )\n        {\n            float fAmount = smoothstep( 0.25, 0.1, fDist );\n            fragColor.x = max(fragColor.x, fAmount * vWheelContactState[w].z );\n            \n            fragColor.y = max(fragColor.y, fAmount * vWheelContactState[w].w * 0.01);\n        }\t\t\n    }\n    \n    \n    fragColor.x = clamp( fragColor.x, 0.0, 1.0);\n    fragColor.y = clamp( fragColor.y, 0.0, 1.0);\n    \n    if( iFrame < 1 )\n    {\n    \tfragColor.x = 0.0;  \n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0, 0.0, 1.0);\n    \n    Camera cam;\n    CameraLoadState( cam, addrCamera );\n\n    Camera prevCam;    \n    CameraLoadState( prevCam, addrPrevCamera );\n    \n    UpdateTyreTracks( prevCam.vPos, cam.vPos, fragColor, fragCoord );        \n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"XsfGRn","filepath":"\/media\/a\/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"\/media\/ap\/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"\/media\/a\/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"\/media\/ap\/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\/\/ Shader Rally - @P_Malin\n\n\/\/ Main HDR scene shader\n\n\/\/ Uncomment the next line to speed things up a bit\n\/\/#define FAST_VERSION\n\/\/#define SHOW_PHYSICS_SHAPE\n\n#define RAYTRACE_COUNT 2\n\nvec3 g_pixelRandom;\n\nivec2 addrVehicle = ivec2( 0.0, 0.0 );\n\nivec2 offsetVehicleParam0 = ivec2( 0.0, 0.0 );\n\nivec2 offsetVehicleBody = ivec2( 1.0, 0.0 );\nivec2 offsetBodyPos = ivec2( 0.0, 0.0 );\nivec2 offsetBodyRot = ivec2( 1.0, 0.0 );\nivec2 offsetBodyMom = ivec2( 2.0, 0.0 );\nivec2 offsetBodyAngMom = ivec2( 3.0, 0.0 );\n\nivec2 offsetVehicleWheel0 = ivec2( 5.0, 0.0 );\nivec2 offsetVehicleWheel1 = ivec2( 7.0, 0.0 );\nivec2 offsetVehicleWheel2 = ivec2( 9.0, 0.0 );\nivec2 offsetVehicleWheel3 = ivec2( 11.0, 0.0 );\n\nivec2 offsetWheelState = ivec2( 0.0, 0.0 );\nivec2 offsetWheelContactState = ivec2( 1.0, 0.0 );\n\n\nivec2 addrCamera = ivec2( 0.0, 1.0 );\nivec2 offsetCameraPos = ivec2( 0.0, 0.0 );\nivec2 offsetCameraTarget = ivec2( 1.0, 0.0 );\n\nivec2 addrPrevCamera = ivec2( 0.0, 2.0 );\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Storage\n\nvec4 LoadVec4( in ivec2 vAddr )\n{\n    return texelFetch( iChannel0, vAddr, 0 );\n}\n\nvec3 LoadVec3( in ivec2 vAddr )\n{\n    return LoadVec4( vAddr ).xyz;\n}\n\nbool AtAddress( vec2 p, ivec2 c ) { return all( equal( floor(p), vec2(c) ) ); }\n\nvoid StoreVec4( in ivec2 vAddr, in vec4 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = AtAddress( fragCoord, vAddr ) ? vValue : fragColor;\n}\n\nvoid StoreVec3( in ivec2 vAddr, in vec3 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec4( vAddr, vec4( vValue, 0.0 ), fragColor, fragCoord);\n}\n\n\nmat3 QuatToMat3( const in vec4 q )\n{\n\tvec4 qSq = q * q;\n\tfloat xy2 = q.x * q.y * 2.0;\n\tfloat xz2 = q.x * q.z * 2.0;\n\tfloat yz2 = q.y * q.z * 2.0;\n\tfloat wx2 = q.w * q.x * 2.0;\n\tfloat wy2 = q.w * q.y * 2.0;\n\tfloat wz2 = q.w * q.z * 2.0;\n \n\treturn mat3 (\t\n     qSq.w + qSq.x - qSq.y - qSq.z, xy2 - wz2, xz2 + wy2,\n     xy2 + wz2, qSq.w - qSq.x + qSq.y - qSq.z, yz2 - wx2,\n     xz2 - wy2, yz2 + wx2, qSq.w - qSq.x - qSq.y + qSq.z );\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Rotation\n\nvec2 Rotate( const in vec2 vPos, const in float t )\n{\n    float s = sin(t);\n    float c = cos(t);\n    \n    return vec2( c * vPos.x + s * vPos.y, -s * vPos.x + c * vPos.y);\n}\n\nvec2 Rotate( const in vec2 vPos, const in vec2 sc )\n{\n    return vec2( sc.y * vPos.x + sc.x * vPos.y, -sc.x * vPos.x + sc.y * vPos.y);\n}\n\nvec3 RotX( const in vec3 vPos, float t )\n{\n    vec3 result;\n    result.x = vPos.x;\n  \tresult.yz = Rotate( vPos.yz, t );\n    return result;\n}\n\nvec3 RotY( const in vec3 vPos, float t )\n{\n    vec3 result;\n    result.y = vPos.y;\n  \tresult.xz = Rotate( vPos.xz, t );\n    return result;\n}\n\nvec3 RotZ( const in vec3 vPos, float t )\n{\n    vec3 result;\n    result.z = vPos.z;\n  \tresult.xy = Rotate( vPos.xy, t );\n    return result;\n}\n\nvec3 RotX( const in vec3 vPos, vec2 sc )\n{\n    vec3 result;\n    result.x = vPos.x;\n  \tresult.yz = Rotate( vPos.yz, sc );\n    return result;\n}\n\nvec3 RotY( const in vec3 vPos, vec2 sc )\n{\n    vec3 result;\n    result.y = vPos.y;\n  \tresult.xz = Rotate( vPos.xz, sc );\n    return result;\n}\n\nvec3 RotZ( const in vec3 vPos, vec2 sc )\n{\n    vec3 result;\n    result.z = vPos.z;\n  \tresult.xy = Rotate( vPos.xy, sc );\n    return result;\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\n\n\nfloat kFarClip=1000.0;\n\nvec2 GetWindowCoord( const in vec2 vUV );\nvec2 GetUVFromWindowCoord( const in vec2 vWindow );\nvec3 GetCameraRayDir( const in vec2 vWindow, const in vec3 vCameraPos, const in vec3 vCameraTarget );\nvec2 GetCameraWindowCoord(const in vec3 vWorldPos, const in vec3 vCameraPos, const in vec3 vCameraTarget);\nvec3 GetSceneColour( in vec3 vRayOrigin,  in vec3 vRayDir, out float fDepth );\nvec3 ApplyPostFX( const in vec2 vUV, const in vec3 vInput );\nvec3 Hash32( vec2 p );\n\nvec2 g_TyreTrackOrigin;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    g_pixelRandom = normalize( Hash32(fragCoord.xy + iTime) );\n    \n\tvec2 vUV = fragCoord.xy \/ iResolution.xy;\n\n\tvec3 vCameraPos = LoadVec3( addrCamera + offsetCameraPos );\n\tvec3 vCameraTarget = LoadVec3( addrCamera + offsetCameraTarget );\n    \n    g_TyreTrackOrigin = floor(vCameraPos.xz);\n    \n\tvec3 vRayOrigin = vCameraPos;\n\tvec3 vRayDir = GetCameraRayDir( GetWindowCoord(vUV), vCameraPos, vCameraTarget );\n\t\n    float fDepth;\n\tvec3 vResult = GetSceneColour(vRayOrigin, vRayDir, fDepth);\n    vResult = max( vResult, vec3(0.0));\n\t    \n\tfragColor = vec4(vResult, fDepth);\n}\n\n\/\/ CAMERA\n\nvec2 GetWindowCoord( const in vec2 vUV )\n{\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= iResolution.x \/ iResolution.y;\n\n\treturn vWindow;\t\n}\n\nvec2 GetUVFromWindowCoord( const in vec2 vWindow )\n{\n\tvec2 vScaledWindow = vWindow;\n    vScaledWindow.x *= iResolution.y \/ iResolution.x;\n    \n\t return vScaledWindow * 0.5 + 0.5;\n}\n\n\nvec3 GetCameraRayDir( const in vec2 vWindow, const in vec3 vCameraPos, const in vec3 vCameraTarget )\n{\n\tvec3 vForward = normalize(vCameraTarget - vCameraPos);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n\t\t\t\t\t\t\t  \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * 2.0);\n\n\treturn vDir;\n}\n\nvec2 GetCameraWindowCoord(const in vec3 vWorldPos, const in vec3 vCameraPos, const in vec3 vCameraTarget)\n{\n\tvec3 vForward = normalize(vCameraTarget - vCameraPos);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n\t\n    vec3 vOffset = vWorldPos - vCameraPos;\n    vec3 vCameraLocal;\n    vCameraLocal.x = dot(vOffset, vRight);\n    vCameraLocal.y = dot(vOffset, vUp);\n    vCameraLocal.z = dot(vOffset, vForward);\n\n    vec2 vWindowPos = vCameraLocal.xy \/ (vCameraLocal.z \/ 2.0);\n    \n    return vWindowPos;\n}\n\n\/\/ RAYTRACE\n\nstruct SurfaceInfo\n{\n    vec3 vUVW;\n    int iId;\n};\n\nstruct ClosestSurface\n{\n    float fDist;\n    SurfaceInfo surface;\n};\n    \nvoid ClosestSurfaceInit( inout ClosestSurface closest, int iId, vec3 vUVW )\n{\n    closest.fDist = kFarClip;\n    closest.surface.vUVW = vUVW;\n    closest.surface.iId = iId;\n}\n\n\nClosestSurface ClosestSurfaceUnion( const in ClosestSurface a, const in ClosestSurface b )\n{\n    if ( a.fDist < b.fDist )\n    {\n        return a;\n    }\n\n    return b;        \n}\n    \nstruct C_Intersection\n{\n\tvec3 vPos;\n\tfloat fDist;\t\n\tvec3 vNormal;\n    SurfaceInfo surface;\n};\n\nvec2 Segment( vec3 vPos, vec3 vP0, vec3 vP1 )\n{\n\tvec3 pa = vPos - vP0;\n\tvec3 ba = vP1 - vP0;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\t\n\treturn vec2( length( pa - ba*h ), h );\n}\n\nfloat SdCapsule( vec3 vPos, vec3 vP0, vec3 vP1, float r0, float r1 )\n{\n    vec2 vC = Segment( vPos, vP0, vP1 );\n    \n    return vC.x - mix(r0, r1, vC.y);\n}\n\nfloat SdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat SdSphere( vec3 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat UdRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)\/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Scene State\n\nstruct VehicleState\n{\n    vec3 vPos;\n    \n    vec4 qRot;\n    mat3 mRot;\n    \n\tvec4 vWheelState0;\n\tvec4 vWheelState1;\n\tvec4 vWheelState2;\n\tvec4 vWheelState3;\n    \n    vec4 vWheelSC0;\n    vec4 vWheelSC1;\n    vec4 vWheelSC2;\n    vec4 vWheelSC3;\n};\n\nstruct SceneState\n{\n    VehicleState vehicleState;\n};\n    \nSceneState SetupSceneState()\n{\n    SceneState sceneState;\n    \n    sceneState.vehicleState.vPos = LoadVec3( addrVehicle + offsetVehicleBody + offsetBodyPos );\n    \n    sceneState.vehicleState.qRot = LoadVec4( addrVehicle + offsetVehicleBody + offsetBodyRot );\n    sceneState.vehicleState.mRot = QuatToMat3( sceneState.vehicleState.qRot );\n\n    vec4 vWheelState0 = LoadVec4( addrVehicle + offsetVehicleWheel0 );\n    vec4 vWheelState1 = LoadVec4( addrVehicle + offsetVehicleWheel1 );\n    vec4 vWheelState2 = LoadVec4( addrVehicle + offsetVehicleWheel2 );\n    vec4 vWheelState3 = LoadVec4( addrVehicle + offsetVehicleWheel3 );\n    \n    sceneState.vehicleState.vWheelState0 = vWheelState0;\n    sceneState.vehicleState.vWheelState1 = vWheelState1;\n    sceneState.vehicleState.vWheelState2 = vWheelState2;\n    sceneState.vehicleState.vWheelState3 = vWheelState3;\n    \n    sceneState.vehicleState.vWheelSC0 = vec4( sin(vWheelState0.x), cos(vWheelState0.x), sin(vWheelState0.y), cos(vWheelState0.y) );\n    sceneState.vehicleState.vWheelSC1 = vec4( sin(vWheelState1.x), cos(vWheelState1.x), sin(vWheelState1.y), cos(vWheelState1.y) );\n    sceneState.vehicleState.vWheelSC2 = vec4( sin(vWheelState2.x), cos(vWheelState2.x), sin(vWheelState2.y), cos(vWheelState2.y) );\n    sceneState.vehicleState.vWheelSC3 = vec4( sin(vWheelState3.x), cos(vWheelState3.x), sin(vWheelState3.y), cos(vWheelState3.y) );\n    \n    return sceneState;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Random\n\n#define MOD2 vec2(4.438975,3.972973)\n#define MOD3 vec3(.1031,.11369,.13787)\n#define MOD4 vec4(.1031,.11369,.13787, .09987)\n#define HASHSCALE .1031\n\nfloat Hash( float p ) \n{\n    \/\/ https:\/\/www.shadertoy.com\/view\/4djSRW - Dave Hoskins\n\tvec2 p2 = fract(vec2(p) * MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);    \n}\n\nvec3 Hash31(float p)\n{\n    \/\/ https:\/\/www.shadertoy.com\/view\/4djSRW - Dave Hoskins\n   vec3 p3 = fract(vec3(p) * MOD3);\n   p3 += dot(p3, p3.yzx + 19.19);\n   return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nvec3 Hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nfloat SmoothNoise(in vec2 o) \n{\n\tvec2 p = floor(o);\n\tvec2 f = fract(o);\n\t\t\n\tfloat n = p.x + p.y*57.0;\n\n\tfloat a = Hash(n+  0.0);\n\tfloat b = Hash(n+  1.0);\n\tfloat c = Hash(n+ 57.0);\n\tfloat d = Hash(n+ 58.0);\n\t\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\t\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\t\n\tfloat u = t.x;\n\tfloat v = t.y;\n\n\tfloat res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n    \n    return res;\n}\n\nfloat FBM( vec2 p, float ps ) {\n\tfloat f = 0.0;\n    float tot = 0.0;\n    float a = 1.0;\n#ifndef FAST_VERSION\n    for( int i=0; i<3; i++)\n#endif\n    {\n        f += SmoothNoise( p ) * a;\n        p *= 2.0;\n        tot += a;\n        a *= ps;\n    }\n    return f \/ tot;\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Scene\n\n#define MAT_TERRAIN 1\n#define MAT_WOOD 2\n\n#define MAT_CAR_BODY 3\n#define MAT_CHROME 4\n#define MAT_GRILL 5\n#define MAT_BLACK_PLASTIC 5\n#define MAT_AXLE 5\n#define MAT_REAR 5\n#define MAT_WHEEL 6\n#define MAT_SUSPENSION 7\n\n\/\/ Motion blur mask\n#define MAT_FIRST_VEHICLE MAT_CAR_BODY\n\nfloat GetTerrainDistance( const vec3 vPos )\n{    \n    float fbm = FBM( vPos.xz * vec2(0.5, 1.0), 0.5 );\n    float fTerrainHeight = fbm * fbm;\n    fTerrainHeight = fTerrainHeight * (sin(vPos.x * 0.1) + 1.0) * 0.5 + vPos.y + 3.0;    \n    \n    \/\/float h = 1.0 - exp(-abs(vPos.x + 15.0) * 0.01);\n    \n    \/\/fTerrainHeight += sin(vPos.x * 0.05) * 5.0 * h;\n    \/\/fTerrainHeight += sin(vPos.z * 0.05) * 5.0 * h;\n    \n    #ifndef FAST_VERSION\n    {\n\t\t\/\/ Apply Tyre Track to Terrain\n        float fRange = 20.0;\n        vec2 vPrevFragOffset = vPos.xz - g_TyreTrackOrigin;\n        vec2 vPrevUV = ( (vPrevFragOffset \/ fRange) + 1.0 ) \/ 2.0;\n\n        vec4 vTrackSample = textureLod( iChannel3, vPrevUV, 0.0 );\n        float fDepth = vTrackSample.x * (1.0 + vTrackSample.y);\n        \n        fTerrainHeight += fDepth * 0.05;        \n    }\n\t#endif\n    \n\treturn fTerrainHeight;\n}\n\nClosestSurface GetRampClosestSurface( const vec3 vPos, const float fRampSeed )\n{\n    ClosestSurface closest;\n    \n    vec3 vHash = Hash31( fRampSeed );\n    \n    closest.surface.iId = MAT_WOOD;\n    closest.surface.vUVW = vPos.xyz;\n    \n    float fHeight = 2.0 + vHash.x * 6.0;\n    float fRadius = 10.0 + vHash.y * 20.0;\n    float fLedge = 2.0 + vHash.z * 3.0;\n        \n    float h2 = fRadius - fHeight;\n    float fLength = sqrt(fRadius * fRadius - h2 * h2);\n    fLength = fLength + fLedge;\n    closest.fDist = sdBox( vPos - vec3( 0.0, fHeight * 0.5, fLength * 0.5 ), vec3(3.0, fHeight * 0.5, fLength * 0.5));\n    \n\n    vec3 vCylDomain = vPos - vec3( 0.0, fRadius, 0.0 );\n    float fCylDist = length(vCylDomain.yz) - fRadius;\n    \n    \/\/closest.fDist = fCylDist;\n    \n    if ( -fCylDist > closest.fDist )\n    {\n        closest.fDist = -fCylDist;\n        closest.surface.iId = MAT_WOOD;\n    }\n    \/\/closest.fDist = max( closest.fDist, -fCylDist);\n    \n    return closest;\n}\n\nClosestSurface GetEnvironmentClosestSurface( const vec3 vPos )\n{\n    ClosestSurface terrainClosest;\n    terrainClosest.surface.iId = MAT_TERRAIN;\n    terrainClosest.surface.vUVW = vec3(vPos.xz,0.0);\n    terrainClosest.fDist = GetTerrainDistance( vPos );\n#ifdef FAST_VERSION\n    return terrainClosest;\n#else\n    float fRepeat = 100.0;\n    vec3 vRampDomain = vPos - vec3(-15.0, -3.0, 0.0);\n    float fRampUnitZ = vRampDomain.z \/ fRepeat + 0.5;\n    float fRampSeed = floor( fRampUnitZ );\n    vRampDomain.z = (fract(fRampUnitZ) - 0.5) * fRepeat;\n    ClosestSurface rampClosest = GetRampClosestSurface( vRampDomain, fRampSeed );\n\n    return ClosestSurfaceUnion( terrainClosest, rampClosest );\n#endif\n}\n\nfloat PlaneDist( const in vec3 vPos, const in vec3 vNormal, float fDist )\n{\n    return dot(vNormal.xyz, vPos) - fDist;\n}\n\nfloat PlaneDist( const in vec3 vPos, const in vec4 vPlane )\n{\n    return PlaneDist(vPos, vPlane.xyz, vPlane.w);\n}\n\n\n\n\nfloat CarBodyMin( float a, float b, float k )\n{\n    return smin(a, b, k);\n}\n  \nfloat CarBodyMax( float a, float b, float k )\n{\n    return -CarBodyMin(-a, -b, k);\n}\n\nfloat WheelArchCombine( float a, float b )\n{\n    float size = 0.1;\n    float r= clamp( 1.0 - abs(b) \/ size, 0.0, 1.0);\n    a -= r * r * size;\n    \n    return CarBodyMax(a, b, 0.1);\n}\n\nfloat GetWheelArchDist( vec3 vPos )\n{\n    vPos.y = max( vPos.y, 0.0 );\n    return  0.45 - length( vec2( length( vPos.zy ), vPos.x ));\n    \/\/return  0.45 - length( vPos.zy );\n}\n\nvec4 GetPlaneCoeffs( vec3 a, vec3 b, vec3 c )\n{\n    vec3 n = normalize( cross(a-b, b-c) );\n    float d = -dot( n, a );\n    \n    return vec4( n, d );\n}\n\n\nClosestSurface GetCarBodyClosestSurface( const in vec3 vCarPos )\n{\n    ClosestSurface closest;\n    \n#ifdef SHOW_PHYSICS_SHAPE\n    vec4 vSpheres[6];\n    vSpheres[0] = vec4(0.7, 0.7, 1.5, 0.5 );\n    vSpheres[1] = vec4(-0.7, 0.7, 1.5, 0.5 );\n    vSpheres[2] = vec4(0.7, 0.7, -1.5, 0.5 );\n    vSpheres[3] = vec4(-0.7, 0.7, -1.5, 0.5 );\n    vSpheres[4] = vec4(0.5, 1.0, 0.0, 0.7 );\n    vSpheres[5] = vec4(-0.5, 1.0, 0.0, 0.7 );    \n\n\tclosest.surface.vUVW = vCarPos.xyz;\n    closest.surface.fId = MAT_CAR_BODY;\n    closest.fDist = kFarClip;\n    \n    for (int s=0; s<6; s++)\n    {\n        float d = length( vCarPos.xyz - vSpheres[s].xyz) - vSpheres[s].w;\n        \n        closest.fDist = min( closest.fDist, d );\n    }\n#else    \n    \n    vec3 vAbsBodyPos = vCarPos - vec3(0.0, 0.3, 0.0);\n\n    vec3 vBodyPos = vAbsBodyPos;\n    vBodyPos.x = abs(vBodyPos.x);\n\tclosest.surface.vUVW = vAbsBodyPos.xyz;\n    closest.surface.iId = MAT_CAR_BODY;\n   \n    \/\/closest.fDist = SdBox( vBodyPos - vec3(0.0, 0.5, 0.0), vec3(0.7, 0.2, 1.5)-0.2)  -0.2;\n    \n    vec3 vFrontWheelPos = -vec3( 0.0, -0.1, -1.25 ) ;\n    vec3 vRearWheelPos = -vec3( 0.0, -0.1, 1.25 ) ;\n\n    vec3 vWheelPos = vBodyPos - vFrontWheelPos;\n    \n    float fSeparation = (vFrontWheelPos.z - vRearWheelPos.z) * 0.5;\n    vWheelPos.z = abs(vWheelPos.z + fSeparation ) - fSeparation;\n    vWheelPos.x = abs(vWheelPos.x) - 0.8;\n    \n    float fWheelArchDist = GetWheelArchDist( vWheelPos );\n    \n\n    \n    float fBodyBaseDist = kFarClip;\n\n    {\n        float fTopDist = PlaneDist( vBodyPos, normalize(vec3(0.0, 1.0, 0.0)), 0.8 );\n        float fFrontDist = PlaneDist( vBodyPos, normalize(vec3(0.0, 0.2, 1.0)), 1.9 );    \n        float fSideDist = PlaneDist( vBodyPos, normalize(vec3(1.0, -0.1, 0.0)), 0.85 );\n        float fBaseDist = PlaneDist( vBodyPos, normalize(vec3(0.0, -1.0, 0.0)), -0.1 );\n        float fBackDist = PlaneDist( vBodyPos, normalize(vec3(0.0, 0.0, -1.0)), 2.0 );\n\n        float fX = abs(vBodyPos.x);\n        fTopDist += fX * fX * 0.05;\n        fFrontDist += fX * fX * 0.1;\n        \n        float fSmooth = 0.2;\n\n        float fFrontTopDist = CarBodyMax( fTopDist, fFrontDist, 0.2 );\n\n        fBodyBaseDist = fFrontTopDist;\n        fBodyBaseDist = CarBodyMax( fBodyBaseDist, fSideDist, 0.3 );\n\n        float fBaseBackDist = CarBodyMax( fBaseDist, fBackDist, 0.1 );\n        fBodyBaseDist = CarBodyMax( fBodyBaseDist, fBaseBackDist, 0.1 );\n    }\n\n    fBodyBaseDist = WheelArchCombine( fBodyBaseDist, fWheelArchDist );   \n            \n    float fBodyTopDist = kFarClip;\n\n    {\n        float fTopDist = PlaneDist( vBodyPos, normalize(vec3(0.0, 1.0, 0.0)), 1.3 );\n        float fFrontDist = PlaneDist( vBodyPos, normalize(vec3(0.0, 1.0, 0.7)), 1.1 );    \n        float fSideDist = PlaneDist( vBodyPos, normalize(vec3(1.0, 0.4, 0.0)), 1.03 );\n        float fBaseDist = PlaneDist( vBodyPos, normalize(vec3(0.0, -1.0, 0.0)), -0.7);\n        float fBackDist = PlaneDist( vBodyPos, normalize(vec3(0.0, 0.0, -1.0)), 0.55 );\n\n        float fX = abs(vBodyPos.x);\n        fTopDist += fX * fX * 0.1;\n        \n        float fFrontTopDist = CarBodyMax( fTopDist, fFrontDist, 0.1 );\n\n        fBodyTopDist = fFrontTopDist;\n        fBodyTopDist = CarBodyMax( fBodyTopDist, fSideDist, 0.1 );\n\n        float fBaseBackDist = CarBodyMax( fBaseDist, fBackDist, 0.1 );\n        fBodyTopDist = CarBodyMax( fBodyTopDist, fBaseBackDist, 0.1 );\n    }\n        \n    \/\/fBodyTopDist = SdBox( vBodyPos - vec3(0.0, 0.5, -0.5), vec3(0.7, 0.5, 1.0)-0.2)  -0.2;\n    \n    \/\/float fDistDome = SdSphere( vBodyPos - vec3(0.0, -0.5, -0.5), 2.0 );\n    \/\/float fDistBase = -vBodyPos.y;\n    \n    \/\/closest.fDist = max( fDistDome, fDistBase );\n    \n    closest.fDist = fBodyBaseDist;\n    \n    closest.fDist = smin( closest.fDist, fBodyTopDist, 0.1);\n    \n#ifndef FAST_VERSION    \n    float fRearSpace = SdBox( vBodyPos - vec3(0.0, 0.8, -1.3), vec3(0.7, 0.35, 0.65) - 0.05) - 0.05 ;\n    \n    fRearSpace = -min(-fRearSpace, -(fWheelArchDist + 0.02) );\n    \n    if( fRearSpace < -closest.fDist )\n    {\n        closest.fDist = -fRearSpace;\n        closest.surface.iId = MAT_REAR;\n    }\n    \n    \n   \tClosestSurface mirrorClosest;\n    vec3 vMirrorDomain = vBodyPos - vec3(0.875, 0.9, 0.55);\n    vMirrorDomain.z += vMirrorDomain.x * 0.1;\n    mirrorClosest.fDist = SdBox( vMirrorDomain, vec3(0.125, 0.1, 0.06)-0.05)  -0.05;\n\tmirrorClosest.surface.vUVW = vBodyPos.xyz - vec3(0.5);\n    mirrorClosest.surface.iId = MAT_CAR_BODY;    \n    if ( mirrorClosest.fDist < -vMirrorDomain.z )\n    {                \n        if ( mirrorClosest.fDist < -0.01 )\n        {\n    \t\tmirrorClosest.surface.iId = MAT_CHROME;    \n        }\n        \n        mirrorClosest.fDist = -vMirrorDomain.z;        \n    }\n    \n    closest = ClosestSurfaceUnion( closest, mirrorClosest );\n\n    \n   \t\/*ClosestSurface grillClosest;\n    vec3 vGrillDomain = vBodyPos - vec3(0.0, 0.55, 1.85);\n    vGrillDomain.z += vGrillDomain.y * 0.2;\n    float fGrillDist = UdRoundBox( vGrillDomain, vec3(0.85, 0.05, 0.0), 0.1);\n    if ( fGrillDist < closest.fDist )\n    {\n        closest.surface.fId = MAT_GRILL;\n    }*\/\n    \n    \/*ClosestSurface lightClosest;\n    vec3 vLightDomain = vBodyPos - vec3(0.5, 0.5, 2.0);\n    if( vBodyPos.z < 0.5 )\n    {\n        vLightDomain = vBodyPos - vec3(0.3, 1.5, -0.2);\n    }\n    lightClosest.fDist = length(vLightDomain) - 0.15;\n    float fFrontDist = length(vLightDomain + vec3(0.0, 0.0, 0.52)) - 0.5;\n    lightClosest.fDist = -min( -lightClosest.fDist, -fFrontDist );\n\tlightClosest.surface.vUVW = vAbsBodyPos.xyz;\n    lightClosest.surface.fId = MAT_CHROME; \n\n    closest = ClosestSurfaceUnion( closest, lightClosest );*\/\n\t\n#endif    \n#endif\n    return closest;\n}\n\nfloat g_fWheelR = 0.45;\nfloat g_fWheelW = 0.25;\nClosestSurface GetWheelClosestSurface( vec3 vPos )\n{   \n    float theta = atan( vPos.z, vPos.y );\n    float r = length( vPos.zy );    \n    float x = vPos.x;\n        \n    float fr = r * ( 1.0 \/ g_fWheelR );\n    \n    if( fr < 0.5 )\n    {\n        x += 0.01 * clamp((0.5 - fr) * 30.0, 0.0, 1.0);\n        \n        if( fr < 0.3 )\n        {\n            float unitr = fr \/ 0.3;\n            x = x + sqrt(1.0 - unitr * unitr) * 0.05;\n            \/\/x = x + 0.01;\n        }    \n    }\n    else\n    {\n#ifndef FAST_VERSION    \n        \n        float fX = x * (1.0 \/ g_fWheelW);\n        float tread = sin(theta * 15.0 + abs(fX) * 4.0);\n        \n        float treadThickness = 1.0 - clamp( 0.9 - fX * fX * 0.3, 0.0, 1.0 );\n\t    \n        r = -min( -r, -(r + abs(tread) * treadThickness * 0.05 + 0.025));\n#endif\n    }\n    \n    float fRound = 0.1;\n    \n    float fWheelR = g_fWheelR - fRound;\n    float fWheelW = g_fWheelW - fRound;       \n    \n    vec2 rx = vec2( r,x );\n\n    ClosestSurface closest;\n    closest.surface.iId = MAT_WHEEL;\n    closest.surface.vUVW = vPos.yzx;\n    closest.fDist = length( max( abs(rx) - vec2(fWheelR, fWheelW), 0.0)) - fRound;\n        \n    return closest;\n}\n\nClosestSurface GetVehicleClosestSurface( const in VehicleState vehicleState, const vec3 vPos )\n{\n    ClosestSurface closest;\n    \n    \/*\n    float fCullDist = length( vPos - vVehPos );\n    if ( fCullDist > 3.5 ) \n    {\n        closest.fDist = fCullDist - 1.0;\n        closest.surface.fId = 0.0;\n        closest.surface.vUVW = vec3(0.0);\n        return closest;\n    }\n\t*\/        \n    \n    \n    vec3 vLocalPos = vehicleState.mRot * (vPos - vehicleState.vPos);\n    \n    \n    \/\/closest.fDist = 10000.0;\n    \/\/closest.surface.fId = 0.0;\n    \/\/closest.surface.vUVW = vec3(0.0);    \n    closest = GetCarBodyClosestSurface( vLocalPos );\n    \n\tvec3 vWheelPos0 = vec3( -0.9, -0.1, 1.25 );\n\tvec3 vWheelPos1 = vec3(  0.9, -0.1, 1.25 );\n\tvec3 vWheelPos2 = vec3( -0.9, -0.1, -1.25 );\n\tvec3 vWheelPos3 = vec3(  0.9, -0.1, -1.25 );        \n        \n    \n    vec3 vWheelOrigin;\n    vec4 vWheelState;\n    vec4 vWheelSC;\n\n    if ( vLocalPos.z > 0.0 )\n    {\n        if ( vLocalPos.x < 0.0 )\n        {\n            vWheelOrigin = vWheelPos0;\n            vWheelState = vehicleState.vWheelState0;\n            vWheelSC = vehicleState.vWheelSC0;\n        }\n        else\n        {\n            vWheelOrigin = vWheelPos1;\n            vWheelState = vehicleState.vWheelState1;\n            vWheelSC = vehicleState.vWheelSC1;\n        }\n    }\n    else\n    {\n        if ( vLocalPos.x < 0.0 )\n        {\n            vWheelOrigin = vWheelPos2;\n            vWheelState = vehicleState.vWheelState2;\n            vWheelSC = vehicleState.vWheelSC2;\n        }\n        else\n        {\n            vWheelOrigin = vWheelPos3;\n            vWheelState = vehicleState.vWheelState3;\n            vWheelSC = vehicleState.vWheelSC3;\n        }\n    }\n    \n    vec3 vWheelPos = vWheelOrigin;\n    float fWheelSide = sign(vWheelOrigin.x);\n    \n    vWheelPos.y -= vWheelState.z - g_fWheelR;\n    vec3 vWheelLocalPos = vWheelPos - vLocalPos;\n    vWheelLocalPos = RotY( vWheelLocalPos, vWheelSC.xy );        \n    vWheelLocalPos = RotX( vWheelLocalPos, vWheelSC.zw );    \n    vWheelLocalPos.x *= -fWheelSide;\n    closest = ClosestSurfaceUnion( closest, GetWheelClosestSurface( vWheelLocalPos ) );\n    \n#ifndef FAST_VERSION    \n    vec3 vAxleOrigin = vWheelOrigin;\n    vAxleOrigin.x = 0.0;\n    vAxleOrigin.y = 0.25;\n    vec3 vAxleEnd = vWheelPos;\n    vAxleEnd.x = 0.9 * fWheelSide;\n    float cDist0 = SdCapsule(vLocalPos, vAxleOrigin, vAxleEnd, 0.05, 0.05);\n    if( cDist0 < closest.fDist )\n    {\n        closest.surface.iId = MAT_AXLE;\n        closest.fDist = cDist0;\n    }\n    \n    float fSuspensionTop = 0.6;\n    \n    vec3 vSuspensionOrigin = vWheelOrigin;\n    vSuspensionOrigin.x -= 0.4 * fWheelSide;\n    vSuspensionOrigin.y = fSuspensionTop;\n    \/\/vSuspensionOrigin.z *= 0.9;\n\n    vec3 vSuspensionDomain = vLocalPos - vSuspensionOrigin;\n    vSuspensionDomain.z = abs(vSuspensionDomain.z) - 0.1;    \n    \n    vec3 vSuspensionEnd = vec3(0.03 * fWheelSide, -fSuspensionTop + (vWheelPos.y - vWheelOrigin.y) * 0.8, 0.0);\n    \/\/vec3 vSuspensionEnd = vWheelPos;\n    \/\/vSuspensionEnd.x = 0.5 * fWheelSide;\n    \/\/vSuspensionEnd.y += 0.05;\n    \/\/vec3 vSuspensionDomain = vLocalPos - vSuspensionOrigin;\n    float cDist1 = SdCapsule(vSuspensionDomain, vec3(0.0), vSuspensionEnd, 0.05, 0.05);\n    if( cDist1 < closest.fDist )\n    {\n        closest.surface.iId = MAT_SUSPENSION;\n        closest.fDist = cDist1;\n        closest.surface.vUVW = vSuspensionDomain;\n        closest.surface.vUVW.y = closest.surface.vUVW.y \/ vSuspensionEnd.y;\n    }\n#endif \n    \n    return closest;\n}\n\n\n\nClosestSurface GetSceneClosestSurface( const in SceneState sceneState, const vec3 vPos )\n{    \n    ClosestSurface closest;\n    \n    ClosestSurfaceInit( closest, MAT_TERRAIN, vec3( 0.0 ) );\n        \n    ClosestSurface terrainClosest = GetEnvironmentClosestSurface( vPos );\n    ClosestSurface vehicleClosest = GetVehicleClosestSurface( sceneState.vehicleState, vPos );\n    closest = ClosestSurfaceUnion( terrainClosest, vehicleClosest );\n    \n    return closest;\n}\n\nvec3 GetSceneNormal( const in SceneState sceneState, const in vec3 vPos )\n{\n    const float fDelta = 0.0005;\n\n    vec3 vDir1 = vec3( 1.0, -1.0, -1.0);\n    vec3 vDir2 = vec3(-1.0, -1.0,  1.0);\n    vec3 vDir3 = vec3(-1.0,  1.0, -1.0);\n    vec3 vDir4 = vec3( 1.0,  1.0,  1.0);\n\t\n    vec3 vOffset1 = vDir1 * fDelta;\n    vec3 vOffset2 = vDir2 * fDelta;\n    vec3 vOffset3 = vDir3 * fDelta;\n    vec3 vOffset4 = vDir4 * fDelta;\n\n    ClosestSurface c1 = GetSceneClosestSurface( sceneState, vPos + vOffset1 );\n    ClosestSurface c2 = GetSceneClosestSurface( sceneState, vPos + vOffset2 );\n    ClosestSurface c3 = GetSceneClosestSurface( sceneState, vPos + vOffset3 );\n    ClosestSurface c4 = GetSceneClosestSurface( sceneState, vPos + vOffset4 );\n\t\n    vec3 vNormal = vDir1 * c1.fDist + vDir2 * c2.fDist + vDir3 * c3.fDist + vDir4 * c4.fDist;\t\n\t\t\n    return normalize( vNormal );\n}\n\nvoid TraceScene( const in SceneState sceneState, out C_Intersection outIntersection, const in vec3 vOrigin, const in vec3 vDir )\n{\t\n\tvec3 vPos = vec3(0.0);\n\t\n\tfloat t = 0.1;\n\tconst int kRaymarchMaxIter = 64;\n\tfor(int i=0; i<kRaymarchMaxIter; i++)\n\t{\n\t\tfloat fClosestDist = GetSceneClosestSurface( sceneState, vOrigin + vDir * t ).fDist;\n\t\tt += fClosestDist;\n\t\tif(abs(fClosestDist) < 0.01)\n\t\t{\n\t\t\tbreak;\n\t\t}\t\t\n\t\tif(t > kFarClip)\n\t\t{\n\t\t\tt = kFarClip;\n\t\t\tbreak;\n\t\t}\n\t}\n    \n\toutIntersection.fDist = t;\n\toutIntersection.vPos = vOrigin + vDir * t;\n    \n    if( t >= kFarClip )\n    {\n        outIntersection.surface.iId = 0;\n        outIntersection.surface.vUVW = vec3( 0.0 );\n        outIntersection.vNormal = vec3(0.0, 1.0, 0.0);\n    }\n    else\n    {\n\t\toutIntersection.vNormal = GetSceneNormal( sceneState, outIntersection.vPos );\n        outIntersection.surface = GetSceneClosestSurface( sceneState, outIntersection.vPos ).surface;\n    }\n}\n\n#define SOFT_SHADOW\n\nfloat TraceShadow( const in SceneState sceneState, const in vec3 vOrigin, const in vec3 vDir, const in float fDist )\n{\n#ifndef SOFT_SHADOW\n\tC_Intersection shadowIntersection;\n\tTraceScene(sceneState, shadowIntersection, vOrigin, vDir);\n\tif(shadowIntersection.fDist < fDist) \n\t{\n\t\treturn 0.0;\t\t\n\t}\n\t\n\treturn 1.0;\n#else\t\n\t#define kShadowIter 32\n\t#define kShadowFalloff 10.0\n\tfloat fShadow = 1.0;\n\tfloat t = 0.01;\n\tfloat fDelta = 2.5 \/ float(kShadowIter);\n\tfor(int i=0; i<kShadowIter; i++)\n\t{\n\t\tvec4 vUnused;\n\t\tClosestSurface closest = GetSceneClosestSurface( sceneState, vOrigin + vDir * t );\n\t\t\n\t\tfShadow = min( fShadow, kShadowFalloff * closest.fDist \/ t );\n\t\t\n\t\tt = t + fDelta;\n\t}\n\n\treturn clamp(fShadow, 0.0, 1.0);\n#endif\n}\n\n\/\/ AMBIENT OCCLUSION\n\nfloat GetAmbientOcclusion( const in SceneState sceneState, const in vec3 vPos, const in vec3 vNormal )\n{\n\tfloat fAmbientOcclusion = 0.0;\n#ifndef FAST_VERSION    \n\t\n\tfloat fStep = 0.1;\n\tfloat fDist = 0.0;\n\tfor(int i=0; i<=5; i++)\n\t{\n\t\tfDist += fStep;\n\t\t\n\t\tvec4 vUnused;\n        \n\t\tClosestSurface closest = GetSceneClosestSurface( sceneState, vPos + vNormal * fDist );\n\t\t\n\t\tfloat fAmount = (fDist - closest.fDist);\n\t\t\n\t\tfAmbientOcclusion += max(0.0, fAmount * fDist );                                  \n\t}\n#endif\t\n\treturn max(1.0 - fAmbientOcclusion, 0.0);\n}\n\n\/\/ LIGHTING\n\nvoid AddLighting(inout vec3 vDiffuseLight, inout vec3 vSpecularLight, const in vec3 vViewDir, const in vec3 vLightDir, const in vec3 vNormal, const in float fSmoothness, const in vec3 vLightColour)\n{\n\tfloat fNDotL = clamp(dot(vLightDir, vNormal), 0.0, 1.0);\n\tvec3 vHalfAngle = normalize(-vViewDir + vLightDir);\n    float fNDotH = clamp(dot(vHalfAngle, vNormal), 0.0, 1.0);\n\t\n\tvDiffuseLight += vLightColour * fNDotL;\n\t\n\tfloat fSpecularPower = exp2(4.0 + 6.0 * fSmoothness);\n\tfloat fSpecularIntensity = (fSpecularPower + 2.0) * 0.125;\n\tvSpecularLight += vLightColour * fSpecularIntensity * clamp(pow(fNDotH, fSpecularPower), 0.0, 1.0) * fNDotL;\n}\n\nvoid AddPointLight(const in SceneState sceneState, inout vec3 vDiffuseLight, inout vec3 vSpecularLight, const in vec3 vViewDir, const in vec3 vPos, const in vec3 vNormal, const in float fSmoothness, const in vec3 vLightPos, const in vec3 vLightColour)\n{\n\tvec3 vToLight = vLightPos - vPos;\t\n\tfloat fDistance2 = dot(vToLight, vToLight);\n\tfloat fAttenuation = 100.0 \/ (fDistance2);\n\tvec3 vLightDir = normalize(vToLight);\n\t\n\tvec3 vShadowRayDir = vLightDir;\n\tvec3 vShadowRayOrigin = vPos + vShadowRayDir * 0.01;\n\tfloat fShadowFactor = TraceShadow( sceneState, vShadowRayOrigin, vShadowRayDir, length(vToLight));\n\t\n\tAddLighting(vDiffuseLight, vSpecularLight, vViewDir, vLightDir, vNormal, fSmoothness, vLightColour * fShadowFactor * fAttenuation);\n}\n\nvoid AddPointLightFlare(inout vec3 vEmissiveGlow, const in vec3 vRayOrigin, const in vec3 vRayDir, const in float fIntersectDistance, const in vec3 vLightPos, const in vec3 vLightColour)\n{\n    vec3 vToLight = vLightPos - vRayOrigin;\n    float fPointDot = dot(vToLight, vRayDir);\n    fPointDot = clamp(fPointDot, 0.0, fIntersectDistance);\n\n    vec3 vClosestPoint = vRayOrigin + vRayDir * fPointDot;\n    float fDist = length(vClosestPoint - vLightPos);\n\tvEmissiveGlow += sqrt(vLightColour * 0.05 \/ (fDist * fDist));\n}\n\nvoid AddDirectionalLight(const in SceneState sceneState, inout vec3 vDiffuseLight, inout vec3 vSpecularLight, const in vec3 vViewDir, const in vec3 vPos, const in vec3 vNormal, const in float fSmoothness, const in vec3 vLightDir, const in vec3 vLightColour)\n{\t\n\tfloat fAttenuation = 1.0;\n\n\tvec3 vShadowRayDir = -vLightDir;\n\tvec3 vShadowRayOrigin = vPos + vShadowRayDir * 0.01;\n\tfloat fShadowFactor = TraceShadow(sceneState, vShadowRayOrigin, vShadowRayDir, 10.0);\n\t\n\tAddLighting(vDiffuseLight, vSpecularLight, vViewDir, -vLightDir, vNormal, fSmoothness, vLightColour * fShadowFactor * fAttenuation);\t\n}\n\nvoid AddDirectionalLightFlareToFog(inout vec3 vFogColour, const in vec3 vRayDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\n\tfloat fDirDot = clamp(dot(-vLightDir, vRayDir) * 0.5 + 0.5, 0.0, 1.0);\n\tfloat kSpreadPower = 5.0;\n\tvFogColour += vLightColour * pow(fDirDot, kSpreadPower) * 0.5;\n}\n\n\/\/ SCENE MATERIALS\n\nvec3 ProjectedTexture( vec3 pos, vec3 normal )\n{\n    vec3 vWeights = normal * normal;\n    vec3 col = vec3(0.0);\n    vec3 samplev;\n    samplev = texture( iChannel1, pos.xz ).rgb;\n    col += samplev * samplev * vWeights.y;\n    samplev = texture( iChannel1, pos.xy ).rgb;\n    col += samplev * samplev * vWeights.z;\n    samplev = texture( iChannel1, pos.yz ).rgb;\n    col += samplev * samplev * vWeights.x;\n    col \/= vWeights.x + vWeights.y + vWeights.z;\n    return col;    \n}\n\nvoid GetSurfaceInfo( out vec3 vOutAlbedo, out float fOutR0, out float fOutSmoothness, out vec3 vOutBumpNormal, const in C_Intersection intersection )\n{\n\tvOutBumpNormal = intersection.vNormal;\n    \n    \/*if(false)\n    {\n\t\tvOutAlbedo = vec3(0.1);\n\t\tfOutSmoothness = 0.0;\t\t\t\n\t\tfOutR0 = 0.02;   \n        return;\n    }*\/\n        \n    \n    float fRange = 20.0;\n    vec2 vPrevFragOffset = intersection.vPos.xz - g_TyreTrackOrigin;\n    vec2 vPrevUV = ( (vPrevFragOffset \/ fRange) + 1.0 ) \/ 2.0;\n\n    vec4 vTrackSample = texture( iChannel3, vPrevUV );            \n    \n    if ( vPrevUV.x < 0.0 || vPrevUV.x >=1.0 || vPrevUV.y < 0.0 || vPrevUV.y >= 1.0 )\n    {\n        vTrackSample = vec4(0.0);\n    }\n\t\n\tfOutR0 = 0.02;\n\n    switch (intersection.surface.iId )       \n\t{\n        case MAT_TERRAIN:\n        {\n            vec2 vUV = intersection.surface.vUVW.xy * 0.1;\n            vOutAlbedo = texture(iChannel1, vUV).rgb;\n\n            #ifndef FAST_VERSION\n            float fBumpScale = 1.0;\n\n            vec2 vRes = iChannelResolution[0].xy;\n            vec2 vDU = vec2(1.0, 0.0) \/ vRes;\n            vec2 vDV = vec2(0.0, 1.0) \/ vRes;\n\n            float fSampleW = texture(iChannel1, vUV - vDU).r;\n            float fSampleE = texture(iChannel1, vUV + vDU).r;\n            float fSampleN = texture(iChannel1, vUV - vDV).r;\n            float fSampleS = texture(iChannel1, vUV + vDV).r;\n\n            vec3 vNormalDelta = vec3(0.0);\n            vNormalDelta.x += \n                ( fSampleW * fSampleW\n                 - fSampleE * fSampleE) * fBumpScale;\n            vNormalDelta.z += \n                (fSampleN * fSampleN\n                 - fSampleS * fSampleS) * fBumpScale;\n\n            vOutBumpNormal = normalize(vOutBumpNormal + vNormalDelta);\n            #endif\n\n            vOutAlbedo = vOutAlbedo * vOutAlbedo;\t\n            fOutSmoothness = vOutAlbedo.r * 0.3;\n\n            \/\/if(false)\n            {       \n                \/\/ Tyre tracks\n                float fDepth = vTrackSample.x * (1.0 + vTrackSample.y);\n\n                \/\/vec3 vTex2 = texture(iChannel2, vUV).rgb;\n                vec3 vTex2 = mix( vOutAlbedo, vec3( 0.9, 0.3, 0.01 ), 0.5);\n                vOutAlbedo = mix( vOutAlbedo, vTex2, fDepth );\n\n                \/\/vOutAlbedo *= 1.0 - 0.2 * vTrackSample.r;\n\n                vOutAlbedo *= 1.0 - 0.6 * vTrackSample.g;\n                fOutSmoothness = mix( fOutSmoothness, fOutSmoothness * 0.75 + 0.25, fDepth );                        \n            }  \n        }\n        break;\n        \n        case MAT_BLACK_PLASTIC:\n        {\n            vec2 vUV = intersection.surface.vUVW.xy;\n            vOutAlbedo = texture(iChannel1, vUV).rgb;\n            vOutAlbedo = vOutAlbedo * vOutAlbedo;\t\n            vOutAlbedo *= 0.01;\n            fOutSmoothness = 0.1;\/\/vOutAlbedo.r;\t\t\t\n\n            vec3 vDirt = (texture(iChannel1, intersection.surface.vUVW.zy).rgb + texture(iChannel1, intersection.surface.vUVW.xy).rgb) * 0.5;\n            float fDirt = vDirt.r;\n\n            float fMix = clamp( fDirt - intersection.surface.vUVW.y * 2.5 + 0.8, 0.0, 1.0 );\n\n            vDirt = vDirt * vDirt * 0.1;\n\n            vOutAlbedo = mix( vOutAlbedo, vDirt, fMix );\n            fOutSmoothness = mix( fOutSmoothness, 0.01, fMix );        \n\n        }\n        break;\n                \n\t\tcase MAT_CHROME:\n        {\n            vOutAlbedo = vec3(0.1);\n            fOutSmoothness = 1.0;\t\t\t\n            fOutR0 = 0.9;\n        }\n        break;\n        \n\t\tcase MAT_CAR_BODY:\n        {\n            vOutAlbedo = vec3(0.0, 0.0, 1.0);\n\n            float fAbsX = abs( intersection.surface.vUVW.x );\n\n            fOutSmoothness = 1.0;\n\n            float fStripe = abs(fAbsX - (0.15));\n            fStripe = smoothstep( 0.1 + 0.01, 0.1 - 0.01, fStripe);\n\n            vOutAlbedo = mix( vOutAlbedo, vec3(1.0, 1.0, 1.0), fStripe);\n\n            if ( intersection.surface.vUVW.y < 0.85 )\n            {\n                float fLine = abs(intersection.surface.vUVW.z - 0.7);\n                fLine = min( fLine, abs(intersection.surface.vUVW.z + 0.6) );\n                fLine = min( fLine, abs(fAbsX - 0.65) );\n                fLine = min( fLine, abs(intersection.surface.vUVW.y - 0.2) );\n                fLine = clamp( (fLine - 0.005) \/ 0.01, 0.0, 1.0);\n                vOutAlbedo *= fLine;\n                fOutR0 *= fLine;\n                fOutSmoothness *= fLine;\n\n            }\n\n            if(fAbsX > 0.92 )\n            {\n                vOutAlbedo = vec3(0.02, 0.02, 0.02);\n                fOutSmoothness = 0.2;\n            }\n\n            if( intersection.surface.vUVW.y > 0.85 && intersection.surface.vUVW.y < 1.2)\n            {\n                bool bFront = (intersection.surface.vUVW.z + intersection.surface.vUVW.y * 1.25 )  > 1.6;\n                bool bRear = (intersection.surface.vUVW.z)  < -0.45;\n                bool bSide = (fAbsX +intersection.surface.vUVW.y * 0.3) > 0.9;\n\n                if ( !(bFront && bSide) && !(bRear && bSide))\n                {\n                    vOutAlbedo = vec3(0.0, 0.0, 0.0);\n                    fOutR0 = 0.02;\n                    fOutSmoothness = 0.9;\n                }\n            }\n\n            vec3 vGrillDomain = intersection.surface.vUVW - vec3(0.0, 0.55, 1.85);\n            float fGrillDist = UdRoundBox( vGrillDomain, vec3(0.85, 0.05, 0.0), 0.1);\n            if ( fGrillDist < 0.0 )\n            {\n                vOutAlbedo = vec3(0.0, 0.0, 0.0);\n                fOutR0 = 0.02;\n            }        \n\n            vec3 vLightDomain = intersection.surface.vUVW;\n            vLightDomain.x = abs( vLightDomain.x );\n            vLightDomain -= vec3(0.6, 0.56, 1.85);\n            float fLightDist = UdRoundBox( vLightDomain, vec3(0.1, 0.04, 0.5), 0.05);\n            if ( fLightDist < 0.0 )\n            {\n                vOutAlbedo = vec3(0.5);\n                fOutR0 = 1.0;\n                fOutSmoothness = 0.8;\n            }\n\n\n            vec3 vDirt = (texture(iChannel1, intersection.surface.vUVW.zy).rgb + texture(iChannel1, intersection.surface.vUVW.xy).rgb) * 0.5;\n            float fDirt = vDirt.r;\n\n            float fMix = clamp( fDirt - intersection.surface.vUVW.y * 1.5 + 0.8, 0.0, 1.0 );\n\n            vDirt = vDirt * vDirt * 0.1;\n\n            vOutAlbedo = mix( vOutAlbedo, vDirt, fMix );\n            fOutR0 = mix( fOutR0, 0.01, fMix );\n            fOutSmoothness = mix( fOutSmoothness, 0.01, fMix );\n\n            \/\/vOutR0 = vec3(0.7, 0.5, 0.02);\n            \/\/vOutAlbedo = vOutR0 * 0.01;\n\n        }\n       \tbreak;\n        \n\t\tcase MAT_WHEEL:\n        {\n            vec2 vUV = intersection.surface.vUVW.xy;\n            vOutAlbedo = texture(iChannel2, vUV).rgb;\n            vOutAlbedo = vOutAlbedo * vOutAlbedo;\t\n            vOutAlbedo *= 0.01;\n            float len = length(vUV);\n            float fR = len * (1.0 \/ g_fWheelR);\n            if ( fR < 0.5 )\n            {\n                fOutSmoothness = 1.0;        \n                fOutR0 = 1.0;\n            }\n            else\n            {\n                fOutSmoothness = 0.1;\n            }\n\n            vec3 vDirt = (texture(iChannel1, intersection.surface.vUVW.zy).rgb + texture(iChannel1, intersection.surface.vUVW.xy).rgb) * 0.5;\n\n            float fDirt = vDirt.r;\n            fDirt = sqrt(fDirt);\n\n            float fMix = clamp( fDirt - (1.0 - fR) * 1.0 + 0.8, 0.0, 1.0 );\n\n            vDirt = vDirt * vDirt * 0.1;\n\n            vOutAlbedo = mix( vOutAlbedo, vDirt, fMix );\n            fOutR0 = mix( fOutR0, 0.01, fMix );\n            fOutSmoothness = mix( fOutSmoothness, 0.01, fMix );\n\n        }\n        break;\n        \n    \tcase MAT_SUSPENSION:\n        {\n            vOutAlbedo = vec3(0.1);\n            fOutSmoothness = 1.0;\t\t\t\n            fOutR0 = 0.9;\n\n            float fY = intersection.surface.vUVW.y;\n\n            float fAngle = atan(intersection.surface.vUVW.x, intersection.surface.vUVW.y);        \n            fAngle -= fY * 30.0;\n            float fFAngle = fract(fAngle \/ (3.1415 * 2.0));\n            if ( fFAngle < 0.5 )\n            {\n                fOutR0 = 0.0;\n                vOutAlbedo = vec3(0.0);            \n            }\n\n            vec3 vDirt = (texture(iChannel1, intersection.surface.vUVW.zy).rgb + texture(iChannel1, intersection.surface.vUVW.xy).rgb) * 0.5;\n\n            float fDirt = vDirt.r;\n            fDirt = sqrt(fDirt);\n\n            float fMix = clamp( fDirt + 0.1, 0.0, 1.0 );\n\n            vDirt = vDirt * vDirt * 0.1;\n\n            vOutAlbedo = mix( vOutAlbedo, vDirt, fMix );\n            fOutR0 = mix( fOutR0, 0.01, fMix );\n            fOutSmoothness = mix( fOutSmoothness, 0.01, fMix );\n\n        }\n        break;\n        \n    \tcase MAT_WOOD:\n        {\n            vec2 vUV = intersection.surface.vUVW.xz * 0.1;\n            vOutAlbedo = texture(iChannel2, vUV).rgb;\n            vOutAlbedo = vOutAlbedo * vOutAlbedo;\n            fOutSmoothness = vOutAlbedo.r;\n\n            vOutAlbedo *= 1.0 - vTrackSample.g * 0.6;\n        }\n        break;\n    }\n\t\n\t\/\/vOutR0 = vec3(0.9);\n\t\/\/fOutSmoothness = 0.5;\n}\n\nvec3 vSkyTop = vec3(0.1, 0.5, 0.8);\nvec3 vSkyBottom = vec3(0.02, 0.04, 0.06);\n\nvec3 GetSkyColour( const in vec3 vDir )\n{\n\tvec3 vResult = vec3(0.0);\n\t\n    vResult = mix(vSkyBottom, vSkyTop, abs(vDir.y)) * 30.0;\n\t\n#ifndef FAST_VERSION    \n    float fCloud = texture( iChannel1, vDir.xz * 0.01 \/ vDir.y ).r;\n    fCloud = clamp( fCloud * fCloud * 3.0 - 1.0, 0.0, 1.0);\n    vResult = mix( vResult, vec3(8.0), fCloud );\n#endif \n    \n\treturn vResult;\t\n}\n\nfloat GetFogFactor(const in float fDist)\n{\n\tfloat kFogDensity = 0.0025;\n\treturn exp(fDist * -kFogDensity);\t\n}\n\nvec3 GetFogColour(const in vec3 vDir)\n{\n\treturn (vSkyBottom) * 25.0;\n}\n\n\nvec3 vSunLightColour = vec3(1.0, 0.9, 0.6) * 10.0;\nvec3 vSunLightDir = normalize(vec3(0.4, -0.3, -0.5));\n\t\nvoid ApplyAtmosphere(inout vec3 vColour, const in float fDist, const in vec3 vRayOrigin, const in vec3 vRayDir)\n{\t\t\n\tfloat fFogFactor = GetFogFactor(fDist);\n\tvec3 vFogColour = GetFogColour(vRayDir);\t\t\t\n\tAddDirectionalLightFlareToFog(vFogColour, vRayDir, vSunLightDir, vSunLightColour);\n\t\n\tvec3 vGlow = vec3(0.0);\n\t\/\/AddPointLightFlare(vGlow, vRayOrigin, vRayDir, fDist, vLightPos, vLightColour);\t\t\t\t\t\n\t\n\tvColour = mix(vFogColour, vColour, fFogFactor) + vGlow;\t\n}\n\n\/\/ TRACING LOOP\n\n\t\nvec3 GetSceneColour( in vec3 vRayOrigin,  in vec3 vRayDir, out float fDepth )\n{\n\tvec3 vColour = vec3(0.0);\n\tfloat fRemaining = 1.0;\n\t\n    SceneState sceneState = SetupSceneState();\n    \n    fDepth = 0.0;\n    float fFirstTrace = 1.0;\n    \n#ifndef FAST_VERSION    \n\tfor(int i=0; i<RAYTRACE_COUNT; i++)\n#endif\n    {\t\n        \/\/ result = reflection\n        \/\/vColour = vec3(0.0);\n\t\t\/\/vRemaining = vec3(1.0);\n        \n\t\tfloat fCurrRemaining = fRemaining;\n\t\tfloat fShouldApply = 1.0;\n\t\t\n\t\tC_Intersection intersection;\t\t\t\t\n\t\tTraceScene( sceneState, intersection, vRayOrigin, vRayDir );\n\n        float fHitDepth = intersection.fDist;\n\t\tif(intersection.surface.iId >= MAT_FIRST_VEHICLE)\n\t\t{\n            fHitDepth = -fHitDepth;\n        }\n\t\t\n        fDepth = ( fFirstTrace > 0.0 ) ? fHitDepth : fDepth;\n        fFirstTrace = 0.0;\n        \n\t\tvec3 vResult = vec3(0.0);\n\t\tfloat fBlendFactor = 0.0;\n\t\t\t\t\t\t\n\t\tif(intersection.surface.iId == 0)\n\t\t{\n\t\t\tfBlendFactor = 1.0;\n\t\t\tfShouldApply = 0.0;\n\t\t}\n\t\telse\n\t\t{\t\t\n\t\t\tvec3 vAlbedo;\n\t\t\tfloat fR0;\n\t\t\tfloat fSmoothness;\n\t\t\tvec3 vBumpNormal;\n\t\t\t\n\t\t\tGetSurfaceInfo( vAlbedo, fR0, fSmoothness, vBumpNormal, intersection );\t\t\t\n\t\t\n\t\t\tvec3 vDiffuseLight = vec3(0.0);\n\t\t\tvec3 vSpecularLight = vec3(0.0);\n\n\t\t\t\/\/AddPointLight(sceneState, vDiffuseLight, vSpecularLight, vRayDir, intersection.vPos, vBumpNormal, fSmoothness, vLightPos, vLightColour);\t\t\t\t\t\t\t\t\n\n\t\t\tAddDirectionalLight(sceneState, vDiffuseLight, vSpecularLight, vRayDir, intersection.vPos, vBumpNormal, fSmoothness, vSunLightDir, vSunLightColour);\t\t\t\t\t\t\t\t\n\t\t\t\n\t\t\tvDiffuseLight += 0.2 * GetAmbientOcclusion(sceneState, intersection.vPos, vBumpNormal);\n\n\t\t\tfloat fSmoothFactor = pow(fSmoothness, 5.0);\n\t\t\tfloat fFresnel = fR0 + (1.0 - fR0) * pow(1.0 - dot(-vBumpNormal, vRayDir), 5.0) * fSmoothFactor;\n\t\t\t\n\t\t\tvResult = mix(vAlbedo * vDiffuseLight, vSpecularLight, fFresnel);\t\t\n\t\t\tfBlendFactor = fFresnel;\n\t\t\t\n\t\t\tApplyAtmosphere(vResult, intersection.fDist, vRayOrigin, vRayDir);\t\t\n\t\t\t\n\t\t\tfRemaining *= fBlendFactor;\t\t\t\n            \n            #ifndef FAST_VERSION\n            float fRoughness = 1.0 - fSmoothness;\n            fRoughness = pow(fRoughness, 5.0);\n            vBumpNormal = normalize(vBumpNormal + g_pixelRandom * (fRoughness) * 0.5);\n\t\t\t#endif\n            vRayDir = normalize(reflect(vRayDir, vBumpNormal));\n\t\t\tvRayOrigin = intersection.vPos;\/\/ + intersection.vNormal;            \n\t\t}\t\t\t\n\n\t\tvColour += vResult * fCurrRemaining * fShouldApply;\n\n#ifndef FAST_VERSION    \n        if( fRemaining < 0.05 )\n        {\n            break;\n        }        \t\t\n#endif        \n\t}\n\n\tvec3 vSkyColor = GetSkyColour(vRayDir);\n\t\n\tApplyAtmosphere(vSkyColor, kFarClip, vRayOrigin, vRayDir);\t\t\n\t\n\tvColour += vSkyColor * fRemaining;\n\t\n\treturn vColour;\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    fragRayOri.x = -fragRayOri.x;\n    fragRayDir.x = -fragRayDir.x;\n    \n    g_pixelRandom = normalize( Hash32(fragCoord.xy + iTime) );\n    \n\tvec2 vUV = fragCoord.xy \/ iResolution.xy;\n\n\tvec3 vCameraPos = LoadVec3( addrCamera + offsetCameraPos );\n    \n    \/\/ This will make you vomit good\n    \/\/fragRayOri.xz += vCameraPos.xz;\n                \n    g_TyreTrackOrigin = floor(vCameraPos.xz);\n    \n\tvec3 vRayOrigin = fragRayOri;\n\tvec3 vRayDir = fragRayDir;\n\t\n    float fDepth;\n\tvec3 vResult = GetSceneColour(vRayOrigin, vRayDir, fDepth);\n    vResult = max( vResult, vec3(0.0));\n\t    \n\tfragColor = vec4(vResult, fDepth);    \n}","name":"Buf C","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"MdBXR3","date":"1414360243","viewed":14000,"name":"Jack-o'-lantern","username":"P_Malin","description":"A shader doodle for halloween\n(Works in VR mode - try uncommmenting #define SCENE_DOMAIN_REPEAT)","likes":102,"published":3,"flags":1,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"\/media\/a\/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"\/media\/ap\/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRn","filepath":"\/media\/a\/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"\/media\/ap\/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Jack-o'-lantern\n\/\/ @P_Malin\n\n\/\/ A little shadertoy doodle for halloween\n\n#define kRaymarchMaxIter 64\n\n#define kBounceCount 1\n\n\/\/#define SCENE_DOMAIN_REPEAT\n\nfloat kFarClip=100.0;\n\nvec2 GetWindowCoord( const in vec2 vUV );\nvec3 GetCameraRayDir( const in vec2 vWindow, const in vec3 vCameraPos, const in vec3 vCameraTarget );\nvec3 GetSceneColour( in vec3 vRayOrigin,  in vec3 vRayDir );\nvec3 ApplyPostFX( const in vec2 vUV, const in vec3 vInput );\n\nfloat GetCarving2dDistance(const in vec2 vPos );\n\nvec3 vLightPos = vec3(0.0, -0.5, 0.0);\t\t\t\nvec3 vLightColour = vec3(1.0, 0.8, 0.4);\n\nfloat fCarving = 1.0;\n\n\/\/ from https:\/\/www.shadertoy.com\/view\/4djSRW\nfloat hash(float p)\n{\n\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vUV = fragCoord.xy \/ iResolution.xy;\n\n    vLightColour *= hash(iTime) * 0.2 + 0.8;\n    float fDist = 7.0;\n\n    float fAngle = radians(190.0) + sin(iTime * 0.25) * 0.2;\n    float fHeight = 2.0 + sin(iTime * 0.1567) * 1.5;\n    \n\tvec2 vMouse = iMouse.xy \/ iResolution.xy;\n\t\n    \n    if(iMouse.z > 0.0)\n    {\n        fAngle = vMouse.x * 2.0 * 3.14;\n        fHeight = vMouse.y * fDist;\n    }\n    \n\tvec3 vCameraPos = vec3(sin(fAngle) * fDist, fHeight, cos(fAngle) * fDist);\n\tvec3 vCameraTarget = vec3(0.0, -0.5, 0.0);\n\n\tvec3 vRayOrigin = vCameraPos;\n\tvec3 vRayDir = GetCameraRayDir( GetWindowCoord(vUV), vCameraPos, vCameraTarget );\n\t\n\tvec3 vResult = GetSceneColour(vRayOrigin, vRayDir);\n\t    \n\tvec3 vFinal = ApplyPostFX( vUV, vResult );\n\t\n\tfragColor = vec4(vFinal, 1.0);\n}\n\n\/\/ CAMERA\n\nvec2 GetWindowCoord( const in vec2 vUV )\n{\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= iResolution.x \/ iResolution.y;\n\n\treturn vWindow;\t\n}\n\nvec3 GetCameraRayDir( const in vec2 vWindow, const in vec3 vCameraPos, const in vec3 vCameraTarget )\n{\n\tvec3 vForward = normalize(vCameraTarget - vCameraPos);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n\t\t\t\t\t\t\t  \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * 1.5);\n\n\treturn vDir;\n}\n\n\/\/ POSTFX\n\nvec3 ApplyVignetting( const in vec2 vUV, const in vec3 vInput )\n{\n\tvec2 vOffset = (vUV - 0.5) * sqrt(2.0);\n\t\n\tfloat fDist = dot(vOffset, vOffset);\n\t\n\tconst float kStrength = 0.95;\n\tconst float kPower = 1.5;\n\n\treturn vInput * ((1.0 - kStrength) +  kStrength * pow(1.0 - fDist, kPower));\n}\n\nvec3 ApplyTonemap( const in vec3 vLinear )\n{\n\tfloat kExposure = 1.0;\n    \n    if(iTime < 2.0)\n    {\n        kExposure = iTime \/ 2.0;\n    }\n    \t\n\treturn 1.0 - exp2(vLinear * -kExposure);\t\n}\n\nvec3 ApplyGamma( const in vec3 vLinear )\n{\n\tconst float kGamma = 2.2;\n\n\treturn pow(vLinear, vec3(1.0\/kGamma));\t\n}\n\nvec3 ApplyBlackLevel( const in vec3 vColour )\n{\n    float fBlackLevel = 0.1;\n    return vColour \/ (1.0 - fBlackLevel) - fBlackLevel;\n}\n\nvec3 ApplyPostFX( const in vec2 vUV, const in vec3 vInput )\n{\n\tvec3 vTemp = ApplyVignetting( vUV, vInput );\t\n\t\n\tvTemp = ApplyTonemap(vTemp);\n\t\n\tvTemp = ApplyGamma(vTemp);\t\t\n    \n    vTemp = ApplyBlackLevel(vTemp);\n    \n    return vTemp;\n}\n\t\n\/\/ RAYTRACE\n\nstruct C_Intersection\n{\n\tvec3 vPos;\n\tfloat fDist;\t\n\tvec3 vNormal;\n\tvec3 vUVW;\n\tfloat fObjectId;\n};\n\nfloat GetCarving2dDistance(const in vec2 vPos )\n{\n    if(fCarving < 0.0)\n        return 10.0;\n    \n\tfloat fMouthDist = length(vPos.xy + vec2(0.0, -0.5)) - 1.5;\n\tfloat fMouthDist2 = length(vPos.xy + vec2(0.0, -1.1 - 0.5)) - 2.0;\n\t\n\tif(-fMouthDist2 > fMouthDist )\n\t{\n\t\tfMouthDist = -fMouthDist2;\n\t}\n\n    float fFaceDist = fMouthDist;\n\n    vec2 vNosePos = vPos.xy + vec2(0.0, -0.5);\n    vNosePos.x = abs(vNosePos.x);\n    float fNoseDist = dot(vNosePos.xy, normalize(vec2(1.0, 0.5)));\n    fNoseDist = max(fNoseDist, -(vNosePos.y + 0.5));\n    if(fNoseDist < fFaceDist)\n    {\n        fFaceDist = fNoseDist;\n    }\n\n\n    vec2 vEyePos = vPos.xy;\n    vEyePos.x = abs(vEyePos.x);\n    vEyePos.x -= 1.0;\n    vEyePos.y -= 1.0;\n    float fEyeDist = dot(vEyePos.xy, normalize(vec2(-1.0, 1.5)));\n    fEyeDist = max(fEyeDist, dot(vEyePos.xy, normalize(vec2(1.0, 0.5))));\n    fEyeDist = max(fEyeDist, -0.5+dot(vEyePos.xy, normalize(vec2(0.0, -1.0))));\n    if(fEyeDist < fFaceDist)\n    {\n        fFaceDist = fEyeDist;\n    }\n    \n    return fFaceDist;\n}\n\nfloat GetCarvingDistance(const in vec3 vPos )\n{\n\tfloat fDist = (length(vPos * vec3(1.0, 1.4, 1.0)) - 2.7) \/ 1.5;\n\n    float fFaceDist = GetCarving2dDistance(vPos.xy);\n    \n\tfloat fRearDist = vPos.z;\n\t\n\tif(fRearDist > fFaceDist)\n\t{\n\t\tfFaceDist = fRearDist;\n\t}\t\n\t\n\tif(fFaceDist < fDist )\n\t{\n\t\tfDist = fFaceDist;\n\t}\n\n    float fR = length(vPos.xz);\n    \n    float fLidDist = dot( vec2(fR, vPos.y), normalize(vec2(1.0, -1.5)));\n    \n    fLidDist = abs(fLidDist) - 0.03;\n\tif(fLidDist < fDist )\n\t{\n\t\tfDist = fLidDist;\n\t}\n    \n\treturn fDist;\n}\n\nfloat GetPumpkinDistance( out vec4 vOutUVW_Id, const in vec3 vPos )\n{\n    vec3 vSphereOrigin = vec3(0.0, 0.0, 0.0);\n    float fSphereRadius = 3.0;\n\n\tvec3 vOffset = vPos - vSphereOrigin;\n\tfloat fFirstDist = length(vOffset);\n\t\n\tfloat fOutDist;\n\tif(fFirstDist > 3.5)\n\t{\n\t\tfOutDist = fFirstDist - fSphereRadius;\n\t}\n\telse\n\t{\n\t\tfloat fAngle1 = atan(vOffset.x, vOffset.z);\n\t\tfloat fSin = sin(fAngle1 * 10.0);\n\t\tfSin = 1.0 - sqrt(abs(fSin));\n\t\tvOffset *= 1.0 + fSin * vec3(0.05, 0.025, 0.05);\n\t\tvOffset.y *= 1.0 + 0.5 * (fSphereRadius - length(vOffset.xz)) \/ fSphereRadius;\n\t\tfOutDist = length(vOffset) - fSphereRadius;\n\t}\n\t\n\n\tvec4 vSphere1UVW_Id = vec4(normalize(vPos - vSphereOrigin), 3.0);\n\tvOutUVW_Id = vSphere1UVW_Id;\n\t\n\tvec3 vStalkOffset = vPos;\n\tvStalkOffset.x += -(vStalkOffset.y - fSphereRadius) * 0.1;\n\tfloat fDist2d = length(vStalkOffset.xz);\n\tfloat fStalkDist = fDist2d - 0.2;\n\tfStalkDist = max(fStalkDist, vPos.y - 2.5 + vPos.x * 0.25);\n\tfStalkDist = max(fStalkDist, -vPos.y);\n\tif( fStalkDist < fOutDist )\n\t{\n\t\tfOutDist = fStalkDist;\n\t\tvOutUVW_Id = vSphere1UVW_Id;\n\t\tvOutUVW_Id.w = 2.0;\n\t}\n\n\treturn fOutDist;\n}\n\nfloat GetSceneDistance( out vec4 vOutUVW_Id, const in vec3 vPos )\n{\n\tfloat fFloorDist = vPos.y + 2.0;\n\tvec4 vFloorUVW_Id = vec4(vPos.xz, 0.0, 1.0);\n\n\t\n\tvec3 vPumpkinDomain = vPos;\n\n#ifdef SCENE_DOMAIN_REPEAT\n\tfloat fRepeat = 12.0;\n\tfloat fOffset = (fRepeat * 0.5);\n\tvPumpkinDomain.xz = fract((vPos.xz + fOffset) \/ fRepeat) * fRepeat - fOffset;\n#endif \n    \n\tfloat fOutDist = fFloorDist;\n\tvOutUVW_Id = vFloorUVW_Id;\n\n\tvec4 vPumpkinUVW_Id;\n\tfloat fPumpkinDist = GetPumpkinDistance( vPumpkinUVW_Id, vPumpkinDomain );\n\n\tfloat fCarvingDist = GetCarvingDistance( vPumpkinDomain );\n\t\n\tif(-fCarvingDist > fPumpkinDist)\n\t{\n\t\tfPumpkinDist = -fCarvingDist;\n\t\tvPumpkinUVW_Id = vec4(4.0);\n\t}\n\n\t\n\tif(fPumpkinDist < fOutDist)\n\t{\n\t\tfOutDist = fPumpkinDist;\n\t\tvOutUVW_Id = vPumpkinUVW_Id;\n\t}\n\t\n\treturn fOutDist;\n}\n\nvec3 GetSceneNormal(const in vec3 vPos)\n{\n    const float fDelta = 0.001;\n\n    vec3 vDir1 = vec3( 1.0, -1.0, -1.0);\n    vec3 vDir2 = vec3(-1.0, -1.0,  1.0);\n    vec3 vDir3 = vec3(-1.0,  1.0, -1.0);\n    vec3 vDir4 = vec3( 1.0,  1.0,  1.0);\n\t\n    vec3 vOffset1 = vDir1 * fDelta;\n    vec3 vOffset2 = vDir2 * fDelta;\n    vec3 vOffset3 = vDir3 * fDelta;\n    vec3 vOffset4 = vDir4 * fDelta;\n\n\tvec4 vUnused;\n    float f1 = GetSceneDistance( vUnused, vPos + vOffset1 );\n    float f2 = GetSceneDistance( vUnused, vPos + vOffset2 );\n    float f3 = GetSceneDistance( vUnused, vPos + vOffset3 );\n    float f4 = GetSceneDistance( vUnused, vPos + vOffset4 );\n\t\n    vec3 vNormal = vDir1 * f1 + vDir2 * f2 + vDir3 * f3 + vDir4 * f4;\t\n\t\t\n    return normalize( vNormal );\n}\n\nvoid TraceScene( out C_Intersection outIntersection, const in vec3 vOrigin, const in vec3 vDir )\n{\t\n\tvec4 vUVW_Id = vec4(0.0);\t\t\n\tvec3 vPos = vec3(0.0);\n\t\n\tfloat t = 0.01;\n\tfor(int i=0; i<kRaymarchMaxIter; i++)\n\t{\n\t\tvPos = vOrigin + vDir * t;\n\t\tfloat fDist = GetSceneDistance(vUVW_Id, vPos);\t\t\n\t\tt += fDist;\n\t\tif(abs(fDist) < 0.001)\n\t\t{\n\t\t\tbreak;\n\t\t}\t\t\n\t\tif(t > 100.0)\n\t\t{\n\t\t\tt = kFarClip;\n\t\t\tvPos = vOrigin + vDir * t;\n\t\t\tvUVW_Id = vec4(0.0);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\toutIntersection.fDist = t;\n\toutIntersection.vPos = vPos;\n\toutIntersection.vNormal = GetSceneNormal(vPos);\n\toutIntersection.vUVW = vUVW_Id.xyz;\n\toutIntersection.fObjectId = vUVW_Id.w;\n}\n\n\nfloat TraceShadow( const in vec3 vOrigin, const in vec3 vDir, const in float fDist )\n{\n    C_Intersection shadowIntersection;\n\tTraceScene(shadowIntersection, vOrigin, vDir);\n\tif(shadowIntersection.fDist < fDist) \n\t{\n\t\treturn 0.0;\t\t\n\t}\n\t\n\treturn 1.0;\n}\n\nfloat GetSSS( const in vec3 vPos, const in vec3 vLightPos )\n{\n    vec3 vLightToPos = vPos - vLightPos;\n    vec3 vDir = normalize(vLightToPos);\n    \n\tC_Intersection intersection;\n\tTraceScene(intersection, vLightPos, vDir);\n\tfloat fOpticalDepth = length(vLightToPos) - intersection.fDist;\n\n    fOpticalDepth = max(0.00001, fOpticalDepth);\n    \n\treturn exp2( fOpticalDepth * -8.0 );\n}\n\n\/\/ LIGHTING\n\nfloat GIV( float dotNV, float k)\n{\n\treturn 1.0 \/ ((dotNV + 0.0001) * (1.0 - k)+k);\n}\n\nvoid AddLighting(inout vec3 vDiffuseLight, inout vec3 vSpecularLight, const in vec3 vViewDir, const in vec3 vLightDir, const in vec3 vNormal, const in float fSmoothness, const in vec3 vLightColour)\n{\n\tvec3 vH = normalize( -vViewDir + vLightDir );\n\tfloat fNDotL = clamp(dot(vLightDir, vNormal), 0.0, 1.0);\n\tfloat fNDotV = clamp(dot(-vViewDir, vNormal), 0.0, 1.0);\n\tfloat fNDotH = clamp(dot(vNormal, vH), 0.0, 1.0);\n\t\n\tfloat alpha = 1.0 - fSmoothness;\n\talpha = alpha * alpha;\n\t\/\/ D\n\n\tfloat alphaSqr = alpha * alpha;\n\tfloat pi = 3.14159;\n\tfloat denom = fNDotH * fNDotH * (alphaSqr - 1.0) + 1.0;\n\tfloat d = alphaSqr \/ (pi * denom * denom);\n\n\tfloat k = alpha \/ 2.0;\n\tfloat vis = GIV(fNDotL, k) * GIV(fNDotV, k);\n\n\tfloat fSpecularIntensity = d * vis * fNDotL;\n\tvSpecularLight += vLightColour * fSpecularIntensity;\n\n\tvDiffuseLight += vLightColour * fNDotL;\n}\n\nvoid AddPointLight(inout vec3 vDiffuseLight, inout vec3 vSpecularLight, const in vec3 vViewDir, const in vec3 vPos, const in vec3 vNormal, const in float fSmoothness, const in vec3 vLightPos, const in vec3 vLightColour)\n{\n\tvec3 vToLight = vLightPos - vPos;\t\n\tfloat fDistance2 = dot(vToLight, vToLight);\n\tfloat fAttenuation = 100.0 \/ (fDistance2);\n\tvec3 vLightDir = normalize(vToLight);\n\t\n\tvec3 vShadowRayDir = vLightDir;\n\tvec3 vShadowRayOrigin = vPos + vShadowRayDir * 0.01;\n\tfloat fShadowFactor = TraceShadow(vShadowRayOrigin, vShadowRayDir, length(vToLight));\n\t\n\tAddLighting(vDiffuseLight, vSpecularLight, vViewDir, vLightDir, vNormal, fSmoothness, vLightColour * fShadowFactor * fAttenuation);\n}\n\nfloat AddDirectionalLight(inout vec3 vDiffuseLight, inout vec3 vSpecularLight, const in vec3 vViewDir, const in vec3 vPos, const in vec3 vNormal, const in float fSmoothness, const in vec3 vLightDir, const in vec3 vLightColour)\n{\t\n\tfloat fAttenuation = 1.0;\n\n\tvec3 vShadowRayDir = -vLightDir;\n\tvec3 vShadowRayOrigin = vPos + vShadowRayDir * 0.01;\n\tfloat fShadowFactor = TraceShadow(vShadowRayOrigin, vShadowRayDir, 10.0);\n\t\n\tAddLighting(vDiffuseLight, vSpecularLight, vViewDir, -vLightDir, vNormal, fSmoothness, vLightColour * fShadowFactor * fAttenuation);\t\n    \n    return fShadowFactor;\n}\n\nvoid AddDirectionalLightFlareToFog(inout vec3 vFogColour, const in vec3 vRayDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\n\tfloat fDirDot = clamp(dot(-vLightDir, vRayDir), 0.0, 1.0);\n\tfloat kSpreadPower = 4.0;\n\tvFogColour += vLightColour * pow(fDirDot, kSpreadPower);\n}\n\n\/\/ SCENE MATERIALS\n\nvoid GetSurfaceInfo(out vec3 vOutAlbedo, out vec3 vOutR0, out float fOutSmoothness, out vec3 vOutBumpNormal, const in C_Intersection intersection )\n{\n\tvOutBumpNormal = intersection.vNormal;\n\t\n\tif(intersection.fObjectId == 1.0)\n\t{\n\t\tvec2 vUV = intersection.vUVW.xy * 0.1;\n\t\tvOutAlbedo = texture(iChannel0, vUV).rgb;\n\t\tfloat fBumpScale = 10.0;\n\t\t\n\t\tvec2 vRes = iChannelResolution[0].xy;\n\t\tvec2 vDU = vec2(1.0, 0.0) \/ vRes;\n\t\tvec2 vDV = vec2(0.0, 1.0) \/ vRes;\n\t\t\n\t\tfloat fSampleW = texture(iChannel0, vUV - vDU).r;\n\t\tfloat fSampleE = texture(iChannel0, vUV + vDU).r;\n\t\tfloat fSampleN = texture(iChannel0, vUV - vDV).r;\n\t\tfloat fSampleS = texture(iChannel0, vUV + vDV).r;\n\t\t\n\t\tvec3 vNormalDelta = vec3(0.0);\n\t\tvNormalDelta.x += \n\t\t\t( fSampleW * fSampleW\n\t\t\t - fSampleE * fSampleE) * fBumpScale;\n\t\tvNormalDelta.z += \n\t\t\t(fSampleN * fSampleN\n\t\t\t - fSampleS * fSampleS) * fBumpScale;\n\t\t\n\t\tvOutBumpNormal = normalize(vOutBumpNormal + vNormalDelta);\n\n\t\tvOutAlbedo = vOutAlbedo * vOutAlbedo;\t\n\t\tfOutSmoothness = clamp((0.8 - vOutAlbedo.r * 4.0), 0.0, 1.0);\n\t\t\n\t\tvOutR0 = vec3(0.01) * vOutAlbedo.g;\n\t}\n\telse if(intersection.fObjectId == 2.0)\n\t{\n\t\tvOutAlbedo = vec3(0.5, 0.5, 0.2);\n\t\tfOutSmoothness = 0.4;\n\t\tvOutR0 = vec3(0.05);\n\t}\n\telse if(intersection.fObjectId == 3.0)\n\t{\n        float fAngle = atan(intersection.vUVW.x, intersection.vUVW.z);\n        vec2 vUV = vec2(fAngle, intersection.vUVW.y) * vec2(1.0, 0.2) * 8.0;\n\t\tvOutAlbedo = texture(iChannel1, vUV).rgb;\n\t\tfOutSmoothness = clamp(1.0 - vOutAlbedo.r * vOutAlbedo.r * 2.0, 0.0, 1.0);\t\t\t\n\t\tvec3 vCol1 = vec3(1.0, 0.5, 0.0);\n\t\tvec3 vCol2 = vec3(0.5, 0.06, 0.0);\n\t\tvOutAlbedo = mix(vCol1, vCol2, vOutAlbedo.r * 0.5).rgb;\n\t\tvOutR0 = vec3(0.05);\n\t}\n\telse if(intersection.fObjectId == 4.0)\n    {\n\t\tvOutAlbedo = vec3(1.0, 0.824, 0.301);\n\t\tfOutSmoothness = 0.4;\n\t\tvOutR0 = vec3(0.05);\n\t}\n}\n\nvec3 GetSkyColour( const in vec3 vDir )\n{\t\n\tvec3 vResult = mix(vec3(0.02, 0.04, 0.06), vec3(0.1, 0.5, 0.8), abs(vDir.y));\n\t\n\treturn vResult;\t\n}\n\nfloat GetFogFactor(const in float fDist)\n{\n\tfloat kFogDensity = 0.025;\n\treturn exp(fDist * -kFogDensity);\t\n}\n\nvec3 GetFogColour(const in vec3 vDir)\n{\n\treturn vec3(0.01);\t\t\n}\n\nvec3 vSunLightColour = vec3(0.1, 0.2, 0.3) * 5.0;\nvec3 vSunLightDir = normalize(vec3(0.4, -0.3, -0.5));\n\t\nvoid ApplyAtmosphere(inout vec3 vColour, const in float fDist, const in vec3 vRayOrigin, const in vec3 vRayDir)\n{\t\t\n\tfloat fFogFactor = GetFogFactor(fDist);\n\tvec3 vFogColour = GetFogColour(vRayDir);\t\t\t\n\tAddDirectionalLightFlareToFog(vFogColour, vRayDir, vSunLightDir, vSunLightColour);\n\t\n\tvColour = mix(vFogColour, vColour, fFogFactor);\t\n}\n\n\/\/ TRACING LOOP\n\n\t\nvec3 GetSceneColour( in vec3 _vRayOrigin,  in vec3 _vRayDir )\n{\n    vec3 vRayOrigin = _vRayOrigin;\n    vec3 vRayDir = _vRayDir;\n\tvec3 vColour = vec3(0.0);\n\tvec3 vRemaining = vec3(1.0);\n\t\n    float fLastShadow = 1.0;\n    \n\tfor(int i=0; i<kBounceCount; i++)\n\t{\t\n\t\tvec3 vCurrRemaining = vRemaining;\n\t\tfloat fShouldApply = 1.0;\n\t\t\n\t\tC_Intersection intersection;\t\t\t\t\n\t\tTraceScene( intersection, vRayOrigin, vRayDir );\n\n\t\tvec3 vResult = vec3(0.0);\n\t\tvec3 vBlendFactor = vec3(0.0);\n\t\t\t\t\t\t\n\t\tif(intersection.fObjectId == 0.0)\n\t\t{\n\t\t\tvBlendFactor = vec3(1.0);\n\t\t\tfShouldApply = 0.0;\n\t\t}\n\t\telse\n\t\t{\t\t\n\t\t\tvec3 vAlbedo;\n\t\t\tvec3 vR0;\n\t\t\tfloat fSmoothness;\n\t\t\tvec3 vBumpNormal;\n\t\t\t\n\t\t\tGetSurfaceInfo( vAlbedo, vR0, fSmoothness, vBumpNormal, intersection );\t\t\t\n\t\t\n\t\t\tvec3 vDiffuseLight = vec3(0.0);\n\t\t\tvec3 vSpecularLight = vec3(0.0);\n\n            fLastShadow = AddDirectionalLight(vDiffuseLight, vSpecularLight, vRayDir, intersection.vPos, vBumpNormal, fSmoothness, vSunLightDir, vSunLightColour);\t\t\t\t\t\t\t\t\n\n            vec3 vPointLightPos = vLightPos;\n            #ifdef SCENE_DOMAIN_REPEAT\n                float fRepeat = 12.0;\n                float fOffset = (fRepeat * 0.5);\n                vec2 vTile = floor((intersection.vPos.xz + fOffset) \/ fRepeat);\n            \tvPointLightPos.xz += vTile * fRepeat;\n            #endif             \n            \n\t\t\tAddPointLight(vDiffuseLight, vSpecularLight, vRayDir, intersection.vPos, vBumpNormal, fSmoothness, vPointLightPos, vLightColour);\t\t\t\t\t\t\t\t\n\n            if(intersection.fObjectId >= 3.0)\n            {\n                vDiffuseLight += GetSSS(intersection.vPos, vPointLightPos) * vLightColour;\n            }\n            else\n            {\n                vec3 vToLight = vPointLightPos - intersection.vPos;\n                float fNdotL = dot(normalize(vToLight), vBumpNormal) * 0.5 + 0.5;\n\t\t\t\tvDiffuseLight += max(0.0, 1.0 - length(vToLight)\/5.0) * vLightColour * fNdotL;                \n            }\n\n\t\t\tfloat fSmoothFactor = fSmoothness * 0.9 + 0.1;\n            float fFresnelClamp = 0.25; \/\/ too much fresnel produces sparkly artefacts\n            float fNdotD = clamp(dot(vBumpNormal, -vRayDir), fFresnelClamp, 1.0);\n\t\t\tvec3 vFresnel = vR0 + (1.0 - vR0) * pow(1.0 - fNdotD, 5.0) * fSmoothFactor;\n\n            \n\t\t\tvResult = mix(vAlbedo * vDiffuseLight, vSpecularLight, vFresnel);\t\t\n\t\t\tvBlendFactor = vFresnel;\n\t\t\t\n\t\t\tApplyAtmosphere(vResult, intersection.fDist, vRayOrigin, vRayDir);\t\t\n\t\t\t\n\t\t\tvRemaining *= vBlendFactor;\t\t\t\t\n\t\t\tvRayDir = normalize(reflect(vRayDir, vBumpNormal));\n\t\t\tvRayOrigin = intersection.vPos;\n\t\t}\t\t\t\n\n\t\tvColour += vResult * vCurrRemaining * fShouldApply;\t\n\t}\n\n\tvec3 vSkyColor = GetSkyColour(vRayDir);\n\t\n\tApplyAtmosphere(vSkyColor, kFarClip, vRayOrigin, vRayDir);\t\t\n\t\n    \/\/ Hack for this scene when using 1 bounce.\n    \/\/ remove final sky reflection when in shadow\n    vSkyColor *= fLastShadow; \n    \n\tvColour += vSkyColor * vRemaining;\n\t\n    \/\/ Face glow\n    float t = -(_vRayOrigin.z + 2.8) \/ _vRayDir.z;\n    \n    if( t > 0.0 )\n    {\n        vec3 vPos = _vRayOrigin + _vRayDir * t;\n\n        float fDist = abs(GetCarving2dDistance(vPos.xy * vec2(1.0, 1.0)));\n        float fDot = max(0.0, _vRayDir.z);\n        fDot = fDot * fDot;\n        vColour += exp2(-fDist * 10.0) * fDot * vLightColour * 0.25;\n    }\n    \n    \n\treturn vColour;\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    fragRayOri.z = -fragRayOri.z;\n    fragRayDir.z = -fragRayDir.z;\n    \n    fragRayOri *= 15.5;\n    \n    fragRayOri.y += 3.5;\n    fragRayOri.z -= 8.0;\n    \n\tvec3 vResult = GetSceneColour(fragRayOri, fragRayDir);\n\t    \n\tvResult = ApplyTonemap(vResult);\n\t\n\tvResult = ApplyGamma(vResult);\t\t\n    \n    vResult = ApplyBlackLevel(vResult);\n    \n    fragColor = vec4( vResult, 1.0 );\n}","name":"Image","description":"","type":"image"}]}];var gFollow = -1;
    var gUseScreenshots = piIsMobile();
    var gThemeName = "classic";
    </script>

</head>

<body onload="resultsInitStatic(8,null,null)">

<!-- header =================================================================================== -->


<div id="header">

    <div id="headerBlock1">
        <a href="/" id="headerTitle">Shadertoy</a>
        <form name="formSearch" action="/results" method="get" style="display:inline-block;">
        <div  id="headerSearch">
            <input type="search" id="mySearch" name="query" placeholder="Search..." value=""/>
        </div>
        </form>
    </div>

    <div id="headerBlock2">
            <a class="headerLinks" href="/browse">Browse</a>
        <a class="headerLinks" href="/new">New</a>
        <a class="headerLinks" href="/signin">Sign In</a>
        </div>
</div>
<!-- content ================================================================================== -->

<div id="content">

    
    <script>
    function follow()
    {
        if (gFollow < 0) return;
        try
        {
            var req = new XMLHttpRequest();
            req.onload = function()
            {
                var jsn = req.response;
                if( jsn==null ) return;
                let btnFollow = document.getElementById( "btnFollow");
                if (gFollow == 1) {
                    gFollow = 0;
                    btnFollow.value="Follow";
                } else if (gFollow == 0) {
                    gFollow = 1;
                    btnFollow.value="Unfollow";
                }
            }
            req.open( "POST", "/shadertoy", true );
            req.responseType = "json";
            req.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
            if (gFollow == 1) {
                var str = "fu=1&uid=P_Malin";
            } else if (gFollow == 0) {
                var str = "fs=1&uid=P_Malin";
            }
            req.send( str );
        }
        catch(e)
        {
            alert( "exception: " + e );
        }
    }
    </script>

    <!-- ---------------------------------- --> 

    <div id="divUser">
        <table style="border:0px;border-spacing:0px;border-collapse:collapse;"><tr>
        <td style="vertical-align:top;">
        <img id="userPicture" src="/media/users/P_Malin/profile.jpeg"></img>        </td>
        <td style="vertical-align:top;padding-left:16px;">
        <b>Name</b>: P_Malin <br/><b>Joined</b>: February 25, 2013 <br/> <br/><b>Shaders</b>: 84<br/><b>Playlists</b>: 0<br/><b>Comments</b>: 604<br/> <br/><b>Following</b>: 12<br/><b>Followers</b>: 109<br/>        </td>
        <td style="vertical-align:top;padding-left:32px;">
        <b>About</b><br><br><a href="https://blog.mousefingers.com" class="regular" target="_blank">https://blog.mousefingers.com</a><br/><a href="https://twitter.com/P_Malin" class="regular" target="_blank">https://twitter.com/P_Malin</a>        </td>
        <td style="vertical-align:top;padding-left:32px;">
                    </td>
        </tr></table>
    </div>

<!-- --------------------------- -->

  <div id="controls">

    <div>
      <div style="text-align: center; vertical-align: middle; display: inline-block; padding-bottom:5px; padding-top:4px; margin-right:8px; margin-bottom:8px; margin-top:8px;">
      Sort:      </div>
      <div class="controlOptions"><div class="pageButtonsCurrent" href="/user/P_Malin/sort=popular">Popular</div><a class="pageButtons" href="/user/P_Malin/sort=newest">Newest</a><a class="pageButtons" href="/user/P_Malin/sort=love">Love</a></div>
    </div>

    <div id="controlFilter">
      <div style="display:flex;margin-right:8px;align-items:center;">Filter:</div>
      <div class="controlOptions"> <a class="pageButtons" href="/user/P_Malin&sort=popular&filter=multipass">Multipass</a><a class="pageButtons" href="/user/P_Malin&sort=popular&filter=soundoutput">GPU Sound</a><a class="pageButtons" href="/user/P_Malin&sort=popular&filter=vr">VR</a><a class="pageButtons" href="/user/P_Malin&sort=popular&filter=soundinput">Microphone</a><a class="pageButtons" href="/user/P_Malin&sort=popular&filter=musicstream">Soundcloud</a><a class="pageButtons" href="/user/P_Malin&sort=popular&filter=webcam">Webcam</a></div>
    </div>

    <div>
        <div style="text-align: center; vertical-align: middle; display: inline-block; padding-bottom:5px; padding-top:4px; margin-right:8px; margin-bottom:8px; margin-top:8px;">
        Results (84):        </div>

        <div class="controlOptions">
              <div id="pageButton"0 class="pageButtonsCurrent" href="/user/P_Malin/sort=popular&from=0&num=8">1</div><a id="pageButton"1 class="pageButtons" href="/user/P_Malin/sort=popular&from=8&num=8">2</a><a id="pageButton"2 class="pageButtons" href="/user/P_Malin/sort=popular&from=16&num=8">3</a><span>...</span><a id="pageButtonLast" class="pageButtons" href="/user/P_Malin/sort=popular&from=80&num=8">11</a>        </div>
    </div>
  </div>


  <div id="shaderGrid">
    <div class='searchResult'><div class='searchResultContainer' id='Preview_0_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_0_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_0_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_0_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_0_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_0_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_0_Thumnail'>        <img class='previewThumbnailImage' id='Preview_0_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_0_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_0_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_0_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_0_Info'>  <span class='previewText'  id='Preview_0_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_0_TextUser'></span>  <span class='previewStats' id='Preview_0_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_1_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_1_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_1_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_1_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_1_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_1_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_1_Thumnail'>        <img class='previewThumbnailImage' id='Preview_1_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_1_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_1_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_1_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_1_Info'>  <span class='previewText'  id='Preview_1_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_1_TextUser'></span>  <span class='previewStats' id='Preview_1_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_2_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_2_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_2_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_2_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_2_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_2_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_2_Thumnail'>        <img class='previewThumbnailImage' id='Preview_2_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_2_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_2_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_2_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_2_Info'>  <span class='previewText'  id='Preview_2_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_2_TextUser'></span>  <span class='previewStats' id='Preview_2_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_3_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_3_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_3_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_3_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_3_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_3_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_3_Thumnail'>        <img class='previewThumbnailImage' id='Preview_3_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_3_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_3_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_3_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_3_Info'>  <span class='previewText'  id='Preview_3_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_3_TextUser'></span>  <span class='previewStats' id='Preview_3_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_4_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_4_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_4_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_4_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_4_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_4_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_4_Thumnail'>        <img class='previewThumbnailImage' id='Preview_4_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_4_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_4_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_4_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_4_Info'>  <span class='previewText'  id='Preview_4_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_4_TextUser'></span>  <span class='previewStats' id='Preview_4_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_5_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_5_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_5_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_5_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_5_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_5_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_5_Thumnail'>        <img class='previewThumbnailImage' id='Preview_5_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_5_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_5_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_5_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_5_Info'>  <span class='previewText'  id='Preview_5_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_5_TextUser'></span>  <span class='previewStats' id='Preview_5_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_6_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_6_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_6_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_6_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_6_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_6_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_6_Thumnail'>        <img class='previewThumbnailImage' id='Preview_6_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_6_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_6_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_6_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_6_Info'>  <span class='previewText'  id='Preview_6_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_6_TextUser'></span>  <span class='previewStats' id='Preview_6_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_7_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_7_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_7_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_7_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_7_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_7_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_7_Thumnail'>        <img class='previewThumbnailImage' id='Preview_7_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_7_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_7_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_7_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_7_Info'>  <span class='previewText'  id='Preview_7_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_7_TextUser'></span>  <span class='previewStats' id='Preview_7_Stats'></span></div></div>  </div>
</div>

<!-- footer ================================================================================== -->

<div id="footer">
    
    <div><span style="color:#ffffff;">Community Forums</span>
      <ul>
      <li><a class="regular" href="/events">Official Events</a></li>
      <li><a class="regular" href="https://www.facebook.com/groups/147749602472741">In Facebook (english)</a></li>
      <li><a class="regular" href="https://www.facebook.com/groups/1339783682699494">In Facebook (korean)</a></li>
      <li><a class="regular" href="https://discord.gg/XtmMN6E">In Discord</a> (<a class="regular" href="https://discordapp.com/channels/578696555612209173/579531723348639754">direct link</a>)</li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Feedback and Support</span>
      <ul>
      <li><a class="regular" href="https://www.facebook.com/Shadertoy">Facebook</a></li>
      <li><a class="regular" href="https://twitter.com/shadertoy">Twitter</a></li>
      <li><a class="regular" href="https://www.patreon.com/shadertoy">Patreon</a></li>
      <li><a class="regular" href="https://trello.com/b/5hM0CjId">Roadmap</a></li>

      
      </ul>
    </div>

    <div><span style="color:#ffffff;">Shadertoy</span>
      <ul>
      <li><a class="regular" href="/store">Store</a></li>
      <li><a class="regular" href="/howto">Documentation</a></li>
      <li><a class="regular" href="/terms">Terms & Privacy</a></li>
      <li><a class="regular" href="/about">About</a></li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Apps and Plugins</span>
      <ul>
      <li><a class="regular" href="https://itunes.apple.com/us/app/shadertoy/id717961814">Official iPhone App</a> by <a class="user" href="/user/reinder">Reinder</a></li>
      <li><a class="regular" href="https://steamcommunity.com/sharedfiles/filedetails/?id=1726697188">Screensaver</a> by <a class="user" href="/user/kosro">Kosro</a></li>
      <li><a class="regular" href="https://chrome.google.com/webstore/detail/shadertoy-unofficial-plug/ohicbclhdmkhoabobgppffepcopomhgl">Shadertoy plugin</a> by <a class="user" href="/user/patu">Patu</a></li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Tutorials</span>
      <ul>
      <li><a class="regular" href="https://www.youtube.com/watch?v=0ifChJ0nJfM">Shader coding intro</a> by <a class="user" href="/user/iq">iq</a></li>
      <li><a class="regular" href="https://shadertoyunofficial.wordpress.com/">Shadertoy Unofficial</a> by <a class="user" href="/user/FabriceNeyret2">FabriceNeyret2</a></li>
      </ul>
    </div>

</div>

<div id="compliance" style="padding-bottom:6px;visibility:hidden;left:0;top:0px;width:100%;background-color:rgb(200,120,20,0.93);position:absolute;color:#FFFFFF">
    <div style="text-align: center; margin-top:8px">
        We use cookies to give you the best experience on our website. If you continue using Shadertoy, we'll assume that you are happy to receive all cookies on this website. 
        For more information, please review our <a class="regular" href="/terms">Terms & Privacy</a>.
    </div> 
    <div style="text-align: center;margin-top:6px">
        <button type="button" style="width:100px;font-size:inherit" onclick="acceptCompliance()">Accept</button>
    </div>
</div>

<script>
(function runCompliance() 
{
    let showCompliance = 1;
    let allcookies = document.cookie;
    let cookiearray = allcookies.split(';');
    for (var i=0; i<cookiearray.length; i++)
    {
        let name  = cookiearray[i].split('=')[0];
        let value = cookiearray[i].split('=')[1];
        if (name.trim() == "scmp") 
        {
            showCompliance = value;
            break;
        }
    }

    if (showCompliance === 1) 
    {
        var ve = document.getElementById("compliance");
        ve.style.visibility="visible";
    }
})();

function acceptCompliance()
{
    let now = new Date();
    now.setTime( now.getTime() + (5*365*24*60*60*1000) );
    document.cookie="scmp=0;expires=" + now.toUTCString() + ";";

    var ve = document.getElementById("compliance");
    ve.style.visibility="hidden";
}
</script>

<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-44068895-1', 'shadertoy.com');
    ga('send', 'pageview');
</script>
</body>
</html>
