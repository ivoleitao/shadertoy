[
    {
        "ver": "0.1",
        "info": {
            "id": "Xds3zN",
            "date": "1364255835",
            "viewed": 646203,
            "name": "Raymarching - Primitives",
            "username": "iq",
            "description": "A set of raw primitives. All except the ellipsoid are exact euclidean distances. More info here: [url=https:\/\/iquilezles.org\/articles\/distfunctions]https:\/\/iquilezles.org\/articles\/distfunctions[\/url]",
            "likes": 1286,
            "published": 3,
            "flags": 0,
            "usePreview": 1,
            "tags": []
        },
        "renderpass": [
            {
                "inputs": [],
                "outputs": [
                    {
                        "id": "4dfGRr",
                        "channel": 0
                    }
                ],
                "code": "\/\/ Copyright Inigo Quilez, 2016 - https:\/\/iquilezles.org\/\n\/\/ I am the sole copyright owner of this Work.\n\/\/ You cannot host, display, distribute or share this Work in any form,\n\/\/ including physical and digital. You cannot use this Work in any\n\/\/ commercial or non-commercial product, website or project. You cannot\n\/\/ sell this Work and you cannot mint an NFTs of it.\n\/\/ I share this Work for educational purposes, and you can link to it,\n\/\/ through an URL, proper attribution and unmodified screenshot, as part\n\/\/ of your educational material. If these conditions are too restrictive\n\/\/ please contact me and we'll definitely work it out.\n\n\/\/ A list of useful distance function to simple primitives. All\n\/\/ these functions (except for ellipsoid) return an exact\n\/\/ euclidean distance, meaning they produce a better SDF than\n\/\/ what you'd get if you were constructing them from boolean\n\/\/ operations (such as cutting an infinite cylinder with two planes).\n\n\/\/ List of other 3D SDFs:\n\/\/    https:\/\/www.shadertoy.com\/playlist\/43cXRl\n\/\/ and\n\/\/    https:\/\/iquilezles.org\/articles\/distfunctions\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2   \/\/ make this 2 or 3 for antialiasing\n#endif\n\n\/\/------------------------------------------------------------------\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \/\/ approximated\n{\n    float k0 = length(p\/r);\n    float k1 = length(p\/(r*r));\n    return k0*(k0-1.0)\/k1;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdOctogonPrism( in vec3 p, in float r, float h )\n{\n  const vec3 k = vec3(-0.9238795325,   \/\/ sqrt(2+sqrt(2))\/2 \n                       0.3826834323,   \/\/ sqrt(2-sqrt(2))\/2\n                       0.4142135623 ); \/\/ sqrt(2)-1 \n  \/\/ reflections\n  p = abs(p);\n  p.xy -= 2.0*min(dot(vec2( k.x,k.y),p.xy),0.0)*vec2( k.x,k.y);\n  p.xy -= 2.0*min(dot(vec2(-k.x,k.y),p.xy),0.0)*vec2(-k.x,k.y);\n  \/\/ polygon side\n  p.xy -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  vec2 d = vec2( length(p.xy)*sign(p.y), p.z-h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)\/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    \/\/ sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0\/l2;\n    \n    \/\/ sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    \/\/ single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy \/= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0\/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)\/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n\/\/ vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\/\/ arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))\/baba;\n}\n\n\/\/ vertical\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n    vec2 q = h*vec2(c.x,-c.y)\/c.y;\n    vec2 w = vec2( length(p.xz), p.y );\n    \n\tvec2 a = w - q*clamp( dot(w,q)\/dot(q,q), 0.0, 1.0 );\n    vec2 b = w - q*vec2( clamp( w.x\/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n\treturn sqrt(d)*sign(s);\n}\n\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)\/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)\/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)\/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\n\/\/ c is the sin\/cos of the desired cone angle\nfloat sdSolidAngle(vec3 pos, vec2 c, float ra)\n{\n    vec2 p = vec2( length(pos.xz), pos.y );\n    float l = length(p) - ra;\n\tfloat m = length(p - c*clamp(dot(p,c),0.0,ra) );\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n\n    \/\/ exact distance\n    #if 0\n    vec3 o = min(3.0*p - m, 0.0);\n    o = max(6.0*p - m*2.0 - o*3.0 + (o.x+o.y+o.z), 0.0);\n    return length(p - s*o\/(o.x+o.y+o.z));\n    #endif\n    \n    \/\/ exact distance\n    #if 1\n \tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n    #endif\n    \n    \/\/ bound, not exact\n    #if 0\n\treturn m*0.57735027;\n    #endif\n}\n\nfloat sdPyramid( in vec3 p, in float h )\n{\n    float m2 = h*h + 0.25;\n    \n    \/\/ symmetry\n    p.xz = abs(p.xz);\n    p.xz = (p.z>p.x) ? p.zx : p.xz;\n    p.xz -= 0.5;\n\t\n    \/\/ project into face plane (2D)\n    vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p.z)\/(m2+0.25), 0.0, 1.0 );\n    \n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n\tfloat b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n    \/\/ recover 3D and scale, and add sign\n    return sqrt( (d2+q.z*q.z)\/m2 ) * sign(max(q.z,-p.y));;\n}\n\n\/\/ la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n    p = abs(p);\n    vec2 b = vec2(la,lb);\n    float f = clamp( (ndot(b,b-2.0*p.xz))\/dot(b,b), -1.0, 1.0 );\n\tvec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\nfloat sdHorseshoe( in vec3 p, in vec2 c, in float r, in float le, vec2 w )\n{\n    p.x = abs(p.x);\n    float l = length(p.xy);\n    p.xy = mat2(-c.x, c.y, \n              c.y, c.x)*p.xy;\n    p.xy = vec2((p.y>0.0 || p.x>0.0)?p.x:l*sign(-c.x),\n                (p.x>0.0)?p.y:l );\n    p.xy = vec2(p.x,abs(p.y-r))-vec2(le,0.0);\n    \n    vec2 q = vec2(length(max(p.xy,0.0)) + min(0.0,max(p.x,p.y)),p.z);\n    vec2 d = abs(q) - w;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdU( in vec3 p, in float r, in float le, vec2 w )\n{\n    p.x = (p.y>0.0) ? abs(p.x) : length(p.xy);\n    p.x = abs(p.x-r);\n    p.y = p.y - le;\n    float k = max(p.x,p.y);\n    vec2 q = vec2( (k<0.0) ? -k : length(max(p.xy,0.0)), abs(p.z) ) - w;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\n\/\/------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n\/\/------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n\/\/------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( 1e10, 0.0 );\n\n    {\n      res = opU( res, vec2( sdSphere(    pos-vec3(-2.0,0.25, 0.0), 0.25 ), 26.9 ) );\n\t  res = opU( res, vec2( sdRhombus(   (pos-vec3(-2.0,0.25, 1.0)).xzy, 0.15, 0.25, 0.04, 0.08 ),17.0 ) );\n    }\n\n    \/\/ bounding box\n    if( sdBox( pos-vec3(0.0,0.3,-1.0),vec3(0.35,0.3,2.5) )<res.x )\n    {\n    \/\/ more primitives\n    res = opU( res, vec2( sdBoxFrame(    pos-vec3( 0.0,0.25, 0.0), vec3(0.3,0.25,0.2), 0.025 ), 16.9 ) );\n\tres = opU( res, vec2( sdTorus(      (pos-vec3( 0.0,0.30, 1.0)).xzy, vec2(0.25,0.05) ), 25.0 ) );\n\tres = opU( res, vec2( sdCone(        pos-vec3( 0.0,0.45,-1.0), vec2(0.6,0.8),0.45 ), 55.0 ) );\n    res = opU( res, vec2( sdCappedCone(  pos-vec3( 0.0,0.25,-2.0), 0.25, 0.25, 0.1 ), 13.67 ) );\n    res = opU( res, vec2( sdSolidAngle(  pos-vec3( 0.0,0.00,-3.0), vec2(3,4)\/5.0, 0.4 ), 49.13 ) );\n    }\n\n    \/\/ bounding box\n    if( sdBox( pos-vec3(1.0,0.3,-1.0),vec3(0.35,0.3,2.5) )<res.x )\n    {\n    \/\/ more primitives\n\tres = opU( res, vec2( sdCappedTorus((pos-vec3( 1.0,0.30, 1.0))*vec3(1,-1,1), vec2(0.866025,-0.5), 0.25, 0.05), 8.5) );\n    res = opU( res, vec2( sdBox(         pos-vec3( 1.0,0.25, 0.0), vec3(0.3,0.25,0.1) ), 3.0 ) );\n    res = opU( res, vec2( sdCapsule(     pos-vec3( 1.0,0.00,-1.0),vec3(-0.1,0.1,-0.1), vec3(0.2,0.4,0.2), 0.1  ), 31.9 ) );\n\tres = opU( res, vec2( sdCylinder(    pos-vec3( 1.0,0.25,-2.0), vec2(0.15,0.25) ), 8.0 ) );\n    res = opU( res, vec2( sdHexPrism(    pos-vec3( 1.0,0.2,-3.0), vec2(0.2,0.05) ), 18.4 ) );\n    }\n\n    \/\/ bounding box\n    if( sdBox( pos-vec3(-1.0,0.35,-1.0),vec3(0.35,0.35,2.5))<res.x )\n    {\n    \/\/ more primitives\n\tres = opU( res, vec2( sdPyramid(    pos-vec3(-1.0,-0.6,-3.0), 1.0 ), 13.56 ) );\n\tres = opU( res, vec2( sdOctahedron( pos-vec3(-1.0,0.15,-2.0), 0.35 ), 23.56 ) );\n    res = opU( res, vec2( sdTriPrism(   pos-vec3(-1.0,0.15,-1.0), vec2(0.3,0.05) ),43.5 ) );\n    res = opU( res, vec2( sdEllipsoid(  pos-vec3(-1.0,0.25, 0.0), vec3(0.2, 0.25, 0.05) ), 43.17 ) );\n    res = opU( res, vec2( sdHorseshoe(  pos-vec3(-1.0,0.25, 1.0), vec2(cos(1.3),sin(1.3)), 0.2, 0.3, vec2(0.03,0.08) ), 11.5 ) );\n    }\n\n    \/\/ bounding box\n    if( sdBox( pos-vec3(2.0,0.3,-1.0),vec3(0.35,0.3,2.5) )<res.x )\n    {\n    \/\/ more primitives\n    res = opU( res, vec2( sdOctogonPrism(pos-vec3( 2.0,0.2,-3.0), 0.2, 0.05), 51.8 ) );\n    res = opU( res, vec2( sdCylinder(    pos-vec3( 2.0,0.15,-2.0), vec3(0.1,-0.1,0.0), vec3(-0.2,0.35,0.1), 0.08), 31.2 ) );\n\tres = opU( res, vec2( sdCappedCone(  pos-vec3( 2.0,0.10,-1.0), vec3(0.1,0.0,0.0), vec3(-0.2,0.40,0.1), 0.15, 0.05), 46.1 ) );\n    res = opU( res, vec2( sdRoundCone(   pos-vec3( 2.0,0.15, 0.0), vec3(0.1,0.0,0.0), vec3(-0.1,0.35,0.1), 0.15, 0.05), 51.7 ) );\n    res = opU( res, vec2( sdRoundCone(   pos-vec3( 2.0,0.20, 1.0), 0.2, 0.1, 0.3 ), 37.0 ) );\n    }\n    \n    return res;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/boxfunctions\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0\/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nvec2 raycast( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    \/\/ raytrace floor plane\n    float tp1 = (0.0-ro.y)\/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n        res = vec2( tp1, 1.0 );\n    }\n    \/\/else return res;\n    \n    \/\/ raymarch primitives   \n    vec2 tb = iBox( ro-vec3(0.0,0.4,-0.5), rd, vec3(2.5,0.41,3.0) );\n    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        \/\/return vec2(tb.x,2.0);\n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for( int i=0; i<70 && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec2(t,h.y); \n                break;\n            }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    \/\/ bounding volume\n    float tp = (0.8-ro.y)\/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<24; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        float s = clamp(8.0*h\/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    \/\/ inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n      \/\/if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/nvscene2008\/rwwtt.pdf\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)\/4.0;\n        float d = map( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/checkerfiltering\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    \/\/ filter kernel\n    vec2 w = abs(dpdx)+abs(dpdy) + 0.001;\n    \/\/ analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))\/w;\n    \/\/ xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy )\n{ \n    \/\/ background\n    vec3 col = vec3(0.7, 0.7, 0.9) - max(rd.y,0.0)*0.3;\n    \n    \/\/ raycast scene\n    vec2 res = raycast(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        \/\/ material        \n        col = 0.2 + 0.2*sin( m*2.0 + vec3(0.0,1.0,2.0) );\n        float ks = 1.0;\n        \n        if( m<1.5 )\n        {\n            \/\/ project pixel footprint into the plane\n            vec3 dpdx = ro.y*(rd\/rd.y-rdx\/rdx.y);\n            vec3 dpdy = ro.y*(rd\/rd.y-rdy\/rdy.y);\n\n            float f = checkersGradBox( 3.0*pos.xz, 3.0*dpdx.xz, 3.0*dpdy.xz );\n            col = 0.15 + f*vec3(0.05);\n            ks = 0.4;\n        }\n\n        \/\/ lighting\n        float occ = calcAO( pos, nor );\n        \n\t\tvec3 lin = vec3(0.0);\n\n        \/\/ sun\n        {\n            vec3  lig = normalize( vec3(-0.5, 0.4, -0.6) );\n            vec3  hal = normalize( lig-rd );\n            float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n          \/\/if( dif>0.0001 )\n        \t      dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n\t\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0);\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0-dot(hal,lig),0.0,1.0),5.0);\n                \/\/spe *= 0.04+0.96*pow(clamp(1.0-sqrt(0.5*(1.0-dot(rd,lig))),0.0,1.0),5.0);\n            lin += col*2.20*dif*vec3(1.30,1.00,0.70);\n            lin +=     5.00*spe*vec3(1.30,1.00,0.70)*ks;\n        }\n        \/\/ sky\n        {\n            float dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n                  dif *= occ;\n            float spe = smoothstep( -0.2, 0.2, ref.y );\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0+dot(nor,rd),0.0,1.0), 5.0 );\n          \/\/if( spe>0.001 )\n                  spe *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n            lin += col*0.60*dif*vec3(0.40,0.60,1.15);\n            lin +=     2.00*spe*vec3(0.40,0.60,1.30)*ks;\n        }\n        \/\/ back\n        {\n        \tfloat dif = clamp( dot( nor, normalize(vec3(0.5,0.0,0.6))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n                  dif *= occ;\n        \tlin += col*0.55*dif*vec3(0.25,0.25,0.25);\n        }\n        \/\/ sss\n        {\n            float dif = pow(clamp(1.0+dot(nor,rd),0.0,1.0),2.0);\n                  dif *= occ;\n        \tlin += col*0.25*dif*vec3(1.00,1.00,1.00);\n        }\n        \n\t\tcol = lin;\n\n        col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy\/iResolution.xy;\n\tfloat time = 32.0 + iTime*1.5;\n\n    \/\/ camera\t\n    vec3 ta = vec3( 0.5, -0.5, -0.6 );\n    vec3 ro = ta + vec3( 4.5*cos(0.1*time + 7.0*mo.x), 1.3 + 2.0*mo.y, 4.5*sin(0.1*time + 7.0*mo.x) );\n    \/\/ camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        \/\/ pixel coordinates\n        vec2 o = vec2(float(m),float(n)) \/ float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)\/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)\/iResolution.y;\n#endif\n\n        \/\/ focal length\n        const float fl = 2.5;\n        \n        \/\/ ray direction\n        vec3 rd = ca * normalize( vec3(p,fl) );\n\n         \/\/ ray differentials\n        vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)\/iResolution.y;\n        vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)\/iResolution.y;\n        vec3 rdx = ca * normalize( vec3(px,fl) );\n        vec3 rdy = ca * normalize( vec3(py,fl) );\n        \n        \/\/ render\t\n        vec3 col = render( ro, rd, rdx, rdy );\n\n        \/\/ gain\n        \/\/ col = col*3.0\/(2.5+col);\n        \n\t\t\/\/ gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot \/= float(AA*AA);\n#endif\n    \n    fragColor = vec4( tot, 1.0 );\n}",
                "name": "Image",
                "description": "",
                "type": "image"
            }
        ]
    },
    {
        "ver": "0.1",
        "info": {
            "id": "XslGRr",
            "date": "1361810389",
            "viewed": 261460,
            "name": "Clouds",
            "username": "iq",
            "description": "Raymarching some fbm (you can move the mouse around). This is my first shader in the \"one shader a week for a year\" challenge that I have committed to. Some related info: [url]https:\/\/iquilezles.org\/articles\/derivative[\/url]",
            "likes": 1718,
            "published": 3,
            "flags": 0,
            "usePreview": 0,
            "tags": []
        },
        "renderpass": [
            {
                "inputs": [
                    {
                        "id": "Xsf3zn",
                        "filepath": "\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
                        "previewfilepath": "\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
                        "type": "texture",
                        "channel": 0,
                        "sampler": {
                            "filter": "mipmap",
                            "wrap": "repeat",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    },
                    {
                        "id": "4sfGRr",
                        "filepath": "\/media\/a\/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin",
                        "previewfilepath": "\/media\/ap\/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin",
                        "type": "volume",
                        "channel": 2,
                        "sampler": {
                            "filter": "mipmap",
                            "wrap": "repeat",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    },
                    {
                        "id": "XsBSR3",
                        "filepath": "\/media\/a\/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png",
                        "previewfilepath": "\/media\/ap\/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png",
                        "type": "texture",
                        "channel": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "wrap": "repeat",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "4dfGRr",
                        "channel": 0
                    }
                ],
                "code": "\/\/ Copyright Inigo Quilez, 2013 - https:\/\/iquilezles.org\/\n\/\/ I am the sole copyright owner of this Work.\n\/\/ You cannot host, display, distribute or share this Work in any form,\n\/\/ including physical and digital. You cannot use this Work in any\n\/\/ commercial or non-commercial product, website or project. You cannot\n\/\/ sell this Work and you cannot mint an NFTs of it.\n\/\/ I share this Work for educational purposes, and you can link to it,\n\/\/ through an URL, proper attribution and unmodified screenshot, as part\n\/\/ of your educational material. If these conditions are too restrictive\n\/\/ please contact me and we'll definitely work it out.\n\n\n\/\/ Volumetric clouds. Not physically correct in any way - \n\/\/ it does the wrong extintion computations and also\n\/\/ works in sRGB instead of linear RGB color space. No\n\/\/ shadows are computed, no scattering is computed. It is\n\/\/ a volumetric raymarcher than samples an fBM and tweaks\n\/\/ the colors to make it look good.\n\/\/\n\/\/ Lighting is done with only one extra sample per raymarch\n\/\/ step instead of using 3 to compute a density gradient,\n\/\/ by using this directional derivative technique:\n\/\/\n\/\/ https:\/\/iquilezles.org\/articles\/derivative\n\n\n\/\/ 0: one 3d texture lookup\n\/\/ 1: two 2d texture lookups with hardware interpolation\n\/\/ 2: two 2d texture lookups with software interpolation\n#define NOISE_METHOD 1\n\n\/\/ 0: no LOD\n\/\/ 1: yes LOD\n#define USE_LOD 1\n\n\/\/ 0: sunset look\n\/\/ 1: bright look\n#define LOOK 1\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\n#if NOISE_METHOD==0\n    x = p + f;\n    return textureLod(iChannel2,(x+0.5)\/32.0,0.0).x*2.0-1.0;\n#endif\n#if NOISE_METHOD==1\n\tvec2 uv = (p.xy+vec2(37.0,239.0)*p.z) + f.xy;\n    vec2 rg = textureLod(iChannel0,(uv+0.5)\/256.0,0.0).yx;\n\treturn mix( rg.x, rg.y, f.z )*2.0-1.0;\n#endif    \n#if NOISE_METHOD==2\n    ivec3 q = ivec3(p);\n\tivec2 uv = q.xy + ivec2(37,239)*q.z;\n\tvec2 rg = mix(mix(texelFetch(iChannel0,(uv           )&255,0),\n\t\t\t\t      texelFetch(iChannel0,(uv+ivec2(1,0))&255,0),f.x),\n\t\t\t\t  mix(texelFetch(iChannel0,(uv+ivec2(0,1))&255,0),\n\t\t\t\t      texelFetch(iChannel0,(uv+ivec2(1,1))&255,0),f.x),f.y).yx;\n\treturn mix( rg.x, rg.y, f.z )*2.0-1.0;\n#endif    \n}\n\n#if LOOK==0\nfloat map( in vec3 p, int oct )\n{\n\tvec3 q = p - vec3(0.0,0.1,1.0)*iTime;\n    float g = 0.5+0.5*noise( q*0.3 );\n    \n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    #if USE_LOD==1\n    if( oct>=2 ) \n    #endif\n    f += 0.25000*noise( q ); q = q*2.23;\n    #if USE_LOD==1\n    if( oct>=3 )\n    #endif\n    f += 0.12500*noise( q ); q = q*2.41;\n    #if USE_LOD==1\n    if( oct>=4 )\n    #endif\n    f += 0.06250*noise( q ); q = q*2.62;\n    #if USE_LOD==1\n    if( oct>=5 )\n    #endif\n    f += 0.03125*noise( q ); \n    \n    f = mix( f*0.1-0.75, f, g*g ) + 0.1;\n    return 1.5*f - 0.5 - p.y;\n}\n\nconst int kDiv = 1; \/\/ make bigger for higher quality\nconst vec3 sundir = normalize( vec3(-1.0,0.0,-1.0) );\n\nvec4 raymarch( in vec3 ro, in vec3 rd, in vec3 bgcol, in ivec2 px )\n{\n    \/\/ bounding planes\t\n    const float yb = -3.0;\n    const float yt =  0.6;\n    float tb = (yb-ro.y)\/rd.y;\n    float tt = (yt-ro.y)\/rd.t;\n\n    \/\/ find tigthest possible raymarching segment\n    float tmin, tmax;\n    if( ro.y>yt )\n    {\n        \/\/ above top plane\n        if( tt<0.0 ) return vec4(0.0); \/\/ early exit\n        tmin = tt;\n        tmax = tb;\n    }\n    else\n    {\n        \/\/ inside clouds slabs\n        tmin = 0.0;\n        tmax = 60.0;\n        if( tt>0.0 ) tmax = min( tmax, tt );\n        if( tb>0.0 ) tmax = min( tmax, tb );\n    }\n    \n    \/\/ dithered near distance\n    float t = tmin + 0.1*texelFetch( iChannel1, px&1023, 0 ).x;\n    \n    \/\/ raymarch loop\n\tvec4 sum = vec4(0.0);\n    for( int i=0; i<190*kDiv; i++ )\n    {\n       \/\/ step size\n       float dt = max(0.05,0.02*t\/float(kDiv));\n\n       \/\/ lod\n       #if USE_LOD==0\n       const int oct = 5;\n       #else\n       int oct = 5 - int( log2(1.0+t*0.5) );\n       #endif\n       \n       \/\/ sample cloud\n       vec3 pos = ro + t*rd;\n       float den = map( pos,oct );\n       if( den>0.01 ) \/\/ if inside\n       {\n           \/\/ do lighting\n           float dif = clamp((den - map(pos+0.3*sundir,oct))\/0.3, 0.0, 1.0 );\n           vec3  lin = vec3(0.65,0.65,0.75)*1.1 + 0.8*vec3(1.0,0.6,0.3)*dif;\n           vec4  col = vec4( mix( vec3(1.0,0.95,0.8), vec3(0.25,0.3,0.35), den ), den );\n           col.xyz *= lin;\n           \/\/ fog\n           col.xyz = mix(col.xyz,bgcol, 1.0-exp2(-0.075*t));\n           \/\/ composite front to back\n           col.w    = min(col.w*8.0*dt,1.0);\n           col.rgb *= col.a;\n           sum += col*(1.0-sum.a);\n       }\n       \/\/ advance ray\n       t += dt;\n       \/\/ until far clip or full opacity\n       if( t>tmax || sum.a>0.99 ) break;\n    }\n\n    return clamp( sum, 0.0, 1.0 );\n}\n\nvec4 render( in vec3 ro, in vec3 rd, in ivec2 px )\n{\n\tfloat sun = clamp( dot(sundir,rd), 0.0, 1.0 );\n\n    \/\/ background sky\n    vec3 col = vec3(0.76,0.75,0.86);\n    col -= 0.6*vec3(0.90,0.75,0.95)*rd.y;\n\tcol += 0.2*vec3(1.00,0.60,0.10)*pow( sun, 8.0 );\n\n    \/\/ clouds    \n    vec4 res = raymarch( ro, rd, col, px );\n    col = col*(1.0-res.w) + res.xyz;\n    \n    \/\/ sun glare    \n\tcol += 0.2*vec3(1.0,0.4,0.2)*pow( sun, 3.0 );\n\n    \/\/ tonemap\n    col = smoothstep(0.15,1.1,col);\n \n    return vec4( col, 1.0 );\n}\n\n#else\n\n\nfloat map5( in vec3 p )\n{    \n    vec3 q = p - vec3(0.0,0.1,1.0)*iTime;    \n    float f;\n    f  = 0.50000*noise( q ); q = q*2.02;    \n    f += 0.25000*noise( q ); q = q*2.03;    \n    f += 0.12500*noise( q ); q = q*2.01;    \n    f += 0.06250*noise( q ); q = q*2.02;    \n    f += 0.03125*noise( q );    \n    return clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\nfloat map4( in vec3 p )\n{    \n    vec3 q = p - vec3(0.0,0.1,1.0)*iTime;    \n    float f;\n    f  = 0.50000*noise( q ); q = q*2.02;    \n    f += 0.25000*noise( q ); q = q*2.03;    \n    f += 0.12500*noise( q ); q = q*2.01;   \n    f += 0.06250*noise( q );    \n    return clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\nfloat map3( in vec3 p )\n{\n    vec3 q = p - vec3(0.0,0.1,1.0)*iTime;    \n    float f;\n    f  = 0.50000*noise( q ); q = q*2.02;    \n    f += 0.25000*noise( q ); q = q*2.03;    f += 0.12500*noise( q );    \n    return clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\nfloat map2( in vec3 p )\n{    \n    vec3 q = p - vec3(0.0,0.1,1.0)*iTime;    \n    float f;\n    f  = 0.50000*noise( q ); \n    q = q*2.02;    f += 0.25000*noise( q );;    \n    return clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\n\nconst vec3 sundir = vec3(-0.7071,0.0,-0.7071);\n\n#define MARCH(STEPS,MAPLOD) for(int i=0; i<STEPS; i++) { vec3 pos = ro + t*rd; if( pos.y<-3.0 || pos.y>2.0 || sum.a>0.99 ) break; float den = MAPLOD( pos ); if( den>0.01 ) { float dif = clamp((den - MAPLOD(pos+0.3*sundir))\/0.6, 0.0, 1.0 ); vec3  lin = vec3(1.0,0.6,0.3)*dif+vec3(0.91,0.98,1.05); vec4  col = vec4( mix( vec3(1.0,0.95,0.8), vec3(0.25,0.3,0.35), den ), den ); col.xyz *= lin; col.xyz = mix( col.xyz, bgcol, 1.0-exp(-0.003*t*t) ); col.w *= 0.4; col.rgb *= col.a; sum += col*(1.0-sum.a); } t += max(0.06,0.05*t); }\n\nvec4 raymarch( in vec3 ro, in vec3 rd, in vec3 bgcol, in ivec2 px )\n{    \n    vec4 sum = vec4(0.0);    \n    float t = 0.05*texelFetch( iChannel1, px&255, 0 ).x;    \n    MARCH(40,map5);    \n    MARCH(40,map4);    \n    MARCH(30,map3);    \n    MARCH(30,map2);    \n    return clamp( sum, 0.0, 1.0 );\n}\n\nvec4 render( in vec3 ro, in vec3 rd, in ivec2 px )\n{\n    \/\/ background sky         \n    float sun = clamp( dot(sundir,rd), 0.0, 1.0 );    \n    vec3 col = vec3(0.6,0.71,0.75) - rd.y*0.2*vec3(1.0,0.5,1.0) + 0.15*0.5;    \n    col += 0.2*vec3(1.0,.6,0.1)*pow( sun, 8.0 );    \n    \/\/ clouds        \n    vec4 res = raymarch( ro, rd, col, px );    \n    col = col*(1.0-res.w) + res.xyz;        \n    \/\/ sun glare        \n    col += vec3(0.2,0.08,0.04)*pow( sun, 3.0 );    \n    return vec4( col, 1.0 );\n}\n\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)\/iResolution.y;\n    vec2 m =                iMouse.xy      \/iResolution.xy;\n\n    \/\/ camera\n    vec3 ro = 4.0*normalize(vec3(sin(3.0*m.x), 0.8*m.y, cos(3.0*m.x))) - vec3(0.0,0.1,0.0);\n\tvec3 ta = vec3(0.0, -1.0, 0.0);\n    mat3 ca = setCamera( ro, ta, 0.07*cos(0.25*iTime) );\n    \/\/ ray\n    vec3 rd = ca * normalize( vec3(p.xy,1.5));\n    \n    fragColor = render( ro, rd, ivec2(fragCoord-0.5) );\n}\n",
                "name": "Image",
                "description": "",
                "type": "image"
            }
        ]
    },
    {
        "ver": "0.1",
        "info": {
            "id": "4ttSWf",
            "date": "1482384986",
            "viewed": 225556,
            "name": "Rainforest",
            "username": "iq",
            "description": "Another terrain, with cheap trees made of ellipsoids and noise. It computes analytic normals for the terrain and clouds. The art composed to camera as usual. Making-of Tutorial: [url]https:\/\/www.youtube.com\/watch?v=BFld4EBO2RE[\/url]",
            "likes": 1029,
            "published": 3,
            "flags": 32,
            "usePreview": 0,
            "tags": []
        },
        "renderpass": [
            {
                "inputs": [
                    {
                        "id": "4dXGR8",
                        "filepath": "\/media\/previz\/buffer00.png",
                        "previewfilepath": "\/media\/previz\/buffer00.png",
                        "type": "buffer",
                        "channel": 0,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "4dfGRr",
                        "channel": 0
                    }
                ],
                "code": "\/\/ Copyright Inigo Quilez, 2016 - https:\/\/iquilezles.org\/\n\/\/ I am the sole copyright owner of this Work.\n\/\/ You cannot host, display, distribute or share this Work in any form,\n\/\/ including physical and digital. You cannot use this Work in any\n\/\/ commercial or non-commercial product, website or project. You cannot\n\/\/ sell this Work and you cannot mint an NFTs of it.\n\/\/ I share this Work for educational purposes, and you can link to it,\n\/\/ through an URL, proper attribution and unmodified screenshot, as part\n\/\/ of your educational material. If these conditions are too restrictive\n\/\/ please contact me and we'll definitely work it out.\n\n\/\/ A rainforest landscape.\n\/\/\n\/\/ Making of Tutorial: https:\/\/www.youtube.com\/watch?v=BFld4EBO2RE\n\/\/ Buy a metal or paper print: https:\/\/www.redbubble.com\/shop\/ap\/39843511\n\/\/\n\/\/ Normals are analytical (true derivatives) for the terrain and for the\n\/\/ clouds, including the noise, the fbm and the smoothsteps.\n\/\/\n\/\/ Lighting and art composed for this shot\/camera. The trees are really\n\/\/ ellipsoids with noise, but they kind of do the job in distance and low\n\/\/ image resolutions Also I used some basic reprojection technique to \n\/\/ smooth out the render.\n\/\/\n\/\/ See here for more info: \n\/\/  https:\/\/iquilezles.org\/articles\/fbm\n\/\/  https:\/\/iquilezles.org\/articles\/morenoise\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord\/iResolution.xy;\n\n    vec3 col = texture( iChannel0, p ).xyz;\n  \/\/vec3 col = texelFetch( iChannel0, ivec2(fragCoord-0.5), 0 ).xyz;\n\n    col *= 0.5 + 0.5*pow( 16.0*p.x*p.y*(1.0-p.x)*(1.0-p.y), 0.05 );\n         \n    fragColor = vec4( col, 1.0 );\n}\n",
                "name": "Image",
                "description": "",
                "type": "image"
            },
            {
                "inputs": [
                    {
                        "id": "4dXGR8",
                        "filepath": "\/media\/previz\/buffer00.png",
                        "previewfilepath": "\/media\/previz\/buffer00.png",
                        "type": "buffer",
                        "channel": 0,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "4dXGR8",
                        "channel": 0
                    }
                ],
                "code": "#define LOWQUALITY\n\n\/\/==========================================================================================\n\/\/ general utilities\n\/\/==========================================================================================\n#define ZERO (min(iFrame,0))\n\nfloat sdEllipsoidY( in vec3 p, in vec2 r )\n{\n    float k0 = length(p\/r.xyx);\n    float k1 = length(p\/(r.xyx*r.xyx));\n    return k0*(k0-1.0)\/k1;\n}\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p\/r);\n    float k1 = length(p\/(r*r));\n    return k0*(k0-1.0)\/k1;\n}\n\n\/\/ return smoothstep and its derivative\nvec2 smoothstepd( float a, float b, float x)\n{\n\tif( x<a ) return vec2( 0.0, 0.0 );\n\tif( x>b ) return vec2( 1.0, 0.0 );\n    float ir = 1.0\/(b-a);\n    x = (x-a)*ir;\n    return vec2( x*x*(3.0-2.0*x), 6.0*x*(1.0-x)*ir );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\/\/==========================================================================================\n\/\/ hashes (low quality, do NOT use in production)\n\/\/==========================================================================================\n\nfloat hash1( vec2 p )\n{\n    p  = 50.0*fract( p*0.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat hash1( float n )\n{\n    return fract( n*17.0*fract( n*0.3183099 ) );\n}\n\nvec2 hash2( vec2 p ) \n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    float n = 111.0*p.x + 113.0*p.y;\n    return fract(n*fract(k*n));\n}\n\n\/\/==========================================================================================\n\/\/ noises\n\/\/==========================================================================================\n\n\/\/ value noise, and its analytical derivatives\nvec4 noised( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    #if 1\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n    #else\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    #endif\n\n    float n = p.x + 317.0*p.y + 157.0*p.z;\n    \n    float a = hash1(n+0.0);\n    float b = hash1(n+1.0);\n    float c = hash1(n+317.0);\n    float d = hash1(n+318.0);\n    float e = hash1(n+157.0);\n\tfloat f = hash1(n+158.0);\n    float g = hash1(n+474.0);\n    float h = hash1(n+475.0);\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z), \n                      2.0* du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\n                                      k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\n                                      k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    #if 1\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    #else\n    vec3 u = w*w*(3.0-2.0*w);\n    #endif\n    \n\n\n    float n = p.x + 317.0*p.y + 157.0*p.z;\n    \n    float a = hash1(n+0.0);\n    float b = hash1(n+1.0);\n    float c = hash1(n+317.0);\n    float d = hash1(n+318.0);\n    float e = hash1(n+157.0);\n\tfloat f = hash1(n+158.0);\n    float g = hash1(n+474.0);\n    float h = hash1(n+475.0);\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z);\n}\n\nvec3 noised( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    #if 1\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec2 du = 30.0*w*w*(w*(w-2.0)+1.0);\n    #else\n    vec2 u = w*w*(3.0-2.0*w);\n    vec2 du = 6.0*w*(1.0-w);\n    #endif\n    \n    float a = hash1(p+vec2(0,0));\n    float b = hash1(p+vec2(1,0));\n    float c = hash1(p+vec2(0,1));\n    float d = hash1(p+vec2(1,1));\n\n    float k0 = a;\n    float k1 = b - a;\n    float k2 = c - a;\n    float k4 = a - b - c + d;\n\n    return vec3( -1.0+2.0*(k0 + k1*u.x + k2*u.y + k4*u.x*u.y), \n                 2.0*du * vec2( k1 + k4*u.y,\n                            k2 + k4*u.x ) );\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    #if 1\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    #else\n    vec2 u = w*w*(3.0-2.0*w);\n    #endif\n\n    float a = hash1(p+vec2(0,0));\n    float b = hash1(p+vec2(1,0));\n    float c = hash1(p+vec2(0,1));\n    float d = hash1(p+vec2(1,1));\n    \n    return -1.0+2.0*(a + (b-a)*u.x + (c-a)*u.y + (a - b - c + d)*u.x*u.y);\n}\n\n\/\/==========================================================================================\n\/\/ fbm constructions\n\/\/==========================================================================================\n\nconst mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                      -0.80,  0.36, -0.48,\n                      -0.60, -0.48,  0.64 );\nconst mat3 m3i = mat3( 0.00, -0.80, -0.60,\n                       0.80,  0.36, -0.48,\n                       0.60, -0.48,  0.64 );\nconst mat2 m2 = mat2(  0.80,  0.60,\n                      -0.60,  0.80 );\nconst mat2 m2i = mat2( 0.80, -0.60,\n                       0.60,  0.80 );\n\n\/\/------------------------------------------------------------------------------------------\n\nfloat fbm_4( in vec2 x )\n{\n    float f = 1.9;\n    float s = 0.55;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=ZERO; i<4; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*m2*x;\n    }\n\treturn a;\n}\n\nfloat fbm_4( in vec3 x )\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=ZERO; i<4; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*m3*x;\n    }\n\treturn a;\n}\n\nvec4 fbmd_7( in vec3 x )\n{\n    float f = 1.92;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    vec3  d = vec3(0.0);\n    mat3  m = mat3(1.0,0.0,0.0,\n                   0.0,1.0,0.0,\n                   0.0,0.0,1.0);\n    for( int i=ZERO; i<7; i++ )\n    {\n        vec4 n = noised(x);\n        a += b*n.x;          \/\/ accumulate values\t\t\n        d += b*m*n.yzw;      \/\/ accumulate derivatives\n        b *= s;\n        x = f*m3*x;\n        m = f*m3i*m;\n    }\n\treturn vec4( a, d );\n}\n\nvec4 fbmd_8( in vec3 x )\n{\n    float f = 2.0;\n    float s = 0.65;\n    float a = 0.0;\n    float b = 0.5;\n    vec3  d = vec3(0.0);\n    mat3  m = mat3(1.0,0.0,0.0,\n                   0.0,1.0,0.0,\n                   0.0,0.0,1.0);\n    for( int i=ZERO; i<8; i++ )\n    {\n        vec4 n = noised(x);\n        a += b*n.x;          \/\/ accumulate values\t\t\n        if( i<4 )\n        d += b*m*n.yzw;      \/\/ accumulate derivatives\n        b *= s;\n        x = f*m3*x;\n        m = f*m3i*m;\n    }\n\treturn vec4( a, d );\n}\n\nfloat fbm_9( in vec2 x )\n{\n    float f = 1.9;\n    float s = 0.55;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=ZERO; i<9; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*m2*x;\n    }\n    \n\treturn a;\n}\n\nvec3 fbmd_9( in vec2 x )\n{\n    float f = 1.9;\n    float s = 0.55;\n    float a = 0.0;\n    float b = 0.5;\n    vec2  d = vec2(0.0);\n    mat2  m = mat2(1.0,0.0,0.0,1.0);\n    for( int i=ZERO; i<9; i++ )\n    {\n        vec3 n = noised(x);\n        n.x = n.x;\n        \n        a += b*n.x;          \/\/ accumulate values\t\t\n        d += b*m*n.yz;       \/\/ accumulate derivatives\n        b *= s;\n        x = f*m2*x;\n        m = f*m2i*m;\n    }\n\n\treturn vec3( a, d );\n}\n\n\/\/==========================================================================================\n\/\/ specifics to the actual painting\n\/\/==========================================================================================\n\n\n\/\/------------------------------------------------------------------------------------------\n\/\/ global\n\/\/------------------------------------------------------------------------------------------\n\nconst vec3  kSunDir = vec3(-0.624695,0.468521,-0.624695);\nconst float kMaxTreeHeight = 4.8;\nconst float kMaxHeight = 840.0;\n\nvec3 fog( in vec3 col, float t )\n{\n    vec3 ext = exp2(-t*0.00025*vec3(1,1.5,4)); \n    return col*ext + (1.0-ext)*vec3(0.55,0.55,0.58); \/\/ 0.55\n}\n\n\/\/------------------------------------------------------------------------------------------\n\/\/ clouds\n\/\/------------------------------------------------------------------------------------------\n\nvec4 cloudsFbm( in vec3 pos )\n{\n    return fbmd_8(pos*0.0015+vec3(2.0,1.1,1.0)+0.07*vec3(iTime,0.5*iTime,-0.15*iTime));\n}\n\nvec4 cloudsMap( in vec3 pos, out float nnd )\n{\n    float d = abs(pos.y-900.0)-40.0;\n    vec3 gra = vec3(0.0,sign(pos.y-900.0),0.0);\n    \n    vec4 n = cloudsFbm(pos);\n    d += 400.0*n.x * (0.7+0.3*gra.y);\n    \n    if( d>0.0 ) return vec4(-d,0.0,0.0,0.0);\n    \n    nnd = -d;\n    d = min(-d\/100.0,0.25);\n    \n    \/\/gra += 0.1*n.yzw *  (0.7+0.3*gra.y);\n    \n    return vec4( d, gra );\n}\n\nfloat cloudsShadowFlat( in vec3 ro, in vec3 rd )\n{\n    float t = (900.0-ro.y)\/rd.y;\n    if( t<0.0 ) return 1.0;\n    vec3 pos = ro + rd*t;\n    return cloudsFbm(pos).x;\n}\n\nfloat terrainShadow( in vec3 ro, in vec3 rd, in float mint );\n\nvec4 renderClouds( in vec3 ro, in vec3 rd, float tmin, float tmax, inout float resT, in vec2 px )\n{\n    vec4 sum = vec4(0.0);\n\n    \/\/ bounding volume!!\n    float tl = ( 600.0-ro.y)\/rd.y;\n    float th = (1200.0-ro.y)\/rd.y;\n    if( tl>0.0 ) tmin = max( tmin, tl ); else return sum;\n    if( th>0.0 ) tmax = min( tmax, th );\n\n    float t = tmin;\n    \/\/t += 1.0*hash1(gl_FragCoord.xy);\n    float lastT = -1.0;\n    float thickness = 0.0;\n    for(int i=ZERO; i<128; i++)\n    { \n        vec3  pos = ro + t*rd; \n        float nnd;\n        vec4  denGra = cloudsMap( pos, nnd ); \n        float den = denGra.x;\n        float dt = max(0.2,0.011*t);\n        \/\/dt *= hash1(px+float(i));\n        if( den>0.001 ) \n        { \n            float kk;\n            cloudsMap( pos+kSunDir*70.0, kk );\n            float sha = 1.0-smoothstep(-200.0,200.0,kk); sha *= 1.5;\n            \n            vec3 nor = normalize(denGra.yzw);\n            float dif = clamp( 0.4+0.6*dot(nor,kSunDir), 0.0, 1.0 )*sha; \n            float fre = clamp( 1.0+dot(nor,rd), 0.0, 1.0 )*sha;\n            float occ = 0.2+0.7*max(1.0-kk\/200.0,0.0) + 0.1*(1.0-den);\n            \/\/ lighting\n            vec3 lin  = vec3(0.0);\n                 lin += vec3(0.70,0.80,1.00)*1.0*(0.5+0.5*nor.y)*occ;\n                 lin += vec3(0.10,0.40,0.20)*1.0*(0.5-0.5*nor.y)*occ;\n                 lin += vec3(1.00,0.95,0.85)*3.0*dif*occ + 0.1;\n\n            \/\/ color\n            vec3 col = vec3(0.8,0.8,0.8)*0.45;\n\n            col *= lin;\n\n            col = fog( col, t );\n\n            \/\/ front to back blending    \n            float alp = clamp(den*0.5*0.125*dt,0.0,1.0);\n            col.rgb *= alp;\n            sum = sum + vec4(col,alp)*(1.0-sum.a);\n\n            thickness += dt*den;\n            if( lastT<0.0 ) lastT = t;            \n        }\n        else \n        {\n            dt = abs(den)+0.2;\n\n        }\n        t += dt;\n        if( sum.a>0.995 || t>tmax ) break;\n    }\n    \n    \/\/resT = min(resT, (150.0-ro.y)\/rd.y );\n    if( lastT>0.0 ) resT = min(resT,lastT);\n    \/\/if( lastT>0.0 ) resT = mix( resT, lastT, sum.w );\n    \n    \n    sum.xyz += max(0.0,1.0-0.0125*thickness)*vec3(1.00,0.60,0.40)*0.3*pow(clamp(dot(kSunDir,rd),0.0,1.0),32.0);\n\n    return clamp( sum, 0.0, 1.0 );\n}\n\n\n\/\/------------------------------------------------------------------------------------------\n\/\/ terrain\n\/\/------------------------------------------------------------------------------------------\n\nvec2 terrainMap( in vec2 p )\n{\n    float e = fbm_9( p\/2000.0 + vec2(1.0,-2.0) );\n    float a = 1.0-smoothstep( 0.12, 0.13, abs(e+0.12) ); \/\/ flag high-slope areas (-0.25, 0.0)\n    e = 600.0*e + 600.0;\n    \n    \/\/ cliff\n    e += 90.0*smoothstep( 552.0, 594.0, e );\n    \/\/e += 90.0*smoothstep( 550.0, 600.0, e );\n    \n    return vec2(e,a);\n}\n\nvec4 terrainMapD( in vec2 p )\n{\n    vec3 e = fbmd_9( p\/2000.0 + vec2(1.0,-2.0) );\n    e.x  = 600.0*e.x + 600.0;\n    e.yz = 600.0*e.yz;\n\n    \/\/ cliff\n    vec2 c = smoothstepd( 550.0, 600.0, e.x );\n\te.x  = e.x  + 90.0*c.x;\n\te.yz = e.yz + 90.0*c.y*e.yz;     \/\/ chain rule\n    \n    e.yz \/= 2000.0;\n    return vec4( e.x, normalize( vec3(-e.y,1.0,-e.z) ) );\n}\n\nvec3 terrainNormal( in vec2 pos )\n{\n#if 1\n    return terrainMapD(pos).yzw;\n#else    \n    vec2 e = vec2(0.03,0.0);\n\treturn normalize( vec3(terrainMap(pos-e.xy).x - terrainMap(pos+e.xy).x,\n                           2.0*e.x,\n                           terrainMap(pos-e.yx).x - terrainMap(pos+e.yx).x ) );\n#endif    \n}\n\nfloat terrainShadow( in vec3 ro, in vec3 rd, in float mint )\n{\n    float res = 1.0;\n    float t = mint;\n#ifdef LOWQUALITY\n    for( int i=ZERO; i<32; i++ )\n    {\n        vec3  pos = ro + t*rd;\n        vec2  env = terrainMap( pos.xz );\n        float hei = pos.y - env.x;\n        res = min( res, 32.0*hei\/t );\n        if( res<0.0001 || pos.y>kMaxHeight ) break;\n        t += clamp( hei, 2.0+t*0.1, 100.0 );\n    }\n#else\n    for( int i=ZERO; i<128; i++ )\n    {\n        vec3  pos = ro + t*rd;\n        vec2  env = terrainMap( pos.xz );\n        float hei = pos.y - env.x;\n        res = min( res, 32.0*hei\/t );\n        if( res<0.0001 || pos.y>kMaxHeight  ) break;\n        t += clamp( hei, 0.5+t*0.05, 25.0 );\n    }\n#endif\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec2 raymarchTerrain( in vec3 ro, in vec3 rd, float tmin, float tmax )\n{\n    \/\/ bounding plane\n    float tp = (kMaxHeight+kMaxTreeHeight-ro.y)\/rd.y;\n    if( tp>0.0 ) tmax = min( tmax, tp );\n    \n    \/\/ raymarch\n    float dis, th;\n    float t2 = -1.0;\n    float t = tmin; \n    float ot = t;\n    float odis = 0.0;\n    float odis2 = 0.0;\n    for( int i=ZERO; i<400; i++ )\n    {\n        th = 0.001*t;\n\n        vec3  pos = ro + t*rd;\n        vec2  env = terrainMap( pos.xz );\n        float hei = env.x;\n\n        \/\/ tree envelope\n        float dis2 = pos.y - (hei+kMaxTreeHeight*1.1);\n        if( dis2<th ) \n        {\n            if( t2<0.0 )\n            {\n                t2 = ot + (th-odis2)*(t-ot)\/(dis2-odis2); \/\/ linear interpolation for better accuracy\n            }\n        }\n        odis2 = dis2;\n        \n        \/\/ terrain\n        dis = pos.y - hei;\n        if( dis<th ) break;\n        \n        ot = t;\n        odis = dis;\n        t += dis*0.8*(1.0-0.75*env.y); \/\/ slow down in step areas\n        if( t>tmax ) break;\n    }\n\n    if( t>tmax ) t = -1.0;\n    else t = ot + (th-odis)*(t-ot)\/(dis-odis); \/\/ linear interpolation for better accuracy\n    \n    return vec2(t,t2);\n}\n\n\/\/------------------------------------------------------------------------------------------\n\/\/ trees\n\/\/------------------------------------------------------------------------------------------\n\nfloat treesMap( in vec3 p, in float rt, out float oHei, out float oMat, out float oDis )\n{\n    oHei = 1.0;\n    oDis = 0.0;\n    oMat = 0.0;\n        \n    float base = terrainMap(p.xz).x; \n    \n    float bb = fbm_4(p.xz*0.075);\n\n    float d = 20.0;\n    vec2 n = floor( p.xz\/2.0 );\n    vec2 f = fract( p.xz\/2.0 );\n    for( int j=0; j<=1; j++ )\n    for( int i=0; i<=1; i++ )\n    {\n        vec2  g = vec2( float(i), float(j) ) - step(f,vec2(0.5));\n        vec2  o = hash2( n + g );\n        vec2  v = hash2( n + g + vec2(13.1,71.7) );\n        vec2  r = g - f + o;\n\n        float height = kMaxTreeHeight * (0.4+0.8*v.x);\n        float width = 0.5 + 0.2*v.x + 0.3*v.y;\n\n        if( bb<0.0 ) width *= 0.5; else height *= 0.7;\n        \n        vec3  q = vec3(r.x,p.y-base-height*0.5,r.y);\n        \n        float k = sdEllipsoidY( q, vec2(width,0.5*height) );\n\n        if( k<d )\n        { \n            d = k;\n            oMat = 0.5*hash1(n+g+111.0);\n            if( bb>0.0 ) oMat += 0.5;\n            oHei = (p.y - base)\/height;\n            oHei *= 0.5 + 0.5*length(q) \/ width;\n        }\n    }\n\n    \/\/ distort ellipsoids to make them look like trees (works only in the distance really)\n    if( rt<1200.0 )\n    {\n        p.y -= 600.0;\n        float s = fbm_4( p*3.0 );\n        s = s*s;\n        float att = 1.0-smoothstep(100.0,1200.0,rt);\n        d += 4.0*s*att;\n        oDis = s*att;\n    }\n    \n    return d;\n}\n\nfloat treesShadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.02;\n#ifdef LOWQUALITY\n    for( int i=ZERO; i<64; i++ )\n    {\n        float kk1, kk2, kk3;\n        vec3 pos = ro + rd*t;\n        float h = treesMap( pos, t, kk1, kk2, kk3 );\n        res = min( res, 32.0*h\/t );\n        t += h;\n        if( res<0.001 || t>50.0 || pos.y>kMaxHeight+kMaxTreeHeight ) break;\n    }\n#else\n    for( int i=ZERO; i<150; i++ )\n    {\n        float kk1, kk2, kk3;\n        float h = treesMap( ro + rd*t, t, kk1, kk2, kk3 );\n        res = min( res, 32.0*h\/t );\n        t += h;\n        if( res<0.001 || t>120.0 ) break;\n    }\n#endif\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 treesNormal( in vec3 pos, in float t )\n{\n    float kk1, kk2, kk3;\n#if 0    \n    const float eps = 0.005;\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*treesMap( pos + e.xyy, t, kk1, kk2, kk3 ) + \n                      e.yyx*treesMap( pos + e.yyx, t, kk1, kk2, kk3 ) + \n                      e.yxy*treesMap( pos + e.yxy, t, kk1, kk2, kk3 ) + \n                      e.xxx*treesMap( pos + e.xxx, t, kk1, kk2, kk3 ) );            \n#else\n    \/\/ inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*treesMap(pos+0.005*e, t, kk1, kk2, kk3);\n    }\n    return normalize(n);\n#endif    \n}\n\n\/\/------------------------------------------------------------------------------------------\n\/\/ sky\n\/\/------------------------------------------------------------------------------------------\n\nvec3 renderSky( in vec3 ro, in vec3 rd )\n{\n    \/\/ background sky     \n    \/\/vec3 col = vec3(0.45,0.6,0.85)\/0.85 - rd.y*vec3(0.4,0.36,0.4);\n    \/\/vec3 col = vec3(0.4,0.6,1.1) - rd.y*0.4;\n    vec3 col = vec3(0.42,0.62,1.1) - rd.y*0.4;\n\n    \/\/ clouds\n    float t = (2500.0-ro.y)\/rd.y;\n    if( t>0.0 )\n    {\n        vec2 uv = (ro+t*rd).xz;\n        float cl = fbm_9( uv*0.00104 );\n        float dl = smoothstep(-0.2,0.6,cl);\n        col = mix( col, vec3(1.0), 0.12*dl );\n    }\n    \n\t\/\/ sun glare    \n    float sun = clamp( dot(kSunDir,rd), 0.0, 1.0 );\n    col += 0.2*vec3(1.0,0.6,0.3)*pow( sun, 32.0 );\n    \n\treturn col;\n}\n\n\/\/------------------------------------------------------------------------------------------\n\/\/ main image making function\n\/\/------------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o = hash2( vec2(iFrame,1) ) - 0.5;\n    \n    vec2 p = (2.0*(fragCoord+o)-iResolution.xy)\/ iResolution.y;\n    \n    \/\/----------------------------------\n    \/\/ setup\n    \/\/----------------------------------\n\n    \/\/ camera\n    float time = iTime;\n    vec3 ro = vec3(0.0, 401.5, 6.0);\n    vec3 ta = vec3(0.0, 403.5, -90.0 + ro.z );\n    \n    \/\/ro += vec3(10.0*sin(0.02*time),0.0,-10.0*sin(0.2+0.031*time))\n    \n    ro.x -= 80.0*sin(0.01*time);\n    ta.x -= 86.0*sin(0.01*time);\n\n    \/\/ ray\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    vec3 rd = ca * normalize( vec3(p,1.5));\n\n\tfloat resT = 2000.0;\n\n    \/\/----------------------------------\n    \/\/ sky\n    \/\/----------------------------------\n\n    vec3 col = renderSky( ro, rd );\n\n\n    \/\/----------------------------------\n    \/\/ raycast terrain and tree envelope\n    \/\/----------------------------------\n    {\n    const float tmax = 2000.0;\n    int   obj = 0;\n    vec2 t = raymarchTerrain( ro, rd, 15.0, tmax );\n    if( t.x>0.0 )\n    {\n        resT = t.x;\n        obj = 1;\n    }\n\n    \/\/----------------------------------\n    \/\/ raycast trees, if needed\n    \/\/----------------------------------\n    float hei, mid, displa;\n    \n    if( t.y>0.0 )\n    {\n        float tf = t.y;\n        float tfMax = (t.x>0.0)?t.x:tmax;\n        for(int i=ZERO; i<64; i++) \n        { \n            vec3  pos = ro + tf*rd; \n            float dis = treesMap( pos, tf, hei, mid, displa); \n            if( dis<(0.000125*tf) ) break;\n            tf += dis;\n            if( tf>tfMax ) break;\n        }\n        if( tf<tfMax )\n        {\n            resT = tf;\n            obj = 2;\n        }\n    }\n\n    \/\/----------------------------------\n    \/\/ shade\n    \/\/----------------------------------\n    if( obj>0 )\n    {\n        vec3 pos  = ro + resT*rd;\n        vec3 epos = pos + vec3(0.0,4.8,0.0);\n\n        float sha1  = terrainShadow( pos+vec3(0,0.02,0), kSunDir, 0.02 );\n        \/\/sha1 *= smoothstep(-0.3,0.0,cloudsShadowFlat(epos, kSunDir));\n        sha1 *= smoothstep(-0.325,-0.075,cloudsShadowFlat(epos, kSunDir));\n        \n        #ifndef LOWQUALITY\n        float sha2  = treesShadow( pos+vec3(0,0.02,0), kSunDir );\n        #endif\n\n        vec3 tnor = terrainNormal( pos.xz );\n        vec3 nor;\n        \n        vec3 speC = vec3(1.0);\n        \/\/----------------------------------\n        \/\/ terrain\n        \/\/----------------------------------\n        if( obj==1 )\n        {\n            \/\/ bump map\n            nor = normalize( tnor + 0.8*(1.0-abs(tnor.y))*0.8*fbmd_7( (pos-vec3(0,600,0))*0.15*vec3(1.0,0.2,1.0) ).yzw );\n\n            col = vec3(0.18,0.12,0.10)*.85;\n\n            col = 1.0*mix( col, vec3(0.1,0.1,0.0)*0.2, smoothstep(0.7,0.9,nor.y) );      \n            float dif = clamp( dot( nor, kSunDir), 0.0, 1.0 ); \n            dif *= sha1;\n            #ifndef LOWQUALITY\n            dif *= sha2;\n            #endif\n\n            float bac = clamp( dot(normalize(vec3(-kSunDir.x,0.0,-kSunDir.z)),nor), 0.0, 1.0 );\n            float foc = clamp( (pos.y\/2.0-180.0)\/130.0, 0.0,1.0);\n            float dom = clamp( 0.5 + 0.5*nor.y, 0.0, 1.0 );\n            vec3  lin  = 1.0*0.2*mix(0.1*vec3(0.1,0.2,0.1),vec3(0.7,0.9,1.5)*3.0,dom)*foc;\n                  lin += 1.0*8.5*vec3(1.0,0.9,0.8)*dif;        \n                  lin += 1.0*0.27*vec3(1.1,1.0,0.9)*bac*foc;\n            speC = vec3(4.0)*dif*smoothstep(20.0,0.0,abs(pos.y\/2.0-310.0)-20.0);\n\n            col *= lin;\n        }\n        \/\/----------------------------------\n        \/\/ trees\n        \/\/----------------------------------\n        else \/\/if( obj==2 )\n        {\n            vec3 gnor = treesNormal( pos, resT );\n            \n            nor = normalize( gnor + 2.0*tnor );\n\n            \/\/ --- lighting ---\n            vec3  ref = reflect(rd,nor);\n            float occ = clamp(hei,0.0,1.0) * pow(1.0-2.0*displa,3.0);\n            float dif = clamp( 0.1 + 0.9*dot( nor, kSunDir), 0.0, 1.0 ); \n            dif *= sha1;\n            if( dif>0.0001 )\n            {\n                float a = clamp( 0.5+0.5*dot(tnor,kSunDir), 0.0, 1.0);\n                a = a*a;\n                a *= occ;\n                a *= 0.6;\n                a *= smoothstep(60.0,200.0,resT);\n                \/\/ tree shadows with fake transmission\n                #ifdef LOWQUALITY\n                float sha2  = treesShadow( pos+kSunDir*0.1, kSunDir );\n                #endif\n                dif *= a+(1.0-a)*sha2;\n            }\n            float dom = clamp( 0.5 + 0.5*nor.y, 0.0, 1.0 );\n            float bac = clamp( 0.5+0.5*dot(normalize(vec3(-kSunDir.x,0.0,-kSunDir.z)),nor), 0.0, 1.0 );                 \n            float fre = clamp(1.0+dot(nor,rd),0.0,1.0);\n            \/\/float spe = pow( clamp(dot(ref,kSunDir),0.0, 1.0), 9.0 )*dif*(0.2+0.8*pow(fre,5.0))*occ;\n\n            \/\/ --- lights ---\n            vec3 lin  = 12.0*vec3(1.2,1.0,0.7)*dif*occ*(2.5-1.5*smoothstep(0.0,120.0,resT));\n                 lin += 0.55*mix(0.1*vec3(0.1,0.2,0.0),vec3(0.6,1.0,1.0),dom*occ);\n                 lin += 0.07*vec3(1.0,1.0,0.9)*bac*occ;\n                 lin += 1.10*vec3(0.9,1.0,0.8)*pow(fre,5.0)*occ*(1.0-smoothstep(100.0,200.0,resT));\n            speC = dif*vec3(1.0,1.1,1.5)*1.2;\n\n            \/\/ --- material ---\n            float brownAreas = fbm_4( pos.zx*0.015 );\n            col = vec3(0.2,0.2,0.05);\n            col = mix( col, vec3(0.32,0.2,0.05), smoothstep(0.2,0.9,fract(2.0*mid)) );\n            col *= (mid<0.5)?0.65+0.35*smoothstep(300.0,600.0,resT)*smoothstep(700.0,500.0,pos.y):1.0;\n            col = mix( col, vec3(0.25,0.16,0.01)*0.825, 0.7*smoothstep(0.1,0.3,brownAreas)*smoothstep(0.5,0.8,tnor.y) );\n            col *= 1.0-0.5*smoothstep(400.0,700.0,pos.y);\n            col *= lin;\n        }\n\n        \/\/ spec\n        vec3  ref = reflect(rd,nor);            \n        float fre = clamp(1.0+dot(nor,rd),0.0,1.0);\n        float spe = 3.0*pow( clamp(dot(ref,kSunDir),0.0, 1.0), 9.0 )*(0.05+0.95*pow(fre,5.0));\n        col += spe*speC;\n\n        col = fog(col,resT);\n    }\n    }\n\n\n\n    float isCloud = 0.0;\n    \/\/----------------------------------\n    \/\/ clouds\n    \/\/----------------------------------\n    {\n        vec4 res = renderClouds( ro, rd, 0.0, resT, resT, fragCoord );\n        col = col*(1.0-res.w) + res.xyz;\n        isCloud = res.w;\n    }\n\n    \/\/----------------------------------\n    \/\/ final\n    \/\/----------------------------------\n    \n    \/\/ sun glare    \n    float sun = clamp( dot(kSunDir,rd), 0.0, 1.0 );\n    col += 0.25*vec3(0.8,0.4,0.2)*pow( sun, 4.0 );\n \n\n    \/\/ gamma\n    \/\/col = sqrt( clamp(col,0.0,1.0) );\n    col = pow( clamp(col*1.1-0.02,0.0,1.0), vec3(0.4545) );\n\n    \/\/ contrast\n    col = col*col*(3.0-2.0*col);            \n    \n    \/\/ color grade    \n    col = pow( col, vec3(1.0,0.92,1.0) );   \/\/ soft green\n    col *= vec3(1.02,0.99,0.9 );            \/\/ tint red\n    col.z = col.z+0.1;                      \/\/ bias blue\n    \n    \/\/------------------------------------------\n\t\/\/ reproject from previous frame and average\n    \/\/------------------------------------------\n\n    mat4 oldCam = mat4( textureLod(iChannel0,vec2(0.5,0.5)\/iResolution.xy, 0.0),\n                        textureLod(iChannel0,vec2(1.5,0.5)\/iResolution.xy, 0.0),\n                        textureLod(iChannel0,vec2(2.5,0.5)\/iResolution.xy, 0.0),\n                        0.0, 0.0, 0.0, 1.0 );\n    \n    \/\/ world space\n    vec4 wpos = vec4(ro + rd*resT,1.0);\n    \/\/ camera space\n    vec3 cpos = (wpos*oldCam).xyz; \/\/ note inverse multiply\n    \/\/ ndc space\n    vec2 npos = 1.5 * cpos.xy \/ cpos.z;\n    \/\/ screen space\n    vec2 spos = 0.5 + 0.5*npos*vec2(iResolution.y\/iResolution.x,1.0);\n    \/\/ undo dither\n    spos -= o\/iResolution.xy;\n\t\/\/ raster space\n    vec2 rpos = spos * iResolution.xy;\n    \n    if( rpos.y<1.0 && rpos.x<3.0 )\n    {\n    }\n\telse\n    {\n        vec3 ocol = textureLod( iChannel0, spos, 0.0 ).xyz;\n    \tif( iFrame==0 ) ocol = col;\n        col = mix( ocol, col, 0.1+0.8*isCloud );\n    }\n\n    \/\/----------------------------------\n                           \n\tif( fragCoord.y<1.0 && fragCoord.x<3.0 )\n    {\n        if( abs(fragCoord.x-2.5)<0.5 ) fragColor = vec4( ca[2], -dot(ca[2],ro) );\n        if( abs(fragCoord.x-1.5)<0.5 ) fragColor = vec4( ca[1], -dot(ca[1],ro) );\n        if( abs(fragCoord.x-0.5)<0.5 ) fragColor = vec4( ca[0], -dot(ca[0],ro) );\n    }\n    else\n    {\n        fragColor = vec4( col, 1.0 );\n    }\n}",
                "name": "Buffer A",
                "description": "",
                "type": "buffer"
            }
        ]
    },
    {
        "ver": "0.1",
        "info": {
            "id": "MdX3Rr",
            "date": "1360495251",
            "viewed": 193180,
            "name": "Elevated",
            "username": "iq",
            "description": "A raymarched version of the demo Elevated from 2009.",
            "likes": 856,
            "published": 3,
            "flags": 32,
            "usePreview": 0,
            "tags": []
        },
        "renderpass": [
            {
                "inputs": [
                    {
                        "id": "4dXGR8",
                        "filepath": "\/media\/previz\/buffer00.png",
                        "previewfilepath": "\/media\/previz\/buffer00.png",
                        "type": "buffer",
                        "channel": 0,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "4dfGRr",
                        "channel": 0
                    }
                ],
                "code": "\/\/ Copyright Inigo Quilez, 2013 - https:\/\/iquilezles.org\/\n\/\/ I am the sole copyright owner of this Work.\n\/\/ You cannot host, display, distribute or share this Work in any form,\n\/\/ including physical and digital. You cannot use this Work in any\n\/\/ commercial or non-commercial product, website or project. You cannot\n\/\/ sell this Work and you cannot mint an NFTs of it.\n\/\/ I share this Work for educational purposes, and you can link to it,\n\/\/ through an URL, proper attribution and unmodified screenshot, as part\n\/\/ of your educational material. If these conditions are too restrictive\n\/\/ please contact me and we'll definitely work it out.\n\n\n\/\/ on the derivatives based noise: https:\/\/iquilezles.org\/articles\/morenoise\n\/\/ on the soft shadow technique: https:\/\/iquilezles.org\/articles\/rmshadows\n\/\/ on the fog calculations: https:\/\/iquilezles.org\/articles\/fog\n\/\/ on the lighting: https:\/\/iquilezles.org\/articles\/outdoorslighting\n\/\/ on the raymarching: https:\/\/iquilezles.org\/articles\/terrainmarching\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord\/iResolution.xy;\n    vec4 data = texture( iChannel0, uv );\n\n    vec3 col = vec3(0.0);\n    if( data.w < 0.0 )\n    {\n        col = data.xyz;\n    }\n    else\n    {\n        \/\/ decompress velocity vector\n        float ss = mod(data.w,1024.0)\/1023.0;\n        float st = floor(data.w\/1024.0)\/1023.0;\n\n        \/\/ motion blur (linear blur across velocity vectors\n        vec2 dir = (-1.0 + 2.0*vec2( ss, st ))*0.25;\n        col = vec3(0.0);\n        for( int i=0; i<32; i++ )\n        {\n            float h = float(i)\/31.0;\n            vec2 pos = uv + dir*h;\n            col += texture( iChannel0, pos ).xyz;\n        }\n        col \/= 32.0;\n    }\n    \n    \/\/ vignetting\t\n\tcol *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 );\n\n    col = clamp(col,0.0,1.0);\n    col = col*0.6 + 0.4*col*col*(3.0-2.0*col) + vec3(0.0,0.0,0.04);\n    \n\n    \n    fragColor = vec4( col, 1.0 );\n}",
                "name": "Image",
                "description": "",
                "type": "image"
            },
            {
                "inputs": [
                    {
                        "id": "4dXGzn",
                        "filepath": "\/media\/a\/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png",
                        "previewfilepath": "\/media\/ap\/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png",
                        "type": "texture",
                        "channel": 0,
                        "sampler": {
                            "filter": "mipmap",
                            "wrap": "repeat",
                            "vflip": "false",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "4dXGR8",
                        "channel": 0
                    }
                ],
                "code": "\/\/ Copyright Inigo Quilez, 2016 - https:\/\/iquilezles.org\/\n\/\/ I am the sole copyright owner of this Work.\n\/\/ You cannot host, display, distribute or share this Work in any form,\n\/\/ including physical and digital. You cannot use this Work in any\n\/\/ commercial or non-commercial product, website or project. You cannot\n\/\/ sell this Work and you cannot mint an NFTs of it.\n\/\/ I share this Work for educational purposes, and you can link to it,\n\/\/ through an URL, proper attribution and unmodified screenshot, as part\n\/\/ of your educational material. If these conditions are too restrictive\n\/\/ please contact me and we'll definitely work it out.\n\n\/\/ on the derivatives based noise: https:\/\/iquilezles.org\/articles\/morenoise\n\/\/ on the soft shadow technique: https:\/\/iquilezles.org\/articles\/rmshadows\n\/\/ on the fog calculations: https:\/\/iquilezles.org\/articles\/fog\n\/\/ on the lighting: https:\/\/iquilezles.org\/articles\/outdoorslighting\n\/\/ on the raymarching: https:\/\/iquilezles.org\/articles\/terrainmarching\n\n\n#define AA 1   \/\/ make this 2 or even 3 if you have a really powerful GPU\n\n#define USE_SMOOTH_NOISE 0   \/\/ enable to prevent discontinuities\n\n#define SC (250.0)\n\n\/\/ value noise, and its analytical derivatives\nvec3 noised( in vec2 x )\n{\n    vec2 f = fract(x);\n    #if USE_SMOOTH_NOISE==0\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n    #else\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n    #endif\n\n#if 1\n    \/\/ texel fetch version\n    ivec2 p = ivec2(floor(x));\n    float a = texelFetch( iChannel0, (p+ivec2(0,0))&255, 0 ).x;\n\tfloat b = texelFetch( iChannel0, (p+ivec2(1,0))&255, 0 ).x;\n\tfloat c = texelFetch( iChannel0, (p+ivec2(0,1))&255, 0 ).x;\n\tfloat d = texelFetch( iChannel0, (p+ivec2(1,1))&255, 0 ).x;\n#else    \n    \/\/ texture version    \n    vec2 p = floor(x);\n\tfloat a = textureLod( iChannel0, (p+vec2(0.5,0.5))\/256.0, 0.0 ).x;\n\tfloat b = textureLod( iChannel0, (p+vec2(1.5,0.5))\/256.0, 0.0 ).x;\n\tfloat c = textureLod( iChannel0, (p+vec2(0.5,1.5))\/256.0, 0.0 ).x;\n\tfloat d = textureLod( iChannel0, (p+vec2(1.5,1.5))\/256.0, 0.0 ).x;\n#endif\n    \n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\tdu*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\nconst mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\n\n\nfloat terrainH( in vec2 x )\n{\n\tvec2  p = x*0.003\/SC;\n    float a = 0.0;\n    float b = 1.0;\n\tvec2  d = vec2(0.0);\n    for( int i=0; i<16; i++ )\n    {\n        vec3 n = noised(p);\n        d += n.yz;\n        a += b*n.x\/(1.0+dot(d,d));\n\t\tb *= 0.5;\n        p = m2*p*2.0;\n    }\n\n    #if USE_SMOOTH_NOISE==1\n    a *= 0.9;\n    #endif\n\treturn SC*120.0*a;\n}\n\nfloat terrainM( in vec2 x )\n{\n\tvec2  p = x*0.003\/SC;\n    float a = 0.0;\n    float b = 1.0;\n\tvec2  d = vec2(0.0);\n    for( int i=0; i<9; i++ )\n    {\n        vec3 n = noised(p);\n        d += n.yz;\n        a += b*n.x\/(1.0+dot(d,d));\n\t\tb *= 0.5;\n        p = m2*p*2.0;\n    }\n    #if USE_SMOOTH_NOISE==1\n    a *= 0.9;\n    #endif\n\treturn SC*120.0*a;\n}\n\nfloat terrainL( in vec2 x )\n{\n\tvec2  p = x*0.003\/SC;\n    float a = 0.0;\n    float b = 1.0;\n\tvec2  d = vec2(0.0);\n    for( int i=0; i<3; i++ )\n    {\n        vec3 n = noised(p);\n        d += n.yz;\n        a += b*n.x\/(1.0+dot(d,d));\n\t\tb *= 0.5;\n        p = m2*p*2.0;\n    }\n    #if USE_SMOOTH_NOISE==1\n    a *= 0.9;\n    #endif\n\treturn SC*120.0*a;\n}\n\nfloat raycast( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\n{\n    float t = tmin;\n\tfor( int i=0; i<300; i++ )\n\t{\n        vec3 pos = ro + t*rd;\n\t\tfloat h = pos.y - terrainM( pos.xz );\n\t\tif( abs(h)<(0.0015*t) || t>tmax ) break;\n\t\tt += 0.4*h;\n\t}\n\n\treturn t;\n}\n\nfloat softShadow(in vec3 ro, in vec3 rd, float dis )\n{\n    float minStep = clamp(dis*0.01,SC*0.5,SC*50.0);\n\n    float res = 1.0;\n    float t = 0.001;\n\tfor( int i=0; i<80; i++ )\n\t{\n\t    vec3  p = ro + t*rd;\n        float h = p.y - terrainM( p.xz );\n\t\tres = min( res, 16.0*h\/t );\n\t\tt += max(minStep,h);\n\t\tif( res<0.001 ||p.y>(SC*200.0) ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos, float t )\n{\n    vec2  eps = vec2( 0.001*t, 0.0 );\n    return normalize( vec3( terrainH(pos.xz-eps.xy) - terrainH(pos.xz+eps.xy),\n                            2.0*eps.x,\n                            terrainH(pos.xz-eps.yx) - terrainH(pos.xz+eps.yx) ) );\n}\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*texture( iChannel0, p\/256.0 ).x; p = m2*p*2.02;\n    f += 0.2500*texture( iChannel0, p\/256.0 ).x; p = m2*p*2.03;\n    f += 0.1250*texture( iChannel0, p\/256.0 ).x; p = m2*p*2.01;\n    f += 0.0625*texture( iChannel0, p\/256.0 ).x;\n    return f\/0.9375;\n}\n\nconst float kMaxT = 5000.0*SC;\n\nvec4 render( in vec3 ro, in vec3 rd )\n{\n    vec3 light1 = normalize( vec3(-0.8,0.4,-0.3) );\n    \/\/ bounding plane\n    float tmin = 1.0;\n    float tmax = kMaxT;\n#if 1\n    float maxh = 250.0*SC;\n    float tp = (maxh-ro.y)\/rd.y;\n    if( tp>0.0 )\n    {\n        if( ro.y>maxh ) tmin = max( tmin, tp );\n        else            tmax = min( tmax, tp );\n    }\n#endif\n\tfloat sundot = clamp(dot(rd,light1),0.0,1.0);\n\tvec3 col;\n    float t = raycast( ro, rd, tmin, tmax );\n    if( t>tmax)\n    {\n        \/\/ sky\t\t\n        col = vec3(0.3,0.5,0.85) - rd.y*rd.y*0.5;\n        col = mix( col, 0.85*vec3(0.7,0.75,0.85), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n        \/\/ sun\n\t\tcol += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n\t\tcol += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n\t\tcol += 0.2*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );\n        \/\/ clouds\n\t\tvec2 sc = ro.xz + rd.xz*(SC*1000.0-ro.y)\/rd.y;\n\t\tcol = mix( col, vec3(1.0,0.95,1.0), 0.5*smoothstep(0.5,0.8,fbm(0.0005*sc\/SC)) );\n        \/\/ horizon\n        col = mix( col, 0.68*vec3(0.4,0.65,1.0), pow( 1.0-max(rd.y,0.0), 16.0 ) );\n        t = -1.0;\n\t}\n\telse\n\t{\n        \/\/ mountains\t\t\n\t\tvec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, t );\n        \/\/nor = normalize( nor + 0.5*( vec3(-1.0,0.0,-1.0) + vec3(2.0,1.0,2.0)*texture(iChannel1,0.01*pos.xz).xyz) );\n        vec3 ref = reflect( rd, nor );\n        float fre = clamp( 1.0+dot(rd,nor), 0.0, 1.0 );\n        vec3 hal = normalize(light1-rd);\n        \n        \/\/ rock\n\t\tfloat r = texture( iChannel0, (7.0\/SC)*pos.xz\/256.0 ).x;\n        col = (r*0.25+0.75)*0.9*mix( vec3(0.08,0.05,0.03), vec3(0.10,0.09,0.08), \n                                     texture(iChannel0,0.00007*vec2(pos.x,pos.y*48.0)\/SC).x );\n\t\tcol = mix( col, 0.20*vec3(0.45,.30,0.15)*(0.50+0.50*r),smoothstep(0.70,0.9,nor.y) );\n        \n        \n        col = mix( col, 0.15*vec3(0.30,.30,0.10)*(0.25+0.75*r),smoothstep(0.95,1.0,nor.y) );\n\t\tcol *= 0.1+1.8*sqrt(fbm(pos.xz*0.04)*fbm(pos.xz*0.005));\n\n\t\t\/\/ snow\n\t\tfloat h = smoothstep(55.0,80.0,pos.y\/SC + 25.0*fbm(0.01*pos.xz\/SC) );\n        float e = smoothstep(1.0-0.5*h,1.0-0.1*h,nor.y);\n        float o = 0.3 + 0.7*smoothstep(0.0,0.1,nor.x+h*h);\n        float s = h*e*o;\n        col = mix( col, 0.29*vec3(0.62,0.65,0.7), smoothstep( 0.1, 0.9, s ) );\n\t\t\n         \/\/ lighting\t\t\n        float amb = clamp(0.5+0.5*nor.y,0.0,1.0);\n\t\tfloat dif = clamp( dot( light1, nor ), 0.0, 1.0 );\n\t\tfloat bac = clamp( 0.2 + 0.8*dot( normalize( vec3(-light1.x, 0.0, light1.z ) ), nor ), 0.0, 1.0 );\n\t\tfloat sh = 1.0; if( dif>=0.0001 ) sh = softShadow(pos+light1*SC*0.05,light1,t);\n\t\t\n\t\tvec3 lin  = vec3(0.0);\n\t\tlin += dif*vec3(8.00,5.00,3.00)*1.3*vec3( sh, sh*sh*0.5+0.5*sh, sh*sh*0.8+0.2*sh );\n\t\tlin += amb*vec3(0.40,0.60,1.00)*1.2;\n        lin += bac*vec3(0.40,0.50,0.60);\n\t\tcol *= lin;\n        \n        col += (0.7+0.3*s)*(0.04+0.96*pow(clamp(1.0+dot(hal,rd),0.0,1.0),5.0))*\n               vec3(7.0,5.0,3.0)*dif*sh*\n               pow( clamp(dot(nor,hal), 0.0, 1.0),16.0);\n        \n        col += s*0.65*pow(fre,4.0)*vec3(0.3,0.5,0.6)*smoothstep(0.0,0.6,ref.y);\n\n        \/\/col = col*3.0\/(1.5+col);\n        \n\t\t\/\/ fog\n        float fo = 1.0-exp(-pow(0.001*t\/SC,1.5) );\n        vec3 fco = 0.65*vec3(0.4,0.65,1.0);\/\/ + 0.1*vec3(1.0,0.8,0.5)*pow( sundot, 4.0 );\n        col = mix( col, fco, fo );\n\n\t}\n    \/\/ sun scatter\n    col += 0.3*vec3(1.0,0.7,0.3)*pow( sundot, 8.0 );\n\n    \/\/ gamma\n\tcol = sqrt(col);\n    \n\treturn vec4( col, t );\n}\n\nvec3 camPath( float time )\n{\n\treturn SC*1100.0*vec3( cos(0.0+0.23*time), 0.0, cos(1.5+0.21*time) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, in float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid moveCamera( float time, out vec3 oRo, out vec3 oTa, out float oCr, out float oFl )\n{\n\tvec3 ro = camPath( time );\n\tvec3 ta = camPath( time + 3.0 );\n\tro.y = terrainL( ro.xz ) + 22.0*SC;\n\tta.y = ro.y - 20.0*SC;\n\tfloat cr = 0.2*cos(0.1*time);\n    oRo = ro;\n    oTa = ta;\n    oCr = cr;\n    oFl = 3.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*0.1 - 0.1 + 0.3 + 4.0*iMouse.x\/iResolution.x;\n\n    \/\/ camera position\n    vec3 ro, ta; float cr, fl;\n    moveCamera( time, ro, ta, cr, fl );\n\n    \/\/ camera2world transform    \n    mat3 cam = setCamera( ro, ta, cr );\n\n    \/\/ pixel\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)\/iResolution.y;\n\n    float t = kMaxT;\n    vec3 tot = vec3(0.0);\n\t#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        \/\/ pixel coordinates\n        vec2 o = vec2(float(m),float(n)) \/ float(AA) - 0.5;\n        vec2 s = (-iResolution.xy + 2.0*(fragCoord+o))\/iResolution.y;\n\t#else    \n        vec2 s = p;\n\t#endif\n\n        \/\/ camera ray    \n        vec3 rd = cam * normalize(vec3(s,fl));\n\n        vec4 res = render( ro, rd );\n        t = min( t, res.w );\n \n        tot += res.xyz;\n\t#if AA>1\n    }\n    tot \/= float(AA*AA);\n\t#endif\n\n\n    \/\/-------------------------------------\n\t\/\/ velocity vectors (through depth reprojection)\n    \/\/-------------------------------------\n    float vel = 0.0;\n    if( t<0.0 )\n    {\n        vel = -1.0;\n    }\n    else\n    {\n\n        \/\/ old camera position\n        float oldTime = time - 0.1 * 1.0\/24.0; \/\/ 1\/24 of a second blur\n        vec3 oldRo, oldTa; float oldCr, oldFl;\n        moveCamera( oldTime, oldRo, oldTa, oldCr, oldFl );\n        mat3 oldCam = setCamera( oldRo, oldTa, oldCr );\n\n        \/\/ world space\n        #if AA>1\n        vec3 rd = cam * normalize(vec3(p,fl));\n        #endif\n        vec3 wpos = ro + rd*t;\n        \/\/ camera space\n        vec3 cpos = vec3( dot( wpos - oldRo, oldCam[0] ),\n                          dot( wpos - oldRo, oldCam[1] ),\n                          dot( wpos - oldRo, oldCam[2] ) );\n        \/\/ ndc space\n        vec2 npos = oldFl * cpos.xy \/ cpos.z;\n        \/\/ screen space\n        vec2 spos = 0.5 + 0.5*npos*vec2(iResolution.y\/iResolution.x,1.0);\n\n\n        \/\/ compress velocity vector in a single float\n        vec2 uv = fragCoord\/iResolution.xy;\n        spos = clamp( 0.5 + 0.5*(spos - uv)\/0.25, 0.0, 1.0 );\n        vel = floor(spos.x*1023.0) + floor(spos.y*1023.0)*1024.0;\n    }\n    \n    fragColor = vec4( tot, vel );\n}",
                "name": "Buffer A",
                "description": "",
                "type": "buffer"
            }
        ]
    },
    {
        "ver": "0.1",
        "info": {
            "id": "ld3Gz2",
            "date": "1450918438",
            "viewed": 173005,
            "name": "Snail",
            "username": "iq",
            "description": "Procedural modeling and procedural lighting. Shading is a mix of procedural and textures. SDF rendered through raymarching.",
            "likes": 727,
            "published": 3,
            "flags": 0,
            "usePreview": 1,
            "tags": []
        },
        "renderpass": [
            {
                "inputs": [
                    {
                        "id": "XsX3Rn",
                        "filepath": "\/media\/a\/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg",
                        "previewfilepath": "\/media\/ap\/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg",
                        "type": "texture",
                        "channel": 2,
                        "sampler": {
                            "filter": "mipmap",
                            "wrap": "repeat",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    },
                    {
                        "id": "Xsf3zn",
                        "filepath": "\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
                        "previewfilepath": "\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
                        "type": "texture",
                        "channel": 3,
                        "sampler": {
                            "filter": "mipmap",
                            "wrap": "repeat",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    },
                    {
                        "id": "4sf3Rr",
                        "filepath": "\/media\/a\/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png",
                        "previewfilepath": "\/media\/ap\/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png",
                        "type": "texture",
                        "channel": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "wrap": "repeat",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "4dfGRr",
                        "channel": 0
                    }
                ],
                "code": "\/\/ Copyright Inigo Quilez, 2015 - https:\/\/iquilezles.org\/\n\/\/ I am the sole copyright owner of this Work.\n\/\/ You cannot host, display, distribute or share this Work in any form,\n\/\/ including physical and digital. You cannot use this Work in any\n\/\/ commercial or non-commercial product, website or project. You cannot\n\/\/ sell this Work and you cannot mint an NFTs of it.\n\/\/ I share this Work for educational purposes, and you can link to it,\n\/\/ through an URL, proper attribution and unmodified screenshot, as part\n\/\/ of your educational material. If these conditions are too restrictive\n\/\/ please contact me and we'll definitely work it out.\n\n\n\/\/ You can buy a metal print of this shader here:\n\/\/ https:\/\/www.redbubble.com\/i\/metal-print\/Snail-by-InigoQuilez\/39845499.0JXQP\n\n\n\/\/ antialiasing - make AA 2, meaning 4x AA, if you have a fast machine\n#define AA 1\n\n#define USE_TEXTURES 1\n\n#define ZERO (min(iFrame,0))\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nfloat sdSphere( in vec3 p, in vec4 s )\n{\n    return length(p-s.xyz) - s.w;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nfloat sdEllipsoid( in vec3 p, in vec3 c, in vec3 r )\n{\n#if 1\n    return (length( (p-c)\/r ) - 1.0) * min(min(r.x,r.y),r.z);\n#else\n    float k0 = length((p-c)\/r);\n    float k1 = length((p-c)\/(r*r));\n    return k0*(k0-1.0)\/k1;\n#endif    \n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n    return length(p-c) - r;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nvec2 udSegment( vec3 p, vec3 a, vec3 b )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ), h );\n}\n\n\/\/ http:\/\/research.microsoft.com\/en-us\/um\/people\/hoppe\/ravg.pdf\nfloat det( vec2 a, vec2 b ) { return a.x*b.y-b.x*a.y; }\nvec3 getClosest( vec2 b0, vec2 b1, vec2 b2 ) \n{\n    float a =     det(b0,b2);\n    float b = 2.0*det(b1,b0);\n    float d = 2.0*det(b2,b1);\n    float f = b*d - a*a;\n    vec2  d21 = b2-b1;\n    vec2  d10 = b1-b0;\n    vec2  d20 = b2-b0;\n    vec2  gf = 2.0*(b*d21+d*d10+a*d20); gf = vec2(gf.y,-gf.x);\n    vec2  pp = -f*gf\/dot(gf,gf);\n    vec2  d0p = b0-pp;\n    float ap = det(d0p,d20);\n    float bp = 2.0*det(d10,d0p);\n    float t = clamp( (ap+bp)\/(2.0*a+b+d), 0.0 ,1.0 );\n    return vec3( mix(mix(b0,b1,t), mix(b1,b2,t),t), t );\n}\n\nvec4 sdBezier( vec3 a, vec3 b, vec3 c, vec3 p )\n{\n\tvec3 w = normalize( cross( c-b, a-b ) );\n\tvec3 u = normalize( c-b );\n\tvec3 v =          ( cross( w, u ) );\n\n\tvec2 a2 = vec2( dot(a-b,u), dot(a-b,v) );\n\tvec2 b2 = vec2( 0.0 );\n\tvec2 c2 = vec2( dot(c-b,u), dot(c-b,v) );\n\tvec3 p3 = vec3( dot(p-b,u), dot(p-b,v), dot(p-b,w) );\n\n\tvec3 cp = getClosest( a2-p3.xy, b2-p3.xy, c2-p3.xy );\n\n\treturn vec4( sqrt(dot(cp.xy,cp.xy)+p3.z*p3.z), cp.z, length(cp.xy), p3.z );\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/smin\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25\/k;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/smin\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25\/k;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/smin\nvec3 smax( vec3 a, vec3 b, float k )\n{\n    vec3 h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25\/k;\n}\n\n\/\/---------------------------------------------------------------------------\n\nfloat hash1( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nvec3 forwardSF( float i, float n ) \n{\n    const float PI  = 3.141592653589793238;\n    const float PHI = 1.618033988749894848;\n    float phi = 2.0*PI*fract(i\/PHI);\n    float zi = 1.0 - (2.0*i+1.0)\/n;\n    float sinTheta = sqrt( 1.0 - zi*zi);\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\n}\n\n\/\/---------------------------------------------------------------------------\n\nconst float pi = 3.1415927;\n\n\/\/---------------------------------------------------------------------------\n\nfloat mapShell( in vec3 p, out vec4 matInfo ) \n{\n    p -= vec3(0.05,0.12,-0.09);    \n\n    vec3 q = mat3(-0.6333234236, -0.7332753384, 0.2474039592,\n                   0.7738444477, -0.6034162289, 0.1924931824,\n                   0.0081370606,  0.3133626215, 0.9495986813) * p;\n\n    const float b = 0.1759;\n    \n    float r = length( q.xy );\n    float t = atan( q.y, q.x );\n \n    \/\/ https:\/\/swiftcoder.wordpress.com\/2010\/06\/21\/logarithmic-spiral-distance-field\/\n    float np = (log(   r)\/b-t)\/(2.0*pi);\n    float nm = (log(0.11)\/b-t)\/(2.0*pi);\n    float n = min(np,nm);\n    \n    float ni = floor( n );\n    \n    float r1 = exp( b * (t + 2.0*pi*ni));\n    float r2 = r1 * 3.019863;\n    \n    \/\/-------\n\n    float h1 = q.z + 1.5*r1 - 0.5; float d1 = sqrt((r1-r)*(r1-r)+h1*h1) - r1;\n    float h2 = q.z + 1.5*r2 - 0.5; float d2 = sqrt((r2-r)*(r2-r)+h2*h2) - r2;\n    \n    float d, dx, dy;\n    if( d1<d2 ) { d = d1; dx=r1-r; dy=h1; }\n    else        { d = d2; dx=r2-r; dy=h2; }\n\n    float di = textureLod( iChannel2, vec2(t+r,0.5), 0. ).x;\n    d += 0.002*di;\n    \n    matInfo = vec4(dx,dy,r\/0.4,t\/pi);\n\n    vec3 s = q;\n    q = q - vec3(0.34,-0.1,0.03);\n    q.xy = mat2(0.8,0.6,-0.6,0.8)*q.xy;\n    d = smin( d, sdTorus( q, vec2(0.28,0.05) ), 0.06);\n    d = smax( d, -sdEllipsoid(q,vec3(0.0,0.0,0.0),vec3(0.24,0.36,0.24) ), 0.03 );\n    d = smax( d, -sdEllipsoid(s,vec3(0.52,-0.0,0.0),vec3(0.42,0.23,0.5) ), 0.05 );\n    \n    return d;\n}\n\n#if USE_TEXTURES==0\nfloat voronoi( in vec2 x, float w, float s )\n{\n    vec2 n = floor( x );\n    vec2 f = fract( x );\n\n\tvec2 m = vec2( 8.0, 0.0 );\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2  g = vec2( float(i),float(j) );\n        vec3  r = hash3( n + g );\n\t\tfloat d = length(g - f + r.xy);\n        float c = s*(0.1+0.9*r.z);\n        d = min(d*1.25,1.0);\n        \/\/ do the smooth min for distances and color\n\t\tfloat h = smoothstep( -1.0, 1.0, (m.x-d)\/w );\n\t    m = mix( m, vec2(d,c), h ) - h*(1.0-h)*w\/(1.0+3.0*w);\n    }\n    \n\treturn m.y*(1.0-m.x);\n}\n#endif\n\nfloat text1( in vec2 p )\n{\n    #if USE_TEXTURES==1\n        return textureLod( iChannel1, p, 0.0 ).x;\n    #else\n        float f = max( voronoi(  7.5*p, 0.3, 1.00 ),\n                       voronoi( 13.0*p, 0.3, 0.75 ) );\n        return 0.5*smoothstep(0.0,1.0,f);\n    #endif\n}\n\nvec2 mapSnail( vec3 p, out vec4 matInfo )\n{\n    const vec3 head = vec3(-0.76,0.6,-0.3);\n    \n    vec3 q = p - head;\n\n    \/\/ body\n    vec4 b1 = sdBezier( vec3(-0.13,-0.65,0.0), vec3(0.24,0.9+0.1,0.0), head+vec3(0.04,0.01,0.0), p );\n    float d1 = b1.x;\n    d1 -= smoothstep(0.0,0.2,b1.y)*(0.16 - 0.07*smoothstep(0.5,1.0,b1.y));\n    b1 = sdBezier( vec3(-0.085,0.0,0.0), vec3(-0.1,0.9-0.05,0.0), head+vec3(0.06,-0.08,0.0), p );\n    float d2 = b1.x;\n    d2 -= 0.1 - 0.06*b1.y;\n    d1 = smin( d1, d2, 0.03 );\n    matInfo.xyz = b1.yzw;\n\n    d2 = sdSphere( q, vec4(0.0,-0.06,0.0,0.085) );\n    d1 = smin( d1, d2, 0.03 );\n    d1 = smin( d1, sdSphere(p,vec4(0.05,0.52,0.0,0.13)), 0.07 );\n    \n    q.xz = mat2(0.8,0.6,-0.6,0.8)*q.xz;\n\n    vec3 sq = vec3( q.xy, abs(q.z) );\n    \n    \/\/ top antenas\n    vec3 af = 0.05*sin(0.5*iTime+vec3(0.0,1.0,3.0) + vec3(2.0,1.0,0.0)*sign(q.z) );\n    vec4 b2 = sdBezier( vec3(0.0), vec3(-0.1,0.2,0.2), vec3(-0.3,0.2,0.3)+af, sq );\n    float d3 = b2.x;\n    d3 -= 0.03 - 0.025*b2.y;\n    d1 = smin( d1, d3, 0.04 );\n    d3 = sdSphere( sq, vec4(-0.3,0.2,0.3,0.016) + vec4(af,0.0) );\n    d1 = smin( d1, d3, 0.01 );    \n    \n    \/\/ bottom antenas\n    vec3 bf = 0.02*sin(0.3*iTime+vec3(4.0,1.0,2.0) + vec3(3.0,0.0,1.0)*sign(q.z) );\n    vec2 b3 = udSegment( sq, vec3(0.06,-0.05,0.0), vec3(-0.04,-0.2,0.18)+bf );\n    d3 = b3.x;\n    d3 -= 0.025 - 0.02*b3.y;\n    d1 = smin( d1, d3, 0.06 );\n    d3 = sdSphere( sq, vec4(-0.04,-0.2,0.18,0.008)+vec4(bf,0.0) );\n    d1 = smin( d1, d3, 0.02 );\n    \n    \/\/ bottom\n    vec3 pp = p-vec3(-0.17,0.15,0.0);\n    float co = 0.988771078;\n    float si = 0.149438132;\n    pp.xy = mat2(co,-si,si,co)*pp.xy;\n    d1 = smin( d1, sdEllipsoid( pp, vec3(0.0,0.0,0.0), vec3(0.084,0.3,0.15) ), 0.05 );\n    d1 = smax( d1, -sdEllipsoid( pp, vec3(-0.08,-0.0,0.0), vec3(0.06,0.55,0.1) ), 0.02 );\n    \n    \/\/ disp\n    float dis = text1(5.0*p.xy);\n    float dx = 0.5 + 0.5*(1.0-smoothstep(0.5,1.0,b1.y));\n    d1 -= 0.005*dis*dx*0.5;\n        \n    return vec2(d1,1.0);\n}\n    \nfloat mapDrop( in vec3 p )\n{\n    p -= vec3(-0.26,0.25,-0.02);\n    p.x -= 2.5*p.y*p.y;\n    return sdCapsule( p, vec3(0.0,-0.06,0.0), vec3(0.014,0.06,0.0), 0.037 );\n}\n\nfloat mapLeaf( in vec3 p )\n{\n    p -= vec3(-1.8,0.6,-0.75);\n    \n    p = mat3(0.671212, 0.366685, -0.644218,\n            -0.479426, 0.877583,  0.000000,\n             0.565354, 0.308854,  0.764842)*p;\n \n    p.y += 0.2*exp2(-abs(2.9*p.z) );\n    \n    float ph = 0.25*50.0*p.x - 0.25*75.0*abs(p.z);\n    float rr = sin( ph );\n    rr = rr*rr;    \n    rr = rr*rr;    \n    p.y += 0.005*rr;\n    \n    float r = clamp((p.x+2.0)\/4.0,0.0,1.0);\n    r = 0.0001 + r*(1.0-r)*(1.0-r)*6.0;\n    \n    rr = sin( ph*2.0 );\n    rr = rr*rr;    \n    rr *= 0.5+0.5*sin( p.x*12.0 );\n\n    float ri = 0.035*rr;\n    \n    float d = sdEllipsoid( p, vec3(0.0), vec3(2.0,0.25*r,r+ri) );\n\n    float d2 = p.y-0.02;\n    \n    return smax( d, -d2, 0.02 );\n}\n\nvec2 mapOpaque( vec3 p, out vec4 matInfo )\n{\n    matInfo = vec4(0.0);\n    \n    \/\/ leaf    \n    vec2 res = vec2( mapLeaf( p ), 4.0);\n    \n    \/\/ stem\n    vec4 b3 = sdBezier( vec3(-0.15,-1.5,0.0), vec3(-0.1,0.5,0.0), vec3(-0.6,1.5,0.0), p );\n    float d3 = b3.x - 0.04 + 0.02*b3.y;\n    if( d3<res.x ) res = vec2(d3,3.0);\n    \n   \t\/\/ snail \n    float boundingVolume = sdCapsule(p, vec3(0.0), vec3(-0.6,0.7,0.0), 0.55);\n    if( boundingVolume<res.x )\n    {\n    vec2 tmp = mapSnail( p, matInfo );\n    if( tmp.x<res.x  ) { res = tmp; }\n    \n    \/\/ shell\n    float bb = length( p-vec3(0.25,0.3,-0.1) )-0.6;\n    if( bb<res.x )\n    {\n    vec4 tmpMatInfo;\n    float d4 = mapShell( p, tmpMatInfo );    \n    if( d4<res.x  ) { res = vec2(d4,2.0); matInfo = tmpMatInfo; }\n    }\n    }\n    \n    return res;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/normalsSDF\nvec3 calcNormalOpaque( in vec3 pos, in float eps )\n{\n    vec4 kk;\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*mapOpaque( pos + e.xyy, kk ).x + \n\t\t\t\t\t  e.yyx*mapOpaque( pos + e.yyx, kk ).x + \n\t\t\t\t\t  e.yxy*mapOpaque( pos + e.yxy, kk ).x + \n\t\t\t\t\t  e.xxx*mapOpaque( pos + e.xxx, kk ).x );\n#else\n    \/\/ inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*mapOpaque(pos+eps*e,kk).x;\n    }\n    return normalize(n);\n#endif    \n}\n\n\/\/=========================================================================\n\nfloat mapLeafWaterDrops( in vec3 p )\n{\n    p -= vec3(-1.8,0.6,-0.75);\n    vec3 s = p;\n    p = mat3(0.671212, 0.366685, -0.644218,\n            -0.479426, 0.877583,  0.000000,\n             0.565354, 0.308854,  0.764842)*p;\n  \n    vec3 q = p;\n    p.y += 0.2*exp(-abs(2.0*p.z) );\n    \n    float r = clamp((p.x+2.0)\/4.0,0.0,1.0);\n    r = r*(1.0-r)*(1.0-r)*6.0;\n    float d1 = sdEllipsoid( q, vec3(0.5,0.0,0.2), 1.0*vec3(0.15,0.13,0.15) );\n    float d2 = sdEllipsoid( q, vec3(0.8,-0.07,-0.15), 0.5*vec3(0.15,0.13,0.15) );\n    float d3 = sdEllipsoid( s, vec3(0.76,-0.8,0.6), 0.5*vec3(0.15,0.2,0.15) );\n    float d4 = sdEllipsoid( q, vec3(-0.5,0.09,-0.2), vec3(0.04,0.03,0.04) );\n\n    d3 = max( d3, p.y-0.01);\n    \n    return min( min(d1,d4), min(d2,d3) );\n}\n\nvec2 mapTransparent( vec3 p, out vec4 matInfo )\n{\n    matInfo = vec4(0.0);\n    \n    float d5 = mapDrop( p );\n    vec2  res = vec2(d5,4.0);\n\n    float d6 = mapLeafWaterDrops( p );\n    res.x = min( res.x, d6 );\n\n    return res;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/normalsSDF\nvec3 calcNormalTransparent( in vec3 pos, in float eps )\n{\n    vec4 kk;\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*mapTransparent( pos + e.xyy, kk ).x + \n\t\t\t\t\t  e.yyx*mapTransparent( pos + e.yyx, kk ).x + \n\t\t\t\t\t  e.yxy*mapTransparent( pos + e.yxy, kk ).x + \n\t\t\t\t\t  e.xxx*mapTransparent( pos + e.xxx, kk ).x );\n}\n\n\/\/=========================================================================\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    vec4 kk;\n\tfloat ao = 0.0;\n    for( int i=ZERO; i<32; i++ )\n    {\n        vec3 ap = forwardSF( float(i), 32.0 );\n        float h = hash1(float(i));\n\t\tap *= sign( dot(ap,nor) ) * h*0.1;\n        ao += clamp( mapOpaque( pos + nor*0.01 + ap, kk ).x*3.0, 0.0, 1.0 );\n    }\n\tao \/= 32.0;\n\t\n    return clamp( ao*6.0, 0.0, 1.0 );\n}\n\nfloat calcSSS( in vec3 pos, in vec3 nor )\n{\n    vec4 kk;\n\tfloat occ = 0.0;\n    for( int i=ZERO; i<8; i++ )\n    {\n        float h = 0.002 + 0.11*float(i)\/7.0;\n        vec3 dir = normalize( sin( float(i)*13.0 + vec3(0.0,2.1,4.2) ) );\n        dir *= sign(dot(dir,nor));\n        occ += (h-mapOpaque(pos-h*dir, kk).x);\n    }\n    occ = clamp( 1.0 - 11.0*occ\/8.0, 0.0, 1.0 );    \n    return occ*occ;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/rmshadows\nfloat calcSoftShadow( in vec3 ro, in vec3 rd, float k )\n{\n    vec4 kk;    \n    float res = 1.0;\n    float t = 0.01;\n    for( int i=ZERO; i<32; i++ )\n    {\n        float h = mapOpaque(ro + rd*t, kk ).x;\n        res = min( res, smoothstep(0.0,1.0,k*h\/t) );\n        t += clamp( h, 0.04, 0.1 );\n\t\tif( res<0.01 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nconst vec3 sunDir = normalize( vec3(0.2,0.1,0.02) );\n\nvec3 shadeOpaque( in vec3 ro, in vec3 rd, in float t, in float m, in vec4 matInfo )\n{\n    float eps = 0.002;\n    \n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormalOpaque( pos, eps );\n\n    vec3 mateD = vec3(0.0);\n    vec3 mateS = vec3(0.0);\n    vec2 mateK = vec2(0.0);\n    vec3 mateE = vec3(0.0);\n\n    float focc = 1.0;\n    float fsha = 1.0;\n\n    if( m<1.5 ) \/\/ snail body\n    {\n        float dis = text1( 5.0*pos.xy );\n\n        float be = sdEllipsoid( pos, vec3(-0.3,-0.5,-0.1), vec3(0.2,1.0,0.5) );\n        be = 1.0-smoothstep( -0.01, 0.01, be );        \n        \n        float ff = abs(matInfo.x-0.20);\n        \n        mateS = 6.0*mix( 0.7*vec3(2.0,1.2,0.2), vec3(2.5,1.8,0.9), ff );\n        mateS += 2.0*dis;\n        mateS *= 1.5;\n        mateS *= 1.0 + 0.5*ff*ff;\n        mateS *= 1.0-0.5*be;\n        \n        mateD = vec3(1.0,0.8,0.4);\n        mateD *= dis;\n        mateD *= 0.015;\n        mateD += vec3(0.8,0.4,0.3)*0.15*be;\n        \n        mateK = vec2( 60.0, 0.7 + 2.0*dis );\n        \n        float f = clamp( dot( -rd, nor ), 0.0, 1.0 );\n        f = 1.0-pow( f, 8.0 );\n        f = 1.0 - (1.0-f)*(1.0-texture( iChannel2, 0.3*pos.xy ).x);\n        mateS *= vec3(0.5,0.1,0.0) + f*vec3(0.5,0.9,1.0);\n        \n        float b = 1.0-smoothstep( 0.25,0.55,abs(pos.y));\n        focc = 0.2 + 0.8*smoothstep( 0.0, 0.15, sdSphere(pos,vec4(0.05,0.52,0.0,0.13)) );\n    }\n\telse if( m<2.5 ) \/\/ shell\n    {\n        mateK = vec2(0.0);\n        \n        float tip = 1.0-smoothstep(0.05,0.4, length(pos-vec3(0.17,0.2,0.35)) );\n        mateD = mix( 0.7*vec3(0.2,0.21,0.22), 0.2*vec3(0.15,0.1,0.0), tip );\n        \n        vec2 uv = vec2( .5*atan(matInfo.x,matInfo.y)\/3.1416, 1.5*matInfo.w );\n        \n        float ff = 2.0*matInfo.w+matInfo.z;        \n        float ral = 0.4 + 0.4*(0.26*sin(ff*6.283185* 1.0+0.0)+\n                               0.23*sin(ff*6.283185* 3.0+2.0)+\n                               0.20*sin(ff*6.283185* 8.0+1.0)+\n                               0.17*sin(ff*6.283185*17.0+3.0)+\n                               0.14*sin(ff*6.283185*25.0+2.0));\n        mateD *= 0.25 + 0.75*ral;\n        \n        float pa = smoothstep(-0.2,0.2, 0.3+sin(2.0+40.0*uv.x + 3.0*sin(11.0*uv.x)) );\n        float bar = mix(pa,1.0,smoothstep(0.7,1.0,tip));\n        bar *= (matInfo.z<0.6) ? 1.0 : smoothstep( 0.17, 0.21, abs(matInfo.w)  );\n        mateD *= vec3(0.06,0.03,0.0)+vec3(0.94,0.97,1.0)*bar;\n\n        mateK = vec2( 64.0, 0.2 );\n        mateS = 1.5*vec3(1.0,0.65,0.6) * (1.0-tip);\/\/*0.5;\n    }\n    else if( m<3.5 ) \/\/ plant\n    {\n        mateD = vec3(0.05,0.1,0.0)*0.2;\n        mateS = vec3(0.1,0.2,0.02)*25.0;\n        mateK = vec2(5.0,1.0);\n        \n        float fre = clamp(1.0+dot(nor,rd), 0.0, 1.0 );\n        mateD += 0.2*fre*vec3(1.0,0.5,0.1);\n        \n        vec3 te = texture( iChannel2, pos.xy*0.2 ).xyz;\n        mateS *= 0.5 + 1.5*te;\n        mateE = 0.5*vec3(0.1,0.1,0.03)*(0.2+0.8*te.x);\n    }\n    else \/\/if( m<4.5 ) \/\/ leaf\n    {\n        vec3 p = pos - vec3(-1.8,0.6,-0.75);\n        vec3 s = p;\n        p = mat3(0.671212, 0.366685, -0.644218,\n                -0.479426, 0.877583,  0.000000,\n                 0.565354, 0.308854,  0.764842)*p;\n\n        vec3 q = p;\n        p.y += 0.2*exp(-abs(2.0*p.z) );\n\n        float v = smoothstep( 0.01, 0.02, abs(p.z));\n        \n        float rr = sin( 4.0*0.25*50.0*p.x - 4.0*0.25*75.0*abs(p.z) );\n\n        vec3 te = texture( iChannel2, p.xz*0.35 ).xyz;\n\n        float r = clamp((p.x+2.0)\/4.0,0.0,1.0);\n        r = r*(1.0-r)*(1.0-r)*6.0;\n        float ff = length(p.xz\/vec2(2.0,r));\n\n        mateD = mix( vec3(0.07,0.1,0.0), vec3(0.05,0.2,0.01)*0.25, v );\n        mateD = mix( mateD, vec3(0.16,0.2,0.01)*0.25, ff );\n        mateD *= 1.0 + 0.25*te;\n        mateD *= 0.8;\n        \n        mateS = vec3(0.15,0.2,0.02)*0.8;\n        mateS *= 1.0 + 0.2*rr;\n        mateS *= 0.8;\n\n        mateK = vec2(64.0,0.25);\n        \n        \/\/---------------------\n        \n        nor.xz += v*0.15*(-1.0+2.0*texture( iChannel3, 1.0*p.xz ).xy);\n        nor = normalize( nor );\n\n        float d1 = sdEllipsoid( q, vec3( 0.5-0.07, 0.0,  0.20), 1.0*vec3(1.4*0.15,0.13,0.15) );\n        float d2 = sdEllipsoid( q, vec3( 0.8-0.05,-0.07,-0.15), 0.5*vec3(1.3*0.15,0.13,0.15) );\n        float d4 = sdEllipsoid( q, vec3(-0.5-0.07, 0.09,-0.20), 1.0*vec3(1.4*0.04,0.03,0.04) );\n        float dd = min(d1,min(d2,d4));\n        fsha = 0.05 + 0.95*smoothstep(0.0,0.05,dd);\n        \n        d1 = abs( sdCircle( q.xz, vec2( 0.5, 0.20), 1.0*0.15 ));\n        d2 = abs( sdCircle( q.xz, vec2( 0.8,-0.15), 0.5*0.15 ));\n        d4 = abs( sdCircle( q.xz, vec2(-0.5,-0.20), 1.0*0.04 ));\n        dd = min(d1,min(d2,d4));\n        focc *= 0.55 + 0.45*smoothstep(0.0,0.08,dd);\n        \n        d1 = distance( q.xz, vec2( 0.5-0.07, 0.20) );\n        d2 = distance( q.xz, vec2( 0.8-0.03,-0.15) );\n        fsha += (1.0-smoothstep(0.0,0.10,d1))*1.5;\n        fsha += (1.0-smoothstep(0.0,0.05,d2))*1.5;    \n    }\n  \n    vec3 hal = normalize( sunDir-rd );\n    float fre = clamp(1.0+dot(nor,rd), 0.0, 1.0 );\n    float occ = calcAO( pos, nor )*focc;\n    float sss = calcSSS( pos, nor );\n    sss = sss*occ + fre*occ + (0.5+0.5*fre)*pow(abs(matInfo.x-0.2),1.0)*occ;\n    \n    float dif1 = clamp( dot(nor,sunDir), 0.0, 1.0 );\n    dif1 *= fsha;\n    float sha = 1.0; if( dif1>0.0001 ) sha=calcSoftShadow( pos, sunDir, 20.0 ); \n    dif1 *= sha;\n    float spe1 = clamp( dot(nor,hal), 0.0, 1.0 );\n\n    float bou = clamp( 0.3-0.7*nor.y, 0.0, 1.0 );\n\n    \/\/ illumination\n    vec3 col = vec3(0.0);\n    col += 7.0*vec3(1.7,1.2,0.6)*dif1*2.0;               \/\/ sun\n    col += 4.0*vec3(0.2,1.2,1.6)*occ*(0.5+0.5*nor.y);    \/\/ sky\n    col += 1.8*vec3(0.1,2.0,0.1)*bou*occ;                \/\/ bounce\n\n    col *= mateD;\n\n    col += 0.4*sss*(vec3(0.15,0.1,0.05)+vec3(0.85,0.9,0.95)*dif1)*(0.05+0.95*occ)*mateS; \/\/ sss\n    col = pow(col,vec3(0.6,0.8,1.0));\n    \n    col += vec3(1.0,1.0,1.0)*0.2*pow( spe1, 1.0+mateK.x )*dif1*(0.04+0.96*pow(fre,4.0))*mateK.x*mateK.y;   \/\/ sun lobe1\n    col += vec3(1.0,1.0,1.0)*0.1*pow( spe1, 1.0+mateK.x\/3.0 )*dif1*(0.1+0.9*pow(fre,4.0))*mateK.x*mateK.y; \/\/ sun lobe2\n\tcol += 0.1*vec3(1.0,max(1.5-0.7*col.y,0.0),2.0)*occ*occ*smoothstep( 0.0, 0.3, reflect( rd, nor ).y )*mateK.x*mateK.y*(0.04+0.96*pow(fre,5.0)); \/\/ sky\n\n    col += mateE;\n\n    return col;        \n}\n\nvec3 shadeTransparent( in vec3 ro, in vec3 rd, in float t, in float m, in vec4 matInfo, in vec3 col, in float depth )\n{\n    vec3 oriCol = col;\n    \n    float dz = depth - t;\n    float ao = clamp(dz*50.0,0.0,1.0);\n    vec3  pos = ro + t*rd;\n    vec3  nor = calcNormalTransparent( pos, 0.002 );\n    float fre = clamp( 1.0 + dot( rd, nor ), 0.0, 1.0 );\n    vec3  hal = normalize( sunDir-rd );\n    vec3  ref = reflect( -rd, nor );\n    float spe1 = clamp( dot(nor,hal), 0.0, 1.0 );\n    float spe2 = clamp( dot(ref,sunDir), 0.0, 1.0 );\n\n    float ds = 1.6 - col.y;\n    \n    col *= mix( vec3(0.0,0.0,0.0), vec3(0.4,0.6,0.4), ao );\n\n    col += ds*1.5*vec3(1.0,0.9,0.8)*pow( spe1, 80.0 );\n    col += ds*0.2*vec3(0.9,1.0,1.0)*smoothstep(0.4,0.8,fre);\n    col += ds*0.9*vec3(0.6,0.7,1.0)*smoothstep( -0.5, 0.5, -reflect( rd, nor ).y )*smoothstep(0.2,0.4,fre);    \n    col += ds*0.5*vec3(1.0,0.9,0.8)*pow( spe2, 80.0 );\n    col += ds*0.5*vec3(1.0,0.9,0.8)*pow( spe2, 16.0 );\n    #if USE_TEXTURES==1\n    col += vec3(0.8,1.0,0.8)*0.5*smoothstep(0.3,0.6,text1( 0.8*nor.xy ))*(0.1+0.9*fre*fre);\n    #else\n    col += vec3(0.8,1.0,0.8)*0.65*smoothstep(0.3,0.6,text1( 0.7*nor.xy ))*(0.1+0.9*fre*fre);\n    #endif\n    \n    \/\/ hide aliasing a bit\n    return mix( col, oriCol, smoothstep(0.6,1.0,fre) ); \n}\n\n\/\/--------------------------------------------\n\nvec2 intersectOpaque( in vec3 ro, in vec3 rd, const float mindist, const float maxdist, out vec4 matInfo )\n{\n    vec2 res = vec2(-1.0);\n    \n    float t = mindist;\n    for( int i=ZERO; i<128; i++ )\n    {\n        vec3 p = ro + t*rd;\n        vec2 h = mapOpaque( p, matInfo );\n        res = vec2(t,h.y);\n\n        if( h.x<(0.001*t) ||  t>maxdist ) break;\n        \n        t += h.x*0.9;\n    }\n\treturn res;\n}\n\nvec2 intersectTransparent( in vec3 ro, in vec3 rd, const float mindist, const float maxdist, out vec4 matInfo )\n{\n    vec2 res = vec2(-1.0);\n    \n    float t = mindist;\n    for( int i=ZERO; i<64; i++ )\n    {\n        vec3 p = ro + t*rd;\n        vec2 h = mapTransparent( p, matInfo );\n        res = vec2(t,h.y);\n\n        if( h.x<(0.001*t) ||  t>maxdist ) break;\n        \n        t += h.x;\n    }\n\treturn res;\n}\n\nvec3 background( in vec3 d )\n{\n    \/\/ cheap cubemap\n    vec3 n = abs(d);\n    vec2 uv = (n.x>n.y && n.x>n.z) ? d.yz\/d.x: \n              (n.y>n.x && n.y>n.z) ? d.zx\/d.y:\n                                     d.xy\/d.z;\n    \/\/ fancy blur\n    vec3  col = vec3( 0.0 );\n    for( int i=ZERO; i<200; i++ )\n    {\n        float h = float(i)\/200.0;\n        float an = 31.0*6.2831*h;\n        vec2  of = vec2( cos(an), sin(an) ) * h;\n\n        vec3 tmp = texture( iChannel2, uv*0.25 + 0.0075*of, 4.0 ).yxz;\n        col = smax( col, tmp, 0.5 );\n    }\n    \n    return pow(col,vec3(3.5,3.0,6.0))*0.2;\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 q )\n{\n    \/\/-----------------------------\n\n    vec3 col = background( rd );\n    \n    \/\/-----------------------------\n    \n    float mindist = 1.0;\n    float maxdist = 4.0;\n\n    vec4 matInfo;\n    vec2 tm = intersectOpaque( ro, rd, mindist, maxdist, matInfo );\n    if( tm.y>-0.5 && tm.x < maxdist )\n    {\n        col = shadeOpaque( ro, rd, tm.x, tm.y, matInfo );\n        maxdist = tm.x;\n    }\n\n    \/\/-----------------------------\n    \n    tm = intersectTransparent( ro, rd, mindist, maxdist, matInfo );\n    if( tm.y>-0.5 && tm.x < maxdist )\n    {\n        col = shadeTransparent( ro, rd, tm.x, tm.y, matInfo, col, maxdist );\n    }\n\n    \/\/-----------------------------\n    \n    float sun = clamp(dot(rd,sunDir),0.0,1.0);\n    col += 1.0*vec3(1.5,0.8,0.7)*pow(sun,4.0);\n\n    \/\/-----------------------------\n\n    col = pow( col, vec3(0.45) );\n    \n    col = vec3(1.05,1.0,1.0)*col*(0.7+0.3*col*max(3.0-2.0*col,0.0)) + vec3(0.0,0.0,0.04);\n\n    col *= 0.3 + 0.7*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.1);\n\n    return clamp( col, 0.0, 1.0 );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 rt )\n{\n    vec3 w = normalize(ro-rt);\n    float m = sqrt(1.0-w.y*w.y);\n    return mat3( w.z,     0.0, -w.x, \n                 0.0,     m*m, -w.z*w.y,\n                 w.x*m, w.y*m,  w.z*m );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    #if AA<2\n        vec2  p = (2.0*fragCoord-iResolution.xy)\/iResolution.y;\n        vec2  q = fragCoord\/iResolution.xy;\n        float an = 1.87 - 0.04*(1.0-cos(0.5*iTime));\n\n        vec3  ro = vec3(-0.4,0.2,0.0) + 2.2*vec3(cos(an),0.0,sin(an));\n        vec3  ta = vec3(-0.6,0.2,0.0);\n        mat3  ca = setCamera( ro, ta );\n        vec3  rd = normalize( ca * vec3(p,-2.8) );\n\n        vec3 col = render( ro, rd, q );\n    #else\n        vec3 col = vec3(0.0);\n        for( int m=ZERO; m<AA; m++ )\n        for( int n=ZERO; n<AA; n++ )\n        {\n            vec2 rr = vec2(float(m),float(n))\/float(AA);\n\n            vec2 p = (2.0*(fragCoord+rr)-iResolution.xy)\/iResolution.y;\n            float an = 1.87 - 0.04*(1.0-cos(0.5*iTime));\n            vec2 q = (fragCoord+rr)\/iResolution.xy;\n\n            vec3 ro = vec3(-0.4,0.2,0.0) + 2.2*vec3(cos(an),0.0,sin(an));\n            vec3 ta = vec3(-0.6,0.2,0.0);\n            mat3 ca = setCamera( ro, ta );\n            vec3 rd = normalize( ca * vec3(p,-2.8) );\n\n\t\t    col += render( ro, rd, q );\n        }    \n        col \/= float(AA*AA);\n    #endif\n\n    fragColor = vec4( col, 1.0 );\n}",
                "name": "Image",
                "description": "",
                "type": "image"
            }
        ]
    },
    {
        "ver": "0.1",
        "info": {
            "id": "XsX3RB",
            "date": "1372830991",
            "viewed": 172840,
            "name": "Volcanic",
            "username": "iq",
            "description": "An alien volcanic landscape. It started as an experiment on 2d-texture based 3d noise. But then I played with the noise shape, the added some shading, put lighting in it, etc..., until I got this.",
            "likes": 672,
            "published": 3,
            "flags": 32,
            "usePreview": 0,
            "tags": []
        },
        "renderpass": [
            {
                "inputs": [
                    {
                        "id": "4dXGR8",
                        "filepath": "\/media\/previz\/buffer00.png",
                        "previewfilepath": "\/media\/previz\/buffer00.png",
                        "type": "buffer",
                        "channel": 0,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "4dfGRr",
                        "channel": 0
                    }
                ],
                "code": "\/\/ Copyright Inigo Quilez, 2013 - https:\/\/iquilezles.org\/\n\/\/ I am the sole copyright owner of this Work.\n\/\/ You cannot host, display, distribute or share this Work in any form,\n\/\/ including physical and digital. You cannot use this Work in any\n\/\/ commercial or non-commercial product, website or project. You cannot\n\/\/ sell this Work and you cannot mint an NFTs of it.\n\/\/ I share this Work for educational purposes, and you can link to it,\n\/\/ through an URL, proper attribution and unmodified screenshot, as part\n\/\/ of your educational material. If these conditions are too restrictive\n\/\/ please contact me and we'll definitely work it out.\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord\/iResolution.xy;\n    vec4 data = textureLod( iChannel0, uv, 0.0 );\n\n    vec3 col = vec3(0.0);\n    \n    if( data.w < 0.0 )\n    {\n        col = textureLod( iChannel0, uv, 0.0 ).xyz;\n    }\n    else\n    {\n        \/\/ decompress velocity vector\n        float ss =   mod(data.w,1024.0)\/1023.0;\n        float st = floor(data.w\/1024.0)\/1023.0;\n\n        \/\/ motion blur (linear blur across velocity vectors)\n        vec2 dir = (2.0*vec2(ss,st)-1.0)*0.25;\n        float tot = 0.0;\n        for( int i=0; i<32; i++ )\n        {\n            float h = float(i)\/31.0;\n            vec2  p = uv + dir*h;\n            float w = 1.0-h;\n            col += w*textureLod( iChannel0, p, 0.0 ).xyz;\n            tot += w;\n        }\n        col \/= tot;\n    }\n\n    \/\/ vignetting\t\n\tcol *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 );\n\n    fragColor = vec4( col, 1.0 );\n}",
                "name": "Image",
                "description": "",
                "type": "image"
            },
            {
                "inputs": [
                    {
                        "id": "4sfGRn",
                        "filepath": "\/media\/a\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg",
                        "previewfilepath": "\/media\/ap\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg",
                        "type": "texture",
                        "channel": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "wrap": "repeat",
                            "vflip": "false",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    },
                    {
                        "id": "XsX3Rn",
                        "filepath": "\/media\/a\/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg",
                        "previewfilepath": "\/media\/ap\/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg",
                        "type": "texture",
                        "channel": 2,
                        "sampler": {
                            "filter": "mipmap",
                            "wrap": "repeat",
                            "vflip": "false",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    },
                    {
                        "id": "Xsf3zn",
                        "filepath": "\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
                        "previewfilepath": "\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
                        "type": "texture",
                        "channel": 0,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "repeat",
                            "vflip": "false",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "4dXGR8",
                        "channel": 0
                    }
                ],
                "code": "\/\/#define HIGH_QUALITY_NOISE\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n#ifndef HIGH_QUALITY_NOISE\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)\/256.0, 0.0 ).yx;\n#else\n\tvec2 uv  = (p.xy+vec2(37.0,17.0)*p.z);\n\tvec2 rg1 = textureLod( iChannel0, (uv+ vec2(0.5,0.5))\/256.0, 0.0 ).yx;\n\tvec2 rg2 = textureLod( iChannel0, (uv+ vec2(1.5,0.5))\/256.0, 0.0 ).yx;\n\tvec2 rg3 = textureLod( iChannel0, (uv+ vec2(0.5,1.5))\/256.0, 0.0 ).yx;\n\tvec2 rg4 = textureLod( iChannel0, (uv+ vec2(1.5,1.5))\/256.0, 0.0 ).yx;\n\tvec2 rg  = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\n#endif\t\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\n\treturn textureLod( iChannel0, (uv+118.4)\/256.0, 0.0 ).x;\n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nfloat fbm4( in vec3 q )\n{\n    float f  = 0.5000*noise( q ); q = m*q*2.02;\n          f += 0.2500*noise( q ); q = m*q*2.03;\n          f += 0.1250*noise( q ); q = m*q*2.01;\n          f += 0.0625*noise( q );\n    return f;\n}\n    \nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n )\n{\n\treturn texture( sam, p.yz )*abs(n.x) +\n           texture( sam, p.zx )*abs(n.y) +\n           texture( sam, p.xy )*abs(n.z);\n}\n\n\/\/=====================================================================\n\nfloat lava( in vec2 p )\n{\n\tp += vec2(2.0,4.0);\n    float f  = 0.5000*noise( p ); p = p*2.02;\n          f += 0.2500*noise( p ); p = p*2.03;\n          f += 0.1250*noise( p ); p = p*2.01;\n          f += 0.0625*noise( p );\n    return f;\n}\n\nfloat displacement( in vec3 p )\n{\n    float dis = textureLod( iChannel2, p.xz, 0.0 ).x;\n    return fbm4(p+vec3(1.0,0.0,0.8)) - dis*0.01;\n}\n\nfloat mapTerrain( in vec3 pos )\n{\n\treturn pos.y*0.1 + (displacement(pos*vec3(0.8,1.0,0.8)) - 0.4)*(1.0-smoothstep(1.0,3.0,pos.y));\n}\n\nfloat raymarchTerrain( in vec3 ro, in vec3 rd )\n{\n    \/\/ bounding plane\n    const float hmax = 1.9;\n    float tp = (hmax-ro.y)\/rd.y;\n    float tmax = (tp<0.0)?30.0:tp;\n\n    \/\/ raymarch\n    float t = 0.1;\n    for( int i=0; i<350; i++ )\n    {\n\t    float h = mapTerrain( ro+rd*t );\n        if( abs(h)<(0.00025*t) || t>tmax ) break;\n        t += h*0.8;\n    }\n    return (t>tmax) ? -1.0 : t;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/rmshadows\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    \/\/ bounding plane\n    const float hmax = 1.9;\n    float tp = (hmax-ro.y)\/rd.y;\n    float tmax = (tp<0.0)?30.0:tp;\n\n    \/\/ raymarch\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<100; i++ )\n    {\n        float h = mapTerrain(ro + rd*t);\n        res = min( res, k*max(h,0.0)\/t );\n        t += clamp( h, 0.01, 0.4 );\n\t\tif( res<0.001 || t>tmax ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/normalsSDF\nvec3 calcNormal( in vec3 pos, in float t )\n{\n    float eps = max(0.02,0.001*t);\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*mapTerrain(pos+e.xyy) + \n\t\t\t\t\t  e.yyx*mapTerrain(pos+e.yyx) + \n\t\t\t\t\t  e.yxy*mapTerrain(pos+e.yxy) + \n\t\t\t\t\t  e.xxx*mapTerrain(pos+e.xxx) );\n}\n\nconst vec3 lig = normalize( vec3(-0.3,0.4,0.7) );\n\nvec4 mapClouds( in vec3 pos )\n{\n\tvec3 q = pos*0.5 + vec3(0.0,-iTime,0.0);\n\t\n\tfloat d = clamp( fbm4(q)-0.55, 0.0, 1.0 );\n\td *= smoothstep( 0.5, 0.55, lava(0.1*pos.xz)+0.01 );\n\t\n\tvec4 res = vec4( d );\n\tres.xyz  = 0.25*mix( vec3(1.0,0.8,0.7), 0.2*vec3(0.4,0.4,0.4), d );\n\tres.xyz *= 0.5 + 0.5*smoothstep(-2.0, 1.0, pos.y);\n\treturn res;\n}\n\nvec4 raymarchClouds( in vec3 ro, in vec3 rd, in vec3 bcol, float tmax, in vec2 px )\n{\n\tvec4 sum = vec4( 0.0 );\n\tfloat sun = pow( clamp( dot(rd,lig), 0.0, 1.0 ), 6.0 );\n\tfloat t = texture(iChannel0,px\/256.0).x*0.1;\n\tfor( int i=0; i<60; i++ )\n\t{\n\t\tvec4 col = mapClouds( ro + t*rd );\n\t\t\n        col.xyz += vec3(1.0,0.7,0.4)*0.4*sun*(1.0-col.w);\n\t\tcol.xyz = mix( col.xyz, bcol, 1.0-exp(-0.00006*t*t*t) );\n        col.a *= 2.0;\n\t\tcol.rgb *= col.a;\n\t\tsum = sum + col*(1.0 - sum.a);\t\n\n\t\tt += max(0.1,0.05*t);\n\t\tif( t>tmax || sum.w>0.95 ) break;\n\t}\n\tsum.xyz \/= (0.001+sum.w);\n\treturn clamp( sum, 0.0, 1.0 );\n}\n\nvec3 path( float time )\n{\n\treturn vec3( 16.0*cos(0.2+0.075*time), 1.5, 16.0*sin(0.1+0.0825*time) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid moveCamera( in float time, out vec3 oRo, out vec3 oTa, out float oCr, out float oFl )\n{\n    oFl = 2.1;\n    oCr = 0.3*sin(1.0+0.07*time);\n    oRo = path( time+0.0 );\n    oTa = path( time+1.6 );\n\toTa.y *= 0.35 + 0.25*sin(0.09*time);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)\/iResolution.y;\n\t\n    \/\/ camera\t\n\tfloat off = step( 0.001, iMouse.z )*6.0*iMouse.x\/iResolution.x;\n    float time = 3.4 + iTime + off;\n    vec3 ro, ta; float cr, fl;\n    moveCamera( time, ro, ta, cr, fl );\n    \n\t\/\/ camera2world transform\n    mat3 cam = setCamera( ro, ta, cr );\n\n    \/\/ ray    \n    vec3 rd = cam * normalize(vec3(p.xy,fl));\n\n    \/\/ sky\t \n    vec3  col = vec3(0.36,0.43,0.54) - rd.y*0.5;\n    float sun = clamp( dot(rd,lig), 0.0, 1.0 );\n\tcol += vec3(1.0,0.8,0.4)*0.24*pow( sun, 6.0 );\n\n\tvec3 bcol = col;\n    \n    \/\/ terrain\t\n\tfloat t = raymarchTerrain(ro, rd);\n    float st = t;\n    if( t>0.0 )\n\t{\n\t\tvec3 pos = ro + t*rd;\n\t\tvec3 nor = calcNormal( pos, t );\n\t\tvec3 ref = reflect( rd, nor );\n\t\t\n        \/\/ lighting\n\t\tfloat hhh = 1.0 - smoothstep(-2.0, 1.0, pos.y);\n\t\tfloat sun = clamp( dot( nor, lig ), 0.0, 1.0 );\n\t\tfloat sha = 0.0; if( sun>0.01) sha=softshadow(pos,lig,0.001,32.0);\n\t\tfloat bac = clamp( dot( nor, normalize(lig*vec3(-1.0,0.0,-1.0)) ), 0.0, 1.0 );\n\t\tfloat sky = 0.5 + 0.5*nor.y;\n        float lav = smoothstep( 0.5, 0.55, lava(0.1*pos.xz) )*hhh*clamp(0.5-0.5*nor.y,0.0,1.0);\n\t\tfloat occ = pow( (1.0-displacement(pos*vec3(0.8,1.0,0.8)))*1.6-0.5, 2.0 );\n\t\tfloat amb = 1.0;\n        float fre = 1.0+dot(nor,rd); fre = fre*fre;\n\n\t\tvec3 lin = vec3(0.0);\n\t\tlin += 1.3*sun*vec3(1.80,1.27,0.99)*pow(vec3(sha),vec3(1.0,1.2,1.5));\n\t\tlin += 1.0*sky*vec3(0.16,0.20,0.40)*occ;\n\t\tlin += 1.0*bac*vec3(0.40,0.28,0.20)*occ;\n\t\tlin += 1.0*amb*vec3(0.15,0.17,0.20)*occ;\n\t\tlin += lav*vec3(3.00,0.61,0.00);\n\n        \/\/ surface shading\/material\t\t\n        vec3 te = texcube( iChannel1, 0.5*pos, nor ).xyz;\n\t\tcol = te;\n\t\tcol = col*(0.2+0.8*texcube( iChannel2, 4.0*vec3(2.0,8.0,2.0)*pos, nor ).x);\n\n\t\tvec3 lava = vec3(1.0,0.9,0.2);\n\t\tlava *= texture( iChannel2, pos.xz ).xyz;\n\t\tcol = mix( col, 0.8*lava, hhh );\n\t\t\n\t\tvec3 verde = vec3(0.2,0.2,0.05);\n\t\tverde *= 0.2+1.6*texture( iChannel1, 7.1*pos.xz ).xyz;\n\t\tverde += 0.1*texture( iChannel1, 1.0*pos.xz ).xyz;\n        verde *= 1.0+fre*fre;\n\t\tcol = mix( col, verde, smoothstep(0.0, 0.8, nor.y)*smoothstep(0.0, 0.1, pos.y-0.8 ) );\n\t\t\n\t\tcol = lin * col;\n\n        \/\/ sun spec\n        vec3 hal = normalize(lig-rd);\n        col += (te.x*te.x)*vec3(11.0,8.0,5.0)*sun*sha*\n               pow( clamp(dot(nor,hal),0.0,1.0), 8.0 ) *\n               (0.04+0.96*pow(clamp(1.0+dot(hal,rd),0.0,1.0),5.0));\n            \n\t\t\/\/ atmospheric\n        vec3 ext = exp2(-t*t*0.001*vec3(0.5,1.0,2.0) );\n        col = col*ext + 0.6*(1.0-ext)*(1.0-0.7*hhh);\n    }\n\n    \/\/ sun glow\n    col += vec3(1.0,0.6,0.2)*0.2*sun*sun*clamp( (rd.y+0.4)\/(0.0+0.4),0.0,1.0);\n\t\n    \/\/ smoke\t\n    vec4 res = raymarchClouds( ro, rd, bcol, (t<0.0)?600.0:t, fragCoord );\n\tcol = mix( col, res.xyz, res.w );\n\n    \/\/ gain\n    col *= 1.6\/(1.0+col);\n    col *= vec3(1.02,1.04,1.0);\n\n    \/\/ gamma\t\n\tcol = pow( clamp( col, 0.0, 1.0 ), vec3(0.45) );\n\n    \/\/ contrast, desat, tint and vignetting\t\n\tcol = col*col*(3.0-2.0*col);\n\tcol = mix( col, vec3(col.x+col.y+col.z)*0.33, 0.2 );\n      \n    \/\/-------------------------------------\n\t\/\/ velocity vectors\n    \/\/-------------------------------------\n    float vel = -1.0;\n    if( st>0.0 )\n    {\n        \/\/ old camera position\n        float oldTime = time - 1.0\/30.0; \/\/ 1\/30 of a second blur\n        vec3 oldRo, oldTa; float oldCr, oldFl;\n        moveCamera( oldTime, oldRo, oldTa, oldCr, oldFl );\n        mat3 oldCam = setCamera( oldRo, oldTa, oldCr );\n        \/\/ world space\n        vec3 wpos = ro + rd*st;\n        \/\/ camera space\n        vec3 cpos = vec3( dot( wpos - oldRo, oldCam[0] ),\n                          dot( wpos - oldRo, oldCam[1] ),\n                          dot( wpos - oldRo, oldCam[2] ) );\n        \/\/ ndc space\n        vec2 npos = oldFl * cpos.xy \/ cpos.z;\n        \/\/ screen space\n        vec2 spos = 0.5 + 0.5*npos*vec2(iResolution.y\/iResolution.x,1.0);\n        \/\/ compress velocity vector in a single float\n        vec2 uv = fragCoord\/iResolution.xy;\n        spos = clamp( 0.5 + 0.5*(spos - uv)\/0.25, 0.0, 1.0 );\n        vel = floor(spos.x*1023.0) + floor(spos.y*1023.0)*1024.0;\n    }\n\n    fragColor = vec4( col, vel );\n}",
                "name": "Buffer A",
                "description": "",
                "type": "buffer"
            }
        ]
    },
    {
        "ver": "0.1",
        "info": {
            "id": "lsl3RH",
            "date": "1365615747",
            "viewed": 139230,
            "name": "Warping - procedural 2",
            "username": "iq",
            "description": "Warp. Tutorial here: https:\/\/iquilezles.org\/articles\/warp",
            "likes": 502,
            "published": 3,
            "flags": 0,
            "usePreview": 0,
            "tags": []
        },
        "renderpass": [
            {
                "inputs": [],
                "outputs": [],
                "code": "\/\/ Copyright Inigo Quilez, 2013 - https:\/\/iquilezles.org\/\n\/\/ I am the sole copyright owner of this Work.\n\/\/ You cannot host, display, distribute or share this Work in any form,\n\/\/ including physical and digital. You cannot use this Work in any\n\/\/ commercial or non-commercial product, website or project. You cannot\n\/\/ sell this Work and you cannot mint an NFTs of it.\n\/\/ I share this Work for educational purposes, and you can link to it,\n\/\/ through an URL, proper attribution and unmodified screenshot, as part\n\/\/ of your educational material. If these conditions are too restrictive\n\/\/ please contact me and we'll definitely work it out.\n\n\n\/\/ See here for a tutorial on how to make this:\n\/\/\n\/\/ https:\/\/iquilezles.org\/articles\/warp\n\n\/\/====================================================================\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat noise( in vec2 p )\n{\n\treturn sin(p.x)*sin(p.y);\n}\n\nfloat fbm4( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f\/0.9375;\n}\n\nfloat fbm6( vec2 p )\n{\n    float f = 0.0;\n    f += 0.500000*(0.5+0.5*noise( p )); p = m*p*2.02;\n    f += 0.250000*(0.5+0.5*noise( p )); p = m*p*2.03;\n    f += 0.125000*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.062500*(0.5+0.5*noise( p )); p = m*p*2.04;\n    f += 0.031250*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.015625*(0.5+0.5*noise( p ));\n    return f\/0.96875;\n}\n\nvec2 fbm4_2( vec2 p )\n{\n    return vec2(fbm4(p), fbm4(p+vec2(7.8)));\n}\n\nvec2 fbm6_2( vec2 p )\n{\n    return vec2(fbm6(p+vec2(16.8)), fbm6(p+vec2(11.5)));\n}\n\n\/\/====================================================================\n\nfloat func( vec2 q, out vec4 ron )\n{\n    q += 0.03*sin( vec2(0.27,0.23)*iTime + length(q)*vec2(4.1,4.3));\n\n\tvec2 o = fbm4_2( 0.9*q );\n\n    o += 0.04*sin( vec2(0.12,0.14)*iTime + length(o));\n\n    vec2 n = fbm6_2( 3.0*o );\n\n\tron = vec4( o, n );\n\n    float f = 0.5 + 0.5*fbm4( 1.8*q + 6.0*n );\n\n    return mix( f, f*f*f*3.5, f*abs(n.x) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)\/iResolution.y;\n    float e = 2.0\/iResolution.y;\n\n    vec4 on = vec4(0.0);\n    float f = func(p, on);\n\n\tvec3 col = vec3(0.0);\n    col = mix( vec3(0.2,0.1,0.4), vec3(0.3,0.05,0.05), f );\n    col = mix( col, vec3(0.9,0.9,0.9), dot(on.zw,on.zw) );\n    col = mix( col, vec3(0.4,0.3,0.3), 0.2 + 0.5*on.y*on.y );\n    col = mix( col, vec3(0.0,0.2,0.4), 0.5*smoothstep(1.2,1.3,abs(on.z)+abs(on.w)) );\n    col = clamp( col*f*2.0, 0.0, 1.0 );\n    \n#if 0\n    \/\/ gpu derivatives - bad quality, but fast\n\tvec3 nor = normalize( vec3( dFdx(f)*iResolution.x, 6.0, dFdy(f)*iResolution.y ) );\n#else    \n    \/\/ manual derivatives - better quality, but slower\n    vec4 kk;\n \tvec3 nor = normalize( vec3( func(p+vec2(e,0.0),kk)-f, \n                                2.0*e,\n                                func(p+vec2(0.0,e),kk)-f ) );\n#endif    \n\n    vec3 lig = normalize( vec3( 0.9, 0.2, -0.4 ) );\n    float dif = clamp( 0.3+0.7*dot( nor, lig ), 0.0, 1.0 );\n    vec3 lin = vec3(0.70,0.90,0.95)*(nor.y*0.5+0.5) + vec3(0.15,0.10,0.05)*dif;\n    col *= 1.2*lin;\n\tcol = 1.0 - col;\n\tcol = 1.1*col*col;\n    \n    fragColor = vec4( col, 1.0 );\n}\n",
                "name": "Image",
                "description": "",
                "type": "image"
            }
        ]
    },
    {
        "ver": "0.1",
        "info": {
            "id": "4dfGzs",
            "date": "1376478210",
            "viewed": 127703,
            "name": "Voxel Edges",
            "username": "iq",
            "description": "Correct edge detection for voxels. The marching function is fb39ca4's DDA, but using floating point operations instead of integers. The most interesting bits are probably the exact 3D intersector, the occlusion and the edge detection code.",
            "likes": 829,
            "published": 3,
            "flags": 1,
            "usePreview": 0,
            "tags": []
        },
        "renderpass": [
            {
                "inputs": [
                    {
                        "id": "Xsf3zn",
                        "filepath": "\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
                        "previewfilepath": "\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
                        "type": "texture",
                        "channel": 0,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "repeat",
                            "vflip": "false",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "4dfGRr",
                        "channel": 0
                    }
                ],
                "code": "\/\/ Copyright Inigo Quilez, 2013 - https:\/\/iquilezles.org\/\n\/\/ I am the sole copyright owner of this Work.\n\/\/ You cannot host, display, distribute or share this Work in any form,\n\/\/ including physical and digital. You cannot use this Work in any\n\/\/ commercial or non-commercial product, website or project. You cannot\n\/\/ sell this Work and you cannot mint an NFTs of it.\n\/\/ I share this Work for educational purposes, and you can link to it,\n\/\/ through an URL, proper attribution and unmodified screenshot, as part\n\/\/ of your educational material. If these conditions are too restrictive\n\/\/ please contact me and we'll definitely work it out.\n\n\/\/ Shading technique explained here:\n\/\/\n\/\/ https:\/\/iquilezles.org\/articles\/voxellines\n\n\n\n\/\/ consider replacing this by a proper noise function\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+0.5)\/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat mapTerrain( vec3 p )\n{\n\tp *= 0.1; \n\tp.xz *= 0.6;\n\t\n\tfloat time = 0.5 + 0.15*iTime;\n\tfloat ft = fract( time );\n\tfloat it = floor( time );\n\tft = smoothstep( 0.7, 1.0, ft );\n\ttime = it + ft;\n\tfloat spe = 1.4;\n\t\n\tfloat f;\n    f  = 0.5000*noise( p*1.00 + vec3(0.0,1.0,0.0)*spe*time );\n    f += 0.2500*noise( p*2.02 + vec3(0.0,2.0,0.0)*spe*time );\n    f += 0.1250*noise( p*4.01 );\n\treturn 25.0*f-10.0;\n}\n\nvec3 gro = vec3(0.0);\n\nfloat map(in vec3 c) \n{\n\tvec3 p = c + 0.5;\n\t\n\tfloat f = mapTerrain( p ) + 0.25*p.y;\n\n    f = mix( f, 1.0, step( length(gro-p), 5.0 ) );\n\n\treturn step( f, 0.5 );\n}\n\nvec3 lig = normalize( vec3(-0.4,0.3,0.7) );\n\nfloat castRay( in vec3 ro, in vec3 rd, out vec3 oVos, out vec3 oDir )\n{\n\tvec3 pos = floor(ro);\n\tvec3 ri = 1.0\/rd;\n\tvec3 rs = sign(rd);\n\tvec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;\n\t\n\tfloat res = -1.0;\n\tvec3 mm = vec3(0.0);\n\tfor( int i=0; i<128; i++ ) \n\t{\n\t\tif( map(pos)>0.5 ) { res=1.0; break; }\n\t\tmm = step(dis.xyz, dis.yzx) * step(dis.xyz, dis.zxy);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t}\n\n\tvec3 nor = -mm*rs;\n\tvec3 vos = pos;\n\t\n    \/\/ intersect the cube\t\n\tvec3 mini = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;\n\tfloat t = max ( mini.x, max ( mini.y, mini.z ) );\n\t\n\toDir = mm;\n\toVos = vos;\n\n\treturn t*res;\n}\n\nvec3 path( float t, float ya )\n{\n    vec2 p  = 100.0*sin( 0.02*t*vec2(1.0,1.2) + vec2(0.1,0.9) );\n\t     p +=  50.0*sin( 0.04*t*vec2(1.3,1.0) + vec2(1.0,4.5) );\n\t\n\treturn vec3( p.x, 18.0 + ya*4.0*sin(0.05*t), p.y );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\nfloat maxcomp( in vec4 v )\n{\n    return max( max(v.x,v.y), max(v.z,v.w) );\n}\n\nfloat isEdge( in vec2 uv, vec4 va, vec4 vb, vec4 vc, vec4 vd )\n{\n    vec2 st = 1.0 - uv;\n\n    \/\/ edges\n    vec4 wb = smoothstep( 0.85, 0.99, vec4(uv.x,\n                                           st.x,\n                                           uv.y,\n                                           st.y) ) * ( 1.0 - va + va*vc );\n    \/\/ corners\n    vec4 wc = smoothstep( 0.85, 0.99, vec4(uv.x*uv.y,\n                                           st.x*uv.y,\n                                           st.x*st.y,\n                                           uv.x*st.y) ) * ( 1.0 - vb + vd*vb );\n    return maxcomp( max(wb,wc) );\n}\n\nfloat calcOcc( in vec2 uv, vec4 va, vec4 vb, vec4 vc, vec4 vd )\n{\n    vec2 st = 1.0 - uv;\n\n    \/\/ edges\n    vec4 wa = vec4( uv.x, st.x, uv.y, st.y ) * vc;\n\n    \/\/ corners\n    vec4 wb = vec4(uv.x*uv.y,\n                   st.x*uv.y,\n                   st.x*st.y,\n                   uv.x*st.y)*vd*(1.0-vc.xzyw)*(1.0-vc.zywx);\n    \n    return wa.x + wa.y + wa.z + wa.w +\n           wb.x + wb.y + wb.z + wb.w;\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    vec3 col = vec3(0.0);\n\t\n    \/\/ raymarch\t\n\tvec3 vos, dir;\n\tfloat t = castRay( ro, rd, vos, dir );\n\tif( t>0.0 )\n\t{\n        vec3 nor = -dir*sign(rd);\n        vec3 pos = ro + rd*t;\n        vec3 uvw = pos - vos;\n\t\t\n\t\tvec3 v1  = vos + nor + dir.yzx;\n\t    vec3 v2  = vos + nor - dir.yzx;\n\t    vec3 v3  = vos + nor + dir.zxy;\n\t    vec3 v4  = vos + nor - dir.zxy;\n\t\tvec3 v5  = vos + nor + dir.yzx + dir.zxy;\n        vec3 v6  = vos + nor - dir.yzx + dir.zxy;\n\t    vec3 v7  = vos + nor - dir.yzx - dir.zxy;\n\t    vec3 v8  = vos + nor + dir.yzx - dir.zxy;\n\t    vec3 v9  = vos + dir.yzx;\n\t    vec3 v10 = vos - dir.yzx;\n\t    vec3 v11 = vos + dir.zxy;\n\t    vec3 v12 = vos - dir.zxy;\n \t    vec3 v13 = vos + dir.yzx + dir.zxy; \n\t    vec3 v14 = vos - dir.yzx + dir.zxy ;\n\t    vec3 v15 = vos - dir.yzx - dir.zxy;\n\t    vec3 v16 = vos + dir.yzx - dir.zxy;\n\n\t\tvec4 vc = vec4( map(v1),  map(v2),  map(v3),  map(v4)  );\n\t    vec4 vd = vec4( map(v5),  map(v6),  map(v7),  map(v8)  );\n\t    vec4 va = vec4( map(v9),  map(v10), map(v11), map(v12) );\n\t    vec4 vb = vec4( map(v13), map(v14), map(v15), map(v16) );\n\t\t\n\t\tvec2 uv = vec2( dot(dir.yzx, uvw), dot(dir.zxy, uvw) );\n\t\t\t\n        \/\/ wireframe\n        float www = 1.0 - isEdge( uv, va, vb, vc, vd );\n        \n        vec3 wir = smoothstep( 0.4, 0.5, abs(uvw-0.5) );\n        float vvv = (1.0-wir.x*wir.y)*(1.0-wir.x*wir.z)*(1.0-wir.y*wir.z);\n\n        col = vec3(0.5);\n        col += 0.8*vec3(0.1,0.3,0.4);\n        col *= 1.0 - 0.75*(1.0-vvv)*www;\n\t\t\n        \/\/ lighting\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(lig*vec3(-1.0,0.0,-1.0)) ), 0.0, 1.0 );\n        float sky = 0.5 + 0.5*nor.y;\n        float amb = clamp(0.75 + pos.y\/25.0,0.0,1.0);\n        float occ = 1.0;\n\t\n        \/\/ ambient occlusion\n        occ = calcOcc( uv, va, vb, vc, vd );\n        occ = 1.0 - occ\/8.0;\n        occ = occ*occ;\n        occ = occ*occ;\n        occ *= amb;\n\n        \/\/ lighting\n        vec3 lin = vec3(0.0);\n        lin += 2.5*dif*vec3(1.00,0.90,0.70)*(0.5+0.5*occ);\n        lin += 0.5*bac*vec3(0.15,0.10,0.10)*occ;\n        lin += 2.0*sky*vec3(0.40,0.30,0.15)*occ;\n\n        \/\/ line glow\t\n        float lineglow = 0.0;\n        lineglow += smoothstep( 0.4, 1.0,     uv.x )*(1.0-va.x*(1.0-vc.x));\n        lineglow += smoothstep( 0.4, 1.0, 1.0-uv.x )*(1.0-va.y*(1.0-vc.y));\n        lineglow += smoothstep( 0.4, 1.0,     uv.y )*(1.0-va.z*(1.0-vc.z));\n        lineglow += smoothstep( 0.4, 1.0, 1.0-uv.y )*(1.0-va.w*(1.0-vc.w));\n        lineglow += smoothstep( 0.4, 1.0,      uv.y*      uv.x )*(1.0-vb.x*(1.0-vd.x));\n        lineglow += smoothstep( 0.4, 1.0,      uv.y* (1.0-uv.x))*(1.0-vb.y*(1.0-vd.y));\n        lineglow += smoothstep( 0.4, 1.0, (1.0-uv.y)*(1.0-uv.x))*(1.0-vb.z*(1.0-vd.z));\n        lineglow += smoothstep( 0.4, 1.0, (1.0-uv.y)*     uv.x )*(1.0-vb.w*(1.0-vd.w));\n\t\t\n        vec3 linCol = 2.0*vec3(5.0,0.6,0.0);\n        linCol *= (0.5+0.5*occ)*0.5;\n        lin += 3.0*lineglow*linCol;\n\t\t\n        col = col*lin;\n        col += 8.0*linCol*vec3(1.0,2.0,3.0)*(1.0-www);\/\/*(0.5+1.0*sha);\n        col += 0.1*lineglow*linCol;\n        col *= min(0.1,exp( -0.07*t ));\n\t\n        \/\/ blend to black & white\t\t\n        vec3 col2 = vec3(1.3)*(0.5+0.5*nor.y)*occ*www*(0.9+0.1*vvv)*exp( -0.04*t );;\n        float mi = sin(-1.57+0.5*iTime);\n        mi = smoothstep( 0.70, 0.75, mi );\n        col = mix( col, col2, mi );\n\t}\n\n\t\/\/ gamma\t\n\tcol = pow( col, vec3(0.45) );\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ inputs\t\n\tvec2 q = fragCoord.xy \/ iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x\/ iResolution.y;\n\t\n    vec2 mo = iMouse.xy \/ iResolution.xy;\n    if( iMouse.z<=0.00001 ) mo=vec2(0.0);\n\t\n\tfloat time = 2.0*iTime + 50.0*mo.x;\n    \/\/ camera\n\tfloat cr = 0.2*cos(0.1*iTime);\n\tvec3 ro = path( time+0.0, 1.0 );\n\tvec3 ta = path( time+5.0, 1.0 ) - vec3(0.0,6.0,0.0);\n\tgro = ro;\n\n    mat3 cam = setCamera( ro, ta, cr );\n\t\n\t\/\/ build ray\n    float r2 = p.x*p.x*0.32 + p.y*p.y;\n    p *= (7.0-sqrt(37.5-11.5*r2))\/(r2+1.0);\n    vec3 rd = normalize( cam * vec3(p.xy,-2.5) );\n\n    vec3 col = render( ro, rd );\n    \n\t\/\/ vignetting\t\n\tcol *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\t\n\tfragColor = vec4( col, 1.0 );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n\tfloat time = 1.0*iTime;\n\n    float cr = 0.0;\n\tvec3 ro = path( time+0.0, 0.0 ) + vec3(0.0,0.7,0.0);\n\tvec3 ta = path( time+2.5, 0.0 ) + vec3(0.0,0.7,0.0);\n\n    mat3 cam = setCamera( ro, ta, cr );\n\n    vec3 col = render( ro + cam*fragRayOri, cam*fragRayDir );\n    \n    fragColor = vec4( col, 1.0 );\n}",
                "name": "Image",
                "description": "",
                "type": "image"
            }
        ]
    }
]