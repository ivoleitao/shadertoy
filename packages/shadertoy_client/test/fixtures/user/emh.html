<!DOCTYPE HTML>
<html lang="en">
<head>
    
<title>emh - Shadertoy BETA</title>
<meta charset="utf-8" />
<meta name="Keywords" content="shadertoy, shader toy, quilez, inigo, jeremias, pol, fractals, demoscene, computer graphics, mathematics, rendering, demo, 3D, realtime, shader, raytracing, raymarching, webgl, glsl" />
<meta name="Description" content="Build shaders, share them, and learn from the best community." />
<meta name="Author" content="Beautypi" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<link rel="image_src" href="https://www.shadertoy.com/img/logo.png" />
<link rel="apple-touch-icon" href="/img/launch_icon_57.png"/>
<link rel="apple-touch-icon" sizes="72x72" href="/img/launch_icon_72.png"/>
<link rel="apple-touch-icon" sizes="114x114" href="/img/launch_icon_114.png"/>
<link rel="shortcut icon" href="/img/favicon.ico"/>

<style>::-webkit-scrollbar {
    height: 8px;
    width: 8px;
    background: #404040;
}

::-webkit-scrollbar-thumb
{
    background: #909090;
    border-radius: 0ex;
}

::-webkit-scrollbar-corner
{
    background: #000;
}

::-webkit-input-placeholder
{
	font-style:italic;
}
input:-moz-placeholder, textarea:-moz-placeholder
{
	font-style:italic;
}
input.placeholder-text, textarea.placeholder-text
{
	font-style:italic;
}

pre 
{
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
    white-space: -pre-wrap;
    white-space: -o-pre-wrap;
    word-wrap: break-word;
}

@font-face
{
    font-family: Lobster;
    src: url("/img/lobster.otf") format("opentype");
}

div#centerScreen
{
    left: 50%;
    top: 50%;
    position: absolute;
}

a.headerLinks:hover
{
    background-color:#505050;
    color : #ff8020;
}

body
{
    color: #000000;
    font-size:12px;
    font-style:normal;
    font-family:Tahoma,Arial;
    background-repeat: no-repeat;
    //background-attachment: fixed;
    padding:0px;
    margin:0px;
    text-align: left;
    background-color: #d0d0d0;
    background-repeat: repeat;
    user-select: text;
}

a,
a:hover,
a:visited
{
  color : inherit;
}

div#content {
    width: 95%;
    overflow: hidden;
    margin: auto;
    padding: 0px;
    min-height: calc(100vh - 80px);
    //box-sizing: border-box;
}


.notificationCount
{
 background-color:#ff0000;
 padding-left:3px;
 padding-right:1px;
 padding-top:1px;
 padding-bottom:1px;
}

div#header
{
    background-color: #404040;
    top: 0px;
    left: 0px;
    width: 100%;
    padding: 0;
    margin: 0;
    color: #ffffff;
    display: flex;
    flex-direction:row;
}

#headerBlock1
{
    width: 50%;
    display:flex;
    align-items:center;
}

a#headerTitle
{
    font-size: 2.25em;
    font-family: Lobster,Tahoma,Arial;
    text-decoration: none;
    padding-left:32px;
    padding-right:32px;
}

#headerSearch
{
    display: inline-block;
    color: #000000;
    width: 300px;
}

input[type=search]#mySearch
{
    width: 100%;
    border-radius: 6px;
    border: 1px solid black;
    padding:12px;
}

#headerBlock2
{
    width: 50%;
    margin-left: auto;
    display: flex;
    justify-content: flex-end;
}


a#headerTitle:hover
{
    color : #ff8020;
}

a.headerLinks
{
    font-weight: bold;
    padding-top: 14px;
    padding-bottom: 14px;
    padding-left: 14px;
    padding-right: 14px;
    margin:0px;
    text-decoration: none;
    transition: background-color 0.15s linear, color 0.15s linear;
}

#footer
{
    background-color: rgba(64,64,64,0.25);
    color: #000000;
    padding: 0px;
    margin: 0px;
    width: 100%;
    display: flex;
    justify-content: space-between;
    flex-wrap: wrap;
}

#footer div
{
    padding-top:10px;
    padding-bottom:0px;
    padding-left:16px;
    padding-right:16px;
}

#footer div ul
{
    margin-left:0px;
    padding-left:16px;
}

#footer div ul li
{
    padding-top:6px;
}

a.regular
{
    font-weight:bold;
    text-decoration:none
}

a.regular:hover
{
  color : #ff8020;
}

a.user
{
    font-weight:bold;
    text-decoration:none;
}

a.user:hover
{
  color : #ff8020;
  text-decoration: underline;
}

.uiButton
{
    border: none;
    outline: none;
    margin: 0px;
    padding: 0px;
    width: 22px;
    height: 22px;
    position: absolute;
    cursor: pointer;
    border-radius: 4px;
}

.uiButton:hover
{
    box-shadow: inset 0px 0px 1px 1px #808080, 0px 0px 1px 1px #808080;
}

.uiDivBUtton
{
    cursor:pointer;
}

.uiDivBUtton:hover
{
    color: #ffffff;
}


.dialog
{
    display: block;
    background-color: #e0e0e0;
    color: #000000;
    border:1px solid #000;
    padding:0px;
    margin:0px;
    text-align:left;
    border-radius: 4px;
    box-shadow:4px 4px 6px 0px rgba(0,0,0,0.5);
    overflow: hidden;
    z-index:1000;
    visibility: hidden;
    opacity:0;
    -moz-transition: opacity 0.25s linear,visibility 0.25s linear;
    -webkit-transition: opacity 0.25s linear,visibility 0.25s linear;
    transition: opacity 0.25s linear,visibility 0.25s linear;
}

.dialogHeader
{
    left:0px;
    top: 0px;
    width:100%;
    height:32px;
    position: absolute;
    background-color: #808080;
    cursor:move;
}

.dialogTitle
{
    left: 12px;
    top: 4px;
    position: absolute;
    padding: 0px;
    margin: 0px;
    color:#000000;
    font-size:1.5em;
    text-align: left;
    user-select: none;
    -moz-user-select: -moz-none;
    -webkit-user-select: none;
}

.dialogOverlay
{
    z-index:1000;

    visibility: hidden;
    opacity:0;
    -moz-transition: opacity 0.25s linear,visibility 0.25s linear;
    -webkit-transition: opacity 0.25s linear,visibility 0.25s linear;
    transition: opacity 0.25s linear,visibility 0.25s linear;

    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    width:100%;
    height:100%;
    position:absolute;

    background-color:rgba(0,0,0,.4);
}

.viewsIcon, .likesIcon
{
    border: none;
    outline: none;
    display:inline-block;
    background-repeat:no-repeat;
    top:0px;
    left:0px;
    padding:0px;
    padding-right: 2px;
    margin:0px;
    position:relative;
}

.userPictureSmall
{
    background-color:#808080;
    border: 1px solid #000000;
    width:32px;
    height:32px;
}

.dialogCloseButton
{
    right:8px;
    top: 4px;
    width:22px;
    height:22px;
    position: absolute;
    background-image: url("/img/close.png");
    cursor: pointer;
    border-radius: 4px;
}

.dialogCloseButton:hover
{
    box-shadow: inset 0px 0px 4px 2px #ffffff, 0px 0px 4px 2px #ffffff;
}

.dialogContentButtons
{
     padding:0;
     border:0;
     text-align: justify;
     left: 24px;
     bottom:40px;
     position:absolute;
}

.dialogButton
{
    text-align: center;
    vertical-align: middle;
    display: inline-block;
    border-radius: 4px;
    font-weight: bold;
    cursor: pointer;
    padding-bottom:5px;
    padding-top:4px;
    padding-left: 8px;
    padding-right: 8px;
    margin-left:4px;
    margin-right:4px;
    text-decoration: none;
    color:#000000;
    width: 80px;
    -moz-transition:    background-color 0.15s linear, color 0.15s linear;
    -webkit-transition: background-color 0.15s linear, color 0.15s linear;
    transition:         background-color 0.15s linear, color 0.15s linear;
}

.dialogButton:hover
{
  background-color:#808080;
  color : #ff8020;
}

.dialogCloseButton:hover
{
    box-shadow: inset 0px 0px 4px 2px #ffffff, 0px 0px 4px 2px #ffffff;
}

.dialogContent
{
    color: inherit;
    overflow: auto;
    width:100%;
    height:100%;
    left: 0px;
    top: 32px;
    position:absolute
}

.dialogContentBody
{
    color: inherit;
    width:100%;
    height:auto;
    padding-top:24px;
    padding-bottom:24px;
    padding-left:24px;
    padding-right:24px;
    text-align: left;
}

.formButton
{
    font-weight:bold;
	color:#ffffff;
	border:none;
    text-align:center;
	background-color:#808080;
    border-radius: 4px;
	padding-left:8px;
	padding-right:8px;
	padding-top:4px;
	padding-bottom:4px;
    cursor:pointer;
    min-width:80px;
    box-sizing: border-box;
}
.formInput {
    border-radius: 6px;
    border: 1px solid black;
    padding: 4px;
    border: none;
}
.formButton:hover {
    background-color: #e0e0e0;
}
.formButton:disabled
{
	color:#b0b0b0;
	background-color:#808080;
}

.formButtonSmall
{
    color:#ffffff;
    border:none;
    text-align:center;
    background-color:#808080;
    border-radius: 4px;
    padding-left:2px;
    padding-right:2px;
    padding-top:2px;
    padding-bottom:2px;
    cursor:pointer;
    min-width:40px;
}

.formButtonSmall:hover
{
    background-color: #e0e0e0;
}

.formButtonSmall:disabled
{
    color:#b0b0b0;
    background-color:#808080;
}

.formButtonSmall.disabled2,
.formButton.disabled2 { color:#b0b0b0; background-color:#808080; pointer-events: none; }

.inputForm
{
    padding-left:2%;
    padding-right:2%;
    resize: none;
    text-align: left;
    background-color:#e0e0e0;
    outline: none;
    border-radius: 4px;
    border: 1px solid #808080;
    color:inherit;
    box-sizing: border-box;
}

.inputForm:focus
{
    border: 1px solid #AFCDD8;
    background-color: #EBF2F4;
}

.transparentPannel
{
    background-color:rgba(64,64,64,0.1);
    padding:16px;
}

.comment, .commentSelf, .commentNew
{
    border-radius: 4px;
    width: 100%;
    margin-left: 0px;
    margin-right: 0px;
    margin-top: 0px;
    margin-bottom: 6px;

    padding: 14px;
    box-sizing: border-box;
    display: grid;
    grid-template-columns: 32px auto 8px;
    grid-template-rows: 1fr;
    grid-gap:8px;
}

.comment:nth-child(even)
{
    background-color: rgba(64,64,64,0.1);
}

.comment:nth-child(odd)
{
    background-color: rgba(128,128,128,0.1);
}

.commentSelf
{
    background-color: rgba(240,160,64,0.1);
}

.commentNew
{
    padding-right: 0px;
    grid-template-columns: 40px auto;
}

.commentContent
{
    vertical-align: top;
    text-align: left;
    word-break: break-all;
    word-break: break-word;
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
}


/* ----------------------- media resolutions ------------------------ */

@media screen and (max-width:799px)
{
    div#header {flex-direction:column; }
    #headerBlock1 { width:100%; }
    #headerBlock2 { width:100%; justify-content: space-around;}
    div#headerSearch {width:200px;}
    input#mySearch { width:200px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .previewText { width:130px; }
    .transparentPannel { padding:10px; }
}

@media screen and (min-width:800px) and (max-width:1279px)
{
    body { font-size: 9px; }
    div#headerSearch {width: 250px;}
    input#mySearch { width:250px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .previewText { width:130px; }
    .transparentPannel { padding:11px; }
}

@media screen and (min-width:1280px) and (max-width:1439px)
{
    body { font-size: 10px; }
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:28px; }
    .previewText { width:180px; }
    .transparentPannel { padding:12px; }
}

@media screen and (min-width:1440px) and (max-width:1919px)
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:28px; }
    .previewText { width:180px; }
    .transparentPannel { padding:12px; }
}

@media screen and (min-width:1920px) and (max-width:2559px)
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:32px; }
    .previewText { width:220px; }
    .transparentPannel { padding:16px; }
}

@media screen and (min-width:2560px) 
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:32px; }
    .previewText { width:220px; }
    .transparentPannel { padding:16px; }
}
body
{
    background-image: url("/img/themes/classic/background.jpg");
}
</style>


    <script>"use strict"

//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piCamera
//
//==============================================================================

function piCamera()
{
    var mMatrix = setIdentity();
    var mMatrixInv = setIdentity();

    var mPosition = [0.0,0.0,0.0];
    var mXRotation = 0.0;
    var mYRotation = 0.0;

    var mPositionTarget = [0.0,0.0,0.0];
    var mXRotationTarget = 0.0;
    var mYRotationTarget = 0.0;

    var me = {};
/*
    me.Set = function( pos, dir, roll) 
             {
                 mMatrix    = setLookat( pos, add(pos,dir), [Math.sin(roll),Math.cos(roll),Math.sin(roll)] );
                 mMatrixInv = invertFast( mMatrix );
             };
*/
    me.SetPos = function(pos)
                {
                    mPosition = pos;
                    //mMatrix[ 3] = -(mMatrix[0] * pos[0] + mMatrix[1] * pos[1] + mMatrix[ 2] * pos[2]);
                    //mMatrix[ 7] = -(mMatrix[4] * pos[0] + mMatrix[5] * pos[1] + mMatrix[ 6] * pos[2]);
                    //mMatrix[11] = -(mMatrix[8] * pos[0] + mMatrix[9] * pos[1] + mMatrix[10] * pos[2]);
                };
/*
    me.GlobalMove = function(pos)
                    {
                        mMatrix[ 3] -= (mMatrix[0] * pos[0] + mMatrix[1] * pos[1] + mMatrix[ 2] * pos[2]);
                        mMatrix[ 7] -= (mMatrix[4] * pos[0] + mMatrix[5] * pos[1] + mMatrix[ 6] * pos[2]);
                        mMatrix[11] -= (mMatrix[8] * pos[0] + mMatrix[9] * pos[1] + mMatrix[10] * pos[2]);
                        mMatrixInv = invertFast(mMatrix);
                    };
*/
    me.LocalMove = function( dis )
                    {
                        dis = matMulvec( setRotationY(-mYRotation), dis);
                        mPositionTarget = sub(mPositionTarget,dis)
                    };

    me.RotateXY = function( x, y)
                  {
                    mXRotationTarget -= x;
                    mYRotationTarget -= y;
                    mXRotationTarget = Math.min( Math.max( mXRotationTarget, -Math.PI/2), Math.PI/2 );
                  };


    me.CameraExectue = function( dt )
    {
        // smooth position
        mXRotation += (mXRotationTarget-mXRotation) * 12.0*dt;
        mYRotation += (mYRotationTarget-mYRotation) * 12.0*dt;
        mPosition = add(mPosition, mul( sub(mPositionTarget, mPosition), 12.0*dt));

        // Make Camera matrix
        mMatrix = matMul( matMul(setRotationX(mXRotation), 
                                 setRotationY(mYRotation)),  
                                 setTranslation(mPosition));
        mMatrixInv = invertFast(mMatrix);

    }

    me.GetMatrix = function() { return mMatrix; };
    me.GetMatrixInverse = function() { return mMatrixInv; };
    me.SetMatrix = function( mat ) 
                    {
                        mMatrix = mat;
                        mMatrixInv = invertFast(mMatrix);

                        mPosition = getXYZ(matMulpoint(mat, [0.0,0.0,0.0]));
                        mPositionTarget = mPosition;
                    };

    me.GetPos = function() { return getXYZ(matMulpoint(mMatrixInv, [0.0,0.0,0.0])); }
    me.GetDir = function() { return getXYZ(normalize(matMulvec(mMatrixInv, [0.0,0.0,-1.0]))); }

    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piFile
//
//==============================================================================

function piFile( binaryDataArrayBuffer )
{
    // private
    //var mDataView = new DataView( binaryDataArrayBuffer, 0 );
    var mDataView = binaryDataArrayBuffer;
    var mOffset = 0;

    // public members
    var me = {};
    me.mDummy = 0;
/*
    // public functions
    me.Seek = function( off ) { mOffset = off - 3; };
    me.ReadUInt16 = function()  { var res = mDataView.getUint16( mOffset ); mOffset+=2; return res; };
    me.ReadUInt32 = function()  { var res = mDataView.getUint32( mOffset ); mOffset+=4; return res; };
    me.ReadUInt64 = function()  { return me.ReadUInt32() + (me.ReadUInt32()<<32); };
    me.ReadFloat32 = function() { var res = mDataView.getFloat32( mOffset ); mOffset+=4; return res; };
*/

    me.Seek = function( off ) { mOffset = off; };
    me.ReadUInt8  = function()  { var res = (new Uint8Array(mDataView,mOffset))[0]; mOffset+=1; return res; };
    me.ReadUInt16 = function()  { var res = (new Uint16Array(mDataView,mOffset))[0]; mOffset+=2; return res; };
    me.ReadUInt32 = function()  { var res = (new Uint32Array(mDataView,mOffset))[0]; mOffset+=4; return res; };
    me.ReadUInt64 = function()  { return me.ReadUInt32() + (me.ReadUInt32()<<32); };
    me.ReadFloat32 = function() { var res = (new Float32Array(mDataView,mOffset))[0]; mOffset+=4; return res; };
    me.ReadFloat32Array = function(n) 
                          { 
                              var src = new Float32Array(mDataView, mOffset);
                              var res = [];  for( var i=0; i<n; i++ ) { res[i] = src[i]; }
                              mOffset += 4*n;
                              return res;
                          };
    me.ReadFloat32ArrayNative = function(n) { var src = new Float32Array(mDataView, mOffset); mOffset += 4*n; return src; };
    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piMesh
//
//==============================================================================

function piMesh()
{
    this.mChunks = [];
    this.mPrimitiveType = 0;
    this.mVertexFormat = null;
}

/*
piMesh.prototype.normalize = function( ppos, npos )
{
    var numv = this.mVertexData.length;
    var numt = this.mIndices.length;

    for( var i=0; i<numv; i++ )
    {
        //float *v = (float*)piMesh_GetVertexData( me, i, npos );
        //v[0] = 0.0f;
        //v[1] = 0.0f;
        //v[2] = 0.0f;
        this.mVerts[8 * i + 3] = 0.0;
        this.mVerts[8 * i + 4] = 0.0;
        this.mVerts[8 * i + 5] = 0.0;
    }

    for( var i=0; i<numt; i++ )
    {
        piMeshFace *face = me->mFaceData.mIndexArray[0].mBuffer + i;

        const int ft = face->mNum;
        
        vec3 nor = vec3( 0.0f, 0.0f, 0.0f );
        for( int j=0; j<ft; j++ )
        {
            const vec3 va = *((vec3*)piMesh_GetVertexData( me, face->mIndex[ j      ], ppos ));
            const vec3 vb = *((vec3*)piMesh_GetVertexData( me, face->mIndex[(j+1)%ft], ppos ));

            nor += cross( va, vb );
        }

        for( int j=0; j<ft; j++ )
        {
            vec3 *n = (vec3*)piMesh_GetVertexData( me, face->mIndex[j], npos );
            n->x += nor.x;
            n->y += nor.y;
            n->z += nor.z;
        }
    }

    for( var i=0; i<numv; i++ )
    {
        vec3 *v = (vec3*)piMesh_GetVertexData( me, i, npos );
        *v = normalize( *v );
    }
}
*/

piMesh.prototype.createCube = function(renderer)
{
    this.mPrimitiveType = 0;

    this.mChunks[0] = { mVerts : new Float32Array([ -1.0, -1.0, -1.0,
                                       1.0, -1.0, -1.0,
                                      -1.0,  1.0, -1.0,
                                       1.0,  1.0, -1.0,
                                      -1.0, -1.0,  1.0,
                                       1.0, -1.0,  1.0,
                                      -1.0,  1.0,  1.0,
                                       1.0,  1.0,  1.0 ]),

                        mIndices : new Uint16Array([ 0, 2, 1,   1, 2, 3,   5, 1, 3,   5, 3, 7,   4, 5, 7,   4, 7, 6,   4, 6, 2,   4, 2, 0,   6, 7, 3,   6, 3, 2,   4, 0, 1,   4, 1, 5 ]),
                        mNumVertices : 8,
                        mNumFaces : 12, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };

    this.mVertexFormat = { mStride:12, mChannels:[ { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false } ] };

    return true;
}

piMesh.prototype.createCubeSharp = function (renderer)
{
    this.mPrimitiveType = 0;

    this.mChunks[0] = { mVerts : new Float32Array([-1.0, 1.0,-1.0,   0.0, 1.0, 0.0,   0.0, 0.0,
                                    -1.0, 1.0, 1.0,   0.0, 1.0, 0.0,   0.0, 1.0,
                                     1.0, 1.0, 1.0,   0.0, 1.0, 0.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   0.0, 1.0, 0.0,   1.0, 0.0,

                                    -1.0,-1.0, 1.0,   0.0, 0.0, 1.0,   0.0, 0.0,
                                     1.0,-1.0, 1.0,   0.0, 0.0, 1.0,   0.0, 1.0,
                                     1.0, 1.0, 1.0,   0.0, 0.0, 1.0,   1.0, 1.0,
                                    -1.0, 1.0, 1.0,   0.0, 0.0, 1.0,   1.0, 0.0,

                                     1.0, 1.0, 1.0,   1.0, 0.0, 0.0,   0.0, 0.0,
                                     1.0,-1.0, 1.0,   1.0, 0.0, 0.0,   0.0, 1.0,
                                     1.0,-1.0,-1.0,   1.0, 0.0, 0.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   1.0, 0.0, 0.0,   1.0, 0.0,

                                     1.0,-1.0,-1.0,   0.0, 0.0,-1.0,   0.0, 0.0,
                                    -1.0,-1.0,-1.0,   0.0, 0.0,-1.0,   0.0, 1.0,
                                    -1.0, 1.0,-1.0,   0.0, 0.0,-1.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   0.0, 0.0,-1.0,   1.0, 0.0,

                                    -1.0,-1.0, 1.0,   0.0,-1.0, 0.0,   0.0, 0.0,
                                    -1.0,-1.0,-1.0,   0.0,-1.0, 0.0,   0.0, 1.0,
                                     1.0,-1.0,-1.0,   0.0,-1.0, 0.0,   1.0, 1.0,
                                     1.0,-1.0, 1.0,   0.0,-1.0, 0.0,   1.0, 0.0,

                                    -1.0, 1.0, 1.0,  -1.0, 0.0, 0.0,   0.0, 0.0,
                                    -1.0, 1.0,-1.0,  -1.0, 0.0, 0.0,   0.0, 1.0,
                                    -1.0,-1.0,-1.0,  -1.0, 0.0, 0.0,   1.0, 1.0,
                                    -1.0,-1.0, 1.0,  -1.0, 0.0, 0.0,   1.0, 0.0 ]),

                        mIndices : new Uint16Array([0,1,2, 0,2,3,   4,5,6, 4,6,7,    8,9,10,8,10,11,   12,13,14,12,14,15,   16,17,18,16,18,19,   20,21,22,20,22,23]),
                        mNumVertices : 24,
                        mNumFaces : 12, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };


    this.mVertexFormat = { mStride:32, mChannels:[ { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false },
                                                   { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false },
                                                   { mNumComponents:2, mType: renderer.TYPE.FLOAT32, mNormalize: false } ] };

    return true;
}


piMesh.prototype.createUnitQuad = function (renderer)
{
    this.mPrimitiveType = 0;
    this.mVertexFormat = { mStride:8, mChannels: [ {mNumComponents:2, mType: renderer.TYPE.FLOAT32, mNormalize: false} ] };

    this.mChunks[0] = { mVerts : new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0,  1.0, 1.0,  1.0]),
                        mIndices : new Uint16Array([0, 2, 1, 1, 2, 3]),
                        mNumVertices : 4,
                        mNumFaces : 2, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };
 
    return true;
}




piMesh.prototype.destroy = function()
{
    //delete this.mVerts;   this.mVerts = null;
    //delete this.mIndices; this.mIndices = null;
}

piMesh.prototype.scale = function (x, y, z)
{
    var stride = this.mVertexFormat.mStride/4;
    for( var j=0; j<this.mChunks.length; j++ )
    {
        var nv = this.mChunks[j].mNumVertices;
        for (var i = 0; i < nv; i++) 
        {
            this.mChunks[j].mVerts[stride * i + 0] *= x;
            this.mChunks[j].mVerts[stride * i + 1] *= y;
            this.mChunks[j].mVerts[stride * i + 2] *= z;
        }
    }
}

piMesh.prototype.translate = function (x, y, z) 
{
    var stride = this.mVertexFormat.mStride/4;
    for( var j=0; j<this.mChunks.length; j++ )
    {
        var nv = this.mChunks[j].mNumVertices;
        for (var i = 0; i < nv; i++) 
        {
            this.mChunks[j].mVerts[stride * i + 0] += x;
            this.mChunks[j].mVerts[stride * i + 1] += y;
            this.mChunks[j].mVerts[stride * i + 2] += z;
        }
    }
}

piMesh.prototype.GPULoad = function (renderer)
{
    for( var i=0; i<this.mChunks.length; i++ )
    {
        var vbo = renderer.CreateVertexArray(this.mChunks[i].mVerts, renderer.BUFTYPE.STATIC );
        if (vbo == null)
            return false;

        var ibo = renderer.CreateIndexArray(this.mChunks[i].mIndices, renderer.BUFTYPE.STATIC);
        if (ibo == null)
            return false;

        this.mChunks[i].mVBO = vbo;
        this.mChunks[i].mIBO = ibo;
    }
    return true;
}

piMesh.prototype.GPURender = function (renderer, positions )//, matPrj, matCam )
{
    //renderer.SetShaderConstantMat4F("unMPrj", matPrj, false );

    var num = this.mChunks.length;
    for( var i=0; i<num; i++ )
    {
        //var mat =  matMul( matCam, this.mChunks[i].mTransform );
        //renderer.SetShaderConstantMat4F("unMMod", mat, false);

        renderer.AttachVertexArray(this.mChunks[i].mVBO, this.mVertexFormat, positions );
        renderer.AttachIndexArray(this.mChunks[i].mIBO );
        renderer.DrawPrimitive(renderer.PRIMTYPE.TRIANGLES, this.mChunks[i].mNumFaces * 3, true, 1);
        renderer.DetachIndexArray(this.mChunks[i].mIBO);
        renderer.DetachVertexArray(this.mChunks[i].mVBO, this.mVertexFormat );
    }
}
//==============================================================================
//
// piLibs 2014-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piRenderer
//
//==============================================================================

function piRenderer()
{
    // private members

    var mGL = null;
    var mBindedShader = null;
    var mIs20 = false;
    var mFloat32Textures;
    var mFloat32Filter;
    var mFloat16Textures;
    var mDrawBuffers;
    var mDepthTextures;
    var mDerivatives;
    var mFloat16Filter;
    var mShaderTextureLOD;
    var mAnisotropic;
    var mRenderToFloat32F;
    var mDebugShader;
    var mAsynchCompile;

    var mVBO_Quad = null;
    var mVBO_Tri = null;
    var mVBO_CubePosNor = null;
    var mVBO_CubePos = null;
    var mShaderHeader = ["",""];
    var mShaderHeaderLines = [0,0];

    // public members
    var me = {};

    me.CLEAR      = { Color: 1, Zbuffer : 2, Stencil : 4 };
    me.TEXFMT     = { C4I8 : 0, C1I8 : 1, C1F16 : 2, C4F16 : 3, C1F32 : 4, C4F32 : 5, Z16 : 6, Z24 : 7, Z32 : 8, C3F32:9 };
    me.TEXWRP     = { CLAMP : 0, REPEAT : 1 };
    me.BUFTYPE    = { STATIC : 0, DYNAMIC : 1 };
    me.PRIMTYPE   = { POINTS : 0, LINES : 1, LINE_LOOP : 2, LINE_STRIP : 3, TRIANGLES : 4, TRIANGLE_STRIP : 5 };
    me.RENDSTGATE = { WIREFRAME : 0, FRONT_FACE : 1, CULL_FACE : 2, DEPTH_TEST : 3, ALPHA_TO_COVERAGE : 4 };
    me.TEXTYPE    = { T2D : 0, T3D : 1, CUBEMAP : 2 };
    me.FILTER     = { NONE : 0, LINEAR : 1, MIPMAP : 2, NONE_MIPMAP : 3 };
    me.TYPE       = { UINT8 : 0, UINT16 : 1, UINT32 : 2, FLOAT16: 3, FLOAT32 : 4, FLOAT64: 5 };

    // private functions

    var iFormatPI2GL = function( format )
    {
        if( mIs20 )
        {
             if (format === me.TEXFMT.C4I8)  return { mGLFormat: mGL.RGBA8,           mGLExternal: mGL.RGBA,             mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1I8)  return { mGLFormat: mGL.R8,              mGLExternal: mGL.RED,              mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1F16) return { mGLFormat: mGL.R16F,            mGLExternal: mGL.RED,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F16) return { mGLFormat: mGL.RGBA16F,         mGLExternal: mGL.RGBA,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C1F32) return { mGLFormat: mGL.R32F,            mGLExternal: mGL.RED,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F32) return { mGLFormat: mGL.RGBA32F,         mGLExternal: mGL.RGBA,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C3F32) return { mGLFormat: mGL.RGB32F,          mGLExternal: mGL.RGB,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.Z16)   return { mGLFormat: mGL.DEPTH_COMPONENT16, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        else if (format === me.TEXFMT.Z24)   return { mGLFormat: mGL.DEPTH_COMPONENT24, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        else if (format === me.TEXFMT.Z32)   return { mGLFormat: mGL.DEPTH_COMPONENT32F, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        }
        else
        {
             if (format === me.TEXFMT.C4I8)  return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1I8)  return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.LUMINANCE,       mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1F16) return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.LUMINANCE,       mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F16) return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C1F32) return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.RED,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F32) return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.Z16)   return { mGLFormat: mGL.DEPTH_COMPONENT, mGLExternal: mGL.DEPTH_COMPONENT, mGLType: mGL.UNSIGNED_SHORT }
        }

        return null;
     }

    // public functions

    me.Initialize = function( gl )
                    {
                        mGL = gl;

                        mIs20 = !(gl instanceof WebGLRenderingContext);

                        if( mIs20 )
                        {
                            mFloat32Textures  = true;
                            mFloat32Filter    = mGL.getExtension( 'OES_texture_float_linear');
                            mFloat16Textures  = true;
                            mFloat16Filter    = mGL.getExtension( 'OES_texture_half_float_linear' );
                            mDerivatives      = true;
                            mDrawBuffers      = true;
                            mDepthTextures    = true;
                            mShaderTextureLOD = true;
                            mAnisotropic = mGL.getExtension( 'EXT_texture_filter_anisotropic' );
                            mRenderToFloat32F = mGL.getExtension( 'EXT_color_buffer_float');
                            mDebugShader = mGL.getExtension('WEBGL_debug_shaders');
                            mAsynchCompile = mGL.getExtension('KHR_parallel_shader_compile');

							mGL.hint( mGL.FRAGMENT_SHADER_DERIVATIVE_HINT, mGL.NICEST);
                        }
                        else
                        {
                            mFloat32Textures  = mGL.getExtension( 'OES_texture_float' );
                            mFloat32Filter    = mGL.getExtension( 'OES_texture_float_linear');
                            mFloat16Textures  = mGL.getExtension( 'OES_texture_half_float' );
                            mFloat16Filter    = mGL.getExtension( 'OES_texture_half_float_linear' );
                            mDerivatives      = mGL.getExtension( 'OES_standard_derivatives' );
                            mDrawBuffers      = mGL.getExtension( 'WEBGL_draw_buffers' );
                            mDepthTextures    = mGL.getExtension( 'WEBGL_depth_texture' );
                            mShaderTextureLOD = mGL.getExtension( 'EXT_shader_texture_lod' );
                            mAnisotropic      = mGL.getExtension( 'EXT_texture_filter_anisotropic' );
                            mRenderToFloat32F = mFloat32Textures;
                            mDebugShader      = null;
                            mAsynchCompile    = null;
							
							if( mDerivatives !== null) mGL.hint( mDerivatives.FRAGMENT_SHADER_DERIVATIVE_HINT_OES, mGL.NICEST);
                        }
                        
                        
                        var maxTexSize = mGL.getParameter( mGL.MAX_TEXTURE_SIZE );
                        var maxCubeSize = mGL.getParameter( mGL.MAX_CUBE_MAP_TEXTURE_SIZE );
                        var maxRenderbufferSize = mGL.getParameter( mGL.MAX_RENDERBUFFER_SIZE );
                        var extensions = mGL.getSupportedExtensions();
                        var textureUnits = mGL.getParameter( mGL.MAX_TEXTURE_IMAGE_UNITS );
                        console.log("WebGL (2.0=" + mIs20 + "):" +
                                    " Asynch Compile: "  + ((mAsynchCompile !==null) ? "yes" : "no") +
                                    ", Textures: F32 ["   + ((mFloat32Textures !==null) ? "yes" : "no") +
                                    "], F16 ["   + ((mFloat16Textures !==null) ? "yes" : "no") +
                                    "], Depth [" + ((mDepthTextures   !==null) ? "yes" : "no") +
                                    "], LOD ["    + ((mShaderTextureLOD!==null) ? "yes" : "no") +
                                    "], Aniso ["   + ((mAnisotropic     !==null) ? "yes" : "no") +
                                    "], Units [" + textureUnits +
                                    "], Max Size [" + maxTexSize +
                                    "], Cube Max Size [" + maxCubeSize +
                                    "], Targets: MRT ["            + ((mDrawBuffers     !==null) ? "yes" : "no") +
                                    "], F32 ["     + ((mRenderToFloat32F!==null) ? "yes" : "no") +
                                    "], Max Size [" + maxRenderbufferSize + "]");

                        // create a 2D quad Vertex Buffer
                        var vertices = new Float32Array( [ -1.0, -1.0,   1.0, -1.0,    -1.0,  1.0,     1.0, -1.0,    1.0,  1.0,    -1.0,  1.0] );
                        mVBO_Quad = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Quad );
                        mGL.bufferData( mGL.ARRAY_BUFFER, vertices, mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 2D triangle Vertex Buffer
                        mVBO_Tri = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Tri );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0,   3.0, -1.0,    -1.0,  3.0] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 3D cube Vertex Buffer
                        mVBO_CubePosNor = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePosNor );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0, -1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0, -1.0,  1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0,  1.0, -1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0,  1.0,  1.0,  -1.0,  0.0,  0.0,
                                                                               1.0,  1.0, -1.0,   1.0,  0.0,  0.0,
                                                                               1.0,  1.0,  1.0,   1.0,  0.0,  0.0,
                                                                               1.0, -1.0, -1.0,   1.0,  0.0,  0.0,
                                                                               1.0, -1.0,  1.0,   1.0,  0.0,  0.0,
                                                                               1.0,  1.0,  1.0,   0.0,  1.0,  0.0,
                                                                               1.0,  1.0, -1.0,   0.0,  1.0,  0.0,
                                                                              -1.0,  1.0,  1.0,   0.0,  1.0,  0.0,
                                                                              -1.0,  1.0, -1.0,   0.0,  1.0,  0.0,
                                                                               1.0, -1.0, -1.0,   0.0, -1.0,  0.0,
                                                                               1.0, -1.0,  1.0,   0.0, -1.0,  0.0,
                                                                              -1.0, -1.0, -1.0,   0.0, -1.0,  0.0,
                                                                              -1.0, -1.0,  1.0,   0.0, -1.0,  0.0,
                                                                              -1.0,  1.0,  1.0,   0.0,  0.0,  1.0,
                                                                              -1.0, -1.0,  1.0,   0.0,  0.0,  1.0,
                                                                               1.0,  1.0,  1.0,   0.0,  0.0,  1.0,
                                                                               1.0, -1.0,  1.0,   0.0,  0.0,  1.0,
                                                                              -1.0, -1.0, -1.0,   0.0,  0.0, -1.0,
                                                                              -1.0,  1.0, -1.0,   0.0,  0.0, -1.0,
                                                                               1.0, -1.0, -1.0,   0.0,  0.0, -1.0,
                                                                               1.0,  1.0, -1.0,   0.0,  0.0, -1.0 ] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 3D cube Vertex Buffer
                        mVBO_CubePos = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePos );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0, -1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                               1.0,  1.0, -1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0, -1.0,  1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0,  1.0, -1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0, -1.0,  1.0,
                                                                              -1.0, -1.0, -1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0, -1.0,  1.0,
                                                                              -1.0, -1.0, -1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0,  1.0, -1.0 ] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        //-------------------------------------------------------------------

                        mShaderHeader[0] = "";
                        mShaderHeaderLines[0] = 0;
                        if( mIs20 ) 
                        { 
                            mShaderHeader[0] += "#version 300 es\n" +
                                                "#ifdef GL_ES\n"+
                                                "precision highp float;\n" +
                                                "precision highp int;\n"+
                                                "precision mediump sampler3D;\n"+
                                                "#endif\n"; 
                            mShaderHeaderLines[0] += 6;
                        }
                        else
                        {
                            mShaderHeader[0] += "#ifdef GL_ES\n"+
                                                "precision highp float;\n" +
                                                "precision highp int;\n"+
                                                "#endif\n"+
                                                "float round( float x ) { return floor(x+0.5); }\n"+
                                                "vec2 round(vec2 x) { return floor(x + 0.5); }\n"+
                                                "vec3 round(vec3 x) { return floor(x + 0.5); }\n"+
                                                "vec4 round(vec4 x) { return floor(x + 0.5); }\n"+
                                                "float trunc( float x, float n ) { return floor(x*n)/n; }\n"+
                                                "mat3 transpose(mat3 m) { return mat3(m[0].x, m[1].x, m[2].x, m[0].y, m[1].y, m[2].y, m[0].z, m[1].z, m[2].z); }\n"+
                                                "float determinant( in mat2 m ) { return m[0][0]*m[1][1] - m[0][1]*m[1][0]; }\n"+
                                                "float determinant( mat4 m ) { float b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0], b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0], b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0], b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1], b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1], b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2], b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0], b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0], b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0], b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1], b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1], b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;}\n"+
                                                "mat2 inverse(mat2 m) { float det = determinant(m); return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / det; }\n"+
                                                "mat4 inverse(mat4 m ) { float inv0 = m[1].y*m[2].z*m[3].w - m[1].y*m[2].w*m[3].z - m[2].y*m[1].z*m[3].w + m[2].y*m[1].w*m[3].z + m[3].y*m[1].z*m[2].w - m[3].y*m[1].w*m[2].z; float inv4 = -m[1].x*m[2].z*m[3].w + m[1].x*m[2].w*m[3].z + m[2].x*m[1].z*m[3].w - m[2].x*m[1].w*m[3].z - m[3].x*m[1].z*m[2].w + m[3].x*m[1].w*m[2].z; float inv8 = m[1].x*m[2].y*m[3].w - m[1].x*m[2].w*m[3].y - m[2].x  * m[1].y * m[3].w + m[2].x  * m[1].w * m[3].y + m[3].x * m[1].y * m[2].w - m[3].x * m[1].w * m[2].y; float inv12 = -m[1].x  * m[2].y * m[3].z + m[1].x  * m[2].z * m[3].y +m[2].x  * m[1].y * m[3].z - m[2].x  * m[1].z * m[3].y - m[3].x * m[1].y * m[2].z + m[3].x * m[1].z * m[2].y; float inv1 = -m[0].y*m[2].z * m[3].w + m[0].y*m[2].w * m[3].z + m[2].y  * m[0].z * m[3].w - m[2].y  * m[0].w * m[3].z - m[3].y * m[0].z * m[2].w + m[3].y * m[0].w * m[2].z; float inv5 = m[0].x  * m[2].z * m[3].w - m[0].x  * m[2].w * m[3].z - m[2].x  * m[0].z * m[3].w + m[2].x  * m[0].w * m[3].z + m[3].x * m[0].z * m[2].w - m[3].x * m[0].w * m[2].z; float inv9 = -m[0].x  * m[2].y * m[3].w +  m[0].x  * m[2].w * m[3].y + m[2].x  * m[0].y * m[3].w - m[2].x  * m[0].w * m[3].y - m[3].x * m[0].y * m[2].w + m[3].x * m[0].w * m[2].y; float inv13 = m[0].x  * m[2].y * m[3].z - m[0].x  * m[2].z * m[3].y - m[2].x  * m[0].y * m[3].z + m[2].x  * m[0].z * m[3].y + m[3].x * m[0].y * m[2].z - m[3].x * m[0].z * m[2].y; float inv2 = m[0].y  * m[1].z * m[3].w - m[0].y  * m[1].w * m[3].z - m[1].y  * m[0].z * m[3].w + m[1].y  * m[0].w * m[3].z + m[3].y * m[0].z * m[1].w - m[3].y * m[0].w * m[1].z; float inv6 = -m[0].x  * m[1].z * m[3].w + m[0].x  * m[1].w * m[3].z + m[1].x  * m[0].z * m[3].w - m[1].x  * m[0].w * m[3].z - m[3].x * m[0].z * m[1].w + m[3].x * m[0].w * m[1].z; float inv10 = m[0].x  * m[1].y * m[3].w - m[0].x  * m[1].w * m[3].y - m[1].x  * m[0].y * m[3].w + m[1].x  * m[0].w * m[3].y + m[3].x * m[0].y * m[1].w - m[3].x * m[0].w * m[1].y; float inv14 = -m[0].x  * m[1].y * m[3].z + m[0].x  * m[1].z * m[3].y + m[1].x  * m[0].y * m[3].z - m[1].x  * m[0].z * m[3].y - m[3].x * m[0].y * m[1].z + m[3].x * m[0].z * m[1].y; float inv3 = -m[0].y * m[1].z * m[2].w + m[0].y * m[1].w * m[2].z + m[1].y * m[0].z * m[2].w - m[1].y * m[0].w * m[2].z - m[2].y * m[0].z * m[1].w + m[2].y * m[0].w * m[1].z; float inv7 = m[0].x * m[1].z * m[2].w - m[0].x * m[1].w * m[2].z - m[1].x * m[0].z * m[2].w + m[1].x * m[0].w * m[2].z + m[2].x * m[0].z * m[1].w - m[2].x * m[0].w * m[1].z; float inv11 = -m[0].x * m[1].y * m[2].w + m[0].x * m[1].w * m[2].y + m[1].x * m[0].y * m[2].w - m[1].x * m[0].w * m[2].y - m[2].x * m[0].y * m[1].w + m[2].x * m[0].w * m[1].y; float inv15 = m[0].x * m[1].y * m[2].z - m[0].x * m[1].z * m[2].y - m[1].x * m[0].y * m[2].z + m[1].x * m[0].z * m[2].y + m[2].x * m[0].y * m[1].z - m[2].x * m[0].z * m[1].y; float det = m[0].x * inv0 + m[0].y * inv4 + m[0].z * inv8 + m[0].w * inv12; det = 1.0 / det; return det*mat4( inv0, inv1, inv2, inv3,inv4, inv5, inv6, inv7,inv8, inv9, inv10, inv11,inv12, inv13, inv14, inv15);}\n"+                                                
                                                "float sinh(float x)  { return (exp(x)-exp(-x))/2.; }\n"+
                                                "float cosh(float x)  { return (exp(x)+exp(-x))/2.; }\n"+
                                                "float tanh(float x)  { return sinh(x)/cosh(x); }\n"+
                                                "float coth(float x)  { return cosh(x)/sinh(x); }\n"+
                                                "float sech(float x)  { return 1./cosh(x); }\n"+
                                                "float csch(float x)  { return 1./sinh(x); }\n"+
                                                "float asinh(float x) { return    log(x+sqrt(x*x+1.)); }\n"+
                                                "float acosh(float x) { return    log(x+sqrt(x*x-1.)); }\n"+
                                                "float atanh(float x) { return .5*log((1.+x)/(1.-x)); }\n"+
                                                "float acoth(float x) { return .5*log((x+1.)/(x-1.)); }\n"+
                                                "float asech(float x) { return    log((1.+sqrt(1.-x*x))/x); }\n"+
                                                "float acsch(float x) { return    log((1.+sqrt(1.+x*x))/x); }\n";
                            mShaderHeaderLines[0] += 26;
                        }

                        //-------------------------------------------------------

                        mShaderHeader[1] = "";
                        mShaderHeaderLines[1] = 0;
                        if( mIs20 ) 
                        { 
                            mShaderHeader[1] += "#version 300 es\n"+
                                                "#ifdef GL_ES\n"+
                                                "precision highp float;\n"+
                                                "precision highp int;\n"+
                                                "precision mediump sampler3D;\n"+
                                                "#endif\n"; 
                            mShaderHeaderLines[1] += 6;
                        }
                        else
                        {
                            if( mDerivatives ) { mShaderHeader[1] += "#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n"; mShaderHeaderLines[1]+=3; }
                            if( mShaderTextureLOD  ) { mShaderHeader[1] += "#extension GL_EXT_shader_texture_lod : enable\n"; mShaderHeaderLines[1]++; }
                            mShaderHeader[1] += "#ifdef GL_ES\n"+
                                                "precision highp float;\n"+
                                                "precision highp int;\n"+
                                                "#endif\n"+ 
                                                "vec4 texture(     sampler2D   s, vec2 c)                   { return texture2D(s,c); }\n"+
                                                "vec4 texture(     sampler2D   s, vec2 c, float b)          { return texture2D(s,c,b); }\n"+
                                                "vec4 texture(     samplerCube s, vec3 c )                  { return textureCube(s,c); }\n"+
                                                "vec4 texture(     samplerCube s, vec3 c, float b)          { return textureCube(s,c,b); }\n"+
                                                "float round( float x ) { return floor(x+0.5); }\n"+
                                                "vec2 round(vec2 x) { return floor(x + 0.5); }\n"+
                                                "vec3 round(vec3 x) { return floor(x + 0.5); }\n"+
                                                "vec4 round(vec4 x) { return floor(x + 0.5); }\n"+
                                                "float trunc( float x, float n ) { return floor(x*n)/n; }\n"+
                                                "mat3 transpose(mat3 m) { return mat3(m[0].x, m[1].x, m[2].x, m[0].y, m[1].y, m[2].y, m[0].z, m[1].z, m[2].z); }\n"+
                                                "float determinant( in mat2 m ) { return m[0][0]*m[1][1] - m[0][1]*m[1][0]; }\n"+
                                                "float determinant( mat4 m ) { float b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0], b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0], b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0], b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1], b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1], b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2], b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0], b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0], b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0], b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1], b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1], b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;}\n"+
                                                "mat2 inverse(mat2 m) { float det = determinant(m); return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / det; }\n"+
                                                "mat4 inverse(mat4 m ) { float inv0 = m[1].y*m[2].z*m[3].w - m[1].y*m[2].w*m[3].z - m[2].y*m[1].z*m[3].w + m[2].y*m[1].w*m[3].z + m[3].y*m[1].z*m[2].w - m[3].y*m[1].w*m[2].z; float inv4 = -m[1].x*m[2].z*m[3].w + m[1].x*m[2].w*m[3].z + m[2].x*m[1].z*m[3].w - m[2].x*m[1].w*m[3].z - m[3].x*m[1].z*m[2].w + m[3].x*m[1].w*m[2].z; float inv8 = m[1].x*m[2].y*m[3].w - m[1].x*m[2].w*m[3].y - m[2].x  * m[1].y * m[3].w + m[2].x  * m[1].w * m[3].y + m[3].x * m[1].y * m[2].w - m[3].x * m[1].w * m[2].y; float inv12 = -m[1].x  * m[2].y * m[3].z + m[1].x  * m[2].z * m[3].y +m[2].x  * m[1].y * m[3].z - m[2].x  * m[1].z * m[3].y - m[3].x * m[1].y * m[2].z + m[3].x * m[1].z * m[2].y; float inv1 = -m[0].y*m[2].z * m[3].w + m[0].y*m[2].w * m[3].z + m[2].y  * m[0].z * m[3].w - m[2].y  * m[0].w * m[3].z - m[3].y * m[0].z * m[2].w + m[3].y * m[0].w * m[2].z; float inv5 = m[0].x  * m[2].z * m[3].w - m[0].x  * m[2].w * m[3].z - m[2].x  * m[0].z * m[3].w + m[2].x  * m[0].w * m[3].z + m[3].x * m[0].z * m[2].w - m[3].x * m[0].w * m[2].z; float inv9 = -m[0].x  * m[2].y * m[3].w +  m[0].x  * m[2].w * m[3].y + m[2].x  * m[0].y * m[3].w - m[2].x  * m[0].w * m[3].y - m[3].x * m[0].y * m[2].w + m[3].x * m[0].w * m[2].y; float inv13 = m[0].x  * m[2].y * m[3].z - m[0].x  * m[2].z * m[3].y - m[2].x  * m[0].y * m[3].z + m[2].x  * m[0].z * m[3].y + m[3].x * m[0].y * m[2].z - m[3].x * m[0].z * m[2].y; float inv2 = m[0].y  * m[1].z * m[3].w - m[0].y  * m[1].w * m[3].z - m[1].y  * m[0].z * m[3].w + m[1].y  * m[0].w * m[3].z + m[3].y * m[0].z * m[1].w - m[3].y * m[0].w * m[1].z; float inv6 = -m[0].x  * m[1].z * m[3].w + m[0].x  * m[1].w * m[3].z + m[1].x  * m[0].z * m[3].w - m[1].x  * m[0].w * m[3].z - m[3].x * m[0].z * m[1].w + m[3].x * m[0].w * m[1].z; float inv10 = m[0].x  * m[1].y * m[3].w - m[0].x  * m[1].w * m[3].y - m[1].x  * m[0].y * m[3].w + m[1].x  * m[0].w * m[3].y + m[3].x * m[0].y * m[1].w - m[3].x * m[0].w * m[1].y; float inv14 = -m[0].x  * m[1].y * m[3].z + m[0].x  * m[1].z * m[3].y + m[1].x  * m[0].y * m[3].z - m[1].x  * m[0].z * m[3].y - m[3].x * m[0].y * m[1].z + m[3].x * m[0].z * m[1].y; float inv3 = -m[0].y * m[1].z * m[2].w + m[0].y * m[1].w * m[2].z + m[1].y * m[0].z * m[2].w - m[1].y * m[0].w * m[2].z - m[2].y * m[0].z * m[1].w + m[2].y * m[0].w * m[1].z; float inv7 = m[0].x * m[1].z * m[2].w - m[0].x * m[1].w * m[2].z - m[1].x * m[0].z * m[2].w + m[1].x * m[0].w * m[2].z + m[2].x * m[0].z * m[1].w - m[2].x * m[0].w * m[1].z; float inv11 = -m[0].x * m[1].y * m[2].w + m[0].x * m[1].w * m[2].y + m[1].x * m[0].y * m[2].w - m[1].x * m[0].w * m[2].y - m[2].x * m[0].y * m[1].w + m[2].x * m[0].w * m[1].y; float inv15 = m[0].x * m[1].y * m[2].z - m[0].x * m[1].z * m[2].y - m[1].x * m[0].y * m[2].z + m[1].x * m[0].z * m[2].y + m[2].x * m[0].y * m[1].z - m[2].x * m[0].z * m[1].y; float det = m[0].x * inv0 + m[0].y * inv4 + m[0].z * inv8 + m[0].w * inv12; det = 1.0 / det; return det*mat4( inv0, inv1, inv2, inv3,inv4, inv5, inv6, inv7,inv8, inv9, inv10, inv11,inv12, inv13, inv14, inv15);}\n"+
                                                "float sinh(float x)  { return (exp(x)-exp(-x))/2.; }\n"+
                                                "float cosh(float x)  { return (exp(x)+exp(-x))/2.; }\n"+
                                                "float tanh(float x)  { return sinh(x)/cosh(x); }\n"+
                                                "float coth(float x)  { return cosh(x)/sinh(x); }\n"+
                                                "float sech(float x)  { return 1./cosh(x); }\n"+
                                                "float csch(float x)  { return 1./sinh(x); }\n"+
                                                "float asinh(float x) { return    log(x+sqrt(x*x+1.)); }\n"+
                                                "float acosh(float x) { return    log(x+sqrt(x*x-1.)); }\n"+
                                                "float atanh(float x) { return .5*log((1.+x)/(1.-x)); }\n"+
                                                "float acoth(float x) { return .5*log((x+1.)/(x-1.)); }\n"+
                                                "float asech(float x) { return    log((1.+sqrt(1.-x*x))/x); }\n"+
                                                "float acsch(float x) { return    log((1.+sqrt(1.+x*x))/x); }\n";
                            mShaderHeaderLines[1] += 30;
                            if( mShaderTextureLOD )
                            {
                            mShaderHeader[1] += "vec4 textureLod(  sampler2D   s, vec2 c, float b)          { return texture2DLodEXT(s,c,b); }\n";
                            mShaderHeader[1] += "vec4 textureGrad( sampler2D   s, vec2 c, vec2 dx, vec2 dy) { return texture2DGradEXT(s,c,dx,dy); }\n";
                            mShaderHeaderLines[1] += 2;

                            //mShaderHeader[1] += "vec4 texelFetch( sampler2D s, ivec2 c, int l) { return texture2DLodEXT(s,(vec2(c)+0.5)/vec2(800,450),float(l)); }\n";
                            //mShaderHeaderLines[1] += 1;
                            }
                        }

                        return true;
                    };

        me.GetCaps =    function ()
                        {   
                            return { mIsGL20 : mIs20,
                                     mFloat32Textures: mFloat32Textures != null,
                                     mFloat16Textures: mFloat16Textures != null,
                                     mDrawBuffers: mDrawBuffers != null,
                                     mDepthTextures: mDepthTextures != null,
                                     mDerivatives: mDerivatives != null,
                                     mShaderTextureLOD: mShaderTextureLOD != null };
                        };

        me.GetShaderHeaderLines = function (shaderType)
                        {   
                            return mShaderHeaderLines[shaderType];
                        };

        me.CheckErrors = function()
                         {
                                var error = mGL.getError();
                                if( error != mGL.NO_ERROR ) 
                                { 
                                    for( var prop in mGL ) 
                                    {
                                        if( typeof mGL[prop] == 'number' ) 
                                        {
                                            if( mGL[prop] == error )
                                            {
                                                console.log( "GL Error " + error + ": " + prop );
                                                break;
                                            }
                                        }
                                    }
                                }
                         };

        me.Clear =  function( flags, ccolor, cdepth, cstencil )
                    {
                        var mode = 0;
                        if( flags & 1 ) { mode |= mGL.COLOR_BUFFER_BIT;   mGL.clearColor( ccolor[0], ccolor[1], ccolor[2], ccolor[3] ); }
                        if( flags & 2 ) { mode |= mGL.DEPTH_BUFFER_BIT;   mGL.clearDepth( cdepth ); }
                        if( flags & 4 ) { mode |= mGL.STENCIL_BUFFER_BIT; mGL.clearStencil( cstencil ); }
                        mGL.clear( mode );
                    };


        me.CreateTexture = function ( type, xres, yres, format, filter, wrap, buffer)
                           {
                                if( mGL===null ) return null;

                                var id = mGL.createTexture();

                                var glFoTy = iFormatPI2GL( format );
                                var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                if( type===me.TEXTYPE.T2D )
                                {
                                    mGL.bindTexture( mGL.TEXTURE_2D, id );
//if( buffer==null )
    //mGL.texStorage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, xres, yres);
//else
                                    mGL.texImage2D( mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texParameteri( mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap );
                                    mGL.texParameteri( mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap );

                                    if (filter === me.FILTER.NONE)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }

                                    mGL.bindTexture( mGL.TEXTURE_2D, null );
                                }
                                else if( type===me.TEXTYPE.T3D )
                                {
                                    if( mIs20 )
                                    {
                                        mGL.bindTexture( mGL.TEXTURE_3D, id );
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_BASE_LEVEL, 0);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAX_LEVEL, Math.log2(xres));
                                        if (filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                        }
                                        else if (filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        }
                                        else
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_3D);
                                        }
                                        mGL.texImage3D( mGL.TEXTURE_3D, 0, glFoTy.mGLFormat, xres, yres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );

                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_R, glWrap );
                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_S, glWrap );
                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_T, glWrap );

                                        if (filter === me.FILTER.MIPMAP)
                                            mGL.generateMipmap( mGL.TEXTURE_3D );
                                        mGL.bindTexture( mGL.TEXTURE_3D, null );
                                    }
                                    else 
                                    {
                                        return null;
                                    }
                                }
                                else 
                                {
                                    mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );

                                    // this works great if we know the number of required mipmaps in advance (1, or other)
                                   //mGL.texStorage2D( mGL.TEXTURE_CUBE_MAP, 1, glFoTy.mGLFormat, xres, yres );

                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );

                                    if( filter === me.FILTER.NONE)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR)
                                    {
                                        mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR );
                                        mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR );
                                    }
                                    else if (filter === me.FILTER.MIPMAP)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                    }

                                    if (filter === me.FILTER.MIPMAP)
                                        mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );

                                    mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                }
                        return { mObjectID: id, mXres: xres, mYres: yres, mFormat: format, mType: type, mFilter: filter, mWrap: wrap, mVFlip:false };
                        };

        me.CreateTextureFromImage = function ( type, image, format, filter, wrap, flipY) 
                                {
                                    if( mGL===null ) return null;

                                    var id = mGL.createTexture();

                                    var glFoTy = iFormatPI2GL( format );

                                    var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                    if( type===me.TEXTYPE.T2D )
                                    {
                                        mGL.bindTexture(mGL.TEXTURE_2D, id);

                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, flipY);
                                        mGL.pixelStorei(mGL.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                                        if( mIs20 ) mGL.pixelStorei(mGL.UNPACK_COLORSPACE_CONVERSION_WEBGL, mGL.NONE );

                                        mGL.texImage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image);

                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap);

                                        if (filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                        }
                                        else if( filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_2D);
                                        }
                                        else
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_2D);
                                        }
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                        mGL.bindTexture(mGL.TEXTURE_2D, null);
                                    }
                                    else if( type===me.TEXTYPE.T3D )
                                    {
                                        return null;
                                    }
                                    else 
                                    {
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, flipY);
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[0] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[1] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (flipY ? image[3] : image[2]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (flipY ? image[2] : image[3]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[4] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[5] );

                                        if( filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR );
                                            mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR );
                                        }
                                        else if (filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                            mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );
                                        }
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                    }
                                    return { mObjectID: id, mXres: image.width, mYres: image.height, mFormat: format, mType: type, mFilter: filter, mWrap:wrap, mVFlip:flipY };
                                };

        me.SetSamplerFilter = function (te, filter, doGenerateMipsIfNeeded) 
                            {
                                if (te.mFilter === filter) return;

                                if (te.mType === me.TEXTYPE.T2D) 
                                {
                                    mGL.bindTexture(mGL.TEXTURE_2D, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_2D, null);

                                }
                                else if (te.mType === me.TEXTYPE.T3D) 
                                {
                                    mGL.bindTexture(mGL.TEXTURE_3D, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_3D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_3D);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_3D, null);

                                }
                                else
                                {
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_CUBE_MAP);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_CUBE_MAP);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                                }


                                te.mFilter = filter;
                            };

        me.SetSamplerWrap = function (te, wrap)
                            {
                                if (te.mWrap === wrap) return;

                                var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                var id = te.mObjectID;

                                if (te.mType === me.TEXTYPE.T2D)
                                {
                                    mGL.bindTexture(mGL.TEXTURE_2D, id);
                                    mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap);
                                    mGL.bindTexture(mGL.TEXTURE_2D, null);

                                }
                                else if (te.mType === me.TEXTYPE.T3D)
                                {
                                    mGL.bindTexture(mGL.TEXTURE_3D, id);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_R, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_S, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_T, glWrap);
                                    mGL.bindTexture(mGL.TEXTURE_3D, null);
                                }

                                te.mWrap = wrap;
                            };

        me.SetSamplerVFlip = function (te, vflip, image)
                            {
                                if (te.mVFlip === vflip) return;

                                var id = te.mObjectID;

                                if (te.mType === me.TEXTYPE.T2D)
                                {
                                    if( image != null)
                                    {
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture(mGL.TEXTURE_2D, id);
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, vflip);
                                        var glFoTy = iFormatPI2GL( te.mFormat );
                                        mGL.texImage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image);
                                        mGL.bindTexture(mGL.TEXTURE_2D, null);
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
                                }
                                else if (te.mType === me.TEXTYPE.CUBEMAP)
                                {
                                    if( image != null)
                                    {
                                        var glFoTy = iFormatPI2GL( te.mFormat );
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );
                                        mGL.pixelStorei( mGL.UNPACK_FLIP_Y_WEBGL, vflip);
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[0] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[1] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (vflip ? image[3] : image[2]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (vflip ? image[2] : image[3]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[4] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[5] );
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
        
                                }

                                te.mVFlip = vflip;
                            };

        me.CreateMipmaps =  function (te)
                            {
                                if( te.mType===me.TEXTYPE.T2D )
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                    mGL.bindTexture(mGL.TEXTURE_2D, te.mObjectID);
                                    mGL.generateMipmap(mGL.TEXTURE_2D);
                                    mGL.bindTexture(mGL.TEXTURE_2D, null);
                                }
                                else if( te.mType===me.TEXTYPE.CUBEMAP )
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, te.mObjectID);
                                    mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                                }
                            };

        me.UpdateTexture =  function( tex, x0, y0, xres, yres, buffer )
                            {
                                var glFoTy = iFormatPI2GL( tex.mFormat );
                                if( tex.mType===me.TEXTYPE.T2D )
                                {
                                    mGL.activeTexture( mGL.TEXTURE0);
                                    mGL.bindTexture( mGL.TEXTURE_2D, tex.mObjectID );
                                    mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, tex.mVFlip );
                                    mGL.texSubImage2D( mGL.TEXTURE_2D, 0, x0, y0, xres, yres, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.bindTexture( mGL.TEXTURE_2D, null );
                                    mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                }
                            };

        me.UpdateTextureFromImage = function( tex, image )
                                {
                                    var glFoTy = iFormatPI2GL( tex.mFormat );
                                    if( tex.mType===me.TEXTYPE.T2D )
                                    {
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture( mGL.TEXTURE_2D, tex.mObjectID );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, tex.mVFlip );
                                        mGL.texImage2D(  mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image );
                                        mGL.bindTexture( mGL.TEXTURE_2D, null );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
                                };

        me.DestroyTexture = function( te )
                            {
                                 mGL.deleteTexture( te.mObjectID );
                            };

        me.AttachTextures = function (num, t0, t1, t2, t3) 
                            {
                                if (num > 0 && t0 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                         if (t0.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t0.mObjectID);
                                    else if (t0.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t0.mObjectID);
                                    else if (t0.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t0.mObjectID);
                                }

                                if (num > 1 && t1 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE1);
                                         if (t1.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t1.mObjectID);
                                    else if (t1.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t1.mObjectID);
                                    else if (t1.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t1.mObjectID);
                                }

                                if (num > 2 && t2 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE2);
                                         if (t2.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t2.mObjectID);
                                    else if (t2.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t2.mObjectID);
                                    else if (t2.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t2.mObjectID);
                                }

                                if (num > 3 && t3 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE3);
                                         if (t3.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t3.mObjectID);
                                    else if (t3.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t3.mObjectID);
                                    else if (t3.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t3.mObjectID);
                                }
                            };

        me.DettachTextures = function()
                             {
                                mGL.activeTexture(mGL.TEXTURE0);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE1);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE2);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE3);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                             };

        me.CreateRenderTarget = function ( color0, color1, color2, color3, depth, wantZbuffer )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if (depth === null)
                                    {
                                        if( wantZbuffer===true )
                                        {
                                            var zb = mGL.createRenderbuffer();
                                            mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);
                                            mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, color0.mXres, color0.mYres);

                                            mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                        }
                                    }
                                    else
                                    {
                                        mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.TEXTURE_2D, depth.mObjectID, 0);
                                    }

                                    if( color0 !=null ) mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_2D, color0.mObjectID, 0);

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                        return null;

                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mTex0: color0 };
                                };

        me.DestroyRenderTarget = function ( tex )
                                 {
                                     mGL.deleteFramebuffer(tex.mObjectID);
                                 };

        me.SetRenderTarget = function (tex)
                             {
                                if( tex===null )
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                else
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, tex.mObjectID);

                                //mGL.drawBuffers([mGL.COLOR_ATTACHMENT0, mGL.COLOR_ATTACHMENT1]);
                             };

        me.CreateRenderTargetNew = function ( wantColor0, wantZbuffer, xres, yres, samples )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if( wantZbuffer===true )
                                    {
                                        var zb = mGL.createRenderbuffer();
                                        mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);

                                        if( samples==1 )
                                        mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, xres, yres);
                                        else
                                        mGL.renderbufferStorageMultisample(mGL.RENDERBUFFER, samples, mGL.DEPTH_COMPONENT16, xres, yres);
                                        mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                    }

                                    if( wantColor0 )
                                    {
                                        var cb = mGL.createRenderbuffer();
                                        mGL.bindRenderbuffer(mGL.RENDERBUFFER, cb);
                                        if( samples==1 )
                                        mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.RGBA8, xres, yres);
                                        else
                                        mGL.renderbufferStorageMultisample(mGL.RENDERBUFFER, samples, mGL.RGBA8, xres, yres);
                                        mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.RENDERBUFFER, cb);
                                    }

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                    {
                                        return null;
                                    }
                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mXres: xres, mYres:yres, mTex0: color0 };
                                };

        me.CreateRenderTargetCubeMap = function ( color0, depth, wantZbuffer )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if (depth === null)
                                    {
                                        if( wantZbuffer===true )
                                        {
                                            var zb = mGL.createRenderbuffer();
                                            mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);
                                            mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, color0.mXres, color0.mYres);
                                            mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                        }
                                    }
                                    else
                                    {
                                        mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.TEXTURE_2D, depth.mObjectID, 0);
                                    }

                                    if( color0 !=null ) mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_CUBE_MAP_POSITIVE_X, color0.mObjectID, 0);

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                        return null;

                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mTex0: color0 };
                                };

        me.SetRenderTargetCubeMap = function (fbo, face)
                             {
                                if( fbo===null )
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                else
                                {
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, fbo.mObjectID);
                                    mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_CUBE_MAP_POSITIVE_X+face, fbo.mTex0.mObjectID, 0);
                                }
                             };


        me.BlitRenderTarget = function( dst, src )
                                {
                                    mGL.bindFramebuffer(mGL.READ_FRAMEBUFFER, src.mObjectID);
                                    mGL.bindFramebuffer(mGL.DRAW_FRAMEBUFFER, dst.mObjectID);
                                    mGL.clearBufferfv(mGL.COLOR, 0, [0.0, 0.0, 0.0, 1.0]);
                                    mGL.blitFramebuffer( 0, 0, src.mXres, src.mYres,
                                                         0, 0, src.mXres, src.mYres,
                                                         mGL.COLOR_BUFFER_BIT, mGL.LINEAR
                                    );
                                };

        me.SetViewport = function( vp )
                         {
                              mGL.viewport( vp[0], vp[1], vp[2], vp[3] );
                         };

        me.SetWriteMask = function( c0, c1, c2, c3, z )
                          {
                              mGL.depthMask(z);
                              mGL.colorMask(c0,c0,c0,c0);
                          };

        me.SetState = function( stateName, stateValue )
                      {
                            if (stateName === me.RENDSTGATE.WIREFRAME)
                            {
                                if( stateValue ) mGL.polygonMode( mGL.FRONT_AND_BACK, mGL.LINE );
                                else             mGL.polygonMode( mGL.FRONT_AND_BACK, mGL.FILL );
                            }
                            else if (stateName === me.RENDSTGATE.FRONT_FACE)
                            {
                                if( stateValue ) mGL.cullFace( mGL.BACK );
                                else             mGL.cullFace( mGL.FRONT );
                            }
                            else if (stateName === me.RENDSTGATE.CULL_FACE)
                            {
                                if( stateValue ) mGL.enable( mGL.CULL_FACE );
                                else             mGL.disable( mGL.CULL_FACE );
                            }
                            else if (stateName === me.RENDSTGATE.DEPTH_TEST)
                            {
                                if( stateValue ) mGL.enable( mGL.DEPTH_TEST );
                                else             mGL.disable( mGL.DEPTH_TEST );
                            }
                            else if (stateName === me.RENDSTGATE.ALPHA_TO_COVERAGE)
                            {
                                if( stateValue ) { mGL.enable(  mGL.SAMPLE_ALPHA_TO_COVERAGE ); }
                                else             { mGL.disable( mGL.SAMPLE_ALPHA_TO_COVERAGE ); }
                            }
                      };

        me.SetMultisample = function( v)
                    {
                        if( v===true )
                        {
                            mGL.enable(mGL.SAMPLE_COVERAGE);
                            mGL.sampleCoverage(1.0, false);
                        }
                        else
                        {
                            mGL.disable(mGL.SAMPLE_COVERAGE);
                        }
                    };

        me.GetTranslatedShaderSource = function (shader) 
                          {
                            if( mGL===null ) return null;
                            if( mDebugShader===null ) return null;
                            let vfs = mGL.getAttachedShaders(shader.mProgram);
                            let str = mDebugShader.getTranslatedShaderSource(vfs[1]);
                            let parts = str.split("GLSL END"); str = (parts.length<2) ? str : parts[1];
                            return str;
                          };

        me.CreateShader = function (vsSource, fsSource, preventCache, forceSynch, onResolve) 
                          {
                            if( mGL===null ) return;

                            var vs = mGL.createShader( mGL.VERTEX_SHADER   );
                            var fs = mGL.createShader( mGL.FRAGMENT_SHADER );

                            vsSource = mShaderHeader[0] + vsSource;
                            fsSource = mShaderHeader[1] + fsSource;

                            if( preventCache )
                            {
                                let vran = Math.random().toString(36).substring(7);
                                let fran = Math.random().toString(36).substring(7);
                                vsSource += "\n#define K" + vran + "\n";
                                fsSource += "\n#define K" + fran + "\n";
                            }

                            var timeStart = getRealTime();

                            mGL.shaderSource(vs, vsSource);
                            mGL.shaderSource(fs, fsSource);
                            mGL.compileShader(vs);
                            mGL.compileShader(fs);

                            var pr = mGL.createProgram();
                            mGL.attachShader(pr, vs);
                            mGL.attachShader(pr, fs);
                            mGL.linkProgram(pr);

                            //-------------
                            let checkErrors = function()
                            {
                                if (!mGL.getProgramParameter(pr, mGL.LINK_STATUS))
                                {
                                    // vs error
                                    if (!mGL.getShaderParameter(vs, mGL.COMPILE_STATUS))
                                    {
                                        let vsLog = mGL.getShaderInfoLog(vs);
                                        onResolve(false, { mErrorType: 0, mErrorStr: vsLog });
                                        mGL.deleteProgram(pr);
                                    }
                                    // fs error
                                    else if (!mGL.getShaderParameter(fs, mGL.COMPILE_STATUS))
                                    {
                                        let fsLog = mGL.getShaderInfoLog(fs);
                                        onResolve(false, { mErrorType: 1, mErrorStr: fsLog });
                                        mGL.deleteProgram(pr);
                                    }
                                    // link error
                                    else
                                    {
                                        let infoLog = mGL.getProgramInfoLog(pr);
                                        onResolve(false, { mErrorType: 2, mErrorStr: infoLog });
                                        mGL.deleteProgram(pr);
                                    }
                                }
                                // no errors
                                else
                                {
                                    let compilationTime = getRealTime() - timeStart;
                                    onResolve(true, { mProgram: pr, mTime: compilationTime });
                                }
                            };

                            // check compilation
                            if (mAsynchCompile === null || forceSynch===true )
                            {
                                checkErrors();
                            }
                            else
                            {
                                let loopCheckCompletion = function ()
                                {
                                    if( mGL.getProgramParameter(pr, mAsynchCompile.COMPLETION_STATUS_KHR) === true )
                                        checkErrors();
                                    else
                                        setTimeout(loopCheckCompletion, 10);
                                };
                                setTimeout(loopCheckCompletion, 10);
                            }
                        };

        me.AttachShader = function( shader )
                          {
                                if( shader===null )
                                {
                                    mBindedShader = null;
                                    mGL.useProgram( null );
                                }
                                else
                                {
                                    mBindedShader = shader;
                                    mGL.useProgram(shader.mProgram);
                                }
                          };

        me.DetachShader = function ()
                        {
                            mGL.useProgram(null);
                        };

        me.DestroyShader = function( tex )
                        {
                            mGL.deleteProgram(tex.mProgram);
                        };

        me.GetAttribLocation = function (shader, name)
                        {
                            return mGL.getAttribLocation(shader.mProgram, name);
                        };

        me.SetShaderConstantLocation = function (shader, name)
                        {
                            return mGL.getUniformLocation(shader.mProgram, name);
                        };

        me.SetShaderConstantMat4F = function( uname, params, istranspose )
                        {
                            var program = mBindedShader;

                            let pos = mGL.getUniformLocation( program.mProgram, uname );
                            if( pos===null )
                                return false;

                            if( istranspose===false )
                            {
                                var tmp = new Float32Array( [ params[0], params[4], params[ 8], params[12],
                                                              params[1], params[5], params[ 9], params[13],
                                                              params[2], params[6], params[10], params[14],
                                                              params[3], params[7], params[11], params[15] ] );
	                            mGL.uniformMatrix4fv(pos,false,tmp);
                            }
                            else
                                mGL.uniformMatrix4fv(pos,false,new Float32Array(params) );
                            return true;
                        };

        me.SetShaderConstant1F_Pos = function(pos, x)
                        {
                            mGL.uniform1f(pos, x);
                            return true;
                        };

        me.SetShaderConstant1FV_Pos = function(pos, x)
                        {
                            mGL.uniform1fv(pos, x);
                            return true;
                        };

        me.SetShaderConstant1F = function( uname, x )
                        {
                            var pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1f(pos, x);
                            return true;
                        };

        me.SetShaderConstant1I = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1i(pos, x);
                            return true;
                        };
        me.SetShaderConstant1I_Pos = function(pos, x)
                        {
                            mGL.uniform1i(pos, x);
                            return true;
                        };


        me.SetShaderConstant2F = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform2fv(pos, x);
                            return true;
                        };

        me.SetShaderConstant3F = function(uname, x, y, z)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform3f(pos, x, y, z);
                            return true;
                        };

        me.SetShaderConstant1FV = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1fv(pos, new Float32Array(x));
                            return true;
                        };

        me.SetShaderConstant3FV = function(uname, x) 
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform3fv(pos, new Float32Array(x) );
                            return true;
                        };

        me.SetShaderConstant4FV = function(uname, x) 
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform4fv(pos, new Float32Array(x) );
                            return true;
                        };

        me.SetShaderTextureUnit = function( uname, unit )
                        {
                            var program = mBindedShader;
                            let pos = mGL.getUniformLocation(program.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform1i(pos, unit);
                            return true;
                        };

        me.CreateVertexArray = function( data, mode )
                        {
                            let id = mGL.createBuffer();
                            mGL.bindBuffer(mGL.ARRAY_BUFFER, id);
                            if (mode === me.BUFTYPE.STATIC)
                                mGL.bufferData(mGL.ARRAY_BUFFER, data, mGL.STATIC_DRAW);
                            else
                                mGL.bufferData(mGL.ARRAY_BUFFER, data, mGL.DYNAMIC_DRAW);
                            return { mObject: id };
                        };

        me.CreateIndexArray = function( data, mode )
                        {
                            let id = mGL.createBuffer();
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, id );
                            if (mode === me.BUFTYPE.STATIC)
                                mGL.bufferData(mGL.ELEMENT_ARRAY_BUFFER, data, mGL.STATIC_DRAW);
                            else
                                mGL.bufferData(mGL.ELEMENT_ARRAY_BUFFER, data, mGL.DYNAMIC_DRAW);
                            return { mObject: id };
                        };

        me.DestroyArray = function( tex )
                        {
                            mGL.destroyBuffer(tex.mObject);
                        };

        me.AttachVertexArray = function( tex, attribs, pos )
                        {
                            let shader = mBindedShader;

                            mGL.bindBuffer( mGL.ARRAY_BUFFER, tex.mObject);

                            var num = attribs.mChannels.length;
                            var stride = attribs.mStride;

                            var offset = 0;
                            for (var i = 0; i < num; i++)
                            {
                                var id = pos[i];
                                mGL.enableVertexAttribArray(id);
                                var dtype = mGL.FLOAT;
                                var dsize = 4;
                                     if( attribs.mChannels[i].mType === me.TYPE.UINT8   ) { dtype = mGL.UNSIGNED_BYTE;  dsize = 1; }
                                else if( attribs.mChannels[i].mType === me.TYPE.UINT16  ) { dtype = mGL.UNSIGNED_SHORT; dsize = 2; }
                                else if( attribs.mChannels[i].mType === me.TYPE.FLOAT32 ) { dtype = mGL.FLOAT;          dsize = 4; }
                                mGL.vertexAttribPointer(id, attribs.mChannels[i].mNumComponents, dtype, attribs.mChannels[i].mNormalize, stride, offset);
                                offset += attribs.mChannels[i].mNumComponents * dsize;
                            }
                        };

        me.AttachIndexArray = function( tex )
                        {
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, tex.mObject);
                        };

        me.DetachVertexArray = function (tex, attribs)
                        {
                            let num = attribs.mChannels.length;
                            for (let i = 0; i < num; i++)
                                mGL.disableVertexAttribArray(i);
                            mGL.bindBuffer(mGL.ARRAY_BUFFER, null);
                        };

        me.DetachIndexArray = function( tex )
                        {
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, null);
                        };

        me.DrawPrimitive = function( typeOfPrimitive, num, useIndexArray, numInstances )
                        {
                            let glType = mGL.POINTS;
                            if( typeOfPrimitive===me.PRIMTYPE.POINTS ) glType = mGL.POINTS;
                            if( typeOfPrimitive===me.PRIMTYPE.LINES ) glType = mGL.LINES;
                            if( typeOfPrimitive===me.PRIMTYPE.LINE_LOOP ) glType = mGL.LINE_LOOP;
                            if( typeOfPrimitive===me.PRIMTYPE.LINE_STRIP ) glType = mGL.LINE_STRIP;
                            if( typeOfPrimitive===me.PRIMTYPE.TRIANGLES ) glType = mGL.TRIANGLES;
                            if( typeOfPrimitive===me.PRIMTYPE.TRIANGLE_STRIP ) glType = mGL.TRIANGLE_STRIP;

                            if( numInstances<=1 )
                            {
  	                            if( useIndexArray ) mGL.drawElements( glType, num, mGL.UNSIGNED_SHORT, 0 );
	                            else                mGL.drawArrays( glType, 0, num );
                            }
                            else
                            {
                                mGL.drawArraysInstanced(glType, 0, num, numInstances);
                                mGL.drawElementsInstanced( glType, num, mGL.UNSIGNED_SHORT, 0, numInstances);
                            }
                        };


        me.DrawFullScreenTriangle_XY = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Tri );
                            mGL.vertexAttribPointer( vpos, 2, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays( mGL.TRIANGLES, 0, 3 );
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        };


        me.DrawUnitQuad_XY = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Quad );
                            mGL.vertexAttribPointer( vpos, 2, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays( mGL.TRIANGLES, 0, 6 );
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        };

        me.DrawUnitCube_XYZ_NOR = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePosNor );
                            mGL.vertexAttribPointer( vpos[0], 3, mGL.FLOAT, false, 0, 0 );
                            mGL.vertexAttribPointer( vpos[1], 3, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos[0] );
                            mGL.enableVertexAttribArray( vpos[1] );
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 0, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 4, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 8, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 12, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 16, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 20, 4);
                            mGL.disableVertexAttribArray( vpos[0] );
                            mGL.disableVertexAttribArray( vpos[1] );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        }

        me.DrawUnitCube_XYZ = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePos );
                            mGL.vertexAttribPointer( vpos, 3, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 0, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 4, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 8, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 12, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 16, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 20, 4);
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        }

        me.SetBlend = function( enabled )
                    {
                        if( enabled )
                        {
                            mGL.enable( mGL.BLEND );
                            mGL.blendEquationSeparate( mGL.FUNC_ADD, mGL.FUNC_ADD );
                            mGL.blendFuncSeparate( mGL.SRC_ALPHA, mGL.ONE_MINUS_SRC_ALPHA, mGL.ONE, mGL.ONE_MINUS_SRC_ALPHA );
                        }
                        else
                        {
                            mGL.disable( mGL.BLEND );
                        }
                    };

        me.GetPixelData = function( data, offset, xres, yres )
                        {
                            mGL.readPixels(0, 0, xres, yres, mGL.RGBA, mGL.UNSIGNED_BYTE, data, offset);
                        };

        me.GetPixelDataRenderTarget = function( obj, data, xres, yres )
                        {
                            mGL.bindFramebuffer(mGL.FRAMEBUFFER, obj.mObjectID);
                            mGL.readBuffer(mGL.COLOR_ATTACHMENT0);
                            mGL.readPixels(0, 0, xres, yres, mGL.RGBA, mGL.FLOAT, data, 0);
                            mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                        };
    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piShading
//
//==============================================================================

function smoothstep(a, b, x)
{
    x = (x - a) / (b - a);
    if (x < 0) x = 0; else if (x > 1) x = 1;
    return x * x * (3.0 - 2.0 * x);
}

function clamp01(x)
{
    if( x < 0.0 ) x = 0.0;
    if( x > 1.0 ) x = 1.0;
    return x;
}

function clamp(x, a, b)
{
    if( x < a ) x = a;
    if( x > b ) x = b;
    return x;
}

function screen(a, b)
{
    return 1.0 - (1.0 - a) * (1.0 - b);
}

function parabola(x)
{
    return 4.0 * x * (1.0 - x);
}

function min(a, b)
{
    return (a < b) ? a : b;
}

function max(a, b)
{
    return (a > b) ? a : b;
}

function noise( x )
{
    function grad(i, j, x, y)
    {
        var h = 7 * i + 131 * j;
        h = (h << 13) ^ h;
        h = (h * (h * h * 15731 + 789221) + 1376312589);

        var rx = (h & 0x20000000) ? x : -x;
        var ry = (h & 0x10000000) ? y : -y;

        return rx + ry;
    }

    var i = [ Math.floor(x[0]), Math.floor(x[1]) ];
    var f = [ x[0] - i[0], x[1] - i[1] ];
    var w = [ f[0]*f[0]*(3.0-2.0*f[0]), f[1]*f[1]*(3.0-2.0*f[1]) ];

    var a = grad( i[0]+0, i[1]+0, f[0]+0.0, f[1]+0.0 );
    var b = grad( i[0]+1, i[1]+0, f[0]-1.0, f[1]+0.0 );
    var c = grad( i[0]+0, i[1]+1, f[0]+0.0, f[1]-1.0 );
    var d = grad( i[0]+1, i[1]+1, f[0]-1.0, f[1]-1.0 );

    return a + (b-a)*w[0] + (c-a)*w[1] + (a-b-c+d)*w[0]*w[1];
}//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piVecTypes
//
//==============================================================================


function vec3( a, b, c )
{
    return [ a, b, c ];
}

function add( a, b )
{
    return [ a[0]+b[0], a[1]+b[1], a[2]+b[2] ];
}

function sub( a, b )
{
    return [ a[0]-b[0], a[1]-b[1], a[2]-b[2] ];
}

function mul( a, s ) 
{
    return [ a[0]*s, a[1]*s, a[2]*s ];
}

function cross( a, b )
{
    return [ a[1]*b[2] - a[2]*b[1],
             a[2]*b[0] - a[0]*b[2],
             a[0]*b[1] - a[1]*b[0] ];
}

function dot( a, b ) 
{
    return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
}

function normalize( v ) 
{
    var is = 1.0 / Math.sqrt( v[0]*v[0] + v[1]*v[1] + v[2]*v[2] );
    return [ v[0]*is, v[1]*is, v[2]*is ];
}

function createCirclePoint( cen, uuu, vvv, rad, s, t )
{
    return [ cen[0] + rad*(uuu[0]*s + vvv[0]*t),
             cen[1] + rad*(uuu[1]*s + vvv[1]*t),
             cen[2] + rad*(uuu[2]*s + vvv[2]*t) ];
}

function createTangent( a, b, c )
{
    var cb = normalize( [ c[0]-b[0], c[1]-b[1], c[2]-b[2] ] );
    var ba = normalize( [ b[0]-a[0], b[1]-a[1], b[2]-a[2] ] );
    return normalize( [ ba[0]+cb[0], ba[1]+cb[1], ba[2]+cb[2] ] );

}

//===================================

function vec4( a, b, c, d )
{
    return [ a, b, c, d ];
}

function getXYZ( v )
{
    return [ v[0], v[1], v[2] ];
}

//===================================

function setIdentity()
{
    return [ 1.0, 0.0, 0.0, 0.0,
             0.0, 1.0, 0.0, 0.0,
             0.0, 0.0, 1.0, 0.0,
             0.0, 0.0, 0.0, 1.0 ];
}

function setRotationX( t )
{
    var sint = Math.sin(t);
    var cost = Math.cos(t);

    return [ 1.0,   0.0,   0.0, 0.0,
             0.0,  cost, -sint, 0.0, 
             0.0,  sint,  cost, 0.0,
             0.0,   0.0,   0.0, 1.0 ];
}

function setRotationY( t )
{
    var sint = Math.sin(t);
    var cost = Math.cos(t);

    return [ cost, 0.0, -sint, 0.0,
              0.0, 1.0,   0.0, 0.0, 
             sint, 0.0,  cost, 0.0,
              0.0, 0.0,   0.0, 1.0 ];
}

function extractRotationEuler( m)
{
    var res = [];
    if (m[0] == 1.0)
    {
        res[0] = Math.atan2(m[2], m[11]);
        res[1] = 0.0;
        res[2] = 0.0;

    }
    else if (m[0] == -1.0)
    {
        res[0] = Math.atan2( m[2], m[11]);
        res[1] = 0.0;
        res[2] = 0.0;
    }
    else
    {
        res[0] = Math.atan2( -m[9], m[10]);
        res[1] = Math.atan2( m[8], Math.sqrt(m[9]*m[9] + m[10]*m[10]));
        res[2] = Math.atan2( m[4], m[0]);
    }
    return res;
}

function setFromQuaternion( q )
{
    var ww = q[3]*q[3];
    var xx = q[0]*q[0];
    var yy = q[1]*q[1];
    var zz = q[2]*q[2];

    return [ ww+xx-yy-zz,                   2.0*(q[0]*q[1] - q[3]*q[2]), 2.0*(q[0]*q[2] + q[3]*q[1]), 0.0,
               2.0*(q[0]*q[1] + q[3]*q[2]),   ww-xx+yy-zz,                 2.0*(q[1]*q[2] - q[3]*q[0]), 0.0,
               2.0*(q[0]*q[2] - q[3]*q[1]),   2.0*(q[1]*q[2] + q[3]*q[0]), ww-xx-yy+zz,                 0.0,
               0.0,                           0.0,                         0.0,                         1.0 ];
}

function setPerspective( fovy, aspect, znear, zfar )
{
    var tan = Math.tan(fovy * Math.PI/180.0);
    var x = 1.0 / (tan*aspect);
    var y = 1.0 / (tan);
    var c = -(zfar + znear) / ( zfar - znear);
    var d = -(2.0 * zfar * znear) / (zfar - znear);

    return [ x,    0.0,  0.0,  0.0,
             0.0,  y,    0.0,  0.0,
             0.0,  0.0,  c,     d,
             0.0,  0.0, -1.0,  0.0 ];
}

function setLookAt( eye, tar, up )
{
    var dir = [ -tar[0]+eye[0], -tar[1]+eye[1], -tar[2]+eye[2] ];

	var m00 = dir[2]*up[1] - dir[1]*up[2]; 
    var m01 = dir[0]*up[2] - dir[2]*up[0];
    var m02 = dir[1]*up[0] - dir[0]*up[1];
    var im = 1.0/Math.sqrt( m00*m00 + m01*m01 + m02*m02 );
    m00 *= im;
    m01 *= im;
    m02 *= im;

	var m04 = m02*dir[1] - m01*dir[2]; 
    var m05 = m00*dir[2] - m02*dir[0];
    var m06 = m01*dir[0] - m00*dir[1];
    im = 1.0/Math.sqrt( m04*m04 + m05*m05 + m06*m06 );
    m04 *= im;
    m05 *= im;
    m06 *= im;

	var m08 = dir[0];
	var m09 = dir[1];
	var m10 = dir[2];
    im = 1.0/Math.sqrt( m08*m08 + m09*m09 + m10*m10 );
    m08 *= im;
    m09 *= im;
    m10 *= im;

	var m03 = -(m00*eye[0] + m01*eye[1] + m02*eye[2] );
	var m07 = -(m04*eye[0] + m05*eye[1] + m06*eye[2] );
	var m11 = -(m08*eye[0] + m09*eye[1] + m10*eye[2] );

    return [ m00, m01, m02, m03,
             m04, m05, m06, m07,
             m08, m09, m10, m11,
             0.0, 0.0, 0.0, 1.0 ];
}


function setOrtho( left, right, bottom, top, znear, zfar )
{
   var x = 2.0 / (right - left);
   var y = 2.0 / (top - bottom);
   var a = (right + left) / (right - left);
   var b = (top + bottom) / (top - bottom);
   var c = -2.0 / (zfar - znear);
   var d = -(zfar + znear) / ( zfar - znear);

   return [  x, 0.0, 0.0,   a,
           0.0,   y, 0.0,   b,
           0.0, 0.0,   c,   d,
           0.0, 0.0, 0.0, 1.0 ];
}

function setTranslation( p )
{
    return [ 1.0, 0.0, 0.0, p[0],
             0.0, 1.0, 0.0, p[1],
             0.0, 0.0, 1.0, p[2],
             0.0, 0.0, 0.0, 1.0 ];
}

function setScale( s )
{
    return [ s[0], 0.0,  0.0,  0.0,
             0.0,  s[1], 0.0,  0.0,
             0.0,  0.0,  s[2], 0.0,
             0.0,  0.0,  0.0,  1.0];
}

function setProjection( fov, znear, zfar )
{
    var x = 2.0 / (fov[3]+fov[2]);
    var y = 2.0 / (fov[0]+fov[1]);
    var a = (fov[3]-fov[2]) / (fov[3]+fov[2]);
    var b = (fov[0]-fov[1]) / (fov[0]+fov[1]);
    var c = -(zfar + znear) / ( zfar - znear);
    var d = -(2.0*zfar*znear) / (zfar - znear);
    return [   x, 0.0,    a, 0.0,
             0.0,   y,    b, 0.0,
             0.0, 0.0,    c,   d,
             0.0, 0.0, -1.0, 0.0 ];
   // inverse is:
   //return mat4x4( 1.0/x, 0.0f,  0.0f,   a/x,
   //               0.0f,  1.0/y, 0.0f,   b/x,
   //               0.0f,  0.0f,  0.0f,   -1.0,
   //               0.0f,  0.0f,  1.0f/d, c/d );
}


function invertFast( m )
{
    var inv = [
   
             m[5]  * m[10] * m[15] - 
             m[5]  * m[11] * m[14] - 
             m[9]  * m[6]  * m[15] + 
             m[9]  * m[7]  * m[14] +
             m[13] * m[6]  * m[11] - 
             m[13] * m[7]  * m[10],

             -m[1]  * m[10] * m[15] + 
              m[1]  * m[11] * m[14] + 
              m[9]  * m[2] * m[15] - 
              m[9]  * m[3] * m[14] - 
              m[13] * m[2] * m[11] + 
              m[13] * m[3] * m[10],

             m[1]  * m[6] * m[15] - 
             m[1]  * m[7] * m[14] - 
             m[5]  * m[2] * m[15] + 
             m[5]  * m[3] * m[14] + 
             m[13] * m[2] * m[7] - 
             m[13] * m[3] * m[6],

             -m[1] * m[6] * m[11] + 
              m[1] * m[7] * m[10] + 
              m[5] * m[2] * m[11] - 
              m[5] * m[3] * m[10] - 
              m[9] * m[2] * m[7] + 
              m[9] * m[3] * m[6],

             -m[4]  * m[10] * m[15] + 
              m[4]  * m[11] * m[14] + 
              m[8]  * m[6]  * m[15] - 
              m[8]  * m[7]  * m[14] - 
              m[12] * m[6]  * m[11] + 
              m[12] * m[7]  * m[10],

             m[0]  * m[10] * m[15] - 
             m[0]  * m[11] * m[14] - 
             m[8]  * m[2] * m[15] + 
             m[8]  * m[3] * m[14] + 
             m[12] * m[2] * m[11] - 
             m[12] * m[3] * m[10],

             -m[0]  * m[6] * m[15] + 
              m[0]  * m[7] * m[14] + 
              m[4]  * m[2] * m[15] - 
              m[4]  * m[3] * m[14] - 
              m[12] * m[2] * m[7] + 
              m[12] * m[3] * m[6],


             m[0] * m[6] * m[11] - 
             m[0] * m[7] * m[10] - 
             m[4] * m[2] * m[11] + 
             m[4] * m[3] * m[10] + 
             m[8] * m[2] * m[7] - 
             m[8] * m[3] * m[6],


             m[4]  * m[9] * m[15] - 
             m[4]  * m[11] * m[13] - 
             m[8]  * m[5] * m[15] + 
             m[8]  * m[7] * m[13] + 
             m[12] * m[5] * m[11] - 
             m[12] * m[7] * m[9],



             -m[0]  * m[9] * m[15] + 
              m[0]  * m[11] * m[13] + 
              m[8]  * m[1] * m[15] - 
              m[8]  * m[3] * m[13] - 
              m[12] * m[1] * m[11] + 
              m[12] * m[3] * m[9],

              m[0]  * m[5] * m[15] - 
              m[0]  * m[7] * m[13] - 
              m[4]  * m[1] * m[15] + 
              m[4]  * m[3] * m[13] + 
              m[12] * m[1] * m[7] - 
              m[12] * m[3] * m[5],

              -m[0] * m[5] * m[11] + 
               m[0] * m[7] * m[9] + 
               m[4] * m[1] * m[11] - 
               m[4] * m[3] * m[9] - 
               m[8] * m[1] * m[7] + 
               m[8] * m[3] * m[5],

              -m[4]  * m[9] * m[14] + 
               m[4]  * m[10] * m[13] +
               m[8]  * m[5] * m[14] - 
               m[8]  * m[6] * m[13] - 
               m[12] * m[5] * m[10] + 
               m[12] * m[6] * m[9],

              m[0]  * m[9] * m[14] - 
              m[0]  * m[10] * m[13] - 
              m[8]  * m[1] * m[14] + 
              m[8]  * m[2] * m[13] + 
              m[12] * m[1] * m[10] - 
              m[12] * m[2] * m[9],

              -m[0]  * m[5] * m[14] + 
               m[0]  * m[6] * m[13] + 
               m[4]  * m[1] * m[14] - 
               m[4]  * m[2] * m[13] - 
               m[12] * m[1] * m[6] + 
               m[12] * m[2] * m[5],

              m[0] * m[5] * m[10] - 
              m[0] * m[6] * m[9] - 
              m[4] * m[1] * m[10] + 
              m[4] * m[2] * m[9] + 
              m[8] * m[1] * m[6] - 
              m[8] * m[2] * m[5] ];

    var det = m[0] * inv[0] + m[1] * inv[4] + m[2] * inv[8] + m[3] * inv[12];

    det = 1.0/det;

    for( var i = 0; i<16; i++ ) inv[i] = inv[i] * det;

    return inv;
}

function matMul( a, b )
{
    var res = [];
    for( var i=0; i<4; i++ )
    {
        var x = a[4*i+0];
        var y = a[4*i+1];
        var z = a[4*i+2];
        var w = a[4*i+3];

        res[4*i+0] = x * b[ 0] + y * b[ 4] + z * b[ 8] + w * b[12];
        res[4*i+1] = x * b[ 1] + y * b[ 5] + z * b[ 9] + w * b[13];
        res[4*i+2] = x * b[ 2] + y * b[ 6] + z * b[10] + w * b[14];
        res[4*i+3] = x * b[ 3] + y * b[ 7] + z * b[11] + w * b[15];
    }

    return res;
}

function matMulpoint( m, v )
{
    return [ m[0]*v[0] + m[1]*v[1] + m[ 2]*v[2] + m[ 3],
             m[4]*v[0] + m[5]*v[1] + m[ 6]*v[2] + m[ 7],
             m[8]*v[0] + m[9]*v[1] + m[10]*v[2] + m[11] ];
}

function matMulvec( m, v )
{
    return [ m[0]*v[0] + m[1]*v[1] + m[ 2]*v[2],
             m[4]*v[0] + m[5]*v[1] + m[ 6]*v[2],
             m[8]*v[0] + m[9]*v[1] + m[10]*v[2] ];
}


function bound3( infi )
{
    return [ infi, -infi, infi, -infi, infi, -infi ];
}

function bound3_include( a, p )
{
    return [
        (p[0]<a[0]) ? p[0] : a[0],
        (p[0]>a[1]) ? p[0] : a[1],
        (p[1]<a[2]) ? p[1] : a[2],
        (p[1]>a[3]) ? p[1] : a[3],
        (p[2]<a[4]) ? p[2] : a[4],
        (p[2]>a[5]) ? p[2] : a[5] ];
}

function bound3_center( b )
{
    return [ 0.5*(b[0]+b[1]),
             0.5*(b[2]+b[3]),
             0.5*(b[4]+b[5]) ];
}

function bound3_radius( b )
{
    return [ 0.5*(b[1]-b[0]),
             0.5*(b[3]-b[2]),
             0.5*(b[5]-b[4]) ];
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piWebVR
//
//==============================================================================

function WebVR( isVREnabledCallback, canvasElement )
{
    isVREnabledCallback(false);
    /*


    this.mSupportVR = false;
    this.mHMD = null;

    var me = this;
    var listVRDisplays = function (vrdevs) {
        for (var i = 0; i < vrdevs.length; i++)
        {
            if (vrdevs[i] instanceof VRDisplay)
            {
                me.mHMD = vrdevs[i];
                console.log("WebVR is available.");
                console.log(me.mHMD);
                break;
            }
        }

        isVREnabledCallback(true);
        me.mSupportVR = true;
    }

    if (navigator.getVRDisplays)
    {
        navigator.getVRDisplays().then(listVRDisplays);
    }

    isVREnabledCallback(false);
    this.mCanvas = canvasElement;
    */
}

WebVR.prototype.IsSupported = function()
{
    return false;
    //return this.mSupportVR;
}

WebVR.prototype.GetData = function( id )
{
    return {};
    /*
    var frameData = new VRFrameData();
    var s = this.mHMD.getFrameData(frameData);
    var ss = frameData.pose;
    
    var fovL = this.mHMD.getEyeParameters("left");
    var fovR = this.mHMD.getEyeParameters( "right" );

    // camera info
    var cPos = vec3(0.0, 0.0, 0.0);
    if (ss.position)
        cPos = vec3(-ss.position[0], -ss.position[1], -ss.position[2]);
    var rot = vec4(0.0, 0.0, 0.0, 0.0);
    if (ss.orientation)
        rot = vec4(ss.orientation[0], ss.orientation[1], ss.orientation[2], ss.orientation[3]);
    var cRot = setFromQuaternion(rot);
    var cTra = setTranslation(cPos);
    var cMat = matMul(invertFast(cRot), cTra);
    
    // per eye info
    var lTra = setTranslation( vec3(-fovL.offset[0], -fovL.offset[1], -fovL.offset[2]) );
    var lMat = matMul(lTra, cMat);
    var lPrj = [ Math.tan( fovL.fieldOfView.upDegrees * Math.PI/180.0),
                 Math.tan(fovL.fieldOfView.downDegrees * Math.PI / 180.0),
                 Math.tan(fovL.fieldOfView.leftDegrees * Math.PI / 180.0),
                 Math.tan(fovL.fieldOfView.rightDegrees * Math.PI / 180.0)];

    var rTra = setTranslation(vec3(-fovR.offset[0], -fovR.offset[1], -fovR.offset[2]));
    var rMat = matMul(rTra, cMat);
    var rPrj = [Math.tan(fovR.fieldOfView.upDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.downDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.leftDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.rightDegrees * Math.PI / 180.0)];

    return {
        mCamera   : { mCamera: cMat },
        mLeftEye  : { mVP:[0,0,fovL.renderWidth,fovL.renderHeight], mProjection:lPrj, mCamera:lMat },
        mRightEye : { mVP:[fovR.renderWidth/2,0,fovR.renderWidth,fovR.renderHeight], mProjection:rPrj, mCamera:rMat }
           };
    */
}

WebVR.prototype.Enable = function( id )
{
    /*
    this.mHMD.requestPresent([{ source: this.mCanvas }]).then(
        function ()
        {
        },
        function (err)
        {
            console.log("webVR : requestPresent failed.");
        }
    );
    */
}

WebVR.prototype.Disable = function( id )
{
    /*
    if (!this.mHMD.isPresenting)
    {
        return;
    }

    this.mHMD.exitPresent().then(
        function ()
        {
        },
        function (err)
        {
            console.log("webVR : exitPresent failed.");
        }
    );
    */
}

WebVR.prototype.RequestAnimationFrame = function (id)
{
    //this.mHMD.requestAnimationFrame(id);
}

WebVR.prototype.IsPresenting = function (id)
{
    /*
    if (this.mHMD.isPresenting)
    {
        return true;
    }
    */
    return false;
}

WebVR.prototype.Finish = function (id)
{
    /*
    if (this.mHMD.isPresenting)
    {
        this.mHMD.submitFrame();
    }
    */
}

//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piWebUtils
//
//==============================================================================


// RequestAnimationFrame
window.requestAnimFrame = ( function () { return window.requestAnimationFrame    || window.webkitRequestAnimationFrame ||
                                                 window.mozRequestAnimationFrame || window.oRequestAnimationFrame ||
                                                 window.msRequestAnimationFrame  || function( cb ) { window.setTimeout(cb,1000/60); };
                                        } )();

// performance.now
window.getRealTime = ( function() { if ("performance" in window ) return function() { return window.performance.now(); }
                                                                  return function() { return (new Date()).getTime(); }
                                  } )();

window.URL = window.URL || window.webkitURL;

navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;

function htmlEntities(str) 
{
    return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g,'&apos;');
}

function piDisableTouch()
{
    document.body.addEventListener('touchstart', function(e){ e.preventDefault(); });
}

var piGetTime = function ( timestamp )
{
    if (timestamp == 0)
        return "";
    return new Date(timestamp * 1000).toISOString().substr(0, 10);
}

function piGetCoords( obj )
{
    var x = 0;
    var y = 0; 
    do
    {
         x += obj.offsetLeft;
         y += obj.offsetTop;
    }while( obj = obj.offsetParent );

    return { mX:x, mY:y };
}

function piGetMouseCoords( ev, canvasElement )
{
    var pos = piGetCoords(canvasElement );
    var mcx =                        (ev.pageX - pos.mX) * canvasElement.width / canvasElement.offsetWidth;
    var mcy = canvasElement.height - (ev.pageY - pos.mY) * canvasElement.height / canvasElement.offsetHeight;

    return { mX: mcx, mY: mcy };

}

function piGetSourceElement( e )
{
    var ele = null;
    if( e.target )     ele = e.target;
    if( e.srcElement ) ele = e.srcElement;
    return ele;
}

function piRequestFullScreen( ele )
{
    if( ele==null ) ele =   document.documentElement;
         if( ele.requestFullscreen       ) ele.requestFullscreen();
    else if( ele.msRequestFullscreen     ) ele.msRequestFullscreen();
    else if( ele.mozRequestFullScreen    ) ele.mozRequestFullScreen();
    else if( ele.webkitRequestFullscreen ) ele.webkitRequestFullscreen( Element.ALLOW_KEYBOARD_INPUT );
}

function piIsFullScreen()
{
    return document.fullscreen || document.mozFullScreen || document.webkitIsFullScreen || document.msFullscreenElement || false;
}

function piExitFullScreen()
{
       if( document.exitFullscreen       ) document.exitFullscreen();
  else if( document.msExitFullscreen     ) document.msExitFullscreen();
  else if( document.mozCancelFullScreen  ) document.mozCancelFullScreen();
  else if( document.webkitExitFullscreen ) document.webkitExitFullscreen();
}

function piIsMobile()
{
    return (navigator.userAgent.match(/Android/i) ||
            navigator.userAgent.match(/webOS/i) ||
            navigator.userAgent.match(/iPhone/i) ||
            navigator.userAgent.match(/iPad/i) ||
            navigator.userAgent.match(/iPod/i) ||
            navigator.userAgent.match(/BlackBerry/i) ||
            navigator.userAgent.match(/Windows Phone/i)) ? true : false;
}

function piCreateGlContext( cv, useAlpha, useDepth, usePreserveBuffer, useSupersampling )
{
    var opts = { alpha: useAlpha, 
                 depth: useDepth, 
                 stencil: false, 
                 premultipliedAlpha: false, 
                 antialias: useSupersampling, 
                 preserveDrawingBuffer: usePreserveBuffer, 
                 powerPreference: "high-performance" }; // "low_power", "high_performance", "default"

    var gl = null;
    if( gl === null) gl = cv.getContext( "webgl2", opts );
    if( gl === null) gl = cv.getContext( "experimental-webgl2", opts );
    if( gl === null) gl = cv.getContext( "webgl", opts );
    if( gl === null) gl = cv.getContext( "experimental-webgl", opts );

    return gl;
}

function piCreateAudioContext()
{
    var res = null;
    try
    {
        if( window.AudioContext ) res = new AudioContext();
        if( res==null && window.webkitAudioContext ) res = new webkitAudioContext();
    }
    catch( e )
    {
        res = null;
    }
    return res;
}

function piHexColorToRGB(str) // "#ff3041"
{
    var rgb = parseInt(str.slice(1), 16);
    var r = (rgb >> 16) & 255;
    var g = (rgb >> 8) & 255;
    var b = (rgb >> 0) & 255;
    return [r, g, b];
}

function piCreateFPSCounter()
{
    var mFrame;
    var mTo;
    var mFPS;

    var iReset = function( time )
    {
        mFrame = 0;
        mTo = time;
        mFPS = 60.0;
    }

    var iCount = function( time )
    {
        mFrame++;

        if( (time-mTo)>500.0 )
        {
            mFPS = 1000.0*mFrame/(time-mTo);
            mFrame = 0;
            mTo = time;
            return true;
        }
        return false;
    }

    var iGetFPS = function()
    {
        return mFPS;
    }
    
    return { Reset : iReset, Count : iCount, GetFPS : iGetFPS };
}

function piCanMediaRecorded(canvas)
{
    if (typeof window.MediaRecorder !== 'function' || typeof canvas.captureStream !== 'function') {
        return false;
    }
    return true;
}

function piCreateMediaRecorder(isRecordingCallback, canvas) 
{
    if (piCanMediaRecorded(canvas) == false)
    {
        return null;
    }
    
    var options = { audioBitsPerSecond : 0, videoBitsPerSecond : 8000000 }; 
	     if (MediaRecorder.isTypeSupported('video/webm;codecs=h264')) options.mimeType = 'video/webm;codecs=h264';
    else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9' )) options.mimeType = 'video/webm;codecs=vp9';
    else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8' )) options.mimeType = 'video/webm;codecs=vp8';
    else                                                              options.mimeType = 'video/webm;';

    var mediaRecorder = new MediaRecorder(canvas.captureStream(), options);
    var chunks = [];
    
    mediaRecorder.ondataavailable = function(e) 
    {
        if (e.data.size > 0) 
        {
            chunks.push(e.data);
        }
    };
 
    mediaRecorder.onstart = function(){ 
        isRecordingCallback( true );
    };
    
    mediaRecorder.onstop = function()
    {
         isRecordingCallback( false );
         let blob     = new Blob(chunks, {type: "video/webm"});
         chunks       = [];
         let videoURL = window.URL.createObjectURL(blob);
         let url      = window.URL.createObjectURL(blob);
         let a        = document.createElement("a");
         document.body.appendChild(a);
         a.style      = "display: none";
         a.href       = url;
         a.download   = "capture.webm";
         a.click();
         window.URL.revokeObjectURL(url);
     };
    
    return mediaRecorder;
}

function piExportToEXR(width, height, numComponents, type, bytes)
{
    var bytesPerComponent = 0;
    if      (type=="Uint")   bytesPerComponent = 4; 
    else if (type=="Half")   bytesPerComponent = 2;
    else if (type=="Float")  bytesPerComponent = 4;

    var tHeader = 258 + (18 * numComponents + 1);
    var tTable = 8 * height;
    var tScanlines = height * (4 + 4 + (numComponents * bytesPerComponent * width));
    var tTotal = tHeader + tTable + tScanlines;

    //console.log("    header size = " + tHeader);
    //console.log("    table size = " + tTable);
    //console.log("    scanlines size = " + tScanlines);
    //console.log("    total = " + tTotal);

    var buffer = new ArrayBuffer(tTotal); 
    var data = new DataView(buffer);

    // Header
    {
        // Header : 4 bytes -> 0x76, 0x2f, 0x31, 0x01
        var c = 0;
        data.setUint8 (c++, 0x76);
        data.setUint8 (c++, 0x2f);
        data.setUint8 (c++, 0x31);
        data.setUint8 (c++, 0x01);

        // Version : 4 bytes -> 2, 0, 0, 0
        data.setUint8 (c++, 0x02);
        data.setUint8 (c++, 0x0);
        data.setUint8 (c++, 0x0);
        data.setUint8 (c++, 0x0);
        
        // Write channel info
        // Write attribute name : "channels"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x73);
            data.setUint8 (c++, 0x0);

            // Write attribute type : "chlist"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00);

            // Write attribute size : 18 x 3 + 1 = 55
            var attribSize = 18 * numComponents + 1;
            data.setUint8 (c++, attribSize); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            var i;
            for (i = 0; i < numComponents; i++)
            {
                // Attribute : "B" (42) "G" (47) "R" (52)
                if (i==0)       data.setUint8 (c++, 0x42);
                else if (i==1)  data.setUint8 (c++, 0x47);
                else if (i==2)  data.setUint8 (c++, 0x52);
                data.setUint8 (c++, 0x00);
                
                // Value : Float (2), Half (1), Uint (0)
                if      (type=="Uint")   data.setUint8 (c++, 0x00); 
                else if (type=="Half")   data.setUint8 (c++, 0x01);
                else if (type=="Float")  data.setUint8 (c++, 0x02);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);

                // Plinear
                data.setUint8 (c++, 0x01);

                // Reserved
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 

                // X sampling
                data.setUint8 (c++, 0x01); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                
                // Y sampling
                data.setUint8 (c++, 0x01);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
            }
            // End attribute
            data.setUint8 (c++, 0x00);
    
        // Write attribute name : "compression"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6d); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x00);

            // Write attribute type : "compression"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6d); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x00);

            // Write attribute size : "1"
            data.setUint8 (c++, 0x01); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // Write attribute value : "0" (None)
            data.setUint8 (c++, 0x00);

        // datawindow
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x00); 

            // box2i
            data.setUint8 (c++, 0x62); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x00);

            // size 16
            data.setUint8 (c++, 0x10); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0 3 2
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 

            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint32 (c, width-1, true);
            c += 4;
            
            data.setUint32 (c, height-1, true); 
            c += 4;

        // displayWindow
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x79); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x00);

            // box2i
            data.setUint8 (c++, 0x62); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x00); 

            // size 16
            data.setUint8 (c++, 0x10); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0 3 2
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint32 (c, width-1, true);
            c += 4;
            
            data.setUint32 (c, height-1, true); 
            c += 4;

        // lineOrder
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x4f); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00); 
            
            // lineOrder
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x4f); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00); 
            
            // size
            data.setUint8 (c++, 0x01);
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);
            
            // value 
            data.setUint8 (c++, 0x00);

        // PixelAspectRatio
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x41); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x52); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x00); 

            // float
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00);
        
            // size 4
            data.setUint8 (c++, 0x04); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 1.0
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x80); 
            data.setUint8 (c++, 0x3f);
        
        // screenWindowCenter
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x63);
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x43); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e);
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00);

            // v2f
            data.setUint8 (c++, 0x76); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x00);

            // size 8
            data.setUint8 (c++, 0x08); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

        // screenWindowWidth
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x00); 
            
            // float
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00); 

            // size
            data.setUint8 (c++, 0x04); 
            data.setUint8 (c++, 0x00);
            data.setUint8 (c++, 0x00);
            data.setUint8 (c++, 0x00);

            // value
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x80); 
            data.setUint8 (c++, 0x3f);

        // End of header
        data.setUint8 (c++, 0x00);
    }
    //console.log("header size = " + c);

    // Scanline table
    var initc = c + height * 8;
    for (var scanline = 0 ; scanline < height ; scanline ++)
    {
        var jump = initc + scanline * (8 + width * bytesPerComponent * numComponents); 
        data.setUint32 (c, jump, true);
        c += 4; 

        data.setUint32 (c, 0x00, true);
        c += 4;
    }
    //console.log("header + scanlines table size = " + c);

    // Scanlines
    for (var scanline = 0 ; scanline < height ; scanline ++)
    {
        // Scanline
        data.setUint32(c, scanline, true);
        c += 4;

        // size 24
        var size = width * numComponents * bytesPerComponent; 
        data.setUint32(c, size, true);
        c += 4;

        var numComponentsSource = 4; // number of components in the SOURCE image
        for (var component = 0; component < numComponents ; component ++) 
        {
            for (var pixel = 0 ; pixel < width ; pixel ++) 
            {
                // flip vertical, so we read OpenGL buffers without JS image flipping
                var v = bytes[(height-1-scanline) * width *numComponentsSource + pixel * numComponentsSource + (2-component)];
                if      (type=="Float") data.setFloat32(c, v, true);
                else if (type=="Half")  data.setUint16(c, v, true);

                c += bytesPerComponent;
            }
        }
    }
    //console.log("total size = " + c);
    return new Blob([buffer], {type: 'application/octet-stream'});
}


function piExportToWAV(numSamples, rate, bits, numChannels, words)
{
    let numBytes = numSamples * numChannels * bits/8;

    let buffer = new ArrayBuffer(44 + numBytes); 
    let data = new DataView(buffer);

    {
        data.setUint32( 0, 0x46464952, true );  // RIFF
        data.setUint32( 4, numBytes + 36, true);
        {
            data.setUint32( 8, 0x45564157, true );  // WAV_WAVE
            data.setUint32( 12, 0x20746D66, true );  // WAV_FMT
            {
                data.setUint32( 16, 16, true);
                data.setUint16( 20, 1, true ); // WAV_FORMAT_PCM
                data.setUint16( 22, numChannels, true);
                data.setUint32( 24, rate, true);
                data.setUint32( 28, rate*numChannels*bits / 8, true);
                data.setUint16( 32, numChannels*bits / 8, true);
                data.setUint16( 34, bits, true);
            }

            data.setUint32( 36, 0x61746164, true);  // WAV_DATA
            {
                data.setUint32( 40, numBytes, true);
                let numWords = numSamples * numChannels;
                for(let i=0; i<numWords; i++ )
                {
                    data.setInt16( 44 + i*2, words[i], true );
                }
            }
        }
    }


    //console.log("total size = " + c);
    return new Blob([buffer], {type: 'application/octet-stream'});
}

function piTriggerDownload(name, blob)
{
    let url = URL.createObjectURL(blob);
    let aElement = document.createElement("a");
    aElement.href     = url;
    aElement.target   = "_self";
    aElement.download = name;
    document.body.appendChild(aElement);
    aElement.click();
    document.body.removeChild(aElement);
}</script>
    <script>"use strict"

function bufferID_to_assetID( id )
{
    if( id===0 ) return '4dXGR8';
    if( id===1 ) return 'XsXGR8';
    if( id===2 ) return '4sXGR8';
    if( id===3 ) return 'XdfGR8';
    return 'none';
}
function assetID_to_bufferID( id )
{
    if( id==='4dXGR8' ) return 0;
    if( id==='XsXGR8' ) return 1;
    if( id==='4sXGR8' ) return 2;
    if( id==='XdfGR8' ) return 3;
    return -1;
}

function assetID_to_cubemapBuferID( id )
{
    if( id==='4dX3Rr' ) return 0;
    return -1;
}
function cubamepBufferID_to_assetID( id )
{
    if( id===0 ) return '4dX3Rr';
    return 'none';
}

function EffectPass( renderer, is20, isLowEnd, hasShaderTextureLOD, callback, obj, forceMuted, forcePaused, outputGainNode, copyProgram, id, effect  )
{
    this.mID = id;
    this.mInputs  = [null, null, null, null ];
    this.mOutputs = [null, null, null, null ];
    this.mSource = null;

    this.mGainNode = outputGainNode;
    this.mSoundShaderCompiled = false;

    this.mEffect = effect;
    this.mRenderer = renderer;
    this.mProgramCopy = copyProgram; 
    this.mCompilationTime = 0;

    this.mType = "none";
    this.mName = "none";
    this.mFrame = 0;

    this.mShaderTextureLOD = hasShaderTextureLOD;
    this.mIs20 = is20;
    this.mIsLowEnd = isLowEnd;
    this.mTextureCallbackFun = callback;
    this.mTextureCallbackObj = obj;
    this.mForceMuted = forceMuted;
    this.mForcePaused = forcePaused;
}

EffectPass.prototype.MakeHeader_Image = function()
{
    let header = "";

    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for( let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        // old API
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                  header += "uniform sampler2D iChannel" + i + ";\n";

        // new API (see shadertoy.com/view/wtdGW8)
        header += "uniform struct {\n";
             if( inp===null )                  header += "  sampler2D";
        else if( inp.mInfo.mType==="cubemap" ) header += "  samplerCube";
        else if( inp.mInfo.mType==="volume"  ) header += "  sampler3D";
        else                                  header += "  sampler2D";
        header +=        " sampler;\n";
        header += "  vec3  size;\n";
        header += "  float time;\n";
        header += "  int   loaded;\n";
        header += "}iCh" + i + ";\n";
    }
	header += "void mainImage( out vec4 c, in vec2 f );\n";
    header += "void st_assert( bool cond );\n";
    header += "void st_assert( bool cond, int v );\n";

    if( this.mIs20 ) 
    {
        header += "\nout vec4 shadertoy_out_color;\n" +
        "void st_assert( bool cond, int v ) {if(!cond){if(v==0)shadertoy_out_color.x=-1.0;else if(v==1)shadertoy_out_color.y=-1.0;else if(v==2)shadertoy_out_color.z=-1.0;else shadertoy_out_color.w=-1.0;}}\n" +
        "void st_assert( bool cond        ) {if(!cond)shadertoy_out_color.x=-1.0;}\n" +
        "void main( void )" +
        "{" +
            "shadertoy_out_color = vec4(1.0,1.0,1.0,1.0);" + 
            "vec4 color = vec4(0.0,0.0,0.0,1.0);" +
            "mainImage( color, gl_FragCoord.xy );" +
            "if(shadertoy_out_color.x<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(shadertoy_out_color.y<0.0) color=vec4(0.0,1.0,0.0,1.0);" +
            "if(shadertoy_out_color.z<0.0) color=vec4(0.0,0.0,1.0,1.0);" +
            "if(shadertoy_out_color.w<0.0) color=vec4(1.0,1.0,0.0,1.0);" +
            "shadertoy_out_color = vec4(color.xyz,1.0);" +
        "}";
    }
    else
    {
        header += "" +
        "void st_assert( bool cond, int v ) {if(!cond){if(v==0)gl_FragColor.x=-1.0;else if(v==1)gl_FragColor.y=-1.0;else if(v==2)gl_FragColor.z=-1.0;else gl_FragColor.w=-1.0;}}\n" +
        "void st_assert( bool cond        ) {if(!cond)gl_FragColor.x=-1.0;}\n" +
        "void main( void )" +
        "{" +
            "gl_FragColor = vec4(0.0,0.0,0.0,1.0);" + 
            "vec4 color = vec4(0.0,0.0,0.0,1.0);" +
            "mainImage( color, gl_FragCoord.xy );" +
            "color.w = 1.0;" +
            "if(gl_FragColor.w<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(gl_FragColor.x<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(gl_FragColor.y<0.0) color=vec4(0.0,1.0,0.0,1.0);" +
            "if(gl_FragColor.z<0.0) color=vec4(0.0,0.0,1.0,1.0);" +
            "if(gl_FragColor.w<0.0) color=vec4(1.0,1.0,0.0,1.0);" +
            "gl_FragColor = vec4(color.xyz,1.0);"+
        "}";
    }
    header += "\n";

    /*
    this.mImagePassFooterVR = "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 ) 
        this.mImagePassFooterVR += "\nout vec4 outColor;\n";
    this.mImagePassFooterVR += "void main( void )" +
    "{" +
        "vec4 color = vec4(0.0,0.0,0.0,1.0);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainVR( color, gl_FragCoord.xy-unViewport.xy, ro, rd );" +
        "color.w = 1.0;"
    if( this.mIs20 ) 
        this.mImagePassFooterVR +=  "outColor = color;}";
    else
        this.mImagePassFooterVR +=  "gl_FragColor = color;}";
    */
    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Buffer = function()
{
    let header = "";
    
    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                  header += "uniform sampler2D iChannel" + i + ";\n";
    }

	header += "void mainImage( out vec4 c,  in vec2 f );\n"

    if( this.mIs20 )
        header += "\nout vec4 outColor;\n";
    header += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(0.0,0.0,0.0,1.0);" +
        "mainImage( color, gl_FragCoord.xy );";
    if( this.mIs20 )
        header +="outColor = color; }";
    else
        header +="gl_FragColor = color; }";
    header += "\n";

    /*
    this.mImagePassFooterVR = "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 )
    this.mImagePassFooterVR += "\nout vec4 outColor;\n";
    this.mImagePassFooterVR += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(0.0,0.0,0.0,1.0);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainVR( color, gl_FragCoord.xy-unViewport.xy, ro, rd );";
    if( this.mIs20 )
        this.mImagePassFooterVR +="outColor = color; }";
    else
        this.mImagePassFooterVR +="gl_FragColor = color; }";
    */
    this.mHeader = header;
    this.mHeaderLength = 0;
}


EffectPass.prototype.MakeHeader_Cubemap = function()
{
    let header = "";
    
    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                   header += "uniform sampler2D iChannel" + i + ";\n";
    }

	header += "void mainCubemap( out vec4 c, in vec2 f, in vec3 ro, in vec3 rd );\n"

    header += "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 )
        header += "\nout vec4 outColor;\n";
    header += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(0.0,0.0,0.0,1.0);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainCubemap( color, gl_FragCoord.xy-unViewport.xy, ro, rd );";
    if( this.mIs20 )
        header +="outColor = color; }";
    else
        header +="gl_FragColor = color; }";
    header += "\n";

    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Sound = function()
{
    let header = "";

    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform float     iChannelTime[4];\n" +
              "uniform float     iTimeOffset;\n" +
              "uniform int       iSampleOffset;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n";

    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp!==null && inp.mInfo.mType==="cubemap" )
            header += "uniform samplerCube iChannel" + i + ";\n";
        else
            header += "uniform sampler2D iChannel" + i + ";\n";
    }
    header += "\n";
    header += "vec2 mainSound( in int samp, float time );\n";

    if( this.mIs20 )
    {
        header += "out vec4 outColor; void main()" +
            "{" +
            "float t = iTimeOffset + ((gl_FragCoord.x-0.5) + (gl_FragCoord.y-0.5)*512.0)/iSampleRate;" +
            "int   s = iSampleOffset + int(gl_FragCoord.y-0.2)*512 + int(gl_FragCoord.x-0.2);" +
            "vec2 y = mainSound( s, t );" +
            "vec2 v  = floor((0.5+0.5*y)*65536.0);" +
            "vec2 vl =   mod(v,256.0)/255.0;" +
            "vec2 vh = floor(v/256.0)/255.0;" +
            "outColor = vec4(vl.x,vh.x,vl.y,vh.y);" +
            "}";
    }
    else
    {
        header += "void main()" +
            "{" +
            "float t = iTimeOffset + ((gl_FragCoord.x-0.5) + (gl_FragCoord.y-0.5)*512.0)/iSampleRate;" +
            "vec2 y = mainSound( 0, t );" +
            "vec2 v  = floor((0.5+0.5*y)*65536.0);" +
            "vec2 vl =   mod(v,256.0)/255.0;" +
            "vec2 vh = floor(v/256.0)/255.0;" +
            "gl_FragColor = vec4(vl.x,vh.x,vl.y,vh.y);" +
            "}";
    }
    header += "\n";
    this.mHeader = header;
    this.mHeaderLength = 0;
}


EffectPass.prototype.MakeHeader_Common = function ()
{
    let header = "";
    let headerlength = 0;

    header += "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n";
    headerlength += 2;

    if (this.mIs20)
    {
        header += "out vec4 outColor;\n";
        headerlength += 1;
    }
    header += "void main( void )\n";
    headerlength += 1;

    if (this.mIs20)
        header += "{ outColor = vec4(0.0); }";
    else
        header += "{ gl_FragColor = vec4(0.0); }";
    headerlength += 1;
    header += "\n";
    headerlength += 1;

    this.mHeader = header;
    this.mHeaderLength = headerlength;
}

EffectPass.prototype.MakeHeader = function()
{
         if( this.mType==="image" ) this.MakeHeader_Image();
    else if( this.mType==="sound" ) this.MakeHeader_Sound();
    else if( this.mType==="buffer") this.MakeHeader_Buffer();
    else if( this.mType==="common") this.MakeHeader_Common();
    else if( this.mType==="cubemap") this.MakeHeader_Cubemap();
    else console.log("ERROR 4");
}

EffectPass.prototype.Create_Image = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mSupportsVR = false;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    //this.mProgramVR = null;
}
EffectPass.prototype.Destroy_Image = function( wa )
{
}

EffectPass.prototype.Create_Buffer = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mSupportsVR = false;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    //this.mProgramVR = null;
}

EffectPass.prototype.Destroy_Buffer = function( wa )
{
}

EffectPass.prototype.Create_Cubemap = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
}

EffectPass.prototype.Destroy_Cubemap = function( wa )
{
}

EffectPass.prototype.Create_Common = function( wa )
{
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.MakeHeader();
}
EffectPass.prototype.Destroy_Common = function( wa )
{
}

EffectPass.prototype.Create_Sound = function (wa)
{
    this.MakeHeader();


    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    this.mSampleRate = 44100;
    this.mPlayTime = 60*3;
    this.mPlaySamples = this.mPlayTime*this.mSampleRate;
    this.mBuffer = wa.createBuffer( 2, this.mPlaySamples, this.mSampleRate );

    //-------------------
    this.mTextureDimensions = 512;
    this.mRenderTexture = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D, 
                                                       this.mTextureDimensions, this.mTextureDimensions,
                                                       this.mRenderer.TEXFMT.C4I8,
                                                       this.mRenderer.FILTER.NONE,
                                                       this.mRenderer.TEXWRP.CLAMP, null);
    this.mRenderFBO = this.mRenderer.CreateRenderTarget(this.mRenderTexture, null, null, null, null, false);

    //-----------------------------

    // ArrayBufferView pixels;
    this.mTmpBufferSamples = this.mTextureDimensions*this.mTextureDimensions;
    this.mData = new Uint8Array( this.mTmpBufferSamples*4 );

    this.mPlaying = false;
}

EffectPass.prototype.Destroy_Sound = function( wa )
{
    if( this.mPlayNode!==null ) this.mPlayNode.stop();
    this.mPlayNode = null;
    this.mBuffer = null;
    this.mData = null;

    this.mRenderer.DestroyRenderTarget(this.mRenderFBO);
    this.mRenderer.DestroyTexture(this.mRenderTexture);
}

EffectPass.prototype.Create = function( passType, wa )
{
    this.mType = passType;
    this.mSource = null;

         if( passType==="image" ) this.Create_Image( wa );
    else if( passType==="sound" ) this.Create_Sound( wa );
    else if( passType==="buffer") this.Create_Buffer( wa );
    else if( passType==="common") this.Create_Common( wa );
    else if( passType==="cubemap") this.Create_Cubemap( wa );
    else alert("ERROR 1");
}

EffectPass.prototype.SetName = function (passName)
{
    this.mName = passName;
}

EffectPass.prototype.SetCode = function (src)
{
    this.mSource = src;
}

EffectPass.prototype.Destroy = function( wa )
{
    this.mSource = null;
         if( this.mType==="image" ) this.Destroy_Image( wa );
    else if( this.mType==="sound" ) this.Destroy_Sound( wa );
    else if( this.mType==="buffer") this.Destroy_Buffer( wa );
    else if( this.mType==="common") this.Destroy_Common( wa );
    else if( this.mType==="cubemap") this.Destroy_Cubemap( wa );
    else alert("ERROR 2");
}

EffectPass.prototype.NewShader_Sound = function( shaderCode, commonShaderCodes)
{
    let vsSource = null;

    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for( let i=0; i<commonShaderCodes.length; i++ )
    {
        fsSource += commonShaderCodes[i]+'\n';
    }
    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;
    fsSource += shaderCode;

    this.mSoundShaderCompiled = false;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader_Image = function ( shaderCode, commonShaderCodes )
{
    this.mSupportsVR = false;


    let vsSource = null;
    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for (let i = 0; i < commonShaderCodes.length; i++)
    {
        fsSource += commonShaderCodes[i]+'\n';
    }
    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;
    fsSource += shaderCode;

    return [vsSource, fsSource];


    /*
    let n1 = shaderCode.indexOf("mainVR(");
    let n2 = shaderCode.indexOf("mainVR (");
    let n3 = shaderCode.indexOf("mainVR  (");
    if( n1>0 || n2>0 || n3>0 )
    {
        let vsSourceVR;
        if( this.mIs20 )
            vsSourceVR = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        else
            vsSourceVR = "attribute in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

        let fsSourceVR = this.mHeader;
        for (let i = 0; i < commonShaderCodes.length; i++) {
            fsSourceVR += commonShaderCodes[i];
        }
        fsSourceVR += shaderCode;
        fsSourceVR += this.mImagePassFooterVR;

        let res = this.mRenderer.CreateShader(vsSource, fsSourceVR, preventCache);
        if( res.mResult == false )
        {
            return res.mInfo;
        }
        if( this.mProgramVR != null )
            this.mRenderer.DestroyShader( this.mProgramVR );

        this.mSupportsVR = true;
        this.mProgramVR = res;
    }
    */
}

EffectPass.prototype.NewShader_Cubemap = function( shaderCode, commonShaderCodes )
{
    let vsSource = null;
    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for (let i = 0; i < commonShaderCodes.length; i++)
    {
        fsSource += commonShaderCodes[i]+'\n';
    }

    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;

    fsSource += shaderCode;

    return [vsSource, fsSource];
}


EffectPass.prototype.NewShader_Common = function (shaderCode )
{
    let vsSource = null;
    if (this.mIs20)
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader + shaderCode;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader = function ( commonSourceCodes, preventCache, onResolve)
{
    if( this.mRenderer===null ) return;

    let vs_fs = null;

         if( this.mType==="sound"  ) vs_fs = this.NewShader_Sound(   this.mSource, commonSourceCodes );
    else if( this.mType==="image"  ) vs_fs = this.NewShader_Image(   this.mSource, commonSourceCodes );
    else if( this.mType==="buffer" ) vs_fs = this.NewShader_Image(   this.mSource, commonSourceCodes );
    else if( this.mType==="common" ) vs_fs = this.NewShader_Common(  this.mSource,                   );
    else if( this.mType==="cubemap") vs_fs = this.NewShader_Cubemap( this.mSource, commonSourceCodes );
    else { console.log("ERROR 3: \"" + this.mType + "\""); return; }

    let me = this;
    this.mRenderer.CreateShader(vs_fs[0], vs_fs[1], preventCache, false,
        function (worked, info)
        {
            if (worked === true)
            {
                if (me.mType === "sound")
                {
                    me.mSoundShaderCompiled = true;
                }

                me.mCompilationTime = info.mTime;
                me.mError = false;
                me.mErrorStr = "No Errors";
                if (me.mProgram !== null)
                    me.mRenderer.DestroyShader(me.mProgram);
                me.mTranslatedSource = me.mRenderer.GetTranslatedShaderSource(info);
                me.mProgram = info;
            }
            else
            {
                me.mError = true;
                me.mErrorStr = info.mErrorStr;
            }
            onResolve();
        });
}

EffectPass.prototype.DestroyInput = function( id )
{
    if( this.mInputs[id]===null ) return;

    if( this.mInputs[id].mInfo.mType==="texture" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    if( this.mInputs[id].mInfo.mType==="volume" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="webcam" )
    {
        this.mInputs[id].video.pause();
        this.mInputs[id].video.src = "";

        if( this.mInputs[id].video.srcObject!==null )
        {
        let tracks = this.mInputs[id].video.srcObject.getVideoTracks();
        if( tracks ) tracks[0].stop();
        }
        this.mInputs[id].video = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="video" )
    {
        this.mInputs[id].video.pause();
        this.mInputs[id].video = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="music" || this.mInputs[id].mInfo.mType==="musicstream")
    {
        this.mInputs[id].audio.pause();
        this.mInputs[id].audio.mSound.mFreqData = null;
        this.mInputs[id].audio.mSound.mWaveData = null;
        this.mInputs[id].audio = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="cubemap" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="keyboard" )
    {
        //if( this.mInputs[id].globject != null )
          //  this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="mic" )
    {
        this.mInputs[id].mic = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }

    this.mInputs[id] = null;
}

EffectPass.prototype.TooglePauseInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused )
        {
            inp.video.play();
            inp.video.mPaused = false;
        }
        else
        {
            inp.video.pause();
            inp.video.mPaused = true;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        wa.resume()
        if( inp.audio.mPaused )
        {
            if( inp.loaded )
            {
                inp.audio.play();
            }
            inp.audio.mPaused = false;
        }
        else
        {
            inp.audio.pause();
            inp.audio.mPaused = true;
        }
        return inp.audio.mPaused;
    }

    return null;
}

EffectPass.prototype.StopInput = function( id )
{
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused === false )
        {
            inp.video.pause();
            inp.video.mPaused = true;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
    {
        if( inp.audio.mPaused === false )
        {
            inp.audio.pause();
            inp.audio.mPaused = true;
        }
        return inp.audio.mPaused;
    }
    return null;
}

EffectPass.prototype.ResumeInput = function( id )
{
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused )
        {
            inp.video.play();
            inp.video.mPaused = false;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
    {
        if( inp.audio.mPaused )
        {
            inp.audio.play();
            inp.audio.mPaused = false;
        }
        return inp.audio.mPaused;
    }
    return null;
}

EffectPass.prototype.RewindInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];

    if( inp==null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.loaded )
        {
            inp.video.currentTime = 0;
        }
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        wa.resume()
        if( inp.loaded )
        {
            inp.audio.currentTime = 0;
        }
    }
}

EffectPass.prototype.MuteInput = function( wa, id )
{
    let inp = this.mInputs[id];
    if( inp===null ) return;

    if( inp.mInfo.mType==="video" )
    {
        inp.video.muted = true;
        inp.video.mMuted = true;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if (wa !== null) inp.audio.mSound.mGain.gain.value = 0.0;
        inp.audio.mMuted = true;
    }
}

EffectPass.prototype.UnMuteInput = function( wa, id )
{
    let inp = this.mInputs[id];
    if( inp===null ) return;

    if( inp.mInfo.mType==="video" )
    {
        inp.video.muted = false;
        inp.video.mMuted = false;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if (wa !== null) inp.audio.mSound.mGain.gain.value = 1.0;
        inp.audio.mMuted = false;
    }
}

EffectPass.prototype.ToggleMuteInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];
    if( inp===null ) return null;

    if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mMuted ) this.UnMuteInput(wa,id);
        else                   this.MuteInput(wa,id);
        return inp.video.mMuted;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if( inp.audio.mMuted ) this.UnMuteInput(wa,id);
        else                   this.MuteInput(wa,id);
        return inp.audio.mMuted;
    }

    return null;
}

EffectPass.prototype.UpdateInputs = function( wa, forceUpdate, keyboard )
{
   for (let i=0; i<this.mInputs.length; i++ )
   {
        let inp = this.mInputs[i];

        if( inp===null )
        {
            if( forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, null, false, 0, 0, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.image, true, 1, 1, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mPreview, true, 1, 1, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
            if( inp.loaded && forceUpdate )
            {
                if( this.mTextureCallbackFun!==null )
                {
                    let img = (assetID_to_cubemapBuferID(inp.mInfo.mID)===-1) ? inp.image[0] : inp.mImage;
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, img, true, 2, 1, -1.0, this.mID );
                }
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:keyboard.mIcon,mData:keyboard.mData}, false, 6, 0, -1.0, this.mID );
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, -1, this.mID );
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
              if( inp.loaded && inp.audio.mPaused === false && inp.audio.mForceMuted === false )
              {
                  if( wa !== null )
                  {
                      inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                      inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                  }

                  if (this.mTextureCallbackFun!==null)
                  {
                           if (inp.mInfo.mType === "music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:(wa==null)?null:inp.audio.mSound.mFreqData}, false, 4, 1, inp.audio.currentTime, this.mID);
                      else if (inp.mInfo.mType === "musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:(wa==null)?null:inp.audio.mSound.mFreqData, info: inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                  }
              }
              else if( inp.loaded===false )
              {
                  if (this.mTextureCallbackFun!==null)
                      this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:null}, false, 4, 0, -1.0, this.mID);
              }
        }
        else if( inp.mInfo.mType==="mic" )
        {
              if( inp.loaded && inp.mForceMuted === false )
              {
                  if( wa !== null )
                  {
                      inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                      inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
                  }
                  if( this.mTextureCallbackFun!==null )
                      this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave: ((wa==null)?null:inp.mFreqData) }, false, 5, 1, 0, this.mID );
              }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:null}, true, 9, 1, -1.0, this.mID );
            }
        }
    }
}

EffectPass.prototype.Sampler2Renderer = function (sampler)
{
    let filter = this.mRenderer.FILTER.NONE;
    if (sampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
    if (sampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
    let wrap = this.mRenderer.TEXWRP.REPEAT;
    if (sampler.wrap === "clamp") wrap = this.mRenderer.TEXWRP.CLAMP;
    let vflip = false;
    if (sampler.vflip === "true") vflip = true;

    return { mFilter: filter, mWrap: wrap, mVFlip: vflip };
}

EffectPass.prototype.GetSamplerVFlip = function (id)
{
    let inp = this.mInputs[id];
    return inp.mInfo.mSampler.vflip;
}

EffectPass.prototype.GetTranslatedShaderSource = function ()
{
    return this.mTranslatedSource;
}


EffectPass.prototype.SetSamplerVFlip = function (id, str) 
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let filter = false;
    if (str === "true") filter = true;

    if (inp === null)
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
    }
    else if (inp.mInfo.mType === "video")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "webcam")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, null);
            inp.mInfo.mSampler.vflip = str;
        }
    }
}

EffectPass.prototype.GetAcceptsVFlip = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return false;
    if (inp.mInfo.mType === "video")  return true;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return true;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return false;
    return true;
}

EffectPass.prototype.GetSamplerFilter = function (id)
{
    let inp = this.mInputs[id];
    if( inp===null) return;
    return inp.mInfo.mSampler.filter;
}

EffectPass.prototype.SetSamplerFilter = function (id, str, buffers, cubeBuffers) 
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let filter = renderer.FILTER.NONE;
    if (str === "linear") filter = renderer.FILTER.LINEAR;
    if (str === "mipmap") filter = renderer.FILTER.MIPMAP;

    if (inp === null)
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "video")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap")
    {
        if (inp.loaded) 
        {
            if( assetID_to_cubemapBuferID(inp.mInfo.mID)===0)
            {
                renderer.SetSamplerFilter(cubeBuffers[0].mTexture[0], filter, true);
                renderer.SetSamplerFilter(cubeBuffers[0].mTexture[1], filter, true);
                inp.mInfo.mSampler.filter = str;
            }
            else
            {
                renderer.SetSamplerFilter(inp.globject, filter, true);
                inp.mInfo.mSampler.filter = str;
            }
        }
    }
    else if (inp.mInfo.mType === "webcam")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "buffer")
    {
        renderer.SetSamplerFilter(buffers[inp.id].mTexture[0], filter, true);
        renderer.SetSamplerFilter(buffers[inp.id].mTexture[1], filter, true);
        inp.mInfo.mSampler.filter = str;
    }
    else if (inp.mInfo.mType === "keyboard")
    {
        inp.mInfo.mSampler.filter = str;
    }
}



EffectPass.prototype.GetAcceptsMipmapping = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return this.mIs20;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return this.mIs20;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return this.mIs20;
    return false;
}

EffectPass.prototype.GetAcceptsLinear = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return true;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return true;
    if (inp.mInfo.mType === "music")  return true;
    if (inp.mInfo.mType === "musicstream") return true;
    if (inp.mInfo.mType === "mic")  return true;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return true;
    return false;
}


EffectPass.prototype.GetAcceptsWrapRepeat = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return this.mIs20;
    if (inp.mInfo.mType === "cubemap") return false;
    if (inp.mInfo.mType === "webcam")  return this.mIs20;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return this.mIs20;
    return false;
}

EffectPass.prototype.GetSamplerWrap = function (id)
{
    let inp = this.mInputs[id];
    return inp.mInfo.mSampler.wrap;
}
EffectPass.prototype.SetSamplerWrap = function (id, str, buffers)
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let restr = renderer.TEXWRP.REPEAT;
    if (str === "clamp") restr = renderer.TEXWRP.CLAMP;

    if (inp === null) 
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "video") 
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap") 
    {
        if (inp.loaded)
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "webcam") 
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "buffer")
    {
        renderer.SetSamplerWrap(buffers[inp.id].mTexture[0], restr);
        renderer.SetSamplerWrap(buffers[inp.id].mTexture[1], restr);
        inp.mInfo.mSampler.wrap = str;
    }
}


EffectPass.prototype.GetTexture = function( slot )
{
    let inp = this.mInputs[slot];
    if( inp===null ) return null;
    return inp.mInfo;

}

EffectPass.prototype.SetOutputs = function( slot, id )
{
    this.mOutputs[slot] = id;
}

EffectPass.prototype.SetOutputsByBufferID = function( slot, id )
{
    if( this.mType==="buffer" )
    {
        this.mOutputs[slot] = bufferID_to_assetID( id );

        this.mEffect.ResizeBuffer( id, this.mEffect.mXres, this.mEffect.mYres, false );
    }
    else if( this.mType==="cubemap" )
    {
        this.mOutputs[slot] = cubamepBufferID_to_assetID( id );
        this.mEffect.ResizeCubemapBuffer(id, 1024, 1024 );
    }
}

EffectPass.prototype.NewTexture = function( wa, slot, url, buffers, cubeBuffers, keyboard )
{
    var me = this;
    var renderer = this.mRenderer;

    if( renderer===null ) return;

    let texture = null;

    if( url===null || url.mType===null )
    {
        if( me.mTextureCallbackFun!==null )
            me.mTextureCallbackFun( this.mTextureCallbackObj, slot, null, true, 0, 0, -1.0, me.mID );
        me.DestroyInput( slot );
        me.mInputs[slot] = null;
        me.MakeHeader();
        return { mFailed:false, mNeedsShaderCompile:false };
    }
    else if( url.mType==="texture" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.image = new Image();
        texture.image.crossOrigin = '';
        texture.image.onload = function()
        {
            let rti = me.Sampler2Renderer(url.mSampler);

            // O.M.G. FIX THIS
            let channels = renderer.TEXFMT.C4I8;
            if (url.mID === "Xdf3zn" || url.mID === "4sf3Rn" || url.mID === "4dXGzn" || url.mID === "4sf3Rr")
                channels = renderer.TEXFMT.C1I8;
            
            texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.image, channels, rti.mFilter, rti.mWrap, rti.mVFlip);

            texture.loaded = true;
            if( me.mTextureCallbackFun!==null )
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.image, true, 1, 1, -1.0, me.mID );
        }
        texture.image.src = url.mSrc;


        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="volume" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.mImage = { mData:null, mXres:1, mYres:0, mZres:0 };
        texture.mPreview = new Image();
        texture.mPreview.crossOrigin = '';

	    var xmlHttp = new XMLHttpRequest();
        if( xmlHttp===null ) return { mFailed:true };

        xmlHttp.open('GET', url.mSrc, true);
        xmlHttp.responseType = "arraybuffer";
        xmlHttp.onerror = function()
        {
            console.log( "Error 1 loading Volume" );
        }
        xmlHttp.onload = function()
        {
            let data = xmlHttp.response;
            if (!data ) { console.log( "Error 2 loading Volume" ); return; }

            let file = piFile(data);

            let signature = file.ReadUInt32();
            texture.mImage.mXres = file.ReadUInt32();
            texture.mImage.mYres = file.ReadUInt32();
            texture.mImage.mZres = file.ReadUInt32();
            let binNumChannels = file.ReadUInt8();
            let binLayout = file.ReadUInt8();
            let binFormat = file.ReadUInt16();
            let format = renderer.TEXFMT.C1I8;
                 if( binNumChannels===1 && binFormat===0 )  format = renderer.TEXFMT.C1I8;
            else if( binNumChannels===2 && binFormat===0 )  format = renderer.TEXFMT.C2I8;
            else if( binNumChannels===3 && binFormat===0 )  format = renderer.TEXFMT.C3I8;
            else if( binNumChannels===4 && binFormat===0 )  format = renderer.TEXFMT.C4I8;
            else if( binNumChannels===1 && binFormat===10 ) format = renderer.TEXFMT.C1F32;
            else if( binNumChannels===2 && binFormat===10 ) format = renderer.TEXFMT.C2F32;
            else if( binNumChannels===3 && binFormat===10 ) format = renderer.TEXFMT.C3F32;
            else if( binNumChannels===4 && binFormat===10 ) format = renderer.TEXFMT.C4F32;
            else return;

            let buffer = new Uint8Array(data, 20); // skip 16 bytes (header of .bin)

            let rti = me.Sampler2Renderer(url.mSampler);

            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T3D, texture.mImage.mXres, texture.mImage.mYres, format, rti.mFilter, rti.mWrap, buffer);

            if( texture.globject===null )
            {
                console.log( "Error 4: loading Volume" ); 
                return { mFailed:true };
            }

            if (me.mTextureCallbackFun !== null)
            {
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mPreview, true, 1, 1, -1.0, me.mID );
            }

            texture.loaded = true;

            // load icon for it
            texture.mPreview.onload = function()
            {
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mPreview, true, 1, 1, -1.0, me.mID );
            }
            texture.mPreview.src = url.mPreviewSrc;
        }
        xmlHttp.send("");


        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]==null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="volume")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="cubemap" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;

        let rti = me.Sampler2Renderer(url.mSampler);

        if( assetID_to_cubemapBuferID(url.mID)!==-1 )
        {
            texture.mImage = new Image();
            texture.mImage.onload = function()
            {
                texture.loaded = true;
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mImage, true, 2, 1, -1.0, me.mID );
            }
            texture.mImage.src = "/media/previz/cubemap00.png";

            this.mEffect.ResizeCubemapBuffer(0, 1024, 1024 );

        }
        else
        {
            texture.image = [ new Image(), new Image(), new Image(), new Image(), new Image(), new Image() ];

            let numLoaded = 0;
            for (var i=0; i<6; i++ )
            {
                texture.image[i].mId = i;
                texture.image[i].crossOrigin = '';
                texture.image[i].onload = function()
                {
                    var id = this.mId;
                    numLoaded++;
                    if( numLoaded===6 )
                    {
                        texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.CUBEMAP, texture.image, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                        texture.loaded = true;
                        if (me.mTextureCallbackFun !== null)
                            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, texture.image[0], true, 2, 1, -1.0, me.mID);
                    }
                }

                if( i === 0) 
                {
                    texture.image[i].src = url.mSrc;
                } 
                else 
                {
                    let n = url.mSrc.lastIndexOf(".");
                    texture.image[i].src = url.mSrc.substring(0, n) + "_" + i + url.mSrc.substring(n, url.mSrc.length);
                }
            }
        }

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]==null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="cubemap")) };

        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="webcam" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;

        texture.video = document.createElement('video');
    	texture.video.width = 320;
    	texture.video.height = 240;
    	texture.video.autoplay = true;
    	texture.video.loop = true;
        texture.mForceMuted = this.mForceMuted;
        texture.mImage = null;

        let rti = me.Sampler2Renderer(url.mSampler);

        var loadImageInsteadOfWebCam = function()
        {
            texture.mImage = new Image();
            texture.mImage.onload = function()
            {
                texture.loaded = true;
                texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.mImage, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mImage, true, 7, 1, -1.0, me.mID );
            }
            texture.mImage.src = "/media/previz/webcam.png";
        }
        
        loadImageInsteadOfWebCam();

        if( typeof navigator.getUserMedia !== "undefined"  && texture.mForceMuted===false )
        {
            texture.video.addEventListener("canplay", function (e)
            {
				try
				{
                    texture.mImage = null;
                    if( texture.globject != null )
                        renderer.DestroyTexture( texture.globject );
					texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.video, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
					texture.loaded = true;
                }
                catch(e)
                {
                    loadImageInsteadOfWebCam();
	                alert( 'Your browser can not transfer webcam data to the GPU.');
                }
            } );

            navigator.mediaDevices.getUserMedia( 
                                { "video": { width: 1280, height: 720 }, "audio": false } )
                                .then( function(stream)
                                       {
                                            texture.video.srcObject = stream;
    	                               } )
                                .catch( function(error)
                                        {
                                            loadImageInsteadOfWebCam();
    		                                alert( 'Unable to capture WebCam. Please reload the page.' );
    	                                } );
        }
        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]==null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!="music") && 
                                                                (this.mInputs[slot].mInfo.mType!="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="mic" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.mForceMuted = this.mForceMuted;
        texture.mAnalyser = null;
        let num = 512;
        texture.mFreqData = new Uint8Array( num );
        texture.mWaveData = new Uint8Array( num );

        if( wa === null || typeof navigator.getUserMedia === "undefined" )
        {
            if( !texture.mForceMuted ) alert( "Shadertoy: Web Audio not implement in this browser" );
            texture.mForceMuted = true; 
        }

        if( texture.mForceMuted )
        {
            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, num, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null)
            texture.loaded = true;
        }
        else
        {
        navigator.getUserMedia( { "audio": true },
                                function(stream)
                                {
                                  texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, null)
                                  texture.mic = wa.createMediaStreamSource(stream);
                                  texture.mAnalyser = wa.createAnalyser();
                                  texture.mic.connect( texture.mAnalyser );
                                  texture.loaded = true;
    	                        },
                                function(error)
                                {
    		                        alert( 'Unable open Mic. Please reload the page.' );
    	                        } );
        }
        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="video" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.video = document.createElement('video');
    	texture.video.loop = true;
        texture.video.preload = "auto";
        texture.video.mPaused = this.mForcePaused;
        texture.video.mMuted = true;//this.mForceMuted;
    	texture.video.muted  = true;//this.mForceMuted;
        if( this.mForceMuted===true )
            texture.video.volume = 0;
    	texture.video.autoplay = false;
        texture.video.hasFalled = false;
        
        let rti = me.Sampler2Renderer(url.mSampler);

        texture.video.addEventListener("canplay", function (e)
        {
            texture.video.play().then( function()
                                       {
                                           texture.video.mPaused = false;

                                           texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.video, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                                           texture.loaded = true;
            
                                           if( me.mTextureCallbackFun!=null )
                                               me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.video, true, 3, 1, -1.0, me.mID );
                                        } )
                               .catch( function(error)
                                       {
                                           console.log( error );
                                       }
                                );
        } );

        texture.video.addEventListener( "error", function(e)
        {
               if( texture.video.hasFalled===true ) { alert("Error: cannot load video" ); return; }
               let str = texture.video.src;
               str = str.substr(0,str.lastIndexOf('.') ) + ".mp4";
               texture.video.src = str;
               texture.video.hasFalled = true;
        } );

        texture.video.src = url.mSrc;

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]==null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!="music") && 
                                                                (this.mInputs[slot].mInfo.mType!="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="music" || url.mType==="musicstream" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.audio = document.createElement('audio');
    	texture.audio.loop = true;
        texture.audio.mMuted = this.mForceMuted;
        texture.audio.mForceMuted = this.mForceMuted;
        texture.audio.muted = this.mForceMuted;
        if( this.mForceMuted===true )
            texture.audio.volume = 0;
        texture.audio.autoplay = false;
        texture.audio.hasFalled = false;
        texture.audio.mPaused = false;
        texture.audio.mSound = {};

        if( this.mForceMuted===false )
        {
            if(url.mType==="musicstream" && SC === null)
            {
                alert( "Shadertoy: Soundcloud could not be reached" );
                texture.audio.mForceMuted = true;
            }
            }

        if( wa === null && this.mForceMuted===false )
        {
            alert( "Shadertoy: Web Audio not implement in this browser" );
            texture.audio.mForceMuted = true;
        }

        if( texture.audio.mForceMuted )
        {
            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null);
            let num = 512;
            texture.audio.mSound.mFreqData = new Uint8Array( num );
            texture.audio.mSound.mWaveData = new Uint8Array( num );
            texture.loaded = true;
        }

        texture.audio.addEventListener( "canplay", function()
        {
            if( texture===null || texture.audio===null ) return;
            if( this.mForceMuted  ) return;
            if( texture.loaded === true ) return;

            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null)

            texture.audio.mSound.mSource   = wa.createMediaElementSource( texture.audio );
            texture.audio.mSound.mAnalyser = wa.createAnalyser();
            texture.audio.mSound.mGain     = wa.createGain();

            texture.audio.mSound.mSource.connect(   texture.audio.mSound.mAnalyser );
            texture.audio.mSound.mAnalyser.connect( texture.audio.mSound.mGain );
            texture.audio.mSound.mGain.connect(me.mGainNode);

            texture.audio.mSound.mFreqData = new Uint8Array( texture.audio.mSound.mAnalyser.frequencyBinCount );
            texture.audio.mSound.mWaveData = new Uint8Array( texture.audio.mSound.mAnalyser.frequencyBinCount );

            if( texture.audio.mPaused )
            {
                texture.audio.pause();
            }
            else
            {
                texture.audio.play().then( function() {/*console.log("ok");*/} ).catch( function(e){console.log("error " + e);} );
            }
            texture.loaded = true;
        } );

        texture.audio.addEventListener( "error", function(e)
        {
               if( this.mForceMuted  ) return;

               if( texture.audio.hasFalled===true ) { return; }
               let str = texture.audio.src;
               str = str.substr(0,str.lastIndexOf('.') ) + ".ogg";
               texture.audio.src = str;
               texture.audio.hasFalled = true;
        } );

        if( !texture.audio.mForceMuted )
        {
            if(url.mType==="musicstream")
            {
                SC.resolve(url.mSrc, 
                    function(song) 
                    {
                        if( song.streamable===true )
                        {
                            texture.audio.crossOrigin = 'anonymous';
                            texture.audio.src = song.stream_url;
                            texture.audio.soundcloudInfo = song;
                        }
                        else
                        {
                            alert('Shadertoy: Soundcloud 3 - This track cannot be streamed' );
                        }
                    },
                    function(error)
                    {
                        if (me.mTextureCallbackFun!==null)
                        {
                            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null}, false, 4, 0, -1.0, me.mID);
                        }
                    } );
            } 
            else
            {
                texture.audio.src = url.mSrc;
            }
        }

        if (me.mTextureCallbackFun!==null)
        {
            if (url.mType === "music")            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null}, false, 4, 0, -1.0, me.mID);
            else if (url.mType === "musicstream") me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null, info: texture.audio.soundcloudInfo}, false, 8, 0, -1.0, me.mID);
        }

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="keyboard" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = true;

        texture.keyboard = {};

        if( me.mTextureCallbackFun!==null )
            me.mTextureCallbackFun( me.mTextureCallbackObj, slot, {mImage: keyboard.mIcon, mData: keyboard.mData}, false, 6, 1, -1.0, me.mID );

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!="music") && 
                                                                (this.mInputs[slot].mInfo.mType!="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="buffer" )
    {
        texture = {};
        texture.mInfo = url;

        texture.image = new Image();
        texture.image.onload = function()
        {
            if( me.mTextureCallbackFun!=null )
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, {texture: texture.image, data:null}, true, 9, 1, -1.0, me.mID );
        }
        texture.image.src = url.mSrc;
        texture.id = assetID_to_bufferID( url.mID );
        texture.loaded = true;

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!="music") && 
                                                                (this.mInputs[slot].mInfo.mType!="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!="video")) };

        this.DestroyInput( slot );
        this.mInputs[slot] = texture;

        this.mEffect.ResizeBuffer(texture.id, this.mEffect.mXres, this.mEffect.mYres, false );

        this.SetSamplerFilter(slot, url.mSampler.filter, buffers, cubeBuffers, true);
        this.SetSamplerVFlip(slot, url.mSampler.vflip);
        this.SetSamplerWrap(slot, url.mSampler.wrap, buffers);

        this.MakeHeader();
        return returnValue;
    }
    else
    {
        alert( "input type error" );
        return { mFailed: true };
    }

    return { mFailed: true };
}

EffectPass.prototype.Paint_Image = function( vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    let times = [ 0.0, 0.0, 0.0, 0.0 ];

    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds()  + d.getMilliseconds()/1000.0 ];

    let mouse = [  mousePosX, mousePosY, mouseOriX, mouseOriY ];


    //------------------------
    
    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];
    let texIsLoaded = [0, 0, 0, 0 ];
    let texID = [ null, null, null, null];

    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            texID[i] = keyboard.mTexture;
            texIsLoaded[i] = 1;
            resos[3*i+0] = 256;
            resos[3*i+1] = 3;
            resos[3*i+2] = 1;
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
            if (inp.loaded === true)
            {
                let id = assetID_to_cubemapBuferID(inp.mInfo.mID);
                if( id!==-1 )
                {
                    texID[i] = cubeBuffers[id].mTexture[ cubeBuffers[id].mLastRenderDone ];
                    resos[3*i+0] = cubeBuffers[id].mResolution[0];
                    resos[3*i+1] = cubeBuffers[id].mResolution[1];
                    resos[3*i+2] = 1;
                    texIsLoaded[i] = 1;

                    // hack. in webgl2.0 we have samplers, so we don't need this crap here
                    let filter = this.mRenderer.FILTER.NONE;
                         if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                    else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                    this.mRenderer.SetSamplerFilter( texID[i], filter, false);
                }
                else
                {
                    texID[i] = inp.globject;
                    texIsLoaded[i] = 1;
                }
            }
        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mImage, false, 7, 1, -1, this.mID );

                    texID[i] = inp.globject;
                    texIsLoaded[i] = 1;
                    resos[3*i+0] = inp.mImage.width;
                    resos[3*i+1] = inp.mImage.height;
                    resos[3*i+2] = 1;
                }
                else  if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {

                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 7, 1, -1, this.mID );

                    texID[i] = inp.globject;
                    this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                    resos[3*i+0] = inp.video.videoWidth;
                    resos[3*i+1] = inp.video.videoHeight;
                    resos[3*i+2] = 1;
                    texIsLoaded[i] = 1;
                }
            }
            else 
            {
                texID[i] = null;
                texIsLoaded[i] = 0;
                resos[3*i+0] = inp.video.width;
                resos[3*i+1] = inp.video.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.mPaused === false )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, inp.video.currentTime, this.mID );
            }

            if( inp.loaded===true )
            { 
                times[i] = inp.video.currentTime;
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;

      	        if( inp.video.mPaused === false )
      	        {
      	            this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
                resos[3*i+0] = inp.video.videoWidth;
                resos[3*i+1] = inp.video.videoHeight;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.audio.mPaused === false && inp.audio.mForceMuted === false && inp.loaded===true )
            {
                if( wa !== null )
                {
                    inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                    inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                }

                if( this.mTextureCallbackFun!==null )
                {
                         if( inp.mInfo.mType==="music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa === null) ? null : { wave : inp.audio.mSound.mFreqData }, false, 4, 1, inp.audio.currentTime, this.mID);
                    else if( inp.mInfo.mType==="musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa === null) ? null : { wave : inp.audio.mSound.mFreqData, info : inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                }
            }

            if( inp.loaded===true )
            {
                times[i] = inp.audio.currentTime;
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;

                if( inp.audio.mForceMuted === true )
                {
                    times[i] = 10.0 + time;
                    let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.audio.mSound.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                  //let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.audio.mSound.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }

                }

      	        if( inp.audio.mPaused === false )
                {
      	            let waveLen = Math.min(inp.audio.mSound.mWaveData.length, 512);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512, 1, inp.audio.mSound.mFreqData);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 1, 512, 1, inp.audio.mSound.mWaveData);
                }

                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                    times[i] = 10.0 + time;
                    let num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                    //var num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }
            }
            else
            {
                inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
            }

            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave:inp.mFreqData}, false, 5, 1, -1, this.mID );

            if( inp.loaded===true )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                let waveLen = Math.min( inp.mWaveData.length, 512 );
                this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512,     1, inp.mFreqData);
                this.mRenderer.UpdateTexture(inp.globject, 0, 1, waveLen, 1, inp.mWaveData);
                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            let id = inp.id;
            if( inp.loaded===true  )
            {
                texID[i] = buffers[id].mTexture[ buffers[id].mLastRenderDone ];
                texIsLoaded[i] = 1;
                resos[3*i+0] = xres;
                resos[3*i+1] = yres;
                resos[3*i+2] = 1;
                // hack. in webgl2.0 we have samplers, so we don't need this crap here
                let filter = this.mRenderer.FILTER.NONE;
                     if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                this.mRenderer.SetSamplerFilter( texID[i], filter, false);
            }

            if( this.mTextureCallbackFun!==null )
            {
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:buffers[id].mThumbnailBuffer}, false, 9, 1, -1, this.mID );
            }
        }
    }

    this.mRenderer.AttachTextures( 4, texID[0], texID[1], texID[2], texID[3] );

    //-----------------------------------

    let prog = this.mProgram;

    //if( vrData!=null && this.mSupportsVR ) prog = this.mProgramVR;



    this.mRenderer.AttachShader(prog);

    this.mRenderer.SetShaderConstant1F(  "iTime", time);
    this.mRenderer.SetShaderConstant3F(  "iResolution", xres, yres, 1.0);
    this.mRenderer.SetShaderConstant4FV( "iMouse", mouse);
    this.mRenderer.SetShaderConstant1FV( "iChannelTime", times );              // OBSOLETE
    this.mRenderer.SetShaderConstant4FV( "iDate", dates );
    this.mRenderer.SetShaderConstant3FV( "iChannelResolution", resos );        // OBSOLETE
    this.mRenderer.SetShaderConstant1F(  "iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit( "iChannel0", 0 );
    this.mRenderer.SetShaderTextureUnit( "iChannel1", 1 );
    this.mRenderer.SetShaderTextureUnit( "iChannel2", 2 );
    this.mRenderer.SetShaderTextureUnit( "iChannel3", 3 );
    this.mRenderer.SetShaderConstant1I(  "iFrame", this.mFrame );
    this.mRenderer.SetShaderConstant1F(  "iTimeDelta", dtime);
    this.mRenderer.SetShaderConstant1F(  "iFrameRate", fps );

    this.mRenderer.SetShaderConstant1F(  "iCh0.time", times[0] );
    this.mRenderer.SetShaderConstant1F(  "iCh1.time", times[1] );
    this.mRenderer.SetShaderConstant1F(  "iCh2.time", times[2] );
    this.mRenderer.SetShaderConstant1F(  "iCh3.time", times[3] );
    this.mRenderer.SetShaderConstant3F(  "iCh0.size", resos[0], resos[ 1], resos[ 2] );
    this.mRenderer.SetShaderConstant3F(  "iCh1.size", resos[3], resos[ 4], resos[ 5] );
    this.mRenderer.SetShaderConstant3F(  "iCh2.size", resos[6], resos[ 7], resos[ 8] );
    this.mRenderer.SetShaderConstant3F(  "iCh3.size", resos[9], resos[10], resos[11] );
    this.mRenderer.SetShaderConstant1I(  "iCh0.loaded",       texIsLoaded[0] );
    this.mRenderer.SetShaderConstant1I(  "iCh1.loaded",       texIsLoaded[1] );
    this.mRenderer.SetShaderConstant1I(  "iCh2.loaded",       texIsLoaded[2] );
    this.mRenderer.SetShaderConstant1I(  "iCh3.loaded",       texIsLoaded[3] );

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");


    if( (vrData !== null) && this.mSupportsVR )
    {
        for (let i=0; i<2; i++ )
        {
            let ei = (i===0) ? vrData.mLeftEye : vrData.mRightEye;

            let vp = [i * xres / 2, 0, xres / 2, yres];

            this.mRenderer.SetViewport(vp);

            let fov = ei.mProjection;
            let corA = [ -fov[2], -fov[1], -1.0 ];
            let corB = [  fov[3], -fov[1], -1.0 ];
            let corC = [  fov[3],  fov[0], -1.0 ];
            let corD = [ -fov[2],  fov[0], -1.0 ];
            let apex = [ 0.0, 0.0, 0.0 ];

            let ma = invertFast( ei.mCamera );
            corA = matMulpoint( ma, corA ); 
            corB = matMulpoint( ma, corB ); 
            corC = matMulpoint( ma, corC ); 
            corD = matMulpoint( ma, corD ); 
            apex = matMulpoint( ma, apex ); 

            let corners = [ corA[0], corA[1], corA[2], 
                            corB[0], corB[1], corB[2], 
                            corC[0], corC[1], corC[2], 
                            corD[0], corD[1], corD[2],
                            apex[0], apex[1], apex[2]];

            this.mRenderer.SetShaderConstant3FV("unCorners", corners);
            this.mRenderer.SetShaderConstant4FV("unViewport", vp);

            this.mRenderer.DrawUnitQuad_XY(l1);
        }
    }
    else 
    {
        this.mRenderer.SetViewport([0, 0, xres, yres]);
        this.mRenderer.DrawFullScreenTriangle_XY( l1 );
    }

    this.mRenderer.DettachTextures();
}

EffectPass.prototype.iRenderSound = function(d, callback )
{
    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds() ];

    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];

    this.mRenderer.SetRenderTarget(this.mRenderFBO);

    this.mRenderer.SetViewport([0, 0, this.mTextureDimensions, this.mTextureDimensions]);
    this.mRenderer.AttachShader(this.mProgram);
    this.mRenderer.SetBlend( false );

    let texID = [null, null, null, null];
    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
    }

    this.mRenderer.AttachTextures(4, texID[0], texID[1], texID[2], texID[3]);

    let l2 = this.mRenderer.SetShaderConstantLocation(this.mProgram, "iTimeOffset");
    let l3 = this.mRenderer.SetShaderConstantLocation(this.mProgram, "iSampleOffset");
    this.mRenderer.SetShaderConstant4FV("iDate", dates);
    this.mRenderer.SetShaderConstant3FV("iChannelResolution", resos);
    this.mRenderer.SetShaderConstant1F("iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit("iChannel0", 0);
    this.mRenderer.SetShaderTextureUnit("iChannel1", 1);
    this.mRenderer.SetShaderTextureUnit("iChannel2", 2);
    this.mRenderer.SetShaderTextureUnit("iChannel3", 3);

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    //--------------------------------
    let numSamples = this.mTmpBufferSamples;
    let numBlocks = this.mPlaySamples / numSamples;
    for (let j=0; j<numBlocks; j++ )
    {
        let off = j*numSamples;
        
        this.mRenderer.SetShaderConstant1F_Pos(l2, off / this.mSampleRate);
        this.mRenderer.SetShaderConstant1I_Pos(l3, off );
        this.mRenderer.DrawUnitQuad_XY(l1);

        this.mRenderer.GetPixelData(this.mData, 0, this.mTextureDimensions, this.mTextureDimensions);

        callback( off, this.mData, numSamples );
    }

    this.mRenderer.DetachShader();
    this.mRenderer.DettachTextures();
    this.mRenderer.SetRenderTarget(null);
}

EffectPass.prototype.Paint_Sound = function( wa, d )
{
    let bufL = this.mBuffer.getChannelData(0); // Float32Array
    let bufR = this.mBuffer.getChannelData(1); // Float32Array

    this.iRenderSound( d, function(off, data, numSamples)
                         {
                            for( let i=0; i<numSamples; i++ )
                            {
                                bufL[off+i] = -1.0 + 2.0*(data[4*i+0]+256.0*data[4*i+1])/65535.0;
                                bufR[off+i] = -1.0 + 2.0*(data[4*i+2]+256.0*data[4*i+3])/65535.0;
                            }
                         }
                     );
}

EffectPass.prototype.SetUniforms = function(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    let times = [ 0.0, 0.0, 0.0, 0.0 ];

    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds()  + d.getMilliseconds()/1000.0 ];

    let mouse = [  mousePosX, mousePosY, mouseOriX, mouseOriY ];

    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];

    //------------------------
    
    let texID = [ null, null, null, null];

    for( let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            texID[i] = keyboard.mTexture;
        }
        else if( inp.mInfo.mType=="cubemap" )
        {
            if (inp.loaded === true)
            {
                let id = assetID_to_cubemapBuferID(inp.mInfo.mID);
                if( id!==-1 )
                {
                    texID[i] = cubeBuffers[id].mTexture[ cubeBuffers[id].mLastRenderDone ];
                    resos[3*i+0] = cubeBuffers[id].mResolution[0];
                    resos[3*i+1] = cubeBuffers[id].mResolution[1];
                    resos[3*i+2] = 1;
    
                    // hack. in webgl2.0 we have samplers, so we don't need this crap here
                    let filter = this.mRenderer.FILTER.NONE;
                         if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                    else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                    this.mRenderer.SetSamplerFilter( texID[i], filter, false);
                }
                else
                {
                    texID[i] = inp.globject;
                }
            }

        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    texID[i] = inp.globject;
                    resos[3*i+0] = inp.mImage.width;
                    resos[3*i+1] = inp.mImage.height;
                    resos[3*i+2] = 1;
                }
                else  if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {
                    texID[i] = inp.globject;
                    resos[3*i+0] = inp.video.videoWidth;
                    resos[3*i+1] = inp.video.videoHeight;
                    resos[3*i+2] = 1;
                }
            }
            else 
            {
                texID[i] = null;
                resos[3*i+0] = inp.video.width;
                resos[3*i+1] = inp.video.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
           if( inp.loaded===true )
           { 
                times[i] = inp.video.currentTime;
                texID[i] = inp.globject;
                resos[3*i+0] = inp.video.videoWidth;
                resos[3*i+1] = inp.video.videoHeight;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.loaded===true )
            {
                times[i] = inp.audio.currentTime;
                texID[i] = inp.globject;

                if( inp.audio.mForceMuted === true )
                {
                    times[i] = 10.0 + time;
                }

                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                times[i] = 10.0 + time;
            }

            if( inp.loaded===true )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = buffers[inp.id].mTexture[ buffers[inp.id].mLastRenderDone ];
                resos[3*i+0] = buffers[inp.id].mResolution[0];
                resos[3*i+1] = buffers[inp.id].mResolution[1];
                resos[3*i+2] = 1;
            }
        }
    }

    this.mRenderer.AttachTextures( 4, texID[0], texID[1], texID[2], texID[3] );

    //-----------------------------------

    this.mRenderer.AttachShader(this.mProgram);

    this.mRenderer.SetShaderConstant1F(  "iTime", time);
    this.mRenderer.SetShaderConstant3F(  "iResolution", xres, yres, 1.0);
    this.mRenderer.SetShaderConstant4FV( "iMouse", mouse);
    this.mRenderer.SetShaderConstant1FV( "iChannelTime", times );              // OBSOLETE
    this.mRenderer.SetShaderConstant4FV( "iDate", dates );
    this.mRenderer.SetShaderConstant3FV( "iChannelResolution", resos );        // OBSOLETE
    this.mRenderer.SetShaderConstant1F(  "iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit( "iChannel0", 0 );
    this.mRenderer.SetShaderTextureUnit( "iChannel1", 1 );
    this.mRenderer.SetShaderTextureUnit( "iChannel2", 2 );
    this.mRenderer.SetShaderTextureUnit( "iChannel3", 3 );
    this.mRenderer.SetShaderConstant1I(  "iFrame", this.mFrame );
    this.mRenderer.SetShaderConstant1F(  "iTimeDelta", dtime);
    this.mRenderer.SetShaderConstant1F(  "iFrameRate", fps );

    this.mRenderer.SetShaderConstant1F(  "iChannel[0].time",       times[0] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[1].time",       times[1] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[2].time",       times[2] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[3].time",       times[3] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[0].resolution", resos[0], resos[ 1], resos[ 2] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[1].resolution", resos[3], resos[ 4], resos[ 5] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[2].resolution", resos[6], resos[ 7], resos[ 8] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[3].resolution", resos[9], resos[10], resos[11] );
}

EffectPass.prototype.ProcessInputs = function(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
        }
        else if( inp.mInfo.mType==="volume" )
        {
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mImage, false, 7, 1, -1, this.mID );
                }
                else if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 7, 1, -1, this.mID );

                    this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.mPaused === false )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, inp.video.currentTime, this.mID );
            }

            if( inp.loaded===true )
            { 
      	        if( inp.video.mPaused === false )
      	        {
      	            this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.audio.mPaused === false && inp.audio.mForceMuted === false && inp.loaded===true )
            {
                if( wa !== null )
                {
                    inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                    inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                }

                if( this.mTextureCallbackFun!==null )
                {
                         if( inp.mInfo.mType==="music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa == null) ? null : { wave : inp.audio.mSound.mFreqData }, false, 4, 1, inp.audio.currentTime, this.mID);
                    else if( inp.mInfo.mType==="musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa == null) ? null : { wave : inp.audio.mSound.mFreqData, info : inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                }
            }

            if( inp.loaded===true )
            {
                if( inp.audio.mForceMuted === true )
                {
                    let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.audio.mSound.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                  //let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.audio.mSound.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }

                }

      	        if( inp.audio.mPaused === false )
                {
      	            let waveLen = Math.min(inp.audio.mSound.mWaveData.length, 512);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512, 1, inp.audio.mSound.mFreqData);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 1, 512, 1, inp.audio.mSound.mWaveData);
                }
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                    let num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                    for( let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }
            }
            else
            {
                inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
            }

            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave:inp.mFreqData}, false, 5, 1, -1, this.mID );

            if( inp.loaded===true )
            {
                let waveLen = Math.min( inp.mWaveData.length, 512 );
                this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512,     1, inp.mFreqData);
                this.mRenderer.UpdateTexture(inp.globject, 0, 1, waveLen, 1, inp.mWaveData);
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded===true  )
            {
                let id = inp.id;
                let texID = buffers[id].mTexture[ buffers[id].mLastRenderDone ];

                // hack. in webgl2.0 we have samplers, so we don't need this crap here
                let filter = this.mRenderer.FILTER.NONE;
                     if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                this.mRenderer.SetSamplerFilter( texID, filter, false);
            }

            if( this.mTextureCallbackFun!==null )
            {
				let id = inp.id;
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:buffers[id].mThumbnailBuffer}, false, 9, 1, -1, this.mID );
            }
        }
    }
}

EffectPass.prototype.Paint_Cubemap = function( vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face )
{
    this.ProcessInputs(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face );
    this.SetUniforms(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    let vp = [0, 0, xres, yres];

    this.mRenderer.SetViewport(vp);

    let corA = [ -1.0, -1.0, -1.0 ];
    let corB = [  1.0, -1.0, -1.0 ];
    let corC = [  1.0,  1.0, -1.0 ];
    let corD = [ -1.0,  1.0, -1.0 ];
    let apex = [  0.0,  0.0,  0.0 ];

    if( face===0 )
    {
        corA = [  1.0,  1.0,  1.0 ];
        corB = [  1.0,  1.0, -1.0 ];
        corC = [  1.0, -1.0, -1.0 ];
        corD = [  1.0, -1.0,  1.0 ];
    }
    else if( face===1 ) // -X
    {
        corA = [ -1.0,  1.0, -1.0 ];
        corB = [ -1.0,  1.0,  1.0 ];
        corC = [ -1.0, -1.0,  1.0 ];
        corD = [ -1.0, -1.0, -1.0 ];
    }
    else if( face===2 ) // +Y
    {
        corA = [ -1.0,  1.0, -1.0 ];
        corB = [  1.0,  1.0, -1.0 ];
        corC = [  1.0,  1.0,  1.0 ];
        corD = [ -1.0,  1.0,  1.0 ];
    }
    else if( face===3 ) // -Y
    {
        corA = [ -1.0, -1.0,  1.0 ];
        corB = [  1.0, -1.0,  1.0 ];
        corC = [  1.0, -1.0, -1.0 ];
        corD = [ -1.0, -1.0, -1.0 ];
    }
    else if( face===4 ) // +Z
    {
        corA = [ -1.0,  1.0,  1.0 ];
        corB = [  1.0,  1.0,  1.0 ];
        corC = [  1.0, -1.0,  1.0 ];
        corD = [ -1.0, -1.0,  1.0 ];
    }
    else //if( face===5 ) // -Z
    {
        corA = [  1.0,  1.0, -1.0 ];
        corB = [ -1.0,  1.0, -1.0 ];
        corC = [ -1.0, -1.0, -1.0 ];
        corD = [  1.0, -1.0, -1.0 ];
    }

    let corners = [ corA[0], corA[1], corA[2], 
                    corB[0], corB[1], corB[2], 
                    corC[0], corC[1], corC[2], 
                    corD[0], corD[1], corD[2],
                    apex[0], apex[1], apex[2]];

    this.mRenderer.SetShaderConstant3FV("unCorners", corners);
    this.mRenderer.SetShaderConstant4FV("unViewport", vp);

    this.mRenderer.DrawUnitQuad_XY(l1);

    this.mRenderer.DettachTextures();
}


EffectPass.prototype.Paint = function( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, bufferNeedsMimaps, buffers, cubeBuffers, keyboard, effect )
{
    if( this.mType==="sound" )
    {
        if (this.mSoundShaderCompiled === true)
        {
            // make sure all textures are loaded
            for (let i=0; i<this.mInputs.length; i++ )
            {
                let inp = this.mInputs[i];
                if (inp === null) continue;

                if (inp.mInfo.mType === "texture" && !inp.loaded) return;
                if (inp.mInfo.mType === "cubemap" && !inp.loaded) return;
            }

            this.Paint_Sound(wa, da);
            this.mSoundShaderCompiled = false;
        }
        if (this.mFrame === 0)
        {
            if (this.mPlaying===true)
            {
                this.mPlayNode.disconnect();
                this.mPlayNode.stop();
                this.mPlayNode = null;
            }
            this.mPlaying = true;

            this.mPlayNode = wa.createBufferSource();
            this.mPlayNode.buffer = this.mBuffer;
            this.mPlayNode.connect(this.mGainNode);
            this.mPlayNode.start(0);
        }
        this.mFrame++;
    }
    else if( this.mType==="image" )
    {
        this.mRenderer.SetRenderTarget( null );
        this.Paint_Image( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );
        this.mFrame++;
    }
    else if( this.mType==="common" )
    {
        //console.log("rendering common");
    }
    else if( this.mType==="buffer" )
    {
        this.mEffect.ResizeBuffer(bufferID, this.mEffect.mXres, this.mEffect.mYres, false );

        let buffer = buffers[bufferID];

        let dstID = 1 - buffer.mLastRenderDone;

        this.mRenderer.SetRenderTarget( buffer.mTarget[dstID] );
        this.Paint_Image( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );

        // compute mipmaps if needd
        if( bufferNeedsMimaps )
        {
            this.mRenderer.CreateMipmaps( buffer.mTexture[dstID]);
        }

        // make thumbnail
        //if( this.mTextureCallbackFun != null )
        /*
        {
            this.mRenderer.SetRenderTarget( buffer.mThumbnailRenderTarget );
            let v = [0, 0, buffer.mThumbnailRes[0], buffer.mThumbnailRes[1]];
            this.mRenderer.SetBlend(false);
            this.mRenderer.SetViewport(v);
            this.mRenderer.AttachShader(this.mProgramCopy);
            let l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, "pos");
            this.mRenderer.SetShaderConstant4FV("v", v);
            this.mRenderer.AttachTextures(1, buffer.mTexture[dstID], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);
            this.mRenderer.DettachTextures();
            this.mRenderer.DetachShader();
            this.mRenderer.GetPixelData( new Uint8Array(buffer.mThumbnailBuffer.data.buffer), buffer.mThumbnailRes[0], buffer.mThumbnailRes[1] );
            this.mRenderer.SetRenderTarget(null);
        }
        */
        buffers[bufferID].mLastRenderDone = 1 - buffers[bufferID].mLastRenderDone;
        this.mFrame++;
    }
    else if( this.mType==="cubemap" )
    {
        this.mEffect.ResizeCubemapBuffer(bufferID, 1024, 1024, false );

        let buffer = cubeBuffers[bufferID];

        xres = buffer.mResolution[0];
        yres = buffer.mResolution[1];
        let dstID = 1 - buffer.mLastRenderDone;
        for( let face=0; face<6; face++ )
        {
            this.mRenderer.SetRenderTargetCubeMap( buffer.mTarget[dstID], face );
            this.Paint_Cubemap( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face );
        }
        this.mRenderer.SetRenderTargetCubeMap( null, 0 );

        // compute mipmaps if needd
        if( bufferNeedsMimaps )
        {
            this.mRenderer.CreateMipmaps( buffer.mTexture[dstID]);
        }
        cubeBuffers[bufferID].mLastRenderDone = 1 - cubeBuffers[bufferID].mLastRenderDone;

        this.mFrame++;
    }

}

EffectPass.prototype.StopOutput_Sound = function( wa )
{
    if( this.mPlayNode===null ) return;
    this.mPlayNode.disconnect();

};

EffectPass.prototype.ResumeOutput_Sound = function( wa )
{
    if( this.mPlayNode===null ) return;

    wa.resume()
    this.mPlayNode.connect( this.mGainNode );
};

EffectPass.prototype.StopOutput_Image = function( wa )
{
};

EffectPass.prototype.ResumeOutput_Image = function( wa )
{
};

EffectPass.prototype.StopOutput = function( wa )
{
    for (let j=0; j<this.mInputs.length; j++ )
        this.StopInput(j);

    if( this.mType==="sound" )
         this.StopOutput_Sound( wa );
    else
         this.StopOutput_Image( wa );
}

EffectPass.prototype.ResumeOutput = function( wa )
{
    for (let j=0; j<this.mInputs.length; j++ )
        this.ResumeInput(j);

    if( this.mType==="sound" )
         this.ResumeOutput_Sound( wa );
    else
         this.ResumeOutput_Image( wa );
}

EffectPass.prototype.GetCompilationTime = function()
{
    return this.mCompilationTime;
}

//============================================================================================================
function Screenshots()
{
    // private
    let mTexture = null;
    let mTarget = null;
    let mXres = 0;
    let mYres = 0;
    let mCubemapToEquirectProgram;
    let mRenderer = null;

    // public
    var me = {};

    me.Initialize = function(renderer)
    {
        mRenderer = renderer;
        let caps = mRenderer.GetCaps();
        let is20 = caps.mIsGL20;


        let vsSourceC, fsSourceC;
        if( is20 )
        {
            vsSourceC = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
            fsSourceC = "uniform samplerCube t; out vec4 outColor; void main() { vec2 px = gl_FragCoord.xy/vec2(4096.0,2048.0); vec2 an = 3.1415926535898 * (px*vec2(2.0, 1.0) - vec2(0.0,0.5)); vec3 rd = vec3(-cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x)); outColor = texture(t, rd); }";
        }
        else
        {
            vsSourceC = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
            fsSourceC = "uniform samplerCube t; void main() { vec2 px = gl_FragCoord.xy/vec2(4096.0,2048.0); vec2 an = 3.1415926535898 * (px*vec2(2.0, 1.0) - vec2(0.0,0.5)); vec3 rd = vec3(-cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x)); gl_FragColor = texture(t, rd); }";
        }

        let compileShader = function (worked, info)
        {
            if (worked === false)
            {
                console.log("Failed to compile cubemap resample shader (" + errorType + "): " + log);
            }
            else
            {
                mCubemapToEquirectProgram = info;
            }
        }
        mRenderer.CreateShader(vsSourceC, fsSourceC, false, true, compileShader);

        return true;
    };

    me.Allocate = function( xres, yres )
    {
        if( xres>mXres || yres>mYres )
        {
            let texture = mRenderer.CreateTexture(mRenderer.TEXTYPE.T2D, xres, yres, mRenderer.TEXFMT.C4F32, mRenderer.FILTER.NONE, mRenderer.TEXWRP.CLAMP, null);
            let target = mRenderer.CreateRenderTarget( texture, null, null, null, null, false);

            if( mXres!==0 )
            {
                mRenderer.DestroyTexture(mTexture);
                mRenderer.DestroyRenderTarget(mTarget);
            }

            mTexture = texture;
            mTarget = target;
            mXres = xres;
            mYres = yres;
        }
    };

    me.GetProgram = function()
    {
        return mCubemapToEquirectProgram;
    };
    me.GetTarget = function()
    {
        return mTarget;
    };

    return me;
};

//============================================================================================================

function Effect(vr, ac, canvas, callback, obj, forceMuted, forcePaused, resizeCallback, crashCallback )
{
    let xres = canvas.width;
    let yres = canvas.height;

    let me = this;
    this.mCanvas = canvas;
    this.mCreated = false;
    this.mRenderer = null;
    this.mAudioContext = ac;
    this.mGLContext = null;
    this.mWebVR = vr;
    this.mRenderingStereo = false;
    this.mXres = xres;
    this.mYres = yres;
    this.mForceMuted = forceMuted;
    if( ac===null ) this.mForceMuted = true;
    this.mForcePaused = forcePaused;
    this.mGainNode = null;
    this.mPasses = [];
    this.mFrame = 0;
    this.mTextureCallbackFun = callback;
    this.mTextureCallbackObj = obj;
    this.mMaxBuffers = 4;
    this.mMaxCubeBuffers = 1;
    this.mMaxPasses = this.mMaxBuffers + 1 + 1 + 1 + 1; // some day decouple passes from buffers (4 buffers + common + Imagen + sound + cubemap)
    this.mBuffers = [];
    this.mCubeBuffers = [];
    this.mScreenshotSytem = null;
    this.mCompilationTime = 0;
    this.mIsLowEnd = piIsMobile();

    this.mGLContext = piCreateGlContext(canvas, false, false, true, false); // need preserve-buffe to true in order to capture screenshots
    if (this.mGLContext === null)
    {
        return;
    }

    canvas.addEventListener("webglcontextlost", function (event)
        {
            event.preventDefault();
            crashCallback();
        }, false);

    this.mRenderer = piRenderer();
    if (!this.mRenderer.Initialize(this.mGLContext))
        return;

    this.mScreenshotSytem = Screenshots();
    if (!this.mScreenshotSytem.Initialize(this.mRenderer))
        return;

    var caps = this.mRenderer.GetCaps();
    this.mIs20 = caps.mIsGL20;
    this.mShaderTextureLOD = caps.mShaderTextureLOD;
    //-------------
    if( ac!==null )
    {   
        this.mGainNode = ac.createGain();
        if( !forceMuted )
        {
            this.mGainNode.connect( ac.destination);
        }
        if (this.mForceMuted )
            this.mGainNode.gain.value = 0.0;
        else
            this.mGainNode.gain.value = 1.0;
    }

    //-------------
    let vsSourceC, fsSourceC;
    if( this.mIs20 )
    {
        vsSourceC = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceC = "uniform vec4 v; uniform sampler2D t; out vec4 outColor; void main() { outColor = textureLod(t, gl_FragCoord.xy / v.zw, 0.0); }";
    }
    else
    {
        vsSourceC = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceC = "uniform vec4 v; uniform sampler2D t; void main() { gl_FragColor = texture2D(t, gl_FragCoord.xy / v.zw, -100.0); }";
    }

    this.mRenderer.CreateShader(vsSourceC, fsSourceC, false, true, function(worked, info)
        {
            if (worked === false) console.log("Failed to compile shader to copy buffers : " + info.mErrorStr);
            else me.mProgramCopy = info;
        });

    let vsSourceD, fsSourceD;
    if( this.mIs20 )
    {
        vsSourceD = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceD = "uniform vec4 v; uniform sampler2D t; out vec4 outColor; void main() { vec2 uv = gl_FragCoord.xy / v.zw; outColor = texture(t, vec2(uv.x,1.0-uv.y)); }";
    }
    else
    {
        vsSourceD = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceD = "uniform vec4 v; uniform sampler2D t; void main() { vec2 uv = gl_FragCoord.xy / v.zw; gl_FragColor = texture2D(t, vec2(uv.x,1.0-uv.y)); }";
    }

    this.mRenderer.CreateShader(vsSourceD, fsSourceD, false, true, function (worked, info)
        {
            if (worked === false) console.log("Failed to compile shader to downscale buffers : " + info.mErrorStr);
            else me.mProgramDownscale = info;
        });


    // set all buffers and cubemaps to null
    for( let i=0; i<this.mMaxBuffers; i++ )
    {
        this.mBuffers[i] = { mTexture: [null, null], 
                             mTarget:  [null, null], 
                             mResolution: [0, 0],
                             mLastRenderDone: 0,
                             mThumbnailRenderTarget: null,
                             mThumbnailTexture: null,
                             mThumbnailBuffer:  null,
                             mThumbnailRes: [0, 0] };
    }

    for( let i=0; i<this.mMaxCubeBuffers; i++ )
    {
        this.mCubeBuffers[i] = { mTexture: [null, null], 
                                mTarget:  [null, null], 
                                mResolution: [0, 0],
                                mLastRenderDone: 0,
                                mThumbnailRenderTarget: null,
                                mThumbnailTexture: null,
                                mThumbnailBuffer:  null,
                                mThumbnailRes: [0, 0] };
    }

    //-------

    let keyboardData = new Uint8Array( 256*3 );
    for (let j=0; j<(256*3); j++ ) { keyboardData[j] = 0; }
    let kayboardTexture = this.mRenderer.CreateTexture( this.mRenderer.TEXTYPE.T2D, 256, 3, this.mRenderer.TEXFMT.C1I8, this.mRenderer.FILTER.NONE, this.mRenderer.TEXWRP.CLAMP, null);
    let keyboardImage = new Image();
    if( callback!==null )
        keyboardImage.src = "/img/keyboard.png"; // don't load PNG if no UI 
    this.mKeyboard = { mData: keyboardData, mTexture: kayboardTexture, mIcon: keyboardImage };

    let iResize = function( xres, yres )
    {
        me.mCanvas.width = xres;
        me.mCanvas.height = yres;
        me.mXres = xres;
        me.mYres = yres;
        me.ResizeBuffers(xres, yres);
        resizeCallback(xres, yres);
    };

    let bestAttemptFallback = function()
    {
        let devicePixelRatio = window.devicePixelRatio || 1;
        let xres = Math.round(me.mCanvas.offsetWidth  * devicePixelRatio) | 0;
        let yres = Math.round(me.mCanvas.offsetHeight * devicePixelRatio) | 0;
        iResize(xres, yres);
    };

    if(!window.ResizeObserver)
    {
        console.log("WARNING: This browser doesn't support ResizeObserver.");
        bestAttemptFallback();
        window.addEventListener("resize", bestAttemptFallback);
    }
    else
    {
        this.mRO = new ResizeObserver( function(entries, observer)
        {
            var entry = entries[0];
            if (!entry['devicePixelContentBoxSize'])
            {
                observer.unobserve(me.mCanvas);
                console.log("WARNING: This browser doesn't support ResizeObserver + device-pixel-content-box (2)");
                bestAttemptFallback();
                window.addEventListener("resize", bestAttemptFallback);
            }
            else
            {
                let box = entry.devicePixelContentBoxSize[0];
                let xres = box.inlineSize;
                let yres = box.blockSize;
                iResize(xres, yres);
            }
        });
        try
        {
            this.mRO.observe(this.mCanvas, { box: ["device-pixel-content-box"] });
            //this.mRO.observe(this.mCanvas);
        }
        catch (e)
        {
            console.log("WARNING: This browser doesn't support ResizeObserver + device-pixel-content-box (1)");
            bestAttemptFallback();
            window.addEventListener("resize", bestAttemptFallback);
        }
    }

    this.mCreated = true;
}


Effect.prototype.ResizeCubemapBuffer = function(i, xres, yres )
{
    let oldXres = this.mCubeBuffers[i].mResolution[0];
    let oldYres = this.mCubeBuffers[i].mResolution[1];

    if( this.mCubeBuffers[i].mTexture[0]===null || oldXres !== xres || oldYres !== yres )
    {
        let texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.CUBEMAP,
            xres, yres,
            this.mRenderer.TEXFMT.C4F16,
            this.mRenderer.FILTER.LINEAR,
            this.mRenderer.TEXWRP.CLAMP, 
            null);
        let target1 = this.mRenderer.CreateRenderTargetCubeMap( texture1, null, false);

        let texture2 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.CUBEMAP,
            xres, yres,
            this.mRenderer.TEXFMT.C4F16,
            this.mRenderer.FILTER.LINEAR,
            this.mRenderer.TEXWRP.CLAMP, 
            null);

        let target2 = this.mRenderer.CreateRenderTargetCubeMap( texture2, null, false);

        // Store new buffers
        this.mCubeBuffers[i].mTexture = [texture1,texture2], 
        this.mCubeBuffers[i].mTarget =  [target1, target2 ], 
        this.mCubeBuffers[i].mLastRenderDone = 0;
        this.mCubeBuffers[i].mResolution[0] = xres;
        this.mCubeBuffers[i].mResolution[1] = yres;
    }
}


Effect.prototype.ResizeBuffer = function( i, xres, yres, skipIfNotExists )
{
    if( skipIfNotExists && this.mBuffers[i].mTexture[0]===null ) return;

    let oldXres = this.mBuffers[i].mResolution[0];
    let oldYres = this.mBuffers[i].mResolution[1];

    if( oldXres !== xres || oldYres !== yres )
    {
        let needCopy = (this.mBuffers[i].mTexture[0]!==null);

        let texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,
            xres, yres,
            this.mRenderer.TEXFMT.C4F32,
            (needCopy) ? this.mBuffers[i].mTexture[0].mFilter : this.mRenderer.FILTER.NONE,
            (needCopy) ? this.mBuffers[i].mTexture[0].mWrap   : this.mRenderer.TEXWRP.CLAMP, 
            null);

        let texture2 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,
            xres, yres,
            this.mRenderer.TEXFMT.C4F32,
            (needCopy) ? this.mBuffers[i].mTexture[1].mFilter : this.mRenderer.FILTER.NONE,
            (needCopy) ? this.mBuffers[i].mTexture[1].mWrap   : this.mRenderer.TEXWRP.CLAMP, 
            null);

        let target1 = this.mRenderer.CreateRenderTarget( texture1, null, null, null, null, false);
        let target2 = this.mRenderer.CreateRenderTarget( texture2, null, null, null, null, false);

        if( needCopy )
        {
            let v = [0, 0, Math.min(xres, oldXres), Math.min(yres, oldYres)];
            this.mRenderer.SetBlend(false);
            this.mRenderer.SetViewport(v);
            this.mRenderer.AttachShader(this.mProgramCopy);
            let l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, "pos");
            let vOld = [0, 0, oldXres, oldYres];
            this.mRenderer.SetShaderConstant4FV("v", vOld);

            // Copy old buffers 1 to new buffer
            this.mRenderer.SetRenderTarget(target1);
            this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[0], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);

            // Copy old buffers 2 to new buffer
            this.mRenderer.SetRenderTarget(target2);
            this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[1], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);

            // Deallocate old memory
            this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[0]);
            this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[0]);
            this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[1]);
            this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[1]);
            //this.mRenderer.DestroyTexture(this.mBuffers[i].thumbnailTexture);
        }

        // Store new buffers
        this.mBuffers[i].mTexture = [texture1,texture2], 
        this.mBuffers[i].mTarget =  [target1, target2 ], 
        this.mBuffers[i].mLastRenderDone = 0;
        this.mBuffers[i].mResolution[0] = xres;
        this.mBuffers[i].mResolution[1] = yres;
    }
}

Effect.prototype.saveScreenshot = function(passid)
{
    let pass = this.mPasses[passid];

    if( pass.mType === "buffer" )
    {
        let bufferID = assetID_to_bufferID( this.mPasses[passid].mOutputs[0] );

        let texture = this.mBuffers[bufferID].mTarget[ this.mBuffers[bufferID].mLastRenderDone ];

        let numComponents = 3;
        let width = texture.mTex0.mXres;
        let height = texture.mTex0.mYres;
        let type = "Float"; // Other options Float, Half, Uint
        let bytes = new Float32Array(width * height * 4 );//numComponents);
        this.mRenderer.GetPixelDataRenderTarget( texture, bytes, width, height );
        let blob = piExportToEXR(width, height, numComponents, type, bytes);

        // Offer download automatically to the user
        piTriggerDownload("image.exr", blob);
    }
    else if( pass.mType === "cubemap" )
    {
        let xres = 4096;
        let yres = 2048;
        this.mScreenshotSytem.Allocate( xres, yres );

        let cubeBuffer = this.mCubeBuffers[0];

        let target = this.mScreenshotSytem.GetTarget();
        this.mRenderer.SetRenderTarget( target );

        let program = this.mScreenshotSytem.GetProgram();

        this.mRenderer.AttachShader(program);
        let l1 = this.mRenderer.GetAttribLocation(program, "pos");
        this.mRenderer.SetViewport( [0, 0, xres, yres] );
        this.mRenderer.AttachTextures(1, cubeBuffer.mTexture[ cubeBuffer.mLastRenderDone ], null, null, null);
        this.mRenderer.DrawUnitQuad_XY(l1);
        this.mRenderer.DettachTextures();
        this.mRenderer.SetRenderTarget( null );

        let data = new Float32Array(xres*yres*4);
        this.mRenderer.GetPixelDataRenderTarget( target, data, xres, yres );

        let blob = piExportToEXR(xres, yres, 3, "Float", data );
        piTriggerDownload("image.exr", blob);
    }
    else if( pass.mType === "sound" )
    {
        let offset = 0;
        const bits = 16;
        const numChannels = 2;
        let words = new Int16Array(60*pass.mSampleRate*numChannels );

        pass.iRenderSound( new Date(), function(off, data, numSamples)
                                         {
                                            for( let i=0; i<numSamples; i++ )
                                            {
                                                words[offset++] = (data[4*i+0]+256.0*data[4*i+1]) - 32767;
                                                words[offset++] = (data[4*i+2]+256.0*data[4*i+3]) - 32767;
                                            }
                                         }
                                     );

        let blob = piExportToWAV( 60*pass.mSampleRate, pass.mSampleRate, bits, numChannels, words);

        piTriggerDownload("sound.wav", blob);
    }    
}

Effect.prototype.ResizeBuffers = function(xres, yres)
{
    for (let i=0; i<this.mMaxBuffers; i++ )
    {
        this.ResizeBuffer(i, xres, yres, true);
    }
}

Effect.prototype.IsEnabledVR = function ()
{
    if (this.mRenderingStereo) return true;
    return false;
}

Effect.prototype.EnableVR = function()
{
    if( !this.mWebVR.IsSupported() ) return;
    if( this.mRenderingStereo ) return;

    this.mRenderingStereo = true;
    this.mWebVR.Enable();
}

Effect.prototype.DisableVR = function()
{
    if( !this.mWebVR.IsSupported() ) return;
    if( !this.mRenderingStereo ) return;

    this.mRenderingStereo = false;
    this.mWebVR.Disable();
}

Effect.prototype.GetTexture = function( passid, slot )
{
    return this.mPasses[passid].GetTexture( slot );
}

Effect.prototype.NewTexture = function( passid, slot, url )
{
    return this.mPasses[passid].NewTexture( this.mAudioContext, slot, url, this.mBuffers, this.mCubeBuffers, this.mKeyboard );
}

Effect.prototype.SetOutputs = function( passid, slot, url )
{
    this.mPasses[passid].SetOutputs( slot, url );
}

Effect.prototype.SetOutputsByBufferID = function( passid, slot, id )
{
    this.mPasses[passid].SetOutputsByBufferID( slot, id );
}

Effect.prototype.GetAcceptsLinear = function (passid, slot) 
{
    return this.mPasses[passid].GetAcceptsLinear(slot);
}

Effect.prototype.GetAcceptsMipmapping = function (passid, slot) 
{
    return this.mPasses[passid].GetAcceptsMipmapping(slot);
}

Effect.prototype.GetAcceptsWrapRepeat = function (passid, slot) 
{
    return this.mPasses[passid].GetAcceptsWrapRepeat(slot);
}

Effect.prototype.GetAcceptsVFlip = function (passid, slot)
{
    return this.mPasses[passid].GetAcceptsVFlip(slot);
}

Effect.prototype.SetSamplerFilter = function (passid, slot, str) 
{
    this.mPasses[passid].SetSamplerFilter(slot, str, this.mBuffers, this.mCubeBuffers);
}

Effect.prototype.GetTranslatedShaderSource = function (passid)
{
    return this.mPasses[passid].GetTranslatedShaderSource();
}

Effect.prototype.GetSamplerFilter = function (passid, slot) {
    return this.mPasses[passid].GetSamplerFilter(slot);
}

Effect.prototype.SetSamplerWrap = function (passid, slot, str) {
    this.mPasses[passid].SetSamplerWrap(slot, str, this.mBuffers);
}

Effect.prototype.GetSamplerWrap = function (passid, slot) {
    return this.mPasses[passid].GetSamplerWrap(slot);
}

Effect.prototype.SetSamplerVFlip = function (passid, slot, str) {
    this.mPasses[passid].SetSamplerVFlip(slot, str);
}

Effect.prototype.GetSamplerVFlip = function (passid, slot) {
    return this.mPasses[passid].GetSamplerVFlip(slot);
}

Effect.prototype.GetHeaderSize = function (passid)
{
    return this.mPasses[passid].mHeaderLength + 
           this.mRenderer.GetShaderHeaderLines(1);
 
}

Effect.prototype.ToggleVolume = function()
{
    this.mForceMuted = !this.mForceMuted;

    // outp
    if (this.mForceMuted)
        this.mGainNode.gain.value = 0.0;
    else
        this.mGainNode.gain.value = 1.0;

    // inp
    let num = this.mPasses.length;
    for( let j=0; j<num; j++ )
    {
        for( let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            if( this.mForceMuted )
                this.mPasses[j].MuteInput( this.mAudioContext, i );
            else
                this.mPasses[j].UnMuteInput( this.mAudioContext, i );
        }
    }

    return this.mForceMuted;
}

Effect.prototype.SetKeyDown = function( passid, k )
{
    if( this.mKeyboard.mData[ k + 0*256 ] == 255 ) return;

    this.mKeyboard.mData[ k + 0*256 ] = 255;
    this.mKeyboard.mData[ k + 1*256 ] = 255;
    this.mKeyboard.mData[ k + 2*256 ] = 255 - this.mKeyboard.mData[ k + 2*256 ];
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    let num = this.mPasses.length;
    for (let j=0; j<num; j++ )
    {
        for (let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            let inp = this.mPasses[j].mInputs[i];
            if( inp!==null && inp.mInfo.mType==="keyboard" )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:this.mKeyboard.mIcon, mData: this.mKeyboard.mData}, false, 6, 1, -1.0, this.mPasses[j].mID );
            }
        }
    }
}

Effect.prototype.SetKeyUp = function( passid, k )
{
    this.mKeyboard.mData[ k + 0*256 ] = 0;
    this.mKeyboard.mData[ k + 1*256 ] = 0;
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    let num = this.mPasses.length;
    for (let j=0; j<num; j++ )
    {
        for (let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            let inp = this.mPasses[j].mInputs[i];
            if( inp!==null && inp.mInfo.mType==="keyboard" )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:this.mKeyboard.mIcon, mData: this.mKeyboard.mData}, false, 6, 1, -1.0, this.mPasses[j].mID );
            }
        }
    }

}

Effect.prototype.StopOutputs = function()
{
    let wa = this.mAudioContext;

    let num = this.mPasses.length;
    for (let i=0; i<num; i++ )
    {
        this.mPasses[i].StopOutput( wa );
    }
}

Effect.prototype.ResumeOutputs = function()
{
    let wa = this.mAudioContext;

    let num = this.mPasses.length;
    for (let i=0; i<num; i++ )
    {
        this.mPasses[i].ResumeOutput( wa );
    }
}

Effect.prototype.PauseInput = function( passid, id )
{
    return this.mPasses[passid].TooglePauseInput( this.mAudioContext, id );
}

Effect.prototype.ToggleMuteInput = function( passid, id )
{
    return this.mPasses[passid].ToggleMuteInput( this.mAudioContext, id );
}

Effect.prototype.RewindInput = function( passid, id )
{
    this.mPasses[passid].RewindInput( this.mAudioContext, id );
}

Effect.prototype.UpdateInputs = function( passid, forceUpdate )
{
   this.mPasses[passid].UpdateInputs( this.mAudioContext, forceUpdate, this.mKeyboard );
}

Effect.prototype.ResetTime = function()
{
    this.mFrame = 0;
    this.mAudioContext.resume()

    let num = this.mPasses.length;
    for( let i=0; i<num; i++ )
    {
        this.mPasses[i].mFrame = 0;
        for( let j=0; j<this.mPasses[i].mInputs.length; j++ )
            this.mPasses[i].RewindInput(this.mAudioContext, j)
    }
}

Effect.prototype.RequestAnimationFrame = function (id)
{
    if (this.mRenderingStereo && this.mWebVR.IsPresenting())
    {
        this.mWebVR.RequestAnimationFrame(id);
    }
    else
    {
        requestAnimFrame(id);
    }
}

Effect.prototype.Paint = function(time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, isPaused)
{
    let wa = this.mAudioContext;
    let da = new Date();
    let vrData = null; if (this.mRenderingStereo) vrData = this.mWebVR.GetData();
    let xres = this.mXres / 1;
    let yres = this.mYres / 1;

    if( this.mFrame===0 )
    {
        for( let i=0; i<this.mMaxBuffers; i++ )
        {
            if( this.mBuffers[i].mTexture[0]!==null )
            {
                this.mRenderer.SetRenderTarget( this.mBuffers[i].mTarget[0] );
                this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
                this.mRenderer.SetRenderTarget( this.mBuffers[i].mTarget[1] );
                this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
				
				this.mRenderer.CreateMipmaps( this.mBuffers[i].mTexture[0] );
				this.mRenderer.CreateMipmaps( this.mBuffers[i].mTexture[1] );
            }
        }
        for( let i=0; i<this.mMaxCubeBuffers; i++ )
        {
            if( this.mCubeBuffers[i].mTexture[0]!==null )
            {
                for( let face=0; face<6; face++ )
                {
                    this.mRenderer.SetRenderTargetCubeMap( this.mCubeBuffers[i].mTarget[0], face );
                    this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
                    this.mRenderer.SetRenderTargetCubeMap( this.mCubeBuffers[i].mTarget[1], face );
                    this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
					this.mRenderer.CreateMipmaps( this.mCubeBuffers[i].mTexture[0] );
				    this.mRenderer.CreateMipmaps( this.mCubeBuffers[i].mTexture[1] );
                }
            }
        }
    }

    let num = this.mPasses.length;

    // render sound first
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "sound" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, null, false, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render buffers second
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "buffer" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        let bufferID = assetID_to_bufferID( this.mPasses[i].mOutputs[0] );

        // check if any downstream pass needs mipmaps when reading from this buffer
        let needMipMaps = false;
        for (let j=0; j<num; j++ )
        {
            for (let k=0; k<this.mPasses[j].mInputs.length; k++ )
            {
                let inp = this.mPasses[j].mInputs[k];
                if( inp!==null && inp.mInfo.mType==="buffer" && inp.id === bufferID && inp.mInfo.mSampler.filter === "mipmap")
                {
                    needMipMaps = true;
                    break;
                }
            }
        }

        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, needMipMaps, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }


    // render cubemap buffers second
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "cubemap" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        let bufferID = 0;//assetID_to_bufferID( this.mPasses[i].mOutputs[0] );

        // check if any downstream pass needs mipmaps when reading from this buffer
        let needMipMaps = false;

        for (let j=0; j<num; j++ )
        {
            for (let k=0; k<this.mPasses[j].mInputs.length; k++ )
            {
                let inp = this.mPasses[j].mInputs[k];
                if( inp!==null && inp.mInfo.mType==="cubemap" )
                {
                    if( assetID_to_cubemapBuferID(inp.mInfo.mID)===0 && inp.mInfo.mSampler.filter === "mipmap" )
                    {
                        needMipMaps = true;
                        break;
                    }
                }
            }
        }

        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, needMipMaps, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render image last
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "image" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, null, false, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }   

    // erase keypresses
    for (let k=0; k<256; k++ )
    {
       this.mKeyboard.mData[ k + 1*256 ] = 0;
    }
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    if( this.mRenderingStereo ) this.mWebVR.Finish();

    this.mFrame++;
}

Effect.prototype.NewShader = function( passid, preventCache, onResolve )
{
    let commonSourceCodes = [];
    for (let i=0; i<this.mPasses.length; i++ )
    {
        if( this.mPasses[i].mType==="common")
        {
            commonSourceCodes.push(this.mPasses[i].mSource);
        }
    }

    this.mPasses[passid].NewShader(commonSourceCodes, preventCache, onResolve );
}

Effect.prototype.GetNumPasses = function()
{
    return this.mPasses.length;
}

Effect.prototype.GetNumOfType = function(passtype)
{
    let id = 0;
    for (let j=0; j<this.mPasses.length; j++ )
    {
        if( this.mPasses[j].mType===passtype )
        {
            id++;
        }
    }
    return id;
}

Effect.prototype.GetPassType = function( id )
{
    return this.mPasses[id].mType;
}
Effect.prototype.GetPassName = function( id )
{
    return this.mPasses[id].mName;
}
Effect.prototype.GetCode = function( id )
{
    return this.mPasses[id].mSource;
}
Effect.prototype.SetCode = function( id, source )
{
    this.mPasses[id].SetCode(source);
}
Effect.prototype.GetError = function (id)
{
    return this.mPasses[id].mError;
}
Effect.prototype.GetErrorStr = function (id)
{
    return this.mPasses[id].mErrorStr;
}
Effect.prototype.GetErrorGlobal = function()
{
    for (let i = 0; i < this.mPasses.length; i++)
    {
        if (this.mPasses[i].mError)
        {
            return true;
        }
    }
    return false;
}

Effect.prototype.Load = function (jobj )
{
    if (jobj.ver !== "0.1")
    {
        console.log("Wrong Format");
        return false;
    }

    let numPasses = jobj.renderpass.length;

    if( numPasses<1 || numPasses>this.mMaxPasses )
    {
        console.log("Corrupted Shader - " + numPasses);
        return false;
    }

    this.mPasses = [];
    for (let j = 0; j < numPasses; j++)
    {
        let rpass = jobj.renderpass[j];

        // skip sound passes if in thumbnail mode
        if( this.mForceMuted && rpass.type === "sound" ) continue;

        let wpass = new EffectPass(this.mRenderer, this.mIs20, this.mIsLowEnd, this.mShaderTextureLOD,
                                   this.mTextureCallbackFun, this.mTextureCallbackObj, this.mForceMuted, this.mForcePaused, this.mGainNode,
                                   this.mProgramDownscale, j, this);

        wpass.Create(rpass.type, this.mAudioContext);

        let numInputs = rpass.inputs.length;

        for (let i = 0; i < 4; i++)
        {
            wpass.NewTexture(this.mAudioContext, i, null, null, null);
        }
        for (let i = 0; i < numInputs; i++)
        {
            let lid  = rpass.inputs[i].channel;
            let styp = rpass.inputs[i].type;
            let sid  = rpass.inputs[i].id;
            let ssrc = rpass.inputs[i].filepath;
            let psrc = rpass.inputs[i].previewfilepath;
            let samp = rpass.inputs[i].sampler;

            wpass.NewTexture(this.mAudioContext, lid, { mType: styp, mID: sid, mSrc: ssrc, mSampler: samp, mPreviewSrc: psrc }, this.mBuffers, this.mCubeBuffers, this.mKeyboard);
        }

        for (let i = 0; i < 4; i++)
        {
            wpass.SetOutputs(i, null);
        }

        let numOutputs = rpass.outputs.length;
        for (let i = 0; i < numOutputs; i++)
        {
            let outputID = rpass.outputs[i].id;
            let outputCH = rpass.outputs[i].channel;
            wpass.SetOutputs(outputCH, outputID);
        }

        // create some hardcoded names. This should come from the DB
        let rpassName = "";
        if (rpass.type === "common" ) rpassName = "Common";
        if (rpass.type === "sound"  ) rpassName = "Sound";
        if (rpass.type === "image"  ) rpassName = "Image";
        if (rpass.type === "buffer") rpassName = "Buffer " + String.fromCharCode(65 + assetID_to_bufferID(wpass.mOutputs[0]));
        if (rpass.type === "cubemap") rpassName = "Cube A";// " + String.fromCharCode(65 + assetID_to_bufferID(this.mPasses[j].mOutputs[0]));
        wpass.SetName(rpassName);
        wpass.SetCode(rpass.code);

        this.mPasses.push(wpass);
    }
    return true;
}

Effect.prototype.CompileSome = function ( passes, preventCache, onResolve )
{
    let me = this;

    let to = getRealTime();
    let allPromisses = [];
    for (let j = 0; j < passes.length; j++)
    {
        allPromisses.push(new Promise(function (resolve, reject)
        {
            me.NewShader(passes[j], preventCache, function () { resolve(1); });
        }));
    }

    // aggregated callback when all passes have been compiled
    Promise.all(allPromisses).then(function (values)
    {
        let totalError = false;
        for (let j = 0; j < me.mPasses.length; j++)
        {
            if (me.mPasses[j].mError)
            {
                totalError = true;
                break;
            }
        }
        me.mCompilationTime = getRealTime() - to;
        onResolve(!totalError);
    }).catch(console.log);
}

Effect.prototype.Compile = function (preventCache, onResolve )
{
    let me = this;

    let to = getRealTime();
    let allPromisses = [];
    let numPasses = this.mPasses.length;
    for (let j = 0; j < numPasses; j++)
    {
        allPromisses.push(new Promise(function (resolve, reject)
        {
            me.NewShader(j, preventCache, function () { resolve(1); });
        }));
    }

    // aggregated callback when all passes have been compiled
    Promise.all(allPromisses).then(function (values)
    {
        let totalError = false;
        for (let j = 0; j < numPasses; j++)
        {
            if (me.mPasses[j].mError)
            {
                totalError = true;
                break;
            }
        }
        me.mCompilationTime = getRealTime() - to;
        onResolve(!totalError);
    }).catch(console.log);
}

Effect.prototype.GetCompilationTime = function( id )
{
    return this.mPasses[id].GetCompilationTime()/1000.0;
}
Effect.prototype.GetTotalCompilationTime = function()
{
    return this.mCompilationTime/1000.0;
}

Effect.prototype.DestroyPass = function( id )
{
   this.mPasses[id].Destroy( this.mAudioContext );
   this.mPasses.splice(id, 1);
}

Effect.prototype.AddPass = function( passType, passName, onResolve )
{
    let shaderStr = null;

    if( passType==="sound"   ) shaderStr = "vec2 mainSound( int samp, float time )\n{\n    // A 440 Hz wave that attenuates quickly overt time\n    return vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );\n}";
    if( passType==="buffer"  ) shaderStr = "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}";
    if( passType==="common"  ) shaderStr = "vec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}";
    if( passType==="cubemap" ) shaderStr = "void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Ray direction as color\n    vec3 col = 0.5 + 0.5*rayDir;\n\n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}";

    let id = this.GetNumPasses();
    this.mPasses[id] = new EffectPass( this.mRenderer, this.mIs20, this.mIsLowEnd, this.mShaderTextureLOD,
                                       this.mTextureCallbackFun, this.mTextureCallbackObj, this.mForceMuted, this.mForcePaused, this.mGainNode, 
                                       this.mProgramDownscale, id, this );

    this.mPasses[id].Create( passType, this.mAudioContext );
    this.mPasses[id].SetName( passName );
    this.mPasses[id].SetCode( shaderStr );
    this.NewShader(id, false, function ()
    {
        onResolve();
    });

    return { mId : id, mShader : shaderStr };
}

// this should be removed once we have MultiPass 2.0 and passes render to arbitrary buffers
Effect.prototype.IsBufferPassUsed = function( bufferID )
{
    for (let j=0; j<this.mPasses.length; j++ )
    {
        if( this.mPasses[j].mType !== "buffer" ) continue;
        if( this.mPasses[j].mOutputs[0] === bufferID_to_assetID(bufferID) ) return true;
    }
    return false;
}

Effect.prototype.Save = function()
{
    var result = {};

    result.ver = "0.1";

    result.renderpass = [];

    let numPasses = this.mPasses.length;
    for (let j=0; j<numPasses; j++ )
    {
        result.renderpass[j] = {};

        result.renderpass[j].outputs = new Array();
        for (let i = 0; i<4; i++ )
        {
            let outputID = this.mPasses[j].mOutputs[i];
            if( outputID===null ) continue;
            result.renderpass[j].outputs.push( { channel: i, id: outputID } );
        }
        result.renderpass[j].inputs = new Array();
        for (let i = 0; i<4; i++ )
        {
            if( this.mPasses[j].mInputs[i]===null ) continue;
            result.renderpass[j].inputs.push( {channel: i,
                                               type    : this.mPasses[j].mInputs[i].mInfo.mType,
                                               id      : this.mPasses[j].mInputs[i].mInfo.mID,
                                               filepath: this.mPasses[j].mInputs[i].mInfo.mSrc,
                                               sampler : this.mPasses[j].mInputs[i].mInfo.mSampler });
        }

        result.renderpass[j].code = this.mPasses[j].mSource;
        result.renderpass[j].name = this.mPasses[j].mName
        result.renderpass[j].description = "";
        result.renderpass[j].type = this.mPasses[j].mType;
    }

    result.flags = this.calcFlags();

    return result;
}

Effect.prototype.calcFlags = function ()
{
    let flagVR = false;
    let flagWebcam = false;
    let flagSoundInput = false;
    let flagSoundOutput = false;
    let flagKeyboard = false;
    let flagMultipass = false;
    let flagMusicStream = false;

    let numPasses = this.mPasses.length;
    for (let j = 0; j < numPasses; j++)
    {
        let pass = this.mPasses[j];

        if (pass.mType === "sound") flagSoundOutput = true;
        if (pass.mType === "buffer") flagMultipass = true;

        for (let i = 0; i < 4; i++)
        {
            if (pass.mInputs[i] === null) continue;

            if (pass.mInputs[i].mInfo.mType === "webcam") flagWebcam = true;
            else if (pass.mInputs[i].mInfo.mType === "keyboard") flagKeyboard = true;
            else if (pass.mInputs[i].mInfo.mType === "mic") flagSoundInput = true;
            else if (pass.mInputs[i].mInfo.mType === "musicstream") flagMusicStream = true;
        }

        let n1 = pass.mSource.indexOf("mainVR(");
        let n2 = pass.mSource.indexOf("mainVR (");
        if (n1 > 0 || n2 > 0) flagVR = true;
    }

    return {
        mFlagVR: flagVR,
        mFlagWebcam: flagWebcam,
        mFlagSoundInput: flagSoundInput,
        mFlagSoundOutput: flagSoundOutput,
        mFlagKeyboard: flagKeyboard,
        mFlagMultipass: flagMultipass,
        mFlagMusicStream: flagMusicStream
    };
}</script>
    <script>"use strict"

const kMaxCompileTime = 10.0;

function iReportCrash(shaderID)
{
    let req = new XMLHttpRequest();
    req.onload = function ()
    {
        let jsn = req.response;
        if (jsn === null) return;
        if (jsn.result === 0)
        {
            // yep
        }
    };
    req.open("POST", "/shadertoy", true);
    req.responseType = "json";
    req.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    req.send( "s=" + shaderID + "&r=2" );
}
</script>
    <script>"use strict"

var gActive = -1;
var mShaders = [];
var gNumCanvases = 0;

function myrefresh( id, slot, img, forceFrame, gui, guiID, renderID, time )
{
    if( mShaders[id].mReady===false ) return;
    if( forceFrame )
    {
        if (mShaders[id].mScreenshot === false)
        {
            mShaders[id].gEffect.Paint(mShaders[id].mTime / 1000.0, 1.0 / 60.0, 60.0, 0, 0, 0, 0, false);
        }
    }
}

function startRendering()
{
    if( gActive<0 ) return;
    if( mShaders[gActive].mReady===false ) return;
    if( mShaders[gActive].mScreenshot===true ) return;

    let time = getRealTime();

    mShaders[gActive].mFPS.Count( time );
    mShaders[gActive].mTime = mShaders[gActive].mTime0 + (time - mShaders[gActive].mTo);
    let dtime = 1000.0/60.0;
    mShaders[gActive].gEffect.Paint( mShaders[gActive].mTime/1000.0, dtime/1000.0, mShaders[gActive].mFPS.GetFPS(), 0,0,0,0, false);

    requestAnimFrame( startRendering );
}

function iLoadAndCompile(jsn, i )
{
    var shaderObj = jsn[i];
    if (shaderObj === null) return;

    var resizeCB = function (xres, yres) { myrefresh(i, 0, null, true, false, 0, -1.0) };
    var crashCB = function () { alert('crash');/*iReportCrash(gShaderIDs[i])*/ };
    mShaders[i].gEffect = new Effect(null, null, mShaders[i].mPreview.mCanvas, myrefresh, i, true, true, resizeCB, crashCB);

    if (!mShaders[i].gEffect.Load(shaderObj)) return;

    mShaders[i].gEffect.Compile(false, function (worked)
    {
        if (worked === true)
        {
            previewShowRender(mShaders[i].mPreview);

            mShaders[i].mScreenshot = false;
            mShaders[i].mReady = true;
            mShaders[i].mTime = 10.0 * 1000.0;
            mShaders[i].mTime0 = 0.0;
            mShaders[i].mTo = 0.0;
            mShaders[i].mFPS = piCreateFPSCounter();
            mShaders[i].mPreview.mCanvas.addEventListener("mouseout", function (ev) { gActive = -1; }, true);
            mShaders[i].mPreview.mBase.addEventListener("mouseover", function (ev) { if (mShaders[i].mPreview.mUI !== null) mShaders[i].mPreview.mUI.classList.add('isVisible'); }, true);
            mShaders[i].mPreview.mBase.addEventListener("mouseout", function (ev) { if (mShaders[i].mPreview.mUI !== null) mShaders[i].mPreview.mUI.classList.remove('isVisible'); }, true);
            mShaders[i].mPreview.mCanvas.addEventListener("mouseover", function (ev)
            {
                let ele = piGetSourceElement(ev);
                if (ele.mId === undefined) return;

                gActive = ele.mId;
                if (!mShaders[gActive].mReady) return;
                let time = getRealTime();
                mShaders[gActive].mTo = time;
                mShaders[gActive].mTime0 = mShaders[gActive].mTime;
                mShaders[gActive].mFPS.Reset(time);

                startRendering();
            }, true);


            /*
            let compilationTime = mShaders[i].gEffect.GetTotalCompilationTime();
            if (compilationTime > kMaxCompileTime)
            {
                iReportCrash(mShaders[i].mShaderID);
            }*/

            myrefresh(i, null, null, true, false, 0, -1.0);
        }
        else
        {
            mShaders[i].mReady = false;
            previewShowError(mShaders[i].mPreview);
        }
    });
};


function iProcessShader( jsn, i )
{
    var shaderObj = jsn[i];
    if( shaderObj===null ) return;

    if ((shaderObj.info.usePreview === 0 && !gUseScreenshots) || (mShaders[i].mPreviewReady !== 1))
    {
        iLoadAndCompile(jsn, i);
    }
    else
    {
        mShaders[i].mScreenshot = true;
        if( shaderObj.info.usePreview === 1 )
            previewShowScreenshot(mShaders[i].mPreview, 1); // comp
        else if (gUseScreenshots)
            previewShowScreenshot(mShaders[i].mPreview, 2); // sett
    }

    if( i<(jsn.length-1) ) setTimeout( function(){iProcessShader(jsn,i+1);}, 10 );
}

function iInitUI(numCanvases, uiCallback, windowTitle)
{
    gNumCanvases = numCanvases;
    document.getElementById("mySearch").focus();

    //-----------------------------------------------------------------
    // window
    //-----------------------------------------------------------------
    if (windowTitle !== null) {
        document.title = windowTitle;
    }

    //-----------------------------------------------------------------
    // ui
    //-----------------------------------------------------------------
    var num = Math.min(gShaders.length, gNumCanvases);

    //var base = document.getElementsByClassName( "searchResult" );

    for (let i = 0; i < gNumCanvases; i++)
    {
        let pv = createPreview(i);

        if (i >= num) {
            previewHide(pv);
            continue;
        }

        let shaderID = gShaders[i].info.id;
        
        if (pv.mUI !== null && uiCallback !== null) {
            pv.mUI.addEventListener('click', function (ev) {
                uiCallback(shaderID);
                ev.preventDefault();
            }, false);
        }
        
        previewShowLoading(pv);
        
        mShaders[i] = {};
        mShaders[i].mShaderID = shaderID;
        mShaders[i].mPreview = pv;
        mShaders[i].mScreenshot = false;
        mShaders[i].mPreview.mLink.href = "/view/" + shaderID;
        mShaders[i].mPreviewReady = 0;
        mShaders[i].mReady = false;
        mShaders[i].gEffect = null;

        previewLoadScreenshot(mShaders[i].mPreview,
            function () { mShaders[i].mPreviewReady = 1; if (mShaders[i].mReady === false) previewShowScreenshot(mShaders[i].mPreview, 0); },
            function () { mShaders[i].mPreviewReady = 2; },
            shaderID);
    }

    if (num <= 0) {
        return;
    }
}

function iInitShaders(jsn)
{
    for (let i = 0; i < jsn.length; i++)
    {
        let shaderObj = jsn[i];
        if (shaderObj === null) continue;
        let inf = shaderObj.info;
        mShaders[i].mPreview.mTextA.textContent = inf.name;
        mShaders[i].mPreview.mTextB.innerHTML = "<a class='user' href='/user/" + htmlEntities(inf.username) + "'>" + htmlEntities(inf.username) + "</a>";
        mShaders[i].mPreview.mTextC.innerHTML = "<img src='/img/themes/" + gThemeName + "/views.png' class='viewsIcon'></img>" + inf.viewed + "    &nbsp;&nbsp;  <img src='/img/themes/" + gThemeName + "/likes.png' class='likesIcon'></img>" + inf.likes;
    }

    setTimeout(function () { iProcessShader(jsn, 0); }, 10);
}

function resultsInitStatic(numCanvases, uiCallback, windowTitle)
{
    iInitUI(numCanvases, uiCallback, windowTitle);

    iInitShaders(gShaders);
}

function resultsInit(numCanvases, uiCallback, windowTitle)
{	
    iInitUI(numCanvases, uiCallback, windowTitle);

    var num = Math.min(gShaderIDs.length, gNumCanvases);

    var mHttpReq = new XMLHttpRequest();

    mHttpReq.abort();

    var str = "{ \"shaders\" : [";
    for( let i=0; i<num; i++ )
    {
         str += "\"" + gShaderIDs[i] + "\"";
         if( i!==(num-1) ) str += ", ";
    }
    str += "] }";

    str = "s=" + encodeURIComponent( str ) + "&nt=0&nl=0&np=0";

    mHttpReq.open( "POST", "/shadertoy", true );
    mHttpReq.responseType = "json";
    mHttpReq.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    mHttpReq.onload = function ()
    {
        let jsn = this.response;
        if( jsn===null )
        {
            console.log( "Could not load shaders" );
            return;
        }

        iInitShaders(jsn);
    }
    mHttpReq.send( str );
}</script>
    <style>
    .shaderPreview
    {
    display: block;
    background-color: #000000;
    background-image: url("/img/loading.gif");
    background-repeat: no-repeat;
    background-position: center;
    padding: 0px;
    margin: 0px;
    border: 0px solid #000000;
    border-radius: 8px;
    width:100%;
    height:100%;
    position: absolute;
    overflow:hidden;
    }

    .previewInfo
    {
    width: 100%;
    left: 0px;
    top: 2px;
    position: relative;
    visibility: hidden;
    }

    .previewCanvas
    {
    left: 0px;
    top: 0px;
    padding: 0px;
    margin: 0px;
    position: absolute;
    cursor: pointer;
    width:100%;
    height:100%;
    border-radius: 8px;
    border: 0px solid #000000;
    backgroundColor: transparent;
visibility: hidden;
opacity:0;
transition: opacity 1.0s ease;
    }

    .previewText
    {
        text-overflow: ellipsis;
    white-space: nowrap;
    padding-right: 1px;
    }

    .previewTextUser
    {
    text-overflow: ellipsis;
    white-space: nowrap;
    padding-left: 3px;
    }

    .previewStats
    {
    padding-right: 1px;
    right: 0px;
    top: 0px;
    position: absolute;
    }

    .previewErrorContainer
    {
    left:0px;
    top:0px;
    width:100%;
    height:100%;
    padding:0px;
    margin:0px;
    background-color:#000000;
    border-radius:8px;
    cursor:pointer;
    visibility:hidden;
    }

    .previewErrorMessage
    {
    top:50%;
    position:absolute;
    width:100%;
    text-align:center;
    padding:0;
    margin:auto;
    color:#ff0000;
    font-size:2em;
    font-style:italic;
    }

    .previewNoGLContainter
    {
    left:0px;
    top:0px;
    width:100%;
    height:100%;
    padding:0px;
    margin:0px;
    position:absolute;
    background-color:#000000;
    border-radius:8px;
    cursor:pointer;
    pointer-events:none;
    visibility:hidden;
    font-size:2em;
    }

    .previewNoGLMessage
    {
    width:86%;
    height:90%;
    padding-left:7%;
    padding-right:7%;
    padding-top:10%;
    padding-bottom:0px;
    color:#ff0000;
    position:absolute;
    visibility:hidden;
    }

    .previewThumbnailContainer
    {
    width:100%;
    height:100%;
    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    cursor:pointer;
    visibility:hidden;
    border-radius:8px;
    border:0px solid #000000;
    }

    .previewThumbnailImage
    {
    width:100%;
    height:100%;
    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    cursor:pointer;
    border-radius:8px;
    border:0px solid #000000;
opacity: 0.0;
transition: opacity 1.0s ease;
    }

    .previewThumbnailIcon
    {
    width:64px;
    height:32px;
    left:0px;
    top:0px;
    padding:0px;
    padding-top:12px;
    margin:0px;
    position:absolute;
    color:#ffffff;
    background-color:#ff8020;
    font-weight:bold;
    border-radius:0px 0px 8px 0px;
    text-align:center;
    //visibility:hidden;
    }


    .previewUIContainter
    {
    display: block;
    right:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    //cursor:pointer;
    //pointer-events:none;
    //visibility:hidden;
    }
</style>

<script>
    function previewHide(me)
    {
    me.mBase.style.visibility = "hidden";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "hidden";
    }

    function previewShowRender(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "visible";
me.mCanvas.style.opacity = 1.0;
    me.mCanvas.style.borderRadius ="8px;";
//  me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "visible";
    }

    function previewShowScreenshot(me, message)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "visible";
me.mThumbnailImg.style.opacity = 1.0;
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "visible";
    me.mThumbnailWar1.style.visibility = (message===1)?"visible":"hidden";
    me.mThumbnailWar2.style.visibility = (message===2)?"visible":"hidden";
    }

    function previewShowLoading(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "hidden";

    me.mLink.style.visibility = "visible";
    me.mBase.style.backgroundColor = "#ff0000;"
    me.mCont.style.visibility = "visible";
    }

    function previewShowNoWebGL(me, shaderID)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "visible";
    me.mError.style.visibility = "visible";
    me.mThumbnailImgNoWebGL.onerror = function(ev) 
                                      { 
                                            me.mThumbnailImgNoWebGL.style.visibility="hidden"; 
                                            me.mMessageNoWebGL.style.visibility="visible"; 
                                      };
    me.mThumbnailImgNoWebGL.src = "/media/shaders/" + shaderID + ".jpg";
    }

    function previewShowError(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "visible";
    me.mCont.style.visibility = "visible";
    }

    function previewLoadScreenshot( me, cbSuccess, cbError, shaderID )
    {
    var url = "/media/shaders/" + shaderID + ".jpg";
    me.mThumbnailImg.onload = cbSuccess;
    me.mThumbnailImg.onerror = function(ev) { cbError(); };
    me.mThumbnailImg.src = url;
    }
        
    function createPreview(id)
    {
        var bar = document.getElementById( "Preview_"+id+"_Canvas" );
        bar.width = bar.offsetWidth;
        bar.height = bar.offsetHeight;
        bar.mId = id;

        return { mBase: document.getElementById( "Preview_"+id+"_Container" ),
        mLink: document.getElementById( "Preview_"+id+"_Link" ),
        mCanvas: bar,
        mCont: document.getElementById( "Preview_"+id+"_Info" ),
        mTextA: document.getElementById( "Preview_"+id+"_Text" ),
        mTextB: document.getElementById( "Preview_"+id+"_TextUser" ),
        mTextC: document.getElementById( "Preview_"+id+"_Stats" ),
        mNoWebGL: document.getElementById( "Preview_"+id+"_NoWebGL" ),
        mError: document.getElementById( "Preview_"+id+"_Error" ),
        mCanvas2D: document.getElementById( "Preview_"+id+"_Thumnail" ),
        mThumbnailImg: document.getElementById( "Preview_"+id+"_ThumnailImage" ),
        mThumbnailWar1: document.getElementById( "Preview_"+id+"_ThumnailWarning1" ),
        mThumbnailWar2: document.getElementById( "Preview_"+id+"_ThumnailWarning2" ),
        mThumbnailImgNoWebGL: document.getElementById( "Preview_"+id+"_ThumnailImageNoWebGL" ),
        mMessageNoWebGL: document.getElementById( "Preview_"+id+"_MessageNoWebGL"),
        mUI: document.getElementById( "Preview_"+id+"_UI" )
        };
    }
</script>

    <style>

    #content
    {
        user-select: text;
        -moz-user-select: -moz-text;
        -webkit-user-select: text;
        padding:0px;
        margin:0px;
        position:relative;
    }

    #divUser
    {
        padding:0px;
        padding-top:24px;
        padding-bottom:16px;
        width:100%;
    }

    div#controls
    {
        width:100%;
        padding-top:16px;
        padding-bottom:16px;
        display:flex;
        justify-content:space-between; 
        flex-wrap:wrap;
    }

    div#controls > div
    {
        display:inline-flex;
    }

    .controlOptions
    {
        display:inline-block;
    }

    div#shaderGrid
    {
        width:100%;
        padding:0px;
        margin:0px;
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        grid-template-rows: repeat(2, 1fr);
        grid-column-gap: 64px;
        grid-row-gap: 16px;
    }

    .searchResult
    {
        margin: 0px;
        padding: 0px;
        width: 100%;
    }
    .searchResultContainer
    {
        width: 100%;
        padding-bottom:56.25%;
        height: 0;
        position: relative;
    }

    div#navigation
    {
        text-align: center;
        width: 100%;
    }


    #userPicture
    {
        background-color:#808080;
        border: 1px solid #000000;
        padding:0px;
        left:0px;
        top:0px;
        width:128px;
        height:128px;
    }

    a.pageButtons, .pageButtonsCurrent
    {
        
        //background-color: #303030;
        border-style: solid;
        border-width: 1px;
        border-color: #808080;
        text-align: center;
        vertical-align: middle;
        margin-left: 12px;
        display: inline-block;
        border-radius: 4px;
		font-weight:bold;
        cursor: pointer;
        padding-bottom:5px;
        padding-top:4px;
        padding-left: 8px;
        padding-right: 8px;
        margin:8px;
    }

    a.pageButtons
    {
        text-decoration: none;
        -moz-transition:    background-color 0.15s linear, color 0.15s linear;
        -webkit-transition: background-color 0.15s linear, color 0.15s linear;
        transition:         background-color 0.15s linear, color 0.15s linear;
    }

    a.pageButtons:hover
    {
      background-color:#808080;
      color : #ff8020;
    }

    .pageButtonsCurrent
    {
        background-color: #808080;
        color:#000000;
    }

    /* ----------------------- media resolutions ------------------------ */

    @media screen and (max-width:799px) 
    {
        div#shaderGrid  { grid-template-columns: 1fr; grid-template-rows: repeat(8, 1fr); grid-column-gap: 0px; grid-row-gap: 16px; padding-bottom:16px; }

        div#controls
        {
            width:100%;
            display:flex;
            justify-content:flex-start; 
            flex-wrap:wrap;
        }

        div#controls > div
        {
            display:inline-flex;
            width:100%;
            margin-left: 0px;
            margin-right: 0px;
            padding-bottom:16px;
        }
    }
    </style>

    <script>

    var gShaders=[{"ver":"0.1","info":{"id":"MstXWS","date":"1461313640","viewed":7598,"name":"Raymarched reaction-diffusion","username":"emh","description":"Ray-marched sphere with reaction diffusion as displacement. Based on https:\/\/www.shadertoy.com\/view\/XsG3z1, original at https:\/\/www.shadertoy.com\/view\/4dcGW2 . Mouse to rotate ball.","likes":129,"published":3,"flags":32,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Created by Eivind Magnus Hvidevold emnh\/2016.\n\/\/ Reaction-diffusion by Flexi.\n\/\/ Raymarching by inigo quilez - iq\/2013.\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n\/\/----------------------------------------------------------------------\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 \/ 3.0, 1.0 \/ 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nvec2 map(in vec3 pos) {    \n    vec3 o = pos;\n    \n    pos = pos - vec3(0.0, -1.5, 0.0);\n    vec2 mo = iMouse.xy\/iResolution.xy;\n    float ms = 3.14 * 2.0;\n    mat4 mrx = rotationMatrix(vec3(1.0, 0.0, 0.0), mo.y * ms);\n    mat4 mry = rotationMatrix(vec3(0.0, 1.0, 0.0), mo.x * ms);\n    mat4 mrt = rotationMatrix(vec3(0.0, 1.0, 0.0), sin(iTime \/ 10.0));\n    \n    pos = (vec4(pos, 1.0) * mrx * mry * mrt).xyz;\n    \n    \/\/ uv mapping\n    vec3 p = normalize(pos);\n    vec2 uv = vec2(0.0);\n    uv.x = 0.5 + atan(p.z, p.x) \/ (2.*3.14159);\n    uv.y = 0.5 - asin(p.y) \/ 3.14159;\n    \n    float y = texture(iChannel0, uv).y;\n    float y2 = 0.1 * y;\n    \n    float ss = 5.0;\n    vec3 sphereO = pos; \/\/ - vec3(0.0, 0.25, 1.0);\n    \n    float sd = 0.0;\n\tsd = sdSphere(sphereO \/ ss, 0.4 + y2) * ss;\n    \n    return vec2(sd, iTime \/ 10.0 + y); \/\/sd + iTime \/ 10.0);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n#if 0\n    float tp1 = (0.0-ro.y)\/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)\/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n\tfloat precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h\/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)\/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        \/\/ material        \n\t\t\/* col = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        \n\t\t\n        if( m<1.5 )\n        {\n            \n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            col = 0.4 + 0.1*f*vec3(1.0);\n        }*\/\n\t\tcol = hsv2rgb(vec3(m, 1.0, 1.0));\n\n        \/\/ lighting        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.20*dif*vec3(1.00,0.85,0.55);\n\t\tlin += 1.20*spe*vec3(1.00,0.85,0.55)*dif;\n        lin += 0.20*amb*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*dom*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.002*t*t ) );\n\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy\/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x\/iResolution.y;\n    vec2 mo = iMouse.xy\/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n\n\t\/\/ camera\t\n\t\/\/ vec3 ro = vec3( -0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 3.5*sin(0.1*time + 6.0*mo.x) );\n    \/\/vec3 ro = vec3( -0.5+3.5*cos(6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 3.5*sin(6.0*mo.x) );\n    vec3 ro = vec3( 3.5, 1.0, 3.5 );\n\tvec3 ta = vec3( -0.5, -2.0, -1.0 );\n\t\n\t\/\/ camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    \/\/ ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    \/\/ render\t\n    vec3 col = render( ro, rd );\n\n\tcol = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ Reaction-diffusion pass.\n\/\/\n\/\/ Here's a really short, non technical explanation:\n\/\/\n\/\/ To begin, sprinkle the buffer with some initial noise on the first few frames (Sometimes, the \n\/\/ first frame gets skipped, so you do a few more).\n\/\/\n\/\/ During the buffer loop pass, determine the reaction diffusion value using a combination of the \n\/\/ value stored in the buffer's \"X\" channel, and a the blurred value - stored in the \"Y\" channel \n\/\/ (You can see how that's done in the code below). Blur the value from the \"X\" channel (the old \n\/\/ reaction diffusion value) and store it in \"Y\", then store the new (reaction diffusion) value \n\/\/ in \"X.\" Display either the \"X\" value  or \"Y\" buffer value in the \"Image\" tab, add some window \n\/\/ dressing, then repeat the process. Simple... Slightly confusing when I try to explain it, but \n\/\/ trust me, it's simple. :)\n\/\/\n\/\/ Anyway, for a more sophisticated explanation, here are a couple of references below:\n\/\/\n\/\/ Reaction-Diffusion by the Gray-Scott Model - http:\/\/www.karlsims.com\/rd.html\n\/\/ Reaction-Diffusion Tutorial - http:\/\/www.karlsims.com\/rd.html\n\n\/\/ Cheap vec3 to vec3 hash. Works well enough, but there are other ways.\nvec3 hash33(in vec2 p){ \n    float n = sin(dot(p, vec2(41, 289)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\n\/\/ Serves no other purpose than to save having to write this out all the time. I could write a \n\/\/ \"define,\" but I'm pretty sure this'll be inlined.\nvec4 tx(in vec2 p){ return texture(iChannel0, p); }\n\n\/\/ Weighted blur function. Pretty standard.\nfloat blur(in vec2 p){\n    \n    \/\/ Used to move to adjoining pixels. - uv + vec2(-1, 1)*px, uv + vec2(1, 0)*px, etc.\n    vec3 e = vec3(1, 0, -1);\n    vec2 px = 1.\/iResolution.xy;\n    \n    \/\/ Weighted 3x3 blur, or a cheap and nasty Gaussian blur approximation.\n\tfloat res = 0.0;\n    \/\/ Four corners. Those receive the least weight.\n\tres += tx(p + e.xx*px ).x + tx(p + e.xz*px ).x + tx(p + e.zx*px ).x + tx(p + e.zz*px ).x;\n    \/\/ Four sides, which are given a little more weight.\n    res += (tx(p + e.xy*px ).x + tx(p + e.yx*px ).x + tx(p + e.yz*px ).x + tx(p + e.zy*px ).x)*2.;\n\t\/\/ The center pixel, which we're giving the most weight to, as you'd expect.\n\tres += tx(p + e.yy*px ).x*4.;\n    \/\/ Normalizing.\n    return res\/16.;     \n    \n}\n\n\/\/ The reaction diffusion loop.\n\/\/ \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n\tvec2 uv = fragCoord\/iResolution.xy; \/\/ Screen coordinates. Range: [0, 1]\n    vec2 pw = 1.\/iResolution.xy; \/\/ Relative pixel width. Used for neighboring pixels, etc.\n    \n    \n    \/\/ The blurred pixel. This is the result that's used in the \"Image\" tab. It's also reused\n    \/\/ in the next frame in the reaction diffusion process (see below).\n\tfloat avgReactDiff = blur(uv);\n\n    \n\t\/\/ The noise value. Because the result is blurred, we can get away with plain old static noise.\n    \/\/ However, smooth noise, and various kinds of noise textures will work, too.\n    vec3 noise = hash33(uv + vec2(53, 43)*iTime)*.6 + .2;\n\n    \/\/ Used to move to adjoining pixels. - uv + vec2(-1, 1)*px, uv + vec2(1, 0)*px, etc.\n    vec3 e = vec3(1, 0, -1);\n    \n    \/\/ Gradient epsilon value. The \"1.5\" figure was trial and error, but was based on the 3x3 blur radius.\n    vec2 pwr = pw*1.5; \n    \n    \/\/ Use the blurred pixels (stored in the Y-Channel) to obtain the gradient. I haven't put too much \n    \/\/ thought into this, but the gradient of a pixel on a blurred pixel grid (average neighbors), would \n    \/\/ be analogous to a Laplacian operator on a 2D discreet grid. Laplacians tend to be used to describe \n    \/\/ chemical flow, so... Sounds good, anyway. :)\n    \/\/\n    \/\/ Seriously, though, take a look at the formula for the reacion-diffusion process, and you'll see\n    \/\/ that the following few lines are simply putting it into effect.\n    \n    \/\/ Gradient of the blurred pixels from the previous frame.\n\tvec2 lap = vec2(tx(uv + e.xy*pwr).y - tx(uv - e.xy*pwr).y, tx(uv + e.yx*pwr).y - tx(uv - e.yx*pwr).y);\/\/\n    \n    \/\/ Add some diffusive expansion, scaled down to the order of a pixel width.\n    uv = uv + lap*pw*3.0; \n    \n    \/\/ Stochastic decay. Ie: A differention equation, influenced by noise.\n    \/\/ You need the decay, otherwise things would keep increasing, which in this case means a white screen.\n    float newReactDiff = tx(uv).x + (noise.z - 0.5)*0.0025 - 0.002; \n    \n    \/\/ Reaction-diffusion.\n\tnewReactDiff += dot(tx(uv + (noise.xy-0.5)*pw).xy, vec2(1, -1))*0.145; \n\n    \n    \/\/ Storing the reaction diffusion value in the X channel, and avgReactDiff (the blurred pixel value) \n    \/\/ in the Y channel. However, for the first few frames, we add some noise. Normally, one frame would \n    \/\/ be enough, but for some weird reason, it doesn't always get stored on the very first frame.\n    if(iFrame>9) fragColor.xy = clamp(vec2(newReactDiff, avgReactDiff\/.98), 0., 1.);\n    else fragColor = vec4(noise, 1.);\n    \n}","name":"Buf A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"XtGBzy","date":"1542891762","viewed":1478,"name":"Chaos Wave Propagation Effect","username":"emh","description":"Click to reset. Based on https:\/\/shadertoy.com\/view\/Xsd3DB and https:\/\/www.shadertoy.com\/view\/ltVBWm .","likes":40,"published":3,"flags":32,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"\/media\/a\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"\/media\/ap\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Fork of \"Wave Propagation Effect\" by tomkh. https:\/\/shadertoy.com\/view\/Xsd3DB\n\/\/ 2018-11-22 10:37:40\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy\/iResolution.xy;\n\n    vec3 e = vec3(vec2(1.)\/iResolution.xy,0.);\n    float f = 10.0;\n    float p10 = texture(iChannel0, q-e.zy).z;\n    float p01 = texture(iChannel0, q-e.xz).z;\n    float p21 = texture(iChannel0, q+e.xz).z;\n    float p12 = texture(iChannel0, q+e.zy).z;\n    \n    vec4 w = texture(iChannel0, q);\n    \n    \/\/ Totally fake displacement and shading:\n    vec3 grad = normalize(vec3(p21 - p01, p12 - p10, 0.5));\n    vec2 uv = fragCoord.xy*2.\/iChannelResolution[1].xy + grad.xy*.35;\n    uv = uv * 0.5;\n    vec4 c = texture(iChannel1, uv);\n    c += c * 0.5;\n    c += c * w * (0.5 - distance(q, vec2(0.5)));\n    vec3 lightDir = vec3(0.2, -0.5, 0.7);\n    vec3 light = normalize(lightDir);\n    \n    float diffuse = dot(grad, light);\n    float spec = pow(max(0.,-reflect(light,grad).z),32.);\n    fragColor = mix(c,vec4(.7,.8,1.,1.),.25)*max(diffuse,0.) + spec;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec4 getTexture(sampler2D sam, vec2 g, vec2 p, vec2 s)\n{\n\tvec2 gp = g+p;\n\t\n\tif (gp.x >= s.x) gp.x = gp.x - s.x;\n\tif (gp.y >= s.y) gp.y = gp.y - s.y;\n\tif (gp.x < 0.0) gp.x = s.x + gp.x;\n\tif (gp.y < 0.0) gp.y = s.y + gp.y;\n\t\n\treturn texture(sam, gp \/ s);\n}\n\nvec4 getState(sampler2D sam, vec2 g, vec2 s, float n)\n{\n\tvec4 p = vec4(0);\n\tfor (float i=0.;i<n;i++)\n\t{\n        p = getTexture(sam, g, -p.xy, s);\n\t}\n\treturn p;\n}\n\n\/*float line(vec2 v, vec2 p0, vec2 p1)\n{\n\tvec2 a = v - p0;\n\tvec2 b = p1 - p0;\n\tfloat h = clamp(dot(a,b)\/dot(b,b),0.,1.);\n\treturn length(a-b*h);\n}*\/\n\n#define tex(p) getTexture(iChannel0, g, p, s)\n#define emit(v,k) if (length(g-(s * (0.5 + v))) < 5.) f.x = k, f.w = 1.\n\n#define frameStep 10000.\n\nvoid mainImage( out vec4 f, vec2 g )\n{\n    float frame = float(iFrame);\n\t\/\/frame = mod(frame, frameStep);\n\t\n\tvec2 s = iResolution.xy;\n\t\n\tvec4 r = tex(vec2(1,0));\n    vec4 t = tex(vec2(0,1));\n    vec4 l = tex(vec2(-1,0));\n    vec4 b = tex(vec2(0,-1));\n        \n    vec2 v = g\/s;\n    \n    \/\/ pifometre :)\n    vec2 c = sin(v * 6.28318)*.5+.5;\n    float cc = c.x + c.y;\n    \n\tf = getState(iChannel0, g, s, cc * 2. + 1.);\n    \n    f.xy += vec2(r.z - l.z, t.z - b.z);\n    \n\tvec4 dp = (r + t + l + b)\/4.;\t\t\t\n\tfloat div = ((l-r).x + (b-t).y)\/20.;\t\n\t\n    f.z = dp.z - div;\t\t\t\t\t\n    \n    emit(vec2(-0.45,0.),50.0);\n    emit(vec2(0.45,0.),-50.0);\n    \n    \n\tif (frame < 2. || iMouse.z > 0.) f *= 0.;\n}","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"ltcyW2","date":"1534118766","viewed":1058,"name":"Torus, Grid and Sentinel","username":"emh","description":"Force directed graph layout with help of Z-order sorted particles. 60 FPS on Radeon 7870. Key LEFT arrow to reset. Should work also in full screen after reset but prettier windowed (added blur to mitigate sharpness).","likes":22,"published":3,"flags":48,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"\/media\/previz\/buffer03.png","previewfilepath":"\/media\/previz\/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ vertical Gaussian blur pass\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixelSize = 1.\/ iChannelResolution[0].xy;\n    vec2 uv = fragCoord.xy * pixelSize;\n\n    float v = pixelSize.y;\n\tvec4 sum = vec4(0.0);\n\tsum += texture(iChannel0, fract(vec2(uv.x, uv.y - 4.0*v)) ) * 0.05;\n\tsum += texture(iChannel0, fract(vec2(uv.x, uv.y - 3.0*v)) ) * 0.09;\n\tsum += texture(iChannel0, fract(vec2(uv.x, uv.y - 2.0*v)) ) * 0.12;\n\tsum += texture(iChannel0, fract(vec2(uv.x, uv.y - 1.0*v)) ) * 0.15;\n\tsum += texture(iChannel0, fract(vec2(uv.x, uv.y + 0.0*v)) ) * 0.16;\n\tsum += texture(iChannel0, fract(vec2(uv.x, uv.y + 1.0*v)) ) * 0.15;\n\tsum += texture(iChannel0, fract(vec2(uv.x, uv.y + 2.0*v)) ) * 0.12;\n\tsum += texture(iChannel0, fract(vec2(uv.x, uv.y + 3.0*v)) ) * 0.09;\n\tsum += texture(iChannel0, fract(vec2(uv.x, uv.y + 4.0*v)) ) * 0.05;\n    \n    fragColor.xyz = sum.xyz\/0.98; \/\/ normalize\n\tfragColor.a = 1.;\n    \n    fragColor = (fragColor + texture(iChannel1, uv)) \/ 2.0;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"precision highp float;\nprecision highp int;\n\n#define mortonBuffer iChannel0\n#define sortedBuffer iChannel0\n#define particleBuffer iChannel0\n#define pixelNearestBuffer iChannel1\n\n\/\/#define maxRes min(vec2(800.0, 450.0), iResolution.xy)\n#define maxRes min(vec2(512.0, 512.0), iResolution.xy)\n\/\/#define maxRes min(vec2(128.0, 128.0), iResolution.xy)\n\/\/#define maxRes min(vec2(512.0, 256.0), iResolution.xy)\n\/\/#define maxRes min(vec2(iResolution.x, 256.0), iResolution.xy)\n\/\/#define maxRes min(vec2(512.0, iResolution.y), iResolution.xy)\n\/\/#define maxRes iResolution.xy\n#define realRes iResolution.xy\n#define powerOfTwoRes vec2(2048.0, 2048.0)\n\/\/#define realRes maxRes\n\/\/#define maxRes iResolution.xy\n\n\/\/ Try this true for more Matrix fun :)\nconst bool justSentinels = false;\n\n\/\/ number of particles will be 2^magicNumberDoNotChange = 64k\n\/\/ I haven't figured out why it seems to work only when this number is 16\nconst int magicNumberDoNotChange = 16;\nconst int MAX_ITER = 12;\nconst int maxBin = 32;\nconst int vec4Count = 1;\n#define PART part\nconst float M_PI = 3.14159265358979323846264338327950288;\n\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 \/ 3.0, 1.0 \/ 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nint getMaxPasses2(vec2 res) {\n    return int(ceil(log2(res.x * res.y)));\n}\n\nstruct mPartitionData {\n    int partitionCount;\n    int maxIndex;\n    int particlesPerPartition;\n    int index;\n    int partitionIndex;\n    int offset;\n    int pastIndex;\n    int futureIndex;\n    ivec2 futureCoord;\n    vec4 futureParticle;\n    bool overflow;\n};\n    \nvec2 extractPosition(vec4 data) {\n    return data.yz;\n}\n\n\/\/ BEGIN QUALITY HASHES\n\nuint baseHash(uvec2 p)\n{\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\n\n\/\/---------------------2D input---------------------\n\nfloat hash12(uvec2 x)\n{\n    uint n = baseHash(x);\n    return float(n)*(1.0\/float(0xffffffffU));\n}\n\nvec2 hash22(uvec2 x)\n{\n    uint n = baseHash(x);\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))\/float(0x7fffffff);\n}\n\nvec3 hash32(uvec2 x)\n{\n    uint n = baseHash(x);\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3(rz & uvec3(0x7fffffffU))\/float(0x7fffffff);\n}\n\nvec4 hash42(uvec2 x)\n{\n    uint n = baseHash(x);\n    uvec4 rz = uvec4(n, n*16807U, n*48271U, n*69621U); \/\/see: http:\/\/random.mat.sbg.ac.at\/results\/karl\/server\/node4.html\n    return vec4(rz & uvec4(0x7fffffffU))\/float(0x7fffffff);\n}\n\n\/\/--------------------------------------------------\n\n\n\/\/Example taking an arbitrary float value as input\n\/*\n\tThis is only possible since the hash quality is high enough so that\n\tfloored float input doesn't break the process when the raw bits are used\n*\/\nvec4 hash42(vec2 x)\n{\n    uint n = baseHash(floatBitsToUint(x));\n    uvec4 rz = uvec4(n, n*16807U, n*48271U, n*69621U);\n    return vec4(rz & uvec4(0x7fffffffU))\/float(0x7fffffff);\n}\n\n\/\/ END QUALITY HASHES\n\n\nfloat hash( uvec2 x )\n{\n    uvec2 q = 1103515245U * ( (x>>1U) ^ (x.yx   ) );\n    uint  n = 1103515245U * ( (q.x  ) ^ (q.y>>3U) );\n    return float(n) * (1.0\/float(0xffffffffU));\n}\n\nvec2 getRes(vec2 res) {\n    \/\/return vec2(exp2(ceil(log2(max(res.x, res.y)))));\n    return powerOfTwoRes;\n}\n\nint toIndexCol(in vec2 fragCoord, in vec2 resolution, inout vec3 col) {\n    int xl = int(fragCoord.x);\n    int yl = int(fragCoord.y);\n    ivec2 res = ivec2(resolution);\n    int div2 = 1;\n    \/*\n    for (int i = 0; i < MAX_ITER; i++) {\n        res \/= 2;\n        div2 *= 2;\n        if (res.x == 0 && res.y == 0) break;\n    }\n    res = ivec2(div2);\n\t*\/\n    int index = 0;\n    int div = 1;\n    div2 = 1;\n    bool colorDone = false;\n    for (int i = 0; i < MAX_ITER; i++) {\n        ivec2 rest = res % 2;\n        res \/= 2;\n        if (res.x == 0 && res.y == 0) break;\n        div *= 4;\n        div2 *= 2;\n        int x = int(xl >= res.x);\n        int y = int(yl >= res.y);\n        xl -= x * res.x;\n        yl -= y * res.y;\n        \/\/res += x * rest.x;\n        \/\/res += y * rest.y;\n        int thisIndex = y * 2 + x;\n        index = index * 4 + thisIndex;\n\n        if (!colorDone) {\n            vec2 uv = vec2(xl, yl) \/ vec2(res);\n            vec2 center = vec2(0.5);\n            float d = distance(uv, center);\n            float r = float(d < 0.25);\n            bool border = d > 0.25 - 0.02 \/ float(div2) && d < 0.25;\n            if (border) {\n                colorDone = true;\n            } else {\n            \tcol = vec3(float(int(col) ^ int(r)));\n            }\n        }\n    }\n    \/\/return res.x * res.y - index - 1;\n    return index;\n}\n\nint toIndexFull(in vec2 fragCoord, in vec2 resolution) {\n    vec3 col = vec3(0.0);\n    int index = toIndexCol(fragCoord, resolution, col);\n    \/\/index += 1;\n    return index;\n}\n\nivec2 fromIndexFull(in int index, in vec2 resolution) {\n    \/\/index -= 1;\n    ivec2 fc = ivec2(0);\n    int div = 1;\n    ivec2 div2 = ivec2(1);\n    ivec2 res = ivec2(resolution);\n    \/\/index = res.x * res.y - index - 1;\n    for (int i = 0; i < MAX_ITER; i++) {\n        res \/= 2;\n        \/\/int rx = res.x % 2 == 0 ? 2 : 1;\n        \/\/int ry = res.y % 2 == 0 ? 2 : 1;\n\n        int thisIndex = index % 4;\n        fc.x += div2.x * (thisIndex % 2);\n        fc.y += div2.y * (thisIndex \/ 2);\n        index = index \/ 4;\n\n        div2 *= 2;\n        if (index == 0) break;\n    }\n    return fc;\n}\n\nivec2 fromLinear(in int index, in vec2 resolution) {\n    \/\/index -= 1;\n    return ivec2(index % int(resolution.x), index \/ int(resolution.x));\n}\n\nint toLinear(in vec2 fragCoord, in vec2 resolution) {\n    int index = int(fragCoord.x) + int(fragCoord.y) * int(resolution.x);\n    \/\/index += 1;\n    return index;\n}\n\n#define toIndex(a) toIndex2(mortonBuffer, a, realRes)\nint toIndex2(in sampler2D channel, in vec2 fragCoord, in vec2 res) {\n    ivec2 fc = ivec2(fragCoord * res);\n    vec4 index = texelFetch(channel, fc, 0);\n    return int(index.w);\n}\n\nvec2 getPosition(sampler2D channel, int index, vec2 res) {\n    ivec2 fc = fromLinear(index, res);\n    vec4 data = texelFetch(channel, fc, 0);\n    return fract(extractPosition(data));\n}\n\nint maxLinear(vec2 res) {\n    return int(exp2(floor(log2(float(toLinear(res - 1.0, res))))));\n}\n\nbool isLinearValid(in int index, vec2 iResolution) {\n    vec2 res = iResolution.xy;\n    \/\/return true;\n\treturn index < maxLinear(iResolution);\n}\n\nbool isValid(in vec2 fragCoord, vec2 iResolution) {\n    vec2 res = iResolution.xy;\n    return isLinearValid(toLinear(fragCoord, res), iResolution);\n}\n\n#define getPartitionData(a, b, c) getPartitionData2(a, b, c, realRes)\nmPartitionData getPartitionData2(sampler2D channel, vec2 fragCoord, vec2 res, vec2 rRes) {\n    \/\/fragCoord = fragCoord \/ rRes * res;\n    mPartitionData mRet;\n    \/\/int maxPasses = getMaxPasses(res);\n    \/\/mRet.partitionCount = int(exp2(ceil(log2(float(maxPasses)))));\n    mRet.partitionCount = magicNumberDoNotChange;\n    \/\/mRet.maxIndex = toLinear(res - 1.0, res);\n    mRet.maxIndex = maxLinear(res);\n    mRet.particlesPerPartition = mRet.maxIndex \/ mRet.partitionCount;\n    mRet.index = toLinear(fragCoord, res);\n    mRet.partitionIndex = mRet.index \/ mRet.particlesPerPartition;\n    mRet.offset = mRet.index % mRet.particlesPerPartition;\n    mRet.futureIndex = mRet.index - mRet.particlesPerPartition;\n    mRet.futureCoord = fromLinear(mRet.futureIndex, res);\n    mRet.futureParticle = texelFetch(channel, mRet.futureCoord, 0);\n    mRet.pastIndex = mRet.index + mRet.particlesPerPartition;\n    mRet.overflow = mRet.index >= mRet.maxIndex;\n    \n    \/\/(mRet.partitionIndex - 1) * mRet.particlesPerPartition + mRet.offset;\n\n\n    return mRet;\n}\n\nint getMaxPartition(mPartitionData pd) {\n    \/\/ TODO: optimize \/ hardcode\n    int k = 0;\n    for (int i = 0; i <= pd.partitionCount; i++) {\n        int n = 1 << i;\n\t\tif (2 * n > pd.particlesPerPartition || pd.particlesPerPartition % n != 0) break;\n        k = i;\n    }\n    return k + 1;\n    \/\/return k;\n}\n\nstruct mRet {\n    int dIndex;\n    int Am;\n    vec4 vi;\n    vec4 v;\n    vec2 pos;\n    bool valid;\n};\n\n#define getMD(a, b, c) getMD2(particleBuffer, mortonBuffer, a, b, c, realRes)\nmRet getMD2(sampler2D channel, sampler2D mchannel, int part, int m, vec2 res, vec2 rRes) {\n    vec2 fc = vec2(fromLinear(m, res));\n    vec4 v = texelFetch(channel, ivec2(fc), 0);\n    vec2 pos = extractPosition(v);\n    int Am = toIndex2(mchannel, pos, rRes);\n    int maxIndex = toLinear(res - 1.0, res);\n    bool valid = m >= 0 && m <= maxIndex && isLinearValid(m, res);\n    \/\/valid = true;\n    return mRet(m, Am, vec4(0.0), v, pos, valid);\n}\n\n#define getM(a, b, c) getM2(sortedBuffer, particleBuffer, mortonBuffer, a, b, c, realRes)\nmRet getM2(sampler2D channel, sampler2D pchannel, sampler2D mchannel, int part, int m, vec2 res, vec2 rRes) {\n    vec2 fc = vec2(fromLinear(m, res));\n    vec4 v = texelFetch(channel, ivec2(fc), 0);\n    mRet ret2 = getMD2(pchannel, mchannel, part, int(v[part]), res, rRes);\n    int maxIndex = toLinear(res - 1.0, res);\n    bool valid = m >= 0 && m <= maxIndex && isLinearValid(m, res);\n    \/\/valid = true;\n    return mRet(int(v[part]), ret2.Am, v, ret2.v, ret2.pos, valid && ret2.valid);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"\/presets\/tex00.jpg","previewfilepath":"\/presets\/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ Resources:\n\/\/ https:\/\/www.ics.uci.edu\/~goodrich\/pubs\/skip-journal.pdf\n\/\/ Sorting with GPUs: A Survey: https:\/\/arxiv.org\/pdf\/1709.02520.pdf\n\n\/\/ Practice JavaScript implementation: http:\/\/jsbin.com\/zeyiraw\/\n\n\/\/ https:\/\/www.shadertoy.com\/view\/XlcGD8\n\/\/ https:\/\/developer.nvidia.com\/gpugems\/GPUGems2\/gpugems2_chapter46.html\n\/\/ https:\/\/stackoverflow.com\/questions\/26093629\/glsl-odd-even-merge-sort\n\/\/ https:\/\/bl.ocks.org\/zz85\/cafa1b8b3098b5a40e918487422d47f6\n\n#define resetPressed (texelFetch(iChannel1, ivec2(KEY_LEFT,1),0 ).x > 0.5)\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nint extractIndex(vec4 v, int part) {\n    return int(v[PART]);\n}\n\nint getIndex(int part, mRet A, vec2 res) {\t\n    return A.Am;\n}\n\nbool compare(int part, mRet A, mRet B, vec2 res) {\n    return getIndex(part, A, res) < getIndex(part, B, res);\n}\n\nbool cutValid(int part, int n1, int n2, int astart, int bstart, int to, int m2, int x, vec2 res) {\n    int apos = m2 - 1;\n    bool aValid = apos >= 0 && apos < n1;\n    int bpos = to - m2 - 1;\n    bool bValid = bpos >= 0 && bpos < n2;\n\n    mRet Amret = getM(part, astart + apos, res);\n    mRet Bmret = getM(part, bstart + bpos, res);\n\n    int cv11 = getIndex(part, Amret, res);\n    int cv12 = getIndex(part, Bmret, res);\n    return (\n        aValid && bValid && apos >= 0 && bpos >= 0 ? max(cv11, cv12) <= x\n        : bValid && apos < 0 && bpos >= 0 ? cv12 <= x\n        : aValid && apos >= 0 && bpos < 0 ? cv11 <= x\n        : Amret.valid && Bmret.valid);\n}\n\nbool cutCValid(int part, int n1, int n2, int astart, int bstart, int to, int bm2, int x, vec2 res) {\n    int apos = to - bm2 - 1;\n    int bpos = bm2 - 1;\n    bool aValid = apos >= 0 && apos < n1;\n    bool bValid = bpos >= 0 && bpos < n2;\n\n    mRet Amret = getM(part, astart + apos, res);\n    mRet Bmret = getM(part, bstart + bpos, res);\n\tint cvc11 = getIndex(part, Amret, res);\n    int cvc12 = getIndex(part, Bmret, res);\n    return (\n    \taValid && bValid && apos >= 0 && bpos >= 0 ? max(cvc11, cvc12) <= x\n        : bValid && apos < 0 && bpos >= 0 ? cvc12 <= x\n        : aValid && apos >= 0 && bpos < 0 ? cvc11 <= x\n        : Amret.valid && Bmret.valid);\n}\n\nmRet checkIndex(int part, int n1, int n2, int astart, int bstart, int to, int apos, vec2 res) {\n    bool aValid = apos >= 0 && apos < n1;\n    int bpos = to - apos;\n    bool bValid = bpos >= 0 && bpos < n2;\n\n    mRet Amret = getM(part, astart + apos, res);\n    mRet Bmret = getM(part, bstart + bpos, res);\n\n    int candA = getIndex(part, Amret, res);\n    bool candAv = cutValid(part, n1, n2, astart, bstart, to, apos, candA, res) && aValid;\n    Amret.valid = Amret.valid && candAv;\n\n    int candB = getIndex(part, Bmret, res);\n    bool candBv = cutCValid(part, n1, n2, astart, bstart, to, bpos, candB, res) && bValid;\n    Bmret.valid = Bmret.valid && candBv;\n\n    if (candAv && candBv) {\n        if (candA < candB) {\n            return Amret;\n        } else {\n            return Bmret;\n        }\n    } else if (candAv) {\n        return Amret;\n    }\n    return Bmret;\n}\n\nmRet binarySearchForMergeSlim(\n    int part,\n    int targetOffset, int n1, int n2, vec2 res,\n    int astart, int bstart) {\n\n    int L1 = min(max(targetOffset + 1 - n1, 0), n1 - 1);\n    int R1 = min(targetOffset + 1, n1);\n    int L2 = min(max(targetOffset + 1 - n2, 0), n2 - 1);\n    int R2 = min(targetOffset + 1, n2);\n\n    int OL1 = L1;\n    int OR2 = R2;\n\n    int i = 0;\n\n    mRet ret;\n\n    bool bValid = true;\n\n    for (i = 0; i < maxBin && L1 < R1 && (L2 < R2 || !bValid); i++) {\n        int m = (L1 + R1) \/ 2 + (L1 + R1) % 2;\n        int bm = targetOffset - m;\n        int apos = m;\n        bool aValid = apos >= 0 && apos < n1;\n        int bpos = bm;\n        bValid = bpos >= 0 && bpos < n2;\n\n        mRet Amret = getM(part, astart + apos, res);\n        aValid = aValid && Amret.valid;\n        mRet Bmret = getM(part, bstart + bpos, res);\n        bValid = bValid && Bmret.valid;\n\n        bool comparison = compare(part, Amret, Bmret, res) && aValid && bValid;\n        bool inUpperHalf = comparison;\n\n        \/\/ m + 1 to R1\n        L1 = inUpperHalf ? m : L1;\n        \/\/ L1 to m\n        R1 = !inUpperHalf ? m - 1 : R1;\n        \/\/ bm + 1 to R2\n        L2 = !inUpperHalf ? bm : L2;\n        \/\/ L2 to bm\n        R2 = inUpperHalf ? bm : R2;\n    }\n    mRet error = mRet(-1, -1, vec4(-1.0), vec4(-1.0), vec2(-1.0), false);\n    \/\/mRet error = mRet(-1, vec4(-1.0), false);\n\n    int apos = L1;\n    int bpos = targetOffset - L1;\n    bValid = bpos >= 0 && bpos < n2;\n\n    mRet AL1ret = getM(part, astart + apos, res);\n    mRet BL1ret = getM(part, bstart + bpos, res);\n    \/\/return AL1ret;\n\n    \/\/ XXX: AL1ret and BL1ret should be valid I hope\n    int m2 = getIndex(part, AL1ret, res) < getIndex(part, BL1ret, res) && bValid ? L1 + 1 : L1;\n    int bm2 = OR2 - (m2 - OL1);\n    bool bm2Valid = bm2 >= 0 && bm2 < n2;\n    bool bm2Min1Valid = bm2 - 1 >= 0 && bm2 - 1 < n2;\n\n    int to = targetOffset;\n\n    mRet cand1 = checkIndex(part, n1, n2, astart, bstart, to, m2, res);\n    mRet cand2 = checkIndex(part, n1, n2, astart, bstart, to, bm2, res);\n    cand2.valid = cand2.valid && bm2Valid;\n    mRet cand3 = checkIndex(part, n1, n2, astart, bstart, to, m2 - 1, res);\n    mRet cand4 = checkIndex(part, n1, n2, astart, bstart, to, bm2 - 1, res);\n    cand4.valid = cand4.valid && bm2Min1Valid;\n\n    ret = cand1;\n    if (cand2.valid && (compare(part, cand2, ret, res) || !ret.valid)) {\n        ret = cand2;\n    }\n    if (cand3.valid && (compare(part, cand3, ret, res) || !ret.valid)) {\n        ret = cand3;\n    }\n    if (cand4.valid && (compare(part, cand4, ret, res) || !ret.valid)) {\n        ret = cand4;\n    }\n    mRet AnMin1 = getM(part, astart + n1 - 1, res);\n    mRet BtoMinN = getM(part, bstart + to - n1, res);\n    mRet BnMin1 = getM(part, bstart + n2 - 1, res);\n    mRet AtoMinN = getM(part, astart + to - n2, res);\n    if (targetOffset >= n1 && compare(part, AnMin1, BtoMinN, res) && BtoMinN.valid) {\n        ret = BtoMinN;\n    }\n    if (targetOffset >= n2 && compare(part, BnMin1, AtoMinN, res) && AtoMinN.valid) {\n        ret = AtoMinN;\n    }\n\n    if (i >= maxBin - 1) {\n        ret = error;\n    }\n    return ret;\n}\n\nstruct mcData {\n    int pass;\n    int n;\n    bool overflow;\n    int index;\n    int base;\n    int astart;\n    int bstart;\n    int targetOffset;\n};\n\nmcData getMCData(int part,mPartitionData pd) {\n    mcData ret;\n    ret.pass = max(0, pd.partitionIndex - 1);\n    ret.n = (1 << ret.pass);\n    ret.overflow = 2 * ret.n > pd.particlesPerPartition || pd.particlesPerPartition % ret.n != 0;\n    ret.index = pd.index - pd.particlesPerPartition;\n    ret.base = ret.index - ret.index % (2 * ret.n);\n    ret.astart = ret.base;\n    ret.bstart = ret.base + ret.n;\n    ret.targetOffset = ret.index - ret.base;\n    return ret;\n}\n\nvec4 mergeSort(in vec2 fragCoord) {\n    vec4 fragColor = vec4(0.0);\n    vec2 res = maxRes;\n    mPartitionData pd = getPartitionData(sortedBuffer, fragCoord, res);\n\n    \/\/fragColor.x = texelFetch(sortedBuffer, ivec2(fragCoord), 0).x;\n\n    bool overflow = false;\n    for (int part = 0; part < vec4Count; part++) {\n        mcData ret = getMCData(PART, pd);\n    \toverflow = overflow || ret.overflow;\n        fragColor[PART] = binarySearchForMergeSlim(\n            PART, ret.targetOffset, ret.n, ret.n,\n            res, ret.astart, ret.bstart).vi[PART];\n    }\n    if (pd.partitionIndex + 1 < pd.partitionCount) {\n        fragColor.x += float(pd.particlesPerPartition);\n    }\n\n    if (overflow) {\n        \/\/fragColor.x = pd.futureParticle.x;\n        fragColor.x = 0.0;\n        return fragColor;\n    }\n\n    if (pd.partitionIndex == 0) {\n        fragColor.x = float(pd.index);\n        fragColor.x += float(pd.particlesPerPartition);\n    }\n\n    return fragColor;\n}\n\n\n\n\n\n\/\/ BEGIN PARTICLES\n\nconst float E = 1.0e-10;\n\nvec2 transformPos(vec2 pos) {\n    pos = (pos - 0.5) * 4.0 + 0.5;\n    pos = mod(pos, 1.0);\n    return pos;\n}\n\nvec2 getSpring(vec2 res, vec4 particle, vec2 pos) {\n    vec2 dv = particle.xy - pos;\n    float l = length(dv);\n    float k = 0.1;\n    float s = sign(k - l);\n    vec2 dvn = dv \/ (E + l);\n    l = min(abs(k - l), l);\n    \n    float SPRING_COEFF = 1.0e2;\n    float SPRING_LENGTH = 0.001;\n    float X = abs(SPRING_LENGTH - l);\n    float F_spring = SPRING_COEFF * X;\n    \n    if (l >= SPRING_LENGTH) {\n    \tdv = dvn * SPRING_LENGTH;\n    }\n    \n    \n    vec2 a = vec2(0.0);\n    \n    \/\/ Spring force\n    a += -dv * F_spring;\n    \n    return a;\n}\n\nvec2 getGravity(vec2 res, vec4 particle, vec2 pos) {\n    \/\/ Anti-gravity\n    float MIN_DIST = 0.01;\n    float G = 5.0e-1;\n    float m = 1.0 \/ (MIN_DIST * MIN_DIST);\n    vec2 dvg = particle.xy - pos.xy; \n    float l2 = length(dvg);\n    vec2 dvgn = dvg \/ l2;\n    \n    vec2 a = G * dvg \/ (MIN_DIST + m * l2 * l2);\n    \n    return a;\n}\n\nvec4 updateParticle(in vec4 particle, vec2 a) {\n    vec2 v = particle.xy - particle.zw;\n    \n    v += a;\n    v *= 0.5;\n    \n    if (particle.x + v.x < 0.0 || particle.x + v.x >= 1.0) {\n        v.x = -v.x;\n        v *= 0.5;\n    }\n    if (particle.y + v.y < 0.0 || particle.y + v.y >= 1.0) {\n        v.y = -v.y;\n        v *= 0.5;\n    }\n    \n    float maxSpeed = 0.01;\n    v = length(v) > maxSpeed ? maxSpeed * v \/ length(v) : v;\n    \n    particle.zw = particle.xy;\n    particle.xy += v;\n        \n    return particle;\n}\n\nvec4 computeParticles(in vec2 fragCoord )\n{\n    vec4 fragColor = vec4(0.0);\n    vec2 res = maxRes;\n    mPartitionData pd = getPartitionData(particleBuffer, fragCoord, res);\n    \n    if (iFrame == 0 || resetPressed) {\n        fragColor = vec4(0.0);\n        \n        vec2 particle = vec2(0.0);\n        if (pd.partitionIndex == 0) {\n            \/\/ position\n            vec2 fc = vec2(fromLinear(pd.index, res));\n            vec4 data = hash42(fc);\n            particle = transformPos(data.xy);\n        } else {\n            \/\/ velocity\n            vec2 fc = vec2(fromLinear(pd.futureIndex, res));\n            vec4 data = hash42(fc);\n\n            vec2 pos = transformPos(data.xy);\n            vec2 vel = 10.0 * (data.zw - 0.5) \/ res;\n            float maxSpeed = 1.0;\n            vel = length(vel) > maxSpeed ? maxSpeed * vel \/ length(vel) : vel;\n            vel = vec2(0.0);\n            vec2 oldPos = pos - vel;\n            particle = oldPos;\n        }\n\n        if (pd.overflow) {\n            particle = vec2(0.0);            \n        }\n        \n        fragColor.yz = particle;\n        \n        return fragColor;\n    }\n    \n    vec4 particle1 = vec4(0.0);\n    particle1.xy = getPosition(particleBuffer, pd.index, res);\n    particle1.zw = getPosition(particleBuffer, pd.pastIndex, res);\n    \n    const int k = 16;\n    const int k2 = 4;\n    int w = int(sqrt(float(k)));\n    vec2 a1 = vec2(0.0);\n    vec2 a2 = vec2(0.0);\n    int torusCount = int(pow(2.0, float(int(iTime \/ 4.0) % 10)));\n    int particlesPerTorus = pd.particlesPerPartition \/ torusCount;\n    int wp = int(sqrt(float(particlesPerTorus)));\n    int torus = pd.index \/ particlesPerTorus;\n    for (int i = 0; i < k; i++) {\n        {\n            int index = pd.index % particlesPerTorus;\n            vec2 fc = vec2(fromLinear(index, vec2(wp)));\n            vec2 offset = vec2(i % w - w \/ 2, i \/ w - w \/ 2);\n            if (torus % 3 == 0 && !justSentinels) {\n                \/\/ Torus\n                fc = fc + offset;\n            \tfc = mod(fc, vec2(wp));\n            } else if (torus % 3 == 1 && !justSentinels) {\n                \/\/ Cloth\n                fc = fc + offset;\n            \tfc = clamp(fc, vec2(0.0), vec2(wp));\n            } else {\n                \/\/ Sentinel\n                offset.x = -1.0;\n                offset.y = 0.0;\n                fc = fc + offset;\n                fc = clamp(fc, vec2(0.0), vec2(wp));\n                if (index % wp == 0) {\n                    fc = vec2(0.0);\n                }\n            }\n            int j = toLinear(fc, vec2(wp)) + pd.index - index;\n            vec2 p2 = getPosition(particleBuffer, j, res);\n            a1 += getSpring(res, particle1, p2.xy) \/ float(w);\n        }\n        for (int i2 = 0; i2 < k2; i2++) {\n            int w = int(sqrt(float(k)));\n            int index = pd.index % particlesPerTorus;\n            int j =\n                int(float(particlesPerTorus) * \n                    hash(uvec2(fragCoord + float(i * k + i2) * vec2(13.0, 29.0) * vec2(iFrame))));\n            j += pd.index - index;\n            vec2 p2 = getPosition(particleBuffer, j, res);\n            a1 += getGravity(res, particle1, p2.xy) \/ float(w * k2);\n        }\n    }\n    \n    vec2 updatedParticle = updateParticle(particle1, a1).xy;\n\t\n    fragColor.yz = pd.partitionIndex == 0 ? updatedParticle.xy : extractPosition(pd.futureParticle);\n    fragColor.yz = pd.overflow ? vec2(0.0) : fragColor.yz;\n    \n    return fragColor;\n}\n\n\/\/ END PARTICLES\n\n\nfloat computeZOrder(in vec2 fragCoord) {\n    vec2 res = realRes;\n    vec2 pres = getRes(res);\n    vec2 fc = fragCoord \/ res * pres;\n    int index = toIndexFull(fc, pres);\n    return float(index);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \/*\n    int maxLinear = toLinear(res - 1.0, res);\n    if (frag\n\t*\/\n    if (iFrame == 0 || resetPressed) {\n        fragColor.xyz = vec3(0.0);\n        fragColor.w = computeZOrder(fragCoord);\n    } else {\n        fragColor.w = texelFetch(mortonBuffer, ivec2(fragCoord), 0).w;\n    }\n    vec2 res = maxRes;\n    if (fragCoord.x >= res.x || fragCoord.y >= res.y) {\n        \/\/discard;\n        return;\n    }\n    fragColor.x = mergeSort(fragCoord).x;\n    fragColor.yz = computeParticles(fragCoord).yz;\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"int binarySearchLeftMost(int part, int T, vec2 res, vec2 fragCoord) {\n    mPartitionData pd = getPartitionData(sortedBuffer, fragCoord, res);\n    int n = pd.particlesPerPartition;\n    int maxPartition = getMaxPartition(pd);\n    int L = maxPartition * n;\n    int R = L + n;\n\n    int i = 0;\n    for (i = 0; i < maxBin && L < R; i++) {\n        int m = (L + R) \/ 2;\n        int Am = getM(part, m, res).Am;\n        L = Am < T ? m + 1 : L;\n        R = Am >= T ? m : R;\n    }\n    int ret = i < maxBin - 1 ? L : -1;\n    return ret;\n}\n\nint binarySearchRightMost(int part, int T, vec2 res, vec2 fragCoord) {\n    mPartitionData pd = getPartitionData(sortedBuffer, fragCoord, res);\n    int n = pd.particlesPerPartition;\n    int maxPartition = getMaxPartition(pd);\n    int L = maxPartition * n;\n    int R = L + n;\n\n    int i = 0;\n    for (i = 0; i < maxBin && L < R; i++) {\n        int m = (L + R) \/ 2;\n        int Am = getM(part, m, res).Am;\n        L = Am <= T ? m + 1 : L;\n        R = Am > T ? m : R;\n    }\n    int ret = i < maxBin - 1 ? L - 1 : -1;\n    return ret;\n}\n\nfloat doDistance(int part, in vec2 fragCoord, vec2 colorUV) {\n    vec2 res = maxRes;\n    \/\/vec2 oc = fragCoord \/ realRes * res;\n    vec2 oc = fragCoord;\n\n    int uvIndex = toIndex(colorUV);\n    int index3 = binarySearchLeftMost(part, uvIndex, res, oc);\n    int index4 = binarySearchRightMost(part, uvIndex, res, oc);\n\n    mRet mret = getM(part, index3, res);\n    int foundIndex = mret.Am;\n    vec4 v = mret.v;\n    float d = distance(colorUV, mret.pos);\n\n    int j = 0;\n    int a = min(index3, index4);\n    int b = max(index3, index4);\n    int maxIter = 10;\n    int retIndex = -1;\n    for (int j = 0; j < maxIter; j++) {\n        int i = a + j - maxIter \/ 2;\n        mRet mret = getM(part, i, res);\n        int foundIndex = mret.Am;\n        vec4 v = mret.v;\n        float d2 = distance(colorUV, mret.pos);\n        if (d2 < d) {\n            d = d2;\n            retIndex = i;\n        }\n    }\n\n    return float(retIndex);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \/\/fragCoord = floor(fragCoord \/ iResolution.xy * maxRes);\n    \n    vec2 res = maxRes;\n    \/\/ TODO: try +0.5\n    vec2 colorUV = (fragCoord + 0.0) \/ realRes;\n    \n\tvec4 old = texelFetch(pixelNearestBuffer, ivec2(fragCoord), 0);\n\n    for (int part = 0; part < vec4Count; part++) {\n    \tfloat oldIndex = old[part];\n\n        mRet mret1 = getM(part, int(oldIndex), res);\n        float d2 = distance(colorUV, mret1.pos);\n\n        float index = doDistance(part, fragCoord, colorUV);\n\n        mRet mret2 = getM(part, int(index), res);\n\n        float d3 = distance(colorUV, mret2.pos);\n\n        index = d3 < d2 ? index : oldIndex;\n\n        fragColor[PART] = index;\n    }\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\/\/ Fork of \"Z Particle Sort Pipeline\" by emh. https:\/\/shadertoy.com\/view\/Mtdyzs\n\/\/ 2018-08-09 11:43:19\n\nvoid lookup(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 res = maxRes;\n    int k = 1;\n    float mul = 1.0;\n    const float MAX = 1.0e10;\n    float rd = 0.0;\n    float mind = MAX;\n    vec2 colorUV = (fragCoord + 0.0) \/ realRes;\n    vec3 color = vec3(1.0);\n    int minIndex = -1;\n    bool firstHalf = true;\n    mPartitionData pd = getPartitionData(particleBuffer, fragCoord, res);\n\n    vec4 indexAndVelNearest = texelFetch(pixelNearestBuffer, ivec2(fragCoord), 0);\n\n    for (int dx = -k; dx <= k; dx++) {\n        for (int dy = -k; dy <= k; dy++) {\n            vec2 delta = vec2(dx, dy);\n            \/\/vec2 delta2 = vec2(sign(float(dx)) * exp2(abs(float(dx))), sign(float(dy)) * exp2(abs(float(dy))));\n\n            ivec2 fc = ivec2(fragCoord + mul * delta);\n            vec4 indexAndVel = texelFetch(pixelNearestBuffer, fc, 0);\n\n            for (int part = 0; part < vec4Count; part++) {\n                int i = int(indexAndVel[part]);\n                mRet iret = getM(part, i, res);\n                vec2 newPos = iret.pos;\n                \/\/vec2 newPos = vec2(fc) \/ realRes;\n                float d = distance(colorUV, newPos);\n                if (i >= 0 && d < mind) {\n                    minIndex = iret.dIndex;\n                    firstHalf = part == 0;\n                }\n                \/\/mind = i < 0 ? mind : min(d, mind);\n                mind = min(d, mind);\n                \/\/float f = 0.00005  \/ d;\n                float f = d;\n                rd = i < 0 ? rd : (d < (float(k) \/ realRes.x) ? f + rd : rd);\n                if (i >= 0 && (d < (float(k) \/ realRes.x))) {\n                    float h = float(iret.dIndex % pd.particlesPerPartition) \/ float(pd.particlesPerPartition);\n                    color = hsv2rgb(vec3(h, 1.0, 1.0));\n                    color = mix(vec3(1.0), color, d * iResolution.x \/ 10.0);\n                \t\/\/fragColor += clamp(0.01 * vec4(color, 1.0) * vec4(1.0 \/ (d * realRes.x)), 0.0, 1.0);\n                }\n            }\n        }\n    }\n\n    float h = float(minIndex % pd.particlesPerPartition) \/ float(pd.particlesPerPartition);\n    color = hsv2rgb(vec3(h, 1.0, 1.0));\n    color = mix(vec3(1.0), color, 100.0 * mind);\n\n    float size = minIndex >= 0 ? float(minIndex % 10 + 1) : 1.0;\n\n    float brightness = 1.0;\n    \/\/fragColor += clamp(brightness * vec4(color, 1.0) * vec4(1.0 \/ (mind * 1000.0)), 0.0, 1.0);\n    fragColor += clamp(brightness * vec4(color, 1.0) * vec4(1.0 \/ (mind * realRes.x)), 0.0, 1.0);\n    \/\/fragColor += clamp(brightness * vec4(color, 1.0) * vec4(1.0 \/ (rd * realRes.x)), 0.0, 1.0);\n    \/\/fragColor = vec4(1.0 * rd);\n}\n\nvoid debug(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 v0 = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec4 v1 = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    vec4 v2 = texelFetch(iChannel2, ivec2(fragCoord), 0);\n    vec4 v3 = texelFetch(iChannel3, ivec2(fragCoord), 0);\n    \/\/float val = float(int(v.w) % 1000) \/ 1000.0;\n    float val = float(int(v0.x) % 10000) \/ 10000.0;\n    fragColor = vec4(val);\n    \/\/fragColor.rb = v0.yz;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \/\/debug(fragColor, fragCoord);\n    lookup(fragColor, fragCoord);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\/\/ horizontal Gaussian blur pass\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixelSize = 1.\/ iChannelResolution[0].xy;\n    vec2 uv = fragCoord.xy * pixelSize;\n    \n    float h = pixelSize.x;\n\tvec4 sum = vec4(0.0);\n\tsum += texture(iChannel0, fract(vec2(uv.x - 4.0*h, uv.y)) ) * 0.05;\n\tsum += texture(iChannel0, fract(vec2(uv.x - 3.0*h, uv.y)) ) * 0.09;\n\tsum += texture(iChannel0, fract(vec2(uv.x - 2.0*h, uv.y)) ) * 0.12;\n\tsum += texture(iChannel0, fract(vec2(uv.x - 1.0*h, uv.y)) ) * 0.15;\n\tsum += texture(iChannel0, fract(vec2(uv.x + 0.0*h, uv.y)) ) * 0.16;\n\tsum += texture(iChannel0, fract(vec2(uv.x + 1.0*h, uv.y)) ) * 0.15;\n\tsum += texture(iChannel0, fract(vec2(uv.x + 2.0*h, uv.y)) ) * 0.12;\n\tsum += texture(iChannel0, fract(vec2(uv.x + 3.0*h, uv.y)) ) * 0.09;\n\tsum += texture(iChannel0, fract(vec2(uv.x + 4.0*h, uv.y)) ) * 0.05;\n    \n    fragColor.xyz = sum.xyz\/0.98; \/\/ normalize\n\tfragColor.a = 1.;\n    \n    \/\/fragColor = texture(iChannel0, uv);\n}","name":"Buffer D","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"XstSDS","date":"1461243240","viewed":1043,"name":"Ball with Noise Displacement","username":"emh","description":"Ball with Noise Displacement","likes":6,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Created by Eivind Magnus Hvidevold emnh\/2016 - raymarching by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n\/\/----------------------------------------------------------------------\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 \/ 3.0, 1.0 \/ 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n#define NUM_OCTAVES 5\n\nfloat fbm(vec3 x) {\n    float v = 0.0;\n    float a = 0.5;\n    vec3 shift = vec3(100);\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        v += a * noise(x);\n        x = x * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nfloat snoise2(vec4 x) {\n    \/*x *= 4.0;\n    vec3 y = x.xyz;\n    y += x.w;\n    return noise(y);\n\t*\/\n    x *= 0.4;\n    vec3 y = x.xyz;\n    y += x.w;\n    return fbm(y);\n}\n\nvec2 map(in vec3 pos) {    \n    vec3 o = pos;\n    \n    pos = pos - vec3(0.0, -1.5, 0.0);\n    vec2 mo = iMouse.xy\/iResolution.xy;\n    float ms = 3.14 * 2.0;\n    mat4 mrx = rotationMatrix(vec3(1.0, 0.0, 0.0), mo.y * ms);\n    mat4 mry = rotationMatrix(vec3(0.0, 1.0, 0.0), mo.x * ms);\n    \n    pos = (vec4(pos, 1.0) * mrx * mry).xyz;\n    \n    float scale = 50.0;\n    \/\/float y = pos.y * 0.01 * sin(iTime \/ 2.0) * sin(scale * pos.x) * sin(scale * pos.y) * sin(scale * pos.z);\n    float speed = 0.1;\n    float y = 0.1 * snoise2(vec4((vec4(pos, 1.0)).xyz * 10.0, iTime * 1.0));\n    \/\/y += 0.05 * snoise2(vec4((vec4(pos, 1.0) * mat_2).xyz, iTime * speed));\n    \/\/y += 0.10 * snoise2(vec4((vec4(pos, 1.0) * mat_3).xyz \/ 2.0, iTime * speed));\n    \n    \/\/float y = 0.03 * sin(scale * pos.x) * sin(scale * pos.y) * sin(scale * pos.z);\n    \/\/float y2 = (sin(scale * pos.x) * sin(scale * pos.y) * sin(scale * pos.z) + 1.0) \/ 2.0;\n    \/\/float y2 = abs(pos.x) + abs(pos.y) + abs(pos.z);\n    float y2 = 1.0;\n    \/\/float y2 = (1.0 + snoise(vec4(pos * 2.0, iTime \/ 10.0))) \/ 2.0;\n    \n    float ss = 5.0;\n    vec3 sphereO = pos; \/\/ - vec3(0.0, 0.25, 1.0);\n    \n    float sd = sdSphere(sphereO \/ ss, 0.5 + y) * ss;\n    \n    return vec2(sd, sd + iTime \/ 10.0);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n#if 0\n    float tp1 = (0.0-ro.y)\/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)\/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n\tfloat precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h\/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)\/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        \/\/ material        \n\t\t\/* col = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        \n\t\t\n        if( m<1.5 )\n        {\n            \n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            col = 0.4 + 0.1*f*vec3(1.0);\n        }*\/\n\t\tcol = hsv2rgb(vec3(m, 1.0, 1.0));\n\n        \/\/ lighting        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.20*dif*vec3(1.00,0.85,0.55);\n\t\tlin += 1.20*spe*vec3(1.00,0.85,0.55)*dif;\n        lin += 0.20*amb*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*dom*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.002*t*t ) );\n\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy\/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x\/iResolution.y;\n    vec2 mo = iMouse.xy\/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n\n\t\/\/ camera\t\n\t\/\/ vec3 ro = vec3( -0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 3.5*sin(0.1*time + 6.0*mo.x) );\n    \/\/vec3 ro = vec3( -0.5+3.5*cos(6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 3.5*sin(6.0*mo.x) );\n    vec3 ro = vec3( 3.5, 1.0, 3.5 );\n\tvec3 ta = vec3( -0.5, -2.0, -1.0 );\n\t\n\t\/\/ camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    \/\/ ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    \/\/ render\t\n    vec3 col = render( ro, rd );\n\n\tcol = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"XttcWM","date":"1532951013","viewed":979,"name":"Per-pixel particle structure","username":"emh","description":"Per-pixel particle data structure. Voronoi based on random graph construction and traversal. Will reinitialize on switch to full screen. Some random forces of various types applied + wave equation. High velocity particles are blue.","likes":13,"published":3,"flags":32,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Public Domain. By Eivind Magnus Hvidevold 30.07.2018.\n\n\/\/ Description:\n\/\/ Per-pixel particle data structure.\n\/\/ Voronoi based on random graph construction and traversal.\n\/\/ Will reinitialize on switch to full screen.\n\/\/ Some random forces of various types applied + wave equation.\n\/\/ High velocity particles are blue.\n\n\/\/ Buf A: Particle positions: xy pos, zw old pos\n\/\/ Buf B: Particle neighbour indices: x, y, z, w indexes neighbour in direction of each corner, respectively\n\/\/ Buf C: x: Nearest particle to pixel position\n\n\/\/ Inspired by https:\/\/www.shadertoy.com\/view\/XsjyRm .\n\/\/ See also https:\/\/www.shadertoy.com\/view\/4dGSDR for Efficient splatting.\n\nbool debug(out vec4 fragColor, in vec2 fragCoord) {\n    int frame = 0;\n    vec3 color = vec3(0.0);\n    vec2 uv = fragCoord \/ iResolution.xy;\n    for (int i = 1; i < 100; i++) {\n        vec2 iv = vec2(ivec2(i \/ 10, i % 10));\n        \n        vec2 pos = texelFetch(iChannel0, ivec2(iv), 0).xy;\n        \n        ivec2 particleCoord = ivec2(iv);\n        \n        ivec4 closest = ivec4(texelFetch(iChannel1, particleCoord, 0));\n        \n        vec2 vnext = vec2(particleCoord);\n        vec2 pos2 = getParticle(iResolution, iChannel0, iFrame, closest.x).xy;\n        vec2 pos3 = getParticle(iResolution, iChannel0, iFrame, closest.y).xy;\n        vec2 pos4 = getParticle(iResolution, iChannel0, iFrame, closest.z).xy;\n        vec2 pos5 = getParticle(iResolution, iChannel0, iFrame, closest.w).xy;\n        \n        \/\/ color = vec3(0.0);\n        if (int(closest.x) != -1) color += drawLine(uv, pos, pos2);\n        if (int(closest.y) != -1) color += drawLine(uv, pos, pos3);\n        if (int(closest.z) != -1) color += drawLine(uv, pos, pos4);\n        if (int(closest.w) != -1) color += drawLine(uv, pos, pos5);\n    }\n\t  \n    fragColor = vec4(color, 1.0);\n    return true;\n}\n\nvec3 vmul(float v) {\n    float r = 0.5;\/\/ + pow(v, 0.1);\n    float g = 0.5;\n    float b = 0.5;\n    float r2 = 0.0;\n    float g2 = 0.0;\n    float b2 = 0.1;\n    float vv = v > 0.002 ? 1.0 : 0.0;\n    vv = smoothstep(0.0, 0.004, v);\n    return mix(vec3(r, g, b), vec3(r2, g2, b2), vv);\n}\n\nvoid mainImage2(out vec4 fragColor, in vec2 fragCoord, in vec2 uv) {\n    \/*\n\tif (debug(fragColor, fragCoord)) {\n        return;\n    }\n\t*\/\n    \n    vec4 near = texelFetch(iChannel2, ivec2(fragCoord), 0);\n    vec2 iv = vec2(fragCoord) + near.yz;\n    int nextIndex = int(near.x);\n    \n    if (nextIndex == -1) {\n        fragColor.r = 1.0;\n        return;\n    }\n\t\n    \/\/int nextIndex = serializeUV(iFrame, getRandomParticlePos(iResolution, iChannel0, iv, frame, i));\n    vec2 closestPos = getParticle(iResolution, iChannel0, iFrame, nextIndex).xy;\n    \n    vec3 color = vec3(0.0);\n    vec3 colorBase = vec3(1.0);\n    float mind = distance(uv, closestPos);\n    float oldmind = 0.0;\n    \/\/float vmul = 1000.0;\n    \n    if (mind <= md) {\n        \/\/fragColor = vec4(1.0);\n    }\n    \/\/fragColor = vec4(float(i) \/ float(iter * iter));\n    \/\/return;\n    \/\/fragColor = vec4(mind \/ md * 0.01);\n    \/\/return;\n    const int iter2 = iter * iter;\n    int seen[iter2];\n    for (int i = 0; i < iter2; i++) {\n        seen[i] = -1;\n    }\n    int stack[iter2];\n    for (int i = 0; i < iter2; i++) {\n        stack[i] = -1;\n    }\n    \n    int oldIndex = nextIndex;\n    int closestIndex = nextIndex;\n    int stackPointer = 0;\n    stack[0] = nextIndex;\n    for (int i = 0; i < 1; i++) {\n    \/\/for (int i = 0; i < iter2 * iter2; i++) {\n    \/\/for (int i = 0; i < 100; i++) {\n        nextIndex = stack[stackPointer];\n        ivec4 closest = ivec4(getParticle(iResolution, iChannel1, iFrame, nextIndex));\n        seen[i] = nextIndex;\n        \n        vec2 pos2 = getParticle(iResolution, iChannel0, iFrame, closest.x).xy;\n        vec2 pos3 = getParticle(iResolution, iChannel0, iFrame, closest.y).xy;\n        vec2 pos4 = getParticle(iResolution, iChannel0, iFrame, closest.z).xy;\n        vec2 pos5 = getParticle(iResolution, iChannel0, iFrame, closest.w).xy;\n        \n        vec2 pos = closestPos;\n        \/\/ color = vec3(0.0);\n        \n        \n        if (nextIndex != -1) {\n            vec4 closest = getParticle(iResolution, iChannel0, iFrame, nextIndex);\n            vec2 v = closest.xy - closest.zw;\n            colorBase = vmul(length(v));\n        }\n        \n        bool lines = LINES;\n        if (lines && length(pos2) > 0.0) {\n            color += colorBase * drawLine(uv, pos, pos2);\n            color += colorBase * drawLine(uv, pos, pos3);\n            color += colorBase * drawLine(uv, pos, pos4);\n            color += colorBase * drawLine(uv, pos, pos5);\n        }\n        \n        {\n            vec2 cmp = uv;\n            \n            bool seenX = false;\n            bool seenY = false;\n            bool seenZ = false;\n            bool seenW = false;\n            for (int j = 0; j <= i && j <= iter2; j++) {\n                seenX = seenX || (seen[j] == closest.x);\n                seenY = seenY || (seen[j] == closest.y);\n                seenZ = seenZ || (seen[j] == closest.z);\n                seenW = seenW || (seen[j] == closest.w);\n            }\n            \n            float d2 = MAX_DIST;\n            if (!seenX && closest.x != -1) {\n            \tnextIndex = closest.x;\n            \tclosestPos = pos2;\n                d2 = distance(uv, closestPos);\n            }\n            if (!seenY && closest.y != -1 && distance(uv, pos3) < d2) {\n                nextIndex = closest.y;\n            \tclosestPos = pos3;\n                d2 = distance(uv, closestPos);\n            }\n            if (!seenZ && closest.z != -1 && distance(uv, pos4) < d2) {\n                nextIndex = closest.z;\n            \tclosestPos = pos4;\n                d2 = distance(uv, closestPos);\n            }\n            if (!seenW && closest.w != -1 && distance(uv, pos5) < d2) {\n                nextIndex = closest.w;\n            \tclosestPos = pos5;\n                d2 = distance(uv, closestPos);\n            }\n        }\n        \n        if (nextIndex == oldIndex) {\n            stackPointer = stackPointer > 0 ? stackPointer - 1 : 0;\n        } else {\n            stackPointer++;\n            stack[stackPointer] = nextIndex;\n        }\n        \n        float d = distance(uv, closestPos);\n        if (d < mind) {\n            mind = d;\n            closestIndex = nextIndex;\n            \/\/ accumulative glow\n            color += 0.1 * colorBase;\n            if (mind <= md) {\n            \tcolor += colorBase;\n            }\n        }\n        oldmind = mind;\n        oldIndex = nextIndex;\n    }\n    \n    \/\/colorBase = vec3(1.0, 1.0, 1.0);\n    \n    colorBase = vec3(1.0, 1.0, 1.0);\n    if (closestIndex != -1) {\n        vec4 closest = getParticle(iResolution, iChannel0, iFrame, closestIndex);\n        vec2 v = closest.xy - closest.zw;\n        colorBase = vmul(length(v));\n    }\n    \n    \/*\n    if (closestIndex > 0 && length(uv) < 0.5) {\n        colorBase.r = hash(uvec2(closestIndex+0, 0));\n        colorBase.g = hash(uvec2(closestIndex+1, 0));\n        colorBase.b = hash(uvec2(closestIndex+2, 0));\n    }*\/\n    \/\/color += colorBase * max(0.0, 1.0 - mind \/ md * 0.5);\n    \/\/color += colorBase * max(0.0, 1000000000.0 * pow(abs(mind - 0.1), 10.0));\n    if (mind <= md) {\n        \/\/color += vec3(1.0 - mind \/ md * 0.5);\n        \/\/color = vec3(1.0);\n    \tcolor += colorBase;\n    }\n    \/\/color = clamp(color, 0.0, 1.0);\n    \/\/fragColor = texelFetch(iChannel2, ivec2(fragCoord), 0) * 0.9 + vec4(color, 1.0);\n    \/\/color *= 10.0;\n    fragColor += vec4(color, 1.0);\n    \/\/fragColor = vec4(mind \/ md * 0.1);\n    \n    \/\/fragColor = texelFetch(iChannel2, ivec2(fragCoord), 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    int dd = iter;\n    vec2 uv = dnpos(fragCoord \/ iResolution.xy);\n    for (int dx = -dd; dx <= dd; dx++) {\n        for (int dy = -dd; dy <= dd; dy++) {\n            vec2 fc = vec2(fragCoord) + 10.0 * vec2(dx, dy);\n            fc = clamp(fc, vec2(0.0), iResolution.xy - vec2(dd));\n            mainImage2(fragColor, fc, uv);\n        }\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec2 getContribution(in vec3 iResolution, in sampler2D iChannel0, in int frame, in int index, in vec2 pos) {\n    vec2 pos2 = getParticle(iResolution, iChannel1, iFrame, index).xy;\n    vec2 v = pos2 - pos;\n    vec2 va = pos2 - vec2(0.0);\n    float d = length(v);\n    float d2 = d + 1.0;\n    float dva = length(va);\n    float dva2 = dva + 1.0;\n    \n    float k = 0.001;\n    vec2 spring = (d < k * 2.0) ? 0.1 * v \/ abs(k - d) : vec2(0.0);\n    vec2 test = d < 0.1 ? 0.0001 * v \/ (d * d2) : vec2(0.0);\n    vec2 gravity = d < 0.1 ? 0.001 * v \/ (d2 * d2) : vec2(0.0);\n    vec2 antigravity = 0.000001 * -v \/ (d2 * d2);\n    \n    vec2 downgravity = vec2(0.0, -0.0000001);\n    \n    vec2 center = 0.0001 * -va \/ (dva2 * dva2);\n    vec2 anticenter = 0.00001 * va \/ (dva2 * dva2);\n    \/\/return spring + anticenter; \/\/spring + antigravity;\n    \n    vec2 a = vec2(0.0);\n    int mf = frame % 5;\n    if (mf == 0) {\n        a = spring;\n    } else if (mf == 1) {\n        a = test;\n    } else if (mf == 2) {\n        a = gravity;\n    } else if (mf == 3) {\n        a = antigravity;\n    } else if (mf == 4) {\n        a = anticenter;\n    }\n    \n    a = spring + test + gravity; \/\/ + downgravity;\n    \/\/a  = spring + gravity + anticenter;\n    \/\/a = spring;\n    float ma = 0.0001;\n    a = clamp(a, -ma, ma);\n    \n    return a;\n}\n\nvec2 getWaveContribution(in vec3 iResolution, in sampler2D iChannel0, in int frame, in int index, in vec2 pos) {\n    vec4 pos22 = getParticle(iResolution, iChannel1, iFrame, index);\n    vec2 pos2 = pos22.xy;\n    vec2 oldPos2 = pos22.zw;\n    vec2 v = pos2 - oldPos2;\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ fragColor = vec4(0.0,0.0,1.0,1.0);\n    \/\/if (fragCoord.y > 0.1) return;\n    vec2 uv = fragCoord \/ iResolution.xy;\n    if (iFrame == 0 || texelFetch(iChannel1, ivec2(iResolution.xy) - ivec2(1.0), 0).xy == vec2(0.0)) {\n        vec2 pos = dnpos(vec2(rand(fragCoord), rand(-fragCoord.yx)));\n        vec2 oldPos = pos;\n        fragColor = vec4(pos, oldPos);\n    } else {\n        vec4 old = texelFetch(iChannel1, ivec2(fragCoord), 0);\n        vec2 oldPos = old.zw;\n        vec2 pos = old.xy;\n        vec2 v = pos - oldPos;\n        \n        vec2 a = vec2(0.0);\n        \n        ivec4 neighbourClosest = ivec4(texelFetch(iChannel2, ivec2(fragCoord), 0));\n\n        a += getContribution(iResolution, iChannel1, iFrame, neighbourClosest.x, pos);\n        a += getContribution(iResolution, iChannel1, iFrame, neighbourClosest.y, pos);\n        a += getContribution(iResolution, iChannel1, iFrame, neighbourClosest.z, pos);\n        a += getContribution(iResolution, iChannel1, iFrame, neighbourClosest.w, pos);\n        for (int i = 0; i < forceIter * forceIter; i++) {\n            ivec2 particleUV = getRandomParticlePos(iResolution, iChannel0, fragCoord, iFrame, i);\n            a += getContribution(iResolution, iChannel1, iFrame, serializeUV(iResolution, iFrame, particleUV), pos);\n        }\n        vec2 vw = vec2(0.0);\n        vw += getWaveContribution(iResolution, iChannel1, iFrame, neighbourClosest.x, pos);\n        vw += getWaveContribution(iResolution, iChannel1, iFrame, neighbourClosest.y, pos);\n        vw += getWaveContribution(iResolution, iChannel1, iFrame, neighbourClosest.z, pos);\n        vw += getWaveContribution(iResolution, iChannel1, iFrame, neighbourClosest.w, pos);\n        vw *= 0.25;\n        v += 0.01 * vw;\n        \n        v += a;\n        \/\/ friction\n        v *= 0.99;\n        \n        oldPos = pos;\n        if (pos.x + v.x <= -1.0 || pos.x + v.x >= 1.0) {\n            v.x = -v.x;\n            \/\/v *= 0.5;\n        }\n        if (pos.y + v.y <= -1.0 || pos.y + v.y >= 1.0) {\n            v.y = -v.y;\n            \/\/v *= 0.5;\n        }\n        pos += v;\n        \n        \/*\n        if (length(pos) < 0.01) {\n            pos = vec2(0.5);\n            oldPos = pos;\n        \t\/\/pos = vec2(rand(fragCoord + 1.0), rand(-fragCoord.yx - 1.0));\n        \t\/\/oldPos = pos;\n        }*\/\n        \n        fragColor = vec4(pos, oldPos);\n    }\n    \/\/vec2 uv = fragCoord \/ iResolution.xy * 40.0;\n    \/\/fragColor = vec4(uv, uv);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define checkPos checkPos2\n\n\/\/ 4 closest points\nvoid checkPos1(in int i, in vec2 pos, in vec2 pos2, inout vec4 mind, inout ivec4 closest) {\n    float d = distance(pos, pos2);\n    if (d == 0.0) return;\n    \n    if (d < mind.x) {\n        mind.w = mind.z;\n        closest.w = closest.z;\n\n        mind.z = mind.y;\n        closest.z = closest.y;\n\n        mind.y = mind.x;\n        closest.y = closest.x;\n\n        mind.x = d;\n        closest.x = i;\n    } else if (d < mind.y) {\n        mind.w = mind.z;\n        closest.w = closest.z;\n\n        mind.z = mind.y;\n        closest.z = closest.y;\n\n        mind.y = d;\n        closest.y = i;\n    } else if (d < mind.z) {\n        mind.w = mind.z;\n        closest.w = closest.z;\n\n        mind.z = d;\n        closest.z = i;\n    } else if (d < mind.w) {\n        mind.w = d;\n        closest.w = i;\n    }\n}\n\n\/\/ closest points in each corner direction\nvoid checkPos2(in int i, in vec2 pos, in vec2 pos2, inout vec4 mind, inout ivec4 closest) {\n    float d = distance(pos, pos2);\n    if (d == 0.0) return;\n                \n    if (d < mind.x && pos2.x < pos.x && pos2.y < pos.y) {\n        mind.x = d;\n        closest.x = i;\n    }\n    if (d < mind.y && pos2.x > pos.x && pos2.y > pos.y) {\n        mind.y = d;\n        closest.y = i;\n    }\n    if (d < mind.z && pos2.y < pos.y && pos2.x > pos.x) {\n        mind.z = d;\n        closest.z = i;\n    }\n    if (d < mind.w && pos2.y > pos.y && pos2.x < pos.x) {\n        mind.w = d;\n        closest.w = i;\n    }\n}\n\n\/\/ closest points in each direction\nvoid checkPos3(in int i, in vec2 pos, in vec2 pos2, inout vec4 mind, inout ivec4 closest) {\n    float d = distance(pos, pos2);\n    if (d == 0.0) return;\n        \n    if (d < mind.x && pos2.x < pos.x) {\n        mind.x = d;\n        closest.x = i;\n    }\n    if (d < mind.y && pos2.x > pos.x) {\n        mind.y = d;\n        closest.y = i;\n    }\n    if (d < mind.z && pos2.y < pos.y) {\n        mind.z = d;\n        closest.z = i;\n    }\n    if (d < mind.w && pos2.y > pos.y) {\n        mind.w = d;\n        closest.w = i;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 old = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec2 pos = old.xy;\n    int self = int(fragCoord.x);\n    vec4 mind = vec4(MAX_DIST);\n    ivec4 closest = ivec4(-1);\n    int frame = iFrame;\n    if (iFrame > 0) {\n        closest = ivec4(texelFetch(iChannel1, ivec2(fragCoord), 0));\n        \n        int oldFrame = iFrame - 1;\n        \/\/vec2 pos2 = getRandomParticle(iResolution, iChannel0, fragCoord, oldFrame, closest.x).xy;\n        vec2 pos2 = getParticle(iResolution, iChannel0, frame, closest.x).xy;\n        vec2 pos3 = getParticle(iResolution, iChannel0, frame, closest.y).xy;\n        vec2 pos4 = getParticle(iResolution, iChannel0, frame, closest.z).xy;\n        vec2 pos5 = getParticle(iResolution, iChannel0, frame, closest.w).xy;\n        \n        mind.x = closest.x != -1 ? distance(pos, pos2) : MAX_DIST;\n        mind.y = closest.y != -1 ? distance(pos, pos3) : MAX_DIST;\n        mind.z = closest.z != -1 ? distance(pos, pos4) : MAX_DIST;\n        mind.w = closest.w != -1 ? distance(pos, pos5) : MAX_DIST;\n    }\n    for (int i = 0; i < iter * iter; i++) {\n        \/\/ if (i == self) continue;\n        \/\/ivec2 p = ivec2(uvec2(fragCoord) + 1920U*1080U*uint(iFrame));\n        ivec2 particleUV = getRandomParticlePos(iResolution, iChannel0, fragCoord, iFrame, i);\n        vec4 particle = texelFetch(iChannel0, particleUV, 0); \/\/getRandomParticle(iResolution, iChannel0, fragCoord, iFrame, i);\n        vec2 pos2 = particle.xy;\n        int index = serializeUV(iResolution, frame, particleUV);\n        checkPos(index, pos, pos2, mind, closest);\n        \n        {\n            \/\/ivec2 particleUV = getRandomParticlePos(iResolution, iChannel0, fragCoord, iFrame, i);\n        \tivec4 neighbourClosest = ivec4(texelFetch(iChannel1, ivec2(particleUV), 0));\n\n            vec2 pos3 = getParticle(iResolution, iChannel0, frame, neighbourClosest.x).xy;\n            vec2 pos4 = getParticle(iResolution, iChannel0, frame, neighbourClosest.y).xy;\n            vec2 pos5 = getParticle(iResolution, iChannel0, frame, neighbourClosest.z).xy;\n            vec2 pos6 = getParticle(iResolution, iChannel0, frame, neighbourClosest.w).xy;\n            \n            checkPos(neighbourClosest.x, pos, pos3, mind, closest);\n            checkPos(neighbourClosest.y, pos, pos4, mind, closest);\n            checkPos(neighbourClosest.z, pos, pos5, mind, closest);\n            checkPos(neighbourClosest.w, pos, pos6, mind, closest);\n\t\t\t\n        }\n    }\n    \n    fragColor = vec4(closest);\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const int xParticles = 200;\n\/\/#define xParticles min(1000, iResolution.y)\nconst int yParticles = xParticles;\n\/\/#define yParticles (20 + frame % 2)\n\nconst int particles = xParticles * yParticles;\nconst float md = max(0.005, 0.2 \/ float(xParticles)); \/\/ circle radius\n\nconst int iter = 2;\nconst int forceIter = 4;\n\nconst float MAX_DIST = 10.0;\n\nconst bool LINES = true;\n\n\/\/ from https:\/\/gist.github.com\/patriciogonzalezvivo\/670c22f3966e662d2f83\nfloat rand(vec2 n) {\n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\n\/\/ from iq\nfloat hash(uvec2 x) {\n    uvec2 q = 1103515245U * ( (x>>1U) ^ (x.yx   ) );\n    uint  n = 1103515245U * ( (q.x  ) ^ (q.y>>3U) );\n    return float(n) * (1.0\/float(0xffffffffU));\n}\n\n\nivec2 getRandomParticlePos(in vec3 iResolution, in sampler2D iChannel0, in vec2 fragCoord, in int frame, int i) {\n    \/\/uvec2 b = uvec2(i \/ iter - iter \/ 2, i % iter - iter \/ 2);\n    uvec2 b = uvec2(0);\n    uvec2 p1 = uvec2(fragCoord) + b + uvec2(frame, 13 * frame);\n    uvec2 p2 = uvec2(fragCoord.yx) + b + uvec2(29 * frame, frame);\n    float f1 = hash(p1);\n    float f2 = hash(p2);\n    \/\/int xp = min(xParticles, int(iResolution.y));\n    \/\/int yp = min(yParticles, int(iResolution.y)); \/\/ + 10 * (frame % 10 + 1);\n    ivec2 p3 = ivec2(f1 * float(xParticles), f2 * float(yParticles));\n    \/\/p3 = ivec2(fragCoord);\n    \/\/i = (i + frame) % (iter * iter);\n    p3 += ivec2(i \/ iter - iter \/ 2, i % iter - iter \/ 2);\n    \/\/p3 += ivec2(i \/ iter, i % iter);\n    p3.x = abs(p3.x % xParticles);\n    p3.y = abs(p3.y % yParticles);\n    return p3;\n}\n\nint serializeUV(in vec3 iResolution, in int frame, ivec2 uv) {\n    \/\/int yp = min(yParticles, int(iResolution.y));\n    return uv.x * yParticles + uv.y;\n}\n\nivec2 deserializeUV(in vec3 iResolution, in int frame, int index) {\n    \/\/int yp = min(yParticles, int(iResolution.y));\n    return ivec2(index \/ yParticles, index % yParticles);\n}\n\nvec4 getRandomParticle2(in vec3 iResolution, in sampler2D iChannel0, in vec2 fragCoord, in int frame, int i) {\n\treturn texelFetch(iChannel0, getRandomParticlePos(iResolution, iChannel0, fragCoord, frame, i), 0);\n}\n\n\/\/ TODO: rename to getParticleData   \nvec4 getParticle(in vec3 iResolution, in sampler2D iChannel0, in int frame, int index) {\n    ivec2 uv = deserializeUV(iResolution, frame, index);\n    \/\/getRandomParticlePos(iResolution, iChannel0, fragCoord, frame, i)\n\treturn texelFetch(iChannel0, uv, 0);\n}\n\nvec2 npos(vec2 pos) {\n    return (pos + 1.0) \/ 2.0;\n}\n\nvec2 dnpos(vec2 pos) {\n    return (pos - 0.5) * 2.0;\n}\n\n\/\/ from http:\/\/stackoverflow.com\/questions\/15276454\/is-it-possible-to-draw-line-thickness-in-a-fragment-shader\n#define Thickness 0.0005\nfloat drawLine(vec2 uv, vec2 p1, vec2 p2) {\n  float a = abs(distance(p1, uv));\n  float b = abs(distance(p2, uv));\n  float c = abs(distance(p1, p2));\n\n  if ( a >= c || b >=  c ) return 0.0;\n\n  float p = (a + b + c) * 0.5;\n\n  \/\/ median to (p1, p2) vector\n  float h = 2.0 \/ c * sqrt( p * ( p - a) * ( p - b) * ( p - c));\n\n  return mix(1.0, 0.0, smoothstep(0.5 * Thickness, 1.5 * Thickness, h));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\nint depthFirst(in int nextIndex, in vec2 closestPos, in vec2 uv, in float mind) {\n    const int iter2 = iter * iter;\n    int seen[iter2];\n    for (int i = 0; i < iter2; i++) {\n        seen[i] = -1;\n    }\n    int stack[iter2];\n    for (int i = 0; i < iter2; i++) {\n        stack[i] = -1;\n    }\n    \n    int oldIndex = nextIndex;\n    int stackPointer = 0;\n    int closestIndex = nextIndex;\n    stack[0] = nextIndex;\n    for (int i = 0; i < iter2; i++) {\n    \/\/for (int i = 0; i < 100; i++) {\n        nextIndex = stack[stackPointer];\n        ivec4 closest = ivec4(getParticle(iResolution, iChannel1, iFrame, nextIndex));\n        seen[i] = nextIndex;\n        \n        vec2 pos2 = getParticle(iResolution, iChannel0, iFrame, closest.x).xy;\n        vec2 pos3 = getParticle(iResolution, iChannel0, iFrame, closest.y).xy;\n        vec2 pos4 = getParticle(iResolution, iChannel0, iFrame, closest.z).xy;\n        vec2 pos5 = getParticle(iResolution, iChannel0, iFrame, closest.w).xy;\n        \n        vec2 pos = closestPos;\n        \n        {\n            vec2 cmp = uv;\n            \n            bool seenX = false;\n            bool seenY = false;\n            bool seenZ = false;\n            bool seenW = false;\n            for (int j = 0; j <= i && j <= iter2; j++) {\n                seenX = seenX || (seen[j] == closest.x);\n                seenY = seenY || (seen[j] == closest.y);\n                seenZ = seenZ || (seen[j] == closest.z);\n                seenW = seenW || (seen[j] == closest.w);\n            }\n            \n            float d2 = MAX_DIST;\n            if (!seenX && closest.x != -1) {\n            \tnextIndex = closest.x;\n            \tclosestPos = pos2;\n                d2 = distance(uv, closestPos);\n            }\n            if (!seenY && closest.y != -1 && distance(uv, pos3) < d2) {\n                nextIndex = closest.y;\n            \tclosestPos = pos3;\n                d2 = distance(uv, closestPos);\n            }\n            if (!seenZ && closest.z != -1 && distance(uv, pos4) < d2) {\n                nextIndex = closest.z;\n            \tclosestPos = pos4;\n                d2 = distance(uv, closestPos);\n            }\n            if (!seenW && closest.w != -1 && distance(uv, pos5) < d2) {\n                nextIndex = closest.w;\n            \tclosestPos = pos5;\n                d2 = distance(uv, closestPos);\n            }\n            \n            \/*\n            if (!seenX && closest.x != -1 && cmp.x < pos.x && cmp.y < pos.y) {\n                nextIndex = closest.x;\n                closestPos = pos2;\n            }\n            if (!seenY && closest.y != -1 && cmp.x > pos.x && cmp.y > pos.y) {\n                nextIndex = closest.y;\n                closestPos = pos3;\n            }\n            if (!seenZ && closest.z != -1 && cmp.y < pos.y && cmp.x > pos.x) {\n                nextIndex = closest.z;\n                closestPos = pos4;\n            }\n            if (!seenW && closest.w != -1 && cmp.y > pos.y && cmp.x < pos.x) {\n                nextIndex = closest.w;\n                closestPos = pos5;\n            }*\/\n        }\n        \n        if (nextIndex == oldIndex) {\n            stackPointer = stackPointer > 0 ? stackPointer - 1 : 0;\n        } else {\n            stackPointer++;\n            stack[stackPointer] = nextIndex;\n        }\n        \n        float d = distance(uv, closestPos);\n        if (d < mind) {\n            mind = d;\n            closestIndex = nextIndex;\n        }\n        oldIndex = nextIndex;\n    }\n    return closestIndex;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = dnpos(fragCoord \/ iResolution.xy);\n    vec3 color = vec3(0.0);\n    \n    float mind = MAX_DIST;\n    int closestIndex = -1;\n    vec2 closestPos = vec2(0.0);\n    \/\/ivec2 next = ivec2(0.0);\n    \/\/next.x = next.x % xParticles;\n    \/\/next.y = next.y % yParticles;\n    \n    int frame = iFrame;\n    \n    if (iFrame > 0) {\n        int dd = 1;\n        for (int dx = -dd; dx <= dd; dx++) {\n            for (int dy = -dd; dy <= dd; dy++) {\n                ivec2 niv = ivec2(fragCoord) + ivec2(dx, dy);\n                int index = int(texelFetch(iChannel2, niv, 0).x);\n                \n                \/\/ivec2 niv = getRandomParticlePos(iResolution, iChannel2, iv, frame, j);\n                \n                if (index == -1) continue;\n                \n                vec2 pos = getParticle(iResolution, iChannel0, iFrame, index).xy;\n                float d = distance(uv, pos);\n                \n                if (d > 0.0 && d < mind) {\n                    mind = d;\n                    closestIndex = index;\n                    closestPos = pos;\n                }\n            }\n        }\n        \/*if (closestIndex != -1) {\n        \treturn;\n        }*\/\n    }\n    \n    for (int i = 0; i < iter * iter; i++) {\n        vec2 iv = fragCoord;\n        int j = i;\n        \/*\n        if (iFrame > 0) {\n            ivec2 niv = getRandomParticlePos(iResolution, iChannel2, iv, frame, j);\n            j = int(texelFetch(iChannel2, niv, 0).x);\n            if (j == -1) continue;\n            \n            vec2 pos = getParticle(iResolution, iChannel0, iFrame, j).xy;\n\n            float d = distance(uv, pos);\n            if (d > 0.0 && d < mind) {\n                mind = d;\n                closestIndex = j;\n                closestPos = pos;\n            }\n        }*\/\n        \n        ivec2 particleCoord = getRandomParticlePos(iResolution, iChannel0, iv, frame, i);\n        vec4 particle = texelFetch(iChannel0, particleCoord, 0);\n        \/\/ getRandomParticle(iResolution, iChannel0, fragCoord, iFrame + i);\n        vec2 pos = particle.xy;\n        \n        float d = distance(uv, pos);\n        if (d > 0.0 && d < mind) {\n            mind = d;\n            closestIndex = i;\n            closestPos = pos;\n        }\n    }\n    \n    fragColor.x = float(depthFirst(closestIndex, closestPos, uv, mind));\n    \n    \/\/fragColor.x = float(closestIndex);\n    \/\/fragColor.x = float(serializeUV(iFrame, getRandomParticlePos(iResolution, iChannel0, fragCoord, iFrame, 0)));\n    \/\/fragColor.x = 0.0;\n    \n    return;\n}","name":"Buf C","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"Mtdyzs","date":"1533814769","viewed":888,"name":"Z Particle Sort Pipeline","username":"emh","description":"Fast Z-order or Morton code merge sort of particles. Merge sort is fast with binary search so log2 number of passes. Particle buffer is partitioned over last log2 physics iterations for pipelined sort.","likes":12,"published":3,"flags":32,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"\/media\/previz\/buffer03.png","previewfilepath":"\/media\/previz\/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define condFetch(x) texelFetch(iChannel2, ivec2(x), 0)\n\nfloat textColor(vec3 bgColor) {\n  float r = bgColor.r * 255.0,\n        g = bgColor.g * 255.0,\n        b = bgColor.b * 255.0;\n  float yiq = (r * 299.0 + g * 587.0 + b * 114.0) \/ 1000.0;\n  return (yiq >= 128.0) ? 0.0 : 1.0;\n}\n\nvec2 vmin(vec2 v1, vec2 v2) {\n    return length(v1) < length(v2) ? v1 : v2;\n}\n\nstruct mRet {\n    int dIndex;\n    int Am;\n    vec4 v;\n    vec2 pos;\n};\n\nmRet getMD(int part, int m, vec2 res, vec2 pres) {\n    vec2 fc = vec2(fromLinear(m, res));\n    vec4 v = texelFetch(iChannel3, ivec2(fc), 0);\n    vec2 pos = part == 0 ? v.xy : v.zw;\n    int Am = toIndex(iChannel0, pos * pres, pres);\n    return mRet(m, Am, v, pos);\n}\n\nmRet getM(int part, int m, vec2 res, vec2 pres) {\n    vec2 fc = vec2(fromLinear(m, res));\n    vec4 v = condFetch(fc);\n    \/\/int Am = toIndex(iChannel0, v.xy * pres, pres);\n    mRet ret2 = getMD(part, int(v[part]), res, pres);\n    vec4 v2 = ret2.v;\n    vec2 pos = part == 0 ? v2.xy : v2.zw;\n    int Am = toIndex(iChannel0, pos * pres, pres);\n    return mRet(int(v[part]), ret2.Am, v2, pos);\n}\n\n\/*\nmRet getM(int m, vec2 res, vec2 pres) {\n    vec2 fc = vec2(fromLinear(m, res));\n    vec4 v = texelFetch(iChannel3, ivec2(fc), 0);\n    int Am = toIndex(iChannel0, v.xy * pres, pres);\n    return mRet(Am, v);\n}*\/\n\nvoid indexPlay(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 col = vec3(0.0);\n    vec2 res = getRes(iResolution.xy);\n    vec2 uv = floor(fragCoord \/ iResolution.xy * res);\n    ivec2 div = maxDiv(res);\n    vec2 colorUV = fragCoord \/ iResolution.xy;\n    int n = int(res.x * res.y);\n    int m = int(iResolution.x * iResolution.y);\n    \n    vec4 color = vec4(colorUV, 0.5, 1.0);\n    fragColor = color;\n    int index2 = int((fragCoord.x + fragCoord.y * iResolution.x) * float(div.x) \/ (iResolution.x * iResolution.y));\n    index2 = (index2 + iFrame * 100) % div.x;\n    vec2 rfc = vec2(fromIndex(iChannel0, index2, res));\n    vec2 colorUV2 = rfc \/ res;\n    vec4 color2 = vec4(colorUV2, 0.5, 1.0);\n    fragColor = color2;\n    \/\/return;\n    \n    \/\/int index = toIndex(fragCoord, iResolution.xy, col);\n    int index = toIndexCol(uv, res, col);\n    \/\/div.x = int(res.x * res.x);\n    int scaledIndex = int(float(index) \/ float(div.x) * iResolution.x * iResolution.y);\n    int scaledIndex2 = int(float(index + 1) \/ float(div.x) * iResolution.x * iResolution.y);\n    int revIndex = int(float(scaledIndex) * float(div.x) \/ (iResolution.x * iResolution.y));\n    vec2 fc = vec2(fromIndex(iChannel0, revIndex, res));\n    vec2 fc2 = vec2(fromIndex(iChannel0, revIndex + 1, res));\n    vec2 fc3 = vec2(fromIndex(iChannel0, revIndex + 2, res));\n    vec2 fc4 = vec2(fromIndex(iChannel0, revIndex + 3, res));\n    \n    vec2 fcy = uv;\n    \/\/fcy.y = res.y - fcy.y;\n    vec2 mfc = vec2(ivec2(fcy) * div.y \/ ivec2(res));\n    vec2 error1 = abs(fc - mfc);\n    vec2 error2 = abs(fc2 - mfc);\n    vec2 error3 = abs(fc3 - mfc);\n    vec2 error4 = abs(fc4 - mfc);\n    vec2 error = vmin(error1, vmin(error2, vmin(error3, error4)));\n    float r = float(scaledIndex) \/ (iResolution.x * iResolution.y);\n    fragColor = vec4(r);\n    if (scaledIndex != scaledIndex2) {\n        fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    }\n    \/\/return;\n    \n    vec2 dfc = mod(fragCoord, iResolution.xy \/ float(div.y));\n    float b1 = print(dfc, float(error.x), 4, 0);\n    float b2 = print(dfc - vec2(50.0, 0.0), float(error.y), 4, 0);\n    fragColor = vec4(b1 + b2);\n    \n    \/\/float b = print(mod(fragCoord, iResolution.xy \/ float(div.y)) * 1.0, float(index), 4, 0);\n    float b3 = print(fragCoord, float(div.x) \/ (iResolution.x * iResolution.y), 10, 3);\n    \/\/col = vec3(float(int(col.r) ^ int(b)));\n    \/\/b = float(int(uv.x + uv.y) % 2 ^ int(b));\n    fragColor = vec4(vec3(b3), 1.0);\n    fragColor = vec4(col, 1.0);\n    \/\/fragColor = vec4(error.x, 0.0, error.y, 1.0);\n}\n\nvoid lookup(out vec4 fragColor, in vec2 fragCoord) { \n\tvec2 res2 = iResolution.xy;\n    int k = 5;\n    float mul = 4.0;\n    const float MAX = 1.0e10;\n    float rd = 0.0;\n    float mind = MAX;\n    vec2 powerOfTwoRes = getRes(res2);\n    vec2 colorUV = fragCoord \/ iResolution.xy;\n    vec3 color = vec3(1.0);\n    int minIndex = -1;\n    bool firstHalf = true;\n    mPartitionData pd = getPartitionData(iChannel3, fragCoord, res2);\n    \n    vec4 indexAndVelNearest = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    \n    for (int dx = -k; dx <= k; dx++) {\n        for (int dy = -k; dy <= k; dy++) {\n    \/\/for (int r = 0; r < k; r++) {\n    \/\/    for (int a = 0; a < k; a++) {\n    \/\/        int dx = int(float(r) * cos(M_PI * 2.0 * float(a \/ k)));\n    \/\/        int dy = int(float(r) * sin(M_PI * 2.0 * float(a \/ k))); \n            vec2 delta = vec2(dx, dy);\n            vec2 delta2 = vec2(sign(float(dx)) * exp2(abs(float(dx))), sign(float(dy)) * exp2(abs(float(dy))));\n            \n            vec4 indexAndVel = texelFetch(iChannel1, ivec2(fragCoord + mul * delta), 0);\n            \/\/vec2 v = indexAndVel.zw;\n            \/\/int i = int(indexAndVel.x);\n            \/\/int j = int(indexAndVel.y);\n            \n            for (int part = 0; part < 2; part++) {\n                int i = int(indexAndVel[part]);\n                mRet iret = getM(part, i, res2, powerOfTwoRes);\n                vec2 newPos = iret.pos;\n                float d = distance(colorUV, newPos);\n                if (i >= 0 && d < mind) {\n                    minIndex = iret.dIndex;\n                    firstHalf = part == 0;\n                }\n                mind = i < 0 ? mind : min(d, mind);\n                float f = 0.00005  \/ d;\n                rd = i < 0 ? rd : (d < (float(k) \/ iResolution.x) ? f + rd : rd);\n                \n                if (i >= 0 && d < (float(k) * mul \/ iResolution.x) && i != int(indexAndVelNearest[part])) {\n                    \/\/float particleSize = length(fragCoord \/ iResolution.xy - 0.5) * 5.0;\n                    float h = float(minIndex % pd.particlesPerPartition) \/ float(pd.particlesPerPartition);\n    \t\t\t\tcolor = hsv2rgb(vec3(h, 1.0, 1.0));\n                    color = mix(vec3(1.0), color, 100.0 * mind);\n                    fragColor += clamp(vec4(color, 1.0) * vec4(0.02 \/ (mind * 500.0)), 0.0, 1.0);\n                }\n            }\n            \n            \/*\n            i = int(texelFetch(iChannel1, ivec2(fragCoord + mul * delta2), 0).x);\n        \td = distance(colorUV, getM(i, res2, powerOfTwoRes).v.xy);\n            mind = i < 0 ? mind : min(d, mind);\n            rd = i < 0 ? rd : d + rd;\n\t\t\t*\/\n        }\n    }\n    \/\/fragColor = rd == MAX ? vec4(0.0) : vec4(rd * 1000.0);\n    \/\/fragColor = vec4(rd * 0.05);\n    \/\/mind = mind > 0.01 ? 0.0 : mind;\n    \/\/fragColor = vec4(mind * 500.0);\n    \n    float h = float(minIndex % pd.particlesPerPartition) \/ float(pd.particlesPerPartition);\n    \/\/color = hsv2rgb(vec3(h, 1.0, 1.0));\n    \n    float size = minIndex >= 0 ? float(minIndex % 10 + 1) : 1.0;\n    \n    \/\/ inverse\n    float particleSize = length(fragCoord \/ iResolution.xy - 0.5) * 5.0;\n    \/\/particleSize = 2.0 \/ size;\n    \/\/particleSize = particleSize > 1.0 ? 1.0 : particleSize;\n    \n    \/\/fragColor += clamp(vec4(color, 1.0) * vec4(1.0 \/ (mind * 500.0 * particleSize)), 0.0, 1.0);\n    fragColor += clamp(vec4(color, 1.0) * vec4(1.0 \/ (mind * 500.0)), 0.0, 1.0);\n    \n    \/\/fragColor *= 1.0 * vec4(rd * 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) { \n    vec3 col = vec3(0.0);\n    vec2 pres = getRes(iResolution.xy);\n    vec2 uv = floor(fragCoord \/ iResolution.xy * pres);\n    ivec2 div = maxDiv(pres);\n    vec2 colorUV = fragCoord \/ iResolution.xy;\n    int n = int(pres.x * pres.y);\n    int m = int(iResolution.x * iResolution.y);\n    fragColor += print(fragCoord, float(n), 10, 0);\n    \/\/return;\n    \n    \/*\n    vec4 color3 = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \/\/color3.ba *= 0.0;\n    fragColor = vec4(float(toIndex(color3.xy * res, res)) \/ float(n)); \/\/vec4(color3.xy \/ length(color3.xy), 0.0, 1.0);\n    \/\/fragColor = color3 + vec4(0.0, 0.0, float(toIndex(color3.xy * res, res)) \/ float(n), 0.0);\n    fragColor = color3;\n    \/\/return;\n    \/\/fragColor = vec4(0.0, 0.0, color3.b, 1.0);\n    fragColor = vec4(color3.b, 0.0, 0.0, 1.0);\n    \/\/return;\n    fragColor = \n        color3.a > 0.0\n        \t? \n        \t\tcolor3.b > 0.0\n        \t\t\t? vec4(0.0)\n        \t\t\t: vec4(1.0)\n        \t: vec4(color3.b, color3.b > 0.0 ? vec3(0.0) : vec3(length(color3.rg)));\n \t*\/\n    \n    lookup(fragColor, fragCoord);\n    \n    vec2 tv = vec2(0.0);\n    \/*\n    vec2 tv = fragCoord.xy \/ iResolution.x;\n    vec4 value =\n        texture(iChannel0, tv) \/\n        \tvec4(\n                toIndexFull(iResolution.xy - 1.0, iResolution.xy),\n                iResolution.x,\n                iResolution.y,\n                1.0);\n    fragColor = vec4(value.x);\n    return;\n    tv = fragCoord.xy \/ iResolution.x;\n    fragColor = texture(iChannel2, tv);\n    return;\n\t*\/\n    \n    \/\/fragColor = texelFetch(iChannel3, ivec2(fragCoord), 0);\n    \/\/return;\n    \n    vec2 res = iResolution.xy;\n    vec2 sz = vec2(0.3);\n    tv = fragCoord.xy \/ iResolution.x \/ sz;\n    vec2 tv2 = (fragCoord.xy + vec2(1.0, 0.0)) \/ iResolution.x \/ sz;\n    mPartitionData pd = getPartitionData(iChannel3, fragCoord, iResolution.xy);\n    if (tv.y < 1.0 && tv.x < 1.0) {\n        if (tv.x < 0.33) {\n            \/\/vec4 value = texture(iChannel0, tv) \/ vec4((iResolution.x * iResolution.y), iResolution.x, iResolution.y, 1.0);\n            vec4 value = texture(iChannel0, tv);\n            \/\/fragColor = value;\n            fragColor = vec4(float(int(value.x) % 1000) \/ 1000.0);\n        } else if (tv.x < 0.66) {\n            vec4 v41 = texture(iChannel2, tv);\n            vec4 v42 = texture(iChannel2, tv2);\n            mRet x = getM(0, int(v41.x), res, pres);\n            mRet y = getM(0, int(v42.x), res, pres);\n            fragColor = vec4(0.0);\n            fragColor = vec4((ivec4(v41) % pd.particlesPerPartition)) \/ float(pd.particlesPerPartition);\n            fragColor.r = float(x.Am < y.Am);\n        } else {\n            \/\/ upd2\n            fragColor = texelFetch(iChannel3, ivec2(tv * iResolution.xy), 0);\n            \/\/fragColor = texture(iChannel3, tv);\n        }\n    } else {\n        if (fragCoord.x < iResolution.x * 1.0 \/ 3.0) {\n            \n        } else {\n            \n        }\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"precision highp float;\nprecision highp int;\n\nconst int MAX_ITER = 12;\nconst int maxBin = 32;\nconst int vec4Count = 2;\n#define PART part\nconst float M_PI = 3.14159265358979323846264338327950288;\n\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 \/ 3.0, 1.0 \/ 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nint getMaxPasses2(vec2 res) {\n    return int(ceil(log2(res.x * res.y)));\n}\n\nstruct mPartitionData {\n    int partitionCount;\n    int maxIndex;\n    int particlesPerPartition;\n    int index;\n    int partitionIndex;\n    int offset;\n    int pastIndex;\n    int futureIndex;\n    ivec2 futureCoord;\n    vec4 futureParticle;\n    bool overflow;\n};\n\nfloat hash( uvec2 x )\n{\n    uvec2 q = 1103515245U * ( (x>>1U) ^ (x.yx   ) );\n    uint  n = 1103515245U * ( (q.x  ) ^ (q.y>>3U) );\n    return float(n) * (1.0\/float(0xffffffffU));\n}\n\nint D(vec2 p, float n) {\n    int i=int(p.y), b=int(exp2(floor(30.-p.x-n*3.)));\n    i = ( p.x<0.||p.x>3.? 0:\n    i==5? 972980223: i==4? 690407533: i==3? 704642687: i==2? 696556137:i==1? 972881535: 0 )\/b;\n \treturn i-i\/2*2;\n}\n\nint Dbg(vec2 p) {\n    int i = int(p.y);\n    return int(p.x >= -1.0 && p.x <= 4.0 && p.y >= -1.0 && p.y <= 7.0);\n}\n\n\nfloat print(vec2 i, float num, int digits, int decimals) {\n    \/*\n    i \/= 2.0;\n    int o = 0;\n    for (float n = float(digits - 1); n >= -float(decimals); n--) { \n        if ((i.x -= 4.0) < 3.0) {\n            \/\/ digit\n            o = D(i, floor(mod(num \/ pow(10.0, n), 10.0)));\n            break;\n        }\n    }\n    return float(o);\n\t*\/\n    return 0.0;\n}\n\nvec2 printBG(vec2 i, float num, int digits, int decimals) {\n    \/*\n    i \/= 2.0;\n    int o = 0;\n    int bg = 0;\n    for (float n = float(digits - 1); n >= -float(decimals); n--) { \n        \/\/ background\n    \tbg += Dbg(i - vec2(4.0, 0.0));\n        if ((i.x -= 4.0) < 3.0) {\n            \/\/ digit\n            o = D(i, floor(mod(num \/ pow(10.0, n), 10.0)));\n            break;\n        }\n    }\n    return vec2(o, bg);\n\t*\/\n    return vec2(0.0);\n}\n\nivec2 maxDiv(in vec2 resolution) {\n    ivec2 res = ivec2(resolution);\n    int div = 1;\n    int div2 = 1;\n    for (int i = 0; i < MAX_ITER; i++) {\n        res \/= 2;\n        if (res.x == 0 && res.y == 0) break;\n        div *= 4;\n        div2 *= 2;\n    }\n    return ivec2(div, div2);\n}\n\nvec2 getRes(vec2 res) {\n    return vec2(exp2(ceil(log2(max(res.x, res.y)))));\n}\n\nint toIndexCol(in vec2 fragCoord, in vec2 resolution, inout vec3 col) {\n    int xl = int(fragCoord.x);\n    int yl = int(fragCoord.y);\n    ivec2 res = ivec2(resolution);\n    int div2 = 1;\n    \/*\n    for (int i = 0; i < MAX_ITER; i++) {\n        res \/= 2;\n        div2 *= 2;\n        if (res.x == 0 && res.y == 0) break;\n    }\n    res = ivec2(div2);\n\t*\/\n    int index = 0;\n    int div = 1;\n    div2 = 1;\n    bool colorDone = false;\n    for (int i = 0; i < MAX_ITER; i++) {\n        ivec2 rest = res % 2;\n        res \/= 2;\n        if (res.x == 0 && res.y == 0) break;\n        div *= 4;\n        div2 *= 2;\n        int x = int(xl >= res.x);\n        int y = int(yl >= res.y);\n        xl -= x * res.x;\n        yl -= y * res.y;\n        \/\/res += x * rest.x;\n        \/\/res += y * rest.y;\n        int thisIndex = y * 2 + x;\n        index = index * 4 + thisIndex;\n        \n        if (!colorDone) {\n            vec2 uv = vec2(xl, yl) \/ vec2(res);\n            vec2 center = vec2(0.5);\n            float d = distance(uv, center);\n            float r = float(d < 0.25);\n            bool border = d > 0.25 - 0.02 \/ float(div2) && d < 0.25;\n            if (border) {\n                colorDone = true;\n            } else {\n            \tcol = vec3(float(int(col) ^ int(r)));\n            }\n        }\n    }\n    \/\/return res.x * res.y - index - 1;\n    return index;\n}\n\nint toIndexFull(in vec2 fragCoord, in vec2 resolution) {\n    vec3 col = vec3(0.0);\n    int index = toIndexCol(fragCoord, resolution, col);\n    \/\/index += 1;\n    return index;\n}\n\nivec2 fromIndexFull(in int index, in vec2 resolution) {\n    \/\/index -= 1;\n    ivec2 fc = ivec2(0);\n    int div = 1;\n    ivec2 div2 = ivec2(1);\n    ivec2 res = ivec2(resolution);\n    \/\/index = res.x * res.y - index - 1;\n    for (int i = 0; i < MAX_ITER; i++) {\n        res \/= 2;\n        \/\/int rx = res.x % 2 == 0 ? 2 : 1;\n        \/\/int ry = res.y % 2 == 0 ? 2 : 1;\n        \n        int thisIndex = index % 4;\n        fc.x += div2.x * (thisIndex % 2);\n        fc.y += div2.y * (thisIndex \/ 2);\n        index = index \/ 4;\n        \n        div2 *= 2;\n        if (index == 0) break;\n    }\n    return fc;\n}\n\nivec2 fromLinear(in int index, in vec2 resolution) {\n    \/\/index -= 1;\n    return ivec2(index % int(resolution.x), index \/ int(resolution.x));\n}\n\nint toLinear(in vec2 fragCoord, in vec2 resolution) {\n    int index = int(fragCoord.x) + int(fragCoord.y) * int(resolution.x);\n    \/\/index += 1;\n    return index;\n}\n\n#define toIndex(a, b, c) toIndex2(a, b, iResolution.xy, c)\nint toIndex2(in sampler2D channel, in vec2 fragCoord, in vec2 res, in vec2 pres) {\n    \/\/return toIndexFull(fragCoord, getRes(resolution));\n    \/\/vec2 pres = getRes(resolution);\n    ivec2 fc = ivec2(fragCoord \/ pres * res);\n    \/\/ivec2 fc = ivec2(fragCoord);\n    vec4 index = texelFetch(channel, fc, 0);\n    \/\/return int(index.x) * 0xFFFF + int(index.y);\n    return int(index.x);\n}\n\n#define fromIndex(a, b, c) fromIndex2(a, b, iResolution.xy, c)\nivec2 fromIndex2(in sampler2D channel, in int index, in vec2 res, in vec2 pres) {\n    \/\/ivec2 fc = ivec2(vec2(fromLinear(index, pres)) \/ pres * res);\n    ivec2 fc = fromLinear(index, res);\n    return ivec2(texelFetch(channel, fc, 0).yz);\n}\n\nvec2 getPosition2(sampler2D channel, int index, vec2 res) {\n    ivec2 fc = fromLinear(index, res);\n    vec4 data = texelFetch(channel, fc, 0);\n    return fract(data.zw);\n}\n\nvec2 getPosition(sampler2D channel, int index, vec2 res) {\n    ivec2 fc = fromLinear(index, res);\n    vec4 data = texelFetch(channel, fc, 0);\n    return fract(data.xy);\n}\n\nvec4 updateParticle(in vec4 particle) {\n    vec2 v = particle.xy - particle.zw;\n    \n    vec2 pos = particle.xy;\n    vec2 dv = pos - 0.5;\n    float l = length(dv);\n    \n    vec2 a = -(dv \/ (0.001 + l)) * 0.00001 \/ (l * l + 1.1);\n    v += a;\n    \n    if (particle.x + v.x < 0.0 || particle.x + v.x >= 1.0) {\n        v.x = -v.x;\n    }\n    if (particle.y + v.y < 0.0 || particle.y + v.y >= 1.0) {\n        v.y = -v.y;\n    }\n    \n    float maxSpeed = 0.1;\n    v = length(v) > maxSpeed ? maxSpeed * v \/ length(v) : v;\n    \n    particle.zw = particle.xy;\n    particle.xy += v;\n        \n    return particle;\n}\n\nint maxLinear(vec2 res) {\n    return int(exp2(floor(log2(float(toLinear(res - 1.0, res))))));\n}\n\nbool isLinearValid(in int index, vec2 iResolution) {\n    vec2 res = iResolution.xy;\n    \/\/return true;\n\treturn index < maxLinear(iResolution);\n}\n\nbool isValid(in vec2 fragCoord, vec2 iResolution) {\n    vec2 res = iResolution.xy;\n    return isLinearValid(toLinear(fragCoord, res), iResolution);\n}\n\nmPartitionData getPartitionData(sampler2D channel, vec2 fragCoord, vec2 res) {\n    mPartitionData mRet;\n    \/\/int maxPasses = getMaxPasses(res);\n    \/\/mRet.partitionCount = int(exp2(ceil(log2(float(maxPasses)))));\n    mRet.partitionCount = 16;\n    \/\/mRet.maxIndex = toLinear(res - 1.0, res);\n    mRet.maxIndex = maxLinear(res);\n    mRet.particlesPerPartition = mRet.maxIndex \/ mRet.partitionCount;\n    mRet.index = toLinear(fragCoord, res);\n    mRet.partitionIndex = mRet.index \/ mRet.particlesPerPartition;\n    mRet.offset = mRet.index % mRet.particlesPerPartition;\n    mRet.futureIndex = mRet.index - mRet.particlesPerPartition;\n    mRet.futureCoord = fromLinear(mRet.futureIndex, res);\n    mRet.futureParticle = texelFetch(channel, mRet.futureCoord, 0);\n    mRet.pastIndex = mRet.index + mRet.particlesPerPartition;\n    mRet.overflow = mRet.index >= mRet.maxIndex;\n    \/\/(mRet.partitionIndex - 1) * mRet.particlesPerPartition + mRet.offset;\n    \n    \n    return mRet;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"\/media\/previz\/buffer03.png","previewfilepath":"\/media\/previz\/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"\/media\/a\/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"\/media\/ap\/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\/\/ Resources:\n\/\/ https:\/\/www.ics.uci.edu\/~goodrich\/pubs\/skip-journal.pdf\n\/\/ Sorting with GPUs: A Survey: https:\/\/arxiv.org\/pdf\/1709.02520.pdf\n\n\/\/ Practice JavaScript implementation: http:\/\/jsbin.com\/zeyiraw\/\n\n\/\/ https:\/\/www.shadertoy.com\/view\/XlcGD8\n\/\/ https:\/\/developer.nvidia.com\/gpugems\/GPUGems2\/gpugems2_chapter46.html\n\/\/ https:\/\/stackoverflow.com\/questions\/26093629\/glsl-odd-even-merge-sort\n\/\/ https:\/\/bl.ocks.org\/zz85\/cafa1b8b3098b5a40e918487422d47f6\n\n\/\/#define PART 0\n\nconst int MAX_INT = 0x8FFFFFFF;\nconst int count = 8;\nint A[count];\nvec4 B[count];\n\nvoid SWAP(int a, int b) {\n    \/\/int small = min(A[a], A[b]);\n    \/\/int big = max(A[a], A[b]);\n    \n    bool cmp = A[a] < A[b];\n    \/*\n    if (cmp) {\n        int tmp = A[a];\n        A[a] = A[b];\n        A[b] = tmp;\n        vec4 tmp2 = B[a];\n        B[a] = B[b];\n        B[b] = tmp2;\n    }*\/\n    \n    int small = cmp ? A[a] : A[b];\n    int big = cmp ? A[b] : A[a];\n    vec4 first = cmp ? B[a] : B[b];\n    vec4 second = cmp ? B[b] : B[a];\n    A[a] = small;\n    A[b] = big;\n    B[a] = first;\n    B[b] = second;\n\t\n}\n\nivec2 fromLinear2(in int index, in vec2 resolution, int mode) {\n    if (mode == 0) {\n    \treturn ivec2(index % int(resolution.x), index \/ int(resolution.x));\n    } else {\n        return ivec2(index \/ int(resolution.y), index % int(resolution.y));\n    }\n}\n\nint toLinear2(in vec2 fragCoord, in vec2 resolution, int mode) {\n    if (mode == 0) {\n    \treturn int(fragCoord.x) + int(fragCoord.y) * int(resolution.x);\n    } else {\n        return int(fragCoord.x) * int(resolution.y) + int(fragCoord.y);\n    }\n}\n\nvec4 sort8(int target) {\n    \/\/ Bitonic sort network from http:\/\/pages.ripco.net\/~jgamble\/nw.html\n    \/\/ http:\/\/jgamble.ripco.net\/cgi-bin\/nw.cgi?inputs=8&algorithm=batcher&output=macro\n\n    \/*\n    for (int i = 0; i < count; i++) {\n        for (int j = i + 1; j < count; j++) {\n            SWAP(i, j);\n        }\n    }\n    for (int i = 0; i < count; i++) {\n        for (int j = i + 1; j < count; j++) {\n            SWAP(i, j);\n        }\n    }*\/\n\n    SWAP(0, 4);\n\tSWAP(1, 5);\n\tSWAP(2, 6);\n\tSWAP(3, 7);\n\tSWAP(0, 2);\n\tSWAP(1, 3);\n\tSWAP(4, 6);\n\tSWAP(5, 7);\n\tSWAP(2, 4);\n\tSWAP(3, 5);\n\tSWAP(0, 1);\n\tSWAP(2, 3);\n\tSWAP(4, 5);\n\tSWAP(6, 7);\n\tSWAP(1, 4);\n\tSWAP(3, 6);\n\tSWAP(1, 2);\n\tSWAP(3, 4);\n\tSWAP(5, 6);\n    return B[target];\n}\n\nvoid sort16() {\n    SWAP(0, 1);\n    SWAP(2, 3);\n    SWAP(4, 5);\n    SWAP(6, 7);\n    SWAP(8, 9);\n    SWAP(10, 11);\n    SWAP(12, 13);\n    SWAP(14, 15);\n    SWAP(0, 2);\n    SWAP(4, 6);\n    SWAP(8, 10);\n    SWAP(12, 14);\n    SWAP(1, 3);\n    SWAP(5, 7);\n    SWAP(9, 11);\n    SWAP(13, 15);\n    SWAP(0, 4);\n    SWAP(8, 12);\n    SWAP(1, 5);\n    SWAP(9, 13);\n    SWAP(2, 6);\n    SWAP(10, 14);\n    SWAP(3, 7);\n    SWAP(11, 15);\n    SWAP(0, 8);\n    SWAP(1, 9);\n    SWAP(2, 10);\n    SWAP(3, 11);\n    SWAP(4, 12);\n    SWAP(5, 13);\n    SWAP(6, 14);\n    SWAP(7, 15);\n    SWAP(5, 10);\n    SWAP(6, 9);\n    SWAP(3, 12);\n    SWAP(13, 14);\n    SWAP(7, 11);\n    SWAP(1, 2);\n    SWAP(4, 8);\n    SWAP(1, 4);\n    SWAP(7, 13);\n    SWAP(2, 8);\n    SWAP(11, 14);\n    SWAP(2, 4);\n    SWAP(5, 6);\n    SWAP(9, 10);\n    SWAP(11, 13);\n    SWAP(3, 8);\n    SWAP(7, 12);\n    SWAP(6, 8);\n    SWAP(10, 12);\n    SWAP(3, 5);\n    SWAP(7, 9);\n    SWAP(3, 4);\n    SWAP(5, 6);\n    SWAP(7, 8);\n    SWAP(9, 10);\n    SWAP(11, 12);\n    SWAP(6, 7);\n    SWAP(8, 9);\n}\n\nbool compareTwo(int i, int j, vec4 a, vec4 b, int compare, vec2 res2) {\n    \/\/toIndex(self.xy * res2, res2) < toIndex(self2.xy * res2, res2)\n    int ai = toIndex(iChannel3, a.xy * res2, res2);\n    int bi = toIndex(iChannel3, b.xy * res2, res2);\n    float l1 = length(a.xy);\n    float l2 = length(b.xy);\n    \/\/return l1 * float(compare) < l2 * float(compare);\n    if (ai == bi) {\n        \/\/return i * compare < j * compare;\n        if (l1 == l2) {\n            if (a.x == b.x) {\n        \t\treturn a.y * float(compare) < b.y * float(compare);\n            } else {\n                return a.x * float(compare) < b.x * float(compare);\n            }\n        } else {\n            return l1 * float(compare) < l2 * float(compare);\n        }\n    } else {\n    \treturn ai * compare < bi * compare;\n    }\n}\n\nvec4 getPartner(int i, vec2 fc, vec2 res, int TwoStage, int Pass_mod_Stage, int TwoStage_PmS_1, int Pass, int maxIndex, int mode) {\n    \/\/ my position within the range to merge\n    int j = int(i % TwoStage);\n\n    int compare = 0;\n\n    bool check1 = i + Pass > maxIndex;\n    bool check2 = i - Pass < 0;\n    bool check = check1 || check2;\n    check = false;\n    if ((j < Pass_mod_Stage) || (j > TwoStage_PmS_1) || check) {\n      \/\/ must copy -> compare with self\n      \/\/return vec4(-1.0);\n      compare = 0;\n    } else {\n      \/\/ must sort\n      if (mod(float((j + Pass_mod_Stage) \/ Pass), 2.0) < 1.0) {\n        \/\/ we are on the left side -> compare with partner on the right\n        compare = check1 ? 0 : 1;\n      } else {\n        \/\/ we are on the right side -> compare with partner on the left\n        compare = check2 ? 0 : -1;\n      }\n    }\n\n    \/\/ get the partner\n    int adr = i + compare * Pass;\n    \/*if (adr > maxIndex || adr < 0) {\n        return vec4(-1.0);\n    }*\/\n    \/\/adr = adr < 0 ? maxIndex - abs(adr % maxIndex) : adr % maxIndex;\n\n    ivec2 fc2 = fromLinear2(adr, res, mode);\n    compare = i < adr ? 1 : -1;\n    return vec4(adr, fc2, compare);\n}\n\nstruct mRet {\n    int Cm;\n    vec4 v;\n    bool valid;\n};\n\n\/\/const int debugLen = 16;\nconst int debugLen = 8;\nconst int debugA[debugLen + 1] = int[debugLen + 1](0, 2, 4, 6, 1, 3, 5, 7, 8);\n\/\/const int debugA[debugLen + 1] = int[debugLen + 1](0, 1, 4, 5, 2, 3, 6, 7, 8);\n\/\/const int debugA[debugLen + 1] = int[debugLen + 1](0, 0, 0, 0, 1, 1, 1, 1, 8);\n\/\/const int debugA[debugLen + 1] = int[debugLen + 1](0, 1, 2, 3, 4, 5, 6, 7, 8);\n\/\/const int debugA[debugLen + 1] = int[debugLen + 1](4, 5, 6, 7, 0, 1, 2, 3, 8);\n\/\/const int debugA[debugLen + 1] = int[debugLen + 1](8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3, 4, 5, 6, 7, 40);\n\/\/ pairs for m = 3:\n\/\/ 6 1\n\/\/ 4 3\n\/\/ 2 5\n\/\/ 0 7\nint debugT[debugLen];\nconst bool debug = false;\n\nmRet getMD(int part, int m, vec2 res, vec2 pres) {\n    \/*if (debug) {\n        return mRet(debugA[m], vec4(debugA[m]), true);\n    }*\/\n    vec2 fc = vec2(fromLinear2(m, res, 0));\n    vec4 v = texelFetch(iChannel2, ivec2(fc), 0);\n    vec2 pos = part == 0 ? v.xy : v.zw;\n    int Am = toIndex(iChannel3, pos * pres, pres);\n    int maxIndex = toLinear2(res - 1.0, res, 0);\n    bool valid = m >= 0 && m <= maxIndex && isLinearValid(m, res);\n    return mRet(Am, v, valid);\n}\n\nmRet getM(int m, vec2 res, vec2 pres) {\n    \/*if (debug) {\n        return mRet(debugA[m], vec4(debugA[m]), true);\n    }*\/\n    vec2 fc = vec2(fromLinear2(m, res, 0));\n    vec4 v = texelFetch(iChannel0, ivec2(fc), 0);\n    \/\/int Am = toIndex(iChannel3, v.xy * pres, pres);\n    int Am = 0;\n    int maxIndex = toLinear2(res - 1.0, res, 0);\n    bool valid = m >= 0 && m <= maxIndex && isLinearValid(m, res);\n    mRet ret = mRet(Am, v, valid);\n    \n    \/\/ret = getMD(int(v.z), res, pres);\n    \/\/ret.v = v;\n    \/*\n    int dIndex = int(v.z);\n    m = dIndex;\n    fc = vec2(fromLinear2(dIndex, res, 0));\n    vec4 v2 = texelFetch(iChannel2, ivec2(fc), 0);\n    Am = toIndex(iChannel3, v2.xy * pres, pres);\n    valid = m >= 0 && m <= maxIndex && isLinearValid(m, res);\n    ret = mRet(Am, v, valid);\n    ret = mRet(Am, vec4(v2.xy, v.z, 0.0), valid);\n\t*\/\n    \n    return ret;\n}\n\nint toRange(int x, int n) {\n    return min(max(0, x), n - 1);\n}\n\n\/*\nivec2 pairToRange(int a, int b, int n, int targetOffset) {\n    if (a < 0) {\n        b += -a;\n        a = 0;\n    }\n    if (b < 0) {\n        a += -b;\n        b = 0;\n    }\n    \/\/a = min(max(0, a), n - 1);\n    \/\/b =\n    return ivec2(a, b);\n}*\/\n\nint extractIndex(vec4 v, int part) {\n    return int(v[PART]);\n}\n\nint getIndex(int part, mRet A, vec2 res, vec2 pres) {\n    vec4 v1 = getMD(part, extractIndex(A.v, part), res, pres).v;\n    vec2 pos = part == 0 ? v1.xy : v1.zw;\n    int Am = toIndex(iChannel3, pos * pres, pres);\n    return Am;\n}\n\nbool compare(int part, mRet A, mRet B, vec2 res, vec2 pres) {\n    vec4 v1 = getMD(part, extractIndex(A.v, part), res, pres).v;\n    vec4 v2 = getMD(part, extractIndex(B.v, part), res, pres).v;\n    vec2 pos1 = part == 0 ? v1.xy : v1.zw;\n    vec2 pos2 = part == 0 ? v2.xy : v2.zw;\n    int Am = toIndex(iChannel3, pos1 * pres, pres);\n    int Bm = toIndex(iChannel3, pos2 * pres, pres);\n    return Am < Bm;\n}\n\nbool cutValid(int part, int n1, int n2, int astart, int bstart, int to, int m2, int x, vec2 res, vec2 pres) {\n    int apos = m2 - 1;\n    bool aValid = apos >= 0 && apos < n1;\n    int bpos = to - m2 - 1;\n    bool bValid = bpos >= 0 && bpos < n2;\n\n    mRet Amret = getM(astart + apos, res, pres);\n    mRet Bmret = getM(bstart + bpos, res, pres);\n\n    int cv11 = getIndex(part, Amret, res, pres);\n    int cv12 = getIndex(part, Bmret, res, pres);\n    return (\n        aValid && bValid && apos >= 0 && bpos >= 0 ? max(cv11, cv12) <= x\n        : bValid && apos < 0 && bpos >= 0 ? cv12 <= x\n        : aValid && apos >= 0 && bpos < 0 ? cv11 <= x\n        : Amret.valid && Bmret.valid);\n}\n\nbool cutCValid(int part, int n1, int n2, int astart, int bstart, int to, int bm2, int x, vec2 res, vec2 pres) {\n    int apos = to - bm2 - 1;\n    int bpos = bm2 - 1;\n    bool aValid = apos >= 0 && apos < n1;\n    bool bValid = bpos >= 0 && bpos < n2;\n\n    mRet Amret = getM(astart + apos, res, pres);\n    mRet Bmret = getM(bstart + bpos, res, pres);\n\tint cvc11 = getIndex(part, Amret, res, pres);\n    int cvc12 = getIndex(part, Bmret, res, pres);\n    return (\n    \taValid && bValid && apos >= 0 && bpos >= 0 ? max(cvc11, cvc12) <= x\n        : bValid && apos < 0 && bpos >= 0 ? cvc12 <= x\n        : aValid && apos >= 0 && bpos < 0 ? cvc11 <= x\n        : Amret.valid && Bmret.valid);\n}\n\nmRet checkIndex(int part, int n1, int n2, int astart, int bstart, int to, int apos, vec2 res, vec2 pres) {\n    bool aValid = apos >= 0 && apos < n1;\n    int bpos = to - apos;\n    bool bValid = bpos >= 0 && bpos < n2;\n\n    mRet Amret = getM(astart + apos, res, pres);\n    mRet Bmret = getM(bstart + bpos, res, pres);\n\n    int candA = getIndex(part, Amret, res, pres);\n    bool candAv = cutValid(part, n1, n2, astart, bstart, to, apos, candA, res, pres) && aValid;\n    Amret.valid = Amret.valid && candAv;\n\n    int candB = getIndex(part, Bmret, res, pres);\n    bool candBv = cutCValid(part, n1, n2, astart, bstart, to, bpos, candB, res, pres) && bValid;\n    Bmret.valid = Bmret.valid && candBv;\n\n    if (candAv && candBv) {\n        if (candA < candB) {\n            return Amret;\n        } else {\n            return Bmret;\n        }\n    } else if (candAv) {\n        return Amret;\n    }\n    return Bmret;\n}\n\nmRet binarySearchForMergeSlim(\n    int part,\n    int targetOffset, int n1, int n2, vec2 pres, vec2 res,\n    in vec2 fragCoord, int astart, int bstart) {\n\n    int L1 = min(max(targetOffset + 1 - n1, 0), n1 - 1);\n    int R1 = min(targetOffset + 1, n1);\n    int L2 = min(max(targetOffset + 1 - n2, 0), n2 - 1);\n    int R2 = min(targetOffset + 1, n2);\n\n    int OL1 = L1;\n    int OR2 = R2;\n\n    int i = 0;\n\n    mRet ret;\n\n    bool bValid = true;\n\n    for (i = 0; i < maxBin && L1 < R1 && (L2 < R2 || !bValid); i++) {\n        int m = (L1 + R1) \/ 2 + (L1 + R1) % 2;\n        int bm = targetOffset - m;\n        int apos = m;\n        bool aValid = apos >= 0 && apos < n1;\n        int bpos = bm;\n        bValid = bpos >= 0 && bpos < n2;\n\n        mRet Amret = getM(astart + apos, res, pres);\n        aValid = aValid && Amret.valid;\n        mRet Bmret = getM(bstart + bpos, res, pres);\n        bValid = bValid && Bmret.valid;\n\n        int Am = getIndex(part, Amret, res, pres);\n        int Bm = getIndex(part, Bmret, res, pres);\n\n        bool comparison = compare(part, Amret, Bmret, res, pres) && aValid && bValid;\n        bool inUpperHalf = comparison;\n\n        \/\/ m + 1 to R1\n        L1 = inUpperHalf ? m : L1;\n        \/\/ L1 to m\n        R1 = !inUpperHalf ? m - 1 : R1;\n        \/\/ bm + 1 to R2\n        L2 = !inUpperHalf ? bm : L2;\n        \/\/ L2 to bm\n        R2 = inUpperHalf ? bm : R2;\n    }\n    mRet error = mRet(-1, vec4(-1.0), false);\n     \n    int apos = L1;\n    int bpos = targetOffset - L1;\n    bValid = bpos >= 0 && bpos < n2;\n\n    mRet AL1ret = getM(astart + apos, res, pres);\n    mRet BL1ret = getM(bstart + bpos, res, pres);\n    \/\/return AL1ret;\n\n    \/\/ XXX: AL1ret and BL1ret should be valid I hope\n    int m2 = getIndex(part, AL1ret, res, pres) < getIndex(part, BL1ret, res, pres) && bValid ? L1 + 1 : L1;\n    int bm2 = OR2 - (m2 - OL1);\n    bool bm2Valid = bm2 >= 0 && bm2 < n2;\n    bool bm2Min1Valid = bm2 - 1 >= 0 && bm2 - 1 < n2;\n\n    int to = targetOffset;\n\n    mRet cand1 = checkIndex(part, n1, n2, astart, bstart, to, m2, res, pres);\n    mRet cand2 = checkIndex(part, n1, n2, astart, bstart, to, bm2, res, pres);\n    cand2.valid = cand2.valid && bm2Valid;\n    mRet cand3 = checkIndex(part, n1, n2, astart, bstart, to, m2 - 1, res, pres);\n    mRet cand4 = checkIndex(part, n1, n2, astart, bstart, to, bm2 - 1, res, pres);\n    cand4.valid = cand4.valid && bm2Min1Valid;\n\n    ret = cand1;\n    if (cand2.valid && (compare(part, cand2, ret, res, pres) || !ret.valid)) {\n        ret = cand2;\n    }\n    if (cand3.valid && (compare(part, cand3, ret, res, pres) || !ret.valid)) {\n        ret = cand3;\n    }\n    if (cand4.valid && (compare(part, cand4, ret, res, pres) || !ret.valid)) {\n        ret = cand4;\n    }\n    mRet AnMin1 = getM(astart + n1 - 1, res, pres);\n    mRet BtoMinN = getM(bstart + to - n1, res, pres);\n    mRet BnMin1 = getM(bstart + n2 - 1, res, pres);\n    mRet AtoMinN = getM(astart + to - n2, res, pres);\n    if (targetOffset >= n1 && compare(part, AnMin1, BtoMinN, res, pres) && BtoMinN.valid) {\n        ret = BtoMinN;\n    }\n    if (targetOffset >= n2 && compare(part, BnMin1, AtoMinN, res, pres) && AtoMinN.valid) {\n        ret = AtoMinN;\n    }\n    \n    if (i >= maxBin - 1) {\n        ret = error;\n    }\n    return ret;\n}\n\n\n\nmRet binarySearchForMerge(\n    int part,\n    int targetOffset, int n1, int n2, vec2 pres, vec2 res,\n    in vec2 fragCoord, int astart, int bstart, inout vec2 digits) {\n\n    int L1 = min(max(targetOffset + 1 - n1, 0), n1 - 1);\n    int R1 = min(targetOffset + 1, n1);\n    int L2 = min(max(targetOffset + 1 - n2, 0), n2 - 1);\n    int R2 = min(targetOffset + 1, n2);\n\n    int OL1 = L1;\n    int OR2 = R2;\n\n    int i = 0;\n\n    mRet ret;\n\n    float bx = -30.0;\n    float by = -15.0;\n    \/\/ Looking for m such that there are\n    \/\/ apos elements less than A[m] in A\n    \/\/ and bpos elements less than A[m] in B.\n    \/\/ For given m, how to count elements less than A[m] in A and B.\n    \/\/ For given m, decide whether there are more than targetOffset elements less than A[m] in A and B.\n    \/\/ For given m, is A[m] such an element that B[bpos] < A[m] and B[bpos + 1]\n\n    vec2 black = vec2(1.0, 0.0);\n    vec2 white = vec2(0.0);\n\n    bool bValid = true;\n\n    for (i = 0; i < maxBin && L1 < R1 && (L2 < R2 || !bValid); i++) {\n        int m = (L1 + R1) \/ 2 + (L1 + R1) % 2;\n        int bm = targetOffset - m;\n        int apos = m;\n        bool aValid = apos >= 0 && apos < n1;\n        int bpos = bm;\n        bValid = bpos >= 0 && bpos < n2;\n\n        mRet Amret = getM(astart + apos, res, pres);\n        aValid = aValid && Amret.valid;\n        mRet Bmret = getM(bstart + bpos, res, pres);\n        bValid = bValid && Bmret.valid;\n\n        float bline = -80.0;\n        bool showPos = true;\n        if (showPos) {\n        \tdigits += printBG(fragCoord + vec2(float(targetOffset) * bx, 1.0 * bline + float(i) * by), float(apos), 2, 0);\n        \tdigits += printBG(fragCoord + vec2(float(targetOffset) * bx, 2.0 * bline + float(i) * by), float(bpos), 2, 0);\n        }\n\n        int Am = getIndex(part, Amret, res, pres);\n        int Bm = getIndex(part, Bmret, res, pres);\n\n        digits += printBG(fragCoord + vec2(float(targetOffset) * bx, 3.0 * bline + float(i) * by), float(Am), 2, 0);\n        digits += printBG(fragCoord + vec2(float(targetOffset) * bx, 4.0 * bline + float(i) * by), float(Bm), 2, 0);\n\n        {\n            float dx = 40.0;\n            int a = L1;\n            int b = R1;\n            int c = L2;\n            int d = R2;\n\n            float sbx = 300.0;\n            float sbx2 = 550.0;\n            float sx = sbx + float(a) * dx;\n            float ex = sx + dx * float(b - a);\n            float sx2 = sbx2 + float(c) * dx;\n            float ex2 = sx2 + dx * float(d - c);\n            float hs = 20.0 + 55.0 * float(targetOffset);\n            float hy = 5.0;\n\n            \/\/ left, a range\n            digits +=\n                fragCoord.x >= sx &&\n                fragCoord.x <= ex &&\n                fragCoord.y >= hs + hy * float(i * 2) &&\n                fragCoord.y <= hs + hy * float(i * 2 + 1)\n                    ? black\n                    : white;\n            \/\/ right, b range\n            digits +=\n                fragCoord.x >= sx2 &&\n                fragCoord.x <= ex2 &&\n                fragCoord.y >= hs + hy * float(i * 2) &&\n                fragCoord.y <= hs + hy * float(i * 2 + 1)\n                    ? black\n                    : white;\n           \t\/\/ whole lines for compare\n            digits +=\n                fragCoord.x >= sbx &&\n                fragCoord.x <= sbx + dx * 8.0 &&\n                fragCoord.y >= 6.0 &&\n                fragCoord.y <= 8.0\n                    ? black\n                    : white;\n            digits +=\n                fragCoord.x >= sbx2 &&\n                fragCoord.x <= sbx2 + dx * 8.0 &&\n                fragCoord.y >= 6.0 &&\n                fragCoord.y <= 8.0\n                    ? black\n                    : white;\n        }\n\n        bool comparison = compare(part, Amret, Bmret, res, pres) && aValid && bValid;\n        bool inUpperHalf = comparison;\n\n        \/\/ m + 1 to R1\n        L1 = inUpperHalf ? m : L1;\n        \/\/ L1 to m\n        R1 = !inUpperHalf ? m - 1 : R1;\n        \/\/ bm + 1 to R2\n        L2 = !inUpperHalf ? bm : L2;\n        \/\/ L2 to bm\n        R2 = inUpperHalf ? bm : R2;\n    }\n    mRet error = mRet(-1, vec4(-1.0), false);\n    if (i >= maxBin - 1) {\n        ret = error;\n    } else {\n        int apos = L1;\n        int bpos = targetOffset - L1;\n        bValid = bpos >= 0 && bpos < n2;\n\n        mRet AL1ret = getM(astart + apos, res, pres);\n        mRet BL1ret = getM(bstart + bpos, res, pres);\n        \/\/return AL1ret;\n\n        \/\/ XXX: AL1ret and BL1ret should be valid I hope\n        int m2 = getIndex(part, AL1ret, res, pres) < getIndex(part, BL1ret, res, pres) && bValid ? L1 + 1 : L1;\n        int bm2 = OR2 - (m2 - OL1);\n        bool bm2Valid = bm2 >= 0 && bm2 < n2;\n        bool bm2Min1Valid = bm2 - 1 >= 0 && bm2 - 1 < n2;\n\n        int to = targetOffset;\n\n        mRet cand1 = checkIndex(part, n1, n2, astart, bstart, to, m2, res, pres);\n        mRet cand2 = checkIndex(part, n1, n2, astart, bstart, to, bm2, res, pres);\n        cand2.valid = cand2.valid && bm2Valid;\n        mRet cand3 = checkIndex(part, n1, n2, astart, bstart, to, m2 - 1, res, pres);\n        mRet cand4 = checkIndex(part, n1, n2, astart, bstart, to, bm2 - 1, res, pres);\n        cand4.valid = cand4.valid && bm2Min1Valid;\n\n        ret = cand1;\n        if (cand2.valid && (compare(part, cand2, ret, res, pres) || !ret.valid)) {\n            ret = cand2;\n        }\n        if (cand3.valid && (compare(part, cand3, ret, res, pres) || !ret.valid)) {\n            ret = cand3;\n        }\n        if (cand4.valid && (compare(part, cand4, ret, res, pres) || !ret.valid)) {\n            ret = cand4;\n        }\n        mRet AnMin1 = getM(astart + n1 - 1, res, pres);\n        mRet BtoMinN = getM(bstart + to - n1, res, pres);\n        mRet BnMin1 = getM(bstart + n2 - 1, res, pres);\n        mRet AtoMinN = getM(astart + to - n2, res, pres);\n        if (targetOffset >= n1 && compare(part, AnMin1, BtoMinN, res, pres) && BtoMinN.valid) {\n            ret = BtoMinN;\n        }\n        if (targetOffset >= n2 && compare(part, BnMin1, AtoMinN, res, pres) && AtoMinN.valid) {\n            ret = AtoMinN;\n        }\n        \/\/ret = cand4;\n        \/\/ret.Am += 10 * int(ret.valid);\n    }\n    return ret;\n}\n\nvoid bitonicSortD(int part, inout vec4 fragColor, in int index) {\n\t\/\/int index = toLinear2(fragCoord, iResolution.xy, 0);\n\n    vec2 res = iResolution.xy;\n    vec2 pres = getRes(res);\n\n    int target = index % count;\n\n    for (int i = 0; i < count; i++) {\n        int partner = index - target + i;\n        \/\/partner = partner * vec4Count + PART;\n        mRet ret = getMD(part, partner, res, pres);\n        A[i] = ret.Cm; \/\/getIndex(part, ret, res, pres);\n        \/\/ TODO: all parts\n        B[i] = vec4(partner);\n    }\n    \/\/sort8();\n\n  \t\/\/fragColor[PART] = B[target][PART];\n    fragColor[PART] = sort8(target)[PART];\n}\n\nstruct mcData {\n    int pass;\n    int n;\n    bool overflow;\n    int index;\n    int base;\n    int astart;\n    int bstart;\n    int targetOffset;\n    \/\/int spart;\n};\n    \nmcData getMCData(int part, in vec2 fragCoord, mPartitionData pd) {\n    mcData ret;\n    \/\/ first partition is lookup, + 3 for bitonic kickstart\n    ret.pass = max(0, pd.partitionIndex - 1);\n    \/\/ret.spart = (part + 1) % vec4Count;\n    ret.n = (1 << ret.pass);\n    ret.overflow = 2 * ret.n > pd.particlesPerPartition || pd.particlesPerPartition % ret.n != 0;\n    ret.index = pd.index - pd.particlesPerPartition;\n    ret.base = ret.index - ret.index % (2 * ret.n);\n    ret.astart = ret.base;\n    ret.bstart = ret.base + ret.n;\n    ret.targetOffset = ret.index - ret.base;\n    return ret;\n}\n\nint mergeColumns(inout vec4 fragColor, in vec2 fragCoord) {\n    vec2 res = iResolution.xy;\n    vec2 pres = getRes(res);\n    mPartitionData pd = getPartitionData(iChannel0, fragCoord, res);\n\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    bool overflow = false;\n    for (int part = 0; part < vec4Count; part++) {\n        mcData ret = getMCData(PART, fragCoord, pd);\n    \toverflow = overflow || ret.overflow;\n        fragColor[PART] = binarySearchForMergeSlim(\n            PART, ret.targetOffset, ret.n, ret.n,\n            pres, res, fragCoord, ret.astart, ret.bstart).v[PART];\n    }\n    if (pd.partitionIndex + 1 < pd.partitionCount) {\n        fragColor += float(pd.particlesPerPartition);\n    }\n    \n    if (overflow) {\n        fragColor = pd.futureParticle;\n        return -1;\n    }\n    \n    if (pd.partitionIndex == 0) {\n        for (int part = 0; part < vec4Count; part++) {\n            bitonicSortD(PART, fragColor, pd.index);\n        }\n        fragColor += float(pd.particlesPerPartition);\n    }\n\n    if (debug) {\n        vec2 digits = vec2(0.0);\n        float bx = -30.0;\n        float by = -15.0;\n        int n = debugLen \/ 2;\n        int astart = 0;\n        int bstart = n;\n        for (int i = 0; i < debugLen; i++) {\n            int targetOffset = i;\n            mRet a = binarySearchForMerge(0, targetOffset, n, n, pres, res, fragCoord, astart, bstart, digits);\n            int val = getIndex(0, a, res, pres);\n            if (val < 0) {\n                val = 99;\n            }\n            digits += printBG(fragCoord + vec2(float(i) * bx, by), float(val), 2, 0);\n        }\n        fragColor.ba += digits;\n        return -1;\n    }\n    return -1;\n}\n\nvoid oddEvenMergeSort(out vec4 fragColor, in vec2 fragCoord) {\n    \/\/ stage 0 has pass = 0\n    \/\/ stage 1 has pass = 1, pass = 0\n    \/\/ stage 2 has pass = 2, pass = 1, pass = 0\n    \/\/ ...\n    vec2 res = iResolution.xy;\n\n    \/\/res = vec2(256.0);\n    vec2 res2 = getRes(res);\n    vec4 self = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    self.ba *= 0.0;\n    int mode = 0;\n    int maxIndex = toLinear2(res - 1.0, res, mode);\n    int fieldSize = int(res.x); \/\/toLinear(res, res);\n    int logFieldsize = int(ceil(log2(float(fieldSize))));\n    int totalSteps = ((logFieldsize + logFieldsize) * (logFieldsize + logFieldsize + 1)) \/ 2;\n    int frame = iFrame;\n\n    \/*\n    if (frame >= totalSteps) {\n        frame -= totalSteps;\n        mode = 1;\n    }*\/\n\n    \/\/frame = int(iTime) \/ 1;\n    \/\/float b3 = print(fragCoord, float(totalSteps) \/ 60.0, 10, 2);\n    \/\/self.b += b3;\n    {\n        vec2 fc = fragCoord;\n        int i = toLinear2(fc, res, mode);\n        int j = i + 1;\n        ivec2 fc2 = fromLinear2(j, res, mode);\n        \/\/fc2 = ivec2(fc + vec2(hash(uvec2(fc)), -1.0));\n        fc2 = ivec2(fc + vec2(0.0, -1.0));\n        \/\/fc2 = ivec2(fc + vec2(1.0, 0.0));\n        vec4 self2 = texelFetch(iChannel0, fc2, 0);\n    \t\/\/self.b = float(length(self2.xy) < length(self.xy));\n        if (!(fragCoord.x >= res.x || fragCoord.y >= res.y)) {\n        \tself.b = float(compareTwo(i, j, self, self2, 1, res2));\n        }\n    }\n    if (frame >= totalSteps) {\n        fragColor = self;\n        return;\n    }\n\n    int pass = -1;\n    int stage = -1;\n    int loopI = 0;\n    for (loopI = 0; loopI < frame + 1; loopI++) {\n        pass--;\n        if (pass < 0) {\n            stage++;\n            pass = stage;\n        }\n    }\n\n    float byd = 15.0;\n    float by = -75.0;\n    float bx = -740.0;\n    vec2 digits = vec2(0.0);\n    digits += printBG(fragCoord + vec2(bx, by), float(pass), 5, 0);\n    by += byd;\n    digits += printBG(fragCoord + vec2(bx, by), float(stage), 5, 0);\n    by += byd;\n    digits += printBG(fragCoord + vec2(bx, by), float(loopI), 5, 0);\n    by += byd;\n    digits += printBG(fragCoord + vec2(bx, by), float(totalSteps), 5, 0);\n    by += byd;\n    digits += printBG(fragCoord + vec2(bx, by), float(logFieldsize), 5, 0);\n    self.ba += digits;\n\n    if (fragCoord.x >= res.x || fragCoord.y >= res.y) {\n        fragColor = vec4(0.0);\n        fragColor = self;\n        return;\n    }\n\n    int ppass = 1 << pass;\n    int pstage = 1 << stage;\n\n    int TwoStage = 2 * pstage;\n    int Pass_mod_Stage = ppass % pstage;\n    int TwoStage_PmS_1 = TwoStage - Pass_mod_Stage - 1;\n    int Pass = ppass;\n\n    int i = toLinear2(fragCoord, res, mode);\n    ivec4 ret = ivec4(getPartner(i, fragCoord, res, TwoStage, Pass_mod_Stage, TwoStage_PmS_1, Pass, maxIndex, mode));\n    int adr = ret.x;\n    ivec2 fc2 = ret.yz;\n    int compare = ret.w;\n\n    if (adr < 0 || fc2.x >= int(res.x) || fc2.y >= int(res.y)) {\n        fragColor = self;\n        return;\n    }\n\n    \/\/ double check that partner will mirror us\n    \/*\n    ivec4 ret2 = ivec4(getPartner(toLinear(fc2, res), vec2(fc2), res, TwoStage, Pass_mod_Stage, TwoStage_PmS_1, Pass, maxIndex));\n    if (ret2.x < 0 || ret2.yz != ivec2(fragCoord) || ret2.w != -compare) {\n        fragColor = self;\n        return;\n    }*\/\n\n    vec4 partner = texelFetch(iChannel0, fc2, 0);\n\n    \/\/ on the left it's a < operation; on the right it's a >= operation\n    \/\/fragColor = (self.x * compare < partner.x * compare) ? self : partner;\n    fragColor = compareTwo(i, adr, self, partner, compare, res2) ? self : partner;\n    \/\/fragColor = (length(self.xy) * float(compare) < length(partner.xy) * float(compare)) ? self : partner;\n}\n\nvoid bitonicSort(int part, out vec4 fragColor, in vec2 fragCoord) {\n\tint index = toLinear2(fragCoord, iResolution.xy, 0);\n\n    vec2 res = iResolution.xy;\n    vec2 pres = getRes(res);\n\n    int target = index % count;\n\n    int bucketSize = count;\n    for (int i = 0; i < count; i++) {\n        int partner = index - target + i;\n        mRet ret = getM(partner, res, pres);\n        A[i] = getIndex(part, ret, res, pres);\n        B[i] = ret.v;\n    }\n    \/\/sort8();\n\n  \tfragColor[PART] = B[target][PART];\n}\n\nvoid bubbleSort(int part, out vec4 fragColor, in vec2 fragCoord, int frame) {\n    vec2 res = iResolution.xy;\n    vec2 pres = getRes(res);\n    int n = toLinear2(res - 1.0, res, 0);\n    int k = frame;\n    int index = toLinear2(fragCoord, res, 0);\n    \/\/ Examples:\n\n    \/\/ k % 2 == 0 && index % 2 == 0 => dir == 1\n    \/\/ k % 2 == 0 && index % 2 == 1 => dir == -1\n    \/\/ k % 2 == 1 && index % 2 == 0 => dir == -1\n    \/\/ k % 2 == 1 && index % 2 == 1 => dir == 1\n\n    \/\/ k == 0 && index == 0 => index + dir == 0 + 1 = 1\n    \/\/ k == 0 && index == 1 => index + dir == 1 - 1 = 0\n    \/\/ k == 0 && index == 2 => index + dir == 2 + 1 = 3\n    \/\/ k == 0 && index == 3 => index + dir == 3 - 1 = 2\n    \/\/ k == 0 && index == 4 => index + dir == 4 + 1 = 5\n    \/\/ k == 0 && index == 5 => index + dir == 5 - 1 = 4\n\n    \/\/ k == 1 && index == 0 => index + dir == 0 - 1 = -1\n    \/\/ k == 1 && index == 1 => index + dir == 1 + 1 = 2\n    \/\/ k == 1 && index == 2 => index + dir == 2 - 1 = 1\n    \/\/ k == 1 && index == 3 => index + dir == 3 + 1 = 4\n    \/\/ k == 1 && index == 4 => index + dir == 4 - 1 = 3\n    \/\/ k == 1 && index == 5 => index + dir == 5 + 1 = 6\n    int dir = index % 2 == k % 2 ? 1 : -1;\n    mRet aRet = getM(index, res, pres);\n    mRet bRet = getM(index + dir, res, pres);\n    \/\/mRet aRet2 = getMD(int(aRet.v.z), res, pres);\n    \/\/mRet bRet2 = getMD(int(bRet.v.z), res, pres);\n\n    \/\/ update\n    \/*\n    aRet.v = updateParticle(aRet.v);\n    bRet.v = updateParticle(bRet.v);\n    aRet.Am = toIndex(aRet.v.xy * pres, pres);\n    bRet.Am = toIndex(bRet.v.xy * pres, pres);\n\t*\/\n\n    if (index + dir < 0 || index + dir >= n || !isLinearValid(index + dir, res)) {\n        fragColor = aRet.v;\n    } else {\n        if (getIndex(part, aRet, res, pres) * dir < getIndex(part, bRet, res, pres) * dir) {\n            fragColor[PART] = aRet.v[PART];\n        } else {\n            fragColor[PART] = bRet.v[PART];\n        }\n    }\n}\n\nint runPasses(out vec4 fragColor, in vec2 fragCoord, int startFrame) {\n    int ret = mergeColumns(fragColor, fragCoord);\n\treturn ret;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    int ret = runPasses(fragColor, fragCoord, int(0));\n    \/*\n    \/\/ https:\/\/www.shadertoy.com\/view\/MsVBWd\n    float startFrame = texelFetch(iChannel0, ivec2(0), 0).a;\n    if (iFrame == 0 || startFrame < 1.0) {\n        fragColor = vec4(0.0);\n        if (iChannelResolution[1].x > 0.0) {\n            if (fragCoord.x <= 1.0 && fragCoord.y <= 1.0) {\n            \tfragColor.a = 1.0 + float(iFrame);\n            }\n        }\n        return;\n    }\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    \/\/oddEvenMergeSort(fragColor, fragCoord);\n    int ret = runPasses(fragColor, fragCoord, int(startFrame));\n\n    \/\/fragColor.ba += printBG(fragCoord + vec2(-100.0, 0.0), float(startFrame), 5, 0);\n\n    if (fragCoord.x < 1.0 && fragCoord.y < 1.0) {\n        fragColor.a = startFrame;\n        \/\/fragColor.b = float(ret);\n    }*\/\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"\/media\/previz\/buffer03.png","previewfilepath":"\/media\/previz\/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"#define condFetch(x) texelFetch(iChannel2, ivec2(x), 0)\n\nstruct mRet {\n    int dIndex;\n    int Am;\n    vec4 v;\n    vec2 pos;\n};\n\nmRet getMD(int part, int m, vec2 res, vec2 pres) {\n    vec2 fc = vec2(fromLinear(m, res));\n    vec4 v = texelFetch(iChannel3, ivec2(fc), 0);\n    vec2 pos = part == 0 ? v.xy : v.zw;\n    int Am = toIndex(iChannel0, pos * pres, pres);\n    return mRet(m, Am, v, pos);\n}\n\nfloat textColor(vec3 bgColor) {\n  float r = bgColor.r * 255.0,\n        g = bgColor.g * 255.0,\n        b = bgColor.b * 255.0;\n  float yiq = (r * 299.0 + g * 587.0 + b * 114.0) \/ 1000.0;\n  return (yiq >= 128.0) ? 0.0 : 1.0;\n}\n\nvec2 vmin(vec2 v1, vec2 v2) {\n    return length(v1) < length(v2) ? v1 : v2;\n}\n\nmRet getM(int part, int m, vec2 res, vec2 pres) {\n    vec2 fc = vec2(fromLinear(m, res));\n    vec4 v = condFetch(fc);\n    \/\/int Am = toIndex(iChannel0, v.xy * pres, pres);\n    mRet ret2 = getMD(part, int(v[part]), res, pres);\n    vec4 v2 = ret2.v;\n    vec2 pos = part == 0 ? v2.xy : v2.zw;\n    int Am = toIndex(iChannel0, pos * pres, pres);\n    return mRet(int(v.x), ret2.Am, v2, pos);\n}\n\nint binarySearchLeftMost(int part, int T, vec2 pres, vec2 res, in vec2 fragCoord, out vec4 col) {\n    mPartitionData pd = getPartitionData(iChannel0, fragCoord, res);\n    int n = pd.particlesPerPartition;\n    int L = (pd.partitionCount - 1) * n;\n    int R = L + n;\n    \n    int bx = 0;\n    int by = 20;\n    int i = 0;\n    for (i = 0; i < maxBin && L < R; i++) {\n        int m = (L + R) \/ 2;\n        int Am = getM(part, m, res, pres).Am;\n        \/\/col += print(fragCoord - vec2(0.0, by + i * 15), float(i), 3, 0);\n        \/\/col += print(fragCoord - vec2(50.0, by + i * 15), float(m), 10, 0);\n        \/\/col += print(fragCoord - vec2(150.0, by + i * 15), float(L), 10, 0);\n        \/\/col += print(fragCoord - vec2(250.0, by + i * 15), float(R), 10, 0);\n        L = Am < T ? m + 1 : L;\n        R = Am >= T ? m : R;\n    }\n    \/\/col += print(fragCoord - vec2(0.0, 0.0), float(T), 10, 0);\n    int ret = i < maxBin - 1 ? L : -1;\n    \/\/col += print(fragCoord - vec2(bx + 100, 0.0), float(ret), 10, 0);\n    return ret;\n}\n\nint binarySearchRightMost(int part, int T, vec2 pres, vec2 res, in vec2 fragCoord, out vec4 col) {\n    mPartitionData pd = getPartitionData(iChannel0, fragCoord, res);\n    int n = pd.particlesPerPartition;\n    int L = (pd.partitionCount - 1) * n;\n    int R = L + n;\n    \n    \n    int bx = 400;\n    int by = 20;\n    int i = 0;\n    for (i = 0; i < maxBin && L < R; i++) {\n        int m = (L + R) \/ 2;\n        int Am = getM(part, m, res, pres).Am;\n        \/\/col += print(fragCoord - vec2(bx + 0, by + i * 15), float(i), 3, 0);\n        \/\/col += print(fragCoord - vec2(bx + 50, by + i * 15), float(m), 10, 0);\n        \/\/col += print(fragCoord - vec2(bx + 150, by + i * 15), float(L), 10, 0);\n        \/\/col += print(fragCoord - vec2(bx + 250, by + i * 15), float(R), 10, 0);\n        L = Am <= T ? m + 1 : L;\n        R = Am > T ? m : R;\n    }\n    \/\/col += print(fragCoord - vec2(bx, 0.0), float(T), 10, 0);\n    int ret = i < maxBin - 1 ? L - 1 : -1;\n    \/\/col += print(fragCoord - vec2(bx + 100, 0.0), float(ret), 10, 0);\n    return ret;\n}\n\nfloat doDistance(int part, in vec2 fragCoord, vec2 colorUV) {\n    vec2 res2 = iResolution.xy;\n    float t = 1.0; \/\/(sin(iTime) + 1.0) \/ 2.0 + 0.1;\n    vec2 oc = fragCoord;\n    fragCoord = ((fragCoord \/ res2 - 0.5) * t + 0.5) * res2;\n    \/\/vec2 res2 = vec2(256.0);\n    \/\/vec3 col = vec3(0.0);\n    vec2 powerOfTwoRes = getRes(res2);\n    \/\/vec2 res = res2;\n    vec2 uv = floor(fragCoord \/ res2 * powerOfTwoRes);\n    ivec2 div = maxDiv(powerOfTwoRes);\n    \/\/vec2 colorUV = fragCoord \/ iResolution.xy;\n    int n = int(powerOfTwoRes.x * powerOfTwoRes.y);\n    int m = int(res2.x * res2.y);\n\n\t\/\/fragColor *= 0.0;\n    int uvIndex = toIndex(iChannel0, uv, powerOfTwoRes);\n    \/\/uvIndex = m \/ 2;\n    vec4 frcol = vec4(0.0);\n    int index3 = binarySearchLeftMost(part, uvIndex, powerOfTwoRes, res2, oc, frcol);\n    int index4 = binarySearchRightMost(part, uvIndex, powerOfTwoRes, res2, oc, frcol);\n\n    mRet mret = getM(part, index3, res2, powerOfTwoRes);\n    int foundIndex = mret.Am;\n    vec4 v = mret.v;\n    float d = distance(colorUV, mret.pos);\n \n    int j = 0;\n    int a = min(index3, index4);\n    int b = max(index3, index4);\n    int maxIter = 1;\n    int retIndex = -1;\n    for (int j = 0; j < maxIter; j++) {\n        int i = a + j - maxIter \/ 2;\n        mRet mret = getM(part, i, res2, powerOfTwoRes);\n        int foundIndex = mret.Am;\n        vec4 v = mret.v;\n        float d2 = distance(colorUV, mret.pos);\n        if (d2 < d) {\n            d = d2;\n            retIndex = i; \/\/foundIndex;\n        }\n    }\n\n    return float(retIndex);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 col = vec3(0.0);\n    vec2 res2 = iResolution.xy;\n    vec2 res = getRes(iResolution.xy);\n    vec2 powerOfTwoRes = res;\n    vec2 uv = floor(fragCoord \/ iResolution.xy * res);\n    ivec2 div = maxDiv(res);\n    vec2 colorUV = fragCoord \/ iResolution.xy;\n    int n = int(res.x * res.y);\n    int m = int(iResolution.x * iResolution.y);\n    fragColor += print(fragCoord, float(n), 10, 0);\n    \/\/return;\n\n    vec4 old = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    float oldIndex = old.x;\n    \/\/float oldIndex2 = old.y;\n\n    for (int part = 0; part < vec4Count; part++) {\n        mRet mret1 = getM(part, int(oldIndex), res2, powerOfTwoRes);\n        float d2 = distance(colorUV, mret1.pos);\n        \/\/mRet mret3 = getM(int(oldIndex2), res2, powerOfTwoRes);\n        \/\/float d5 = distance(colorUV, mret3.v.xy);\n        \/\/float d2 = min(d4, d5);\n        \/\/float oldIndex = d4 < d5 ? oldIndex1 : oldIndex2;\n\n        float index = doDistance(part, fragCoord, colorUV);\n\n        mRet mret2 = getM(part, int(index), res2, powerOfTwoRes);\n        \/\/int bufDIndex = int(mret2.v.z);\n        \/\/mRet mret3 = getMD(bufDIndex, res2, powerOfTwoRes);\n\n        float d3 = distance(colorUV, mret2.pos);\n        \/\/float d3 = distance(colorUV, mret2.v.xy);\n\n        index = d3 < d2 ? index : oldIndex;\n        \/\/vec2 v = d3 < d2 ? mret2.v.xy - mret2.v.zw : old.zw;\n\n        fragColor[PART] = index; \/\/vec4(index, 0.0, v);\n    }\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"\/media\/previz\/buffer03.png","previewfilepath":"\/media\/previz\/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"\/media\/a\/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"\/media\/ap\/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy;\n    vec2 pres = getRes(res);\n    vec2 fc = fragCoord \/ res * pres;\n    \/\/fc = fragCoord;\n    int index = toIndexFull(fc, pres);\n    \n    \/\/ TODO: maybe incorrect\n    vec2 revIndex = vec2(fromIndexFull(toLinear(fc, res), pres));\n    \n    \/\/float startFrame = texelFetch(iChannel0, ivec2(0), 0).a;\n    \n    \/\/fragColor = vec4(index \/ 0xFFFF, index % 0xFFFF, 0.0, 0.0);\n    fragColor = vec4(index, 0.0, 0.0, 0.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"\/media\/previz\/buffer03.png","previewfilepath":"\/media\/previz\/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"\/media\/a\/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"\/media\/ap\/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"vec2 transformPos(vec2 pos) {\n    pos = (pos - 0.5) * 4.0 + 0.5;\n    pos = mod(pos, 1.0);\n\t\/\/pos = clamp(pos, 0.0, 1.0);\n    pos = vec2(0.5);\n    return pos;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ https:\/\/www.shadertoy.com\/view\/MsVBWd\n    float startFrame = floor(texelFetch(iChannel0, ivec2(0), 0).a);\n    \n    vec2 res = iResolution.xy;\n    mPartitionData pd = getPartitionData(iChannel0, fragCoord, res);\n    \n    if (iFrame == 0 || startFrame < 1.0) {\n        fragColor = vec4(0.0);\n        if (iChannelResolution[2].x > 0.0) {\n        \t\/\/fragColor.ba = vec2(0.0);\n            \n            if (pd.partitionIndex == 0) {\n                \/\/ position\n                vec2 fc = vec2(fromLinear(pd.index, res));\n            \tvec4 data = texture(iChannel2, fc \/ iResolution.xy);\n        \t\tfragColor.xy = transformPos(data.xy);\n                fragColor.zw = transformPos(data.zw);\n            } else {\n                \/\/ velocity\n                vec2 fc = vec2(fromLinear(pd.futureIndex, res));\n            \tvec4 data = texture(iChannel2, fc \/ iResolution.xy);\n                \n                vec2 pos = transformPos(data.xy);\n                vec2 vel = 10.0 * (data.zw - 0.5) \/ iResolution.xy;\n                float maxSpeed = 1.0;\n                vel = length(vel) > maxSpeed ? maxSpeed * vel \/ length(vel) : vel;\n                vec2 oldPos = pos - vel;\n            \tfragColor.xy = oldPos;\n                \n                pos = transformPos(data.zw);\n                vel = 10.0 * (data.xy - 0.5) \/ iResolution.xy;\n                vel = length(vel) > maxSpeed ? maxSpeed * vel \/ length(vel) : vel;\n                oldPos = pos - vel;\n            \tfragColor.zw = oldPos;\n            }\n            \n            if (pd.overflow) {\n                fragColor = vec4(0.0);\n            }\n            \n            if (fragCoord.x < 1.0 && fragCoord.y < 1.0) {\n            \tfragColor.a += 1.0 + float(iFrame);\n            }\n        }\n        return;\n    }\n    \/\/fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    vec4 particle1 = vec4(0.0);\n    particle1.xy = getPosition(iChannel0, pd.index, res);\n    particle1.zw = getPosition(iChannel0, pd.pastIndex, res);\n    vec4 particle2 = vec4(0.0);\n    particle2.xy = getPosition2(iChannel0, pd.index, res);\n    particle2.zw = getPosition2(iChannel0, pd.pastIndex, res);\n    \/\/fragColor = texture(iChannel2, fragCoord \/ iResolution.xy) + hash(uvec2(fragCoord) + uint(iFrame));\n    vec4 updatedParticle = vec4(updateParticle(particle1).xy, updateParticle(particle2).xy);\n    \/\/newParticle = fragColor;\n\t\n    \/\/newParticle = vec4(float(iFrame % 10) \/ 10.0);\n    fragColor = pd.partitionIndex == 0 ? updatedParticle : pd.futureParticle;\n    fragColor = pd.overflow ? vec4(0.0) : fragColor;\n    \n    \/\/bubbleSort(fragColor, fragCoord, iFrame);\n    \n    \n    \/*\n    bool sorted1 = texelFetch(iChannel1, ivec2(0), 0).b > 1.0;\n    int mp = getMaxPasses(iResolution.xy);\n    int frame = iFrame - int(startFrame);\n    if (sorted1 && isValid(fragCoord, iResolution.xy) && frame % (3 * mp) == mp) {\n        int index = int(texelFetch(iChannel1, ivec2(fragCoord), 0).z);\n       \tfragColor = texelFetch(iChannel0, ivec2(fromLinear(index, iResolution.xy)), 0);\n    }*\/\n    \n    if (fragCoord.x < 1.0 && fragCoord.y < 1.0) {\n        fragColor.a = fract(fragColor.a) + startFrame;\n    }\n}","name":"Buffer D","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"XsByzK","date":"1492706000","viewed":878,"name":"2D Terrain and Water","username":"emh","description":"Water simulation with obstacles \/ terrain interaction using finite differences approximation of the wave equation. Click on the surface to make some waves. Based on https:\/\/www.shadertoy.com\/view\/4sd3WB .","likes":6,"published":3,"flags":32,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Wave propagation simulation using finite differences.\n\/\/ See (f.ex.) http:\/\/www.uio.no\/studier\/emner\/matnat\/ifi\/INF2340\/v05\/foiler\/sim04.pdf\n\/\/ for the model and equations.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    uv \/= 1.0;\n    vec4 water = texture(iChannel0, uv);\n    float h = 2.0*water.w+0.5;\n    if (false && water.x == 0.0) {\n        fragColor = vec4(water.z); \/\/ vec4(0.0, 0.0, water.z, 1.0);\n    } else {\n        \/*\n        if (water.y < 0.0) {\n        \tfragColor = vec4(water.w, 0.0, 0.0, 1.0);\n        } else {\n            fragColor = vec4(0.0, 0.0, water.w, 1.0);\n        }*\/\n        \/\/vec4 waterColor = mix(vec4(1.0, 0.0, 0.0, 1.0), vec4(0.0, 0.0, 1.0, 1.0), water.y + 0.5) * water.w;\n        vec4 waterColor = mix(vec4(0.0, 0.0, 0.0, 1.0), vec4(0.0, 0.0, 1.0, 1.0), water.y) * water.w + vec4(0.0, 0.5, 1.0, 0.0);\n        vec4 land = vec4(0.0); \/\/ vec4(water.z * water.x * 5.0, 0.0, 0.0, 1.0);\n        \/\/vec4 land = vec4(1.0, 1.0, 1.0, 1.0);\n        fragColor = mix(land, waterColor, water.x);\n        \/\/fragColor = waterColor + vec4(vec3(0.0, 0.3, 0.6) * water.w, 1.0);\n        if (water.z > 0.0) {\n            vec4 forestColor = vec4(fragColor.r, 0.8 - water.z, fragColor.b, 1.0);\n            if (water.z < 0.1) {\n                \/\/ beachhead\n                fragColor.r = water.z;\n            } else if (water.z < 0.2) {\n                \/\/ forest\n        \t\tfragColor = forestColor;\n            } else {\n                \/\/ mountains\n                fragColor = mix(forestColor,\n                                vec4(0.6, 0.5, 0.5, 1.0) * water.z, (water.z - 0.2));\n            }\n        }\n        \/\/ fragColor = vec4(water.z);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ Mouse excitation\n    vec2 r = fragCoord.xy - iMouse.xy;\n    float d = 0.001*dot(r,r);\n    if(iMouse.z > 0.0 && d < 0.05) {\n    \t\/\/fragColor = vec4(0.0,0.2,0,0);\n        fragColor = vec4(0.0,10.0,0,0);\n        return;\n    } \n    \n    \/\/ Periodic excitation\n    \/*\n    r = fragCoord.xy - vec2(50, 70);\n    d = 0.001*dot(r,r);\n    if (mod(iTime, 0.5) < 0.1 && d < 0.05) {\n        fragColor = vec4(0.0,0.1,0,0);\n        return;\n   \t}\n    \n    if (mod(iTime, 0.5) < 0.1 && fragCoord.x \/ iResolution.x > 0.99) {\n        fragColor = vec4(0.0,0.1,0,0);\n        return;\n   \t}\n\t*\/\n\n    \/\/ just copy\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n   \tfragColor = texture(iChannel0, uv);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n#define HEIGHT 2.4\n#define TERRAMUL 1.0\n\nbool hitTest(vec2 uvn) {\n    \/*float d = distance(uvn, vec2(0.5, 0.5));\n    if (d < 0.2) {\n        return self;\n    }*\/\n    \/*\n    if ((uvn.x > 0.4 && uvn.x < 0.6) &&\n        (uvn.y > 0.4 && uvn.y < 0.6)) {\n        return true;\n    }*\/\n    float h = texture(iChannel1, uvn).x;\n    \/\/if (h > nb || h > HEIGHT) {\n    if (h > HEIGHT) {\n        return true;\n    }\n    return false;\n}\n\nbool checkSink(vec2 uv) {\n    return distance(uv, vec2(0.5, 0.5)) <= 0.1;\n}\n\nfloat getContribution(vec2 uv, float u, float uTotal) {\n    float terrainHeight = texture(iChannel1, uv).x * TERRAMUL;\n    float waterHeight = texture(iChannel0, uv).x;\n    float totalHeight = waterHeight + terrainHeight;\n    float ux = 0.0;\n    if (totalHeight >= uTotal) {\n        ux = min(totalHeight - uTotal, waterHeight);\n    } else {\n        \/\/ux = max(totalHeight - uTotal, -u);\n        ux = max(totalHeight - uTotal, -u);\n    }\n    \/\/ ux = totalHeight - uTotal;\n    bool ht = hitTest(uv);\n    \/\/ if (ht || checkSink(uv)) {\n    if (ht) {\n    \tux = 0.0;\n    }\n    return ux;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float dx = 1.0\/iResolution.x;\n    float dy = 1.0\/iResolution.y;\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n\n    vec2 udu = texture(iChannel0, uv).xy;\n\t\/\/ old elevation\n    float u = udu.x;\n    float terrainHeight = texture(iChannel1, uv).x * TERRAMUL;\n    float uTotal = u + terrainHeight;\n    \/\/ old velociy\n    float du = udu.y;\n    \n    \n    \n    float self = 0.0;\n    \n    \/\/ Finite differences\n    vec2 uv1 = vec2(uv.x+dx, uv.y);\n    float ux = getContribution(uv1, u, uTotal);\n    \n    vec2 uv2 = vec2(uv.x-dx, uv.y);\n    float umx = getContribution(uv2, u, uTotal);\n    \n    vec2 uv3 = vec2(uv.x, uv.y+dy);\n    float uy = getContribution(uv3, u, uTotal);\n    \n    vec2 uv4 = vec2(uv.x, uv.y-dy);\n    float umy = getContribution(uv4, u, uTotal);\n    \n    bool onlyRain = terrainHeight > 0.0;\n\n    \/\/ new elevation\n    float nu = u + du + 0.5*(umx+ux+umy+uy);\n    if (onlyRain) {\n        nu = u + 0.5 * (umx+ux+umy+uy);\n    }\n    \/\/ float nu = u + 0.5*(umx+ux+umy+uy);\n    \n    \/\/ store elevation and velocity\n    \n    \/\/ wave decay\n    nu = 0.999999*nu;\n    \n    \/*\n    float d = distance(uv, vec2(0.5, 0.5));\n    if (d < 0.1) {\n        float scale = mix(0.99, 0.999999, d * 2.0);\n        nu = scale*nu;\n    }*\/\n    \n    \/\/ if (terrainHeight < 0.1) {\n    float v = nu - u;\n    \n    if (onlyRain) {\n    \tv = 0.0;\n    }\n    \n    bool dry = false; \/\/ checkSink(uv) || hitTest(uv);\n    \n    if (dry) {\n        nu = 0.0;\n        v = 0.0;\n    }   \n    \n    \/\/ rain\n    if (!dry) {\n    \tnu += 0.00001;\n    }\n    \n    if (nu < 0.0) {\n        nu = 0.0;\n        v = 0.0;\n    }\n    if (nu > 1.5) {\n        nu = 1.5;\n        v \/= 1.1;\n    }\n    \n    float z = terrainHeight \/ TERRAMUL;\n    float w = (terrainHeight + nu) \/ TERRAMUL;\n    \n    fragColor = vec4(nu,v,z,w);\n\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\/\/\n\/\/ Description : Array and textureless GLSL 2D\/3D\/4D simplex \n\/\/               noise functions.\n\/\/      Author : Ian McEwan, Ashima Arts.\n\/\/  Maintainer : stegu\n\/\/     Lastmod : 20110822 (ijm)\n\/\/     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n\/\/               Distributed under the MIT License. See LICENSE file.\n\/\/               https:\/\/github.com\/ashima\/webgl-noise\n\/\/               https:\/\/github.com\/stegu\/webgl-noise\n\/\/ \n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 \/ 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 \/ 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  { \n  const vec2  C = vec2(1.0\/6.0, 1.0\/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n\/\/ First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n\/\/ Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  \/\/   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  \/\/   x1 = x0 - i1  + 1.0 * C.xxx;\n  \/\/   x2 = x0 - i2  + 2.0 * C.xxx;\n  \/\/   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; \/\/ 2.0*C.x = 1\/3 = C.y\n  vec3 x3 = x0 - D.yyy;      \/\/ -1.0+3.0*C.x = -0.5 = -D.y\n\n\/\/ Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n\/\/ Gradients: 7x7 points over a square, mapped onto an octahedron.\n\/\/ The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; \/\/ 1.0\/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  \/\/  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    \/\/ mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  \/\/vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  \/\/vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n\/\/Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n\/\/ Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    float scale = 3.0;\n    float ns = 0.0;\n    float fac = 1.0;\n    float time = iTime \/ 40.0;\n    \/\/ time = 0.0;\n    ns += fac * snoise(vec3(uv.x * scale, uv.y * scale, time));\n    fac \/= 2.0;\n    scale *= 2.0;\n    ns += fac * snoise(vec3(uv.x * scale, uv.y * scale, time));\n    fac \/= 2.0;\n    scale *= 2.0;\n    ns += fac * snoise(vec3(uv.x * scale, uv.y * scale, time));\n    fac \/= 2.0;\n    scale *= 2.0;\n    ns += fac * snoise(vec3(uv.x * scale, uv.y * scale, time));\n    fragColor = vec4(ns);\n}","name":"Buf C","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"4lKGzw","date":"1473934811","viewed":745,"name":"Tree Computation","username":"emh","description":"Shows how to compute a binary heap in buffer A and then draw lines for branches in buffer B. I believe it has some bugs still. A branch per pixel. New random tree each 20 seconds (when at 60 FPS).","likes":7,"published":3,"flags":32,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 restorePoint(vec2 point) {\n    return point * 2.0 - 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord \/ iResolution.xy;\n    vec2 uvn = restorePoint(uv);\n    vec4 color = texture(iChannel0, uv);\n    vec2 point = restorePoint(color.zw);\n    float d = distance(uvn, point);\n    fragColor.a = 1.0;\n    if (color.x > 0.0 || color.z > 0.0) {\n    \t\/\/fragColor = vec4(vec3(0.0, 0.0, color.x * 1.0e3 * color.y) + vec3(color.z, 0.0, 0.0), 1.0);\n        float g = color.x * 1000.0 * pow(color.y, 0.5);\n        fragColor = vec4(vec3(0.0, g, 0.0) + vec3(color.z, 0.0, 0.0), 1.0);\n    } else {\n        \/\/fragColor = vec4(vec3(0.5), 1.0);\n        fragColor = vec4(vec3(0.5 + uv.y \/ 2.0, 0.5, 0.5), 1.0);\n    }\n    \/\/fragColor = vec4(vec3(color.x) * 10.0, 1.0);\n\t\/\/fragColor = vec4(vec3(d) * 200.0, 1.0);\n    \/\/fragColor = vec4(vec3(d) * 10.0, 1.0);\n    \/\/fragColor.xy = color.xy;\n    \/\/fragColor = vec4(vec3(color.z), 1.0);\n    \/\/fragColor.xy = texture(iChannel1, uv).xy;\n    \/\/fragColor.r = texture(iChannel1, uv).z;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.141592653589793238462643383\n\n#define REDRAW_INTERVAL 20.0\n\n#define Thickness 0.001\n\n#define iRes iChannelResolution[0]\n\n\/\/ Simple random function\nfloat random(float co)\n{\n    return fract(sin(co*12.989) * 43758.545);\n}\n\n#define INIT_VALUE1 storePoint(vec2(1.0))\n#define INIT_VALUE2 storePoint(vec2(0.0))\n#define INIT_VALUE vec4(INIT_VALUE1, INIT_VALUE2)\n\nvec2 restorePoint(vec2 point) {\n    return point * 2.0 - 1.0;\n}\n\nvec2 storePoint(vec2 point) {\n    return (point + 1.0) \/ 2.0;\n}\n\nvec4 doMain(vec2 fragCoord, vec2 uv) {\n    vec4 prev = texture(iChannel0, uv);\n    vec2 coord = fragCoord;\n    int height = int(iRes.y);\n    float eps = 1.0;\n    vec2 uvn = restorePoint(uv);\n    \n    \/\/ test\n    \/*\n    vec2 point = vec2(uvn.x, uvn.y);\n    prev.xy = storePoint(point);\n    prev.zw = storePoint(point+vec2(1.0)\/iRes.xy);\n    prev.zw = storePoint(vec2(0.0));\n\t*\/\n    \n    if (prev.xy == INIT_VALUE1 && coord.x < eps && coord.y < eps) {\n        vec2 point = vec2(0.0, -1.0);\n        float radius = 0.2;\n        float angle = PI \/ 2.0;\n        vec2 point2 = storePoint(point + vec2(cos(angle), sin(angle)) * radius);\n        point = storePoint(point);\n        return vec4(point2, point);\n    }\n    \n    const int iterations = 1;\n    int index = int(coord.y) * int(height) + int(coord.x);\n    int maxi = 0;\n    for (int i = 0; i < iterations; i++) {\n        if (index == 0) {\n            maxi = i;\n            break;\n        }\n        int parentIndex = (index - 1) \/ 2;\n        vec2 pv2 = vec2(mod(float(parentIndex), float(height)), float(parentIndex \/ int(height))) \/ iRes.xy;\n        vec4 parentValue = texture(iChannel0, pv2);\n        \n        if (i == 0 && prev.xy == INIT_VALUE1 && parentValue.xy != INIT_VALUE1) {\n            \n            vec2 point = restorePoint(parentValue.xy);\n            vec2 point2 = restorePoint(parentValue.zw);\n            \n            float radius = distance(point, point2) * 0.9;\n            vec2 pp2 = point - point2;\n            float prevAngle = atan(pp2.y, pp2.x);\n            \n            float at = atan(uvn.y - point.y, uvn.x - point.x);\n            float atNorm = (at + PI) \/ (2.0 * PI);\n            float angle = random(11.7 + at + uv.x + uv.y + iTime);\n            \/\/float angle = random(11.7 + floor(at * 5.0) + iTime);\n            angle = prevAngle + (angle * 2.0 - 1.0) * PI \/ 4.0;\n            vec2 newPoint = point + vec2(cos(angle), sin(angle)) * radius;\n            newPoint = storePoint(newPoint);\n            vec2 parentPoint = storePoint(point);\n            float storeAngle = (angle + PI) \/ (2.0 * PI);\n            return vec4(newPoint, parentPoint);\n        } else {\n            break;\n        }\n        index = parentIndex;\n    }\n    \/\/if (prev.xy == INIT_VALUE1) {\n    \n    \/\/}\n    return prev;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy \/ iRes.xy;\n    \n    \/\/ initialize\n    if (mod(float(iFrame), REDRAW_INTERVAL * 60.0) < 10.0) {\n        fragColor = INIT_VALUE;\n    } else {\n    \tfragColor = doMain(fragCoord, uv);\n    }\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define PI 3.141592653589793238462643383\n\n#define REDRAW_INTERVAL 20.0\n\n#define Thickness 0.001\n\n#define iRes iChannelResolution[0]\n\n\/\/ from http:\/\/stackoverflow.com\/questions\/15276454\/is-it-possible-to-draw-line-thickness-in-a-fragment-shader\n\nfloat drawLine(vec2 uv, vec2 p1, vec2 p2) {\n  float a = abs(distance(p1, uv));\n  float b = abs(distance(p2, uv));\n  float c = abs(distance(p1, p2));\n\n  if ( a >= c || b >=  c ) return 0.0;\n\n  float p = (a + b + c) * 0.5;\n\n  \/\/ median to (p1, p2) vector\n  float h = 2.0 \/ c * sqrt( p * ( p - a) * ( p - b) * ( p - c));\n\n  return mix(1.0, 0.0, smoothstep(0.5 * Thickness, 1.5 * Thickness, h));\n}\n\n\/\/ end from\n\n\n\/\/ Simple random function\nfloat random(float co)\n{\n    return fract(sin(co*12.989) * 43758.545);\n}\n\n#define INIT_VALUE1 storePoint(vec2(1.0))\n#define INIT_VALUE2 storePoint(vec2(0.0))\n#define INIT_VALUE vec4(INIT_VALUE1, INIT_VALUE2)\n\nvec2 restorePoint(vec2 point) {\n    return point * 2.0 - 1.0;\n}\n\nvec2 storePoint(vec2 point) {\n    return (point + 1.0) \/ 2.0;\n}\n\n\/*\nvec2 getParent(vec2 pv) {\n    int height = int(iRes.y);\n    int index = int(pv.y * iRes.y) * int(height) + int(pv.x * iRes.x);\n    int parentIndex = (index - 1) \/ 2;\n    float x = mod(float(parentIndex), float(height));\n    float y = float(parentIndex \/ height);\n    vec2 pv3 = vec2(x, y) \/ iRes.xy;\n    vec4 parentValue = texture(iChannel0, pv3);\n    vec2 point2 = restorePoint(parentValue.xy);\n    return point2;\n}\n\nvec2 getClosestPointOnLine(vec2 point, vec2 endPoint1, vec2 endPoint2) {\n    vec2 p1 = endPoint1;\n    vec2 p2 = point;\n    vec2 v = endPoint2 - endPoint1;\n    vec2 pr = p1 + dot((p2 - p1), v) * v \/ dot(v, v);\n    return pr;\n}\n*\/\n\nvec4 doMain(vec2 fragCoord, vec2 uv) {\n    vec4 prev2 = texture(iChannel1, uv);\n    vec2 coord = fragCoord; \/\/uv * iRes.xy;\n    int height = int(iRes.y);\n    float eps = 1.0;\n    \n    vec2 uvn = restorePoint(uv);\n    \n    \n    if (prev2.x == INIT_VALUE.x) {\n        prev2.x = 0.0;\n        prev2.y = 1.0;\n        prev2.z = 0.0;\n    }\n\n    const int area = 10;\n    const int area2 = area * 2;\n    \n    \/\/ why * 2.0? was found \"experimentally\"\n    float numAreasHeight = ceil(float(height \/ area2)) * 2.0;\n\n    \/\/float frame = mod(float(iFrame), ceil(iRes.x * iRes.y \/ float(area2 * area2)));\n    \/\/float frame = mod(float(iFrame), numAreasHeight * numAreasHeight);\n    float frame = float(iFrame);\n    float frameX = mod(frame, numAreasHeight) * float(area2);\n    float frameY = floor(frame \/ numAreasHeight) * float(area2);\n    float xoffset = frameX \/ iRes.x;\n    float yoffset = frameY \/ iRes.y;\n\n    for (int i = -area; i < area; i++) {\n        for (int j = -area; j < area; j++) {\n            vec2 pv = uv + vec2(float(i), float(j)) \/ iRes.xy;\n            pv.x = fract(pv.x + xoffset);\n            pv.y = fract(pv.y + yoffset);\n            vec4 val = texture(iChannel0, pv);\n            if (val == INIT_VALUE) {\n                continue;\n            }\n            vec2 point = restorePoint(val.xy);\n            vec2 point2 = restorePoint(val.zw);\n\n            \/\/vec2 point2 = getParent(pv);\t\t\t\t\n            float z = drawLine(uvn, point, point2);\n            if (uvn == point || uvn == point2) {\n                z = 1.0;\n            }\n            float maxdist = 0.001;\n            float z2 = distance(uvn, point);\n            float z3 = distance(uvn, point2);\n            if (z2 >= maxdist) {\n                z2 = 0.0;\n            } else {\n                z2 = 1.0;\n            }\n            if (z3 >= maxdist) {\n                z3 = 0.0;\n            } else {\n                z3 = 1.0;\n            }\n\n            prev2.x += 0.0001 * z;\n            if (z > 0.0) {\n                prev2.y = 1.0 \/ (1.0 \/ prev2.y + 1.0);\n            }\n\n            \/\/ draw nodes\n            \/\/prev2.z = max(prev2.z, max(z2, z3));\n        }\n    }\n    \n    return prev2;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy \/ iRes.xy;\n    \n    \/\/ initialize\n    if (mod(float(iFrame), REDRAW_INTERVAL * 60.0) < 10.0) {\n        fragColor = INIT_VALUE;\n    } else {\n    \tfragColor = doMain(fragCoord, uv);\n    }\n}","name":"Buf B","description":"","type":"buffer"}]}];var gFollow = -1;
    var gUseScreenshots = piIsMobile();
    var gThemeName = "classic";
    </script>

</head>

<body onload="resultsInitStatic(8,null,null)">

<!-- header =================================================================================== -->


<div id="header">

    <div id="headerBlock1">
        <a href="/" id="headerTitle">Shadertoy</a>
        <form name="formSearch" action="/results" method="get" style="display:inline-block;">
        <div  id="headerSearch">
            <input type="search" id="mySearch" name="query" placeholder="Search..." value=""/>
        </div>
        </form>
    </div>

    <div id="headerBlock2">
            <a class="headerLinks" href="/browse">Browse</a>
        <a class="headerLinks" href="/new">New</a>
        <a class="headerLinks" href="/signin">Sign In</a>
        </div>
</div>
<!-- content ================================================================================== -->

<div id="content">

    
    <script>
    function follow()
    {
        if (gFollow < 0) return;
        try
        {
            var req = new XMLHttpRequest();
            req.onload = function()
            {
                var jsn = req.response;
                if( jsn==null ) return;
                let btnFollow = document.getElementById( "btnFollow");
                if (gFollow == 1) {
                    gFollow = 0;
                    btnFollow.value="Follow";
                } else if (gFollow == 0) {
                    gFollow = 1;
                    btnFollow.value="Unfollow";
                }
            }
            req.open( "POST", "/shadertoy", true );
            req.responseType = "json";
            req.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
            if (gFollow == 1) {
                var str = "fu=1&uid=emh";
            } else if (gFollow == 0) {
                var str = "fs=1&uid=emh";
            }
            req.send( str );
        }
        catch(e)
        {
            alert( "exception: " + e );
        }
    }
    </script>

    <!-- ---------------------------------- --> 

    <div id="divUser">
        <table style="border:0px;border-spacing:0px;border-collapse:collapse;"><tr>
        <td style="vertical-align:top;">
        <img id="userPicture" src="/img/profile.jpg"></img>        </td>
        <td style="vertical-align:top;padding-left:16px;">
        <b>Name</b>: emh <br/><b>Joined</b>: July 17, 2015 <br/> <br/><b>Shaders</b>: 21<br/><b>Playlists</b>: 0<br/><b>Comments</b>: 21<br/> <br/><b>Following</b>: 3<br/><b>Followers</b>: 6<br/>        </td>
        <td style="vertical-align:top;padding-left:32px;">
        <b>About</b><br><br>        </td>
        <td style="vertical-align:top;padding-left:32px;">
                    </td>
        </tr></table>
    </div>

<!-- --------------------------- -->

  <div id="controls">

    <div>
      <div style="text-align: center; vertical-align: middle; display: inline-block; padding-bottom:5px; padding-top:4px; margin-right:8px; margin-bottom:8px; margin-top:8px;">
      Sort:      </div>
      <div class="controlOptions"><div class="pageButtonsCurrent" href="/user/emh/sort=popular">Popular</div><a class="pageButtons" href="/user/emh/sort=newest">Newest</a><a class="pageButtons" href="/user/emh/sort=love">Love</a></div>
    </div>

    <div id="controlFilter">
      <div style="display:flex;margin-right:8px;align-items:center;">Filter:</div>
      <div class="controlOptions"> <a class="pageButtons" href="/user/emh&sort=popular&filter=multipass">Multipass</a><a class="pageButtons" href="/user/emh&sort=popular&filter=soundoutput">GPU Sound</a><a class="pageButtons" href="/user/emh&sort=popular&filter=vr">VR</a><a class="pageButtons" href="/user/emh&sort=popular&filter=soundinput">Microphone</a><a class="pageButtons" href="/user/emh&sort=popular&filter=musicstream">Soundcloud</a><a class="pageButtons" href="/user/emh&sort=popular&filter=webcam">Webcam</a></div>
    </div>

    <div>
        <div style="text-align: center; vertical-align: middle; display: inline-block; padding-bottom:5px; padding-top:4px; margin-right:8px; margin-bottom:8px; margin-top:8px;">
        Results (21):        </div>

        <div class="controlOptions">
              <div id="pageButton"0 class="pageButtonsCurrent" href="/user/emh/sort=popular&from=0&num=8">1</div><a id="pageButton"1 class="pageButtons" href="/user/emh/sort=popular&from=8&num=8">2</a><a id="pageButton"2 class="pageButtons" href="/user/emh/sort=popular&from=16&num=8">3</a>        </div>
    </div>
  </div>


  <div id="shaderGrid">
    <div class='searchResult'><div class='searchResultContainer' id='Preview_0_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_0_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_0_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_0_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_0_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_0_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_0_Thumnail'>        <img class='previewThumbnailImage' id='Preview_0_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_0_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_0_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_0_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_0_Info'>  <span class='previewText'  id='Preview_0_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_0_TextUser'></span>  <span class='previewStats' id='Preview_0_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_1_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_1_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_1_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_1_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_1_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_1_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_1_Thumnail'>        <img class='previewThumbnailImage' id='Preview_1_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_1_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_1_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_1_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_1_Info'>  <span class='previewText'  id='Preview_1_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_1_TextUser'></span>  <span class='previewStats' id='Preview_1_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_2_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_2_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_2_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_2_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_2_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_2_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_2_Thumnail'>        <img class='previewThumbnailImage' id='Preview_2_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_2_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_2_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_2_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_2_Info'>  <span class='previewText'  id='Preview_2_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_2_TextUser'></span>  <span class='previewStats' id='Preview_2_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_3_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_3_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_3_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_3_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_3_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_3_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_3_Thumnail'>        <img class='previewThumbnailImage' id='Preview_3_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_3_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_3_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_3_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_3_Info'>  <span class='previewText'  id='Preview_3_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_3_TextUser'></span>  <span class='previewStats' id='Preview_3_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_4_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_4_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_4_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_4_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_4_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_4_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_4_Thumnail'>        <img class='previewThumbnailImage' id='Preview_4_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_4_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_4_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_4_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_4_Info'>  <span class='previewText'  id='Preview_4_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_4_TextUser'></span>  <span class='previewStats' id='Preview_4_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_5_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_5_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_5_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_5_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_5_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_5_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_5_Thumnail'>        <img class='previewThumbnailImage' id='Preview_5_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_5_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_5_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_5_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_5_Info'>  <span class='previewText'  id='Preview_5_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_5_TextUser'></span>  <span class='previewStats' id='Preview_5_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_6_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_6_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_6_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_6_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_6_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_6_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_6_Thumnail'>        <img class='previewThumbnailImage' id='Preview_6_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_6_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_6_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_6_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_6_Info'>  <span class='previewText'  id='Preview_6_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_6_TextUser'></span>  <span class='previewStats' id='Preview_6_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_7_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_7_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_7_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_7_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_7_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_7_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_7_Thumnail'>        <img class='previewThumbnailImage' id='Preview_7_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_7_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_7_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_7_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_7_Info'>  <span class='previewText'  id='Preview_7_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_7_TextUser'></span>  <span class='previewStats' id='Preview_7_Stats'></span></div></div>  </div>
</div>

<!-- footer ================================================================================== -->

<div id="footer">
    
    <div><span style="color:#ffffff;">Community Forums</span>
      <ul>
      <li><a class="regular" href="/events">Official Events</a></li>
      <li><a class="regular" href="https://www.facebook.com/groups/147749602472741">In Facebook (english)</a></li>
      <li><a class="regular" href="https://www.facebook.com/groups/1339783682699494">In Facebook (korean)</a></li>
      <li><a class="regular" href="https://discord.gg/XtmMN6E">In Discord</a> (<a class="regular" href="https://discordapp.com/channels/578696555612209173/579531723348639754">direct link</a>)</li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Feedback and Support</span>
      <ul>
      <li><a class="regular" href="https://www.facebook.com/Shadertoy">Facebook</a></li>
      <li><a class="regular" href="https://twitter.com/shadertoy">Twitter</a></li>
      <li><a class="regular" href="https://www.patreon.com/shadertoy">Patreon</a></li>
      <li><a class="regular" href="https://trello.com/b/5hM0CjId">Roadmap</a></li>

      
      </ul>
    </div>

    <div><span style="color:#ffffff;">Shadertoy</span>
      <ul>
      <li><a class="regular" href="/store">Store</a></li>
      <li><a class="regular" href="/howto">Documentation</a></li>
      <li><a class="regular" href="/terms">Terms & Privacy</a></li>
      <li><a class="regular" href="/about">About</a></li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Apps and Plugins</span>
      <ul>
      <li><a class="regular" href="https://itunes.apple.com/us/app/shadertoy/id717961814">Official iPhone App</a> by <a class="user" href="/user/reinder">Reinder</a></li>
      <li><a class="regular" href="https://steamcommunity.com/sharedfiles/filedetails/?id=1726697188">Screensaver</a> by <a class="user" href="/user/kosro">Kosro</a></li>
      <li><a class="regular" href="https://chrome.google.com/webstore/detail/shadertoy-unofficial-plug/ohicbclhdmkhoabobgppffepcopomhgl">Shadertoy plugin</a> by <a class="user" href="/user/patu">Patu</a></li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Tutorials</span>
      <ul>
      <li><a class="regular" href="https://www.youtube.com/watch?v=0ifChJ0nJfM">Shader coding intro</a> by <a class="user" href="/user/iq">iq</a></li>
      <li><a class="regular" href="https://shadertoyunofficial.wordpress.com/">Shadertoy Unofficial</a> by <a class="user" href="/user/FabriceNeyret2">FabriceNeyret2</a></li>
      </ul>
    </div>

</div>

<div id="compliance" style="padding-bottom:6px;visibility:hidden;left:0;top:0px;width:100%;background-color:rgb(200,120,20,0.93);position:absolute;color:#FFFFFF">
    <div style="text-align: center; margin-top:8px">
        We use cookies to give you the best experience on our website. If you continue using Shadertoy, we'll assume that you are happy to receive all cookies on this website. 
        For more information, please review our <a class="regular" href="/terms">Terms & Privacy</a>.
    </div> 
    <div style="text-align: center;margin-top:6px">
        <button type="button" style="width:100px;font-size:inherit" onclick="acceptCompliance()">Accept</button>
    </div>
</div>

<script>
(function runCompliance() 
{
    let showCompliance = 1;
    let allcookies = document.cookie;
    let cookiearray = allcookies.split(';');
    for (var i=0; i<cookiearray.length; i++)
    {
        let name  = cookiearray[i].split('=')[0];
        let value = cookiearray[i].split('=')[1];
        if (name.trim() == "scmp") 
        {
            showCompliance = value;
            break;
        }
    }

    if (showCompliance === 1) 
    {
        var ve = document.getElementById("compliance");
        ve.style.visibility="visible";
    }
})();

function acceptCompliance()
{
    let now = new Date();
    now.setTime( now.getTime() + (5*365*24*60*60*1000) );
    document.cookie="scmp=0;expires=" + now.toUTCString() + ";";

    var ve = document.getElementById("compliance");
    ve.style.visibility="hidden";
}
</script>

<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-44068895-1', 'shadertoy.com');
    ga('send', 'pageview');
</script>
</body>
</html>
