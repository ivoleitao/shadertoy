[
    {
        "ver": "0.1",
        "info": {
            "id": "3lsSzf",
            "date": "1564012178",
            "viewed": 126422,
            "name": "Happy Jumping",
            "username": "iq",
            "description": "A happy and blobby creature jumping. It gets off-model very often, but it looks good enough. Making of and related math\/shader\/art explanations (6 hours long): [url]https:\/\/www.youtube.com\/watch?v=Cfe5UQ-1L9Q[\/url]. ",
            "likes": 773,
            "published": 3,
            "flags": 0,
            "usePreview": 0,
            "tags": []
        },
        "renderpass": [
            {
                "inputs": [],
                "outputs": [
                    {
                        "id": "4dfGRr",
                        "channel": 0
                    }
                ],
                "code": "\/\/ Copyright Inigo Quilez, 2019 - https:\/\/iquilezles.org\/\n\/\/ I am the sole copyright owner of this Work.\n\/\/ You cannot host, display, distribute or share this Work in any form,\n\/\/ including physical and digital. You cannot use this Work in any\n\/\/ commercial or non-commercial product, website or project. You cannot\n\/\/ sell this Work and you cannot mint an NFTs of it.\n\/\/ I share this Work for educational purposes, and you can link to it,\n\/\/ through an URL, proper attribution and unmodified screenshot, as part\n\/\/ of your educational material. If these conditions are too restrictive\n\/\/ please contact me and we'll definitely work it out.\n\n\n\/\/ An animation test - a happy and blobby creature\n\/\/ jumping and looking around. It gets off-model very\n\/\/ often, but it looks good enough I think.\n\/\/\n\/\/ Making-of with math\/shader\/art explanations (6 hours\n\/\/ long): https:\/\/www.youtube.com\/watch?v=Cfe5UQ-1L9Q\n\/\/\n\/\/ Buy a metal print here: https:\/\/www.redbubble.com\/i\/metal-print\/Happy-Jumping-by-InigoQuilez\/43594745.0JXQP\n\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2  \/\/ Set AA to 1 if your machine is too slow\n#endif\n\n\n\/\/------------------------------------------------------------------\n\n\n\/\/ https:\/\/iquilezles.org\/articles\/smin\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25\/k;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/smin\nvec2 smin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)\/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/smin\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25\/k;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \/\/ approximated\n{\n    float k0 = length(p\/r);\n    float k1 = length(p\/(r*r));\n    return k0*(k0-1.0)\/k1;\n}\n\nvec2 sdStick(vec3 p, vec3 a, vec3 b, float r1, float r2) \/\/ approximated\n{\n    vec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ) - mix(r1,r2,h*h*(3.0-2.0*h)), h );\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/smin\nvec4 opU( vec4 d1, vec4 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n\/\/------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n\/\/------------------------------------------------------------------\n\nfloat href;\nfloat hsha;\n\nvec4 map( in vec3 pos, float atime )\n{\n    hsha = 1.0;\n    \n    float t1 = fract(atime);\n    float t4 = abs(fract(atime*0.5)-0.5)\/0.5;\n\n    float p = 4.0*t1*(1.0-t1);\n    float pp = 4.0*(1.0-2.0*t1); \/\/ derivative of p\n\n    vec3 cen = vec3( 0.5*(-1.0 + 2.0*t4),\n                     pow(p,2.0-p) + 0.1,\n                     floor(atime) + pow(t1,0.7) -1.0 );\n\n    \/\/ body\n    vec2 uu = normalize(vec2( 1.0, -pp ));\n    vec2 vv = vec2(-uu.y, uu.x);\n    \n    float sy = 0.5 + 0.5*p;\n    float compress = 1.0-smoothstep(0.0,0.4,p);\n    sy = sy*(1.0-compress) + compress;\n    float sz = 1.0\/sy;\n\n    vec3 q = pos - cen;\n    float rot = -0.25*(-1.0 + 2.0*t4);\n    float rc = cos(rot);\n    float rs = sin(rot);\n    q.xy = mat2x2(rc,rs,-rs,rc)*q.xy;\n    vec3 r = q;\n\thref = q.y;\n    q.yz = vec2( dot(uu,q.yz), dot(vv,q.yz) );\n    \n    float deli = sdEllipsoid( q, vec3(0.25, 0.25*sy, 0.25*sz) );\n    vec4 res = vec4( deli, 2.0, 0.0, 1.0 );\n\n    \/\/ ground\n    float fh = -0.1 - 0.05*(sin(pos.x*2.0)+sin(pos.z*2.0));\n    float t5f = fract(atime+0.05);\n    float t5i = floor(atime+0.05); \n    float bt4 = abs(fract(t5i*0.5)-0.5)\/0.5;\n    vec2  bcen = vec2( 0.5*(-1.0+2.0*bt4),t5i+pow(t5f,0.7)-1.0 );\n    \n    float k = length(pos.xz-bcen);\n    float tt = t5f*15.0-6.2831 - k*3.0;\n    fh -= 0.1*exp(-k*k)*sin(tt)*exp(-max(tt,0.0)\/2.0)*smoothstep(0.0,0.01,t5f);\n    float d = pos.y - fh;\n    \n    \/\/ bubbles\n    {\n    vec3 vp = vec3( mod(abs(pos.x),3.0)-1.5,pos.y,mod(pos.z+1.5,3.0)-1.5);\n    vec2 id = vec2( floor(pos.x\/3.0), floor((pos.z+1.5)\/3.0) );\n    float fid = id.x*11.1 + id.y*31.7;\n    float fy = fract(fid*1.312+atime*0.1);\n    float y = -1.0+4.0*fy;\n    vec3  rad = vec3(0.7,1.0+0.5*sin(fid),0.7);\n    rad -= 0.1*(sin(pos.x*3.0)+sin(pos.y*4.0)+sin(pos.z*5.0));    \n    float siz = 4.0*fy*(1.0-fy);\n    float d2 = sdEllipsoid( vp-vec3(0.5,y,0.0), siz*rad );\n    \n    d2 -= 0.03*smoothstep(-1.0,1.0,sin(18.0*pos.x)+sin(18.0*pos.y)+sin(18.0*pos.z));\n    d2 *= 0.6;\n    d2 = min(d2,2.0);\n    d = smin( d, d2, 0.32 );\n    if( d<res.x ) { res = vec4(d,1.0,0.0,1.0); hsha=sqrt(siz); }\n    }\n\n    \/\/ rest of body\n    if( deli-1.0 < res.x ) \/\/ bounding volume\n\t{\n    float t2 = fract(atime+0.8);\n    float p2 = 0.5-0.5*cos(6.2831*t2);\n    r.z += 0.05-0.2*p2;\n    r.y += 0.2*sy-0.2;\n    vec3 sq = vec3( abs(r.x), r.yz );\n\n\t\/\/ head\n    vec3 h = r;\n    float hr = sin(0.791*atime);\n    hr = 0.7*sign(hr)*smoothstep(0.5,0.7,abs(hr));\n    h.xz = mat2x2(cos(hr),sin(hr),-sin(hr),cos(hr))*h.xz;\n    vec3 hq = vec3( abs(h.x), h.yz );\n   \tfloat d  = sdEllipsoid( h-vec3(0.0,0.20,0.02), vec3(0.08,0.2,0.15) );\n\tfloat d2 = sdEllipsoid( h-vec3(0.0,0.21,-0.1), vec3(0.20,0.2,0.20) );\n\td = smin( d, d2, 0.1 );\n    res.x = smin( res.x, d, 0.1 );\n    \n    \/\/ belly wrinkles\n    {\n    float yy = r.y-0.02-2.5*r.x*r.x;\n    res.x += 0.001*sin(yy*120.0)*(1.0-smoothstep(0.0,0.1,abs(yy)));\n    }\n        \n    \/\/ arms\n    {\n    vec2 arms = sdStick( sq, vec3(0.18-0.06*hr*sign(r.x),0.2,-0.05), vec3(0.3+0.1*p2,-0.2+0.3*p2,-0.15), 0.03, 0.06 );\n    res.xz = smin( res.xz, arms, 0.01+0.04*(1.0-arms.y)*(1.0-arms.y)*(1.0-arms.y) );\n    }\n        \n    \/\/ ears\n    {\n    float t3 = fract(atime+0.9);\n    float p3 = 4.0*t3*(1.0-t3);\n    vec2 ear = sdStick( hq, vec3(0.15,0.32,-0.05), vec3(0.2+0.05*p3,0.2+0.2*p3,-0.07), 0.01, 0.04 );\n    res.xz = smin( res.xz, ear, 0.01 );\n    }\n    \n    \/\/ mouth\n    {\n   \td = sdEllipsoid( h-vec3(0.0,0.15+4.0*hq.x*hq.x,0.15), vec3(0.1,0.04,0.2) );\n    res.w = 0.3+0.7*clamp( d*150.0,0.0,1.0);\n    res.x = smax( res.x, -d, 0.03 );\n    }\n\n\t\/\/ legs\n    {\n    float t6 = cos(6.2831*(atime*0.5+0.25));\n    float ccc = cos(1.57*t6*sign(r.x));\n    float sss = sin(1.57*t6*sign(r.x));\n\tvec3 base = vec3(0.12,-0.07,-0.1); base.y -= 0.1\/sy;\n    vec2 legs = sdStick( sq, base, base + vec3(0.2,-ccc,sss)*0.2, 0.04, 0.07 );\n    res.xz = smin( res.xz, legs, 0.07 );\n    }\n        \n    \/\/ eye\n    {\n    float blink = pow(0.5+0.5*sin(2.1*iTime),20.0);\n    float eyeball = sdSphere(hq-vec3(0.08,0.27,0.06),0.065+0.02*blink);\n    res.x = smin( res.x, eyeball, 0.03 );\n    \n    vec3 cq = hq-vec3(0.1,0.34,0.08);\n    cq.xy = mat2x2(0.8,0.6,-0.6,0.8)*cq.xy;\n    d = sdEllipsoid( cq, vec3(0.06,0.03,0.03) );\n    res.x = smin( res.x, d, 0.03 );\n\n    float eo = 1.0-0.5*smoothstep(0.01,0.04,length((hq.xy-vec2(0.095,0.285))*vec2(1.0,1.1)));\n    res = opU( res, vec4(sdSphere(hq-vec3(0.08,0.28,0.08),0.060),3.0,0.0,eo));\n    res = opU( res, vec4(sdSphere(hq-vec3(0.075,0.28,0.102),0.0395),4.0,0.0,1.0));\n    }\n\t}\n\n    \/\/ candy\n    if( pos.y-1.0 < res.x ) \/\/ bounding volume\n    {\n    float fs = 5.0;\n    vec3 qos = fs*vec3(pos.x, pos.y-fh, pos.z );\n    vec2 id = vec2( floor(qos.x+0.5), floor(qos.z+0.5) );\n    vec3 vp = vec3( fract(qos.x+0.5)-0.5,qos.y,fract(qos.z+0.5)-0.5);\n    vp.xz += 0.1*cos( id.x*130.143 + id.y*120.372 + vec2(0.0,2.0) );\n    float den = sin(id.x*0.1+sin(id.y*0.091))+sin(id.y*0.1);\n    float fid = id.x*0.143 + id.y*0.372;\n    float ra = smoothstep(0.0,0.1,den*0.1+fract(fid)-0.95);\n    d = sdSphere( vp, 0.35*ra )\/fs;\n    if( d<res.x ) res = vec4(d,5.0,qos.y,1.0);\n    }\n    \n    return res;\n}\n\nvec4 raycast( in vec3 ro, in vec3 rd, float time )\n{\n    vec4 res = vec4(-1.0,-1.0,0.0,1.0);\n\n    float tmin = 0.5;\n    float tmax = 20.0;\n    \n\t#if 1\n    \/\/ raytrace bounding plane\n    float tp = (3.4-ro.y)\/rd.y;\n    if( tp>0.0 ) tmax = min( tmax, tp );\n\t#endif    \n    \n    \/\/ raymarch scene\n    float t = tmin;\n    for( int i=0; i<256 && t<tmax; i++ )\n    {\n        vec4 h = map( ro+rd*t, time );\n        if( abs(h.x)<(0.0005*t) )\n        { \n            res = vec4(t,h.yzw); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float time )\n{\n    float res = 1.0;\n\n    float tmax = 12.0;\n    #if 1\n    float tp = (3.4-ro.y)\/rd.y; \/\/ raytrace bounding plane\n    if( tp>0.0 ) tmax = min( tmax, tp );\n\t#endif    \n    \n    float t = 0.02;\n    for( int i=0; i<50; i++ )\n    {\n\t\tfloat h = map( ro + rd*t, time ).x;\n        res = min( res, mix(1.0,16.0*h\/t, hsha) );\n        t += clamp( h, 0.05, 0.40 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/normalsSDF\nvec3 calcNormal( in vec3 pos, float time )\n{\n    \n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.001;\n    return normalize( e.xyy*map( pos + e.xyy, time ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, time ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, time ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, time ).x );\n#else\n    \/\/ inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.001*e,time).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor, float time )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.11*float(i)\/4.0;\n        vec3 opos = pos + h*nor;\n        float d = map( opos, time ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 render( in vec3 ro, in vec3 rd, float time )\n{ \n    \/\/ sky dome\n    vec3 col = vec3(0.5, 0.8, 0.9) - max(rd.y,0.0)*0.5;\n    \/\/ sky clouds\n    vec2 uv = 1.5*rd.xz\/rd.y;\n    float cl  = 1.0*(sin(uv.x)+sin(uv.y)); uv *= mat2(0.8,0.6,-0.6,0.8)*2.1;\n          cl += 0.5*(sin(uv.x)+sin(uv.y));\n    col += 0.1*(-1.0+2.0*smoothstep(-0.1,0.1,cl-0.4));\n    \/\/ sky horizon\n\tcol = mix( col, vec3(0.5, 0.7, .9), exp(-10.0*max(rd.y,0.0)) );    \n\n    \/\/ scene geometry\n    vec4 res = raycast(ro,rd, time);\n    if( res.y>-0.5 )\n    {\n        float t = res.x;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, time );\n        vec3 ref = reflect( rd, nor );\n        float focc = res.w;\n        \n        \/\/ material        \n\t\tcol = vec3(0.2);\n        float ks = 1.0;\n\n        if( res.y>4.5 )  \/\/ candy\n        { \n             col = vec3(0.14,0.048,0.0); \n             vec2 id = floor(5.0*pos.xz+0.5);\n\t\t     col += 0.036*cos((id.x*11.1+id.y*37.341) + vec3(0.0,1.0,2.0) );\n             col = max(col,0.0);\n             focc = clamp(4.0*res.z,0.0,1.0);\n        }\n        else if( res.y>3.5 ) \/\/ eyeball\n        { \n            col = vec3(0.0);\n        } \n        else if( res.y>2.5 ) \/\/ iris\n        { \n            col = vec3(0.4);\n        } \n        else if( res.y>1.5 ) \/\/ body\n        { \n            col = mix(vec3(0.144,0.09,0.0036),vec3(0.36,0.1,0.04),res.z*res.z);\n            col = mix(col,vec3(0.14,0.09,0.06)*2.0, (1.0-res.z)*smoothstep(-0.15, 0.15, -href));\n        }\n\t\telse \/\/ terrain\n        {\n            \/\/ base green            \n            col = vec3(0.05,0.09,0.02);\n            float f = 0.2*(-1.0+2.0*smoothstep(-0.2,0.2,sin(18.0*pos.x)+sin(18.0*pos.y)+sin(18.0*pos.z)));\n            col += f*vec3(0.06,0.06,0.02);\n            ks = 0.5 + pos.y*0.15;\n            \n\t\t\t\/\/ footprints            \n            vec2 mp = vec2(pos.x-0.5*(mod(floor(pos.z+0.5),2.0)*2.0-1.0), fract(pos.z+0.5)-0.5 );\n            float mark = 1.0-smoothstep(0.1, 0.5, length(mp));\n            mark *= smoothstep(0.0, 0.1, floor(time) - floor(pos.z+0.5) );\n            col *= mix( vec3(1.0), vec3(0.5,0.5,0.4), mark );\n            ks *= 1.0-0.5*mark;\n        }\n        \n        \/\/ lighting (sun, sky, bounce, back, sss)\n        float occ = calcOcclusion( pos, nor, time )*focc;\n        float fre = clamp(1.0+dot(nor,rd),0.0,1.0);\n        \n        vec3  sun_lig = normalize( vec3(0.6, 0.35, 0.5) );\n        float sun_dif = clamp(dot( nor, sun_lig ), 0.0, 1.0 );\n        vec3  sun_hal = normalize( sun_lig-rd );\n        float sun_sha = calcSoftshadow( pos, sun_lig, time );\n\t\tfloat sun_spe = ks*pow(clamp(dot(nor,sun_hal),0.0,1.0),8.0)*sun_dif*(0.04+0.96*pow(clamp(1.0+dot(sun_hal,rd),0.0,1.0),5.0));\n\t\tfloat sky_dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n        float sky_spe = ks*smoothstep( 0.0, 0.5, ref.y )*(0.04+0.96*pow(fre,4.0));\n        float bou_dif = sqrt(clamp( 0.1-0.9*nor.y, 0.0, 1.0 ))*clamp(1.0-0.1*pos.y,0.0,1.0);\n        float bac_dif = clamp(0.1+0.9*dot( nor, normalize(vec3(-sun_lig.x,0.0,-sun_lig.z))), 0.0, 1.0 );\n        float sss_dif = fre*sky_dif*(0.25+0.75*sun_dif*sun_sha);\n\n\t\tvec3 lin = vec3(0.0);\n        lin += sun_dif*vec3(8.10,6.00,4.20)*vec3(sun_sha,sun_sha*sun_sha*0.5+0.5*sun_sha,sun_sha*sun_sha);\n        lin += sky_dif*vec3(0.50,0.70,1.00)*occ;\n        lin += bou_dif*vec3(0.20,0.70,0.10)*occ;\n        lin += bac_dif*vec3(0.45,0.35,0.25)*occ;\n        lin += sss_dif*vec3(3.25,2.75,2.50)*occ;\n\t\tcol = col*lin;\n\t\tcol += sun_spe*vec3(9.90,8.10,6.30)*sun_sha;\n        col += sky_spe*vec3(0.20,0.30,0.65)*occ*occ;\n      \t\n        col = pow(col,vec3(0.8,0.9,1.0) );\n        \n        \/\/ fog\n        col = mix( col, vec3(0.5,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n    }\n\n    return col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        \/\/ pixel coordinates\n        vec2 o = vec2(float(m),float(n)) \/ float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))\/iResolution.y;\n        \/\/ time coordinate (motion blurred, shutter=0.5)\n        \/\/ see https:\/\/www.shadertoy.com\/view\/4sBGD1\n        float d = 0.5+0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n        float time = iTime - 0.5*(1.0\/24.0)*(float(m*AA+n)+d)\/float(AA*AA);\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)\/iResolution.y;\n        float time = iTime;\n#endif\n        time += -2.6;\n        time *= 0.9;\n        \n        \/\/ camera\t\n        float cl = sin(0.5*time);\n        float an = 1.57 + 0.7*sin(0.15*time);\n        vec3  ta = vec3( 0.0, 0.65, -0.6+time*1.0 - 0.4*cl);\n        vec3  ro = ta + vec3( 1.3*cos(an), -0.250, 1.3*sin(an) );\n        float ti = fract(time-0.15);\n        ti = 4.0*ti*(1.0-ti);        \n        ta.y += 0.15*ti*ti*(3.0-2.0*ti)*smoothstep(0.4,0.9,cl);\n        \n        \/\/ camera bounce\n        float t4 = abs(fract(time*0.5)-0.5)\/0.5;\n        float bou = -1.0 + 2.0*t4;\n        ro += 0.06*sin(time*12.0+vec3(0.0,2.0,4.0))*smoothstep( 0.85, 1.0, abs(bou) );\n\n        \/\/ camera-to-world rotation\n        mat3 ca = setCamera( ro, ta, 0.0 );\n\n        \/\/ ray direction\n        vec3 rd = ca * normalize( vec3(p,1.8) );\n        \n        \/\/ render\t\n        vec3 col = render( ro, rd, time );\n\n        \/\/ color grading\n        col = col*vec3(1.11,0.89,0.79);\n\n        \/\/ compress        \n        col = 1.35*col\/(1.0+col);\n        \n        \/\/ gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot \/= float(AA*AA);\n#endif\n\n    \/\/ s-surve    \n    tot = clamp(tot,0.0,1.0);\n    tot = tot*tot*(3.0-2.0*tot);\n\n    \/\/ vignetting        \n    vec2 q = fragCoord\/iResolution.xy;\n    tot *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.25);\n\n    \/\/ output    \n    fragColor = vec4( tot, 1.0 );\n}",
                "name": "Image",
                "description": "",
                "type": "image"
            }
        ]
    },
    {
        "ver": "0.1",
        "info": {
            "id": "WsSBzh",
            "date": "1606524984",
            "viewed": 124752,
            "name": "Selfie Girl",
            "username": "iq",
            "description": "A raymarched procedural SDF - a girl taking a selfie, this time. Making of video here: [url]https:\/\/www.youtube.com\/watch?v=8--5LwHRhjk[\/url]",
            "likes": 495,
            "published": 3,
            "flags": 32,
            "usePreview": 1,
            "tags": []
        },
        "renderpass": [
            {
                "inputs": [
                    {
                        "id": "4sf3Rn",
                        "filepath": "\/media\/a\/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png",
                        "previewfilepath": "\/media\/ap\/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png",
                        "type": "texture",
                        "channel": 2,
                        "sampler": {
                            "filter": "mipmap",
                            "wrap": "repeat",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    },
                    {
                        "id": "Xsf3zn",
                        "filepath": "\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
                        "previewfilepath": "\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
                        "type": "texture",
                        "channel": 3,
                        "sampler": {
                            "filter": "mipmap",
                            "wrap": "repeat",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    },
                    {
                        "id": "4sfGRr",
                        "filepath": "\/media\/a\/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin",
                        "previewfilepath": "\/media\/ap\/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin",
                        "type": "volume",
                        "channel": 0,
                        "sampler": {
                            "filter": "mipmap",
                            "wrap": "repeat",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    },
                    {
                        "id": "XsXGR8",
                        "filepath": "\/media\/previz\/buffer01.png",
                        "previewfilepath": "\/media\/previz\/buffer01.png",
                        "type": "buffer",
                        "channel": 1,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "4dfGRr",
                        "channel": 0
                    }
                ],
                "code": "\/\/ Copyright Inigo Quilez, 2020 - https:\/\/iquilezles.org\/\n\/\/ I am the sole copyright owner of this Work.\n\/\/ You cannot host, display, distribute or share this Work in any form,\n\/\/ including physical and digital. You cannot use this Work in any\n\/\/ commercial or non-commercial product, website or project. You cannot\n\/\/ sell this Work and you cannot mint an NFTs of it.\n\/\/ I share this Work for educational purposes, and you can link to it,\n\/\/ through an URL, proper attribution and unmodified screenshot, as part\n\/\/ of your educational material. If these conditions are too restrictive\n\/\/ please contact me and we'll definitely work it out.\n\n\n\/\/ Source code of the mathematical painting \"Selfie Girl\".\n\/\/ Making-of video on Youtube:\n\/\/\n\/\/ https:\/\/www.youtube.com\/watch?v=8--5LwHRhjk\n\n\/\/ The image is a single formula, but I had to split it\n\/\/ down into 3 passes here so it could be shared without\n\/\/ breaking the WebGL implementation of the web browsers\n\/\/ (which is what Shadertoy uses to run the code below\n\/\/ that implements the formula).\n\n\/\/ This \"Image\" tab in particular renders the girl through\n\/\/ raymarching and then performs the final composition with\n\/\/ the background, which is computed in \"Buffer B\" (open\n\/\/ the rest of the tabs to see explanations of what each\n\/\/ one does). For the rendering\/computer graphics people - \n\/\/ there's no TAA in this pass because I didn't want to\n\/\/ compute velocity vectors for the animation, so things\n\/\/ alias a bit (feel free to change the AA define below to\n\/\/ 2 if you have a fast GPU)\n\n#define AA 1\n\n\n\/\/ This SDF is really 6 braids at once (through domain\n\/\/ repetition) with three strands each (brute forced)\nvec4 sdHair( vec3 p, vec3 pa, vec3 pb, vec3 pc, float an, out vec2 occ_id) \n{\n    vec4 b = sdBezier(p, pa,pb,pc );\n    vec2 q = rot(b.zw,an);\n  \t\n    vec2 id2 = round(q\/0.1);\n    id2 = clamp(id2,vec2(0),vec2(2,1));\n    q -= 0.1*id2;\n\n    float id = 11.0*id2.x + id2.y*13.0;\n\n    q += smoothstep(0.5,0.8,b.y)*0.02*vec2(0.4,1.5)*cos( 23.0*b.y + id*vec2(13,17));\n\n    occ_id.x = clamp(length(q)*8.0-0.2,0.0,1.0);\n    vec4 res = vec4(99,q,b.y);\n    for( int i=0; i<3; i++ )\n    {\n        vec2 tmp = q + 0.01*cos( id + 180.0*b.y + vec2(2*i,6-2*i));\n        float lt = length(tmp)-0.02;\n        if( lt<res.x )\n        { \n            occ_id.y = id+float(i); \n            res.x = lt; \n            res.yz = tmp;\n        }\n    }\n    return res;\n}\n\n\/\/ The SDF for the hoodie and jacket. It's a very distorted\n\/\/ ellipsoid, torus section, a segment and a sphere.\nvec4 sdHoodie( in vec3 pos )\n{\n    vec3 opos = pos;\n\n    pos.x   += 0.09*sin(3.5*pos.y-0.5)*sin(    pos.z) + 0.015;\n    pos.xyz += 0.03*sin(2.0*pos.y)*sin(7.0*pos.zyx);\n    \n    \/\/ hoodie\n    vec3 hos = pos-vec3(0.0,-0.33,0.15);\n    hos.x -= 0.031*smoothstep(0.0,1.0,opos.y+0.33);\n    hos.yz = rot(hos.yz,0.9);\n    float d1 = sdEllipsoid(hos,vec3(0.96-pos.y*0.1,1.23,1.5));\n\tfloat d2 = 0.95*pos.z-0.312*pos.y-0.9;\n    float d = max(opOnion(d1,0.01), d2 );\n    \n    \/\/ shoulders\n    vec3 sos = vec3( abs(pos.x), pos.yz );    \n    vec2 se = sdSegment(sos, vec3(0.18,-1.6,-0.3), vec3(1.1,-1.9,0.0) );\n    d = smin(d,se.x-mix(0.25,0.43,se.y),0.4);\n    d = smin(d,sdSphere(sos-vec3(0.3,-2.2,0.4), 0.5 ),0.2);\n\n    \/\/ neck\n    opos.x -= 0.02*sin(9.0*opos.y);\n    vec4 w = opElongate( opos-vec3(0.0,-1.2,0.3), vec3(0.0,0.3,0.0) );\n    d = smin(d,\n             w.w+sdCappedTorus(vec3(w.xy,-w.z),vec2(0.6,-0.8),0.6,0.02),\n             0.1);\n    \n    \/\/ bumps\n    d += 0.004*sin(pos.x*90.0)*sin(pos.y*90.0)*sin(pos.z*90.0);\n    d -= 0.002*sin(pos.x*300.0);\n    d -= 0.02*(1.0-smoothstep(0.0,0.04,abs(opOnion(pos.x,1.1))));\n    \n    \/\/ border\n    d = min(d,length(vec2(d1,d2))-0.015);\n    \n    return vec4(d,pos);\n}\n\n\/\/ moves the head (and hair and hoodie). This could be done\n\/\/ more efficiently (with a single matrix or quaternion),\n\/\/ but this code was optimized for editing, not for runtime\nvec3 moveHead( in vec3 pos, in vec3 an, in float amount)\n{\n    pos.y -= -1.0;\n    pos.xz = rot(pos.xz,amount*an.x);\n    pos.xy = rot(pos.xy,amount*an.y);\n    pos.yz = rot(pos.yz,amount*an.z);\n    pos.y += -1.0;\n    return pos;\n}\n\n\/\/ the animation state\nvec3 animData; \/\/ { blink, nose follow up, mouth } \nvec3 animHead; \/\/ { head rotation angles }\n\n\/\/ SDF of the girl. It is not as efficient as it should, \n\/\/ both in terms of performance and euclideanness of the\n\/\/ returned distance. Among other things I tweaked the\n\/\/ overal shape of the head though scaling right in the\n\/\/ middle of the design process (see 1.02 and 1.04 numbers\n\/\/ below). I should have backpropagated those adjustements\n\/\/ to the  primitives themselves, but I didn't and now it's\n\/\/ too late. So, I am paying some cost there.\n\/\/\n\/\/ She is modeled to camera (her face's shape looks bad\n\/\/ from other perspectives. She's made of five ellipsoids\n\/\/ blended together for the face, a cone and three spheres\n\/\/ for the nose, a torus for the teeh and two quadratic \n\/\/ curves for the lips. The neck is a cylinder, the hair\n\/\/ is made of three quadratic curves that are repeated\n\/\/ multiple times through domain repetition and each of\n\/\/ them contains three more curves in order to make the\n\/\/ braids. The hoodie is an ellipsoid deformed with\n\/\/ two sine waves and cut in half, the neck is an elongated\n\/\/ torus section and the shoulders are capsules.\n\/\/\nvec4 map( in vec3 pos, in float time, out float outMat, out vec3 uvw )\n{\n    outMat = 1.0;\n\n    vec3 oriPos = pos;\n    \n    \/\/ head deformation and transformation\n    pos.y \/= 1.04;\n    vec3 opos;\n    opos = moveHead( pos, animHead, smoothstep(-1.2, 0.2,pos.y) );\n    pos  = moveHead( pos, animHead, smoothstep(-1.4,-1.0,pos.y) );\n    pos.x *= 1.04;\n    pos.y \/= 1.02;\n    uvw = pos;\n\n    \/\/ symmetric coord systems (sharp, and smooth)\n    vec3 qos = vec3(abs(pos.x),pos.yz);\n    vec3 sos = vec3(sqrt(qos.x*qos.x+0.0005),pos.yz);\n    \n    \/\/ head\n    float d = sdEllipsoid( pos-vec3(0.0,0.05,0.07), vec3(0.8,0.75,0.85) );\n    \n    \/\/ jaw\n    vec3 mos = pos-vec3(0.0,-0.38,0.35); mos.yz = rot(mos.yz,0.4);\n\tmos.yz = rot(mos.yz,0.1*animData.z);\n\tfloat d2 = sdEllipsoid(mos-vec3(0,-0.17,0.16),\n                 vec3(0.66+sclamp(mos.y*0.9-0.1*mos.z,-0.3,0.4),\n                 \t  0.43+sclamp(mos.y*0.5,-0.5,0.2),\n                      0.50+sclamp(mos.y*0.3,-0.45,0.5)));\n        \n    \/\/ mouth hole\n    d2 = smax(d2,-sdEllipsoid(mos-vec3(0,0.06,0.6+0.05*animData.z), vec3(0.16,0.035+0.05*animData.z,0.1)),0.01);\n    \n    \/\/ lower lip    \n    vec4 b = sdBezier(vec3(abs(mos.x),mos.yz), \n                      vec3(0,0.01,0.61),\n                      vec3(0.094+0.01*animData.z,0.015,0.61),\n                      vec3(0.18-0.02*animData.z,0.06+animData.z*0.05,0.57-0.006*animData.z));\n    float isLip = smoothstep(0.045,0.04,b.x+b.y*0.03);\n    d2 = smin(d2,b.x - 0.027*(1.0-b.y*b.y)*smoothstep(1.0,0.4,b.y),0.02);\n    d = smin(d,d2,0.19);\n\n    \/\/ chicks\n    d = smin(d,sdSphere(qos-vec3(0.2,-0.33,0.62),0.28 ),0.04);\n    \n    \/\/ who needs ears\n    \n    \/\/ eye sockets\n    vec3 eos = sos-vec3(0.3,-0.04,0.7);\n    eos.xz = rot(eos.xz,-0.2);\n    eos.xy = rot(eos.xy,0.3);\n    eos.yz = rot(eos.yz,-0.2);\n    d2 = sdEllipsoid( eos-vec3(-0.05,-0.05,0.2), vec3(0.20,0.14-0.06*animData.x,0.1) );\n\td = smax( d, -d2, 0.15 );\n\n    eos = sos-vec3(0.32,-0.08,0.8);\n    eos.xz = rot(eos.xz,-0.4);\n    d2 = sdEllipsoid( eos, vec3(0.154,0.11,0.1) );\n    d = smax( d, -d2, 0.05 );\n\n    vec3 oos = qos - vec3(0.25,-0.06,0.42);\n    \n    \/\/ eyelid\n    d2 = sdSphere( oos, 0.4 );\n    oos.xz = rot(oos.xz, -0.2);\n    oos.xy = rot(oos.xy, 0.2);\n    vec3 tos = oos;        \n    oos.yz = rot(oos.yz,-0.6+0.58*animData.x);\n\n    \/\/eyebags\n    tos = tos-vec3(-0.02,0.06,0.2+0.02*animData.x);\n    tos.yz = rot(tos.yz,0.8);\n    tos.xy = rot(tos.xy,-0.2);\n\td = smin( d, sdTorus(tos,0.29,0.01), 0.03 );\n    \n    \/\/ eyelids\n    eos = qos - vec3(0.33,-0.07,0.53);\n    eos.xy = rot(eos.xy, 0.2);\n    eos.yz = rot(eos.yz,0.35-0.25*animData.x);\n    d2 = smax(d2-0.005, -max(oos.y+0.098,-eos.y-0.025), 0.02 );\n    d = smin( d, d2, 0.012 );\n\n\t\/\/ eyelashes\n\toos.x -= 0.01;\n    float xx = clamp( oos.x+0.17,0.0,1.0);\n    float ra = 0.35 + 0.1*sqrt(xx\/0.2)*(1.0-smoothstep(0.3,0.4,xx))*(0.6+0.4*sin(xx*256.0));\n    float rc = 0.18\/(1.0-0.7*smoothstep(0.15,0.5,animData.x));\n    oos.y -= -0.18 - (rc-0.18)\/1.8;\n    d2 = (1.0\/1.8)*sdArc( oos.xy*vec2(1.0,1.8), vec2(0.9,sqrt(1.0-0.9*0.9)), rc )-0.001;\n    float deyelashes = max(d2,length(oos.xz)-ra)-0.003;\n    \n    \/\/ nose\n    eos = pos-vec3(0.0,-0.079+animData.y*0.005,0.86);\n    eos.yz = rot(eos.yz,-0.23);\n    float h = smoothstep(0.0,0.26,-eos.y);\n    d2 = sdCone( eos-vec3(0.0,-0.02,0.0), vec2(0.03,-0.25) )-0.04*h-0.01;\n    eos.x = sqrt(eos.x*eos.x + 0.001);\n    d2 = smin( d2, sdSphere(eos-vec3(0.0, -0.25,0.037),0.06 ), 0.07 );\n    d2 = smin( d2, sdSphere(eos-vec3(0.1, -0.27,0.03 ),0.04 ), 0.07 );\n    d2 = smin( d2, sdSphere(eos-vec3(0.0, -0.32,0.05 ),0.025), 0.04 );        \n    d2 = smax( d2,-sdSphere(eos-vec3(0.07,-0.31,0.038),0.02 ), 0.035 );\n    d = smin(d,d2,0.05-0.03*h);\n    \n    \/\/ mouth\n    eos = pos-vec3(0.0,-0.38+animData.y*0.003+0.01*animData.z,0.71);\n    tos = eos-vec3(0.0,-0.13,0.06);\n    tos.yz = rot(tos.yz,0.2);\n    float dTeeth = sdTorus(tos,0.15,0.015);\n    eos.yz = rot(eos.yz,-0.5);\n    eos.x \/= 1.04;\n\n    \/\/ nose-to-upperlip connection\n    d2 = sdCone( eos-vec3(0,0,0.03), vec2(0.14,-0.2) )-0.03;\n    d2 = max(d2,-(eos.z-0.03));\n    d = smin(d,d2,0.05);\n\n    \/\/ upper lip\n    eos.x = abs(eos.x);\n    b = sdBezier(eos, vec3(0.00,-0.22,0.17),\n                      vec3(0.08,-0.22,0.17),\n                      vec3(0.17-0.02*animData.z,-0.24-0.01*animData.z,0.08));\n    d2 = length(b.zw\/vec2(0.5,1.0)) - 0.03*clamp(1.0-b.y*b.y,0.0,1.0);\n    d = smin(d,d2,0.02);\n    isLip = max(isLip,(smoothstep(0.03,0.005,abs(b.z+0.015+abs(eos.x)*0.04))\n                 -smoothstep(0.45,0.47,eos.x-eos.y*1.15)));\n\n    \/\/ valley under nose\n    vec2 se = sdSegment(pos, vec3(0.0,-0.45,1.01),  vec3(0.0,-0.47,1.09) );\n    d2 = se.x-0.03-0.06*se.y;\n    d = smax(d,-d2,0.04);\n    isLip *= smoothstep(0.01,0.03,d2);\n\n    \/\/ neck\n    se = sdSegment(pos, vec3(0.0,-0.65,0.0), vec3(0.0,-1.7,-0.1) );\n    d2 = se.x - 0.38;\n\n    \/\/ shoulders\n    se = sdSegment(sos, vec3(0.0,-1.55,0.0), vec3(0.6,-1.65,0.0) );\n    d2 = smin(d2,se.x-0.21,0.1);\n    d = smin(d,d2,0.4);\n        \n    \/\/ register eyelases now\n    vec4 res = vec4( d, isLip, 0, 0 );\n    if( deyelashes<res.x )\n    {\n        res.x = deyelashes*0.8;\n        res.yzw = vec3(0.0,1.0,0.0);\n    }\n    \/\/ register teeth now\n    if( dTeeth<res.x )\n    {\n        res.x = dTeeth;\n        outMat = 5.0;\n    }\n \n    \/\/ eyes\n\tpos.x \/=1.05;        \n    eos = qos-vec3(0.25,-0.06,0.42);\n    d2 = sdSphere(eos,0.4);\n    if( d2<res.x ) \n    { \n        res.x = d2;\n     \toutMat = 2.0;\n        uvw = pos;\n    }\n        \n    \/\/ hair\n    {\n        vec2 occ_id, tmp;\n\t\tqos = pos; qos.x=abs(pos.x);\n\n        vec4 pres = sdHair(pos,vec3(-0.3, 0.55,0.8), \n                               vec3( 0.95, 0.7,0.85), \n                               vec3( 0.4,-1.45,0.95),\n                               -0.9,occ_id);\n\n        vec4 pres2 = sdHair(pos,vec3(-0.4, 0.6,0.55), \n                                vec3(-1.0, 0.4,0.2), \n                                vec3(-0.6,-1.4,0.7),\n                                0.6,tmp);\n        if( pres2.x<pres.x ) { pres=pres2; occ_id=tmp;  occ_id.y+=40.0;}\n\n        pres2 = sdHair(qos,vec3( 0.4, 0.7,0.4), \n                           vec3( 1.0, 0.5,0.45), \n                           vec3( 0.4,-1.45,0.55),\n                           -0.2,tmp);\n        if( pres2.x<pres.x ) { pres=pres2; occ_id=tmp;  occ_id.y+=80.0;}\n    \n\n        pres.x *= 0.8;\n        if( pres.x<res.x )\n        {\n            res = vec4( pres.x, occ_id.y, 0.0, occ_id.x );\n            uvw = pres.yzw;\n            outMat = 4.0;\n        }\n    }\n\n    \/\/ hoodie\n    vec4 tmp = sdHoodie( opos );\n    if( tmp.x<res.x )\n    {\n        res.x = tmp.x;\n        outMat = 3.0;\n        uvw  = tmp.yzw;\n    }\n\n    return res;\n}\n\n\/\/ SDF of the girl again, but with extra high frequency\n\/\/ modeling detail. While the previous one is used for\n\/\/ raymarching and shadowing, this one is used for normal\n\/\/ computation. This separation is conceptually equivalent\n\/\/ to decoupling detail from base geometry with \"normal\n\/\/ maps\", but done in 3D and with SDFs, which is way\n\/\/ simpler and can be done corretly (something rarely seen\n\/\/ in 3D engines) without any complexity.\nvec4 mapD( in vec3 pos, in float time )\n{\n    float matID;\n    vec3 uvw;\n    vec4 h = map(pos, time, matID, uvw);\n    \n    if( matID<1.5 ) \/\/ skin\n    {\n        \/\/ pores\n        float d = fbm1(iChannel0,120.0*uvw);\n        h.x += 0.0015*d*d;\n    }\n    else if( matID>3.5 && matID<4.5 ) \/\/ hair\n    {\n        \/\/ some random displacement to evoke hairs\n        float te = texture( iChannel2,vec2( 0.25*atan(uvw.x,uvw.y),8.0*uvw.z) ).x;\n    \th.x -= 0.02*te;\n    }    \n    return h;\n}\n\n\/\/ Computes the normal of the girl's surface (the gradient\n\/\/ of the SDF). The implementation is weird because of the\n\/\/ technicalities of the WebGL API that forces us to do\n\/\/ some trick to prevent code unrolling. More info here:\n\/\/\n\/\/ https:\/\/iquilezles.org\/articles\/normalsSDF\n\/\/\nvec3 calcNormal( in vec3 pos, in float time )\n{\n    const float eps = 0.001;\n#if 0    \n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*eps,time,kk ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps,time,kk ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps,time,kk ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps,time,kk ).x );\n#else\n    vec4 n = vec4(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec4 s = vec4(pos, 0.0);\n        float kk; vec3 kk2;\n        s[i] += eps;\n        n[i] = mapD(s.xyz, time).x;\n      \/\/if( n.x+n.y+n.z+n.w>100.0 ) break;\n    }\n    return normalize(n.xyz-n.w);\n#endif   \n}\n\n\/\/ Compute soft shadows for a given light, with a single\n\/\/ ray insead of using montecarlo integration or shadowmap\n\/\/ blurring. More info here:\n\/\/\n\/\/ https:\/\/iquilezles.org\/articles\/rmshadows\n\/\/\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, in float time, float k )\n{\n    \/\/ first things first - let's do a bounding volume test\n    vec2 sph = iCylinderY( ro, rd, 1.5 );\n  \/\/vec2 sph = iConeY(ro-vec3(-0.05,3.7,0.35),rd,0.08);\n    tmax = min(tmax,sph.y);\n\n    \/\/ raymarch and track penumbra    \n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<128; i++ )\n    {\n        float kk; vec3 kk2;\n\t\tfloat h = map( ro + rd*t, time, kk, kk2 ).x;\n        res = min( res, k*h\/t );\n        t += clamp( h, 0.005, 0.1 );\n        if( res<0.002 || t>tmax ) break;\n    }\n    return max( res, 0.0 );\n}\n\n\/\/ Computes convexity for our girl SDF, which can be used\n\/\/ to approximate ambient occlusion. More info here:\n\/\/\n\/\/ https:\/\/iquilezles.org\/www\/material\/nvscene2008\/rwwtt.pdf\n\/\/\nfloat calcOcclusion( in vec3 pos, in vec3 nor, in float time )\n{\n    float kk; vec3 kk2;\n\tfloat ao = 0.0;\n    float off = textureLod(iChannel3,gl_FragCoord.xy\/256.0,0.0).x;\n    vec4 k = vec4(0.7012912,0.3941462,0.8294585,0.109841)+off;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tk = fract(k + H4);\n        vec3 ap = normalize(-1.0+2.0*k.xyz);\n        float h = k.w*0.1;\n        ap = (nor+ap)*h;\n        float d = map( pos+ap, time, kk, kk2 ).x;\n        ao += max(0.0,h-d);\n        if( ao>16.0 ) break;\n    }\n\tao \/= 16.0;\n    return clamp( 1.0-ao*24.0, 0.0, 1.0 );\n}\n\n\/\/ Computes the intersection point between our girl SDF and\n\/\/ a ray (coming form the camera in this case). It's a\n\/\/ traditional and basic\/uncomplicated SDF raymarcher. More\n\/\/ info here:\n\/\/\n\/\/ https:\/\/iquilezles.org\/www\/material\/nvscene2008\/rwwtt.pdf\n\/\/\nvec2 intersect( in vec3 ro, in vec3 rd, in float tmax, in float time, out vec3 cma, out vec3 uvw )\n{\n    cma = vec3(0.0);\n    uvw = vec3(0.0);\n    float matID = -1.0;\n\n    float t = 1.0;\n    \n    \/\/ bounding volume test first\n    vec2 sph = iCylinderY( ro, rd, 1.5 );\n  \/\/vec2 sph = iConeY(ro-vec3(-0.05,3.7,0.35),rd,0.08);\n    if( sph.y<0.0 ) return vec2(-1.0);\n    \n    \/\/ clip raymarch space to bonding volume\n    tmax = min(tmax,sph.y);\n    t    = max(1.0, sph.x);\n    \n    \/\/ raymarch\n    for( int i=0; i<256; i++ )\n    {\n        vec3 pos = ro + t*rd;\n\n        float tmp;\n        vec4 h = map(pos,time,tmp,uvw);\n        if( h.x<0.001 )\n        {\n            cma = h.yzw;\n            matID = tmp;\n            break;\n        }\n        t += h.x*0.95;\n        if( t>tmax ) break;\n    }\n\n    return vec2(t,matID);\n}\n\n\/\/ This is a replacement for a traditional dot(N,L) diffuse\n\/\/ lobe (called N.L in the code) that fakes some subsurface\n\/\/ scattering (transmision of light thorugh the skin that\n\/\/ surfaces as a red glow)\n\/\/\nvec3 sdif( float ndl, float ir )\n{\n    float pndl = clamp( ndl, 0.0, 1.0 );\n    float nndl = clamp(-ndl, 0.0, 1.0 );\n    return vec3(pndl) + vec3(1.0,0.1,0.01)*0.7*pow(clamp(ir*0.75-nndl,0.0,1.0),2.0);\n}\n\n\/\/ Animates the eye central position (not the actual random\n\/\/ darts). It's carefuly synched with the head motion, to\n\/\/ make the eyes anticipate the head turn (without this\n\/\/ anticipation, the eyes and the head are disconnected and\n\/\/ it all looks like a zombie\/animatronic)\n\/\/\nfloat animEye( in float time )\n{\n    const float w = 6.1;\n    float t = mod(time-0.31,w*1.0);\n    \n    float q = fract((time-0.31)\/(2.0*w));\n    float s = (q > 0.5) ? 1.0 : 0.0;\n    return (t<0.15)?1.0-s:s;\n}\n\n\/\/ Renders the girl. It finds the ray-girl intersection\n\/\/ point, computes the normal at the intersection point,\n\/\/ computes the ambient occlusion approximation, does per\n\/\/ material setup (color, specularity, subsurface\n\/\/ coefficient and paints some fake occlusion), and finally\n\/\/ does the lighting computations.\n\/\/\n\/\/ Lighting is not based on pathtracing. Instead the bounce\n\/\/ light occlusion signals are created manually (placed\n\/\/ and sized by hand). The subsurface scattering in the\n\/\/ nose area is also painted by hand. There's not much\n\/\/ attention to the physicall correctness of the light\n\/\/ response and materials, but generally all signal do\n\/\/ follow physically based rendering practices.\n\/\/\nvec3 renderGirl( in vec2 p, in vec3 ro, in vec3 rd, in float tmax, in vec3 col, in float time )\n{\n    \/\/ --------------------------\n    \/\/ find ray-girl intersection\n    \/\/ --------------------------\n    vec3 cma, uvw;\n    vec2 tm = intersect( ro, rd, tmax, time, cma, uvw );\n\n    \/\/ --------------------------\n    \/\/ shading\/lighting\t\n    \/\/ --------------------------\n    if( tm.y>0.0 )\n    {\n        vec3 pos = ro + tm.x*rd;\n        vec3 nor = calcNormal(pos, time);\n\n        float ks = 1.0;\n        float se = 16.0;\n        float tinterShadow = 0.0;\n        float sss = 0.0;\n        float focc = 1.0;\n        \/\/float frsha = 1.0;\n\n        \/\/ --------------------------\n        \/\/ material\n        \/\/ --------------------------\n        if( tm.y<1.5 ) \/\/ skin\n        {\n            vec3 qos = vec3(abs(uvw.x),uvw.yz);\n\n            \/\/ base skin color\n            col = mix(vec3(0.225,0.15,0.12),\n                      vec3(0.24,0.1,0.066),\n                      smoothstep(0.4 ,0.0,length( qos.xy-vec2(0.42,-0.3)))+\n                      smoothstep(0.15,0.0,length((qos.xy-vec2(0,-0.29))\/vec2(1.4,1))));\n            \n            \/\/ fix that ugly highlight\n            col -= 0.03*smoothstep(0.13,0.0,length((qos.xy-vec2(0,-0.49))\/vec2(2,1)));\n                \n            \/\/ lips\n            col = mix(col,vec3(0.14,0.06,0.1),cma.x*step(-0.7,qos.y));\n            \n            \/\/ eyelashes\n            col = mix(col,vec3(0.04,0.02,0.02)*0.6,0.9*cma.y);\n\n            \/\/ fake skin drag\n            uvw.y += 0.025*animData.x*smoothstep(0.3,0.1,length(uvw-vec3(0.0,0.1,1.0)));\n\t\t\tuvw.y -= 0.005*animData.y*smoothstep(0.09,0.0,abs(length((uvw.xy-vec2(0.0,-0.38))\/vec2(2.5,1.0))-0.12));\n            \n            \/\/ freckles\n            vec2 ti = floor(9.0+uvw.xy\/0.04);\n            vec2 uv = fract(uvw.xy\/0.04)-0.5;\n            float te = fract(111.0*sin(1111.0*ti.x+1331.0*ti.y));\n            te = smoothstep(0.9,1.0,te)*exp(-dot(uv,uv)*24.0); \n            col *= mix(vec3(1.1),vec3(0.8,0.6,0.4), te);\n\n            \/\/ texture for specular\n            ks = 0.5 + 4.0*texture(iChannel3,uvw.xy*1.1).x;\n            se = 12.0;\n            ks *= 0.5;\n            tinterShadow = 1.0;\n            sss = 1.0;\n            ks *= 1.0 + cma.x;\n            \n            \/\/ black top\n            col *= 1.0-smoothstep(0.48,0.51,uvw.y);\n            \n            \/\/ makeup\n            float d2 = sdEllipsoid(qos-vec3(0.25,-0.03,0.43),vec3(0.37,0.42,0.4));\n            col = mix(col,vec3(0.06,0.024,0.06),1.0 - smoothstep(0.0,0.03,d2));\n\n            \/\/ eyebrows\n    \t\t{\n            #if 0\n            \/\/ youtube video version\n        \tvec4 be = sdBezier( qos, vec3(0.165+0.01*animData.x,0.105-0.02*animData.x,0.89),\n                                     vec3(0.37,0.18-0.005*animData.x,0.82+0.005*animData.x), \n                                     vec3(0.53,0.15,0.69) );\n            float ra = 0.005 + 0.015*sqrt(be.y);\n            #else\n            \/\/ fixed version\n        \tvec4 be = sdBezier( qos, vec3(0.16+0.01*animData.x,0.11-0.02*animData.x,0.89),\n                                     vec3(0.37,0.18-0.005*animData.x,0.82+0.005*animData.x), \n                                     vec3(0.53,0.15,0.69) );\n            float ra = 0.005 + 0.01*sqrt(1.0-be.y);\n            #endif\n            float dd = 1.0+0.05*(0.7*sin((sin(qos.x*3.0)\/3.0-0.5*qos.y)*350.0)+\n                                 0.3*sin((qos.x-0.8*qos.y)*250.0+1.0));\n    \t\tfloat d = be.x - ra*dd;\n        \tfloat mask = 1.0-smoothstep(-0.005,0.01,d);\n        \tcol = mix(col,vec3(0.04,0.02,0.02),mask*dd );\n        \t}\n\n            \/\/ fake occlusion\n            focc = 0.2+0.8*pow(1.0-smoothstep(-0.4,1.0,uvw.y),2.0);\n            focc *= 0.5+0.5*smoothstep(-1.5,-0.75,uvw.y);\n            focc *= 1.0-smoothstep(0.4,0.75,abs(uvw.x));\n            focc *= 1.0-0.4*smoothstep(0.2,0.5,uvw.y);\n            \n            focc *= 1.0-smoothstep(1.0,1.3,1.7*uvw.y-uvw.x);\n            \n            \/\/frsha = 0.0;\n        }\n        else if( tm.y<2.5 ) \/\/ eye\n        {\n            \/\/ The eyes are fake in that they aren't 3D. Instead I simply\n\t\t\t\/\/ stamp a 2D mathematical drawing of an iris and pupil. That\n\t\t\t\/\/ includes the highlight and occlusion in the eyesballs.\n            \n            sss = 1.0;\n\n            vec3 qos = vec3(abs(uvw.x),uvw.yz);\n\t\t\tfloat ss = sign(uvw.x);\n            \n            \/\/ iris animation\n            float dt = floor(time*1.1);\n            float ft = fract(time*1.1);\n            vec2 da0 = sin(1.7*(dt+0.0)) + sin(2.3*(dt+0.0)+vec2(1.0,2.0));\n            vec2 da1 = sin(1.7*(dt+1.0)) + sin(2.3*(dt+1.0)+vec2(1.0,2.0));\n            vec2 da = mix(da0,da1,smoothstep(0.9,1.0,ft));\n\n            float gg = animEye(time);\n            da *= 1.0+0.5*gg;\n            qos.yz = rot(qos.yz,da.y*0.004-0.01);\n            qos.xz = rot(qos.xz,da.x*0.004*ss-gg*ss*(0.03-step(0.0,ss)*0.014)+0.02);\n\n            vec3 eos = qos-vec3(0.31,-0.055 - 0.03*animData.x,0.45);\n            \n            \/\/ iris\n            float r = length(eos.xy)+0.005;\n            float a = atan(eos.y,ss*eos.x);\n            vec3 iris = vec3(0.09,0.0315,0.0135);\n            iris += iris*3.0*(1.0-smoothstep(0.0,1.0, abs((a+3.14159)-2.5) ));\n            iris *= 0.35+0.7*texture(iChannel2,vec2(r,a\/6.2831)).x;\n            \/\/ base color\n            col = vec3(0.42);\n            col *= 0.1+0.9*smoothstep(0.10,0.114,r);\n            col = mix( col, iris, 1.0-smoothstep(0.095,0.10,r) );\n            col *= smoothstep(0.05,0.07,r);\n\t\t\t\n            \/\/ fake occlusion backed in\n            float edis = length((vec2(abs(uvw.x),uvw.y)-vec2(0.31,-0.07))\/vec2(1.3,1.0));\n            col *= mix( vec3(1.0), vec3(0.4,0.2,0.1), linearstep(0.07,0.16,edis) );\n\n            \/\/ fake highlight\n            qos = vec3(abs(uvw.x),uvw.yz);\n            col += (0.5-gg*0.3)*(1.0-smoothstep(0.0,0.02,length(qos.xy-vec2(0.29-0.05*ss,0.0))));\n            \n            se = 128.0;\n\n            \/\/ fake occlusion\n            focc = 0.2+0.8*pow(1.0-smoothstep(-0.4,1.0,uvw.y),2.0);\n            focc *= 1.0-linearstep(0.10,0.17,edis);\n            \/\/frsha = 0.0;\n        }\n        else if( tm.y<3.5 )\/\/ hoodie\n        {\n            sss = 0.0;\n            col = vec3(0.81*texture(iChannel0,uvw*6.0).x);\n            ks *= 2.0;\n            \n            \/\/ logo\n            if( abs(uvw.x)<0.66 )\n            {\n                float par = length(uvw.yz-vec2(-1.05,0.65));\n                col *= mix(vec3(1.0),vec3(0.6,0.2,0.8)*0.7,1.0-smoothstep(0.1,0.11,par));\n                col *= smoothstep(0.005,0.010,abs(par-0.105));\n            }                \n\n            \/\/ fake occlusion\n            focc = mix(1.0,\n                \t   0.03+0.97*smoothstep(-0.15,1.7,uvw.z),\n                       smoothstep(-1.6,-1.3,uvw.y)*(1.0-clamp(dot(nor.xz,normalize(uvw.xz)),0.0,1.0))\n                      );\n            \n            \/\/frsha = mix(1.0,\n            \/\/            clamp(dot(nor.xz,normalize(uvw.xz)),0.0,1.0),\n            \/\/            smoothstep(-1.6,-1.3,uvw.y)\n            \/\/           );\n            \/\/frsha *= smoothstep(0.85,1.0,length(uvw-vec3(0.0,-1.0,0.0)));\n        }\n        else if( tm.y<4.5 )\/\/ hair\n        {\n            sss = 0.0;\n            col = (sin(cma.x)>0.7) ? vec3(0.03,0.01,0.05)*1.5 :\n                                     vec3(0.04,0.02,0.01)*0.4;\n            ks *= 0.75 + cma.z*18.0;\n            float te = texture( iChannel2,vec2( 0.25*atan(uvw.x,uvw.y),8.0*uvw.z) ).x;\n            col *= 2.0*te;\n            ks *= 1.5*te;\n            \n\t\t\t\/\/ fake occlusion\n            focc  = 1.0-smoothstep(-0.40, 0.8, uvw.y);\n            focc *= 1.0-0.95*smoothstep(-1.20,-0.2,-uvw.z);\n            focc *= 0.5+cma.z*12.0;\n            \/\/frsha = 1.0-smoothstep(-1.3,-0.8,uvw.y);\n            \/\/frsha *= 1.0-smoothstep(-1.20,-0.2,-uvw.z);\n        }\n        else if( tm.y<5.5 )\/\/ teeth\n        {\n            sss = 1.0;\n            col = vec3(0.3);\n            ks *= 1.5;\n            \/\/frsha = 0.0;\n        }\n\n        float fre = clamp(1.0+dot(nor,rd),0.0,1.0);\n        float occ = focc*calcOcclusion( pos, nor, time );\n\n        \/\/ --------------------------\n        \/\/ lighting. just four lights\n        \/\/ --------------------------\n        vec3 lin = vec3(0.0);\n\n        \/\/ fake sss\n        float nma = 0.0;\n        if( tm.y<1.5 )\n        {\n        nma = 1.0-smoothstep(0.0,0.12,length((uvw.xy-vec2(0.0,-0.37))\/vec2(2.4,0.7)));\n        }\n\n        \/\/vec3 lig = normalize(vec3(0.5,0.4,0.6));\n        vec3 lig = vec3(0.57,0.46,0.68);\n        vec3 hal = normalize(lig-rd);\n        float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n        \/\/float sha = 0.0; if( dif>0.001 ) sha=calcSoftshadow( pos+nor*0.002, lig, 0.0001, 2.0, time, 5.0 );\n        float sha = calcSoftshadow( pos+nor*0.002, lig, 0.0001, 2.0, time, 5.0 );\n        float spe = 2.0*ks*pow(clamp(dot(nor,hal),0.0,1.0),se)*dif*sha*(0.04+0.96*pow(clamp(1.0-dot(hal,-rd),0.0,1.0),5.0));\n\n        \/\/ fake sss for key light\n        vec3 cocc = mix(vec3(occ),\n                        vec3(0.1+0.9*occ,0.9*occ+0.1*occ*occ,0.8*occ+0.2*occ*occ),\n                        tinterShadow);\n        cocc = mix( cocc, vec3(1,0.3,0.0), nma);\n        sha = mix(sha,max(sha,0.3),nma);\n\n        vec3  amb = cocc*(0.55 + 0.45*nor.y);\n        float bou = clamp(0.3-0.7*nor.x, 0.0, 1.0 );\n\n        lin +=      vec3(0.65,1.05,2.0)*amb*1.15;\n        lin += 1.50*vec3(1.60,1.40,1.2)*sdif(dot(nor,lig),0.5+0.3*nma+0.2*(1.0-occ)*tinterShadow) * mix(vec3(sha),vec3(sha,0.2*sha+0.7*sha*sha,0.2*sha+0.7*sha*sha),tinterShadow);\n        lin +=      vec3(1.00,0.30,0.1)*sss*fre*0.6*(0.5+0.5*dif*sha*amb)*(0.1+0.9*focc);\n        lin += 0.35*vec3(4.00,2.00,1.0)*bou*occ*col;\n\n        col = lin*col + spe + fre*fre*fre*0.1*occ;\n\n        \/\/ overall\n\t\tcol *= 1.1;\n    }\n        \n    return col;\n}\n\n\/\/ Animates the head turn. This is my first time animating\n\/\/ and I am aware I'm in uncanny\/animatronic land. But I\n\/\/ have to start somwhere!\n\/\/\nfloat animTurn( in float time )\n{\t\n    const float w = 6.1;\n    float t = mod(time,w*2.0);\n    \n    vec3 p = (t<w) ? vec3(0.0,0.0,1.0) : vec3(w,1.0,-1.0);\n    return p.y + p.z*expSustainedImpulse(t-p.x,1.0,10.0);\n}\n\n\/\/ Animates the eye blinks. Blinks are motivated by head\n\/\/ turns (again, in an attempt tp avoid animatronic and\n\/\/ zoombie feel), but also there are random blinks. This\n\/\/ same funcion is called with some delay and extra\n\/\/ smmoothness to get the blink of the eyes be followed by\n\/\/ the face muscles around the face.\n\/\/\nfloat animBlink( in float time, in float smo )\n{\n    \/\/ head-turn motivated blink\n    const float w = 6.1;\n    float t = mod(time-0.31,w*1.0);\n    float blink = smoothstep(0.0,0.1,t) - smoothstep(0.18,0.4,t);\n\n    \/\/ regular blink\n    float tt = mod(1.0+time,3.0);\n    blink = max(blink,smoothstep(0.0,0.07+0.07*smo,tt)-smoothstep(0.1+0.04*smo,0.35+0.3*smo,tt));\n    \n    \/\/ keep that eye alive always\n    float blinkBase = 0.04*(0.5+0.5*sin(time));\n    blink = mix( blinkBase, 1.0, blink );\n\n    \/\/ base pose is a bit down\n    float down = 0.15;\n    return down+(1.0-down)*blink;\n}\n\n\/\/ The main rendering entry point. Basically it does some\n\/\/ setup, creating the ray that will explore the 3D scene\n\/\/ in search of the girl for each pixel, computes the\n\/\/ animation variables (blink, mouth and head movements),\n\/\/ does the rendering of the girl if it finds her under\n\/\/ the current pixel, and finally does gamme correction\n\/\/ and some minimal color processing and vignetting to the\n\/\/ image.\n\/\/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ render\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        \/\/ pixel coordinates\n        vec2 o = vec2(float(m),float(n)) \/ float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))\/iResolution.y;\n        float d = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n        float time = iTime - 0.5*(1.0\/24.0)*(float(m*AA+n)+d)\/float(AA*AA-1);\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)\/iResolution.y;\n        float time = iTime;\n        #endif\n        \n        time += 2.0;\n        \n        \/\/ camera movement\t\n        vec3 ro; float fl;\n        mat3 ca = calcCamera( time, ro, fl );\n    \tvec3 rd = ca * normalize( vec3((p-vec2(-0.52,0.12))\/1.1,fl));\n\n        \/\/ animation (blink, face follow up, mouth)\n        float turn = animTurn( time );\n        animData.x = animBlink(time,0.0);\n        animData.y = animBlink(time-0.02,1.0);\n        animData.z = -0.25 + 0.2*(1.0-turn)*smoothstep(-0.3,0.9,sin(time*1.1)) + 0.05*cos(time*2.7);\n\n        \/\/ animation (head orientation)\n        animHead = vec3( sin(time*0.5), sin(time*0.3), -cos(time*0.2) );\n        animHead = animHead*animHead*animHead;\n        animHead.x = -0.025*animHead.x + 0.2*(0.7+0.3*turn);\n        animHead.y =  0.1 + 0.02*animHead.y*animHead.y*animHead.y;\n        animHead.z = -0.03*(0.5 + 0.5*animHead.z) - (1.0-turn)*0.05;\n        \n        \/\/ rendering\n        vec4 tmp = texelFetch(iChannel1,ivec2(fragCoord),0);\n        vec3 col = tmp.xyz;\n        float tmin = tmp.w;\n        \n        if( p.x*1.4+p.y<0.8 && -p.x*4.5+p.y<6.5 && p.x<0.48)\n        col = renderGirl(p,ro,rd,tmin,col,time);\n        \/\/else col=vec3(0,1,0);\n        \n        \/\/ gamma        \n        col = pow( col, vec3(0.4545) );\n\t    tot += col;\n    #if AA>1\n    }\n    tot \/= float(AA*AA);\n    #endif\n \n    \/\/ compress\n    tot = 3.8*tot\/(3.0+dot(tot,vec3(0.333)));\n  \n    \/\/ vignette\n    vec2 q = fragCoord\/iResolution.xy;\n    tot *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.15);\n\n    \/\/ grade\n    tot = tot*vec3(1.02,1.00,0.99)+vec3(0.0,0.0,0.045);\n       \n    fragColor = vec4( tot, 1.0 );\n}",
                "name": "Image",
                "description": "",
                "type": "image"
            },
            {
                "inputs": [],
                "outputs": [],
                "code": "\/\/ Basic utility functions (SDFs, noises, shaping functions)\n\/\/ and also the camera setup which is shared between the\n\/\/ background rendering code (\"Buffer A\" tab) and the character\n\/\/ rendering code (\"Image\" tab)\n\n\n\n\/\/ https:\/\/iquilezles.org\/articles\/smin\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25\/k;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/smin\nfloat smax( float a, float b, float k )\n{\n    k *= 1.4;\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*h\/(6.0*k*k);\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/smin\nfloat smin3( float a, float b, float k )\n{\n    k *= 1.4;\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*h\/(6.0*k*k);\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/smin\nfloat sclamp(in float x, in float a, in float b )\n{\n    float k = 0.1;\n\treturn smax(smin(x,b,k),a,k);\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nfloat opOnion( in float sdf, in float thickness )\n{\n    return abs(sdf)-thickness;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nfloat opRepLim( in float p, in float s, in float lima, in float limb )\n{\n    return p-s*clamp(round(p\/s),lima,limb);\n}\n\nfloat det( vec2 a, vec2 b ) { return a.x*b.y-b.x*a.y; }\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x-a.y*b.y; }\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nfloat sdTorus( in vec3 p, in float ra, in float rb )\n{\n    return length( vec2(length(p.xz)-ra,p.y) )-rb;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.z) ? dot(p.xz,sc) : length(p.xz);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nfloat sdSphere( in vec3 p, in float r ) \n{\n    return length(p)-r;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    float k0 = length(p\/r);\n    float k1 = length(p\/(r*r));\n    return k0*(k0-1.0)\/k1;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nfloat sdBox( in vec3 p, in vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min( max(max(d.x,d.y),d.z),0.0) + length(max(d,0.0));\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nfloat sdArc( in vec2 p, in vec2 scb, in float ra )\n{\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k );\n}\n\n#if 1\n\/\/ http:\/\/research.microsoft.com\/en-us\/um\/people\/hoppe\/ravg.pdf\n\/\/ { dist, t, y (above the plane of the curve, x (away from curve in the plane of the curve))\nvec4 sdBezier( vec3 p, vec3 va, vec3 vb, vec3 vc )\n{\n  vec3 w = normalize( cross( vc-vb, va-vb ) );\n  vec3 u = normalize( vc-vb );\n  vec3 v =          ( cross( w, u ) );\n  \/\/----  \n  vec2 m = vec2( dot(va-vb,u), dot(va-vb,v) );\n  vec2 n = vec2( dot(vc-vb,u), dot(vc-vb,v) );\n  vec3 q = vec3( dot( p-vb,u), dot( p-vb,v), dot(p-vb,w) );\n  \/\/----  \n  float mn = det(m,n);\n  float mq = det(m,q.xy);\n  float nq = det(n,q.xy);\n  \/\/----  \n  vec2  g = (nq+mq+mn)*n + (nq+mq-mn)*m;\n  float f = (nq-mq+mn)*(nq-mq+mn) + 4.0*mq*nq;\n  vec2  z = 0.5*f*vec2(-g.y,g.x)\/dot(g,g);\n\/\/float t = clamp(0.5+0.5*(det(z,m+n)+mq+nq)\/mn, 0.0 ,1.0 );\n  float t = clamp(0.5+0.5*(det(z-q.xy,m+n))\/mn, 0.0 ,1.0 );\n  vec2 cp = m*(1.0-t)*(1.0-t) + n*t*t - q.xy;\n  \/\/----  \n  float d2 = dot(cp,cp);\n  return vec4(sqrt(d2+q.z*q.z), t, q.z, -sign(f)*sqrt(d2) );\n}\n#else\nfloat det( vec3 a, vec3 b, in vec3 v ) { return dot(v,cross(a,b)); }\n\n\/\/ my adaptation to 3d of http:\/\/research.microsoft.com\/en-us\/um\/people\/hoppe\/ravg.pdf\n\/\/ { dist, t, y (above the plane of the curve, x (away from curve in the plane of the curve))\nvec4 sdBezier( vec3 p, vec3 b0, vec3 b1, vec3 b2 )\n{\n    b0 -= p;\n    b1 -= p;\n    b2 -= p;\n    \n    vec3  d21 = b2-b1;\n    vec3  d10 = b1-b0;\n    vec3  d20 = (b2-b0)*0.5;\n\n    vec3  n = normalize(cross(d10,d21));\n\n    float a = det(b0,b2,n);\n    float b = det(b1,b0,n);\n    float d = det(b2,b1,n);\n    vec3  g = b*d21 + d*d10 + a*d20;\n\tfloat f = a*a*0.25-b*d;\n\n    vec3  z = cross(b0,n) + f*g\/dot(g,g);\n    float t = clamp( dot(z,d10-d20)\/(a+b+d), 0.0 ,1.0 );\n    vec3 q = mix(mix(b0,b1,t), mix(b1,b2,t),t);\n    \n    float k = dot(q,n);\n    return vec4(length(q),t,-k,-sign(f)*length(q-n*k));\n}\n#endif\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nvec2 sdSegment(vec3 p, vec3 a, vec3 b)\n{\n    vec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ), h );\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nvec2 sdSegmentOri(vec2 p, vec2 b)\n{\n\tfloat h = clamp( dot(p,b)\/dot(b,b), 0.0, 1.0 );\n\treturn vec2( length( p - b*h ), h );\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nfloat sdFakeRoundCone(vec3 p, float b, float r1, float r2)\n{\n    float h = clamp( p.y\/b, 0.0, 1.0 );\n    p.y -= b*h;\n\treturn length(p) - mix(r1,r2,h);\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nfloat sdCone( in vec3 p, in vec2 c )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n\n  vec2 a = q - c*clamp( (q.x*c.x+q.y*c.y)\/dot(c,c), 0.0, 1.0 );\n  vec2 b = q - c*vec2( clamp( q.x\/c.x, 0.0, 1.0 ), 1.0 );\n  \n  float s = -sign( c.y );\n  vec2 d = min( vec2( dot( a, a ), s*(q.x*c.y-q.y*c.x) ),\n\t\t\t    vec2( dot( b, b ), s*(q.y-c.y)  ));\n  return -sqrt(d.x)*sign(d.y);\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n    p = abs(p);\n    vec2 b = vec2(la,lb);\n    float f = clamp( (ndot(b,b-2.0*p.xz))\/dot(b,b), -1.0, 1.0 );\n\tvec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nvec4 opElongate( in vec3 p, in vec3 h )\n{\n    vec3 q = abs(p)-h;\n    return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n\n\/\/-----------------------------------------------\n\n\/\/ ray-infinite-cylinder intersection\nvec2 iCylinderY( in vec3 ro, in vec3 rd, in float rad )\n{\n\tvec3 oc = ro;\n    float a = dot( rd.xz, rd.xz );\n\tfloat b = dot( oc.xz, rd.xz );\n\tfloat c = dot( oc.xz, oc.xz ) - rad*rad;\n\tfloat h = b*b - a*c;\n\tif( h<0.0 ) return vec2(-1.0);\n    h = sqrt(h);\n\treturn vec2(-b-h,-b+h)\/a;\n}\n\n\/\/ ray-infinite-cone intersection\nvec2 iConeY(in vec3 ro, in vec3 rd, in float k )\n{\n\tfloat a = dot(rd.xz,rd.xz) - k*rd.y*rd.y;\n    float b = dot(ro.xz,rd.xz) - k*ro.y*rd.y;\n    float c = dot(ro.xz,ro.xz) - k*ro.y*ro.y; \n        \n    float h = b*b-a*c;\n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b-h,-b+h)\/a;\n}\n\n\/\/-----------------------------------------------\n\nfloat linearstep(float a, float b, in float x )\n{\n    return clamp( (x-a)\/(b-a), 0.0, 1.0 );\n}\n\nvec2 rot( in vec2 p, in float an )\n{\n    float cc = cos(an);\n    float ss = sin(an);\n    return mat2(cc,-ss,ss,cc)*p;\n}\n\nfloat expSustainedImpulse( float t, float f, float k )\n{\n    return smoothstep(0.0,f,t)*1.1 - 0.1*exp2(-k*max(t-f,0.0));\n}\n\n\/\/-----------------------------------------------\n\nvec3 hash3( uint n ) \n{\n    \/\/ integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    uvec3 k = n * uvec3(n,n*16807U,n*48271U);\n    return vec3( k & uvec3(0x7fffffffU))\/float(0x7fffffff);\n}\n\n\/\/---------------------------------------\n\nfloat noise1( sampler3D tex, in vec3 x )\n{\n    return textureLod(tex,(x+0.5)\/32.0,0.0).x;\n}\nfloat noise1( sampler2D tex, in vec2 x )\n{\n    return textureLod(tex,(x+0.5)\/64.0,0.0).x;\n}\nfloat noise1f( sampler2D tex, in vec2 x )\n{\n    return texture(tex,(x+0.5)\/64.0).x;\n}\nfloat fbm1( sampler3D tex, in vec3 x )\n{\n    float f = 0.0;\n    f += 0.5000*noise1(tex,x); x*=2.01;\n    f += 0.2500*noise1(tex,x); x*=2.01;\n    f += 0.1250*noise1(tex,x); x*=2.01;\n    f += 0.0625*noise1(tex,x);\n    f = 2.0*f-0.9375;\n    return f;\n}\n\nfloat fbm1( sampler2D tex, in vec2 x )\n{\n    float f = 0.0;\n    f += 0.5000*noise1(tex,x); x*=2.01;\n    f += 0.2500*noise1(tex,x); x*=2.01;\n    f += 0.1250*noise1(tex,x); x*=2.01;\n    f += 0.0625*noise1(tex,x);\n    f = 2.0*f-0.9375;\n    return f;\n}\nfloat fbm1f( sampler2D tex, in vec2 x )\n{\n    float f = 0.0;\n    f += 0.5000*noise1f(tex,x); x*=2.01;\n    f += 0.2500*noise1f(tex,x); x*=2.01;\n    f += 0.1250*noise1f(tex,x); x*=2.01;\n    f += 0.0625*noise1f(tex,x);\n    f = 2.0*f-0.9375;\n    return f;\n}\nfloat bnoise( in float x )\n{\n    float i = floor(x);\n    float f = fract(x);\n    float s = sign(fract(x\/2.0)-0.5);\n    float k = 0.5+0.5*sin(i);\n    return s*f*(f-1.0)*((16.0*k-4.0)*f*(f-1.0)-1.0);\n}\nvec3 fbm13( in float x, in float g )\n{    \n    vec3 n = vec3(0.0);\n    float s = 1.0;\n    for( int i=0; i<6; i++ )\n    {\n        n += s*vec3(bnoise(x),bnoise(x+13.314),bnoise(x+31.7211));\n        s *= g;\n        x *= 2.01;\n        x += 0.131;\n    }\n    return n;\n}\n\n\/\/--------------------------------------------------\n\/\/const float X1 = 1.6180339887498948; const float H1 = float( 1.0\/X1 );\n\/\/const float X2 = 1.3247179572447460; const vec2  H2 = vec2(  1.0\/X2, 1.0\/(X2*X2) );\n\/\/const float X3 = 1.2207440846057595; const vec3  H3 = vec3(  1.0\/X3, 1.0\/(X3*X3), 1.0\/(X3*X3*X3) );\n  const float X4 = 1.1673039782614187; const vec4  H4 = vec4(  1.0\/X4, 1.0\/(X4*X4), 1.0\/(X4*X4*X4), 1.0\/(X4*X4*X4*X4) );\n\n\/\/--------------------------------------\nmat3 calcCamera( in float time, out vec3 oRo, out float oFl )\n{\n    vec3 ta = vec3( 0.0, -0.3, 0.0 );\n    vec3 ro = vec3( -0.5563, -0.2, 2.7442 );\n    float fl = 1.7;\n#if 0\n    vec3 fb = fbm13( 0.2*time, 0.5 );\n    ta += 0.025*fb;\n    float cr = -0.01 + 0.006*fb.z;\n#else\n    vec3 fb1 = fbm13( 0.15*time, 0.50 );\n    ro.xyz += 0.010*fb1.xyz;\n    vec3 fb2 = fbm13( 0.33*time, 0.65 );\n    fb2 = fb2*fb2*sign(fb2);\n    ta.xy += 0.005*fb2.xy;\n    float cr = -0.01 + 0.002*fb2.z;\n#endif\n    \n    \/\/ camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(cr),cos(cr),0.0) ) );\n    vec3 vv =          ( cross(uu,ww));\n    \n    oRo = ro;\n    oFl = fl;\n\n    return mat3(uu,vv,ww);\n}\n\n#define ZERO min(iFrame,0)\n#define ZEROU min(uint(iFrame),0u)\n",
                "name": "Common",
                "description": "",
                "type": "common"
            },
            {
                "inputs": [
                    {
                        "id": "4sf3Rn",
                        "filepath": "\/media\/a\/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png",
                        "previewfilepath": "\/media\/ap\/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png",
                        "type": "texture",
                        "channel": 2,
                        "sampler": {
                            "filter": "mipmap",
                            "wrap": "repeat",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    },
                    {
                        "id": "Xsf3zn",
                        "filepath": "\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
                        "previewfilepath": "\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
                        "type": "texture",
                        "channel": 3,
                        "sampler": {
                            "filter": "mipmap",
                            "wrap": "repeat",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    },
                    {
                        "id": "4sfGRr",
                        "filepath": "\/media\/a\/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin",
                        "previewfilepath": "\/media\/ap\/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin",
                        "type": "volume",
                        "channel": 0,
                        "sampler": {
                            "filter": "mipmap",
                            "wrap": "repeat",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    },
                    {
                        "id": "4dXGR8",
                        "filepath": "\/media\/previz\/buffer00.png",
                        "previewfilepath": "\/media\/previz\/buffer00.png",
                        "type": "buffer",
                        "channel": 1,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "4dXGR8",
                        "channel": 0
                    }
                ],
                "code": "\/\/ Renders the background (trees, ground, river and bridge).\n\/\/ The render uses a super basic implementation of Temporal\n\/\/ Antialiasing (TAA) without color clipping or anything,\n\/\/ but it's enough to stabilize aliasing. It also outputs\n\/\/ the deph buffer into the alpha channel for the next pass\n\/\/ (\"Buffer B\") to consume and do proper Depth Of Field.\n\n\n\/\/ The ground - it's a simple box deformed by a few sine waves\n\/\/\nfloat sdGround( in vec3 pos )\n{\n    pos -= vec3(120.0,-35.0,-700.0);\n    pos.x += -150.0;\n    pos.z += 30.0*sin(1.00*pos.x*0.016+0.0);\n    pos.z += 10.0*sin(2.20*pos.x*0.016+1.0);\n    pos.y += 20.0*sin(0.01*pos.x+2.0)*sin(0.01*pos.z+2.0);\n    \n    return sdBox(pos,vec3(1000.0,2.0,400.0))-10.0;\n}\n\n\/\/ The bridge. It's made of five boxes repeated forever\n\/\/ with some mod() call, which are distorted with gentle\n\/\/ sine waves so they don't look like perfectly geometrical. \n\/\/\nvec2 sdBridge( in vec3 pos )\n{\n    float issnow = 0.0;\n    vec3 opos = pos;\n    pos.x  += 50.0*sin(pos.z*0.01)+10.0;\n    pos.xz += 0.05*sin(pos.yx+vec2(0,2));                \n    vec3 sos = vec3(abs(pos.x),pos.yz);\n    float h = -16.0;\n    \n    \/\/ floor\n    vec3 ros = vec3(sos.xy,mod(sos.z+2.0,4.0)-2.0 )-vec3(0.0,h,0.0);\n    float d = sdBox(ros,vec3(20.0,1.0,1.85));\n\n    \/\/ thick bars\n    ros = vec3(sos.xy,mod(sos.z+5.0,10.0)-5.0 )-vec3(20.0,h+5.0-0.4,0.0);\n    float d2 = sdBox(ros,vec3(1.2,5.0,0.7)+0.1)-0.1;\n    d = min(d,d2);\n    \n    #if 0\n    {\n    float id = floor((sos.z+5.0)\/10.0);\n    ros = vec3(sos.xy,mod(sos.z+5.0,10.0)-5.0 )-vec3(20.0,h-0.4,0.0);\n\tros-=vec3(-1.5,1,0);\n    ros.x -= ros.y;\n    float ra = 0.5 + 0.5*sin(float(id)+4.0);\n    float d2 = sdEllipsoid(ros,vec3(2.0,2.0,1.3)*ra);\n    issnow = clamp( 0.5+0.5*(d-d2)\/0.7, 0.0, 1.0 );\n    d = smin(d,d2,0.7);\n    }\n    #endif\n\n    \/\/ small bars\n    ros = vec3(sos.xy,mod(sos.z+1.25,2.5)-1.25 )-vec3(20.0,h+5.0,0.0);\n    d2 = sdBox(ros,vec3(0.2,5.0,0.2))-0.05;\n    d = min(d,d2);\n    \n    \/\/ handle\n    d2 = sdBox(sos-vec3(20.0,h+10.0,0.0),vec3(0.5,0.1,300.0))-0.4;\n    d = min(d,d2);\n    \n    \/\/ foot bar\n    d2 = sdBox(sos-vec3(20.0,h+2.4,0.0),vec3(0.7,0.1,300.0))-0.2;\n    d = min(d,d2);\n    \n\treturn vec2(d,issnow);\n}\n\n\/\/ The trees are ultra basic and look really bad without\n\/\/ defocus, but all I needed was something that looked like\n\/\/ pine trees so the viewers would complete the picture in\n\/\/ their heads. Only four trees are evaluated at any time,\n\/\/ even though  there are inifinte many of them. Yet these\n\/\/ four trees consume most of the rendering budget for the\n\/\/ painting.\n\/\/\nvec3 sdForest( in vec3 pos, float tmin )\n{\n    float shid = 0.0;\n    \n    const float per = 200.0;\n    \n    pos -= vec3(120.0,-16.0,-600.0);\n        \n    vec3 vos = pos\/per;\n    vec3 ip = floor(vos);\n    vec3 fp = fract(vos);\n    \n    bool hit = false;\n    float d = tmin;\n    float occ = 1.0;\n    \n    for( int j=0; j<=1; j++ )\n    for( int i=0; i<=1; i++ )\n    {\n        vec2 of = vec2(i,j);\n        ivec2 tid = ivec2(ip.xz + of );\n        tid.y = min(tid.y,-0);\n        \n        uint treeId = uint(tid.y)*17u+uint(tid.x)*1231u;\n        \n        vec3 rf =  hash3( uint(treeId) )-0.5;\n        \n        vec3 ros = vec3( (float(tid.x)+rf.x)*per,\n                         0.0,\n                         (float(tid.y)+rf.y)*per );\n\n\n        float hei = 1.0 + 0.2*sin( float(tid.x*115+tid.y*221) );\n        hei *= (tid.y==0) ? 1.0 : 1.5;\n          \n        hei *= 275.0;\n\n        float d2 = sdFakeRoundCone( pos-ros,hei,7.0,1.0);\n        if( d2<d)\n        {\n            d = d2;\n            hit = false;\n        }\n        \n        if( d2-150.0>d ) continue;\n        \n        vec2 qos = pos.xz - ros.xz;\n        float an = atan(qos.x,qos.y);\n        float ra = length(qos);\n        float vv = 0.3*sin(11.0*an) + 0.2*sin(28.0*an)+ 0.10*sin(53.0*an+4.0);\n\n        \n        \/\/ trick - only evalute 4 closest of the 10 cones\n        int segid = int(floor(16.0*(pos.y-ros.y)\/hei));\n        for( uint k=ZEROU; k<4u; k++ )\n        {\n            uint rk = uint( min(max(segid+int(k),5),15) );\n            \n            float h = float(rk)\/15.0;\n            \n            vec3 ran = hash3( treeId*24u+rk );\n            \n            h += 0.1*(1.0-h)*(ran.z-0.5) + 0.05*sin(1.0*an);\n\n            ros.y = h*hei;\n            \n            float hh = 0.5 + 0.5*(1.0-h);\n            float ww = 0.1 + 0.9*(1.0-h);\n            hh *= 0.7+0.2*ran.x;\n            ww *= 0.9+0.2*ran.y;\n            hh *= 1.0+0.2*vv;\n            \n            vec2 rrr = vec2( ra, pos.y-ros.y );\n            vec2 tmp = sdSegmentOri( rrr,vec2(120.0*ww,-100.0*hh));\n            float d2 = tmp.x-mix(1.0,vv,tmp.y);\n            if( d2<d )\n            {\n                hit = true;\n                d = d2;\n                shid = rf.z;\n                occ = tmp.y * clamp(ra\/100.0+h,0.0,1.0);\n            }\n        }\n    }\n    \n    if( hit )\n    {\n        float dis = 0.5+0.5*fbm1(iChannel0,0.1*pos*vec3(1,0.3,1));\n        d -= 8.0*dis-4.0;\n        \/\/occ = dis;\n    }\n    \n\treturn vec3(d,shid,occ);\n}\n\n\n\/\/ The SDF of the landscape is made by combining ground, \n\/\/ bridge, river and trees. \n\/\/\nvec4 map( in vec3 pos, in float time, out float outMat, out vec3 uvw )\n{\n    pos.xz = rot(pos.xz,0.2);\n\n    vec4 res = vec4(pos.y+36.0,0,0,0);    \n    \n    outMat = 1.0;\n    uvw = pos;\n    \n    \/\/-------\n    {\n    vec2 d2 = sdBridge(pos);\n    if( d2.x<res.x )\n    {\n        res.xy = d2;\n        outMat = 2.0;\n    }\n    }\n    \/\/-------\n    float d = sdGround(pos);\n    if( d<res.x )\n    {\n        res.x = d;\n        outMat = 4.0;\n    }\n    \/\/-------\n    float bb = pos.z+450.0;\n    if( bb<d )\n    {\n    vec3 d2 = sdForest(pos,d);\n    if( d2.x<res.x )\n    {\n        res.x = d2.x;\n        res.y = d2.y;\n        res.z = d2.z;\n        outMat = 3.0;\n    }\n    }\n    \n    return res;\n}\n\n\/\/ The landscape SDF again, but with extra high frequency\n\/\/ modeling detail. While the previous one is used for\n\/\/ raymarching and shadowing, this one is used for normal\n\/\/ computation. This separation is conceptually equivalent\n\/\/ to decoupling detail from base geometry with \"normal\n\/\/ maps\", but done in 3D and with SDFs, which is way simpler\n\/\/ and can be done correctly (something rarely seen in 3D\n\/\/ engines) without any complexity.\n\/\/\nfloat mapD( in vec3 pos, in float time )\n{\n    float matID; vec3 kk2;\n    float d = map(pos,time,matID,kk2).x;\n    \n    if( matID<1.5 ) \/\/ water\n    {\n        float g = 0.5 + 0.5*fbm1f(iChannel2,0.02*pos.xz);\n        g = g*g;\n    \tfloat f = 0.5 + 0.5*fbm1f(iChannel2,pos.xz);\n        d -= g*12.0*(0.5+0.5*f*g*2.0);\n    }\n    else if( matID<2.5 ) \/\/ bridge\n    {\n    \td -= 0.07*(0.5+0.5*fbm1(iChannel0, pos*vec3(8,1,8) ));\n    }\n    else if( matID<4.5 ) \/\/ ground\n    {\n    \tfloat dis = fbm1(iChannel0,0.1*pos);\n    \td -= 3.0*dis;\n    }\n    \n    return d;\n}\n\n\/\/ Computes the normal of the girl's surface (the gradient\n\/\/ of the SDF). The implementation is weird because of the\n\/\/ technicalities of the WebGL API that forces us to do\n\/\/ some trick to prevent code unrolling. More info here:\n\/\/\n\/\/ https:\/\/iquilezles.org\/articles\/normalsSDF\n\/\/\nvec3 calcNormal( in vec3 pos, in float time, in float t )\n{\n    float eps = 0.001*t;\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*mapD( pos + e.xyy*eps,time ) + \n\t\t\t\t\t  e.yyx*mapD( pos + e.yyx*eps,time ) + \n\t\t\t\t\t  e.yxy*mapD( pos + e.yxy*eps,time ) + \n\t\t\t\t\t  e.xxx*mapD( pos + e.xxx*eps,time ) );\n#else\n    vec4 n = vec4(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec4 s = vec4(pos, 0.0);\n        s[i] += eps;\n        n[i] = mapD(s.xyz, time);\n        \/\/if( n.x+n.y+n.z+n.w>100.0 ) break;\n    }\n    return normalize(n.xyz-n.w);\n#endif    \n}\n\n\/\/ Compute soft shadows for a given light, with a single ray\n\/\/ insead of using montecarlo integration or shadowmap\n\/\/ blurring. More info here:\n\/\/\n\/\/ https:\/\/iquilezles.org\/articles\/rmshadows\n\/\/\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, in float time, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    \n    \/\/ first things first - let's do a bounding volume test\n    float tm = (480.0-ro.y)\/rd.y; if( tm>0.0 ) tmax=min(tmax,tm);\n    \n    \/\/ raymarch and track penumbra\n    for( int i=ZERO; i<128; i++ )\n    {\n        float kk; vec3 kk2;\n\t\tfloat h = map( ro + rd*t, time, kk, kk2 ).x;\n        res = min( res, k*h\/t );\n        t += clamp( h, 0.05, 25.0 );\n        if( res<0.002 || t>tmax ) break;\n    }\n    return max( res, 0.0 );\n}\n\n\/\/ Computes convexity for our landscape SDF, which can be\n\/\/ used to approximate ambient occlusion. More info here:\n\/\/\n\/\/ https:\/\/iquilezles.org\/www\/material\/nvscene2008\/rwwtt.pdf\n\/\/\nfloat calcOcclusion( in vec3 pos, in vec3 nor, in float time, float sca, in vec2 px )\n{\n    float kk; vec3 kk2;\n\tfloat ao = 0.0;\n    float off = textureLod(iChannel3,px\/256.0,0.0).x;\n    vec4 k = vec4(0.7012912,0.3941462,0.8294585,0.109841)+off;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tk = fract(k + H4);\n        vec3 ap = normalize(-1.0+2.0*k.xyz);\n        float h = k.w*1.0*sca;\n        ap = (nor+ap)*h;\n        float d = map( pos+ap, time, kk, kk2 ).x;\n        ao += max(0.0,h-d);\n        if( ao>10000.0 ) break;\n    }\n\tao \/= 16.0;\n    return clamp( 1.0-ao*2.0\/sca, 0.0, 1.0 );\n}\n\n\/\/ Computes the intersection point between our landscape SDF\n\/\/ and a ray (coming form the camera in this case). It's a\n\/\/ traditional and uncomplicated SDF raymarcher. More info:\n\/\/\n\/\/ https:\/\/iquilezles.org\/www\/material\/nvscene2008\/rwwtt.pdf\n\/\/\nvec2 intersect( in vec3 ro, in vec3 rd, in float time, out vec3 cma, out vec3 uvw )\n{\n    cma = vec3(0.0);\n    uvw = vec3(0.0);\n    float matID = -1.0;\n\n    float tmax = 2500.0;\n    float t = 15.0;\n\t\/\/ bounding volume test first    \n    float tm = (480.0-ro.y)\/rd.y; if( tm>0.0 ) tmax=min(tmax,tm);\n    \n    \/\/ raymarch\n    for( int i=ZERO; i<1024; i++ )\n    {\n        vec3 pos = ro + t*rd;\n\n        float tmp;\n        vec4 h = map(pos,time,tmp,uvw);\n        if( (h.x)<0.0002*t )\n        {\n            cma = h.yzw;\n            matID = tmp;\n            break;\n        }\n        t += h.x*0.8;\n        if( t>tmax ) break;\n    }\n\n    return vec2(t,matID);\n}\n\n\/\/ Renders the landscape. It finds the ray-landscape\n\/\/ intersection point, computes the normal at the\n\/\/ intersection point, computes the ambient occlusion\n\/\/ approximation, does per material setup (color,\n\/\/ specularity, and paints some fake occlusion), and\n\/\/ finally does the lighting computation.\n\/\/\nvec4 renderBackground( in vec2 p, in vec3 ro, in vec3 rd, in float time, in vec2 px )\n{\n    \/\/ sky color\n    vec3 col = vec3(0.45,0.75,1.1) + rd.y*0.5;\n    vec3 fogcol = vec3(0.3,0.5,1.0)*0.25;\n    col = mix( col, fogcol, exp2(-8.0*max(rd.y,0.0)) );\n    \n    \/\/ -------------------------------\n    \/\/ find ray-landscape intersection\n    \/\/ -------------------------------\n    float tmin = 1e20;\n    vec3 cma, uvw;\n    vec2 tm = intersect( ro, rd, time, cma, uvw);\n\n    \/\/ --------------------------\n    \/\/ shading\/lighting\t\n    \/\/ --------------------------\n    if( tm.y>0.0 )\n    {\n        tmin = tm.x;\n        \n        vec3 pos = ro + tmin*rd;\n        vec3 nor = calcNormal(pos, time, tmin);\n\n        col = cma;\n\n        float ks = 1.0;\n        float se = 16.0;\n        float focc = 1.0;\n        float occs = 1.0;\n        float snow = 1.0;\n        \n    \t\/\/ --------------------------\n        \/\/ materials\n    \t\/\/ --------------------------\n\n        \/\/ water\n        if( tm.y<1.5 )\n        {\n            col = vec3(0.1,0.2,0.3);\n            occs = 20.0;\n        }\n        \/\/ bridge\n        else if( tm.y<2.5 )\n        {\n            float f = 0.5 + 0.5*fbm1(iChannel0,pos*vec3(8,1,8));\n            ks = f*8.0;\n            se = 12.0;\n            col = mix(vec3(0.40,0.22,0.15)*0.63,\n                      vec3(0.35,0.07,0.02)*0.2,f);\n            f = fbm1(iChannel0,pos*0.5);\n            col *= 1.0 + 1.1*f*vec3(0.5,1.0,1.5);\n          \tcol *= 1.0 + 0.2*cos(cma.y*23.0+vec3(0,0.2,0.5));\n            \n            float g = 0.5 + 0.5*fbm1(iChannel0,0.21*pos);\n            g -= 0.8*nor.x*nor.x;\n            snow *= smoothstep(0.2,0.6,g);\n        }\n        \/\/ forest\n        else if( tm.y<3.5 )\n        {\n            col = vec3(0.2,0.1,0.02)*0.7;\n            focc = cma.y*(0.7+0.3*nor.y);\n            occs = 100.0;\n        }\n        \/\/ ground\n        else if( tm.y<4.5 )\n        {\n            col = vec3(0.7,0.3,0.1)*0.12;\n            float d = smoothstep(1.0,6.0,pos.y-(-36.0));\n            col *= 0.2+0.8*d;\n            occs = 100.0;\n            snow = 1.0;\n        }\n\n        float fre = clamp(1.0+dot(nor,rd),0.0,1.0);\n        float occ = focc*calcOcclusion( pos, nor, time, occs, px );\n\n        snow *= smoothstep(0.25,0.3,nor.y);\n        if( abs(tm.y-2.0)<0.5 )\n        {\n            snow = max(snow,clamp(1.0-occ*occ*3.5,0.0,1.0));\n            snow = max(snow,cma.x);\n        }\n\n        col = mix( col, vec3(0.7,0.75,0.8)*0.6, snow);\n\t\t\n\t\t\n    \t\/\/ --------------------------\n        \/\/ lighting\n    \t\/\/ --------------------------\n        vec3 lin = vec3(0.0);\n\n        vec3  lig = normalize(vec3(0.5,0.4,0.6));\n        vec3  hal = normalize(lig-rd);\n        float dif = clamp(dot(nor,lig), 0.0, 1.0 );\n        \/\/float sha = 0.0; if( dif>0.001 ) sha=calcSoftshadow( pos, lig, 0.001, 500.0, time, 8.0 );\n        float sha = calcSoftshadow( pos, lig, 0.001, 500.0, time, 8.0 );\n        dif *= sha;\n        float spe = ks*pow(clamp(dot(nor,hal),0.0,1.0),se)*dif*(0.04+0.96*pow(clamp(1.0+dot(hal,rd),0.0,1.0),5.0));\n        vec3  amb = occ*vec3(0.55+0.45*nor.y);\n\n        lin += col*vec3(0.4,0.7,1.1)*amb;\n        lin += col*1.4*vec3(2.3,1.5,1.1)*dif;\n        lin += spe*2.0;\n        lin += snow*vec3(0.21,0.35,0.7)*fre*fre*fre*(0.5+0.5*dif*amb)*focc;\n\n        #if 1\n        if( abs(tm.y-2.0)<0.5 )\n        {\n\t\t\tfloat dif = max(0.2+0.8*dot(nor,vec3(-1,-0.3,0)),0.0);\n\t\t\tlin += col*vec3(0.58,0.29,0.14)*dif;\n        }\n\t\t#endif\n\t\tcol = lin;\n\n        col = mix( col, vec3(0.3,0.5,1.0)*0.25, 1.0-exp2(-0.0003*tmin) );\n    }\n\n    \/\/ sun flow\n    float glow = max(dot(rd,vec3(0.5,0.4,0.2)),0.0);\n    glow *= glow;\n    col += vec3(6.0,4.0,3.6)*glow*glow;\n\n    return vec4(col,tmin);\n}\n    \n\/\/ The main rendering entry point. Basically it does some\n\/\/ setup or creating the ray that will explore the 3D\n\/\/ scene in search of the landscape for each pixel, does\n\/\/ the rendering of the landscape, and performs the\n\/\/ Temporal Antialiasing before spiting out the color (in\n\/\/ linear space, not gama) and the deph of the scene.\n\/\/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ render\n    vec2 o = hash3( uint(iFrame) ).xy - 0.5;\n    vec2 p = (2.0*(fragCoord+o)-iResolution.xy)\/iResolution.y;\n        \n    float time = 2.0 + iTime;\n    \n    \/\/ skip pixels behind girl\n    #if 1\n    if( length((p-vec2(-0.56, 0.2))\/vec2(0.78,1.0))<0.85 ||\n        length((p-vec2(-0.56,-0.4))\/vec2(1.00,1.0))<0.73)\n    {\n        fragColor = vec4( 0.55,0.55,0.65,1e20 ); return;\n    }\n    #endif\n\n    \/\/ camera movement\t\n    vec3 ro; float fl;\n    mat3 ca = calcCamera( time, ro, fl );\n    vec3 rd = ca * normalize( vec3((p-vec2(-0.52,0.12))\/1.1,fl));\n\n    vec4 tmp = renderBackground(p,ro,rd,time,fragCoord);\n    vec3 col = tmp.xyz;\n\n    \/\/---------------------------------------------------------------\n\t\/\/ reproject from previous frame and average (cheap TAA, kind of)\n    \/\/---------------------------------------------------------------\n    \n    mat4 oldCam = mat4( textureLod(iChannel1,vec2(0.5,0.5)\/iResolution.xy, 0.0),\n                        textureLod(iChannel1,vec2(1.5,0.5)\/iResolution.xy, 0.0),\n                        textureLod(iChannel1,vec2(2.5,0.5)\/iResolution.xy, 0.0),\n                        0.0, 0.0, 0.0, 1.0 );\n    bool oldStarted = textureLod(iChannel1,vec2(3.5,0.5)\/iResolution.xy, 0.0).x>0.5;\n    \n    \/\/ world space\n    vec4 wpos = vec4(ro + rd*tmp.w,1.0);\n    \/\/ camera space\n    vec3 cpos = (wpos*oldCam).xyz; \/\/ note inverse multiply\n    \/\/ ndc space\n    vec2 npos = fl * cpos.xy \/ cpos.z;\n    \/\/ undo composition hack\n    npos = npos*1.1+vec2(-0.52,0.12); \n    \/\/ screen space\n    vec2 spos = 0.5 + 0.5*npos*vec2(iResolution.y\/iResolution.x,1.0);\n    \/\/ undo dither\n    spos -= o\/iResolution.xy;\n\t\/\/ raster space\n    vec2 rpos = spos * iResolution.xy;\n    \n    if( rpos.y<1.0 && rpos.x<4.0 )\n    {\n    }\n\telse\n    {\n        vec3 ocol = textureLod( iChannel1, spos, 0.0 ).xyz;\n    \tif( !oldStarted ) ocol = col;\n        col = mix( ocol, col, 0.1 );\n    }\n\n    \/\/----------------------------------\n    bool started = textureSize(iChannel0,0).x>=2 &&\n                   textureSize(iChannel2,0).x>=2 &&\n                   textureSize(iChannel3,0).x>=2;\n                           \n\tif( fragCoord.y<1.0 && fragCoord.x<4.0 )\n    {\n        if( abs(fragCoord.x-3.5)<0.5 ) fragColor = vec4( started?1.0:0.0, 0.0, 0.0, 0.0 );\n        if( abs(fragCoord.x-2.5)<0.5 ) fragColor = vec4( ca[2], -dot(ca[2],ro) );\n        if( abs(fragCoord.x-1.5)<0.5 ) fragColor = vec4( ca[1], -dot(ca[1],ro) );\n        if( abs(fragCoord.x-0.5)<0.5 ) fragColor = vec4( ca[0], -dot(ca[0],ro) );\n    }\n    else\n    {\n        fragColor = vec4( col, tmp.w );\n    }\n    \n    if( !started ) fragColor = vec4(0.0);\n}",
                "name": "Buffer A",
                "description": "",
                "type": "buffer"
            },
            {
                "inputs": [
                    {
                        "id": "4dXGR8",
                        "filepath": "\/media\/previz\/buffer00.png",
                        "previewfilepath": "\/media\/previz\/buffer00.png",
                        "type": "buffer",
                        "channel": 0,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "XsXGR8",
                        "channel": 0
                    }
                ],
                "code": "\/\/ Depth of Field (depth defocus) on the background. It's a basic\n\/\/ gather approach, where each pixel's neighborhood gets scanned\n\/\/ and the Circle of Confusion computed for each one of those\n\/\/ neighbor pixels. If the distance to the pixel is smaller than\n\/\/ the Circle of Confusion, the current pixel gets a contribution\n\/\/ from it with a weight that is inversely proportional to the\n\/\/ area of the Circle of Confusion, to conserve energy.\n\/\/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec4 ref = texelFetch( iChannel0, ivec2(fragCoord),0);\n    \n    vec2 q = fragCoord\/iResolution.xy;\n\n    vec4 acc = vec4(0.0);\n    const int N = 9;\n\tfor( int j=-N; j<=N; j++ )\n    for( int i=-N; i<=N; i++ )\n    {\n        vec2 off = vec2(float(i),float(j));\n        \n        vec4 tmp = texture( iChannel0, q + off\/vec2(1280.0,720.0) ); \n\n        float coc = 0.01 + 9.0*(1.0-1.0\/(1.0+0.01*abs(tmp.w)));\n        \n        if( dot(off,off) < coc*coc )\n        {\n            float w = 1.0\/(coc*coc); \n            acc += vec4(tmp.xyz*w,w);\n        }\n    }\n    vec3 col = acc.xyz \/ acc.w;\n\n    fragColor = vec4(col,ref.w);\n}\n",
                "name": "Buffer B",
                "description": "",
                "type": "buffer"
            }
        ]
    },
    {
        "ver": "0.1",
        "info": {
            "id": "MsXGWr",
            "date": "1367548764",
            "viewed": 118650,
            "name": "Mike",
            "username": "iq",
            "description": "Raymarching (a simplified version of) Mike's procedural distance field. Modeling and shading are pretty arbitrary, and made after the first picture you get in google image when you type his name. You can see him in 3D if you uncomment line 9.",
            "likes": 134,
            "published": 3,
            "flags": 0,
            "usePreview": 0,
            "tags": []
        },
        "renderpass": [
            {
                "inputs": [
                    {
                        "id": "XdXGzn",
                        "filepath": "\/media\/a\/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png",
                        "previewfilepath": "\/media\/ap\/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png",
                        "type": "texture",
                        "channel": 0,
                        "sampler": {
                            "filter": "mipmap",
                            "wrap": "repeat",
                            "vflip": "false",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "4dfGRr",
                        "channel": 0
                    }
                ],
                "code": "\/\/ Copyright Inigo Quilez, 2013 - https:\/\/iquilezles.org\/\n\/\/ I am the sole copyright owner of this Work.\n\/\/ You cannot host, display, distribute or share this Work in any form,\n\/\/ including physical and digital. You cannot use this Work in any\n\/\/ commercial or non-commercial product, website or project. You cannot\n\/\/ sell this Work and you cannot mint an NFTs of it.\n\/\/ I share this Work for educational purposes, and you can link to it,\n\/\/ through an URL, proper attribution and unmodified screenshot, as part\n\/\/ of your educational material. If these conditions are too restrictive\n\/\/ please contact me and we'll definitely work it out.\n\n\n\/\/ Made with love after a famous movie character. Modeling is pretty\n\/\/ arbitrary and was done by visual inspiration from the first picture\n\/\/ you get in google images when you type \"mike wazowski\".\n\n\n\nfloat hash( float n )\n{\n    return fract(sin(n)*158.5453123);\n}\n\nfloat noise( in float x )\n{\n    float p = floor(x);\n    float f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    return mix( hash(p+0.0), hash(p+1.0),f);\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*157.0;\n\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+157.0), hash(n+158.0),f.x),f.y);\n}\n\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.5000*noise( p ); p = m2*p*2.02;\n    f += 0.2500*noise( p ); p = m2*p*2.03;\n    f += 0.1250*noise( p ); p = m2*p*2.01;\n    f += 0.0625*noise( p );\n\n    return f\/0.9375;\n}\n\nvec3 texturize( sampler2D sa, vec3 p, vec3 n )\n{\n\tvec3 x = texture( sa, p.yz ).xyz;\n\tvec3 y = texture( sa, p.zx ).xyz;\n\tvec3 z = texture( sa, p.xy ).xyz;\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\n\/\/----------------------------------------------------------------\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nvec2 sdSegment( in vec3 p, in vec3 a, in vec3 b )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ), h );\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length(p\/r) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/smin\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )\/k;\n    return min( a, b ) - h*h*h*k*(1.0\/6.0);\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n#define ZERO (min(iFrame,0))\n\n\/\/----------------------------------------------------------------\n\nvec2 map( vec3 p )\n{\n\tp.y -= 1.8;\n\tp.x = abs(p.x);\n\n\tvec3 q = p;\n\tq.y -= 0.3*pow(1.0-length(p.xz),1.0)*smoothstep(0.0, 0.2, p.y);\n\tq.y *= 1.05;\n\tq.z *= 1.0 + 0.1*smoothstep( 0.0, 0.5, q.z )*smoothstep( -0.5, 0.5, p.y );\n    float dd = length( (p - vec3(0.0,0.65,0.8))*vec3(1.0,0.75,1.0) );\n\tfloat am = clamp( 4.0*abs(p.y-0.45), 0.0, 1.0 );\n\tfloat fo = -0.03*(1.0-smoothstep( 0.0, 0.04*am, abs(dd-0.42) ))*am;\n    float dd2 = length( (p - vec3(0.0,0.65,0.8))*vec3(1.0,0.25,1.0) );\n\tfloat am2 = clamp( 1.5*(p.y-0.45), 0.0, 1.0 );\n\tfloat fo2 = -0.085*(1.0-smoothstep( 0.0, 0.08*am2, abs(dd2-0.42) ))*am2;\n    q.y += -0.05+0.05*length(q.x);\n\t\n\tfloat d1 = length( q ) - 0.9 + fo + fo2;\n    vec2 res = vec2( d1, 1.0 );\n\n\t\/\/ arms\n\tvec2 h = sdSegment( p, vec3(.83,0.15,0.0), vec3(1.02,-0.6,-.1) );\n\tfloat d2 = h.x - 0.07;\n\tres.x = smin( res.x, d2, 0.03 );\n\th = sdSegment( p, vec3(1.02,-0.6,-.1), vec3(0.95,-1.2,0.1) );\n\td2 = h.x - 0.07 + h.y*0.02;\n\tres.x = smin( res.x, d2, 0.02 );\n\t\n\t\/\/ hands\n\tif( p.y<-1.0 )\n\t{\n    float fa = sin(3.0*iTime);\n\th = sdSegment( p, vec3(0.95,-1.2,0.1), vec3(0.97,-1.5,0.0) );\n\td2 = h.x - 0.03;\n\tres.x = smin( res.x, d2, 0.01 );\n\th = sdSegment( p, vec3(0.97,-1.5,0.0), vec3(0.95,-1.7,0.0)-0.01*fa );\n\td2 = h.x - 0.03 + 0.01*h.y;\n\tres.x = smin( res.x, d2, 0.02 );\n\th = sdSegment( p, vec3(0.95,-1.2,0.1), vec3(1.05,-1.5,0.1) );\n\td2 = h.x - 0.03;\n\tres.x = smin( res.x, d2, 0.02 );\n\th = sdSegment( p, vec3(1.05,-1.5,0.1), vec3(1.0,-1.75,0.1)-0.01*fa );\n\td2 = h.x - 0.03 + 0.01*h.y;\n\tres.x = smin( res.x, d2, 0.02 );\n\th = sdSegment( p, vec3(0.95,-1.2,0.1), vec3(0.98,-1.5,0.2) );\n\td2 = h.x - 0.03;\n\tres.x = smin( res.x, d2, 0.03 );\n\th = sdSegment( p, vec3(0.98,-1.5,0.2), vec3(0.95,-1.7,0.15)-0.01*fa );\n\td2 = h.x - 0.03 + 0.01*h.y;\n\tres.x = smin( res.x, d2, 0.03 );\n\th = sdSegment( p, vec3(0.95,-1.2,0.1), vec3(0.85,-1.4,0.2) );\n\td2 = h.x - 0.04 + 0.01*h.y;\n\tres.x = smin( res.x, d2, 0.05 );\n\th = sdSegment( p, vec3(0.85,-1.4,0.2), vec3(0.85,-1.63,0.15)+0.01*fa );\n\td2 = h.x - 0.03 + 0.01*h.y;\n\tres.x = smin( res.x, d2, 0.03 );\n\t}\n\t\n\t\/\/ legs\n\tif( p.y<0.0 )\n\t{\n\th = sdSegment( p, vec3(0.5,-0.5,0.0), vec3(0.6,-1.2,0.1) );\n\td2 = h.x - 0.14 + h.y*0.08;\n\tres.x = smin( res.x, d2, 0.06 );\n\th = sdSegment( p, vec3(0.6,-1.2,0.1), vec3(0.5,-1.8,0.0) );\n\td2 = h.x - 0.06;\n\tres.x = smin( res.x, d2, 0.06 );\n\t}\n\n    \/\/ feet\n\tif( p.y<-0.5 )\n\t{\n\th = sdSegment( p, vec3(0.5,-1.8,0.0), vec3(0.6,-1.8,0.4) );\n\td2 = h.x - 0.09 + 0.02*h.y;\n\tres.x = smin( res.x, d2, 0.06 );\n\th = sdSegment( p, vec3(0.5,-1.8,0.0), vec3(0.77,-1.8,0.35) );\n\td2 = h.x - 0.08 + 0.02*h.y;\n\tres.x = smin( res.x, d2, 0.06 );\n\th = sdSegment( p, vec3(0.5,-1.8,0.0), vec3(0.9,-1.8,0.2) );\n\td2 = h.x - 0.07 + 0.02*h.y;\n\tres.x = smin( res.x, d2, 0.06 );\n\t}\n\t\n\t\/\/ horns\n\tvec3 hp = p - vec3(0.25,0.7,0.0);\n    hp.xy = mat2(0.6,0.8,-0.8,0.6)*hp.xy;\n    hp.x += 0.8*hp.y*hp.y;\n    float d4 = sdEllipsoid( hp, vec3(0.13,0.5,0.16) );\n\tif( d4<res.x ) res = vec2( d4, 3.0 );\n    \n\t\/\/ eyes\n\tfloat d3 = length( (p - vec3(0.0,0.25,0.35))*vec3(1.0,0.8,1.0) ) - 0.5;\n\tif( d3<res.x ) res = vec2( d3, 2.0 );\n\n\t\/\/ mouth\n\tfloat mo = length( (q-vec3(0.0,-0.35,1.0))*vec3(1.0,1.2,0.25)\/1.2 ) -0.3\/1.2;\n\tfloat of = 0.1*pow(smoothstep( 0.0, 0.2, abs(p.x-0.3) ),0.5);\n\tmo = max( mo, -q.y-0.35-of );\n\n\tfloat li = smoothstep( 0.0, 0.05, mo+0.02 ) - smoothstep( 0.05, 0.10, mo+0.02 );\n\tres.x -= 0.03*li*clamp( (-q.y-0.4)*10.0, 0.0, 1.0 );\n\t\n\tif( -mo > res.x )\n\t\tres = vec2( -mo, 4.0 );\n\n    res.x += 0.01*(smoothstep( 0.0, 0.05, mo+0.062 ) - smoothstep( 0.05, 0.10, mo+0.062 ));\n\n    \/\/ teeth\t\n\tif( p.x<0.3 )\n\t{\n    p.x = mod( p.x, 0.16 )-0.08;\t\n    float d5 = length( (p-vec3(0.0,-0.37,0.65))*vec3(1.0,2.0,1.0))-0.08;\n\tif( d5<res.x )\n\t\tres = vec2( d5, 2.0 );\n\t}\n\t\n\treturn vec2(res.x*0.8,res.y);\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n#if 0    \n    vec3 eps = vec3(0.002,0.0,0.0);\n\treturn normalize( vec3(\n           map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n           map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\n#else\n    \/\/ inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.002*e).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n    float m = -1.0;\n\tfloat mint = 10.0;\n\n    \/\/ floor\t\n\tfloat tf = (0.0-ro.y)\/rd.y;\n\tif( tf>0.0 ) { mint = tf; m = 0.0; }\n\t\n\t\/\/ mike\n\tfloat maxd = min(5.0,mint);\n\tfloat precis = 0.001;\n    float t = 0.0;\n\tfloat d = 0.0;\n    for( int i=ZERO; i<128; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        float h = res.x;\n\t\td = res.y;\n        if( h<precis||t>maxd ) break;\n        t += h;\n    }\n\n    if( t<maxd && t<mint )\n\t{\n\t\tmint = t;\n\t\tm = d;\n\t}\n\n    return vec3( mint, m, m );\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/rmshadows\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<50; i++ )\n    {\n        float h = map(ro + rd*t).x;\n        res = min( res, smoothstep(0.0,1.0,k*h\/t) );\n\t\tt += clamp( h, 0.01, 0.25 );\n\t\tif( res<0.005 || t>10.0 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\n\nconst vec3 lig = normalize(vec3(1.0,0.7,0.9));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)\/iResolution.y;\n    \n    \/\/-----------------------------------------------------\n    \/\/ camera\n    \/\/-----------------------------------------------------\n\t\n\tfloat an = sin(-0.25 + 0.31416*iTime);\n\tvec3 ro = vec3(3.5*sin(an),1.8,3.5*cos(an));\n    vec3 ta = vec3(0.0,1.5,0.0);\n\n    \/\/ camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n\t\/\/ create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n    \/\/-----------------------------------------------------\n\t\/\/ render\n    \/\/-----------------------------------------------------\n\n\tvec3 col = vec3(1.0);\n\n\t\/\/ raymarch\n    vec3 tmat = intersect(ro,rd);\n    if( tmat.z>-0.5 )\n    {\n        \/\/ geometry\n        vec3 pos = ro + tmat.x*rd;\n        vec3 nor = calcNormal(pos);\n\t\tvec3 ref = reflect( rd, nor );\n\n        \/\/ materials\n\t\tvec4 mate = vec4(0.0);\n\t\tvec2 mate2 = vec2(1.0,1.0);\n\t\tif( tmat.z<0.5 )\n\t\t{\n\t\t\tnor = vec3(0.0,1.0,0.0);\n\t\t    ref = reflect( rd, nor );\n\t\t\tmate.xyz = vec3(1.0);\n            mate2.y = 1.0 - 0.9*(2.0\/(2.0+dot(pos.xz,pos.xz)));\n\t\t}\n\t\telse if( tmat.z<1.5 )\n\t\t{\n            mate2.x = 4.0;\n\t\t\tmate = vec4(0.16,0.32,0.0,0.8);\n\n            float f = texturize( iChannel0, 0.15*pos, nor ).x * texturize( iChannel0, 0.2*0.25*pos, nor ).x;\n\t\t\tmate.xyz = mix( 0.56*mate.xyz, vec3(0.21,0.28,0.0), f );\n\n\t\t\tf = texturize( iChannel0, pos, nor ).x * texturize( iChannel0, 0.25*pos, nor ).x;\n\t\t\tf = f*f;\n\t\t    mate.xyz = mix( mate.xyz, vec3(0.21,0.28,0.0), 0.6*f );\n\n\t\t\tvec3 bnor = -1.0+2.0*texturize( iChannel0, 4.0*pos, nor );\n\t\t\tnor = normalize( nor + 0.15*bnor );\n\t\t}\n\t\telse if( tmat.z<2.5 )\n\t\t{\n\t\t\tvec3 q = pos-vec3(0.0,1.8,0.0) - vec3(0.0,0.44,0.35);\n\n\t\t\tfloat an2 = an + 0.015*(-1.0+2.0*noise( 6.0*iTime ));\n            vec3 oq = q;\t\t\t\n\t\t\tq.x += -2.0*0.15*clamp(sin(an2),-0.42,0.42);\n\t\t\tfloat f = length( q.xy );\n\t\t\t\n\t\t\tmate2.y = 1.0-smoothstep(0.24,0.35,length( oq.xy-vec2(0.0,0.035) ));\n\t\t\tmate = vec4(0.5,0.5,0.5,1.0);\n\t\t\tmate.xyz = mix( mate.xyz, vec3(0.6,0.4,0.3), 0.5*smoothstep(0.1,0.4,f) );\n\t\t\t\n            vec3 c1 = vec3(0.0,0.15,0.05)*(1.0-0.85*f\/0.19);\n\t\t\tfloat a = atan(q.y,-q.x);\n            float te = fbm( 20.0*vec2(0.3*a,1.0*f) );\n\t\t\tc1 *= 0.3 + 5.0*te;\n            \n            c1 += vec3(0.5,1.0,0.1)*0.35*(0.5+te)*\n                (1.0-smoothstep( 0.3,1.2,abs(a+0.5)))*\n                (1.0-smoothstep( 0.0, 0.06, abs(f-0.125) ));\n            \n\t\t\tmate.xyz = mix( mate.xyz, c1, 1.0-smoothstep( 0.18, 0.19, f ) );\n\n\t\t\toq.x += -2.0*0.19*clamp(sin(an2),-0.42,0.42);\n\t\t\tf = length( oq.xy );\n\t\t\tmate.xyz *= smoothstep( 0.07, 0.10, f );\n            mate.xyz *= 1.0-0.2*vec3(0.5,0.9,1.0)*smoothstep( 0.2, 0.4, f );\n            \n\t\t\tmate.w = 2.0;\n            mate2.x = 64.0;\n\t\t}\n\t\telse if( tmat.z<3.5 )\n\t\t{\n\t\t\tmate = 0.8*vec4(0.85,0.7,0.6,0.0);\n            mate2.x = 0.0;\n\t\t\tfloat f = smoothstep( 0.0, 0.1, 0.5*abs(pos.x)+pos.y-3.02 );\n\t\t\tmate.xyz *= 1.0 - 0.8*vec3( f );\n\t\t\tmate.xyz *= 0.2 + 0.8*smoothstep( 0.0, 1.0, texturize( iChannel0, 0.1*2.1*pos*vec3(4.0,0.1,4.0), nor ).x );\n\t\t}\n\t\telse if( tmat.z<4.5 )\n\t\t{\n\t\t\tfloat z = smoothstep( 0.0, 2.0, pos.z+0.5 );\n\t\t\tmate = 0.5*vec4(0.5,0.25,0.1,0.0);\n\t\t\tmate.x += 0.1*(1.0-z);\n\t\t\tmate2.y = z;\n\t\t}\n\n\t\t\/\/ lighting\n\t\tfloat occ = (0.5 + 0.5*nor.y)*mate2.y;\n        float amb = 0.5;\n\t\tfloat bou = clamp(-nor.y,0.0,1.0);\n\t\tfloat dif = max(dot(nor,lig),0.0);\n        float bac = max(0.3 + 0.7*dot(nor,-lig),0.0);\n\t\tfloat sha = 0.0; if( dif>0.01 ) sha=softshadow( pos+0.01*nor, lig, 0.001, 32.0 );\n        float fre = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 2.0 );\n        vec3  hal = normalize(lig-rd);\n        float spe = max(pow( clamp( dot(nor,hal), 0.0, 1.0), mate2.x*4.0 ),0.0 );\n\t\t\n\t\t\/\/ lights\n\t\tvec3 lin = vec3(0.0);\n        lin += 2.0*dif*vec3(1.00,1.00,1.00)*pow(vec3(sha),vec3(1.0,1.2,1.5));\n\t\tlin += 1.0*amb*vec3(0.30,0.30,0.30)*occ;\n\t\tlin += 2.0*bou*vec3(0.40,0.40,0.40)*mate2.y;\n\t\tlin += 4.0*bac*vec3(0.40,0.30,0.25)*occ;\n        lin += 1.0*fre*vec3(1.00,1.00,1.00)*2.0*mate.w*(0.5+0.5*dif*sha)*occ;\n\t\tcol = mate.xyz*lin;\n\t\tcol += 4.0*spe*vec3(2.0)*mate.w*dif*sha*(0.04+0.96*pow(clamp(1.0+dot(hal,rd),0.0,1.0),5.0));\n\t}\n\n\t\/\/-----------------------------------------------------\n\t\/\/ postprocessing\n    \/\/-----------------------------------------------------\n    \/\/ gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.45) );\n\n\t\/\/ vigneting\n\tvec2 q = fragCoord \/ iResolution.xy;\n    col *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.25 );\n\t   \n    fragColor = vec4( col, 1.0 );\n}\n",
                "name": "Image",
                "description": "",
                "type": "image"
            }
        ]
    },
    {
        "ver": "0.1",
        "info": {
            "id": "Msl3Rr",
            "date": "1362385890",
            "viewed": 91185,
            "name": "Cubescape",
            "username": "iq",
            "description": "Pulsating rounded cubes. Mixes raytracing in a (2D) grid and raymarching within a cell.",
            "likes": 548,
            "published": 3,
            "flags": 1,
            "usePreview": 1,
            "tags": []
        },
        "renderpass": [
            {
                "inputs": [
                    {
                        "id": "XsfGRn",
                        "filepath": "\/media\/a\/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg",
                        "previewfilepath": "\/media\/ap\/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg",
                        "type": "texture",
                        "channel": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "wrap": "repeat",
                            "vflip": "false",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    },
                    {
                        "id": "XsXGzn",
                        "filepath": "\/media\/a\/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3",
                        "previewfilepath": "\/media\/ap\/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3",
                        "type": "music",
                        "channel": 0,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "4dfGRr",
                        "channel": 0
                    }
                ],
                "code": "\/\/ Copyright Inigo Quilez, 2013 - https:\/\/iquilezles.org\/\n\/\/ I am the sole copyright owner of this Work.\n\/\/ You cannot host, display, distribute or share this Work in any form,\n\/\/ including physical and digital. You cannot use this Work in any\n\/\/ commercial or non-commercial product, website or project. You cannot\n\/\/ sell this Work and you cannot mint an NFTs of it.\n\/\/ I share this Work for educational purposes, and you can link to it,\n\/\/ through an URL, proper attribution and unmodified screenshot, as part\n\/\/ of your educational material. If these conditions are too restrictive\n\/\/ please contact me and we'll definitely work it out.\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2   \/\/ make this 2 or 3 for antialiasing\n#endif\n\nfloat hash( float n ) { return fract(sin(n)*13.5453123); }\n\nfloat maxcomp( in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\nfloat udBox( vec3 p, vec3 b, float r )\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n )\n{\n    vec3 a = n*n;\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.yx );\n\treturn (x*a.x + y*a.y + z*a.z) \/ (a.x + a.y + a.z);\n}\n\n\/\/---------------------------------\n\nfloat freqs[4];\n\nvec3 mapH( in vec2 pos )\n{\n\tvec2 fpos = fract( pos ); \n\tvec2 ipos = floor( pos );\n\t\n    float f = 0.0;\t\n\tfloat id = hash( ipos.x + ipos.y*57.0 );\n\tf += freqs[0] * clamp(1.0 - abs(id-0.20)\/0.30, 0.0, 1.0 );\n\tf += freqs[1] * clamp(1.0 - abs(id-0.40)\/0.30, 0.0, 1.0 );\n\tf += freqs[2] * clamp(1.0 - abs(id-0.60)\/0.30, 0.0, 1.0 );\n\tf += freqs[3] * clamp(1.0 - abs(id-0.80)\/0.30, 0.0, 1.0 );\n\n    f = pow( clamp( f, 0.0, 1.0 ), 2.0 );\n    float h = 2.5*f;\n\n    return vec3( h, id, f );\n}\n\nvec3 map( in vec3 pos )\n{\n\tvec2  p = fract( pos.xz ); \n    vec3  m = mapH( pos.xz );\n\tfloat d = udBox( vec3(p.x-0.5,pos.y-0.5*m.x,p.y-0.5), vec3(0.3,m.x*0.5,0.3), 0.1 );\n    return vec3( d, m.yz );\n}\n\nconst float surface = 0.001;\n\nvec3 trace( vec3 ro, in vec3 rd, in float tmin, in float tmax )\n{\n    ro += tmin*rd;\n    \n\tvec2 pos = floor(ro.xz);\n    vec3 rdi = 1.0\/rd;\n    vec3 rda = abs(rdi);\n\tvec2 rds = sign(rd.xz);\n\tvec2 dis = (pos-ro.xz+ 0.5 + rds*0.5) * rdi.xz;\n\t\n\tvec3 res = vec3( -1.0 );\n\n    \/\/ traverse regular grid (in 2D)\n\tvec2 mm = vec2(0.0);\n\tfor( int i=0; i<28; i++ ) \n\t{\n        vec3 cub = mapH( pos );\n\n        #if 1\n            vec2 pr = pos+0.5-ro.xz;\n\t\t\tvec2 mini = (pr-0.5*rds)*rdi.xz;\n\t        float s = max( mini.x, mini.y );\n            if( (tmin+s)>tmax ) break;\n        #endif\n        \n        \/\/ intersect box\n\t\tvec3  ce = vec3( pos.x+0.5, 0.5*cub.x, pos.y+0.5 );\n        vec3  rb = vec3(0.3,cub.x*0.5,0.3);\n        vec3  ra = rb + 0.12;\n\t\tvec3  rc = ro - ce;\n        float tN = maxcomp( -rdi*rc - rda*ra );\n        float tF = maxcomp( -rdi*rc + rda*ra );\n        if( tN < tF )\/\/&& tF > 0.0 )\n        {\n            \/\/ raymarch\n            float s = tN;\n            float h = 1.0;\n            for( int j=0; j<24; j++ )\n            {\n                h = udBox( rc+s*rd, rb, 0.1 ); \n                s += h;\n                if( s>tF ) break;\n            }\n\n            if( h < (surface*s*2.0) )\n            {\n                res = vec3( s, cub.yz );\n                break; \n            }\n            \n\t\t}\n\n        \/\/ step to next cell\t\t\n\t\tmm = step( dis.xy, dis.yx ); \n\t\tdis += mm*rda.xz;\n        pos += mm*rds;\n\t}\n\n    res.x += tmin;\n    \n\treturn res;\n}\n\nfloat usmoothstep( in float x )\n{\n    x = clamp(x,0.0,1.0);\n    return x*x*(3.0-2.0*x);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<50; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        res = min( res, usmoothstep(k*h\/t) );\n        t += clamp( h, 0.05, 0.2 );\n        if( res<0.001 || t>maxt ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos, in float t )\n{\n    vec2 e = vec2(1.0,-1.0)*surface*t;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nconst vec3 light1 = vec3(  0.70, 0.52, -0.45 );\nconst vec3 light2 = vec3( -0.71, 0.000,  0.71 );\nconst vec3 lpos = vec3(0.0) + 6.0*light1;\n\nvec2 boundingVolume( vec2 tminmax, in vec3 ro, in vec3 rd )\n{\n    float bp = 2.7;\n    float tp = (bp-ro.y)\/rd.y;\n    if( tp>0.0 ) \n    {\n        if( ro.y>bp ) tminmax.x = max( tminmax.x, tp );\n        else          tminmax.y = min( tminmax.y, tp );\n    }\n    bp = 0.0;\n    tp = (bp-ro.y)\/rd.y;\n    if( tp>0.0 ) \n    {\n        if( ro.y>bp ) tminmax.y = min( tminmax.y, tp );\n    }\n    return tminmax;\n}\n\nvec3 doLighting( in vec3 col, in float ks,\n                 in vec3 pos, in vec3 nor, in vec3 rd )\n{\n    vec3  ldif = lpos - pos;\n    float llen = length( ldif );\n    ldif \/= llen;\n\tfloat con = dot( light1,ldif);\n\tfloat occ = mix( clamp( pos.y\/4.0, 0.0, 1.0 ), 1.0, 0.2*max(0.0,nor.y) );\n    vec2 sminmax = vec2(0.01, 5.0);\n\n    float sha = softshadow( pos, ldif, sminmax.x, sminmax.y, 32.0 );;\n\t\t\n    float bb = smoothstep( 0.5, 0.8, con );\n    float lkey = clamp( dot(nor,ldif), 0.0, 1.0 );\n\tvec3  lkat = vec3(1.0);\n          lkat *= vec3(bb*bb*0.6+0.4*bb,bb*0.5+0.5*bb*bb,bb).zyx;\n          lkat \/= 1.0+0.25*llen*llen;\t\t\n\t\t  lkat *= 30.0;\n          \/\/lkat *= sha;\n          lkat *= vec3(sha,0.6*sha+0.4*sha*sha,0.3*sha+0.7*sha*sha);\n    \n    float lbac = clamp( 0.5 + 0.5*dot( light2, nor ), 0.0, 1.0 );\n          lbac *= smoothstep( 0.0, 0.8, con );\n\t\t  lbac \/= 1.0+0.2*llen*llen;\t\t\n\t\t  lbac *= 7.0;\n\tfloat lamb = 1.0 - 0.5*nor.y;\n          lamb *= 1.0-smoothstep( 10.0, 25.0, length(pos.xz) );\n\t\t  lamb *= 0.25 + 0.75*smoothstep( 0.0, 0.8, con );\n\t\t  lamb *= 0.25;\n\n    vec3 lin  = 1.0*vec3(1.60,0.70,0.30)*lkey*lkat*(0.5+0.5*occ);\n         lin += 1.0*vec3(0.20,0.05,0.02)*lamb*occ*occ;\n         lin += 1.0*vec3(0.70,0.20,0.08)*lbac*occ*occ;\n         lin *= vec3(1.3,1.1,1.0);\n    \n    col = col*lin;\n\n    vec3 hal = normalize(ldif-rd);\n    vec3 spe = lkey*lkat*(0.5+0.5*occ)*5.0*\n               pow( clamp(dot(hal, nor),0.0,1.0), 6.0+6.0*ks ) * \n               (0.04+0.96*pow(clamp(1.0-dot(hal,ldif),0.0,1.0),5.0));\n\n    col += (0.4+0.6*ks)*spe*vec3(0.8,0.9,1.0);\n\n    col = 1.4*col\/(1.0+col);\n    \n    return col;\n}\n\nmat3 setLookAt( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3  cw = normalize(ta-ro);\n\tvec3  cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3  cu = normalize( cross(cw,cp) );\n\tvec3  cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    vec3 col = vec3( 0.0 );\n\n    vec2 tminmax = vec2(0.0, 40.0 );\n\n    tminmax = boundingVolume( tminmax, ro, rd );\n\n    \/\/ raytrace\n    vec3 res = trace( ro, rd, tminmax.x, tminmax.y );\n    if( res.y > -0.5 )\n    {\n        float t = res.x;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, t );\n\n        \/\/ material\t\n        col = 0.5 + 0.5*cos( 6.2831*res.y + vec3(0.0, 0.4, 0.8) );\n        vec3 ff = texcube( iChannel1, 0.21*vec3(pos.x,4.0*res.z-pos.y,pos.z), nor ).xyz;\n        ff = pow(ff,vec3(1.3))*1.1;\n        col *= ff.x;\n\n        \/\/ lighting\n        col = doLighting( col, ff.x*ff.x*ff.x*2.0, pos, nor, rd );\n        col *= 1.0 - smoothstep( 20.0, 40.0, t );\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfreqs[0] = texture( iChannel0, vec2( 0.01, 0.25 ) ).x;\n\tfreqs[1] = texture( iChannel0, vec2( 0.07, 0.25 ) ).x;\n\tfreqs[2] = texture( iChannel0, vec2( 0.15, 0.25 ) ).x;\n\tfreqs[3] = texture( iChannel0, vec2( 0.30, 0.25 ) ).x;\n    \/\/-----------\n    float time = 5.0 + 0.2*iTime + 20.0*iMouse.x\/iResolution.x;\n    \n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int j=0; j<AA; j++ )\n    for( int i=0; i<AA; i++ )\n    {\n        vec2 off = vec2(float(i),float(j))\/float(AA);\n    #else\n        vec2 off = vec2(0.0);\n    #endif        \n        vec2 xy = (-iResolution.xy+2.0*(fragCoord+off)) \/ iResolution.y;\n\n        \/\/ camera\t\n        vec3 ro = vec3( 8.5*cos(0.2+.33*time), 5.0+2.0*cos(0.1*time), 8.5*sin(0.1+0.37*time) );\n        vec3 ta = vec3( -2.5+3.0*cos(1.2+.41*time), 0.0, 2.0+3.0*sin(2.0+0.38*time) );\n        float roll = 0.2*sin(0.1*time);\n\n        \/\/ camera tx\n        mat3 ca = setLookAt( ro, ta, roll );\n        vec3 rd = normalize( ca * vec3(xy.xy,1.75) );\n        \n        vec3 col = render( ro, rd );\n        col = pow( col, vec3(0.4545) );\n        col = pow( col, vec3(0.8,0.93,1.0) );\n        \/\/col = clamp(col,0.0,1.0);\n        tot += col;\n        \n    #if AA>1\n    }\n\ttot \/= float(AA*AA);\n    #endif    \n    \n    \/\/ vigneting\n\tvec2 q = fragCoord.xy\/iResolution.xy;\n    tot *= 0.2 + 0.8*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\n    fragColor = vec4( tot, 1.0 );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n\tfreqs[0] = texture( iChannel0, vec2( 0.01, 0.25 ) ).x;\n\tfreqs[1] = texture( iChannel0, vec2( 0.07, 0.25 ) ).x;\n\tfreqs[2] = texture( iChannel0, vec2( 0.15, 0.25 ) ).x;\n\tfreqs[3] = texture( iChannel0, vec2( 0.30, 0.25 ) ).x;\n\n    vec3 col = render( fragRayOri + vec3(0.0,4.0,0.0), fragRayDir );\n\n    col = pow( col, vec3(0.4545) );\n    col = pow( col, vec3(0.8,0.95,1.0) );\n\n    fragColor = vec4( col, 1.0 );\n}",
                "name": "Image",
                "description": "",
                "type": "image"
            }
        ]
    },
    {
        "ver": "0.1",
        "info": {
            "id": "ldl3W8",
            "date": "1369238474",
            "viewed": 89051,
            "name": "Voronoi - distances",
            "username": "iq",
            "description": "Mathematically correct Voronoi cell interior distances and hence correct cell borders. Seems nobody out there is doing this correctly... So here. More info [url=https:\/\/iquilezles.org\/articles\/voronoilines]in this article[\/url]",
            "likes": 454,
            "published": 3,
            "flags": 0,
            "usePreview": 0,
            "tags": []
        },
        "renderpass": [
            {
                "inputs": [
                    {
                        "id": "Xsf3zn",
                        "filepath": "\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
                        "previewfilepath": "\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
                        "type": "texture",
                        "channel": 0,
                        "sampler": {
                            "filter": "nearest",
                            "wrap": "repeat",
                            "vflip": "false",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "4dfGRr",
                        "channel": 0
                    }
                ],
                "code": "\/\/ The MIT License\n\/\/ Copyright \u00a9 2013 Inigo Quilez\n\/\/ https:\/\/www.youtube.com\/c\/InigoQuilez\n\/\/ https:\/\/iquilezles.org\/\n\/\/ Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\/\/ I've not seen anybody out there computing correct cell interior distances for Voronoi\n\/\/ patterns yet. That's why they cannot shade the cell interior correctly, and why you've\n\/\/ never seen cell boundaries rendered correctly. \n\/\/\n\/\/ However, here's how you do mathematically correct distances (note the equidistant and non\n\/\/ degenerated grey isolines inside the cells) and hence edges (in yellow):\n\/\/\n\/\/ https:\/\/iquilezles.org\/articles\/voronoilines\n\/\/\n\/\/ More Voronoi shaders:\n\/\/\n\/\/ Exact edges:  https:\/\/www.shadertoy.com\/view\/ldl3W8\n\/\/ Hierarchical: https:\/\/www.shadertoy.com\/view\/Xll3zX\n\/\/ Smooth:       https:\/\/www.shadertoy.com\/view\/ldB3zc\n\/\/ Voronoise:    https:\/\/www.shadertoy.com\/view\/Xd23Dh\n\n#define ANIMATE\n\nvec2 hash2( vec2 p )\n{\n\t\/\/ texture based white noise\n\treturn textureLod( iChannel0, (p+0.5)\/256.0, 0.0 ).xy;\n\t\n    \/\/ procedural white noise\t\n\t\/\/return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec3 voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    \/\/----------------------------------\n    \/\/ first pass: regular voronoi\n    \/\/----------------------------------\n\tvec2 mg, mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin( iTime + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\n    \/\/----------------------------------\n    \/\/ second pass: distance to borders\n    \/\/----------------------------------\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin( iTime + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec3( md, mr );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord\/iResolution.xx;\n\n    vec3 c = voronoi( 8.0*p );\n\n\t\/\/ isolines\n    vec3 col = c.x*(0.5 + 0.5*sin(64.0*c.x))*vec3(1.0);\n    \/\/ borders\t\n    col = mix( vec3(1.0,0.6,0.0), col, smoothstep( 0.04, 0.07, c.x ) );\n    \/\/ feature points\n\tfloat dd = length( c.yz );\n\tcol = mix( vec3(1.0,0.6,0.1), col, smoothstep( 0.0, 0.12, dd) );\n\tcol += vec3(1.0,0.6,0.1)*(1.0-smoothstep( 0.0, 0.04, dd));\n\n\tfragColor = vec4(col,1.0);\n}\n",
                "name": "Image",
                "description": "",
                "type": "image"
            }
        ]
    },
    {
        "ver": "0.1",
        "info": {
            "id": "MdlGW7",
            "date": "1372661086",
            "viewed": 85268,
            "name": "Cloudy Terrain",
            "username": "iq",
            "description": "A terrain full of trees or something (up to your interpretation). Distance field raymarching for the terrain. Linearly volumetric raymarching for the foliage. Linearly volumetric raymarching for clouds. Plain plane Raytraced for lakes.",
            "likes": 486,
            "published": 3,
            "flags": 32,
            "usePreview": 0,
            "tags": []
        },
        "renderpass": [
            {
                "inputs": [
                    {
                        "id": "4dXGR8",
                        "filepath": "\/media\/previz\/buffer00.png",
                        "previewfilepath": "\/media\/previz\/buffer00.png",
                        "type": "buffer",
                        "channel": 0,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "4dfGRr",
                        "channel": 0
                    }
                ],
                "code": "\/\/ Copyright Inigo Quilez, 2013 - https:\/\/iquilezles.org\/\n\/\/ I am the sole copyright owner of this Work.\n\/\/ You cannot host, display, distribute or share this Work in any form,\n\/\/ including physical and digital. You cannot use this Work in any\n\/\/ commercial or non-commercial product, website or project. You cannot\n\/\/ sell this Work and you cannot mint an NFTs of it.\n\/\/ I share this Work for educational purposes, and you can link to it,\n\/\/ through an URL, proper attribution and unmodified screenshot, as part\n\/\/ of your educational material. If these conditions are too restrictive\n\/\/ please contact me and we'll definitely work it out.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord\/iResolution.xy;\n    vec4 data = texture( iChannel0, uv );\n\n    vec3 col = vec3(0.0);\n    if( data.w < 0.0 )\n    {\n        col = texture( iChannel0, uv ).xyz;\n    }\n    else\n    {\n        \/\/ decompress velocity vector\n        float ss = mod(data.w,256.0)\/255.0;\n        float st = floor(data.w\/256.0)\/255.0;\n\n        \/\/ motion blur (linear blur across velocity vectors\n        vec2 dir = (-1.0 + 2.0*vec2( ss, st ))*0.25;\n        col = vec3(0.0);\n        for( int i=0; i<32; i++ )\n        {\n            float h = float(i)\/31.0;\n            vec2 pos = uv + dir*h;\n            col += texture( iChannel0, pos ).xyz;\n        }\n        col \/= 32.0;\n    }\n    \n    \/\/ vignetting\t\n\tcol *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 );\n\n    fragColor = vec4( col, 1.0 );\n}",
                "name": "Image",
                "description": "",
                "type": "image"
            },
            {
                "inputs": [
                    {
                        "id": "XdX3Rn",
                        "filepath": "\/media\/a\/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg",
                        "previewfilepath": "\/media\/ap\/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg",
                        "type": "texture",
                        "channel": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "wrap": "repeat",
                            "vflip": "false",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    },
                    {
                        "id": "XdXGzn",
                        "filepath": "\/media\/a\/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png",
                        "previewfilepath": "\/media\/ap\/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png",
                        "type": "texture",
                        "channel": 3,
                        "sampler": {
                            "filter": "mipmap",
                            "wrap": "repeat",
                            "vflip": "false",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    },
                    {
                        "id": "4dXGzn",
                        "filepath": "\/media\/a\/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png",
                        "previewfilepath": "\/media\/ap\/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png",
                        "type": "texture",
                        "channel": 0,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "repeat",
                            "vflip": "false",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    },
                    {
                        "id": "4dXGR8",
                        "filepath": "\/media\/previz\/buffer00.png",
                        "previewfilepath": "\/media\/previz\/buffer00.png",
                        "type": "buffer",
                        "channel": 2,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "4dXGR8",
                        "channel": 0
                    }
                ],
                "code": "\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    float a = textureLod( iChannel0, x.xy\/256.0 + (p.z+0.0)*120.7123, 0.0 ).x;\n    float b = textureLod( iChannel0, x.xy\/256.0 + (p.z+1.0)*120.7123, 0.0 ).x;\n\treturn mix( a, b, f.z );\n}\n\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n\nfloat envelope( vec3 p )\n{\n\tfloat isLake = 1.0-smoothstep( 0.62, 0.72, textureLod( iChannel0, 0.001*p.zx, 0.0).x );\n\treturn 0.1 + isLake*0.9*textureLod( iChannel1, 0.01*p.xz, 0.0 ).x;\n}\n\nfloat mapTerrain( in vec3 pos )\n{\n\treturn pos.y - envelope(pos);\n}\n\nfloat raymarchTerrain( in vec3 ro, in vec3 rd )\n{\n\tfloat maxd = 50.0;\n\tfloat precis = 0.001;\n    float h = 1.0;\n    float t = 0.0;\n    for( int i=0; i<80; i++ )\n    {\n        if( abs(h)<precis||t>maxd ) break;\n        t += h;\n\t    h = mapTerrain( ro+rd*t );\n    }\n\n    if( t>maxd ) t=-1.0;\n    return t;\n}\n\nvec3 lig = normalize( vec3(0.7,0.4,0.2) );\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.02,0.0,0.0);\n\treturn normalize( vec3(\n           mapTerrain(pos+eps.xyy) - mapTerrain(pos-eps.xyy),\n           0.5*2.0*eps.x,\n           mapTerrain(pos+eps.yyx) - mapTerrain(pos-eps.yyx) ) );\n\n}\n\nvec4 mapTrees( in vec3 pos, in vec3 rd )\n{\n    vec3  col = vec3(0.0);\t\n\tfloat den = 1.0;\n\n\tfloat kklake = textureLod( iChannel0, 0.001*pos.zx, 0.0).x;\n\tfloat isLake = smoothstep( 0.7, 0.71, kklake );\n\t\n\tif( pos.y>1.0 || pos.y<0.0 ) \n\t{\n\t\tden = 0.0;\n\t}\n\telse\n\t{\n\t\t\n\t\tfloat h = pos.y;\n\t\tfloat e = envelope( pos );\n\t\tfloat r = clamp(h\/e,0.0,1.0);\n\t\t\n        den = smoothstep( r, 1.0, textureLod(iChannel0, pos.xz*0.15, 0.0).x );\n        \n\t\tden *= 1.0-0.95*clamp( (r-0.75)\/(1.0-0.75) ,0.0,1.0);\n\t\t\n        float id = textureLod( iChannel0, pos.xz, 0.0).x;\n        float oc = pow( r, 2.0 );\n\n\t\tvec3  nor = calcNormal( pos );\n\t\tvec3  dif = vec3(1.0)*clamp( dot( nor, lig ), 0.0, 1.0 );\n\t\tfloat amb = 0.5 + 0.5*nor.y;\n\t\t\n\t\tfloat w = (2.8-pos.y)\/lig.y;\n\t\tfloat c = fbm( (pos+w*lig)*0.35 );\n\t\tc = smoothstep( 0.38, 0.6, c );\n\t\tdif *= pow( vec3(c), vec3(0.8, 1.0, 1.5 ) );\n\t\t\t\n\t\tvec3  brdf = 1.7*vec3(1.5,1.0,0.8)*dif*(0.1+0.9*oc) + 1.3*amb*vec3(0.1,0.15,0.2)*oc;\n\n\t\tvec3 mate = 0.6*vec3(0.5,0.5,0.1);\n\t\tmate += 0.3*textureLod( iChannel1, 0.1*pos.xz, 0.0 ).zyx;\n\t\t\n\t\tcol = brdf * mate;\n\n\t\tden *= 1.0-isLake;\n\t}\n\n\treturn vec4( col, den );\n}\n\n\nvec4 raymarchTrees( in vec3 ro, in vec3 rd, float tmax, vec3 bgcol, out float resT )\n{\n\tvec4 sum = vec4(0.0);\n    float t = tmax;\n\tfor( int i=0; i<512; i++ )\n\t{\n\t\tvec3 pos = ro + t*rd;\n\t\tif( sum.a>0.99 || pos.y<0.0  || t>20.0 ) break;\n\t\t\n\t\tvec4 col = mapTrees( pos, rd );\n\n\t\tcol.xyz = mix( col.xyz, bgcol, 1.0-exp(-0.0018*t*t) );\n        \n\t\tcol.rgb *= col.a;\n\n\t\tsum = sum + col*(1.0 - sum.a);\t\n\t\t\n\t\tt += 0.0035*t;\n\t}\n    \n    resT = t;\n\n\treturn clamp( sum, 0.0, 1.0 );\n}\n\nvec4 mapClouds( in vec3 p )\n{\n\tfloat d = 1.0-0.3*abs(2.8 - p.y);\n\td -= 1.6 * fbm( p*0.35 );\n\n\td = clamp( d, 0.0, 1.0 );\n\t\n\tvec4 res = vec4( d );\n\n\tres.xyz = mix( 0.8*vec3(1.0,0.95,0.8), 0.2*vec3(0.6,0.6,0.6), res.x );\n\tres.xyz *= 0.65;\n\t\n\treturn res;\n}\n\n\nvec4 raymarchClouds( in vec3 ro, in vec3 rd, in vec3 bcol, float tmax, out float rays, ivec2 px )\n{\n\tvec4 sum = vec4(0, 0, 0, 0);\n\trays = 0.0;\n    \n\tfloat sun = clamp( dot(rd,lig), 0.0, 1.0 );\n\tfloat t = 0.1*texelFetch( iChannel0, px&ivec2(255), 0 ).x;\n\tfor(int i=0; i<64; i++)\n\t{\n\t\tif( sum.w>0.99 || t>tmax ) break;\n\t\tvec3 pos = ro + t*rd;\n\t\tvec4 col = mapClouds( pos );\n\n\t\tfloat dt = max(0.1,0.05*t);\n\t\tfloat h = (2.8-pos.y)\/lig.y;\n\t\tfloat c = fbm( (pos + lig*h)*0.35 );\n\t\t\/\/kk += 0.05*dt*(smoothstep( 0.38, 0.6, c ))*(1.0-col.a);\n\t\trays += 0.02*(smoothstep( 0.38, 0.6, c ))*(1.0-col.a)*(1.0-smoothstep(2.75,2.8,pos.y));\n\t\n\t\t\n\t\tcol.xyz *= vec3(0.4,0.52,0.6);\n\t\t\n        col.xyz += vec3(1.0,0.7,0.4)*0.4*pow( sun, 6.0 )*(1.0-col.w);\n\t\t\n\t\tcol.xyz = mix( col.xyz, bcol, 1.0-exp(-0.0018*t*t) );\n\t\t\n\t\tcol.a *= 0.5;\n\t\tcol.rgb *= col.a;\n\n\t\tsum = sum + col*(1.0 - sum.a);\t\n\n\t\tt += dt;\/\/max(0.1,0.05*t);\n\t}\n    rays = clamp( rays, 0.0, 1.0 );\n\n\treturn clamp( sum, 0.0, 1.0 );\n}\n\nvec3 path( float time )\n{\n\treturn vec3( 32.0*cos(0.2+0.75*.1*time*1.5), 1.2, 32.0*sin(0.1+0.75*0.11*time*1.5) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid moveCamera( float time, out vec3 oRo, out vec3 oTa, out float oCr, out float oFl )\n{\n    \/\/ camera\t\n\toRo = path( time );\n\toTa = path( time+1.0 );\n\toTa.y *= 0.2;\n\toCr = 0.3*cos(0.07*time);\n    oFl = 1.75;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy \/ iResolution.xy;\n\tvec2 p = -1.0 + 2.0*q;\n\tp.x *= iResolution.x \/ iResolution.y;\n\t\n\tfloat time = 23.5+iTime;\n\t\n    \/\/ camera\t\n\tvec3 ro, ta;\n    float roll, fl;\n    moveCamera( time, ro, ta, roll, fl );\n        \n\t\/\/ camera tx\n    mat3 cam = setCamera( ro, ta, roll );\n\n    \/\/ ray direction\n    vec3 rd = normalize( cam * vec3(p.xy,fl) );\n\n    \/\/ sky\t \n\tvec3 col = vec3(0.84,0.95,1.0)*0.77 - rd.y*0.6;\n\tcol *= 0.75;\n\tfloat sun = clamp( dot(rd,lig), 0.0, 1.0 );\n    col += vec3(1.0,0.7,0.3)*0.3*pow( sun, 6.0 );\n\tvec3 bcol = col;\n\n    \/\/ lakes\n    float gt = (0.0-ro.y)\/rd.y;\n    if( gt>0.0 )\n    {\n        vec3 pos = ro + rd*gt;\n\n\t\tvec3 nor = vec3(0.0,1.0,0.0);\n\t    nor.xz  = 0.10*(-1.0 + 2.0*texture( iChannel3, 1.5*pos.xz ).xz);\n\t    nor.xz += 0.15*(-1.0 + 2.0*texture( iChannel3, 3.2*pos.xz ).xz);\n\t    nor.xz += 0.20*(-1.0 + 2.0*texture( iChannel3, 6.0*pos.xz ).xz);\n\tnor = normalize(nor);\n\n\t\tvec3 ref = reflect( rd, nor );\n\t    vec3 sref = reflect( rd, vec3(0.0,1.0,0.0) );\n\t\tfloat sunr = clamp( dot(ref,lig), 0.0, 1.0 );\n\n\t    float kklake = texture( iChannel0, 0.001*pos.zx).x;\n\t\tcol = vec3(0.1,0.1,0.0);\n        vec3 lcol = vec3(0.2,0.5,0.7);\n\t\tcol = mix( lcol, 1.1*vec3(0.2,0.6,0.7), 1.0-smoothstep(0.7,0.81,kklake) );\n\t\t\n\t\tcol *= 0.12;\n\n\t    float fre = 1.0 - max(sref.y,0.0);\n\t\tcol += 0.8*vec3(1.0,0.9,0.8)*pow( sunr, 64.0 )*pow(fre,1.0);\n\t\tcol += 0.5*vec3(1.0,0.9,0.8)*pow( fre, 10.0 );\n\n\t\tfloat h = (2.8-pos.y)\/lig.y;\n        float c = fbm( (pos+h*lig)*0.35 );\n\t\tcol *= 0.4 + 0.6*smoothstep( 0.38, 0.6, c );\n\n\t    col *= smoothstep(0.7,0.701,kklake);\n\n\t    col.xyz = mix( col.xyz, bcol, 1.0-exp(-0.0018*gt*gt) );\n    }\n\n\n    \/\/ terrain\t\n\tfloat t = raymarchTerrain(ro, rd);\n    if( t>0.0 )\n\t{\n        \/\/ trees\t\t\n        float ot;\n        vec4 res = raymarchTrees( ro, rd, t, bcol, ot );\n        t = ot;\n\t    col = col*(1.0-res.w) + res.xyz;\n\t}\n\n\t\/\/ sun glow\n    col += vec3(1.0,0.5,0.2)*0.35*pow( sun, 3.0 );\n\n    float rays = 0.0;\n    \/\/ clouds\t\n    {\n\tif( t<0.0 ) t=600.0;\n    vec4 res = raymarchClouds( ro, rd, bcol, t, rays, ivec2(fragCoord) );\n\tcol = col*(1.0-res.w) + res.xyz;\n\t}\n\n\tcol += (1.0-0.8*col)*rays*rays*rays*0.4*vec3(1.0,0.8,0.7);\n\tcol = clamp( col, 0.0, 1.0 );\n\n\t\n    \/\/ gamma\t\n\tcol = pow( col, vec3(0.45) );\n\n    \/\/ contrast, desat, tint and vignetting\t\n\tcol = col*0.1 + 0.9*col*col*(3.0-2.0*col);\n\tcol = mix( col, vec3(col.x+col.y+col.z)*0.33, 0.2 );\n\tcol *= vec3(1.06,1.05,1.0);\n\n    \/\/-------------------------------------\n\t\/\/ velocity vectors (through depth reprojection)\n    \/\/-------------------------------------\n    float vel = 0.0;\n    if( t<0.0 )\n    {\n        vel = -1.0;\n    }\n    else\n    {\n\n        \/\/ old camera position\n        float oldTime = time - 1.0\/30.0; \/\/ 1\/30 of a second blur\n        vec3 oldRo, oldTa; float oldCr, oldFl;\n        moveCamera( oldTime, oldRo, oldTa, oldCr, oldFl );\n        mat3 oldCam = setCamera( oldRo, oldTa, oldCr );\n\n        \/\/ world space\n        vec3 wpos = ro + rd*t;\n        \/\/ camera space\n        vec3 cpos = vec3( dot( wpos - oldRo, oldCam[0] ),\n                          dot( wpos - oldRo, oldCam[1] ),\n                          dot( wpos - oldRo, oldCam[2] ) );\n        \/\/ ndc space\n        vec2 npos = oldFl * cpos.xy \/ cpos.z;\n        \/\/ screen space\n        vec2 spos = 0.5 + 0.5*npos*vec2(iResolution.y\/iResolution.x,1.0);\n\n\n        \/\/ compress velocity vector in a single float\n        vec2 uv = fragCoord\/iResolution.xy;\n        spos = clamp( 0.5 + 0.5*(spos - uv)\/0.25, 0.0, 1.0 );\n        vel = floor(spos.x*255.0) + floor(spos.y*255.0)*256.0;\n    }\n    \n    fragColor = vec4( col, vel );\n}",
                "name": "Buffer A",
                "description": "",
                "type": "buffer"
            }
        ]
    },
    {
        "ver": "0.1",
        "info": {
            "id": "ll2GD3",
            "date": "1433235426",
            "viewed": 80109,
            "name": "Palettes",
            "username": "iq",
            "description": "Cosine based palettes (faster than linear interpolation or triangle waves). \nMore info: [url]http:\/\/iquilezles.org\/articles\/palettes[\/url]",
            "likes": 425,
            "published": 3,
            "flags": 0,
            "usePreview": 1,
            "tags": []
        },
        "renderpass": [
            {
                "inputs": [
                    {
                        "id": "Xsf3zn",
                        "filepath": "\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
                        "previewfilepath": "\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
                        "type": "texture",
                        "channel": 0,
                        "sampler": {
                            "filter": "mipmap",
                            "wrap": "repeat",
                            "vflip": "false",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "4dfGRr",
                        "channel": 0
                    }
                ],
                "code": "\/\/ The MIT License\n\/\/ https:\/\/www.youtube.com\/c\/InigoQuilez\n\/\/ https:\/\/iquilezles.org\/\n\/\/ Copyright \u00a9 2015 Inigo Quilez\n\/\/ Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\/\/ A simple way to create color variation in a cheap way (yes, trigonometrics ARE cheap\n\/\/ in the GPU, don't try to be smart and use a triangle wave instead).\n\n\/\/ See https:\/\/iquilezles.org\/articles\/palettes for more information\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy \/ iResolution.xy;\n    \n    \/\/ animate\n    p.x += 0.01*iTime;\n    \n    \/\/ compute colors\n    vec3                col = pal( p.x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n    if( p.y>(1.0\/7.0) ) col = pal( p.x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );\n    if( p.y>(2.0\/7.0) ) col = pal( p.x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.3,0.20,0.20) );\n    if( p.y>(3.0\/7.0) ) col = pal( p.x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n    if( p.y>(4.0\/7.0) ) col = pal( p.x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,0.7,0.4),vec3(0.0,0.15,0.20) );\n    if( p.y>(5.0\/7.0) ) col = pal( p.x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(2.0,1.0,0.0),vec3(0.5,0.20,0.25) );\n    if( p.y>(6.0\/7.0) ) col = pal( p.x, vec3(0.8,0.5,0.4),vec3(0.2,0.4,0.2),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25) );\n    \n\n    \/\/ band\n    float f = fract(p.y*7.0);\n    \/\/ borders\n    col *= smoothstep( 0.49, 0.47, abs(f-0.5) );\n    \/\/ shadowing\n    col *= 0.5 + 0.5*sqrt(4.0*f*(1.0-f));\n    \/\/ dithering\n    col += (1.0\/255.0)*texture( iChannel0, fragCoord.xy\/iChannelResolution[0].xy ).xyz;\n\n\tfragColor = vec4( col, 1.0 );\n}",
                "name": "Image",
                "description": "",
                "type": "image"
            }
        ]
    },
    {
        "ver": "0.1",
        "info": {
            "id": "Xd23Dh",
            "date": "1389822885",
            "viewed": 80049,
            "name": "Voronoise",
            "username": "iq",
            "description": "Patterns such as cell-noise, perlin noise and voronoi can be seen as particular cases of a more general pattern, which I call \"voronoise\". More info [url= http:\/\/iquilezles.org\/articles\/voronoise]in this article[\/url]. ",
            "likes": 302,
            "published": 3,
            "flags": 0,
            "usePreview": 0,
            "tags": []
        },
        "renderpass": [
            {
                "inputs": [],
                "outputs": [
                    {
                        "id": "4dfGRr",
                        "channel": 0
                    }
                ],
                "code": "\/\/ The MIT License\n\/\/ https:\/\/www.youtube.com\/c\/InigoQuilez\n\/\/ https:\/\/iquilezles.org\/\n\/\/ Copyright \u00a9 2014 Inigo Quilez\n\/\/ Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\/\/ This is a procedural pattern that has 2 parameters, that generalizes cell-noise, \n\/\/ perlin-noise and voronoi, all of which can be written in terms of the former as:\n\/\/\n\/\/ cellnoise(x) = pattern(0,0,x)\n\/\/ perlin(x) = pattern(0,1,x)\n\/\/ voronoi(x) = pattern(1,0,x)\n\/\/\n\/\/ From this generalization of the three famouse patterns, a new one (which I call \n\/\/ \"Voronoise\") emerges naturally. It's like perlin noise a bit, but within a jittered \n\/\/ grid like voronoi):\n\/\/\n\/\/ voronoise(x) = pattern(1,1,x)\n\/\/\n\/\/ Not sure what one would use this generalization for, because it's slightly slower \n\/\/ than perlin or voronoise (and certainly much slower than cell noise), and in the \n\/\/ end as a shading TD you just want one or another depending of the type of visual \n\/\/ features you are looking for, I can't see a blending being needed in real life.  \n\/\/ But well, if only for the math fun it was worth trying. And they say a bit of \n\/\/ mathturbation can be healthy anyway!\n\/\/\n\/\/ More info here: https:\/\/iquilezles.org\/articles\/voronoise\n\n\/\/ More Voronoi shaders:\n\/\/\n\/\/ Exact edges:  https:\/\/www.shadertoy.com\/view\/ldl3W8\n\/\/ Hierarchical: https:\/\/www.shadertoy.com\/view\/Xll3zX\n\/\/ Smooth:       https:\/\/www.shadertoy.com\/view\/ldB3zc\n\/\/ Voronoise:    https:\/\/www.shadertoy.com\/view\/Xd23Dh\n\n\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat voronoise( in vec2 p, float u, float v )\n{\n\tfloat k = 1.0+63.0*pow(1.0-v,6.0);\n\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n\tvec2 a = vec2(0.0,0.0);\n    for( int y=-2; y<=2; y++ )\n    for( int x=-2; x<=2; x++ )\n    {\n        vec2  g = vec2( x, y );\n\t\tvec3  o = hash3( i + g )*vec3(u,u,1.0);\n\t\tvec2  d = g - f + o.xy;\n\t\tfloat w = pow( 1.0-smoothstep(0.0,1.414,length(d)), k );\n\t\ta += vec2(o.z*w,w);\n    }\n\t\n    return a.x\/a.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord \/ iResolution.xx;\n\n    vec2 p = 0.5 - 0.5*cos( iTime*vec2(1.0,0.5) );\n    \n\tif( iMouse.w>0.001 ) p = vec2(0.0,1.0) + vec2(1.0,-1.0)*iMouse.xy\/iResolution.xy;\n\t\n\tp = p*p*(3.0-2.0*p);\n\tp = p*p*(3.0-2.0*p);\n\tp = p*p*(3.0-2.0*p);\n\t\n\tfloat f = voronoise( 24.0*uv, p.x, p.y );\n\t\n\tfragColor = vec4( f, f, f, 1.0 );\n}",
                "name": "Image",
                "description": "",
                "type": "image"
            }
        ]
    }
]