<!DOCTYPE HTML>
<html lang="en">
<head>

    
<title>Browse (2) - Shadertoy BETA</title>
<meta charset="utf-8" />
<meta name="Keywords" content="shadertoy, shader toy, quilez, inigo, jeremias, pol, fractals, demoscene, computer graphics, mathematics, rendering, demo, 3D, realtime, shader, raytracing, raymarching, webgl, glsl" />
<meta name="Description" content="Build shaders, share them, and learn from the best community." />
<meta name="Author" content="Beautypi" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<link rel="image_src" href="https://www.shadertoy.com/img/logo.png" />
<link rel="apple-touch-icon" href="/img/launch_icon_57.png"/>
<link rel="apple-touch-icon" sizes="72x72" href="/img/launch_icon_72.png"/>
<link rel="apple-touch-icon" sizes="114x114" href="/img/launch_icon_114.png"/>
<link rel="shortcut icon" href="/img/favicon.ico"/>

<style>::-webkit-scrollbar {
    height: 8px;
    width: 8px;
    background: #404040;
}

::-webkit-scrollbar-thumb
{
    background: #909090;
    border-radius: 0ex;
}

::-webkit-scrollbar-corner
{
    background: #000;
}

::-webkit-input-placeholder
{
	font-style:italic;
}
input:-moz-placeholder, textarea:-moz-placeholder
{
	font-style:italic;
}
input.placeholder-text, textarea.placeholder-text
{
	font-style:italic;
}

pre 
{
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
    white-space: -pre-wrap;
    white-space: -o-pre-wrap;
    word-wrap: break-word;
}

@font-face
{
    font-family: Lobster;
    src: url("/img/lobster.otf") format("opentype");
}

div#centerScreen
{
    left: 50%;
    top: 50%;
    position: absolute;
}

a.headerLinks:hover
{
    background-color:#505050;
    color : #ff8020;
}

body
{
    color: #000000;
    font-size:12px;
    font-style:normal;
    font-family:Tahoma,Arial;
    background-repeat: no-repeat;
    //background-attachment: fixed;
    padding:0px;
    margin:0px;
    text-align: left;
    background-color: #d0d0d0;
    background-repeat: repeat;
    user-select: text;
}

a,
a:hover,
a:visited
{
  color : inherit;
}

div#content {
    width: 95%;
    overflow: hidden;
    margin: auto;
    padding: 0px;
    min-height: calc(100vh - 80px);
    //box-sizing: border-box;
}


.notificationCount
{
 background-color:#ff0000;
 padding-left:3px;
 padding-right:1px;
 padding-top:1px;
 padding-bottom:1px;
}

div#header
{
    background-color: #404040;
    top: 0px;
    left: 0px;
    width: 100%;
    padding: 0;
    margin: 0;
    color: #ffffff;
    display: flex;
    flex-direction:row;
}

#headerBlock1
{
    width: 50%;
    display:flex;
    align-items:center;
}

a#headerTitle
{
    font-size: 2.25em;
    font-family: Lobster,Tahoma,Arial;
    text-decoration: none;
    padding-left:32px;
    padding-right:32px;
}

#headerSearch
{
    display: inline-block;
    color: #000000;
    width: 300px;
}

input[type=search]#mySearch
{
    width: 100%;
    border-radius: 6px;
    border: 1px solid black;
    padding:12px;
}

#headerBlock2
{
    width: 50%;
    margin-left: auto;
    display: flex;
    justify-content: flex-end;
}


a#headerTitle:hover
{
    color : #ff8020;
}

a.headerLinks
{
    font-weight: bold;
    padding-top: 14px;
    padding-bottom: 14px;
    padding-left: 14px;
    padding-right: 14px;
    margin:0px;
    text-decoration: none;
    transition: background-color 0.15s linear, color 0.15s linear;
}

#footer
{
    background-color: rgba(64,64,64,0.25);
    color: #000000;
    padding: 0px;
    margin: 0px;
    width: 100%;
    display: flex;
    justify-content: space-between;
    flex-wrap: wrap;
}

#footer div
{
    padding-top:10px;
    padding-bottom:0px;
    padding-left:16px;
    padding-right:16px;
}

#footer div ul
{
    margin-left:0px;
    padding-left:16px;
}

#footer div ul li
{
    padding-top:6px;
}

a.regular
{
    font-weight:bold;
    text-decoration:none
}

a.regular:hover
{
  color : #ff8020;
}

a.user
{
    font-weight:bold;
    text-decoration:none;
}

a.user:hover
{
  color : #ff8020;
  text-decoration: underline;
}

.uiButton
{
    border: none;
    outline: none;
    margin: 0px;
    padding: 0px;
    width: 22px;
    height: 22px;
    position: absolute;
    cursor: pointer;
    border-radius: 4px;
}

.uiButton:hover
{
    box-shadow: inset 0px 0px 1px 1px #808080, 0px 0px 1px 1px #808080;
}

.uiDivBUtton
{
    cursor:pointer;
}

.uiDivBUtton:hover
{
    color: #ffffff;
}


.dialog
{
    display: block;
    background-color: #e0e0e0;
    color: #000000;
    border:1px solid #000;
    padding:0px;
    margin:0px;
    text-align:left;
    border-radius: 4px;
    box-shadow:4px 4px 6px 0px rgba(0,0,0,0.5);
    overflow: hidden;
    z-index:1000;
    visibility: hidden;
    opacity:0;
    -moz-transition: opacity 0.25s linear,visibility 0.25s linear;
    -webkit-transition: opacity 0.25s linear,visibility 0.25s linear;
    transition: opacity 0.25s linear,visibility 0.25s linear;
}

.dialogHeader
{
    left:0px;
    top: 0px;
    width:100%;
    height:32px;
    position: absolute;
    background-color: #808080;
    cursor:move;
}

.dialogTitle
{
    left: 12px;
    top: 4px;
    position: absolute;
    padding: 0px;
    margin: 0px;
    color:#000000;
    font-size:1.5em;
    text-align: left;
    user-select: none;
    -moz-user-select: -moz-none;
    -webkit-user-select: none;
}

.dialogOverlay
{
    z-index:1000;

    visibility: hidden;
    opacity:0;
    -moz-transition: opacity 0.25s linear,visibility 0.25s linear;
    -webkit-transition: opacity 0.25s linear,visibility 0.25s linear;
    transition: opacity 0.25s linear,visibility 0.25s linear;

    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    width:100%;
    height:100%;
    position:absolute;

    background-color:rgba(0,0,0,.4);
}

.viewsIcon, .likesIcon
{
    border: none;
    outline: none;
    display:inline-block;
    background-repeat:no-repeat;
    top:0px;
    left:0px;
    padding:0px;
    padding-right: 2px;
    margin:0px;
    position:relative;
}

.userPictureSmall
{
    background-color:#808080;
    border: 1px solid #000000;
    width:32px;
    height:32px;
}

.dialogCloseButton
{
    right:8px;
    top: 4px;
    width:22px;
    height:22px;
    position: absolute;
    background-image: url("/img/close.png");
    cursor: pointer;
    border-radius: 4px;
}

.dialogCloseButton:hover
{
    box-shadow: inset 0px 0px 4px 2px #ffffff, 0px 0px 4px 2px #ffffff;
}

.dialogContentButtons
{
     padding:0;
     border:0;
     text-align: justify;
     left: 24px;
     bottom:40px;
     position:absolute;
}

.dialogButton
{
    text-align: center;
    vertical-align: middle;
    display: inline-block;
    border-radius: 4px;
    font-weight: bold;
    cursor: pointer;
    padding-bottom:5px;
    padding-top:4px;
    padding-left: 8px;
    padding-right: 8px;
    margin-left:4px;
    margin-right:4px;
    text-decoration: none;
    color:#000000;
    width: 80px;
    -moz-transition:    background-color 0.15s linear, color 0.15s linear;
    -webkit-transition: background-color 0.15s linear, color 0.15s linear;
    transition:         background-color 0.15s linear, color 0.15s linear;
}

.dialogButton:hover
{
  background-color:#808080;
  color : #ff8020;
}

.dialogCloseButton:hover
{
    box-shadow: inset 0px 0px 4px 2px #ffffff, 0px 0px 4px 2px #ffffff;
}

.dialogContent
{
    color: inherit;
    overflow: auto;
    width:100%;
    height:100%;
    left: 0px;
    top: 32px;
    position:absolute
}

.dialogContentBody
{
    color: inherit;
    width:100%;
    height:auto;
    padding-top:24px;
    padding-bottom:24px;
    padding-left:24px;
    padding-right:24px;
    text-align: left;
}

.formButton
{
    font-weight:bold;
	color:#ffffff;
	border:none;
    text-align:center;
	background-color:#808080;
    border-radius: 4px;
	padding-left:8px;
	padding-right:8px;
	padding-top:4px;
	padding-bottom:4px;
    cursor:pointer;
    min-width:80px;
    box-sizing: border-box;
}
.formInput {
    border-radius: 6px;
    border: 1px solid black;
    padding: 4px;
    border: none;
}
.formButton:hover {
    background-color: #e0e0e0;
}
.formButton:disabled
{
	color:#b0b0b0;
	background-color:#808080;
}

.formButtonSmall
{
    color:#ffffff;
    border:none;
    text-align:center;
    background-color:#808080;
    border-radius: 4px;
    padding-left:2px;
    padding-right:2px;
    padding-top:2px;
    padding-bottom:2px;
    cursor:pointer;
    min-width:40px;
}

.formButtonSmall:hover
{
    background-color: #e0e0e0;
}

.formButtonSmall:disabled
{
    color:#b0b0b0;
    background-color:#808080;
}

.formButtonSmall.disabled2,
.formButton.disabled2 { color:#b0b0b0; background-color:#808080; pointer-events: none; }

.inputForm
{
    padding-left:2%;
    padding-right:2%;
    resize: none;
    text-align: left;
    background-color:#e0e0e0;
    outline: none;
    border-radius: 4px;
    border: 1px solid #808080;
    color:inherit;
    box-sizing: border-box;
}

.inputForm:focus
{
    border: 1px solid #AFCDD8;
    background-color: #EBF2F4;
}

.transparentPannel
{
    background-color:rgba(64,64,64,0.1);
    padding:16px;
}

.comment, .commentSelf, .commentNew
{
    border-radius: 4px;
    width: 100%;
    margin-left: 0px;
    margin-right: 0px;
    margin-top: 0px;
    margin-bottom: 6px;

    padding: 14px;
    box-sizing: border-box;
    display: grid;
    grid-template-columns: 32px auto 8px;
    grid-template-rows: 1fr;
    grid-gap:8px;
}

.comment:nth-child(even)
{
    background-color: rgba(64,64,64,0.1);
}

.comment:nth-child(odd)
{
    background-color: rgba(128,128,128,0.1);
}

.commentSelf
{
    background-color: rgba(240,160,64,0.1);
}

.commentNew
{
    padding-right: 0px;
    grid-template-columns: 40px auto;
}

.commentContent
{
    vertical-align: top;
    text-align: left;
    word-break: break-all;
    word-break: break-word;
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
}


/* ----------------------- media resolutions ------------------------ */

@media screen and (max-width:799px)
{
    div#header {flex-direction:column; }
    #headerBlock1 { width:100%; }
    #headerBlock2 { width:100%; justify-content: space-around;}
    div#headerSearch {width:200px;}
    input#mySearch { width:200px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .previewText { width:130px; }
    .transparentPannel { padding:10px; }
}

@media screen and (min-width:800px) and (max-width:1279px)
{
    body { font-size: 9px; }
    div#headerSearch {width: 250px;}
    input#mySearch { width:250px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .previewText { width:130px; }
    .transparentPannel { padding:11px; }
}

@media screen and (min-width:1280px) and (max-width:1439px)
{
    body { font-size: 10px; }
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:28px; }
    .previewText { width:180px; }
    .transparentPannel { padding:12px; }
}

@media screen and (min-width:1440px) and (max-width:1919px)
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:28px; }
    .previewText { width:180px; }
    .transparentPannel { padding:12px; }
}

@media screen and (min-width:1920px) and (max-width:2559px)
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:32px; }
    .previewText { width:220px; }
    .transparentPannel { padding:16px; }
}

@media screen and (min-width:2560px) 
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:32px; }
    .previewText { width:220px; }
    .transparentPannel { padding:16px; }
}
body
{
    background-image: url("/img/themes/classic/background.jpg");
}
</style>



    <script>"use strict"

//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piCamera
//
//==============================================================================

function piCamera()
{
    var mMatrix = setIdentity();
    var mMatrixInv = setIdentity();

    var mPosition = [0.0,0.0,0.0];
    var mXRotation = 0.0;
    var mYRotation = 0.0;

    var mPositionTarget = [0.0,0.0,0.0];
    var mXRotationTarget = 0.0;
    var mYRotationTarget = 0.0;

    var me = {};
/*
    me.Set = function( pos, dir, roll) 
             {
                 mMatrix    = setLookat( pos, add(pos,dir), [Math.sin(roll),Math.cos(roll),Math.sin(roll)] );
                 mMatrixInv = invertFast( mMatrix );
             };
*/
    me.SetPos = function(pos)
                {
                    mPosition = pos;
                    //mMatrix[ 3] = -(mMatrix[0] * pos[0] + mMatrix[1] * pos[1] + mMatrix[ 2] * pos[2]);
                    //mMatrix[ 7] = -(mMatrix[4] * pos[0] + mMatrix[5] * pos[1] + mMatrix[ 6] * pos[2]);
                    //mMatrix[11] = -(mMatrix[8] * pos[0] + mMatrix[9] * pos[1] + mMatrix[10] * pos[2]);
                };
/*
    me.GlobalMove = function(pos)
                    {
                        mMatrix[ 3] -= (mMatrix[0] * pos[0] + mMatrix[1] * pos[1] + mMatrix[ 2] * pos[2]);
                        mMatrix[ 7] -= (mMatrix[4] * pos[0] + mMatrix[5] * pos[1] + mMatrix[ 6] * pos[2]);
                        mMatrix[11] -= (mMatrix[8] * pos[0] + mMatrix[9] * pos[1] + mMatrix[10] * pos[2]);
                        mMatrixInv = invertFast(mMatrix);
                    };
*/
    me.LocalMove = function( dis )
                    {
                        dis = matMulvec( setRotationY(-mYRotation), dis);
                        mPositionTarget = sub(mPositionTarget,dis)
                    };

    me.RotateXY = function( x, y)
                  {
                    mXRotationTarget -= x;
                    mYRotationTarget -= y;
                    mXRotationTarget = Math.min( Math.max( mXRotationTarget, -Math.PI/2), Math.PI/2 );
                  };


    me.CameraExectue = function( dt )
    {
        // smooth position
        mXRotation += (mXRotationTarget-mXRotation) * 12.0*dt;
        mYRotation += (mYRotationTarget-mYRotation) * 12.0*dt;
        mPosition = add(mPosition, mul( sub(mPositionTarget, mPosition), 12.0*dt));

        // Make Camera matrix
        mMatrix = matMul( matMul(setRotationX(mXRotation), 
                                 setRotationY(mYRotation)),  
                                 setTranslation(mPosition));
        mMatrixInv = invertFast(mMatrix);

    }

    me.GetMatrix = function() { return mMatrix; };
    me.GetMatrixInverse = function() { return mMatrixInv; };
    me.SetMatrix = function( mat ) 
                    {
                        mMatrix = mat;
                        mMatrixInv = invertFast(mMatrix);

                        mPosition = getXYZ(matMulpoint(mat, [0.0,0.0,0.0]));
                        mPositionTarget = mPosition;
                    };

    me.GetPos = function() { return getXYZ(matMulpoint(mMatrixInv, [0.0,0.0,0.0])); }
    me.GetDir = function() { return getXYZ(normalize(matMulvec(mMatrixInv, [0.0,0.0,-1.0]))); }

    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piFile
//
//==============================================================================

function piFile( binaryDataArrayBuffer )
{
    // private
    //var mDataView = new DataView( binaryDataArrayBuffer, 0 );
    var mDataView = binaryDataArrayBuffer;
    var mOffset = 0;

    // public members
    var me = {};
    me.mDummy = 0;
/*
    // public functions
    me.Seek = function( off ) { mOffset = off - 3; };
    me.ReadUInt16 = function()  { var res = mDataView.getUint16( mOffset ); mOffset+=2; return res; };
    me.ReadUInt32 = function()  { var res = mDataView.getUint32( mOffset ); mOffset+=4; return res; };
    me.ReadUInt64 = function()  { return me.ReadUInt32() + (me.ReadUInt32()<<32); };
    me.ReadFloat32 = function() { var res = mDataView.getFloat32( mOffset ); mOffset+=4; return res; };
*/

    me.Seek = function( off ) { mOffset = off; };
    me.ReadUInt8  = function()  { var res = (new Uint8Array(mDataView,mOffset))[0]; mOffset+=1; return res; };
    me.ReadUInt16 = function()  { var res = (new Uint16Array(mDataView,mOffset))[0]; mOffset+=2; return res; };
    me.ReadUInt32 = function()  { var res = (new Uint32Array(mDataView,mOffset))[0]; mOffset+=4; return res; };
    me.ReadUInt64 = function()  { return me.ReadUInt32() + (me.ReadUInt32()<<32); };
    me.ReadFloat32 = function() { var res = (new Float32Array(mDataView,mOffset))[0]; mOffset+=4; return res; };
    me.ReadFloat32Array = function(n) 
                          { 
                              var src = new Float32Array(mDataView, mOffset);
                              var res = [];  for( var i=0; i<n; i++ ) { res[i] = src[i]; }
                              mOffset += 4*n;
                              return res;
                          };
    me.ReadFloat32ArrayNative = function(n) { var src = new Float32Array(mDataView, mOffset); mOffset += 4*n; return src; };
    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piMesh
//
//==============================================================================

function piMesh()
{
    this.mChunks = [];
    this.mPrimitiveType = 0;
    this.mVertexFormat = null;
}

/*
piMesh.prototype.normalize = function( ppos, npos )
{
    var numv = this.mVertexData.length;
    var numt = this.mIndices.length;

    for( var i=0; i<numv; i++ )
    {
        //float *v = (float*)piMesh_GetVertexData( me, i, npos );
        //v[0] = 0.0f;
        //v[1] = 0.0f;
        //v[2] = 0.0f;
        this.mVerts[8 * i + 3] = 0.0;
        this.mVerts[8 * i + 4] = 0.0;
        this.mVerts[8 * i + 5] = 0.0;
    }

    for( var i=0; i<numt; i++ )
    {
        piMeshFace *face = me->mFaceData.mIndexArray[0].mBuffer + i;

        const int ft = face->mNum;
        
        vec3 nor = vec3( 0.0f, 0.0f, 0.0f );
        for( int j=0; j<ft; j++ )
        {
            const vec3 va = *((vec3*)piMesh_GetVertexData( me, face->mIndex[ j      ], ppos ));
            const vec3 vb = *((vec3*)piMesh_GetVertexData( me, face->mIndex[(j+1)%ft], ppos ));

            nor += cross( va, vb );
        }

        for( int j=0; j<ft; j++ )
        {
            vec3 *n = (vec3*)piMesh_GetVertexData( me, face->mIndex[j], npos );
            n->x += nor.x;
            n->y += nor.y;
            n->z += nor.z;
        }
    }

    for( var i=0; i<numv; i++ )
    {
        vec3 *v = (vec3*)piMesh_GetVertexData( me, i, npos );
        *v = normalize( *v );
    }
}
*/

piMesh.prototype.createCube = function(renderer)
{
    this.mPrimitiveType = 0;

    this.mChunks[0] = { mVerts : new Float32Array([ -1.0, -1.0, -1.0,
                                       1.0, -1.0, -1.0,
                                      -1.0,  1.0, -1.0,
                                       1.0,  1.0, -1.0,
                                      -1.0, -1.0,  1.0,
                                       1.0, -1.0,  1.0,
                                      -1.0,  1.0,  1.0,
                                       1.0,  1.0,  1.0 ]),

                        mIndices : new Uint16Array([ 0, 2, 1,   1, 2, 3,   5, 1, 3,   5, 3, 7,   4, 5, 7,   4, 7, 6,   4, 6, 2,   4, 2, 0,   6, 7, 3,   6, 3, 2,   4, 0, 1,   4, 1, 5 ]),
                        mNumVertices : 8,
                        mNumFaces : 12, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };

    this.mVertexFormat = { mStride:12, mChannels:[ { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false } ] };

    return true;
}

piMesh.prototype.createCubeSharp = function (renderer)
{
    this.mPrimitiveType = 0;

    this.mChunks[0] = { mVerts : new Float32Array([-1.0, 1.0,-1.0,   0.0, 1.0, 0.0,   0.0, 0.0,
                                    -1.0, 1.0, 1.0,   0.0, 1.0, 0.0,   0.0, 1.0,
                                     1.0, 1.0, 1.0,   0.0, 1.0, 0.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   0.0, 1.0, 0.0,   1.0, 0.0,

                                    -1.0,-1.0, 1.0,   0.0, 0.0, 1.0,   0.0, 0.0,
                                     1.0,-1.0, 1.0,   0.0, 0.0, 1.0,   0.0, 1.0,
                                     1.0, 1.0, 1.0,   0.0, 0.0, 1.0,   1.0, 1.0,
                                    -1.0, 1.0, 1.0,   0.0, 0.0, 1.0,   1.0, 0.0,

                                     1.0, 1.0, 1.0,   1.0, 0.0, 0.0,   0.0, 0.0,
                                     1.0,-1.0, 1.0,   1.0, 0.0, 0.0,   0.0, 1.0,
                                     1.0,-1.0,-1.0,   1.0, 0.0, 0.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   1.0, 0.0, 0.0,   1.0, 0.0,

                                     1.0,-1.0,-1.0,   0.0, 0.0,-1.0,   0.0, 0.0,
                                    -1.0,-1.0,-1.0,   0.0, 0.0,-1.0,   0.0, 1.0,
                                    -1.0, 1.0,-1.0,   0.0, 0.0,-1.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   0.0, 0.0,-1.0,   1.0, 0.0,

                                    -1.0,-1.0, 1.0,   0.0,-1.0, 0.0,   0.0, 0.0,
                                    -1.0,-1.0,-1.0,   0.0,-1.0, 0.0,   0.0, 1.0,
                                     1.0,-1.0,-1.0,   0.0,-1.0, 0.0,   1.0, 1.0,
                                     1.0,-1.0, 1.0,   0.0,-1.0, 0.0,   1.0, 0.0,

                                    -1.0, 1.0, 1.0,  -1.0, 0.0, 0.0,   0.0, 0.0,
                                    -1.0, 1.0,-1.0,  -1.0, 0.0, 0.0,   0.0, 1.0,
                                    -1.0,-1.0,-1.0,  -1.0, 0.0, 0.0,   1.0, 1.0,
                                    -1.0,-1.0, 1.0,  -1.0, 0.0, 0.0,   1.0, 0.0 ]),

                        mIndices : new Uint16Array([0,1,2, 0,2,3,   4,5,6, 4,6,7,    8,9,10,8,10,11,   12,13,14,12,14,15,   16,17,18,16,18,19,   20,21,22,20,22,23]),
                        mNumVertices : 24,
                        mNumFaces : 12, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };


    this.mVertexFormat = { mStride:32, mChannels:[ { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false },
                                                   { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false },
                                                   { mNumComponents:2, mType: renderer.TYPE.FLOAT32, mNormalize: false } ] };

    return true;
}


piMesh.prototype.createUnitQuad = function (renderer)
{
    this.mPrimitiveType = 0;
    this.mVertexFormat = { mStride:8, mChannels: [ {mNumComponents:2, mType: renderer.TYPE.FLOAT32, mNormalize: false} ] };

    this.mChunks[0] = { mVerts : new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0,  1.0, 1.0,  1.0]),
                        mIndices : new Uint16Array([0, 2, 1, 1, 2, 3]),
                        mNumVertices : 4,
                        mNumFaces : 2, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };
 
    return true;
}




piMesh.prototype.destroy = function()
{
    //delete this.mVerts;   this.mVerts = null;
    //delete this.mIndices; this.mIndices = null;
}

piMesh.prototype.scale = function (x, y, z)
{
    var stride = this.mVertexFormat.mStride/4;
    for( var j=0; j<this.mChunks.length; j++ )
    {
        var nv = this.mChunks[j].mNumVertices;
        for (var i = 0; i < nv; i++) 
        {
            this.mChunks[j].mVerts[stride * i + 0] *= x;
            this.mChunks[j].mVerts[stride * i + 1] *= y;
            this.mChunks[j].mVerts[stride * i + 2] *= z;
        }
    }
}

piMesh.prototype.translate = function (x, y, z) 
{
    var stride = this.mVertexFormat.mStride/4;
    for( var j=0; j<this.mChunks.length; j++ )
    {
        var nv = this.mChunks[j].mNumVertices;
        for (var i = 0; i < nv; i++) 
        {
            this.mChunks[j].mVerts[stride * i + 0] += x;
            this.mChunks[j].mVerts[stride * i + 1] += y;
            this.mChunks[j].mVerts[stride * i + 2] += z;
        }
    }
}

piMesh.prototype.GPULoad = function (renderer)
{
    for( var i=0; i<this.mChunks.length; i++ )
    {
        var vbo = renderer.CreateVertexArray(this.mChunks[i].mVerts, renderer.BUFTYPE.STATIC );
        if (vbo == null)
            return false;

        var ibo = renderer.CreateIndexArray(this.mChunks[i].mIndices, renderer.BUFTYPE.STATIC);
        if (ibo == null)
            return false;

        this.mChunks[i].mVBO = vbo;
        this.mChunks[i].mIBO = ibo;
    }
    return true;
}

piMesh.prototype.GPURender = function (renderer, positions )//, matPrj, matCam )
{
    //renderer.SetShaderConstantMat4F("unMPrj", matPrj, false );

    var num = this.mChunks.length;
    for( var i=0; i<num; i++ )
    {
        //var mat =  matMul( matCam, this.mChunks[i].mTransform );
        //renderer.SetShaderConstantMat4F("unMMod", mat, false);

        renderer.AttachVertexArray(this.mChunks[i].mVBO, this.mVertexFormat, positions );
        renderer.AttachIndexArray(this.mChunks[i].mIBO );
        renderer.DrawPrimitive(renderer.PRIMTYPE.TRIANGLES, this.mChunks[i].mNumFaces * 3, true, 1);
        renderer.DetachIndexArray(this.mChunks[i].mIBO);
        renderer.DetachVertexArray(this.mChunks[i].mVBO, this.mVertexFormat );
    }
}
//==============================================================================
//
// piLibs 2014-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piRenderer
//
//==============================================================================

function piRenderer()
{
    // private members

    var mGL = null;
    var mBindedShader = null;
    var mIs20 = false;
    var mFloat32Textures;
    var mFloat32Filter;
    var mFloat16Textures;
    var mDrawBuffers;
    var mDepthTextures;
    var mDerivatives;
    var mFloat16Filter;
    var mShaderTextureLOD;
    var mAnisotropic;
    var mRenderToFloat32F;
    var mDebugShader;
    var mAsynchCompile;

    var mVBO_Quad = null;
    var mVBO_Tri = null;
    var mVBO_CubePosNor = null;
    var mVBO_CubePos = null;
    var mShaderHeader = ["",""];
    var mShaderHeaderLines = [0,0];

    // public members
    var me = {};

    me.CLEAR      = { Color: 1, Zbuffer : 2, Stencil : 4 };
    me.TEXFMT     = { C4I8 : 0, C1I8 : 1, C1F16 : 2, C4F16 : 3, C1F32 : 4, C4F32 : 5, Z16 : 6, Z24 : 7, Z32 : 8, C3F32:9 };
    me.TEXWRP     = { CLAMP : 0, REPEAT : 1 };
    me.BUFTYPE    = { STATIC : 0, DYNAMIC : 1 };
    me.PRIMTYPE   = { POINTS : 0, LINES : 1, LINE_LOOP : 2, LINE_STRIP : 3, TRIANGLES : 4, TRIANGLE_STRIP : 5 };
    me.RENDSTGATE = { WIREFRAME : 0, FRONT_FACE : 1, CULL_FACE : 2, DEPTH_TEST : 3, ALPHA_TO_COVERAGE : 4 };
    me.TEXTYPE    = { T2D : 0, T3D : 1, CUBEMAP : 2 };
    me.FILTER     = { NONE : 0, LINEAR : 1, MIPMAP : 2, NONE_MIPMAP : 3 };
    me.TYPE       = { UINT8 : 0, UINT16 : 1, UINT32 : 2, FLOAT16: 3, FLOAT32 : 4, FLOAT64: 5 };

    // private functions

    var iFormatPI2GL = function( format )
    {
        if( mIs20 )
        {
             if (format === me.TEXFMT.C4I8)  return { mGLFormat: mGL.RGBA8,           mGLExternal: mGL.RGBA,             mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1I8)  return { mGLFormat: mGL.R8,              mGLExternal: mGL.RED,              mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1F16) return { mGLFormat: mGL.R16F,            mGLExternal: mGL.RED,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F16) return { mGLFormat: mGL.RGBA16F,         mGLExternal: mGL.RGBA,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C1F32) return { mGLFormat: mGL.R32F,            mGLExternal: mGL.RED,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F32) return { mGLFormat: mGL.RGBA32F,         mGLExternal: mGL.RGBA,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C3F32) return { mGLFormat: mGL.RGB32F,          mGLExternal: mGL.RGB,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.Z16)   return { mGLFormat: mGL.DEPTH_COMPONENT16, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        else if (format === me.TEXFMT.Z24)   return { mGLFormat: mGL.DEPTH_COMPONENT24, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        else if (format === me.TEXFMT.Z32)   return { mGLFormat: mGL.DEPTH_COMPONENT32F, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        }
        else
        {
             if (format === me.TEXFMT.C4I8)  return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1I8)  return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.LUMINANCE,       mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1F16) return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.LUMINANCE,       mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F16) return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C1F32) return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.RED,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F32) return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.Z16)   return { mGLFormat: mGL.DEPTH_COMPONENT, mGLExternal: mGL.DEPTH_COMPONENT, mGLType: mGL.UNSIGNED_SHORT }
        }

        return null;
     }

    // public functions

    me.Initialize = function( gl )
                    {
                        mGL = gl;

                        mIs20 = !(gl instanceof WebGLRenderingContext);

                        if( mIs20 )
                        {
                            mFloat32Textures  = true;
                            mFloat32Filter    = mGL.getExtension( 'OES_texture_float_linear');
                            mFloat16Textures  = true;
                            mFloat16Filter    = mGL.getExtension( 'OES_texture_half_float_linear' );
                            mDerivatives      = true;
                            mDrawBuffers      = true;
                            mDepthTextures    = true;
                            mShaderTextureLOD = true;
                            mAnisotropic = mGL.getExtension( 'EXT_texture_filter_anisotropic' );
                            mRenderToFloat32F = mGL.getExtension( 'EXT_color_buffer_float');
                            mDebugShader = mGL.getExtension('WEBGL_debug_shaders');
                            mAsynchCompile = mGL.getExtension('KHR_parallel_shader_compile');

							mGL.hint( mGL.FRAGMENT_SHADER_DERIVATIVE_HINT, mGL.NICEST);
                        }
                        else
                        {
                            mFloat32Textures  = mGL.getExtension( 'OES_texture_float' );
                            mFloat32Filter    = mGL.getExtension( 'OES_texture_float_linear');
                            mFloat16Textures  = mGL.getExtension( 'OES_texture_half_float' );
                            mFloat16Filter    = mGL.getExtension( 'OES_texture_half_float_linear' );
                            mDerivatives      = mGL.getExtension( 'OES_standard_derivatives' );
                            mDrawBuffers      = mGL.getExtension( 'WEBGL_draw_buffers' );
                            mDepthTextures    = mGL.getExtension( 'WEBGL_depth_texture' );
                            mShaderTextureLOD = mGL.getExtension( 'EXT_shader_texture_lod' );
                            mAnisotropic      = mGL.getExtension( 'EXT_texture_filter_anisotropic' );
                            mRenderToFloat32F = mFloat32Textures;
                            mDebugShader      = null;
                            mAsynchCompile    = null;
							
							if( mDerivatives !== null) mGL.hint( mDerivatives.FRAGMENT_SHADER_DERIVATIVE_HINT_OES, mGL.NICEST);
                        }
                        
                        
                        var maxTexSize = mGL.getParameter( mGL.MAX_TEXTURE_SIZE );
                        var maxCubeSize = mGL.getParameter( mGL.MAX_CUBE_MAP_TEXTURE_SIZE );
                        var maxRenderbufferSize = mGL.getParameter( mGL.MAX_RENDERBUFFER_SIZE );
                        var extensions = mGL.getSupportedExtensions();
                        var textureUnits = mGL.getParameter( mGL.MAX_TEXTURE_IMAGE_UNITS );
                        console.log("WebGL (2.0=" + mIs20 + "):" +
                                    " Asynch Compile: "  + ((mAsynchCompile !==null) ? "yes" : "no") +
                                    ", Textures: F32 ["   + ((mFloat32Textures !==null) ? "yes" : "no") +
                                    "], F16 ["   + ((mFloat16Textures !==null) ? "yes" : "no") +
                                    "], Depth [" + ((mDepthTextures   !==null) ? "yes" : "no") +
                                    "], LOD ["    + ((mShaderTextureLOD!==null) ? "yes" : "no") +
                                    "], Aniso ["   + ((mAnisotropic     !==null) ? "yes" : "no") +
                                    "], Units [" + textureUnits +
                                    "], Max Size [" + maxTexSize +
                                    "], Cube Max Size [" + maxCubeSize +
                                    "], Targets: MRT ["            + ((mDrawBuffers     !==null) ? "yes" : "no") +
                                    "], F32 ["     + ((mRenderToFloat32F!==null) ? "yes" : "no") +
                                    "], Max Size [" + maxRenderbufferSize + "]");

                        // create a 2D quad Vertex Buffer
                        var vertices = new Float32Array( [ -1.0, -1.0,   1.0, -1.0,    -1.0,  1.0,     1.0, -1.0,    1.0,  1.0,    -1.0,  1.0] );
                        mVBO_Quad = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Quad );
                        mGL.bufferData( mGL.ARRAY_BUFFER, vertices, mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 2D triangle Vertex Buffer
                        mVBO_Tri = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Tri );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0,   3.0, -1.0,    -1.0,  3.0] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 3D cube Vertex Buffer
                        mVBO_CubePosNor = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePosNor );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0, -1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0, -1.0,  1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0,  1.0, -1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0,  1.0,  1.0,  -1.0,  0.0,  0.0,
                                                                               1.0,  1.0, -1.0,   1.0,  0.0,  0.0,
                                                                               1.0,  1.0,  1.0,   1.0,  0.0,  0.0,
                                                                               1.0, -1.0, -1.0,   1.0,  0.0,  0.0,
                                                                               1.0, -1.0,  1.0,   1.0,  0.0,  0.0,
                                                                               1.0,  1.0,  1.0,   0.0,  1.0,  0.0,
                                                                               1.0,  1.0, -1.0,   0.0,  1.0,  0.0,
                                                                              -1.0,  1.0,  1.0,   0.0,  1.0,  0.0,
                                                                              -1.0,  1.0, -1.0,   0.0,  1.0,  0.0,
                                                                               1.0, -1.0, -1.0,   0.0, -1.0,  0.0,
                                                                               1.0, -1.0,  1.0,   0.0, -1.0,  0.0,
                                                                              -1.0, -1.0, -1.0,   0.0, -1.0,  0.0,
                                                                              -1.0, -1.0,  1.0,   0.0, -1.0,  0.0,
                                                                              -1.0,  1.0,  1.0,   0.0,  0.0,  1.0,
                                                                              -1.0, -1.0,  1.0,   0.0,  0.0,  1.0,
                                                                               1.0,  1.0,  1.0,   0.0,  0.0,  1.0,
                                                                               1.0, -1.0,  1.0,   0.0,  0.0,  1.0,
                                                                              -1.0, -1.0, -1.0,   0.0,  0.0, -1.0,
                                                                              -1.0,  1.0, -1.0,   0.0,  0.0, -1.0,
                                                                               1.0, -1.0, -1.0,   0.0,  0.0, -1.0,
                                                                               1.0,  1.0, -1.0,   0.0,  0.0, -1.0 ] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 3D cube Vertex Buffer
                        mVBO_CubePos = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePos );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0, -1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                               1.0,  1.0, -1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0, -1.0,  1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0,  1.0, -1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0, -1.0,  1.0,
                                                                              -1.0, -1.0, -1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0, -1.0,  1.0,
                                                                              -1.0, -1.0, -1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0,  1.0, -1.0 ] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        //-------------------------------------------------------------------

                        mShaderHeader[0] = "";
                        mShaderHeaderLines[0] = 0;
                        if( mIs20 ) 
                        { 
                            mShaderHeader[0] += "#version 300 es\n" +
                                                "#ifdef GL_ES\n"+
                                                "precision highp float;\n" +
                                                "precision highp int;\n"+
                                                "precision mediump sampler3D;\n"+
                                                "#endif\n"; 
                            mShaderHeaderLines[0] += 6;
                        }
                        else
                        {
                            mShaderHeader[0] += "#ifdef GL_ES\n"+
                                                "precision highp float;\n" +
                                                "precision highp int;\n"+
                                                "#endif\n"+
                                                "float round( float x ) { return floor(x+0.5); }\n"+
                                                "vec2 round(vec2 x) { return floor(x + 0.5); }\n"+
                                                "vec3 round(vec3 x) { return floor(x + 0.5); }\n"+
                                                "vec4 round(vec4 x) { return floor(x + 0.5); }\n"+
                                                "float trunc( float x, float n ) { return floor(x*n)/n; }\n"+
                                                "mat3 transpose(mat3 m) { return mat3(m[0].x, m[1].x, m[2].x, m[0].y, m[1].y, m[2].y, m[0].z, m[1].z, m[2].z); }\n"+
                                                "float determinant( in mat2 m ) { return m[0][0]*m[1][1] - m[0][1]*m[1][0]; }\n"+
                                                "float determinant( mat4 m ) { float b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0], b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0], b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0], b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1], b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1], b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2], b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0], b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0], b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0], b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1], b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1], b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;}\n"+
                                                "mat2 inverse(mat2 m) { float det = determinant(m); return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / det; }\n"+
                                                "mat4 inverse(mat4 m ) { float inv0 = m[1].y*m[2].z*m[3].w - m[1].y*m[2].w*m[3].z - m[2].y*m[1].z*m[3].w + m[2].y*m[1].w*m[3].z + m[3].y*m[1].z*m[2].w - m[3].y*m[1].w*m[2].z; float inv4 = -m[1].x*m[2].z*m[3].w + m[1].x*m[2].w*m[3].z + m[2].x*m[1].z*m[3].w - m[2].x*m[1].w*m[3].z - m[3].x*m[1].z*m[2].w + m[3].x*m[1].w*m[2].z; float inv8 = m[1].x*m[2].y*m[3].w - m[1].x*m[2].w*m[3].y - m[2].x  * m[1].y * m[3].w + m[2].x  * m[1].w * m[3].y + m[3].x * m[1].y * m[2].w - m[3].x * m[1].w * m[2].y; float inv12 = -m[1].x  * m[2].y * m[3].z + m[1].x  * m[2].z * m[3].y +m[2].x  * m[1].y * m[3].z - m[2].x  * m[1].z * m[3].y - m[3].x * m[1].y * m[2].z + m[3].x * m[1].z * m[2].y; float inv1 = -m[0].y*m[2].z * m[3].w + m[0].y*m[2].w * m[3].z + m[2].y  * m[0].z * m[3].w - m[2].y  * m[0].w * m[3].z - m[3].y * m[0].z * m[2].w + m[3].y * m[0].w * m[2].z; float inv5 = m[0].x  * m[2].z * m[3].w - m[0].x  * m[2].w * m[3].z - m[2].x  * m[0].z * m[3].w + m[2].x  * m[0].w * m[3].z + m[3].x * m[0].z * m[2].w - m[3].x * m[0].w * m[2].z; float inv9 = -m[0].x  * m[2].y * m[3].w +  m[0].x  * m[2].w * m[3].y + m[2].x  * m[0].y * m[3].w - m[2].x  * m[0].w * m[3].y - m[3].x * m[0].y * m[2].w + m[3].x * m[0].w * m[2].y; float inv13 = m[0].x  * m[2].y * m[3].z - m[0].x  * m[2].z * m[3].y - m[2].x  * m[0].y * m[3].z + m[2].x  * m[0].z * m[3].y + m[3].x * m[0].y * m[2].z - m[3].x * m[0].z * m[2].y; float inv2 = m[0].y  * m[1].z * m[3].w - m[0].y  * m[1].w * m[3].z - m[1].y  * m[0].z * m[3].w + m[1].y  * m[0].w * m[3].z + m[3].y * m[0].z * m[1].w - m[3].y * m[0].w * m[1].z; float inv6 = -m[0].x  * m[1].z * m[3].w + m[0].x  * m[1].w * m[3].z + m[1].x  * m[0].z * m[3].w - m[1].x  * m[0].w * m[3].z - m[3].x * m[0].z * m[1].w + m[3].x * m[0].w * m[1].z; float inv10 = m[0].x  * m[1].y * m[3].w - m[0].x  * m[1].w * m[3].y - m[1].x  * m[0].y * m[3].w + m[1].x  * m[0].w * m[3].y + m[3].x * m[0].y * m[1].w - m[3].x * m[0].w * m[1].y; float inv14 = -m[0].x  * m[1].y * m[3].z + m[0].x  * m[1].z * m[3].y + m[1].x  * m[0].y * m[3].z - m[1].x  * m[0].z * m[3].y - m[3].x * m[0].y * m[1].z + m[3].x * m[0].z * m[1].y; float inv3 = -m[0].y * m[1].z * m[2].w + m[0].y * m[1].w * m[2].z + m[1].y * m[0].z * m[2].w - m[1].y * m[0].w * m[2].z - m[2].y * m[0].z * m[1].w + m[2].y * m[0].w * m[1].z; float inv7 = m[0].x * m[1].z * m[2].w - m[0].x * m[1].w * m[2].z - m[1].x * m[0].z * m[2].w + m[1].x * m[0].w * m[2].z + m[2].x * m[0].z * m[1].w - m[2].x * m[0].w * m[1].z; float inv11 = -m[0].x * m[1].y * m[2].w + m[0].x * m[1].w * m[2].y + m[1].x * m[0].y * m[2].w - m[1].x * m[0].w * m[2].y - m[2].x * m[0].y * m[1].w + m[2].x * m[0].w * m[1].y; float inv15 = m[0].x * m[1].y * m[2].z - m[0].x * m[1].z * m[2].y - m[1].x * m[0].y * m[2].z + m[1].x * m[0].z * m[2].y + m[2].x * m[0].y * m[1].z - m[2].x * m[0].z * m[1].y; float det = m[0].x * inv0 + m[0].y * inv4 + m[0].z * inv8 + m[0].w * inv12; det = 1.0 / det; return det*mat4( inv0, inv1, inv2, inv3,inv4, inv5, inv6, inv7,inv8, inv9, inv10, inv11,inv12, inv13, inv14, inv15);}\n"+                                                
                                                "float sinh(float x)  { return (exp(x)-exp(-x))/2.; }\n"+
                                                "float cosh(float x)  { return (exp(x)+exp(-x))/2.; }\n"+
                                                "float tanh(float x)  { return sinh(x)/cosh(x); }\n"+
                                                "float coth(float x)  { return cosh(x)/sinh(x); }\n"+
                                                "float sech(float x)  { return 1./cosh(x); }\n"+
                                                "float csch(float x)  { return 1./sinh(x); }\n"+
                                                "float asinh(float x) { return    log(x+sqrt(x*x+1.)); }\n"+
                                                "float acosh(float x) { return    log(x+sqrt(x*x-1.)); }\n"+
                                                "float atanh(float x) { return .5*log((1.+x)/(1.-x)); }\n"+
                                                "float acoth(float x) { return .5*log((x+1.)/(x-1.)); }\n"+
                                                "float asech(float x) { return    log((1.+sqrt(1.-x*x))/x); }\n"+
                                                "float acsch(float x) { return    log((1.+sqrt(1.+x*x))/x); }\n";
                            mShaderHeaderLines[0] += 26;
                        }

                        //-------------------------------------------------------

                        mShaderHeader[1] = "";
                        mShaderHeaderLines[1] = 0;
                        if( mIs20 ) 
                        { 
                            mShaderHeader[1] += "#version 300 es\n"+
                                                "#ifdef GL_ES\n"+
                                                "precision highp float;\n"+
                                                "precision highp int;\n"+
                                                "precision mediump sampler3D;\n"+
                                                "#endif\n"; 
                            mShaderHeaderLines[1] += 6;
                        }
                        else
                        {
                            if( mDerivatives ) { mShaderHeader[1] += "#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n"; mShaderHeaderLines[1]+=3; }
                            if( mShaderTextureLOD  ) { mShaderHeader[1] += "#extension GL_EXT_shader_texture_lod : enable\n"; mShaderHeaderLines[1]++; }
                            mShaderHeader[1] += "#ifdef GL_ES\n"+
                                                "precision highp float;\n"+
                                                "precision highp int;\n"+
                                                "#endif\n"+ 
                                                "vec4 texture(     sampler2D   s, vec2 c)                   { return texture2D(s,c); }\n"+
                                                "vec4 texture(     sampler2D   s, vec2 c, float b)          { return texture2D(s,c,b); }\n"+
                                                "vec4 texture(     samplerCube s, vec3 c )                  { return textureCube(s,c); }\n"+
                                                "vec4 texture(     samplerCube s, vec3 c, float b)          { return textureCube(s,c,b); }\n"+
                                                "float round( float x ) { return floor(x+0.5); }\n"+
                                                "vec2 round(vec2 x) { return floor(x + 0.5); }\n"+
                                                "vec3 round(vec3 x) { return floor(x + 0.5); }\n"+
                                                "vec4 round(vec4 x) { return floor(x + 0.5); }\n"+
                                                "float trunc( float x, float n ) { return floor(x*n)/n; }\n"+
                                                "mat3 transpose(mat3 m) { return mat3(m[0].x, m[1].x, m[2].x, m[0].y, m[1].y, m[2].y, m[0].z, m[1].z, m[2].z); }\n"+
                                                "float determinant( in mat2 m ) { return m[0][0]*m[1][1] - m[0][1]*m[1][0]; }\n"+
                                                "float determinant( mat4 m ) { float b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0], b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0], b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0], b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1], b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1], b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2], b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0], b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0], b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0], b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1], b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1], b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;}\n"+
                                                "mat2 inverse(mat2 m) { float det = determinant(m); return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / det; }\n"+
                                                "mat4 inverse(mat4 m ) { float inv0 = m[1].y*m[2].z*m[3].w - m[1].y*m[2].w*m[3].z - m[2].y*m[1].z*m[3].w + m[2].y*m[1].w*m[3].z + m[3].y*m[1].z*m[2].w - m[3].y*m[1].w*m[2].z; float inv4 = -m[1].x*m[2].z*m[3].w + m[1].x*m[2].w*m[3].z + m[2].x*m[1].z*m[3].w - m[2].x*m[1].w*m[3].z - m[3].x*m[1].z*m[2].w + m[3].x*m[1].w*m[2].z; float inv8 = m[1].x*m[2].y*m[3].w - m[1].x*m[2].w*m[3].y - m[2].x  * m[1].y * m[3].w + m[2].x  * m[1].w * m[3].y + m[3].x * m[1].y * m[2].w - m[3].x * m[1].w * m[2].y; float inv12 = -m[1].x  * m[2].y * m[3].z + m[1].x  * m[2].z * m[3].y +m[2].x  * m[1].y * m[3].z - m[2].x  * m[1].z * m[3].y - m[3].x * m[1].y * m[2].z + m[3].x * m[1].z * m[2].y; float inv1 = -m[0].y*m[2].z * m[3].w + m[0].y*m[2].w * m[3].z + m[2].y  * m[0].z * m[3].w - m[2].y  * m[0].w * m[3].z - m[3].y * m[0].z * m[2].w + m[3].y * m[0].w * m[2].z; float inv5 = m[0].x  * m[2].z * m[3].w - m[0].x  * m[2].w * m[3].z - m[2].x  * m[0].z * m[3].w + m[2].x  * m[0].w * m[3].z + m[3].x * m[0].z * m[2].w - m[3].x * m[0].w * m[2].z; float inv9 = -m[0].x  * m[2].y * m[3].w +  m[0].x  * m[2].w * m[3].y + m[2].x  * m[0].y * m[3].w - m[2].x  * m[0].w * m[3].y - m[3].x * m[0].y * m[2].w + m[3].x * m[0].w * m[2].y; float inv13 = m[0].x  * m[2].y * m[3].z - m[0].x  * m[2].z * m[3].y - m[2].x  * m[0].y * m[3].z + m[2].x  * m[0].z * m[3].y + m[3].x * m[0].y * m[2].z - m[3].x * m[0].z * m[2].y; float inv2 = m[0].y  * m[1].z * m[3].w - m[0].y  * m[1].w * m[3].z - m[1].y  * m[0].z * m[3].w + m[1].y  * m[0].w * m[3].z + m[3].y * m[0].z * m[1].w - m[3].y * m[0].w * m[1].z; float inv6 = -m[0].x  * m[1].z * m[3].w + m[0].x  * m[1].w * m[3].z + m[1].x  * m[0].z * m[3].w - m[1].x  * m[0].w * m[3].z - m[3].x * m[0].z * m[1].w + m[3].x * m[0].w * m[1].z; float inv10 = m[0].x  * m[1].y * m[3].w - m[0].x  * m[1].w * m[3].y - m[1].x  * m[0].y * m[3].w + m[1].x  * m[0].w * m[3].y + m[3].x * m[0].y * m[1].w - m[3].x * m[0].w * m[1].y; float inv14 = -m[0].x  * m[1].y * m[3].z + m[0].x  * m[1].z * m[3].y + m[1].x  * m[0].y * m[3].z - m[1].x  * m[0].z * m[3].y - m[3].x * m[0].y * m[1].z + m[3].x * m[0].z * m[1].y; float inv3 = -m[0].y * m[1].z * m[2].w + m[0].y * m[1].w * m[2].z + m[1].y * m[0].z * m[2].w - m[1].y * m[0].w * m[2].z - m[2].y * m[0].z * m[1].w + m[2].y * m[0].w * m[1].z; float inv7 = m[0].x * m[1].z * m[2].w - m[0].x * m[1].w * m[2].z - m[1].x * m[0].z * m[2].w + m[1].x * m[0].w * m[2].z + m[2].x * m[0].z * m[1].w - m[2].x * m[0].w * m[1].z; float inv11 = -m[0].x * m[1].y * m[2].w + m[0].x * m[1].w * m[2].y + m[1].x * m[0].y * m[2].w - m[1].x * m[0].w * m[2].y - m[2].x * m[0].y * m[1].w + m[2].x * m[0].w * m[1].y; float inv15 = m[0].x * m[1].y * m[2].z - m[0].x * m[1].z * m[2].y - m[1].x * m[0].y * m[2].z + m[1].x * m[0].z * m[2].y + m[2].x * m[0].y * m[1].z - m[2].x * m[0].z * m[1].y; float det = m[0].x * inv0 + m[0].y * inv4 + m[0].z * inv8 + m[0].w * inv12; det = 1.0 / det; return det*mat4( inv0, inv1, inv2, inv3,inv4, inv5, inv6, inv7,inv8, inv9, inv10, inv11,inv12, inv13, inv14, inv15);}\n"+
                                                "float sinh(float x)  { return (exp(x)-exp(-x))/2.; }\n"+
                                                "float cosh(float x)  { return (exp(x)+exp(-x))/2.; }\n"+
                                                "float tanh(float x)  { return sinh(x)/cosh(x); }\n"+
                                                "float coth(float x)  { return cosh(x)/sinh(x); }\n"+
                                                "float sech(float x)  { return 1./cosh(x); }\n"+
                                                "float csch(float x)  { return 1./sinh(x); }\n"+
                                                "float asinh(float x) { return    log(x+sqrt(x*x+1.)); }\n"+
                                                "float acosh(float x) { return    log(x+sqrt(x*x-1.)); }\n"+
                                                "float atanh(float x) { return .5*log((1.+x)/(1.-x)); }\n"+
                                                "float acoth(float x) { return .5*log((x+1.)/(x-1.)); }\n"+
                                                "float asech(float x) { return    log((1.+sqrt(1.-x*x))/x); }\n"+
                                                "float acsch(float x) { return    log((1.+sqrt(1.+x*x))/x); }\n";
                            mShaderHeaderLines[1] += 30;
                            if( mShaderTextureLOD )
                            {
                            mShaderHeader[1] += "vec4 textureLod(  sampler2D   s, vec2 c, float b)          { return texture2DLodEXT(s,c,b); }\n";
                            mShaderHeader[1] += "vec4 textureGrad( sampler2D   s, vec2 c, vec2 dx, vec2 dy) { return texture2DGradEXT(s,c,dx,dy); }\n";
                            mShaderHeaderLines[1] += 2;

                            //mShaderHeader[1] += "vec4 texelFetch( sampler2D s, ivec2 c, int l) { return texture2DLodEXT(s,(vec2(c)+0.5)/vec2(800,450),float(l)); }\n";
                            //mShaderHeaderLines[1] += 1;
                            }
                        }

                        return true;
                    };

        me.GetCaps =    function ()
                        {   
                            return { mIsGL20 : mIs20,
                                     mFloat32Textures: mFloat32Textures != null,
                                     mFloat16Textures: mFloat16Textures != null,
                                     mDrawBuffers: mDrawBuffers != null,
                                     mDepthTextures: mDepthTextures != null,
                                     mDerivatives: mDerivatives != null,
                                     mShaderTextureLOD: mShaderTextureLOD != null };
                        };

        me.GetShaderHeaderLines = function (shaderType)
                        {   
                            return mShaderHeaderLines[shaderType];
                        };

        me.CheckErrors = function()
                         {
                                var error = mGL.getError();
                                if( error != mGL.NO_ERROR ) 
                                { 
                                    for( var prop in mGL ) 
                                    {
                                        if( typeof mGL[prop] == 'number' ) 
                                        {
                                            if( mGL[prop] == error )
                                            {
                                                console.log( "GL Error " + error + ": " + prop );
                                                break;
                                            }
                                        }
                                    }
                                }
                         };

        me.Clear =  function( flags, ccolor, cdepth, cstencil )
                    {
                        var mode = 0;
                        if( flags & 1 ) { mode |= mGL.COLOR_BUFFER_BIT;   mGL.clearColor( ccolor[0], ccolor[1], ccolor[2], ccolor[3] ); }
                        if( flags & 2 ) { mode |= mGL.DEPTH_BUFFER_BIT;   mGL.clearDepth( cdepth ); }
                        if( flags & 4 ) { mode |= mGL.STENCIL_BUFFER_BIT; mGL.clearStencil( cstencil ); }
                        mGL.clear( mode );
                    };


        me.CreateTexture = function ( type, xres, yres, format, filter, wrap, buffer)
                           {
                                if( mGL===null ) return null;

                                var id = mGL.createTexture();

                                var glFoTy = iFormatPI2GL( format );
                                var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                if( type===me.TEXTYPE.T2D )
                                {
                                    mGL.bindTexture( mGL.TEXTURE_2D, id );
//if( buffer==null )
    //mGL.texStorage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, xres, yres);
//else
                                    mGL.texImage2D( mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texParameteri( mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap );
                                    mGL.texParameteri( mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap );

                                    if (filter === me.FILTER.NONE)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }

                                    mGL.bindTexture( mGL.TEXTURE_2D, null );
                                }
                                else if( type===me.TEXTYPE.T3D )
                                {
                                    if( mIs20 )
                                    {
                                        mGL.bindTexture( mGL.TEXTURE_3D, id );
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_BASE_LEVEL, 0);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAX_LEVEL, Math.log2(xres));
                                        if (filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                        }
                                        else if (filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        }
                                        else
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_3D);
                                        }
                                        mGL.texImage3D( mGL.TEXTURE_3D, 0, glFoTy.mGLFormat, xres, yres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );

                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_R, glWrap );
                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_S, glWrap );
                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_T, glWrap );

                                        if (filter === me.FILTER.MIPMAP)
                                            mGL.generateMipmap( mGL.TEXTURE_3D );
                                        mGL.bindTexture( mGL.TEXTURE_3D, null );
                                    }
                                    else 
                                    {
                                        return null;
                                    }
                                }
                                else 
                                {
                                    mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );

                                    // this works great if we know the number of required mipmaps in advance (1, or other)
                                   //mGL.texStorage2D( mGL.TEXTURE_CUBE_MAP, 1, glFoTy.mGLFormat, xres, yres );

                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );

                                    if( filter === me.FILTER.NONE)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR)
                                    {
                                        mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR );
                                        mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR );
                                    }
                                    else if (filter === me.FILTER.MIPMAP)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                    }

                                    if (filter === me.FILTER.MIPMAP)
                                        mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );

                                    mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                }
                        return { mObjectID: id, mXres: xres, mYres: yres, mFormat: format, mType: type, mFilter: filter, mWrap: wrap, mVFlip:false };
                        };

        me.CreateTextureFromImage = function ( type, image, format, filter, wrap, flipY) 
                                {
                                    if( mGL===null ) return null;

                                    var id = mGL.createTexture();

                                    var glFoTy = iFormatPI2GL( format );

                                    var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                    if( type===me.TEXTYPE.T2D )
                                    {
                                        mGL.bindTexture(mGL.TEXTURE_2D, id);

                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, flipY);
                                        mGL.pixelStorei(mGL.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                                        if( mIs20 ) mGL.pixelStorei(mGL.UNPACK_COLORSPACE_CONVERSION_WEBGL, mGL.NONE );

                                        mGL.texImage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image);

                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap);

                                        if (filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                        }
                                        else if( filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_2D);
                                        }
                                        else
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_2D);
                                        }
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                        mGL.bindTexture(mGL.TEXTURE_2D, null);
                                    }
                                    else if( type===me.TEXTYPE.T3D )
                                    {
                                        return null;
                                    }
                                    else 
                                    {
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, flipY);
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[0] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[1] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (flipY ? image[3] : image[2]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (flipY ? image[2] : image[3]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[4] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[5] );

                                        if( filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR );
                                            mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR );
                                        }
                                        else if (filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                            mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );
                                        }
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                    }
                                    return { mObjectID: id, mXres: image.width, mYres: image.height, mFormat: format, mType: type, mFilter: filter, mWrap:wrap, mVFlip:flipY };
                                };

        me.SetSamplerFilter = function (te, filter, doGenerateMipsIfNeeded) 
                            {
                                if (te.mFilter === filter) return;

                                if (te.mType === me.TEXTYPE.T2D) 
                                {
                                    mGL.bindTexture(mGL.TEXTURE_2D, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_2D, null);

                                }
                                else if (te.mType === me.TEXTYPE.T3D) 
                                {
                                    mGL.bindTexture(mGL.TEXTURE_3D, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_3D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_3D);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_3D, null);

                                }
                                else
                                {
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_CUBE_MAP);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_CUBE_MAP);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                                }


                                te.mFilter = filter;
                            };

        me.SetSamplerWrap = function (te, wrap)
                            {
                                if (te.mWrap === wrap) return;

                                var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                var id = te.mObjectID;

                                if (te.mType === me.TEXTYPE.T2D)
                                {
                                    mGL.bindTexture(mGL.TEXTURE_2D, id);
                                    mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap);
                                    mGL.bindTexture(mGL.TEXTURE_2D, null);

                                }
                                else if (te.mType === me.TEXTYPE.T3D)
                                {
                                    mGL.bindTexture(mGL.TEXTURE_3D, id);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_R, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_S, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_T, glWrap);
                                    mGL.bindTexture(mGL.TEXTURE_3D, null);
                                }

                                te.mWrap = wrap;
                            };

        me.SetSamplerVFlip = function (te, vflip, image)
                            {
                                if (te.mVFlip === vflip) return;

                                var id = te.mObjectID;

                                if (te.mType === me.TEXTYPE.T2D)
                                {
                                    if( image != null)
                                    {
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture(mGL.TEXTURE_2D, id);
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, vflip);
                                        var glFoTy = iFormatPI2GL( te.mFormat );
                                        mGL.texImage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image);
                                        mGL.bindTexture(mGL.TEXTURE_2D, null);
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
                                }
                                else if (te.mType === me.TEXTYPE.CUBEMAP)
                                {
                                    if( image != null)
                                    {
                                        var glFoTy = iFormatPI2GL( te.mFormat );
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );
                                        mGL.pixelStorei( mGL.UNPACK_FLIP_Y_WEBGL, vflip);
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[0] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[1] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (vflip ? image[3] : image[2]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (vflip ? image[2] : image[3]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[4] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[5] );
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
        
                                }

                                te.mVFlip = vflip;
                            };

        me.CreateMipmaps =  function (te)
                            {
                                if( te.mType===me.TEXTYPE.T2D )
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                    mGL.bindTexture(mGL.TEXTURE_2D, te.mObjectID);
                                    mGL.generateMipmap(mGL.TEXTURE_2D);
                                    mGL.bindTexture(mGL.TEXTURE_2D, null);
                                }
                                else if( te.mType===me.TEXTYPE.CUBEMAP )
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, te.mObjectID);
                                    mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                                }
                            };

        me.UpdateTexture =  function( tex, x0, y0, xres, yres, buffer )
                            {
                                var glFoTy = iFormatPI2GL( tex.mFormat );
                                if( tex.mType===me.TEXTYPE.T2D )
                                {
                                    mGL.activeTexture( mGL.TEXTURE0);
                                    mGL.bindTexture( mGL.TEXTURE_2D, tex.mObjectID );
                                    mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, tex.mVFlip );
                                    mGL.texSubImage2D( mGL.TEXTURE_2D, 0, x0, y0, xres, yres, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.bindTexture( mGL.TEXTURE_2D, null );
                                    mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                }
                            };

        me.UpdateTextureFromImage = function( tex, image )
                                {
                                    var glFoTy = iFormatPI2GL( tex.mFormat );
                                    if( tex.mType===me.TEXTYPE.T2D )
                                    {
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture( mGL.TEXTURE_2D, tex.mObjectID );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, tex.mVFlip );
                                        mGL.texImage2D(  mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image );
                                        mGL.bindTexture( mGL.TEXTURE_2D, null );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
                                };

        me.DestroyTexture = function( te )
                            {
                                 mGL.deleteTexture( te.mObjectID );
                            };

        me.AttachTextures = function (num, t0, t1, t2, t3) 
                            {
                                if (num > 0 && t0 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                         if (t0.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t0.mObjectID);
                                    else if (t0.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t0.mObjectID);
                                    else if (t0.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t0.mObjectID);
                                }

                                if (num > 1 && t1 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE1);
                                         if (t1.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t1.mObjectID);
                                    else if (t1.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t1.mObjectID);
                                    else if (t1.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t1.mObjectID);
                                }

                                if (num > 2 && t2 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE2);
                                         if (t2.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t2.mObjectID);
                                    else if (t2.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t2.mObjectID);
                                    else if (t2.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t2.mObjectID);
                                }

                                if (num > 3 && t3 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE3);
                                         if (t3.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t3.mObjectID);
                                    else if (t3.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t3.mObjectID);
                                    else if (t3.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t3.mObjectID);
                                }
                            };

        me.DettachTextures = function()
                             {
                                mGL.activeTexture(mGL.TEXTURE0);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE1);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE2);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE3);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                             };

        me.CreateRenderTarget = function ( color0, color1, color2, color3, depth, wantZbuffer )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if (depth === null)
                                    {
                                        if( wantZbuffer===true )
                                        {
                                            var zb = mGL.createRenderbuffer();
                                            mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);
                                            mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, color0.mXres, color0.mYres);

                                            mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                        }
                                    }
                                    else
                                    {
                                        mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.TEXTURE_2D, depth.mObjectID, 0);
                                    }

                                    if( color0 !=null ) mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_2D, color0.mObjectID, 0);

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                        return null;

                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mTex0: color0 };
                                };

        me.DestroyRenderTarget = function ( tex )
                                 {
                                     mGL.deleteFramebuffer(tex.mObjectID);
                                 };

        me.SetRenderTarget = function (tex)
                             {
                                if( tex===null )
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                else
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, tex.mObjectID);

                                //mGL.drawBuffers([mGL.COLOR_ATTACHMENT0, mGL.COLOR_ATTACHMENT1]);
                             };

        me.CreateRenderTargetNew = function ( wantColor0, wantZbuffer, xres, yres, samples )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if( wantZbuffer===true )
                                    {
                                        var zb = mGL.createRenderbuffer();
                                        mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);

                                        if( samples==1 )
                                        mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, xres, yres);
                                        else
                                        mGL.renderbufferStorageMultisample(mGL.RENDERBUFFER, samples, mGL.DEPTH_COMPONENT16, xres, yres);
                                        mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                    }

                                    if( wantColor0 )
                                    {
                                        var cb = mGL.createRenderbuffer();
                                        mGL.bindRenderbuffer(mGL.RENDERBUFFER, cb);
                                        if( samples==1 )
                                        mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.RGBA8, xres, yres);
                                        else
                                        mGL.renderbufferStorageMultisample(mGL.RENDERBUFFER, samples, mGL.RGBA8, xres, yres);
                                        mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.RENDERBUFFER, cb);
                                    }

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                    {
                                        return null;
                                    }
                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mXres: xres, mYres:yres, mTex0: color0 };
                                };

        me.CreateRenderTargetCubeMap = function ( color0, depth, wantZbuffer )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if (depth === null)
                                    {
                                        if( wantZbuffer===true )
                                        {
                                            var zb = mGL.createRenderbuffer();
                                            mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);
                                            mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, color0.mXres, color0.mYres);
                                            mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                        }
                                    }
                                    else
                                    {
                                        mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.TEXTURE_2D, depth.mObjectID, 0);
                                    }

                                    if( color0 !=null ) mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_CUBE_MAP_POSITIVE_X, color0.mObjectID, 0);

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                        return null;

                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mTex0: color0 };
                                };

        me.SetRenderTargetCubeMap = function (fbo, face)
                             {
                                if( fbo===null )
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                else
                                {
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, fbo.mObjectID);
                                    mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_CUBE_MAP_POSITIVE_X+face, fbo.mTex0.mObjectID, 0);
                                }
                             };


        me.BlitRenderTarget = function( dst, src )
                                {
                                    mGL.bindFramebuffer(mGL.READ_FRAMEBUFFER, src.mObjectID);
                                    mGL.bindFramebuffer(mGL.DRAW_FRAMEBUFFER, dst.mObjectID);
                                    mGL.clearBufferfv(mGL.COLOR, 0, [0.0, 0.0, 0.0, 1.0]);
                                    mGL.blitFramebuffer( 0, 0, src.mXres, src.mYres,
                                                         0, 0, src.mXres, src.mYres,
                                                         mGL.COLOR_BUFFER_BIT, mGL.LINEAR
                                    );
                                };

        me.SetViewport = function( vp )
                         {
                              mGL.viewport( vp[0], vp[1], vp[2], vp[3] );
                         };

        me.SetWriteMask = function( c0, c1, c2, c3, z )
                          {
                              mGL.depthMask(z);
                              mGL.colorMask(c0,c0,c0,c0);
                          };

        me.SetState = function( stateName, stateValue )
                      {
                            if (stateName === me.RENDSTGATE.WIREFRAME)
                            {
                                if( stateValue ) mGL.polygonMode( mGL.FRONT_AND_BACK, mGL.LINE );
                                else             mGL.polygonMode( mGL.FRONT_AND_BACK, mGL.FILL );
                            }
                            else if (stateName === me.RENDSTGATE.FRONT_FACE)
                            {
                                if( stateValue ) mGL.cullFace( mGL.BACK );
                                else             mGL.cullFace( mGL.FRONT );
                            }
                            else if (stateName === me.RENDSTGATE.CULL_FACE)
                            {
                                if( stateValue ) mGL.enable( mGL.CULL_FACE );
                                else             mGL.disable( mGL.CULL_FACE );
                            }
                            else if (stateName === me.RENDSTGATE.DEPTH_TEST)
                            {
                                if( stateValue ) mGL.enable( mGL.DEPTH_TEST );
                                else             mGL.disable( mGL.DEPTH_TEST );
                            }
                            else if (stateName === me.RENDSTGATE.ALPHA_TO_COVERAGE)
                            {
                                if( stateValue ) { mGL.enable(  mGL.SAMPLE_ALPHA_TO_COVERAGE ); }
                                else             { mGL.disable( mGL.SAMPLE_ALPHA_TO_COVERAGE ); }
                            }
                      };

        me.SetMultisample = function( v)
                    {
                        if( v===true )
                        {
                            mGL.enable(mGL.SAMPLE_COVERAGE);
                            mGL.sampleCoverage(1.0, false);
                        }
                        else
                        {
                            mGL.disable(mGL.SAMPLE_COVERAGE);
                        }
                    };

        me.GetTranslatedShaderSource = function (shader) 
                          {
                            if( mGL===null ) return null;
                            if( mDebugShader===null ) return null;
                            let vfs = mGL.getAttachedShaders(shader.mProgram);
                            let str = mDebugShader.getTranslatedShaderSource(vfs[1]);
                            let parts = str.split("GLSL END"); str = (parts.length<2) ? str : parts[1];
                            return str;
                          };

        me.CreateShader = function (vsSource, fsSource, preventCache, forceSynch, onResolve) 
                          {
                            if( mGL===null ) return;

                            var vs = mGL.createShader( mGL.VERTEX_SHADER   );
                            var fs = mGL.createShader( mGL.FRAGMENT_SHADER );

                            vsSource = mShaderHeader[0] + vsSource;
                            fsSource = mShaderHeader[1] + fsSource;

                            if( preventCache )
                            {
                                let vran = Math.random().toString(36).substring(7);
                                let fran = Math.random().toString(36).substring(7);
                                vsSource += "\n#define K" + vran + "\n";
                                fsSource += "\n#define K" + fran + "\n";
                            }

                            var timeStart = getRealTime();

                            mGL.shaderSource(vs, vsSource);
                            mGL.shaderSource(fs, fsSource);
                            mGL.compileShader(vs);
                            mGL.compileShader(fs);

                            var pr = mGL.createProgram();
                            mGL.attachShader(pr, vs);
                            mGL.attachShader(pr, fs);
                            mGL.linkProgram(pr);

                            //-------------
                            let checkErrors = function()
                            {
                                if (!mGL.getProgramParameter(pr, mGL.LINK_STATUS))
                                {
                                    // vs error
                                    if (!mGL.getShaderParameter(vs, mGL.COMPILE_STATUS))
                                    {
                                        let vsLog = mGL.getShaderInfoLog(vs);
                                        onResolve(false, { mErrorType: 0, mErrorStr: vsLog });
                                        mGL.deleteProgram(pr);
                                    }
                                    // fs error
                                    else if (!mGL.getShaderParameter(fs, mGL.COMPILE_STATUS))
                                    {
                                        let fsLog = mGL.getShaderInfoLog(fs);
                                        onResolve(false, { mErrorType: 1, mErrorStr: fsLog });
                                        mGL.deleteProgram(pr);
                                    }
                                    // link error
                                    else
                                    {
                                        let infoLog = mGL.getProgramInfoLog(pr);
                                        onResolve(false, { mErrorType: 2, mErrorStr: infoLog });
                                        mGL.deleteProgram(pr);
                                    }
                                }
                                // no errors
                                else
                                {
                                    let compilationTime = getRealTime() - timeStart;
                                    onResolve(true, { mProgram: pr, mTime: compilationTime });
                                }
                            };

                            // check compilation
                            if (mAsynchCompile === null || forceSynch===true )
                            {
                                checkErrors();
                            }
                            else
                            {
                                let loopCheckCompletion = function ()
                                {
                                    if( mGL.getProgramParameter(pr, mAsynchCompile.COMPLETION_STATUS_KHR) === true )
                                        checkErrors();
                                    else
                                        setTimeout(loopCheckCompletion, 10);
                                };
                                setTimeout(loopCheckCompletion, 10);
                            }
                        };

        me.AttachShader = function( shader )
                          {
                                if( shader===null )
                                {
                                    mBindedShader = null;
                                    mGL.useProgram( null );
                                }
                                else
                                {
                                    mBindedShader = shader;
                                    mGL.useProgram(shader.mProgram);
                                }
                          };

        me.DetachShader = function ()
                        {
                            mGL.useProgram(null);
                        };

        me.DestroyShader = function( tex )
                        {
                            mGL.deleteProgram(tex.mProgram);
                        };

        me.GetAttribLocation = function (shader, name)
                        {
                            return mGL.getAttribLocation(shader.mProgram, name);
                        };

        me.SetShaderConstantLocation = function (shader, name)
                        {
                            return mGL.getUniformLocation(shader.mProgram, name);
                        };

        me.SetShaderConstantMat4F = function( uname, params, istranspose )
                        {
                            var program = mBindedShader;

                            let pos = mGL.getUniformLocation( program.mProgram, uname );
                            if( pos===null )
                                return false;

                            if( istranspose===false )
                            {
                                var tmp = new Float32Array( [ params[0], params[4], params[ 8], params[12],
                                                              params[1], params[5], params[ 9], params[13],
                                                              params[2], params[6], params[10], params[14],
                                                              params[3], params[7], params[11], params[15] ] );
	                            mGL.uniformMatrix4fv(pos,false,tmp);
                            }
                            else
                                mGL.uniformMatrix4fv(pos,false,new Float32Array(params) );
                            return true;
                        };

        me.SetShaderConstant1F_Pos = function(pos, x)
                        {
                            mGL.uniform1f(pos, x);
                            return true;
                        };

        me.SetShaderConstant1FV_Pos = function(pos, x)
                        {
                            mGL.uniform1fv(pos, x);
                            return true;
                        };

        me.SetShaderConstant1F = function( uname, x )
                        {
                            var pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1f(pos, x);
                            return true;
                        };

        me.SetShaderConstant1I = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1i(pos, x);
                            return true;
                        };
        me.SetShaderConstant1I_Pos = function(pos, x)
                        {
                            mGL.uniform1i(pos, x);
                            return true;
                        };


        me.SetShaderConstant2F = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform2fv(pos, x);
                            return true;
                        };

        me.SetShaderConstant3F = function(uname, x, y, z)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform3f(pos, x, y, z);
                            return true;
                        };

        me.SetShaderConstant1FV = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1fv(pos, new Float32Array(x));
                            return true;
                        };

        me.SetShaderConstant3FV = function(uname, x) 
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform3fv(pos, new Float32Array(x) );
                            return true;
                        };

        me.SetShaderConstant4FV = function(uname, x) 
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform4fv(pos, new Float32Array(x) );
                            return true;
                        };

        me.SetShaderTextureUnit = function( uname, unit )
                        {
                            var program = mBindedShader;
                            let pos = mGL.getUniformLocation(program.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform1i(pos, unit);
                            return true;
                        };

        me.CreateVertexArray = function( data, mode )
                        {
                            let id = mGL.createBuffer();
                            mGL.bindBuffer(mGL.ARRAY_BUFFER, id);
                            if (mode === me.BUFTYPE.STATIC)
                                mGL.bufferData(mGL.ARRAY_BUFFER, data, mGL.STATIC_DRAW);
                            else
                                mGL.bufferData(mGL.ARRAY_BUFFER, data, mGL.DYNAMIC_DRAW);
                            return { mObject: id };
                        };

        me.CreateIndexArray = function( data, mode )
                        {
                            let id = mGL.createBuffer();
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, id );
                            if (mode === me.BUFTYPE.STATIC)
                                mGL.bufferData(mGL.ELEMENT_ARRAY_BUFFER, data, mGL.STATIC_DRAW);
                            else
                                mGL.bufferData(mGL.ELEMENT_ARRAY_BUFFER, data, mGL.DYNAMIC_DRAW);
                            return { mObject: id };
                        };

        me.DestroyArray = function( tex )
                        {
                            mGL.destroyBuffer(tex.mObject);
                        };

        me.AttachVertexArray = function( tex, attribs, pos )
                        {
                            let shader = mBindedShader;

                            mGL.bindBuffer( mGL.ARRAY_BUFFER, tex.mObject);

                            var num = attribs.mChannels.length;
                            var stride = attribs.mStride;

                            var offset = 0;
                            for (var i = 0; i < num; i++)
                            {
                                var id = pos[i];
                                mGL.enableVertexAttribArray(id);
                                var dtype = mGL.FLOAT;
                                var dsize = 4;
                                     if( attribs.mChannels[i].mType === me.TYPE.UINT8   ) { dtype = mGL.UNSIGNED_BYTE;  dsize = 1; }
                                else if( attribs.mChannels[i].mType === me.TYPE.UINT16  ) { dtype = mGL.UNSIGNED_SHORT; dsize = 2; }
                                else if( attribs.mChannels[i].mType === me.TYPE.FLOAT32 ) { dtype = mGL.FLOAT;          dsize = 4; }
                                mGL.vertexAttribPointer(id, attribs.mChannels[i].mNumComponents, dtype, attribs.mChannels[i].mNormalize, stride, offset);
                                offset += attribs.mChannels[i].mNumComponents * dsize;
                            }
                        };

        me.AttachIndexArray = function( tex )
                        {
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, tex.mObject);
                        };

        me.DetachVertexArray = function (tex, attribs)
                        {
                            let num = attribs.mChannels.length;
                            for (let i = 0; i < num; i++)
                                mGL.disableVertexAttribArray(i);
                            mGL.bindBuffer(mGL.ARRAY_BUFFER, null);
                        };

        me.DetachIndexArray = function( tex )
                        {
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, null);
                        };

        me.DrawPrimitive = function( typeOfPrimitive, num, useIndexArray, numInstances )
                        {
                            let glType = mGL.POINTS;
                            if( typeOfPrimitive===me.PRIMTYPE.POINTS ) glType = mGL.POINTS;
                            if( typeOfPrimitive===me.PRIMTYPE.LINES ) glType = mGL.LINES;
                            if( typeOfPrimitive===me.PRIMTYPE.LINE_LOOP ) glType = mGL.LINE_LOOP;
                            if( typeOfPrimitive===me.PRIMTYPE.LINE_STRIP ) glType = mGL.LINE_STRIP;
                            if( typeOfPrimitive===me.PRIMTYPE.TRIANGLES ) glType = mGL.TRIANGLES;
                            if( typeOfPrimitive===me.PRIMTYPE.TRIANGLE_STRIP ) glType = mGL.TRIANGLE_STRIP;

                            if( numInstances<=1 )
                            {
  	                            if( useIndexArray ) mGL.drawElements( glType, num, mGL.UNSIGNED_SHORT, 0 );
	                            else                mGL.drawArrays( glType, 0, num );
                            }
                            else
                            {
                                mGL.drawArraysInstanced(glType, 0, num, numInstances);
                                mGL.drawElementsInstanced( glType, num, mGL.UNSIGNED_SHORT, 0, numInstances);
                            }
                        };


        me.DrawFullScreenTriangle_XY = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Tri );
                            mGL.vertexAttribPointer( vpos, 2, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays( mGL.TRIANGLES, 0, 3 );
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        };


        me.DrawUnitQuad_XY = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Quad );
                            mGL.vertexAttribPointer( vpos, 2, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays( mGL.TRIANGLES, 0, 6 );
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        };

        me.DrawUnitCube_XYZ_NOR = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePosNor );
                            mGL.vertexAttribPointer( vpos[0], 3, mGL.FLOAT, false, 0, 0 );
                            mGL.vertexAttribPointer( vpos[1], 3, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos[0] );
                            mGL.enableVertexAttribArray( vpos[1] );
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 0, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 4, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 8, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 12, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 16, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 20, 4);
                            mGL.disableVertexAttribArray( vpos[0] );
                            mGL.disableVertexAttribArray( vpos[1] );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        }

        me.DrawUnitCube_XYZ = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePos );
                            mGL.vertexAttribPointer( vpos, 3, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 0, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 4, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 8, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 12, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 16, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 20, 4);
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        }

        me.SetBlend = function( enabled )
                    {
                        if( enabled )
                        {
                            mGL.enable( mGL.BLEND );
                            mGL.blendEquationSeparate( mGL.FUNC_ADD, mGL.FUNC_ADD );
                            mGL.blendFuncSeparate( mGL.SRC_ALPHA, mGL.ONE_MINUS_SRC_ALPHA, mGL.ONE, mGL.ONE_MINUS_SRC_ALPHA );
                        }
                        else
                        {
                            mGL.disable( mGL.BLEND );
                        }
                    };

        me.GetPixelData = function( data, offset, xres, yres )
                        {
                            mGL.readPixels(0, 0, xres, yres, mGL.RGBA, mGL.UNSIGNED_BYTE, data, offset);
                        };

        me.GetPixelDataRenderTarget = function( obj, data, xres, yres )
                        {
                            mGL.bindFramebuffer(mGL.FRAMEBUFFER, obj.mObjectID);
                            mGL.readBuffer(mGL.COLOR_ATTACHMENT0);
                            mGL.readPixels(0, 0, xres, yres, mGL.RGBA, mGL.FLOAT, data, 0);
                            mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                        };
    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piShading
//
//==============================================================================

function smoothstep(a, b, x)
{
    x = (x - a) / (b - a);
    if (x < 0) x = 0; else if (x > 1) x = 1;
    return x * x * (3.0 - 2.0 * x);
}

function clamp01(x)
{
    if( x < 0.0 ) x = 0.0;
    if( x > 1.0 ) x = 1.0;
    return x;
}

function clamp(x, a, b)
{
    if( x < a ) x = a;
    if( x > b ) x = b;
    return x;
}

function screen(a, b)
{
    return 1.0 - (1.0 - a) * (1.0 - b);
}

function parabola(x)
{
    return 4.0 * x * (1.0 - x);
}

function min(a, b)
{
    return (a < b) ? a : b;
}

function max(a, b)
{
    return (a > b) ? a : b;
}

function noise( x )
{
    function grad(i, j, x, y)
    {
        var h = 7 * i + 131 * j;
        h = (h << 13) ^ h;
        h = (h * (h * h * 15731 + 789221) + 1376312589);

        var rx = (h & 0x20000000) ? x : -x;
        var ry = (h & 0x10000000) ? y : -y;

        return rx + ry;
    }

    var i = [ Math.floor(x[0]), Math.floor(x[1]) ];
    var f = [ x[0] - i[0], x[1] - i[1] ];
    var w = [ f[0]*f[0]*(3.0-2.0*f[0]), f[1]*f[1]*(3.0-2.0*f[1]) ];

    var a = grad( i[0]+0, i[1]+0, f[0]+0.0, f[1]+0.0 );
    var b = grad( i[0]+1, i[1]+0, f[0]-1.0, f[1]+0.0 );
    var c = grad( i[0]+0, i[1]+1, f[0]+0.0, f[1]-1.0 );
    var d = grad( i[0]+1, i[1]+1, f[0]-1.0, f[1]-1.0 );

    return a + (b-a)*w[0] + (c-a)*w[1] + (a-b-c+d)*w[0]*w[1];
}//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piVecTypes
//
//==============================================================================


function vec3( a, b, c )
{
    return [ a, b, c ];
}

function add( a, b )
{
    return [ a[0]+b[0], a[1]+b[1], a[2]+b[2] ];
}

function sub( a, b )
{
    return [ a[0]-b[0], a[1]-b[1], a[2]-b[2] ];
}

function mul( a, s ) 
{
    return [ a[0]*s, a[1]*s, a[2]*s ];
}

function cross( a, b )
{
    return [ a[1]*b[2] - a[2]*b[1],
             a[2]*b[0] - a[0]*b[2],
             a[0]*b[1] - a[1]*b[0] ];
}

function dot( a, b ) 
{
    return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
}

function normalize( v ) 
{
    var is = 1.0 / Math.sqrt( v[0]*v[0] + v[1]*v[1] + v[2]*v[2] );
    return [ v[0]*is, v[1]*is, v[2]*is ];
}

function createCirclePoint( cen, uuu, vvv, rad, s, t )
{
    return [ cen[0] + rad*(uuu[0]*s + vvv[0]*t),
             cen[1] + rad*(uuu[1]*s + vvv[1]*t),
             cen[2] + rad*(uuu[2]*s + vvv[2]*t) ];
}

function createTangent( a, b, c )
{
    var cb = normalize( [ c[0]-b[0], c[1]-b[1], c[2]-b[2] ] );
    var ba = normalize( [ b[0]-a[0], b[1]-a[1], b[2]-a[2] ] );
    return normalize( [ ba[0]+cb[0], ba[1]+cb[1], ba[2]+cb[2] ] );

}

//===================================

function vec4( a, b, c, d )
{
    return [ a, b, c, d ];
}

function getXYZ( v )
{
    return [ v[0], v[1], v[2] ];
}

//===================================

function setIdentity()
{
    return [ 1.0, 0.0, 0.0, 0.0,
             0.0, 1.0, 0.0, 0.0,
             0.0, 0.0, 1.0, 0.0,
             0.0, 0.0, 0.0, 1.0 ];
}

function setRotationX( t )
{
    var sint = Math.sin(t);
    var cost = Math.cos(t);

    return [ 1.0,   0.0,   0.0, 0.0,
             0.0,  cost, -sint, 0.0, 
             0.0,  sint,  cost, 0.0,
             0.0,   0.0,   0.0, 1.0 ];
}

function setRotationY( t )
{
    var sint = Math.sin(t);
    var cost = Math.cos(t);

    return [ cost, 0.0, -sint, 0.0,
              0.0, 1.0,   0.0, 0.0, 
             sint, 0.0,  cost, 0.0,
              0.0, 0.0,   0.0, 1.0 ];
}

function extractRotationEuler( m)
{
    var res = [];
    if (m[0] == 1.0)
    {
        res[0] = Math.atan2(m[2], m[11]);
        res[1] = 0.0;
        res[2] = 0.0;

    }
    else if (m[0] == -1.0)
    {
        res[0] = Math.atan2( m[2], m[11]);
        res[1] = 0.0;
        res[2] = 0.0;
    }
    else
    {
        res[0] = Math.atan2( -m[9], m[10]);
        res[1] = Math.atan2( m[8], Math.sqrt(m[9]*m[9] + m[10]*m[10]));
        res[2] = Math.atan2( m[4], m[0]);
    }
    return res;
}

function setFromQuaternion( q )
{
    var ww = q[3]*q[3];
    var xx = q[0]*q[0];
    var yy = q[1]*q[1];
    var zz = q[2]*q[2];

    return [ ww+xx-yy-zz,                   2.0*(q[0]*q[1] - q[3]*q[2]), 2.0*(q[0]*q[2] + q[3]*q[1]), 0.0,
               2.0*(q[0]*q[1] + q[3]*q[2]),   ww-xx+yy-zz,                 2.0*(q[1]*q[2] - q[3]*q[0]), 0.0,
               2.0*(q[0]*q[2] - q[3]*q[1]),   2.0*(q[1]*q[2] + q[3]*q[0]), ww-xx-yy+zz,                 0.0,
               0.0,                           0.0,                         0.0,                         1.0 ];
}

function setPerspective( fovy, aspect, znear, zfar )
{
    var tan = Math.tan(fovy * Math.PI/180.0);
    var x = 1.0 / (tan*aspect);
    var y = 1.0 / (tan);
    var c = -(zfar + znear) / ( zfar - znear);
    var d = -(2.0 * zfar * znear) / (zfar - znear);

    return [ x,    0.0,  0.0,  0.0,
             0.0,  y,    0.0,  0.0,
             0.0,  0.0,  c,     d,
             0.0,  0.0, -1.0,  0.0 ];
}

function setLookAt( eye, tar, up )
{
    var dir = [ -tar[0]+eye[0], -tar[1]+eye[1], -tar[2]+eye[2] ];

	var m00 = dir[2]*up[1] - dir[1]*up[2]; 
    var m01 = dir[0]*up[2] - dir[2]*up[0];
    var m02 = dir[1]*up[0] - dir[0]*up[1];
    var im = 1.0/Math.sqrt( m00*m00 + m01*m01 + m02*m02 );
    m00 *= im;
    m01 *= im;
    m02 *= im;

	var m04 = m02*dir[1] - m01*dir[2]; 
    var m05 = m00*dir[2] - m02*dir[0];
    var m06 = m01*dir[0] - m00*dir[1];
    im = 1.0/Math.sqrt( m04*m04 + m05*m05 + m06*m06 );
    m04 *= im;
    m05 *= im;
    m06 *= im;

	var m08 = dir[0];
	var m09 = dir[1];
	var m10 = dir[2];
    im = 1.0/Math.sqrt( m08*m08 + m09*m09 + m10*m10 );
    m08 *= im;
    m09 *= im;
    m10 *= im;

	var m03 = -(m00*eye[0] + m01*eye[1] + m02*eye[2] );
	var m07 = -(m04*eye[0] + m05*eye[1] + m06*eye[2] );
	var m11 = -(m08*eye[0] + m09*eye[1] + m10*eye[2] );

    return [ m00, m01, m02, m03,
             m04, m05, m06, m07,
             m08, m09, m10, m11,
             0.0, 0.0, 0.0, 1.0 ];
}


function setOrtho( left, right, bottom, top, znear, zfar )
{
   var x = 2.0 / (right - left);
   var y = 2.0 / (top - bottom);
   var a = (right + left) / (right - left);
   var b = (top + bottom) / (top - bottom);
   var c = -2.0 / (zfar - znear);
   var d = -(zfar + znear) / ( zfar - znear);

   return [  x, 0.0, 0.0,   a,
           0.0,   y, 0.0,   b,
           0.0, 0.0,   c,   d,
           0.0, 0.0, 0.0, 1.0 ];
}

function setTranslation( p )
{
    return [ 1.0, 0.0, 0.0, p[0],
             0.0, 1.0, 0.0, p[1],
             0.0, 0.0, 1.0, p[2],
             0.0, 0.0, 0.0, 1.0 ];
}

function setScale( s )
{
    return [ s[0], 0.0,  0.0,  0.0,
             0.0,  s[1], 0.0,  0.0,
             0.0,  0.0,  s[2], 0.0,
             0.0,  0.0,  0.0,  1.0];
}

function setProjection( fov, znear, zfar )
{
    var x = 2.0 / (fov[3]+fov[2]);
    var y = 2.0 / (fov[0]+fov[1]);
    var a = (fov[3]-fov[2]) / (fov[3]+fov[2]);
    var b = (fov[0]-fov[1]) / (fov[0]+fov[1]);
    var c = -(zfar + znear) / ( zfar - znear);
    var d = -(2.0*zfar*znear) / (zfar - znear);
    return [   x, 0.0,    a, 0.0,
             0.0,   y,    b, 0.0,
             0.0, 0.0,    c,   d,
             0.0, 0.0, -1.0, 0.0 ];
   // inverse is:
   //return mat4x4( 1.0/x, 0.0f,  0.0f,   a/x,
   //               0.0f,  1.0/y, 0.0f,   b/x,
   //               0.0f,  0.0f,  0.0f,   -1.0,
   //               0.0f,  0.0f,  1.0f/d, c/d );
}


function invertFast( m )
{
    var inv = [
   
             m[5]  * m[10] * m[15] - 
             m[5]  * m[11] * m[14] - 
             m[9]  * m[6]  * m[15] + 
             m[9]  * m[7]  * m[14] +
             m[13] * m[6]  * m[11] - 
             m[13] * m[7]  * m[10],

             -m[1]  * m[10] * m[15] + 
              m[1]  * m[11] * m[14] + 
              m[9]  * m[2] * m[15] - 
              m[9]  * m[3] * m[14] - 
              m[13] * m[2] * m[11] + 
              m[13] * m[3] * m[10],

             m[1]  * m[6] * m[15] - 
             m[1]  * m[7] * m[14] - 
             m[5]  * m[2] * m[15] + 
             m[5]  * m[3] * m[14] + 
             m[13] * m[2] * m[7] - 
             m[13] * m[3] * m[6],

             -m[1] * m[6] * m[11] + 
              m[1] * m[7] * m[10] + 
              m[5] * m[2] * m[11] - 
              m[5] * m[3] * m[10] - 
              m[9] * m[2] * m[7] + 
              m[9] * m[3] * m[6],

             -m[4]  * m[10] * m[15] + 
              m[4]  * m[11] * m[14] + 
              m[8]  * m[6]  * m[15] - 
              m[8]  * m[7]  * m[14] - 
              m[12] * m[6]  * m[11] + 
              m[12] * m[7]  * m[10],

             m[0]  * m[10] * m[15] - 
             m[0]  * m[11] * m[14] - 
             m[8]  * m[2] * m[15] + 
             m[8]  * m[3] * m[14] + 
             m[12] * m[2] * m[11] - 
             m[12] * m[3] * m[10],

             -m[0]  * m[6] * m[15] + 
              m[0]  * m[7] * m[14] + 
              m[4]  * m[2] * m[15] - 
              m[4]  * m[3] * m[14] - 
              m[12] * m[2] * m[7] + 
              m[12] * m[3] * m[6],


             m[0] * m[6] * m[11] - 
             m[0] * m[7] * m[10] - 
             m[4] * m[2] * m[11] + 
             m[4] * m[3] * m[10] + 
             m[8] * m[2] * m[7] - 
             m[8] * m[3] * m[6],


             m[4]  * m[9] * m[15] - 
             m[4]  * m[11] * m[13] - 
             m[8]  * m[5] * m[15] + 
             m[8]  * m[7] * m[13] + 
             m[12] * m[5] * m[11] - 
             m[12] * m[7] * m[9],



             -m[0]  * m[9] * m[15] + 
              m[0]  * m[11] * m[13] + 
              m[8]  * m[1] * m[15] - 
              m[8]  * m[3] * m[13] - 
              m[12] * m[1] * m[11] + 
              m[12] * m[3] * m[9],

              m[0]  * m[5] * m[15] - 
              m[0]  * m[7] * m[13] - 
              m[4]  * m[1] * m[15] + 
              m[4]  * m[3] * m[13] + 
              m[12] * m[1] * m[7] - 
              m[12] * m[3] * m[5],

              -m[0] * m[5] * m[11] + 
               m[0] * m[7] * m[9] + 
               m[4] * m[1] * m[11] - 
               m[4] * m[3] * m[9] - 
               m[8] * m[1] * m[7] + 
               m[8] * m[3] * m[5],

              -m[4]  * m[9] * m[14] + 
               m[4]  * m[10] * m[13] +
               m[8]  * m[5] * m[14] - 
               m[8]  * m[6] * m[13] - 
               m[12] * m[5] * m[10] + 
               m[12] * m[6] * m[9],

              m[0]  * m[9] * m[14] - 
              m[0]  * m[10] * m[13] - 
              m[8]  * m[1] * m[14] + 
              m[8]  * m[2] * m[13] + 
              m[12] * m[1] * m[10] - 
              m[12] * m[2] * m[9],

              -m[0]  * m[5] * m[14] + 
               m[0]  * m[6] * m[13] + 
               m[4]  * m[1] * m[14] - 
               m[4]  * m[2] * m[13] - 
               m[12] * m[1] * m[6] + 
               m[12] * m[2] * m[5],

              m[0] * m[5] * m[10] - 
              m[0] * m[6] * m[9] - 
              m[4] * m[1] * m[10] + 
              m[4] * m[2] * m[9] + 
              m[8] * m[1] * m[6] - 
              m[8] * m[2] * m[5] ];

    var det = m[0] * inv[0] + m[1] * inv[4] + m[2] * inv[8] + m[3] * inv[12];

    det = 1.0/det;

    for( var i = 0; i<16; i++ ) inv[i] = inv[i] * det;

    return inv;
}

function matMul( a, b )
{
    var res = [];
    for( var i=0; i<4; i++ )
    {
        var x = a[4*i+0];
        var y = a[4*i+1];
        var z = a[4*i+2];
        var w = a[4*i+3];

        res[4*i+0] = x * b[ 0] + y * b[ 4] + z * b[ 8] + w * b[12];
        res[4*i+1] = x * b[ 1] + y * b[ 5] + z * b[ 9] + w * b[13];
        res[4*i+2] = x * b[ 2] + y * b[ 6] + z * b[10] + w * b[14];
        res[4*i+3] = x * b[ 3] + y * b[ 7] + z * b[11] + w * b[15];
    }

    return res;
}

function matMulpoint( m, v )
{
    return [ m[0]*v[0] + m[1]*v[1] + m[ 2]*v[2] + m[ 3],
             m[4]*v[0] + m[5]*v[1] + m[ 6]*v[2] + m[ 7],
             m[8]*v[0] + m[9]*v[1] + m[10]*v[2] + m[11] ];
}

function matMulvec( m, v )
{
    return [ m[0]*v[0] + m[1]*v[1] + m[ 2]*v[2],
             m[4]*v[0] + m[5]*v[1] + m[ 6]*v[2],
             m[8]*v[0] + m[9]*v[1] + m[10]*v[2] ];
}


function bound3( infi )
{
    return [ infi, -infi, infi, -infi, infi, -infi ];
}

function bound3_include( a, p )
{
    return [
        (p[0]<a[0]) ? p[0] : a[0],
        (p[0]>a[1]) ? p[0] : a[1],
        (p[1]<a[2]) ? p[1] : a[2],
        (p[1]>a[3]) ? p[1] : a[3],
        (p[2]<a[4]) ? p[2] : a[4],
        (p[2]>a[5]) ? p[2] : a[5] ];
}

function bound3_center( b )
{
    return [ 0.5*(b[0]+b[1]),
             0.5*(b[2]+b[3]),
             0.5*(b[4]+b[5]) ];
}

function bound3_radius( b )
{
    return [ 0.5*(b[1]-b[0]),
             0.5*(b[3]-b[2]),
             0.5*(b[5]-b[4]) ];
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piWebVR
//
//==============================================================================

function WebVR( isVREnabledCallback, canvasElement )
{
    isVREnabledCallback(false);
    /*


    this.mSupportVR = false;
    this.mHMD = null;

    var me = this;
    var listVRDisplays = function (vrdevs) {
        for (var i = 0; i < vrdevs.length; i++)
        {
            if (vrdevs[i] instanceof VRDisplay)
            {
                me.mHMD = vrdevs[i];
                console.log("WebVR is available.");
                console.log(me.mHMD);
                break;
            }
        }

        isVREnabledCallback(true);
        me.mSupportVR = true;
    }

    if (navigator.getVRDisplays)
    {
        navigator.getVRDisplays().then(listVRDisplays);
    }

    isVREnabledCallback(false);
    this.mCanvas = canvasElement;
    */
}

WebVR.prototype.IsSupported = function()
{
    return false;
    //return this.mSupportVR;
}

WebVR.prototype.GetData = function( id )
{
    return {};
    /*
    var frameData = new VRFrameData();
    var s = this.mHMD.getFrameData(frameData);
    var ss = frameData.pose;
    
    var fovL = this.mHMD.getEyeParameters("left");
    var fovR = this.mHMD.getEyeParameters( "right" );

    // camera info
    var cPos = vec3(0.0, 0.0, 0.0);
    if (ss.position)
        cPos = vec3(-ss.position[0], -ss.position[1], -ss.position[2]);
    var rot = vec4(0.0, 0.0, 0.0, 0.0);
    if (ss.orientation)
        rot = vec4(ss.orientation[0], ss.orientation[1], ss.orientation[2], ss.orientation[3]);
    var cRot = setFromQuaternion(rot);
    var cTra = setTranslation(cPos);
    var cMat = matMul(invertFast(cRot), cTra);
    
    // per eye info
    var lTra = setTranslation( vec3(-fovL.offset[0], -fovL.offset[1], -fovL.offset[2]) );
    var lMat = matMul(lTra, cMat);
    var lPrj = [ Math.tan( fovL.fieldOfView.upDegrees * Math.PI/180.0),
                 Math.tan(fovL.fieldOfView.downDegrees * Math.PI / 180.0),
                 Math.tan(fovL.fieldOfView.leftDegrees * Math.PI / 180.0),
                 Math.tan(fovL.fieldOfView.rightDegrees * Math.PI / 180.0)];

    var rTra = setTranslation(vec3(-fovR.offset[0], -fovR.offset[1], -fovR.offset[2]));
    var rMat = matMul(rTra, cMat);
    var rPrj = [Math.tan(fovR.fieldOfView.upDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.downDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.leftDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.rightDegrees * Math.PI / 180.0)];

    return {
        mCamera   : { mCamera: cMat },
        mLeftEye  : { mVP:[0,0,fovL.renderWidth,fovL.renderHeight], mProjection:lPrj, mCamera:lMat },
        mRightEye : { mVP:[fovR.renderWidth/2,0,fovR.renderWidth,fovR.renderHeight], mProjection:rPrj, mCamera:rMat }
           };
    */
}

WebVR.prototype.Enable = function( id )
{
    /*
    this.mHMD.requestPresent([{ source: this.mCanvas }]).then(
        function ()
        {
        },
        function (err)
        {
            console.log("webVR : requestPresent failed.");
        }
    );
    */
}

WebVR.prototype.Disable = function( id )
{
    /*
    if (!this.mHMD.isPresenting)
    {
        return;
    }

    this.mHMD.exitPresent().then(
        function ()
        {
        },
        function (err)
        {
            console.log("webVR : exitPresent failed.");
        }
    );
    */
}

WebVR.prototype.RequestAnimationFrame = function (id)
{
    //this.mHMD.requestAnimationFrame(id);
}

WebVR.prototype.IsPresenting = function (id)
{
    /*
    if (this.mHMD.isPresenting)
    {
        return true;
    }
    */
    return false;
}

WebVR.prototype.Finish = function (id)
{
    /*
    if (this.mHMD.isPresenting)
    {
        this.mHMD.submitFrame();
    }
    */
}

//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piWebUtils
//
//==============================================================================


// RequestAnimationFrame
window.requestAnimFrame = ( function () { return window.requestAnimationFrame    || window.webkitRequestAnimationFrame ||
                                                 window.mozRequestAnimationFrame || window.oRequestAnimationFrame ||
                                                 window.msRequestAnimationFrame  || function( cb ) { window.setTimeout(cb,1000/60); };
                                        } )();

// performance.now
window.getRealTime = ( function() { if ("performance" in window ) return function() { return window.performance.now(); }
                                                                  return function() { return (new Date()).getTime(); }
                                  } )();

window.URL = window.URL || window.webkitURL;

navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;

function htmlEntities(str) 
{
    return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g,'&apos;');
}

function piDisableTouch()
{
    document.body.addEventListener('touchstart', function(e){ e.preventDefault(); });
}

var piGetTime = function ( timestamp )
{
    if (timestamp == 0)
        return "";
    return new Date(timestamp * 1000).toISOString().substr(0, 10);
}

function piGetCoords( obj )
{
    var x = 0;
    var y = 0; 
    do
    {
         x += obj.offsetLeft;
         y += obj.offsetTop;
    }while( obj = obj.offsetParent );

    return { mX:x, mY:y };
}

function piGetMouseCoords( ev, canvasElement )
{
    var pos = piGetCoords(canvasElement );
    var mcx =                        (ev.pageX - pos.mX) * canvasElement.width / canvasElement.offsetWidth;
    var mcy = canvasElement.height - (ev.pageY - pos.mY) * canvasElement.height / canvasElement.offsetHeight;

    return { mX: mcx, mY: mcy };

}

function piGetSourceElement( e )
{
    var ele = null;
    if( e.target )     ele = e.target;
    if( e.srcElement ) ele = e.srcElement;
    return ele;
}

function piRequestFullScreen( ele )
{
    if( ele==null ) ele =   document.documentElement;
         if( ele.requestFullscreen       ) ele.requestFullscreen();
    else if( ele.msRequestFullscreen     ) ele.msRequestFullscreen();
    else if( ele.mozRequestFullScreen    ) ele.mozRequestFullScreen();
    else if( ele.webkitRequestFullscreen ) ele.webkitRequestFullscreen( Element.ALLOW_KEYBOARD_INPUT );
}

function piIsFullScreen()
{
    return document.fullscreen || document.mozFullScreen || document.webkitIsFullScreen || document.msFullscreenElement || false;
}

function piExitFullScreen()
{
       if( document.exitFullscreen       ) document.exitFullscreen();
  else if( document.msExitFullscreen     ) document.msExitFullscreen();
  else if( document.mozCancelFullScreen  ) document.mozCancelFullScreen();
  else if( document.webkitExitFullscreen ) document.webkitExitFullscreen();
}

function piIsMobile()
{
    return (navigator.userAgent.match(/Android/i) ||
            navigator.userAgent.match(/webOS/i) ||
            navigator.userAgent.match(/iPhone/i) ||
            navigator.userAgent.match(/iPad/i) ||
            navigator.userAgent.match(/iPod/i) ||
            navigator.userAgent.match(/BlackBerry/i) ||
            navigator.userAgent.match(/Windows Phone/i)) ? true : false;
}

function piCreateGlContext( cv, useAlpha, useDepth, usePreserveBuffer, useSupersampling )
{
    var opts = { alpha: useAlpha, 
                 depth: useDepth, 
                 stencil: false, 
                 premultipliedAlpha: false, 
                 antialias: useSupersampling, 
                 preserveDrawingBuffer: usePreserveBuffer, 
                 powerPreference: "high-performance" }; // "low_power", "high_performance", "default"

    var gl = null;
    if( gl === null) gl = cv.getContext( "webgl2", opts );
    if( gl === null) gl = cv.getContext( "experimental-webgl2", opts );
    if( gl === null) gl = cv.getContext( "webgl", opts );
    if( gl === null) gl = cv.getContext( "experimental-webgl", opts );

    return gl;
}

function piCreateAudioContext()
{
    var res = null;
    try
    {
        if( window.AudioContext ) res = new AudioContext();
        if( res==null && window.webkitAudioContext ) res = new webkitAudioContext();
    }
    catch( e )
    {
        res = null;
    }
    return res;
}

function piHexColorToRGB(str) // "#ff3041"
{
    var rgb = parseInt(str.slice(1), 16);
    var r = (rgb >> 16) & 255;
    var g = (rgb >> 8) & 255;
    var b = (rgb >> 0) & 255;
    return [r, g, b];
}

function piCreateFPSCounter()
{
    var mFrame;
    var mTo;
    var mFPS;

    var iReset = function( time )
    {
        mFrame = 0;
        mTo = time;
        mFPS = 60.0;
    }

    var iCount = function( time )
    {
        mFrame++;

        if( (time-mTo)>500.0 )
        {
            mFPS = 1000.0*mFrame/(time-mTo);
            mFrame = 0;
            mTo = time;
            return true;
        }
        return false;
    }

    var iGetFPS = function()
    {
        return mFPS;
    }
    
    return { Reset : iReset, Count : iCount, GetFPS : iGetFPS };
}

function piCanMediaRecorded(canvas)
{
    if (typeof window.MediaRecorder !== 'function' || typeof canvas.captureStream !== 'function') {
        return false;
    }
    return true;
}

function piCreateMediaRecorder(isRecordingCallback, canvas) 
{
    if (piCanMediaRecorded(canvas) == false)
    {
        return null;
    }
    
    var options = { audioBitsPerSecond : 0, videoBitsPerSecond : 8000000 }; 
	     if (MediaRecorder.isTypeSupported('video/webm;codecs=h264')) options.mimeType = 'video/webm;codecs=h264';
    else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9' )) options.mimeType = 'video/webm;codecs=vp9';
    else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8' )) options.mimeType = 'video/webm;codecs=vp8';
    else                                                              options.mimeType = 'video/webm;';

    var mediaRecorder = new MediaRecorder(canvas.captureStream(), options);
    var chunks = [];
    
    mediaRecorder.ondataavailable = function(e) 
    {
        if (e.data.size > 0) 
        {
            chunks.push(e.data);
        }
    };
 
    mediaRecorder.onstart = function(){ 
        isRecordingCallback( true );
    };
    
    mediaRecorder.onstop = function()
    {
         isRecordingCallback( false );
         let blob     = new Blob(chunks, {type: "video/webm"});
         chunks       = [];
         let videoURL = window.URL.createObjectURL(blob);
         let url      = window.URL.createObjectURL(blob);
         let a        = document.createElement("a");
         document.body.appendChild(a);
         a.style      = "display: none";
         a.href       = url;
         a.download   = "capture.webm";
         a.click();
         window.URL.revokeObjectURL(url);
     };
    
    return mediaRecorder;
}

function piExportToEXR(width, height, numComponents, type, bytes)
{
    var bytesPerComponent = 0;
    if      (type=="Uint")   bytesPerComponent = 4; 
    else if (type=="Half")   bytesPerComponent = 2;
    else if (type=="Float")  bytesPerComponent = 4;

    var tHeader = 258 + (18 * numComponents + 1);
    var tTable = 8 * height;
    var tScanlines = height * (4 + 4 + (numComponents * bytesPerComponent * width));
    var tTotal = tHeader + tTable + tScanlines;

    //console.log("    header size = " + tHeader);
    //console.log("    table size = " + tTable);
    //console.log("    scanlines size = " + tScanlines);
    //console.log("    total = " + tTotal);

    var buffer = new ArrayBuffer(tTotal); 
    var data = new DataView(buffer);

    // Header
    {
        // Header : 4 bytes -> 0x76, 0x2f, 0x31, 0x01
        var c = 0;
        data.setUint8 (c++, 0x76);
        data.setUint8 (c++, 0x2f);
        data.setUint8 (c++, 0x31);
        data.setUint8 (c++, 0x01);

        // Version : 4 bytes -> 2, 0, 0, 0
        data.setUint8 (c++, 0x02);
        data.setUint8 (c++, 0x0);
        data.setUint8 (c++, 0x0);
        data.setUint8 (c++, 0x0);
        
        // Write channel info
        // Write attribute name : "channels"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x73);
            data.setUint8 (c++, 0x0);

            // Write attribute type : "chlist"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00);

            // Write attribute size : 18 x 3 + 1 = 55
            var attribSize = 18 * numComponents + 1;
            data.setUint8 (c++, attribSize); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            var i;
            for (i = 0; i < numComponents; i++)
            {
                // Attribute : "B" (42) "G" (47) "R" (52)
                if (i==0)       data.setUint8 (c++, 0x42);
                else if (i==1)  data.setUint8 (c++, 0x47);
                else if (i==2)  data.setUint8 (c++, 0x52);
                data.setUint8 (c++, 0x00);
                
                // Value : Float (2), Half (1), Uint (0)
                if      (type=="Uint")   data.setUint8 (c++, 0x00); 
                else if (type=="Half")   data.setUint8 (c++, 0x01);
                else if (type=="Float")  data.setUint8 (c++, 0x02);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);

                // Plinear
                data.setUint8 (c++, 0x01);

                // Reserved
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 

                // X sampling
                data.setUint8 (c++, 0x01); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                
                // Y sampling
                data.setUint8 (c++, 0x01);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
            }
            // End attribute
            data.setUint8 (c++, 0x00);
    
        // Write attribute name : "compression"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6d); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x00);

            // Write attribute type : "compression"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6d); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x00);

            // Write attribute size : "1"
            data.setUint8 (c++, 0x01); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // Write attribute value : "0" (None)
            data.setUint8 (c++, 0x00);

        // datawindow
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x00); 

            // box2i
            data.setUint8 (c++, 0x62); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x00);

            // size 16
            data.setUint8 (c++, 0x10); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0 3 2
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 

            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint32 (c, width-1, true);
            c += 4;
            
            data.setUint32 (c, height-1, true); 
            c += 4;

        // displayWindow
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x79); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x00);

            // box2i
            data.setUint8 (c++, 0x62); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x00); 

            // size 16
            data.setUint8 (c++, 0x10); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0 3 2
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint32 (c, width-1, true);
            c += 4;
            
            data.setUint32 (c, height-1, true); 
            c += 4;

        // lineOrder
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x4f); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00); 
            
            // lineOrder
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x4f); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00); 
            
            // size
            data.setUint8 (c++, 0x01);
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);
            
            // value 
            data.setUint8 (c++, 0x00);

        // PixelAspectRatio
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x41); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x52); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x00); 

            // float
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00);
        
            // size 4
            data.setUint8 (c++, 0x04); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 1.0
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x80); 
            data.setUint8 (c++, 0x3f);
        
        // screenWindowCenter
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x63);
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x43); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e);
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00);

            // v2f
            data.setUint8 (c++, 0x76); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x00);

            // size 8
            data.setUint8 (c++, 0x08); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

        // screenWindowWidth
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x00); 
            
            // float
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00); 

            // size
            data.setUint8 (c++, 0x04); 
            data.setUint8 (c++, 0x00);
            data.setUint8 (c++, 0x00);
            data.setUint8 (c++, 0x00);

            // value
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x80); 
            data.setUint8 (c++, 0x3f);

        // End of header
        data.setUint8 (c++, 0x00);
    }
    //console.log("header size = " + c);

    // Scanline table
    var initc = c + height * 8;
    for (var scanline = 0 ; scanline < height ; scanline ++)
    {
        var jump = initc + scanline * (8 + width * bytesPerComponent * numComponents); 
        data.setUint32 (c, jump, true);
        c += 4; 

        data.setUint32 (c, 0x00, true);
        c += 4;
    }
    //console.log("header + scanlines table size = " + c);

    // Scanlines
    for (var scanline = 0 ; scanline < height ; scanline ++)
    {
        // Scanline
        data.setUint32(c, scanline, true);
        c += 4;

        // size 24
        var size = width * numComponents * bytesPerComponent; 
        data.setUint32(c, size, true);
        c += 4;

        var numComponentsSource = 4; // number of components in the SOURCE image
        for (var component = 0; component < numComponents ; component ++) 
        {
            for (var pixel = 0 ; pixel < width ; pixel ++) 
            {
                // flip vertical, so we read OpenGL buffers without JS image flipping
                var v = bytes[(height-1-scanline) * width *numComponentsSource + pixel * numComponentsSource + (2-component)];
                if      (type=="Float") data.setFloat32(c, v, true);
                else if (type=="Half")  data.setUint16(c, v, true);

                c += bytesPerComponent;
            }
        }
    }
    //console.log("total size = " + c);
    return new Blob([buffer], {type: 'application/octet-stream'});
}


function piExportToWAV(numSamples, rate, bits, numChannels, words)
{
    let numBytes = numSamples * numChannels * bits/8;

    let buffer = new ArrayBuffer(44 + numBytes); 
    let data = new DataView(buffer);

    {
        data.setUint32( 0, 0x46464952, true );  // RIFF
        data.setUint32( 4, numBytes + 36, true);
        {
            data.setUint32( 8, 0x45564157, true );  // WAV_WAVE
            data.setUint32( 12, 0x20746D66, true );  // WAV_FMT
            {
                data.setUint32( 16, 16, true);
                data.setUint16( 20, 1, true ); // WAV_FORMAT_PCM
                data.setUint16( 22, numChannels, true);
                data.setUint32( 24, rate, true);
                data.setUint32( 28, rate*numChannels*bits / 8, true);
                data.setUint16( 32, numChannels*bits / 8, true);
                data.setUint16( 34, bits, true);
            }

            data.setUint32( 36, 0x61746164, true);  // WAV_DATA
            {
                data.setUint32( 40, numBytes, true);
                let numWords = numSamples * numChannels;
                for(let i=0; i<numWords; i++ )
                {
                    data.setInt16( 44 + i*2, words[i], true );
                }
            }
        }
    }


    //console.log("total size = " + c);
    return new Blob([buffer], {type: 'application/octet-stream'});
}

function piTriggerDownload(name, blob)
{
    let url = URL.createObjectURL(blob);
    let aElement = document.createElement("a");
    aElement.href     = url;
    aElement.target   = "_self";
    aElement.download = name;
    document.body.appendChild(aElement);
    aElement.click();
    document.body.removeChild(aElement);
}</script>
    <script>"use strict"

function bufferID_to_assetID( id )
{
    if( id===0 ) return '4dXGR8';
    if( id===1 ) return 'XsXGR8';
    if( id===2 ) return '4sXGR8';
    if( id===3 ) return 'XdfGR8';
    return 'none';
}
function assetID_to_bufferID( id )
{
    if( id==='4dXGR8' ) return 0;
    if( id==='XsXGR8' ) return 1;
    if( id==='4sXGR8' ) return 2;
    if( id==='XdfGR8' ) return 3;
    return -1;
}

function assetID_to_cubemapBuferID( id )
{
    if( id==='4dX3Rr' ) return 0;
    return -1;
}
function cubamepBufferID_to_assetID( id )
{
    if( id===0 ) return '4dX3Rr';
    return 'none';
}

function EffectPass( renderer, is20, isLowEnd, hasShaderTextureLOD, callback, obj, forceMuted, forcePaused, outputGainNode, copyProgram, id, effect  )
{
    this.mID = id;
    this.mInputs  = [null, null, null, null ];
    this.mOutputs = [null, null, null, null ];
    this.mSource = null;

    this.mGainNode = outputGainNode;
    this.mSoundShaderCompiled = false;

    this.mEffect = effect;
    this.mRenderer = renderer;
    this.mProgramCopy = copyProgram; 
    this.mCompilationTime = 0;

    this.mType = "none";
    this.mName = "none";
    this.mFrame = 0;

    this.mShaderTextureLOD = hasShaderTextureLOD;
    this.mIs20 = is20;
    this.mIsLowEnd = isLowEnd;
    this.mTextureCallbackFun = callback;
    this.mTextureCallbackObj = obj;
    this.mForceMuted = forceMuted;
    this.mForcePaused = forcePaused;
}

EffectPass.prototype.MakeHeader_Image = function()
{
    let header = "";

    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for( let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        // old API
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                  header += "uniform sampler2D iChannel" + i + ";\n";

        // new API (see shadertoy.com/view/wtdGW8)
        header += "uniform struct {\n";
             if( inp===null )                  header += "  sampler2D";
        else if( inp.mInfo.mType==="cubemap" ) header += "  samplerCube";
        else if( inp.mInfo.mType==="volume"  ) header += "  sampler3D";
        else                                  header += "  sampler2D";
        header +=        " sampler;\n";
        header += "  vec3  size;\n";
        header += "  float time;\n";
        header += "  int   loaded;\n";
        header += "}iCh" + i + ";\n";
    }
	header += "void mainImage( out vec4 c, in vec2 f );\n";
    header += "void st_assert( bool cond );\n";
    header += "void st_assert( bool cond, int v );\n";

    if( this.mIs20 ) 
    {
        header += "\nout vec4 shadertoy_out_color;\n" +
        "void st_assert( bool cond, int v ) {if(!cond){if(v==0)shadertoy_out_color.x=-1.0;else if(v==1)shadertoy_out_color.y=-1.0;else if(v==2)shadertoy_out_color.z=-1.0;else shadertoy_out_color.w=-1.0;}}\n" +
        "void st_assert( bool cond        ) {if(!cond)shadertoy_out_color.x=-1.0;}\n" +
        "void main( void )" +
        "{" +
            "shadertoy_out_color = vec4(1.0,1.0,1.0,1.0);" + 
            "vec4 color = vec4(0.0,0.0,0.0,1.0);" +
            "mainImage( color, gl_FragCoord.xy );" +
            "if(shadertoy_out_color.x<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(shadertoy_out_color.y<0.0) color=vec4(0.0,1.0,0.0,1.0);" +
            "if(shadertoy_out_color.z<0.0) color=vec4(0.0,0.0,1.0,1.0);" +
            "if(shadertoy_out_color.w<0.0) color=vec4(1.0,1.0,0.0,1.0);" +
            "shadertoy_out_color = vec4(color.xyz,1.0);" +
        "}";
    }
    else
    {
        header += "" +
        "void st_assert( bool cond, int v ) {if(!cond){if(v==0)gl_FragColor.x=-1.0;else if(v==1)gl_FragColor.y=-1.0;else if(v==2)gl_FragColor.z=-1.0;else gl_FragColor.w=-1.0;}}\n" +
        "void st_assert( bool cond        ) {if(!cond)gl_FragColor.x=-1.0;}\n" +
        "void main( void )" +
        "{" +
            "gl_FragColor = vec4(0.0,0.0,0.0,1.0);" + 
            "vec4 color = vec4(0.0,0.0,0.0,1.0);" +
            "mainImage( color, gl_FragCoord.xy );" +
            "color.w = 1.0;" +
            "if(gl_FragColor.w<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(gl_FragColor.x<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(gl_FragColor.y<0.0) color=vec4(0.0,1.0,0.0,1.0);" +
            "if(gl_FragColor.z<0.0) color=vec4(0.0,0.0,1.0,1.0);" +
            "if(gl_FragColor.w<0.0) color=vec4(1.0,1.0,0.0,1.0);" +
            "gl_FragColor = vec4(color.xyz,1.0);"+
        "}";
    }
    header += "\n";

    /*
    this.mImagePassFooterVR = "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 ) 
        this.mImagePassFooterVR += "\nout vec4 outColor;\n";
    this.mImagePassFooterVR += "void main( void )" +
    "{" +
        "vec4 color = vec4(0.0,0.0,0.0,1.0);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainVR( color, gl_FragCoord.xy-unViewport.xy, ro, rd );" +
        "color.w = 1.0;"
    if( this.mIs20 ) 
        this.mImagePassFooterVR +=  "outColor = color;}";
    else
        this.mImagePassFooterVR +=  "gl_FragColor = color;}";
    */
    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Buffer = function()
{
    let header = "";
    
    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                  header += "uniform sampler2D iChannel" + i + ";\n";
    }

	header += "void mainImage( out vec4 c,  in vec2 f );\n"

    if( this.mIs20 )
        header += "\nout vec4 outColor;\n";
    header += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(0.0,0.0,0.0,1.0);" +
        "mainImage( color, gl_FragCoord.xy );";
    if( this.mIs20 )
        header +="outColor = color; }";
    else
        header +="gl_FragColor = color; }";
    header += "\n";

    /*
    this.mImagePassFooterVR = "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 )
    this.mImagePassFooterVR += "\nout vec4 outColor;\n";
    this.mImagePassFooterVR += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(0.0,0.0,0.0,1.0);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainVR( color, gl_FragCoord.xy-unViewport.xy, ro, rd );";
    if( this.mIs20 )
        this.mImagePassFooterVR +="outColor = color; }";
    else
        this.mImagePassFooterVR +="gl_FragColor = color; }";
    */
    this.mHeader = header;
    this.mHeaderLength = 0;
}


EffectPass.prototype.MakeHeader_Cubemap = function()
{
    let header = "";
    
    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                   header += "uniform sampler2D iChannel" + i + ";\n";
    }

	header += "void mainCubemap( out vec4 c, in vec2 f, in vec3 ro, in vec3 rd );\n"

    header += "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 )
        header += "\nout vec4 outColor;\n";
    header += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(0.0,0.0,0.0,1.0);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainCubemap( color, gl_FragCoord.xy-unViewport.xy, ro, rd );";
    if( this.mIs20 )
        header +="outColor = color; }";
    else
        header +="gl_FragColor = color; }";
    header += "\n";

    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Sound = function()
{
    let header = "";

    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform float     iChannelTime[4];\n" +
              "uniform float     iTimeOffset;\n" +
              "uniform int       iSampleOffset;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n";

    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp!==null && inp.mInfo.mType==="cubemap" )
            header += "uniform samplerCube iChannel" + i + ";\n";
        else
            header += "uniform sampler2D iChannel" + i + ";\n";
    }
    header += "\n";
    header += "vec2 mainSound( in int samp, float time );\n";

    if( this.mIs20 )
    {
        header += "out vec4 outColor; void main()" +
            "{" +
            "float t = iTimeOffset + ((gl_FragCoord.x-0.5) + (gl_FragCoord.y-0.5)*512.0)/iSampleRate;" +
            "int   s = iSampleOffset + int(gl_FragCoord.y-0.2)*512 + int(gl_FragCoord.x-0.2);" +
            "vec2 y = mainSound( s, t );" +
            "vec2 v  = floor((0.5+0.5*y)*65536.0);" +
            "vec2 vl =   mod(v,256.0)/255.0;" +
            "vec2 vh = floor(v/256.0)/255.0;" +
            "outColor = vec4(vl.x,vh.x,vl.y,vh.y);" +
            "}";
    }
    else
    {
        header += "void main()" +
            "{" +
            "float t = iTimeOffset + ((gl_FragCoord.x-0.5) + (gl_FragCoord.y-0.5)*512.0)/iSampleRate;" +
            "vec2 y = mainSound( 0, t );" +
            "vec2 v  = floor((0.5+0.5*y)*65536.0);" +
            "vec2 vl =   mod(v,256.0)/255.0;" +
            "vec2 vh = floor(v/256.0)/255.0;" +
            "gl_FragColor = vec4(vl.x,vh.x,vl.y,vh.y);" +
            "}";
    }
    header += "\n";
    this.mHeader = header;
    this.mHeaderLength = 0;
}


EffectPass.prototype.MakeHeader_Common = function ()
{
    let header = "";
    let headerlength = 0;

    header += "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n";
    headerlength += 2;

    if (this.mIs20)
    {
        header += "out vec4 outColor;\n";
        headerlength += 1;
    }
    header += "void main( void )\n";
    headerlength += 1;

    if (this.mIs20)
        header += "{ outColor = vec4(0.0); }";
    else
        header += "{ gl_FragColor = vec4(0.0); }";
    headerlength += 1;
    header += "\n";
    headerlength += 1;

    this.mHeader = header;
    this.mHeaderLength = headerlength;
}

EffectPass.prototype.MakeHeader = function()
{
         if( this.mType==="image" ) this.MakeHeader_Image();
    else if( this.mType==="sound" ) this.MakeHeader_Sound();
    else if( this.mType==="buffer") this.MakeHeader_Buffer();
    else if( this.mType==="common") this.MakeHeader_Common();
    else if( this.mType==="cubemap") this.MakeHeader_Cubemap();
    else console.log("ERROR 4");
}

EffectPass.prototype.Create_Image = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mSupportsVR = false;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    //this.mProgramVR = null;
}
EffectPass.prototype.Destroy_Image = function( wa )
{
}

EffectPass.prototype.Create_Buffer = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mSupportsVR = false;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    //this.mProgramVR = null;
}

EffectPass.prototype.Destroy_Buffer = function( wa )
{
}

EffectPass.prototype.Create_Cubemap = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
}

EffectPass.prototype.Destroy_Cubemap = function( wa )
{
}

EffectPass.prototype.Create_Common = function( wa )
{
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.MakeHeader();
}
EffectPass.prototype.Destroy_Common = function( wa )
{
}

EffectPass.prototype.Create_Sound = function (wa)
{
    this.MakeHeader();


    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    this.mSampleRate = 44100;
    this.mPlayTime = 60*3;
    this.mPlaySamples = this.mPlayTime*this.mSampleRate;
    this.mBuffer = wa.createBuffer( 2, this.mPlaySamples, this.mSampleRate );

    //-------------------
    this.mTextureDimensions = 512;
    this.mRenderTexture = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D, 
                                                       this.mTextureDimensions, this.mTextureDimensions,
                                                       this.mRenderer.TEXFMT.C4I8,
                                                       this.mRenderer.FILTER.NONE,
                                                       this.mRenderer.TEXWRP.CLAMP, null);
    this.mRenderFBO = this.mRenderer.CreateRenderTarget(this.mRenderTexture, null, null, null, null, false);

    //-----------------------------

    // ArrayBufferView pixels;
    this.mTmpBufferSamples = this.mTextureDimensions*this.mTextureDimensions;
    this.mData = new Uint8Array( this.mTmpBufferSamples*4 );

    this.mPlaying = false;
}

EffectPass.prototype.Destroy_Sound = function( wa )
{
    if( this.mPlayNode!==null ) this.mPlayNode.stop();
    this.mPlayNode = null;
    this.mBuffer = null;
    this.mData = null;

    this.mRenderer.DestroyRenderTarget(this.mRenderFBO);
    this.mRenderer.DestroyTexture(this.mRenderTexture);
}

EffectPass.prototype.Create = function( passType, wa )
{
    this.mType = passType;
    this.mSource = null;

         if( passType==="image" ) this.Create_Image( wa );
    else if( passType==="sound" ) this.Create_Sound( wa );
    else if( passType==="buffer") this.Create_Buffer( wa );
    else if( passType==="common") this.Create_Common( wa );
    else if( passType==="cubemap") this.Create_Cubemap( wa );
    else alert("ERROR 1");
}

EffectPass.prototype.SetName = function (passName)
{
    this.mName = passName;
}

EffectPass.prototype.SetCode = function (src)
{
    this.mSource = src;
}

EffectPass.prototype.Destroy = function( wa )
{
    this.mSource = null;
         if( this.mType==="image" ) this.Destroy_Image( wa );
    else if( this.mType==="sound" ) this.Destroy_Sound( wa );
    else if( this.mType==="buffer") this.Destroy_Buffer( wa );
    else if( this.mType==="common") this.Destroy_Common( wa );
    else if( this.mType==="cubemap") this.Destroy_Cubemap( wa );
    else alert("ERROR 2");
}

EffectPass.prototype.NewShader_Sound = function( shaderCode, commonShaderCodes)
{
    let vsSource = null;

    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for( let i=0; i<commonShaderCodes.length; i++ )
    {
        fsSource += commonShaderCodes[i]+'\n';
    }
    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;
    fsSource += shaderCode;

    this.mSoundShaderCompiled = false;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader_Image = function ( shaderCode, commonShaderCodes )
{
    this.mSupportsVR = false;


    let vsSource = null;
    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for (let i = 0; i < commonShaderCodes.length; i++)
    {
        fsSource += commonShaderCodes[i]+'\n';
    }
    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;
    fsSource += shaderCode;

    return [vsSource, fsSource];


    /*
    let n1 = shaderCode.indexOf("mainVR(");
    let n2 = shaderCode.indexOf("mainVR (");
    let n3 = shaderCode.indexOf("mainVR  (");
    if( n1>0 || n2>0 || n3>0 )
    {
        let vsSourceVR;
        if( this.mIs20 )
            vsSourceVR = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        else
            vsSourceVR = "attribute in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

        let fsSourceVR = this.mHeader;
        for (let i = 0; i < commonShaderCodes.length; i++) {
            fsSourceVR += commonShaderCodes[i];
        }
        fsSourceVR += shaderCode;
        fsSourceVR += this.mImagePassFooterVR;

        let res = this.mRenderer.CreateShader(vsSource, fsSourceVR, preventCache);
        if( res.mResult == false )
        {
            return res.mInfo;
        }
        if( this.mProgramVR != null )
            this.mRenderer.DestroyShader( this.mProgramVR );

        this.mSupportsVR = true;
        this.mProgramVR = res;
    }
    */
}

EffectPass.prototype.NewShader_Cubemap = function( shaderCode, commonShaderCodes )
{
    let vsSource = null;
    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for (let i = 0; i < commonShaderCodes.length; i++)
    {
        fsSource += commonShaderCodes[i]+'\n';
    }

    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;

    fsSource += shaderCode;

    return [vsSource, fsSource];
}


EffectPass.prototype.NewShader_Common = function (shaderCode )
{
    let vsSource = null;
    if (this.mIs20)
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader + shaderCode;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader = function ( commonSourceCodes, preventCache, onResolve)
{
    if( this.mRenderer===null ) return;

    let vs_fs = null;

         if( this.mType==="sound"  ) vs_fs = this.NewShader_Sound(   this.mSource, commonSourceCodes );
    else if( this.mType==="image"  ) vs_fs = this.NewShader_Image(   this.mSource, commonSourceCodes );
    else if( this.mType==="buffer" ) vs_fs = this.NewShader_Image(   this.mSource, commonSourceCodes );
    else if( this.mType==="common" ) vs_fs = this.NewShader_Common(  this.mSource,                   );
    else if( this.mType==="cubemap") vs_fs = this.NewShader_Cubemap( this.mSource, commonSourceCodes );
    else { console.log("ERROR 3: \"" + this.mType + "\""); return; }

    let me = this;
    this.mRenderer.CreateShader(vs_fs[0], vs_fs[1], preventCache, false,
        function (worked, info)
        {
            if (worked === true)
            {
                if (me.mType === "sound")
                {
                    me.mSoundShaderCompiled = true;
                }

                me.mCompilationTime = info.mTime;
                me.mError = false;
                me.mErrorStr = "No Errors";
                if (me.mProgram !== null)
                    me.mRenderer.DestroyShader(me.mProgram);
                me.mTranslatedSource = me.mRenderer.GetTranslatedShaderSource(info);
                me.mProgram = info;
            }
            else
            {
                me.mError = true;
                me.mErrorStr = info.mErrorStr;
            }
            onResolve();
        });
}

EffectPass.prototype.DestroyInput = function( id )
{
    if( this.mInputs[id]===null ) return;

    if( this.mInputs[id].mInfo.mType==="texture" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    if( this.mInputs[id].mInfo.mType==="volume" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="webcam" )
    {
        this.mInputs[id].video.pause();
        this.mInputs[id].video.src = "";

        if( this.mInputs[id].video.srcObject!==null )
        {
        let tracks = this.mInputs[id].video.srcObject.getVideoTracks();
        if( tracks ) tracks[0].stop();
        }
        this.mInputs[id].video = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="video" )
    {
        this.mInputs[id].video.pause();
        this.mInputs[id].video = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="music" || this.mInputs[id].mInfo.mType==="musicstream")
    {
        this.mInputs[id].audio.pause();
        this.mInputs[id].audio.mSound.mFreqData = null;
        this.mInputs[id].audio.mSound.mWaveData = null;
        this.mInputs[id].audio = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="cubemap" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="keyboard" )
    {
        //if( this.mInputs[id].globject != null )
          //  this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="mic" )
    {
        this.mInputs[id].mic = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }

    this.mInputs[id] = null;
}

EffectPass.prototype.TooglePauseInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused )
        {
            inp.video.play();
            inp.video.mPaused = false;
        }
        else
        {
            inp.video.pause();
            inp.video.mPaused = true;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        wa.resume()
        if( inp.audio.mPaused )
        {
            if( inp.loaded )
            {
                inp.audio.play();
            }
            inp.audio.mPaused = false;
        }
        else
        {
            inp.audio.pause();
            inp.audio.mPaused = true;
        }
        return inp.audio.mPaused;
    }

    return null;
}

EffectPass.prototype.StopInput = function( id )
{
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused === false )
        {
            inp.video.pause();
            inp.video.mPaused = true;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
    {
        if( inp.audio.mPaused === false )
        {
            inp.audio.pause();
            inp.audio.mPaused = true;
        }
        return inp.audio.mPaused;
    }
    return null;
}

EffectPass.prototype.ResumeInput = function( id )
{
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused )
        {
            inp.video.play();
            inp.video.mPaused = false;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
    {
        if( inp.audio.mPaused )
        {
            inp.audio.play();
            inp.audio.mPaused = false;
        }
        return inp.audio.mPaused;
    }
    return null;
}

EffectPass.prototype.RewindInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];

    if( inp==null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.loaded )
        {
            inp.video.currentTime = 0;
        }
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        wa.resume()
        if( inp.loaded )
        {
            inp.audio.currentTime = 0;
        }
    }
}

EffectPass.prototype.MuteInput = function( wa, id )
{
    let inp = this.mInputs[id];
    if( inp===null ) return;

    if( inp.mInfo.mType==="video" )
    {
        inp.video.muted = true;
        inp.video.mMuted = true;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if (wa !== null) inp.audio.mSound.mGain.gain.value = 0.0;
        inp.audio.mMuted = true;
    }
}

EffectPass.prototype.UnMuteInput = function( wa, id )
{
    let inp = this.mInputs[id];
    if( inp===null ) return;

    if( inp.mInfo.mType==="video" )
    {
        inp.video.muted = false;
        inp.video.mMuted = false;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if (wa !== null) inp.audio.mSound.mGain.gain.value = 1.0;
        inp.audio.mMuted = false;
    }
}

EffectPass.prototype.ToggleMuteInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];
    if( inp===null ) return null;

    if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mMuted ) this.UnMuteInput(wa,id);
        else                   this.MuteInput(wa,id);
        return inp.video.mMuted;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if( inp.audio.mMuted ) this.UnMuteInput(wa,id);
        else                   this.MuteInput(wa,id);
        return inp.audio.mMuted;
    }

    return null;
}

EffectPass.prototype.UpdateInputs = function( wa, forceUpdate, keyboard )
{
   for (let i=0; i<this.mInputs.length; i++ )
   {
        let inp = this.mInputs[i];

        if( inp===null )
        {
            if( forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, null, false, 0, 0, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.image, true, 1, 1, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mPreview, true, 1, 1, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
            if( inp.loaded && forceUpdate )
            {
                if( this.mTextureCallbackFun!==null )
                {
                    let img = (assetID_to_cubemapBuferID(inp.mInfo.mID)===-1) ? inp.image[0] : inp.mImage;
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, img, true, 2, 1, -1.0, this.mID );
                }
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:keyboard.mIcon,mData:keyboard.mData}, false, 6, 0, -1.0, this.mID );
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, -1, this.mID );
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
              if( inp.loaded && inp.audio.mPaused === false && inp.audio.mForceMuted === false )
              {
                  if( wa !== null )
                  {
                      inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                      inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                  }

                  if (this.mTextureCallbackFun!==null)
                  {
                           if (inp.mInfo.mType === "music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:(wa==null)?null:inp.audio.mSound.mFreqData}, false, 4, 1, inp.audio.currentTime, this.mID);
                      else if (inp.mInfo.mType === "musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:(wa==null)?null:inp.audio.mSound.mFreqData, info: inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                  }
              }
              else if( inp.loaded===false )
              {
                  if (this.mTextureCallbackFun!==null)
                      this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:null}, false, 4, 0, -1.0, this.mID);
              }
        }
        else if( inp.mInfo.mType==="mic" )
        {
              if( inp.loaded && inp.mForceMuted === false )
              {
                  if( wa !== null )
                  {
                      inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                      inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
                  }
                  if( this.mTextureCallbackFun!==null )
                      this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave: ((wa==null)?null:inp.mFreqData) }, false, 5, 1, 0, this.mID );
              }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:null}, true, 9, 1, -1.0, this.mID );
            }
        }
    }
}

EffectPass.prototype.Sampler2Renderer = function (sampler)
{
    let filter = this.mRenderer.FILTER.NONE;
    if (sampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
    if (sampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
    let wrap = this.mRenderer.TEXWRP.REPEAT;
    if (sampler.wrap === "clamp") wrap = this.mRenderer.TEXWRP.CLAMP;
    let vflip = false;
    if (sampler.vflip === "true") vflip = true;

    return { mFilter: filter, mWrap: wrap, mVFlip: vflip };
}

EffectPass.prototype.GetSamplerVFlip = function (id)
{
    let inp = this.mInputs[id];
    return inp.mInfo.mSampler.vflip;
}

EffectPass.prototype.GetTranslatedShaderSource = function ()
{
    return this.mTranslatedSource;
}


EffectPass.prototype.SetSamplerVFlip = function (id, str) 
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let filter = false;
    if (str === "true") filter = true;

    if (inp === null)
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
    }
    else if (inp.mInfo.mType === "video")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "webcam")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, null);
            inp.mInfo.mSampler.vflip = str;
        }
    }
}

EffectPass.prototype.GetAcceptsVFlip = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return false;
    if (inp.mInfo.mType === "video")  return true;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return true;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return false;
    return true;
}

EffectPass.prototype.GetSamplerFilter = function (id)
{
    let inp = this.mInputs[id];
    if( inp===null) return;
    return inp.mInfo.mSampler.filter;
}

EffectPass.prototype.SetSamplerFilter = function (id, str, buffers, cubeBuffers) 
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let filter = renderer.FILTER.NONE;
    if (str === "linear") filter = renderer.FILTER.LINEAR;
    if (str === "mipmap") filter = renderer.FILTER.MIPMAP;

    if (inp === null)
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "video")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap")
    {
        if (inp.loaded) 
        {
            if( assetID_to_cubemapBuferID(inp.mInfo.mID)===0)
            {
                renderer.SetSamplerFilter(cubeBuffers[0].mTexture[0], filter, true);
                renderer.SetSamplerFilter(cubeBuffers[0].mTexture[1], filter, true);
                inp.mInfo.mSampler.filter = str;
            }
            else
            {
                renderer.SetSamplerFilter(inp.globject, filter, true);
                inp.mInfo.mSampler.filter = str;
            }
        }
    }
    else if (inp.mInfo.mType === "webcam")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "buffer")
    {
        renderer.SetSamplerFilter(buffers[inp.id].mTexture[0], filter, true);
        renderer.SetSamplerFilter(buffers[inp.id].mTexture[1], filter, true);
        inp.mInfo.mSampler.filter = str;
    }
    else if (inp.mInfo.mType === "keyboard")
    {
        inp.mInfo.mSampler.filter = str;
    }
}



EffectPass.prototype.GetAcceptsMipmapping = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return this.mIs20;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return this.mIs20;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return this.mIs20;
    return false;
}

EffectPass.prototype.GetAcceptsLinear = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return true;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return true;
    if (inp.mInfo.mType === "music")  return true;
    if (inp.mInfo.mType === "musicstream") return true;
    if (inp.mInfo.mType === "mic")  return true;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return true;
    return false;
}


EffectPass.prototype.GetAcceptsWrapRepeat = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return this.mIs20;
    if (inp.mInfo.mType === "cubemap") return false;
    if (inp.mInfo.mType === "webcam")  return this.mIs20;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return this.mIs20;
    return false;
}

EffectPass.prototype.GetSamplerWrap = function (id)
{
    let inp = this.mInputs[id];
    return inp.mInfo.mSampler.wrap;
}
EffectPass.prototype.SetSamplerWrap = function (id, str, buffers)
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let restr = renderer.TEXWRP.REPEAT;
    if (str === "clamp") restr = renderer.TEXWRP.CLAMP;

    if (inp === null) 
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "video") 
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap") 
    {
        if (inp.loaded)
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "webcam") 
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "buffer")
    {
        renderer.SetSamplerWrap(buffers[inp.id].mTexture[0], restr);
        renderer.SetSamplerWrap(buffers[inp.id].mTexture[1], restr);
        inp.mInfo.mSampler.wrap = str;
    }
}


EffectPass.prototype.GetTexture = function( slot )
{
    let inp = this.mInputs[slot];
    if( inp===null ) return null;
    return inp.mInfo;

}

EffectPass.prototype.SetOutputs = function( slot, id )
{
    this.mOutputs[slot] = id;
}

EffectPass.prototype.SetOutputsByBufferID = function( slot, id )
{
    if( this.mType==="buffer" )
    {
        this.mOutputs[slot] = bufferID_to_assetID( id );

        this.mEffect.ResizeBuffer( id, this.mEffect.mXres, this.mEffect.mYres, false );
    }
    else if( this.mType==="cubemap" )
    {
        this.mOutputs[slot] = cubamepBufferID_to_assetID( id );
        this.mEffect.ResizeCubemapBuffer(id, 1024, 1024 );
    }
}

EffectPass.prototype.NewTexture = function( wa, slot, url, buffers, cubeBuffers, keyboard )
{
    var me = this;
    var renderer = this.mRenderer;

    if( renderer===null ) return;

    let texture = null;

    if( url===null || url.mType===null )
    {
        if( me.mTextureCallbackFun!==null )
            me.mTextureCallbackFun( this.mTextureCallbackObj, slot, null, true, 0, 0, -1.0, me.mID );
        me.DestroyInput( slot );
        me.mInputs[slot] = null;
        me.MakeHeader();
        return { mFailed:false, mNeedsShaderCompile:false };
    }
    else if( url.mType==="texture" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.image = new Image();
        texture.image.crossOrigin = '';
        texture.image.onload = function()
        {
            let rti = me.Sampler2Renderer(url.mSampler);

            // O.M.G. FIX THIS
            let channels = renderer.TEXFMT.C4I8;
            if (url.mID === "Xdf3zn" || url.mID === "4sf3Rn" || url.mID === "4dXGzn" || url.mID === "4sf3Rr")
                channels = renderer.TEXFMT.C1I8;
            
            texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.image, channels, rti.mFilter, rti.mWrap, rti.mVFlip);

            texture.loaded = true;
            if( me.mTextureCallbackFun!==null )
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.image, true, 1, 1, -1.0, me.mID );
        }
        texture.image.src = url.mSrc;


        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="volume" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.mImage = { mData:null, mXres:1, mYres:0, mZres:0 };
        texture.mPreview = new Image();
        texture.mPreview.crossOrigin = '';

	    var xmlHttp = new XMLHttpRequest();
        if( xmlHttp===null ) return { mFailed:true };

        xmlHttp.open('GET', url.mSrc, true);
        xmlHttp.responseType = "arraybuffer";
        xmlHttp.onerror = function()
        {
            console.log( "Error 1 loading Volume" );
        }
        xmlHttp.onload = function()
        {
            let data = xmlHttp.response;
            if (!data ) { console.log( "Error 2 loading Volume" ); return; }

            let file = piFile(data);

            let signature = file.ReadUInt32();
            texture.mImage.mXres = file.ReadUInt32();
            texture.mImage.mYres = file.ReadUInt32();
            texture.mImage.mZres = file.ReadUInt32();
            let binNumChannels = file.ReadUInt8();
            let binLayout = file.ReadUInt8();
            let binFormat = file.ReadUInt16();
            let format = renderer.TEXFMT.C1I8;
                 if( binNumChannels===1 && binFormat===0 )  format = renderer.TEXFMT.C1I8;
            else if( binNumChannels===2 && binFormat===0 )  format = renderer.TEXFMT.C2I8;
            else if( binNumChannels===3 && binFormat===0 )  format = renderer.TEXFMT.C3I8;
            else if( binNumChannels===4 && binFormat===0 )  format = renderer.TEXFMT.C4I8;
            else if( binNumChannels===1 && binFormat===10 ) format = renderer.TEXFMT.C1F32;
            else if( binNumChannels===2 && binFormat===10 ) format = renderer.TEXFMT.C2F32;
            else if( binNumChannels===3 && binFormat===10 ) format = renderer.TEXFMT.C3F32;
            else if( binNumChannels===4 && binFormat===10 ) format = renderer.TEXFMT.C4F32;
            else return;

            let buffer = new Uint8Array(data, 20); // skip 16 bytes (header of .bin)

            let rti = me.Sampler2Renderer(url.mSampler);

            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T3D, texture.mImage.mXres, texture.mImage.mYres, format, rti.mFilter, rti.mWrap, buffer);

            if( texture.globject===null )
            {
                console.log( "Error 4: loading Volume" ); 
                return { mFailed:true };
            }

            if (me.mTextureCallbackFun !== null)
            {
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mPreview, true, 1, 1, -1.0, me.mID );
            }

            texture.loaded = true;

            // load icon for it
            texture.mPreview.onload = function()
            {
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mPreview, true, 1, 1, -1.0, me.mID );
            }
            texture.mPreview.src = url.mPreviewSrc;
        }
        xmlHttp.send("");


        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]==null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="volume")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="cubemap" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;

        let rti = me.Sampler2Renderer(url.mSampler);

        if( assetID_to_cubemapBuferID(url.mID)!==-1 )
        {
            texture.mImage = new Image();
            texture.mImage.onload = function()
            {
                texture.loaded = true;
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mImage, true, 2, 1, -1.0, me.mID );
            }
            texture.mImage.src = "/media/previz/cubemap00.png";

            this.mEffect.ResizeCubemapBuffer(0, 1024, 1024 );

        }
        else
        {
            texture.image = [ new Image(), new Image(), new Image(), new Image(), new Image(), new Image() ];

            let numLoaded = 0;
            for (var i=0; i<6; i++ )
            {
                texture.image[i].mId = i;
                texture.image[i].crossOrigin = '';
                texture.image[i].onload = function()
                {
                    var id = this.mId;
                    numLoaded++;
                    if( numLoaded===6 )
                    {
                        texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.CUBEMAP, texture.image, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                        texture.loaded = true;
                        if (me.mTextureCallbackFun !== null)
                            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, texture.image[0], true, 2, 1, -1.0, me.mID);
                    }
                }

                if( i === 0) 
                {
                    texture.image[i].src = url.mSrc;
                } 
                else 
                {
                    let n = url.mSrc.lastIndexOf(".");
                    texture.image[i].src = url.mSrc.substring(0, n) + "_" + i + url.mSrc.substring(n, url.mSrc.length);
                }
            }
        }

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]==null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="cubemap")) };

        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="webcam" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;

        texture.video = document.createElement('video');
    	texture.video.width = 320;
    	texture.video.height = 240;
    	texture.video.autoplay = true;
    	texture.video.loop = true;
        texture.mForceMuted = this.mForceMuted;
        texture.mImage = null;

        let rti = me.Sampler2Renderer(url.mSampler);

        var loadImageInsteadOfWebCam = function()
        {
            texture.mImage = new Image();
            texture.mImage.onload = function()
            {
                texture.loaded = true;
                texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.mImage, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mImage, true, 7, 1, -1.0, me.mID );
            }
            texture.mImage.src = "/media/previz/webcam.png";
        }
        
        loadImageInsteadOfWebCam();

        if( typeof navigator.getUserMedia !== "undefined"  && texture.mForceMuted===false )
        {
            texture.video.addEventListener("canplay", function (e)
            {
				try
				{
                    texture.mImage = null;
                    if( texture.globject != null )
                        renderer.DestroyTexture( texture.globject );
					texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.video, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
					texture.loaded = true;
                }
                catch(e)
                {
                    loadImageInsteadOfWebCam();
	                alert( 'Your browser can not transfer webcam data to the GPU.');
                }
            } );

            navigator.mediaDevices.getUserMedia( 
                                { "video": { width: 1280, height: 720 }, "audio": false } )
                                .then( function(stream)
                                       {
                                            texture.video.srcObject = stream;
    	                               } )
                                .catch( function(error)
                                        {
                                            loadImageInsteadOfWebCam();
    		                                alert( 'Unable to capture WebCam. Please reload the page.' );
    	                                } );
        }
        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]==null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!="music") && 
                                                                (this.mInputs[slot].mInfo.mType!="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="mic" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.mForceMuted = this.mForceMuted;
        texture.mAnalyser = null;
        let num = 512;
        texture.mFreqData = new Uint8Array( num );
        texture.mWaveData = new Uint8Array( num );

        if( wa === null || typeof navigator.getUserMedia === "undefined" )
        {
            if( !texture.mForceMuted ) alert( "Shadertoy: Web Audio not implement in this browser" );
            texture.mForceMuted = true; 
        }

        if( texture.mForceMuted )
        {
            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, num, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null)
            texture.loaded = true;
        }
        else
        {
        navigator.getUserMedia( { "audio": true },
                                function(stream)
                                {
                                  texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, null)
                                  texture.mic = wa.createMediaStreamSource(stream);
                                  texture.mAnalyser = wa.createAnalyser();
                                  texture.mic.connect( texture.mAnalyser );
                                  texture.loaded = true;
    	                        },
                                function(error)
                                {
    		                        alert( 'Unable open Mic. Please reload the page.' );
    	                        } );
        }
        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="video" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.video = document.createElement('video');
    	texture.video.loop = true;
        texture.video.preload = "auto";
        texture.video.mPaused = this.mForcePaused;
        texture.video.mMuted = true;//this.mForceMuted;
    	texture.video.muted  = true;//this.mForceMuted;
        if( this.mForceMuted===true )
            texture.video.volume = 0;
    	texture.video.autoplay = false;
        texture.video.hasFalled = false;
        
        let rti = me.Sampler2Renderer(url.mSampler);

        texture.video.addEventListener("canplay", function (e)
        {
            texture.video.play().then( function()
                                       {
                                           texture.video.mPaused = false;

                                           texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.video, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                                           texture.loaded = true;
            
                                           if( me.mTextureCallbackFun!=null )
                                               me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.video, true, 3, 1, -1.0, me.mID );
                                        } )
                               .catch( function(error)
                                       {
                                           console.log( error );
                                       }
                                );
        } );

        texture.video.addEventListener( "error", function(e)
        {
               if( texture.video.hasFalled===true ) { alert("Error: cannot load video" ); return; }
               let str = texture.video.src;
               str = str.substr(0,str.lastIndexOf('.') ) + ".mp4";
               texture.video.src = str;
               texture.video.hasFalled = true;
        } );

        texture.video.src = url.mSrc;

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]==null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!="music") && 
                                                                (this.mInputs[slot].mInfo.mType!="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="music" || url.mType==="musicstream" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.audio = document.createElement('audio');
    	texture.audio.loop = true;
        texture.audio.mMuted = this.mForceMuted;
        texture.audio.mForceMuted = this.mForceMuted;
        texture.audio.muted = this.mForceMuted;
        if( this.mForceMuted===true )
            texture.audio.volume = 0;
        texture.audio.autoplay = false;
        texture.audio.hasFalled = false;
        texture.audio.mPaused = false;
        texture.audio.mSound = {};

        if( this.mForceMuted===false )
        {
            if(url.mType==="musicstream" && SC === null)
            {
                alert( "Shadertoy: Soundcloud could not be reached" );
                texture.audio.mForceMuted = true;
            }
            }

        if( wa === null && this.mForceMuted===false )
        {
            alert( "Shadertoy: Web Audio not implement in this browser" );
            texture.audio.mForceMuted = true;
        }

        if( texture.audio.mForceMuted )
        {
            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null);
            let num = 512;
            texture.audio.mSound.mFreqData = new Uint8Array( num );
            texture.audio.mSound.mWaveData = new Uint8Array( num );
            texture.loaded = true;
        }

        texture.audio.addEventListener( "canplay", function()
        {
            if( texture===null || texture.audio===null ) return;
            if( this.mForceMuted  ) return;
            if( texture.loaded === true ) return;

            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null)

            texture.audio.mSound.mSource   = wa.createMediaElementSource( texture.audio );
            texture.audio.mSound.mAnalyser = wa.createAnalyser();
            texture.audio.mSound.mGain     = wa.createGain();

            texture.audio.mSound.mSource.connect(   texture.audio.mSound.mAnalyser );
            texture.audio.mSound.mAnalyser.connect( texture.audio.mSound.mGain );
            texture.audio.mSound.mGain.connect(me.mGainNode);

            texture.audio.mSound.mFreqData = new Uint8Array( texture.audio.mSound.mAnalyser.frequencyBinCount );
            texture.audio.mSound.mWaveData = new Uint8Array( texture.audio.mSound.mAnalyser.frequencyBinCount );

            if( texture.audio.mPaused )
            {
                texture.audio.pause();
            }
            else
            {
                texture.audio.play().then( function() {/*console.log("ok");*/} ).catch( function(e){console.log("error " + e);} );
            }
            texture.loaded = true;
        } );

        texture.audio.addEventListener( "error", function(e)
        {
               if( this.mForceMuted  ) return;

               if( texture.audio.hasFalled===true ) { return; }
               let str = texture.audio.src;
               str = str.substr(0,str.lastIndexOf('.') ) + ".ogg";
               texture.audio.src = str;
               texture.audio.hasFalled = true;
        } );

        if( !texture.audio.mForceMuted )
        {
            if(url.mType==="musicstream")
            {
                SC.resolve(url.mSrc, 
                    function(song) 
                    {
                        if( song.streamable===true )
                        {
                            texture.audio.crossOrigin = 'anonymous';
                            texture.audio.src = song.stream_url;
                            texture.audio.soundcloudInfo = song;
                        }
                        else
                        {
                            alert('Shadertoy: Soundcloud 3 - This track cannot be streamed' );
                        }
                    },
                    function(error)
                    {
                        if (me.mTextureCallbackFun!==null)
                        {
                            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null}, false, 4, 0, -1.0, me.mID);
                        }
                    } );
            } 
            else
            {
                texture.audio.src = url.mSrc;
            }
        }

        if (me.mTextureCallbackFun!==null)
        {
            if (url.mType === "music")            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null}, false, 4, 0, -1.0, me.mID);
            else if (url.mType === "musicstream") me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null, info: texture.audio.soundcloudInfo}, false, 8, 0, -1.0, me.mID);
        }

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="keyboard" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = true;

        texture.keyboard = {};

        if( me.mTextureCallbackFun!==null )
            me.mTextureCallbackFun( me.mTextureCallbackObj, slot, {mImage: keyboard.mIcon, mData: keyboard.mData}, false, 6, 1, -1.0, me.mID );

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!="music") && 
                                                                (this.mInputs[slot].mInfo.mType!="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="buffer" )
    {
        texture = {};
        texture.mInfo = url;

        texture.image = new Image();
        texture.image.onload = function()
        {
            if( me.mTextureCallbackFun!=null )
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, {texture: texture.image, data:null}, true, 9, 1, -1.0, me.mID );
        }
        texture.image.src = url.mSrc;
        texture.id = assetID_to_bufferID( url.mID );
        texture.loaded = true;

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!="music") && 
                                                                (this.mInputs[slot].mInfo.mType!="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!="video")) };

        this.DestroyInput( slot );
        this.mInputs[slot] = texture;

        this.mEffect.ResizeBuffer(texture.id, this.mEffect.mXres, this.mEffect.mYres, false );

        this.SetSamplerFilter(slot, url.mSampler.filter, buffers, cubeBuffers, true);
        this.SetSamplerVFlip(slot, url.mSampler.vflip);
        this.SetSamplerWrap(slot, url.mSampler.wrap, buffers);

        this.MakeHeader();
        return returnValue;
    }
    else
    {
        alert( "input type error" );
        return { mFailed: true };
    }

    return { mFailed: true };
}

EffectPass.prototype.Paint_Image = function( vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    let times = [ 0.0, 0.0, 0.0, 0.0 ];

    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds()  + d.getMilliseconds()/1000.0 ];

    let mouse = [  mousePosX, mousePosY, mouseOriX, mouseOriY ];


    //------------------------
    
    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];
    let texIsLoaded = [0, 0, 0, 0 ];
    let texID = [ null, null, null, null];

    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            texID[i] = keyboard.mTexture;
            texIsLoaded[i] = 1;
            resos[3*i+0] = 256;
            resos[3*i+1] = 3;
            resos[3*i+2] = 1;
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
            if (inp.loaded === true)
            {
                let id = assetID_to_cubemapBuferID(inp.mInfo.mID);
                if( id!==-1 )
                {
                    texID[i] = cubeBuffers[id].mTexture[ cubeBuffers[id].mLastRenderDone ];
                    resos[3*i+0] = cubeBuffers[id].mResolution[0];
                    resos[3*i+1] = cubeBuffers[id].mResolution[1];
                    resos[3*i+2] = 1;
                    texIsLoaded[i] = 1;

                    // hack. in webgl2.0 we have samplers, so we don't need this crap here
                    let filter = this.mRenderer.FILTER.NONE;
                         if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                    else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                    this.mRenderer.SetSamplerFilter( texID[i], filter, false);
                }
                else
                {
                    texID[i] = inp.globject;
                    texIsLoaded[i] = 1;
                }
            }
        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mImage, false, 7, 1, -1, this.mID );

                    texID[i] = inp.globject;
                    texIsLoaded[i] = 1;
                    resos[3*i+0] = inp.mImage.width;
                    resos[3*i+1] = inp.mImage.height;
                    resos[3*i+2] = 1;
                }
                else  if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {

                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 7, 1, -1, this.mID );

                    texID[i] = inp.globject;
                    this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                    resos[3*i+0] = inp.video.videoWidth;
                    resos[3*i+1] = inp.video.videoHeight;
                    resos[3*i+2] = 1;
                    texIsLoaded[i] = 1;
                }
            }
            else 
            {
                texID[i] = null;
                texIsLoaded[i] = 0;
                resos[3*i+0] = inp.video.width;
                resos[3*i+1] = inp.video.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.mPaused === false )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, inp.video.currentTime, this.mID );
            }

            if( inp.loaded===true )
            { 
                times[i] = inp.video.currentTime;
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;

      	        if( inp.video.mPaused === false )
      	        {
      	            this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
                resos[3*i+0] = inp.video.videoWidth;
                resos[3*i+1] = inp.video.videoHeight;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.audio.mPaused === false && inp.audio.mForceMuted === false && inp.loaded===true )
            {
                if( wa !== null )
                {
                    inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                    inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                }

                if( this.mTextureCallbackFun!==null )
                {
                         if( inp.mInfo.mType==="music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa === null) ? null : { wave : inp.audio.mSound.mFreqData }, false, 4, 1, inp.audio.currentTime, this.mID);
                    else if( inp.mInfo.mType==="musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa === null) ? null : { wave : inp.audio.mSound.mFreqData, info : inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                }
            }

            if( inp.loaded===true )
            {
                times[i] = inp.audio.currentTime;
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;

                if( inp.audio.mForceMuted === true )
                {
                    times[i] = 10.0 + time;
                    let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.audio.mSound.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                  //let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.audio.mSound.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }

                }

      	        if( inp.audio.mPaused === false )
                {
      	            let waveLen = Math.min(inp.audio.mSound.mWaveData.length, 512);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512, 1, inp.audio.mSound.mFreqData);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 1, 512, 1, inp.audio.mSound.mWaveData);
                }

                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                    times[i] = 10.0 + time;
                    let num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                    //var num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }
            }
            else
            {
                inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
            }

            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave:inp.mFreqData}, false, 5, 1, -1, this.mID );

            if( inp.loaded===true )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                let waveLen = Math.min( inp.mWaveData.length, 512 );
                this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512,     1, inp.mFreqData);
                this.mRenderer.UpdateTexture(inp.globject, 0, 1, waveLen, 1, inp.mWaveData);
                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            let id = inp.id;
            if( inp.loaded===true  )
            {
                texID[i] = buffers[id].mTexture[ buffers[id].mLastRenderDone ];
                texIsLoaded[i] = 1;
                resos[3*i+0] = xres;
                resos[3*i+1] = yres;
                resos[3*i+2] = 1;
                // hack. in webgl2.0 we have samplers, so we don't need this crap here
                let filter = this.mRenderer.FILTER.NONE;
                     if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                this.mRenderer.SetSamplerFilter( texID[i], filter, false);
            }

            if( this.mTextureCallbackFun!==null )
            {
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:buffers[id].mThumbnailBuffer}, false, 9, 1, -1, this.mID );
            }
        }
    }

    this.mRenderer.AttachTextures( 4, texID[0], texID[1], texID[2], texID[3] );

    //-----------------------------------

    let prog = this.mProgram;

    //if( vrData!=null && this.mSupportsVR ) prog = this.mProgramVR;



    this.mRenderer.AttachShader(prog);

    this.mRenderer.SetShaderConstant1F(  "iTime", time);
    this.mRenderer.SetShaderConstant3F(  "iResolution", xres, yres, 1.0);
    this.mRenderer.SetShaderConstant4FV( "iMouse", mouse);
    this.mRenderer.SetShaderConstant1FV( "iChannelTime", times );              // OBSOLETE
    this.mRenderer.SetShaderConstant4FV( "iDate", dates );
    this.mRenderer.SetShaderConstant3FV( "iChannelResolution", resos );        // OBSOLETE
    this.mRenderer.SetShaderConstant1F(  "iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit( "iChannel0", 0 );
    this.mRenderer.SetShaderTextureUnit( "iChannel1", 1 );
    this.mRenderer.SetShaderTextureUnit( "iChannel2", 2 );
    this.mRenderer.SetShaderTextureUnit( "iChannel3", 3 );
    this.mRenderer.SetShaderConstant1I(  "iFrame", this.mFrame );
    this.mRenderer.SetShaderConstant1F(  "iTimeDelta", dtime);
    this.mRenderer.SetShaderConstant1F(  "iFrameRate", fps );

    this.mRenderer.SetShaderConstant1F(  "iCh0.time", times[0] );
    this.mRenderer.SetShaderConstant1F(  "iCh1.time", times[1] );
    this.mRenderer.SetShaderConstant1F(  "iCh2.time", times[2] );
    this.mRenderer.SetShaderConstant1F(  "iCh3.time", times[3] );
    this.mRenderer.SetShaderConstant3F(  "iCh0.size", resos[0], resos[ 1], resos[ 2] );
    this.mRenderer.SetShaderConstant3F(  "iCh1.size", resos[3], resos[ 4], resos[ 5] );
    this.mRenderer.SetShaderConstant3F(  "iCh2.size", resos[6], resos[ 7], resos[ 8] );
    this.mRenderer.SetShaderConstant3F(  "iCh3.size", resos[9], resos[10], resos[11] );
    this.mRenderer.SetShaderConstant1I(  "iCh0.loaded",       texIsLoaded[0] );
    this.mRenderer.SetShaderConstant1I(  "iCh1.loaded",       texIsLoaded[1] );
    this.mRenderer.SetShaderConstant1I(  "iCh2.loaded",       texIsLoaded[2] );
    this.mRenderer.SetShaderConstant1I(  "iCh3.loaded",       texIsLoaded[3] );

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");


    if( (vrData !== null) && this.mSupportsVR )
    {
        for (let i=0; i<2; i++ )
        {
            let ei = (i===0) ? vrData.mLeftEye : vrData.mRightEye;

            let vp = [i * xres / 2, 0, xres / 2, yres];

            this.mRenderer.SetViewport(vp);

            let fov = ei.mProjection;
            let corA = [ -fov[2], -fov[1], -1.0 ];
            let corB = [  fov[3], -fov[1], -1.0 ];
            let corC = [  fov[3],  fov[0], -1.0 ];
            let corD = [ -fov[2],  fov[0], -1.0 ];
            let apex = [ 0.0, 0.0, 0.0 ];

            let ma = invertFast( ei.mCamera );
            corA = matMulpoint( ma, corA ); 
            corB = matMulpoint( ma, corB ); 
            corC = matMulpoint( ma, corC ); 
            corD = matMulpoint( ma, corD ); 
            apex = matMulpoint( ma, apex ); 

            let corners = [ corA[0], corA[1], corA[2], 
                            corB[0], corB[1], corB[2], 
                            corC[0], corC[1], corC[2], 
                            corD[0], corD[1], corD[2],
                            apex[0], apex[1], apex[2]];

            this.mRenderer.SetShaderConstant3FV("unCorners", corners);
            this.mRenderer.SetShaderConstant4FV("unViewport", vp);

            this.mRenderer.DrawUnitQuad_XY(l1);
        }
    }
    else 
    {
        this.mRenderer.SetViewport([0, 0, xres, yres]);
        this.mRenderer.DrawFullScreenTriangle_XY( l1 );
    }

    this.mRenderer.DettachTextures();
}

EffectPass.prototype.iRenderSound = function(d, callback )
{
    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds() ];

    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];

    this.mRenderer.SetRenderTarget(this.mRenderFBO);

    this.mRenderer.SetViewport([0, 0, this.mTextureDimensions, this.mTextureDimensions]);
    this.mRenderer.AttachShader(this.mProgram);
    this.mRenderer.SetBlend( false );

    let texID = [null, null, null, null];
    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
    }

    this.mRenderer.AttachTextures(4, texID[0], texID[1], texID[2], texID[3]);

    let l2 = this.mRenderer.SetShaderConstantLocation(this.mProgram, "iTimeOffset");
    let l3 = this.mRenderer.SetShaderConstantLocation(this.mProgram, "iSampleOffset");
    this.mRenderer.SetShaderConstant4FV("iDate", dates);
    this.mRenderer.SetShaderConstant3FV("iChannelResolution", resos);
    this.mRenderer.SetShaderConstant1F("iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit("iChannel0", 0);
    this.mRenderer.SetShaderTextureUnit("iChannel1", 1);
    this.mRenderer.SetShaderTextureUnit("iChannel2", 2);
    this.mRenderer.SetShaderTextureUnit("iChannel3", 3);

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    //--------------------------------
    let numSamples = this.mTmpBufferSamples;
    let numBlocks = this.mPlaySamples / numSamples;
    for (let j=0; j<numBlocks; j++ )
    {
        let off = j*numSamples;
        
        this.mRenderer.SetShaderConstant1F_Pos(l2, off / this.mSampleRate);
        this.mRenderer.SetShaderConstant1I_Pos(l3, off );
        this.mRenderer.DrawUnitQuad_XY(l1);

        this.mRenderer.GetPixelData(this.mData, 0, this.mTextureDimensions, this.mTextureDimensions);

        callback( off, this.mData, numSamples );
    }

    this.mRenderer.DetachShader();
    this.mRenderer.DettachTextures();
    this.mRenderer.SetRenderTarget(null);
}

EffectPass.prototype.Paint_Sound = function( wa, d )
{
    let bufL = this.mBuffer.getChannelData(0); // Float32Array
    let bufR = this.mBuffer.getChannelData(1); // Float32Array

    this.iRenderSound( d, function(off, data, numSamples)
                         {
                            for( let i=0; i<numSamples; i++ )
                            {
                                bufL[off+i] = -1.0 + 2.0*(data[4*i+0]+256.0*data[4*i+1])/65535.0;
                                bufR[off+i] = -1.0 + 2.0*(data[4*i+2]+256.0*data[4*i+3])/65535.0;
                            }
                         }
                     );
}

EffectPass.prototype.SetUniforms = function(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    let times = [ 0.0, 0.0, 0.0, 0.0 ];

    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds()  + d.getMilliseconds()/1000.0 ];

    let mouse = [  mousePosX, mousePosY, mouseOriX, mouseOriY ];

    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];

    //------------------------
    
    let texID = [ null, null, null, null];

    for( let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            texID[i] = keyboard.mTexture;
        }
        else if( inp.mInfo.mType=="cubemap" )
        {
            if (inp.loaded === true)
            {
                let id = assetID_to_cubemapBuferID(inp.mInfo.mID);
                if( id!==-1 )
                {
                    texID[i] = cubeBuffers[id].mTexture[ cubeBuffers[id].mLastRenderDone ];
                    resos[3*i+0] = cubeBuffers[id].mResolution[0];
                    resos[3*i+1] = cubeBuffers[id].mResolution[1];
                    resos[3*i+2] = 1;
    
                    // hack. in webgl2.0 we have samplers, so we don't need this crap here
                    let filter = this.mRenderer.FILTER.NONE;
                         if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                    else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                    this.mRenderer.SetSamplerFilter( texID[i], filter, false);
                }
                else
                {
                    texID[i] = inp.globject;
                }
            }

        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    texID[i] = inp.globject;
                    resos[3*i+0] = inp.mImage.width;
                    resos[3*i+1] = inp.mImage.height;
                    resos[3*i+2] = 1;
                }
                else  if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {
                    texID[i] = inp.globject;
                    resos[3*i+0] = inp.video.videoWidth;
                    resos[3*i+1] = inp.video.videoHeight;
                    resos[3*i+2] = 1;
                }
            }
            else 
            {
                texID[i] = null;
                resos[3*i+0] = inp.video.width;
                resos[3*i+1] = inp.video.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
           if( inp.loaded===true )
           { 
                times[i] = inp.video.currentTime;
                texID[i] = inp.globject;
                resos[3*i+0] = inp.video.videoWidth;
                resos[3*i+1] = inp.video.videoHeight;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.loaded===true )
            {
                times[i] = inp.audio.currentTime;
                texID[i] = inp.globject;

                if( inp.audio.mForceMuted === true )
                {
                    times[i] = 10.0 + time;
                }

                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                times[i] = 10.0 + time;
            }

            if( inp.loaded===true )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = buffers[inp.id].mTexture[ buffers[inp.id].mLastRenderDone ];
                resos[3*i+0] = buffers[inp.id].mResolution[0];
                resos[3*i+1] = buffers[inp.id].mResolution[1];
                resos[3*i+2] = 1;
            }
        }
    }

    this.mRenderer.AttachTextures( 4, texID[0], texID[1], texID[2], texID[3] );

    //-----------------------------------

    this.mRenderer.AttachShader(this.mProgram);

    this.mRenderer.SetShaderConstant1F(  "iTime", time);
    this.mRenderer.SetShaderConstant3F(  "iResolution", xres, yres, 1.0);
    this.mRenderer.SetShaderConstant4FV( "iMouse", mouse);
    this.mRenderer.SetShaderConstant1FV( "iChannelTime", times );              // OBSOLETE
    this.mRenderer.SetShaderConstant4FV( "iDate", dates );
    this.mRenderer.SetShaderConstant3FV( "iChannelResolution", resos );        // OBSOLETE
    this.mRenderer.SetShaderConstant1F(  "iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit( "iChannel0", 0 );
    this.mRenderer.SetShaderTextureUnit( "iChannel1", 1 );
    this.mRenderer.SetShaderTextureUnit( "iChannel2", 2 );
    this.mRenderer.SetShaderTextureUnit( "iChannel3", 3 );
    this.mRenderer.SetShaderConstant1I(  "iFrame", this.mFrame );
    this.mRenderer.SetShaderConstant1F(  "iTimeDelta", dtime);
    this.mRenderer.SetShaderConstant1F(  "iFrameRate", fps );

    this.mRenderer.SetShaderConstant1F(  "iChannel[0].time",       times[0] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[1].time",       times[1] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[2].time",       times[2] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[3].time",       times[3] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[0].resolution", resos[0], resos[ 1], resos[ 2] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[1].resolution", resos[3], resos[ 4], resos[ 5] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[2].resolution", resos[6], resos[ 7], resos[ 8] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[3].resolution", resos[9], resos[10], resos[11] );
}

EffectPass.prototype.ProcessInputs = function(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
        }
        else if( inp.mInfo.mType==="volume" )
        {
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mImage, false, 7, 1, -1, this.mID );
                }
                else if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 7, 1, -1, this.mID );

                    this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.mPaused === false )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, inp.video.currentTime, this.mID );
            }

            if( inp.loaded===true )
            { 
      	        if( inp.video.mPaused === false )
      	        {
      	            this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.audio.mPaused === false && inp.audio.mForceMuted === false && inp.loaded===true )
            {
                if( wa !== null )
                {
                    inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                    inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                }

                if( this.mTextureCallbackFun!==null )
                {
                         if( inp.mInfo.mType==="music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa == null) ? null : { wave : inp.audio.mSound.mFreqData }, false, 4, 1, inp.audio.currentTime, this.mID);
                    else if( inp.mInfo.mType==="musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa == null) ? null : { wave : inp.audio.mSound.mFreqData, info : inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                }
            }

            if( inp.loaded===true )
            {
                if( inp.audio.mForceMuted === true )
                {
                    let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.audio.mSound.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                  //let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.audio.mSound.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }

                }

      	        if( inp.audio.mPaused === false )
                {
      	            let waveLen = Math.min(inp.audio.mSound.mWaveData.length, 512);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512, 1, inp.audio.mSound.mFreqData);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 1, 512, 1, inp.audio.mSound.mWaveData);
                }
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                    let num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                    for( let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }
            }
            else
            {
                inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
            }

            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave:inp.mFreqData}, false, 5, 1, -1, this.mID );

            if( inp.loaded===true )
            {
                let waveLen = Math.min( inp.mWaveData.length, 512 );
                this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512,     1, inp.mFreqData);
                this.mRenderer.UpdateTexture(inp.globject, 0, 1, waveLen, 1, inp.mWaveData);
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded===true  )
            {
                let id = inp.id;
                let texID = buffers[id].mTexture[ buffers[id].mLastRenderDone ];

                // hack. in webgl2.0 we have samplers, so we don't need this crap here
                let filter = this.mRenderer.FILTER.NONE;
                     if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                this.mRenderer.SetSamplerFilter( texID, filter, false);
            }

            if( this.mTextureCallbackFun!==null )
            {
				let id = inp.id;
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:buffers[id].mThumbnailBuffer}, false, 9, 1, -1, this.mID );
            }
        }
    }
}

EffectPass.prototype.Paint_Cubemap = function( vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face )
{
    this.ProcessInputs(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face );
    this.SetUniforms(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    let vp = [0, 0, xres, yres];

    this.mRenderer.SetViewport(vp);

    let corA = [ -1.0, -1.0, -1.0 ];
    let corB = [  1.0, -1.0, -1.0 ];
    let corC = [  1.0,  1.0, -1.0 ];
    let corD = [ -1.0,  1.0, -1.0 ];
    let apex = [  0.0,  0.0,  0.0 ];

    if( face===0 )
    {
        corA = [  1.0,  1.0,  1.0 ];
        corB = [  1.0,  1.0, -1.0 ];
        corC = [  1.0, -1.0, -1.0 ];
        corD = [  1.0, -1.0,  1.0 ];
    }
    else if( face===1 ) // -X
    {
        corA = [ -1.0,  1.0, -1.0 ];
        corB = [ -1.0,  1.0,  1.0 ];
        corC = [ -1.0, -1.0,  1.0 ];
        corD = [ -1.0, -1.0, -1.0 ];
    }
    else if( face===2 ) // +Y
    {
        corA = [ -1.0,  1.0, -1.0 ];
        corB = [  1.0,  1.0, -1.0 ];
        corC = [  1.0,  1.0,  1.0 ];
        corD = [ -1.0,  1.0,  1.0 ];
    }
    else if( face===3 ) // -Y
    {
        corA = [ -1.0, -1.0,  1.0 ];
        corB = [  1.0, -1.0,  1.0 ];
        corC = [  1.0, -1.0, -1.0 ];
        corD = [ -1.0, -1.0, -1.0 ];
    }
    else if( face===4 ) // +Z
    {
        corA = [ -1.0,  1.0,  1.0 ];
        corB = [  1.0,  1.0,  1.0 ];
        corC = [  1.0, -1.0,  1.0 ];
        corD = [ -1.0, -1.0,  1.0 ];
    }
    else //if( face===5 ) // -Z
    {
        corA = [  1.0,  1.0, -1.0 ];
        corB = [ -1.0,  1.0, -1.0 ];
        corC = [ -1.0, -1.0, -1.0 ];
        corD = [  1.0, -1.0, -1.0 ];
    }

    let corners = [ corA[0], corA[1], corA[2], 
                    corB[0], corB[1], corB[2], 
                    corC[0], corC[1], corC[2], 
                    corD[0], corD[1], corD[2],
                    apex[0], apex[1], apex[2]];

    this.mRenderer.SetShaderConstant3FV("unCorners", corners);
    this.mRenderer.SetShaderConstant4FV("unViewport", vp);

    this.mRenderer.DrawUnitQuad_XY(l1);

    this.mRenderer.DettachTextures();
}


EffectPass.prototype.Paint = function( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, bufferNeedsMimaps, buffers, cubeBuffers, keyboard, effect )
{
    if( this.mType==="sound" )
    {
        if (this.mSoundShaderCompiled === true)
        {
            // make sure all textures are loaded
            for (let i=0; i<this.mInputs.length; i++ )
            {
                let inp = this.mInputs[i];
                if (inp === null) continue;

                if (inp.mInfo.mType === "texture" && !inp.loaded) return;
                if (inp.mInfo.mType === "cubemap" && !inp.loaded) return;
            }

            this.Paint_Sound(wa, da);
            this.mSoundShaderCompiled = false;
        }
        if (this.mFrame === 0)
        {
            if (this.mPlaying===true)
            {
                this.mPlayNode.disconnect();
                this.mPlayNode.stop();
                this.mPlayNode = null;
            }
            this.mPlaying = true;

            this.mPlayNode = wa.createBufferSource();
            this.mPlayNode.buffer = this.mBuffer;
            this.mPlayNode.connect(this.mGainNode);
            this.mPlayNode.start(0);
        }
        this.mFrame++;
    }
    else if( this.mType==="image" )
    {
        this.mRenderer.SetRenderTarget( null );
        this.Paint_Image( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );
        this.mFrame++;
    }
    else if( this.mType==="common" )
    {
        //console.log("rendering common");
    }
    else if( this.mType==="buffer" )
    {
        this.mEffect.ResizeBuffer(bufferID, this.mEffect.mXres, this.mEffect.mYres, false );

        let buffer = buffers[bufferID];

        let dstID = 1 - buffer.mLastRenderDone;

        this.mRenderer.SetRenderTarget( buffer.mTarget[dstID] );
        this.Paint_Image( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );

        // compute mipmaps if needd
        if( bufferNeedsMimaps )
        {
            this.mRenderer.CreateMipmaps( buffer.mTexture[dstID]);
        }

        // make thumbnail
        //if( this.mTextureCallbackFun != null )
        /*
        {
            this.mRenderer.SetRenderTarget( buffer.mThumbnailRenderTarget );
            let v = [0, 0, buffer.mThumbnailRes[0], buffer.mThumbnailRes[1]];
            this.mRenderer.SetBlend(false);
            this.mRenderer.SetViewport(v);
            this.mRenderer.AttachShader(this.mProgramCopy);
            let l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, "pos");
            this.mRenderer.SetShaderConstant4FV("v", v);
            this.mRenderer.AttachTextures(1, buffer.mTexture[dstID], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);
            this.mRenderer.DettachTextures();
            this.mRenderer.DetachShader();
            this.mRenderer.GetPixelData( new Uint8Array(buffer.mThumbnailBuffer.data.buffer), buffer.mThumbnailRes[0], buffer.mThumbnailRes[1] );
            this.mRenderer.SetRenderTarget(null);
        }
        */
        buffers[bufferID].mLastRenderDone = 1 - buffers[bufferID].mLastRenderDone;
        this.mFrame++;
    }
    else if( this.mType==="cubemap" )
    {
        this.mEffect.ResizeCubemapBuffer(bufferID, 1024, 1024, false );

        let buffer = cubeBuffers[bufferID];

        xres = buffer.mResolution[0];
        yres = buffer.mResolution[1];
        let dstID = 1 - buffer.mLastRenderDone;
        for( let face=0; face<6; face++ )
        {
            this.mRenderer.SetRenderTargetCubeMap( buffer.mTarget[dstID], face );
            this.Paint_Cubemap( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face );
        }
        this.mRenderer.SetRenderTargetCubeMap( null, 0 );

        // compute mipmaps if needd
        if( bufferNeedsMimaps )
        {
            this.mRenderer.CreateMipmaps( buffer.mTexture[dstID]);
        }
        cubeBuffers[bufferID].mLastRenderDone = 1 - cubeBuffers[bufferID].mLastRenderDone;

        this.mFrame++;
    }

}

EffectPass.prototype.StopOutput_Sound = function( wa )
{
    if( this.mPlayNode===null ) return;
    this.mPlayNode.disconnect();

};

EffectPass.prototype.ResumeOutput_Sound = function( wa )
{
    if( this.mPlayNode===null ) return;

    wa.resume()
    this.mPlayNode.connect( this.mGainNode );
};

EffectPass.prototype.StopOutput_Image = function( wa )
{
};

EffectPass.prototype.ResumeOutput_Image = function( wa )
{
};

EffectPass.prototype.StopOutput = function( wa )
{
    for (let j=0; j<this.mInputs.length; j++ )
        this.StopInput(j);

    if( this.mType==="sound" )
         this.StopOutput_Sound( wa );
    else
         this.StopOutput_Image( wa );
}

EffectPass.prototype.ResumeOutput = function( wa )
{
    for (let j=0; j<this.mInputs.length; j++ )
        this.ResumeInput(j);

    if( this.mType==="sound" )
         this.ResumeOutput_Sound( wa );
    else
         this.ResumeOutput_Image( wa );
}

EffectPass.prototype.GetCompilationTime = function()
{
    return this.mCompilationTime;
}

//============================================================================================================
function Screenshots()
{
    // private
    let mTexture = null;
    let mTarget = null;
    let mXres = 0;
    let mYres = 0;
    let mCubemapToEquirectProgram;
    let mRenderer = null;

    // public
    var me = {};

    me.Initialize = function(renderer)
    {
        mRenderer = renderer;
        let caps = mRenderer.GetCaps();
        let is20 = caps.mIsGL20;


        let vsSourceC, fsSourceC;
        if( is20 )
        {
            vsSourceC = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
            fsSourceC = "uniform samplerCube t; out vec4 outColor; void main() { vec2 px = gl_FragCoord.xy/vec2(4096.0,2048.0); vec2 an = 3.1415926535898 * (px*vec2(2.0, 1.0) - vec2(0.0,0.5)); vec3 rd = vec3(-cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x)); outColor = texture(t, rd); }";
        }
        else
        {
            vsSourceC = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
            fsSourceC = "uniform samplerCube t; void main() { vec2 px = gl_FragCoord.xy/vec2(4096.0,2048.0); vec2 an = 3.1415926535898 * (px*vec2(2.0, 1.0) - vec2(0.0,0.5)); vec3 rd = vec3(-cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x)); gl_FragColor = texture(t, rd); }";
        }

        let compileShader = function (worked, info)
        {
            if (worked === false)
            {
                console.log("Failed to compile cubemap resample shader (" + errorType + "): " + log);
            }
            else
            {
                mCubemapToEquirectProgram = info;
            }
        }
        mRenderer.CreateShader(vsSourceC, fsSourceC, false, true, compileShader);

        return true;
    };

    me.Allocate = function( xres, yres )
    {
        if( xres>mXres || yres>mYres )
        {
            let texture = mRenderer.CreateTexture(mRenderer.TEXTYPE.T2D, xres, yres, mRenderer.TEXFMT.C4F32, mRenderer.FILTER.NONE, mRenderer.TEXWRP.CLAMP, null);
            let target = mRenderer.CreateRenderTarget( texture, null, null, null, null, false);

            if( mXres!==0 )
            {
                mRenderer.DestroyTexture(mTexture);
                mRenderer.DestroyRenderTarget(mTarget);
            }

            mTexture = texture;
            mTarget = target;
            mXres = xres;
            mYres = yres;
        }
    };

    me.GetProgram = function()
    {
        return mCubemapToEquirectProgram;
    };
    me.GetTarget = function()
    {
        return mTarget;
    };

    return me;
};

//============================================================================================================

function Effect(vr, ac, canvas, callback, obj, forceMuted, forcePaused, resizeCallback, crashCallback )
{
    let xres = canvas.width;
    let yres = canvas.height;

    let me = this;
    this.mCanvas = canvas;
    this.mCreated = false;
    this.mRenderer = null;
    this.mAudioContext = ac;
    this.mGLContext = null;
    this.mWebVR = vr;
    this.mRenderingStereo = false;
    this.mXres = xres;
    this.mYres = yres;
    this.mForceMuted = forceMuted;
    if( ac===null ) this.mForceMuted = true;
    this.mForcePaused = forcePaused;
    this.mGainNode = null;
    this.mPasses = [];
    this.mFrame = 0;
    this.mTextureCallbackFun = callback;
    this.mTextureCallbackObj = obj;
    this.mMaxBuffers = 4;
    this.mMaxCubeBuffers = 1;
    this.mMaxPasses = this.mMaxBuffers + 1 + 1 + 1 + 1; // some day decouple passes from buffers (4 buffers + common + Imagen + sound + cubemap)
    this.mBuffers = [];
    this.mCubeBuffers = [];
    this.mScreenshotSytem = null;
    this.mCompilationTime = 0;
    this.mIsLowEnd = piIsMobile();

    this.mGLContext = piCreateGlContext(canvas, false, false, true, false); // need preserve-buffe to true in order to capture screenshots
    if (this.mGLContext === null)
    {
        return;
    }

    canvas.addEventListener("webglcontextlost", function (event)
        {
            event.preventDefault();
            crashCallback();
        }, false);

    this.mRenderer = piRenderer();
    if (!this.mRenderer.Initialize(this.mGLContext))
        return;

    this.mScreenshotSytem = Screenshots();
    if (!this.mScreenshotSytem.Initialize(this.mRenderer))
        return;

    var caps = this.mRenderer.GetCaps();
    this.mIs20 = caps.mIsGL20;
    this.mShaderTextureLOD = caps.mShaderTextureLOD;
    //-------------
    if( ac!==null )
    {   
        this.mGainNode = ac.createGain();
        if( !forceMuted )
        {
            this.mGainNode.connect( ac.destination);
        }
        if (this.mForceMuted )
            this.mGainNode.gain.value = 0.0;
        else
            this.mGainNode.gain.value = 1.0;
    }

    //-------------
    let vsSourceC, fsSourceC;
    if( this.mIs20 )
    {
        vsSourceC = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceC = "uniform vec4 v; uniform sampler2D t; out vec4 outColor; void main() { outColor = textureLod(t, gl_FragCoord.xy / v.zw, 0.0); }";
    }
    else
    {
        vsSourceC = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceC = "uniform vec4 v; uniform sampler2D t; void main() { gl_FragColor = texture2D(t, gl_FragCoord.xy / v.zw, -100.0); }";
    }

    this.mRenderer.CreateShader(vsSourceC, fsSourceC, false, true, function(worked, info)
        {
            if (worked === false) console.log("Failed to compile shader to copy buffers : " + info.mErrorStr);
            else me.mProgramCopy = info;
        });

    let vsSourceD, fsSourceD;
    if( this.mIs20 )
    {
        vsSourceD = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceD = "uniform vec4 v; uniform sampler2D t; out vec4 outColor; void main() { vec2 uv = gl_FragCoord.xy / v.zw; outColor = texture(t, vec2(uv.x,1.0-uv.y)); }";
    }
    else
    {
        vsSourceD = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceD = "uniform vec4 v; uniform sampler2D t; void main() { vec2 uv = gl_FragCoord.xy / v.zw; gl_FragColor = texture2D(t, vec2(uv.x,1.0-uv.y)); }";
    }

    this.mRenderer.CreateShader(vsSourceD, fsSourceD, false, true, function (worked, info)
        {
            if (worked === false) console.log("Failed to compile shader to downscale buffers : " + info.mErrorStr);
            else me.mProgramDownscale = info;
        });


    // set all buffers and cubemaps to null
    for( let i=0; i<this.mMaxBuffers; i++ )
    {
        this.mBuffers[i] = { mTexture: [null, null], 
                             mTarget:  [null, null], 
                             mResolution: [0, 0],
                             mLastRenderDone: 0,
                             mThumbnailRenderTarget: null,
                             mThumbnailTexture: null,
                             mThumbnailBuffer:  null,
                             mThumbnailRes: [0, 0] };
    }

    for( let i=0; i<this.mMaxCubeBuffers; i++ )
    {
        this.mCubeBuffers[i] = { mTexture: [null, null], 
                                mTarget:  [null, null], 
                                mResolution: [0, 0],
                                mLastRenderDone: 0,
                                mThumbnailRenderTarget: null,
                                mThumbnailTexture: null,
                                mThumbnailBuffer:  null,
                                mThumbnailRes: [0, 0] };
    }

    //-------

    let keyboardData = new Uint8Array( 256*3 );
    for (let j=0; j<(256*3); j++ ) { keyboardData[j] = 0; }
    let kayboardTexture = this.mRenderer.CreateTexture( this.mRenderer.TEXTYPE.T2D, 256, 3, this.mRenderer.TEXFMT.C1I8, this.mRenderer.FILTER.NONE, this.mRenderer.TEXWRP.CLAMP, null);
    let keyboardImage = new Image();
    if( callback!==null )
        keyboardImage.src = "/img/keyboard.png"; // don't load PNG if no UI 
    this.mKeyboard = { mData: keyboardData, mTexture: kayboardTexture, mIcon: keyboardImage };

    let iResize = function( xres, yres )
    {
        me.mCanvas.width = xres;
        me.mCanvas.height = yres;
        me.mXres = xres;
        me.mYres = yres;
        me.ResizeBuffers(xres, yres);
        resizeCallback(xres, yres);
    };

    let bestAttemptFallback = function()
    {
        let devicePixelRatio = window.devicePixelRatio || 1;
        let xres = Math.round(me.mCanvas.offsetWidth  * devicePixelRatio) | 0;
        let yres = Math.round(me.mCanvas.offsetHeight * devicePixelRatio) | 0;
        iResize(xres, yres);
    };

    if(!window.ResizeObserver)
    {
        console.log("WARNING: This browser doesn't support ResizeObserver.");
        bestAttemptFallback();
        window.addEventListener("resize", bestAttemptFallback);
    }
    else
    {
        this.mRO = new ResizeObserver( function(entries, observer)
        {
            var entry = entries[0];
            if (!entry['devicePixelContentBoxSize'])
            {
                observer.unobserve(me.mCanvas);
                console.log("WARNING: This browser doesn't support ResizeObserver + device-pixel-content-box (2)");
                bestAttemptFallback();
                window.addEventListener("resize", bestAttemptFallback);
            }
            else
            {
                let box = entry.devicePixelContentBoxSize[0];
                let xres = box.inlineSize;
                let yres = box.blockSize;
                iResize(xres, yres);
            }
        });
        try
        {
            this.mRO.observe(this.mCanvas, { box: ["device-pixel-content-box"] });
            //this.mRO.observe(this.mCanvas);
        }
        catch (e)
        {
            console.log("WARNING: This browser doesn't support ResizeObserver + device-pixel-content-box (1)");
            bestAttemptFallback();
            window.addEventListener("resize", bestAttemptFallback);
        }
    }

    this.mCreated = true;
}


Effect.prototype.ResizeCubemapBuffer = function(i, xres, yres )
{
    let oldXres = this.mCubeBuffers[i].mResolution[0];
    let oldYres = this.mCubeBuffers[i].mResolution[1];

    if( this.mCubeBuffers[i].mTexture[0]===null || oldXres !== xres || oldYres !== yres )
    {
        let texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.CUBEMAP,
            xres, yres,
            this.mRenderer.TEXFMT.C4F16,
            this.mRenderer.FILTER.LINEAR,
            this.mRenderer.TEXWRP.CLAMP, 
            null);
        let target1 = this.mRenderer.CreateRenderTargetCubeMap( texture1, null, false);

        let texture2 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.CUBEMAP,
            xres, yres,
            this.mRenderer.TEXFMT.C4F16,
            this.mRenderer.FILTER.LINEAR,
            this.mRenderer.TEXWRP.CLAMP, 
            null);

        let target2 = this.mRenderer.CreateRenderTargetCubeMap( texture2, null, false);

        // Store new buffers
        this.mCubeBuffers[i].mTexture = [texture1,texture2], 
        this.mCubeBuffers[i].mTarget =  [target1, target2 ], 
        this.mCubeBuffers[i].mLastRenderDone = 0;
        this.mCubeBuffers[i].mResolution[0] = xres;
        this.mCubeBuffers[i].mResolution[1] = yres;
    }
}


Effect.prototype.ResizeBuffer = function( i, xres, yres, skipIfNotExists )
{
    if( skipIfNotExists && this.mBuffers[i].mTexture[0]===null ) return;

    let oldXres = this.mBuffers[i].mResolution[0];
    let oldYres = this.mBuffers[i].mResolution[1];

    if( oldXres !== xres || oldYres !== yres )
    {
        let needCopy = (this.mBuffers[i].mTexture[0]!==null);

        let texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,
            xres, yres,
            this.mRenderer.TEXFMT.C4F32,
            (needCopy) ? this.mBuffers[i].mTexture[0].mFilter : this.mRenderer.FILTER.NONE,
            (needCopy) ? this.mBuffers[i].mTexture[0].mWrap   : this.mRenderer.TEXWRP.CLAMP, 
            null);

        let texture2 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,
            xres, yres,
            this.mRenderer.TEXFMT.C4F32,
            (needCopy) ? this.mBuffers[i].mTexture[1].mFilter : this.mRenderer.FILTER.NONE,
            (needCopy) ? this.mBuffers[i].mTexture[1].mWrap   : this.mRenderer.TEXWRP.CLAMP, 
            null);

        let target1 = this.mRenderer.CreateRenderTarget( texture1, null, null, null, null, false);
        let target2 = this.mRenderer.CreateRenderTarget( texture2, null, null, null, null, false);

        if( needCopy )
        {
            let v = [0, 0, Math.min(xres, oldXres), Math.min(yres, oldYres)];
            this.mRenderer.SetBlend(false);
            this.mRenderer.SetViewport(v);
            this.mRenderer.AttachShader(this.mProgramCopy);
            let l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, "pos");
            let vOld = [0, 0, oldXres, oldYres];
            this.mRenderer.SetShaderConstant4FV("v", vOld);

            // Copy old buffers 1 to new buffer
            this.mRenderer.SetRenderTarget(target1);
            this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[0], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);

            // Copy old buffers 2 to new buffer
            this.mRenderer.SetRenderTarget(target2);
            this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[1], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);

            // Deallocate old memory
            this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[0]);
            this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[0]);
            this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[1]);
            this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[1]);
            //this.mRenderer.DestroyTexture(this.mBuffers[i].thumbnailTexture);
        }

        // Store new buffers
        this.mBuffers[i].mTexture = [texture1,texture2], 
        this.mBuffers[i].mTarget =  [target1, target2 ], 
        this.mBuffers[i].mLastRenderDone = 0;
        this.mBuffers[i].mResolution[0] = xres;
        this.mBuffers[i].mResolution[1] = yres;
    }
}

Effect.prototype.saveScreenshot = function(passid)
{
    let pass = this.mPasses[passid];

    if( pass.mType === "buffer" )
    {
        let bufferID = assetID_to_bufferID( this.mPasses[passid].mOutputs[0] );

        let texture = this.mBuffers[bufferID].mTarget[ this.mBuffers[bufferID].mLastRenderDone ];

        let numComponents = 3;
        let width = texture.mTex0.mXres;
        let height = texture.mTex0.mYres;
        let type = "Float"; // Other options Float, Half, Uint
        let bytes = new Float32Array(width * height * 4 );//numComponents);
        this.mRenderer.GetPixelDataRenderTarget( texture, bytes, width, height );
        let blob = piExportToEXR(width, height, numComponents, type, bytes);

        // Offer download automatically to the user
        piTriggerDownload("image.exr", blob);
    }
    else if( pass.mType === "cubemap" )
    {
        let xres = 4096;
        let yres = 2048;
        this.mScreenshotSytem.Allocate( xres, yres );

        let cubeBuffer = this.mCubeBuffers[0];

        let target = this.mScreenshotSytem.GetTarget();
        this.mRenderer.SetRenderTarget( target );

        let program = this.mScreenshotSytem.GetProgram();

        this.mRenderer.AttachShader(program);
        let l1 = this.mRenderer.GetAttribLocation(program, "pos");
        this.mRenderer.SetViewport( [0, 0, xres, yres] );
        this.mRenderer.AttachTextures(1, cubeBuffer.mTexture[ cubeBuffer.mLastRenderDone ], null, null, null);
        this.mRenderer.DrawUnitQuad_XY(l1);
        this.mRenderer.DettachTextures();
        this.mRenderer.SetRenderTarget( null );

        let data = new Float32Array(xres*yres*4);
        this.mRenderer.GetPixelDataRenderTarget( target, data, xres, yres );

        let blob = piExportToEXR(xres, yres, 3, "Float", data );
        piTriggerDownload("image.exr", blob);
    }
    else if( pass.mType === "sound" )
    {
        let offset = 0;
        const bits = 16;
        const numChannels = 2;
        let words = new Int16Array(60*pass.mSampleRate*numChannels );

        pass.iRenderSound( new Date(), function(off, data, numSamples)
                                         {
                                            for( let i=0; i<numSamples; i++ )
                                            {
                                                words[offset++] = (data[4*i+0]+256.0*data[4*i+1]) - 32767;
                                                words[offset++] = (data[4*i+2]+256.0*data[4*i+3]) - 32767;
                                            }
                                         }
                                     );

        let blob = piExportToWAV( 60*pass.mSampleRate, pass.mSampleRate, bits, numChannels, words);

        piTriggerDownload("sound.wav", blob);
    }    
}

Effect.prototype.ResizeBuffers = function(xres, yres)
{
    for (let i=0; i<this.mMaxBuffers; i++ )
    {
        this.ResizeBuffer(i, xres, yres, true);
    }
}

Effect.prototype.IsEnabledVR = function ()
{
    if (this.mRenderingStereo) return true;
    return false;
}

Effect.prototype.EnableVR = function()
{
    if( !this.mWebVR.IsSupported() ) return;
    if( this.mRenderingStereo ) return;

    this.mRenderingStereo = true;
    this.mWebVR.Enable();
}

Effect.prototype.DisableVR = function()
{
    if( !this.mWebVR.IsSupported() ) return;
    if( !this.mRenderingStereo ) return;

    this.mRenderingStereo = false;
    this.mWebVR.Disable();
}

Effect.prototype.GetTexture = function( passid, slot )
{
    return this.mPasses[passid].GetTexture( slot );
}

Effect.prototype.NewTexture = function( passid, slot, url )
{
    return this.mPasses[passid].NewTexture( this.mAudioContext, slot, url, this.mBuffers, this.mCubeBuffers, this.mKeyboard );
}

Effect.prototype.SetOutputs = function( passid, slot, url )
{
    this.mPasses[passid].SetOutputs( slot, url );
}

Effect.prototype.SetOutputsByBufferID = function( passid, slot, id )
{
    this.mPasses[passid].SetOutputsByBufferID( slot, id );
}

Effect.prototype.GetAcceptsLinear = function (passid, slot) 
{
    return this.mPasses[passid].GetAcceptsLinear(slot);
}

Effect.prototype.GetAcceptsMipmapping = function (passid, slot) 
{
    return this.mPasses[passid].GetAcceptsMipmapping(slot);
}

Effect.prototype.GetAcceptsWrapRepeat = function (passid, slot) 
{
    return this.mPasses[passid].GetAcceptsWrapRepeat(slot);
}

Effect.prototype.GetAcceptsVFlip = function (passid, slot)
{
    return this.mPasses[passid].GetAcceptsVFlip(slot);
}

Effect.prototype.SetSamplerFilter = function (passid, slot, str) 
{
    this.mPasses[passid].SetSamplerFilter(slot, str, this.mBuffers, this.mCubeBuffers);
}

Effect.prototype.GetTranslatedShaderSource = function (passid)
{
    return this.mPasses[passid].GetTranslatedShaderSource();
}

Effect.prototype.GetSamplerFilter = function (passid, slot) {
    return this.mPasses[passid].GetSamplerFilter(slot);
}

Effect.prototype.SetSamplerWrap = function (passid, slot, str) {
    this.mPasses[passid].SetSamplerWrap(slot, str, this.mBuffers);
}

Effect.prototype.GetSamplerWrap = function (passid, slot) {
    return this.mPasses[passid].GetSamplerWrap(slot);
}

Effect.prototype.SetSamplerVFlip = function (passid, slot, str) {
    this.mPasses[passid].SetSamplerVFlip(slot, str);
}

Effect.prototype.GetSamplerVFlip = function (passid, slot) {
    return this.mPasses[passid].GetSamplerVFlip(slot);
}

Effect.prototype.GetHeaderSize = function (passid)
{
    return this.mPasses[passid].mHeaderLength + 
           this.mRenderer.GetShaderHeaderLines(1);
 
}

Effect.prototype.ToggleVolume = function()
{
    this.mForceMuted = !this.mForceMuted;

    // outp
    if (this.mForceMuted)
        this.mGainNode.gain.value = 0.0;
    else
        this.mGainNode.gain.value = 1.0;

    // inp
    let num = this.mPasses.length;
    for( let j=0; j<num; j++ )
    {
        for( let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            if( this.mForceMuted )
                this.mPasses[j].MuteInput( this.mAudioContext, i );
            else
                this.mPasses[j].UnMuteInput( this.mAudioContext, i );
        }
    }

    return this.mForceMuted;
}

Effect.prototype.SetKeyDown = function( passid, k )
{
    if( this.mKeyboard.mData[ k + 0*256 ] == 255 ) return;

    this.mKeyboard.mData[ k + 0*256 ] = 255;
    this.mKeyboard.mData[ k + 1*256 ] = 255;
    this.mKeyboard.mData[ k + 2*256 ] = 255 - this.mKeyboard.mData[ k + 2*256 ];
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    let num = this.mPasses.length;
    for (let j=0; j<num; j++ )
    {
        for (let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            let inp = this.mPasses[j].mInputs[i];
            if( inp!==null && inp.mInfo.mType==="keyboard" )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:this.mKeyboard.mIcon, mData: this.mKeyboard.mData}, false, 6, 1, -1.0, this.mPasses[j].mID );
            }
        }
    }
}

Effect.prototype.SetKeyUp = function( passid, k )
{
    this.mKeyboard.mData[ k + 0*256 ] = 0;
    this.mKeyboard.mData[ k + 1*256 ] = 0;
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    let num = this.mPasses.length;
    for (let j=0; j<num; j++ )
    {
        for (let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            let inp = this.mPasses[j].mInputs[i];
            if( inp!==null && inp.mInfo.mType==="keyboard" )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:this.mKeyboard.mIcon, mData: this.mKeyboard.mData}, false, 6, 1, -1.0, this.mPasses[j].mID );
            }
        }
    }

}

Effect.prototype.StopOutputs = function()
{
    let wa = this.mAudioContext;

    let num = this.mPasses.length;
    for (let i=0; i<num; i++ )
    {
        this.mPasses[i].StopOutput( wa );
    }
}

Effect.prototype.ResumeOutputs = function()
{
    let wa = this.mAudioContext;

    let num = this.mPasses.length;
    for (let i=0; i<num; i++ )
    {
        this.mPasses[i].ResumeOutput( wa );
    }
}

Effect.prototype.PauseInput = function( passid, id )
{
    return this.mPasses[passid].TooglePauseInput( this.mAudioContext, id );
}

Effect.prototype.ToggleMuteInput = function( passid, id )
{
    return this.mPasses[passid].ToggleMuteInput( this.mAudioContext, id );
}

Effect.prototype.RewindInput = function( passid, id )
{
    this.mPasses[passid].RewindInput( this.mAudioContext, id );
}

Effect.prototype.UpdateInputs = function( passid, forceUpdate )
{
   this.mPasses[passid].UpdateInputs( this.mAudioContext, forceUpdate, this.mKeyboard );
}

Effect.prototype.ResetTime = function()
{
    this.mFrame = 0;
    this.mAudioContext.resume()

    let num = this.mPasses.length;
    for( let i=0; i<num; i++ )
    {
        this.mPasses[i].mFrame = 0;
        for( let j=0; j<this.mPasses[i].mInputs.length; j++ )
            this.mPasses[i].RewindInput(this.mAudioContext, j)
    }
}

Effect.prototype.RequestAnimationFrame = function (id)
{
    if (this.mRenderingStereo && this.mWebVR.IsPresenting())
    {
        this.mWebVR.RequestAnimationFrame(id);
    }
    else
    {
        requestAnimFrame(id);
    }
}

Effect.prototype.Paint = function(time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, isPaused)
{
    let wa = this.mAudioContext;
    let da = new Date();
    let vrData = null; if (this.mRenderingStereo) vrData = this.mWebVR.GetData();
    let xres = this.mXres / 1;
    let yres = this.mYres / 1;

    if( this.mFrame===0 )
    {
        for( let i=0; i<this.mMaxBuffers; i++ )
        {
            if( this.mBuffers[i].mTexture[0]!==null )
            {
                this.mRenderer.SetRenderTarget( this.mBuffers[i].mTarget[0] );
                this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
                this.mRenderer.SetRenderTarget( this.mBuffers[i].mTarget[1] );
                this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
				
				this.mRenderer.CreateMipmaps( this.mBuffers[i].mTexture[0] );
				this.mRenderer.CreateMipmaps( this.mBuffers[i].mTexture[1] );
            }
        }
        for( let i=0; i<this.mMaxCubeBuffers; i++ )
        {
            if( this.mCubeBuffers[i].mTexture[0]!==null )
            {
                for( let face=0; face<6; face++ )
                {
                    this.mRenderer.SetRenderTargetCubeMap( this.mCubeBuffers[i].mTarget[0], face );
                    this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
                    this.mRenderer.SetRenderTargetCubeMap( this.mCubeBuffers[i].mTarget[1], face );
                    this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
					this.mRenderer.CreateMipmaps( this.mCubeBuffers[i].mTexture[0] );
				    this.mRenderer.CreateMipmaps( this.mCubeBuffers[i].mTexture[1] );
                }
            }
        }
    }

    let num = this.mPasses.length;

    // render sound first
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "sound" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, null, false, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render buffers second
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "buffer" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        let bufferID = assetID_to_bufferID( this.mPasses[i].mOutputs[0] );

        // check if any downstream pass needs mipmaps when reading from this buffer
        let needMipMaps = false;
        for (let j=0; j<num; j++ )
        {
            for (let k=0; k<this.mPasses[j].mInputs.length; k++ )
            {
                let inp = this.mPasses[j].mInputs[k];
                if( inp!==null && inp.mInfo.mType==="buffer" && inp.id === bufferID && inp.mInfo.mSampler.filter === "mipmap")
                {
                    needMipMaps = true;
                    break;
                }
            }
        }

        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, needMipMaps, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }


    // render cubemap buffers second
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "cubemap" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        let bufferID = 0;//assetID_to_bufferID( this.mPasses[i].mOutputs[0] );

        // check if any downstream pass needs mipmaps when reading from this buffer
        let needMipMaps = false;

        for (let j=0; j<num; j++ )
        {
            for (let k=0; k<this.mPasses[j].mInputs.length; k++ )
            {
                let inp = this.mPasses[j].mInputs[k];
                if( inp!==null && inp.mInfo.mType==="cubemap" )
                {
                    if( assetID_to_cubemapBuferID(inp.mInfo.mID)===0 && inp.mInfo.mSampler.filter === "mipmap" )
                    {
                        needMipMaps = true;
                        break;
                    }
                }
            }
        }

        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, needMipMaps, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render image last
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "image" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, null, false, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }   

    // erase keypresses
    for (let k=0; k<256; k++ )
    {
       this.mKeyboard.mData[ k + 1*256 ] = 0;
    }
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    if( this.mRenderingStereo ) this.mWebVR.Finish();

    this.mFrame++;
}

Effect.prototype.NewShader = function( passid, preventCache, onResolve )
{
    let commonSourceCodes = [];
    for (let i=0; i<this.mPasses.length; i++ )
    {
        if( this.mPasses[i].mType==="common")
        {
            commonSourceCodes.push(this.mPasses[i].mSource);
        }
    }

    this.mPasses[passid].NewShader(commonSourceCodes, preventCache, onResolve );
}

Effect.prototype.GetNumPasses = function()
{
    return this.mPasses.length;
}

Effect.prototype.GetNumOfType = function(passtype)
{
    let id = 0;
    for (let j=0; j<this.mPasses.length; j++ )
    {
        if( this.mPasses[j].mType===passtype )
        {
            id++;
        }
    }
    return id;
}

Effect.prototype.GetPassType = function( id )
{
    return this.mPasses[id].mType;
}
Effect.prototype.GetPassName = function( id )
{
    return this.mPasses[id].mName;
}
Effect.prototype.GetCode = function( id )
{
    return this.mPasses[id].mSource;
}
Effect.prototype.SetCode = function( id, source )
{
    this.mPasses[id].SetCode(source);
}
Effect.prototype.GetError = function (id)
{
    return this.mPasses[id].mError;
}
Effect.prototype.GetErrorStr = function (id)
{
    return this.mPasses[id].mErrorStr;
}
Effect.prototype.GetErrorGlobal = function()
{
    for (let i = 0; i < this.mPasses.length; i++)
    {
        if (this.mPasses[i].mError)
        {
            return true;
        }
    }
    return false;
}

Effect.prototype.Load = function (jobj )
{
    if (jobj.ver !== "0.1")
    {
        console.log("Wrong Format");
        return false;
    }

    let numPasses = jobj.renderpass.length;

    if( numPasses<1 || numPasses>this.mMaxPasses )
    {
        console.log("Corrupted Shader - " + numPasses);
        return false;
    }

    this.mPasses = [];
    for (let j = 0; j < numPasses; j++)
    {
        let rpass = jobj.renderpass[j];

        // skip sound passes if in thumbnail mode
        if( this.mForceMuted && rpass.type === "sound" ) continue;

        let wpass = new EffectPass(this.mRenderer, this.mIs20, this.mIsLowEnd, this.mShaderTextureLOD,
                                   this.mTextureCallbackFun, this.mTextureCallbackObj, this.mForceMuted, this.mForcePaused, this.mGainNode,
                                   this.mProgramDownscale, j, this);

        wpass.Create(rpass.type, this.mAudioContext);

        let numInputs = rpass.inputs.length;

        for (let i = 0; i < 4; i++)
        {
            wpass.NewTexture(this.mAudioContext, i, null, null, null);
        }
        for (let i = 0; i < numInputs; i++)
        {
            let lid  = rpass.inputs[i].channel;
            let styp = rpass.inputs[i].type;
            let sid  = rpass.inputs[i].id;
            let ssrc = rpass.inputs[i].filepath;
            let psrc = rpass.inputs[i].previewfilepath;
            let samp = rpass.inputs[i].sampler;

            wpass.NewTexture(this.mAudioContext, lid, { mType: styp, mID: sid, mSrc: ssrc, mSampler: samp, mPreviewSrc: psrc }, this.mBuffers, this.mCubeBuffers, this.mKeyboard);
        }

        for (let i = 0; i < 4; i++)
        {
            wpass.SetOutputs(i, null);
        }

        let numOutputs = rpass.outputs.length;
        for (let i = 0; i < numOutputs; i++)
        {
            let outputID = rpass.outputs[i].id;
            let outputCH = rpass.outputs[i].channel;
            wpass.SetOutputs(outputCH, outputID);
        }

        // create some hardcoded names. This should come from the DB
        let rpassName = "";
        if (rpass.type === "common" ) rpassName = "Common";
        if (rpass.type === "sound"  ) rpassName = "Sound";
        if (rpass.type === "image"  ) rpassName = "Image";
        if (rpass.type === "buffer") rpassName = "Buffer " + String.fromCharCode(65 + assetID_to_bufferID(wpass.mOutputs[0]));
        if (rpass.type === "cubemap") rpassName = "Cube A";// " + String.fromCharCode(65 + assetID_to_bufferID(this.mPasses[j].mOutputs[0]));
        wpass.SetName(rpassName);
        wpass.SetCode(rpass.code);

        this.mPasses.push(wpass);
    }
    return true;
}

Effect.prototype.CompileSome = function ( passes, preventCache, onResolve )
{
    let me = this;

    let to = getRealTime();
    let allPromisses = [];
    for (let j = 0; j < passes.length; j++)
    {
        allPromisses.push(new Promise(function (resolve, reject)
        {
            me.NewShader(passes[j], preventCache, function () { resolve(1); });
        }));
    }

    // aggregated callback when all passes have been compiled
    Promise.all(allPromisses).then(function (values)
    {
        let totalError = false;
        for (let j = 0; j < me.mPasses.length; j++)
        {
            if (me.mPasses[j].mError)
            {
                totalError = true;
                break;
            }
        }
        me.mCompilationTime = getRealTime() - to;
        onResolve(!totalError);
    }).catch(console.log);
}

Effect.prototype.Compile = function (preventCache, onResolve )
{
    let me = this;

    let to = getRealTime();
    let allPromisses = [];
    let numPasses = this.mPasses.length;
    for (let j = 0; j < numPasses; j++)
    {
        allPromisses.push(new Promise(function (resolve, reject)
        {
            me.NewShader(j, preventCache, function () { resolve(1); });
        }));
    }

    // aggregated callback when all passes have been compiled
    Promise.all(allPromisses).then(function (values)
    {
        let totalError = false;
        for (let j = 0; j < numPasses; j++)
        {
            if (me.mPasses[j].mError)
            {
                totalError = true;
                break;
            }
        }
        me.mCompilationTime = getRealTime() - to;
        onResolve(!totalError);
    }).catch(console.log);
}

Effect.prototype.GetCompilationTime = function( id )
{
    return this.mPasses[id].GetCompilationTime()/1000.0;
}
Effect.prototype.GetTotalCompilationTime = function()
{
    return this.mCompilationTime/1000.0;
}

Effect.prototype.DestroyPass = function( id )
{
   this.mPasses[id].Destroy( this.mAudioContext );
   this.mPasses.splice(id, 1);
}

Effect.prototype.AddPass = function( passType, passName, onResolve )
{
    let shaderStr = null;

    if( passType==="sound"   ) shaderStr = "vec2 mainSound( int samp, float time )\n{\n    // A 440 Hz wave that attenuates quickly overt time\n    return vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );\n}";
    if( passType==="buffer"  ) shaderStr = "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}";
    if( passType==="common"  ) shaderStr = "vec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}";
    if( passType==="cubemap" ) shaderStr = "void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Ray direction as color\n    vec3 col = 0.5 + 0.5*rayDir;\n\n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}";

    let id = this.GetNumPasses();
    this.mPasses[id] = new EffectPass( this.mRenderer, this.mIs20, this.mIsLowEnd, this.mShaderTextureLOD,
                                       this.mTextureCallbackFun, this.mTextureCallbackObj, this.mForceMuted, this.mForcePaused, this.mGainNode, 
                                       this.mProgramDownscale, id, this );

    this.mPasses[id].Create( passType, this.mAudioContext );
    this.mPasses[id].SetName( passName );
    this.mPasses[id].SetCode( shaderStr );
    this.NewShader(id, false, function ()
    {
        onResolve();
    });

    return { mId : id, mShader : shaderStr };
}

// this should be removed once we have MultiPass 2.0 and passes render to arbitrary buffers
Effect.prototype.IsBufferPassUsed = function( bufferID )
{
    for (let j=0; j<this.mPasses.length; j++ )
    {
        if( this.mPasses[j].mType !== "buffer" ) continue;
        if( this.mPasses[j].mOutputs[0] === bufferID_to_assetID(bufferID) ) return true;
    }
    return false;
}

Effect.prototype.Save = function()
{
    var result = {};

    result.ver = "0.1";

    result.renderpass = [];

    let numPasses = this.mPasses.length;
    for (let j=0; j<numPasses; j++ )
    {
        result.renderpass[j] = {};

        result.renderpass[j].outputs = new Array();
        for (let i = 0; i<4; i++ )
        {
            let outputID = this.mPasses[j].mOutputs[i];
            if( outputID===null ) continue;
            result.renderpass[j].outputs.push( { channel: i, id: outputID } );
        }
        result.renderpass[j].inputs = new Array();
        for (let i = 0; i<4; i++ )
        {
            if( this.mPasses[j].mInputs[i]===null ) continue;
            result.renderpass[j].inputs.push( {channel: i,
                                               type    : this.mPasses[j].mInputs[i].mInfo.mType,
                                               id      : this.mPasses[j].mInputs[i].mInfo.mID,
                                               filepath: this.mPasses[j].mInputs[i].mInfo.mSrc,
                                               sampler : this.mPasses[j].mInputs[i].mInfo.mSampler });
        }

        result.renderpass[j].code = this.mPasses[j].mSource;
        result.renderpass[j].name = this.mPasses[j].mName
        result.renderpass[j].description = "";
        result.renderpass[j].type = this.mPasses[j].mType;
    }

    result.flags = this.calcFlags();

    return result;
}

Effect.prototype.calcFlags = function ()
{
    let flagVR = false;
    let flagWebcam = false;
    let flagSoundInput = false;
    let flagSoundOutput = false;
    let flagKeyboard = false;
    let flagMultipass = false;
    let flagMusicStream = false;

    let numPasses = this.mPasses.length;
    for (let j = 0; j < numPasses; j++)
    {
        let pass = this.mPasses[j];

        if (pass.mType === "sound") flagSoundOutput = true;
        if (pass.mType === "buffer") flagMultipass = true;

        for (let i = 0; i < 4; i++)
        {
            if (pass.mInputs[i] === null) continue;

            if (pass.mInputs[i].mInfo.mType === "webcam") flagWebcam = true;
            else if (pass.mInputs[i].mInfo.mType === "keyboard") flagKeyboard = true;
            else if (pass.mInputs[i].mInfo.mType === "mic") flagSoundInput = true;
            else if (pass.mInputs[i].mInfo.mType === "musicstream") flagMusicStream = true;
        }

        let n1 = pass.mSource.indexOf("mainVR(");
        let n2 = pass.mSource.indexOf("mainVR (");
        if (n1 > 0 || n2 > 0) flagVR = true;
    }

    return {
        mFlagVR: flagVR,
        mFlagWebcam: flagWebcam,
        mFlagSoundInput: flagSoundInput,
        mFlagSoundOutput: flagSoundOutput,
        mFlagKeyboard: flagKeyboard,
        mFlagMultipass: flagMultipass,
        mFlagMusicStream: flagMusicStream
    };
}</script>
    <script>"use strict"

const kMaxCompileTime = 10.0;

function iReportCrash(shaderID)
{
    let req = new XMLHttpRequest();
    req.onload = function ()
    {
        let jsn = req.response;
        if (jsn === null) return;
        if (jsn.result === 0)
        {
            // yep
        }
    };
    req.open("POST", "/shadertoy", true);
    req.responseType = "json";
    req.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    req.send( "s=" + shaderID + "&r=2" );
}
</script>
    <script>"use strict"

var gActive = -1;
var mShaders = [];
var gNumCanvases = 0;

function myrefresh( id, slot, img, forceFrame, gui, guiID, renderID, time )
{
    if( mShaders[id].mReady===false ) return;
    if( forceFrame )
    {
        if (mShaders[id].mScreenshot === false)
        {
            mShaders[id].gEffect.Paint(mShaders[id].mTime / 1000.0, 1.0 / 60.0, 60.0, 0, 0, 0, 0, false);
        }
    }
}

function startRendering()
{
    if( gActive<0 ) return;
    if( mShaders[gActive].mReady===false ) return;
    if( mShaders[gActive].mScreenshot===true ) return;

    let time = getRealTime();

    mShaders[gActive].mFPS.Count( time );
    mShaders[gActive].mTime = mShaders[gActive].mTime0 + (time - mShaders[gActive].mTo);
    let dtime = 1000.0/60.0;
    mShaders[gActive].gEffect.Paint( mShaders[gActive].mTime/1000.0, dtime/1000.0, mShaders[gActive].mFPS.GetFPS(), 0,0,0,0, false);

    requestAnimFrame( startRendering );
}

function iLoadAndCompile(jsn, i )
{
    var shaderObj = jsn[i];
    if (shaderObj === null) return;

    var resizeCB = function (xres, yres) { myrefresh(i, 0, null, true, false, 0, -1.0) };
    var crashCB = function () { alert('crash');/*iReportCrash(gShaderIDs[i])*/ };
    mShaders[i].gEffect = new Effect(null, null, mShaders[i].mPreview.mCanvas, myrefresh, i, true, true, resizeCB, crashCB);

    if (!mShaders[i].gEffect.Load(shaderObj)) return;

    mShaders[i].gEffect.Compile(false, function (worked)
    {
        if (worked === true)
        {
            previewShowRender(mShaders[i].mPreview);

            mShaders[i].mScreenshot = false;
            mShaders[i].mReady = true;
            mShaders[i].mTime = 10.0 * 1000.0;
            mShaders[i].mTime0 = 0.0;
            mShaders[i].mTo = 0.0;
            mShaders[i].mFPS = piCreateFPSCounter();
            mShaders[i].mPreview.mCanvas.addEventListener("mouseout", function (ev) { gActive = -1; }, true);
            mShaders[i].mPreview.mBase.addEventListener("mouseover", function (ev) { if (mShaders[i].mPreview.mUI !== null) mShaders[i].mPreview.mUI.classList.add('isVisible'); }, true);
            mShaders[i].mPreview.mBase.addEventListener("mouseout", function (ev) { if (mShaders[i].mPreview.mUI !== null) mShaders[i].mPreview.mUI.classList.remove('isVisible'); }, true);
            mShaders[i].mPreview.mCanvas.addEventListener("mouseover", function (ev)
            {
                let ele = piGetSourceElement(ev);
                if (ele.mId === undefined) return;

                gActive = ele.mId;
                if (!mShaders[gActive].mReady) return;
                let time = getRealTime();
                mShaders[gActive].mTo = time;
                mShaders[gActive].mTime0 = mShaders[gActive].mTime;
                mShaders[gActive].mFPS.Reset(time);

                startRendering();
            }, true);


            /*
            let compilationTime = mShaders[i].gEffect.GetTotalCompilationTime();
            if (compilationTime > kMaxCompileTime)
            {
                iReportCrash(mShaders[i].mShaderID);
            }*/

            myrefresh(i, null, null, true, false, 0, -1.0);
        }
        else
        {
            mShaders[i].mReady = false;
            previewShowError(mShaders[i].mPreview);
        }
    });
};


function iProcessShader( jsn, i )
{
    var shaderObj = jsn[i];
    if( shaderObj===null ) return;

    if ((shaderObj.info.usePreview === 0 && !gUseScreenshots) || (mShaders[i].mPreviewReady !== 1))
    {
        iLoadAndCompile(jsn, i);
    }
    else
    {
        mShaders[i].mScreenshot = true;
        if( shaderObj.info.usePreview === 1 )
            previewShowScreenshot(mShaders[i].mPreview, 1); // comp
        else if (gUseScreenshots)
            previewShowScreenshot(mShaders[i].mPreview, 2); // sett
    }

    if( i<(jsn.length-1) ) setTimeout( function(){iProcessShader(jsn,i+1);}, 10 );
}

function iInitUI(numCanvases, uiCallback, windowTitle)
{
    gNumCanvases = numCanvases;
    document.getElementById("mySearch").focus();

    //-----------------------------------------------------------------
    // window
    //-----------------------------------------------------------------
    if (windowTitle !== null) {
        document.title = windowTitle;
    }

    //-----------------------------------------------------------------
    // ui
    //-----------------------------------------------------------------
    var num = Math.min(gShaders.length, gNumCanvases);

    //var base = document.getElementsByClassName( "searchResult" );

    for (let i = 0; i < gNumCanvases; i++)
    {
        let pv = createPreview(i);

        if (i >= num) {
            previewHide(pv);
            continue;
        }

        let shaderID = gShaders[i].info.id;
        
        if (pv.mUI !== null && uiCallback !== null) {
            pv.mUI.addEventListener('click', function (ev) {
                uiCallback(shaderID);
                ev.preventDefault();
            }, false);
        }
        
        previewShowLoading(pv);
        
        mShaders[i] = {};
        mShaders[i].mShaderID = shaderID;
        mShaders[i].mPreview = pv;
        mShaders[i].mScreenshot = false;
        mShaders[i].mPreview.mLink.href = "/view/" + shaderID;
        mShaders[i].mPreviewReady = 0;
        mShaders[i].mReady = false;
        mShaders[i].gEffect = null;

        previewLoadScreenshot(mShaders[i].mPreview,
            function () { mShaders[i].mPreviewReady = 1; if (mShaders[i].mReady === false) previewShowScreenshot(mShaders[i].mPreview, 0); },
            function () { mShaders[i].mPreviewReady = 2; },
            shaderID);
    }

    if (num <= 0) {
        return;
    }
}

function iInitShaders(jsn)
{
    for (let i = 0; i < jsn.length; i++)
    {
        let shaderObj = jsn[i];
        if (shaderObj === null) continue;
        let inf = shaderObj.info;
        mShaders[i].mPreview.mTextA.textContent = inf.name;
        mShaders[i].mPreview.mTextB.innerHTML = "<a class='user' href='/user/" + htmlEntities(inf.username) + "'>" + htmlEntities(inf.username) + "</a>";
        mShaders[i].mPreview.mTextC.innerHTML = "<img src='/img/themes/" + gThemeName + "/views.png' class='viewsIcon'></img>" + inf.viewed + "    &nbsp;&nbsp;  <img src='/img/themes/" + gThemeName + "/likes.png' class='likesIcon'></img>" + inf.likes;
    }

    setTimeout(function () { iProcessShader(jsn, 0); }, 10);
}

function resultsInitStatic(numCanvases, uiCallback, windowTitle)
{
    iInitUI(numCanvases, uiCallback, windowTitle);

    iInitShaders(gShaders);
}

function resultsInit(numCanvases, uiCallback, windowTitle)
{	
    iInitUI(numCanvases, uiCallback, windowTitle);

    var num = Math.min(gShaderIDs.length, gNumCanvases);

    var mHttpReq = new XMLHttpRequest();

    mHttpReq.abort();

    var str = "{ \"shaders\" : [";
    for( let i=0; i<num; i++ )
    {
         str += "\"" + gShaderIDs[i] + "\"";
         if( i!==(num-1) ) str += ", ";
    }
    str += "] }";

    str = "s=" + encodeURIComponent( str ) + "&nt=0&nl=0&np=0";

    mHttpReq.open( "POST", "/shadertoy", true );
    mHttpReq.responseType = "json";
    mHttpReq.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    mHttpReq.onload = function ()
    {
        let jsn = this.response;
        if( jsn===null )
        {
            console.log( "Could not load shaders" );
            return;
        }

        iInitShaders(jsn);
    }
    mHttpReq.send( str );
}</script>
    <style>
    .shaderPreview
    {
    display: block;
    background-color: #000000;
    background-image: url("/img/loading.gif");
    background-repeat: no-repeat;
    background-position: center;
    padding: 0px;
    margin: 0px;
    border: 0px solid #000000;
    border-radius: 8px;
    width:100%;
    height:100%;
    position: absolute;
    overflow:hidden;
    }

    .previewInfo
    {
    width: 100%;
    left: 0px;
    top: 2px;
    position: relative;
    visibility: hidden;
    }

    .previewCanvas
    {
    left: 0px;
    top: 0px;
    padding: 0px;
    margin: 0px;
    position: absolute;
    cursor: pointer;
    width:100%;
    height:100%;
    border-radius: 8px;
    border: 0px solid #000000;
    backgroundColor: transparent;
visibility: hidden;
opacity:0;
transition: opacity 1.0s ease;
    }

    .previewText
    {
        text-overflow: ellipsis;
    white-space: nowrap;
    padding-right: 1px;
    }

    .previewTextUser
    {
    text-overflow: ellipsis;
    white-space: nowrap;
    padding-left: 3px;
    }

    .previewStats
    {
    padding-right: 1px;
    right: 0px;
    top: 0px;
    position: absolute;
    }

    .previewErrorContainer
    {
    left:0px;
    top:0px;
    width:100%;
    height:100%;
    padding:0px;
    margin:0px;
    background-color:#000000;
    border-radius:8px;
    cursor:pointer;
    visibility:hidden;
    }

    .previewErrorMessage
    {
    top:50%;
    position:absolute;
    width:100%;
    text-align:center;
    padding:0;
    margin:auto;
    color:#ff0000;
    font-size:2em;
    font-style:italic;
    }

    .previewNoGLContainter
    {
    left:0px;
    top:0px;
    width:100%;
    height:100%;
    padding:0px;
    margin:0px;
    position:absolute;
    background-color:#000000;
    border-radius:8px;
    cursor:pointer;
    pointer-events:none;
    visibility:hidden;
    font-size:2em;
    }

    .previewNoGLMessage
    {
    width:86%;
    height:90%;
    padding-left:7%;
    padding-right:7%;
    padding-top:10%;
    padding-bottom:0px;
    color:#ff0000;
    position:absolute;
    visibility:hidden;
    }

    .previewThumbnailContainer
    {
    width:100%;
    height:100%;
    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    cursor:pointer;
    visibility:hidden;
    border-radius:8px;
    border:0px solid #000000;
    }

    .previewThumbnailImage
    {
    width:100%;
    height:100%;
    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    cursor:pointer;
    border-radius:8px;
    border:0px solid #000000;
opacity: 0.0;
transition: opacity 1.0s ease;
    }

    .previewThumbnailIcon
    {
    width:64px;
    height:32px;
    left:0px;
    top:0px;
    padding:0px;
    padding-top:12px;
    margin:0px;
    position:absolute;
    color:#ffffff;
    background-color:#ff8020;
    font-weight:bold;
    border-radius:0px 0px 8px 0px;
    text-align:center;
    //visibility:hidden;
    }


    .previewUIContainter
    {
    display: block;
    right:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    //cursor:pointer;
    //pointer-events:none;
    //visibility:hidden;
    }
</style>

<script>
    function previewHide(me)
    {
    me.mBase.style.visibility = "hidden";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "hidden";
    }

    function previewShowRender(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "visible";
me.mCanvas.style.opacity = 1.0;
    me.mCanvas.style.borderRadius ="8px;";
//  me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "visible";
    }

    function previewShowScreenshot(me, message)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "visible";
me.mThumbnailImg.style.opacity = 1.0;
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "visible";
    me.mThumbnailWar1.style.visibility = (message===1)?"visible":"hidden";
    me.mThumbnailWar2.style.visibility = (message===2)?"visible":"hidden";
    }

    function previewShowLoading(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "hidden";

    me.mLink.style.visibility = "visible";
    me.mBase.style.backgroundColor = "#ff0000;"
    me.mCont.style.visibility = "visible";
    }

    function previewShowNoWebGL(me, shaderID)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "visible";
    me.mError.style.visibility = "visible";
    me.mThumbnailImgNoWebGL.onerror = function(ev) 
                                      { 
                                            me.mThumbnailImgNoWebGL.style.visibility="hidden"; 
                                            me.mMessageNoWebGL.style.visibility="visible"; 
                                      };
    me.mThumbnailImgNoWebGL.src = "/media/shaders/" + shaderID + ".jpg";
    }

    function previewShowError(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "visible";
    me.mCont.style.visibility = "visible";
    }

    function previewLoadScreenshot( me, cbSuccess, cbError, shaderID )
    {
    var url = "/media/shaders/" + shaderID + ".jpg";
    me.mThumbnailImg.onload = cbSuccess;
    me.mThumbnailImg.onerror = function(ev) { cbError(); };
    me.mThumbnailImg.src = url;
    }
        
    function createPreview(id)
    {
        var bar = document.getElementById( "Preview_"+id+"_Canvas" );
        bar.width = bar.offsetWidth;
        bar.height = bar.offsetHeight;
        bar.mId = id;

        return { mBase: document.getElementById( "Preview_"+id+"_Container" ),
        mLink: document.getElementById( "Preview_"+id+"_Link" ),
        mCanvas: bar,
        mCont: document.getElementById( "Preview_"+id+"_Info" ),
        mTextA: document.getElementById( "Preview_"+id+"_Text" ),
        mTextB: document.getElementById( "Preview_"+id+"_TextUser" ),
        mTextC: document.getElementById( "Preview_"+id+"_Stats" ),
        mNoWebGL: document.getElementById( "Preview_"+id+"_NoWebGL" ),
        mError: document.getElementById( "Preview_"+id+"_Error" ),
        mCanvas2D: document.getElementById( "Preview_"+id+"_Thumnail" ),
        mThumbnailImg: document.getElementById( "Preview_"+id+"_ThumnailImage" ),
        mThumbnailWar1: document.getElementById( "Preview_"+id+"_ThumnailWarning1" ),
        mThumbnailWar2: document.getElementById( "Preview_"+id+"_ThumnailWarning2" ),
        mThumbnailImgNoWebGL: document.getElementById( "Preview_"+id+"_ThumnailImageNoWebGL" ),
        mMessageNoWebGL: document.getElementById( "Preview_"+id+"_MessageNoWebGL"),
        mUI: document.getElementById( "Preview_"+id+"_UI" )
        };
    }
</script>

    <style>

    div#shaderGrid
    {
        width:100%;
        padding:0px;
        margin:0px;
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        grid-template-rows: repeat(3, 1fr);
        grid-column-gap: 64px;
        grid-row-gap: 24px;
    }
    .searchResult
    {
        margin: 0px;
        padding: 0px;
        width: 100%;
    }
    .searchResultContainer
    {
        width: 100%;
        padding-bottom:56.25%;
        height: 0;
        position: relative;
    }
    .navigation
    {
        display:flex;
        align-items:center;
    }
    div#navBottom
    {
        display:none;
        justify-content:center;
    }
    a.pageButtons, .pageButtonsCurrent
    {
        border-style: solid;
        border-width: 1px;
        border-color: #808080;
        text-align: center;
        vertical-align: middle;
        margin-left: 12px;
        display: inline-block;
        border-radius: 4px;
		font-weight:bold;
        cursor: pointer;
        padding-bottom:5px;
        padding-top:4px;
        padding-left: 8px;
        padding-right: 8px;
        margin:8px;
    }
    a.pageButtons
    {
        text-decoration: none;
        -moz-transition:    background-color 0.15s linear, color 0.15s linear;
        -webkit-transition: background-color 0.15s linear, color 0.15s linear;
        transition:         background-color 0.15s linear, color 0.15s linear;
    }
    a.pageButtons:hover
    {
      background-color:#808080;
      color : #ff8020;
    }
    .pageButtonsCurrent
    {
        background-color: #808080;
        color:#000000;
    }
    div#controls
    {
        width:100%;
        padding-top:16px;
        padding-bottom:16px;
        display:flex;
        justify-content:space-between; 
        flex-wrap:wrap;
    }
    div#controls > div
    {
        display:inline-flex;
    }
    .controlOptions
    {
        display:inline-block;
    }

    /* ----------------------- media resolutions ------------------------ */

    @media screen and (max-width:799px) 
    {
        div#shaderGrid  { grid-template-columns: 1fr; grid-template-rows: repeat(12, 1fr); grid-column-gap: 0px; grid-row-gap: 16px; }
        div#controls
        {
            width:100%;
            display:flex;
            justify-content:flex-start; 
            flex-wrap:wrap;
        }
        div#controls > div
        {
            display:inline-flex;
            width:100%;
            margin-left: 0px;
            margin-right: 0px;
            padding-bottom:16px;
        }
        div#navBottom
        {
            display: flex;
        }
    }
    
    </style>
    <script>
    var gShaders=[{"ver":"0.1","info":{"id":"Xllfzl","date":"1513378957","viewed":10067,"name":"Homeward","username":"Dave_Hoskins","description":"OK, it's feathers aren't quite the right shape for a crow, but hey...\nIt takes advantage of WebGL2 and buffers. All the stuff that is done multiple times for each pixel, like animation, is put into A as single pixel calculations\n","likes":220,"published":3,"flags":104,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"ltSSR1","filepath":"https:\/\/soundcloud.com\/made-in-the-hutch\/albatross-peter-green-fleetwood-mac-tribute-ed?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","previewfilepath":"https:\/\/soundcloud.com\/made-in-the-hutch\/albatross-peter-green-fleetwood-mac-tribute-ed?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","type":"musicstream","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Homeward\n\/\/ by David Hoskins.\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ Do the crow in this buffer...\n\n\n\n#define PI 3.1415926535\n\nmat3 crowDir;\nvec4 flapping, headTilt;\nfloat turn, specular;\n\n\/\/----------------------------------------------------------------------------------------\nvec4 getStore(int num)\n{\n    \/\/ivec2 loc = ivec2(num & 63, num\/64); \/\/ Didn't need that many, doh!\n    ivec2 loc = ivec2(num, 0);\n    return  texelFetch(iChannel0, loc, 0);\n}\n\n\n\/\/----------------------------------------------------------------------------------------\n\n\/\/----------------------------------------------------------------------------------------\nfloat noise( in float p  )\n{\n    \n    float f = fract(p);\n    p = floor(p);\n\tf = f*f*(3.0-2.0*f);\n\treturn mix(hash11(p),hash11(p+1.), f);\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat sMin( float a, float b, float k )\n{\n    \n\tfloat h = clamp(0.5 + 0.5*(b-a)\/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.-h);\n}\n\/\/----------------------------------------------------------------------------------------\nmat2 rot2D(float a)\n{\n\tfloat si = sin(a);\n\tfloat co = cos(a);\n\treturn mat2(co, si, -si, co);\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat  sphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat featherBox( vec3 p, vec3 b, float r )\n{\n    b.y-= smoothstep(3.75, -4.0, p.z)*noise(p.x*6.)*.56;\n\n    p.y+=  smoothstep(1.5, .0, p.z)*noise(p.x*3.+crowPos.z*1.)*.35;\n    return length(max(abs(p)-b,0.0))-r;\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat featherTailBox( vec3 p, vec3 b, float r )\n{\n    \/\/b.x \/= smoothstep(-10.,4.,p.z);\n    p.x *= clamp((p.z+4.)\/6., 0.1,2.5);\n    b.y-= smoothstep(.75, .0, p.z)*noise(p.x*3.)*.3;\n    \n    p.y+=  smoothstep(1., -4.0, p.z)*noise(p.x*3.+crowPos.z*1.)*.5;\n    return length(max(abs(p)-b,0.0))-r;\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat segment(vec3 p,  vec3 a, vec3 b, float r1, float r2)\n{\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r1 + r2*h;\n}\n\n\n\/\/--------------------------------------------------------------------------\nfloat noise( in vec3 p )\n{\n    vec3 f = fract(p);\n    p = floor(p);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel3, (uv+ 0.5)\/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec3 getSky(vec3 dir, vec3 pos)\n{\n    vec3 col;\n    vec3 clou = dir * 1. + pos*.025;\n\tfloat t = noise(clou);\n    t += noise(clou * 2.1) * .5;\n    t += noise(clou * 4.3) * .25;\n    t += noise(clou * 7.9) * .125;\n\tcol = mix(vec3(FOG_COLOUR), vec3(0.2, 0.2,.2),abs(dir.y))+ FOG_COLOUR *t*.4;\n \n    return col;\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ Map a crow like asbtract bird thing...\nfloat map(vec3 p, float t)\n{\n    float d, f;\n    specular = .1;\n    \/\/ Normalize rotation...\n    vec3 q = crowDir*(p-crowPos);\n    \/\/ Head...\n    vec3 b = q- vec3(.0, 0, 2.8);\n    b.yz = b.yz*rot2D(headTilt.x);\n    b.xz = b.xz*rot2D(headTilt.y);\n    d = segment(b,vec3(0,0,1), vec3(0,0,5.), 1.2, 3.); \n\n    \/\/ Body...\n    b = q+vec3(0,1.,3);\n  \td = sMin(d, segment(q, vec3(0), vec3(0,0,-14), 1.3, 11.5), 3.); \n    \/\/ Tail...\n    b.xy = b.xy* rot2D(headTilt.w);\n    d = sMin(d, featherTailBox(b, vec3(headTilt.z,.1,2.2), .3),4.3); \n    \/\/ Left wing...\n    b = q + vec3(2.8,0,0);\n    b.xy = rot2D(flapping.x)*b.xy;\n    d = sMin(d, featherBox(b+(vec3(4,0,1.)), vec3(4,.05,2.5),.4), 2.);\n    \n    b =  b + vec3(8,0,0);\n    b.xy = rot2D(flapping.y*1.5)*b.xy;\n\tf = featherBox(b+vec3(4,0,0), vec3(4,.05,3.5),.4);\n    f = max(f, sphere(b+vec3(2,0,3), 5.));\n    d = sMin(d, f, .1);\n    \n    \/\/ Right wing...\n    b = q - vec3(2.8,0,0);\n    b.xy = rot2D(-flapping.z)*b.xy;\n    d = sMin(d, featherBox(b-(vec3(4,0,-1.)), vec3(4,.05,2.5),.4), 2.);\n    \n    \n    b =  b - vec3(8,0,0);\n    b.xy = rot2D(-flapping.w*1.5)*b.xy;\n    f = featherBox(b-vec3(4,0,0), vec3(4,.05,3.5),.4);\n    f = max(f, sphere(b-vec3(2,0,-3), 5.));\n    d = sMin(d, f, .1);\n\n    \/\/ Do some glassy eyes...\n    b = q- vec3(.0, .0, 2.85);\n    \n    b.yz = b.yz*rot2D(headTilt.x);\n    b.xz = b.xz*rot2D(headTilt.y);\n\tb.x = abs(b.x);\n\n    f = sphere(b-vec3(.7,0.1,1.4), .25);\n    if (f < d){ d = f; specular = 4.0;}\n\n    \n    return d;\n}\n\/\/----------------------------------------------------------------------------------------\nvec3 getNormal(vec3 p, float e)\n{\n    return normalize( vec3( map(p+vec3(e,0.0,0.0), e) - map(p-vec3(e,0.0,0.0), e),\n                            map(p+vec3(0.0,e,0.0), e) - map(p-vec3(0.0,e,0.0), e),\n                            map(p+vec3(0.0,0.0,e), e) - map(p-vec3(0.0,0.0,e), e) ) );\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec3 lighting(in vec3 pos, in vec3 normal, in vec3 eyeDir, in float d)\n{\n\t;\n   \tnormal = reflect(eyeDir, normal); \/\/ Specular...\n    vec3 col = pow(max(dot(sunLight, normal), 0.0), 10.0)  * SUN_COLOUR * specular;\n\n\n\treturn min(col, 1.0);\n}\n\n\n\/\/----------------------------------------------------------------------------------------\nfloat marchScene(in vec3 rO, in vec3 rD, vec2 co, float t)\n{\n\tt += .5*hash12(co);\n    \n    for( int j=0; j < 30; j++ )\n\t{\n\t\tif (t >= FAR) break;\n\t\tfloat h = map( rO + t*rD, t*0.012);\n \t\tif(h < 0.03)\n\t\t{\n  \n            break;\n\t     }\n        t += h + t*.005;\n\t}\n    return t;\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec3 lenseFlare(vec2 uv,vec3 dir, mat3 camMat)\n{\n\n    vec3 col = vec3(0);\n    float bri = dot(dir, sunLight)*.7;\n\tif (bri > 0.0)\n\t{\n\t\tvec2 sunPos = vec2(dot( sunLight, camMat[0] ),dot( sunLight, camMat[1] ) );\n        \/\/sunPos = clamp(sunPos,-.5,.5);\n        \/\/sunPos *= vec2(iResolution.y\/iResolution.x, 1.);\n\t    float z = textureLod(iChannel1,(sunPos+1.)*.5, 0.).w;\n       \tvec2 uvT = uv-sunPos;\n        if (z >= FAR)\n        {\n            uvT = uvT*(length(uvT));\n            bri = pow(bri, 6.0)*.7;\n\n            \/\/ glare = the red shifted blob...\n            float glare1 = max(dot(dir,sunLight),0.0)*1.4;\n            \/\/ glare2 is the yellow ring...\n            float glare2 = max(1.-length(uvT+sunPos*.4)*4.0, 0.0);\n            uvT = mix (uvT, uv, -2.3);\n            \/\/ glare3 is a splodge...\n            float glare3 = max(1.-pow(length(uvT+sunPos*2.5)*3., 2.), 0.0);\n\n            col += bri * vec3(1.0, .0, .0)  * pow(glare1, 12.5)*.05;\n            col += bri * vec3(1.0, 1.0, .1) * pow(glare2, 2.0)*2.5;\n            col += bri * SUN_COLOUR * pow(glare3, 3.)*3.0;\n        }\n\t}\n    return col;\n}\n\n\n\/\/----------------------------------------------------------------------------------------\nvoid mainImage( out vec4 colOut, in vec2 fragCoord )\n{\n    \n    vec2 uv = (-iResolution.xy + 2.0 * fragCoord ) \/ iResolution.y;\n\n  \tvec3 col;\n\n    sunLight \t= getStore(SUN_DIRECTION).xyz;\n    vec3 camPos = getStore(CAMERA_POS).xyz;\n    vec3 camTar = getStore(CAMERA_TAR).xyz;\n    crowPos  \t= getStore(CROW_POS).xyz;\n    vec3 crowTar= getStore(CROW_HEADING).xyz;\n    flapping\t= getStore(CROW_FLAPPING);\n    headTilt\t= getStore(CROW_HEADTILT);\n    turn  \t\t= getStore(CROW_TURN).x;\n    crowDir\t\t= setCamMat(crowPos, crowTar, turn);\n    crowDir \t= inverse(crowDir);\n\tmat3 camMat = setCamMat(camPos, camTar, (camTar.x-camPos.x)*.02);\n    vec3 dir \t= camMat * normalize( vec3(uv, cos((length(uv*.5)))));\n\n\n\t\n    colOut = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    float t = max(length(camPos-crowTar)-25., .0);\n    float far = t+30.0;\n    float dhit = marchScene(camPos, dir, fragCoord, t);\n  \n    if (dhit < far && dhit < colOut.w)\n    {\n      \t\n       \tvec3  p = camPos+dhit*dir; \n        vec3 sky = getSky(dir, p);\n       \tvec3 nor =  getNormal(p, dhit*.003);\n   \t\tcol = lighting(p,nor, dir, dhit);\n        col = mix(sky, col.xyz , exp(-dhit*.0015)-.1);\n    }else\n    \tcol = texelFetch(iChannel1, ivec2(fragCoord), 0).xyz;\n    \n    \n    col += lenseFlare(uv, dir, camMat);\n    col = clamp(col, 0.0, 1.0);\n\n\t\/\/ Contrast & stretch...\n\n    col = pow( col, vec3(1.7,1.95,2.) )*1.8;\n    col = clamp(col, 0., 1.0);\n\tcol = col*.2 + (col*col*(3.0-2.0*col))*.8;\n \n    \/\/ Gamma...\n    col = min(sqrt(col), 1.0);\n\n\n    \/\/ Vignette...\n    vec2 xy = abs((fragCoord.xy \/ iResolution.xy)-.5);\n    col *= pow(abs(250.0* (.5-xy.y))*(.5-xy.x), .2 )*.7;\n\tcolOut = vec4(col*smoothstep(.0, 2.,iTime), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ by David Hoskins.\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/ These are indices into the variable data in this buffer...\n\n\n\/\/----------------------------------------------------------------------------------------\nfloat noise( in float p  )\n{\n    float f = fract(p);\n    p = floor(p);\n\tf = f*f*(3.0-2.0*f);\n\treturn mix(hash11(p),hash11(p+1.), f);\n}\n\/\/----------------------------------------------------------------------------------------\nfloat noiseTilt( in float p  )\n{\n    float f = fract(p);\n    p = floor(p);\n\tf = f*f*(3.0-2.0*f);\n    \n    f = f*f*f*f;\n\treturn mix(hash11(p),hash11(p+1.), f);\n}\n\/\/----------------------------------------------------------------------------------------\nfloat grabTime()\n{\n  \tfloat m = (iMouse.x\/iResolution.x)*80.0;\n\treturn (iTime+m+110.)*32.;\n}\n\n\/\/----------------------------------------------------------------------------------------\nint StoreIndex(ivec2 p)\n{\n\treturn p.x + 64 * p.y;\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec4 getStore(int num)\n{\n   \t\/\/ivec2 loc = ivec2(num & 63, num\/64); \/\/ Didn't need that many, doh!\n    ivec2 loc = ivec2(num, 0);\n    return  texelFetch(iChannel0, loc, 0);\n}\n\n\/\/----------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    ivec2 pos = ivec2(fragCoord);\n    vec4 col = vec4(0.);\n\tfloat gTime = grabTime();\n    \n    int num = StoreIndex(pos);\n    if (num > CROW_CLIMBING) discard;\n    \n    vec4 diff = (getStore(CROW_HEADING) - getStore(CROW_POS)) * vec4(-.07,.3, 1,1);\n    float climb  = diff.y;\n    float oldClimb  = getStore(CROW_CLIMBING).x;\n\n    switch (num)\n    {\n        case CAMERA_POS:\n        {\n            float r = gTime \/ 63.;\n        \tcol.xyz = cameraPath(gTime)+vec3(sin(r*.64 )*12., cos(r*.3)*12., 0.);\n           \n        }\n    \t\tbreak;\n        case CAMERA_TAR:\n            col.xyz = cameraPath(gTime + 20.);\n        \tbreak;\n        case SUN_DIRECTION:\n        \tcol.xyz  = normalize( vec3(  0.7, .8,  0.3 ) );\n    \t\tbreak;\n       \tcase CROW_POS:\n        {\n        \tfloat r = gTime \/ 200.-10.;\n        \tcol.xyz = cameraPath(gTime + 45.+ sin(r*.5)* 30.)+vec3(sin(r)*15.0, cos(r*.2)*12.0, 0.0);\n            float sp = pow((clamp(oldClimb+.1,0.0, .5)), 2.2)*3.;\n            \n            \/\/col.y-= sin(gTime*.25)*sp;\n            vec2 ax = vec2(sin(diff.x), cos(diff.x));\n            col.xy+= -ax*sin(gTime*.25)*sp;\n        }\n        \tbreak;\n        case CROW_HEADING:\n        {\n        \tfloat r = gTime \/ 200.-10.;\n        \tcol.xyz = cameraPath(gTime + 50.+ sin(r*.5)* 30.)+vec3(sin(r)*15.0, cos(r*.2)*12.0, 0.0);\n        }\n         \tbreak;\n        case CROW_FLAPPING:\n        {\n            float sp = pow((clamp(oldClimb+.1,0.0, .5)), 2.2)*3.5;\n   \n        \tcol.x  = sin(gTime*.25)*sp+ noise(gTime*.1)*.35;\n            col.y  = sin(gTime*.25-1.)*sp*.5+smoothstep(0.5,.0,sp)*.1;\n            \n            col.z  = sin(gTime*.25)*sp+ noise(gTime*.1+8.)*.35;\n            col.w  = sin(gTime*.25-1.)*sp*.5+smoothstep(0.5,.0,sp)*.1;\n        }\n        \tbreak;\n        case CROW_HEADTILT:\n        \tcol.x = noiseTilt(gTime*.01+8.)*.5;\n        \tcol.y = noiseTilt(gTime*.05+111.)-.5;\n        \tcol.z = noiseTilt(gTime*.03)*.8+.2;\n        \tcol.w = (noiseTilt(gTime*.04)-.5);\n        \tbreak;\n        case CROW_TURN:\n        \tcol = diff;\n        \tbreak;\n        case CROW_CLIMBING:\n        \t\/\/ IIR leaky integrator for smoothing wing power...\n        \tcol.x = oldClimb *.99+climb *.01;\n        \tbreak;\n        \n\n    }\n    fragColour = col;\n \n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4sfGRn","filepath":"\/media\/a\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"\/media\/ap\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"\/media\/a\/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"\/media\/ap\/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\/\/ Render the landscape and sky...\n\/\/ by David Hoskins.\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ These are indices into the variable data in Buf A...\n\nfloat gTime, specular;\n\n\n\n\/\/========================================================================\n\/\/ Utilities...\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ Grab value of variable, indexed 'num' from buffer A...\n\/\/ Useful because each pixel doesn't need to do a whole bunch of math\/code over and over again.\n\/\/ Like camera positions and animations...\nvec4 getStore(int num)\n{\n    \/\/ivec2 loc = ivec2(num & 63, num\/64); \/\/ Didn't need that many, doh!\n    ivec2 loc = ivec2(num, 0);\n\treturn  texelFetch(iChannel0, loc, 0);\n}\n\n\/\/----------------------------------------------------------------------------------------\nfloat  sphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n\/\/--------------------------------------------------------------------------\n\n\/\/--------------------------------------------------------------------------\nfloat noise( in vec3 p )\n{\n    vec3 f = fract(p);\n    p = floor(p);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel3, (uv+ 0.5)\/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n\/\/--------------------------------------------------------------------------\n\nfloat sMax(float a, float b, float s){\n    \n    float h = clamp( 0.5 + 0.5*(a-b)\/s, 0., 1.);\n    return mix(b, a, h) + h*(1.0-h)*s;\n}\n\n\n\/\/--------------------------------------------------------------------------\n\/\/ This uses mipmapping with the incoming ray distance.\n\/\/ I think it also helps with the texture cache, but I don't know that for sure...\nfloat map( in vec3 p, float di)\n{\n  \n    di = min(di, 6.0);\n\n    \/\/ Grab texture based on 3D coordinate mixing...\n \tfloat te = textureLod(iChannel1, p.xz*.0022 + p.xy * 0.0023-p.zy*.0011, di).x*40.0;\n    \/\/ Make a wibbly wobbly sin\/cos dot product..\n    float h = dot(sin(p*.0173),cos(p.zxy*.0191))*30.;\n    \/\/ Add them all together...\n    float d =  h+p.y*.2 + te;\n    \/\/...Then subtract the camera tunnel...\n    p.xy -= cameraPath(p.z).xy;\n    float tunnel = 15. - length(p.xy)-h; \n\n    d = sMax(d, tunnel, 80.);\n    \n    \/\/d = max(tunnel, d); \n\n    return d;\n}\n\n\/\/--------------------------------------------------------------------------\n\nvec3 getSky(vec3 dir, vec2 uv, vec3 pos)\n{\n    vec3 col;\n    vec3 clou = dir * 1. + pos*.025;\n\tfloat t = noise(clou);\n    t += noise(clou * 2.1) * .5;\n    t += noise(clou * 4.3) * .25;\n    t += noise(clou * 7.9) * .125;\n\tcol = mix(vec3(FOG_COLOUR), vec3(0.2, 0.2,.2),abs(dir.y))+ FOG_COLOUR *t*.4;\n \n    return col;\n}\n\n\n\/\/--------------------------------------------------------------------------\n\nvec3 getNormal(vec3 p, float e)\n{\n    return normalize( vec3( map(p+vec3(e,0.0,0.0), e) - map(p-vec3(e,0.0,0.0), e),\n                            map(p+vec3(0.0,e,0.0), e) - map(p-vec3(0.0,e,0.0), e),\n                            map(p+vec3(0.0,0.0,e), e) - map(p-vec3(0.0,0.0,e), e) ) );\n}\n\n\/\/--------------------------------------------------------------------------\n\nfloat BinarySubdivision(in vec3 rO, in vec3 rD, vec2 t)\n{\n    float halfwayT;\n  \n    for (int i = 0; i < 5; i++)\n    {\n\n        halfwayT = dot(t, vec2(.5));\n        float d = map(rO + halfwayT*rD, halfwayT*.008); \n        t = mix(vec2(t.x, halfwayT), vec2(halfwayT, t.y), step(0.02, d));\n    }\n\n\treturn halfwayT;\n}\n\n\/\/--------------------------------------------------------------------------\nfloat marchScene(in vec3 rO, in vec3 rD, vec2 co)\n{\n\tfloat t = 10.+10.*hash12(co), oldT = 0.;\n\tvec2 dist = vec2(1000);\n\tvec3 p;\n    bool hit = false;\n    \n    for( int j=0; j < 150; j++ )\n\t{\n\t\tif (t >= FAR) break;\n\t\tp = rO + t*rD;\n\n\t\tfloat h = map(p, t*0.008);\n \t\tif(h < 0.02)\n\t\t{\n            dist = vec2(oldT, t);\n            break;\n\t     }\n        oldT = t;\n        t += h * .4 + t*.004;\n\t}\n    if (t < FAR) \n    {\n       t = BinarySubdivision(rO, rD, dist);\n    }\n    return t;\n}\n\n\/\/--------------------------------------------------------------------------\nfloat noise2d(vec2 p)\n{\n    vec2 f = fract(p);\n    p = floor(p);\n    f = f*f*(3.0-2.0*f);\n    \n    float res = mix(mix( hash12(p),  \t\t    hash12(p + vec2(1,0)),f.x),\n                    mix( hash12(p + vec2(0,1)), hash12(p + vec2(1,1)),f.x),f.y);\n    return res;\n}\n\n\/\/--------------------------------------------------------------------------\nfloat findClouds2D(in vec2 p)\n{\n\tfloat a = 1.0, r = 0.0;\n    p*= .001;\n    for (int i = 0; i < 5; i++)\n    {\n        r+= noise2d(p*=2.563)*a;\n        a*=.5;\n    }\n\treturn max(r-1.1, 0.0);\n}\n\n\/\/--------------------------------------------------------------------------\n\/\/ Use the difference between two cloud densities to light clouds in the direction of the sun.\nvec4 getClouds(vec3 pos, vec3 dir)\n{\n    if (dir.y < 0.0) return vec4(0.0);\n    float d = (600. \/ dir.y);\n    vec2 p = pos.xz+dir.xz*d;\n    float r = findClouds2D(p);\n    float t = findClouds2D(p+normalize(sunLight.xz)*15.);    \n    t = sqrt(max((r-t)*30., .8));\n    vec3 col = vec3(t) * SUN_COLOUR;\n    \/\/ returns colour and alpha...\n    return vec4(col, r);\n}\n\n\/\/--------------------------------------------------------------------------\n\/\/ Turn a 2D texture into a six sided one...\nvec3 texCube(in sampler2D tex, in vec3 p, in vec3 n )\n{\n\tvec3 x = textureLod(tex, p.yz, 0.0).xyz;\n\tvec3 y = textureLod(tex, p.zx, 0.0).xyz;\n\tvec3 z = textureLod(tex, p.xy, 0.0).xyz;\n\treturn (x*abs(n.x) + y*abs(n.y) + z*abs(n.z))\/(1e-20+abs(n.x)+abs(n.y)+abs(n.z));\n}\n\n\/\/--------------------------------------------------------------------------\n\/\/ Grab the colour...\nvec3 albedo(vec3 pos, vec3 nor)\n{\n    specular  = .8;\n    vec3 alb  = texCube(iChannel2, pos*.03, nor);\n\n    \/\/ Brown the texture in places for warmth...\n    float v = noise(pos*.04+20.);\n    alb *= vec3(.85+v, .9+v*.5, .9);\n    \n    \/\/ Mossy rocky bits...\n    v = pow(max(noise(pos*.03)-.4, 0.0), .7);\n    alb = mix(alb, vec3(.45,.55,.45), v*v*4.);\n    \n\t\/\/ Do ice on flat areas..\n    float ice = smoothstep(0.4, .7,nor.y);\n\talb = mix(alb, vec3(.5, .8,1.), ice);\n    specular+=ice*.5;\n    \n    return alb*1.8;\n}\n\n\/\/--------------------------------------------------------------------------\nfloat mapCrowShad(vec3 p)\n{\n    float d = 0.;\n    p= p-crowPos;\n    d = sphere(p, 3.);\n    return smoothstep(.0, 8.0, d)+.8;\n}\n\n\/\/--------------------------------------------------------------------------\nfloat shadow(in vec3 ro, in vec3 rd)\n{\n\tfloat res = 1.0;\n    \n    float t = .1;\n    for( int i = 0; i < 14; i++ )\n    {\n\t\tfloat h = map(ro + rd*t, 4.);\n        float g = mapCrowShad(ro + rd*t);\n        h = min(g, h); \n        res = min( res, 4.*h\/t );\n        t += h+.35;\n    }\n    return clamp( res, 0., 1.0 );\n}\n\n\n\/\/--------------------------------------------------------------------------\nvec3 lighting(in vec3 mat, in vec3 pos, in vec3 normal, in vec3 eyeDir, in float d)\n{\n  \n\tfloat sh = shadow(pos+normal*.5,  sunLight);\n    \/\/sh*=curve(pos)+1.;\n    \/\/ Light surface with 'sun'...\n\tvec3 col = mat * SUN_COLOUR*(max(dot(sunLight,normal), 0.0))*sh;\n\n    \n    \/\/ Ambient...\n\tcol += mat  * abs(normal.y*.14);\n    \n    normal = reflect(eyeDir, normal); \/\/ Specular...\n    col += pow(max(dot(sunLight, normal), 0.0), 10.0)  * SUN_COLOUR * sh * specular;\n\n\treturn min(col, 1.0);\n}\n\n\n\/\/--------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (-iResolution.xy + 2.0 * fragCoord ) \/ iResolution.y;\n    specular = 0.0;\n  \tvec3 col;\n\n    sunLight \t= getStore(SUN_DIRECTION).xyz;\n    vec3 camPos = getStore(CAMERA_POS).xyz;\n    vec3 camTar = getStore(CAMERA_TAR).xyz;\n    crowPos  \t= getStore(CROW_POS).xyz;\n  \n    \/\/ Setup an epic fisheye lens for the ray 'dir'....\n    mat3 camMat = setCamMat(camPos, camTar, (camTar.x-camPos.x)*.02);\n    vec3 dir = camMat * normalize( vec3(uv, cos((length(uv*.5)))));\n\n    \/\/ The sky is a general mix of blue to fog colour with 3D 'cold' clouds, for mixing with the distance fogging effect...\n    vec3 sky = getSky(dir, uv, camPos);\n    \/\/March it...\n    float dhit = marchScene(camPos, dir, fragCoord);\n    \/\/ Render at distance value...\n    if (dhit < FAR)\n    {\n\t   \tvec3  p = camPos+dhit*dir;\n        float pixel = iResolution.y;\n       \tvec3 nor =  getNormal(p, dhit\/pixel);\n       \tvec3 mat = albedo(p, nor);\n\t\tvec3  temp = lighting(mat, p, nor, dir, dhit);\n\t\t\/\/ Distance fog...\n       \ttemp = mix(sky, temp , exp(-dhit*.0015)-.1);\n       \tcol = temp;\n    }else\n\t{\n \n        \/\/ Clouds and Sun...\n        col = sky;\n        vec4 cc = getClouds(camPos, dir);\n       \n        col = mix(col, cc.xyz, cc.w);\n\n        col+= pow(max(dot(sunLight, dir), 0.0), 200.0)*SUN_COLOUR;\n    }\n   \t\/\/col *= vec3(1.1,1.0,1.0);\n    \n\t\/\/col = mix( col, vec3(dot(col,vec3(0.333))), 0.4 );\n    \/\/col = col*0.5+0.5*col*col*(3.0-2.0*col);\n    \n\tfragColor = vec4(col, dhit);\n    \n}\n\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\/\/ Wind and Crow sound effects.\n\/\/ Usees a formant graph to approximate the CAW sound.\n\/\/ by David Hoskins.\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\/\/----------------------------------------------------------------------------------------\n\/\/  1 out, 1 in ...\nfloat shash11(float p)\n{\n\tvec2 p2 = fract(vec2(p) * vec2(.16632,.17369));\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y)-.5;\n}\n\/\/----------------------------------------------------------------------------------------\n\/\/  2 out, 1 in...\nvec2 shash21(float p)\n{\n\t\/\/p  = fract(p * MOD3);\n    vec3 p3 = fract(vec3(p) * vec3(.16532,.17369,.15787));\n    p3 += dot(p3.xyz, p3.yzx + 19.19);\n   return fract(vec2(p3.x * p3.y, p3.z*p3.x))-.5;\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/\/  2 out, 2 in...\nvec2 shash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.16532,.17369,.15787));\n    p3 += dot(p3.zxy, p3.yxz+19.19);\n    return fract(vec2(p3.x * p3.y, p3.z*p3.x))-.5;\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/  2 out, 1 in...\nvec2 Noise21(float x)\n{\n    float p = floor(x);\n    float f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    return  mix( shash21(p), shash21(p + 1.0), f)-.5;\n    \n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/  2 out, 1 in...\nfloat Noise11(float x)\n{\n    float p = floor(x);\n    float f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    return mix( shash11(p), shash11(p + 1.0), f);\n\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/  2 out, 2 in...\nvec2 Noise22(vec2 x)\n{\n    const vec2 add = vec2(1.0, 0.0);\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    vec2 res = mix(mix( shash22(p),          shash22(p + add.xy),f.x),\n                   mix( shash22(p + add.yx), shash22(p + add.xx),f.x),f.y);\n    return res;\n}\n#define F(p1, p2, p3, p4, p5) {d+=0.00625; f123 = ivec4(p2, p3, p4, p5);}\n#define TAU  6.28318530718\n#define PI TAU*.5;\n\/\/----------------------------------------------------------------------------------\nfloat Tract(float x, float f, float bandwidth)\n{\n    float ret = sin(TAU * f * x) * exp(-bandwidth * 3.14159265359 * x)*(Noise11(f));\n    return ret;\n}\nfloat crow(float time)\n{\n   \tfloat\tx = 0.0;\n    time -= 1.0;\n \n    float t = mod(time, 12.);\n    float p = Noise11(floor(time\/12.0)*33.0)*.002+.008;\n    float v = smoothstep(0.,.01, t)*smoothstep(0.5,.49, t);\n    x = mod(t, p + t * t * smoothstep(0.2, .5, t)*.002+t*smoothstep(0.2, .0, t)*.004);\n    vec4 formants = vec4(1500.0, 1900., 2408., 3268.);\n    \n\tfloat glot = \tTract(x, formants.x, 200.0)  +\n       \t\tTract(x, formants.y, 100.0)  * .8 +\n       \t\tTract(x, formants.z, 90.0) * .6 +\n   \t\t\tTract(x, formants.w, 90.0) * .5;\n     glot *= sin(time*3.3)*.5+1.0;\n\t\n\treturn glot*v*3.;\n}\n\/\/----------------------------------------------------------------------------------------\n\/\/ Fractal Brownian Motion...\nvec2 FBM22(vec2 x)\n{\n    vec2 r = vec2(0.0);\n    \n    float a = .7;\n    \n    for (int i = 0; i < 8; i++)\n    {\n        r += Noise22(x) * a;\n        a *= .5;\n        x *= 2.0;\n        x += 10.;\n    }\n     \n    return r;\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec2 mainSound( in int samp,float time)\n{\n\tvec2 audio = vec2(.0);\n    vec2 n1 = FBM22( vec2(time*520., time*530.) * (Noise21(time*.2+9.)*.2+1.)) * (Noise21(time*.5)+1.);\n\tvec2 n2 = FBM22( vec2(time*1800., time*900.) * (Noise21(time*.1)*.2+1.))  * (Noise21(time*.2)+1.);\n\n    audio += (n1+n2)\/2.0;\n    \n    audio+= (crow(time)+crow(time+.02)+crow(time+.04))*.2;  \/\/ ...Not very good, but it has a little style of its own...\n    audio.x+= crow(time-.25)*.15;\n    audio.y+= crow(time-.5)*.1;\n\n \/\/   float foot = tri(time*3.);\n\/\/    audio += Noise11(time*10.0)*Noise11(time*500.0)*Noise11(time*3000.0)* smoothstep(0.6,1.,abs(foot)) * 6.;\n    \n    return clamp(audio, -1.0, 1.0) * smoothstep(0.0, .6, time) * smoothstep(180.0, 170.0, time);\n    \n}","name":"Sound","description":"","type":"sound"},{"inputs":[],"outputs":[],"code":"#define CAMERA_POS\t\t0\n#define CAMERA_TAR\t\t1\n#define SUN_DIRECTION \t2\n#define CROW_POS\t\t3\n#define CROW_HEADING\t4\n#define CROW_FLAPPING\t5\n#define CROW_HEADTILT\t6\n#define CROW_TURN\t\t7\n#define CROW_CLIMBING\t8\n\n#define FAR 850.\n\n#define TAU 6.28318530718\n#define SUN_COLOUR vec3(1.1, .95, .85)\n#define FOG_COLOUR vec3(.48, .49, .53)\n\nvec3 sunLight, crowPos;\n\n\/\/----------------------------------------------------------------------------------------\n\nvec3 cameraPath( float z )\n{\n\treturn vec3(100.2*sin(z * .0045)+90.*cos(z *.012), 43.*(cos(z * .0047)+sin(z*.0013)) + 53.*(sin(z*0.0112)), z);\n}\n\/\/ Set up a camera matrix\n\n\/\/--------------------------------------------------------------------------\nmat3 setCamMat( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"MscXzn","date":"1457308502","viewed":25510,"name":"IcePrimitives","username":"Bers","description":"Practice at playing with ray-marched refraction through arbitrary geometry.","likes":218,"published":3,"flags":32,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"\/media\/a\/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"\/media\/ap\/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rn","filepath":"\/media\/a\/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"\/media\/ap\/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Author : S\u00c3\u00a9bastien B\u00c3\u00a9rub\u00c3\u00a9\n\/\/ Created : Dec 2014\n\/\/ Modified : Feb 2016\n\/\/\n\/\/ Ice raymarching experiment, built on top of primitives shader from Inigo Quilez : \n\/\/ https:\/\/www.shadertoy.com\/view\/Xds3zN\n\/\/\n\/\/ You can play with the sliders : 1-Normal map scale\n\/\/                                 2-Isosurface thickness\n\/\/                                 3-Color \/ refraction normal \/ other debug stuff\n\/\/                                 4-Refraction index\n\/\/\n\/\/ Notes:\n\/\/ \n\/\/ - distance function map() works as usual, as all boolean operations and signed distance functions do.\n\/\/ - sphereTracing() function was modified for volume raymarching (sign added, simple as that).\n\/\/ - triplanar noise projection used for surface normal noise.\n\/\/ - smooth subtraction was implemented to smooth out boolean shape.\n\/\/ - \"in scattering\" is simply approximated with positive inner ice colors (the default color)\n\/\/ - extinction coefficient is also roughly approximated both by negative inner ice color\n\/\/   and with traversal distance (WIP, I'll return to improve this once I better\n\/\/   understand scattering equations).\n\/\/ - RAYMARCH_DFSS is slightly different from inigo's softshadow.\n\/\/   A \"light cone width\" value [0-1] is passed to the function in order to control softness.\n\/\/   I don't know how well it would perform in other scenarios, but it seems to do the trick\n\/\/   with limited samples in this case. I guess the principle is the same.\n\/\/\n\/\/ License : Creative Commons Non-commercial (NC) license\n\/\/\n\n\/\/----------------------\n\/\/ Constants \nconst float GEO_MAX_DIST  = 1000.0;\nconst int MATERIALID_NONE      = 0;\nconst int MATERIALID_FLOOR     = 1;\nconst int MATERIALID_ICE_OUTER = 2;\nconst int MATERIALID_ICE_INNER = 3;\nconst int MATERIALID_SKY       = 4;\n\n\/\/----------------------\n\/\/ Slider bound globals.\nfloat ROUGHNESS      = 0.25; \/\/sliderVal[0]\nfloat ISOVALUE       = 0.03; \/\/sliderVal[1]\nfloat ICE_COLOR      = 0.00; \/\/sliderVal[2]\nfloat REFRACTION_IDX = 1.31; \/\/sliderVal[3]\n\nstruct TraceData\n{\n    float rayLen;\n    vec3  rayDir;\n    vec3  normal;\n    int   matID;\n    vec3  matUVW;\n    float alpha;\n};\n\n#define saturate(x) clamp(x,0.0,1.0)\nvec3 normalMap(vec3 p, vec3 n);\nTraceData TRACE_geometry(vec3 o, vec3 d);\nTraceData TRACE_reflexion(vec3 o, vec3 d);\nTraceData TRACE_translucentDensity(vec3 o, vec3 d);\nTraceData TRACE_cheap(vec3 o, vec3 d);\n\nfloat RAYMARCH_DFSS(vec3 ro, vec3 rd, float coneWidth);\n\nvec4 MAT_apply(vec3 pos, TraceData traceData)\n{\n    vec3 L = normalize(vec3(-0.6,0.7,-0.5));\n    vec4 col = vec4(traceData.alpha);\n    \n    if(traceData.matID==MATERIALID_NONE)\n    {\n        return vec4(0,0,0,1);\n    }\n    else if(traceData.matID==MATERIALID_ICE_INNER)\n    {\n        \/\/NOTE : Coloring is not physically accurate.\n        \/\/       For this to be more accurate, \n        \/\/       it should probably be computed like fog.\n        \/\/       (in scattering, out scattering \/ extinction coefficient?).\n        vec3 cRed   = vec3( 0.70,-0.5,-0.60);\n        vec3 cGreen = vec3(-0.50, 0.0,-0.5);\n        vec3 cBlue  = vec3(-0.50,-0.5, 0.30);\n        vec3 cGrey = vec3(-0.3); \/\/Glass (~extinction coefficient, more or less)\n        vec3 cWhite = vec3(1.0); \/\/Ice (pseudo \"in scattering\")\n        \n        col.rgb = mix(cWhite ,cGrey, smoothstep(0.00,0.20,ICE_COLOR));\n\t\tcol.rgb = mix(col.rgb,cBlue, smoothstep(0.20,0.40,ICE_COLOR));\n        col.rgb = mix(col.rgb,cGreen,smoothstep(0.40,0.60,ICE_COLOR));\n\t\tcol.rgb = mix(col.rgb,cRed , smoothstep(0.60,0.80,ICE_COLOR));    \n    }\n    else if(traceData.matID==MATERIALID_SKY)\n    {\n        col.rgb = vec3(0.6,0.7,0.85);\n    }\n    else if(traceData.matID==MATERIALID_FLOOR)\n    {\n        vec3 cDiff = pow(texture(iChannel1,traceData.matUVW.xz).rgb,vec3(1.2));\n        float dfss = RAYMARCH_DFSS(pos, L, 0.07);\n    \tcol.rgb = cDiff*(0.45+1.2*(dfss));\n    }\n    return col;\n}\n\nstruct IceTracingData\n{\n    TraceData reflectTraceData;\n\tTraceData translucentTraceData;\n    TraceData exitTraceData;\n};\n    \nIceTracingData renderIce(TraceData iceSurface, vec3 ptIce, vec3 dir)\n{\n    IceTracingData iceData;\n    \n    vec3 normalDelta = normalMap(ptIce*ROUGHNESS,iceSurface.normal)*ROUGHNESS\/10.;\n    \n    vec3 iceSurfaceNormal = normalize(iceSurface.normal+normalDelta); \n    vec3 refract_dir = refract(dir,iceSurfaceNormal,1.0\/REFRACTION_IDX); \/\/Ice refraction index = 1.31\n    vec3 reflect_dir = reflect(dir,iceSurfaceNormal);\n\n    \/\/Trace reflection\n    iceData.reflectTraceData = TRACE_reflexion(ptIce,reflect_dir);\n    \n    \/\/Balance between refraction and reflection (not entirely physically accurate, Fresnel could be used here).\n    float fReflectAlpha = 0.5*(1.0-abs(dot(normalize(dir),iceSurfaceNormal)));\n    iceData.reflectTraceData.alpha = fReflectAlpha;\n    vec3 ptReflect = ptIce+iceData.reflectTraceData.rayLen*reflect_dir;\n\n    \/\/Trace refraction\n    iceData.translucentTraceData = TRACE_translucentDensity(ptIce,refract_dir);\n    \n    vec3 ptRefract = ptIce+iceData.translucentTraceData.rayLen*refract_dir;\n    vec3 exitRefract_dir = refract(refract_dir,-iceData.translucentTraceData.normal,REFRACTION_IDX);\n\n    \/\/This value fades around total internal refraction angle threshold.\n    if(length(exitRefract_dir)<=0.95)\n    {\n        \/\/Total internal reflection (either refraction or reflexion, to keep things cheap).\n        exitRefract_dir = reflect(refract_dir,-iceData.translucentTraceData.normal);\n    }\n    \n    \/\/Trace environment upon exit.\n    iceData.exitTraceData = TRACE_cheap(ptRefract,exitRefract_dir);\n    iceData.exitTraceData.matID = MATERIALID_FLOOR;\n    \n    return iceData;\n}\n\nvec3 main_render( vec3 o, vec3 dir, vec2 uv)\n{ \n    vec3 pt = o;\n    \n    vec3 ptGeometry = vec3(0);\n    vec3 ptReflect = vec3(0);\n    \n    TraceData geometryTraceData = TRACE_geometry(pt, dir);\n    ptGeometry = o+geometryTraceData.rayLen*dir;\n    \n    IceTracingData iceData;\n    iceData.translucentTraceData.rayLen = 0.0;\n    if(geometryTraceData.matID == MATERIALID_ICE_OUTER && geometryTraceData.rayLen < GEO_MAX_DIST)\n    {\n        vec3 ptIce = ptGeometry;\n        iceData = renderIce(geometryTraceData, ptIce, dir);\n        geometryTraceData = iceData.exitTraceData;\n        \n        vec3 ptRefract = ptIce+iceData.translucentTraceData.rayLen*iceData.translucentTraceData.rayDir;\n        ptReflect = ptIce+iceData.reflectTraceData.rayLen*iceData.reflectTraceData.rayDir;\n        ptGeometry = ptRefract+geometryTraceData.rayLen*dir;\n        \n        \/\/<Debug section, not mandatory>\n        \/\/[0.80-1.00] = Debug color range.\n        if(ICE_COLOR>0.95) return iceData.exitTraceData.rayDir;\n        if(ICE_COLOR>0.90) return max(iceData.exitTraceData.matUVW,vec3(0));\n        if(ICE_COLOR>0.85) return iceData.translucentTraceData.rayLen*vec3(1);\n        if(ICE_COLOR>0.80) return iceData.reflectTraceData.alpha*vec3(1);\n        \/\/<\/Debug section, not mandatory>\n    }\n    \n    \/\/cTerrain is either direct ray or refract ray.\n    vec4 cTerrain  = MAT_apply(ptGeometry,geometryTraceData);\n    vec4 cIceInner = MAT_apply(ptGeometry,iceData.translucentTraceData);\n    vec4 cReflect  = MAT_apply(ptReflect,iceData.reflectTraceData);\n    \n    if(iceData.translucentTraceData.rayLen > 0.0 )\n    {\n        float fTrav = iceData.translucentTraceData.rayLen;\n        vec3 cRefract = cTerrain.rgb;\n        cRefract.rgb = mix(cRefract,cIceInner.rgb,0.3*fTrav+0.2*sqrt(fTrav*3.0));\n        cRefract.rgb += fTrav*0.3;\n        vec3 cIce = mix(cRefract,cReflect.rgb,iceData.reflectTraceData.alpha);\n        return cIce;\n\t}\n    return cTerrain.rgb;\n}\n\n\n\n\nstruct DF_out\n{\n    float d;  \/\/Distance to geometry\n    int matID;\/\/Geometry material ID\n};\n    \n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0\/8.0 );\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length8(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\n\n\/\/----------------------------------------------------------------------\n\nfloat opSmoothSubtract( float d1, float d2 )\n{\n    return length(vec2(max(d1,0.),min(d2,0.0)));\n}\n\nfloat opU( float d1, float d2 )\n{\n\treturn (d1<d2) ? d1 : d2;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\nDF_out map( in vec3 pos )\n{\n    float dist = opU( sdPlane(     pos-vec3( -1.4) ),\n\t                sdSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ) );\n    dist = opU( dist, udRoundBox(  pos-vec3( 1.0,0.25, 1.0), vec3(0.15), 0.1 ) );\n\tdist = opU( dist, sdTorus(     pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ) );\n\tdist = opU( dist, sdTriPrism(  pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ) );\n\tdist = opU( dist, sdCylinder(  pos-vec3( 1.0,0.30,-1.0), vec2(0.10,0.20) ) );\n\tdist = opU( dist, sdTorus88(   pos-vec3(-1.0,0.25, 1.0), vec2(0.20,0.05) ) );\n    dist = opU( dist, opSmoothSubtract(\n\t                      udRoundBox(  pos-vec3(-1.0,0.2, 0.0), vec3(0.15),0.05),\n\t                      sdSphere(    pos-vec3(-1.0,0.2, 0.0), 0.25)) );\n    dist = opU( dist, sdBox(       pos-vec3( 0.0,0.20,-1.0), vec3(0.25)) );\n\tdist = opU( dist, 0.5*sdTorus( opTwist(pos-vec3( 1.0,0.25, 0.0)),vec2(0.15,0.02)) );\n\n    DF_out outData;\n    outData.d = dist-ISOVALUE;\n    outData.matID = MATERIALID_ICE_OUTER;\n    return outData;\n}\n\nvec3 gradient( in vec3 p )\n{\n\tconst float d = 0.001;\n\tvec3 grad = vec3(map(p+vec3(d,0,0)).d-map(p-vec3(d,0,0)).d,\n                     map(p+vec3(0,d,0)).d-map(p-vec3(0,d,0)).d,\n                     map(p+vec3(0,0,d)).d-map(p-vec3(0,0,d)).d);\n\treturn grad;\n}\n\nvec2 sphereTracing( const vec3 o, const vec3 d, const float tmin, const float eps, const bool bInternal)\n{\n    \/\/https:\/\/iquilezles.org\/articles\/raymarchingdf\n    \/\/http:\/\/mathinfo.univ-reims.fr\/IMG\/pdf\/hart94sphere.pdf p.5-89\n    \/\/[modified for internal marching]\n    float tmax = 10.0;\n    float t = tmin;\n    float dist = GEO_MAX_DIST;\n    for( int i=0; i<50; i++ )\n    {\n        vec3 p = o+d*t;\n\t    dist = (bInternal?-1.:1.)*map(p).d;\n        if( abs(dist)<eps || t>tmax )\n            break;\n        t += dist;\n    }\n    \n    dist = (dist<tmax)?dist:GEO_MAX_DIST;\n    return vec2( t, dist );\n}\n\nTraceData TRACE_getFront(const in TraceData tDataA, const in TraceData tDataB)\n{\n    if(tDataA.rayLen<tDataB.rayLen)\n    {\n        return tDataA;\n    }\n    else\n    {\n        return tDataB;\n    }\n}\n\nfloat RAYCAST_floor(vec3 o, vec3 d)\n{\n    vec3 n = vec3(0,1,0);\n    vec3 p = vec3(-0.1);\n    float t = dot(p-o,n)\/dot(d,n);\n    return (t<0.0)?GEO_MAX_DIST:t;\n}\n\n\/\/o=origin, d = direction\nTraceData TRACE_cheap(vec3 o, vec3 d)\n{\n    TraceData floorData;\n\tfloorData.rayLen  = RAYCAST_floor(o, d);\n\tfloorData.rayDir  = d;\n\tfloorData.normal  = vec3(0,1,0);\n\tfloorData.matUVW  = o+d*floorData.rayLen;\n\tfloorData.matID   = MATERIALID_FLOOR;\n    floorData.alpha   = 1.0;\n    \n    TraceData skyData;\n    skyData.rayLen  = 50.0;\n    skyData.rayDir  = d;\n\tskyData.normal  = -d;\n\tskyData.matUVW  = d;\n\tskyData.matID   = MATERIALID_SKY;\n    skyData.alpha   = 1.0;\n    return TRACE_getFront(floorData,skyData);\n}\n\nTraceData TRACE_reflexion(vec3 o, vec3 d)\n{\n    return TRACE_cheap(o,d);\n}\n\n\/\/o=origin, d = direction\nTraceData TRACE_geometry(vec3 o, vec3 d)\n{\n    TraceData cheapTrace = TRACE_cheap(o,d);\n    \n    TraceData iceTrace;\n    vec2 rayLen_geoDist = sphereTracing(o,d,0.1,0.0001,false);\n    vec3 iceHitPosition = o+rayLen_geoDist.x*d;\n    iceTrace.rayDir     = d;\n    iceTrace.rayLen     = rayLen_geoDist.x;\n    iceTrace.normal     = normalize(gradient(iceHitPosition));\n    iceTrace.matUVW     = iceHitPosition;\n    iceTrace.matID      = MATERIALID_ICE_OUTER;\n    iceTrace.alpha      = 0.0;\n    \n    return TRACE_getFront(cheapTrace,iceTrace);\n}\n\n\/\/o=origin, d = direction\nTraceData TRACE_translucentDensity(vec3 o, vec3 d)\n{\n    TraceData innerIceTrace;\n    \n    vec2 rayLen_geoDist   = sphereTracing(o,d,0.01,0.001,true).xy;\n    vec3 iceExitPosition  = o+rayLen_geoDist.x*d;\n    innerIceTrace.rayDir  = d;\n    innerIceTrace.rayLen  = rayLen_geoDist.x;\n    innerIceTrace.normal  = normalize(gradient(iceExitPosition));\n    innerIceTrace.matUVW  = iceExitPosition;\n    innerIceTrace.matID   = MATERIALID_ICE_INNER;\n    innerIceTrace.alpha   = rayLen_geoDist.x;\n    return innerIceTrace;\n}\n\n#define saturate(x) clamp(x,0.0,1.0)\n\/\/o=origin, L = light direction\nfloat RAYMARCH_DFSS( vec3 o, vec3 L, float coneWidth )\n{\n    \/\/Variation of the Distance Field Soft Shadow from : https:\/\/www.shadertoy.com\/view\/Xds3zN\n    \/\/Initialize the minimum aperture (angle tan) allowable with this distance-field technique\n    \/\/(45deg: sin\/cos = 1:1)\n    float minAperture = 1.0; \n    float t = 0.0;\n    float dist = GEO_MAX_DIST;\n    for( int i=0; i<6; i++ )\n    {\n        vec3 p = o+L*t; \/\/Sample position = ray origin + ray direction * travel distance\n        float dist = map( p ).d;\n        float curAperture = dist\/t; \/\/Aperture ~= cone angle tangent (sin=dist\/cos=travelDist)\n        minAperture = min(minAperture,curAperture);\n        t += 0.03+dist; \/\/0.03 : min step size.\n    }\n    \n    \/\/The cone width controls shadow transition. The narrower, the sharper the shadow.\n    return saturate(minAperture\/coneWidth); \/\/Should never exceed [0-1]. 0 = shadow, 1 = fully lit.\n}\n\nvec3 smoothSampling(vec2 uv)\n{\n    const float T_RES = 64.0;\n    vec2 x = fract(uv*T_RES+0.5);\n    vec2 pc1 = uv-(x)\/T_RES;\n    \/\/vec2 t = x * x * (3.0 - 2.0 * x);\n    vec2 t = (6.*x*x-15.0*x+10.)*x*x*x; \/\/ease function\n    return textureLod(iChannel0,pc1+t\/T_RES,0.0).xyz;\n}\n\nfloat triplanarSampling(vec3 p, vec3 n)\n{\n\tfloat fTotal = abs(n.x)+abs(n.y)+abs(n.z);\n\treturn  (abs(n.x)*smoothSampling(p.yz).x\n            +abs(n.y)*smoothSampling(p.xz).x\n            +abs(n.z)*smoothSampling(p.xy).x)\/fTotal;\n}\n\nconst mat2 m2 = mat2(0.90,0.44,-0.44,0.90);\nfloat triplanarNoise(vec3 p, vec3 n)\n{\n    const float BUMP_MAP_UV_SCALE = 0.2;\n    float fTotal = abs(n.x)+abs(n.y)+abs(n.z);\n    float f1 = triplanarSampling(p*BUMP_MAP_UV_SCALE,n);\n    p.xy = m2*p.xy;\n    p.xz = m2*p.xz;\n    p *= 2.1;\n    float f2 = triplanarSampling(p*BUMP_MAP_UV_SCALE,n);\n    p.yx = m2*p.yx;\n    p.yz = m2*p.yz;\n    p *= 2.3;\n    float f3 = triplanarSampling(p*BUMP_MAP_UV_SCALE,n);\n    return f1+0.5*f2+0.25*f3;\n}\n\nvec3 normalMap(vec3 p, vec3 n)\n{\n    float d = 0.005;\n    float po = triplanarNoise(p,n);\n\tfloat px = triplanarNoise(p+vec3(d,0,0),n);\n    float py = triplanarNoise(p+vec3(0,d,0),n);\n\tfloat pz = triplanarNoise(p+vec3(0,0,d),n);\n    return normalize(vec3((px-po)\/d,\n                          (py-po)\/d,\n                          (pz-po)\/d));\n}\n\nstruct Cam\n{\n    vec3 R;\/\/Right, \n    vec3 U;\/\/Up,\n    vec3 D;\/\/Direction,\n    vec3 o;\/\/origin (pos)\n};\nCam CAM_animate(vec2 uv)\n{\n    float PI = 3.14159;\n\tfloat rotX = 2.0*PI*(iMouse.x\/iResolution.x+iTime*0.05);\n    Cam cam;\n    cam.o = vec3(cos(rotX),0.475,sin(rotX))*2.3;\n    cam.D = normalize(vec3(0,-0.25,0)-cam.o);\n    cam.R = normalize(cross(cam.D,vec3(0,1,0)));\n    cam.U = cross(cam.R,cam.D);\n    return cam;\n}\nvec3 CAM_getRay(Cam cam,vec2 uv)\n{\n    uv *= 2.0*iResolution.x\/iResolution.y;;\n    return normalize(uv.x*cam.R+uv.y*cam.U+cam.D*2.5);\n}\n\nvec4 processSliders(in vec2 fragCoord)\n{\n    vec4 sliderVal = texture(iChannel2,vec2(0,0));\n\tROUGHNESS       = sliderVal[0]*4.0;\n\tISOVALUE        = 0.005+sliderVal[1]*0.1;\n\tICE_COLOR       = sliderVal[2];\n\tREFRACTION_IDX  = 1.0+sliderVal[3];\n    \n    if(length(fragCoord.xy-vec2(0,0))>1.)\n    {\n    \treturn texture(iChannel2,fragCoord.xy\/iResolution.xy);\n    }\n    return vec4(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 cSlider = processSliders(fragCoord);\n\tvec2 uv = (fragCoord.xy-0.5*iResolution.xy) \/ iResolution.xx;\n    \n    Cam cam = CAM_animate(uv);\n    vec3 d = CAM_getRay(cam,uv);\n    vec3 c = main_render(cam.o, d, uv);\n    \n    \/\/Vignetting\n    float lensRadius = 0.65;\n    uv \/= lensRadius;\n    float sin2 = uv.x*uv.x+uv.y*uv.y;\n    float cos2 = 1.0-min(sin2*sin2,1.0);\n    float cos4 = cos2*cos2;\n    c *= cos4;\n    \n    \/\/Gamma\n    c = pow(c,vec3(0.4545)); \/\/2.2 Gamma compensation\n    \n    \/\/Apply slider overlay\n    c = mix(c,cSlider.rgb,cSlider.a);\n    \n    fragColor = vec4(c,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/Buffer A : slider management (this is not required)\n\n#define saturate(x) clamp(x,0.0,1.0)\nvec4 sliderVal = vec4(0.25,0.22,0,0.31); \/\/Default slider values [0-1]\n\nvoid SLIDER_setValue(float idx, float val)\n{\n    if(idx<0.) return;\n    else if(idx<0.25) sliderVal[0] = saturate(val);\n\telse if(idx<0.50) sliderVal[1] = saturate(val);\n\telse if(idx<0.75) sliderVal[2] = saturate(val);\n\telse if(idx<1.00) sliderVal[3] = saturate(val);\n}\n\nfloat SLIDER_getValue(float idx)\n{\n    if     (idx<0.25) return sliderVal[0];\n    else if(idx<0.50) return sliderVal[1];\n    else if(idx<0.75) return sliderVal[2];\n    else if(idx<1.00) return sliderVal[3];\n\telse return 0.;\n}\n\nvoid SLIDER_init(vec2 mousePos, vec2 cMin, vec2 cMax )\n{\n    vec4 cPingPong = textureLod(iChannel0,vec2(0),0.0);\n    if(length(cPingPong)>0.001)\n        sliderVal = cPingPong;\n        \n    float width = cMax.x-cMin.x;\n    float height = cMax.y-cMin.y;\n    if(mousePos.x>cMin.x && mousePos.x<cMax.x &&\n       mousePos.y>cMin.y && mousePos.y<cMax.y )\n    {\n        float t = (mousePos.y-cMin.y)\/height;\n        t = clamp(t\/0.75-0.125,0.,1.); \/\/25% top\/bottom margins\n\t\tSLIDER_setValue((mousePos.x-cMin.x)\/width, t);\n    }\n}\n\n\/\/Returns the distance from point \"p\" to a given line segment defined by 2 points [a,b]\nfloat UTIL_distanceToLineSeg(vec2 p, vec2 a, vec2 b)\n{\n    \/\/       p\n    \/\/      \/\n    \/\/     \/\n    \/\/    a--e-------b\n    vec2 ap = p-a;\n    vec2 ab = b-a;\n    \/\/Scalar projection of ap in the ab direction = dot(ap,ab)\/|ab| : Amount of ap aligned towards ab\n    \/\/Divided by |ab| again, it becomes normalized along ab length : dot(ap,ab)\/(|ab||ab|) = dot(ap,ab)\/dot(ab,ab)\n    \/\/The clamp provides the line seg limits. e is therefore the \"capped orthogogal projection\", and length(p-e) is dist.\n    vec2 e = a+clamp(dot(ap,ab)\/dot(ab,ab),0.0,1.0)*ab;\n    return length(p-e);\n}\n\n\/\/uv = slider pixel in local space [0-1], t = slider value [0-1], ar = aspect ratio (w\/h)\nvec4 SLIDER_drawSingle(vec2 uv, float t, vec2 ar, bool bHighlighted)\n{\n    const vec3  ITEM_COLOR = vec3(1);\n    const vec3  HIGHLIGHT_COLOR = vec3(0.2,0.7,0.8);\n    const float RAD = 0.05;  \/\/Cursor radius, in local space\n    const float LW  = 0.030; \/\/Line width\n    float aa  = 14.\/iResolution.x; \/\/antialiasing width (smooth transition)\n    vec3 selectionColor = bHighlighted?HIGHLIGHT_COLOR:ITEM_COLOR;\n    vec3 cheapGloss   = 0.8*selectionColor+0.2*smoothstep(-aa,aa,uv.y-t-0.01+0.01*sin(uv.x*12.));\n    vec2 bottomCenter = vec2(0.5,0.0);\n\tvec2 topCenter    = vec2(0.5,1.0);\n    vec2 cursorPos    = vec2(0.5,t);\n    float distBar = UTIL_distanceToLineSeg(uv*ar, bottomCenter*ar, topCenter*ar);\n    float distCur = length((uv-cursorPos)*ar)-RAD;\n    float alphaBar = 1.0-smoothstep(2.0*LW-aa,2.0*LW+aa, distBar);\n    float alphaCur = 1.0-smoothstep(2.0*LW-aa,2.0*LW+aa, distCur);\n    vec4  colorBar = vec4(mix(   vec3(1),vec3(0),smoothstep(LW-aa,LW+aa, distBar)),alphaBar);\n    vec4  colorCur = vec4(mix(cheapGloss,vec3(0),smoothstep(LW-aa,LW+aa, distCur)),alphaCur);\n    return mix(colorBar,colorCur,colorCur.a);\n}\n\n#define withinUnitRect(a) (a.x>=0. && a.x<=1. && a.y>=0. && a.y<=1.0)\nvec4 SLIDER_drawAll(vec2 uv, vec2 cMin, vec2 cMax, vec2 muv)\n{\n    float width = cMax.x-cMin.x;\n    float height = cMax.y-cMin.y;\n    vec2 ar = vec2(0.30,1.0);\n    uv  = (uv -cMin)\/vec2(width,height); \/\/pixel Normalization\n    muv = (muv-cMin)\/vec2(width,height); \/\/mouse Normalization\n    if( withinUnitRect(uv) )\n    {\n        float t = SLIDER_getValue(uv.x);\n\t\tbool bHighlight = withinUnitRect(muv) && abs(floor(uv.x*4.0)-floor(muv.x*4.0))<0.01;\n\t\tuv.x = fract(uv.x*4.0); \/\/repeat 4x\n\t\tuv.y = uv.y\/0.75-0.125; \/\/25% margins\n        return SLIDER_drawSingle(uv,t,ar,bHighlight);\n    }\n    return vec4(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 cMinSliders = vec2(0.9,0.80);\n    vec2 cMaxSliders = vec2(1.0,1.00);\n    vec2 uvSliders = fragCoord.xy \/ iResolution.xy;\n    vec2 mousePos = iMouse.xy \/ iResolution.xy;\n    SLIDER_init(mousePos, cMinSliders, cMaxSliders);\n    vec4 cSlider = SLIDER_drawAll(uvSliders,cMinSliders, cMaxSliders, mousePos);\n    \n    if(length(fragCoord.xy-vec2(0,0))<1.) \n        fragColor = sliderVal;\n\telse fragColor = cSlider;\n}","name":"Buf A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"4slyRs","date":"1490564246","viewed":7708,"name":"Alien corridor","username":"zguerrero","description":"Playing with raymarching and distance field functions, a lot of things taken form iq's web site http:\/\/iquilezles.org\/articles\/distfunctions\/distfunctions.htm, and various shaders on Shadertoy. I love the smin !","likes":204,"published":1,"flags":32,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"\/media\/previz\/buffer03.png","previewfilepath":"\/media\/previz\/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/bloom & vignet effect\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec2 uv =  fragCoord.xy\/iResolution.xy;\n   \n    vec4 tex = texture(iChannel1, uv);\n    vec4 texBlurred = texture(iChannel0, uv);\n    float vignet = length(uv - vec2(0.5))*1.5;\n        \n\tfragColor = mix(tex, texBlurred*texBlurred, vignet) + texBlurred*texBlurred*0.5;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3Rr","filepath":"\/media\/a\/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"\/media\/ap\/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float EPSILON = 0.002;\nvec2 twist = vec2(2.0,7.0);\nfloat planesDistance = 0.3;\nvec4 bumpMapParams1 = vec4(2.0,7.0,0.01,-0.01);\nvec4 bumpMapParams2 = vec4(2.0,3.0,-0.01,0.01);\nvec4 heightMapParams = vec4(3.0,1.0,0.0,0.01);\nvec4 heightInfluence = vec4(-0.025,-0.05,0.8,1.8);\nfloat fogDensity = 0.2;\nfloat fogDistance = 0.1;\nvec3 groundColor1 = vec3(0.2,0.3,0.3);\nvec3 groundColor2 = vec3(0.4,0.8,0.4);\nvec3 columnColors = vec3(0.9,0.3,0.3);\nvec4 ambient = vec4(0.2,0.3,0.4,0.0);\nvec3 lightColor = vec3(0.4,0.7,0.7);\nvec4 fogColor = vec4(0.0,0.1,0.5,1.0);\nvec3 rimColor = vec3(1.0,0.75,0.75);\n\nfloat pi = 3.14159265359;\n\nmat2 rot(float a) \n{\n    vec2 s = sin(vec2(a, a + pi\/2.0));\n    return mat2(s.y,s.x,-s.x,s.y);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)\/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sphere(vec3 pos, float radius, vec3 scale)\n{\n    return length(pos*scale)-radius;\n}\n\nfloat heightmap(vec2 uv)\n{\n    return heightMapParams.x*texture(iChannel0, (uv + iTime*heightMapParams.zw)*heightMapParams.y).x;\n}\n\nfloat bumpmap(vec2 uv)\n{\n    float b1 = bumpMapParams1.x*(1.0 - texture(iChannel0, (uv + iTime*bumpMapParams1.zw)*bumpMapParams1.y).x);\n    float b2 = bumpMapParams2.x*(1.0-texture(iChannel0, (uv + iTime*bumpMapParams2.zw)*bumpMapParams2.x).x);\n    return b1+b2;\n}\n\nfloat distfunc(vec3 pos)\n{\n    vec3 p2 = pos;\n    p2.x += sin(p2.z*3.0 + p2.y*5.0)*0.15;\n    p2.xy *= rot(floor(p2.z*2.0)*twist.y);\n    pos.xy *= rot(pos.z*twist.x);\n    \n    float h = heightmap(pos.xz)*heightInfluence.x;\n    \n    vec3 columnsrep = vec3(0.75,1.0,0.5);\n    vec3 reppos = (mod(p2 + vec3(iTime*0.01 + sin(pos.z*0.5),0.0,0.0),columnsrep)-0.5*columnsrep);\n    \n    float columnsScaleX = 1.0 + sin(p2.y*20.0*sin(p2.z) + iTime*5.0 + pos.z)*0.15;\n    float columnsScaleY = (sin(iTime + pos.z*4.0)*0.5+0.5);\n    \n    float columns = sphere(vec3(reppos.x, pos.y+0.25, reppos.z), 0.035, vec3(columnsScaleX,columnsScaleY,columnsScaleX));\n    float corridor = planesDistance - abs(pos.y) + h;\n    float d = smin(corridor, columns, 0.25); \n           \n    return d;\n}\n\nfloat rayMarch(vec3 rayDir, vec3 cameraOrigin)\n{\n    const int MAX_ITER = 50;\n\tconst float MAX_DIST = 30.0;\n    \n    float totalDist = 0.0;\n    float totalDist2 = 0.0;\n\tvec3 pos = cameraOrigin;\n\tfloat dist = EPSILON;\n    vec3 col = vec3(0.0);\n    float glow = 0.0;\n    \n    for(int j = 0; j < MAX_ITER; j++)\n\t{\n\t\tdist = distfunc(pos);\n\t\ttotalDist = totalDist + dist;\n\t\tpos += dist*rayDir;\n        \n        if(dist < EPSILON || totalDist > MAX_DIST)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n    \n    return totalDist  ;\n}\n\n\/\/Taken from https:\/\/www.shadertoy.com\/view\/Xds3zN\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 calculateNormals(vec3 pos)\n{\n\tvec2 eps = vec2(0.0, EPSILON*1.0);\n\tvec3 n = normalize(vec3(\n\tdistfunc(pos + eps.yxx) - distfunc(pos - eps.yxx),\n\tdistfunc(pos + eps.xyx) - distfunc(pos - eps.xyx),\n\tdistfunc(pos + eps.xxy) - distfunc(pos - eps.xxy)));\n    \n\treturn n;\n}\n\n\/\/Taken from https:\/\/www.shadertoy.com\/view\/XlXXWj\nvec3 doBumpMap(vec2 uv, vec3 nor, float bumpfactor)\n{\n   \n    const float eps = 0.001;\n    float ref = bumpmap(uv); \n    \n    vec3 grad = vec3(bumpmap(vec2(uv.x-eps, uv.y))-ref, 0.0, bumpmap(vec2(uv.x, uv.y-eps))-ref); \n             \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec3 cameraOrigin = vec3(0.0, 0.0, iTime*-0.1);\n    vec3 cameraTarget = cameraOrigin + vec3(0.0, 0.0, 1.0);;\n    \n\tvec2 screenPos = (fragCoord.xy\/iResolution.xy)*2.0-1.0;\n\tscreenPos.x *= iResolution.x\/iResolution.y;\n    \n\tmat3 cam = setCamera(cameraOrigin, cameraTarget, 0.0 );\n    \n    vec3 rayDir = cam* normalize( vec3(screenPos.xy,2.0) );\n    rayDir.xy *= rot(iTime*0.1);\n    float dist = rayMarch(rayDir, cameraOrigin);\n   \n    vec3 pos = cameraOrigin + dist*rayDir;\n    vec2 uv = pos.xy * rot(pos.z*twist.x);\n    float h = heightmap(vec2(uv.x, pos.z));\n    vec3 n = calculateNormals(pos);\n    vec3 bump = doBumpMap(vec2(uv.x, pos.z), n, 3.0);\n    float m = smoothstep(-0.15,0.2, planesDistance - abs(uv.y) + h*heightInfluence.y + sin(iTime)*0.05);\n    vec3 color = mix(mix(groundColor1, groundColor2, smoothstep(heightInfluence.z,heightInfluence.w,h)), columnColors, m);\n    float fog = dist*fogDensity-fogDistance;\n    float heightfog = pos.y;\n    float rim = (1.0-max(0.0, dot(-normalize(rayDir), bump)));\n    vec3 lightPos = pos - (cameraOrigin + vec3(0.0,0.0,1.0));\n    vec3 lightDir = -normalize(lightPos);\n    float lightdist = length(lightPos);\n    float atten = 1.0 \/ (1.0 + lightdist*lightdist*3.0);\n    float light = max(0.0, dot(lightDir, bump));\n   \tvec3 r = reflect(normalize(rayDir), bump);\n    float spec = clamp (dot (r, lightDir),0.0,1.0);\n    float specpow = pow(spec,20.0);\n    vec3 c = color*(ambient.xyz + mix(rim*rim*rim, rim*0.35+0.65, m)*rimColor + lightColor*(light*atten*2.0 + specpow*1.5));\n    vec4 res = mix(vec4(c, rim), fogColor, clamp(fog+heightfog,0.0,1.0));\n\n    \n\tfragColor = res;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\/\/Blur Pass1\nvec2 sampleDist = vec2(2.0,2.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord.xy\/iResolution.xy;\n    \n    vec4 tex = vec4(0.0);\n    vec2 dist = sampleDist\/iResolution.xy;\n    \n    for(int x = -2; x <= 2; x++)\n    {\n    \tfor(int y = -2; y <= 2; y++)\n        {\n\t\t\ttex += texture(iChannel0, uv + vec2(x,y)*dist);\n        }\n    }\n        \n    tex \/= 25.0;\n    \n\tfragColor = tex;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\/\/Blur Pass2\nvec2 sampleDist = vec2(4.0,4.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord.xy\/iResolution.xy;\n    \n    vec4 tex = vec4(0.0);\n    vec2 dist = sampleDist\/iResolution.xy;\n    \n    for(int x = -2; x <= 2; x++)\n    {\n    \tfor(int y = -2; y <= 2; y++)\n        {\n\t\t\ttex += texture(iChannel0, uv + vec2(x,y)*dist);\n        }\n    }\n        \n    tex \/= 25.0;\n    \n\tfragColor = tex;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\/\/Blur Pass3\nvec2 sampleDist = vec2(8.0,8.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord.xy\/iResolution.xy;\n    \n    vec4 tex = vec4(0.0);\n    vec2 dist = sampleDist\/iResolution.xy;\n    \n    for(int x = -2; x <= 2; x++)\n    {\n    \tfor(int y = -2; y <= 2; y++)\n        {\n\t\t\ttex += texture(iChannel0, uv + vec2(x,y)*dist);\n        }\n    }\n        \n    tex \/= 25.0;\n    \n\tfragColor = tex;\n}","name":"Buffer D","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"MlscWX","date":"1509015241","viewed":18715,"name":"Turn n' Burn","username":"ingagard","description":"Please read description in the top of Image for information about controls and optimizations.\nUse the mouse while holding down the left mouse button to control the camera.\n\nEnjoy!","likes":200,"published":3,"flags":48,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"\/media\/a\/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"\/media\/ap\/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Copyright \u00a9 2017 Kim Berkeby\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/*\n\n CONTROLS:\n ---------\n SPACE  FIRE MISSILE\n \n S      ROLL LEFT\n F      ROLL RIGHT  \n E      PITCH DOWN\n D      PITCH UP\n \n W      YAW LEFT   (PLANE TURN) \n R      YAW RIGHT   (PLANE TURN)\n \n SHIFT  INCREASE SPEED\n CTRL   DECCREASE SPEED \n \n F1     ZOOM OUT\n F2     ZOOM IN\n \n NOTICE:\n Controls can be changed to use arrow keys if you uncomment the alternative controls in Buf A. \n \n \n Toggle effects by pressing folloving keys:\n ------------------------------------------\n 1-key  = Lens dirt  on\/off               (default off)\n 2-key  = Grain filter  on\/off            (default on)\n 3-key  = Chromatic aberration  on\/off    (default on)    \n 4-key  = Anti aliasing  on\/off           (default on)\n 5-key  = Lens flare  on\/off              (default on)\n \n --------------------------------------------------------\n TO INCREASE PERFORMANCE:\n \n Delete one or several defines from Buf B:\n \n #define SHADOWS\n #define QUALITY_TREE\n #define QUALITY_REFLECTIONS\n #define EXACT_EXPLOSIONS\n --------------------------------------------------------\n \n This shader was made by using distance functions found in HG_SDF:\n http:\/\/mercury.sexy\n \n Special thanks to Inigo Quilez for his great tutorials on:\n https:\/\/iquilezles.org\/\n \n Last but not least, thanks to all the nice people here at ShaderToy! :-D\n\n*\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ POST EFFECTS BUFFER\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Channel 0 = Buffer A. Read data from data-buffer.\n\/\/ Channel 1 = LowRes noise texture. Used in fast noise functions.\n\/\/ Channel 2 = Buffer C. Get the colors of the render from the last buffer.\n\/\/ Channel 3 = Organic 2 texture. Used in lens dirt filter.\n\n\n  #define FastNoise(posX) (  textureLod(iChannel1, (posX+0.5)\/iResolution.xy, 0.0).r)\n  #define readAlpha(memPos) (  textureLod(iChannel2, memPos, 0.0).a)\n  #define read(memPos) (  texelFetch(iChannel0, memPos, 0).a)\n  #define readRGB(memPos) (  texelFetch(iChannel0, memPos, 0).rgb)\n  #define CLOUDLEVEL -70.0\n  #define PI acos(-1.)\n  #pragma optimize(off) \nmat3 cameraMatrix;\nvec3 planePos=vec3(0.);\nvec3 sunPos=vec3(0.);\nconst vec3 eps = vec3(0.02, 0.0, 0.0);\n\nfloat GetExplosionIntensity(float life)\n{\n  return mix(1., .0, smoothstep(0., 5.0, distance(life, 5.)));\n}\n\n\/\/ 3D noise function (IQ)\nfloat fastFBM(vec3 p)\n{\n  vec3 ip=floor(p);\n  p-=ip; \n  vec3 s=vec3(7, 157, 113);\n  vec4 h=vec4(0., s.yz, s.y+s.z)+dot(ip, s);\n  p=p*p*(3.-2.*p); \n  h=mix(fract(sin(h)*43758.5), fract(sin(h+s.x)*43758.5), p.x);\n  h.xy=mix(h.xz, h.yw, p.y);\n  return mix(h.x, h.y, p.z);\n}\n\nmat3 setCamera(  vec3 ro, vec3 ta, float cr )\n{\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n  vec3 cu = normalize( cross(cw, cp) );\n  vec3 cv = normalize( cross(cu, cw) );\n  return mat3( cu, cv, cw );\n}\n\nvec2 GetScreenPos(vec3 pos)\n{\n  return vec2(PI*dot( pos, cameraMatrix[0].xyz ), PI* dot( pos, cameraMatrix[1].xyz ));\n}\n\nvec3 CalculateSunFlare(vec3 rayDir, vec3 rayOrigin, vec2 screenSpace, float alpha, float enableFlare)\n{\n  float visibility = pow(max(0., dot(sunPos, rayDir)), 8.0);  \n  if (visibility<=0.05) return vec3(0.);\n\n  vec2 sunScreenPos = GetScreenPos(sunPos);\n\n  vec2 uvT = screenSpace-sunScreenPos;\n  float sunIntensity = (1.0\/(pow(length(uvT)*4.0+1.0, 1.30)))*visibility;\n\n  vec3 flareColor = vec3(0.);\n  vec2 offSet = uvT;\n  vec2 offSetStep=  0.4*sunScreenPos;\n  vec3 color;\n  float size=.0, dist=0.;\n  \n  if(enableFlare>0.)\n  {\n  \/\/ check if center of sun is covered by any object. MATH IS OFF AT SCREEN CHECK POS! sunScreenPos\/2.0 +0.5 IS NOT EXACTLY SUN MIDDLE!\n  \/\/ only draw if not covered by any object\n  if (readAlpha( sunScreenPos\/2.0 +0.5)<0.50)\n  {\n    \/\/ create flare rings\n    for (float i =1.; i<8.; i++)\n    {\n      color.rg = vec2(abs((sin(i*53.))), 0.65);\n      color.b = abs((cos(i*25.)));\n      offSet += offSetStep;\n\n      size = 0.05+((1.-sin(i*0.54))*0.28);\n      dist = pow(distance(sunScreenPos, offSet), 1.20);\n\n      flareColor += mix(vec3(0.), sunIntensity*(10.*size) * color, smoothstep(size, size-dist, dist))\/(1.0-size);\n    }\n  }\n  flareColor*=mix(0., 1.0, smoothstep(0., 0.1, visibility));\n  }\n    \n  \/\/ flare star shape\n  vec3 sunSpot = vec3(1.30, 1., .80)*sunIntensity*(sin(FastNoise((sunScreenPos.x+sunScreenPos.y)*2.3+atan(uvT.x, uvT.y)*15.)*5.0)*.12);\n  \/\/ sun glow\n  sunSpot+=vec3(1.0, 0.96, 0.90)*sunIntensity*.75;\n  sunSpot+=vec3(1.0, 0.76, 0.20)*visibility*0.15;\n\n  return flareColor+(sunSpot*(1.0-alpha));\n}\nvec3 CalculateExplosionFlare(vec3 rayDir, vec3 rayOrigin, vec2 screenSpace, float alpha, vec3 explosionPos, float enableFlare)\n{\n\n  float visibility = max(0., dot(explosionPos, rayDir));  \n  if (visibility<=0.15) return vec3(0.);\n\n  vec2 flareScreenPos = GetScreenPos(explosionPos);\n  vec2 uvT = screenSpace-flareScreenPos;\n  float flareIntensity = 0.2*visibility;\n  vec3 flareColor = vec3(0.);\n  vec2 offSet = uvT;\n  vec2 offSetStep=  0.4*flareScreenPos;\n  vec3 color;\n  float size=.0, dist=0.; \n\n    if(enableFlare>0.)\n    {\n  \/\/ create flare rings\n  for (float i =1.; i<8.; i++)\n  {\n    color.rg = vec2(0.75+(0.25*sin(i*i)));\n    color.b = 0.75+(0.35*cos(i*i));\n    offSet += offSetStep;\n    size = 0.05+((1.-sin(i*0.54))*0.38);\n    dist = pow(distance(flareScreenPos, offSet), 1.20);\n\n    flareColor += mix(vec3(0.), flareIntensity*(4.*size) * color, smoothstep(size, size-dist, dist))\/(1.0-size);\n  }\n  flareColor\/=2.;\n    }\n  \/\/ flare star shape\n  vec3 flareSpot = vec3(1.30, 1., .80)*flareIntensity*(sin(FastNoise((flareScreenPos.x+flareScreenPos.y)*5.+atan(uvT.x, uvT.y)*10.)*4.0)*.2+3.5*flareIntensity);\n  \/\/ flare glow\n  flareSpot+=vec3(1.0, 0.7, 0.2)*pow(visibility, 12.0)*0.3;\n\n  return (flareColor+flareSpot)*(1.0-alpha);\n}\n\nvoid pR(inout vec2 p, float a)\n{\n  p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat DrawExplosion(int id, inout vec4 color, vec3 rayDir, vec3 rayOrigin, vec2 screenSpace, float enableFlare)\n{\n  id *= 100; \n  float dist =-10000.;\n  float life = read(ivec2(122+id, 0));\n\n  \/\/ check if explosion has been spawned\n  if (life>0. )\n  {     \n    vec3 pos = normalize(readRGB(ivec2(120+id, 0))-planePos); \n    float eDist = pow(max(0., dot(pos, rayDir)), 2.0); \n    float intensity =GetExplosionIntensity(life);\n    dist = eDist*intensity*1.4;\n    color.rgb += CalculateExplosionFlare(rayDir, rayOrigin, screenSpace, 1.0-intensity, pos, enableFlare);\n    color.rgb = mix(color.rgb, color.rgb+vec3(1.0, 0.4, 0)*0.5, eDist*intensity);\n  }   \n  return dist;\n}  \n\n\nvec3 AntiAliasing(vec2 uv)\n{\n  vec2 offset = vec2(0.11218413712, 0.33528304367) * (1.0 \/ iResolution.xy);\n\n  return (texture(iChannel2, uv + vec2(-offset.x, offset.y)) +\n    texture(iChannel2, uv + vec2( offset.y, offset.x)) +\n    texture(iChannel2, uv + vec2( offset.x, -offset.y)) +\n    texture(iChannel2, uv + vec2(-offset.y, -offset.x))).rgb * 0.25;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{  \n  vec2 mo = iMouse.xy\/iResolution.xy;\n  vec2 uv = fragCoord.xy \/ iResolution.xy;\n  vec2 screenSpace = (-iResolution.xy + 2.0*(fragCoord))\/iResolution.y;\n\n  \/\/ read values from buffer\n  vec3 effects = readRGB(ivec2(20, 0));  \n  vec3 effects2 = readRGB(ivec2(22, 0)); \n  float turn = read(ivec2(1, 10));\n  sunPos = readRGB(ivec2(50, 0));\n  planePos = readRGB(ivec2(55, 0));\n  \/\/ setup camera and ray direction\n  vec2 camRot = readRGB(ivec2(57, 0)).xy;\n  float CAMZOOM = read(ivec2(52, 0));  \n  vec3 rayOrigin = vec3(CAMZOOM*cos(camRot.x), 3.+CAMZOOM*sin(camRot.y), -3.+CAMZOOM*sin(camRot.x) );\n  pR(rayOrigin.xz, -turn);\n  cameraMatrix  = setCamera( rayOrigin, vec3(0., 0., -3. ), 0.0 );\n  vec3 rayDir = cameraMatrix * normalize( vec3(screenSpace.xy, 2.0) );\n\n  vec2 d = abs((uv - 0.5) * 2.0);\n  d = pow(d, vec2(2.0, 2.0));\n  float minDist = -1000.0;\n\n\n  vec4 color;\n\n  \/\/ chromatic aberration?\n  if (effects.z>0.)\n  {\n    float offSet = distance(uv, vec2(0.5))*0.005;\n    \/\/ AA pass?\n    if (effects2.y>0.)\n    {\n      color.rgb = vec3(AntiAliasing(uv + offSet).r, AntiAliasing(uv).g, AntiAliasing(uv - offSet).b);\n    } else\n    {\n      color.rgb = vec3(texture(iChannel2, uv + offSet).r, texture(iChannel2, uv).g, texture(iChannel2, uv - offSet).b);\n    }\n  }\n  \/\/ no chromatic aberration \n  else\n  {\n    \/\/ AA pass?\n    if (effects2.y>0.)\n    {\n      color.rgb=AntiAliasing(uv);\n    } else\n    {\n      color.rgb = texture(iChannel2, uv).rgb;\n    }\n  }\n\n  color.a=textureLod(iChannel2, uv, 0.).a;\n\n  \/\/ add sun with lens flare effect\n  color.rgb += CalculateSunFlare(rayDir, rayOrigin, screenSpace, clamp(color.a, 0., 1.0),effects2.x);\n\n  \/\/ add explosion light effects\n  minDist = max(minDist, DrawExplosion(0, color, rayDir, rayOrigin, screenSpace,effects2.x));\n  minDist = max(minDist, DrawExplosion(1, color, rayDir, rayOrigin, screenSpace,effects2.x));\n\n  float cloudDistance = distance(rayOrigin.y+planePos.y, -CLOUDLEVEL);\n\n  \/\/ grain noise\n  if (effects.y>0.)\n  {\n    vec2 grainTexPos = ((fragCoord.xy + iTime*60.0*vec2(10, 35.))*mix(0.6, 0.2, smoothstep(5.0, 0., cloudDistance)))\/iChannelResolution[0].xy;\n    vec2 filmNoise = textureLod( iChannel1, grainTexPos, 0. ).rb;\n    \/\/ scale up effect when flying through clouds\n    color.rgb *= mix( vec3(1), mix(vec3(1, .5, 0), vec3(0, .5, 1), filmNoise.x), mix(.04, 0.7, smoothstep(5.0, 0., cloudDistance))*filmNoise.y );\n  }\n\n  \/\/ flying though clouds\n  color = mix(color, clamp(color+max(0.4, fastFBM(rayOrigin+planePos)*2.), 0., 1.0), smoothstep(5.0, 0., cloudDistance));\n\n\n  \/\/ Lens dirt when looking into strong light source\n  if (effects.x>0.)\n  {\n    minDist=max(minDist, pow(max(0., dot(sunPos, rayDir)), 2.0));     \n    float dirtTex = textureLod( iChannel3, (fragCoord.xy \/ iResolution.x), 0.3 ).r*2.5;\n\n    color.rgb += 0.04*dirtTex*minDist;\n  }\n\n  fragColor =  vec4(pow(color.rgb, vec3(1.0\/1.1)), 1.0 ) * (0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.2 ));\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sfGRn","filepath":"\/media\/a\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"\/media\/ap\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzn","filepath":"\/media\/a\/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"\/media\/ap\/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"\/presets\/tex00.jpg","previewfilepath":"\/presets\/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ DATA BUFFER  -  PLANE MOVEMENT, KEYBOARD CHECKS AND MISSILE UPDATE (IF LAUNCHED)\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Channel 0 = Keyoard input. Used to capture key-presses.\n\/\/ Channel 1 = LowRes noise texture. Used in fast noise functions.\n\/\/ Channel 2 = This buffer (A). Read and write data to update movement in this shader.\n\/\/ Channel 3 = Lichen texture. Used to create landscape height map used in collision detection.\n\n  #define PI acos(-1.)\n  #define keyClick(ascii)   ( texelFetch(iChannel0, ivec2(ascii, 0), 0).x > 0.)\n  #define keyPress(ascii)   ( texelFetch(iChannel0, ivec2(ascii, 1), 0).x > 0.)\n  #define read(memPos) (  texelFetch(iChannel2, memPos, 0).a)\n  #define readRGB(memPos) (  texelFetch(iChannel2, memPos, 0).rgb)\n  #define MAX_HEIGHT 150. \n  #define MIN_HEIGHT 0. \n  #define STARTHEIGHT 40.\n  #pragma optimize(off) \n\/\/ SPACE   FIRE MISSILE\n#define MISSILE_KEY 32  \n\/\/ S    ROLL LEFT\n#define ROLL_LEFT_KEY 83  \n\/\/ F    ROLL RIGHT\n#define ROLL_RIGHT_KEY 70      \n\/\/ W    YAW LEFT   (PLANE STRIFE)\n#define LEFT_KEY 87    \n\/\/ R    YAW RIGHT   (PLANE STRIFE)\n#define RIGHT_KEY 82     \n\/\/ E    PITCH DOWN\n#define UP_KEY 69     \n\/\/ D    PITCH UP\n#define DOWN_KEY 68     \n\/\/ SHIFT  INC SPEED\n#define SPEED_INCREASE_KEY 16     \n\/\/ CTRL   DEC SPEED\n#define SPEED_DECREASE_KEY 17    \n\/\/ F1     ZOOM OUT\n#define ZOOMOUT_KEY 112\n\/\/ F2     ZOOM IN\n#define ZOOMIN_KEY 113\n\n\/\/ Alternative controls if uncommented  (lets you use arrow keys to control the plane)\n\/* \n\/\/ ENTER   FIRE MISSILE\n#define MISSILE_KEY 13\n\/\/ LEFT ARROW    ROLL LEFT\n#define ROLL_LEFT_KEY 37  \n\/\/ RIGHT ARROW    ROLL RIGHT\n#define ROLL_RIGHT_KEY 39     \n\/\/ DELETE   YAW LEFT   (PLANE STRIFE)\n#define LEFT_KEY 46    \n\/\/ PAGE DOWN    YAW RIGHT   (PLANE STRIFE)\n#define RIGHT_KEY 34     \n\/\/ UP ARROW    PITCH DOWN\n#define UP_KEY 38     \n\/\/ DOWN ARROW    PITCH UP\n#define DOWN_KEY 40     \n\/\/ SHIFT  INC SPEED\n#define SPEED_INCREASE_KEY 16     \n\/\/ CTRL   DEC SPEED\n#define SPEED_DECREASE_KEY 17    \n\/\/ F1     ZOOM OUT\n#define ZOOMOUT_KEY 112\n\/\/ F2     ZOOM IN\n#define ZOOMIN_KEY 113\n*\/\n\n\nvec3 sunPos=vec3(0.);\nvec3 planePos=vec3(0.);\nfloat explosionCount=0.;\n\n\nstruct Missile\n{ \n  vec3 pos;\n  float life;\n  vec3 orientation;   \/\/ roll,pitch,turn amount\n    vec3 startPos;\n};\n\nstruct Explosion\n{ \n  vec3 pos;\n  float life;\n};\n\n\n\nmat3 setCamera(  vec3 ro, vec3 ta, float cr )\n{\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n  vec3 cu = normalize( cross(cw, cp) );\n  vec3 cv = normalize( cross(cu, cw) );\n  return mat3( cu, cv, cw );\n}\n\nmat2 r2(float r) {\n  float c=cos(r), s=sin(r);\n  return mat2(c, s, -s, c);\n}\n\nvoid pR(inout vec2 p, float a) \n{\n  p*=r2(a);\n}\n\nfloat noise2D( in vec2 pos, float lod)\n{   \n  vec2 f = fract(pos);\n  f = f*f*(3.0-2.0*f);\n  vec2 rg = textureLod( iChannel1, (((floor(pos).xy+vec2(37.0, 17.0)) + f.xy)+ 0.5)\/64.0, lod).yx;  \n  return -1.0+2.0*mix( rg.x, rg.y, 0.5 );\n}\n\nfloat noise2D( in vec2 pos )\n{\n  return noise2D(pos, 0.0);\n}\n\n\/\/ 3D noise function (IQ)\nfloat fastFBM(vec3 p)\n{\n  vec3 ip=floor(p);\n  p-=ip; \n  vec3 s=vec3(7, 157, 113);\n  vec4 h=vec4(0., s.yz, s.y+s.z)+dot(ip, s);\n  p=p*p*(3.-2.*p); \n  h=mix(fract(sin(h)*43758.5), fract(sin(h+s.x)*43758.5), p.x);\n  h.xy=mix(h.xz, h.yw, p.y);\n  return mix(h.x, h.y, p.z);\n}\n\nfloat hash(float h) \n{\n  return fract(sin(h) * 43758.5453123);\n}\n\nfloat noise(vec3 x) \n{\n  vec3 p = floor(x);\n  vec3 f = fract(x);\n  f = f * f * (3.0 - 2.0 * f);\n\n  float n = p.x + p.y * 157.0 + 113.0 * p.z;\n  return -1.0+2.0*mix(\n    mix(mix(hash(n + 0.0), hash(n + 1.0), f.x), \n    mix(hash(n + 157.0), hash(n + 158.0), f.x), f.y), \n    mix(mix(hash(n + 113.0), hash(n + 114.0), f.x), \n    mix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\n\nfloat NoTreeZone(vec3 p)\n{\n    float dist = distance(readRGB(ivec2(140, 0)).xz,p.xz);\n    dist = min(dist,distance(readRGB(ivec2(142, 0)).xz,p.xz));\n    dist = min(dist,distance(readRGB(ivec2(144, 0)).xz,p.xz));\n    dist = min(dist,distance(readRGB(ivec2(146, 0)).xz,p.xz));\n    dist = min(dist,distance(readRGB(ivec2(148, 0)).xz,p.xz));\n    return dist;\n}\nfloat GetTerrainHeight( vec3 p)\n{\n  vec2 p2 = (p.xz+planePos.xz)*0.0005;\n\n  float heightDecrease = mix(1.0,0.,smoothstep(0.,15.0,NoTreeZone(p+planePos)));\n    \n  float mainHeight = -2.3+fastFBM((p+vec3(planePos.x, 0., planePos.z))*0.025)*max(11., abs(22.*noise2D(p2))); \n  mainHeight-=heightDecrease;\n    \n  float terrainHeight=mainHeight;\n  p2*=4.0;\n  terrainHeight += textureLod( iChannel3, p2, 2.7 ).x*1.; \n  p2*=2.0;\n  terrainHeight -= textureLod( iChannel3, p2, 1.2 ).x*.7;\n  p2*=3.0;\n  terrainHeight -= textureLod( iChannel3, p2, 0.5 ).x*.1;\n\n  terrainHeight=mix(terrainHeight, mainHeight*1.4, smoothstep(1.5, 3.5, terrainHeight)); \n\n  return   terrainHeight;\n}\n\nfloat GetTreeHeight( vec3 p, float terrainHeight)\n{\n  if(NoTreeZone(p+planePos)<25.) return 0.;\n  float treeHeight = textureLod(iChannel3, (p.xz+planePos.xz)*0.006, .1).x;\n  float tree = mix(0., mix(0., mix(0., 2.0, smoothstep(0.3, 0.86, treeHeight)), smoothstep(1.5, 3.5, terrainHeight)), step(0.3, treeHeight)); \n  tree -= tree*0.75;\n  tree*=4.0;\n\n  return  tree;\n}\n\nvec3 TranslatePos(vec3 p, float _direction, float _pitch, float _roll)\n{\n  pR(p.xz, _direction);\n  pR(p.zy, _pitch);\n\n  return p;\n}\n\nvoid LaunchMissile(inout Missile missile, vec3 startPos, vec3 orientation)\n{\n  missile.life=4.0; \n  missile.orientation = orientation;\n  missile.pos =  startPos;\n  missile.startPos= planePos;\n  missile.orientation.y *=cos(missile.orientation.x-PI);\n}\n\nvoid UpdateMissile(inout Missile missile, float id, inout vec4 fragColor, vec2 fragCoord, vec3 moveDiff)\n{\n  float adressStep = id*100.;\n     \n  Explosion explosion;\n \n  \/\/ read variables for explosion s\n  explosion.pos = readRGB(ivec2(120+int(adressStep), 0));    \n  explosion.life = read(ivec2(122+int(adressStep), 0));\n\n  \/\/ update active missile and save variables\n  if ( missile.life>0.)\n  {\n    missile.life-= 0.015;\n    vec3 velocityAdd = vec3(0., 0., 1.4);\n\n    pR(velocityAdd.yz, missile.orientation.y);\n    pR(velocityAdd.xz, -missile.orientation.z);\n\n    missile.pos += velocityAdd; \/\/ add velocity movement to pos\n    missile.pos.xz-=moveDiff.xz; \/\/ add plane movement to pos\n\n    \/\/ ground collision check                 \n    vec3 testPoint = missile.pos;\n      \n    testPoint+=vec3(4.8 - (9.6*id), -0.4, -3.0);\n    pR(testPoint.xz, missile.orientation.z);\n    testPoint-=vec3(4.8 - (9.6*id), -0.4, -3.0);\n    testPoint.y+=missile.startPos.y;\n      \n    float tHeight = GetTerrainHeight(testPoint);\n    tHeight+=GetTreeHeight(testPoint, tHeight);\n\n    \/\/ does missile hit terrain?\n    if (testPoint.y<tHeight)\n    {\n      \/\/ if colliding, kill missile and spawn explosion.             \n       explosion.pos =  missile.pos+missile.startPos;\n       explosion.pos.y = tHeight-3.0;\n       explosion.life=10.0;\n       missile.life=-10.;\n       explosionCount+=2.0;\n       explosionCount = mod(explosionCount,10.);\n    }\n\n    fragColor.a = mix(missile.life, fragColor.a, step(1., distance(fragCoord.xy, vec2(100.0+adressStep, 0.0))));\n    fragColor.rgb = mix(missile.startPos, fragColor.rgb, step(1., distance(fragCoord.xy, vec2(102.0+adressStep, 0.0))));\n    fragColor.rgb = mix(missile.orientation, fragColor.rgb, step(1., distance(fragCoord.xy, vec2(108.0+adressStep, 0.0)))); \n    fragColor.rgb = mix(missile.pos, fragColor.rgb, step(1., distance(fragCoord.xy, vec2(116.0+adressStep, 0.0))));\n            \n  }\n  \/\/ ##################################################################\n\n  \/\/ update explosion\n  if ( explosion.life>0.)\n  {   \n    explosion.life-= 0.115;\n   \/\/ explosion.life= 9.715;\n    fragColor.rgb = mix(explosion.pos, fragColor.rgb, step(1., distance(fragCoord.xy, vec2(120.0+adressStep, 0.0)))); \n    fragColor.a = mix(explosion.life, fragColor.a, step(1., distance(fragCoord.xy, vec2(122.0+adressStep, 0.0))));\n      \n    \/\/ terrain holes\n    fragColor.rgb = mix(mix(explosion.pos, fragColor.rgb, step(1., distance(fragCoord.xy, vec2(140.0+explosionCount, 0.0)))),fragColor.rgb,step(0.4,distance(5.0,explosion.life)));\n  }\n}\n\n\nvoid ToggleEffects(inout vec4 fragColor, vec2 fragCoord)\n{\n   \/\/ read and save effect values from buffer  \n   vec3 effects =  mix(vec3(-1.0,1.0,1.0), readRGB(ivec2(20, 0)), step(1.0, float(iFrame)));\n   effects.x*=1.0+(-2.*float(keyPress(49))); \/\/1-key  LENSDIRT\n   effects.y*=1.0+(-2.*float(keyPress(50))); \/\/2-key  GRAINFILTER\n   effects.z*=1.0+(-2.*float(keyPress(51))); \/\/3-key  ChromaticAberration\n   \n   vec3 effects2 =  mix(vec3(1.0,1.0,1.0), readRGB(ivec2(22, 0)), step(1.0, float(iFrame)));\n   effects2.y*=1.0+(-2.*float(keyPress(52))); \/\/4-key  AA-pass\n   effects2.x*=1.0+(-2.*float(keyPress(53))); \/\/5-key  lens flare\n\n   fragColor.rgb = mix(effects, fragColor.rgb, step(1., distance(fragCoord.xy, vec2(20.0, 0.0))));  \n   fragColor.rgb = mix(effects2, fragColor.rgb, step(1., distance(fragCoord.xy, vec2(22.0, 0.0))));  \n}\n\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{  \n  vec2 mo = iMouse.xy\/iResolution.xy;\n  vec2 uv = fragCoord.xy \/ iResolution.xy;\n  vec2 screenSpace = (-iResolution.xy + 2.0*(fragCoord))\/iResolution.y;\n\n  \/\/ read plane values from buffer\n  float turn = mix(1.0, read(ivec2(1, 10)), step(1.0, float(iFrame)));\n  float roll = mix(3.14, read(ivec2(1, 1)), step(1.0, float(iFrame)));\n  float rudderAngle = read(ivec2(6, 1));\n  float speed = read(ivec2(10, 1));\n  float pitch = read(ivec2(15, 1));\n  explosionCount = read(ivec2(3, 0));  \n    \n  sunPos = mix(normalize( vec3(-1.0, 0.3, -.50) ), readRGB(ivec2(50, 0)), step(1.0, float(iFrame)));\n  planePos = mix(vec3(-400, STARTHEIGHT, -100), readRGB(ivec2(55, 0)), step(1.0, float(iFrame)));\n  float CAMZOOM = mix(13.9, read(ivec2(52, 0)), step(1.0, float(iFrame)));  \n  vec2 camRot = vec2(-1., 0.340);\n\n  \/\/ setup camera and ray direction\n  camRot.x+=mo.x*16.; \n  camRot.y+=mo.y*16.; \n \n  \/\/ limit roll\n  roll=mod(roll, 6.28);\n \n    \/\/ add turn angle based on roll  \n  float turnAmount = mix(0., 1.57, smoothstep(0., 1.57, 1.57-distance(1.57, roll-3.14)));\n  turnAmount += mix(0., -1.57, smoothstep(0., 1.57, 1.57-distance(-1.57, roll-3.14)));\n  float PitchAdd = sin(pitch);\n \n  \/\/ YAW\n  turn+=0.02*rudderAngle;\n  \/\/ add turn angle  \n  turn+=turnAmount*0.015;\n  turn-=0.1*(((pitch*0.25)*cos(roll-1.57)));\n  \n    turn= mod(turn,PI*2.);\n  vec3 oldPlanePos = vec3(planePos.x, planePos.y, planePos.z);\n\n  \/\/ move plane\n  planePos.xz += vec2(cos(turn+1.5707963)*0.5,  sin(turn+1.5707963)*0.5)*(0.7+speed)*cos(pitch);\n  planePos.y = clamp(planePos.y+((PitchAdd*0.25)*cos(roll-PI)), MIN_HEIGHT, MAX_HEIGHT);\n\n  rudderAngle*=0.97;\n  \/\/ check key inputs\n  rudderAngle-=0.03*float(keyClick(LEFT_KEY));\n  rudderAngle+=0.03*float(keyClick(RIGHT_KEY));\n  rudderAngle=clamp(rudderAngle, -0.4, 0.4);;\n  roll-=0.055*float(keyClick(ROLL_LEFT_KEY));\n  roll+=0.055*float(keyClick(ROLL_RIGHT_KEY));\n\n  speed+=(0.02*float(keyClick(SPEED_INCREASE_KEY)));\n  speed-=(0.02*float(keyClick(SPEED_DECREASE_KEY)));\n  speed=clamp(speed, -0.3, 1.);\n   \n  \/\/ prevent plane from getting into terrain\n  float tHeight = GetTerrainHeight(planePos);\n  tHeight+=GetTreeHeight(planePos, tHeight);\n  float minHeight = tHeight+12.;\n  planePos.y = max(planePos.y,minHeight);\n    \n   \/\/ pitch = sin(pitch);\n  pitch-=(mix(0.02, 0., smoothstep(0., 3., 3.0-abs(distance(planePos.y, minHeight))))*float(keyClick(UP_KEY))); \/\/e-key\n  pitch+=(mix(0.02, 0., smoothstep(0., 3., 3.0-abs(distance(planePos.y, MAX_HEIGHT))))*float(keyClick(DOWN_KEY))); \/\/d-key\n  pitch = clamp(pitch, -1.25, 1.25);\n  pitch*=0.97;\n\n  turnAmount += mix(0., -1.57, smoothstep(0., 1.57, 1.57-distance(-1.57, roll-3.14)));\n  fragColor = vec4(textureLod(iChannel2, uv,0.).rgb,0.);\n    \n  \/\/ ------------------------- MISSILES ------------------------------\n  \/\/ NOTE: MISSILES ARE RENDERED IN BUFFER B TOGETHER WITH THE TERRAIN     \n  int adressStep = 0;\n  bool launchLocked=false;\n  Missile missile;\n  for (int i=0; i<2; i++)\n  {\n    adressStep = i*100;\n      \n    \/\/ read variables for missiles\n    missile.life = read(ivec2(100 + adressStep, 0));\n    missile.startPos = readRGB(ivec2(102 + adressStep, 0));  \n    missile.orientation = readRGB(ivec2(108 + adressStep, 0));\n    missile.pos = readRGB(ivec2(116 + adressStep, 0));\n\n  \/\/ if missile is \"dead\" check if a new missile is being lanched by pressing the M-key\n  if (keyPress(MISSILE_KEY) && !launchLocked)\n  {    \n   if (missile.life<=0.)\n   {\n      LaunchMissile(missile, vec3(4.8- (9.6*float(i)), -0.4, -3.0), vec3(roll, pitch, turn));  \n      launchLocked=true;\n   } \n }    \n\n  UpdateMissile(missile, float(i), fragColor, fragCoord, (planePos-oldPlanePos));\n  \/\/ ##################################################################\n  }\n\n  ToggleEffects(fragColor, fragCoord);\n   \n  CAMZOOM-=0.3*float(keyClick(ZOOMIN_KEY));\n  CAMZOOM+=0.3*float(keyClick(ZOOMOUT_KEY));\n  CAMZOOM=clamp(CAMZOOM, 10., 30.);;\n  \n  \/\/ save roll,speed and scroll values etc to buffer A \n  fragColor.a = mix(turn, fragColor.a, step(1., distance(fragCoord.xy, vec2(1.0, 10.0)))); \n  fragColor.a = mix(speed, fragColor.a, step(1., distance(fragCoord.xy, vec2(10.0, 1.0)))); \n  fragColor.a = mix(roll, fragColor.a, step(1., distance(fragCoord.xy, vec2(1.0, 1.0)))); \n  fragColor.a = mix(pitch, fragColor.a, step(1., distance(fragCoord.xy, vec2(15.0, 1.0)))); \n  fragColor.a = mix(rudderAngle, fragColor.a, step(1., distance(fragCoord.xy, vec2(6.0, 1.0))));\n  fragColor.a = mix(explosionCount, fragColor.a, step(1., distance(fragCoord.xy, vec2(3.0, 0.0)))); \n  fragColor.rgb = mix(sunPos, fragColor.rgb, step(1., distance(fragCoord.xy, vec2(50.0, 0.0))));\n  fragColor.a = mix(CAMZOOM, fragColor.a, step(1., distance(fragCoord.xy, vec2(52.0, 0.0))));\n  fragColor.rgb = mix(planePos, fragColor.rgb, step(1., distance(fragCoord.xy, vec2(55.0, 0.0))));\n  fragColor.rgb = mix(vec3(camRot.xy, 0.), fragColor.rgb, step(1., distance(fragCoord.xy, vec2(57.0, 0.0))));\n}\n","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4sfGRn","filepath":"\/media\/a\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"\/media\/ap\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzn","filepath":"\/media\/a\/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"\/media\/ap\/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ TERRAIN BUFFER  -   RENDERS TERRAIN AND LAUNCHED MISSILES + EXPLOSIONS \n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Channel 0 = Fine noise texture. Used in noise functions.\n\/\/ Channel 1 = LowRes noise texture. Used in fast noise functions.\n\/\/ Channel 2 = Buffer A. Read data from data-buffer.\n\/\/ Channel 3 = Lichen texture. Used to create landscape height map and textures.\n\n  #define read(memPos) (  texelFetch(iChannel2, memPos, 0).a)\n  #define readRGB(memPos) (  texelFetch(iChannel2, memPos, 0).rgb)\n  #define MAX_HEIGHT 150. \n  #define WATER_LOD 0.4\n  #define CLOUDLEVEL -70.0\n  #define PI acos(-1.)\n  #pragma optimize(off) \n  \/\/ remove on or several of below defines, if FPS is too low\n  #define SHADOWS\n  #define QUALITY_TREE\n  #define QUALITY_REFLECTIONS\n  #define EXACT_EXPLOSIONS\n  \/\/ ---------------------------------------------------------\n\nfloat turn=0.;\nvec2 cloudPos=vec2(0.);\nfloat eFlameDist=10000.0;\nvec3 checkPos=vec3(0.);\nvec3 sunPos=vec3(0.);\nconst vec3 sunColor = vec3(1.00, 0.90, 0.85);\n\nconst vec3 eps = vec3(0.02, 0.0, 0.0);\nvec3 planePos=vec3(0.);\n\nstruct RayHit\n{\n  bool hit;  \n  vec3 hitPos;\n  vec3 normal;\n  float dist;\n  float depth;\n  float eFlameDist;\n};\n\nstruct Missile\n{ \n  vec3 pos;\n  float life;\n  vec3 orientation;   \/\/ roll,pitch,turn amount\n  vec3 origin;\n};\n    \nstruct Explosion\n{ \n  vec3 pos;\n  float life;\n};\n\nmat2 r2(float r) {\n  float c=cos(r), s=sin(r);\n  return mat2(c, s, -s, c);\n}\n\n#define r3(r) mat2(sin(vec4(-1, 0, 0, 1)*acos(0.)+r))\n\nvoid pR(inout vec2 p, float a)\n{\n  p*=r2(a);\n}\n\nfloat sgn(float x)\n{   \n  return (x<0.)?-1.:1.;\n}\n\nfloat hash(float h) \n{\n  return fract(sin(h) * 43758.5453123);\n}\n\nfloat noise(vec3 x) \n{\n  vec3 p = floor(x);\n  vec3 f = fract(x);\n  f = f * f * (3.0 - 2.0 * f);\n\n  float n = p.x + p.y * 157.0 + 113.0 * p.z;\n  return -1.0+2.0*mix(\n    mix(mix(hash(n + 0.0), hash(n + 1.0), f.x), \n    mix(hash(n + 157.0), hash(n + 158.0), f.x), f.y), \n    mix(mix(hash(n + 113.0), hash(n + 114.0), f.x), \n    mix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\n\nfloat fbm(vec3 p) \n{\n  float f = 0.5000 * noise(p);\n  p *= 2.01;\n  f += 0.2500 * noise(p);\n  p *= 2.02;\n  f += 0.1250 * noise(p);\n  return f;\n}\n\nfloat noise2D( in vec2 pos, float lod)\n{   \n  vec2 f = fract(pos);\n  f = f*f*(3.0-2.0*f);\n  vec2 rg = textureLod( iChannel1, (((floor(pos).xy+vec2(37.0, 17.0)) + f.xy)+ 0.5)\/64.0, lod).yx;  \n  return -1.0+2.0*mix( rg.x, rg.y, 0.5 );\n}\nfloat noise2D( in vec2 pos )\n{\n  return noise2D(pos, 0.0);\n}\n\n\/\/ 3D noise function (IQ)\nfloat fastFBM(vec3 p)\n{\n  vec3 ip=floor(p);\n  p-=ip; \n  vec3 s=vec3(7, 157, 113);\n  vec4 h=vec4(0., s.yz, s.y+s.z)+dot(ip, s);\n  p=p*p*(3.-2.*p); \n  h=mix(fract(sin(h)*43758.5), fract(sin(h+s.x)*43758.5), p.x);\n  h.xy=mix(h.xz, h.yw, p.y);\n  return mix(h.x, h.y, p.z);\n}\nfloat fastFBMneg(vec3 p)\n{\n  return -1.0+2.0*fastFBM(p);\n}\nvec2 pModPolar(vec2 p, float repetitions) {\n  float angle = 2.*PI\/repetitions;\n  float a = atan(p.y, p.x) + angle\/2.;\n  float r = length(p);\n  float c = floor(a\/angle);\n  a = mod(a, angle) - angle\/2.;\n  p = vec2(cos(a), sin(a))*r;\n  if (abs(c) >= (repetitions\/2.)) c = abs(c);\n  return p;\n}\n\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)\/size);\n  p = mod(p+halfsize, size) - halfsize;\n  if (c > stop) {\n    p += size*(c - stop);\n    c = stop;\n  }\n  if (c <start) {\n    p += size*(c - start);\n    c = start;\n  }\n  return c;\n}\nfloat pMirror (inout float p, float dist) {\n  float s = sgn(p);\n  p = abs(p)-dist;\n  return s;\n}\n\nfloat fCylinder(vec3 p, float r, float height) {\n  float d = length(p.xy) - r;\n  d = max(d, abs(p.z) - height);\n  return d;\n}\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  return (length( p\/r.xyz ) - 1.0) * r.y;\n}\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.y-h.y, max((q.z*0.866025+q.x*0.5), q.x)-h.x);\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\nfloat fSphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat GetExplosionIntensity(Explosion ex)\n{\n  return mix(1., .0, smoothstep(0., 5.0, distance(ex.life, 5.)));\n}\n\nfloat NoTreeZone(vec3 p)\n{\n  float dist = distance(readRGB(ivec2(140, 0)).xz, p.xz);\n  dist = min(dist, distance(readRGB(ivec2(142, 0)).xz, p.xz));\n  dist = min(dist, distance(readRGB(ivec2(144, 0)).xz, p.xz));\n  dist = min(dist, distance(readRGB(ivec2(146, 0)).xz, p.xz));\n  dist = min(dist, distance(readRGB(ivec2(148, 0)).xz, p.xz));\n  return dist;\n}\nfloat GetTerrainHeight( vec3 p)\n{\n  vec2 p2 = (p.xz+planePos.xz)*0.0005;\n\n  float heightDecrease = mix(1.0, 0., smoothstep(0., 15.0, NoTreeZone(p+planePos)));\n\n  float mainHeight = -2.3+fastFBM((p+vec3(planePos.x, 0., planePos.z))*0.025)*max(11., abs(22.*noise2D(p2))); \n  mainHeight-=heightDecrease;\n\n  float terrainHeight=mainHeight;\n  p2*=4.0;\n  terrainHeight += textureLod( iChannel3, p2, 2.7 ).x*1.; \n  p2*=2.0;\n  terrainHeight -= textureLod( iChannel3, p2, 1.2 ).x*.7;\n  p2*=3.0;\n  terrainHeight -= textureLod( iChannel3, p2, 0.5 ).x*.1;\n\n  terrainHeight=mix(terrainHeight, mainHeight*1.4, smoothstep(1.5, 3.5, terrainHeight)); \n\n  return   terrainHeight;\n}\n\nfloat GetTreeHeight( vec3 p, float terrainHeight)\n{\n  if (NoTreeZone(p+planePos)<25.) return 0.;\n  float treeHeight = textureLod(iChannel3, (p.xz+planePos.xz)*0.006, .1).x;\n  float tree = mix(0., mix(0., mix(0., 2.0, smoothstep(0.3, 0.86, treeHeight)), smoothstep(1.5, 3.5, terrainHeight)), step(0.3, treeHeight)); \n  tree -= tree*0.75;\n  tree*=4.0;\n\n  return  tree;\n}\n\nfloat MapTerrainSimple( vec3 p)\n{\n  float terrainHeight = GetTerrainHeight(p);   \n  return  p.y - max((terrainHeight+GetTreeHeight(p, terrainHeight)), 0.);\n}\n\nfloat GetStoneHeight(vec3 p, float terrainHeight)\n{\n  return (textureLod(iChannel1, (p.xz+planePos.xz)*0.05, 0.).x*max(0., -0.3+(1.25*terrainHeight)));\n}\n\nfloat MapTerrain( vec3 p)\n{   \n  float terrainHeight = GetTerrainHeight(p);   \n  terrainHeight= mix(terrainHeight+GetStoneHeight(p, terrainHeight), terrainHeight, smoothstep(0., 1.5, terrainHeight));\n  terrainHeight= mix(terrainHeight+(textureLod(iChannel1, (p.xz+planePos.xz)*0.0015, 0.).x*max(0., -0.3+(.5*terrainHeight))), terrainHeight, smoothstep(1.2, 12.5, terrainHeight));\n\n  terrainHeight= mix(terrainHeight-0.30, terrainHeight, smoothstep(-0.5, 0.25, terrainHeight));\n  float water=0.;\n  if (terrainHeight<=0.)\n  {   \n    water = (-0.5+(0.5*(noise2D((p.xz+planePos.xz+ vec2(-iTime*0.4, iTime*0.25))*2.60, WATER_LOD))));\n    water*=(-0.5+(0.5*(noise2D((p.xz+planePos.xz+ vec2(iTime*.3, -iTime*0.25))*2.90), WATER_LOD)));\n  }\n  return   p.y -  max((terrainHeight+GetTreeHeight(p, terrainHeight)), -water*0.04);\n}\n\n\nfloat MapTree( vec3 p)\n{  \n  float terrainHeight = GetTerrainHeight(p);\n  float treeHeight =GetTreeHeight(p, terrainHeight);\n\n  \/\/ get terrain height at position and tree height onto that\n  return  p.y - terrainHeight-treeHeight;\n}\n\nvec3 calcTreeNormal( in vec3 pos )\n{    \n  return normalize( vec3(MapTree(pos+eps.xyy) - MapTree(pos-eps.xyy), 0.5*2.0*eps.x, MapTree(pos+eps.yyx) - MapTree(pos-eps.yyx) ) );\n}\n\nvec4 TraceTrees( vec3 origin, vec3 direction, int steps, float terrainHeight)\n{\n  vec4 treeCol =vec4(0.5, 0.5, 0.5, 0.0);\n  float intensity=0.0, t = .0, dist = 0.0;\n  vec3 rayPos, nn;\n  float precis=.0, dif =0.0, densAdd =.0;\n  float treeHeight = 0.0;\n  float td =.0;\n  for ( int i=0; i<steps; i++ )\n  {\n    rayPos = origin+direction*t;\n    treeHeight = GetTreeHeight(rayPos, terrainHeight);\n    dist = rayPos.y - (terrainHeight + treeHeight);  \n    precis = 0.015*t;\n\n    if (treeHeight>0.1 && dist<precis)\n    {\n      nn= calcTreeNormal(rayPos);  \n      dif = clamp( dot( nn, sunPos ), 0.0, 1.0 );\n\n      densAdd = (precis-dist)*3.0*td;\n      treeCol.rgb+=(0.5*td)*dif;\n      treeCol.a+=(1.-treeCol.a)*densAdd;\n    } \n    if (treeCol.a > 0.99) \n    {\n      break;\n    }\n    td = max(0.04, dist*0.5);\n    t+=td;\n  }\n\n  return clamp(treeCol, 0., 1.);\n}\n\n\nRayHit TraceTerrainReflection( vec3 origin, vec3 direction, int steps)\n{\n  RayHit result;\n  float precis = 0.0, maxDist = 100.0, t = 0.0, dist = 0.0;\n  vec3 rayPos;\n\n  for ( int i=0; i<steps; i++ )\n  {\n    rayPos =origin+direction*t; \n    dist = MapTerrainSimple( rayPos);\n    precis = 0.01*t;\n\n    if (dist<precis || t>maxDist )\n    {             \n      result.hit=!(t>maxDist);\n      result.depth = t; \n      result.dist = dist;                              \n      result.hitPos = origin+((direction*t));     \n      break;\n    }\n\n    t += dist*0.5;\n  }\n\n  return result;\n}\n\nRayHit TraceTerrain( vec3 origin, vec3 direction, int steps)\n{\n  RayHit result;\n  float precis = 0.0, maxDist = 400.0, t = 0.0, dist = 0.0;\n  vec3 rayPos;\n\n  for ( int i=0; i<steps; i++ )\n  {\n    rayPos =origin+direction*t; \n    dist = MapTerrain( rayPos);\n    precis = 0.001*t;\n\n    if (dist<precis || t>maxDist )\n    {             \n      result.hit=!(t>maxDist);\n      result.depth = t; \n      result.dist = dist;                              \n      result.hitPos = origin+((direction*t));     \n      break;\n    }\n\n    t += dist*0.5;\n  }\n\n  return result;\n}\n\nfloat SoftShadow( in vec3 origin, in vec3 direction )\n{\n  float res = 2.0, t = 0.0, h;\n  for ( int i=0; i<16; i++ )\n  {\n    h = MapTerrain(origin+direction*t);\n    res = min( res, 3.5*h\/t );\n    t += clamp( h, 0.02, 0.8);\n    if ( h<0.002 ) break;\n  }\n  return clamp( res, 0.0, 1.0 );\n}\n\n\nvec3 calcNormal( in vec3 pos )\n{    \n  return normalize( vec3(MapTerrain(pos+eps.xyy) - MapTerrain(pos-eps.xyy), 0.5*2.0*eps.x, MapTerrain(pos+eps.yyx) - MapTerrain(pos-eps.yyx) ) );\n}\n\nfloat GetCloudHeight(vec3 p)\n{    \n  vec3 p2 = (p+vec3(planePos.x, 0., planePos.z)+vec3(cloudPos.x, 0., cloudPos.y))*0.03;\n\n  float i  = (-0.3+noise(p2))*4.4; \n  p2*=2.52;\n  i +=abs(noise( p2 ))*1.7; \n  p2*=2.53;\n  i += noise( p2 )*1.; \n  p2*=2.51;\n  i += noise(p2 )*0.5;\n  p2*=4.22;\n  i += noise( p2)*0.2;\n  return i*3.;\n}\n\nfloat GetCloudHeightBelow(vec3 p)\n{    \n  vec3 p2 = (p+vec3(planePos.x, 0., planePos.z)+vec3(cloudPos.x, 0., cloudPos.y))*0.03;\n\n  float i  = (-0.3+noise(p2))*4.4; \n  p2*=2.52;\n  i +=noise( p2 )*1.7; \n  p2*=2.53;\n  i += noise( p2 )*1.; \n  p2*=2.51;\n  i += noise(p2 )*0.5;\n  p2*=3.42;\n  i += noise( p2)*0.2;\n  i*=0.5;\n  i-=0.25*i; \n\n  return i*5.;\n}\n\nfloat GetHorizon( vec3 p)\n{\n  return sdEllipsoid(p, vec3(1000., -CLOUDLEVEL, 1000.));\n}\n\nfloat MapCloud( vec3 p)\n{\n  return GetHorizon(p) - max(-3., (1.3*GetCloudHeight(p)));\n}\n\nvec4 TraceClouds( vec3 origin, vec3 direction, vec3 skyColor, int steps)\n{\n  vec4 cloudCol=vec4(skyColor*vec3(0.65, 0.69, 0.72)*1.3, 0.0);\n  cloudCol.rgb=mix(cloudCol.rgb, sunColor, 0.32);\n\n  float density = 0.0, t = .0, dist = 0.0;\n  vec3 rayPos;\n  float precis; \n  float td =.0;\n  float densAdd;\n  float sunDensity;\n  for ( int i=0; i<steps; i++ )\n  {\n    rayPos = origin+direction*t;\n    density = max(-5., 1.7+(GetCloudHeight(rayPos)*1.3));\n    dist = GetHorizon(rayPos)-(density);\n\n    precis = 0.01*t;\n    if (dist<precis && density>-5.1)\n    {    \n      sunDensity = MapCloud(rayPos+sunPos*3.);\n      densAdd =  mix(0., 0.5*(1.0-cloudCol.a), smoothstep(-5.1, 4.3, density));\n      cloudCol.rgb-=clamp((density-sunDensity), 0., 1.0)*0.06*sunColor*densAdd;\n      cloudCol.rgb += 0.003*max(0., sunDensity)*density*densAdd;\n      \n\n      cloudCol.a+=(1.-cloudCol.a)*densAdd;\n    } \n\n    if (cloudCol.a > 0.99) break; \n\n    td = max(0.12, dist*0.45);\n    t+=td;\n  }\n\n  \/\/ mix clouds color with sky color\n  float mixValue = smoothstep(100., 620., t);\n  cloudCol.rgb = mix(cloudCol.rgb, skyColor, mixValue);\n\n  return cloudCol;\n}\n\nvec4 TraceCloudsBelow( vec3 origin, vec3 direction, vec3 skyColor, int steps)\n{\n  vec4 cloudCol=vec4(vec3(0.95, 0.95, 0.98)*0.7, 0.0);\n  cloudCol.rgb=mix(cloudCol.rgb, sunColor, 0.2);\n\n  float density = 0.0, t = .0, dist = 0.0;\n  vec3 rayPos;\n  float precis; \n  float td =.0;\n  float energy=1.0;\n  float densAdd=0.;\n  float sunDensity;\n\n  for ( int i=0; i<steps; i++ )\n  {\n    rayPos = origin+direction*t;\n    density = clamp(GetCloudHeightBelow(rayPos), 0., 1.)*2.;          \n    dist = -GetHorizon(rayPos);\n\n    precis = 0.015*t;\n    if (dist<precis && density>0.001)\n    {    \n      densAdd = 0.14*density\/td;\n      sunDensity = clamp(GetCloudHeightBelow(rayPos+sunPos*3.), -0.6, 2.)*2.; \n      cloudCol.rgb-=sunDensity*0.02*cloudCol.a*densAdd; \n      cloudCol.a+=(1.-cloudCol.a)*densAdd;\n\n      cloudCol.rgb += 0.03*max(0., density-sunDensity)*densAdd;\n\n      cloudCol.rgb+=mix(vec3(0.), vec3(1.0, 1.0, 0.9)*0.013, energy)*sunColor;\n      energy*=0.96;\n    } \n\n    if (cloudCol.a > 0.99) break; \n\n    td = max(1.4, dist);\n    t+=td;\n  }\n    \n  \/\/ mix clouds color with sky color\n  cloudCol.rgb = mix(cloudCol.rgb, vec3(0.97), smoothstep(100., 960., t)); \n  cloudCol.a = mix(cloudCol.a, 0., smoothstep(0., 960., t));\n\n  return cloudCol;\n}\n\nfloat getTrailDensity( vec3 p)\n{\n  return noise(p*3.)*1.;\n}\n\nvoid TranslateMissilePos(inout vec3 p, Missile missile)\n{  \n  p = p-(missile.pos);  \n  p+=missile.origin;\n  pR(p.xz, missile.orientation.z);\n  pR(p.xy, -missile.orientation.x +PI);\n  p-=missile.origin;\n}\n\nvec2 MapSmokeTrail( vec3 p, Missile missile)\n{\n  TranslateMissilePos(p, missile);\n  float spreadDistance = 1.5;\n  p.z+=3.82;\n\n  \/\/ map trail by using mod op and ellipsoids\n  float s = pModInterval1(p.z, -spreadDistance, .0, min(12., (missile.pos.z-planePos.z)\/spreadDistance));     \n  float dist = sdEllipsoid(p+vec3(0.0, 0.0, .4), vec3(0.6, 0.6, 3.));   \n  dist-= getTrailDensity(p+vec3(10.*s))*0.25;\n\n  return vec2(dist, s);\n}\n\n\nvec4 TraceSmoketrail( vec3 origin, vec3 direction, int steps, Missile missile)\n{\n  vec4 trailCol =vec4(0.5, 0.5, 0.5, 0.0);\n  float height = 0.0, t = .0;\n  vec2 dist = vec2(0.0);\n  vec3 rayPos;\n  float precis; \n  float td =.0;\n  for ( int i=0; i<steps; i++ )\n  {\n    rayPos = origin+direction*t;\n    dist = MapSmokeTrail(rayPos, missile);  \n    precis = 0.002*t;\n    if (dist.x<precis)\n    {     \n      trailCol.rgb+=(0.5*(getTrailDensity(rayPos+sunPos*.17)))*0.03;\n\n      float densAdd =(precis-dist.x)*0.20;\n      trailCol.a+=(1.-trailCol.a)*densAdd\/(1.+(pow(dist.y, 2.0)*0.021));\n    } \n\n    if (trailCol.a > 0.99) break; \n\n    td = max(0.04, dist.x);\n    t+=td;\n  }\n\n  return clamp(trailCol, 0., 1.);\n}\n\n\nfloat MapExplosion( vec3 p, Explosion ex)\n{ \n  checkPos = (ex.pos)-vec3(planePos.x, 0., planePos.z); \n  checkPos=p-checkPos;\n\n  float testDist = fSphere(checkPos, 20.0);\n  if (testDist>10.)  return testDist;\n\n  float intensity =GetExplosionIntensity(ex);\n  float d= fSphere(checkPos, intensity*15.);  \n\n  \/\/ terrain clipping\n  #ifdef EXACT_EXPLOSIONS\n    d=max(d, -MapTerrain(p));\n  #else\n    d = max(d, -sdBox(checkPos+vec3(0., 50., 0.), vec3(50., 50.0, 50.0)));\n  #endif\n\n  \/\/ add explosion \"noise\/flames\"\n  float displace = fbm(((checkPos) + vec3(1, -2, -1)*iTime)*0.5);\n  return d + (displace * 1.5*max(0., 4.*intensity));\n}\n\n\nRayHit TraceExplosion(in vec3 origin, in vec3 direction, int steps, Explosion ex)\n{\n  RayHit result;\n  float precis = 0.0, maxDist = 350.0, t = 0.0, dist = 0.0;\n  vec3 rayPos;\n\n  for ( int i=0; i<steps; i++ )\n  {\n    rayPos =origin+direction*t; \n    dist = MapExplosion( rayPos, ex);\n    precis = 0.01*t;\n\n    if (dist<precis || t>maxDist )\n    {             \n      result.hit=!(t>maxDist);\n      result.depth = t; \n      result.dist = dist;                              \n      result.hitPos = origin+((direction*t));     \n      break;\n    }\n\n    t += dist*0.5;\n  }\n\n  return result;\n}\n\n\/\/ inspired by https:\/\/www.shadertoy.com\/view\/XdfGz8\nvec3 GetExplosionColor(float x)\n{\n  vec3 col1= vec3(240., 211., 167.)\/255.;\n  vec3 col2 = vec3(210., 90., 60.)\/255.;\n  vec3 col3 = vec3(84., 20., 13.)\/255.;\n\n  float t = fract(x*3.);\n  vec3 c= mix(col2, col3, t);\n  c= mix(mix(col1, col2, t), c, step(0.666, x));\n  return mix(mix(vec3(4, 4, 4), col1, t), c, step(0.333, x));\n}\n\nvec3 GetExplosionLight(float specLevel, vec3 normal, RayHit rayHit, vec3 rayDir, vec3 origin)\n{                \n  vec3 reflectDir = reflect( rayDir, normal );\n\n  vec3 lightTot = vec3(0.0);\n  float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );\n  float dif = clamp( dot( normal, sunPos ), 0.0, 1.0 );\n  float bac = clamp( dot( normal, normalize(vec3(-sunPos.x, 0.0, -sunPos.z)) ), 0.0, 1.0 ) * clamp(1.0-rayHit.hitPos.y\/20.0, 0.0, 1.0);\n\n  float fre = pow( clamp(1.0+dot(normal, rayDir), 0.0, 1.0), 2.0 );\n  specLevel*= pow(clamp( dot( reflectDir, sunPos ), 0.0, 1.0 ), 7.0);\n  float skylight = smoothstep( -0.1, 0.1, reflectDir.y );\n\n  lightTot += 1.5*dif*vec3(1.00, 0.90, 0.85);\n  lightTot += 0.50*skylight*vec3(0.40, 0.60, 0.95);\n  lightTot += 1.00*specLevel*vec3(0.9, 0.8, 0.7)*dif;\n  lightTot += 0.50*bac*vec3(0.25, 0.25, 0.25);\n  lightTot += 0.25*fre*vec3(1.00, 1.00, 1.00);\n\n  return clamp(lightTot, 0., 10.);\n}\n\n\nvoid DrawExplosion(int id, RayHit marchResult, inout vec3 color, vec3 rayDir, vec3 rayOrigin)\n{\n  Explosion explosion;\n  id *= 100;\n  explosion.life = read(ivec2(122+id, 0));\n\n  \/\/ check if explosion has been spawned\n  if (explosion.life>0.)\n  {  \n    explosion.pos = readRGB(ivec2(120+id, 0)); \n\n    vec3 testPoint = explosion.pos-planePos;\n    \/\/ ensure the explosions starts on ground\n    \/\/ explosion.pos.y=GetTerrainHeight(testPoint);\n\n    \/\/ explosion light flash    \n    if (marchResult.hit)\n    {\n      float intensity = GetExplosionIntensity(explosion);\n\n      vec3 testCol = color.rgb+vec3(1.0, 0.59, 0.28)*2.5;\n      color.rgb=mix(color.rgb, mix(testCol, color.rgb, smoothstep(0., 40.0*intensity, distance(testPoint.xz, marchResult.hitPos.xz))), intensity);\n    }\n\n    \/\/ trace explosion  \n    RayHit exploTest = TraceExplosion(rayOrigin, rayDir, 68, explosion);   \n    if (exploTest.hit)\n    {\n      color.rgb = GetExplosionColor(clamp(0.5+((fbm((exploTest.hitPos + vec3(1, -2, -1)*iTime)*0.5))), 0.0, 0.99));\n      color.rgb = mix(color.rgb, color.rgb*0.45, smoothstep(0., 12., distance(exploTest.hitPos.y, GetTerrainHeight(testPoint))));\n    }\n\n    color.rgb = mix(color.rgb*3.0, color.rgb, smoothstep(0., 12.4, exploTest.dist));\n  }\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n}\n\nfloat MapFlare( vec3 p, Missile missile)\n{\n  TranslateMissilePos(p, missile);\n  return sdEllipsoid( p+ vec3(0., 0., 2.4), vec3(.05, 0.05, .15));\n}\n\nfloat TraceEngineFlare(in vec3 origin, in vec3 direction, Missile missile)\n{\n  float t = 0.0;\n  vec3 rayPos = vec3(0.0);\n  float dist=10000.;\n\n  for ( int i=0; i<10; i++ )\n  {\n    rayPos =origin+direction*t;\n    dist = min(dist, MapFlare( rayPos, missile));\n    t += dist;\n  }\n\n  return dist;\n}\n\nfloat MapMissile(vec3 p, Missile missile)\n{\n  float d= fCylinder( p, 0.70, 1.7);\n  if (d<1.0)\n  {\n    d = fCylinder( p, 0.12, 1.2);   \n    d =min(d, sdEllipsoid( p- vec3(0, 0, 1.10), vec3(0.12, 0.12, 1.0))); \n\n    checkPos = p;  \n    pR(checkPos.xy, 0.785);\n    checkPos.xy = pModPolar(checkPos.xy, 4.0);\n\n    d=min(d, sdHexPrism( checkPos-vec3(0., 0., .60), vec2(0.50, 0.01)));\n    d=min(d, sdHexPrism( checkPos+vec3(0., 0., 1.03), vec2(0.50, 0.01)));\n    d = max(d, -sdBox(p+vec3(0., 0., 3.15), vec3(3.0, 3.0, 2.0)));\n    d = max(d, -fCylinder(p+vec3(0., 0., 2.15), 0.09, 1.2));\n  }\n  return d;\n}\n\nfloat MapFlyingMissile( vec3 p, Missile missile)\n{\n  TranslateMissilePos(p, missile);  \n  \/\/ map missile flame\n  eFlameDist = min(eFlameDist, sdEllipsoid( p+ vec3(0., 0., 2.2+cos(iTime*90.0)*0.23), vec3(.17, 0.17, 1.0)));\n  \/\/ map missile \n  return min(MapMissile(p, missile), eFlameDist);\n}\n\nRayHit TraceMissile(in vec3 origin, in vec3 direction, int steps, Missile missile)\n{\n  RayHit result;\n  float maxDist = 450.0;\n  float t = 0.0, glassDist = 0.0, dist = 100000.0;\n  vec3 rayPos;\n  eFlameDist=10000.0;\n  for ( int i=0; i<steps; i++ )\n  {\n    rayPos =origin+direction*t;\n    dist = MapFlyingMissile(rayPos, missile);\n\n    if (dist<0.01 || t>maxDist )\n    {                \n      result.hit=!(t>maxDist);\n      result.depth = t; \n      result.dist = dist;                              \n      result.hitPos = origin+((direction*t));   \n\n      result.eFlameDist = eFlameDist;\n      break;\n    }\n    t += dist;\n  }\n\n  return result;\n}\n\nfloat SoftShadowMissile( in vec3 origin, in vec3 direction, Missile missile )\n{\n  float res = 2.0, t = 0.02, h;\n  for ( int i=0; i<8; i++ )\n  {\n    h = MapMissile(origin+direction*t, missile);\n    res = min( res, 7.5*h\/t );\n    t += clamp( h, 0.05, 0.2 );\n    if ( h<0.001 || t>2.5 ) break;\n  }\n  return clamp( res, 0.0, 1.0 );\n}\n\nvec3 GetMissileLightning(float specLevel, vec3 normal, RayHit rayHit, vec3 rayDir, vec3 origin, Missile missile)\n{       \n  float dif = clamp( dot( normal, sunPos ), 0.0, 1.0 );\n  vec3 reflectDir = reflect( rayDir, normal );\n  specLevel= 3.5*pow(clamp( dot( reflectDir, sunPos ), 0.0, 1.0 ), 9.0\/3.);\n\n  float fre = pow( 1.0-abs(dot( normal, rayDir )), 2.0 );\n  fre = mix( .03, 1.0, fre );   \n  float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );\n\n  float shadow = SoftShadowMissile(origin+((rayDir*rayHit.depth)*0.998), sunPos, missile);\n  dif*=shadow;\n  float skyLight = smoothstep( -0.1, 0.1, reflectDir.y );\n\n  vec3 lightTot = (vec3(0.7)*amb); \n  lightTot+=vec3(0.85)*dif;\n  lightTot += 1.00*specLevel*dif;\n  lightTot += 0.80*skyLight*vec3(0.40, 0.60, 1.00);\n  lightTot= mix(lightTot*.7, lightTot*1.2, fre );\n\n  return lightTot*sunColor;\n}\n\nvec3 calcMissileNormal( in vec3 pos, Missile missile )\n{    \n  return normalize( vec3(MapFlyingMissile(pos+eps.xyy, missile) - MapFlyingMissile(pos-eps.xyy, missile), 0.5*2.0*eps.x, MapFlyingMissile(pos+eps.yyx, missile) - MapFlyingMissile(pos-eps.yyx, missile) ) );\n}\n\nmat3 setCamera(  vec3 ro, vec3 ta, float cr )\n{\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n  vec3 cu = normalize( cross(cw, cp) );\n  vec3 cv = normalize( cross(cu, cw) );\n  return mat3( cu, cv, cw );\n}\n\n\/\/ set sky color tone. 2 gradient passes using MIX.\nvec3 GetSkyColor(vec3 rayDir)\n{ \n  return mix(mix(vec3(0.15, 0.19, 0.24), vec3(220., 230., 240.0)\/255., smoothstep(1.0, .30, rayDir.y)), mix(vec3(229.0, 221., 230)\/200., sunColor, 0.15), smoothstep(0.15, -0.13, rayDir.y));\n}\n\n\/\/ scene lightning\nvec3 GetSceneLight(float specLevel, vec3 normal, RayHit rayHit, vec3 rayDir, vec3 origin)\n{                \n  vec3 reflectDir = reflect( rayDir, normal );\n\n  vec3 lightTot = vec3(0.0);\n  float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );\n  float dif = clamp( dot( normal, sunPos ), 0.0, 1.0 );\n  float bac = clamp( dot( normal, normalize(vec3(-sunPos.x, 0.0, -sunPos.z)) ), 0.0, 1.0 ) * clamp(1.0-rayHit.hitPos.y\/20.0, 0.0, 1.0);\n  ;\n  float fre = pow( clamp(1.0+dot(normal, rayDir), 0.0, 1.0), 2.0 );\n  specLevel*= pow(clamp( dot( reflectDir, sunPos ), 0.0, 1.0 ), 7.0);\n  float skylight = smoothstep( -0.1, 0.1, reflectDir.y );\n\n  float shadow=1.; \n  #ifdef SHADOWS\n    shadow = SoftShadow(origin+((rayDir*rayHit.depth)*0.988), sunPos);\n  #endif\n\n    lightTot += 1.5*dif*vec3(1.00, 0.90, 0.85)*shadow;\n  lightTot += 0.50*skylight*vec3(0.40, 0.60, 0.95);\n  lightTot += 1.00*specLevel*vec3(0.9, 0.8, 0.7)*dif;\n  lightTot += 0.50*bac*vec3(0.25, 0.25, 0.25);\n  lightTot += 0.25*fre*vec3(1.00, 1.00, 1.00)*shadow;\n\n  return clamp(lightTot, 0., 10.)*sunColor;\n}\n\nvec3 GetSceneLightWater(float specLevel, vec3 normal, RayHit rayHit, vec3 rayDir, vec3 origin)\n{                \n  vec3 reflectDir = reflect( rayDir, normal );\n  float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );\n  float dif = clamp( dot( normal, sunPos ), 0.0, 1.0 );\n  float bac = clamp( dot( normal, normalize(vec3(-sunPos.x, 0.0, -sunPos.z)) ), 0.0, 1.0 ) * clamp(1.0-rayHit.hitPos.y\/20.0, 0.0, 1.0);\n\n  specLevel*= pow(clamp( dot( reflectDir, sunPos ), 0.0, 1.0 ), 9.0);\n\n  float skylight = smoothstep( -0.1, 0.1, reflectDir.y );\n  float fre = pow( 1.0-abs(dot( normal, rayDir )), 4.0 );\n  fre = mix( .03, 1.0, fre );   \n\n  vec3 reflection = vec3(1.0);\n  vec3 lightTot = vec3(0.0);\n\n  lightTot += 1.15*dif*vec3(1.00, 0.90, 0.85);\n  lightTot += 1.00*specLevel*vec3(0.9, 0.8, 0.7)*dif;    \n  lightTot= mix(lightTot, reflection, fre );\n  lightTot += 0.70*skylight*vec3(0.70, 0.70, 0.85);\n  lightTot += 1.30*bac*vec3(0.25, 0.25, 0.25);\n  lightTot += 0.25*amb*vec3(0.80, 0.90, 0.95);  \n  return clamp(lightTot, 0., 10.);\n}\n\n\nvoid ApplyFog(inout vec3 color, vec3 skyColor, vec3 rayOrigin, vec3 rayDir, float depth)   \n{\n  float mixValue = smoothstep(50., 15000., pow(depth, 2.)*0.1);\n  float sunVisibility = max(0., dot(sunPos, rayDir));\n  \/\/ horizontal fog\n  vec3 fogColor = mix(sunColor*0.7, skyColor, mixValue);  \n  fogColor = mix(fogColor, sunColor, smoothstep(0., 1., sunVisibility));   \n  color = mix(color, fogColor, mixValue);\n\n  \/\/ vertical fog\n  float heightAmount = .01;\n  float fogAmount = 0.2 * exp(-rayOrigin.y*heightAmount) * (1.0-exp( -depth*rayDir.y*heightAmount ))\/rayDir.y;\n  color = mix(color, fogColor, fogAmount);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{  \n  vec2 mo = iMouse.xy\/iResolution.xy;\n  vec2 uv = fragCoord.xy \/ iResolution.xy;\n  vec2 screenSpace = (-iResolution.xy + 2.0*(fragCoord))\/iResolution.y;\n\n  \/\/ read plane data from buffer\n  turn = read(ivec2(1, 10));\n  float roll = read(ivec2(1, 1));\n  float speed = read(ivec2(10, 1));\n  float pitch = read(ivec2(15, 1));\n  sunPos =  readRGB(ivec2(50, 0));\n  planePos = readRGB(ivec2(55, 0));\n  float CAMZOOM = read(ivec2(52, 0));  \n\n  \/\/ setup camera and ray direction\n  vec2 camRot = readRGB(ivec2(57, 0)).xy;\n\n  cloudPos = vec2(-iTime*0.3, iTime*0.45);\n\n  vec3 rayOrigin = vec3(CAMZOOM*cos(camRot.x), planePos.y+CAMZOOM*sin(camRot.y), -3.+CAMZOOM*sin(camRot.x) );    \n  pR(rayOrigin.xz, -turn);\n  mat3 ca = setCamera( rayOrigin, vec3(0., planePos.y, -3. ), 0.0 );\n  vec3 rayDir = ca * normalize( vec3(screenSpace.xy, 2.0) );\n\n  \/\/ create sky color fade\n  vec3 skyColor = GetSkyColor(rayDir);\n  vec3 color = skyColor;\n  float alpha=0.;\n\n  RayHit marchResult = TraceTerrain(rayOrigin, rayDir, 1200);\n\n  \/\/ is terrain hit?\n  if (marchResult.hit)\n  { \n\n    alpha=1.0;\n    marchResult.normal = calcNormal(marchResult.hitPos);  \n\n    float specLevel=0.7;\n    color=vec3(0.5);\n\n    \/\/ create terrain texture\n    vec3 colorRocks= vec3(mix(texture(iChannel3, (marchResult.hitPos.xz+planePos.xz)*.01).rgb, texture(iChannel3, (marchResult.hitPos.xz+vec2(10000.0, 10000.0)+planePos.xz)*.01).rgb, fastFBM(marchResult.hitPos)));\n    color =colorRocks;\n    color.rgb = mix(color.rgb, color*3., abs(noise2D((marchResult.hitPos.xz+planePos.xz)*0.4, 1.0))); \n\n    \/\/ grass\n    color.rgb = mix(color.rgb, ((color+noise2D((marchResult.hitPos.xz+planePos.xz)*24., 1.0))+vec3(0.5, 0.4, .1))*0.3, smoothstep(0.2, 2.0, marchResult.hitPos.y)); \n\n    float stoneHeight = GetStoneHeight(marchResult.hitPos, (GetTerrainHeight(marchResult.hitPos)));     \n    color.rgb = mix(color.rgb, vec3(0.5+(noise(marchResult.hitPos+vec3(planePos.x, 0., planePos.z))*0.3)), smoothstep(1., .0, stoneHeight));\n    specLevel = mix(specLevel, specLevel*2.6, smoothstep(1., .0, stoneHeight));\n\n    \/\/ beach\n    color.rgb = mix((color+vec3(1.2, 1.1, 1.0))*0.5, color.rgb, smoothstep(0.3, 0.7, marchResult.hitPos.y)); \n\n\n    float burn = NoTreeZone(marchResult.hitPos+planePos);\n    color=mix(color*0.1, color, smoothstep(0., 25., burn));\n\n    \/\/ create slight wave difference between water and beach level\n    float wave = max(0., cos(abs(noise2D((marchResult.hitPos.xz+planePos.xz)))+(iTime*.5)+(length(marchResult.hitPos.xz)*0.03))*0.09);\n\n    vec3 light;\n    \/\/ check if terrain is below water level\n    if (marchResult.hitPos.y<0.3+wave)\n    {\n      vec3 terrainHit = rayOrigin+((rayDir*marchResult.depth)*0.998);\n      vec3 refDir = reflect(rayDir, marchResult.normal);\n      vec4 testClouds = TraceCloudsBelow(terrainHit, refDir, skyColor, 30);\n\n      color = vec3(0.3);\n\n      float sunVisibility = max(0., dot(sunPos, rayDir));\n\n      \/\/ calculate water fresnel  \n      float dotNormal = dot(rayDir, marchResult.normal);\n      float fresnel = pow(1.0-abs(dotNormal), 4.);  \n      vec3 rayRef = rayDir-marchResult.normal*dotNormal;\n\n      \/\/color.rgb  = mix(mix(vec3(1.0), (vec3(0.7)+sunColor)*1.50, smoothstep(150., 350.,marchResult.depth)), color.rgb, smoothstep(-TERRAINLEVEL-0.37, -TERRAINLEVEL+0.25, marchResult.hitPos.y));\n      color.rgb  = mix(color*.7, color.rgb, smoothstep(-3.0, -0.15, marchResult.hitPos.y));\n\n      color = color+(sunColor*pow(sunVisibility, 5.0));\n\n      \/\/ sea color\n      color = mix(mix(color, color+fresnel, fresnel ), color, smoothstep(-0.1, 0.15, marchResult.hitPos.y));\n\n      vec3 reflection = color;\n\n      #ifdef QUALITY_REFLECTIONS\n        \/\/ cast rays from water surface onto terrain. If terrain is hit, color water dark in these areas.\n        RayHit reflectResult = TraceTerrainReflection(terrainHit, refDir, 100); \n\n      if (reflectResult.hit==true)\n      {\n        reflection  = mix(color, vec3(.01, 0.03, .0), 0.9);\n      }\n      #endif\n        light = GetSceneLightWater(specLevel, marchResult.normal, marchResult, rayDir, rayOrigin);   \n      color=mix(mix(color.rgb, testClouds.rgb, testClouds.a*.26), mix(color.rgb, testClouds.rgb, testClouds.a), smoothstep(0., 0.7, fresnel)); \n      color=mix(mix(color.rgb, reflection, 0.5), reflection, smoothstep(0., 0.7, fresnel)); \n      color=mix(color, color+(0.5*fresnel), smoothstep(0., 0.3, fresnel)); \n\n      color=color*light;\n      color = mix(color, skyColor, smoothstep(320., 400., marchResult.depth));\n    } \n    \/\/ terrain is ABOVE water level  \n    else\n    {\n      \/\/ get lightning based on material\n      light = GetSceneLight(specLevel, marchResult.normal, marchResult, rayDir, rayOrigin);   \n\n      \/\/ apply lightning\n      color = color*light;\n\n      #ifdef QUALITY_TREE\n        \/\/ add trees\n        vec4 treeColor = TraceTrees(rayOrigin, rayDir, 28, marchResult.hitPos.y-0.3 );      \n      color =clamp( mix( color, treeColor.rgb*((noise2D((marchResult.hitPos.xz+planePos.xz)*36., 3.0)+vec3(0.56, 0.66, .45))*0.6)*sunColor*(.30+(0.6*light)), treeColor.a ), 0.02, 1.); \n      #endif\n    }\n\n    color = mix(color, (color+sunColor)*0.6, smoothstep(70., 300., marchResult.depth));\n    \/\/ add haze when high above ground  \n    color = mix(color, color+vec3(0.37, 0.58, 0.9)*sunColor, mix(0., 0.75, smoothstep(-CLOUDLEVEL*0.65, MAX_HEIGHT, planePos.y)));  \n    ApplyFog(color, skyColor, rayOrigin, rayDir, marchResult.depth);\n  } else\n  {\n    \/\/ add volumetric clouds \n    \/\/ below cloud level\n    if (rayOrigin.y<-CLOUDLEVEL && rayDir.y>0.)\n    {  \n      vec4 cloudColor=TraceCloudsBelow(rayOrigin, rayDir, skyColor, 60);    \n\n      \/\/ make clouds slightly light near the sun\n      float sunVisibility = pow(max(0., dot(sunPos, rayDir)), 2.0)*0.10;\n      color.rgb = mix(color.rgb, max(vec3(0.), cloudColor.rgb+sunVisibility), cloudColor.a);      \n      \/\/color.rgb = mix(color.rgb, cloudColor.rgb, cloudColor.a);       \n      alpha+=cloudColor.a*0.86;\n    }\n  }\n\n  \/\/ add volumetric clouds \n  \/\/ above cloud level\n  if (rayOrigin.y>=-CLOUDLEVEL)\n  {  \n    vec4 cloudColor=TraceClouds(rayOrigin, rayDir, skyColor, 80);    \n    color.rgb = mix(color.rgb, cloudColor.rgb, cloudColor.a);\n  }\n\n  rayDir = ca * normalize( vec3(screenSpace.xy, 2.0) );\n  DrawExplosion(0, marchResult, color, rayDir, rayOrigin);\n  DrawExplosion(1, marchResult, color, rayDir, rayOrigin);\n\n\n  \/\/ #################################################################### \/\/    \n  \/\/ ##############             MISSILES             #################### \/\/     \n  \/\/ #################################################################### \/\/    \n\n  rayOrigin = vec3(CAMZOOM*cos(camRot.x), CAMZOOM*sin(camRot.y), CAMZOOM*sin(camRot.x) );\n  pR(rayOrigin.xz, -turn);\n  ca = setCamera( rayOrigin, vec3(0., 0., 0. ), 0.0 );\n  rayDir = ca * normalize( vec3(screenSpace.xy, 2.0) );\n\n  int adressStep = 0;\n  Missile missile;\n  for (int i=0; i<2; i++)\n  {\n    adressStep = i*100;\n    missile.life = read(ivec2(100 + adressStep, 0));\n    \/\/ check if missile is launched\n    if (missile.life>0.)\n    {\n      missile.origin = vec3(4.8 - (9.6*float(i)), -0.4, -3.0);       \n      missile.orientation = readRGB(ivec2(108+adressStep, 0));\n      missile.pos = readRGB(ivec2(116+adressStep, 0));\n\n      \/\/ calculate engine flare\n      float lightDist = TraceEngineFlare(rayOrigin, rayDir, missile);\n\n      \/\/ add engine flares for missiles based on engine distance\n      vec3 lightFlares=vec3(0.);\n      lightFlares =  mix((vec3(1., 0.4, 0.2)), vec3(0.), smoothstep(0., 1.1, lightDist));             \n      lightFlares =  mix(lightFlares+(2.*vec3(1., 0.5, 0.2)), lightFlares, smoothstep(0., 0.7, lightDist));\n      lightFlares =  mix(lightFlares+vec3(1., 1., 1.), lightFlares, smoothstep(0., 0.2, lightDist));\n\n      \/\/ rayTrace missile\n      RayHit marchResult = TraceMissile(rayOrigin, rayDir, 64, missile);\n\n      \/\/ apply color and lightning to missile if hit in raymarch test    \n      if (marchResult.hit)\n      {\n        marchResult.normal = calcMissileNormal(marchResult.hitPos, missile);  \n\n        \/\/ create texture map and set specular levels\n        vec4 col = vec4(0.45, 0.45, 0.45, 0.8);\n\n        \/\/ flame\n        col.rgb=mix(col.rgb, vec3(1.2, .55, 0.30)*2.5, smoothstep(.16, 0., marchResult.eFlameDist));\n\n        \/\/ get lightning based on material\n        vec3 light = GetMissileLightning(col.a, marchResult.normal, marchResult, rayDir, rayOrigin, missile);   \n\n        \/\/ apply lightning\n        color.rgb = col.rgb*light;\n\n        alpha = 1.; \n\n        lightFlares = mix(lightFlares, vec3(.0), step(0.1, distance(marchResult.dist, marchResult.eFlameDist)));\n      }\n\n      color.rgb+=lightFlares;\n\n      \/\/draw smoke trail behind missile\n      vec4 trailColor = TraceSmoketrail(rayOrigin, rayDir, 48, missile);     \n      color.rgb = mix(color.rgb, trailColor.rgb, trailColor.a);\n      alpha+=trailColor.a;   \n\n      if (marchResult.hit) \n      { \n        break;\n      }\n    }\n  }\n  \/\/ #################################################################### \/\/\n  \/\/ #################################################################### \/\/\n\n  fragColor = vec4(color.rgb, min(1.0, alpha));\n}\n","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"XdXGzn","filepath":"\/media\/a\/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"\/media\/ap\/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3zn","filepath":"\/media\/a\/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"\/media\/ap\/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ PLANE BUFFER   -   RENDERS PLANE ONLY\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Channel 0 = Buffer B. Get the colors of the terrain buffer render.\n\/\/ Channel 1 = LowRes noise texture. Used in fast noise functions.\n\/\/ Channel 2 = Buffer A. Read data from data-buffer.\n\/\/ Channel 3 = Forest blurred cube map. Used in reflections in plane window and hull.\n\n  #pragma optimize(off) \n#define PI acos(-1.)\n  #define read(memPos) (  texelFetch(iChannel2, memPos, 0).a)\n  #define readRGB(memPos) (  texelFetch(iChannel2, memPos, 0).rgb)\n  #define RAYSTEPS 300\n  #define CLOUDLEVEL -70.0\n  float turn=0., pitch = 0., roll=0., rudderAngle = 0.;\nfloat speed = 0.5;\nvec3 checkPos=vec3(0.);\nvec3 sunPos=vec3(0.);\nconst vec3 sunColor = vec3(1.00, 0.90, 0.85);\nvec3 planePos=vec3(0.);\nconst vec3 eps = vec3(0.02, 0.0, 0.0);\n\nfloat winDist=10000.0;\nfloat engineDist=10000.0;\nfloat eFlameDist=10000.0;\nfloat blackDist=10000.0;\nfloat bombDist=10000.0;\nfloat bombDist2=10000.0;\nfloat missileDist=10000.0;\nfloat frontWingDist=10000.0;\nfloat rearWingDist=10000.0;\nfloat topWingDist=10000.0;\nvec2 missilesLaunched=vec2(0.);\n\nfloat sgn(float x) \n{   \n  return (x<0.)?-1.:1.;\n}\n\nstruct RayHit\n{\n  bool hit;  \n  vec3 hitPos;\n  vec3 normal;\n  float dist;\n  float depth;\n\n  float winDist;\n  float engineDist;\n  float eFlameDist;\n  float blackDist;\n  float bombDist;\n  float bombDist2;\n  float missileDist;\n  float frontWingDist;\n  float rearWingDist;\n  float topWingDist;\n};\n\nfloat noise2D( in vec2 pos, float lod)\n{   \n  vec2 f = fract(pos);\n  f = f*f*(3.0-2.0*f);\n  vec2 rg = textureLod( iChannel1, (((floor(pos).xy+vec2(37.0, 17.0)) + f.xy)+ 0.5)\/64.0, lod).yx;  \n  return -1.0+2.0*mix( rg.x, rg.y, 0.5 );\n}\nfloat noise2D( in vec2 pos )\n{\n  return noise2D(pos, 0.0);\n}\n\nfloat noise( in vec3 x )\n{\n  vec3 p = floor(x);\n  vec3 f = fract(x);\n\n  float a = textureLod( iChannel1, x.xy\/64.0 + (p.z+0.0)*120.7123, 0.1 ).x;\n  float b = textureLod( iChannel1, x.xy\/64.0 + (p.z+1.0)*120.7123, 0.1 ).x;\n  return mix( a, b, f.z );\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x, p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa, ba)\/dot(ba, ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  return (length( p\/r.xyz ) - 1.0) * r.y;\n}\n\nfloat sdConeSection( vec3 p, float h, float r1, float r2 )\n{\n  float d1 = -p.z - h;\n  float q = p.z - h;\n  float si = 0.5*(r1-r2)\/h;\n  float d2 = max( sqrt( dot(p.xy, p.xy)*(1.0-si*si)) + q*si - r2, q );\n  return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.);\n}\n\nfloat fCylinder(vec3 p, float r, float height) {\n  float d = length(p.xy) - r;\n  d = max(d, abs(p.z) - height);\n  return d;\n}\nfloat fSphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.y-h.y, max((q.z*0.866025+q.x*0.5), q.x)-h.x);\n}\n\nfloat fOpPipe(float a, float b, float r) {\n  return length(vec2(a, b)) - r;\n}\n\nvec2 pModPolar(vec2 p, float repetitions) {\n  float angle = 2.*PI\/repetitions;\n  float a = atan(p.y, p.x) + angle\/2.;\n  float r = length(p);\n  float c = floor(a\/angle);\n  a = mod(a, angle) - angle\/2.;\n  p = vec2(cos(a), sin(a))*r;\n  if (abs(c) >= (repetitions\/2.)) c = abs(c);\n  return p;\n}\n\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)\/size);\n  p = mod(p+halfsize, size) - halfsize;\n  if (c > stop) {\n    p += size*(c - stop);\n    c = stop;\n  }\n  if (c <start) {\n    p += size*(c - start);\n    c = start;\n  }\n  return c;\n}\n\nfloat pMirror (inout float p, float dist) {\n  float s = sgn(p);\n  p = abs(p)-dist;\n  return s;\n}\n\nmat2 r2(float r)\n{\n  float c=cos(r), s=sin(r);\n  return mat2(c, s, -s, c);\n}\n\n#define r3(r) mat2(sin(vec4(-1, 0, 0, 1)*acos(0.)+r))\n  void pR(inout vec2 p, float a) \n{\n  p*=r2(a);\n}\n\nfloat fOpUnionRound(float a, float b, float r) {\n  vec2 u = max(vec2(r - a, r - b), vec2(0));\n  return max(r, min (a, b)) - length(u);\n}\n\nfloat fOpIntersectionRound(float a, float b, float r) {\n  vec2 u = max(vec2(r + a, r + b), vec2(0));\n  return min(-r, max (a, b)) + length(u);\n}\n\n\/\/ limited by euler rotation. I wont get a good plane rotation without quaternions! :-(\nvec3 TranslatePos(vec3 p, float _pitch, float _roll)\n{\n  pR(p.xy, _roll-PI);\n  p.z+=5.;\n  pR(p.zy, _pitch);\n  p.z-=5.; \n  return p;\n}\n\nfloat MapEsmPod(vec3 p)\n{\n  float dist = fCylinder( p, 0.15, 1.0);   \n  checkPos =  p- vec3(0, 0, -1.0);\n  pModInterval1(checkPos.z, 2.0, .0, 1.0);\n  return min(dist, sdEllipsoid(checkPos, vec3(0.15, 0.15, .5)));\n}\n\nfloat MapMissile(vec3 p)\n{\n  float d= fCylinder( p, 0.70, 1.7);\n  if (d<1.0)\n  {\n    missileDist = min(missileDist, fCylinder( p, 0.12, 1.2));   \n    missileDist =min(missileDist, sdEllipsoid( p- vec3(0, 0, 1.10), vec3(0.12, 0.12, 1.0))); \n\n    checkPos = p;  \n    pR(checkPos.xy, 0.785);\n    checkPos.xy = pModPolar(checkPos.xy, 4.0);\n\n    missileDist=min(missileDist, sdHexPrism( checkPos-vec3(0., 0., .60), vec2(0.50, 0.01)));\n    missileDist=min(missileDist, sdHexPrism( checkPos+vec3(0., 0., 1.03), vec2(0.50, 0.01)));\n    missileDist = max(missileDist, -sdBox(p+vec3(0., 0., 3.15), vec3(3.0, 3.0, 2.0)));\n    missileDist = max(missileDist, -fCylinder(p+vec3(0., 0., 2.15), 0.09, 1.2));\n  }\n  return missileDist;\n}\n\nfloat MapFrontWing(vec3 p, float mirrored)\n{\n  missileDist=10000.0;\n\n  checkPos = p;\n  pR(checkPos.xy, -0.02);\n  float wing =sdBox( checkPos- vec3(4.50, 0.25, -4.6), vec3(3.75, 0.04, 2.6)); \n\n  if (wing<5.) \/\/Bounding Box test\n  {\n    \/\/ cutouts\n    checkPos = p-vec3(3.0, 0.3, -.30);\n    pR(checkPos.xz, -0.5);\n    wing=fOpIntersectionRound(wing, -sdBox( checkPos, vec3(6.75, 1.4, 2.0)), 0.1);\n\n    checkPos = p - vec3(8.0, 0.3, -8.80);\n    pR(checkPos.xz, -0.05);\n    wing=fOpIntersectionRound(wing, -sdBox( checkPos, vec3(10.75, 1.4, 2.0)), 0.1);\n\n    checkPos = p- vec3(9.5, 0.3, -8.50);\n    wing=fOpIntersectionRound(wing, -sdBox( checkPos, vec3(2.0, 1.4, 6.75)), 0.6);\n\n    \/\/ join wing and engine\n    wing=min(wing, sdCapsule(p- vec3(2.20, 0.3, -4.2), vec3(0, 0, -1.20), vec3(0, 0, 0.8), 0.04));\n    wing=min(wing, sdCapsule(p- vec3(3., 0.23, -4.2), vec3(0, 0, -1.20), vec3(0, 0, 0.5), 0.04));    \n\n    checkPos = p;\n    pR(checkPos.xz, -0.03);\n    wing=min(wing, sdConeSection(checkPos- vec3(0.70, -0.1, -4.52), 5.0, 0.25, 0.9));   \n\n    checkPos = p;\n    pR(checkPos.yz, 0.75);\n    wing=fOpIntersectionRound(wing, -sdBox( checkPos- vec3(3.0, -.5, 1.50), vec3(3.75, 3.4, 2.0)), 0.12); \n    pR(checkPos.yz, -1.95);\n    wing=fOpIntersectionRound(wing, -sdBox( checkPos- vec3(2.0, .70, 2.20), vec3(3.75, 3.4, 2.0)), 0.12); \n\n    checkPos = p- vec3(0.47, 0.0, -4.3);\n    pR(checkPos.yz, 1.57);\n    wing=min(wing, sdTorus(checkPos-vec3(0.0, -3., .0), vec2(.3, 0.05)));   \n\n    \/\/ flaps\n    wing =max(wing, -sdBox( p- vec3(3.565, 0.1, -6.4), vec3(1.50, 1.4, .5)));\n    wing =max(wing, -max(sdBox( p- vec3(5.065, 0.1, -8.4), vec3(0.90, 1.4, 2.5)), -sdBox( p- vec3(5.065, 0., -8.4), vec3(0.89, 1.4, 2.49))));\n\n    checkPos = p- vec3(3.565, 0.18, -6.20+0.30);\n    pR(checkPos.yz, -0.15+(0.8*pitch));\n    wing =min(wing, sdBox( checkPos+vec3(0.0, 0.0, 0.30), vec3(1.46, 0.007, 0.3)));\n\n    \/\/ missile holder\n    float holder = sdBox( p- vec3(3.8, -0.26, -4.70), vec3(0.04, 0.4, 0.8));\n\n    checkPos = p;\n    pR(checkPos.yz, 0.85);\n    holder=max(holder, -sdBox( checkPos- vec3(2.8, -1.8, -3.0), vec3(1.75, 1.4, 1.0))); \n    holder=max(holder, -sdBox( checkPos- vec3(2.8, -5.8, -3.0), vec3(1.75, 1.4, 1.0))); \n    holder =fOpUnionRound(holder, sdBox( p- vec3(3.8, -0.23, -4.70), vec3(1.0, 0.03, 0.5)), 0.1); \n\n    \/\/ bomb\n    bombDist = fCylinder( p- vec3(3.8, -0.8, -4.50), 0.35, 1.);   \n    bombDist =min(bombDist, sdEllipsoid( p- vec3(3.8, -0.8, -3.50), vec3(0.35, 0.35, 1.0)));   \n    bombDist =min(bombDist, sdEllipsoid( p- vec3(3.8, -0.8, -5.50), vec3(0.35, 0.35, 1.0)));   \n\n    \/\/ missiles\n    checkPos = p-vec3(2.9, -0.45, -4.50);\n\n    \/\/ check if any missile has been fired. If so, do NOT mod missile position  \n    float maxMissiles =0.; \n    if (mirrored>0.) maxMissiles =  mix(1.0, 0., step(1., missilesLaunched.x));\n    else maxMissiles =  mix(1.0, 0., step(1., missilesLaunched.y)); \n\n    pModInterval1(checkPos.x, 1.8, .0, maxMissiles);\n    holder = min(holder, MapMissile(checkPos));\n\n    \/\/ ESM Pod\n    holder = min(holder, MapEsmPod(p-vec3(7.2, 0.06, -5.68)));\n\n    \/\/ wheelholder\n    wing=min(wing, sdBox( p- vec3(0.6, -0.25, -3.8), vec3(0.8, 0.4, .50)));\n\n    wing=min(bombDist, min(wing, holder));\n  }\n\n  return wing;\n}\n\nfloat MapRearWing(vec3 p)\n{\n  float wing2 =sdBox( p- vec3(2.50, 0.1, -8.9), vec3(1.5, 0.017, 1.3)); \n  if (wing2<0.15) \/\/Bounding Box test\n  {\n    \/\/ cutouts\n    checkPos = p-vec3(3.0, 0.0, -5.9);\n    pR(checkPos.xz, -0.5);\n    wing2=fOpIntersectionRound(wing2, -sdBox( checkPos, vec3(6.75, 1.4, 2.0)), 0.2); \n\n    checkPos = p-vec3(0.0, 0.0, -4.9);\n    pR(checkPos.xz, -0.5);\n    wing2=fOpIntersectionRound(wing2, -sdBox( checkPos, vec3(3.3, 1.4, 1.70)), 0.2);\n\n    checkPos = p-vec3(3.0, 0.0, -11.70);\n    pR(checkPos.xz, -0.05);\n    wing2=fOpIntersectionRound(wing2, -sdBox( checkPos, vec3(6.75, 1.4, 2.0)), 0.1); \n\n    checkPos = p-vec3(4.30, 0.0, -11.80);\n    pR(checkPos.xz, 1.15);\n    wing2=fOpIntersectionRound(wing2, -sdBox( checkPos, vec3(6.75, 1.4, 2.0)), 0.1);\n  }\n  return wing2;\n} \n\nfloat MapTailFlap(vec3 p, float mirrored)\n{\n  p.z+=0.3;\n  pR(p.xz, rudderAngle*(-1.*mirrored)); \n  p.z-=0.3;\n\n  float tailFlap =sdBox(p- vec3(0., -0.04, -.42), vec3(0.025, .45, .30));\n\n  \/\/ tailFlap front cutout\n  checkPos = p- vec3(0., 0., 1.15);\n  pR(checkPos.yz, 1.32);\n  tailFlap=max(tailFlap, -sdBox( checkPos, vec3(.75, 1.41, 1.6)));\n\n  \/\/ tailFlap rear cutout\n  checkPos = p- vec3(0., 0, -2.75);  \n  pR(checkPos.yz, -0.15);\n  tailFlap=fOpIntersectionRound(tailFlap, -sdBox( checkPos, vec3(.75, 1.4, 2.0)), 0.05);\n\n  checkPos = p- vec3(0., 0., -.65);\n  tailFlap = min(tailFlap, sdEllipsoid( checkPos-vec3(0.00, 0.25, 0), vec3(0.06, 0.05, 0.15)));\n  tailFlap = min(tailFlap, sdEllipsoid( checkPos-vec3(0.00, 0.10, 0), vec3(0.06, 0.05, 0.15)));\n\n  return tailFlap;\n}\n\nfloat MapTopWing(vec3 p, float mirrored)\n{    \n  checkPos = p- vec3(1.15, 1.04, -8.5);\n  pR(checkPos.xy, -0.15);  \n  float topWing = sdBox( checkPos, vec3(0.014, 0.8, 1.2));\n  if (topWing<.15) \/\/Bounding Box test\n  {\n    float flapDist = MapTailFlap(checkPos, mirrored);\n\n    checkPos = p- vec3(1.15, 1.04, -8.5);\n    pR(checkPos.xy, -0.15);  \n    \/\/ top border    \n    topWing = min(topWing, sdBox( checkPos-vec3(0, 0.55, 0), vec3(0.04, 0.1, 1.25)));\n\n    float flapCutout = sdBox(checkPos- vec3(0., -0.04, -1.19), vec3(0.02, .45, 1.0));\n    \/\/ tailFlap front cutout\n    checkPos = p- vec3(1.15, 2., -7.65);\n    pR(checkPos.yz, 1.32);\n    flapCutout=max(flapCutout, -sdBox( checkPos, vec3(.75, 1.41, 1.6)));\n\n    \/\/ make hole for tail flap\n    topWing=max(topWing, -flapCutout);\n\n    \/\/ front cutouts\n    checkPos = p- vec3(1.15, 2., -7.);\n    pR(checkPos.yz, 1.02);\n    topWing=fOpIntersectionRound(topWing, -sdBox( checkPos, vec3(.75, 1.41, 1.6)), 0.05);\n\n    \/\/ rear cutout\n    checkPos = p- vec3(1.15, 1., -11.25);  \n    pR(checkPos.yz, -0.15);\n    topWing=fOpIntersectionRound(topWing, -sdBox( checkPos, vec3(.75, 1.4, 2.0)), 0.05);\n\n    \/\/ top roll \n    topWing=min(topWing, sdCapsule(p- vec3(1.26, 1.8, -8.84), vec3(0, 0, -.50), vec3(0, 0, 0.3), 0.06)); \n\n    topWing = min(topWing, flapDist);\n  }\n  return topWing;\n}\n\nfloat MapPlane( vec3 p)\n{\n  float  d=100000.0;\n  vec3 pOriginal = p;\n  \/\/ rotate position \n  p=TranslatePos(p, pitch, roll);\n  float mirrored=0.;\n  \/\/ AABB TEST  \n  float test = sdBox( p- vec3(0., -0., -3.), vec3(7.5, 4., 10.6));    \n  if (test>1.0) return test;\n\n  \/\/ mirror position at x=0.0. Both sides of the plane are equal.\n  mirrored = pMirror(p.x, 0.0);\n\n  float body= min(d, sdEllipsoid(p-vec3(0., 0.1, -4.40), vec3(0.50, 0.30, 2.)));\n  body=fOpUnionRound(body, sdEllipsoid(p-vec3(0., 0., .50), vec3(0.50, 0.40, 3.25)), 1.);\n  body=min(body, sdConeSection(p- vec3(0., 0., 3.8), 0.1, 0.15, 0.06));   \n\n  body=min(body, sdConeSection(p- vec3(0., 0., 3.8), 0.7, 0.07, 0.01));   \n\n  \/\/ window\n  winDist =sdEllipsoid(p-vec3(0., 0.3, -0.10), vec3(0.45, 0.4, 1.45));\n  winDist =fOpUnionRound(winDist, sdEllipsoid(p-vec3(0., 0.3, 0.60), vec3(0.3, 0.6, .75)), 0.4);\n  winDist = max(winDist, -body);\n  body = min(body, winDist);\n  body=min(body, fOpPipe(winDist, sdBox(p-vec3(0., 0., 1.0), vec3(3.0, 1., .01)), 0.03));\n  body=min(body, fOpPipe(winDist, sdBox(p-vec3(0., 0., .0), vec3(3.0, 1., .01)), 0.03));\n\n  \/\/ front (nose)\n  body=max(body, -max(fCylinder(p-vec3(0, 0, 2.5), .46, 0.04), -fCylinder(p-vec3(0, 0, 2.5), .35, 0.1)));\n  checkPos = p-vec3(0, 0, 2.5);\n  pR(checkPos.yz, 1.57);\n  body=fOpIntersectionRound(body, -sdTorus(checkPos+vec3(0, 0.80, 0), vec2(.6, 0.05)), 0.015);\n  body=fOpIntersectionRound(body, -sdTorus(checkPos+vec3(0, 2.30, 0), vec2(.62, 0.06)), 0.015);\n\n  \/\/ wings       \n  frontWingDist = MapFrontWing(p, mirrored);\n  d=min(d, frontWingDist);   \n  rearWingDist = MapRearWing(p);\n  d=min(d, rearWingDist);\n  topWingDist = MapTopWing(p, mirrored);\n  d=min(d, topWingDist);\n\n  \/\/ bottom\n  checkPos = p-vec3(0., -0.6, -5.0);\n  pR(checkPos.yz, 0.07);  \n  d=fOpUnionRound(d, sdBox(checkPos, vec3(0.5, 0.2, 3.1)), 0.40);\n\n  float holder = sdBox( p- vec3(0., -1.1, -4.30), vec3(0.08, 0.4, 0.8));  \n  checkPos = p;\n  pR(checkPos.yz, 0.85);\n  holder=max(holder, -sdBox( checkPos- vec3(0., -5.64, -2.8), vec3(1.75, 1.4, 1.0))); \n  d=fOpUnionRound(d, holder, 0.25);\n\n  \/\/ large bomb\n  bombDist2 = fCylinder( p- vec3(0., -1.6, -4.0), 0.45, 1.);   \n  bombDist2 =min(bombDist2, sdEllipsoid( p- vec3(0., -1.6, -3.20), vec3(0.45, 0.45, 2.)));   \n  bombDist2 =min(bombDist2, sdEllipsoid( p- vec3(0., -1.6, -4.80), vec3(0.45, 0.45, 2.)));   \n\n  d=min(d, bombDist2);\n\n  d=min(d, sdEllipsoid(p- vec3(1.05, 0.13, -8.4), vec3(0.11, 0.18, 1.0)));    \n\n  checkPos = p- vec3(0, 0.2, -5.0);\n  d=fOpUnionRound(d, fOpIntersectionRound(sdBox( checkPos, vec3(1.2, 0.14, 3.7)), -sdBox( checkPos, vec3(1., 1.14, 4.7)), 0.2), 0.25);\n\n  d=fOpUnionRound(d, sdEllipsoid( p- vec3(0, 0., -4.), vec3(1.21, 0.5, 2.50)), 0.75);\n\n  \/\/ engine cutout\n  blackDist = max(d, fCylinder(p- vec3(.8, -0.15, 0.), 0.5, 2.4)); \n  d=max(d, -fCylinder(p- vec3(.8, -0.15, 0.), 0.45, 2.4)); \n\n  \/\/ engine\n  d =max(d, -sdBox(p-vec3(0., 0, -9.5), vec3(1.5, 0.4, 0.7)));\n\n  engineDist=fCylinder(p- vec3(0.40, -0.1, -8.7), .42, 0.2);\n  checkPos = p- vec3(0.4, -0.1, -8.3);\n  pR(checkPos.yz, 1.57);\n  engineDist=min(engineDist, sdTorus(checkPos, vec2(.25, 0.25)));\n  engineDist=min(engineDist, sdConeSection(p- vec3(0.40, -0.1, -9.2), 0.3, .22, .36));\n\n  checkPos = p-vec3(0., 0., -9.24);  \n  checkPos.xy-=vec2(0.4, -0.1);\n  checkPos.xy = pModPolar(checkPos.xy, 22.0);\n\n  float engineCone = fOpPipe(engineDist, sdBox( checkPos, vec3(.6, 0.001, 0.26)), 0.015);\n  engineDist=min(engineDist, engineCone);\n\n  d=min(d, engineDist);\n  eFlameDist = sdEllipsoid( p- vec3(0.4, -0.1, -9.45-(speed*0.07)+cos(iTime*40.0)*0.014), vec3(.17, 0.17, .10));\n  d=min(d, eFlameDist);\n\n  d=min(d, winDist);\n  d=min(d, body);\n\n  d=min(d, sdBox( p- vec3(1.1, 0., -6.90), vec3(.33, .12, .17))); \n  checkPos = p-vec3(0.65, 0.55, -1.4);\n  pR(checkPos.yz, -0.35);\n  d=min(d, sdBox(checkPos, vec3(0.2, 0.1, 0.45)));\n\n  return min(d, eFlameDist);\n}\n\nRayHit TracePlane(in vec3 origin, in vec3 direction)\n{\n  RayHit result;\n  float maxDist = 150.0;\n  float t = 0.0, dist = 0.0;\n  vec3 rayPos;\n  eFlameDist=10000.0;\n  for ( int i=0; i<RAYSTEPS; i++ )\n  {\n    rayPos =origin+direction*t;\n    dist = MapPlane( rayPos);\n\n    if (abs(dist)<0.003 || t>maxDist )\n    {                \n      result.hit=!(t>maxDist);\n      result.depth = t; \n      result.dist = dist;                              \n      result.hitPos = origin+((direction*t));   \n      result.winDist = winDist;\n      result.engineDist = engineDist;\n      result.eFlameDist = eFlameDist;\n      result.blackDist = blackDist;\n      result.bombDist = bombDist;\n      result.bombDist2 = bombDist2;\n      result.missileDist = missileDist;\n      result.frontWingDist = frontWingDist;\n      result.rearWingDist = rearWingDist;\n      result.topWingDist = topWingDist;\n      break;\n    }\n    t += dist;\n  }\n\n  return result;\n}\n\nfloat MapLights( vec3 p)\n{\n  vec3 pOriginal = p;\n  \/\/ rotate position \n  p=TranslatePos(p, pitch, roll);   \n  \/\/ mirror position at x=0.0. Both sides of the plane are equal.\n  pMirror(p.x, 0.0);\n\n  return max(sdEllipsoid( p- vec3(0.4, -0.1, -9.5), vec3(0.03, 0.03, 0.03+max(0., (speed*0.07)))), -sdBox(p- vec3(0.4, -0.1, -9.6+2.0), vec3(2.0, 2.0, 2.0)));\n}\n\nfloat TraceLights(in vec3 origin, in vec3 direction)\n{\n  float maxDist = 150.0;\n  float t = 0.0;\n  vec3 rayPos;\n  float dist=10000.;\n\n  for ( int i=0; i<10; i++ )\n  {\n    rayPos =origin+direction*t;\n    dist = min(dist, MapLights( rayPos));\n    t += dist;\n  }\n\n  return dist;\n}\n\nvec3 calcNormal( in vec3 pos )\n{    \n  return normalize( vec3(MapPlane(pos+eps.xyy) - MapPlane(pos-eps.xyy), 0.5*2.0*eps.x, MapPlane(pos+eps.yyx) - MapPlane(pos-eps.yyx) ) );\n}\n\nfloat SoftShadow( in vec3 origin, in vec3 direction )\n{\n  float res = 2.0, t = 0.02, h;\n  for ( int i=0; i<24; i++ )\n  {\n    h = MapPlane(origin+direction*t);\n    res = min( res, 7.5*h\/t );\n    t += clamp( h, 0.05, 0.2 );\n    if ( h<0.001 || t>2.5 ) break;\n  }\n  return clamp( res, 0.0, 1.0 );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n  vec3 cu = normalize( cross(cw, cp) );\n  vec3 cv = normalize( cross(cu, cw) );\n  return mat3( cu, cv, cw );\n}\n\n\n\/\/ Advanced lightning pass\nvec3 GetSceneLight(float specLevel, vec3 normal, RayHit rayHit, vec3 rayDir, vec3 origin, float specSize)\n{          \n  float dif = clamp( dot( normal, sunPos ), 0.0, 1.0 );\n  vec3 reflectDir = reflect( rayDir, normal );\n  specLevel*= pow(clamp( dot( reflectDir, sunPos ), 0.0, 1.0 ), 9.0\/specSize);\n  vec3 reflection = vec3(texture(iChannel3, reflectDir ).r*1.5);\n\n  float fre = pow( 1.0-abs(dot( normal, rayDir )), 2.0 );\n  fre = mix( .03, 1.0, fre );   \n  float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );\n\n  vec3 shadowPos = origin+((rayDir*rayHit.depth)*0.998);\n\n  float shadow = SoftShadow(shadowPos, sunPos);\n  dif*=shadow;\n  float skyLight = smoothstep( -0.1, 0.1, reflectDir.y );\n  skyLight *= SoftShadow(shadowPos, reflectDir );\n\n  vec3 lightTot = (vec3(0.2)*amb); \n  lightTot+=vec3(0.85)*dif;\n  lightTot= mix(lightTot, reflection*max(0.3, shadow), fre );\n  lightTot += 1.00*specLevel*dif;\n  lightTot += 0.50*skyLight*vec3(0.40, 0.60, 1.00);\n  lightTot= mix(lightTot*.7, lightTot*1.2, fre );\n\n  fre = pow( 1.0-abs(dot(rayHit.normal, rayDir)), 4.0);\n  fre = mix(0., mix( .1, 1.0, specLevel*0.5), fre );\n  lightTot = mix( lightTot, lightTot+ vec3(1.6), fre );\n\n  return lightTot*sunColor;\n}\n\nfloat drawRect(vec2 p1, vec2 p2, vec2 uv) \n{\n  vec4 rect = vec4(p1, p2);\n  vec2 hv = step(rect.xy, uv) * step(uv, rect.zw);\n  return hv.x * hv.y;\n}\n\n\/\/ Thanks I\u00c3\u00b1igo Quilez!\nfloat line(vec2 p, vec2 a, vec2 b, float size)\n{\n  vec2 pa = -p - a;\n  vec2 ba = b - a;\n  float h = clamp( dot(pa, ba)\/dot(ba, ba), 0.0, 1.0 );\n  float d = length( pa - ba*h );\n\n  return clamp((((1.0+size) - d)-0.99)*100.0, 0.0, 1.0);\n}\n\nvoid AddLetters(vec2 hitPos, inout vec3 col, vec2 linePos)\n{\n  \/\/ text\n  vec3 textColor = vec3(0.2);\n  vec2 absHitPos2 = vec2(hitPos.x-1.05, hitPos.y);\n\n  pModInterval1(absHitPos2.x, 8., linePos.x, linePos.x+10.);\n\n  \/\/ E\n  col =mix(col, textColor, line(absHitPos2, linePos+vec2(1.45, 0.4), linePos+vec2(1.45, .9), 0.06));\n  col =mix(col, textColor, line(absHitPos2, linePos+vec2(1.45, 0.9), linePos+vec2(1.1, .9), 0.06));\n  col =mix(col, textColor, line(absHitPos2, linePos+vec2(1.45, 0.65), linePos+vec2(1.25, 0.65), 0.06));\n  col =mix(col, textColor, line(absHitPos2, linePos+vec2(1.45, 0.4), linePos+vec2(1.1, .4), 0.06));\n  \/\/ F            \n  col =mix(col, textColor, line(absHitPos2, linePos+vec2(0.9, 0.4), linePos+vec2(0.9, .9), 0.06));\n  col =mix(col, textColor, line(absHitPos2, linePos+vec2(0.9, 0.9), linePos+vec2(.65, .9), 0.06));\n  col =mix(col, textColor, line(absHitPos2, linePos+vec2(0.9, 0.65), linePos+vec2(.75, 0.65), 0.06));\n  \/\/ Z\n  col =mix(col, textColor, line(absHitPos2, linePos+vec2(0.45, 0.4), linePos+vec2(.1, 0.9), 0.06));\n  col =mix(col, textColor, line(absHitPos2, linePos+vec2(0.45, 0.9), linePos+vec2(.1, 0.9), 0.06));\n  col =mix(col, textColor, line(absHitPos2, linePos+vec2(0.45, 0.4), linePos+vec2(.1, 0.4), 0.06));\n}\n\n\nvec3 GetReflectionMap(vec3 rayDir, vec3 normal)\n{\n  return texture(iChannel3, reflect( rayDir, normal )).rgb;\n}\n\nvec4 GetMaterial(vec3 rayDir, inout RayHit rayHit, vec2 fragCoord, inout float specSize)\n{\n  vec3 hitPos =TranslatePos(rayHit.hitPos, pitch, roll);\n  vec2 center;\n  float dist;\n\n  float specLevel=0.7;\n  specSize=0.7;\n\n  float fre = pow( 1.0-abs(dot( rayHit.normal, rayDir )), 3.0 );\n  fre = mix( .03, 1.0, fre );   \n\n  \/\/ vec3 tint = vec3(0.62,.50,0.40)*1.15;\n  vec3 tint = vec3(1.62, 1.50, 1.30)*0.65;\n  vec3 brightCamo =1.15*tint;\n  vec3 darkCamo = 0.78*tint;\n\n\n  vec3 baseTexture = mix(brightCamo, darkCamo, smoothstep(0.5, 0.52, noise(hitPos*1.6)));\n\n  \/\/ baseTexture = col;\n  vec3 col=mix(brightCamo, darkCamo, smoothstep(0.5, 0.52, noise(hitPos*1.6)));\n  vec3 reflection = GetReflectionMap(rayDir, rayHit.normal);\n  \/\/ create base color mixes\n  vec3 lightColor = (vec3(1.0));\n  vec3 darkColor = (vec3(0.25));\n  vec3 missilBaseCol =  lightColor*0.5;\n  vec3 missilBaseCol2 =  darkColor;\n  vec3 missilCol = lightColor;\n  vec3 missilCol2 = lightColor*0.27;\n\n  if (distance(rayHit.dist, rayHit.topWingDist)<.01)\n  { \n    \/\/ top wing stripes\n    col=mix(darkColor, baseTexture, smoothstep(0.55, 0.57, distance(0.85, hitPos.y)));\n    col=mix(lightColor, col, smoothstep(.32, 0.34, distance(0.95, hitPos.y)));\n\n    \/\/ create star (top wings)    \n    center = vec2(-8.73, 0.95)-vec2(hitPos.z, hitPos.y);\n    dist = length(center); \n    col=mix(darkColor, col, smoothstep(0.24, 0.26, dist));\n    col=mix(lightColor, col, smoothstep(0.24, 0.26, (dist*1.15)+abs(cos( atan(center.y, center.x)*2.5)*0.13)));\n  } else if (distance(rayHit.dist, rayHit.winDist)<.01)\n  { \n    \/\/ windows\n    col=vec3(0.2, 0.21, 0.22)*reflection;\n    specSize=3.2;\n    specLevel=3.5;\n    fre = pow( 1.0-abs(dot(rayHit.normal, rayDir)), 3.0);\n    fre = mix( mix( .0, .01, specLevel ), mix( .4, 1.0, specLevel ), fre );\n    col = mix(col, vec3(1.5), fre );\n  } else if (distance(rayHit.dist, rayHit.missileDist)<.01)\n  {  \n    specSize=2.;\n    specLevel=2.;\n    \/\/ small missiles\n    col=mix(missilBaseCol, missilCol2, smoothstep(-3.35, -3.37, hitPos.z));\n    col=mix(col, missilCol, smoothstep(-3.2, -3.22, hitPos.z));\n    col=mix(missilCol2, col, smoothstep(.32, 0.34, distance(-4.75, hitPos.z)));\n    col=mix(missilBaseCol, col, smoothstep(.25, 0.27, distance(-4.75, hitPos.z)));\n  } else if (distance(rayHit.dist, rayHit.bombDist)<.01)\n  { \n    specSize=2.;\n    specLevel=1.7;\n    \/\/ small bombs   \n    col=mix(missilCol, missilBaseCol, smoothstep(1.18, 1.2, distance(-4.5, hitPos.z)));      \n    col=mix(col, missilCol2, smoothstep(1.3, 1.32, distance(-4.5, hitPos.z)));\n  } else if (distance(rayHit.dist, rayHit.bombDist2)<.01)\n  {   \n    specSize=2.;\n    specLevel=1.8;\n    \/\/ large bomb  \n    col=mix(missilBaseCol2, missilCol, smoothstep(1.48, 1.5, distance(-4.1, hitPos.z)));      \n    col=mix(col, missilBaseCol, smoothstep(1.6, 1.62, distance(-4.1, hitPos.z)));      \n    col=mix(missilBaseCol, col, smoothstep(0.45, 0.47, distance(-4.1, hitPos.z)));\n  } else\n  {\n    \/\/ remove camo from wing tip\n    col =mix(col, brightCamo, line(vec2(abs(hitPos.x), hitPos.z), vec2(-7.25, 5.), vec2(-1.45, 1.7), 0.3));\n\n    \/\/ color bottom gray\n    col=mix(lightColor*0.7, col, step(0.01, hitPos.y));\n\n    \/\/ front\n    col = mix(col, lightColor, smoothstep(3.0, 3.02, hitPos.z));  \n    col = mix(col, darkColor, smoothstep(3.08, 3.1, hitPos.z));\n    col =mix(col*1.4, col, smoothstep(.07, .09, distance(1.8, hitPos.z)));\n\n\n    \/\/ front wing stripes\n    col=mix(darkColor, col, smoothstep(1.4, 1.42, distance(-6.90, hitPos.z)));\n    col=mix(lightColor, col, smoothstep(1.3, 1.32, distance(-6.90, hitPos.z)));\n    col=mix(darkColor, col, smoothstep(.84, 0.86, distance(-6.7, hitPos.z)));\n    col=mix(lightColor, col, smoothstep(.22, 0.235, distance(-6.94, hitPos.z)));\n\n    \/\/ vertical stripes   \n    float xMod = mod(hitPos.x-0.5, 11.0);\n    col=mix(darkColor, col, smoothstep(0.5, 0.52, distance(5., xMod)));\n    col=mix(lightColor, col, smoothstep(0.4, 0.42, distance(5., xMod)));\n\n\n    \/\/ boxes \n    vec2 absHitPos = abs(hitPos.xz);\n\n    col =mix(col, col*1.40, drawRect(vec2(0.4, 2.0)-0.05, vec2(0.8, 2.0)+0.05+0.25, absHitPos));\n    col =mix(col, col*0.2, drawRect(vec2(0.4, 2.0), vec2(0.8, 2.0)+0.2, absHitPos));\n\n    \/\/ side 17      \n    vec2 linePos = vec2(-0.55, 0.);\n    vec3 textColor = vec3(0.2);\n    if (hitPos.x<0.)\n    {\n      col =mix(col, textColor, line(hitPos.zy, linePos+vec2(0., -0.2), linePos+vec2(0., .2), 0.04));\n      col =mix(col, textColor, line(hitPos.zy, linePos+vec2(-0.2, -0.2), linePos+vec2(-.4, -.2), 0.04));\n      col =mix(col, textColor, line(hitPos.zy, linePos+vec2(-0.4, -0.2), linePos+vec2(-.25, .2), 0.04));\n    } else\n    {\n      col =mix(col, textColor, line(hitPos.zy, linePos+vec2(-0.35, -0.2), linePos+vec2(-0.35, .2), 0.04));\n      col =mix(col, textColor, line(hitPos.zy, linePos+vec2(0.1, -0.2), linePos+vec2(-.15, -.2), 0.04));\n      col =mix(col, textColor, line(hitPos.zy, linePos+vec2(-0.15, 0.2), linePos+vec2(.10, -.2), 0.04));\n    }  \n\n    if (hitPos.y>0.15)\n    {\n      \/\/ letters BoundingBox\n      if (drawRect(vec2(3.2, 3.8)-0.05, vec2(4.9, 4.8), absHitPos)>=1.)\n      {\n        AddLetters(hitPos.xz, col, vec2(-3.70, 3.60));\n      }\n\n      \/\/ more boxes \n      col =mix(col, col*1.40, drawRect(vec2(0.2, 3.6)-0.05, vec2(1., 3.6)+0.05+0.35, absHitPos)); \n      col =mix(col, col*0.2, drawRect(vec2(0.2, 3.6), vec2(1., 3.6)+0.3, absHitPos));          \n      col =mix(col, col*0.2, drawRect(vec2(3.5, 4.8), vec2(4.5, 5.3), absHitPos));\n\n      \/\/ create star (front wings)         \n      center = vec2(5., -5.1)-vec2(xMod, hitPos.z);\n      dist = length(center);\n      col=mix(lightColor, col, smoothstep(0.8, 0.82, dist));\n      col=mix(darkColor, col, smoothstep(0.7, 0.72, dist));\n      col=mix(lightColor, col, smoothstep(0.7, 0.72, (dist*1.15)+abs(cos( atan(center.y, center.x)*2.5)*0.3)));\n      col=mix(darkColor, col, smoothstep(0.6, 0.62, (dist*1.50)+abs(cos( atan(center.y, center.x)*2.5)*0.3)));\n    } else\n    {\n      \/\/ bottom details\n      col =mix(col, darkColor, line(vec2(abs(hitPos.x), hitPos.z), vec2(0., -1.5), vec2(-0.3, -1.5), 0.06));\n      col =mix(col, darkColor, line(vec2(abs(hitPos.x), hitPos.z), vec2(-0.3, -1.5), vec2(-0.3, -1.), 0.085));\n    }\n\n    \/\/ rear wing stripes\n    col=mix(darkColor, col, smoothstep(.55, 0.57, distance(-9.6, hitPos.z)));\n    col=mix(lightColor, col, smoothstep(.5, 0.52, distance(-9.6, hitPos.z)));\n    col=mix(darkColor, col, smoothstep(.4, 0.42, distance(-9.6, hitPos.z)));\n\n    \/\/ esm pods\n    col = mix(col, lightColor*0.75, smoothstep(7.02, 7.04, abs(hitPos.x)));\n\n    \/\/ stabilizer\n    col = mix(col, lightColor*0.75, smoothstep(1.72, 1.74, abs(hitPos.y)));\n\n    \/\/ engines exhaust\n    col=mix(mix(vec3(0.7), reflection, fre), col, step(.05, rayHit.engineDist));\n    specSize=mix(4., specSize, step(.05, rayHit.engineDist));\n    col=mix(col*0.23, col, step(.02, rayHit.blackDist));\n    col=mix(col+0.5, col, smoothstep(.04, 0.10, distance(2.75, hitPos.z)));\n  }\n  fre = pow( 1.0-abs(dot(rayHit.normal, rayDir)), 7.0);\n  fre = mix( 0., mix( .2, 1.0, specLevel*0.5 ), fre );\n  col = mix( col, vec3(1.0, 1.0, 1.1)*1.5, fre );\n\n  return vec4(col, specLevel);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n  vec2 mo = iMouse.xy\/iResolution.xy;\n  vec2 uv = fragCoord.xy \/ iResolution.xy;\n  vec2 screenSpace = (-iResolution.xy + 2.0*(fragCoord))\/iResolution.y;\n  vec2 cloudPos = vec2(-iTime*1.3, -iTime*.95);\n  float CAMZOOM = read(ivec2(52, 0));  \n\n  \/\/ read missile data\n  missilesLaunched = vec2(read(ivec2(100, 0)), read(ivec2(200, 0)));\n\n  \/\/ read roll and speed values from buffer\n  turn = read(ivec2(1, 10));\n  roll = read(ivec2(1, 1));\n  speed = read(ivec2(10, 1));\n  pitch = read(ivec2(15, 1));\n  rudderAngle = read(ivec2(6, 1));\n  sunPos = readRGB(ivec2(50, 0));\n  planePos = readRGB(ivec2(55, 0));\n  pR(sunPos.xz, turn);\n\n  \/\/ setup camera and ray direction\n  vec2 camRot = readRGB(ivec2(57, 0)).xy;\n\n  vec3 rayOrigin = vec3(CAMZOOM*cos(camRot.x), CAMZOOM*sin(camRot.y), -3.+CAMZOOM*sin(camRot.x) );\n  mat3 ca = setCamera( rayOrigin, vec3(0., 0., -3. ), 0.0 );\n  vec3 rayDir = ca * normalize( vec3(screenSpace.xy, 2.0) );\n\n  \/\/ load background from buffer A\n  vec4 color =  texture(iChannel0, uv);\n\n  \/\/ calculate engine flare\n  float lightDist = TraceLights(rayOrigin, rayDir);\n    \n  vec3 lightFlares = vec3(0.);\n  lightFlares =  mix((vec3(1., 0.4, 0.2)), vec3(0.), smoothstep(0., .35, lightDist));             \n  lightFlares =  mix(lightFlares+(2.*vec3(1., 0.5, 0.2)), lightFlares, smoothstep(0., 0.15, lightDist));\n  lightFlares =  mix(lightFlares+vec3(1., 1., 1.), lightFlares, smoothstep(0., 0.08, lightDist));\n  RayHit marchResult = TracePlane(rayOrigin, rayDir);\n\n  if (marchResult.hit)\n  {\n    float specSize=1.0;\n\n    marchResult.normal = calcNormal(marchResult.hitPos); \n\n    \/\/ create texture map and set specular levels\n    color = GetMaterial(rayDir, marchResult, fragCoord, specSize);\n\n    if (marchResult.dist != marchResult.eFlameDist)\n    {\n      \/\/ get lightning based on material\n      vec3 light = GetSceneLight(color.a, marchResult.normal, marchResult, rayDir, rayOrigin, specSize);   \n\n      \/\/ cloud shadows on plane if below cloud level\n      if (planePos.y<=-CLOUDLEVEL)\n      {  \n        \/\/ get cloud shadows at rayMarch hitpos\n        float clouds =clamp(max(0., -0.15+noise(marchResult.hitPos+planePos+vec3(cloudPos.x, 0., cloudPos.y))), 0., 1.)*.5;\n\n        color.rgb*= 1.0-clouds;\n        \/\/ sun light  \n        color.rgb*= 1.+(clouds);\n      }   \n\n      \/\/ apply lightning\n      color.rgb *=light;\n\n      \/\/ balance colors\n      color.rgb = pow(color.rgb, vec3(1.0\/1.1));\n    }\n\n    color.rgb = mix(color.rgb, vec3(0.3, 0.5, 0.7), 0.1);    \n    color.a=1.0;  \n\n    lightFlares = mix(lightFlares, lightFlares*0., step(0.1, distance(marchResult.dist, marchResult.eFlameDist)));\n  }\n\n  color.rgb+=lightFlares;\n  fragColor = color;\n}\n","name":"Buf C","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"ldd3DX","date":"1542803894","viewed":42559,"name":"Surfer Boy","username":"iq","description":"A surfer boy in the beach, in pixar style unapologetically. I had to compromise quality so it would compile in my CPU, and had to model and paint it to camera. I took out the animation. If you have a slow PC: https:\/\/www.youtube.com\/watch?v=ya3FRzuozQ0","likes":199,"published":3,"flags":32,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"\/\/ Copyright Inigo Quilez, 2018 - https:\/\/iquilezles.org\/\n\/\/ I am the sole copyright owner of this Work.\n\/\/ You cannot host, display, distribute or share this Work in any form,\n\/\/ including physical and digital. You cannot use this Work in any\n\/\/ commercial or non-commercial product, website or project. You cannot\n\/\/ sell this Work and you cannot mint an NFTs of it.\n\/\/ I share this Work for educational purposes, and you can link to it,\n\/\/ through an URL, proper attribution and unmodified screenshot, as part\n\/\/ of your educational material. If these conditions are too restrictive\n\/\/ please contact me and we'll definitely work it out.\n\n\n\/\/ A surfer boy in the beach, disney\/pixar style. I had to be very careful\n\/\/ with the complexity, otherwise the browser would crash during shader\n\/\/ compilation. I also had to split the boy in two layers because of that,\n\/\/ see below (the single pass version is smaller of course but takes 3 extra\n\/\/ seconds to compile, and renders a bit more slowly)\n\/\/\n\/\/ This is totally painted to camera, it won't work from others perspectives.\n\/\/\n\/\/ Common   - contains some basic stuff\n\/\/ Buffer A - renders the brackground - not super polished really\n\/\/ Buffer B - blurs the background\n\/\/ Buffer C - paints the boy, except the hand and the board\n\/\/ Image    - paints the hand and the board, and does some minimal postpro\n\/\/\n\/\/ If you have a slow PC, you can watch it here: https:\/\/www.youtube.com\/watch?v=ya3FRzuozQ0\n\n\n\/\/ hands and board\nvec3 map( vec3 p )\n{\n    \/\/ hands\n    float d = 1.0;\n\tif( p.x<-0.8 && p.y<-0.1)\n\t{\n\t\tvec3 hp = p - vec3(-0.9,-0.30,0.12);\n\n\t\thp.z *= 1.2;\n\t\t\n\t\tfloat ss = sign(hp.y+0.05);\n\n\t\tvec4 a1 = vec4(-0.030+0.010*ss, -0.050 +0.050 *ss, 0.06, 0.0225);\n\t\tvec4 b1 = vec4(-0.070+0.010*ss, -0.049 +0.051 *ss, 0.05, 0.024);\n\t\tvec4 c1 = vec4(-0.145+0.015*ss, -0.0465+0.0535*ss, 0.01, 0.027);\n\t\tvec4 d1 = vec4(-0.12,           -0.0465+0.0535*ss,-0.06, 0.030);\n\t\tvec3 u1 = vec3(-0.0290+0.011*ss,-0.05  +0.05  *ss, 0.08);\n\t\tvec3 v1 = vec3(-0.0185,         -0.05  +0.05  *ss, 0.08);\n\n\t\tfloat dd =     sdCapsule( hp, a1, b1 ).x;\n\t\tdd = smin( dd, sdCapsule( hp, b1, c1 ).x, 0.005 );\n\t\tdd = smin( dd, sdCapsule( hp, c1, d1 ).x, 0.005 );\n\t\tdd = smax( dd,-sdCapsule( hp, u1, v1, 0.021 ),0.005);\n\t\td = min( d, dd\/1.2 );\n\t\t\n\t\tss = sign(hp.y+0.1);\n\t\t\n\t\tif( hp.y>-0.1 )\n\t\t{\n\t\t\tconst vec4 a2 = vec4(-0.02,-0.050, 0.06, 0.024);\n\t\t\tconst vec4 b2 = vec4(-0.06,-0.050, 0.05, 0.0256);\n\t\t\tconst vec4 c2 = vec4(-0.15,-0.050, 0.01, 0.0288);\n\t\t\tconst vec4 d2 = vec4(-0.13,-0.050,-0.06, 0.032);\n\t\t\tconst vec3 u2 = vec3(-0.018,-0.05,0.08);\n\t\t\tconst vec3 v2 = vec3(-0.017,-0.05,0.08);\n\n\t\t\tdd =           sdCapsule( hp, a2, b2 ).x;\n\t\t\tdd = smin( dd, sdCapsule( hp, b2, c2 ).x, 0.005 );\n\t\t\tdd = smin( dd, sdCapsule( hp, c2, d2 ).x, 0.005 );\n\t\t\tdd = smax( dd,-sdCapsule( hp, u2, v2, 0.021 ),0.005);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst vec4 a2 = vec4(-0.07,-0.145, 0.06, 0.021);\n\t\t\tconst vec4 b2 = vec4(-0.10,-0.145, 0.05, 0.0224);\n\t\t\tconst vec4 c2 = vec4(-0.16,-0.145, 0.01, 0.0252);\n\t\t\tconst vec4 d2 = vec4(-0.15,-0.145,-0.06, 0.028);\n\t\t\tconst vec3 u2 = vec3(-0.07,-0.145,0.08);\n\t\t\tconst vec3 v2 = vec3(-0.05,-0.145,0.08);\n\n\t\t\tdd =           sdCapsule( hp, a2, b2 ).x;\n\t\t\tdd = smin( dd, sdCapsule( hp, b2, c2 ).x, 0.005 );\n\t\t\tdd = smin( dd, sdCapsule( hp, c2, d2 ).x, 0.005 );\n\t\t\tdd = smax( dd,-sdCapsule( hp, u2, v2, 0.019 ),0.005);\n\t\t}\n        d = min( d, dd\/1.2 );\n\t}\n    \n\tvec3 res = vec3(d,1.0,1.0);\n\n    \/\/ nails\n\t{\n\t\tvec3 np = mat3(0.990,0.0,0.141,\n\t\t\t\t\t   0.000,1.0,0.000,\n\t\t\t\t\t   -0.141,0.0,0.990)*\n\t\t\t\t\t   (p-vec3(-0.9,-0.30,0.12));\n\t\td =       sdEllipsoid(np, vec3(-0.025, 0.000,0.056), vec3(0.022,0.018,0.006) );\n\t\td = min(d,sdEllipsoid(np, vec3(-0.025,-0.050,0.056), vec3(0.023,0.019,0.006) ));\n\t\td = min(d,sdEllipsoid(np, vec3(-0.046,-0.100,0.053), vec3(0.022,0.018,0.006) ));\n\t\td = min(d,sdEllipsoid(np, vec3(-0.073,-0.145,0.048), vec3(0.021,0.017,0.006) ));\n\t\tif( d<res.x ) res = vec3(d,9.0,1.0);\n\t}\n\n\t\n    \/\/ board\n\t\/\/if( p.x<-0.2 )\n\t{\n\tvec3 bp = p - vec3(-0.695,-1.5,0.1 );\n    bp.x = 0.15 + sqrt( bp.x*bp.x+0.0002 );\n\td = sdEllipsoid( bp, vec3(0.0),vec3(0.65,1.8,0.1) );\n\tif( d<res.x ) res = vec3(d,6.0,1.0);\n\t}\n\t\n\treturn res;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/normalsSDF\nvec3 calcNormalmap( in vec3 pos, in float ep )\n{\n#if 0    \n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize(e.xyy*map(pos+e.xyy*ep).x + \n\t\t\t\t\t e.yyx*map(pos+e.yyx*ep).x + \n\t\t\t\t\t e.yxy*map(pos+e.yxy*ep).x + \n\t\t\t\t\t e.xxx*map(pos+e.xxx*ep).x );\n#else\n    \/\/ inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+e*ep).x;\n    }\n    return normalize(n);\n#endif    \n    \n}\n\n\n\/\/=========================================================================\n\nfloat calcAO( in vec3 pos, in vec3 nor, in int sampleID )\n{\n\tfloat ao = 0.0;\n\n\tvec3 v = normalize(vec3(0.7,0.5,0.2));\n\tfor( int i=ZERO; i<12; i++ )\n\t{\n\t\tfloat h = abs(sin(float(i+12*sampleID)));\n\t\t\n\t\tvec3 kv = v + 2.0*nor*max(0.0,-dot(nor,v));\n\t\tao += clamp( map(pos+nor*0.01+kv*h*0.08).x*3.0, 0.0, 1.0 );\n        \n\t\tv = v.yzx; if( (i&2)==2) v.yz *= -1.0;\n\t}\n\tao \/= 12.0;\n\tao = ao + 2.0*ao*ao;\n\treturn clamp( ao*5.0, 0.0, 1.0 );\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/rmshadows\nfloat calcSoftShadow( in vec3 ro, in vec3 rd, float k )\n{\n\tfloat res = 1.0;\n\tfloat t = 0.001;\n\tfor( int i=ZERO; i<50; i++ )\n\t{\n\t\tfloat h = map(ro + rd*t ).x;\n\n\t\tres = min( res, smoothstep(0.0,1.0,1.8*k*(h+0.001)\/sqrt(t)) );\n\t\t\n\t\tt += clamp( h, 0.003, 0.1 );\n\t\tif( res<0.001 || t>0.8) break;\n\t}\n\treturn clamp(res,0.0,1.0);\n}\n\nvec3 shade( in vec3 ro, in vec3 rd, in float t, in float m, in float matInfo, in int sampleID )\n{\n\tvec3 pos = ro + t*rd;\n\tvec3 nor = calcNormalmap( pos, 0.0002 );\n\t\n\n\tvec3 mateD = vec3(0.0);\n\tvec2 mateK = vec2(0.0);\n\tfloat mateS = 0.0;\n\tvec3 mateSG = vec3(1.0);\n\n\tif( m<1.5 )\n\t{\n\t\tmateD = vec3(0.132,0.06,0.06);\n\t\t\n\t\tvec3 p = pos;\n\t\tfloat no = texture(iChannel0,p.xy).x;\n\t\tmateSG = vec3(0.75,0.97,1.0);\n\t\tmateK = vec2(0.08,0.5);\n\t\tmateS = 1.0;    \n\t\tmateK *= 0.5 + no;\n\t}\n\telse if( m<6.5 )\n\t{\n        mateD = vec3(0.22,0.24,0.26);\n\t\t\n\t\tvec3 bp = pos - vec3(-0.695,-1.6,0.1 );\n\n\t\tmateD = mix( mateD, vec3(0.15,0.08,0.05), 1.0-smoothstep(0.003,0.01,abs(bp.x)) );\n\t\t\n\t\tfloat h = bp.y - 0.15*sin( 6.0*bp.x );\n\t\th = min( abs(h-1.15)-0.04, abs(h-1.05)-0.01 );\n\t\t\n\t\tmateD = mix( mateD, vec3(0.004), 1.0-smoothstep( 0.01, 0.02, h ) );\n\t\t\n\t\tmateD *= 0.9 + 0.1*texture(iChannel0, 1.0*pos.xy ).x;\n\t\tmateS = 3.0;\n\t\tmateK = vec2(1.0,16.0);\n\t\t\n\t\tvec2 uv = pos.xy*0.1;\n\t\tfloat te = 0.0;\n\t\tfloat s = 0.5;\n\t\tfor( int i=0; i<9; i++ )\n\t\t{\n\t\t\tte += s*texture(iChannel0,uv).x;\n\t\t\tuv *= 2.11;\n\t\t\ts *= 0.6;\n\t\t}\n\t\tmateD = mix( mateD, vec3(0.16,0.08,0.0)*0.27, \t\t\t0.15*smoothstep(0.6,0.9,te) );\n\t\tmateK.x *= 1.0-te;\n\t\t\n\t\t\n\t}\n\telse if( m<9.5 )\n\t{\n\t\tmateD = vec3(0.134,0.07,0.07);\n\t\t\n\t\tvec3 hp = pos - vec3(-0.945,-0.30,0.12);\n\t\t\n\t\tfloat r = length(hp.xy);\n\t\tr = min( r, length(hp.xy-vec2(0.0,-0.05)) );\n\t\tr = min( r, length(hp.xy-vec2(-0.02,-0.095)) );\n\t\tr = min( r, length(hp.xy-vec2(-0.048,-0.14)) );\n\t\t\n\t\tmateD += 0.023*(1.0 - smoothstep( 0.014,0.018,r));\n\t\t\n\t\tmateK = vec2(0.2,2.0);\n\t\tmateS = 1.0;\n\t\t\n\t}\n\t\n\tfloat fre = clamp(1.0+dot(nor,rd), 0.0, 1.0 );\n\tfloat occ = calcAO( pos, nor, sampleID );\n\t\n\tvec3 col = vec3(0.0);\n\t\n    {\n\t\t\/\/ key\n\t\tfloat dif1 = dot(nor,sunDir);\n\t\tvec3 hal = normalize( sunDir-rd );\n\t\tfloat spe = pow(clamp(dot(hal,nor),0.0,1.0),0.001+8.0*mateK.y);\n\n\t\tfloat sha = calcSoftShadow( pos+nor*0.0005, sunDir, 24.0 ); \n        \n        sha *= 0.15+0.85*smoothstep(0.1,0.3,length((pos-vec3(-0.45,0.16,0.1))*vec3(1.4,0.4,1.0)));\n        \n\t\tfloat ssha = 1.0;\n\t\tif( abs(m-3.0)<0.2 ) { dif1=0.5*dif1+0.5; sha=0.95*sha+0.05; }\n\t\tif( abs(m-2.0)<0.2 ) { sha=clamp(0.2+sha*dif1*2.0,0.0,1.0); dif1=0.4+0.6*dif1; ssha=0.0; }\n\t\t\n\t\tdif1 = clamp(dif1,0.0,1.0);\n\n\t\tvec3 sha3 = vec3(sha,sha*0.4+0.6*sha*sha,sha*sha);\n\t\t\n\t\tcol += mateD*3.1*vec3(2.5,1.1,0.5)*dif1*sha3;\n\t\tcol += mateK.x*vec3(1.5,1.4,1.3)*dif1*sha*spe*(0.04+0.96*pow(clamp(dot(hal,nor),0.0,1.0),5.0))*ssha;\n    }\n\t{\n\t\t\/\/ fill\n\t\t\n\t\tcol += mateD*vec3(0.45,0.75,1.0)*occ*occ*occ*(0.5+0.5*nor.y)*4.5;\n\n\t\tfloat dif1 = 0.5 + 0.5*nor.y;\n\t\tfloat sha = 1.0;\n\t\tfloat spe = smoothstep( -0.15, 0.15, reflect(rd,nor).y );\n\t\tcol += mateK.x*vec3(0.7,0.9,1.0)*dif1*sha*spe*(0.04+0.96*pow(clamp(dot(rd,nor),0.0,1.0),5.0))*occ*occ*3.0;\n\t}\n\t{\n\t\t\/\/ bounce\n\t\tvec3 bak = normalize( sunDir*vec3(-1.0,-3.5,-1.0));\n\t\tfloat dif = clamp(0.3+0.7*dot(nor,bak),0.0,1.0);\n\t\tcol += mateD*vec3(1.2,0.8,0.6)*occ*occ*dif*2.5;\n\t}\n\t{\n\t\tcol += mateS*mateD*fre    *vec3(2.0,0.95,0.80)*0.7*occ;\n\t\tcol += mateS*mateD*fre*fre*vec3(1.1,0.80,0.65)*1.2*occ;\n\t}\n\n\tcol = pow( col, mateSG );\n\n    return col;        \n}\n\n\/\/--------------------------------------------\n\nvec3 intersect( in vec3 ro, in vec3 rd, float mindist, float maxdist )\n{\n\tvec3 res = vec3(-1.0);\n\t\n\tfloat t = mindist;\n\tfor( int i=ZERO; i<150; i++ )\n\t{\n\t\tvec3 p = ro + t*rd;\n\t\tvec3 h = map( p );\n\t\tres = vec3(t,h.yz);\n\t\tif( abs(h.x)<0.00025 || t>maxdist ) break;\n\t\tt += h.x;\n\t}\n\treturn res;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 uv, in int sampleID )\n{\n\tvec4 res = texture(iChannel1,uv);\n\tvec3 col = res.xyz;\n\t\n\tconst float mindist = 0.8;\n\tconst float maxdist = 1.8;\n\t\n\tvec3 tm = intersect( ro, rd, mindist, maxdist );\n\tif( tm.y>-0.5 && tm.x < maxdist )\n\t{\n\t\tcol = shade( ro, rd, tm.x, tm.y, tm.z, sampleID );\n\t}\n\n\tfloat sun = clamp(0.5+0.5*dot( rd, sunDir ),0.0,1.0);\n\tcol += 20.0*vec3(1.2,0.7,0.4)*pow(sun,8.0);\n\n\tcol = pow( col, vec3(0.4545) );\n\n\t\/\/col.z += 0.005;\n\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\n\tmat3 ca; vec3 ro; float fl;\n\tcomputeCamera( iTime, ca, ro, fl );\n\n#if AA<2\n\tvec2  p = (2.0*fragCoord-iResolution.xy)\/iResolution.y;\n    vec3  rd = normalize( ca*vec3(p,-fl) );\n\tvec3 col = render( ro, rd, fragCoord.xy\/iResolution.xy, 0 );\n#else\n\tvec3 col = vec3(0.0);\n\tfor( int m=ZERO; m<AA; m++ )\n\tfor( int n=ZERO; n<AA; n++ )\n\t{\n\t\tvec2 rr = vec2( float(m), float(n) ) \/ float(AA) - 0.5;\n\t\tvec2 p = (2.0*(fragCoord.xy+rr)-iResolution.xy)\/iResolution.y;\n\t\tvec3 rd = normalize( ca * vec3(p,-fl) );\n\t\tcol += render( ro, rd, (fragCoord+rr)\/iResolution.xy, AA*m+n );\n\t}    \n\tcol \/= float(AA*AA);\n#endif\n\t\t\n\tvec2 q = fragCoord.xy\/iResolution.xy;\n\tcol *= 0.3 + 0.7*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.1);\n\n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float noise( in vec2 p )\n{\n  return -1.0+2.0*textureGood( iChannel0, p-0.5 );\n}\n\nconst float hmin = -6.0;\nconst float hmax = -1.0;\n\nfloat mapWater( in vec3 p )\n{\n    float w = 0.0;\n    float s = 0.5;\n    vec2 q = p.xz;\n    for( int i=0; i<4; i++ )\n    {\n        w += s*noise(q*vec2(0.5,1.0));\n        q = 2.01*(q + vec2(0.03,0.07));\n        s = 0.5*s;\n    }\n    w \/= 0.9375;\n    \n    \n    float h = hmin + (hmax-hmin)*w;\n    \n\n    float cr = 0.0;\n    float wh = 0.2 + 0.8*smoothstep( 0.0, 75.0, -p.z );\n    vec2 pp = p.xz\/50.0;\n    float d = 1e20;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 o = floor( pp );\n        o += vec2( float(i), float(j) );\n        vec4 ra = texelFetch( iChannel0, ivec2(o)&255, 0 );\n        o += ra.xy;\n        vec3 r = p - vec3(o.x*50.0,-4.0-(1.0-wh)*5.0+ra.z*ra.z*2.0-3.0,o.y*50.0 + mod(10.0*iTime*0.2,50.0));\n        r.yz = mat2(0.99,0.141,-0.141,0.99)*r.yz;\n        d = smin( d, sdEllipsoid( r, vec3(0.0,0.0,0.0), (0.2+0.8*wh)*vec3(35.0,(0.1+0.9*ra.z*ra.z)*3.0,15.0)), 2.10 );\n        \n        float pm = (0.1+0.9*wh)*15.0;\n        float cc = 1.0-smoothstep( 0.0, 2.0, abs(abs(r.z)-pm) );\n        cr = max( cr, cc );\n    }\n    d = d - w*0.5;\n    d = smin( d, p.y+4.0, 1.0);\n    d = d - w*0.03;\n\n    return d;\n}\n\nconst vec3 bnor = normalize(vec3(0.0,0.9,-0.05));\n\nfloat mapBeach( in vec3 p )\n{\n    float d = dot(p,bnor)-2.8;\n    \n    vec2 w = vec2(0.0);\n    vec2 s = vec2(0.5);\n    vec2 t = vec2(0.0);\n\t\n    vec2 q = p.xz*1.25;\n    q += 1.0*cos( 0.3*q.yx );\n    for( int i=0; i<7;i++ )\n    {\n        float n = 0.5 + 0.5*noise(q);\n\t\tw += s*vec2(1.0-almostIdentity(abs(-1.0+2.0*n),0.1,0.05 ),n);\n\t\tt += s;\n        q = mat2(1.6,1.2,-1.2,1.6)*q;\n\t\ts *= vec2(0.3,0.5);\n    }\n\tw \/= t;\n\n\tfloat f = w.x + w.y*0.4;\n    \n    float wet = 1.0-smoothstep(-16.0, -10.0, p.z );\n    \n    return d - 0.15*mix(f, (1.0-f)*0.1, wet );\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/normalsSDF\nvec3 calcNormalmapWater( in vec3 pos, in float ep )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize(e.xyy*mapWater(pos+e.xyy*ep) + \n\t\t\t\t\t e.yyx*mapWater(pos+e.yyx*ep) + \n\t\t\t\t\t e.yxy*mapWater(pos+e.yxy*ep) + \n\t\t\t\t\t e.xxx*mapWater(pos+e.xxx*ep) );\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/normalsSDF\nvec3 calcNormalmapBeach( in vec3 pos, in float ep )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize(e.xyy*mapBeach(pos+e.xyy*ep) + \n\t\t\t\t\t e.yyx*mapBeach(pos+e.yyx*ep) + \n\t\t\t\t\t e.yxy*mapBeach(pos+e.yxy*ep) + \n\t\t\t\t\t e.xxx*mapBeach(pos+e.xxx*ep) );\n}\n\n\nfloat intersectWater( in vec3 ro, in vec3 rd, in float mint )\n{\n    float t = mint;\n    for( int i=0; i<200; i++ )\n    {\n        vec3 p = ro + t*rd;\n        float h = mapWater( p );\n        if( abs(h)<(0.0004*t) ) break;\n        t += h;\n    }\n\treturn t;\n}\n\nvec3 sky( in vec3 rd )\n{\n    if( rd.y<0.0 ) return vec3(0.0,0.05,0.10);\n    \n    \/\/ gradient\n    float dy = max(0.0,rd.y);\n    vec3 col = vec3(0.3,0.7,0.9) - dy*0.5;\n\tcol = mix( col, vec3(1.3,0.45,0.10), exp(-4.0*dy) );\n\tcol = mix( col, vec3(1.5,0.10,0.05), exp(-30.0*dy) );\n\tcol = mix( col, vec3(0.1,0.10,0.10), exp(-60.0*dy) );\n    \n    \/\/ clouds\n    vec2 uv = 0.003*rd.xz\/rd.y;\n\tuv += 0.006*sin(100.0*uv.yx);\n    float f  = 0.5000*texture( iChannel0, 1.0*uv.xy ).x;\n          f += 0.2500*texture( iChannel0, 1.9*uv.yx ).x;\n          f += 0.1250*texture( iChannel0, 4.1*uv.xy ).x;\n          f += 0.0625*texture( iChannel0, 7.9*uv.yx ).x;\n          \n    return mix( col, vec3(1.0,0.37,0.4)*(1.0-f)*0.5,0.3*smoothstep(0.4,0.7,f) );\n}\n\nvec4 render( in vec3 ro, in vec3 rd )\n{\n\tvec3 col = vec3(0.0);\n    \n    float ma = -1.0;\n    float tmin = 1e20;\n    \n    float t = (hmax-ro.y)\/rd.y;\n    if( t>5.0 )\n    {\n        t = intersectWater( ro, rd, t );\n        ma = 0.0;\n        tmin = t;\n    }\n\n    t = (-2.8-dot(ro,bnor))\/dot(rd,bnor);\n    if( t>0.0 && t<tmin)\n    {\n\t\ttmin = t;\n\t\tma = 1.0;\n    }\n\n    if( ma<0.0 )\n    {\n        col = sky( rd );\n    }\n    else if( ma<0.5 )\n    {\n    \tvec3 pos = ro + tmin*rd;\n        vec3 nor = calcNormalmapWater(pos,0.0001*tmin);\n\n        float h = (pos.y - hmin)\/(hmax-hmin);\n        float f = exp(-0.01*tmin);\n        col = mix( vec3(0.03,0.1,0.1), vec3(0.02,0.04,0.08), 1.0-f );\n        \n        h = 1.0-abs(nor.y);\n        col += h*vec3(0.00,0.03,0.03)*2.0;\n\n        vec3 ref = reflect( rd, nor );\n        float kr = pow( clamp(1.0 + dot( rd, nor ),0.0,1.0), 5.0 );\n        col += 0.7*(0.01 + 0.99*kr)*sky( ref );\n        \n        \n        float dif = clamp( dot(nor,sunDir),0.0,1.0);\n        col *= 0.8 + 0.4*dif;\n        col *= 0.75;\n        \n        \/\/ foam waves\n        float foam = smoothstep( -0.5, 0.1, -nor.y );\n\t\t\/\/ foam shore\n\t\tfloat te = texture(iChannel0,0.016*pos.xz + vec2(-0.002,-.007)*iTime).x;\n\t\tfoam += \n\t\tsmoothstep(-24.0,-23.0,pos.z + 0.5*sin(pos.x*0.4+te*2.0))*\n\t\tsmoothstep(0.4,0.5,te)*0.8;\n\t    col = mix( col, vec3(0.8,0.9,1.0), 0.4*foam );\n    \n        \/\/ fog\n\t\tcol = mix( col, vec3(0.1), 1.0-exp(-0.000001*tmin*tmin) );\n    }\n\telse if( ma<1.5 )\n    {\n        col = vec3(0.0);\n\n        vec3 pos = ro + tmin*rd;\n        vec3 nor = calcNormalmapBeach(pos,0.0002);\n\n\t\tvec3 mateD = vec3(1.0,0.7,0.5)*0.17;\n        vec2 mateK = vec2(1.0,0.5);\n        float mateS = 0.0;\n\n\t\t\n        float fr = pow(clamp( 1.0+dot(rd,nor), 0.0, 1.0 ),2.0);\n\t\tmateD += 0.05*vec3(1.0,0.5,0.2)*fr;\n\n\t\t\n        float wet = 1.0-smoothstep(-17.0, -11.0, pos.z );\n\t\tmateD = mix( mateD, vec3(0.05,0.02,0.0)*0.8, wet );\n        mateK.x += 12.0*wet;\n        mateK.y += 9.0*wet;\n        \n\t\tmateD *= 0.9;\n        \n\t\tfloat dif1 = clamp( -0.1+1.4*dot(nor,sunDir),0.0,1.0);\n        vec3 hal = normalize( sunDir-rd );\n        float spe = pow(clamp(dot(hal,nor),0.0,1.0),0.001+8.0*mateK.y);\n\t\tcol += mateD*4.0*vec3(2.5,1.0,0.5)*dif1;\n\t\t\tcol += mateK.x*vec3(1.4,1.30,1.3)*dif1*spe*(0.04+0.96*pow(clamp(dot(hal,nor),0.0,1.0),5.0));\n\n        col += mateD*vec3(1.0,0.9,0.9)*(0.5+0.5*nor.y)*0.2;\n        col += mateK.x*vec3(0.8,0.8,0.9)*smoothstep( -0.1,0.3,reflect(rd,nor).y) *(0.04+0.96*pow(clamp(dot(rd,nor),0.0,1.0),5.0));\n        \n    }\n    \n    return vec4(col,tmin);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    mat3 ca; vec3 ro; float fl;\n    computeCamera( iTime, ca, ro, fl );\n    \n    vec2  p = (2.0*fragCoord.xy-iResolution.xy)\/iResolution.y;\n    vec3  rd = normalize( ca * vec3(p,-fl) );\n    \n    fragColor = render( ro, rd );\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\/\/ antialiasing - make AA 2, meaning 4x AA, if you have a fast machine\n#define AA 1\n\nconst vec3 sunDir = normalize( vec3(1.0,0.5,0.7) );\n\n\nvoid computeCamera( in float time, out mat3 rCam, out vec3 rRo, out float rFl )\n{\n    vec3 ro = vec3(-0.045+0.05*sin(0.25*time),-0.04,1.3);\n\tvec3 ta = vec3(-0.19,-0.08,0.0);\n\tfloat fl = 2.45;\n    \n    vec3 w = normalize(ta-ro);\n\tfloat k = inversesqrt(1.0-w.y*w.y);\n    rCam = mat3( vec3(-w.z,0.0,w.x)*k, \n                 vec3(-w.x*w.y,1.0-w.y*w.y,-w.y*w.z)*k,\n                 -w);\n    rRo = ro;\n    rFl = fl;\n}\n\n\/\/------------------------------------------------------\n\n\/\/ https:\/\/iquilezles.org\/articles\/texture\nfloat textureGood( sampler2D sam, in vec2 x )\n{\n\tivec2 p = ivec2(floor(x));\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float a = texelFetch(sam,(p+ivec2(0,0))&255,0).x;\n\tfloat b = texelFetch(sam,(p+ivec2(1,0))&255,0).x;\n\tfloat c = texelFetch(sam,(p+ivec2(0,1))&255,0).x;\n\tfloat d = texelFetch(sam,(p+ivec2(1,1))&255,0).x;\n\treturn mix(mix( a, b,f.x), mix( c, d,f.x), f.y);\n}\n\n\/\/------------------------------------------------------\n\n\/\/ https:\/\/iquilezles.org\/articles\/functions\nfloat almostIdentity( float x, float m, float n )\n{\n    if( x>m ) return x;\n    float a = 2.0*n - m;\n    float b = 2.0*m - 3.0*n;\n    float t = x\/m;\n    return (a*t + b)*t*t + n;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/smin\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25\/k;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/smin\nfloat smax( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)\/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\n\/\/------------------------------------------------------\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nfloat sdEllipsoid( in vec3 p, in vec3 c, in vec3 r )\n{\n  p = p-c;\n  float k0 = length(p\/r);\n  float k1 = length(p\/(r*r));\n  return k0*(k0-1.0)\/k1;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nfloat sdCapsule( in vec3 p, in vec3 a, in vec3 b, in float r )\n{\n  vec3 pa = p-a, ba = b-a;\n  float h = clamp(dot(pa,ba)\/dot(ba,ba),0.0,1.0);\n  return length(pa-ba*h) - r;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nvec2 sdCapsule( in vec3 p, in vec4 a, in vec4 b )\n{\n  vec3 pa = p-a.xyz, ba = b.xyz-a.xyz;\n  float h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n  return vec2( length(pa-ba*h) - mix(a.w,b.w,h), h );\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nfloat sdSphere( in vec3 p, in vec3 c, in float r )\n{\n  return length(p-c)-r;\n}\n\nfloat sdEllipsoidXY2Z( in vec3 p, in vec3 r )\n{\n  vec3 d = p\/r;\n  float h = pow(d.x*d.x + abs(d.y*d.y*d.y) + d.z*d.z, 1.0\/3.0); \n  return (h-1.0)*min(r.x,min(r.y,r.z));\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nfloat sdCone( in vec3 p, in vec2 c )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n\n  vec2 a = q - c*clamp( (q.x*c.x+q.y*c.y)\/dot(c,c), 0.0, 1.0 );\n  vec2 b = q - c*vec2( clamp( q.x\/c.x, 0.0, 1.0 ), 1.0 );\n  \n  float s = -sign( c.y );\n  vec2 d = min( vec2( dot( a, a ), s*(q.x*c.y-q.y*c.x) ),\n\t\t\t    vec2( dot( b, b ), s*(q.y-c.y)  ));\n  return -sqrt(d.x)*sign(d.y);\n}\n\n\/\/ http:\/\/research.microsoft.com\/en-us\/um\/people\/hoppe\/ravg.pdf\nfloat det( vec2 a, vec2 b ) { return a.x*b.y-b.x*a.y; }\nvec3 getClosest( vec2 b0, vec2 b1, vec2 b2 ) \n{\n  float a =     det(b0,b2);\n  float b = 2.0*det(b1,b0);\n  float d = 2.0*det(b2,b1);\n  float f = b*d - a*a;\n  vec2 d21 = b2-b1;\n  vec2 d10 = b1-b0;\n  vec2 d20 = b2-b0;\n  vec2 gf = 2.0*(b*d21+d*d10+a*d20); gf = vec2(gf.y,-gf.x);\n  vec2 pp = -f*gf\/dot(gf,gf);\n  vec2 d0p = b0-pp;\n  float ap = det(d0p,d20);\n  float bp = 2.0*det(d10,d0p);\n  float t = clamp( (ap+bp)\/(2.0*a+b+d), 0.0 ,1.0 );\n  return vec3( mix(mix(b0,b1,t), mix(b1,b2,t),t), t );\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nvec4 sdBezier2( vec3 a, vec3 b, vec3 c, vec3 p, out vec3 resP )\n{\n  vec3 w = normalize( cross( c-b, a-b ) );\n  vec3 u = normalize( c-b );\n  vec3 v =          ( cross( w, u ) );\n\n  vec2 m = vec2( dot(a-b,u), dot(a-b,v) );\n  vec2 n = vec2( dot(c-b,u), dot(c-b,v) );\n  vec3 q = vec3( dot(p-b,u), dot(p-b,v), dot(p-b,w) );\n\n  vec3 cp = getClosest( m-q.xy, -q.xy, n-q.xy );\n\n  resP = mix( mix(a,b,cp.z), mix(b,c,cp.z), cp.z );\n\n  return vec4( sqrt(dot(cp.xy,cp.xy)+q.z*q.z), cp.z, length(cp.xy), q.z );\n}\n\nvec4 sdBezier( vec3 a, vec3 b, vec3 c, vec3 p )\n{\n  vec3 kk;\n  return sdBezier2(a,b,c,p,kk);\n}\n\n\/\/ trick by klems\n#define ZERO (min(iFrame,0))\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 q = fragCoord\/iResolution.xy;\n\n    vec4 acc = vec4(0.0);\n    const int N = 5;\n\tfor( int j=-N; j<=N; j++ )\n    for( int i=-N; i<=N; i++ )\n    {\n        vec2 off = vec2(float(i),float(j));\n        \n        vec4 tmp = texture( iChannel0, q + off\/vec2(1280.0,720.0) ); \n        if( dot(off,off) < float(N*N) )\n        {\n            acc += vec4(tmp.xyz,1.0);\n        }\n    }\n    vec3 col = acc.xyz \/ acc.w;\n\n    fragColor = vec4(col,1.0);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"const vec3 corner1 = vec3(-0.088,-0.103,0.084);\nconst vec3 center  = vec3(-0.005,-0.193,0.14);\nconst vec3 corner2 = vec3( 0.098,-0.105,0.08);\n\nvec3 transformHead( in vec3 p )\n{\n  p.x += 0.012;\n  return mat3( 0.986264,-0.097838, -0.133010,\n               0.086792, 0.992467, -0.086465,\n               0.140468, 0.073733,  0.987326)*p;\n}\n\nvec3 transformHat(in vec3 p)\n{\n  p.y -= 0.03;\n  p = mat3( 0.79200, -0.141, 0.59400,\n           -0.26976,  0.792, 0.54768,\n           -0.54768, -0.594, 0.58924)*p;\n  p.y -= 0.1;\n  return p;\n}\n\nconst float eyeOff = 0.005;\n\nvec3 map( vec3 p )\n{\n\tvec3 headp = transformHead( p );\n\tvec3 headq = vec3( abs(headp.x), headp.yz );\n\n    \/\/ head\n\tfloat d = sdEllipsoid( headp, vec3(0.0,0.015,-0.06 ),vec3(0.33,0.365,0.34) );\n\td = smax(d,-sdEllipsoid( vec3( almostIdentity( headq.x, 0.03, 0.01 ), headp.yz),  vec3( 0.25,0.06,0.4),vec3(0.4,0.2,0.2) ), 0.015);\n    \/\/d = smax(d,-sdEllipsoid( vec3( sqrt(headq.x*headq.x+0.0001), headp.yz),  vec3( 0.25,0.06,0.4),vec3(0.4,0.2,0.2) ), 0.015);\n\td = smin(d,sdEllipsoid( headp, vec3(0.0,-0.165,0.13),vec3(0.22,0.15,0.145)), 0.01 );\n\td = smin(d,sdEllipsoid( headp, vec3(0.01,-0.2,0.17),vec3(0.12,0.115,0.105)), 0.01 );\n\td = smin(d,sdEllipsoid( headq, vec3(0.1,-0.103,0.09),vec3(0.175,0.146,0.18) ), 0.02);\n\n    \n    \/\/ nose\n\tvec3 n = headp-vec3(0.0,0.1,0.23);\n\tn.x -= n.y*n.y*0.18;\n\tn.yz = mat2(0.98,0.198997,-0.198997,0.98)*n.yz;\n\td = smin( d, sdCone( n, vec2(0.01733,-0.13) ), 0.03);\n\tn.yz -= vec2(-0.102975, 0.004600);\n\tvec3 m = vec3(abs(n.x),n.yz);\n\tfloat na = sdCone( n, vec2(0.527,-0.85) );\n\tna = smax( na, sdSphere(n,vec3(0.0,-0.03,-0.04),0.1), 0.015 );\n\tna = smin( na, sdEllipsoid(m, vec3(0.038,-0.085,0.0),vec3(0.027)), 0.016 );\n\tna = smin( na, sdEllipsoid(m, vec3(0.0,-0.11,-0.01), vec3(0.02,0.02,0.02)), 0.02 );\n\tna = smax(na,-sdEllipsoid(m, vec3(0.033,-0.09,0.008),vec3(0.01,0.02,0.009)*1.5), 0.008 );\n\td = smin( d, na, 0.01);\n\n    \/\/ mouth\n\tvec3 bocap = headp-vec3(-0.006,-0.026,0.22);\n\tvec3 bocap3 = bocap;\n\tbocap.xy = mat2x2(0.99,-0.141,0.141,0.99)*bocap.xy;\n\tvec3 bocap2 = bocap;\n\tbocap.yz = mat2x2(0.9,-0.346,0.346,0.9)*bocap.yz;\n\tfloat  labioa = sdCone(bocap, vec2(0.219,-0.18) );\n\tlabioa = smax( labioa, sdEllipsoid(bocap,vec3(0.0,0.1,-0.15), vec3(0.22,0.35,0.34)), 0.02 );\n\td = smin( d, labioa, 0.015 );\n\td = smax( d, -sdCapsule( bocap, vec3(0.0,-0.077,0.115),vec3(0.0,-0.09,0.135), 0.013 ), 0.01 );\n\tbocap2.y -= min(bocap2.x*bocap2.x*4.0,0.04);\n\td = smax( d, -sdEllipsoid(bocap2,vec3(0.0,-0.172,0.15), vec3(0.09+0.008*sign(bocap.x),0.017,0.25)), 0.01 );\t\t\n\tvec4 b = sdBezier( corner1, center, corner2, bocap );\n\td = smin(d,b.x - 0.0075*sqrt(4.0*b.y*(1.0-b.y)), 0.005);\n\n    \/\/ ears\n\tvec3 earq = headq - vec3(0.34,-0.04,0.02);\n\tearq.xy = mat2(0.9,0.436,-0.436,0.9)*earq.xy;\n\tearq.xz = mat2(0.8,0.6,-0.6,0.8)*earq.xz;\n\tfloat ear = sdEllipsoid( earq, vec3(0.0),vec3(0.08,0.12,0.09) );\n\tear = smax( ear, (abs(earq.z)-0.016), 0.01 );\n\tear = smin( ear, sdSphere(earq,vec3(0.015,0.0,-0.03),0.04), 0.02);        \n\tear = smax( ear, -0.8*sdEllipsoid( earq, vec3(0.0,0.022,0.02),vec3(0.06,0.08,0.027) ),0.01 );\n\tear = smax( ear, -sdEllipsoid( earq, vec3(-0.01,-0.01,0.01),vec3(0.04,0.04,0.05) ), 0.01 );\n\td = smin(d,ear, 0.015);\n    \n    \n    \/\/ eye sockets\n\td = smax(d,-sdEllipsoid( headq, vec3(0.1+eyeOff,0.03,0.11),vec3(0.105,max(0.0,0.12-0.2*headq.x),0.115)+0.01),0.01 );\n\tb = sdBezier( vec3(0.053+eyeOff,0.017,0.225), vec3(0.12+eyeOff,-0.02,0.255), vec3(0.18+eyeOff,0.02,0.205), headq-vec3(0.0,0.03-0.04,0.0) );\n\td = smin(d,b.x - 0.003*b.y*(1.0-b.y)*4.0,0.012);\n\n    \/\/ chin fold\n\tn = (headp-vec3(0.14,-0.16,0.297));\n\tn.xy = mat2(0.8,0.6,-0.6,0.8)*n.xy;\n\td = smax(d, -sdEllipsoid( n,  vec3(0.0), vec3(0.096,0.01,0.03)), 0.007);\n\t\n    \/\/ neck\/body\n\t{\n\tvec3 q = vec3( abs(p.x), p.yz );\n\td = smin( d, sdCapsule( p, vec4(0.0,-0.1,-0.1,0.1), vec4(0.0,-0.6,-0.1, 0.12 )).x, 0.05 );\n\td = smin( d, sdCapsule( q, vec3(0.0,-0.62,-0.08), vec3(0.24,-0.71,0.02-0.1), 0.16 ), 0.05 );        \n\td = smin( d, sdCapsule( q, vec4(0.046,-0.555,0.05,0.01), vec4(0.250,-0.55,-0.035,-0.02) ).x, 0.03 );\n\t}\n    \n\tvec3 res = vec3(d,1.0,1.0);\n    \n\n    \/\/ eyes\n\tm = headq - vec3(0.0021,0.0,0.019);\n\td = sdEllipsoid( m, vec3(0.1+eyeOff,0.03,0.11),vec3(0.105,0.09,0.1) );\n\td = smax(d,-sdEllipsoid( headq, vec3(0.102+eyeOff+0.004*sign(headp.x)*1.8,0.03+0.004*1.8,0.28),vec3(0.07) ),0.001);\n\tif( d<res.x ) res = vec3(d,2.0,1.0);\n\n    \/\/ teeth\n\t{\n\tbocap3 = bocap3 - vec3(0.01,-0.055,0.04);\n\tbocap3.xz = mat2x2(0.99,0.141,-0.141,0.99)*bocap3.xz;\n\td = sdCappedCylinder( bocap3.xzy, vec2(0.11,0.01) );\n\tvec3 dd = bocap3;\n\tdd.x = mod(dd.x+0.0075,0.015)-0.0075;\n\tfloat sp = sdBox( dd-vec3(0.0,-0.1,0.0), vec3(0.0004,0.018,0.015) );\n\td = smax(d,-sp,0.003);\n\td = max( d, dot(bocap3.xy,vec2(-0.707,0.707))+0.05 );\n\tif( d<res.x ) res = vec3(d,8.0,1.0);\n\t}\n\n\t\n\t\/\/ eyebrows\n\tb = sdBezier( vec3(0.035,0.16,0.0), vec3(0.1,0.18,-0.02), vec3(0.2,0.12,-0.1), \n\t(headq-vec3(0.0,0.0,0.25))*vec3(1.0,1.0,2.0) );\n\td = b.x - 0.01*sqrt(clamp(1.0-b.y,0.0,0.9));\n\tfloat fr = (sign(b.w)*headq.x*0.436+0.9*headq.y);\n\tfloat cp = cos(1300.0*fr);\n\tcp -= 0.5*cos(600.0*fr); \n\tcp += 0.3*cos(330.0*fr);\n\tcp *= clamp(1.0-3.0*headq.x,0.0,0.8);\n\td -= cp*0.0017;\n\td\/=1.5;\n\tif( d<res.x ) { res = vec3(d,3.0,0.4);}\n\n    \/\/ hair\n\t\/\/if( p.x>-0.4 && p.y>-0.1) \/\/ +10%\n\t{\n\t\tfloat hh = 0.27 - headp.y;\n\n\t\tfloat ss = sign(headp.x);\n\n\t\tvec3 pelop = headp;\n\t\tpelop.x += (1.0-hh)*0.007*cos(pelop.y*30.0);\n\t\tvec3 peloq = vec3( abs(pelop.x), pelop.yz );\n\t\t\n\t\tvec3 ta = vec3(0.0);\n\t\tfloat vc = 0.0;\n\n\t\t{\n\t\tconst vec3 p0a = vec3(0.05,0.3,0.15);\n\t\tconst vec3 p0b = vec3(0.18,0.17,0.22);\n\t\tconst vec3 p0c = vec3(0.1,0.2,0.23);\n\t\tvec4 b = sdBezier( p0a, p0c, p0b, pelop );\n\t\tfloat d1 = b.x - 0.06*(1.0-0.9*b.y);\n\t\td = d1; ta = p0b - p0a; vc = b.y;\n\t\t}\n\t\t{\n\t\tconst vec4 p1a = vec4(-0.04,0.26,0.15,0.075);\n\t\tconst vec4 p1c = vec4(0.02,0.2,0.24,0.015);\n\t\tvec2 b = sdCapsule(pelop, p1a, p1c );\n\t\tfloat d1 = b.x;\n\t\tif( d1<d ) { d=d1; ta = (p1a.xyz-p1c.xyz)*vec3(ss,1.0,1.0); vc = b.y;}\n\t\t}\n\t\t{\n\t\tconst vec4 p2a = vec4(0.16,0.25,0.14,0.07);\n\t\tvec4 p2b = vec4(0.185+0.025*ss,0.14,0.23-0.02*ss,0.006);\n\t\tvec2 b = sdCapsule(peloq, p2a, p2b );\n\t\tfloat d1 = b.x;\n\t\tif( d1<d ) { d=d1; ta = p2b.xyz-p2a.xyz; vc = b.y;}\n\t\t}\n\t\t{\n\t\tconst vec3 p3a = vec3(0.205,0.20,0.14);\n\t\tvec3 p3b = vec3(0.255+0.01*ss,0.05,0.17);\n\t\tvec3 p3c = vec3(0.21+0.01*ss,0.15,0.18);\n\t\tvec4 b = sdBezier( p3a, p3c, p3b, peloq );\n\t\tfloat d1 = b.x - 0.06*(1.0-0.9*b.y);\n\t\tif( d1<d ) { d=d1; ta = p3b-p3a; vc = b.y;}\n\t\t}\n\t\t{\n\t\tconst vec4 p4a = vec4(0.24,0.16,0.11,0.06);\n\t\tvec4 p4b = vec4(0.285,-0.04,0.14,0.006);\n\t\tvec2 b = sdCapsule(peloq, p4a, p4b );\n\t\tfloat d1 = b.x;\n\t\tif( d1<d ) { d=d1; ta = p4b.xyz-p4a.xyz; vc = b.y; }\n\t\t}\n\t\t{\n\t\tconst vec4 p5a = vec4(0.275,0.12,0.07,0.06);\n\t\tvec4 p5b = vec4(0.295,-0.09,0.1,0.006);\n\t\tvec2 b = sdCapsule(peloq, p5a, p5b );\n\t\tfloat d1 = b.x;\n\t\tif( d1<d ) { d=d1; ta = p5b.xyz-p5a.xyz; vc = b.y; }\n\t\t}\n\n\t\t\n\t\t{\n\t\tvec3 vv = normalize(vec3(ta.z*ta.z+ta.y*ta.y, -ta.x*ta.y, -ta.x*ta.z) );\n\t\tfloat ps  = dot(peloq,vv);\n\t\td -= 0.003*sin(300.0*ps);\n\t\td -= 0.008*(-1.0+2.0*textureGood( iChannel0, vec2(1024.0*ps,vc*5.12) ));\n\t\t}\n\t\t\n\t\tif( d<res.x ) res = vec3(d,3.0,vc);\n\t}\n\n    \/\/ eyelashes\n\t{\n\tvec3 cp;\n\tvec4 b = sdBezier2(  vec3(0.0525+0.0025*sign(headp.x)+eyeOff,0.063, 0.225), \n\t\t\tvec3(0.120+eyeOff,0.135, 0.215), vec3(0.1825+eyeOff+0.0025*sign(headp.x),0.050, 0.200), \n\t\t\theadq, cp );\n\tfloat ls = 4.0*b.y*sqrt(1.0-b.y);\n\td = b.x - 0.002*ls;\n\td += 0.001*ls*sin(headq.x*300.0-headq.y*300.0)*step(cp.y,headq.y);\n\td += 0.001*ls*sin(headq.x*1000.0-headq.y*1000.0)*step(cp.y,headq.y);\n\tif( d<res.x ) { res = vec3(d,3.0,0.35);}\n    }\n\t\n\n    \/\/ hat\n    {\n\tvec3 hatp = transformHat( headp );\n\td = sdEllipsoidXY2Z( hatp, vec3(0.36,0.38,0.365) );\n\td = abs(d+0.003)-0.003;\n\td = smax(d,-0.065-hatp.y,0.006);\n\tfloat gb = abs(hatp.x)-hatp.z-0.0975;\n\td -= 0.002*sqrt(clamp(abs(gb)\/0.015,0.0,1.0)) - 0.002;\n\thatp.y += 0.1;\n\tfloat p1 = abs(sin(600.0*hatp.x+hatp.y*200.0));\n\tfloat p2 = abs(cos(150.0*hatp.z)*sin(150.0*hatp.y));\n\tp2 *= smoothstep(0.01,0.02,hatp.y-0.035);\n\td -= 0.0005*mix(p1,2.0*p2,smoothstep(0.0,0.01,gb));\n\tif( d<res.x ) res = vec3(d,4.0,1.0);\n\tvec3 vp = hatp - vec3(0.0,0.19,0.0);\n\tvp.yz = mat2(0.8,-0.6,0.6,0.8)*vp.yz;\n\tvp.y -= 0.2*sqrt(clamp(1.0-vp.x*vp.x\/0.115,0.0,1.0))-0.1;\n\td = 0.8*sdEllipsoid( vp, vec3(0.0,0.0,0.25),vec3(0.3,0.04,0.35) );\n\tif( d<res.x ) res = vec3(d,5.0,1.0);\n    }\t\n\t\n\t\n\treturn res;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/normalsSDF\nvec3 calcNormalmap( in vec3 pos, in float ep )\n{\n#if 0    \n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize(e.xyy*map(pos+e.xyy*ep).x + \n\t\t\t\t\t e.yyx*map(pos+e.yyx*ep).x + \n\t\t\t\t\t e.yxy*map(pos+e.yxy*ep).x + \n\t\t\t\t\t e.xxx*map(pos+e.xxx*ep).x );\n#else\n    \/\/ inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+e*ep).x;\n    }\n    return normalize(n);\n#endif    \n}\n\n\/\/=========================================================================\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat ao = 0.0;\n\n\tvec3 v = normalize(vec3(0.7,0.5,0.2));\n\tfor( int i=ZERO; i<12; i++ )\n\t{\n\t\tfloat h = abs(sin(float(i)));\n\t\tvec3 kv = v + 2.0*nor*max(0.0,-dot(nor,v));\n\t\tao += clamp( map(pos+nor*0.01+kv*h*0.08).x*3.0, 0.0, 1.0 );\n\t\tv = v.yzx; if( (i&2)==2) v.yz *= -1.0;\n\t}\n\tao \/= 12.0;\n\tao = ao + 2.0*ao*ao;\n\treturn clamp( ao*5.0, 0.0, 1.0 );\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/rmshadows\nfloat calcSoftShadow( in vec3 ro, in vec3 rd, float k )\n{\n\tfloat res = 1.0;\n\tfloat t = 0.001;\n\tfor( int i=ZERO; i<50; i++ )\n\t{\n\t\tfloat h = map(ro + rd*t ).x;\n\t\tres = min( res, smoothstep(0.0,1.0,1.4*k*(h+0.0015)\/sqrt(t)) );\n\t\tt += clamp( h, 0.003, 0.1 );\n\t\tif( res<0.001 || t>0.8) break;\n\t}\n\treturn clamp(res,0.0,1.0);\n}\n\n\nvec3 shade( in vec3 ro, in vec3 rd, in float t, in float m, in float matInfo )\n{\n\tfloat eps = (abs(m-3.0)<0.2) ? 0.002: 0.0002;\n\t\n\tvec3 pos = ro + t*rd;\n\tvec3 nor = calcNormalmap( pos, eps );\n\t\n\n\tvec3 mateD = vec3(0.0);\n\tvec2 mateK = vec2(0.0);\n\tfloat mateS = 0.0;\n\tvec3 mateSG = vec3(1.0);\n\n\tif( m<1.5 )\n\t{\n\t\tmateD = vec3(0.132,0.06,0.06);\n\t\t\n\t\tvec3 p = transformHead( pos );\n\t\tvec3 headp = p;\n\t\tvec3 q = vec3( abs(p.x), p.yz );\n\n\t\tfloat m = 1.0 - smoothstep( 0.04, 0.14, length(q-vec3(0.16,-0.11,0.23)) );\n\t\tfloat no = texture(iChannel0,p.xy).x;\n\t\tm = clamp( m + 0.25*(-1.0+2.0*no), 0.0, 1.0 );\n\t\tmateD = mix( mateD, vec3(0.13,0.03,0.03), m );\n\t\t\n\n\t\tmateSG = vec3(0.75,0.97,1.0);\n\n\t\t\t\t\t\n\t\tm = 1.0 - smoothstep( 0.04, 0.17, length(q-vec3(0.45,-0.01,0.0)) );\n\t\tmateD += vec3(1.0,0.01,0.0)*m*0.3*(1.0+0.4*sign(p.x));\n\t\tmateSG = mix( mateSG, vec3(0.3-0.1*sign(p.x),0.9,1.0), m );;\n\n\t\tm = 1.0 - smoothstep( 0.05, 0.1, length(vec3(0.5,1.0,1.0)*(q-vec3(0.0,-0.06,0.23))) );\n\n\t\tvec2 uv = pos.xy*22.0;\n\t\tvec2 iuv = floor(uv);\n\t\tvec2 fuv = fract(uv);\n\t\tvec4 ran = texelFetch( iChannel0, (ivec2(iuv)+6)&255, 0 );\n\t\tvec2 off = ran.xy;\n\t\tfloat sss = pow(ran.z,5.0);\n\t\tfloat size = max(0.0,(0.5+0.5*m)*(0.3+0.7*sss)*0.12);\n\t\tfloat fr = 1.0 - smoothstep( size*0.5, size*2.0, length(fuv-off) );\n\t\tmateD = mix(mateD,vec3(0.25,0.05,0.0)*0.2, 0.6*(1.0-0.4*sss)*fr );\n\t\t\t\t\t\n\t\tmateK = vec2(0.08,0.5);\n\t\tmateS = 1.0;    \n\n\t\t\n\t\tvec3 bocap = headp-vec3(-0.006,-0.025,0.22);\n\t\tbocap.xy = mat2x2(0.99,-0.141,0.141,0.99)*bocap.xy;\n\t\tbocap.yz = mat2x2(0.9,-0.346,0.346,0.9)*bocap.yz;\n\t\t\n\t\t{\n\t\tvec4 b = sdBezier( corner1, center, corner2, bocap );\n\t\tfloat d1 = b.x - 0.01*4.0*b.y*(1.0-b.y);\n\t\tfloat isLip = 1.0-smoothstep( 0.0005, 0.0050, d1 );\n\t\tmateD = mix( mateD, vec3(0.14,0.04,0.05), 0.7*isLip );\n\t\tmateK = mix( mateK, vec2(0.4,1.5), isLip );\n\t\t}\n\t\t\n\t\tmateK *= 0.5 + no;\n\t}\n\telse if( m<2.5 )\n\t{\n\t\tmateD = vec3(0.18,0.18,0.225)*0.85;\n\t\tmateK = vec2(0.5,10.0);\n\t\tmateSG = vec3(1.0,1.0,0.9);\n\t\t\n        \n\t\tvec3 p = transformHead( pos );\n\t\tvec3 q = vec3( abs(p.x), p.yz );\n        q.x -= eyeOff;\n        \n\t\t\n\t\tvec2 r = q.xy-vec2(0.102+0.004*sign(p.x),0.03+0.004);\n\t\t\n\t\tfloat m = length(r) - 0.042;\n\t\tif( m<0.0 )\n\t\t{\n\t\t\tm = abs(m);\n\t\t\tmateD = mix( mateD, vec3(0.0), smoothstep(0.0,0.003,m));\n\t\t\tmateD = mix( mateD, vec3(0.06,0.02,0.0), smoothstep(0.003,0.006,m));\n\t\t\t\n\t\t\tr.x *= -sign(p.x);\n\t\t\tfloat an = atan(r.y,r.x) + 1.5;\n\t\t\tfloat ca = 1.0-smoothstep(0.0,1.0,abs(an-1.0));\n\t\t\tca *= 1.0-smoothstep(0.0,0.008,abs(m-0.011));\n\n\t\t\tfloat te = texture(iChannel0, vec2(an*0.1,m)).x;\n\t\t\tmateD = mix( mateD, (1.8*te*vec3(0.06,0.02,0.0)+(0.5+0.5*te)*ca*1.3*vec3(0.1,0.07,0.05)), smoothstep(0.003,0.006,m));\n\n\t\t\tmateD = mix( mateD, vec3(0.0), smoothstep(0.017,0.018,m-0.001));\n\t\t\tmateK = vec2(0.05,8.0);\n\t\t}\n\n\t\tr = q.xy-vec2(0.105+0.03*sign(p.x),0.058);\n\t\tmateD += (1.0-smoothstep(0.00,0.012,length(r)))*1.0;\n\t}\n\telse if( m<3.5 )\n\t{\n\t\tfloat focc = smoothstep(0.0,1.0,matInfo);\n\n\t\tmateD = vec3(0.025,0.015,0.01)*0.6*focc;\n\t\tmateK = vec2(0.1*focc,1.0);\n\t}\n\telse if( m<4.5 )\n\t{\n\t\tvec3 hatp = pos;\n\t\thatp = transformHat(hatp);\n\t\thatp.y += 0.1;\n\t\tfloat f = abs(hatp.x)-hatp.z;\n\t\tf = smoothstep(0.19,0.2,f );\n\t\t\n\t\tvec3 blue = vec3(0.01,0.04,0.08);\n\t\tvec3 te = \n\t\ttexture( iChannel0, 0.15*pos.yz ).xyz+\n\t\ttexture( iChannel0, 1.0*pos.yz ).xyz;\n\t\tblue *= 0.5+0.5*te.z;\n\t\tmateD = mix( vec3(0.18), blue, f );\n\t\tmateS = 0.05;\n\t\t\n\t\t\t\n\t\tvec2 si = (hatp.xy-vec2(0.0,-0.18)) * 3.5;\n\t\tfloat h = si.y - 0.1*sin( 8.0*si.x );\n\t\th = min( abs(h-1.15)-0.06, abs(h-1.0)-0.015 );\n\t\th += clamp( (abs(hatp.x)-0.25)\/0.1, 0.0, 1.0 );\n\t\tmateD = mix( mateD, vec3(0.004,0.008,0.014), 1.0-smoothstep( 0.01, 0.02, h ) );\n\t\t\n\t}\n\telse if( m<5.5 )\n\t{\n\t\tmateD = 0.5*vec3(0.01,0.04,0.08);\n\t\tmateD *= 0.7+0.6*texture( iChannel0, 2.0*pos.xz ).x;\n\t\tmateS = 0.05;\n\t}\n\telse if( m<8.5 )\n\t{\n\t\tmateD = vec3(0.30,0.30,0.40)*0.5;\n\t\tmateK = vec2(0.5,1.0);\n\t\tmateS = 0.2;\n\t\t\n\t}\n\t\n\tfloat fre = clamp(1.0+dot(nor,rd), 0.0, 1.0 );\n\tfloat occ = calcAO( pos, nor );\n\t\n\tvec3 col = vec3(0.0);\n\t\n    {\n\t\t\/\/ key\n\t\tfloat dif1 = dot(nor,sunDir);\n\t\tvec3 hal = normalize( sunDir-rd );\n\t\tfloat spe = pow(clamp(dot(hal,nor),0.0,1.0),0.001+8.0*mateK.y);\n\t\tfloat sha = calcSoftShadow( pos+nor*0.0005, sunDir, 24.0 ); \n\t\tfloat ssha = 1.0;\n\t\tif( abs(m-3.0)<0.2 ) { dif1=0.5*dif1+0.5; sha=0.95*sha+0.05;  }\n\t\tif( abs(m-2.0)<0.2 ) { sha=clamp(0.2+sha*dif1*2.0,0.0,1.0); dif1=0.4+0.6*dif1; ssha=0.0; }\n\t\t\n\t\tdif1 = clamp(dif1,0.0,1.0);\n\n        float sks = (abs(m-1.0)<0.2)?0.5:0.0;\n\t\tvec3 sha3 = vec3((1.0-sks)*sha+sks*sqrt(sha),sha*0.4+0.6*sha*sha,sha*sha);\n\t\t\n\t\tcol += mateD*3.1*vec3(2.5,1.1,0.5)*dif1*sha3;\n\t\tcol += mateK.x*vec3(1.5,1.4,1.3)*dif1*sha*spe*(0.04+0.96*pow(clamp(dot(hal,nor),0.0,1.0),5.0))*ssha;\n    }\n\t{\n\t\t\/\/ fill\n\t\tcol += mateD*vec3(0.45,0.75,1.0)*occ*occ*occ*(0.5+0.5*nor.y)*4.5;\n\t\tfloat dif1 = 0.5 + 0.5*nor.y;\n\t\tfloat sha = 1.0;\n\t\tfloat spe = smoothstep( -0.15, 0.15, reflect(rd,nor).y );\n\t\tcol += mateK.x*vec3(0.7,0.9,1.0)*dif1*sha*spe*(0.04+0.96*pow(clamp(dot(rd,nor),0.0,1.0),5.0))*occ*occ*3.0;\n\t}\n\t{\n\t\t\/\/ bounce\n\t\tvec3 bak = normalize( sunDir*vec3(-1.0,-3.5,-1.0));\n\t\tfloat dif = clamp(0.3+0.7*dot(nor,bak),0.0,1.0);\n\t\tcol += mateD*vec3(1.2,0.8,0.6)*occ*occ*dif*2.5;\n\t}\n\t{\n\t\tcol += mateS*mateD*fre    *vec3(2.0,0.95,0.80)*0.7*occ;\n\t\tcol += mateS*mateD*fre*fre*vec3(1.1,0.80,0.65)*1.2*occ;\n\t}\n\n\tcol = pow( col, mateSG );\n\n    return col;\n}\n\n\/\/--------------------------------------------\n\nvec3 intersect( in vec3 ro, in vec3 rd, float mindist, float maxdist )\n{\n\tvec3 res = vec3(-1.0);\n\t\n\tfloat t = mindist;\n\tfor( int i=ZERO; i<150; i++ )\n\t{\n\t\tvec3 p = ro + t*rd;\n\t\tvec3 h = map( p );\n\t\tres = vec3(t,h.yz);\n\t\tif( abs(h.x)<0.00025 || t>maxdist ) break;\n\t\tt += h.x;\n\t}\n\treturn res;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 uv, in int sampleID )\n{\n\tvec4 res = texture(iChannel1,uv);\n\tvec3 col = res.xyz;\n\t\n\tconst float mindist = 0.8;\n\tconst float maxdist = 1.8;\n\t\n\tvec3 tm = intersect( ro, rd, mindist, maxdist );\n\tif( tm.y>-0.5 && tm.x < maxdist )\n\t{\n\t\tcol = shade( ro, rd, tm.x, tm.y, tm.z );\n\t}\n\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tmat3 ca; vec3 ro; float fl;\n\tcomputeCamera( iTime, ca, ro, fl );\n#if AA<2\n\tvec2  p = (2.0*fragCoord-iResolution.xy)\/iResolution.y;\n    vec3  rd = normalize( ca*vec3(p,-fl) );\n\tvec3 col = render( ro, rd, fragCoord.xy\/iResolution.xy, 0 );\n#else\n\tvec3 col = vec3(0.0);\n\tfor( int m=ZERO; m<AA; m++ )\n\tfor( int n=ZERO; n<AA; n++ )\n\t{\n\t\tvec2 rr = vec2( float(m), float(n) ) \/ float(AA) - 0.5;\n\t\tvec2 p = (2.0*(fragCoord.xy+rr)-iResolution.xy)\/iResolution.y;\n\t\tvec3 rd = normalize( ca * vec3(p,-fl) );\n\t\tcol += render( ro, rd, (fragCoord+rr)\/iResolution.xy, AA*m+n );\n\t}    \n\tcol \/= float(AA*AA);\n#endif\n\t\t\n\tfragColor = vec4( col, 1.0 );\n}","name":"Buffer C","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"MsdGzl","date":"1451942717","viewed":28563,"name":"Basic Montecarlo","username":"iq","description":"A simple pathtracer, with progressive rendering. The random numbers are really bad quality, so this is probably noisier than it should, and biased. I have disabled the specular reflections.","likes":198,"published":3,"flags":32,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"\/\/ Copyright Inigo Quilez, 2016 - https:\/\/iquilezles.org\/\n\/\/ I am the sole copyright owner of this Work.\n\/\/ You cannot host, display, distribute or share this Work in any form,\n\/\/ including physical and digital. You cannot use this Work in any\n\/\/ commercial or non-commercial product, website or project. You cannot\n\/\/ sell this Work and you cannot mint an NFTs of it.\n\/\/ I share this Work for educational purposes, and you can link to it,\n\/\/ through an URL, proper attribution and unmodified screenshot, as part\n\/\/ of your educational material. If these conditions are too restrictive\n\/\/ please contact me and we'll definitely work it out.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 data = texelFetch( iChannel0, ivec2(fragCoord), 0 );\n    vec3 col = data.xyz\/data.w;\n\n    \/\/ tonemap\n    col = col*1.4\/(1.0+col);\n    \n    \/\/ gamma\n    col = pow( col, vec3(0.4545) );\n    \n    \/\/ vignetting\n\tvec2 uv = fragCoord \/ iResolution.xy;\n    col *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 );\n    \n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ Pathtrace the scene. One path per pixel. Samples the sun light\n\/\/ and the sky dome light at each vertex of the path.\n\/\/\n\/\/ More info: https:\/\/iquilezles.org\/articles\/simplepathtracing\n\n\/\/------------------------------------------------------------------\n\/\/ oldschool rand() from Visual Studio\n\/\/------------------------------------------------------------------\nint   seed = 1;\nint   rand(void) { seed = seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())\/32767.0; }\nvoid  srand( ivec2 p, int frame )\n{\n    int n = frame;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589; \/\/ by Hugo Elias\n    n += p.y;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589;\n    n += p.x;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589;\n    seed = n;\n}\n\/\/------------------------------------------------------------------\nvec3 cosineDirection( in vec3 nor)\n{\n    float u = frand();\n    float v = frand();\n\n    \/\/ Method 1 and 2 first generate a frame of reference to use\n    \/\/ with an arbitrary distribution, cosine in this case.\n    \/\/ Method 3 (invented by fizzer) specializes the whole math to\n    \/\/ the cosine distribution and simplifies the result to a more\n    \/\/ compact version that does not even need constructing a frame\n    \/\/ of reference.\n\n    #if 0\n        \/\/ method 1 by http:\/\/orbit.dtu.dk\/fedora\/objects\/orbit:113874\/datastreams\/file_75b66578-222e-4c7d-abdf-f7e255100209\/content\n        vec3 tc = vec3( 1.0+nor.z-nor.xy*nor.xy, -nor.x*nor.y)\/(1.0+nor.z);\n        vec3 uu = vec3( tc.x, tc.z, -nor.x );\n        vec3 vv = vec3( tc.z, tc.y, -nor.y );\n        float a = 6.2831853*v;\n        return sqrt(u)*(cos(a)*uu + sin(a)*vv) + sqrt(1.0-u)*nor;\n    #endif\n\t#if 0\n    \t\/\/ method 2 by pixar:  http:\/\/jcgt.org\/published\/0006\/01\/01\/paper.pdf\n    \tfloat ks = (nor.z>=0.0)?1.0:-1.0;     \/\/do not use sign(nor.z), it can produce 0.0\n        float ka = 1.0 \/ (1.0 + abs(nor.z));\n        float kb = -ks * nor.x * nor.y * ka;\n        vec3 uu = vec3(1.0 - nor.x * nor.x * ka, ks*kb, -ks*nor.x);\n        vec3 vv = vec3(kb, ks - nor.y * nor.y * ka * ks, -nor.y);\n        float a = 6.2831853 * v;\n        return sqrt(u)*(cos(a)*uu + sin(a)*vv) + sqrt(1.0-u)*nor;\n    #endif\n    #if 1\n    \t\/\/ method 3 by fizzer: http:\/\/www.amietia.com\/lambertnotangent.html\n        float a = 6.2831853*v; float b = 2.0*u-1.0;\n        vec3 dir = vec3(sqrt(1.0-b*b)*vec2(cos(a),sin(a)),b);\n        return normalize( nor + dir );\n    #endif\n}\nvec3 uniformVector(void)\n{\n    float phi = frand()*6.28318530718;\n    float x = frand()*2.0-1.0;\n    float z = frand();\n\treturn pow(z,1.0\/3.0)*vec3(sqrt(1.0-x*x)*vec2(sin(phi),cos(phi)),x);\n}\n    \n\/\/------------------------------------------------------------------\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3  di = abs(p) - b;\n  float mc = max(di.x,max(di.y,di.z));\n  return min(mc,length(max(di,0.0)));\n}\n\nvec2 map( vec3 p )\n{\n    vec3 w = p;\n    vec3 q = p;\n\n    q.xz = mod( q.xz+1.0, 2.0 ) -1.0;\n    \n    float d = sdBox(q,vec3(1.0));\n    float s = 1.0;\n    for( int m=0; m<6; m++ )\n    {\n        float h = float(m)\/6.0;\n\n        p =  q - 0.5*sin( abs(p.y) + float(m)*3.0+vec3(0.0,3.0,1.0));\n\n        vec3 a = mod( p*s, 2.0 )-1.0;\n        s *= 3.0;\n        vec3 r = abs(1.0 - 3.0*abs(a));\n\n        float da = max(r.x,r.y);\n        float db = max(r.y,r.z);\n        float dc = max(r.z,r.x);\n        float c = (min(da,min(db,dc))-1.0)\/s;\n\n        d = max( c, d );\n   }\n\n   vec2 res = vec2(d,1.0);\n    \n   {\n   d = length(w-vec3(0.22,0.35,0.4)) - 0.09;\n   if( d<res.x ) res=vec2(d,2.0);\n   }\n   \n   {\n   d = w.y + 0.22;\n   if( d<res.x ) res=vec2(d,3.0);\n   }\n    \n   return res;\n}\n\n\/\/------------------------------------------------------------------\n\nvec3 calcNormal( in vec3 pos )\n{\n    const vec2 eps = vec2(0.0001,0.0);\n    return normalize( vec3(\n      map( pos+eps.xyy ).x - map( pos-eps.xyy ).x,\n      map( pos+eps.yxy ).x - map( pos-eps.yxy ).x,\n      map( pos+eps.yyx ).x - map( pos-eps.yyx ).x ) );\n}\n\nvec2 intersect( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n    float tmax = 16.0;\n    float t = 0.01;\n    for(int i=0; i<128; i++ )\n    {\n        vec2 h = map(ro+rd*t);\n        res = vec2(t,h.y);\n        if( h.x<0.0001 || t>tmax ) break;\n        t += h.x;\n    }\n    \n    if( t>tmax ) res.x = -1.0;;\n\n    return res;\n}\n\nfloat shadow( in vec3 ro, in vec3 rd )\n{\n    float res = 0.0;\n    \n    float tmax = 12.0;\n    \n    float t = 0.001;\n    for(int i=0; i<80; i++ )\n    {\n        float h = map(ro+rd*t).x;\n        if( h<0.0001 || t>tmax) break;\n        t += h;\n    }\n\n    return (t<tmax) ? res : 1.0;\n}\n\nconst float epsilon = 0.0001;\nvec3 light( vec3 surfColor, float surfSpecN, bool surfIsMetal,\n            vec3 pos, vec3 nor, vec3 rd, \n            vec3 ligDir, vec3 ligColor )\n{\n    vec3 fo = (!surfIsMetal) ? vec3(0.04) : surfColor;\n\n    vec3  hal = normalize(ligDir-rd);\n    float dif = max(0.0, dot(ligDir, nor));\n    float sha = 1.0; if( dif > 0.00001 ) sha = shadow( pos + nor*epsilon, ligDir);\n    float spe = (surfSpecN+0.0)\/8.0*pow(clamp(dot(nor,hal),0.0,1.0),surfSpecN);\n    vec3  fre = fo + (1.0-fo)*pow(clamp(1.0-dot(hal,ligDir),0.0,1.0),5.0);\n    \n    vec3 res = vec3(0.0);\n\n    if( !surfIsMetal )\n    res += surfColor * ligColor * dif * sha;\n    res +=             ligColor * dif * sha * spe * fre * 3.0;\n    return res;\n}\n\nconst vec3 sunDir = normalize(vec3(-0.3,1.3,0.1));\nconst vec3 sunCol = 12.0*vec3(1.1,0.8,0.6);\nconst vec3 skyCol = 6.0*vec3(0.2,0.5,0.8);\n\nvec3 calculateColor(vec3 ro, vec3 rd )\n{\n    vec3 colorMask = vec3(1.0);\n    vec3 accumulatedColor = vec3(0.0);\n\n    float fdis = 0.0;\n    for( int bounce = 0; bounce<4; bounce++ ) \/\/ bounces of GI\n    {\n        \/\/rd = normalize(rd);\n       \n        \/\/-----------------------\n        \/\/ trace\n        \/\/-----------------------\n        vec2 tm = intersect( ro, rd );\n        float t = tm.x;\n        if( t < 0.0 )\n        {\n            if( bounce==0 ) return mix( 0.1*vec3(0.8,0.9,1.0), skyCol, smoothstep(0.05,0.1,rd.y) );\n            break;\n        }\n\n        if( bounce==0 ) fdis = t;\n\n        vec3 pos = ro + rd * t;\n        vec3 nor = calcNormal( pos );\n        \n        \/\/-----------------------\n        \/\/ material\n        \/\/-----------------------\n\n        vec3  surfColor;\n        float surfSpecN;\n        bool  surfIsMetal;\n        if( tm.y<1.5 )\n        {\n        surfColor= vec3(0.38)*vec3(1.2,0.8,0.6);\n        surfIsMetal = false;\n        surfSpecN = 8.0;\n        }\n        else if( tm.y<2.5 )\n        {\n        \/\/surfColor = vec3(0.37);\n        surfColor = vec3(0.9,0.8,0.5);\n        surfIsMetal = true;\n        surfSpecN = 2000.0;\n        }\n        else \/\/if( tm.y<2.5 )\n        {\n        surfColor = vec3(0.38)*vec3(1.2,0.8,0.6);\n        surfIsMetal = false;\n        surfSpecN = 8.0;\n        }\n\n\n        \/\/-----------------------\n        \/\/ sample light sources\n        \/\/-----------------------\n\n        \/\/ light 1 : sun\n        accumulatedColor += light(surfColor*colorMask,surfSpecN,surfIsMetal,\n                                  pos,nor,rd,\n                                  sunDir, sunCol );\n\n        \/\/ light 2 : sky\n        #if 0\n        \/\/ sample sky uniformly\n        vec3 skyDir = uniformVector();\n        if( skyDir.y<0.0 ) skyDir=-skyDir;\n        accumulatedColor += light(surfColor*colorMask,surfSpecN,surfIsMetal,\n                                  pos,nor,rd,\n                                  skyDir, skyCol )*3.1415;\n        #else\n        \/\/ sample sky cosine weighted\n        vec3 skyDir = cosineDirection(nor);\n        if( skyDir.y<0.0 ) skyDir=-skyDir;\n        accumulatedColor += light(surfColor*colorMask,surfSpecN,surfIsMetal,\n                                  pos,nor,rd,\n                                  skyDir, skyCol )\/(dot(nor,skyDir)+0.00001);\n        #endif                          \n\n        \/\/---------------------------------\n        \/\/ bounce and gather indirect light\n        \/\/---------------------------------\n        \n        if( surfIsMetal )\n        {\n            \/\/ TODO: I feel need to multiply colorMask by fresnel\n            colorMask *= surfColor;\n            float glo = clamp(1.0-surfSpecN\/2048.0,0.0,1.0);\n            glo = glo*glo;\n            rd = normalize(reflect(rd,nor)) + glo*uniformVector();\n        }\n        else\n        {\n            \/\/float isDif = 1.0;\n            \/\/if( frand() < isDif )\n            {\n               colorMask *= surfColor;\n               rd = cosineDirection(nor);\n            }\n            \/\/else\n            \/\/{\n            \/\/    float glo = clamp(1.0-surfSpecN\/2048.0,0.0,1.0);\n            \/\/    glo = glo*glo;\n            \/\/    rd = normalize(reflect(rd,nor)) + glo*uniformVector();\n           \/\/ }\n        }\n        ro = pos;\n   }\n\n   float ff = exp2(-0.2*fdis);\n   accumulatedColor *= ff; \n   accumulatedColor += (1.0-ff)*(1.0-ff)*0.1*vec3(0.8,0.9,1.0);\n\n\n   \n   \n   return accumulatedColor;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 rt, in float cr )\n{\n\tvec3 cw = normalize(rt-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ init randoms\n    srand( ivec2(fragCoord), iFrame );\n\n    \n    vec2 of = -0.5 + vec2( frand(), frand()  );\n    vec2 p = (2.0*(fragCoord+of)-iResolution.xy)\/iResolution.y;\n\n    vec3 ro = vec3(0.0,0.0,0.0);\n    vec3 ta = vec3(1.5,0.7,1.5);\n\n    mat3  ca = setCamera( ro, ta, 0.0 );\n    vec3  rd = normalize( ca * vec3(p,-1.3) );\n\n    vec4 data = texture( iChannel0, fragCoord\/iResolution.xy );\n    if( iFrame==0 ) data = vec4(0.0);\n    \n    data += vec4( calculateColor( ro, rd ), 1.0 );\n\n    fragColor = data;\n}","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"WtSBzh","date":"1611688746","viewed":10716,"name":"prism liquid","username":"louis_C","description":"little doodeling with liquid","likes":180,"published":1,"flags":40,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n      vec2 uv = fragCoord\/iResolution.xy;\n    vec3 col = vec3(0.);\n    float b = sqrt(64.);\n    float v1 = distance(uv.y,0.5)*0.005+0.0002;\n    for(float i = -0.5*b;i<=0.5*b;i++)\n    for(float j=-0.5*b;j<=0.5*b;j++)\n    {\n    col += texture(iChannel0,uv+vec2(i,j)*v1).xyz;\n    }\n    col\/=64.;\n    float m = (1.-distance(uv.x,0.5))*(1.-distance(uv.y,0.5));\n    fragColor = vec4(pow(col,vec3(mix(2.,1.,m))),1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvec2 isphe ( in vec3 ro, in vec3 rd, in vec3 cen , in float rad)\n{\nro -= cen;\nfloat b = dot(rd,ro);\nfloat c =dot(ro,ro)-rad*rad;\nfloat h = b*b-c;\nif(h<0.)return vec2(-1.);\nh = sqrt(h);\nreturn vec2(-b-h,-b+h);\n}\nfloat pi = 3.141592653589793;\nvoid moda(inout vec2 p, float r){\nfloat pe = (2.*pi)\/r;float a=atan(p.y,p.x);\na = mod(a,pe)-pe*0.5; p = vec2(cos(a),sin(a))*length(p);\n}\nvec3 rore(vec3 p, float r){\nfloat pe = (2.*3.14)\/r;\nfloat a = atan (p.z,p.x);\na = mod (a,pe)-pe*0.5;\nvec2 pp = vec2 (cos(a),sin(a))*length(p.xz);\nreturn vec3(pp.x,p.y,pp.y);}\nfloat ov(float a, float b){return a<0.5? (2.*a*b) : (1.-2.*(1.-a)*(1.-b));}\nvec3 ov (vec3 a, vec3 b) {return vec3(ov(a.x,b.x),ov(a.y,b.y),ov(a.z,b.z));}\nmat2 rot (float t){float c=cos(t);float s=sin(t);return mat2(c,-s,s,c);}\nfloat oc (vec3 p, float s){p = abs(p);return (p.x+p.y+p.z-s)*0.57735027;}\nfloat cap (vec3 p, vec3 a, vec3 b, float r){\nvec3 pa = p-a; vec3 ba = b-a; float h = clamp(dot(pa,ba)\/dot(ba,ba),0.,1.);\nreturn length(pa-ba*h)-r;}\nfloat smin (float a, float b, float f){float h=clamp(0.5+0.5*(b-a)\/f,0.,1.);\nreturn mix(b,a,h)-f*h*(1.-h);}\nfloat rd(float t) { return fract(sin(dot(floor(fract(t*0.05)*20.),84.259))*7846.236);}\nfloat no (float t){return mix(rd(t),rd(t+1.),smoothstep(0.,1.,fract(t)));}\nfloat it(float t){float r=0.;float a=0.5;for(int i =0; i<5;i++){\nr +=no(t\/a)*a;a*=0.5;\n}return r;}\nfloat rd(vec2 t) { return fract(sin(dot(floor(t),vec2(957.23,84.259)))*7846.236);}\nfloat hs(vec2 t) { return fract(sin(dot((t),vec2(957.23,84.259)))*7846.236);}\nfloat hs2(vec2 t) { return fract(sin(dot((t),vec2(957.23,84.259)))*7846.236+iTime*3.);}\nfloat no(vec2 t) {vec2 e= vec2(1.,0.);float a =rd(t);float b=rd(t+e.xy);float c=rd(t+e.yx);float d=rd(t+e.xx);\nvec2 h = smoothstep(0.,1.,fract(t));return mix(mix(a,b,h.x),mix(c,d,h.x),h.y);}\nfloat it(vec2 t){float r=0.;float a=0.5;for(int i =0; i<4;i++){\nr +=no(t\/a)*a;a*=0.5;\n}return r;}\nfloat rd2(vec2 t) { return fract(sin(dot(floor(t),vec2(957.23,84.259)))*7846.236+iTime*2.);}\nfloat no2(vec2 t) {vec2 e= vec2(1.,0.);float a =rd2(t);float b=rd2(t+e.xy);float c=rd2(t+e.yx);float d=rd2(t+e.xx);\nvec2 h = smoothstep(0.,1.,fract(t));return mix(mix(a,b,h.x),mix(c,d,h.x),h.y);}\nfloat it2(vec2 t){float r=0.;float a=0.5;for(int i =0; i<4;i++){\nr +=no2(t\/a)*a;a*=0.5;\n}return r;}\nfloat vt = 0.;\nfloat t2 = 0.;\nfloat map(vec3 p){\nfloat vrt = smoothstep(0.2,1.,pow(it(iTime*0.7),2.))*30.+1.; \n\/\/float vrt = 15.;\nfloat tt = iTime*1.1;\nvec3 p2 = p*vec3(1.,0.8,1.);\np2.xz *= rot(iTime*1.1);\nmoda (p2.xz,vrt);\nfloat s1 = oc(p2,3.);\nt2 = ov(it(p2.xz*1.2),mix(rd(p2.xz*100.),0.5,0.8));\nvec3 p3 = p;\np3.xz*=rot(p.y*it((p.x+p.z+tt*0.1)*0.3)*0.2);\np3.y += (it(p.x*0.3+tt)+it(p.z*0.3+tt))*-1.;\nmoda (p3.xz,vrt);\nfloat s2 =length(p3);\nfor (int i =0;i<18;i ++){\nfloat v1 = no(tt+float(i)*98.236);\nfloat v2 = no(tt+float(i)*15.76);\nfloat v3 = no(tt+float(i)*125.236);\nfloat vr = iTime+float(i)*26.265+v3;\nfloat cc = cap (p3 , vec3(sin(vr)*3.,v3,cos(vr)*3.5),vec3(sin(vr+v1*0.5)*3.5,v2,cos(vr+v1*0.5)*3.),v1*0.2);\nfloat cc2 = length (p3+vec3(sin(tt+float(i)*48.236+v2)*3.5,v3,cos(tt+float(i)*48.236+v2)*3.5))-v3*0.2;\ns2 = smin (s2,cc,0.8);\ns2 = smin(s2,cc2,0.8);\n\n}\nvt =s2;\nreturn min(s1,s2);}\nvec3 nor( vec3 p ){ vec2 e = vec2(0.01,0.);return normalize(map(p)-vec3(map(p-e.xyy),map(p-e.yxy),map(p-e.yyx)));}\nvec3 sky (vec3 p){return max(smoothstep(-1.,1.,dot(p,vec3(1,0.,0.)))*vec3(0.2,0.4,0.4),smoothstep(0.5,0.8,dot(p,vec3(0,1.,0.))));}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \nfloat time = iTime;\nfloat tau = 6.28318530717958647692;\n    vec2 uv = -1. + 2. * fragCoord\/iResolution.xy;\n    uv.x*= iResolution.x\/iResolution.y;\n    float t1 = time;\n    vec3 e = vec3(0.,0.,-6.);\n    vec3 r = normalize(vec3(uv,1.));\n    float vm1 = (it(time*0.7)-0.4)*0.5;\n    e.yz *= rot(vm1);\n    r.yz *= rot(vm1);\n    vec3 p = e;\n   \n    float side =sign(map(p));\n    vec3 col ;\n    float dd = 0.;\n    float prod  = 1.;\n    vec2 vol = isphe (e,r,vec3(0.,0.8,0.), 4.);\n    if(vol.y>0.0)\n    {\n    for (int i = 0; i< 48; i ++){\n    float d = map(p)*side;\n    if(dd>20.){dd = 20.;break;}\n    if(d<0.001){\n    float tex = mix(0.9,1.,smoothstep(0.3,0.8,t2));\n    vec3 n = nor(p)*side;\n    float opa = smoothstep(0.1,0.,vt);\n     vec3 l1 = sky(reflect(r,n*tex))*0.8;\n     \/\/float oc =mix(smoothstep(-1.,1.,map(p+n*0.3)\/0.3),1.,opa);\n     \/\/l1*=oc;\n     \/\/vec3 r1 = mix(sky(r),l1*0.8,1.-clamp(map(p),0.,1.));\n     col = l1;\n    side=-side;\n    d=0.01;\n    r = refract(r,n,1.+0.1*side);\n    \/\/prod *= 0.;\n    if(opa==0.)break;\n    \/\/break;\n    }\n    p += r*d;\n    dd +=d;\n    }\n    }\n    else {dd = 20.;}\n  \n     \/\/vec3 col = nor(p);\n     \/\/vec3 l1 = sky(reflect(r,col))*0.5;\n     \/\/l1 += smoothstep(.8,-0.5,pow(dot(col,-r),0.3));\n     \/\/float m = clamp(map(p),0.,1.);\n     \n     \n     float m = smoothstep(0.,15.,dd);\n     vec3 c2 = mix(col,(3.*abs(1.-2.*fract(m*2.5+vec3(0.,-1.\/3.,1.\/3.)))-1.)*col,0.07);\n     vec3 r1 = mix(c2*0.8,sky(r),m);\n     vec3 gr = vec3(hs2(uv),hs2(uv+59.236),hs2(uv+958.236));\n     vec3 r2 = ov(r1,mix(vec3(0.5),gr,0.2));\n     vec3 f1 = pow(r2,vec3(0.5));\n    float fno = it2(uv*5.);\n    float fo1 = smoothstep(0.75,0.9,fno);\n    float fo2 = smoothstep(0.78,0.9,fno);\n    float rgo = smoothstep(0.3,1.,it(time*5.));\n    float fo3 = (fo1-fo2)+0.5-fo2*0.5;\n    vec3 f2 =ov(f1,vec3(mix(0.5,1.-fo3,rgo*0.7)));\n    fragColor = vec4(f2,1.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float rd(float t) { return fract(sin(dot(floor(fract(t*0.05)*20.),84.259))*7846.236);}\nfloat no (float t){return mix(rd(t),rd(t+1.),smoothstep(0.,1.,fract(t)));}\nfloat it(float t){float r=0.;float a=0.5;for(int i =0; i<5;i++){\nr +=no(t\/a)*a;a*=0.5;\n}return r;}\nfloat hash(float x){return fract(sin(x) * 897612.531);}\nfloat voc(float t, float f, float ft,float t2){float x = fract(t * f) \/ f;\nfloat a=(sin(x*6.5*ft)*.4+sin(x*13.*ft)+sin(x*24.*ft)*.2);\n   return a* min(x * 1000., 1.) * exp(x * -200.);}\nvec2 inst2(float t, float var,float t2){\n    vec2 v = vec2(0., 0.);\n    for(int i = 0; i < 16; ++i){\n        float h = float(i);\n       \tfloat m = voc(t + h \/ 3., 50. + pow(2.01, (h - 8.) * .2), var,t2);\n        float pan = hash(h);\n        v.x += m * pan;\n        v.y += m * (1. - pan);\n    }\n    return v * .1;\n}\nvec2 sons ( float time) {float tt = time*1.1;\n    float vrt = smoothstep(0.2,1.,pow(it(time*0.7),2.))*30.+1.;\n    float bt = pow(fract(vrt\/3.14),0.2);\n    float v = sin(bt*50.)*it(time*24.);\n    \n    float v2 =  (fract(sin(dot(time,84.259))*7846.236)-0.5);\n    float v3 = v2 * smoothstep(0.,1.,(1.-pow(fract(vrt\/3.14),0.1))); \n    float v4 = sin(time*250.)*(smoothstep(1.,0.,sin(vrt)*0.5+0.5));\n    float f1 = sin(time*200.+it(tt*0.1)*300.)*it(tt*0.3)  ;\n    float va = 50.+50.*no(time*0.5);\n    return vec2((v4+v*0.05+v3*0.05)+f1*0.5)+ inst2(time,va,time)*0.25;}\nvec2 mainSound( in int samp, float time )\n{\n    \n     float ta = 0.01;    \n    vec2 rev = vec2(0.);\n    float sum = 0.;\n    for(float t = 0.; t<2.;t +=ta){      \n    float rand = fract(120.*sin(t*1000.));\n    float t2 = t + ta*rand*5.;\n    float amp = exp2(-t2);\n    rev += sons( time - t2 ) * amp;\n    sum += amp;}\n    rev \/= sum;    \n    rev *= 10.; \n    vec2 s2 = sons(time);\n    vec2 f =  clamp(mix(vec2(s2.x,rev.x),vec2(rev.y,s2.y),it(time*18.)),-1.,1.);\n    return clamp(f*1.5,0.,1.);\n}","name":"Sound","description":"","type":"sound"}]},{"ver":"0.1","info":{"id":"4tySDW","date":"1485002916","viewed":5413,"name":"Blueprint of the Architekt","username":"s23b","description":"took a shot at cheap edge detection and post-processing. mouse enabled as usual :)\n\nmusic by [url=https:\/\/www.youtube.com\/watch?v=cUvEZgQC-tY]Arms and Sleepers[\/url]","likes":166,"published":3,"flags":96,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SPEED .1\n#define FOV 3.\n\n#define MAX_STEPS 80\n#define EPS .001\n#define RENDER_DIST 5.\n#define AO_SAMPLES 4.\n#define AO_RANGE 100.\n\n#define PI 3.14159265359\n#define saturate(x) clamp(x, 0., 1.)\n\n\/\/ precomputed globals\nfloat _house = 0.;\nfloat _boat = 0.;\nfloat _spaceship = 0.;\nfloat _atmosphere = 0.;\nmat3 _kifsRot = mat3(1, 0, 0, 0, 1, 0, 0, 0, 1);\nfloat _kifsOffset = 0.;\n\n\/\/ rotate 2d space with given angle\nvoid tRotate(inout vec2 p, float angel) {\n    float s = sin(angel), c = cos(angel);\n\tp *= mat2(c, -s, s, c);\n}\n\n\/\/ divide 2d space into s chunks around the center\nvoid tFan(inout vec2 p, float s) {\n    float k = s \/ PI \/ 2.;\n    tRotate(p, -floor((atan(p.y, p.x)) * k + .5) \/ k);\n}\n\n\/\/ rectangle distance\nfloat sdRect(vec2 p, vec2 r) {\n    p = abs(p) - r;\n\treturn min(max(p.x, p.y), 0.) + length(max(p, 0.));\n}\n\n\/\/ box distance\nfloat sdBox(vec3 p, vec3 r) {\n    p = abs(p) - r;\n\treturn min(max(p.x, max(p.y, p.z)), 0.) + length(max(p, 0.));\n}\n\n\/\/ sphere distance\nfloat sdSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\n\/\/ 3d cross distance\nfloat sdCross(vec3 p, vec3 r) {\n    p =abs(p) - r;\n    p.xy = p.x < p.y ? p.xy : p.yx;\n    p.yz = p.y < p.z ? p.yz : p.zy;\n    p.xy = p.x < p.y ? p.xy : p.yx;\n    return length(min(p.yz, 0.)) - max(p.y, 0.);\n}\n\n\/\/ union\nfloat opU(float a, float b) {\n    return min(a, b);\n}\n\n\/\/ intersection\nfloat opI(float a, float b) {\n    return max(a, b);\n}\n\n\/\/ substraction\nfloat opS(float a, float b) {\n    return max(a, -b);\n}\n\n\/\/ smooth union\nfloat opSU(float a, float b, float k)\n{\n    float h = clamp(.5 + .5 * (b - a) \/ k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\n\/\/ house distance\nfloat sdHouse(vec3 p) {\n    p.y += .075;\n    vec3 boxDim = vec3(.2, .15, .2);\n    \n    \/\/ add the walls\n    float d = sdBox(p, boxDim);\n    \n    \/\/ add the windows\n    vec3 q = abs(p);\n    vec3 windSize = vec3(.04, .04, .06);\n    q -= windSize + vec3(.005);\n    d = opI(d, opU(sdCross(q, windSize), .11 - abs(p.y)));\n    \n    \/\/ add the roof\n    q = p;\n    q.y -= .38;\n    tFan(q.xz, 4.);\n    tRotate(q.xy, PI\/4.);\n    d = opU(d, sdBox(q, vec3(.35, .01, .35)));\n    \n    \/\/ make it hollow\n    d = opS(d, sdBox(p, boxDim - vec3(.02)));\n    return d;\n}\n\n\/\/ boat distance\nfloat sdBoat(vec3 p) {\n    \n    \/\/ add the mast (a word I learned today :P)\n    float d = sdBox(p + vec3(0, .05, 0), vec3(.01, .2, .01));\n    \n    \/\/ add the sail\n    vec3 q = p + vec3(0, -.05, .12);\n    float a = sdSphere(q, .2);\n\ta = opS(a, sdSphere(q, .195));\n    q.x = abs(q.x);\n    tRotate(q.yx, .1);\n    a = opI(a, sdBox(q - vec3(0, 0, .1), vec3(.1)));\n    d = opU(d, a);\n    \n    \/\/ add the body of the boat\n    p.x = abs(p.x);\n    p.x += .1;\n    a = sdSphere(p, .3);\n    a = opS(a, sdSphere(p, .29));\n    a = opI(a, p.y + .15);\n    d = opU(d,a);\n    return d;\n}\n\n\/\/ spaceship distance\nfloat sdSpaceship(vec3 p) {\n    tFan(p.xz, 6.);\n    p.x += .3;\n    \n    \/\/ add the cap\n    float d = sdSphere(p, .4);\n    d = opS(d, p.y - .12);\n    \n    \/\/ add the body\n    d = opU(d, sdSphere(p, .39));\n    \n    \/\/ add the fins (another word I learned, thanks google :P)\n    d = opU(d, opI(sdSphere(p + vec3(0, .24, 0), .41), sdRect(p.zx, vec2(.005, .5))));\n    d = opS(d, sdSphere(p + vec3(0, .3, 0), .37));\n    d = opS(d, p.y + .25);\n    return d;\n}\n\n\/\/ atmosphere distance\nfloat sdAtmosphere(vec3 p) {\n    float time = iTime;\n    tRotate(p.yz, time);\n    vec3 q = p;\n    tFan(q.xz, 12.);\n    float d = sdBox(q - vec3(.3, 0, 0), vec3(.01));\n    tRotate(p.yx, time);\n    q = p;\n    tFan(q.yz, 12.);\n    d = opU(d, sdBox(q - vec3(0, .23, 0), vec3(.01)));\n    tRotate(p.xz, time);\n    q = p;\n    tFan(q.yx, 12.);\n    d = opU(d, sdBox(q - vec3(0, .16, 0), vec3(.01)));\n    \n    return d;\n}\n\n\/\/ distance estimation of everything together\nfloat map(vec3 p) {\n    float d = _house <= 0. ? 5. : sdHouse(p) + .1  - _house * .1;\n    if (_boat > 0.) d = opU(d, sdBoat(p) + .1  - _boat * .1);\n    if (_spaceship > 0.) d = opU(d, sdSpaceship(p) + .1  - _spaceship * .1);\n    if (_atmosphere > 0.) d = opU(d, sdAtmosphere(p) + .1 - _atmosphere * .1);\n    \n    \/\/return d;\n    float s = 1.;\n    for (int i = 0; i < 4; ++i) {\n        tFan(p.xz, 10.);\n        p = abs(p);\n        p -= _kifsOffset;\n        \n        p *= _kifsRot;\n        s *= 2.;\n    }\n    \n    return opSU(d, sdBox(p * s, vec3(s \/ 17.)) \/ s, .1);\n}\n\n\/\/ trace the scene from ro (origin) to rd (direction, normalized)\n\/\/ until hit or reached maxDist, outputs distance traveled, the number of steps\n\/\/ and the closest distance achieved during marching (used of cheap edge detection)\nfloat trace(vec3 ro, vec3 rd, float maxDist, out float steps, out float nt) {\n    float total = 0.;\n    steps = 0.;\n    nt = 100.;\n    \n    for (int i = 0; i < MAX_STEPS; ++i) {\n        ++steps;\n        float d = map(ro + rd * total);\n        nt = min(d, nt);\n        total += d;\n        if (d < EPS || maxDist < total) break;\n    }\n    \n    return total;\n}\n\n\/\/ calculate the normal vector\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(.0001, 0);\n    return normalize(vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n\t));\n}\n\n\/\/ ambient occlusion\nfloat calculateAO(vec3 p, vec3 n) {\n    \n    float r = 0., w = 1., d;\n    \n    for (float i = 1.; i <= AO_SAMPLES; i++){\n        d = i \/ AO_SAMPLES \/ AO_RANGE;\n        r += w * (d - map(p + n * d));\n        w *= .5;\n    }\n    \n    return 1.-saturate(r * AO_RANGE);\n}\n\n\/\/ a lovely function that goes up and down periodically between 0 and 1, pausing at the extremes\nfloat pausingWave(float x, float a, float b) { \/\/    ___          ___          ___\n    x = abs(fract(x) - .5) * 1. - .5 + a;      \/\/   \/   \\        \/   \\        \/   \\ \n    return smoothstep(0., a - b, x);           \/\/ --     --------     --------     ------\n}\t\t\t\t\t\t\t\t\t\t\t   \/\/ basically like this :P\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \/\/ transform screen coordinates\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x \/ iResolution.y;\n    \n    \/\/ transform mouse coordinates\n\tvec2 mouse = iMouse.xy \/ iResolution.xy * 2. - 1.;\n    mouse.x *= iResolution.x \/ iResolution.y;\n    mouse *= 2.;\n    \n    \/\/ set time dependent constants\n    float speed = .25 \/ 10.5;\n    float time = mod(iTime, 290.);\n    time -= 10.5;\n    if (time > 167.) time -= 167.; else\n    if (time > 63.) time -= 63.;\n    time -= 5.25;\n\ttime *= speed;\n    \n    \/\/ these determine which object to show\n    _house = pausingWave(time, .15, .125);\n    _boat = pausingWave(time - .125 \/ .1, .15, .125);\n    _spaceship = pausingWave(time - .25 \/ .1, .15, .125);\n    _atmosphere = pausingWave(time - .375 \/ .1, .15, .125) * step(10., iTime);\n    \n    \/\/ set up kifs rotation matrix\n    float a = -texture(iChannel0, vec2(.5, .25)).x + sin(iTime) * .2 + .9;\n    float s = sin(a), c = cos(a);\n    _kifsRot *= mat3(c, -s, 0, s, c, 0, 0, 0, 1);\n    _kifsRot *= mat3(1, 0, 0, 0, c, -s, 0, s, c);\n    _kifsRot *= mat3(c, 0, s, 0, 1, 0, -s, 0, c);\n    \n    \/\/ set up kifs offset\n    _kifsOffset = .07 + texture(iChannel0, vec2(.1, .25)).x * .06;\n    \n    \/\/ set up camera position\n    vec3 rd =  normalize(vec3(uv, FOV));\n    vec3 ro = vec3(0, 0, -2);\n    \n    \/\/ light is relative to the camera\n    vec3 light = vec3(-1., .5, 0);\n    \n    vec2 rot = vec2(0);\n    if (iMouse.z > 0. && iMouse.x > 0. && iMouse.y > 0.) {\n    \t\/\/ rotate the scene using the mouse\n        rot = -mouse;\n    } else {\n        \/\/ otherwise rotate constantly as time passes\n        rot = vec2(\n            iTime * SPEED * PI,\/\/had to slightly modify \\\/ this value due to an issue reported by Fabrice\n            mix(sin(iTime * SPEED) * PI \/ 8., PI \/ 2. - 1e-5, saturate(exp(-iTime + 10.5))));\n    }\n    \n    tRotate(rd.yz, rot.y);\n    tRotate(rd.xz, rot.x);\n    tRotate(light.xz, rot.x);\n    tRotate(ro.yz, rot.y);\n    tRotate(ro.xz, rot.x);\n    \n    \/\/ march\n    float steps, outline, dist = trace(ro, rd, RENDER_DIST, steps, outline); \n    \n    \/\/ calculate hit point coordinates\n    vec3 p = ro + rd * dist;\n    \n    \/\/ calculate normal\n    vec3 normal = getNormal(p);\n    \n    \/\/ light direction\n    vec3 l = normalize(light - p);\n    \n    \/\/ ambient light\n    float ambient = .1;\n    \n    \/\/ diffuse light\n    float diffuse = max(0., dot(l, normal));\n    \n    \/\/ specular light\n    float specular = pow(max(0., dot(reflect(-l, normal), -rd)), 4.);\n    \n    \/\/ \"ambient occlusion\"\n    float ao = calculateAO(p, normal);\n    \n    \/\/ create the background grid\n    vec2 gridUv = fragCoord.xy - iResolution.xy \/ 2.;\n    float grid = dot(step(mod(gridUv.xyxy, vec4(20, 20, 100, 100)), vec4(1)), vec4(.1, .1, .2, .2));\n    \n    \/\/ create blue background\n    vec3 bg = vec3(0, .1, .3) * saturate(1.5 - length(uv) * .5);\n    \n    \/\/ find the edges in the geometry\n    float edgeWidth = .0015;\n    float edge = smoothstep(1., .0, dot(normal, getNormal(p - normal * edgeWidth))) * step(length(p), 1.);\n    \n    \/\/ get the outline of the shapes\n    outline = smoothstep(.005, .0, outline) * step(1., length(p));\n    \n    \/\/ diagonal strokes used for shading\n    vec2 strokes = sin(vec2(uv.x + uv.y, uv.x - uv.y) * iResolution.y * PI \/ 4.) * .5 - .5;\n    \n    \/\/ first part of the shading: ao + marching steps\n    float highlights = (steps \/ float(MAX_STEPS) + sqrt(1. - ao)) * step(length(p), 1.) * .5;\n    highlights = floor(highlights * 5.) \/ 10.;\n    \n    \/\/ second part of the shading: ambient + diffuse + specular light\n    float fog = saturate(length(ro) - dist * dist * .25);\n    float lightValue = (ambient + diffuse + specular) * fog;\n    lightValue = floor(lightValue * 5.) \/ 10.;\n    \n    fragColor.rgb = mix(bg, vec3(1., .9, .7),\n                        max(max(max(saturate(highlights + strokes.x), saturate(lightValue + strokes.y)) * fog,\n                                (edge + outline) * 2. + strokes.y), grid));\n    \n    \/\/ gamma correction\n    fragColor = pow(saturate(fragColor), vec4(1. \/ 2.2)) * step(abs(uv.y), 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"ldfXDl","filepath":"https:\/\/soundcloud.com\/fakechapter\/the-architekt","previewfilepath":"https:\/\/soundcloud.com\/fakechapter\/the-architekt","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ the purpose of this buffer is too smooth out the sudden changes in the fft\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n    float old = texture(iChannel1, uv).x;\n    float new = texture(iChannel0, uv).x;\n    fragColor = vec4(mix(old, new, new > old ? .4 : .04));\n}","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"4dKXDG","date":"1466337141","viewed":6739,"name":"Crossy Penguin [MIGJRV]","username":"RobotPenguin","description":"A tribute to Crossy Road, made by Hector Barreiro-Cabrera and Rosa Ma. Sanchez-Banderas as the 2nd assignment of the PGATR course (MIGJRV master, URJC). Crossy Road is a mobile game developed by Hipster Whale. All rights to their respective owners.","likes":164,"published":1,"flags":112,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"MsfGDX","filepath":"https:\/\/soundcloud.com\/kade-kalka\/the-oyster-groove","previewfilepath":"https:\/\/soundcloud.com\/kade-kalka\/the-oyster-groove","type":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/*\n\n(06\/11\/16)\n\nSome instructions on how to play:\n\nSpace: Used to start the game and restarting on Game Over.\nArrows: Move around the player character.\n1-4: Change the render buffer resolution to get a\n     big speedup (1 - 100%, 2 - 75%, 3 - 50%, 4 - 25%).\n\n--------------------------------------\n\nKnown Issues:\n\n- Some drivers might take long to compile the shader, we're currently looking into this.\n- You might find that the player moves weirdly when jumping\n  on water tiles, we'll try to figure out a better way to handle those cases.\n\nPotential Issues:\n\n- We haven't battle tested the shader on other GPUs than NVIDIA,\n  so we don't know if they'll work at all.\n\n*\/\n\n\/\/ =============================================================================\n\/\/ START OF SHARED CODE\n\/\/ =============================================================================\n\n\/\/ -- Constants ----------------------------------------------------------------\n\n\/\/ State constants.\n\nconst float kStateTitle      = 0.0;\nconst float kStateInGame     = 1.0;\nconst float kStateGameOver   = 2.0;\nconst float kStateRestarting = 3.0;\n\n\/\/ Scene constants.\n\nconst float kSceneWidth         = 5.0;\nconst float kSceneMinTileSpeed  = 2.0;\nconst float kSceneMaxTileSpeed  = 2.0;\n\nconst float kSceneNumChunks     = 3.0;     \/\/ Number of pre-defined chunks in the scene.\nconst float kSceneChunkTiles    = 5.0;     \/\/ Number of tiles per chunk.\nconst float kSceneInvChunkTiles = 0.2;     \/\/ Inverse number of tiles per chunk.\n\nconst float kSceneTileSnow      = 0.0;     \/\/ Id of the snow tile.\nconst float kSceneTileIceRoad   = 1.0;     \/\/ Id of the ice road tile.\nconst float kSceneTileWater     = 2.0;     \/\/ Id of the water tile.\n\nconst float kBehavGround        = 0.0;\nconst float kBehavWater         = 1.0;\nconst float kBehavObstacle      = 2.0;\nconst float kBehavHazard        = 3.0;\nconst float kBehavOutOfScreen   = 4.0;\n\n\/\/ Player motion constants.\n\nconst float kPlayerSpeed      = 5.0;\nconst float kPlayerJumpHeight = 0.3;\n\n\/\/ State coordinates.\n\nconst vec2 kTexState1 = vec2(0.0, 0.0); \/\/ x   = Current state,  y  = State time, w = Init\nconst vec2 kTexState2 = vec2(1.0, 0.0); \/\/ xy  = Current coords, zw = Next coords\nconst vec2 kTexState3 = vec2(2.0, 0.0); \/\/ x   = Motion time, y = Rotation, z = NextRotation, w = Scale\nconst vec2 kTexState4 = vec2(3.0, 0.0); \/\/ xyz = Coordinates, w = Rotation\nconst vec2 kTexState5 = vec2(4.0, 0.0); \/\/ x   = Death cause, y = Death time, z = Score, w = Fb. Scale\n\n\/\/ Misc constants.\n\nconst float kPi = 3.14159265359;\nconst float kOneOverPi = 0.31830988618;\nconst float kOmega = 1e20;\n\n\/\/ -- Global values ------------------------------------------------------------\n\nfloat gGameState;\nfloat gGameStateTime;\nfloat gGameInit;\nfloat gGameSeed;\nvec2  gPlayerCoords;\nvec2  gPlayerNextCoords;\nfloat gPlayerMotionTimer;\nfloat gPlayerRotation;\nfloat gPlayerNextRotation;\nfloat gPlayerScale;\nvec3  gPlayerVisualCoords;\nfloat gPlayerVisualRotation;\nfloat gPlayerDeathCause;\nfloat gPlayerDeathTime;\nfloat gScore;\nfloat gFbScale;\n\n\/\/ -- State functions ----------------------------------------------------------\n\nfloat IsInside(vec2 p, vec2 c)\n{\n    vec2 d = abs(p - 0.5 - c) - 0.5;\n    return -max(d.x, d.y);\n}\n\nvec4 LoadValue(vec2 st)\n{\n    return texture(iChannel0, (0.5 + st) \/ iChannelResolution[0].xy, -100.0);\n}\n\nvoid StoreValue(vec2 st, vec4 value, inout vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = (IsInside(fragCoord, st) > 0.0 )? value : fragColor;\n}\n\nvoid LoadState()\n{\n    vec4 state1 = LoadValue(kTexState1);\n    vec4 state2 = LoadValue(kTexState2);\n    vec4 state3 = LoadValue(kTexState3);\n    vec4 state4 = LoadValue(kTexState4);\n    vec4 state5 = LoadValue(kTexState5);\n    \n    gGameState            = state1.x;\n    gGameStateTime        = state1.y;\n    gGameSeed             = state1.z;\n    gGameInit             = state1.w;\n    gPlayerCoords         = state2.xy;\n    gPlayerNextCoords     = state2.zw;\n    gPlayerMotionTimer    = state3.x;\n    gPlayerRotation       = state3.y;\n    gPlayerNextRotation   = state3.z;\n    gPlayerScale          = state3.w;\n    gPlayerVisualCoords   = state4.xyz;\n    gPlayerVisualRotation = state4.w;\n    gPlayerDeathCause     = state5.x;\n    gPlayerDeathTime      = state5.y;\n    gScore                = state5.z;\n    gFbScale              = state5.w;\n}\n\nvoid StoreState(inout vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 state1 = vec4(gGameState, gGameStateTime, gGameSeed, gGameInit);\n    vec4 state2 = vec4(gPlayerCoords, gPlayerNextCoords);\n    vec4 state3 = vec4(gPlayerMotionTimer, gPlayerRotation, gPlayerNextRotation, gPlayerScale);\n    vec4 state4 = vec4(gPlayerVisualCoords, gPlayerVisualRotation);\n    vec4 state5 = vec4(gPlayerDeathCause, gPlayerDeathTime, gScore, gFbScale);\n    \n    StoreValue(kTexState1, state1, fragColor, fragCoord);\n    StoreValue(kTexState2, state2, fragColor, fragCoord);\n    StoreValue(kTexState3, state3, fragColor, fragCoord);\n    StoreValue(kTexState4, state4, fragColor, fragCoord);\n    StoreValue(kTexState5, state5, fragColor, fragCoord);\n}\n\n\/\/ -- Hashing functions --------------------------------------------------------\n\nvec4 Hash(float p)\n{\n    vec2 h = vec2(p) * vec2(1.271,3.117) + gGameSeed;\n    return texture(iChannel3, h \/ iChannelResolution[3].xy, -100.0);\n}\n\nvec4 Hash(vec2 p)\n{\n    vec2 h = p.xy * vec2(1.271,3.117) + gGameSeed;\n    return texture(iChannel3, h \/ iChannelResolution[3].xy, -100.0);\n}\n\nvec4 Hash(vec3 p)\n{\n    vec2 h = p.xy * vec2(1.271,3.117) + p.z * vec2(1.833,4.192) + gGameSeed;\n    return texture(iChannel3, h \/ iChannelResolution[3].xy, -100.0);\n}\n\n\/\/ -- Scene tile functions -----------------------------------------------------\n\n\/\/ Procedural tile management.\n\nfloat GetSceneTileIndex(float z)\n{\n    \/\/ The scene is separated into chunks of 5 consecutive tiles, where\n    \/\/ each chunk is simply a predefined set of tiles.\n    \n    \/\/ First, determine the chunk index and it's type, based on that index.\n    float chunkIndex = floor(z * kSceneInvChunkTiles);\n    float chunkType  = floor(kSceneNumChunks * Hash(chunkIndex).x) * step(1.0, chunkIndex);\n        \n   \t\/\/ Second, determine the tile number we're referring to inside the chunk.\n\tfloat tileNum = floor(kSceneChunkTiles * (z * kSceneInvChunkTiles - chunkIndex));\n    \n    \/\/ Finally, depending upon the chunk type, determine which tile occupies\n    \/\/ that location.\n\tfloat tileIdx = 0.0;\n\t\n\tif (chunkType == 0.0)\n\t{\n\t\ttileIdx = kSceneTileSnow;\n\t}\n\telse if (chunkType == 1.0)\n\t{\n\t\ttileIdx = mix(kSceneTileIceRoad, kSceneTileSnow, step(1.5, tileNum));\n\t\ttileIdx = mix(tileIdx, kSceneTileIceRoad,        step(2.5, tileNum));\n\t}\n\telse if (chunkType == 2.0)\n\t{\n\t\ttileIdx = mix(kSceneTileSnow, kSceneTileWater, step(0.5, tileNum));\n\t\ttileIdx = mix(tileIdx, kSceneTileSnow,         step(2.5, tileNum));\n\t}\n\t\n\treturn tileIdx;\n}\n\n\/\/ Snow tile management.\n\nfloat GetSceneSnowTileTreeChance(float coords, float treeIdx)\n{\n    return step(0.5, Hash(vec2(coords, treeIdx)).x) * step(0.5, coords);\n}\n\nfloat GetSceneSnowTileTreeCoord(float coords, float treeIdx)\n{\n    return floor(-kSceneWidth + 2.0 * kSceneWidth * Hash(vec2(coords, treeIdx)).y);\n}\n\n\/\/ Water and ice tiles common management.\n\nvec4 GetSceneTileVSS(float coords, float minWidth, float maxWidth, float playerCoef)\n{\n    vec4 t;\n    vec3 h = Hash(coords).xyz;\n    t.x = (kSceneMinTileSpeed + floor(kSceneMaxTileSpeed * h.x)) * (2.0 * step(0.5, h.y) - 1.0);\n    t.y = floor(mix(minWidth, maxWidth, h.z));\n    t.z = 2.0 * t.y;\n    t.w = playerCoef;\n    return t;\n}\n\nvec4 GetSceneTileVss(vec3 coordsTile)\n{\n    vec4 vss = vec4(0.0);\n    \n    if (coordsTile.z == kSceneTileWater)\n        vss = GetSceneTileVSS(coordsTile.y, 3.0, 6.0, 1.0);\n\n    if (coordsTile.z == kSceneTileIceRoad)\n\t\tvss = GetSceneTileVSS(coordsTile.y, 3.0, 8.0, 0.0);\n    \n    return vss;\n}\n\n\/\/ -- Scene gameplay functions -------------------------------------------------\n\n\/\/ Tile gameplay management.\n\nvec3 GetSceneCoordsTile(vec2 loc)\n{\n    return vec3(floor(loc), GetSceneTileIndex(loc.y));\n}\n\nfloat GetSceneTileLocalSpaceLoc(float loc, vec4 vss)\n{\n    loc = loc - iTime * vss.x;\n    return vss.z * fract(loc \/ vss.z);\n}\n\nvec4 GetSceneTileVss(vec2 loc)\n{\n    vec3 coordsTile = GetSceneCoordsTile(loc);\n    return GetSceneTileVss(coordsTile);\n}\n\nfloat GetSceneTileBehaviour(vec2 loc)\n{\n    vec3 coordsTile = GetSceneCoordsTile(loc);\n    vec4 vss = GetSceneTileVss(coordsTile);\n    \n    \/\/ Anything below or above the scene width is an obstacle.\n\tfloat isObstacle = max(step(1.0, -coordsTile.y), step(kSceneWidth + 0.5, abs(coordsTile.x)));\n\tfloat isWater = 0.0;\n    float isHazard = 0.0;\n    float isOutOfScreen = 0.0;\n    \n    \/\/ Check for each tile case.\n    if (coordsTile.z == kSceneTileSnow)\n    {\n        for (int i = 0; i < 5; i++)\n        {\n            float treeChance = GetSceneSnowTileTreeChance(coordsTile.y, float(i));\n            float treeCoord = GetSceneSnowTileTreeCoord(coordsTile.y, float(i));\n            \n            isObstacle = max(isObstacle, treeChance * (1.0 - step(0.5, abs(coordsTile.x - treeCoord))));\n        }\n    }\n    else if (coordsTile.z == kSceneTileWater)\n    {\n        isOutOfScreen = isObstacle;\n        isObstacle = 0.0;\n        \n        float l = GetSceneTileLocalSpaceLoc(loc.x, vss);        \n        if (l > vss.y) isWater = 1.0;\n    }\n    else if (coordsTile.z == kSceneTileIceRoad)\n    {\n        float l = GetSceneTileLocalSpaceLoc(loc.x, vss);\n        if (l < 2.0) isHazard = 1.0;\n    }\n    \n    float behav = kBehavGround;\n    behav = mix(behav, kBehavWater, isWater);\n    behav = mix(behav, kBehavHazard, isHazard);\n    behav = mix(behav, kBehavObstacle, isObstacle);\n    behav = mix(behav, kBehavOutOfScreen, isOutOfScreen);\n    \n    return behav;\n}\n\nvec2 GetNextCoordinates(vec2 loc)\n{\n    float behav = GetSceneTileBehaviour(loc);\n    vec4 vss = GetSceneTileVss(loc);\n    \n    float lsloc = vss.w == 0.0 && behav != kBehavWater? loc.x : GetSceneTileLocalSpaceLoc(loc.x, vss);\n    float lsloc0 = floor(lsloc) + 0.5;\n    \n    loc.y = floor(loc.y) + 0.5;\n    loc.x += (lsloc0 - lsloc);    \n    return loc;\n}\n\n\/\/ =============================================================================\n\/\/ END OF SHARED CODE\n\/\/ =============================================================================\n\n\/\/ =============================================================================\n\/\/ BEGIN OF FONT CODE\n\/\/ =============================================================================\n\n\/\/ --- Global values -----------------------------------------------------------\n\nfloat gCharPadding  = 2.0;\nvec2  gCharPrintPos = vec2(0.0);\n\n\/\/ --- Character printing functions --------------------------------------------\n\nfloat CharRect(vec2 p, vec2 b)\n{\n\tvec2 d = abs(p) - b;\n  \treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat CharRect(vec2 p, float minX, float minY, float maxX, float maxY)\n{\n\tvec2 minCoord = vec2(minX, minY);\n\tvec2 maxCoord = vec2(maxX, maxY);\n\tvec2 b = 0.5 * (maxCoord - minCoord);\n    vec2 c = 0.5 * (maxCoord + minCoord);\n    return CharRect(p - c, b);\n}\n\nfloat CharA(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\t\n    d = min(d, CharRect(p, 3.0, 3.0, 7.0, 12.0));\n    d = min(d, CharRect(p, 9.0, 3.0, 13.0, 12.0));\n    d = min(d, CharRect(p, 7.0, 7.0, 9.0, 9.0));\n    d = min(d, CharRect(p, 4.0, 11.0, 12.0, 13.0));\n    \n    return d;\n}\n\nfloat CharB(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\t\n    d = min(d, CharRect(p, 3.0, 3.0, 7.0, 13.0));\n    d = min(d, CharRect(p, 3.0, 3.0, 12.0, 5.0));\n    d = min(d, CharRect(p, 3.0, 7.0, 12.0, 9.0));\n    d = min(d, CharRect(p, 3.0, 11.0, 12.0, 13.0));\n    d = min(d, CharRect(p, 9.0, 4.0, 13.0, 7.0));\n    d = min(d, CharRect(p, 9.0, 9.0, 13.0, 12.0));\n    return d;\n}\n\nfloat CharC(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 3.0, 4.0, 7.0, 12.0));\n    d = min(d, CharRect(p, 4.0, 3.0, 13.0, 5.0));\n    d = min(d, CharRect(p, 4.0, 11.0, 13.0, 13.0));\n    return d;\n}\n\nfloat CharD(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 3.0, 3.0, 7.0, 13.0));\n    d = min(d, CharRect(p, 9.0, 3.0, 12.0, 13.0));\n    d = min(d, CharRect(p, 3.0, 3.0, 12.0, 5.0));\n    d = min(d, CharRect(p, 3.0, 11.0, 12.0, 13.0));\n    d = min(d, CharRect(p, 9.0, 4.0, 13.0, 12.0));\n    return d;\n}\n\nfloat CharE(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 3.0, 4.0, 7.0, 12.0));\n    d = min(d, CharRect(p, 4.0, 3.0, 13.0, 5.0));\n    d = min(d, CharRect(p, 4.0, 11.0, 13.0, 13.0));\n    d = min(d, CharRect(p, 7.0, 7.0, 10.0, 9.0));\n    return d;\n}\n\nfloat CharF(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 3.0, 3.0, 7.0, 12.0));\n    d = min(d, CharRect(p, 3.0, 7.0, 10.0, 9.0));\n    d = min(d, CharRect(p, 4.0, 11.0, 13.0, 13.0));\n    return d;\n}\n\nfloat CharG(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 3.0, 4.0, 7.0, 12.0));\n    d = min(d, CharRect(p, 4.0, 3.0, 13.0, 5.0));\n    d = min(d, CharRect(p, 9.0, 3.0, 13.0, 9.0));\n    d = min(d, CharRect(p, 8.0, 7.0, 13.0, 9.0));\n    d = min(d, CharRect(p, 4.0, 11.0, 13.0, 13.0));\n    return d;\n}\n\nfloat CharH(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 3.0, 3.0, 7.0, 13.0));\n    d = min(d, CharRect(p, 9.0, 3.0, 13.0, 13.0));\n    d = min(d, CharRect(p, 3.0, 7.0, 13.0, 9.0));\n    return d;\n}\n\nfloat CharI(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(11.0, 0.0);\n\tgCharPrintPos.x += 4.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 6.0, 3.0, 10.0, 13.0));\n    return d;\n}\n\nfloat CharJ(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 3.0, 3.0, 12.0, 5.0));\n    d = min(d, CharRect(p, 9.0, 4.0, 13.0, 13.0));\n    return d;\n}\n\nfloat CharK(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 3.0, 3.0, 7.0, 13.0));\n    d = min(d, CharRect(p, 3.0, 7.0, 12.0, 9.0));\n    d = min(d, CharRect(p, 9.0, 3.0, 13.0, 7.0));\n    d = min(d, CharRect(p, 9.0, 9.0, 13.0, 13.0));\n    return d;\n}\n\nfloat CharL(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 3.0, 3.0, 7.0, 13.0));\n    d = min(d, CharRect(p, 3.0, 3.0, 13.0, 5.0));\n    return d;\n}\n\nfloat CharM(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(5.0, 0.0);\n\tgCharPrintPos.x += 16.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 0.0, 3.0, 4.0, 13.0));\n    d = min(d, CharRect(p, 6.0, 3.0, 10.0, 13.0));\n    d = min(d, CharRect(p, 12.0, 3.0, 16.0, 12.0));\n    d = min(d, CharRect(p, 0.0, 11.0, 15.0, 13.0));\n    return d;\n}\n\nfloat CharN(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 3.0, 3.0, 7.0, 13.0));\n    d = min(d, CharRect(p, 3.0, 11.0, 12.0, 13.0));\n    d = min(d, CharRect(p, 9.0, 3.0, 13.0, 12.0));\n    return d;\n}\n\nfloat CharO(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 3.0, 4.0, 7.0, 12.0));\n    d = min(d, CharRect(p, 9.0, 4.0, 13.0, 12.0));\n    d = min(d, CharRect(p, 4.0, 3.0, 12.0, 5.0));\n    d = min(d, CharRect(p, 4.0, 11.0, 12.0, 13.0));\n    return d;\n}\n\nfloat CharP(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 3.0, 3.0, 7.0, 13.0));\n    d = min(d, CharRect(p, 6.0, 7.0, 12.0, 9.0));\n    d = min(d, CharRect(p, 9.0, 8.0, 13.0, 12.0));\n    d = min(d, CharRect(p, 6.0, 11.0, 12.0, 13.0));\n    return d;\n}\n\nfloat CharQ(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 3.0, 4.0, 7.0, 12.0));\n    d = min(d, CharRect(p, 9.0, 4.0, 13.0, 12.0));\n    d = min(d, CharRect(p, 4.0, 3.0, 12.0, 5.0));\n    d = min(d, CharRect(p, 4.0, 11.0, 12.0, 13.0));\n    d = min(d, CharRect(p, 8.0, 1.0, 13.0, 3.0));\n    return d;\n}\n\nfloat CharR(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 3.0, 3.0, 7.0, 13.0));\n    d = min(d, CharRect(p, 6.0, 7.0, 12.0, 9.0));\n    d = min(d, CharRect(p, 9.0, 8.0, 13.0, 12.0));\n    d = min(d, CharRect(p, 6.0, 11.0, 12.0, 13.0));\n    d = min(d, CharRect(p, 9.0, 3.0, 13.0, 7.0));\n    return d;\n}\n\nfloat CharS(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 3.0, 3.0, 12.0, 5.0));\n    d = min(d, CharRect(p, 4.0, 7.0, 12.0, 9.0));\n    d = min(d, CharRect(p, 4.0, 11.0, 13.0, 13.0));\n    d = min(d, CharRect(p, 9.0, 4.0, 13.0, 8.0));\n    d = min(d, CharRect(p, 3.0, 8.0, 7.0, 12.0));\n    return d;\n}\n\nfloat CharT(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 6.0, 3.0, 10.0, 13.0));\n    d = min(d, CharRect(p, 3.0, 11.0, 13.0, 13.0));\n    return d;\n}\n\nfloat CharU(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 3.0, 4.0, 7.0, 13.0));\n    d = min(d, CharRect(p, 9.0, 4.0, 13.0, 13.0));\n    d = min(d, CharRect(p, 4.0, 3.0, 12.0, 5.0));\n    return d;\n}\n\nfloat CharV(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 3.0, 3.0, 7.0, 13.0));\n    d = min(d, CharRect(p, 9.0, 4.0, 13.0, 13.0));\n    d = min(d, CharRect(p, 4.0, 3.0, 12.0, 5.0));\n    return d;\n}\n\nfloat CharW(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(5.0, 0.0);\n\tgCharPrintPos.x += 16.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 0.0, 3.0, 4.0, 13.0));\n    d = min(d, CharRect(p, 6.0, 3.0, 10.0, 13.0));\n    d = min(d, CharRect(p, 12.0, 4.0, 16.0, 13.0));\n    d = min(d, CharRect(p, 0.0, 3.0, 15.0, 6.0));\n    return d;\n}\n\nfloat CharX(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 3.0, 3.0, 7.0, 7.0));\n    d = min(d, CharRect(p, 9.0, 3.0, 13.0, 7.0));\n    d = min(d, CharRect(p, 3.0, 9.0, 7.0, 13.0));\n    d = min(d, CharRect(p, 9.0, 9.0, 13.0, 13.0));\n    d = min(d, CharRect(p, 4.0, 7.0, 12.0, 9.0));\n    return d;\n}\n\nfloat CharY(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 6.0, 3.0, 10.0, 7.0));\n    d = min(d, CharRect(p, 3.0, 8.0, 7.0, 13.0));\n    d = min(d, CharRect(p, 9.0, 8.0, 13.0, 13.0));\n    d = min(d, CharRect(p, 4.0, 7.0, 12.0, 9.0));\n    return d;\n}\n\nfloat CharZ(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 3.0, 3.0, 13.0, 5.0));\n    d = min(d, CharRect(p, 4.0, 7.0, 12.0, 9.0));\n    d = min(d, CharRect(p, 3.0, 11.0, 13.0, 13.0));\n    d = min(d, CharRect(p, 9.0, 8.0, 13.0, 13.0));\n    d = min(d, CharRect(p, 3.0, 4.0, 7.0, 8.0));\n    return d;\n}\n\nfloat Char0(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 3.0, 4.0, 7.0, 12.0));\n    d = min(d, CharRect(p, 9.0, 4.0, 13.0, 12.0));\n    d = min(d, CharRect(p, 4.0, 3.0, 12.0, 5.0));\n    d = min(d, CharRect(p, 4.0, 11.0, 12.0, 13.0));\n    d = min(d, CharRect(p, 7.0, 7.0, 9.0, 9.0));\n    return d;\n}\n\nfloat Char1(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(10.0, 0.0);\n\tgCharPrintPos.x += 8.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 7.0, 3.0, 11.0, 12.0));\n    d = min(d, CharRect(p, 6.0, 11.0, 10.0, 13.0));\n    return d;\n}\n\nfloat Char2(vec2 p, inout float d)\n{\n    return CharZ(p, d);\n}\n\nfloat Char3(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 3.0, 3.0, 12.0, 5.0));\n    d = min(d, CharRect(p, 9.0, 4.0, 13.0, 7.0));\n    d = min(d, CharRect(p, 6.0, 7.0, 12.0, 9.0));\n    d = min(d, CharRect(p, 9.0, 9.0, 13.0, 12.0));\n    d = min(d, CharRect(p, 3.0, 11.0, 12.0, 13.0));\n    return d;\n}\n\nfloat Char4(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 9.0, 3.0, 13.0, 13.0));\n    d = min(d, CharRect(p, 4.0, 7.0, 13.0, 9.0));\n    d = min(d, CharRect(p, 3.0, 8.0, 7.0, 13.0));\n    return d;\n}\n\nfloat Char5(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 3.0, 3.0, 12.0, 5.0));\n    d = min(d, CharRect(p, 4.0, 7.0, 12.0, 9.0));\n    d = min(d, CharRect(p, 3.0, 11.0, 13.0, 13.0));\n    d = min(d, CharRect(p, 9.0, 4.0, 13.0, 8.0));\n    d = min(d, CharRect(p, 3.0, 8.0, 7.0, 12.0));\n    return d;\n}\n\nfloat Char6(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 3.0, 4.0, 7.0, 12.0));\n    d = min(d, CharRect(p, 4.0, 3.0, 12.0, 5.0));\n    d = min(d, CharRect(p, 9.0, 4.0, 13.0, 8.0));\n    d = min(d, CharRect(p, 3.0, 7.0, 12.0, 9.0));\n    d = min(d, CharRect(p, 4.0, 11.0, 13.0, 13.0));\n    return d;\n}\n\nfloat Char7(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 9.0, 3.0, 13.0, 12.0));\n    d = min(d, CharRect(p, 3.0, 11.0, 12.0, 13.0));\n    return d;\n}\n\nfloat Char8(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 3.0, 4.0, 7.0, 7.0));\n    d = min(d, CharRect(p, 9.0, 4.0, 13.0, 7.0));\n    d = min(d, CharRect(p, 3.0, 9.0, 7.0, 12.0));\n    d = min(d, CharRect(p, 9.0, 9.0, 13.0, 12.0));\n    d = min(d, CharRect(p, 4.0, 7.0, 12.0, 9.0));\n    d = min(d, CharRect(p, 4.0, 3.0, 12.0, 5.0));\n    d = min(d, CharRect(p, 4.0, 11.0, 12.0, 13.0));\n    return d;\n}\n\nfloat Char9(vec2 p, inout float d)\n{\n    p -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n    \n\td = min(d, CharRect(p, 3.0, 3.0, 12.0, 5.0));\n    d = min(d, CharRect(p, 9.0, 4.0, 13.0, 12.0));\n    d = min(d, CharRect(p, 4.0, 11.0, 12.0, 13.0));\n    d = min(d, CharRect(p, 3.0, 8.0, 7.0, 12.0));\n    d = min(d, CharRect(p, 4.0, 7.0, 13.0, 9.0));\n    return d;\n}\n\nvoid CharSpace()\n{\n    gCharPrintPos.x += 10.0 + gCharPadding;\n}\n\nfloat CharDigit(vec2 p, float n, inout float d)\n{\n    n = floor(n);\n    \n    if (n == 0.0) return Char0(p, d);\n    if (n == 1.0) return Char1(p, d);\n    if (n == 2.0) return Char2(p, d);\n    if (n == 3.0) return Char3(p, d);\n    if (n == 4.0) return Char4(p, d);\n    if (n == 5.0) return Char5(p, d);\n    if (n == 6.0) return Char6(p, d);\n    if (n == 7.0) return Char7(p, d);\n    if (n == 8.0) return Char8(p, d);\n    if (n == 9.0) return Char9(p, d);\n    return d;\n}\n\nvoid Print(vec2 p, float n\n           , inout float d)\n{   \n\tfor (int i = 5; i >= 0; i--)\n    {\n        float w = pow(10.0, float(i));\n        float k = mod(n \/ w, 10.0);\n        \n        if (abs(n) > w || i == 0)\n            CharDigit(p, k, d);\n    }   \n}    \n\n\/\/ =============================================================================\n\/\/ END OF FONT CODE\n\/\/ =============================================================================\n\n\/\/ =============================================================================\n\/\/ START OF UI RENDER CODE\n\/\/ =============================================================================\n\nvoid RenderUI(inout vec4 fragColor, vec2 fragCoord, vec2 uv, float aspect)\n{\n    uv *= 128.0;\n       \n    \/\/ Render CROSSY PENGUIN logo upon the title screen or during the first\n    \/\/ seconds of the game (with an animation!).\n    \n    if (gGameState == kStateTitle || (gGameState == kStateInGame && gGameStateTime < 4.0))\n    {\n        float logoSdf = kOmega;        \n        vec2 logoUv = uv * 0.5;\n        logoUv.x -= (gGameState == kStateInGame)? 500.0 * gGameStateTime * gGameStateTime : 0.0;\n        logoUv.y += uv.x * 0.13;\n                \n        vec2 subLogoUv = logoUv * 3.0;\n        \n        gCharPrintPos = vec2(-34.0, 7.0);\n        CharC(logoUv, logoSdf);\n        CharR(logoUv, logoSdf);\n        CharO(logoUv, logoSdf);\n        CharS(logoUv, logoSdf);\n        CharS(logoUv, logoSdf);\n        CharY(logoUv, logoSdf);\n        gCharPrintPos = vec2(-38.0, -7.0);\n        CharP(logoUv, logoSdf);\n        CharE(logoUv, logoSdf);\n        CharN(logoUv, logoSdf);\n        CharG(logoUv, logoSdf);\n        CharU(logoUv, logoSdf);\n        CharI(logoUv, logoSdf);\n        CharN(logoUv, logoSdf);\n        gCharPrintPos = vec2(-132.0, -40.0);\n        CharA(subLogoUv, logoSdf);\n        CharSpace();\n        CharC(subLogoUv, logoSdf);\n        CharR(subLogoUv, logoSdf);\n        CharO(subLogoUv, logoSdf);\n        CharS(subLogoUv, logoSdf);\n        CharS(subLogoUv, logoSdf);\n        CharY(subLogoUv, logoSdf);\n        CharSpace();\n        CharR(subLogoUv, logoSdf);\n        CharO(subLogoUv, logoSdf);\n        CharA(subLogoUv, logoSdf);\n        CharD(subLogoUv, logoSdf);\n        CharSpace();\n        CharT(subLogoUv, logoSdf);\n        CharR(subLogoUv, logoSdf);\n        CharI(subLogoUv, logoSdf);\n        CharB(subLogoUv, logoSdf);\n        CharU(subLogoUv, logoSdf);\n        CharT(subLogoUv, logoSdf);\n        CharE(subLogoUv, logoSdf);\n        \n        fragColor.rgb = mix(fragColor.rgb, vec3(0.0), step(-3.0, -logoSdf));\n        fragColor.rgb = mix(fragColor.rgb, vec3(1.0), step(0.0, -logoSdf));\n    }\n    \n    \/\/ Render the score during the InGame state and hide on GameOver.\n    \n    if (gGameState == kStateInGame || (gGameState == kStateGameOver && gGameStateTime < 4.0))\n    {\n        float scoreSdf = kOmega;\n        vec2 scoreUv = uv;\n        \n        if (gGameState == kStateInGame) scoreUv.y -= 64.0 - 64.0 * min(1.0, gGameStateTime);\n        else                            scoreUv.y -= 64.0 * min(1.0, gGameStateTime);\n        \n        gCharPrintPos = vec2(-120.0 * aspect, 104.0);\n        Print(scoreUv, gScore, scoreSdf);\n        \n        fragColor.rgb = mix(fragColor.rgb, vec3(0.0), step(-3.0, -scoreSdf));\n        fragColor.rgb = mix(fragColor.rgb, vec3(1.0), step(0.0, -scoreSdf));\n    }\n    \n    \/\/ Fade to blue upon GameOver and show score.\n   \n    if (gGameState == kStateGameOver || gGameState == kStateRestarting)\n    {\n        fragColor.rgb  = mix(fragColor.rgb, vec3(0.2, 0.7, 1.0), min(0.5, gGameStateTime));\n        \n        float gameOverSdf = kOmega;        \n        vec2 gameOverUv = uv * 0.5;\n        float gameOverTime = gGameState == kStateRestarting? 1.0 : min(gGameStateTime * 0.7, 1.0);\n        \n        gameOverUv.y -= 128.0 * abs(cos(2.0 * kPi * gameOverTime * gameOverTime)) * (1.0 - gameOverTime);\n                       \n        gCharPrintPos = vec2(-45.0, 0.0);\n        CharG(gameOverUv, gameOverSdf);\n        CharA(gameOverUv, gameOverSdf);\n        CharM(gameOverUv, gameOverSdf);\n        CharE(gameOverUv, gameOverSdf);\n        CharSpace();\n        CharO(gameOverUv, gameOverSdf);\n        CharV(gameOverUv, gameOverSdf);\n        CharE(gameOverUv, gameOverSdf);\n        CharR(gameOverUv, gameOverSdf);\n        \n        fragColor.rgb = mix(fragColor.rgb, vec3(0.0), step(-3.0, -gameOverSdf));\n        fragColor.rgb = mix(fragColor.rgb, vec3(1.0), step(0.0, -gameOverSdf));\n        \n        float messageSdf = kOmega;\n        vec2 messageUv = uv * 1.5;\n        float messageTime = gGameState == kStateRestarting? 1.0 : clamp(gGameStateTime * 0.7 - 1.0, 0.0, 1.0);\n        \n        messageUv.x -= 1024.0 * (1.0 - messageTime) * (1.0 - messageTime);\n                 \n        if (gPlayerDeathCause == kBehavWater)\n        {\n            gCharPrintPos = vec2(-170.0, -40.0);\n            CharS(messageUv, messageSdf);\n            CharE(messageUv, messageSdf);\n            CharE(messageUv, messageSdf);\n            CharM(messageUv, messageSdf);\n            CharS(messageUv, messageSdf);\n            CharSpace();\n            CharL(messageUv, messageSdf);\n            CharI(messageUv, messageSdf);\n            CharK(messageUv, messageSdf);\n            CharE(messageUv, messageSdf);\n            CharSpace();\n            CharT(messageUv, messageSdf);\n            CharH(messageUv, messageSdf);\n            CharI(messageUv, messageSdf);\n            CharS(messageUv, messageSdf);\n            CharSpace();\n            CharP(messageUv, messageSdf);\n            CharE(messageUv, messageSdf);\n            CharN(messageUv, messageSdf);\n            CharG(messageUv, messageSdf);\n            CharU(messageUv, messageSdf);\n            CharI(messageUv, messageSdf);\n            CharN(messageUv, messageSdf);\n            CharSpace();\n            CharC(messageUv, messageSdf);\n            CharA(messageUv, messageSdf);\n            CharN(messageUv, messageSdf);\n            CharT(messageUv, messageSdf);\n            CharSpace();\n            CharS(messageUv, messageSdf);\n            CharW(messageUv, messageSdf);\n            CharI(messageUv, messageSdf);\n            CharM(messageUv, messageSdf);\n        }\n        else if (gPlayerDeathCause == kBehavOutOfScreen)\n        {\n            gCharPrintPos = vec2(-220.0, -40.0);\n            CharY(messageUv, messageSdf);\n            CharO(messageUv, messageSdf);\n            CharU(messageUv, messageSdf);\n            CharSpace();\n            CharW(messageUv, messageSdf);\n            CharE(messageUv, messageSdf);\n            CharN(messageUv, messageSdf);\n            CharT(messageUv, messageSdf);\n            CharSpace();\n            CharO(messageUv, messageSdf);\n            CharN(messageUv, messageSdf);\n            CharSpace();\n            CharA(messageUv, messageSdf);\n            CharSpace();\n            CharJ(messageUv, messageSdf);\n            CharO(messageUv, messageSdf);\n            CharU(messageUv, messageSdf);\n            CharR(messageUv, messageSdf);\n            CharN(messageUv, messageSdf);\n            CharE(messageUv, messageSdf);\n            CharY(messageUv, messageSdf);\n            CharSpace();\n            CharT(messageUv, messageSdf);\n            CharO(messageUv, messageSdf);\n            CharSpace();\n            CharF(messageUv, messageSdf);\n            CharA(messageUv, messageSdf);\n            CharR(messageUv, messageSdf);\n            CharSpace();\n            CharA(messageUv, messageSdf);\n            CharW(messageUv, messageSdf);\n            CharA(messageUv, messageSdf);\n            CharY(messageUv, messageSdf);\n            CharSpace();\n            CharL(messageUv, messageSdf);\n            CharA(messageUv, messageSdf);\n            CharN(messageUv, messageSdf);\n            CharD(messageUv, messageSdf);\n            CharS(messageUv, messageSdf);\n        }\n        else if (gPlayerDeathCause == kBehavHazard)\n        {\n            gCharPrintPos = vec2(-170.0, -40.0);\n            CharD(messageUv, messageSdf);\n            CharI(messageUv, messageSdf);\n            CharD(messageUv, messageSdf);\n            CharSpace();\n            CharA(messageUv, messageSdf);\n            CharN(messageUv, messageSdf);\n            CharY(messageUv, messageSdf);\n            CharO(messageUv, messageSdf);\n            CharN(messageUv, messageSdf);\n            CharE(messageUv, messageSdf);\n            CharSpace();\n            CharC(messageUv, messageSdf);\n            CharA(messageUv, messageSdf);\n            CharT(messageUv, messageSdf);\n            CharC(messageUv, messageSdf);\n            CharH(messageUv, messageSdf);\n            CharSpace();\n            CharT(messageUv, messageSdf);\n            CharH(messageUv, messageSdf);\n            CharE(messageUv, messageSdf);\n            CharSpace();\n            CharL(messageUv, messageSdf);\n            CharI(messageUv, messageSdf);\n            CharC(messageUv, messageSdf);\n            CharE(messageUv, messageSdf);\n            CharN(messageUv, messageSdf);\n            CharS(messageUv, messageSdf);\n            CharE(messageUv, messageSdf);\n            CharSpace();\n            CharP(messageUv, messageSdf);\n            CharL(messageUv, messageSdf);\n            CharA(messageUv, messageSdf);\n            CharT(messageUv, messageSdf);\n            CharE(messageUv, messageSdf);\n        }\n        \n        fragColor.rgb = mix(fragColor.rgb, vec3(0.0), step(-3.0, -gameOverSdf));\n        fragColor.rgb = mix(fragColor.rgb, vec3(1.0), step(0.0, -gameOverSdf));\n        fragColor.rgb = mix(fragColor.rgb, vec3(0.0), step(-3.0, -messageSdf));\n        fragColor.rgb = mix(fragColor.rgb, vec3(1.0), step(0.0, -messageSdf));\n    }   \n    \n    \/\/ Fade to white upon Restarting\n    \n    if (gGameState == kStateRestarting)\n        fragColor.rgb = mix(mix(fragColor.rgb, vec3(0.2, 0.7, 1.0), 0.5), vec3(1.0), min(1.0, gGameStateTime));\n    \n    \/\/ Fade from white at the title.\n    \n    if (gGameState == kStateTitle)\n    \tfragColor.rgb = mix(vec3(1.0), fragColor.rgb, min(1.0, gGameStateTime));\n    \n    \/\/ Press space to continue.\n    \n    if (step(0.5, fract(iTime * 0.75)) > 0.5 && (gGameState == kStateTitle || gGameState == kStateGameOver) && gGameStateTime > 1.0)\n    {\n        float messageSdf = kOmega;\n        vec2 messageUv = uv * 1.75;\n                 \n        gCharPrintPos = vec2(-130.0, -100.0);\n        CharP(messageUv, messageSdf);\n        CharR(messageUv, messageSdf);\n        CharE(messageUv, messageSdf);\n        CharS(messageUv, messageSdf);\n        CharS(messageUv, messageSdf);\n        CharSpace();\n        CharS(messageUv, messageSdf);\n        CharP(messageUv, messageSdf);\n        CharA(messageUv, messageSdf);\n        CharC(messageUv, messageSdf);\n        CharE(messageUv, messageSdf);\n        CharSpace();\n        CharT(messageUv, messageSdf);\n        CharO(messageUv, messageSdf);\n        CharSpace();\n        CharC(messageUv, messageSdf);\n        CharO(messageUv, messageSdf);\n        CharN(messageUv, messageSdf);\n        CharT(messageUv, messageSdf);\n        CharI(messageUv, messageSdf);\n        CharN(messageUv, messageSdf);\n        CharU(messageUv, messageSdf);\n        CharE(messageUv, messageSdf);\n        \n        fragColor.rgb = mix(fragColor.rgb, vec3(0.0), step(-3.0, -messageSdf));\n        fragColor.rgb = mix(fragColor.rgb, vec3(1.0, 1.0, 0.0), step(0.0, -messageSdf));\n    }\n}\n\n\/\/ =============================================================================\n\/\/ END OF UI RENDER CODE\n\/\/ =============================================================================\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    LoadState();\n\n\t\/\/ Compute uv coords.\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n    \n    \/\/ Render lower-res back buffer.\n    fragColor = texture(iChannel1, uv * gFbScale);\n    \n    \/\/ Render UI\n    float aspect = iResolution.x \/ iResolution.y;\n    uv = 2.0 * uv - 1.0;\n    uv.x *= aspect;    \n\n    RenderUI(fragColor, fragCoord, uv, aspect);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"\/presets\/tex00.jpg","previewfilepath":"\/presets\/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/*\n\n(06\/11\/16)\n\nSome instructions on how to play:\n\nSpace: Used to start the game and restarting on Game Over.\nArrows: Move around the player character.\n1-4: Change the render buffer resolution to get a\n     big speedup (1 - 100%, 2 - 75%, 3 - 50%, 4 - 25%).\n\n--------------------------------------\n\nKnown Issues:\n\n- Some drivers might take long to compile the shader, we're currently looking into this.\n- You might find that the player moves weirdly when jumping\n  on water tiles, we'll try to figure out a better way to handle those cases.\n\nPotential Issues:\n\n- We haven't battle tested the shader on other GPUs than NVIDIA,\n  so we don't know if they'll work at all.\n\n*\/\n\n\/\/ =============================================================================\n\/\/ START OF SHARED CODE\n\/\/ =============================================================================\n\n\/\/ -- Constants ----------------------------------------------------------------\n\n\/\/ State constants.\n\nconst float kStateTitle      = 0.0;\nconst float kStateInGame     = 1.0;\nconst float kStateGameOver   = 2.0;\nconst float kStateRestarting = 3.0;\n\n\/\/ Scene constants.\n\nconst float kSceneWidth         = 5.0;\nconst float kSceneMinTileSpeed  = 2.0;\nconst float kSceneMaxTileSpeed  = 2.0;\n\nconst float kSceneNumChunks     = 3.0;     \/\/ Number of pre-defined chunks in the scene.\nconst float kSceneChunkTiles    = 5.0;     \/\/ Number of tiles per chunk.\nconst float kSceneInvChunkTiles = 0.2;     \/\/ Inverse number of tiles per chunk.\n\nconst float kSceneTileSnow      = 0.0;     \/\/ Id of the snow tile.\nconst float kSceneTileIceRoad   = 1.0;     \/\/ Id of the ice road tile.\nconst float kSceneTileWater     = 2.0;     \/\/ Id of the water tile.\n\nconst float kBehavGround        = 0.0;\nconst float kBehavWater         = 1.0;\nconst float kBehavObstacle      = 2.0;\nconst float kBehavHazard        = 3.0;\nconst float kBehavOutOfScreen   = 4.0;\n\n\/\/ Player motion constants.\n\nconst float kPlayerSpeed      = 5.0;\nconst float kPlayerJumpHeight = 0.3;\n\n\/\/ State coordinates.\n\nconst vec2 kTexState1 = vec2(0.0, 0.0); \/\/ x   = Current state,  y  = State time, w = Init\nconst vec2 kTexState2 = vec2(1.0, 0.0); \/\/ xy  = Current coords, zw = Next coords\nconst vec2 kTexState3 = vec2(2.0, 0.0); \/\/ x   = Motion time, y = Rotation, z = NextRotation, w = Scale\nconst vec2 kTexState4 = vec2(3.0, 0.0); \/\/ xyz = Coordinates, w = Rotation\nconst vec2 kTexState5 = vec2(4.0, 0.0); \/\/ x   = Death cause, y = Death time, z = Score, w = Fb. Scale\n\n\/\/ Misc constants.\n\nconst float kPi = 3.14159265359;\nconst float kOneOverPi = 0.31830988618;\nconst float kOmega = 1e20;\n\n\/\/ -- Global values ------------------------------------------------------------\n\nfloat gGameState;\nfloat gGameStateTime;\nfloat gGameInit;\nfloat gGameSeed;\nvec2  gPlayerCoords;\nvec2  gPlayerNextCoords;\nfloat gPlayerMotionTimer;\nfloat gPlayerRotation;\nfloat gPlayerNextRotation;\nfloat gPlayerScale;\nvec3  gPlayerVisualCoords;\nfloat gPlayerVisualRotation;\nfloat gPlayerDeathCause;\nfloat gPlayerDeathTime;\nfloat gScore;\nfloat gFbScale;\n\n\/\/ -- State functions ----------------------------------------------------------\n\nfloat IsInside(vec2 p, vec2 c)\n{\n    vec2 d = abs(p - 0.5 - c) - 0.5;\n    return -max(d.x, d.y);\n}\n\nvec4 LoadValue(vec2 st)\n{\n    return texture(iChannel0, (0.5 + st) \/ iChannelResolution[0].xy, -100.0);\n}\n\nvoid StoreValue(vec2 st, vec4 value, inout vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = (IsInside(fragCoord, st) > 0.0 )? value : fragColor;\n}\n\nvoid LoadState()\n{\n    vec4 state1 = LoadValue(kTexState1);\n    vec4 state2 = LoadValue(kTexState2);\n    vec4 state3 = LoadValue(kTexState3);\n    vec4 state4 = LoadValue(kTexState4);\n    vec4 state5 = LoadValue(kTexState5);\n    \n    gGameState            = state1.x;\n    gGameStateTime        = state1.y;\n    gGameSeed             = state1.z;\n    gGameInit             = state1.w;\n    gPlayerCoords         = state2.xy; \n    gPlayerNextCoords     = state2.zw;\n    gPlayerMotionTimer    = state3.x;\n    gPlayerRotation       = state3.y;\n    gPlayerNextRotation   = state3.z;\n    gPlayerScale          = state3.w;\n    gPlayerVisualCoords   = state4.xyz;\n    gPlayerVisualRotation = state4.w;\n    gPlayerDeathCause     = state5.x;\n    gPlayerDeathTime      = state5.y;\n    gScore                = state5.z;\n    gFbScale              = state5.w;\n}\n\nvoid StoreState(inout vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 state1 = vec4(gGameState, gGameStateTime, gGameSeed, gGameInit);\n    vec4 state2 = vec4(gPlayerCoords, gPlayerNextCoords);\n    vec4 state3 = vec4(gPlayerMotionTimer, gPlayerRotation, gPlayerNextRotation, gPlayerScale);\n    vec4 state4 = vec4(gPlayerVisualCoords, gPlayerVisualRotation);\n    vec4 state5 = vec4(gPlayerDeathCause, gPlayerDeathTime, gScore, gFbScale);\n    \n    StoreValue(kTexState1, state1, fragColor, fragCoord);\n    StoreValue(kTexState2, state2, fragColor, fragCoord);\n    StoreValue(kTexState3, state3, fragColor, fragCoord);\n    StoreValue(kTexState4, state4, fragColor, fragCoord);\n    StoreValue(kTexState5, state5, fragColor, fragCoord);\n}\n\n\/\/ -- Hashing functions --------------------------------------------------------\n\nvec4 Hash(float p)\n{\n    vec2 h = vec2(p) * vec2(1.271,3.117) + gGameSeed;\n    return texture(iChannel3, h \/ iChannelResolution[3].xy, -100.0);\n}\n\nvec4 Hash(vec2 p)\n{\n    vec2 h = p.xy * vec2(1.271,3.117) + gGameSeed;\n    return texture(iChannel3, h \/ iChannelResolution[3].xy, -100.0);\n}\n\nvec4 Hash(vec3 p)\n{\n    vec2 h = p.xy * vec2(1.271,3.117) + p.z * vec2(1.833,4.192) + gGameSeed;\n    return texture(iChannel3, h \/ iChannelResolution[3].xy, -100.0);\n}\n\n\/\/ -- Scene tile functions -----------------------------------------------------\n\n\/\/ Procedural tile management.\n\nfloat GetSceneTileIndex(float z)\n{\n    \/\/ The scene is separated into chunks of 5 consecutive tiles, where\n    \/\/ each chunk is simply a predefined set of tiles.\n    \n    \/\/ First, determine the chunk index and it's type, based on that index.\n    float chunkIndex = floor(z * kSceneInvChunkTiles);\n    float chunkType  = floor(kSceneNumChunks * Hash(chunkIndex).x) * step(1.0, chunkIndex);\n        \n   \t\/\/ Second, determine the tile number we're referring to inside the chunk.\n\tfloat tileNum = floor(kSceneChunkTiles * (z * kSceneInvChunkTiles - chunkIndex));\n    \n    \/\/ Finally, depending upon the chunk type, determine which tile occupies\n    \/\/ that location.\n\tfloat tileIdx = 0.0;\n\t\n\tif (chunkType == 0.0)\n\t{\n\t\ttileIdx = kSceneTileSnow;\n\t}\n\telse if (chunkType == 1.0)\n\t{\n\t\ttileIdx = mix(kSceneTileIceRoad, kSceneTileSnow, step(1.5, tileNum));\n\t\ttileIdx = mix(tileIdx, kSceneTileIceRoad,        step(2.5, tileNum));\n\t}\n\telse if (chunkType == 2.0)\n\t{\n\t\ttileIdx = mix(kSceneTileSnow, kSceneTileWater, step(0.5, tileNum));\n\t\ttileIdx = mix(tileIdx, kSceneTileSnow,         step(2.5, tileNum));\n\t}\n\t\n\treturn tileIdx;\n}\n\n\/\/ Snow tile management.\n\nfloat GetSceneSnowTileTreeChance(float coords, float treeIdx)\n{\n    return step(0.5, Hash(vec2(coords, treeIdx)).x) * step(0.5, coords);\n}\n\nfloat GetSceneSnowTileTreeCoord(float coords, float treeIdx)\n{\n    return floor(-kSceneWidth + 2.0 * kSceneWidth * Hash(vec2(coords, treeIdx)).y);\n}\n\n\/\/ Water and ice tiles common management.\n\nvec4 GetSceneTileVSS(float coords, float minWidth, float maxWidth, float playerCoef)\n{\n    vec4 t;\n    vec3 h = Hash(coords).xyz;\n    t.x = (kSceneMinTileSpeed + floor(kSceneMaxTileSpeed * h.x)) * (2.0 * step(0.5, h.y) - 1.0);\n    t.y = floor(mix(minWidth, maxWidth, h.z));\n    t.z = 2.0 * t.y;\n    t.w = playerCoef;\n    return t;\n}\n\nvec4 GetSceneTileVss(vec3 coordsTile)\n{\n    vec4 vss = vec4(0.0);\n    \n    if (coordsTile.z == kSceneTileWater)\n        vss = GetSceneTileVSS(coordsTile.y, 3.0, 6.0, 1.0);\n\n    if (coordsTile.z == kSceneTileIceRoad)\n\t\tvss = GetSceneTileVSS(coordsTile.y, 3.0, 8.0, 0.0);\n    \n    return vss;\n}\n\n\/\/ -- Scene gameplay functions -------------------------------------------------\n\n\/\/ Tile gameplay management.\n\nvec3 GetSceneCoordsTile(vec2 loc)\n{\n    return vec3(floor(loc), GetSceneTileIndex(loc.y));\n}\n\nfloat GetSceneTileLocalSpaceLoc(float loc, vec4 vss)\n{\n    loc = loc - iTime * vss.x;\n    return vss.z * fract(loc \/ vss.z);\n}\n\nvec4 GetSceneTileVss(vec2 loc)\n{\n    vec3 coordsTile = GetSceneCoordsTile(loc);\n    return GetSceneTileVss(coordsTile);\n}\n\nfloat GetSceneTileBehaviour(vec2 loc)\n{\n    vec3 coordsTile = GetSceneCoordsTile(loc);\n    vec4 vss = GetSceneTileVss(coordsTile);\n    \n    \/\/ Anything below or above the scene width is an obstacle.\n\tfloat isObstacle = max(step(1.0, -coordsTile.y), step(kSceneWidth + 0.5, abs(coordsTile.x)));\n\tfloat isWater = 0.0;\n    float isHazard = 0.0;\n    float isOutOfScreen = 0.0;\n    \n    \/\/ Check for each tile case.\n    if (coordsTile.z == kSceneTileSnow)\n    {\n        for (int i = 0; i < 5; i++)\n        {\n            float treeChance = GetSceneSnowTileTreeChance(coordsTile.y, float(i));\n            float treeCoord = GetSceneSnowTileTreeCoord(coordsTile.y, float(i));\n            \n            isObstacle = max(isObstacle, treeChance * (1.0 - step(0.5, abs(coordsTile.x - treeCoord))));\n        }\n    }\n    else if (coordsTile.z == kSceneTileWater)\n    {\n        isOutOfScreen = isObstacle;\n        isObstacle = 0.0;\n        \n        float l = GetSceneTileLocalSpaceLoc(loc.x, vss);        \n        if (l > vss.y) isWater = 1.0;\n    }\n    else if (coordsTile.z == kSceneTileIceRoad)\n    {\n        float l = GetSceneTileLocalSpaceLoc(loc.x, vss);\n        if (l < 2.0) isHazard = 1.0;\n    }\n    \n    float behav = kBehavGround;\n    behav = mix(behav, kBehavWater, isWater);\n    behav = mix(behav, kBehavHazard, isHazard);\n    behav = mix(behav, kBehavObstacle, isObstacle);\n    behav = mix(behav, kBehavOutOfScreen, isOutOfScreen);\n    \n    return behav;\n}\n\nvec2 GetNextCoordinates(vec2 loc)\n{\n    float behav = GetSceneTileBehaviour(loc);\n    vec4 vss = GetSceneTileVss(loc);\n    \n    float lsloc = vss.w == 0.0 && behav != kBehavWater? loc.x : GetSceneTileLocalSpaceLoc(loc.x, vss);\n    float lsloc0 = floor(lsloc) + 0.5;\n    \n    loc.y = floor(loc.y) + 0.5;\n    loc.x += (lsloc0 - lsloc);    \n    return loc;\n}\n\n\/\/ =============================================================================\n\/\/ END OF SHARED CODE\n\/\/ =============================================================================\n\n\/\/ -- Constants ----------------------------------------------------------------\n\n\/\/ Key constants.\n\nconst float kKeyLeft  = 37.5 \/ 256.0;\nconst float kKeyUp    = 38.5 \/ 256.0;\nconst float kKeyRight = 39.5 \/ 256.0;\nconst float kKeyDown  = 40.5 \/ 256.0;\nconst float kKeySpace = 32.5 \/ 256.0;\nconst float kKey1     = 49.5 \/ 256.0;\nconst float kKey2     = 50.5 \/ 256.0;\nconst float kKey3     = 51.5 \/ 256.0;\nconst float kKey4     = 52.5 \/ 256.0;\n\n\/\/ -- Aux functions ------------------------------------------------------------\n\nfloat MixAngle(float a, float b, float t)\n{\n    float d = (b - a);\n    d -= floor(d * 0.5 * kOneOverPi) * 2.0 * kPi;\n    \n    if (d > kPi)\n        d -= 2.0 * kPi;\n    \n    return a + d * t;\n}\n\nfloat JumpCurve(float x)\n{\n    return 1.0 - 4.0 * (x - 0.5) * (x - 0.5);\n}\n\n\/\/ -- IO functions -------------------------------------------------------------\n\nfloat SampleKey(float key)\n{\n\treturn step(0.5, texture(iChannel1, vec2(key, 0.25)).x);\n}\n\nvec2 SampleAxes()\n{\n    vec2 axes;\n    axes.x = SampleKey(kKeyRight) - SampleKey(kKeyLeft);\n    axes.y = (axes.x == 0.0)? SampleKey(kKeyUp) - SampleKey(kKeyDown) : 0.0;\n    return axes;\n}\n\n\/\/ -- State functions ----------------------------------------------------------\n\nvoid GameSetState(float state)\n{\n    gGameState     = state;\n    gGameStateTime = 0.0;\n}\n\nvoid GameRestart(float state)\n{\n    GameSetState(state);\n    gGameSeed             = iTime;\n    gPlayerCoords         = vec2(0.5, 0.5);\n    gPlayerNextCoords     = vec2(0.5, 0.5);\n    gPlayerMotionTimer    = 0.0;\n    gPlayerRotation       = 0.0;\n    gPlayerNextRotation   = 0.0;\n    gPlayerScale          = 1.0;\n    gPlayerVisualCoords   = vec3(gPlayerCoords, 0.0).xzy;\n    gPlayerVisualRotation = 0.0;\n    gPlayerDeathCause     = 0.0;\n    gScore                = 1.0;\n}\n\nvoid GameUpdate()\n{\n    float behav = GetSceneTileBehaviour(gPlayerNextCoords);\n    \n    if (behav == kBehavObstacle)\n    {\n        GameSetState(kStateGameOver);\n        gPlayerDeathCause = behav;\n        gPlayerDeathTime = iTime;\n    }\n    else if (gPlayerMotionTimer >= 1.0 && gGameState != kStateGameOver)\n    {       \n        gPlayerCoords = gPlayerNextCoords;\n        gPlayerRotation = gPlayerNextRotation;\n        \n        if (behav != kBehavGround)\n        {\n            GameSetState(kStateGameOver);\n            gPlayerDeathCause = behav;\n            gPlayerDeathTime = iTime;\n        }\n        else\n        {       \n            vec2 axes = SampleAxes();\n\n            if (dot(axes, axes) > 0.0)\n            {\n                vec2 nextCoords = GetNextCoordinates(gPlayerCoords + axes);\n\n                if (GetSceneTileBehaviour(nextCoords) != kBehavObstacle)\n                {\n                    gPlayerNextCoords = nextCoords;\n                    gPlayerMotionTimer = 0.0;\n                    gPlayerNextRotation = atan(axes.x, axes.y);\n\t\t\t\t\tgScore = max(gScore, floor(nextCoords.y));\n                }\n            }\n        }\n    }\n    else\n    {\n        gPlayerMotionTimer += iTimeDelta * kPlayerSpeed;\n    }\n        \n    vec4 coordsVss = GetSceneTileVss(gPlayerCoords);\n    vec4 nextCoordsVss = GetSceneTileVss(gPlayerNextCoords);\n    gPlayerCoords.x += coordsVss.x * coordsVss.w * iTimeDelta;\n    gPlayerNextCoords.x += nextCoordsVss.x * nextCoordsVss.w * iTimeDelta;\n    gPlayerVisualCoords.xz = mix(gPlayerCoords, gPlayerNextCoords, clamp(gPlayerMotionTimer, 0.0, 1.0));\n    gPlayerVisualCoords.y  = kPlayerJumpHeight * JumpCurve(min(1.0, gPlayerMotionTimer));\n    gPlayerVisualRotation  = MixAngle(gPlayerRotation, gPlayerNextRotation, clamp(gPlayerMotionTimer, 0.0, 1.0));\n    gPlayerScale = 1.0 + 0.1 * JumpCurve(min(1.0, gPlayerMotionTimer));\n    \n    if (gGameState == kStateGameOver)\n    {\n         if (gPlayerDeathCause == kBehavWater)\n             gPlayerVisualCoords.y = kPlayerJumpHeight * JumpCurve(gPlayerMotionTimer);\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (fragCoord.x > 14.0 || fragCoord.y > 14.0)\n        discard;\n\n    LoadState();\n       \n    if (gGameInit == 0.0)\n    {\n\t\tGameRestart(kStateTitle);\n        gFbScale = 1.0;\n        gGameInit = 1.0;\n    }\n    else if (gGameState == kStateTitle)\n    {\n        if (SampleKey(kKeySpace) == 1.0)\n            GameSetState(kStateInGame);\n    }\n    else if (gGameState == kStateInGame)\n    {\n        GameUpdate();\n    }\n    else if (gGameState == kStateGameOver)\n    {\n        GameUpdate();\n        \n        if (SampleKey(kKeySpace) == 1.0)\n            GameSetState(kStateRestarting);\n    }\n    else\n    {\n        if (gGameStateTime > 1.0)\n            GameRestart(kStateTitle);\n    }\n \n    if (SampleKey(kKey1) == 1.0)\n        gFbScale = 1.0;\n    \n    if (SampleKey(kKey2) == 1.0)\n        gFbScale = 0.75;\n    \n    if (SampleKey(kKey3) == 1.0)\n        gFbScale = 0.5;\n    \n    if (SampleKey(kKey4) == 1.0)\n        gFbScale = 0.25;\n    \n   \tgGameStateTime += iTimeDelta;\n    StoreState(fragColor, fragCoord);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\/*\n\n(06\/11\/16)\n\nSome instructions on how to play:\n\nSpace: Used to start the game and restarting on Game Over.\nArrows: Move around the player character.\n1-4: Change the render buffer resolution to get a\n     big speedup (1 - 100%, 2 - 75%, 3 - 50%, 4 - 25%).\n\n--------------------------------------\n\nKnown Issues:\n\n- Some drivers might take long to compile the shader, we're currently looking into this.\n- You might find that the player moves weirdly when jumping\n  on water tiles, we'll try to figure out a better way to handle those cases.\n\nPotential Issues:\n\n- We haven't battle tested the shader on other GPUs than NVIDIA,\n  so we don't know if they'll work at all.\n\n*\/\n\n\/\/ =============================================================================\n\/\/ START OF SHARED CODE\n\/\/ =============================================================================\n\n\/\/ -- Constants ----------------------------------------------------------------\n\n\/\/ State constants.\n\nconst float kStateTitle      = 0.0;\nconst float kStateInGame     = 1.0;\nconst float kStateGameOver   = 2.0;\nconst float kStateRestarting = 3.0;\n\n\/\/ Scene constants.\n\nconst float kSceneWidth         = 5.0;\nconst float kSceneMinTileSpeed  = 2.0;\nconst float kSceneMaxTileSpeed  = 2.0;\n\nconst float kSceneNumChunks     = 3.0;     \/\/ Number of pre-defined chunks in the scene.\nconst float kSceneChunkTiles    = 5.0;     \/\/ Number of tiles per chunk.\nconst float kSceneInvChunkTiles = 0.2;     \/\/ Inverse number of tiles per chunk.\n\nconst float kSceneTileSnow      = 0.0;     \/\/ Id of the snow tile.\nconst float kSceneTileIceRoad   = 1.0;     \/\/ Id of the ice road tile.\nconst float kSceneTileWater     = 2.0;     \/\/ Id of the water tile.\n\nconst float kBehavGround        = 0.0;\nconst float kBehavWater         = 1.0;\nconst float kBehavObstacle      = 2.0;\nconst float kBehavHazard        = 3.0;\nconst float kBehavOutOfScreen   = 4.0;\n\n\/\/ Player motion constants.\n\nconst float kPlayerSpeed      = 5.0;\nconst float kPlayerJumpHeight = 0.3;\n\n\/\/ State coordinates.\n\nconst vec2 kTexState1 = vec2(0.0, 0.0); \/\/ x   = Current state,  y  = State time, w = Init\nconst vec2 kTexState2 = vec2(1.0, 0.0); \/\/ xy  = Current coords, zw = Next coords\nconst vec2 kTexState3 = vec2(2.0, 0.0); \/\/ x   = Motion time, y = Rotation, z = NextRotation, w = Scale\nconst vec2 kTexState4 = vec2(3.0, 0.0); \/\/ xyz = Coordinates, w = Rotation\nconst vec2 kTexState5 = vec2(4.0, 0.0); \/\/ x   = Death cause, y = Death time, z = Score, w = Fb. Scale\n\n\/\/ Misc constants.\n\nconst float kPi = 3.14159265359;\nconst float kOneOverPi = 0.31830988618;\nconst float kOmega = 1e20;\n\n\/\/ -- Global values ------------------------------------------------------------\n\nfloat gGameState;\nfloat gGameStateTime;\nfloat gGameInit;\nfloat gGameSeed;\nvec2  gPlayerCoords;\nvec2  gPlayerNextCoords;\nfloat gPlayerMotionTimer;\nfloat gPlayerRotation;\nfloat gPlayerNextRotation;\nfloat gPlayerScale;\nvec3  gPlayerVisualCoords;\nfloat gPlayerVisualRotation;\nfloat gPlayerDeathCause;\nfloat gPlayerDeathTime;\nfloat gScore;\nfloat gFbScale;\n\n\/\/ -- State functions ----------------------------------------------------------\n\nfloat IsInside(vec2 p, vec2 c)\n{\n    vec2 d = abs(p - 0.5 - c) - 0.5;\n    return -max(d.x, d.y);\n}\n\nvec4 LoadValue(vec2 st)\n{ \n    return texture(iChannel0, (0.5 + st) \/ iChannelResolution[0].xy, -100.0);\n}\n\nvoid LoadState()\n{\n    vec4 state1 = LoadValue(kTexState1);\n    vec4 state2 = LoadValue(kTexState2);\n    vec4 state3 = LoadValue(kTexState3);\n    vec4 state4 = LoadValue(kTexState4);\n    vec4 state5 = LoadValue(kTexState5);\n    \n    gGameState            = state1.x;\n    gGameStateTime        = state1.y;\n    gGameSeed             = state1.z;\n    gGameInit             = state1.w;\n    gPlayerCoords         = state2.xy;\n    gPlayerNextCoords     = state2.zw;\n    gPlayerMotionTimer    = state3.x;\n    gPlayerRotation       = state3.y;\n    gPlayerNextRotation   = state3.z;\n    gPlayerScale          = state3.w;\n    gPlayerVisualCoords   = state4.xyz;\n    gPlayerVisualRotation = state4.w;\n    gPlayerDeathCause     = state5.x;\n    gPlayerDeathTime      = state5.y;\n    gScore                = state5.z;\n    gFbScale              = state5.w;\n}\n\n\/\/ -- Hashing functions --------------------------------------------------------\n\nvec4 Hash(float p)\n{\n    vec2 h = vec2(p) * vec2(1.271,3.117) + gGameSeed;\n    return texture(iChannel3, h \/ iChannelResolution[3].xy, -100.0);\n}\n\nvec4 Hash(vec2 p)\n{\n    vec2 h = p.xy * vec2(1.271,3.117) + gGameSeed;\n    return texture(iChannel3, h \/ iChannelResolution[3].xy, -100.0);\n}\n\nvec4 Hash(vec3 p)\n{\n    vec2 h = p.xy * vec2(1.271,3.117) + p.z * vec2(1.833,4.192) + gGameSeed;\n    return texture(iChannel3, h \/ iChannelResolution[3].xy, -100.0);\n}\n\n\/\/ -- Scene tile functions -----------------------------------------------------\n\n\/\/ Procedural tile management.\n\nfloat GetSceneTileIndex(float z)\n{\n    \/\/ The scene is separated into chunks of 5 consecutive tiles, where\n    \/\/ each chunk is simply a predefined set of tiles.\n    \n    \/\/ First, determine the chunk index and it's type, based on that index.\n    float chunkIndex = floor(z * kSceneInvChunkTiles);\n    float chunkType  = floor(kSceneNumChunks * Hash(chunkIndex).x) * step(1.0, chunkIndex);\n        \n   \t\/\/ Second, determine the tile number we're referring to inside the chunk.\n\tfloat tileNum = floor(kSceneChunkTiles * (z * kSceneInvChunkTiles - chunkIndex));\n    \n    \/\/ Finally, depending upon the chunk type, determine which tile occupies\n    \/\/ that location.\n\tfloat tileIdx = 0.0;\n\t\n\tif (chunkType == 0.0)\n\t{\n\t\ttileIdx = kSceneTileSnow;\n\t}\n\telse if (chunkType == 1.0)\n\t{\n\t\ttileIdx = mix(kSceneTileIceRoad, kSceneTileSnow, step(1.5, tileNum));\n\t\ttileIdx = mix(tileIdx, kSceneTileIceRoad,        step(2.5, tileNum));\n\t}\n\telse if (chunkType == 2.0)\n\t{\n\t\ttileIdx = mix(kSceneTileSnow, kSceneTileWater, step(0.5, tileNum));\n\t\ttileIdx = mix(tileIdx, kSceneTileSnow,         step(2.5, tileNum));\n\t}\n\t\n\treturn tileIdx;\n}\n\n\/\/ Snow tile management.\n\nfloat GetSceneSnowTileTreeChance(float coords, float treeIdx)\n{\n    return step(0.5, Hash(vec2(coords, treeIdx)).x) * step(0.5, coords);\n}\n\nfloat GetSceneSnowTileTreeCoord(float coords, float treeIdx)\n{\n    return floor(-kSceneWidth + 2.0 * kSceneWidth * Hash(vec2(coords, treeIdx)).y);\n}\n\n\/\/ Water and ice tiles common management.\n\nvec4 GetSceneTileVSS(float coords, float minWidth, float maxWidth, float playerCoef)\n{\n    vec4 t;\n    vec3 h = Hash(coords).xyz;\n    t.x = (kSceneMinTileSpeed + floor(kSceneMaxTileSpeed * h.x)) * (2.0 * step(0.5, h.y) - 1.0);\n    t.y = floor(mix(minWidth, maxWidth, h.z));\n    t.z = 2.0 * t.y;\n    t.w = playerCoef;\n    return t;\n}\n\nvec4 GetSceneTileVss(vec3 coordsTile)\n{\n    vec4 vss = vec4(0.0);\n    \n    if (coordsTile.z == kSceneTileWater)\n        vss = GetSceneTileVSS(coordsTile.y, 3.0, 6.0, 1.0);\n\n    if (coordsTile.z == kSceneTileIceRoad)\n\t\tvss = GetSceneTileVSS(coordsTile.y, 3.0, 8.0, 0.0);\n    \n    return vss;\n}\n\n\/\/ -- Scene gameplay functions -------------------------------------------------\n\n\/\/ Tile gameplay management.\n\nvec3 GetSceneCoordsTile(vec2 loc)\n{\n    return vec3(floor(loc), GetSceneTileIndex(loc.y));\n}\n\nfloat GetSceneTileLocalSpaceLoc(float loc, vec4 vss)\n{\n    loc = loc - iTime * vss.x;\n    return vss.z * fract(loc \/ vss.z);\n}\n\nvec4 GetSceneTileVss(vec2 loc)\n{\n    vec3 coordsTile = GetSceneCoordsTile(loc);\n    return GetSceneTileVss(coordsTile);\n}\n\nfloat GetSceneTileBehaviour(vec2 loc)\n{\n    vec3 coordsTile = GetSceneCoordsTile(loc);\n    vec4 vss = GetSceneTileVss(coordsTile);\n    \n    \/\/ Anything below or above the scene width is an obstacle.\n\tfloat isObstacle = max(step(1.0, -coordsTile.y), step(kSceneWidth + 0.5, abs(coordsTile.x)));\n\tfloat isWater = 0.0;\n    float isHazard = 0.0;\n    float isOutOfScreen = 0.0;\n    \n    \/\/ Check for each tile case.\n    if (coordsTile.z == kSceneTileSnow)\n    {\n        for (int i = 0; i < 5; i++)\n        {\n            float treeChance = GetSceneSnowTileTreeChance(coordsTile.y, float(i));\n            float treeCoord = GetSceneSnowTileTreeCoord(coordsTile.y, float(i));\n            \n            isObstacle = max(isObstacle, treeChance * (1.0 - step(0.5, abs(coordsTile.x - treeCoord))));\n        }\n    }\n    else if (coordsTile.z == kSceneTileWater)\n    {\n        isOutOfScreen = isObstacle;\n        isObstacle = 0.0;\n        \n        float l = GetSceneTileLocalSpaceLoc(loc.x, vss);        \n        if (l > vss.y) isWater = 1.0;\n    }\n    else if (coordsTile.z == kSceneTileIceRoad)\n    {\n        float l = GetSceneTileLocalSpaceLoc(loc.x, vss);\n        if (l < 2.0) isHazard = 1.0;\n    }\n    \n    float behav = kBehavGround;\n    behav = mix(behav, kBehavWater, isWater);\n    behav = mix(behav, kBehavHazard, isHazard);\n    behav = mix(behav, kBehavObstacle, isObstacle);\n    behav = mix(behav, kBehavOutOfScreen, isOutOfScreen);\n    \n    return behav;\n}\n\n\/\/ =============================================================================\n\/\/ END OF SHARED CODE\n\/\/ =============================================================================\n\n\/\/ =============================================================================\n\/\/ START OF RENDER CODE\n\/\/ =============================================================================\n\n\/\/ -- Constants ----------------------------------------------------------------\n\n\/\/ RayMarching constants\n\nconst int   kMaxSteps          = 30;    \/\/ Max number of raymarching steps\nconst float kStepRatio         = 1.0;\nconst float kMaxDistance       = 50.0;  \/\/ Max raymarching distance\nconst float kMinDistance       = 13.0;  \/\/ Max raymarching distance\nconst float kBias              = 0.05;  \/\/ Bias offset for normal estimation\nconst float kParallelThreshold = 1e-5;\nconst float kNoHit             = -1.0;  \/\/ No intersection distance.\n        \n\/\/ Material constants.\nconst float kMaterialNone                 = 0.0;\nconst float kMaterialPenguinBlackFeathers = 1.0;\nconst float kMaterialPenguinWhiteFeathers = 2.0;\nconst float kMaterialPenguinEyes          = 3.0;\nconst float kMaterialPenguinBeak          = 4.0;\nconst float kMaterialSledMetal            = 5.0;\nconst float kMaterialSled                 = 6.0;\nconst float kMaterialMonsterSkinGreen     = 7.0;\nconst float kMaterialMonsterSkinWhite     = 8.0;\nconst float kMaterialEnvironmentSnow      = 9.0;\nconst float kMaterialEnvironmentIce       = 10.0;\nconst float kMaterialEnvironmentWater     = 11.0;\nconst float kMaterialTreeWood             = 12.0;\nconst float kMaterialTreeLeaves           = 9.0;\nconst float kMaterialRiderSkin            = 14.0;\nconst float kMaterialRiderCloth1          = 15.0;\nconst float kMaterialRiderCloth2          = 16.0;\n\n\/\/ Other constants\n\nconst vec3 kOnes = vec3(1.0, -1.0, 0.0);               \/\/ Helper vector with ones.\n\n\/\/ -- Global values ------------------------------------------------------------\n\nvec3 gCameraPosition;\nvec4 gCameraRotation;\n\n\/\/ -- Structures ---------------------------------------------------------------\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct RayHit\n{\n    float time;\n    float material;\n};\n\nstruct DistSample\n{\n    float dist;\n    float stepRatio;\n    float material;\n};\n\n    \n\/\/ --- Math funcs --------------------------------------------------------------\n\nvec4 QMul(vec4 q1, vec4 q2)\n{\n    vec4 res;\n    res.w = q1.w * q2.w - dot(q1.xyz, q2.xyz);\n    res.xyz = q1.w * q2.xyz + q2.w * q1.xyz + cross(q1.xyz, q2.xyz);\n    return res;\n}\n\nvec4 QAxisAngle(vec3 axis, float angle)\n{\n    float theta = 0.5 * angle;\n    float sine = sin(theta);\n    return vec4(sin(theta) * axis, cos(theta));\n}\n\nvec4 QConjugate(vec4 q)\n{\n    return vec4(q.xyz, -q.w);\n}\n\nvec3 QTransform(vec3 v, vec4 q)\n{\n    vec3 t = 2.0 * cross(q.xyz, v);\n    return v + q.w * t + cross(q.xyz, t);\n}\n\nvec4 QEuler(vec3 angles)\n{\n    vec4 qx = QAxisAngle(vec3(1.0, 0.0, 0.0), angles.x);\n    vec4 qy = QAxisAngle(vec3(0.0, 1.0, 0.0), angles.y);\n    vec4 qz = QAxisAngle(vec3(0.0, 0.0, 1.0), angles.z);\n    return QMul(qz, QMul(qy, qx));\n}\n\n\/\/ -- Misc. functions ----------------------------------------------------------\n\nvec3 HSV(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 \/ 3.0, 1.0 \/ 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat smin(float a, float b, float k)\n{\n    \/\/float h = clamp( 0.5+0.5*(b-a)\/k, 0.0, 1.0 );\n    \/\/return mix(b, a, h) - k*h*(1.0-h);\n    float h = clamp((b - a)\/k, -1.0, 1.0);\n    return mix(b, a, smoothstep(-1.0, 1.0, h));\n}\n\n\n\/\/ -- Noise functions ----------------------------------------------------------\n\nfloat Perlin(vec2 p)\n{    \n    vec4 i;\n    i.xy = floor(p);\n    i.zw = i.xy + vec2(1.0, 1.0);\n    \n    vec2 f = fract(p);  \n    vec2 u = smoothstep(0.0, 1.0, f);\n    \n    float f00 = mix(Hash(i.xy).x, Hash(i.zy).x, u.x);\n    float f01 = mix(Hash(i.xw).x, Hash(i.zw).x, u.x);\n    float f1 = mix(f00, f01, u.y);\n    \n    return f1;\n}\n\nfloat Cellular(vec3 p, float k)\n{\n    vec3 i = floor(p);\n\tfloat d = 1.0;\n\t\n\tfor (int x = -1; x <= 1; x++)\n\tfor (int y = -1; y <= 1; y++)\n    for (int z = -1; z <= 1; z++)\n\t{\n\t\tvec3 q = i + vec3(x, y, z);\n\t\tq += Hash(q).xyz - p;\n\t\td = smin(d, dot(q, q), k);\n\t}\n\n    return sqrt(d);\n}\n\n\/\/ -- Ray funcs ----------------------------------------------------------------\n\nRay MakeRay(vec3 ro, vec3 rd)\n{\n\tRay ray;\n\tray.origin = ro;\n\tray.direction = rd;\n\treturn ray;\n}\n\nRayHit MakeRayHit(float t, float m)\n{\n    RayHit h;\n    h.time = t;\n    h.material = m;\n    return h;\n}\n\nDistSample MakeDistSample(float d, float s, float m)\n{\n    DistSample h;\n    h.dist = d;\n    h.stepRatio = s;\n    h.material = m;\n    return h;\n}\n\n\/\/ -- SDF CGS funcs ------------------------------------------------------------\n\nDistSample OpU(DistSample d1, DistSample d2)\n{\n    if (d1.dist < d2.dist) return d1; return d2;\n}\n\nDistSample OpS(DistSample d1, DistSample d2)\n{\n    d2.dist = -d2.dist;\n    if (d1.dist > d2.dist) return d1; return d2;\n}\n\nDistSample OpI(DistSample d1, DistSample d2)\n{\n    if (d1.dist > d2.dist) return d1; return d2;\n}\n\n\/\/ -- Transform funcs ----------------------------------------------------------\n\nvec3 Tx(vec3 p, vec3 tx)\n{\n    return (p - tx);\n}\n\nvec3 Tx(vec3 p, vec3 tx, vec3 s)\n{\n    p -= tx;\n    p \/= s;\n    return p;\n}\n\nvec3 Tx(vec3 p, vec3 tx, vec4 q)\n{\n    p -= tx;\n    return QTransform(p, QConjugate(q));\n}\n\nvec3 Tx(vec3 p, vec3 tx, vec4 q, vec3 s)\n{\n    p -= tx;\n    p = QTransform(p, QConjugate(q));\n    p \/= s;    \n    return p;\n}\n\nvec3 Tx(vec3 p, vec3 tx, vec3 axis, float angle)\n{\n    return Tx(p, tx, QAxisAngle(axis, angle));\n}\n\nvec3 Tx(vec3 p, vec3 tx, vec3 axis, float angle, vec3 s)\n{\n    return Tx(p, tx, QAxisAngle(axis, angle), s);\n}\n\n\/\/ -- SDF funcs ----------------------------------------------------------------\n\nDistSample SdfBox(vec3 p, vec3 b, float mat)\n{\n  vec3 d = abs(p) - b;\n  return MakeDistSample(min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0)), 1.0, mat);\n}\n\nDistSample SdfPenguin(vec3 p)\n{\n    DistSample result = SdfBox(p, vec3(0.75), kMaterialNone);\n    \n    if (result.dist < 0.5)\n    {\n        if (gGameState == kStateGameOver && gPlayerDeathCause == kBehavHazard)\n        {\n            DistSample result = SdfBox(Tx(p, vec3(0, 0.047, -0.082)), vec3(0.2799999, 0.04, 0.1204678), kMaterialPenguinBlackFeathers);\n            result = OpU(result, SdfBox(Tx(p, vec3(0, 0.107, 0.038)), vec3(0.28, 0.02, 0.24), kMaterialPenguinBlackFeathers));\n            result = OpU(result, SdfBox(Tx(p, vec3(0, 0.047, 0.158)), vec3(0.28, 0.04, 0.12), kMaterialPenguinWhiteFeathers));\n            result = OpU(result, SdfBox(Tx(p, vec3(0, 0.031, -0.282)), vec3(0.28, 0.024, 0.08000001), kMaterialPenguinBlackFeathers));\n            result = OpU(result, SdfBox(Tx(p, vec3(0, 0.095, 0.29)), vec3(0.12, 0.008, 0.08000001), kMaterialPenguinBeak));\n            result = OpU(result, SdfBox(Tx(p, vec3(-0.152, -0.001, -0.022)), vec3(0.048, 0.01, 0.06000001), kMaterialPenguinBeak));\n            result = OpU(result, SdfBox(Tx(p, vec3(0.152, -0.001, -0.022)), vec3(0.048, 0.01, 0.06000001), kMaterialPenguinBeak));\n            result = OpU(result, SdfBox(Tx(p, vec3(0.152, -0.009, 0.01)), vec3(0.112, 0.004, 0.16), kMaterialPenguinBeak));\n            result = OpU(result, SdfBox(Tx(p, vec3(-0.152, -0.009, 0.01)), vec3(0.112, 0.004, 0.16), kMaterialPenguinBeak));\n            result = OpU(result, SdfBox(Tx(p, vec3(0.136, 0.111, 0.29)), vec3(0.032, 0.006000001, 0.012), kMaterialPenguinEyes));\n            result = OpU(result, SdfBox(Tx(p, vec3(-0.136, 0.111, 0.29)), vec3(0.032, 0.006000001, 0.012), kMaterialPenguinEyes));\n            result = OpU(result, SdfBox(Tx(p, vec3(0.323, 0.037, -0.002), vec4(0, 0, 0.1736482, 0.9848078)), vec3(0.05, 0.028, 0.12), kMaterialPenguinBlackFeathers));\n            result = OpU(result, SdfBox(Tx(p, vec3(-0.342, 0.045, -0.002), vec4(0, 0, -0.1736482, 0.9848078)), vec3(0.04999999, 0.028, 0.12), kMaterialPenguinBlackFeathers));\n            return result;\n\n        }\n        else\n        {\n            result = SdfBox(Tx(p, vec3(0, 0.296, -0.0855)), vec3(0.14, 0.2, 0.06023391), kMaterialPenguinBlackFeathers);\n            result = OpU(result, SdfBox(Tx(p, vec3(0, 0.596, -0.0255)), vec3(0.14, 0.1, 0.12), kMaterialPenguinBlackFeathers));\n            result = OpU(result, SdfBox(Tx(p, vec3(0, 0.296, 0.0345)), vec3(0.14, 0.2, 0.06000001), kMaterialPenguinWhiteFeathers));\n            result = OpU(result, SdfBox(Tx(p, vec3(0, 0.216, -0.1855)), vec3(0.14, 0.12, 0.04), kMaterialPenguinBlackFeathers));\n            result = OpU(result, SdfBox(Tx(p, vec3(0, 0.536, 0.1005)), vec3(0.06, 0.04, 0.04), kMaterialPenguinBeak));\n            result = OpU(result, SdfBox(Tx(p, vec3(-0.076, 0.056, -0.0555)), vec3(0.024, 0.05, 0.03), kMaterialPenguinBeak));\n            result = OpU(result, SdfBox(Tx(p, vec3(0.076, 0.056, -0.0555)), vec3(0.024, 0.05, 0.03), kMaterialPenguinBeak));\n            result = OpU(result, SdfBox(Tx(p, vec3(0.076, 0.016, -0.0395)), vec3(0.056, 0.02, 0.08000001), kMaterialPenguinBeak));\n            result = OpU(result, SdfBox(Tx(p, vec3(-0.076, 0.016, -0.0395)), vec3(0.056, 0.02, 0.08000001), kMaterialPenguinBeak));\n            result = OpU(result, SdfBox(Tx(p, vec3(0.068, 0.616, 0.1005)), vec3(0.016, 0.03, 0.006000001), kMaterialPenguinEyes));\n            result = OpU(result, SdfBox(Tx(p, vec3(-0.068, 0.616, 0.1005)), vec3(0.016, 0.03, 0.006000001), kMaterialPenguinEyes));\n            result = OpU(result, SdfBox(Tx(p, vec3(0.18, 0.316, -0.0455), vec4(0, 0, 0.1736482, 0.9848078)), vec3(0.025, 0.14, 0.06000001), kMaterialPenguinBlackFeathers));\n            result = OpU(result, SdfBox(Tx(p, vec3(-0.18, 0.316, -0.0455), vec4(0, 0, -0.1736482, 0.9848078)), vec3(0.025, 0.14, 0.06000001), kMaterialPenguinBlackFeathers));\n        }\n    }\n    return result;\n}\n\nDistSample SdfSled(vec3 p)\n{\n    DistSample result = SdfBox(Tx(p, vec3(0, 0.241, 0.1725)), vec3(0.294, 0.07, 0.49), kMaterialSled);\n    result = OpU(result, SdfBox(Tx(p, vec3(0, 0.42, -0.5625)), vec3(0.294, 0.25, 0.245), kMaterialSled));\n    result = OpU(result, SdfBox(Tx(p, vec3(0.168, 0.136, -0.5625)), vec3(0.0336, 0.07, 0.049), kMaterialSledMetal));\n    result = OpU(result, SdfBox(Tx(p, vec3(-0.168, 0.136, -0.5625)), vec3(0.0336, 0.07, 0.049), kMaterialSledMetal));\n    result = OpU(result, SdfBox(Tx(p, vec3(0.168, 0.136, 0.07450002)), vec3(0.0336, 0.07, 0.049), kMaterialSledMetal));\n    result = OpU(result, SdfBox(Tx(p, vec3(-0.168, 0.136, 0.07450002)), vec3(0.0336, 0.07, 0.049), kMaterialSledMetal));\n    result = OpU(result, SdfBox(Tx(p, vec3(0.168, 0.031, 0.07450002)), vec3(0.0336, 0.028, 0.833), kMaterialSledMetal));\n    result = OpU(result, SdfBox(Tx(p, vec3(-0.168, 0.031, 0.07450002)), vec3(0.0336, 0.028, 0.833), kMaterialSledMetal));\n    result = OpU(result, SdfBox(Tx(p, vec3(0.269, 0.374, 0.1725)), vec3(0.025, 0.07, 0.49), kMaterialSled));\n    result = OpU(result, SdfBox(Tx(p, vec3(-0.269, 0.374, 0.1725)), vec3(0.025, 0.07, 0.49), kMaterialSled));\n    result = OpU(result, SdfBox(Tx(p, vec3(0, 0.407, 0.562)), vec3(0.294, 0.1, 0.1), kMaterialSled));\n    result = OpU(result, SdfBox(Tx(p, vec3(0, 0.554, -0.152)), vec3(0.15, 0.225, 0.115), kMaterialRiderCloth2));\n    result = OpU(result, SdfBox(Tx(p, vec3(0.119, 0.389, 0.033)), vec3(0.08, 0.06599999, 0.3), kMaterialRiderCloth1));\n    result = OpU(result, SdfBox(Tx(p, vec3(-0.119, 0.389, 0.033)), vec3(0.08, 0.06599999, 0.3), kMaterialRiderCloth1));\n    result = OpU(result, SdfBox(Tx(p, vec3(-0.162, 0.549, 0.005), vec4(0.3420202, 0, 0, 0.9396926)), vec3(0.032, 0.06599999, 0.25), kMaterialRiderCloth2));\n    result = OpU(result, SdfBox(Tx(p, vec3(0.162, 0.549, 0.005), vec4(0.3420202, 0, 0, 0.9396926)), vec3(0.032, 0.06599999, 0.25), kMaterialRiderCloth2));\n    result = OpU(result, SdfBox(Tx(p, vec3(0, 0.871, -0.128)), vec3(0.15, 0.1, 0.125), kMaterialRiderSkin));\n    result = OpU(result, SdfBox(Tx(p, vec3(0, 1.02, -0.128)), vec3(0.15, 0.05, 0.125), kMaterialRiderCloth1));\n    return result;    \n}\n\nDistSample SdfTree(vec3 p)\n{\n    DistSample result = SdfBox(p, vec3(1.0), kMaterialNone);\n    \n    if (result.dist < 1.0)\n    {\n\t\tDistSample result = SdfBox(Tx(p, vec3(0.5, 0.589, 0.5)), vec3(0.08700001, 0.6, 0.087), kMaterialTreeWood);\n\t\tresult = OpU(result, SdfBox(Tx(p, vec3(0.5, 0.591, 0.5)), vec3(0.348, 0.19575, 0.348), kMaterialTreeLeaves));\n        result = OpU(result, SdfBox(Tx(p, vec3(0.5, 0.985, 0.5)), vec3(0.261, 0.1305, 0.261), kMaterialTreeLeaves));\n        result = OpU(result, SdfBox(Tx(p, vec3(0.5, 1.281, 0.5)), vec3(0.174, 0.1044, 0.174), kMaterialTreeLeaves));\n        return result;\n    }\n    \n    return result;\n}\n\nDistSample SdfTreeGroup(vec3 p)\n{\n    p.x = clamp(p.x, -10.0, 10.0);\n    p.x = mod(p.x + 1.0, 2.0) - 1.0;\n    return SdfTree(p);\n}\n\nDistSample SdfSnowTile(vec3 p, vec3 coordsTile, vec4 vss)\n{\n    DistSample result = SdfBox(Tx(p, vec3(0.0, -0.5, 0.5)), vec3(30, 0.5, 0.5), kMaterialEnvironmentSnow);\n    \n    for (int i = 0; i < 5; i++)\n    {\n        float treeChance = GetSceneSnowTileTreeChance(coordsTile.y, float(i));\n        float treeCoord = GetSceneSnowTileTreeCoord(coordsTile.y, float(i));\n\n        if (treeChance > 0.0)\n            result = OpU(result, SdfTree(Tx(p, vec3(treeCoord, 0.0, 0.0))));\n    }\n    \n    float offset = step(0.5, fract(coordsTile.y * 0.5));\n    result = OpU(result, SdfTreeGroup(Tx(p, vec3(-kSceneWidth - 10.0 + offset, 0.0, 0.0))));\n    result = OpU(result, SdfTreeGroup(Tx(p, vec3(kSceneWidth + 11.0 + offset, 0.0, 0.0))));\n\treturn result;\n}\n\nDistSample SdfIceTile(vec3 p, vec3 coordsTile, vec4 vss)\n{\n    DistSample result = SdfBox(Tx(p, vec3(0.0, -0.6, 0.5)), vec3(30, 0.5, 0.5), kMaterialEnvironmentIce);\n    \n    p.x = GetSceneTileLocalSpaceLoc(p.x, vss);\n    result = OpU(result, SdfSled(Tx(p, vec3(1.0, 0.0, 0.5), vec3(0.0, 1.0, 0.0), (-0.5 + step(0.0, vss.x)) * kPi)));\n   \n\treturn result;\n}\n\nDistSample SdfWaterTile(vec3 p, vec3 coordsTile, vec4 vss)\n{   \n    DistSample result = SdfBox(Tx(p, vec3(0.0, -0.7, 0.5)), vec3(30, 0.5, 0.5), kMaterialEnvironmentWater);\n    \n    p.x = GetSceneTileLocalSpaceLoc(p.x, vss);\n    result = OpU(result, SdfBox(Tx(p, vec3(0.5 * vss.y, -0.5, 0.5)), vec3(0.5 * vss.y - 0.25, 0.5, 0.25), kMaterialEnvironmentIce));\n   \n\treturn result;\n}\n\nDistSample SdfEnvironment(vec3 p, vec3 coordsTile, vec4 vss)\n{\n    p = Tx(p, vec3(0.0, 0.0, coordsTile.y));\n    \n    if (coordsTile.z == kSceneTileSnow)         return SdfSnowTile(p, coordsTile, vss);\n    else if (coordsTile.z == kSceneTileIceRoad) return SdfIceTile(p, coordsTile, vss);\n    else                                        return SdfWaterTile(p, coordsTile, vss);\n}\n\nDistSample SdfEnvironment(vec3 p)\n{\n\tvec3 coordsTile = GetSceneCoordsTile(p.xz);\n\tvec4 vss = GetSceneTileVss(coordsTile);\n    return SdfEnvironment(p, coordsTile, vss);\n}\n\n\/\/ --- Scene funcs -------------------------------------------------------------\n\nDistSample Scene(vec3 p)\n{\n    DistSample result;\n    result = SdfPenguin(Tx(p, gPlayerVisualCoords, vec3(0, 1, 0), gPlayerVisualRotation, vec2(gPlayerScale, 1.0 \/ gPlayerScale).yxy));\n    result = OpU(result, SdfEnvironment(p));\n    return result;\n}\n\nvec3 SceneNormal(vec3 position)\n{\n    vec2 offset = vec2(0.05, 0.0);\n    float d = Scene(position - offset.xyy).dist;\n    \n    return normalize(vec3\n    (\n        Scene(position + offset.xyy).dist - d,\n        Scene(position + offset.yxy).dist - d,\n        Scene(position + offset.yyx).dist - d\n    ));\n}\n\nRayHit Raymarch(Ray ray, float tmin, float tmax)\n{\n    \/\/ We need to use a bit of an special raymarcher,\n    \/\/ as we're sampling the distance field in tiles.\n        \n    DistSample d;\n\n    float t = tmin;\n    vec3  p = ray.origin + ray.direction * t;\n    vec3  s = vec3(ray.direction.xy \/ ray.direction.z, 1.0);\n    \n    for (int i = 0; i < kMaxSteps; i++)\n    {\n        \/\/ Sample scene distance field.\n        d = Scene(p);\n        \n        \/\/ Determine the current step distance.\n        float td = d.dist * d.stepRatio * kStepRatio;\n\n        \/\/ If the ray is not parallel to the Z axis,\n        \/\/ ensure we're stopping by the axis.\n        if (abs(ray.direction.z) > kParallelThreshold)\n        {\n            \/\/ Perform slope-based intersection.\n            float dz = floor(p.z) - p.z + (ray.direction.z < 0.0? -kBias : 1.0 + kBias);\n\t\t\ttd = min(td, distance(p, p + s * dz));\n        }\n\n        p += ray.direction * td;\n        t += td;\n        \n        if (abs(d.dist) < 1e-2 || (t >= tmax))\n            break;\n    }\n    \n    if (t < kMaxDistance)\n        return MakeRayHit(t, d.material);\n    \n    return MakeRayHit(kNoHit, kMaterialNone);\n}\n\n\nvoid Material(float material, vec3 position, out vec3 albedo, out float specular, out float shininess)\n{\n    if (material == kMaterialPenguinBlackFeathers)\n    {\n        albedo = vec3(0.35, 0.27, 0.82);\n        specular = 0.3;\n        shininess = 256.0;\n    }\n    else if (material == kMaterialPenguinWhiteFeathers)\n    {\n        albedo = vec3(1, 1, 1);\n        specular = 0.3;\n        shininess = 256.0;\n    }   \n    else if (material == kMaterialPenguinEyes)\n    {\n        albedo = vec3(0.1, 0.1, 0.1);\n        specular = 0.3;\n        shininess = 256.0;\n    }   \n    else if (material == kMaterialPenguinBeak)\n    {\n        albedo = vec3(1.0, 0.26, 0.055225);\n        specular = 0.3;\n        shininess = 256.0;\n    }   \n    else if (material == kMaterialMonsterSkinGreen)\n    {\n        albedo = vec3(0.0484, 0.8836, 0.0576);\n        specular = 0.3;\n        shininess = 1024.0;\n    }\n    else if (material == kMaterialEnvironmentSnow)\n    {\n        albedo = vec3(0.81, 0.9025, 1.0);\n        specular = 0.0;\n        shininess = 1024.0;\n    }\n    else if (material == kMaterialEnvironmentIce)\n    {\n        vec2 p = position.xz * vec2(1.0, 16.0);\n        \n        float texture = (1.0 \/ 56.0) * (32.0 * Perlin(p) + 16.0 * Perlin(p * 4.0) + 8.0 * Perlin(p * 8.0));\n        texture *= texture;\n        texture *= texture;\n        \n        albedo = mix(vec3(0.6, 0.8, 1.0), vec3(0.4), texture);\n        specular = 0.3;\n        shininess = 256.0;\n    }\n    else if (material == kMaterialEnvironmentWater)\n    {\n        vec3 p = position * 2.0 + vec3(iTime * 1.0, iTime * 0.7, 0.0);\n\n        float texture = Cellular(p, 0.1);\n        texture *= texture;\n        texture *= texture;\n        texture *= texture;\n        texture = max(texture, smoothstep(0.75, 0.0, abs(abs(position.x) - kSceneWidth)) * (0.3 + Perlin(p.xz * 5.0)));\n        \n        albedo = mix(vec3(0.12, 0.4, 0.7), vec3(1.0), texture);\n        specular = 1.0;\n        shininess = 8.0;\n    }\n    else if (material == kMaterialTreeWood)\n    {\n        albedo = vec3(0.36, 0.08, 0.0);\n        specular = 0.3;\n        shininess = 256.0;\n    }\n    else if (material == kMaterialSledMetal)\n    {\n        albedo = vec3(0.5476, 0.5476, 0.5476);\n        specular = 0.3;\n        shininess = 256.0;\n    }    \n    else if (material == kMaterialSled)\n    {\n        float hash = Hash(GetSceneCoordsTile(position.xz).y * 20.0).x;\n        albedo = HSV(vec3(hash, 0.8, 1.0));\n        specular = 0.3;\n        shininess = 256.0;\n    }\n    else if (material == kMaterialRiderSkin)\n    {\n        albedo = vec3(0.9231064975, 0.537777, 0.34142);\n        specular = 0.3;\n        shininess = 256.0;\n    }\n    else if (material == kMaterialRiderCloth1)\n    {\n        float hash = Hash(GetSceneCoordsTile(position.xz).y * 40.0).z;\n        albedo = HSV(vec3(hash, 0.8, 0.5));\n        albedo *= albedo;\n        specular = 0.3;\n        shininess = 256.0;\n    }\n    if (material == kMaterialRiderCloth2)\n    {\n        float hash = Hash(GetSceneCoordsTile(position.xz).y * 80.0).y;\n        albedo = HSV(vec3(hash, 0.2, 0.7));\n        albedo *= albedo;\n        specular = 0.3;\n        shininess = 256.0;\n    }\n}\n\nfloat LightingShadow(vec3 o, vec3 d, float minDist, float maxDist)\n{\n    float t = minDist;\n        \n    for (int i = 0; i < 24; i++)\n    {\n\t\tfloat h = Scene(o + d * t).dist;\n        t += h;\n        \n        if (h < 0.005) \n            return 0.0;\n        \n        if (t > maxDist)\n            break;\n    }\n\t\n    return 1.0;\n}\n\nfloat LightingAmbientOcclusion(vec3 p, vec3 n)\n{\n\tfloat ao = 0.0;\n    float sca = 1.0;\n\t\n    for (int i = 0; i < 5; i++)\n    {\n        float hr = 0.01 + 0.12 * float(i) \/ 4.0;\n        float dd = Scene(n * hr + p).dist;\n        ao += -(dd - hr) * sca;\n        sca *= 0.95;\n    }\n\t\n    return clamp(1.0 - 3.0 * ao, 0.0, 1.0);    \n}\n\nvec3 LightingIndirect(vec3 n, vec3 albedo, vec3 sky, vec3 ground)\n{\n    float a = clamp(0.5 + 0.5 * n.y, 0.0, 1.0);\n    return albedo * mix(ground, sky, a);\n}\n\nvec3 LightingDirect(vec3 l, vec3 v, vec3 p, vec3 n, vec3 albedo, float specular, float shininess)\n{  \n    vec3 h = normalize(l + v);\n    float LdotN = max(0.0, dot(l, n));\n\tfloat HdotN\t= max(0.0, dot(h, n));\n    float shadow = LightingShadow(p + n * kBias, l, 0.02, 8.0);\n    return shadow * LdotN * (albedo + vec3(specular) * pow(HdotN, shininess));\n}\n\nvec3 SkyColor(vec3 n)\n{\n    return vec3(0.1, 0.1, 0.1);\n}\n\n\/\/ --- Camera funcs ------------------------------------------------------------\n\nRay OrthographicCamera(float size, vec2 uv, vec3 offs, vec4 rot)\n{\n    uv.x = -uv.x;\n    \n    Ray ray;\n    ray.direction = QTransform(vec3(0.0, 0.0, -1.0), rot);\n    ray.origin = offs + size * (QTransform(vec3(1.0, 0.0, 0.0), rot) * uv.x + QTransform(vec3(0.0, 1.0, 0.0), rot) * uv.y);\n    \n    return ray;\n}\n\n\/\/ =============================================================================\n\/\/ END OF RENDER CODE\n\/\/ =============================================================================\n\n\/\/ --- Main --------------------------------------------------------------------\n\nvec3 DebugColor(vec2 loc)\n{   \n    \/\/ Compute tile beneath the location and output the corresponding\n    \/\/ debug color.\n    vec3 coordsTile = GetSceneCoordsTile(loc);\n\tvec3 color = HSV(vec3(coordsTile.z \/ 3.0, 1.0, 1.0));\n    \n    float behav = GetSceneTileBehaviour(loc);\n    \n    if (behav == kBehavObstacle) color = vec3(1.0, 0.5, 0.0);\n    if (behav == kBehavWater)    color = vec3(0.0, 1.0, 0.5);\n    if (behav == kBehavHazard)   color = vec3(1.0, 0.0, 0.5);\n    \n    \/\/ Display grid (visual aid).\n\tfloat grid = 0.5 + 0.5 * step(0.1, fract(loc.x)) * step(0.1, fract(loc.y));\n\tgrid *= 0.25 + 0.75 * step(0.05, fract(loc.y * kSceneInvChunkTiles));\n    color *= 0.5 + 0.5 * grid;\n    \n    \/\/ Display penguin's location.\n    color = mix(color, vec3(1.0), smoothstep(0.4, 0.35, distance(loc, gPlayerVisualCoords.xz)));\n    \n    return color;\n}\n\nvoid RenderScene(inout vec4 fragColor, vec2 fragCoord, vec2 uv)\n{\n    \/\/ Setup camera.\n\tgCameraRotation = QEuler(radians(vec3(-45.0, 160.0, 0.0)));\n    gCameraPosition = vec3(gPlayerVisualCoords.xz, 0.0).xzy;\n    gCameraPosition.x = clamp(gCameraPosition.x, -kSceneWidth * 0.4, kSceneWidth * 0.4);\n    gCameraPosition.z = max(gCameraPosition.z, kSceneWidth * 0.75);\n    gCameraPosition += QTransform(vec3(0.0, 0.0, 20.0), gCameraRotation);\n                                     \n    \/\/ Generate first ray and raymarch along scene.\n \tRay ray = OrthographicCamera(4.0, uv, gCameraPosition, gCameraRotation);\n    RayHit hit = Raymarch(ray, kMinDistance, kMaxDistance);\n\n\t\/\/ Initialize color to sky.\n\tfragColor.rgb = SkyColor(ray.direction);\n    \n    \/\/ If there was an intersection, compute normal and the hit surface color.\n    if (hit.material != kMaterialNone)\n    {\n        vec3 p = ray.direction * hit.time + ray.origin;\n        vec3 n = SceneNormal(p);\n        vec3 v = normalize(gCameraPosition - p);\n\n        vec3 albedo;\n        float shininess;\n        float specular;\n        Material(hit.material, p, albedo, specular, shininess);\n        \n        vec3 l = normalize(vec3(-0.6, 0.7, -0.5));\n        \n        float ao = LightingAmbientOcclusion(p, n);\n        fragColor.rgb = vec3(1.00, 0.85, 0.55) * LightingDirect(l, v, p, n, albedo, specular, shininess);\n        fragColor.rgb += ao * LightingIndirect(n, albedo, vec3(0.50, 0.70, 1.00), vec3(0.0, 0.0, 0.0));\n    }\n    \n    \/\/ Convert to gamma space and apply vignetting effect.\n    fragColor.rgb = sqrt(fragColor.rgb);\n    fragColor.rgb -= fragColor.rgb * 0.1 * dot(uv, uv);\n}\n\nvoid RenderSceneDebug(inout vec4 fragColor, vec2 fragCoord, vec2 uv)\n{\n\tvec2 loc = uv * 10.0 + gPlayerVisualCoords.xz;\n\tfragColor.rgb = DebugColor(loc);\n\tfragColor.a = 1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    LoadState();\n    \n    \/\/ Compute aspect ratio.\n    float aspect = iResolution.x \/ iResolution.y;\n    \n    \/\/ Compute uv coords.\n    vec2 uv = fragCoord.xy \/ (gFbScale * iResolution.xy);\n    \n    if (max(uv.x, uv.y) > 1.0)\n        discard;\n\n    uv = 2.0 * uv - 1.0;\n    uv.x *= aspect;\n    \n    \/\/ Render scene.\n\t\/\/RenderSceneDebug(fragColor, fragCoord, uv * 0.75);\n    RenderScene(fragColor, fragCoord, uv);\n}\n","name":"Buf B","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"XsKGRW","date":"1453904549","viewed":11394,"name":"Full Scene Radial Blur","username":"Shane","description":"Applying some God rays, post process, to a simple raymarched scene. Inspired by Passion's \"Blue Dream\" ... and a lot of old demos. :)","likes":159,"published":3,"flags":32,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/*\n\tFull Scene Radial Blur\n\t----------------------\n\n\tRadial blur - as a postprocessing effect - is one of the first things I considered doing \n\twhen the multipass system came out. I've always loved this effect. Reminds me of the early \n\tdemos from Aardbei et al. \n\n\tAnyway, Shadertoy user, Passion, did a really cool radial blur on a field of spheres that\n\tinspired me to do my own. Radial blurs are pretty straight forward, but it was still\n    helpful to have Passion's version as a guide. \n\n    As for the radial blur process, there's not much to it. Start off at the pixel position, \n    then radiate outwards gathering up pixels with decreased weighting. The result is a\n\tblurring of the image in a radial fashion, strangely enough. :)\n\n\tInspired by:\n\n\tBlue Dream - Passion\n\thttps:\/\/www.shadertoy.com\/view\/MdG3RD\n\n\tRadial Blur - IQ\n\thttps:\/\/www.shadertoy.com\/view\/4sfGRn\n\n\tRays of Blinding Light - mu6k\n\thttps:\/\/www.shadertoy.com\/view\/lsf3Dn\n\n*\/\n\n\/\/ The radial blur section. Shadertoy user, Passion, did a good enough job, so I've used a\n\/\/ slightly trimmed down version of that. By the way, there are accumulative weighting \n\/\/ methods that do a slightly better job, but this method is good enough for this example.\n\n\n\/\/ Radial blur samples. More is always better, but there's frame rate to consider.\nconst float SAMPLES = 24.; \n\n\n\/\/ 2x1 hash. Used to jitter the samples.\nfloat hash( vec2 p ){ return fract(sin(dot(p, vec2(41, 289)))*45758.5453); }\n\n\n\/\/ Light offset.\n\/\/\n\/\/ I realized, after a while, that determining the correct light position doesn't help, since \n\/\/ radial blur doesn't really look right unless its focus point is within the screen boundaries, \n\/\/ whereas the light is often out of frame. Therefore, I decided to go for something that at \n\/\/ least gives the feel of following the light. In this case, I normalized the light position \n\/\/ and rotated it in unison with the camera rotation. Hacky, for sure, but who's checking? :)\nvec3 lOff(){    \n    \n    vec2 u = sin(vec2(1.57, 0) - iTime\/2.);\n    mat2 a = mat2(u, -u.y, u.x);\n    \n    vec3 l = normalize(vec3(1.5, 1., -0.5));\n    l.xz = a * l.xz;\n    l.xy = a * l.xy;\n    \n    return l;\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    \/\/ Screen coordinates.\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n\n    \/\/ Radial blur factors.\n    \/\/\n    \/\/ Falloff, as we radiate outwards.\n    float decay = 0.97; \n    \/\/ Controls the sample density, which in turn, controls the sample spread.\n    float density = 0.5; \n    \/\/ Sample weight. Decays as we radiate outwards.\n    float weight = 0.1; \n    \n    \/\/ Light offset. Kind of fake. See above.\n    vec3 l = lOff();\n    \n    \/\/ Offset texture position (uv - .5), offset again by the fake light movement.\n    \/\/ It's used to set the blur direction (a direction vector of sorts), and is used \n    \/\/ later to center the spotlight.\n    \/\/\n    \/\/ The range is centered on zero, which allows the accumulation to spread out in\n    \/\/ all directions. Ie; It's radial.\n    vec2 tuv =  uv - .5 - l.xy*.45;\n    \n    \/\/ Dividing the direction vector above by the sample number and a density factor\n    \/\/ which controls how far the blur spreads out. Higher density means a greater \n    \/\/ blur radius.\n    vec2 dTuv = tuv*density\/SAMPLES;\n    \n    \/\/ Grabbing a portion of the initial texture sample. Higher numbers will make the\n    \/\/ scene a little clearer, but I'm going for a bit of abstraction.\n    vec4 col = texture(iChannel0, uv.xy)*0.25;\n    \n    \/\/ Jittering, to get rid of banding. Vitally important when accumulating discontinuous \n    \/\/ samples, especially when only a few layers are being used.\n    uv += dTuv*(hash(uv.xy + fract(iTime))*2. - 1.);\n    \n    \/\/ The radial blur loop. Take a texture sample, move a little in the direction of\n    \/\/ the radial direction vector (dTuv) then take another, slightly less weighted,\n    \/\/ sample, add it to the total, then repeat the process until done.\n    for(float i=0.; i < SAMPLES; i++){\n    \n        uv -= dTuv;\n        col += texture(iChannel0, uv) * weight;\n        weight *= decay;\n        \n    }\n    \n    \/\/ Multiplying the final color with a spotlight centered on the focal point of the radial\n    \/\/ blur. It's a nice finishing touch... that Passion came up with. If it's a good idea,\n    \/\/ it didn't come from me. :)\n    col *= (1. - dot(tuv, tuv)*.75);\n    \n    \/\/ Smoothstepping the final color, just to bring it out a bit, then applying some \n    \/\/ loose gamma correction.\n    fragColor = sqrt(smoothstep(0., 1., col));\n    \n    \/\/ Bypassing the radial blur to show the raymarched scene on its own.\n    \/\/fragColor = sqrt(texture(iChannel0, fragCoord.xy \/ iResolution.xy));\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGRn","filepath":"\/media\/a\/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"\/media\/ap\/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ The scene itself. Not much commenting, since this is mainly about the radial blur,\n\/\/ plus a lot of it is rudimentary.\n\n#define FAR 20.\n\n\/\/ Hash.\nfloat hash( float n ){ return fract(cos(n)*45758.5453); }\n\n\n\/\/ Tri-Planar blending function. Based on an old Nvidia writeup:\n\/\/ GPU Gems 3 - Ryan Geiss: http:\/\/http.developer.nvidia.com\/GPUGems3\/gpugems3_ch01.html\nvec3 tpl( sampler2D t, in vec3 p, in vec3 n ){\n   \n    n = max(abs(n), 0.001);\n    n \/= (n.x + n.y + n.z );  \n\tp = (texture(t, p.yz)*n.x + texture(t, p.zx)*n.y + texture(t, p.xy)*n.z).xyz;\n    return p*p;\n}\n\n\/\/ A simple, cheap but visually effective sinusoid based lattice. The downside to building\n\/\/ a scene with transcendentals is the honing difficulty, but the logarithmic based\n\/\/ \"Logarithmmic Bisection\" tracing method counters that.\nfloat map(in vec3 p){\n   \n    \/\/ A few small bumps to put on the surface.\n    float bump = (dot(sin(p*24. - cos(p.yzx*36.)), vec3(.015)));\n    \n    \/\/ Perturbing the surface slightly, prior to construction.\n    p += sin(p*8. + 3.14159)*.1;\n    \n    \/\/ The main surface. A weird, molecular looking lattice.\n    float n = dot(sin(p*2.), cos(p.yzx*2.));\n    \n \t\/\/ Clamping the surface value, and adding the bumps.\n    \/\/return (clamp(0., -1.1, n) + 1.1)\/1.1 + bump;\n    return (min(n, 0.) + 1.1)\/1.1 + bump;\n    \n}\n\n \n\/\/ Ambient occlusion, for that self shadowed look.\n\/\/ XT95 came up with this particular version. Very nice.\n\/\/\n\/\/ Hemispherical SDF AO - https:\/\/www.shadertoy.com\/view\/4sdGWN\n\/\/ Alien Cocoons - https:\/\/www.shadertoy.com\/view\/MsdGz2\nfloat cao( in vec3 p, in vec3 n, float maxDist )\n{\n\tfloat ao = 0.0, l;\n\tconst float nbIte = 6.0;\n\tconst float falloff = 1.5;\n    for( float i=1.; i< nbIte+.5; i++ ){\n    \n        l = (i + hash(i))*.5\/nbIte*maxDist;\n        ao += (l - map( p + n*l ))\/ pow(1. + l, falloff);\n    }\n\t\n    return clamp( 1.-ao\/nbIte, 0., 1.);\n}\n\n\/\/ Tetrahedral normal, courtesy of IQ.\nvec3 nr(in vec3 p)\n{  \n    vec2 e = vec2(-1, 1)*.001;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\n\/\/ A trimmed down version of Nimitz's \"Log Bisecion\" method. Very effective on\n\/\/ difficult to hone in on things like weird, transcendental surfaces.\n\/\/ Worth studying, if you're not familiar with it.\n\/\/\n\/\/ Log-Bisection Tracing - Nimitz\n\/\/ https:\/\/www.shadertoy.com\/view\/4sSXzD\nfloat logBisectTrace( in vec3 ro, in vec3 rd){\n\n\n    float t = 0., told = 0., mid, dn;\n    float d = map(rd*t + ro);\n    float sgn = sign(d);\n\n    for (int i=0; i<64; i++){\n\n        \/\/ If the threshold is crossed with no detection, use the bisection method.\n        \/\/ Also, break for the usual reasons. Note that there's only one \"break\"\n        \/\/ statement in the loop. I heard GPUs like that... but who knows?\n        if (sign(d) != sgn || d < 0.001 || t > FAR) break;\n \n        told = t;\n        \n        \/\/ Branchless version of the following:  \n        \/\/ if(d>1.) t += d*.5; else t += log(abs(d) + 1.1)*.5;\n        t += step(d, 1.)*(log(abs(d) + 1.1)*.5 - d*.5) + d*.5;\n       \n        d = map(rd*t + ro);\n    }\n    \n    \/\/ If a threshold was crossed without a solution, use the bisection method.\n    if (sign(d) != sgn){\n    \n        \/\/ Based on suggestions from CeeJayDK, with some minor changes.\n\n        dn = sign(map(rd*told + ro));\n        \n        vec2 iv = vec2(told, t); \/\/ Near, Far\n\n        \/\/ 6 iterations seems to be more than enough, for most cases...\n        \/\/ but there's an early exit, so I've added a couple more.\n        for (int ii=0; ii<8; ii++){ \n            \/\/Evaluate midpoint\n            mid = dot(iv, vec2(.5));\n            float d = map(rd*mid + ro);\n            if (abs(d) < 0.001)break;\n            \/\/ Suggestion from movAX13h - Shadertoy is one of those rare\n            \/\/ sites with helpful commenters. :)\n            \/\/ Set mid to near or far, depending on which side we're on.\n            iv = mix(vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d*dn));\n        }\n\n        t = mid; \n        \n    }\n\n    return min(t, FAR);\n}\n\n\/\/ Shadows.\nfloat sha(in vec3 ro, in vec3 rd, in float start, in float end, in float k){\n\n    float shade = 1.0;\n    const int maxIterationsShad = 16; \n\n    float dist = start;\n    float stepDist = end\/float(maxIterationsShad);\n\n    for (int i=0; i<maxIterationsShad; i++){\n        float h = map(ro + rd*dist);\n        \/\/shade = min(shade, k*h\/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h\/dist));\n\n        dist += clamp(h, 0.02, 0.16);\n        \n        \/\/ There's some accuracy loss involved, but early exits from accumulative distance function can help.\n        if ((h)<0.001 || dist > end) break; \n    }\n    \n    return min(max(shade, 0.) + 0.1, 1.0); \n}\n\n\/\/ Grey scale.\nfloat gr(vec3 p){ return dot(p, vec3(0.299, 0.587, 0.114)); }\n\n\/\/ Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 db( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \/\/ Gradient vector, constructed with offset greyscale texture values.\n    vec3 g = vec3( gr(tpl(tx, p - e.xyy, n)), gr(tpl(tx, p - e.yxy, n)), gr(tpl(tx, p - e.yyx, n)));\n    \n    g = (g - gr(tpl(tx,  p , n)))\/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); \/\/ Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n\/\/ Camera path. Arranged to coincide with the frequency of the lattice.\nvec3 camPath(float t){\n  \n    return vec3(-sin(t), sin(t) + .75, t*2. + .5);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    \n\t\/\/ Screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*0.5)\/iResolution.y;\n\t\n\t\/\/ Camera Setup.\n\t\n    vec3 o = camPath(iTime); \/\/ Camera position, doubling as the ray origin.\n    vec3 lk = camPath(iTime + .1);  \/\/ \"Look At\" position.\n    vec3 l = o + vec3(1.5, 1., -0.5); \/\/ Light position, somewhere near the moving camera.\n\n\n    \/\/ Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159\/3.; \/\/ FOV - Field of view.\n    vec3 fwd = normalize(lk-o);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    vec3 up = cross(fwd, rgt);\n\n    \/\/ Unit direction ray.\n    vec3 r = normalize(fwd + FOV*(u.x*rgt + u.y*up));\n    \/\/ Lens distortion.\n    \/\/vec3 r = fwd + FOV*(u.x*rgt + u.y*up);\n    \/\/r = normalize(vec3(r.xy, (r.z - length(r.xy)*.5)));\n    \n    \n    \/\/ Rotate the camera using Fabrice's simplified rotation matrix.\n    u = sin(vec2(1.57, 0) - iTime\/2.); \/\/ Reusing \"u.\"\n    mat2 a = mat2(u, -u.y, u.x);\n    r.xz = a * r.xz;\n    r.xy = a * r.xy;\n\n    \/\/ Nimitz's fancy surface intersection formula.\n    float t = logBisectTrace(o, r);\n\n    \/\/ Initialize the scene color to zero.\n    vec3 col = vec3(0);\n    \n    \/\/ If the surface is hit, light it up.\n    if(t<FAR){\n    \n        \/\/ Position and normal.\n        vec3 p = o + r*t, n = nr(p);\n        \n        \/\/ Texture bump the normal.\n        float sz = 1.\/1.;\n        n = db(iChannel0, p*sz, n, .03\/(1. + t\/FAR));\n\n\n        l -= p; \/\/ Light to surface vector. Ie: Light direction vector.\n        float d = max(length(l), 0.001); \/\/ Light to surface distance.\n        l \/= d; \/\/ Normalizing the light direction vector.\n        \n        \/\/ Ambient occlusion and shadowing.\n        float ao =  cao(p, n, 4.);\n        float sh = sha(p, l, 0.04, d, 4.);\n        \n        \/\/ Diffuse, specular, fresnel. Only the latter is being used here.\n        \/\/float di = max(dot(l, n), 0.);\n        \/\/float sp = pow(max( dot( reflect(r, n), l ), 0.0 ), 8.); \/\/ Specular term.\n        float fr = clamp(1.0 + dot(r, n), 0.0, 1.0); \/\/ Fresnel reflection term.\n        \n        \/\/ Texturing the surface with some tri-planar mapping..\n        vec3 tx = tpl( iChannel0, p*sz, n);\n\n\t\t\/\/ Very simple coloring. Fresnel and texture combination. Radial blurs like simplicity. :)\n        col = tx*fr*4.;\n        col *= 1.\/(1. + d*.125 + d*d*.05)*ao*sh;\n\n        \n    }\n\n    vec3 bg = vec3(1, .56, .3);\n    col = mix(clamp(col, 0., 1.), bg, smoothstep(0., FAR-2., t));\n    fragColor = vec4(col, 1.);\n    \n    \n}","name":"Buf A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"MdV3Wz","date":"1454184710","viewed":9764,"name":"Fractal Explorer Multi-res.","username":"Dave_Hoskins","description":"Mandalay fractal. USE WASD\/CURSOR KEYS AND MOUSE.\nThanks to 'rebb' for the fractal formula reference in Fractal city_242.\nUses multi-resolution rendering for speed up.","likes":156,"published":3,"flags":112,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"llj3z3","filepath":"https:\/\/soundcloud.com\/nitenichiryu\/dubtechnoblogshowmixlr-2016-01-24","previewfilepath":"https:\/\/soundcloud.com\/nitenichiryu\/dubtechnoblogshowmixlr-2016-01-24","type":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Fractal Explorer Multi-res. January 2016\n\/\/ by David Hoskins\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/ https:\/\/www.shadertoy.com\/view\/MdV3Wz\n\n\/\/ Mandalay fractal. Thanks to 'rebb' for the fractal fomula reference in Fractal city_242.\n\/\/ Here:- https:\/\/www.shadertoy.com\/view\/MsK3DR\n\n\/\/ Enable antialiasing...\n#define ANTIALIAS\n\n\/\/ * * CONTROLS * *\n\/\/ WASD or CURSOR keys\n\/\/ Mouse drag to turn.\n\/\/ SHIFT or SPACE for 2X speed\n\n\/\/--------------------------------------------------------------------------\n#define SUN_COLOUR vec3(1., .95, .9)\n#define FOG_COLOUR vec3(.12, 0.13, 0.14)\n#define HASHSCALE .1031\n#define TAU 6.28318530718\n\nvec2 fcoord;\n\nvec2 camStore = vec2(4.0,  0.0);\nvec2 rotationStore\t= vec2(1.,  0.);\nvec3 sunLight  = normalize(vec3(  0.4, 0.7,  0.4 ));\n\n\n\/\/--------------------------------------------------------------------------\nvec3 loadValue3( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) \/ iChannelResolution[0].xy, -100.0 ).xyz;\n}\nvec2 loadValue2( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) \/ iChannelResolution[0].xy, -100.0 ).xy;\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ From https:\/\/www.shadertoy.com\/view\/4djSRW\n\n\/\/----------------------------------------------------------------------------------------\nfloat Noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel2, (uv+ 0.5)\/256.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\nvec3 GetSky(vec3 pos)\n{\n    pos *= 2.;\n    pos -= iTime*.08;\n\tfloat t = Noise(pos);\n    t += Noise(pos * 2.1) * .5;\n    t += Noise(pos * 4.3) * .25;\n    t += Noise(pos * 7.9) * .125;\n\treturn (t * 0.7+.6) *FOG_COLOUR *.6;\n}\n\/\/----------------------------------------------------------------------------------------\n\/\/--------------------------------------------------------------------------\nfloat Shadow( in vec3 ro, in vec3 rd)\n{\n\tfloat res = 1.0;\n    float t = 0.06;\n\tfloat h;\n\t\n    for (int i = 0; i < 5; i++)\n\t{\n\t\th = Map( ro + rd*t );\n\t\tres = min(4.5*h \/ t, res);\n\t\tt += h+.2;\n\t}\n    return max(res, 0.0);\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 DoLighting(in vec3 mat, in vec3 pos, in vec3 normal, in vec3 eyeDir, in float d, in float sh)\n{\n    vec3 sunLight  = normalize( vec3(  0.4, 0.4,  0.3 ) );\n\/\/\tsh = Shadow(pos,  sunLight);\n    \/\/ Light surface with 'sun'...\n\tvec3 col = mat * SUN_COLOUR*(max(dot(sunLight,normal), 0.0)) *sh;\n    col += mat *(max(dot(-sunLight,normal), 0.0))*.5;\n    \n    normal = reflect(eyeDir, normal); \/\/ Specular...\n    col += pow(max(dot(sunLight, normal), 0.0), 10.0)  * SUN_COLOUR * .4 *sh;\n    \/\/ Abmient..\n    col += mat * .2 * max(normal.y, 0.3)+.011;\n    \n    \n\treturn col;\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 GetNormal(vec3 p, float sphereR)\n{\n\tvec2 eps = vec2(sphereR, 0.0);\n\treturn normalize( vec3(\n           Map(p+eps.xyy) - Map(p-eps.xyy),\n           Map(p+eps.yxy) - Map(p-eps.yxy),\n           Map(p+eps.yyx) - Map(p-eps.yyx) ) );\n}\n\n\n\/\/--------------------------------------------------------------------------\nfloat binarySubdivision(in vec3 rO, in vec3 rD, vec2 t)\n{\n\t\/\/ Home in on the surface by dividing by two and split...\n    float halfwayT;\n\tfor (int n = 0; n < 4; n++)\n\t{\n\t\thalfwayT = (t.x + t.y) * .5;\n        (Map(rO + halfwayT*rD) < 0.002) ? t.x = halfwayT:t.y = halfwayT;\n\t}\n\treturn halfwayT;\n}\n\n\/\/--------------------------------------------------------------------------\nfloat Scene(in vec3 rO, in vec3 rD, in float t)\n{\n\t\n\tvec3 p = vec3(0.0);\n    \/\/t -= hash13(rO+rD+t)*.1;\n    float oldT = t;\n\n\tfor( int j=0; j < 60; j++ )\n\t{\n\t\tif (t > 7.0) break;\n\t\tp = rO + t*rD;\n\t\tfloat de = Map(p);\n\t\tif(abs(de) < 0.002) break;\n        oldT = t;\n\t\tt +=  de;\n\t}\n    if (t < 7.0) t = binarySubdivision(rO, rD, vec2(t, oldT));\n\treturn t;\n}\n\nfloat calcOcc( in vec3 pos, in vec3 nor)\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for(float h= 0.02; h < .05; h+= .01)\n    {\n\t\tvec3 opos = pos + h*nor;\n        float d = Map(opos);\n        occ += (h-d)*sca;\n        \/\/sca *= 0.5;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\n\n\/\/--------------------------------------------------------------------------\nvec3 PostEffects(vec3 rgb, vec2 xy)\n{\n\t\/\/ Gamma first...\n\n\n    rgb = rgb*rgb * (3.0-2.0*rgb);\n   \trgb = pow(rgb, vec3(0.45));\n    rgb  = rgb * 2.;\n\n\t\/\/ Vignette...\n    rgb *= .7+0.5*pow(250.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.3);\t\n\n\n\treturn clamp(rgb, 0.0, 1.0);\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 TexCube( sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec3 x = texture( sam, p.yz ).xzy;\n\tvec3 y = texture( sam, p.zx ).xyz;\n\tvec3 z = texture( sam, p.xy ).yzx;\n\treturn (x*abs(n.x) + y*abs(n.y) + z*abs(n.z))\/(abs(n.x)+abs(n.y)+abs(n.z));\n}\n\n\/\/----------------------------------------------------------------------------------------\nvec2 rot2D(inout vec2 p, float a)\n{\n    return cos(a)*p - sin(a) * vec2(p.y, -p.x);\n}\n\n\/\/--------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n\n\tfloat m = (iMouse.x\/iResolution.x)*20.0;\n\tfloat gTime = ((iTime+26.)*.2+m);\n    vec2 xy = fragCoord.xy \/ iResolution.xy;\n\tvec2 uv = (-1. + 2.0 * xy) * vec2(iResolution.x\/iResolution.y,1.0);\n    \n    vec3 cameraPos = texture( iChannel0, vec2(.5,.5)\/iResolution.xy, -100.0 ).xyz;\n    vec2 camRot = texture( iChannel0, vec2(1.5,.5)\/iResolution.xy, -100.0 ).xy;\n    camRot*= TAU;\n   \n\t\/\/ Recorded distance so far..\n    float recDis = texture( iChannel1, xy*.5, -100.0 ).x;\n\n    vec3 col = vec3(.0);\n    vec3 sky = vec3(-1);\n    \n    \n#ifdef ANTIALIAS\n    for (int y = 0; y < 2; y++)\n    {\n    \tfor (int x = 0; x < 2; x++)\n        {\n            vec3 dir = normalize( vec3(uv+vec2(x,y)\/iResolution.xy, sqrt(max(1.2 - dot(uv.xy, uv.xy)*.1, 0.))));\n#else\n\t\t\tvec3 dir = normalize( vec3(uv, sqrt(max(1.2 - dot(uv.xy, uv.xy)*.1, 0.))));\n                                       \n\n#endif\n            dir =  normalize(dir);\n\n            float roll = .05 * sin(iTime*.3);\n            dir.xy = dir.xy*cos(roll) + sin(roll)*vec2(1,-1)*dir.yx;\n            dir.zy = dir.zy*cos(camRot.x) + sin(camRot.x)*vec2(1,-1)*dir.yz;\n            dir.xz = dir.xz*cos(camRot.y) + sin(camRot.y)*vec2(1,-1)*dir.zx;\n\n            float dis = Scene(cameraPos, dir, recDis);\n            if (sky.x < 0.0)  sky = GetSky(dir);\n            if (dis < 7.0)\n            {\n                vec3 pos = cameraPos + dir * dis;\n                \n                vec3 normal = GetNormal(pos, 0.002);\n\n                float sha = Shadow(pos, sunLight);\n                float occ = calcOcc(pos, sunLight);\n\n                vec3 alb =\tX.xyz*X.w*orbitTrap.x +\n\t\t\t\t\t\t\tY.xyz*Y.w*orbitTrap.y +\n\t\t\t\t\t\t\tZ.xyz*Z.w*orbitTrap.z +\n\t\t\t\t\t\t\tR.xyz*R.w*orbitTrap.w;\n\t\t\t\t\/\/alb *= occ;\n                vec3 mat = DoLighting(alb*.2, pos, normal, dir, dis, sha)*occ;\n                mat = mix(sky,mat, clamp(exp(-dis*dis*.05)+.03,0.0, 1.0));\n                col += mat;\n            }else\n            {\n                col += sky+pow(max(dot(sunLight, dir), 0.0), 20.0)  * SUN_COLOUR * .07;\n\n            }\n            col += pow(max(dot(sunLight, dir), 0.0), 2.0)  * SUN_COLOUR * .08;\n#ifdef ANTIALIAS\n        }\n    }\n        col\/=4.;\n#endif\n    \n\t   \n\tcol = PostEffects(col, xy) * smoothstep(.0, 2.0, iTime);\t\n\t\n    \/\/fragColour=vec4(col+vec3(recDis\/16., 0, 0), 1.);\n    \/\/fragColour=vec4(dis\/16.);\n\tfragColour=vec4(col, 1.);\n}\n\n\/\/--------------------------------------------------------------------------","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"\/presets\/tex00.jpg","previewfilepath":"\/presets\/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ Adaption of Ben Quantock, WASD 2016 ( https:\/\/www.shadertoy.com\/view\/ldyGzW )\n\/\/ With speed limits and frame delta added by Dave Hoskins.\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define INVERT_Y 0\n\n#define ACCEL .01\n#define DECAY  .85 \/\/ how much velocity is preserved per frame (proportionally)\n#define MAX_SPEED  .01\n\n#if INVERT_Y\nconst float yMul = 1.0;\n#else\nconst float yMul = -1.0;\n#endif\nconst int KEY_W\t\t= 87;\nconst int KEY_A\t\t= 65;\nconst int KEY_S\t\t= 83;\nconst int KEY_D\t\t= 68;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst int KEY_SPACE\t= 32;\nconst int KEY_SHIFT\t= 16;\n\n\/\/----------------------------------------------------------------------------------------\nfloat ReadKey( int key )\n{\n   \treturn step(.5,texture( iChannel3, vec2( (float(key)+.5)\/256.0, .25)).x);\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/----------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,0.0,1.0);\n\n    if ( int(fragCoord.y) == 0 )\n    {\n        if ( int(fragCoord.x) == 0 )\n        {\n            vec3 camPos = texture( iChannel0, vec2(.5,.5)\/iResolution.xy, -100.0 ).xyz;\n            vec3 camVel = texture( iChannel0, vec2(3.5,.5)\/iResolution.xy, -100.0 ).xyz;\n            float time  = (iTime-texture( iChannel0, vec2(4.5,.5)\/iResolution.xy, -100.0 ).x)*30.0;\n             if (iFrame == 0)\n\t\t    {\n        \t\tfragColor = vec4(3.0, 4.2,1.5, 1.);\n            }else\n            {\n                camVel *= time*(1.0+ReadKey(KEY_SHIFT)+ReadKey(KEY_SPACE));\n                vec3 oldCam = camPos;\n                camPos.x += camVel.x;if (Map(camPos) < 0.002) camPos.x = oldCam.x;\n                camPos.y += camVel.y;if (Map(camPos) < 0.002) camPos.y = oldCam.y;\n                camPos.z += camVel.z;if (Map(camPos) < 0.002) camPos.z = oldCam.z;\n                \n            \tfragColor = vec4(camPos, 0);\n            }\n        }\n        else if ( int(fragCoord.x) <= 2 )\n        {\n            vec4 baseCamRot = texture( iChannel0, vec2(2.5,.5)\/iResolution.xy, -100.0 );\n            vec4 camRot = texture( iChannel0, vec2(1.5,.5)\/iResolution.xy, -100.0 );\n\n            vec2 mouseRot = (iMouse.yx\/iResolution.yx-.5)*vec2(.5*yMul,1.);\n            \n            camRot.w = iMouse.z;\n            \n            bool press = (camRot.w > .0);\n            bool lastPress = (baseCamRot.w > .0);\n            bool click = press && !lastPress;\n            if ( click )\n            {\n                baseCamRot.xy -= mouseRot;\n            }\n            \n            if ( press )\n            {\n                camRot.xy = baseCamRot.xy + mouseRot;\n            }\n            else\n            {\n                \/\/update the base pos\n                baseCamRot = camRot;\n            }\n\n            baseCamRot.w = camRot.w;\n            \n            \/\/ store\n            if ( int(fragCoord.x) == 1 )\n            {\n\t\t\t\tif (iFrame == 0)\n\t\t    \t{\n        \t\t\tfragColor = vec4(.0, .75, .0,0);\n            \t}else\n            \tfragColor = camRot;\n            }\n            else\n            {\n            \tfragColor = baseCamRot;\n            }\n        }\n        else if ( int(fragCoord.x) == 3 )\n        {\n            vec4 camVel = texture( iChannel0, vec2(3.5,.5)\/iResolution.xy, -100.0 );\n            vec4 camRot = texture( iChannel0, vec2(1.5,.5)\/iResolution.xy, -100.0 )*6.28318530718;\n            \n            vec3 forward = vec3(0,0,ACCEL);\n            vec3 right \t = vec3(ACCEL,0,0);\n\n            forward.zy = forward.zy*cos(camRot.x) + sin(camRot.x)*vec2(1,-1)*forward.yz;\n            right.zy = right.zy*cos(camRot.x) + sin(camRot.x)*vec2(1,-1)*right.yz;\n                \n            forward.xz = forward.xz*cos(camRot.y) + sin(camRot.y)*vec2(1,-1)*forward.zx;\n\t\t    right.xz = right.xz*cos(camRot.y) + sin(camRot.y)*vec2(1,-1)*right.zx;\n            \n            camVel.xyz += (ReadKey(KEY_W)-ReadKey(KEY_S)+ReadKey(KEY_UP)-ReadKey(KEY_DOWN)) * forward;\n            camVel.xyz += (ReadKey(KEY_D)-ReadKey(KEY_A)+ReadKey(KEY_RIGHT)-ReadKey(KEY_LEFT)) * right;\n            \n\n            camVel *= DECAY; \/\/ exponential decay\n            float lim = length(camVel);\n            if (lim > MAX_SPEED)\n            {\n                camVel = normalize(camVel) * MAX_SPEED;\n            }\n        \n            \n            fragColor = camVel;\n        }\n\t\telse if ( int(fragCoord.x) == 4 )\n        {\n\t\t\tfragColor = vec4(iTime);\n\t    }\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\/\/ Fractal Explorer Multi-res. January 2016\n\/\/ by David Hoskins\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/ https:\/\/www.shadertoy.com\/view\/MdV3Wz\n\n\/\/ Mandalay fractal. Thanks to 'rebb' for the fractal fomula reference in Fractal city_242.\n\/\/ Here:- https:\/\/www.shadertoy.com\/view\/MsK3DR\n\n\n\/\/--------------------------------------------------------------------------\n#define TAU 6.28318530718\n\n\/\/--------------------------------------------------------------------------\nvec3 loadValue3( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) \/ iChannelResolution[0].xy, -100.0 ).xyz;\n}\nvec2 loadValue2( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) \/ iChannelResolution[0].xy, -100.0 ).xy;\n}\n\n\/\/----------------------------------------------------------------------------------------\n\n\/\/--------------------------------------------------------------------------\n\nfloat SphereRadius(in float t)\n{\n    t = t * .001*(500.\/iResolution.y);\n    return (t*2.5);\n}\n\/\/--------------------------------------------------------------------------\nfloat binarySubdivision(in vec3 rO, in vec3 rD, vec2 t)\n{\n\t\/\/ Home in on the surface by dividing by two and split...\n    float halfwayT;\n\tfor (int n = 0; n < 4; n++)\n\t{\n\t\thalfwayT = (t.x + t.y) * .5;\n        (Map(rO + halfwayT*rD) < SphereRadius(t.x)) ? t.x = halfwayT:t.y = halfwayT;\n\t}\n\treturn halfwayT;\n}\n\/\/--------------------------------------------------------------------------\nfloat Scene(in vec3 rO, in vec3 rD, vec2 uv)\n{\n\n\tfloat t = hash12(uv)*.05;\n    float oldT = t;\n\n\t\n\tvec3 p = vec3(0.0);\n\n\tfor( int j=0; j < 80; j++ )\n\t{\n\t\tif (t > 7.0) break;\n\t\tp = rO + t*rD;\n\t\t\n\t\tfloat de = Map(p);\n\t\tif(abs(de) < .1) break;\n        \n       oldT = t;\n\t\tt +=  de;\n\t}\n    \/\/if (t < 7.0) t = binarySubdivision(rO, rD, vec2(t, oldT));\n\n\treturn max(t, 0.01);\n}\n\n\/\/--------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n\tfloat m = (iMouse.x\/iResolution.x)*20.0;\n\tfloat gTime = ((iTime+26.)*.2+m);\n    \n    \/\/ Only use a quarter of the screen for first pass...\n    vec2 xy = fragCoord.xy \/ iResolution.xy;\n    if(xy.x > .5 || xy.y > .5) discard;\n    xy *= 2.0;\n\tvec2 uv = (-1. + 2.0 * xy) * vec2(iResolution.x\/iResolution.y,1.0);\n    \n   \n    vec3 cameraPos = texture( iChannel0, vec2(.5,.5)\/iResolution.xy, -100.0 ).xyz;\n    vec2 camRot = texture( iChannel0, vec2(1.5,.5)\/iResolution.xy, -100.0 ).xy;\n\n    camRot*= TAU;\n\n\tvec3 dir = normalize( vec3(uv, sqrt(max(1.2 - dot(uv.xy, uv.xy)*.1, 0.))));\n    dir =  normalize(dir);\n\n    float roll = .05 * sin(iTime*.3);\n    dir.xy = dir.xy*cos(roll) + sin(roll)*vec2(1,-1)*dir.yx;\n    dir.zy = dir.zy*cos(camRot.x) + sin(camRot.x)*vec2(1,-1)*dir.yz;\n    dir.xz = dir.xz*cos(camRot.y) + sin(camRot.y)*vec2(1,-1)*dir.zx;\n  \n    float dis = Scene(cameraPos, dir, fragCoord);\n\t\n\tfragColour = vec4(dis);\n}\n\n\/\/--------------------------------------------------------------------------","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nfloat Scale = 4.;\nfloat MinRad2 = 0.25;\n\nfloat sr = 4.0;\nvec3 fo =vec3 (0.7,.9528,.9);\nvec3 gh = vec3 (.8,.7,0.5638);\nvec3 gw = vec3 (.3, 0.5 ,.2);\nvec4 X = vec4( .1,0.5,0.1,.3);\nvec4 Y = vec4(.1, 0.8, .1, .1);\nvec4 Z = vec4(.2,0.2,.2,.45902);\nvec4 R = vec4(0.19,.1,.1,.2);\nvec4 orbitTrap = vec4(40000.0);\n\/\/--------------------------------------------------------------------------\nfloat DBFold(vec3 p, float fo, float g, float w){\n    if(p.z>p.y) p.yz=p.zy;\n    float vx=p.x-2.*fo;\n    float vy=p.y-4.*fo;\n    float v=max(abs(vx+fo)-fo,vy);\n    float v1=max(vx-g,p.y-w);\n    v=min(v,v1);\n    v1=max(v1,-abs(p.x));\n    return min(v,p.x);\n}\n\/\/the coordinates are pushed\/pulled in parallel\n\n\n\/\/the coordinates are pushed\/pulled in parallel\nvec3 DBFoldParallel(vec3 p, vec3 fo, vec3 g, vec3 w){\n\tvec3 p1=p;\n\tp.x=DBFold(p1,fo.x,g.x,w.x);\n\tp.y=DBFold(p1.yzx,fo.y,g.y,w.y);\n\tp.z=DBFold(p1.zxy,fo.z,g.z,w.z);\n\treturn p;\n}\n\/\/serial version\nvec3 DBFoldSerial(vec3 p, vec3 fo, vec3 g,vec3 w){\n\tp.x=DBFold(p,fo.x,g.x,w.x);\n\tp.y=DBFold(p.yzx,fo.y,g.y,w.y);\n\tp.z=DBFold(p.zxy,fo.z,g.z,w.z);\n\treturn p;\n}\nfloat Map(vec3 p)\n{\n\tvec4 JC=vec4(p,1.);\n\tfloat r2=dot(p,p);\n\tfloat dd = 1.;\n\tfor(int i = 0; i< 6; i++){\n\t\t\n\t\tp = p - clamp(p.xyz, -1.0, 1.0) * 2.0;  \/\/ mandelbox's box fold\n\n\t\t\/\/Apply pull transformation\n\t\tvec3 signs=sign(p);\/\/Save \tthe original signs\n\t\tp=abs(p);\n\t\tp=DBFoldParallel(p,fo,gh,gw);\n\t\t\n\t\tp*=signs;\/\/resore signs: this way the mandelbrot set won't extend in negative directions\n\t\t\n\t\t\/\/Sphere fold\n\t\tr2=dot(p,p);\n\t\tfloat  t = clamp(1.\/r2, 1., 1.\/MinRad2);\n\t\tp*=t; dd*=t;\n\t\t\n\t\t\/\/Scale and shift\n\t\tp=p*Scale+JC.xyz; dd=dd*Scale+JC.w;\n\t\tp=vec3(1.0,1.0,.92)*p;\n\n\t\tr2=dot(p,p);\n\t\torbitTrap = min(orbitTrap, abs(vec4(p.x,p.y,p.z,r2)));\t\n\t}\n\tdd=abs(dd);\n#if 1\n\treturn (sqrt(r2)-sr)\/dd;\/\/bounding volume is a sphere\n#else\n\tp=abs(p); return (max(p.x,max(p.y,p.z))-sr)\/dd;\/\/bounding volume is a cube\n#endif\n}","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"4dKGWm","date":"1454853751","viewed":31968,"name":"Elephant","username":"iq","description":"Signed Distance Field raymarching. Procedural elephants, split it in layers to prevent the compiler from crashing. The art is composed to camera. Video: [url]https:\/\/www.youtube.com\/watch?v=vga8FZzv5GE[\/url]","likes":154,"published":3,"flags":32,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"\/media\/a\/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"\/media\/ap\/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"\/media\/a\/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"\/media\/ap\/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"\/media\/a\/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"\/media\/ap\/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Copyright Inigo Quilez, 2016 - https:\/\/iquilezles.org\/\n\/\/ I am the sole copyright owner of this Work.\n\/\/ You cannot host, display, distribute or share this Work in any form,\n\/\/ including physical and digital. You cannot use this Work in any\n\/\/ commercial or non-commercial product, website or project. You cannot\n\/\/ sell this Work and you cannot mint an NFTs of it.\n\/\/ I share this Work for educational purposes, and you can link to it,\n\/\/ through an URL, proper attribution and unmodified screenshot, as part\n\/\/ of your educational material. If these conditions are too restrictive\n\/\/ please contact me and we'll definitely work it out.\n\nfloat leg( in vec3 p, in vec3 pa, in vec3 pb, in vec3 pc, float m, float h )\n{\n    vec2 b = sdSegment( p, pa, pb );\n\n    float tr = 0.35 - 0.16*smoothstep(0.0,1.0,b.y);\n    float d3 = b.x - tr;\n\n    b = sdSegment( p, pb, pc );\n    tr = 0.18;\n    d3 = smin( d3, b.x - tr, 0.1 );\n\n    \/\/ paw        \n    vec3 ww = normalize( mix( normalize(pc-pb), vec3(0.0,1.0,0.0), h) );\n    mat3 pr = base( ww );\n    vec3 fc = pr*((p-pc))-vec3(0.02,0.0,0.0)*(-1.0+2.0*h);\n    float d4 = sdEllipsoid( fc, vec3(0.0), vec3(0.2,0.15,0.2) );\n\n    d3 = smin( d3, d4, 0.1 );\n\n    \/\/ nails\n    float d6 = sdEllipsoid( fc, vec3(0.14,-0.06,0.0)*(-1.0+2.0*h), vec3(0.1,0.16,0.1));\n    d6 = min( d6, sdEllipsoid( vec3(fc.xy,abs(fc.z)), vec3(0.13*(-1.0+2.0*h),-0.08*(-1.0+2.0*h),0.13), vec3(0.09,0.14,0.1)) );\n    d3 = smin( d3, d6, 0.001 );\n\treturn d3;\n}\n\nvec2 mapElephant( vec3 p, out vec3 matInfo )\n{\n    matInfo = vec3(0.0);\n    \n    p.x -= -0.5;\n\tp.y -= 2.4;\n    \n    vec3 ph = p;\n    float cc = 0.995;\n    float ss = 0.0998745;\n    ph.yz = mat2(cc,-ss,ss,cc)*ph.yz;\n    ph.xy = mat2(cc,-ss,ss,cc)*ph.xy;\n    \n    \/\/ head\n    float d1 = sdEllipsoid( ph, vec3(0.0,0.05,0.0), vec3(0.45,0.5,0.3) );\n    d1 = smin( d1, sdEllipsoid( ph, vec3(-0.3,0.15,0.0), vec3(0.2,0.2,0.2) ), 0.1 );\n\n    \/\/ nose\n    vec2 kk;\n    vec2 b1 = sdBezier( vec3(-0.15,-0.05,0.0), vec3(-0.7,0.0,0.0), vec3(-0.7,-0.8,0.0), ph, kk );\n    float tr1 = 0.30 - 0.17*smoothstep(0.0,1.0,b1.y);\n    vec2  b2 = sdBezier( vec3(-0.7,-0.8,0.0), vec3(-0.7,-1.5,0.0), vec3(-0.4,-1.6,0.2), ph, kk );\n    float tr2 = 0.30 - 0.17 - 0.05*smoothstep(0.0,1.0,b2.y);\n    float bd1 = b1.x-tr1;\n    float bd2 = b2.x-tr2;\n    float nl = b1.y*0.5;\n    float bd = bd1;\n    if( bd2<bd1 )\n    {\n        nl = 0.5 + 0.5*b2.y;\n        bd = bd2;\n    }\n    matInfo.x = clamp(nl * (1.0-smoothstep(0.0,0.2,bd)),0.0,1.0);\n    float d2 = bd;\n    float xx = nl*120.0;\n    float ff = sin(xx + sin(xx + sin(xx + sin(xx))));\n    \/\/ff *= smoothstep(0.0,0.01,kk.y);\n    d2 += 0.003*ff*(1.0-nl)*(1.0-nl)*smoothstep(0.0,0.1,nl);\n\n    d2 -= (0.05 - 0.05*(1.0-pow(textureLod( iChannel0, vec2(1.0*nl,p.z*0.12), 0.0 ).x,1.0)))*nl*(1.0-nl)*0.5;\n    \n    float d = smin(d1,d2,0.2);\n\n    \/\/ teeth\n    vec3 q = vec3( p.xy, abs(p.z) );\n    vec3 qh = vec3( ph.xy, abs(ph.z) );\n    {\n    vec2 s1 = sdSegment( qh, vec3(-0.4,-0.1,0.1), vec3(-0.5,-0.4,0.28) );\n    float d3 = s1.x - 0.18*(1.0 - 0.3*smoothstep(0.0,1.0,s1.y));\n    d = smin( d, d3, 0.1 );\n    }\n    \n    \/\/ eyes\n    {\n    vec2 s1 = sdSegment( qh, vec3(-0.2,0.2,0.11), vec3(-0.3,-0.0,0.26) );\n    float d3 = s1.x - 0.19*(1.0 - 0.3*smoothstep(0.0,1.0,s1.y));\n    d = smin( d, d3, 0.03 );\n\n    float st = length(qh.xy-vec2(-0.31,-0.02));\n    \/\/d += 0.005*sin(250.0*st)*exp(-110.0*st*st );\n    d += 0.0015*sin(250.0*st)*(1.0-smoothstep(0.0,0.2,st));\n\n        \n    mat3 rot = mat3(0.8,-0.6,0.0,\n                    0.6, 0.8,0.0,\n                    0.0, 0.0,1.0 );\n    float d4 = sdEllipsoid( rot*(qh-vec3(-0.31,-0.02,0.34)), vec3(0.0), vec3(0.1,0.08,0.07)*0.7 );\n\td = smax(d, -d4, 0.02 );\n    }\n   \n\n    \/\/ body\n    {\n    float co = cos(0.4);\n    float si = sin(0.4);\n    vec3 w = p;\n    w.xy = mat2(co,si,-si,co)*w.xy;\n\n    float d4 = sdEllipsoid( w, vec3(0.6,0.3,0.0), vec3(0.6,0.6,0.6) );\n\td = smin(d, d4, 0.1 );\n\n    d4 = sdEllipsoid( w, vec3(1.8,0.3,0.0), vec3(1.2,0.9,0.7) );\n\td = smin(d, d4, 0.2 );\n\n    d4 = sdEllipsoid( w, vec3(2.1,0.55,0.0), vec3(1.0,0.9,0.6) );\n\td = smin(d, d4, 0.1 );\n\n    d4 = sdEllipsoid( w, vec3(2.0,0.8,0.0), vec3(0.7,0.6,0.8) );\n\td = smin(d, d4, 0.1 );\n    }\n\n    \/\/ back-left leg\n    {\n    float d3 = leg( q, vec3(2.6,-0.5,0.3), vec3(2.65,-1.45,0.3), vec3(2.6,-2.1,0.25), 1.0, 0.0 );\n    d = smin(d,d3,0.1);\n    }\n    \n\t\/\/ tail\n    #if 0\n    {\n    vec2 b = sdBezier( vec3(2.8,0.2,0.0), vec3(3.4,-0.6,0.0), vec3(3.1,-1.6,0.0), p, kk );\n    float tr = 0.10 - 0.07*b.y;\n    float d2 = b.x - tr;\n    d = smin( d, d2, 0.05 );\n    }\n    #endif\n        \n    \/\/ front-left leg\n    #if 0\n    {\n    float d3 = leg( q, vec3(0.8,-0.4,0.3), vec3(0.5,-1.55,0.3), vec3(0.5,-2.1,0.3), 1.0, 0.0 );\n    d = smin(d,d3,0.15);\n    }\n    #else\n    {\n    float d3 = leg( p, vec3(0.8,-0.4,0.3), vec3(0.7,-1.55,0.3), vec3(0.8,-2.1,0.3), 1.0, 0.0 );\n    d = smin(d,d3,0.15);\n    d3 = leg( p, vec3(0.8,-0.4,-0.3), vec3(0.4,-1.55,-0.3), vec3(0.4,-2.1,-0.3), 1.0, 0.0 );\n    d = smin(d,d3,0.15);\n    }\n    #endif\n    \n#if 1\n    \/\/ ear\n    float co = cos(0.5);\n    float si = sin(0.5);\n    vec3 w = qh;\n    w.xz = mat2(co,si,-si,co)*w.xz;\n    \n    vec2 ep = w.zy - vec2(0.5,0.4);\n    float aa = atan(ep.x,ep.y);\n    float al = length(ep);\n    w.x += 0.003*sin(24.0*aa)*smoothstep(0.0,0.5,dot(ep,ep));\n    w.x += 0.02*textureLod( iChannel1, vec2(al*0.02,0.5+0.05*sin(aa)), 0.0 ).x * smoothstep(0.0,0.3,dot(ep,ep));\n                      \n    float r = 0.02*sin( 24.0*atan(ep.x,ep.y))*clamp(-w.y*1000.0,0.0,1.0);\n    r += 0.01*sin(15.0*w.z);\n    \/\/ section        \n    float d4 = length(w.zy-vec2( 0.5,-0.2+0.03)) - 0.8 + r;    \n    float d5 = length(w.zy-vec2(-0.1, 0.6+0.03)) - 1.5 + r;    \n    float d6 = length(w.zy-vec2( 1.8, 0.1+0.03)) - 1.6 + r;    \n    d4 = smax( d4, d5, 0.1 );\n    d4 = smax( d4, d6, 0.1 );\n\n    float wi = 0.02 + 0.1*pow(clamp(1.0-0.7*w.z+0.3*w.y,0.0,1.0),2.0);\n    w.x += 0.05*cos(6.0*w.y);\n    \n    \/\/ cut it!\n    d4 = smax( d4, -w.x, 0.03 ); \n    d4 = smax( d4, w.x-wi, 0.03 ); \n    \n\tmatInfo.y = clamp(length(ep),0.0,1.0) * (1.0-smoothstep( -0.1, 0.05, d4 ));\n    \n    d = smin( d, d4, 0.3*max(qh.y,0.0)+0.0001 ); \/\/ trick -> positional smooth\n    \n    \/\/ conection hear\/head\n    vec2 s1 = sdBezier( vec3(-0.15,0.3,0.0), vec3(0.1,0.6,0.2), vec3(0.35,0.6,0.5), qh, kk );\n    float d3 = s1.x - 0.08*(1.0-0.95*s1.y*s1.y);\n    d = smin( d, d3, 0.05 );\n    \n#endif\n\n    d -= 0.002*textureLod( iChannel1, 0.5*p.yz, 0.0 ).x;\n    d -= 0.002*textureLod( iChannel1, 0.5*p.yx, 0.0 ).x;\n    d += 0.003;\n    d -= 0.005*textureLod( iChannel0, 0.5*p.yx, 0.0 ).x*(0.2 + 0.8*smoothstep( 0.8, 1.3, length(p-vec3(-0.5,0.0,0.0)) ));\n\n    \n    vec2 res = vec2(d,0.0);\n\t\/\/=====================\n    \/\/ teeth\n    vec2 b = sdBezier( vec3(-0.5,-0.4,0.28), vec3(-0.5,-0.7,0.32), vec3(-1.0,-0.8,0.45), qh, kk );\n    float tr = 0.10 - 0.08*b.y;\n    d2 = b.x - tr;\n    if( d2<res.x ) \n    {\n        res = vec2( d2, 1.0 );\n        matInfo.x = b.y;\n    }\n\t\/\/------------------\n    \/\/eyeball\n    mat3 rot = mat3(0.8,-0.6,0.0,\n                    0.6, 0.8,0.0,\n                    0.0, 0.0,1.0 );\n    d4 = sdEllipsoid( rot*(qh-vec3(-0.31,-0.02,0.33)), vec3(0.0), vec3(0.1,0.08,0.07)*0.7 );\n    if( d4<res.x ) res = vec2( d4, 2.0 );\n\n    return res;\n}\n\nfloat sleg( in vec3 p, in vec3 pa, in vec3 pb, in vec3 pc, float m, float h, float sc )\n{\n    vec2 b = sdSegment( p, pa, pb );\n\n    float tr = 0.35 - 0.15*smoothstep(0.0,1.0,b.y);\n    float d3 = b.x - tr*sc;\n\n    b = sdSegment( p, pb, pc );\n    tr = 0.18;\/\/ - 0.015*smoothstep(0.0,1.0,b.y);\n    d3 = smin( d3, b.x - tr*sc, 0.1 );\n\n    \/\/ paw        \n    vec3 ww = normalize( mix( normalize(pc-pb), vec3(0.0,1.0,0.0), h) );\n    mat3 pr = base( ww );\n    vec3 fc = pr*((p-pc))-vec3(0.02,0.0,0.0)*(-1.0+2.0*h);\n    float d4 = sdEllipsoid( fc, vec3(0.0), vec3(0.2,0.15,0.2) );\n\n    d3 = smin( d3, d4, 0.1 );\n\n    \/\/ nails\n    float d6 = sdEllipsoid( fc, vec3(0.14,-0.04,0.0)*(-1.0+2.0*h), vec3(0.1,0.16,0.1));\n    d6 = min( d6, sdEllipsoid( vec3(fc.xy,abs(fc.z)), vec3(0.13*(-1.0+2.0*h),0.04,0.13), vec3(0.09,0.14,0.1)) );\n    d3 = smin( d3, d6, 0.001 );\n\treturn d3;\n\n\treturn d3;\n}\n\nvec2 mapSmallElephant( vec3 p, out vec3 matInfo )\n{\n    matInfo = vec3(0.0);\n    vec3 oop = p;\n    const float sca = 2.0;\n    p.xz = mat2(0.8,0.6,-0.6,0.8)*p.xz;\n    p *= sca;\n    \n    p -= vec3(-1.1,2.4,-2.0);\n        \n    vec3 ph = p;\n    ph.yz = mat2(0.95,0.31225,-0.31225,0.95)*ph.yz;\n        \n    \/\/ head\n    float d1 = sdEllipsoid( ph, vec3(0.0,0.0,0.0), vec3(0.45,0.55,0.38) );\n\n    \/\/ nose\n    vec2 kk;\n    \n    vec2 b1 = sdBezier( vec3(-0.15,-0.05,0.0), vec3(-0.7,-0.2,-0.1), vec3(-0.7,-0.5,0.1), ph, kk );    \n    float tr1 = 0.30 - 0.17*smoothstep(0.0,1.0,b1.y);\n    vec2 b2 = sdBezier( vec3(-0.7,-0.5,0.1), vec3(-0.7,-0.8,0.3), vec3(-0.4,-0.8,0.8), ph, kk );\n    \n    float tr2 = 0.30 - 0.17 - 0.05*smoothstep(0.0,1.0,b2.y);\n    float bd1 = b1.x-tr1;\n    float bd2 = b2.x-tr2;\n    float nl = b1.y*0.5;\n    float bd = bd1;\n    if( bd2<bd1 )\n    {\n        nl = 0.5 + 0.5*b2.y;\n        bd = bd2;\n    }\n    \n    matInfo.x = clamp(nl * (1.0-smoothstep(0.0,0.2,bd)),0.0,1.0);\n            \n    float d2 = bd;\n    float xx = nl*120.0;\n    float ff = sin(xx + sin(xx + sin(xx + sin(xx))));\n    d2 += 0.005*ff*(1.0-nl)*(1.0-nl)*smoothstep(0.0,0.1,nl);\n\n    float d = smin(d1,d2,0.2);\n\n    vec3 qh = vec3( ph.xy, abs(ph.z) );\n\n    \/\/ eyes\n    {\n    vec2 s1 = sdSegment( qh, vec3(-0.2,0.2,0.11), vec3(-0.3,-0.0,0.23) );\n    float d3 = s1.x - 0.19*(1.0 - 0.3*smoothstep(0.0,1.0,s1.y));\n    d = smin( d, d3, 0.03 );\n    mat3 rot = mat3(0.8,-0.6,0.0,\n                    0.6, 0.8,0.0,\n                    0.0, 0.0,1.0 );\n    float d4 = sdEllipsoid( rot*(qh-vec3(-0.31,-0.02,0.34)), vec3(0.0), vec3(0.1,0.08,0.07)*0.7 );\n\td = smax(d, -d4, 0.04 );\n    }\n\n\n    vec3 q = vec3( p.xy, abs(p.z) );\n\n    \/\/ body\n    {\n    float co = cos(0.4);\n    float si = sin(0.4);\n    vec3 w = p;\n    w.xy = mat2(co,si,-si,co)*w.xy;\n        \n    float d4 = sdEllipsoid( w, vec3(0.6,0.3,0.0), vec3(0.6,0.6,0.6) );\n\td = smin(d, d4, 0.1 );\n\n    d4 = sdEllipsoid( w, vec3(1.8,0.3,0.0), vec3(1.2,0.9,0.7) );\n\td = smin(d, d4, 0.2 );\n    }\n\n    \/\/ back-left leg\n    {\n    float d3 = sleg( q, vec3(2.6,-0.6,0.3), vec3(2.65,-1.4,0.3), vec3(2.6,-2.0,0.25), 1.0, 0.0, 0.75 );\n    d = smin(d,d3,0.1);\n    }\n    \n\t\/\/ tail\n    #if 0\n    {\n    vec2 b = sdBezier( vec3(2.6,0.,0.0), vec3(3.4,-0.6,0.0), vec3(3.1,-1.6,0.0), p, kk );\n    float tr = 0.10 - 0.07*b.y;\n    float d2 = b.x - tr;\n    d = smin( d, d2, 0.05 );\n    }\n    #endif\n    \n    \/\/ front-left leg\n    {\n    float d3 = sleg( p, vec3(0.8,-0.4,0.2), vec3(0.6,-1.4,0.2), vec3(0.7,-1.9,0.2), 1.0, 0.0, 0.75 );\n    d = smin(d,d3,0.15);\n    d3 = sleg( p, vec3(0.8,-0.4,-0.2), vec3(0.3,-1.4,-0.2), vec3(0.2,-1.9,-0.2), 1.0, 0.0, 0.75 );\n    d = smin(d,d3,0.15);\n    }\n            \n#if 1\n    \/\/ ear\n    float co = cos(0.5);\n    float si = sin(0.5);\n    vec3 w = qh;\n    w.xz = mat2(co,si,-si,co)*w.xz;\n    \n    vec2 ep = w.zy - vec2(0.5,0.4);\n    float aa = atan(ep.x,ep.y);\n    float al = length(ep);\n    w.x += 0.003*sin( 24.0*aa)*smoothstep(0.0,0.5,dot(ep,ep));\n    w.x += 0.02*textureLod( iChannel1, vec2(al*0.02,0.15*aa\/3.1416), 0.0 ).x * smoothstep(0.0,0.3,dot(ep,ep));\n                      \n    float r = 0.02*sin( 24.0*atan(ep.x,ep.y))*clamp(-w.y*1000.0,0.0,1.0);\n    r += 0.01*sin(15.0*w.z);\n    \/\/ section        \n    float d4 = length(w.zy-vec2( 0.5,-0.2+0.03)) - 0.8 + r;    \n    float d5 = length(w.zy-vec2(-0.1, 0.6+0.03)) - 1.5 + r;    \n    float d6 = length(w.zy-vec2( 1.8, 0.1+0.03)) - 1.6 + r;    \n    d4 = smax( d4, d5, 0.1 );\n    d4 = smax( d4, d6, 0.1 );\n\n    float wi = 0.02 + 0.1*pow(clamp(1.0-0.7*w.z+0.3*w.y,0.0,1.0),2.0);\n    w.x += 0.05*cos(6.0*w.y);\n    \n    \/\/ cut it!\n    d4 = smax( d4, -w.x, 0.03 ); \n    d4 = smax( d4, w.x-wi, 0.03 ); \n    \n\tmatInfo.y = clamp(length(ep),0.0,1.0) * (1.0-smoothstep( -0.1, 0.05, d4 ));\n    \n    d = smin( d, d4, 0.3*max(qh.y+0.2,0.0)+0.0001 ); \/\/ trick -> positional smooth\n    \n    \/\/ conection hear\/head\n    vec2 s1 = sdBezier( vec3(-0.15,0.3,0.0), vec3(0.1,0.6,0.2), vec3(0.35,0.6,0.5), qh, kk );\n    float d3 = s1.x - 0.08*(1.0-0.95*s1.y*s1.y);\n    d = smin( d, d3, 0.05 );\n    \n#endif\n    \n    d -= 0.008*textureLod( iChannel1, 0.25*p.yz, 0.0 ).x;\n    d -= 0.008*textureLod( iChannel1, 0.25*p.yx, 0.0 ).x;\n    d += 0.010;\n    d -= 0.012*textureLod( iChannel0, 0.25*p.yx, 0.0 ).x*(0.3 + 0.7*smoothstep( 0.5, 1.0, length(p-vec3(-0.5,0.0,0.0)) ));\n    \n    vec2 res = vec2(d,0.0);\n\t\/\/=====================\n    \/\/eyeball\n    mat3 rot = mat3(0.8,-0.6,0.0,\n                    0.6, 0.8,0.0,\n                    0.0, 0.0,1.0 );\n    d4 = sdEllipsoid( rot*(qh-vec3(-0.31,-0.02,0.33)), vec3(0.0), vec3(0.1,0.08,0.07)*0.7 );\n    \n    if( d4<res.x ) res = vec2( d4, 2.0 );\n\n    res.x \/= sca;\n        \n    return res;\n}\n\nvec2 map( vec3 p, out vec3 matInfo )\n{\n    vec2 res = vec2(p.y+2.2-1.0);\n    \n    \/\/ bounding volume for big elephant\n    \/\/float b2 = length(p-vec3(0.5,1.7,0.0))-2.1;\n\t\/\/if( b2<res.x )    \n    {\n        res = mapElephant( p, matInfo );\n    }\n    \n    \/\/ bounding volume for small elephant\n    float bb = length(p-vec3(-0.4,0.5,-0.8))-1.3;\n    if( bb<res.x )\n    {\n        vec3 mi2;\n        vec2 tmp = mapSmallElephant( p, mi2 );\n        if( tmp.x<res.x ) { res=tmp; matInfo=mi2; }\n    }\n    \n    return res;\n}\n\nvec2 mapWithTerrain( vec3 p, out vec3 matInfo )\n{\n    vec2 res = map(p,matInfo);\n        \n    \/\/--------------------\n    \/\/ terrain\n    float h = 2.1+0.1;\n    float d2 = p.y + h;\n    if( d2<res.x ) res = vec2( d2, 3.0 );\n    \n    return res;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/normalsSDF\nvec3 calcNormal( in vec3 pos, in float eps )\n{\n    vec3 kk;\n#if 0    \n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*map( pos + e.xyy, kk ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, kk ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, kk ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, kk ).x );\n#else\n    \/\/ inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+e*eps,kk).x;\n    }\n    return normalize(n);\n#endif    \n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/rmshadows\nfloat calcSoftShadow( in vec3 ro, in vec3 rd, float k )\n{\n    vec3 kk;\n    float res = 1.0;\n    float t = 0.01;\n    for( int i=0; i<32; i++ )\n    {\n        float h = map(ro + rd*t, kk ).x;\n        res = min( res, k*h\/t );\n        t += clamp( h, 0.05, 0.5 );\n\t\tif( res<0.01 ) break;\n    }\n    return smoothstep(0.0,1.0,res);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    vec3 kk;\n\tfloat ao = 0.0;\n    for( int i=ZERO; i<32; i++ )\n    {\n        vec3 ap = forwardSF( float(i), 32.0 );\n        ap *= sign( dot(ap,nor) );\n        float h = hash1(float(i));\n\t\tap *= h*0.3;\n        ao += clamp( mapWithTerrain( pos + nor*0.01 + ap, kk ).x*1.0\/h, 0.0, 1.0 );\n    }\n\tao \/= 32.0;\n\t\n    return clamp( ao*4.0*(1.0+0.25*nor.y), 0.0, 1.0 );\n}\n\nconst vec3 sunDir = normalize( vec3(0.15,0.7,0.65) );\n\nfloat dapples( in vec3 ro, in vec3 rd )\n{\n    float sha = eliSoftShadow( ro, rd, vec3(0.0,4.0,4.0), vec3(3.0,1.0,3.0), 70.0 );\n    \n    vec3 uu = normalize( cross( rd, vec3(0.0,0.0,1.0) ) );\n    vec3 vv = normalize( cross( uu, rd ) );\n\n    vec3 ce = vec3(0.0,4.0,5.0);\n    float t = -dot(ro-ce,rd);\n    vec3 po = ro + t*rd;\n    vec2 uv = vec2( dot(uu,po-ce), dot(vv,po-ce) );\n    \n    float dap = 1.0-smoothstep( 0.1, 0.5, texture(iChannel2,0.25+0.4*uv,-100.0).x );\n    return 1.0 - 0.9*(1.0-sha)*(1.0-dap);\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/filteringrm\nvoid calcDpDxy( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy, in float t, in vec3 nor, out vec3 dpdx, out vec3 dpdy )\n{\n    dpdx = t*(rdx*dot(rd,nor)\/dot(rdx,nor) - rd);\n    dpdy = t*(rdy*dot(rd,nor)\/dot(rdy,nor) - rd);\n}\n\nvec3 shade( in vec3 ro, in vec3 rd, in float t, in float m, in vec3 matInfo, in vec3 rdx, in vec3 rdy )\n{\n    float eps = 0.001;\n    \n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormal( pos, eps*t );\n    vec3 dposdx, dposdy;\n    calcDpDxy( ro, rd, rdx, rdy, t, nor, dposdx, dposdy );\n\n    float kk;\n\n    vec3 mateD = vec3(0.2,0.16,0.11);\n    vec3 mateS = vec3(0.2,0.12,0.07);\n    vec3 mateK = vec3(0.0,1.0,0.0); \/\/ amount, power, metalic\n    float focc = 1.0;\n        \n    if( m<0.5 ) \/\/ body\n    {\n        mateD = vec3(0.27,0.26,0.25)*0.4;\n        mateS = vec3(0.27,0.26,0.25)*0.4;\n        mateK = vec3(0.12,20.0,0.0);\n        \n        float te = texcube( iChannel1, 0.25*pos, nor, 4.0, 0.25*dposdx, 0.25*dposdy ).x;\n        mateD *= 0.2+0.6*te;\n        mateK *= te;\n        \n        mateD *= 1.1 - 0.4*smoothstep( 0.3, 0.7, matInfo.x );\n        mateD = mix( mateD, mateD*vec3(1.1,0.8,0.7), smoothstep( 0.0, 0.15, matInfo.y ) );\n\n        focc *= 0.5 + 0.5*smoothstep(0.0,3.0,pos.y);\n                   \n        vec3 q = pos - vec3(-0.5,2.4,0.0);\n\n        \/\/---\n        vec2 est = q.xy-vec2(-0.31,-0.02);\n        mateD *= mix( vec3(1.0), vec3(0.2,0.15,0.1), exp(-20.0*dot(est,est)) );\n\n        mateD *= 1.2;\n        mateS *= 1.2;\n        mateK.x *= 1.2;\n        \n        mateK.xy *= vec2(3.0,2.0);\n    }\n    else if( m<1.5 ) \/\/ teeh\n    {\n        mateD = vec3(0.3,0.28,0.25)*0.9;\n        mateS = vec3(0.3,0.28,0.25)*0.9;\n        mateK = vec3(0.2,32.0,0.0);\n        mateD *= mix( vec3(0.45,0.4,0.35), vec3(1.0), sqrt(matInfo.x) );\n        focc = smoothstep(0.1,0.3,matInfo.x);\n        float te = texcube( iChannel1, 0.5*pos, nor, 4.0, 0.5*dposdx, 0.5*dposdy ).x;\n        mateD *= te;\n        mateK.x *= te;\n    }\n    else \/\/if( m<2.5 ) \/\/eyeball\n    {\n        mateD = vec3(0.0);\n        mateS = vec3(0.0);\n        mateK = vec3(0.4,32.0,0.0);\n    }\n    \n    vec3 hal = normalize( sunDir-rd );\n    float fre = clamp(1.0+dot(nor,rd), 0.0, 1.0 );\n    float occ = calcAO( pos, nor )*focc;\n        \n    float dif1 = dot(nor,sunDir);\n    if( dif1>0.001 )\n    {\n    float sha = calcSoftShadow( pos, sunDir, 16.0 );\n    sha = min( sha, dapples(pos,sunDir) );\n    dif1 *= sha;\n    }\n    dif1 = clamp( dif1, 0.0, 1.0 );\n\n    float spe1 = clamp( dot(nor,hal), 0.0, 1.0 );\n    float bak = clamp( dot(nor,normalize(vec3(-sunDir.x,0.0,-sunDir.z))), 0.0, 1.0 );\n    float bou = clamp( 0.3-0.7*nor.y, 0.0, 1.0 );\n    float rod1 = 1.0 - (1.0-smoothstep( 0.15,0.2, length(pos.yz-vec2(1.8,0.3))))*(1.0-smoothstep(0.0,0.1,abs(pos.x+0.2)));\n\n    \n    \/\/ sun\n    vec3 col = 8.5*vec3(2.0,1.2,0.65)*dif1;\n    \/\/ sky\n    col += 4.5*vec3(0.35,0.7,1.0)*occ*clamp(0.2+0.8*nor.y,0.0,1.0);\n    \/\/ ground\n    col += 4.0*vec3(0.4,0.25,0.12)*bou*occ;\n    \/\/ back\n    col += 3.5*vec3(0.2,0.2,0.15)*bak*occ*rod1;\n    \/\/ sss\n    col += 25.0*fre*fre*(0.2+0.8*dif1*occ)*mateS*rod1;\n\n    \/\/ sun\n    vec3 hdir = normalize(sunDir - rd);\n    float costd = clamp( dot(sunDir, hdir), 0.0, 1.0 );\n    float spp = pow( spe1, mateK.y )*dif1*mateK.x * (0.04 + 0.96*pow(1. - costd,5.0));\n\n    \/\/ sky spec\n    float sksp = occ*occ*smoothstep(-0.2,0.2,reflect(rd,nor).y)*(0.5+0.5*nor.y)*mateK.x * (0.04 + 0.96*pow(fre,5.0));\n\n    col += mateK.z*15.0*5.0*spp; \n\n    col *= mateD;\n\n    col += (1.0-mateK.z)*75.0*spp; \n    col += (1.0-mateK.z)* 3.0*sksp*vec3(0.35,0.7,1.0); \n\n    return col;        \n}\n\nvec2 raycast( in vec3 ro, in vec3 rd, in float tmax, out vec3 matInfo )\n{\n    vec2 res = vec2(-1.0);\n\n    float maxdist = min(tmax,10.0);\n    float t = 4.0;\n\n#if 1\n    \/\/ this bounding cylinder only covers the front half of the\n    \/\/ elephant, but because of the camera direction, in perspective\n    \/\/ it also covers the back side. For a different camera direction\n    \/\/ the true bounding cylinder should be used.\n    vec2 bb = iCylinderY(ro,rd,vec4(-0.1,0.0,-0.2,1.45));\n    if( bb.y<0.0 ) return res;\n    if( bb.x>0.0 ) t = max(t,bb.x);\n    \/\/maxdist = min(maxdist,bb.y); \/\/ enable only when using the true bounding cylinder\n#endif\n\n    for( int i=0; i<128; i++ )\n    {\n        vec3 p = ro + t*rd;\n        vec2 h = map( p, matInfo );\n        res = vec2(t,h.y);\n        if( h.x<(0.0001*t) || t>maxdist ) break;\n        t += h.x;\/\/*0.75;\n    }\n\n    if( t>maxdist )\n    {\n        res = vec2(-1.0);\n    }\n\n    return res;\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec3 col, in float tmax, in vec3 rdx, in vec3 rdy )\n{\n    vec3 matInfo;\n    vec2 tm = raycast( ro, rd, tmax, matInfo );\n    if( tm.y>-0.5  )\n    {\n        col = shade( ro, rd, tm.x, tm.y, matInfo, rdx, rdy );\n        float fa = 1.0-exp(-0.0001*(tm.x*tm.x+tm.x));\n        col = mix( col, vec3(0.4,0.5,0.65), fa );\n    }\n\treturn col;    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 q = fragCoord\/iResolution.xy;\n    vec2 p = (2.0*fragCoord-iResolution.xy)\/iResolution.y;\n\n    \/\/ camera\n    float an = 0.025*sin(0.5*iTime) - 1.25;\n    vec3 ro = vec3(5.7*sin(an),1.6,5.7*cos(an));\n    vec3 ta = vec3(0.0,1.6,0.0);\n\n    \/\/ ray\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    vec3 rd = normalize( ca * vec3(p,-3.5) );\n\n    \/\/ ray differentials\n    \/\/ https:\/\/iquilezles.org\/articles\/filteringrm\n    vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)\/iResolution.y;\n    vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)\/iResolution.y;\n    vec3 rdx = normalize( ca * vec3(px,-3.5) );\n    vec3 rdy = normalize( ca * vec3(py,-3.5) );\n    \n    \/\/ red background\n    vec4 data = texture( iChannel3, q );\n    vec3 col = data.xyz;\n    float t = data.w;\n\n    \/\/ render\n    col = render( ro, rd, col, t, rdx, rdy);\n\n    \/\/ sun\n    float sun = clamp( 0.5 + 0.5*dot(rd,sunDir), 0.0, 1.0 );\n    col += 1.5*vec3(1.0,0.8,0.6)*pow(sun,16.0);\n\n    \/\/ gamma\n    col = pow(col,vec3(0.4545));\n    \n    \/\/ color grade\n    col.x += 0.010;\n    \n    \/\/ vignette\n    col *= 0.3 + 0.7*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.1);\n    fragColor = vec4( col, 1.0 );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3Rn","filepath":"\/media\/a\/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"\/media\/ap\/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"\/media\/a\/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"\/media\/ap\/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"\/media\/a\/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"\/media\/ap\/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ Copyright Inigo Quilez, 2016 - https:\/\/iquilezles.org\/\n\/\/ I am the sole copyright owner of this Work.\n\/\/ You cannot host, display, distribute or share this Work in any form,\n\/\/ including physical and digital. You cannot use this Work in any\n\/\/ commercial or non-commercial product, website or project. You cannot\n\/\/ sell this Work and you cannot mint an NFTs of it.\n\/\/ I share this Work for educational purposes, and you can link to it,\n\/\/ through an URL, proper attribution and unmodified screenshot, as part\n\/\/ of your educational material. If these conditions are too restrictive\n\/\/ please contact me and we'll definitely work it out.\n\n#define USE_REPROJECTION\n\nfloat leg( in vec3 p, in vec3 pa, in vec3 pb, in vec3 pc, float m, float h, float sc )\n{\n    vec2 b = sdSegment( p, pa, pb );\n\n    float tr = 0.35 - 0.16*smoothstep(0.0,1.0,b.y);\n    float d3 = b.x - tr*sc;\n\n    b = sdSegment( p, pb, pc );\n    tr = 0.18;\n    d3 = smin( d3, b.x - tr*sc, 0.1 );\n\n    vec3 ww = normalize( mix( normalize(pc-pb), vec3(0.0,1.0,0.0), h) );\n    mat3 pr = base( ww );\n    vec3 fc = pr*((p-pc))-vec3(0.02,0.0,0.0)*(-1.0+2.0*h);\n    float d4 = sdEllipsoid( fc, vec3(0.0), vec3(0.2,0.15,0.2) );\n\n    d3 = smin( d3, d4, 0.1 );\n\n\treturn d3;\n}\n\nfloat mapElephantSimple( vec3 p )\n{\n    p.x -= -0.5;\n\tp.y -= 2.4;\n    \n    \/\/ head\n    float d = sdEllipsoid( p, vec3(0.0,0.0,0.0), vec3(0.55,0.55,0.35) );\n\n\n    \/\/ body\n    {\n    float co = cos(0.4);\n    float si = sin(0.4);\n    vec3 w = p;\n    w.xy = mat2(co,si,-si,co)*w.xy;\n\n    float d4 = sdEllipsoid( w, vec3(0.6,0.3,0.0), vec3(0.6,0.6,0.6) );\n\td = smin(d, d4, 0.1 );\n\n    d4 = sdEllipsoid( w, vec3(1.8,0.3,0.0), vec3(1.2,0.9,0.7) );\n\td = smin(d, d4, 0.2 );\n\n    d4 = sdEllipsoid( w, vec3(2.1,0.55,0.0), vec3(1.0,0.9,0.6) );\n\td = smin(d, d4, 0.1 );\n\n    d4 = sdEllipsoid( w, vec3(2.0,0.8,0.0), vec3(0.7,0.6,0.8) );\n\td = smin(d, d4, 0.1 );\n\n    }\n    vec3 q = vec3( p.xy, abs(p.z) );\n\n    \/\/ back-left leg\n    {\n    float d3 = leg( q, vec3(2.6,-0.6,0.3), vec3(2.65,-1.45,0.3), vec3(2.6,-2.1,0.25), 1.0, 0.0, 1.0 );\n    d = smin(d,d3,0.1);\n    }\n\n    \n    \/\/ front-left leg\n    float d3 = leg( p, vec3(0.8,-0.4,0.3), vec3(0.7,-1.55,0.3), vec3(0.8,-2.1,0.3), 1.0, 0.0, 1.0 );\n    d = smin(d,d3,0.15);\n    d3 = leg( p, vec3(0.8,-0.4,-0.3), vec3(0.4,-1.55,-0.3), vec3(0.4,-2.1,-0.3), 1.0, 0.0, 1.0 );\n    d = smin(d,d3,0.15);\n    \n    return d;\n}\n\nfloat mapTree( vec3 p )\n{\n    float f = length(p);\n    if( f>8.0 )\n        return f - 8.0 + 0.1;\n\n    vec3 q = p;   \n    \n    p.xz += 0.1*sin(4.0*p.y+vec2(0.0,1.0));\n    vec2 s1 = sdSegment( p, vec3(0.0,-2.0,0.0), vec3(-2.0,3.3,4.0) );\n    float d2 = s1.x - (0.25 - 0.12*s1.y);\n    s1 = sdSegment( p, vec3(0.0,-2.0,0.0), vec3(-3.0,3.3,0.0) );\n    float d4 = s1.x - (0.25 - 0.12*s1.y);\n    d2 = min( d2, d4 );\n    s1 = sdSegment( p, mix( vec3(0.0,-2.0,0.0), vec3(-3.0,3.3,-1.0), 0.35 ), vec3(-2.0,3.3,-4.0) );\n    d4 = s1.x - (0.25 - 0.12*s1.y);\n    d2 = min( d2, d4 );\n    \n    p.y += length(p.xz)*0.1;\n    p.y += 0.5*sin(p.x);\n    \n    float nn = textureLod(iChannel2,0.1*q.zy, 0.0).x;\n    d4 = sdEllipsoid( p, vec3( 0.0,3.3,0.0), vec3(4.5,0.9,4.5)*(1.0+nn) );\n    \n    d4 += max(0.0,3.0*sin(1.5*q.x)*sin(1.5*q.y)*sin(1.5*q.z)*clamp( 1.0 - d4\/3.0, 0.0, 1.0 ));\n\n    return min( d2, d4 );\n}\n\nmat3 rotationMat( in vec3 xyz )\n{\n    vec3 si = sin(xyz);\n    vec3 co = cos(xyz);\n\n\treturn mat3( co.y*co.z,                co.y*si.z,               -si.y,    \n                 si.x*si.y*co.z-co.x*si.z, si.x*si.y*si.z+co.x*co.z, si.x*co.y,\n                 co.x*si.y*co.z+si.x*si.z, co.x*si.y*si.z-si.x*co.z, co.x*co.y );\n}\n\nvec2 map( vec3 p, out vec3 matInfo )\n{\n    matInfo = vec3(0.0);\n    \n    p.x -= -0.5;\n\tp.y -= 2.4;\n    \n    \/\/--------------------\n    \/\/ ground\n    \/\/--------------------\n    \n    float h = 2.1 + 0.1*textureLod( iChannel2, 0.07*p.xz, 0.0 ).x;\n    float d2 = p.y + h;\n    vec2 res = vec2( d2, 3.0 );\n\n    \n    \/\/--------------------\n    \/\/ leaves\n    \/\/--------------------\n#if 1\n    for( int j=ZERO; j<2; j++ )\n    {\n        float dleaves = 1000.0;\n\n        vec3         pl = p - vec3(-0.85,0.30,2.1);\n        vec3         pd = vec3(-0.2,-0.5,-0.3);\n        if( j==1 ) { pl = p - vec3(-0.00,0.45,2.2);\n                     pd = vec3( 0.2,-0.6, 0.1); };\n        \n        float pr = dot(pl,pl);\n        if( sqrt(pr)-1.5<res.x && pr<1.5 )\n        {\n            float sim = 1.0;\n            vec2 uv = vec2(0.0);\n            for( int i=ZERO; i<9; i++ )\n            {\n                float h = float(i);\n                float hh = float(i+10*j);\n                vec3 sc = hash3(hh*13.92);\n                vec3 di = sin(vec3(0.0,1.0,2.0)+hh*vec3(10.0,15.0,20.0));\n                vec3 of = pd*h\/8.0;\n\n                vec3 q = pl - of;\n                q = rotationMat( 6.2831*di*vec3(0.1,-0.1,0.9) + 0.04*sin(20.0*hh + 0.7*iTime) ) * q;\n\n                q.z = q.z*sim - 0.22;\n\n                q.xz += q.y*q.y*2.0;\n\n                q *= 0.75 + 0.4*sc.x;\n\n                d2 =          sdSphere( q, vec3(0.0,-0.1,0.0), 0.25 );\n                d2 = max( d2, sdSphere( q, vec3(0.0, 0.1,0.0), 0.25 ) );\n                d2 = smax( d2, abs(q.x)-0.003, 0.01 );\n\n                d2 \/= 0.75 + 0.4*sc.x;\n\n                if( d2<dleaves )\n                {\n                    dleaves = d2;\n                    uv = q.yz;\n                }\n                sim *= -1.0;\n            }\n            vec2 s2 = sdSegment( pl, vec3(0.0), pd );\n            d2 = s2.x - 0.01;\n            dleaves = min(dleaves,d2); \n            if( dleaves<res.x ) \n            {\n                res = vec2( dleaves, 6.0 );\n                matInfo.x = 0.0;\n                matInfo.yz = uv;\n            }\n        }\n    }\n#endif\n\n    \/\/--------------------\n    \/\/ bushes\n    \/\/--------------------\n    \n#if 1\n    float bb = max( -(p.x-18.0), p.y+0.4 );\n    if( bb<res.x )\n    {\n    vec2 idb = floor(p.xz\/4.0);        \n    \/\/for( int j=ZERO; j<2; j++ )    \n    \/\/for( int i=ZERO; i<2; i++ )    \n    {\n        vec2 id = idb;\/\/ + vec2(float(i),float(j));\n        if( id.x>4.0 )\n        {\n            float h = id.x*7.7 + id.y*13.1;\n            float si = hash1(h*31.7);\n            float al = hash1(h*41.9);\n\n            if( si>0.5 )\n            {\n                vec3 bc = vec3(id.x*4.0+2.0,-2.0,id.y*4.0+2.0);\n                bc.xz -= 1.0*hash3( h*7.7 ).xy;\n                vec3 eli = vec3(1.6*(0.3 + 0.7*si),1.5*(0.5 + 0.5*al),1.6*(0.3 + 0.7*si));\n\n                #if 0\n                d2 = sdEllipsoid( p, bc, eli );\n                if( d2<res.x ) \n                {\n                    res = vec2( d2, 4.0 );\n                    matInfo.x = hash1(h*77.7);\n                }\n\n                #else\n                float d4 = 1000.0;\n                float d3 = 0.0;\n                for( int j=0; j<12; j++ )\n                {\n                    float h2 = float(j);\n                    vec3 of = normalize((-1.0+2.0*hash3(h*11.11+h2*9.13)));\n\n                    of.y = of.y*of.y - 0.1;\n                    of *= eli;\n\n                    vec3 bb = bc + of;\n                    d2 = sdEllipsoid( p, bb, 0.5*vec3(1.0,0.85,1.0));\n\n                    if( d2<d4)\n                    {\n                        d4 = d2;\n                        d3 = hash1(h*77.7);\n                    }\n                }\n\n                float di = textureLod(iChannel2,0.06*p.yz,0.0).x +\n                           textureLod(iChannel2,0.06*p.xy,0.0).x;\n                di \/= 2.0;\n                d4 -= 0.4*di*di;\n\n                if( d4<res.x ) \n                {\n                    res = vec2( d4, 4.0 );\n                    matInfo.x = d3;\n                    matInfo.y = di;\n                }\n                #endif\n            }\n        }\n    }\n    }\n#endif    \n\n    \/\/--------------------\n    \/\/ trees\n    \/\/--------------------\n     \n#if 1\n    {\n    const vec3 tc1 = vec3(50.0,0.0,-40.0);\n    const vec3 tc2 = vec3(85.0,0.0,5.0);\n    float td1 = dot(p.xz-tc1.xz,p.xz-tc1.xz);\n    float td2 = dot(p.xz-tc2.xz,p.xz-tc2.xz);\n    vec3 tc = (td1<td2) ? tc1 : tc2;\n    bb = length(p-tc)-8.0;\n    if( bb<res.x )\n    {\n    float d2 = mapTree( p - tc );\n    if( d2<res.x ) \n    {\n        res = vec2( d2, 5.0 );\n        matInfo.x = 0.0;\n    }\n    }\n    }\n#endif\n\n    return res;\n}\n\nfloat mapSmallElephantSimple( vec3 p )\n{\n    const float sca = 2.0;\n    p.xz = mat2(0.8,0.6,-0.6,0.8)*p.xz;\n    p *= sca;\n    \n    p -= vec3(-1.1,2.4,-2.0);\n    \n    vec3 ph = p;\n    ph.yz = mat2(0.95,0.31225,-0.31225,0.95)*ph.yz;\n        \n    \/\/ head\n    float d = sdEllipsoid( ph, vec3(0.0,0.0,0.0), vec3(0.45,0.55,0.35) );\n\n    vec3 qh = vec3( ph.xy, abs(ph.z) );\n\n    vec3 q = vec3( p.xy, abs(p.z) );\n\n    \/\/ body\n    {\n    float co = cos(0.4);\n    float si = sin(0.4);\n    vec3 w = p;\n    w.xy = mat2(co,si,-si,co)*w.xy;\n        \n    float d4 = sdEllipsoid( w, vec3(1.8,0.3,0.0), vec3(1.2,0.9,0.7) );\n\td = smin(d, d4, 0.2 );\n\n    }\n\n    \/\/ back-left leg\n    {\n    float d3 = leg( q, vec3(2.6,-0.6,0.3), vec3(2.65,-1.4,0.3), vec3(2.6,-2.0,0.25), 1.0, 0.0, 0.75  );\n    d = smin(d,d3,0.1);\n    }\n    \n    \n    \/\/ front-left leg\n    {\n    float d3 = leg( p, vec3(0.8,-0.4,0.2), vec3(0.6,-1.4,0.2), vec3(0.7,-1.9,0.2), 1.0, 0.0, 0.75 );\n    d = smin(d,d3,0.15);\n    d3 = leg( p, vec3(0.8,-0.4,-0.2), vec3(0.3,-1.4,-0.2), vec3(0.2,-1.9,-0.2), 1.0, 0.0, 0.75 );\n    d = smin(d,d3,0.15);\n\n    }\n    \n    return d\/sca;\n}\n\nfloat mapWithElephants( vec3 p )\n{\n    vec3 kk;\n    float res = map( p, kk ).x;\n\n    res = min( res, mapElephantSimple(p) );\n    res = min( res, mapSmallElephantSimple(p) );\n\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos, in float eps )\n{\n    vec3 kk;\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*map( pos + e.xyy, kk ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, kk ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, kk ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, kk ).x );\n#else\n    \/\/ trick by klems, to prevent the compiler from inlining map() 4 times\n    vec4 n = vec4(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec4 s = vec4(pos, 0.0);\n        s[i] += eps*0.25;\n        n[i] = map(s.xyz,kk).x;\n    }\n    return normalize(n.xyz-n.w);\n#endif    \n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/rmshadows\nfloat calcSoftShadow( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n    float t = 0.01;\n    for( int i=0; i<24; i++ )\n    {\n        float h = mapWithElephants(ro + rd*t );\n        res = min( res, smoothstep(0.0,1.0,k*h\/t) );\n        t += clamp( h, 0.05, 0.5 );\n\t\tif( res<0.01 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat ao = 0.0;\n    for( int i=ZERO; i<8; i++ )\n    {\n        vec3 ap = forwardSF( float(i), 8.0 );\n        float h = hash1(float(i));\n        float dk = dot(ap,nor); if( dk<0.0 ) ap -= 2.0*nor*dk;\n        ap *= h*0.3;\n        ao += clamp( mapWithElephants( pos + nor*0.01 + ap )*2.4, 0.0, 1.0 );\n    }\n\tao \/= 8.0;\n\t\n    return clamp( ao*4.0*(1.0+0.25*nor.y), 0.0, 1.0 );\n}\n\nconst vec3 sunDir = normalize( vec3(0.15,0.7,0.65) );\n\nfloat dapples( in vec3 ro, in vec3 rd )\n{\n    float sha = eliSoftShadow( ro, rd, vec3(0.0,4.0,4.0), vec3(3.0,1.0,3.0), 10.0 );\n    \n    vec3 uu = normalize( cross( rd, vec3(0.0,0.0,1.0) ) );\n    vec3 vv = normalize( cross( uu, rd ) );\n\n    vec3 ce = vec3(0.0,4.0,5.0);\n    float t = -dot(ro-ce,rd);\n    vec3 po = ro + t*rd;\n    vec2 uv = vec2( dot(uu,po-ce), dot(vv,po-ce) );\n\n    float dap = 1.0-smoothstep( 0.1, 0.5, texture(iChannel3,0.25+0.4*uv).x );\n    return 1.0 - 0.95*(1.0-sha)*(1.0-dap);\n}\n\nvec3 shade( in vec3 ro, in vec3 rd, in float t, in float m, in vec3 matInfo )\n{\n    float eps = 0.001;\n    \n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormal( pos, eps*t );\n    float kk;\n\n    vec3 mateD = vec3(0.2,0.16,0.11);\n    vec3 mateS = vec3(0.2,0.12,0.07);\n    vec3 mateK = vec3(0.0,1.0,0.0); \/\/ amount, power, metalic\n    float focc = 1.0;\n    \n    if( m<3.5 ) \/\/ ground\n    {\n        mateD = vec3(0.1,0.09,0.07)*0.27;\n        mateS = vec3(0.0,0.0,0.0);\n        mateD *= 2.0*texture( iChannel1, 0.1*pos.xz ).xyz;\n        \n        float gr = smoothstep( 0.3,0.4,texture(iChannel2,0.01*pos.zx).x );\n        vec3 grcol = vec3(0.3,0.28,0.05)*0.07;\n        grcol *= 0.5 + texture( iChannel2, 4.0*pos.xz ).x;\n        mateD = mix( mateD, grcol, smoothstep( 0.9,1.0,nor.y)*gr );\n        mateD *= 1.2;\n        mateK = vec3(1.0,8.0,1.0);\n    }\n    else if( m<4.5) \/\/ bushes\n    {\n        mateD = vec3(0.2,0.32,0.07)*0.1;\n        mateD.x += matInfo.x*0.02;\n        mateS = vec3(0.8,0.9,0.1);\n        focc = 1.0-matInfo.y;\n        mateK = vec3(0.07,16.0,0.0);\n    }\n    else if( m<5.5 ) \/\/ trees\n    {\n        mateD = vec3(0.2,0.3,0.07)*0.07;\n        mateS = vec3(0.0,0.0,0.0);\n        mateK = vec3(0.2,16.0,0.0);\n    }\n    else \/\/ leaves\n    {\n        mateD = vec3(0.2,0.35,0.07)*0.2;\n        mateS = vec3(0.8,1.0,0.1)*0.25;\n        mateK = vec3(0.07,16.0,0.0);\n        float te = texture( iChannel2, 0.35*matInfo.yz ).x;\n        mateD *= 1.0 + 0.6*te;\n        mateS *= 1.0 + 0.6*te;\n        mateD += vec3(0.035) * (1.0-smoothstep(0.005,0.01,abs(matInfo.y)+matInfo.z*0.05) );\n    }\n    \n    vec3 hal = normalize( sunDir-rd );\n    float fre = clamp(1.0+dot(nor,rd), 0.0, 1.0 );\n    float occ = calcAO( pos, nor )*focc;\n        \n    float dif1 = clamp( dot(nor,sunDir), 0.0, 1.0 );\n    float bak = clamp( dot(nor,normalize(vec3(-sunDir.x,0.0,-sunDir.z))), 0.0, 1.0 );\n    float sha = calcSoftShadow( pos, sunDir, 16.0 );\n\tsha = min( sha, dapples(pos,sunDir) );\n              \n    dif1 *= sha;\n    float spe1 = clamp( dot(nor,hal), 0.0, 1.0 );\n    float bou = clamp( 0.3-0.7*nor.y, 0.0, 1.0 );\n\n    \/\/ sun\n    vec3 col = 8.5*vec3(2.0,1.2,0.65)*dif1;\n    \/\/ sky\n    col += 4.5*vec3(0.35,0.7,1.0)*occ*clamp(0.2+0.8*nor.y,0.0,1.0);\n    \/\/ ground\n    col += 4.0*vec3(0.4,0.25,0.12)*bou*occ;\n    \/\/ back\n    col += 3.5*vec3(0.2,0.2,0.15)*bak*occ;\n    \/\/ sss\n    col += 25.0*fre*fre*(0.2+0.8*dif1*occ)*mateS;\n\n    \/\/ sun\n    vec3 hdir = normalize(sunDir - rd);\n    float costd = clamp( dot(sunDir, hdir), 0.0, 1.0 );\n    float spp = pow( spe1, mateK.y )*dif1*mateK.x * (0.04 + 0.96*pow(1. - costd,5.0));\n    col += mateK.z*15.0*5.0*spp; \n    \n    col *= mateD;\n\n    col += (1.0-mateK.z)*15.0*5.0*spp; \n    \n    return col;        \n}\n\nvec2 raycast( in vec3 ro, in vec3 rd, out vec3 matInfo )\n{\n    vec2 res = vec2(-1.0);\n\n    float maxdist = 100.0;\n    float t = 1.0;\n\n    float tp = ( 8.0-ro.y)\/rd.y; if( tp>0.0 ) maxdist = min( maxdist, tp );\n          tp = (-2.2-ro.y)\/rd.y; if( tp>0.0 ) maxdist = min( maxdist, tp );\n    \n    for( int i=0; i<110; i++ )\n    {\n        vec3 p = ro + t*rd;\n        vec2 h = map( p, matInfo );\n        res = vec2(t,h.y);\n        if( h.x<(0.0001*t) ||  t>maxdist ) break;\n        t += h.x*0.75;\n    }\n\n    if( t>maxdist )\n    {\n        res = vec2(-1.0);\n    }\n\n    return res;\n}\n\nfloat mapBk( in vec3 pos )\n{\n    float l = length(pos.xz);\n    float f = smoothstep( 1000.0, 1500.0, l );\n\n    float h = 200.0*f*texture( iChannel2, 0.001 + 0.00003*pos.xz ).x;\n\n    return pos.y-h;\n}\n\nvec3 calcNormalBk( in vec3 pos, in float eps )\n{\n#if 0    \n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*mapBk( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*mapBk( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*mapBk( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*mapBk( pos + e.xxx ) );\n#else\n    \/\/ trick by klems, to prevent the compiler from inlining map() 4 times\n    vec4 n = vec4(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec4 s = vec4(pos, 0.0);\n        s[i] += eps;\n        n[i] = mapBk(s.xyz);\n    }\n    return normalize(n.xyz-n.w);\n#endif    \n}\n\nfloat calcSoftShadowBk( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n    float t = 0.01;\n    for( int i=0; i<16; i++ )\n    {\n        float h = mapBk(ro + rd*t );\n        res = min( res, smoothstep(0.0,1.0,k*h\/t) );\n        t += clamp( h, 10.0, 100.0 );\n\t\tif( res<0.01 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec3 shadeBk( in vec3 ro, in vec3 rd, in float t )\n{\n    float eps = 0.005;\n    \n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormalBk( pos, eps*t );\n    float kk;\n\n    vec3 mateD = vec3(0.14,0.14,0.12);\n    mateD = mix( mateD, vec3(0.04,0.04,0.0), smoothstep(0.85,0.95, nor.y ) );\n    mateD *= 0.3;\n  \n    mateD *= 0.1 + 2.0*texture( iChannel2, pos.xz*0.005 ).x;\n    \n    vec3 hal = normalize( sunDir-rd );\n        \n    float dif1 = clamp( dot(nor,sunDir), 0.0, 1.0 );\n    \/\/if( dif1>0.001 ) dif1 *= calcSoftShadowBk( pos, sunDir, 16.0 );\n\n    \/\/ sun\n    vec3 col = 8.0*vec3(1.8,1.2,0.8)*dif1;\n    \/\/ sky\n    col += 4.0*vec3(0.3,0.7,1.0)*clamp(0.2+0.8*nor.y,0.0,1.0);\n    \n    col *= mateD*1.2;\n    return col;        \n}\n\nfloat intersectBk( in vec3 ro, in vec3 rd )\n{\n    float res = -1.0;\n\n    float maxdist = 2000.0;\n    float t = 1000.0;\n\n    for( int i=0; i<100; i++ )\n    {\n        vec3 p = ro + t*rd;\n        float h = mapBk( p );\n        res = t;\n        if( h<(0.0001*t) ||  t>maxdist ) break;\n        t += h*0.75;\n    }\n\n    if( t>maxdist ) res = -1.0;\n\n    return res;\n}\n\nvec3 render( in vec3 ro, in vec3 rd, out float resT )\n{\n    resT = 10000.0;\n    \n    \/\/ sky\n    \/\/vec3 col = clamp(vec3(0.7,0.9,1.0) - rd.y,0.0,1.0);\n    vec3 col = clamp(vec3(0.75,0.9,1.0) - rd.y,0.0,1.0);\n    \n    \/\/ clouds\n    float t = (1000.0-ro.y)\/rd.y;\n    if( t>0.0 )\n    {\n        vec2 uv = (ro+t*rd).xz;\n        float cl = texture( iChannel2, .000013*uv ).x;\n        cl = smoothstep(0.4,1.0,cl);\n        col = mix( col, vec3(1.0), 0.4*cl );\n    }\n\n    \/\/ distant mountains\n    {\n    float tm = intersectBk( ro, rd );\n    if( tm>-0.5  )\n    {\n        col = shadeBk( ro, rd, tm );\n        float fa = 1.0-exp(-0.001*tm);\n        vec3 pos = ro + rd*tm;\n        fa *= exp(-0.001*pos.y);\n        col = mix( col, vec3(0.35,0.5,0.8), fa );\n        resT = tm;\n    }\n    }\n    \n    \/\/ landscape\n    vec3 matInfo;\n    vec2 tm = raycast( ro, rd, matInfo );\n    if( tm.y>-0.5  )\n    {\n        col = shade( ro, rd, tm.x, tm.y, matInfo );\n        float fa = 1.0-exp(-0.00018*(tm.x*tm.x*0.4  + 0.6*tm.x));\n        col = mix( col, vec3(0.35,0.5,0.75), fa );\n        resT = tm.x;\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    #ifdef USE_REPROJECTION\n    vec2 o = hash2( float(iFrame) ) - 0.5;\n    #else\n    vec2 o = vec2(0.0);\n    #endif\n\n    vec2 q = fragCoord\/iResolution.xy;\n    vec2 p = (2.0*(fragCoord+o)-iResolution.xy)\/iResolution.y;\n\n    \/\/ camera\n    float an = 0.025*sin(0.5*iTime) - 1.25;\n    vec3 ro = vec3(5.7*sin(an),1.6,5.7*cos(an));\n    vec3 ta = vec3(0.0,1.6,0.0);\n\n    \/\/ ray\n    const float fl = 3.5;\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    vec3 rd = normalize( ca * vec3(p,-fl) );\n\n    \/\/ render\n    float t;\n    vec3 col = render( ro, rd, t);\n    \n    \/\/------------------------------------------\n\t\/\/ reproject from previous frame and average\n    \/\/------------------------------------------\n#ifdef USE_REPROJECTION\n    mat4 oldCam = mat4( textureLod(iChannel0,vec2(0.5,0.5)\/iResolution.xy, 0.0),\n                        textureLod(iChannel0,vec2(1.5,0.5)\/iResolution.xy, 0.0),\n                        textureLod(iChannel0,vec2(2.5,0.5)\/iResolution.xy, 0.0),\n                        0.0, 0.0, 0.0, 1.0 );\n    \n    \/\/ world space\n    vec4 wpos = vec4(ro + rd*t,1.0);\n    \/\/ camera space\n    vec3 cpos = (wpos*oldCam).xyz; \/\/ note inverse multiply\n    \/\/ ndc space\n    vec2 npos = -fl * cpos.xy \/ cpos.z;\n    \/\/ screen space\n    vec2 spos = 0.5 + 0.5*npos*vec2(iResolution.y\/iResolution.x,1.0);\n    \/\/ undo dither\n    spos -= o\/iResolution.xy;\n\t\/\/ raster space\n    vec2 rpos = spos * iResolution.xy;\n    \n    if( rpos.y<1.0 && rpos.x<3.0 )\n    {\n    }\n\telse\n    {\n        vec3 ocol = textureLod( iChannel0, spos, 0.0 ).xyz;\n    \tif( iFrame==0 ) ocol = col;\n        col = mix( ocol, col, 0.13 );\n    }\n\n    \/\/----------------------------------\n                           \n\tif( fragCoord.y<1.0 && fragCoord.x<3.0 )\n    {\n        if( abs(fragCoord.x-2.5)<0.5 ) fragColor = vec4( ca[2], -dot(ca[2],ro) );\n        if( abs(fragCoord.x-1.5)<0.5 ) fragColor = vec4( ca[1], -dot(ca[1],ro) );\n        if( abs(fragCoord.x-0.5)<0.5 ) fragColor = vec4( ca[0], -dot(ca[0],ro) );\n    }\n    else\n    {\n        fragColor = vec4( col, t );\n    }\n#else\n    fragColor = vec4( col, t );\n#endif\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\/\/ Copyright Inigo Quilez, 2016 - https:\/\/iquilezles.org\/\n\/\/ I am the sole copyright owner of this Work.\n\/\/ You cannot host, display, distribute or share this Work in any form,\n\/\/ including physical and digital. You cannot use this Work in any\n\/\/ commercial or non-commercial product, website or project. You cannot\n\/\/ sell this Work and you cannot mint an NFTs of it.\n\/\/ I share this Work for educational purposes, and you can link to it,\n\/\/ through an URL, proper attribution and unmodified screenshot, as part\n\/\/ of your educational material. If these conditions are too restrictive\n\/\/ please contact me and we'll definitely work it out.\n\n\/\/ pretty decent DOF with a gather approach\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 di = hash2( fragCoord )-0.5;\n    vec2 uv = fragCoord\/iResolution.xy;\n    \n    vec4 ref = texture( iChannel0, uv );\n    \n    const float focus = 7.0;\n\n    vec4 acc = vec4(0.0);\n    for( int j=0; j<11; j++ )\n    for( int i=0; i<11; i++ )\n    {\n        vec2 of = 1.0 * (di+vec2(float(i-5),float(j-5)))\/800.0;\n\n        vec4  cold = texture( iChannel0, uv + of );\n        float depth = cold.w;\n        float coc = max(0.001,0.005*abs(depth-focus)\/depth);   \/\/ compute scatter radious\n\n        if( dot(of,of) < (coc*coc) )\n        {\n            float w = 1.0\/(coc*coc); \n            acc += vec4(cold.xyz*w,w);\n        }\n    }\n    \n    vec3 col = acc.xyz \/ acc.w;\n    \n\tfragColor = vec4( col, ref.w );\n}    \n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\/\/ The MIT License\n\/\/ Copyright \u00a9 2016 Inigo Quilez\n\/\/ Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\/\/ https:\/\/iquilezles.org\/articles\/smin\nfloat smin( float a, float b, float k )\n{\n    \/\/return min(a,b);\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25\/k;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/smin\nfloat smax( float a, float b, float k )\n{\n    return -smin(-a,-b,k);\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nvec2 sdSegment( in vec3 p, vec3 a, vec3 b )\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ), h );\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nfloat sdEllipsoid( in vec3 p, in vec3 c, in vec3 r )\n{\n#if 1   \n    return (length( (p-c)\/r ) - 1.0) * min(min(r.x,r.y),r.z);\n#else\n    p -= c;\n    float k0 = length(p\/r);\n    float k1 = length(p\/(r*r));\n    return k0*(k0-1.0)\/k1;\n#endif    \n}\n\n\/\/ http:\/\/research.microsoft.com\/en-us\/um\/people\/hoppe\/ravg.pdf\nfloat det( vec2 a, vec2 b ) { return a.x*b.y-b.x*a.y; }\nvec3 getClosest( vec2 b0, vec2 b1, vec2 b2 ) \n{\n  float a =     det(b0,b2);\n  float b = 2.0*det(b1,b0);\n  float d = 2.0*det(b2,b1);\n  float f = b*d - a*a;\n  vec2  d21 = b2-b1;\n  vec2  d10 = b1-b0;\n  vec2  d20 = b2-b0;\n  vec2  gf = 2.0*(b*d21+d*d10+a*d20); gf = vec2(gf.y,-gf.x);\n  vec2  pp = -f*gf\/dot(gf,gf);\n  vec2  d0p = b0-pp;\n  float ap = det(d0p,d20);\n  float bp = 2.0*det(d10,d0p);\n  float t = clamp( (ap+bp)\/(2.0*a+b+d), 0.0 ,1.0 );\n  return vec3( mix(mix(b0,b1,t), mix(b1,b2,t),t), t );\n}\n\nvec2 sdBezier( vec3 a, vec3 b, vec3 c, vec3 p, out vec2 pos )\n{\n\tvec3 w = normalize( cross( c-b, a-b ) );\n\tvec3 u = normalize( c-b );\n\tvec3 v = normalize( cross( w, u ) );\n\n\tvec2 a2 = vec2( dot(a-b,u), dot(a-b,v) );\n\tvec2 b2 = vec2( 0.0 );\n\tvec2 c2 = vec2( dot(c-b,u), dot(c-b,v) );\n\tvec3 p3 = vec3( dot(p-b,u), dot(p-b,v), dot(p-b,w) );\n\n\tvec3 cp = getClosest( a2-p3.xy, b2-p3.xy, c2-p3.xy );\n\n    pos = cp.xy;\n    \n\treturn vec2( sqrt(dot(cp.xy,cp.xy)+p3.z*p3.z), cp.z );\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nfloat sdSphere( in vec3 p, in vec3 c, in float r )\n{\n    return length(p-c) - r;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/intersectors\nvec2 iCylinderY( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n    float a = dot( rd.xz, rd.xz );\n\tfloat b = dot( oc.xz, rd.xz );\n\tfloat c = dot( oc.xz, oc.xz ) - sph.w*sph.w;\n\tfloat h = b*b - a*c;\n\tif( h<0.0 ) return vec2(-1.0);\n    h = sqrt(h);\n\treturn vec2(-b-h, -b+h )\/a;\n}\n\n\/\/ https:\/\/www.shadertoy.com\/view\/llsSzn\nfloat eliSoftShadow( in vec3 ro, in vec3 rd, in vec3 sphcen, in vec3 sphrad, in float k )\n{\n    vec3 oc = ro - sphcen;\n    \n    vec3 ocn = oc \/ sphrad;\n    vec3 rdn = rd \/ sphrad;\n    \n    float a = dot( rdn, rdn );\n\tfloat b = dot( ocn, rdn );\n\tfloat c = dot( ocn, ocn );\n\tfloat h = b*b - a*(c-1.0);\n\n    float t = (-b - sqrt( max(h,0.0) ))\/a;\n\n    return (h>0.0) ? step(t,0.0) : smoothstep(0.0, 1.0, -k*h\/max(t,0.0) );\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/biplanar\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n, in float k, in vec3 g1, in vec3 g2 )\n{\n    vec3 m = pow( abs( n ), vec3(k) );\n\tvec4 x = textureGrad( sam, p.yz, g1.yz, g2.yz );\n\tvec4 y = textureGrad( sam, p.zx, g1.zx, g2.zx );\n\tvec4 z = textureGrad( sam, p.xy, g1.xy, g2.xy );\n\treturn (x*m.x + y*m.y + z*m.z) \/ (m.x + m.y + m.z);\n}\n\nfloat hash1( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nvec2 hash2( in vec2 f ) \n{ \n    float n = f.x+131.1*f.y;\n    return fract(sin(vec2(n,n+113.0))*43758.5453123); \n}\n\nvec2 hash2( float n )\n{\n    return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123));\n}\n\nvec3 hash3( float n )\n{\n    return fract(sin(n+vec3(0.0,13.1,31.3))*158.5453123);\n}\n\nvec3 forwardSF( float i, float n) \n{\n    const float PI  = 3.141592653589793238;\n    const float PHI = 1.618033988749894848;\n    float phi = 2.0*PI*fract(i\/PHI);\n    float zi = 1.0 - (2.0*i+1.0)\/n;\n    float sinTheta = sqrt( 1.0 - zi*zi);\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\n}\n\nmat3 base( in vec3 ww )\n{\n    vec3  vv = vec3(0.0,0.0,1.0);\n    vec3  uu = normalize( cross( vv, ww ) );\n    return mat3(uu.x,ww.x,vv.x,\n                uu.y,ww.y,vv.y,\n                uu.z,ww.z,vv.z);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 rt, in float cr )\n{\n\tvec3 cw = normalize(rt-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\n#define ZERO (min(iFrame,0))\n","name":"Common","description":"","type":"common"}]}];    var gUseScreenshots = piIsMobile();
    var gThemeName = "classic";



    </script>
</head>

<!-- <body onload="resultsInit(12,null,null)"> -->
<body onload="resultsInitStatic(12,null,null)">

<!-- header =================================================================================== -->


<div id="header">

    <div id="headerBlock1">
        <a href="/" id="headerTitle">Shadertoy</a>
        <form name="formSearch" action="/results" method="get" style="display:inline-block;">
        <div  id="headerSearch">
            <input type="search" id="mySearch" name="query" placeholder="Search..." value="raymarch"/>
        </div>
        </form>
    </div>

    <div id="headerBlock2">
            <a class="headerLinks" href="/browse">Browse</a>
        <a class="headerLinks" href="/new">New</a>
        <a class="headerLinks" href="/signin">Sign In</a>
        </div>
</div>
<!-- content ================================================================================== -->

<div id="content">

  <div id="controls">
    <div>
      <div style="text-align: center; vertical-align: middle; display: inline-block; padding-bottom:5px; padding-top:4px; margin-right:8px; margin-bottom:8px; margin-top:8px;">
      Sort:      </div>
      <div class="controlOptions"><a class="pageButtons" href="/results?query=raymarch&sort=popular&filter=&filter=multipass">Popular</a><a class="pageButtons" href="/results?query=raymarch&sort=newest&filter=&filter=multipass">Newest</a><div class="pageButtonsCurrent" href="/results?query=raymarch&sort=love&filter=&filter=multipass">Love</div><a class="pageButtons" href="/results?query=raymarch&sort=hot&filter=&filter=multipass">Hot</a></div>
    </div>

    <div id="controlFilter">
      <div style="display:flex;margin-right:8px;align-items:center;">Filter:</div>
      <div class="controlOptions"> <a class="pageButtonsCurrent" href="/results?query=raymarch&sort=love">Multipass</a><a class="pageButtons" href="/results?query=raymarch&sort=love&filter=soundoutput&filter=multipass">GPU Sound</a><a class="pageButtons" href="/results?query=raymarch&sort=love&filter=vr&filter=multipass">VR</a><a class="pageButtons" href="/results?query=raymarch&sort=love&filter=soundinput&filter=multipass">Microphone</a><a class="pageButtons" href="/results?query=raymarch&sort=love&filter=multipass&filter=musicstream">Soundcloud</a><a class="pageButtons" href="/results?query=raymarch&sort=love&filter=webcam&filter=multipass">Webcam</a></div>
    </div>

    <div>
        <div style="text-align: center; vertical-align: middle; display: inline-block; padding-bottom:5px; padding-top:4px; margin-right:8px; margin-bottom:8px; margin-top:8px;">
        View:</div>
        <div><a class="pageButtons" href="/slideshow?query=raymarch&sort=love">Slideshow</a></div>
    </div>

    <div class="navigation" id="navTop" ><span style="padding-right:8px;">Results (37):</span><div class="controlOptions"><a id="pageButton"0 class="pageButtons" href="results?query=raymarch&sort=love&filter=multipass&from=0&num=12">1</a><div id="pageButton"1 class="pageButtonsCurrent" href="results?query=raymarch&sort=love&filter=multipass&from=12&num=12">2</div><a id="pageButton"2 class="pageButtons" href="results?query=raymarch&sort=love&filter=multipass&from=24&num=12">3</a><a id="pageButton"3 class="pageButtons" href="results?query=raymarch&sort=love&filter=multipass&from=36&num=12">4</a><span>...</span><a id="pageButtonLast" class="pageButtons" href="results?query=raymarch&sort=love&filter=multipass&from=1044&num=12">88</a></div>
</div>
  </div>


  <div id="shaderGrid">
    <div class='searchResult'><div class='searchResultContainer' id='Preview_0_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_0_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_0_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_0_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_0_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_0_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_0_Thumnail'>        <img class='previewThumbnailImage' id='Preview_0_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_0_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_0_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_0_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_0_Info'>  <span class='previewText'  id='Preview_0_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_0_TextUser'></span>  <span class='previewStats' id='Preview_0_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_1_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_1_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_1_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_1_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_1_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_1_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_1_Thumnail'>        <img class='previewThumbnailImage' id='Preview_1_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_1_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_1_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_1_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_1_Info'>  <span class='previewText'  id='Preview_1_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_1_TextUser'></span>  <span class='previewStats' id='Preview_1_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_2_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_2_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_2_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_2_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_2_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_2_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_2_Thumnail'>        <img class='previewThumbnailImage' id='Preview_2_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_2_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_2_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_2_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_2_Info'>  <span class='previewText'  id='Preview_2_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_2_TextUser'></span>  <span class='previewStats' id='Preview_2_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_3_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_3_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_3_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_3_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_3_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_3_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_3_Thumnail'>        <img class='previewThumbnailImage' id='Preview_3_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_3_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_3_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_3_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_3_Info'>  <span class='previewText'  id='Preview_3_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_3_TextUser'></span>  <span class='previewStats' id='Preview_3_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_4_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_4_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_4_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_4_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_4_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_4_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_4_Thumnail'>        <img class='previewThumbnailImage' id='Preview_4_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_4_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_4_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_4_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_4_Info'>  <span class='previewText'  id='Preview_4_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_4_TextUser'></span>  <span class='previewStats' id='Preview_4_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_5_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_5_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_5_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_5_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_5_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_5_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_5_Thumnail'>        <img class='previewThumbnailImage' id='Preview_5_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_5_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_5_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_5_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_5_Info'>  <span class='previewText'  id='Preview_5_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_5_TextUser'></span>  <span class='previewStats' id='Preview_5_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_6_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_6_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_6_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_6_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_6_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_6_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_6_Thumnail'>        <img class='previewThumbnailImage' id='Preview_6_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_6_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_6_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_6_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_6_Info'>  <span class='previewText'  id='Preview_6_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_6_TextUser'></span>  <span class='previewStats' id='Preview_6_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_7_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_7_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_7_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_7_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_7_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_7_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_7_Thumnail'>        <img class='previewThumbnailImage' id='Preview_7_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_7_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_7_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_7_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_7_Info'>  <span class='previewText'  id='Preview_7_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_7_TextUser'></span>  <span class='previewStats' id='Preview_7_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_8_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_8_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_8_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_8_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_8_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_8_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_8_Thumnail'>        <img class='previewThumbnailImage' id='Preview_8_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_8_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_8_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_8_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_8_Info'>  <span class='previewText'  id='Preview_8_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_8_TextUser'></span>  <span class='previewStats' id='Preview_8_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_9_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_9_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_9_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_9_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_9_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_9_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_9_Thumnail'>        <img class='previewThumbnailImage' id='Preview_9_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_9_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_9_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_9_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_9_Info'>  <span class='previewText'  id='Preview_9_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_9_TextUser'></span>  <span class='previewStats' id='Preview_9_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_10_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_10_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_10_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_10_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_10_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_10_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_10_Thumnail'>        <img class='previewThumbnailImage' id='Preview_10_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_10_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_10_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_10_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_10_Info'>  <span class='previewText'  id='Preview_10_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_10_TextUser'></span>  <span class='previewStats' id='Preview_10_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_11_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_11_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_11_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_11_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_11_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_11_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_11_Thumnail'>        <img class='previewThumbnailImage' id='Preview_11_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_11_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_11_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_11_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_11_Info'>  <span class='previewText'  id='Preview_11_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_11_TextUser'></span>  <span class='previewStats' id='Preview_11_Stats'></span></div></div>  </div>
  <br>
  <div class="navigation" id="navBottom" ><span style="padding-right:8px;">Results (37):</span><div class="controlOptions"><a id="pageButton"0 class="pageButtons" href="results?query=raymarch&sort=love&filter=multipass&from=0&num=12">1</a><div id="pageButton"1 class="pageButtonsCurrent" href="results?query=raymarch&sort=love&filter=multipass&from=12&num=12">2</div><a id="pageButton"2 class="pageButtons" href="results?query=raymarch&sort=love&filter=multipass&from=24&num=12">3</a><a id="pageButton"3 class="pageButtons" href="results?query=raymarch&sort=love&filter=multipass&from=36&num=12">4</a><span>...</span><a id="pageButtonLast" class="pageButtons" href="results?query=raymarch&sort=love&filter=multipass&from=1044&num=12">88</a></div>
</div>  <br>      
</div>

<!-- footer ================================================================================== -->

<div id="footer">
    
    <div><span style="color:#ffffff;">Community Forums</span>
      <ul>
      <li><a class="regular" href="/events">Official Events</a></li>
      <li><a class="regular" href="https://www.facebook.com/groups/147749602472741">In Facebook (english)</a></li>
      <li><a class="regular" href="https://www.facebook.com/groups/1339783682699494">In Facebook (korean)</a></li>
      <li><a class="regular" href="https://discord.gg/XtmMN6E">In Discord</a> (<a class="regular" href="https://discordapp.com/channels/578696555612209173/579531723348639754">direct link</a>)</li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Feedback and Support</span>
      <ul>
      <li><a class="regular" href="https://www.facebook.com/Shadertoy">Facebook</a></li>
      <li><a class="regular" href="https://twitter.com/shadertoy">Twitter</a></li>
      <li><a class="regular" href="https://www.patreon.com/shadertoy">Patreon</a></li>
      <li><a class="regular" href="https://trello.com/b/5hM0CjId">Roadmap</a></li>

      
      </ul>
    </div>

    <div><span style="color:#ffffff;">Shadertoy</span>
      <ul>
      <li><a class="regular" href="/store">Store</a></li>
      <li><a class="regular" href="/howto">Documentation</a></li>
      <li><a class="regular" href="/terms">Terms & Privacy</a></li>
      <li><a class="regular" href="/about">About</a></li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Apps and Plugins</span>
      <ul>
      <li><a class="regular" href="https://itunes.apple.com/us/app/shadertoy/id717961814">Official iPhone App</a> by <a class="user" href="/user/reinder">Reinder</a></li>
      <li><a class="regular" href="https://steamcommunity.com/sharedfiles/filedetails/?id=1726697188">Screensaver</a> by <a class="user" href="/user/kosro">Kosro</a></li>
      <li><a class="regular" href="https://chrome.google.com/webstore/detail/shadertoy-unofficial-plug/ohicbclhdmkhoabobgppffepcopomhgl">Shadertoy plugin</a> by <a class="user" href="/user/patu">Patu</a></li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Tutorials</span>
      <ul>
      <li><a class="regular" href="https://www.youtube.com/watch?v=0ifChJ0nJfM">Shader coding intro</a> by <a class="user" href="/user/iq">iq</a></li>
      <li><a class="regular" href="https://shadertoyunofficial.wordpress.com/">Shadertoy Unofficial</a> by <a class="user" href="/user/FabriceNeyret2">FabriceNeyret2</a></li>
      </ul>
    </div>

</div>

<div id="compliance" style="padding-bottom:6px;visibility:hidden;left:0;top:0px;width:100%;background-color:rgb(200,120,20,0.93);position:absolute;color:#FFFFFF">
    <div style="text-align: center; margin-top:8px">
        We use cookies to give you the best experience on our website. If you continue using Shadertoy, we'll assume that you are happy to receive all cookies on this website. 
        For more information, please review our <a class="regular" href="/terms">Terms & Privacy</a>.
    </div> 
    <div style="text-align: center;margin-top:6px">
        <button type="button" style="width:100px;font-size:inherit" onclick="acceptCompliance()">Accept</button>
    </div>
</div>

<script>
(function runCompliance() 
{
    let showCompliance = 1;
    let allcookies = document.cookie;
    let cookiearray = allcookies.split(';');
    for (var i=0; i<cookiearray.length; i++)
    {
        let name  = cookiearray[i].split('=')[0];
        let value = cookiearray[i].split('=')[1];
        if (name.trim() == "scmp") 
        {
            showCompliance = value;
            break;
        }
    }

    if (showCompliance === 1) 
    {
        var ve = document.getElementById("compliance");
        ve.style.visibility="visible";
    }
})();

function acceptCompliance()
{
    let now = new Date();
    now.setTime( now.getTime() + (5*365*24*60*60*1000) );
    document.cookie="scmp=0;expires=" + now.toUTCString() + ";";

    var ve = document.getElementById("compliance");
    ve.style.visibility="hidden";
}
</script>

<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-44068895-1', 'shadertoy.com');
    ga('send', 'pageview');
</script></body>
</html>
