{
    "ver": "0.1",
    "info": {
        "id": "fsXcR8",
        "date": "1641828262",
        "viewed": 6608,
        "name": "On the salt lake",
        "username": "iapafoto",
        "description": "Improve a bit my red hiker. \nInspired by nguyen nhut work https:\/\/twitter.com\/nguyenhut_art\nTeapot alone: https:\/\/www.shadertoy.com\/view\/XsSGzG",
        "likes": 113,
        "published": 1,
        "flags": 0,
        "usePreview": 1,
        "tags": [
            "animation",
            "walk",
            "human",
            "bone"
        ],
        "hasliked": 0
    },
    "renderpass": [
        {
            "inputs": [
                {
                    "id": "Xsf3Rr",
                    "filepath": "\/media\/a\/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg",
                    "previewfilepath": "\/media\/ap\/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg",
                    "type": "texture",
                    "channel": 0,
                    "sampler": {
                        "filter": "mipmap",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dfGRr",
                    "channel": 0
                }
            ],
            "code": "\/\/-----------------------------------------------------\n\/\/ Created by sebastien durand - 2021\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/-----------------------------------------------------\n\/\/ inspired by nguyen nhut work https:\/\/twitter.com\/nguyenhut_art\n\/\/ Teapot alone: https:\/\/www.shadertoy.com\/view\/XsSGzG\n\/\/-----------------------------------------------------\n\n#define PI 3.14159265\n\n#define WITH_AO\n\n#define ZERO (min(0, iFrame))\n\n\n#define GROUND 0.\n#define SKIN 1.\n#define SHOES1 2.\n#define SHOES2 2.5\n#define SHORT 3.\n#define BAG 4.\n#define SHIRT 5.\n#define TEAPOT 6.\n#define BED 7.\n#define METAL 8.\n\/\/#define PANEL 9.\n#define BONE 10.\n\n#define WITH_SPIRAL\n\nfloat gTime;\n\n\/\/---------------------------------------------------------------------\n\/\/    Animation\n\/\/---------------------------------------------------------------------\n\n\/\/                       Contact           Down               Pass               Up      \n\nvec3[9] HEAD = vec3[9]( vec3(50,24,0),  vec3(73,30,0),   vec3(94,20,0),   vec3(117,15,0),  \n                        vec3(135,24,0), vec3(158,30,0),  vec3(179,20,0),  vec3(202,15,0), vec3(218,24,0));\n\nvec3[9] SHOULDER = vec3[9](vec3(44,47,16),vec3(66,53,16), vec3(91,43,16), vec3(115,38,16), \n                         vec3(136,50,16), vec3(158,55,16), vec3(176,43,16), vec3(85+111,37,16), vec3(212,47,16));\n\nvec3[9] ELBOW = vec3[9](vec3(25,64,25), vec3(46,67,25),  vec3(88,70,25),  vec3(120,65,25),\n                        vec3(139,72,25),vec3(172,67,25), vec3(176,71,25), vec3(177,61,25), vec3(193,64,25));\n\nvec3[9] WRIST = vec3[9](vec3(20,85,15), vec3(35,76,20), vec3(88,100,25), vec3(128,89,25), \n                        vec3(164,85,15), vec3(187,81,20),vec3(85+88,98,25),vec3(85+82,81,20), vec3(188,85,15));\n\nvec3[9] HIP = vec3[9](  vec3(42,90,10),  vec3(62,95,10),   vec3(83,88,10),   vec3(107,83,10),  \n                        vec3(127,92,10), vec3(147,94,10),  vec3(168,91,10),  vec3(192,85,10), vec3(210,90,10));\n\nvec3[9] KNEE = vec3[9]( vec3(29,118,7),  vec3(48,120,8),   vec3(97,117,10),  vec3(130,107,10), \n                        vec3(144,120,7), vec3(167,118,7),  vec3(167,118,7),  vec3(181,111,7), vec3(197,118,7));\n\nvec3[9] ANKLE = vec3[9](vec3(5,134,5),   vec3(22,132,6),   vec3(71,122,10),  vec3(113,127,10), \n                        vec3(162,146,5), vec3(164,146,5),  vec3(164,146,5),  vec3(168,137,5), vec3(173,134,5));\n\nvec3[9] FOOT = vec3[9]( vec3(14,150,10), vec3(16,150,10),  vec3(63,139,10),  vec3(119,143,10), \n                        vec3(178,139,10),vec3(182,150,10), vec3(182,150,10), vec3(182,150,10), vec3(182,150,10));\n\n\nvec3 shoulder1, elbow1, wrist1, head,\n     shoulder2, elbow2, wrist2;\nvec3 foot1, ankle1, knee1, hip1,\n     foot2, ankle2, knee2, hip2;\n\nmat2 rot, rot1, rot2;\n\n\n#define U(a,b) (a.x*b.y-b.x*a.y)\n\nvec2 A[15];\nvec2 T1[5];\nvec2 T2[5];\n\nfloat smin(float a, float b, float k){\n    float h = clamp(.5+.5*(b-a)\/k, 0., 1.);\n    return mix(b,a,h)-k*h*(1.-h);\n}\n\nvec2 min2(vec2 a, vec2 b) {\n    return a.x<b.x ? a : b; \n}\n\n#ifdef WITH_SPIRAL\nfloat sdSpiral(vec3 p, vec2 sz){\n    float d = length(p.xy)\/sz.x + atan(-p.y,p.x)*.5;  \n    d -= PI*clamp(round(d\/PI),1.,4.);\n    return max(sz.x*(abs(d)-.77), abs(p.z)-sz.y); \n}\n#endif\n\n\n#ifdef BONE\n\/\/ Adated from gaz [Bones] https:\/\/www.shadertoy.com\/view\/ldG3zc\nvec2 sdBone(in vec3 p) {\n\/\/return vec2(sdSpiral(p-vec3(0,.5,0), vec2(.015,.5)),BONE);\n    p.x -= 80.;\n    const float m = 200.;\n    float scale = .5 + floor(abs(p.x)\/m);\n    p.x = mod(p.x+m*.5,m)-m*.5;\n    p.xz *= rot;\n    p \/= scale;\n    p -= vec3(0.,.05,2.5);\n    float d = length(p-vec3(1.2,.2,-.35)) - .2;\n    p.y -= .2*p.x*p.x;\n    p.y *= cos(atan(.6*p.x));\n    float n = clamp(p.x,-.7,1.);\n    vec2 sg = vec2(length(p.xy-vec2(n,0)),(n+.7)\/1.7),\n         p0 = pow(abs(vec2(sg.x, p.z)), vec2(3));\n    d = smin(d,pow(p0.x+p0.y, 1.\/3.) -(.3*pow(sg.y-.5,2.)+.2), .3);\n    return vec2(.7*scale*d, BONE);\n}\n#endif\n\n\/\/ Distance to Bezier\n\/\/ inspired by [iq:https:\/\/www.shadertoy.com\/view\/ldj3Wh]\n\/\/ calculate distance to 2D bezier curve on xy but without forgeting the z component of p\n\/\/ total distance is corrected using pytagore just before return\nvec2 sdBezier(vec2 m, vec2 n, vec2 o, vec3 p) {\n\tvec2 q = p.xy;\n\tm-= q; n-= q; o-= q;\n\tfloat x = U(m, o), y = 2. * U(n, m), z = 2. * U(o, n);\n\tvec2 i = o - m, j = o - n, k = n - m, \n\t\t s = 2. * (x * i + y * j + z * k), \n\t\t r = m + (y * z - x * x) * vec2(s.y, -s.x) \/ dot(s, s);\n\tfloat t = clamp((U(r, i) + 2. * U(k, r)) \/ (x + x + y + z), 0.,1.); \/\/ parametric position on curve\n\tr = m + t * (k + k + t * (j - k)); \/\/ distance on 2D xy space\n\treturn vec2(sqrt(dot(r, r) + p.z * p.z), t); \/\/ distance on 3D space\n}\n\n\/\/-----------------------------------------------------------------------------------\n\/\/ iq - https:\/\/www.shadertoy.com\/view\/ldj3Wh\nvec2 sdBezier(in vec3 p,in vec3 b0,in vec3 b1,in vec3 b2 ) {\n    b0 -= p; b1 -= p; b2 -= p;\n    vec3 b01 = cross(b0,b1), b12 = cross(b1,b2), b20 = cross(b2,b0),\n         n =  b01+b12+b20;\n    float a = -dot(b20,n), b = -dot(b01,n), d = -dot(b12,n), m = -dot(n,n);\n    vec3  g =  (d-b)*b1 + (b+a*.5)*b2 + (-d-a*.5)*b0;\n    float t = clamp((a*.5+b-.5*(a*a*.25-b*d)*dot(g,b0-2.*b1+b2)\/dot(g,g))\/m, 0., 1.);\n    return vec2(length(mix(mix(b0,b1,t), mix(b1,b2,t),t)),t);\n}\n\n\/\/ Distance to scene\nfloat sdTeapot(vec3 p) {\n\/\/ Distance to Teapot --------------------------------------------------- \n\t\/\/ precalcul first part of teapot spout\n\tvec2 h = sdBezier(T1[2],T1[3],T1[4], p);\n\tfloat a = 99., \n    \/\/ distance to teapot handle (-.06 => make the thickness) \n\t\tb = min(min(sdBezier(T2[0],T2[1],T2[2], p).x, sdBezier(T2[2],T2[3],T2[4], p).x) - .06, \n    \/\/ max p.y-.9 => cut the end of the spout \n                max(p.y - .9,\n    \/\/ distance to second part of teapot spout (abs(dist,r1)-dr) => enable to make the spout hole \n                    min(abs(sdBezier(T1[0],T1[1],T1[2], p).x - .07) - .01, \n    \/\/ distance to first part of teapot spout (tickness incrase with pos on curve) \n                        h.x * (1. - .75 * h.y) - .08)));\n    \/\/ distance to teapot body => use rotation symetry to simplify calculation to a distance to 2D bezier curve\n    vec3 qq= vec3(sqrt(dot(p,p)-p.y*p.y), p.y, 0);\n    \/\/ the substraction of .015 enable to generate a small thickness arround bezier to help convergance\n    \/\/ the .8 factor help convergance  \n\tfor(int i=ZERO;i<13;i+=2) \n\t\ta = min(a, (sdBezier(A[i], A[i + 1], A[i + 2], qq).x - .035) * .9); \n    \/\/ smooth minimum to improve quality at junction of handle and spout to the body\n\treturn smin(a,b,.02);\n}\n\n\/\/ Interpolate pos of articulations\nvec3 getPos(vec3 arr[9], int it, float kt, float z) {\n    it = it%8;\n    vec3 p = mix(arr[it], arr[it+1], kt);\n\treturn .02*vec3(p.x+floor(gTime\/8.)*168., 150.-p.y, p.z*z);\n}\n\n\/\/---------------------------------------------------------------------\n\/\/    HASH functions (iq)\n\/\/---------------------------------------------------------------------\n\nvec2 hash22(vec2 p) {\n    p = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n    return fract(vec2(p.x * p.y * 95.4337, p.x * p.y * 97.597));\n}\n\n\/\/---------------------------------------------------------------------\n\/\/   Modeling Primitives\n\/\/   [Inigo Quilez] https:\/\/iquilezles.org\/articles\/distfunctions\n\/\/---------------------------------------------------------------------\n\nfloat sdCap(vec3 p, vec3 a, vec3 b) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)\/dot(ba,ba), 0., 1. );\n    return length( pa - ba*h );\n}\n\nfloat sdCap2(vec3 p, vec3 a, vec3 b, float r1, float r2) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa,ba)\/dot(ba,ba), 0., 1. );\n    return length( pa - ba*h ) - mix(r1,r2,h);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r ) {\n  return length(max(abs(p)-b,0.))-r;\n}\n\nfloat sdCappedCylinder(vec3 p, vec2 h ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.) + length(max(d,0.));\n}\n\n\/\/ approximated\nfloat sdEllipsoid( in vec3 p, in vec3 r ) {\n    float k0 = length(p\/r);\n    return k0*(k0-1.)\/length(p\/(r*r));\n}\n\nfloat sdEar(in vec3 p) {\n    vec3 p_ear = 1.5*p;\n    float d = max(-sdEllipsoid(p_ear-vec3(.005,.015,.02), vec3(.07,.1,.07)), \n                   sdEllipsoid(p_ear, vec3(.08,.12,.09)));\n    d = max(p_ear.z, d); \n    d = smin(d, sdEllipsoid(p_ear+vec3(.035,.045,.01), vec3(.04,.04,.018)), .01);\n    return d\/1.5;\n}\n\n\nmat3 baseArm1, baseArm2, baseBag, baseFoot1, baseFoot2;\n\nvec2 sdMan(in vec3 pos){\n    vec3 p0 = pos;\n    vec2 res = vec2(999,0);\n    \n    \/\/ Legs\n    float dSkin = min(\n        min(sdCap(pos, ankle1, knee1), \n            sdCap(pos, knee1, hip1)),\n        min(sdCap(pos, ankle2, knee2),\n            sdCap(pos, knee2, hip2)))-.1;\n            \n    \/\/ Foot1 flat part - vector base linked to leg 1\n    float dShoes1 = max(sdCap(pos, foot1, ankle1) - .15, -dot((pos-ankle1)*baseFoot1-vec3(0,0,-.13), vec3(0,0,1))); \n\n    \/\/ Leg 2\n    float dShoes2 = max(sdCap(pos, foot2, ankle2) - .15, -dot((pos-ankle2)*baseFoot2-vec3(0,0,-.13), vec3(0,0,1)));  \n    \n    vec3 ep0 = mix(shoulder1,shoulder2,.5),\n         ha0 = mix(hip1,hip2,.5);\n\n    \/\/ Head\n    vec3 h1 = vec3(0,.17,0), h2 = vec3(.02,-.11,0),\n         h = mix(h1,h2,.2);\n    dSkin = min(dSkin, sdCap(pos, head - h, head - h2)-.25);\n    \n    vec3 posHead = pos-head;\n    posHead.xz *= rot1;\n    vec3 posEar = posHead;\n    posEar.z = abs(posEar.z);\n    posEar-=vec3(0.,-.08,.29);\n    posEar.zx *= rot;\n \n     \/\/ ear \/ noze\n    dSkin = smin(dSkin, min(sdEar(posEar.zyx),\n                            sdCap(posHead, - mix(h1,h2,.4), - mix(h1,h2,.4) + vec3(.28,0,0))- .04),.02);\n    \/\/ Torso\n    vec3 a = mix(ha0,ep0,.15), b = mix(ha0,ep0,.78);\n    \n    \/\/ Neck\n    float dNeck = sdCap(pos, ep0-vec3(.08,0,0), head-vec3(.08,.1,0))- .1;\n    dSkin = smin(dSkin, dNeck,.06);\n  \n    float dTorso = smin(sdCap(pos,shoulder1,shoulder2)-.11, sdCap2(pos, a, b, .23,.28),.095);\n    dSkin = min(dSkin, dTorso);\n   \n    dTorso = smin(dTorso, sdCap(pos, shoulder1, mix(shoulder1,elbow1,.3))- .1,.05);\n\n    \/\/ Arm 1\n    dSkin = smin(dSkin, sdCap(pos, shoulder1, elbow1)- .1,.05);\n    dSkin = min(dSkin, sdCap2(pos, elbow1, wrist1-.05*normalize(wrist1-elbow1), .1, .08));\n   \n    vec3 p2 = (pos-wrist1)*baseArm1; \/\/ change to hand base\n    float d2 = sdCap(p2,vec3(-.1,.12,.04),vec3(-.04,.18,.06))-.05;\n    p2.z -= 1.5*p2.x*p2.x;\n    d2 = min(d2,sdEllipsoid(p2-vec3(.02,.05,0), vec3(.17,.14,.07)));\n\n    \/\/ Arm 2\n    dTorso = smin(dTorso, sdCap(pos, shoulder2, mix(shoulder2,elbow2,.3))- .1,.05);\n    dSkin = smin(dSkin, sdCap2(pos, shoulder2, elbow2, .11,.1),.05);\n    dSkin = min(dSkin, sdCap2(pos, elbow2, wrist2-.105*normalize(wrist2-elbow2), .1, .08));\n    \n    p2 = (pos - wrist2)*baseArm2; \/\/ change to hand base\n    d2 = min(d2,sdCap(p2,vec3(-.1,.12,.04),vec3(-.04,.18,.06))-.05);\n    p2.z -= 1.5*p2.x*p2.x;\n    d2 = min(d2,sdEllipsoid(p2-vec3(.02,.05,0), vec3(.17,.14,.07)));\n    \n   \tdSkin = smin(d2, dSkin, .1);\n\n    \/\/ Short\n    float dShort = min(sdCap(pos, hip1, mix(hip1,knee1,.7)), \n                       sdCap(pos, hip2, mix(hip2,knee2,.7)))-.14;  \n    dShort = min(dShort, smin(dShort, sdEllipsoid(pos-ha0-vec3(.01,.06,0),vec3(.23,.3,.3)), .05));\n \n    \/\/ Belt\n    vec3 p3 = p0;\n    p3.y -= ha0.y+.2;\n    float dBelt = max(max(min(dTorso-.05,dShort-.02), p3.y), -p3.y-.16);\n    dShoes1 = min(dShoes1, dBelt); \n\n    float dMetal = mix(dBelt,sdCappedCylinder((p0-ha0-vec3(.2,.11,0)).zxy, vec2(.07,.14)),.5);\n    float dNeck2 = length(pos - ep0)-.25;\n    dTorso = max(max(dTorso-.03, -dNeck2), -dSkin + .005);\n    dTorso = max(dTorso, -pos.y + a.y);\n\n    pos.x += .2;\n    pos = pos - ep0;\n    pos *= baseBag;\n    vec3 pos0 = pos;\n    \n    \/\/ Backpack\n    float ta = cos(2.8+.25*PI*gTime);\n\n    \/\/ Water\n    vec3 p = pos - vec3(-.50,-.5,-.4);\n    p.xy *= rot2;\n    dMetal = min(dMetal, min(sdCap(p,vec3(0), vec3(0,-.4-.04*ta,-.04*ta))- .1,\n                             sdCap(p,vec3(0,.1,.01*ta), vec3(0,.15,.015*ta))-.07)); \n    pos.z = abs(pos.z);\n    float dPack = sdBezier(pos, vec3(-.2,.2,.17),vec3(.9,.2,.36),vec3(-.2,-.6,.3)).x-.04;\n   \n    dPack = mix(dPack, dTorso,.2);\n\n    pos = pos0;\n  \n    float ta2 = cos(2.5+.25*PI*gTime);\n    pos.y += .15*ta2*ta2;\n    pos.z += .06*ta2*ta2*ta2;\n#ifdef WITH_SPIRAL  \n    float dBed = sdSpiral(pos-vec3(-.35-.14,.5-.16,0), vec2(.015,.5));\n#else\n    float dBed = sdCappedCylinder(pos.yzx+vec3(-.35,0,.5), vec2(.2,.5)); \n#endif     \n    \/\/ Teapot\n    vec3 posTeapot = 3.*(pos - vec3(-.9,.25,.4)).yxz;\n    posTeapot.xy *= rot2;\n    posTeapot.yz *= rot;\n    posTeapot.yx *= -1.; \n    float dTeapot = .7*sdTeapot(posTeapot-vec3(1.,-1.,0))\/3.;\n    \n    dPack = min(dPack, sdCappedCylinder(pos-vec3(-.75,.23,.26), vec2(.05,.03))); \n    pos.z = abs(pos.z);\n    dPack = min(dPack, sdCappedCylinder(pos.yzx-vec3(.35,.25,-.5), vec2(.22,.05))); \n    dPack = min(dPack, udRoundBox(pos0-vec3(-.33,-.25,-.35), vec3(.08,.1,.1),.04)); \n    dPack = smin(dPack, udRoundBox(pos0-vec3(-.33,-.2,0), vec3(.1,.3,.2), .15), .12);\n    \n    \/\/ Little box\n    dBed = min(dBed, udRoundBox(pos0-vec3(-.33,-.1,-.35), vec3(.08,.1,.1),.0)); \n    \n    \/\/ Cap\n    pos = posHead + h2;\n    float d = pos.x*.2-pos.y+.15*cos(5.*pos.z)-.12;\n    float dHat = max(sdCap(pos, vec3(0), vec3(.2,0,0))-.27, -d);\n    dHat = min(dHat, mix(dSkin, sdCappedCylinder(pos, vec2(.25,.23)),.4)-.01);      \n    dHat = max(dHat, d-.02);\n    dPack = min(dPack, dHat);\n\n    \/\/ Asssociate distance to materials\n    res = min2(res, vec2(dTeapot, TEAPOT));\n    res = min2(res, vec2(dTorso, SHIRT));\n    res = min2(res, vec2(dShort, SHORT));\n    res = min2(res, vec2(dShoes1, SHOES1));\n    res = min2(res, vec2(dShoes2, SHOES2));\n    res = min2(res, vec2(dSkin, SKIN));\n    res = min2(res, vec2(dMetal, METAL));\n    res = min2(res, vec2(dPack, BAG));\n    res = min2(res, vec2(dBed, BED));\n    \n    \/\/ Distance field is not percise for cap, teapot and hands\n    res.x *= .8;\n    return res;\n}\n\n#ifdef PANEL\n\nfloat sdFont(in vec2 p, in int c) {\n    vec2 uv = (p + vec2(float(c%16), float(15-c\/16)) + .5)\/16.;\n    return max(max(abs(p.x) - .25, max(p.y - .35, -.38 - p.y)), textureLod(iChannel1, uv, 0.).w - 127.\/255.);\n}\n\nfloat sdMessage2D(in vec2 p, int i0, in int[15] txt, in float scale) { \n    p \/= scale;\n \tfloat d = 999., w = .45; \/\/ letter width  \n    p.x += w*float(txt.length()-1)*.5; \/\/ center text arround 0\n    for (int id = i0; id<15; id++){\n        if (txt[id] == 0) break;\n    \td = min(d, sdFont(p, txt[id]));   \n    \tp.x -= w; \n    }\n    return scale*d;\n}\n\nvec2 sdPanel(vec3 p) {\n    p.x -= 300.;\n    p.z += 2.5;\n    float d = udRoundBox(p, vec3(.05,1.9,.05),.01);\n    d = min(d, udRoundBox(p-vec3(0,1.5,.07), vec3(.7,.25,.02),.01));  \n    return vec2(d, PANEL);\n}\n\n#endif\n\nvec2 map(in vec3 p0){\n    \/\/ Little stones    \n    vec2 size = vec2(35.,20.),\n         id = floor((p0.xz + size*0.5)\/size);\n    vec3 pos = p0;\n    pos.xz = mod(p0.xz + size*0.5,size) - size*0.5;\n    vec2 h = 1.-2.*hash22(id);\n    float r = .15+.25*abs(h.x),\n          d = length(pos - vec3(h.x*5.,-r*.4,7.*h.y))-r;\n    vec2 res = vec2(d,GROUND);\n#ifdef PANEL\n    res = min2(res, sdPanel(p0)); \n#endif\n#ifdef BONE\n    res = min2(res, sdBone(p0));\n#endif    \n    d = length(p0-hip1)-2.;\n    if (d<0.) {\n        return min2(sdMan(p0), res);\n    } else {    \n        return min2(vec2(d+.1,999.), res);\n    }\n}\n\n\/\/---------------------------------------------------------------------\n\/\/   Ray marching scene if ray intersect bbox\n\/\/---------------------------------------------------------------------\n\nvec2 Trace( in vec3 ro, in vec3 rd) {\n    vec2 res = vec2(999,0);\n    float t = .5;\n    for( int i=ZERO; i<128 && t<100.; i++ ) {\n        vec2 h = map( ro+rd*t);\n        if( abs(h.x)<.0005*t ) { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    return res;\n}\n\n\/\/------------------------------------------------------------------------\n\/\/ [Shane] - Desert Canyon - https:\/\/www.shadertoy.com\/view\/Xs33Df\n\/\/------------------------------------------------------------------------\n\/\/ Tri-Planar blending function. Based on an old Nvidia writeup:\n\/\/ GPU Gems 3 - Ryan Geiss: http:\/\/http.developer.nvidia.com\/GPUGems3\/gpugems3_ch01.html\nfloat tex3D(sampler2D tex, in vec3 p, in vec3 n){\n    n = max(n*n, .001);\n    n \/= (n.x + n.y + n.z );  \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).x;\n}\n\n\/\/ Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 n, float k){\n    const float ep = .001;\n    vec3 grad = vec3( tex3D(tex, vec3(p.x-ep, p.y, p.z), n),\n                      tex3D(tex, vec3(p.x, p.y-ep, p.z), n),\n                      tex3D(tex, vec3(p.x, p.y, p.z-ep), n));\n    grad = (grad - tex3D(tex, p, n))\/ep;             \n    grad -= n*dot(n, grad);          \n    return normalize(n + grad*k);\n}\n\n\/\/---------------------------------------------------------------------\n\/\/   Ambiant occlusion\n\/\/---------------------------------------------------------------------\n\n#ifdef WITH_AO\nfloat calcAO( in vec3 pos, in vec3 nor ){\n\tfloat dd, hr, sca = 1., totao = 0.;\n    vec3 aopos; \n    for( int aoi=ZERO; aoi<5; aoi++ ) {\n        hr = .01 + .05*float(aoi);\n        aopos = nor * hr + pos;\n        totao += -(map(aopos).x-hr)*sca;\n        sca *= .75;\n    }\n    return clamp(1. - 4.*totao, 0., 1.);\n}\n#endif\n\nfloat textureInvader(vec2 uv) {\n\tfloat y = 7.-floor((uv.y)*16.+4.);\n\tif (y<0. || y>7.) return 0.;\n\tfloat x = floor((abs(uv.x))*16.),\n\t      v=y>6.5? 6.:y>5.5? 40.:y>4.5? 47.:y>3.5?63.:\n\t\t\ty>2.5? 27.:y>1.5? 15.:y>0.5? 4.:8.;\n\treturn floor(mod(v\/pow(2.,x), 2.0)) == 0. ? 0.: 1.;\n}\n\nvec3 doColor(in vec3 p, in vec3 rd, in vec3 n, in vec2 res){\n    \/\/ sky dome\n    vec3 skyColor =  .5*vec3(.5, .6, .9),\n         col = skyColor - max(rd.y,0.)*.5;\n  \n    float ss = .5, sp = 0.;\n#ifdef BONE    \n    if (res.y == GROUND || res.y == BONE) {\n#else    \n    if (res.y == GROUND) {\n#endif    \n        col = .7+ .5 *vec3(texture(iChannel0,.1*p.zx).x)+p.y;\n        col.r *= .8;\n        n = doBumpMap(iChannel0, .1*p, n, .002);\n        ss = 0.;\n        sp = .3;\n    } else \n    if (res.y == SHOES1) {\n        sp = .1;\n        vec3 pFoot = (p-ankle1)*baseFoot1;\n        col = mix(vec3(.1,.1,0), vec3(0,0,.1), smoothstep(-.1,-.09,pFoot.z));\n    } else if (res.y == SHOES2) {\n        col = vec3(0,0,.1);\n        sp = .1;\n        vec3 pFoot = (p-ankle2)*baseFoot2;\n        col = mix(vec3(.1,.1,0), vec3(0,0,.1), smoothstep(-.1,-.09,pFoot.z));\n    } else if (res.y == SKIN) {\n        col = vec3(222,177,144)\/255.;\n        ss = 1.;\n        sp = .1;\n        if (p.x>head.x) {\n\t\t\t\/\/ Draw simple face\n            vec3 phead = (p - head);\n            phead.xz *= rot1;\n\t\t\tvec2 p2 = phead.zy;\n            p2.x = abs(p2.x);\n            float d = length(p2-vec2(.1,0))-.02;\n            d = min(d, max(length(p2-vec2(0.,-.18))-.05, -length(p2-vec2(0.,-.14))+.07))            ;\n            col = mix(vec3(0), col, smoothstep(.0,.01,d));\n\t\t}\n    } else if (res.y == METAL) {\n        col = vec3(.8,.9,1.);\n        sp = 2.;\n    } else if (res.y == SHORT) {\n        col = vec3(.35,.7,.85);\n    } else if (res.y == BAG) {\n\/\/        vec3 ep0 = mix(shoulder1,shoulder2,.5);\n\/\/        p.x += .2;\n\/\/        p -= ep0;\n        col = vec3(.3,.5,.2);\n\/\/        nor = doBumpMap(iChannel0, .1*(p*baseBag), nor, .002);\n        sp = .1;\n    } else if (res.y == SHIRT) {\n        col = vec3(.3,.4,.5);\n        vec2 p2 = p.zy;\n        p2.y -= mix(mix(shoulder2,shoulder1,.5),\n                    mix(hip2,hip1,.5),.5).y;\n        col *= 1.-.5*textureInvader(p2*1.9-vec2(0,.3));\n        ss = .2;\n    } else if (res.y == TEAPOT) {\n        col = vec3(1.,.01,.01);\n        sp = .5;\n    } else if (res.y == BED) {\n        col = vec3(1.,.5,.01);\n        ss = 1.;\n        sp = .3;\n    }\n#ifdef PANEL\n    else if (res.y == PANEL) {\n        col = vec3(.8,.4,.1);\n        if (p.z > -2.4) {\n            int[] gtxt = int[] (72,69,76,76,79,0,0,70,65,66,82,73,67,69,33);\n            float d = min(sdMessage2D(p.xy-vec2(300.66,1.6),0, gtxt, .3),\n                          sdMessage2D(p.xy-vec2(300.5,1.4),7, gtxt, .3));\n            col = mix(vec3(0), col, smoothstep(.0,.01,d));\n        }\n    }\n#endif\n    else {\n        return col;\n    }\n#ifdef BONE    \n    if (res.y == BONE) {\n        ss = 1.;\n        sp = 1.;\n    }\n#endif    \n    vec2 d = vec2(res.x, res.y);\n    vec3 ld = -normalize(vec3(50,100,-100)-p);\n    \/\/ IQ sss version\n    float sss = ss*0.2*clamp(0.5+0.5*dot(ld,n),0.0,1.0)*(2.0+dot(rd,n));\n    vec3 r = reflect(rd,n);\n    float diff = max(0.,dot(n,ld)),\n         amb = dot(n,ld)*.45+.55,\n         spec = pow(max(0.,dot(r,ld)),40.),\n         fres = pow(abs(.7+dot(rd,n)),3.),   \n         ao = calcAO(p, n);\n    \/\/ ligthing     \n    col = col*mix(1.2*vec3(.25,.08,.13),vec3(.984,.996,.804), mix(amb,diff,.75)) + \n          spec*sp+fres*mix(col,vec3(1),.7)*.4;\n    \/\/ kind of sub surface scatering      \n    col += sss*vec3(1.,.3,.2);\n    \/\/ sky light reflected from the ground\n    col += max(0.,dot(vec3(0,-1,0), n))*.1*skyColor;\n    \/\/ ambiant occusion\n    col *= mix(ao,1.,.5);\n    \/\/ fade in distance\n    return mix( col, skyColor, smoothstep(30.,100., res.x) );\n}\n\n\n\/\/---------------------------------------------------------------------\n\/\/   Calculate normal\n\/\/ inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n\/\/---------------------------------------------------------------------\nvec3 normal(in vec3 pos, vec3 rd, float t ) {\n    vec3 n = vec3(0);\n    for( int i=ZERO; i<4; i++) {\n        vec3 e = .5773*(2.*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.);\n        n += e*map(pos+.002*e).x;\n    }\n\treturn normalize(n - max(0., dot(n,rd ))*rd);\n}\n\n\/\/---------------------------------------------------------------------\n\/\/   Camera\n\/\/---------------------------------------------------------------------\n\nmat3 setCamera( in vec3 ro, in vec3 ta, in float r) {\n\tvec3 w = normalize(ta-ro),\n         p = vec3(sin(r), cos(r),0.),\n         u = normalize( cross(w,p) ),\n         v = normalize( cross(u,w) );\n    return mat3( u, v, w );\n}\n\n\/\/---------------------------------------------------------------------\n\/\/   Entry point\n\/\/---------------------------------------------------------------------\n\/\/#define iTime (iTime + 250.) \/\/ Direct to big Bone\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    \/\/ Teapot body profil (8 quadratic curves) \n\tA[0]=vec2(0,0);A[1]=vec2(.64,0);A[2]=vec2(.64,.03);A[3]=vec2(.8,.12);A[4]=vec2(.8,.3);A[5]=vec2(.8,.48);A[6]=vec2(.64,.9);A[7]=vec2(.6,.93);\n    A[8]=vec2(.56,.9);A[9]=vec2(.56,.96);A[10]=vec2(.12,1.02);A[11]=vec2(0,1.05);A[12]=vec2(.16,1.14);A[13]=vec2(.2,1.2);A[14]=vec2(0,1.2);\n\t\/\/ Teapot spout (2 quadratic curves)\n\tT1[0]=vec2(1.16, .96);T1[1]=vec2(1.04, .9);T1[2]=vec2(1,.72);T1[3]=vec2(.92, .48);T1[4]=vec2(.72, .42);\n\t\/\/ Teapot handle (2 quadratic curves)\n\tT2[0]=vec2(-.6, .78);T2[1]=vec2(-1.16, .84);T2[2]=vec2(-1.16,.63);T2[3]=vec2(-1.2, .42);;T2[4]=vec2(-.72, .24);\n\n    gTime = iTime*6.;\n   \n    \/\/ Animation\n    int it = int(floor(gTime));\n    float kt = fract(gTime), dz = 1.;\n   \n    head = getPos(HEAD, it, kt, dz);\n\n    shoulder1 = getPos(SHOULDER, it, kt, -dz);\n    elbow1 = getPos(ELBOW, it, kt, -dz);\n    wrist1 = getPos(WRIST, it, kt, -dz);\n    \n    foot1 = getPos(FOOT, it, kt, dz);\n    ankle1 = getPos(ANKLE, it, kt, dz);\n    knee1 = getPos(KNEE, it, kt, dz);\n    hip1 = getPos(HIP, it, kt, dz);\n    \n    shoulder2 = getPos(SHOULDER, it+4, kt, dz);\n    elbow2 = getPos(ELBOW, it+4, kt, dz);\n    wrist2 = getPos(WRIST, it+4, kt, dz);\n\n    foot2 = getPos(FOOT, it+4, kt, -dz);\n    ankle2 = getPos(ANKLE, it+4, kt, -dz);\n    knee2 = getPos(KNEE, it+4, kt, -dz);\n    hip2 = getPos(HIP, it+4, kt, -dz);\n    \n    float dx = it%8 < 4 ? -85.*.02 : 85.*.02; \n    foot2.x += dx;\n    ankle2.x += dx;\n    knee2.x += dx;\n    hip2.x += dx;\n\n    shoulder2.x += dx;\n    elbow2.x += dx;\n    wrist2.x += dx;\n    \n    vec3 v1 = normalize(wrist1-elbow1),\n    v0 = normalize(wrist1-shoulder1),\n    v3 = normalize(cross(v1,v0)),\n    v2 = cross(v1,v3);\n    baseArm1 = mat3(v0,v2,-v3);\n    \n    v1 = normalize(wrist2-elbow2),\n    v0 = normalize(wrist2-shoulder2),\n    v3 = normalize(cross(v1,v0)),\n    v2 = cross(v1,v3);\n    baseArm2 = mat3(v0,v2,v3);\n    \n    v1 = normalize(shoulder1-shoulder2);\n    v0 = normalize(mix(hip1,hip2,.5)-mix(shoulder1,shoulder2,.5));\n    v2 = normalize(cross(v1,v0));\n    v3 = normalize(cross(v1,v2));\n    baseBag = mat3(-v2,v3,v1);\n    \n    v2 = normalize(knee1 - ankle1);\n    v1 = normalize(ankle1 - foot1-v2*.1);\n    v3 = cross(v1,v2);\n    baseFoot1 = mat3(v1,v3,-cross(v1,v3));\n    \n    v2 = normalize(knee2 - ankle2);\n    v1 = normalize(ankle2 - foot2-v2*.1);\n    v3 = cross(v1,v2);\n    baseFoot2 = mat3(v1,v3,-cross(v1,v3));\n    \n    float a = -1.5708*.4;\n    rot = mat2(cos(a), sin(a), -sin(a), cos(a));\n     \n    a = .2*cos(.4*iTime) + .3*cos(.05*iTime);\n    rot1 = mat2(cos(a), sin(a), -sin(a), cos(a));\n     \n    a = .5*cos(.5*3.141592*gTime);\n    a = a*a;\n    rot2 = mat2(cos(a), sin(a), -sin(a), cos(a));\n    \n\/\/ ------------------------------------\n \n    \/\/ Screen \n    vec2 q = fragCoord.xy\/iResolution.xy, \n         m = iMouse.xy\/iResolution.y - .5,\n         p = -1.+2.*q;\n    p.x *= iResolution.x\/iResolution.y;        \n      \n    \/\/ Camera\t\n    vec3 ro = vec3(  hip1.x+12.*cos(PI*(.05*iTime+m.x)),\n                4.5+2.*(sin(.1*iTime))+4.*(m.y+.3),\n                hip1.z+12.*sin(PI*(.05*iTime+m.x)));\n    vec3 ta = hip1;\n    ta.x +=1.2;\n    ta.y = 1.2;\n    mat3 ca = setCamera(ro, ta, 0.);\n    vec3 rd = ca * normalize(vec3(p.xy,4.5) );\n  \n    \/\/ Ray intersection with scene\n    vec2 res = Trace(ro, rd);\n    if (rd.y >= 0.) {\n       res = min2(res, vec2(999.,100.));\n    } else {        \n       res = min2(res, vec2(-ro.y \/ rd.y,GROUND));\n    }\n    \n    \/\/ Rendering\n    vec3 pos = ro + rd*res.x;\n    vec3 n = pos.y<.02 ? vec3(0,1,0) : normal(pos, rd, res.x);\n    vec3 col = doColor(pos, rd, n, res);\n    col = pow( col, vec3(.4545) );                 \/\/ Gamma    \n    col *= pow(16.*q.x*q.y*(1.-q.x)*(1.-q.y), .1); \/\/ Vigneting\n     \n\tfragColor = vec4(col,1);\n}\n",
            "name": "Image",
            "description": "",
            "type": "image"
        }
    ]
}