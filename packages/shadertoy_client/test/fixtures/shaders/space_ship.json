{
    "ver": "0.1",
    "info": {
        "id": "NlsBzn",
        "date": "1650559527",
        "viewed": 3101,
        "name": "Space ship",
        "username": "A_Toaster",
        "description": "Raymarched SDF spaceship. Definitely can be improved+optimized.",
        "likes": 52,
        "published": 3,
        "flags": 0,
        "usePreview": 0,
        "tags": [
            "raymarching",
            "space"
        ],
        "hasliked": 0
    },
    "renderpass": [
        {
            "inputs": [
                {
                    "id": "4sXGRn",
                    "filepath": "\/media\/a\/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg",
                    "previewfilepath": "\/media\/ap\/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg",
                    "type": "texture",
                    "channel": 1,
                    "sampler": {
                        "filter": "mipmap",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "Xsf3zn",
                    "filepath": "\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
                    "previewfilepath": "\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
                    "type": "texture",
                    "channel": 0,
                    "sampler": {
                        "filter": "mipmap",
                        "wrap": "repeat",
                        "vflip": "false",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dfGRr",
                    "channel": 0
                }
            ],
            "code": "#define EPS 0.00002\n\n#define MAX_DIST 10.0\n\n\/\/ SHIP SDF \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \/\/ approximated\n{\n    float k0 = length(p\/r);\n    float k1 = length(p\/(r*r));\n    return k0*(k0-1.0)\/k1;\n}\n\n\/\/ vertical\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n    vec2 q = h*vec2(c.x,-c.y)\/c.y;\n    vec2 w = vec2( length(p.xz), p.y );\n    \n\tvec2 a = w - q*clamp( dot(w,q)\/dot(q,q), 0.0, 1.0 );\n    vec2 b = w - q*vec2( clamp( w.x\/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n\treturn sqrt(d)*sign(s);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)\/baba;\n    float x = sqrt( papa - paba*paba*baba );\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)\/k, 0.0, 1.0 );\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\nfloat opSubtract( float d1, float d2 ) {\n\t return max(-d1,d2); \n}\n\nvec3 opElongate(in vec3 p, in vec3 h )\n{\n    return p - clamp( p, -h, h );\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)\/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n\n}\n\nfloat shipWindows(in vec3 p) {\n    return sdRoundBox(vec3(abs(p.x) - 0.56, p.y - 0.76, p.z-0.57), vec3(0.5, 0.5, 0.5), 0.05);\n}\n\n\/\/ returns 0 for body, 1 for window\nfloat windowDeform(in vec3 p){\n\treturn 1.0 - smoothstep(0.0, 0.01, shipWindows(p));\n}\n\n\nfloat shipBody( in vec3 p) {\n\treturn opSmoothUnion(\n\t\tsdEllipsoid(p, vec3(0.3, 0.4, 0.3)),\n\t\tsdCapsule(vec3(abs(p.x), p.y, abs(p.z)), vec3(0.2, 0.0, 0.2), vec3(0.28, -0.1, 0.28), 0.015),\n\t\t0.02\n\t) + 0.01 * windowDeform(p);\n}\n\nfloat shipEngine( in vec3 p){\n\treturn opSubtract(\n\t\tsdCone(p + vec3(0.0, 0.34, 0.0), vec2(0.6, 1.0), 0.25),\n\t\tsdCone(p + vec3(0.0, 0.42, 0.0), vec2(0.40, 1.0), 0.05) - 0.07\n\t);\n}\n\n\n\/\/ ring and landing gear\nfloat shipRing( in vec3 p){\n\treturn min(\n\t\tsdTorus(opElongate(p + vec3(0, 0.05, 0), vec3(0, 0.05, 0)), vec2(0.4, 0.013)),\n\t\tsdCappedCone(vec3(abs(p.x), p.y, abs(p.z)), vec3(0.1, -0.3, 0.1), vec3(0.17, -0.5, 0.17), 0.02, 0.01)\n\t);\n}\n\n\n\n\nfloat ship(in vec3 p){\n\treturn min(\n\t\tmin(\n\t\t\tshipBody(p),\n\t\t\tshipEngine(p)\n\t\t),\n\t\tshipRing(p)\n\t);\n}\n\n\/\/ Ship map\nfloat map(in vec3 p){\n    float d2 = dot(p,p);\n    if(d2 > 1.){\n        return sqrt(d2)-0.5;\n    }\n    return ship(p.xzy); \/\/ Rotat eship so it's horizontal\n}\n\nfloat windowMat(in vec3 p) {\n    return smoothstep(-0.001, 0.0,-shipWindows(p.xzy));\n}\n\n\nfloat engineMat(in vec3 p) {\n    return smoothstep(-EPS - 0.01, -EPS, -shipEngine(p.xzy));\n}\n\n\n\/\/ Engine plume\n\/\/ returns 3D value noise - from https:\/\/iquilezles.org\/articles\/gradientnoise\/\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (i.xy+vec2(37.0,17.0)*i.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+0.5)\/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z ) - 0.5;\n    \n}\nfloat fbm( in vec3 x, in float H, in int octaves)\n{    \n    float G = exp2(-H);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i<octaves; i++ )\n    {\n        t += a*noise(f*x);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\nfloat exhaustNoise(in vec3 p, in int octaves){\n    vec3 p2 = p.xzy;\n    vec3 noise_pos = p2 * vec3(10. \/ p2.y, 2., 10. \/ p2.y) + vec3(0., 50. * iTime, 0.); \/\/ Moving origin to make exhaust move\n   \n    float strength = smoothstep(0.25, 2., -p2.y) * -p2.y * 0.1;\n    float distort = fbm(noise_pos, 1.2, octaves) * strength;\n    return distort;\n}\n\nfloat exhaust(in vec3 p, in int octaves) {\n    vec3 p2 = p.xzy + vec3(0., -0.25, 0.); \/\/ origin centered on start of exhaust\n    float distort = exhaustNoise(p, octaves);\n\n    return sdCone(p2, vec2(0.1, 1.0), 100.0) + distort;\n}\n\nvec3 exhaustNormal( in vec3 pos ) \/\/ for function f(p)\n{\n    const float h = 0.001;\n    #define ZERO (min(iFrame,0)) \/\/ non-constant zero\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*exhaust(pos+e*h, 2);\n    }\n    return normalize(n);\n}\n\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n\tfloat h = 1.0;\n    for( int i=0; i<32; i++ )\n    {\n        h = map(ro + rd*t);\n        res = min( res, k*h\/t );\n\t\tt += clamp( h, 0.005, 0.1 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\n\n\/\/ From https:\/\/iquilezles.org\/articles\/normalsSDF\/\nvec3 calcNormal( in vec3 pos ) \/\/ for function f(p)\n{\n    const float h = 0.0001;      \/\/ replace by an appropriate value\n    #define ZERO (min(iFrame,0)) \/\/ non-constant zero\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+e*h);\n    }\n    return normalize(n);\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)\/4.0;\n        float d = map( pos + h*nor );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n\nbool intersect( in vec3 ro, in vec3 rd, out float dist )\n{\n\tfloat h = 1.0;\n\tdist = 0.0;\n    for( int i=0; i<128; i++ )\n    {\n\t\tif( h < EPS * dist) return true;\n\t\th = map(ro + rd * dist);\n        dist += h;\n\t\tif( dist > MAX_DIST) return false;\n    }\n\treturn false;\n}\n\n\/\/ Often fails because of inexact SDF, but this is okay - it leads to a cool pattern in the exhaust.\nbool intersect_exhaust( in vec3 ro, in vec3 rd, out float dist )\n{\n\tfloat h = 1.0;\n\tdist = 0.0;\n    for( int i=0; i<64; i++ )\n    {\n\t\tif( h < 0.0001 * dist) return true;\n        vec3 p = ro + rd * dist;\n\t\th = exhaust(ro + rd * dist, 6);\n        dist += h * 0.9;\n\t\tif( dist > 20.) return false;\n    }\n\treturn h < 0.01;\n}\n\n\/\/ Faster, lower quality exhaust\nbool intersect_exhaust_lq( in vec3 ro, in vec3 rd, out float dist)\n{\n\tfloat h = 1.0;\n\tdist = 0.0;\n    for( int i=0; i<16; i++ )\n    {\n\t\tif( h < 0.02 * dist) return true;\n        vec3 p = ro + rd * dist;\n\t\th = exhaust(ro + rd * dist, 1);\n        dist += h * 0.9 + 0.02;\n\t\tif( dist > 50.) return false;\n    }\n\treturn false;\n}\n\n\/\/ From https:\/\/www.shadertoy.com\/view\/4slSWf\nvoid generateRay( out vec3 resRo, out vec3 resRd, in vec3 po, in vec3 ta, in vec2 pi )\n{\n\tvec2 p = (2.0*pi-iResolution.xy)\/iResolution.y;\n        \n    \/\/ camera matrix\n    vec3 ww = normalize( ta - po );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n\t\/\/ create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 2.2*ww );\n\n    resRo = po;\n    resRd = rd;\n}\n\n\nvec3 fancyCube( sampler2D sam, in vec3 d, in float s, in float b )\n{\n    vec3 colx = texture( sam, 0.5 + s*d.yz\/d.x, b ).xyz;\n    vec3 coly = texture( sam, 0.5 + s*d.zx\/d.y, b ).xyz;\n    vec3 colz = texture( sam, 0.5 + s*d.xy\/d.z, b ).xyz;\n    \n    vec3 n = d*d;\n    \n    return (colx*n.x + coly*n.y + colz*n.z)\/(n.x+n.y+n.z);\n}\n\n\nvec2 hash( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*43758.5453); }\n\nvec2 voronoi( in vec2 x )\n{\n    vec2 n = floor( x );\n    vec2 f = fract( x );\n\n\tvec3 m = vec3( 8.0 );\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2  g = vec2( float(i), float(j) );\n        vec2  o = hash( n + g );\n        vec2  r = g - f + o;\n\t\tfloat d = dot( r, r );\n        if( d<m.x )\n            m = vec3( d, o );\n    }\n\n    return vec2( sqrt(m.x), m.y+m.z );\n}\n\n\n\/\/ Background based off of https:\/\/www.shadertoy.com\/view\/llj3Rz\nvec3 background( in vec3 d, in vec3 l , in float starsize)\n{\n    vec3 col = vec3(0.0);\n         col += 0.6*pow( fancyCube( iChannel1, d, 0.05, 5.0 ).zyx, vec3(2.0) );\n         col += 1.5*vec3(0.80,0.5,0.6)*pow( fancyCube( iChannel1, d, 0.1, 0.0 ).xxx, vec3(6.0) );\n    float stars = smoothstep( 0.3, 0.7, fancyCube( iChannel1, d, 0.91, 0.0 ).x );\n\n    col = smoothstep(0.15, 0.5, col);\n    \n    vec3 n = abs(d);\n    n = n*n*n;\n    \n    vec2 vxy = voronoi( 30.0*d.xy*starsize );\n    vec2 vyz = voronoi( 30.0*d.yz*starsize );\n    vec2 vzx = voronoi( 30.0*d.zx*starsize );\n    vec2 r = (vyz*n.x + vzx*n.y + vxy*n.z) \/ (n.x+n.y+n.z);\n    col += 0.9 * stars * clamp(1.0-(3.0+r.y*5.0)*r.x,0.0,1.0);\n\n\n\n    float s = clamp( dot(d,l), 0.0, 1.0 );\n    col += 0.4*pow(s,10.0*starsize)*vec3(1.0,0.7,0.6)*2.0;\n    col += 0.4*pow(s,100.0*starsize)*vec3(1.0,0.9,0.8)*2.0;\n    \n    return col;\n}\n\nvec3 BlackBody( float t )\n{\n    const float h = 6.6e-34; \/\/ Planck constant\n    const float k = 1.4e-23; \/\/ Boltzmann constant\n    const float c = 3e8;\/\/ Speed of light\n\n    vec3 w = vec3( 610.0, 549.0, 468.0 ) \/ 1e9; \/\/ approximate wavelength of primaries\n    \n    \/\/ Planck's law https:\/\/en.wikipedia.org\/wiki\/Planck%27s_law\n    \n    vec3 w5 = w*w*w*w*w;    \n    vec3 o = 2.*h*(c*c) \/ (w5 * (exp(h*c\/(w*k*t)) - 1.0));\n\n    return o;\n}\n\nvec3 shadeExhaust(vec3 p, vec3 rd) {\n    vec3 norm = exhaustNormal(p);\n    float ndotr = dot(rd, norm);\n    float rim = pow(1.0-abs(ndotr),2.0);\n    float temp_gradient = mix(1200., 0., -p.z * 0.03);\n    float temperature = temp_gradient + smoothstep(-0.5, 0.5, -exhaustNoise(p, 8)) * 200.;\n    float thickness = (rim + 0.03) * 0.00001;\n    \n    return vec3(BlackBody(temperature) * thickness);\n}\n\n\nvec3 shadeShip(vec3 p, vec3 rd, vec3 lightDir) {\n    float window = windowMat(p);\n    float engine = engineMat(p);\n    vec3 norm = calcNormal(p);\n    float spec_strength = mix(0.6, 0.9, window);\n    spec_strength = mix(spec_strength, 0.01, engine);\n\n\tfloat ndotl = dot(norm,lightDir);\n    float ao = mix(0.6, 1.0, calcAO(p, norm));\n    float shadowAttenuation = softshadow(p + norm * EPS, lightDir, 0.01, 3.0);\n    float occ = ao * shadowAttenuation;\n\n    \n    \/\/ Diffuse\n    vec3 albedo = mix(vec3(0.9, 0.1, 0.1), vec3(0.05, 0.05, 0.05), window);\n    albedo = mix(albedo, vec3(0.05), engine);\n    \n\tvec3 light = smoothstep(-.1, 1.0, ndotl) * vec3(1.);\n\n\tvec3 col = albedo * light * occ;\n\t\n    vec3 exhaust_dir = vec3(0., 0., -1.);\n    float ndotexhaust = dot(norm, exhaust_dir);\n    light = smoothstep(-.1, 1.0, ndotexhaust) * vec3(1., 0.8, 0.2) * 15.;\n    float exhaust_occ = softshadow(p + norm * EPS, exhaust_dir, 0.001, 0.5) + 0.2;\n    \n\tcol += albedo * light * exhaust_occ;\n    \n\t\/\/ specular\n\tvec3 h = normalize(lightDir-rd);\n\tfloat s = pow(max(0.0,dot(norm,h)),50.0) * spec_strength;\n\t\n\tvec3 specular = s*vec3(1.0);\n\n\n    \/\/ Reflections\n    \/\/ I think these look too sharp on the body of the ship. \n    \/\/ Skybox reflection\n\tvec3 rr = reflect(rd, norm);\n    float rr_atten = softshadow(p + norm * EPS, rr, 0.01, 100.0);\n\tspecular += mix(albedo * occ * spec_strength, background(rr, lightDir, spec_strength), rr_atten);\n    \n    \/\/ Exhaust reflection\n    float exhaust_d;\n    bool rr_exhaust_hit = intersect_exhaust_lq(p, rr, exhaust_d);\n    if(rr_exhaust_hit){\n        specular += rr_atten * spec_strength * shadeExhaust (p + rr * exhaust_d, rr);\n    }\n\t\n\tfloat ndotr = dot(norm,rd);\n\tfloat fresnel = pow(1.0-abs(ndotr),5.0) * spec_strength;\n\tfresnel = mix(spec_strength, 1.0, fresnel );\n\n\tcol = mix( col, specular, fresnel );\n\t\n\treturn col;\n}\n\n\n\n\nvec3 encodeSRGB(vec3 linearRGB)\n{\n    vec3 a = 12.92 * linearRGB;\n    vec3 b = 1.055 * pow(linearRGB, vec3(1.0 \/ 2.4)) - 0.055;\n    vec3 c = step(vec3(0.0031308), linearRGB);\n    return mix(a, b, c);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    \/\/ camera\n    float an = 0.3*iTime;\n\tvec3  po = vec3(1.0 + 3.5*sin(an),1.0,3.5*cos(an));\n    vec3  ta = vec3(0.0,0.0,0.0);\n\n    vec3 ro,  rd;  generateRay( ro,  rd,  po, ta, fragCoord.xy );\n    \n    vec4 ship_sphere = vec4(vec3(0.), 0.6);\n    \n    vec3 col = vec3(0.0);\n\n    vec3 star_dir = normalize(vec3(1., 1., 1.));\/\/normalize(vec3(sin(0.5*iTime),2. * sin(0.34253*iTime),cos(0.5*iTime)));\n\n    \n    float dist; bool hit;\n    float exhaust_dist;\n    hit = intersect(ro, rd, dist);\n    if(hit){\n        vec3 pos = ro + dist * rd;\n        col = shadeShip(pos, rd, star_dir);\n        hit = intersect_exhaust(ro, rd, exhaust_dist);\n        if(hit && exhaust_dist < dist){\n            col += shadeExhaust(ro + rd * exhaust_dist, rd);\n        }\n    } else {\n        col = background(rd, star_dir, 1.5) * 0.5;\n        hit = intersect_exhaust(ro, rd, exhaust_dist);\n        if(hit){\n            col += shadeExhaust(ro + rd * exhaust_dist, rd);\n        }\n    }\n    \n\n    col = col * vec3(1., 1., 1.);\n    col = encodeSRGB(col);\n    \/\/ Output to screen\n    fragColor = vec4(col, 0.0);\n}",
            "name": "Image",
            "description": "",
            "type": "image"
        }
    ]
}