{
    "ver": "0.1",
    "info": {
        "id": "7lcyz8",
        "date": "1659223153",
        "viewed": 889,
        "name": "KITTIES!!",
        "username": "Xibanya",
        "description": "They love you!",
        "likes": 52,
        "published": 3,
        "flags": 0,
        "usePreview": 0,
        "tags": [
            "procedural",
            "sdf",
            "cat",
            "generator",
            "cats"
        ],
        "hasliked": 0
    },
    "renderpass": [
        {
            "inputs": [],
            "outputs": [
                {
                    "id": "4dfGRr",
                    "channel": 0
                }
            ],
            "code": "\/\/ designs inspired by https:\/\/www.freepik.com\/premium-vector\/cute-cats-collection-cats-faces_10120615.htm\n\/\/ comment this out to get four rows of procgen cats rather than 2\n#define BIGGER\n\n#ifdef GL_OES_standard_derivatives\n    #extension GL_OES_standard_derivatives : enable\n#endif\n\n\n#define PUPIL vec3(0.18, 0.17, 0.165)\n#define CAT_BASE_1 vec3(0.9, 0.77, 0.55)\n#define CAT_BASE_2 vec3(0.4, 0.37, 0.37)\n#define CAT_BASE_3 vec3(0.7, 0.6, 0.5)\n#define CAT_BASE_4 vec3(0.7, 0.6, 0.5)\n#define CAT_BASE_5 vec3(0.9, 0.9, 0.83)\n#define CAT_LIGHT_1 vec3(0.97, 0.9, 0.7)\n#define CAT_LIGHT_2 vec3(1., 0.95, 0.97)\n#define CAT_LIGHT_3 vec3(1., 0.95, 0.85) \n#define CAT_LIGHT_4 vec3(1., 0.96, 0.78)\n#define CAT_LIGHT_5 vec3(0.9, 0.9, 0.83)\n#define CAT_DARK_1 vec3(0.7, 0.5, 0.4)\n#define CAT_DARK_2 vec3(0.25, 0.2, 0.2)\n#define CAT_DARK_3 vec3(0.5, 0.4, 0.35)\n#define CAT_DARK_4 vec3(0.5, 0.4, 0.35)\n#define CAT_DARK_5 vec3(0.44, 0.37, 0.36)\n#define CAT_OUTLINE_1 vec3(0.37, 0.2, 0.13)\n#define CAT_OUTLINE_2 vec3(0.18, 0.18, 0.16)\n#define CAT_OUTLINE_3 vec3(0.35, 0.3, 0.26)\n#define CAT_OUTLINE_4 vec3(0.35, 0.3, 0.26)\n#define CAT_OUTLINE_5 vec3(0.35, 0.3, 0.26)\n#define CAT_EYE_1 vec3(1.)\n#define CAT_EYE_2 vec3(0.8, 0.76, 0.38)\n#define CAT_EYE_3 vec3(0.6, 0.86, 0.9)\n#define CAT_EYE_4 vec3(0.6, 0.86, 0.9)\n#define CAT_EYE_5 vec3(0.9)\n#define CAT_BELLY_1 vec3(0.97, 0.9, 0.7)\n#define CAT_BELLY_2 vec3(1., 0.95, 0.97)\n#define CAT_BELLY_3 vec3(0.7, 0.6, 0.5) * 1.1\n#define CAT_BELLY_4 vec3(1., 0.96, 0.78)\n#define CAT_BELLY_5 vec3(0.9, 0.9, 0.83)\n\n#define TABBY_SPOT 0.075\n\n#define MAX_ROTATION 150.\n#define MIN_ROTATION -150.\n#define MAX_EAR_DOWN 225.\n#define MAX_EAR_UP 195.\n\n#ifdef BIGGER\n    #define OUTLINE_THICKNESS 0.04\n#else\n    #define OUTLINE_THICKNESS 0.02\n#endif\n#define OUTLINE_THRESHOLD 0.7\n\nstruct Cat {\n    float butt; \/\/ width of the lower end of the body\n    float height; \/\/ body length\n    float rotation; \/\/ body rotation in degrees\n    vec3 baseColor;\n    vec3 lightColor;\n    vec3 darkColor;\n    vec3 outlineColor;\n    vec3 eyeColor;\n    vec3 belly;\n    float f; \/\/ this is to cache the FBM noise value\n    float r; \/\/ progress from min rotation value to max rotation value from 0 to 1\n    float faceDark;\n    float heart;\n    float spots;\n    float tabby;\n    int type;\n};\nmat2 Rotate2DMatrix(float a)\n{\n    float ca = cos(a);\n    float sa = sin(a);\n    return mat2(ca, -sa, sa, ca);\n}\nvec2 Rotate2D(vec2 p, float a)\n{\n    return Rotate2DMatrix(radians(a)) * p;\n}\n\/\/ Antialiased step\n\/\/ https:\/\/github.com\/glslify\/glsl-aastep\nfloat aastep(float threshold, float value) \n{\n    float afwidth = length(\n        vec2(dFdx(value), dFdy(value))) * 0.70710678118654757;\n    return smoothstep(\n        threshold - afwidth, threshold+afwidth, value); \n}\nvec3 DoOutline(float d, vec3 color, float thickness, vec3 outColor)\n{\n    if (d < 0.)\n    {\n        float t = -d \/ thickness;\n        t = t * t;\n        color = mix(outColor, color, aastep(OUTLINE_THRESHOLD, t));\n    }\n    return color;\n}\nfloat InvLerp(in float from, float to, float value)\n{\n    return (value - from) \/ (to - from);\n}\nvec2 interpolate(vec2 a, vec2 b, vec2 c, vec2 d, float p)\n{\n    vec2 v0 = mix(a, b, p);\n    vec2 v1 = mix(b, c, p);\n    vec2 v2 = mix(c, d, p);\n    vec2 v3 = mix(v0, v1, p);\n    vec2 v4 = mix(v1, v2, p);\n    \n    return mix(v3, v4, p);\n}\nfloat Spline(in vec2 p, in vec2 a, in vec2 b)\n{\n    vec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa,ba) \/ dot(ba,ba), 0., 1.);\t\n\treturn length(pa - ba * h);\n}\n\/\/ 2D SDF functions from https:\/\/iquilezles.org\/articles\/distfunctions2d\/\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat Heart( in vec2 p )\n{\n    p.x = abs(p.x);\n\n    if( p.y+p.x>1.0 )\n        return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)\/4.0;\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n                    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\nfloat UnevenCapsule( vec2 p, float r1, float r2, float h )\n{\n    p.x = abs(p.x);\n    float b = (r1-r2)\/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\nfloat EquiTriSDF(in vec2 p)\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0\/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)\/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\nfloat Isosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)\/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x\/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\nfloat Egg( in vec2 p, in float ra, in float rb )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x);\n    float r = ra - rb;\n    return ((p.y<0.0)       ? length(vec2(p.x,  p.y    )) - r :\n            (k*(p.x+r)<p.y) ? length(vec2(p.x,  p.y-k*r)) :\n                              length(vec2(p.x+r,p.y    )) - 2.0*r) - rb;\n}\nfloat Circle( vec2 p, float r )\n{\n    return length(p) - r;\n}\nfloat FBMRandom(vec2 st)\n{\n    vec2 m = vec2(iMouse.xy);\n    return fract(sin(dot(st.xy, m + vec2(12.9898, 78.233))) *\n                    43758.5453123);\n}\nCat GetCat(vec2 uv)\n{\n    \/\/ declaring the arrays outside the function doesn't work on some platforms\n    \/\/ so gotta do this rigamarole here\n    vec3[5] base;\n    base[0] = CAT_BASE_1; base[1] = CAT_BASE_2; base[2] = CAT_BASE_3; \n    base[3] = CAT_BASE_4; base[4] = CAT_BASE_5;\n\n    vec3[5] light;\n    light[0] = CAT_LIGHT_1; light[1] = CAT_LIGHT_2; light[2] = CAT_LIGHT_3; \n    light[3] = CAT_LIGHT_4; light[4] = CAT_LIGHT_5;\n\n    vec3[5] dark;\n    dark[0] = CAT_DARK_1; dark[1] = CAT_DARK_2; dark[2] = CAT_DARK_3; \n    dark[3] = CAT_DARK_4; dark[4] = CAT_DARK_5;\n\n    vec3[3] eye;\n    eye[0] = CAT_EYE_1; eye[1] = CAT_EYE_2; eye[2] = CAT_EYE_3;\n\n    vec3[5] outline;\n    outline[0] = CAT_OUTLINE_1; outline[1] = CAT_OUTLINE_2; outline[2] = CAT_OUTLINE_3; \n    outline[3] = CAT_OUTLINE_4; outline[4] = CAT_OUTLINE_5;\n\n    vec3[5] belly;\n    belly[0] = CAT_BELLY_1; belly[1] = CAT_BELLY_2;\n    belly[2] = CAT_BELLY_3; belly[3] = CAT_BELLY_4;\n    belly[4] = CAT_BELLY_5;\n\n    Cat cat;\n\n    vec2 cUV = floor(uv * 2.);\n\n    float f = clamp(0., 1., FBMRandom(cUV));\n    cat.f = f;\n    int i = 0;\n    float count = 5.;\n    float mul = 1000.;\n    float cF = fract(f + cUV.x + cUV.y * 0.5);\n    if (mod(floor(cF * mul) + 1., count) == 0.) i = 1;\n    else if (mod(floor(cF * mul) + 2., count) == 0.) i = 2; \n    else if (mod(floor(cF * mul) + 3., count) == 0.) i = 3; \n    else if (mod(floor(cF * mul) + 4., count) == 0.) i = 4;\n\n    cat.type = i;\n    \n    cat.baseColor = base[i];\n    cat.lightColor = light[i];\n    cat.darkColor = dark[i];\n    cat.outlineColor = outline[i];\n    cat.belly = belly[i];\n    cat.eyeColor = mod(floor(f * 100.), 3.) == 0.? eye[0] : \n        (mod(floor(f * 100.) + 1., 3.) == 0.? eye[1] : eye[2]);\n\n    cat.rotation = mix(MIN_ROTATION, MAX_ROTATION, fract(f + cUV.x * 0.3));\n    cat.r = InvLerp(MIN_ROTATION, MAX_ROTATION, cat.rotation);\n    cat.height = mix(0.5, 1., fract(f + 0.5 + cUV.y));\n    cat.butt = mix(0.7, 0.9, abs(f * 2. - 1.));\n   \n    cat.faceDark = mod(floor((1. - cat.f) * 5.), 4.) == 0.? 1. : 0.;\n    cat.heart = mod(floor(fract(cat.f + 0.75) * 10.), 2.) == 0.? 1. : 0.;\n    cat.spots = mod(floor(cat.f * 1450.), 2.) == 0.? 1. : 0.;\n    cat.tabby = mod(floor(fract(cat.f + 0.25) * 1329.), 3.) == 0.? 1. : 0.;\n    return cat;\n}\nfloat Smooth(float sdf) { return 1. - smoothstep(-0.025, -0.01, sdf);}\nfloat TopMarks(vec2 headUV)\n{\n    float xSign = sign(headUV.x);  \n    vec2 mUV = headUV * vec2(7., 1.) + vec2(0., 2.);\n    float markScale = 1.;\n    float mSDF = Circle(mUV, markScale);\n\n    vec2 mUV1 = Rotate2D(headUV, 16. * xSign);\n    mUV1 = mUV1 * vec2(10., 1.) + vec2(-1. * -xSign, 2.2);\n    mSDF = min(mSDF, Circle(mUV1, markScale));\n    return mSDF;\n}\nfloat HeartMark(vec2 headUV)\n{\n    vec2 heartUV = headUV * vec2(0.15, 0.2) + vec2(0., 1.05);\n    return Heart(heartUV);\n}\nvoid HeadMarkings(vec2 p, Cat cat, inout vec3 col)\n{\n    float xSign = sign(p.x);\n    vec3 light = mix(cat.lightColor * 1.1, cat.lightColor, \n        clamp(0., 1., dot(p, p)));\n    if (cat.heart == 1.)\n    {\n        float heartSDF = HeartMark(p);\n        col = heartSDF < 0.? col : light;\n    }\n   \n    if (cat.faceDark == 1.)\n    {\n        float spots = 0.;\n        vec3 sColor = cat.darkColor;\n        if (cat.spots == 1.)\n        {\n            float w =  sin(p.x * 50.) * 0.025;\n            vec2 stUV = p + vec2(1., 1.4);\n            stUV.y += w;\n            spots = Circle(stUV * vec2(1., 1.2), 1.2);\n            stUV -= vec2(2.3, 0.1);\n            spots = min(spots, Circle(Rotate2D(stUV, 25.) * vec2(1., 1.75), 0.75));\n            if (cat.heart == 0.)\n            {\n                stUV = p - vec2(0.8, 1.4);\n                stUV.y += w * 0.2;\n                stUV.x *= 0.7;\n                spots = min(spots, Circle(stUV, 0.75));\n            }\n            if (cat.tabby == 1.) sColor += TABBY_SPOT;\n        }\n        else\n        {\n            vec2 sideUV = p - vec2(1.6 * xSign, -0.9);\n            spots = Circle(sideUV, 1.5);\n        }\n         col = mix(col, sColor, Smooth(spots));\n    }\n    if (cat.tabby == 1.)\n    {\n        float mSDF = TopMarks(p);\n        col = mix(col, cat.darkColor, Smooth(mSDF));\n    }\n    if (mod(floor(cat.f * 1000.), 2.) == 0.)\n    {\n        float muzzle = Isosceles(p * 3. + vec2(0., 0.1), vec2(0.9, 1.)) - 1.;\n        col = mix(col, light, Smooth(muzzle));\n    }\n}\nvoid Eyes(vec2 headUV, Cat cat, inout vec3 col)\n{\n    float xSign = sign(headUV.x);  \n    vec2 eyeUV = headUV + vec2(0., 0.5);\n    eyeUV.x -= 0.8 * xSign;\n\n    \/\/ blinky blinky\n    float t = sin(iTime * max(0.5, cat.f) + cat.f) * 0.5 + 0.5;\n    float b = smoothstep(0., 1., InvLerp(0.999, 1., t));\n    eyeUV.y = mix(eyeUV.y, eyeUV.y * 7., b);\n\n    float eyeScale = mix(0.5, 0.55, cat.f);\n    float eyeSDF = Circle(eyeUV, eyeScale);\n    vec3 eyeCol = cat.eyeColor;\n    float pupil = Circle(eyeUV, eyeScale * 0.75);\n    eyeCol = mix(eyeCol, PUPIL, Smooth(pupil));\n    vec2 shineUV = eyeUV + vec2(0.2, 0.15);\n    float shine = Circle(shineUV, eyeScale * 0.3);\n    shine = min(shine, Circle(shineUV + vec2(0.1, -0.2), eyeScale * 0.15));\n    eyeCol = mix(eyeCol, vec3(1.), Smooth(shine));\n    vec2 lidUV = eyeUV * vec2(1., 0.95) + vec2(0., 0.05);\n    lidUV.y = mix(lidUV.y, lidUV.y * 0.95 - 0.02, b);\n    float lid = Circle(lidUV, eyeScale);\n    vec3 lidColor = cat.faceDark == 1.? cat.outlineColor : cat.darkColor;\n    eyeCol = mix(lidColor, eyeCol, Smooth(eyeSDF));\n    eyeSDF = min(eyeSDF, lid);\n    col = mix(col, eyeCol, Smooth(eyeSDF));\n}\nfloat Head(vec2 p, Cat cat, out vec3 col)\n{\n    float headHeight = cat.height * 1.2;\n    float headScale = 2.5;\n    vec2 headUV = (p - vec2(0., headHeight)) * headScale;\n    headUV = Rotate2D(headUV, -cat.rotation);\n    headUV.y *= -1.;\n    float xSign = sign(headUV.x);  \n    float headSDF = Egg(headUV, 2., 3.) + 0.1;\n    vec2 huv = headUV + vec2(0., 0.);\n    col = mix(cat.baseColor * 1.2, cat.baseColor, \n        smoothstep(0., 1.5, dot(huv, huv)));\n\n    \/\/ markings\n    HeadMarkings(headUV, cat, col);\n\n    \/\/Ears\n    vec2 earUV = headUV;\n    earUV.x -= 1.1 * xSign;\n    earUV.y += 1.1;\n    float earRot = mix(MAX_EAR_DOWN, MAX_EAR_UP, fract(cat.f * 25.));\n    float earTip = 1.;\n    if (mod(floor(cat.f * 0.35 * 1000.), 3.) == 0.) earTip = 0.75;\n    earUV = Rotate2D(earUV, earRot * xSign);\n    float ear = Egg(earUV, 2., earTip) + 1.2;\n    vec3 earColor = cat.darkColor;\n    earUV = Rotate2D(earUV, -5. * xSign);\n    float earNeg = Egg(earUV * vec2(1.1, 1.) + vec2(0.2 * xSign, 0.), 2., 1.) + 1.4;\n    earColor = mix(earColor, cat.lightColor, Smooth(earNeg));\n    col = mix(earColor, col, Smooth(headSDF));\n    headSDF = min(headSDF, ear);\n   \n    \/\/ nose\n    vec3 noseColor = cat.outlineColor;\n    float noseScale = 8.;\n    vec2 noseUV = headUV;\n   \n    float bridge = Isosceles(noseUV * noseScale + vec2(0., 2.3), \n        vec2(0.7, 2.5)) - .75;\n    vec3 bridgeCol = cat.darkColor;\n    if (cat.type == 1) bridgeCol = cat.baseColor;\n    else if (mod(floor(cat.f * 2324321.), 2.) == 0.)\n    {\n        bridgeCol = cat.baseColor * 1.1;\n    }\n    col = mix(col, bridgeCol, Smooth(bridge));\n\n    noseUV *= vec2(1., -1.);\n    noseUV.y += 0.2;\n    float noseSDF = Isosceles(noseUV * noseScale, vec2(1.1, 0.8)) - .5;\n    col = mix(col, noseColor, Smooth(noseSDF));\n\n    \/\/ Eyes\n    Eyes(headUV, cat, col);\n\n    \/\/ Mouth\n    vec2 mouthUV = headUV - vec2(0., 0.3);\n    mouthUV.x *= 0.8;\n    mouthUV.x -= 0.19 * xSign;\n    float mouthScale = 0.2;\n    float mouth = Circle(mouthUV, mouthScale);\n    mouthUV = mouthUV * vec2(1.2, 0.9) + vec2(0., 0.1);\n    mouth = max(mouth, -Circle(mouthUV, mouthScale));\n    col = mix(col, cat.outlineColor, Smooth(mouth));\n\n    \/\/ head outline before whiskers\n    col = DoOutline(headSDF, col, OUTLINE_THICKNESS * headScale, cat.outlineColor);\n\n    \/\/ whiskers\n    vec2 wUV = headUV;\n    wUV.x -= 2. * xSign;\n    wUV.y -= 1.;\n    float wScale = 1.2;\n    float whisker = Circle(wUV, wScale);\n    vec2 wUV2 = wUV * vec2(0.8, 1.) - vec2(0.1 * xSign, 0.075);\n    whisker = max(whisker, -Circle(wUV2, wScale));\n\n    wUV.x += 0.35 * xSign;\n    wUV.y -= 0.25;\n    float w2 = Circle(wUV, wScale);\n    wUV2 = wUV * vec2(0.8, 1.) + vec2(0.1 * xSign, -0.075);\n    w2 = max(w2, -Circle(wUV2, wScale));\n    whisker = min(whisker, w2);\n\n    wUV.x += 0.1 * xSign;\n    wUV.y -= 0.15;\n    w2 = Circle(wUV, wScale);\n    wUV2 = wUV * vec2(0.75, 1.) + vec2(0.2 * xSign, -0.05);\n    w2 = max(w2, -Circle(wUV2, wScale));\n    whisker = min(whisker, w2);\n\n    col = whisker < 0.? cat.outlineColor : col;\n\n    headSDF = min(headSDF, whisker);\n    return headSDF;\n}\nfloat Tail(vec2 uv, Cat cat)\n{\n    float rSign = sign(cat.rotation);\n    float xMul = cat.r * 2. - 1.;\n    float invX = 1. - abs(xMul);\n    float t = (sin(iTime * cat.f + cat.f) * 0.5 + 0.5);\n\n    vec2 a = vec2(0., 0.6);\n    vec2 b = vec2(1. * xMul * t, 1. * abs(xMul));\n    vec2 c = vec2((-0.5 + 0.5 *invX) * xMul + 1.5 * invX + t * 0.5, 1. - 0.5 * invX);\n    vec2 d = vec2((0.3 + 0.5 * invX) * xMul * t, 1.5 + 0.15 * abs(xMul) * t * 2.);\n\n    float tail = 0.;\n    const float STEPS = 20.;\n    for (float i = 0.; i < STEPS; ++i)\n    {\n        vec2  p0 = interpolate(a, b, c, d, (i   ) \/ STEPS);\n        vec2  p1 = interpolate(a, b, c, d, (i+1.) \/ STEPS);\n        float l = Spline(uv, p0, p1) - 0.1;\n        tail = min(tail, l);\n    }   \n    return tail;\n}\nvoid BackPattern(vec2 p, Cat cat, inout vec3 col)\n{\n    float r = cat.r * 2. - 1.;\n    float aR = abs(r);\n    float rSign = sign(r);\n    \n    \/\/spots\n    if ((cat.spots == 1. || cat.faceDark == 1.))\n    {\n        vec2 spotUV = p * 7.;\n        spotUV.y += mix(10., 2., aR) * rSign;\n        spotUV.x += mix(-10., -3., aR) * rSign;\n\n        \/\/ if smooth face marks, spots should also be smooth\n        if (cat.spots == 1.) spotUV.y += sin(spotUV.x * 10.) * 0.1;\n       \n        float spot = EquiTriSDF(spotUV) - 2.;\n        spot = min(spot, EquiTriSDF(spotUV * 2. + \n            vec2(10. * rSign + 10. * step(rSign, 0.), 6. + 5. * step(rSign, 0.))) - 2.);\n\n        vec3 spotColor = cat.darkColor;\n        if (cat.tabby == 1.) spotColor += TABBY_SPOT;\n        \n        col = spot < 0.? spotColor : col;\n    }\n    \n    \/\/ tabby stripes\n    if (cat.tabby == 1.)\n    {\n        float xSign = sign(p.x);\n        vec2 uv = p;\n        \n        if (rSign > 0.)\n        {\n            uv.x += mix(-2., -.05, aR);\n            uv = Rotate2D(uv, 25. * aR);\n        }\n        else if (rSign < 0.)\n        {\n            uv.x += mix(2., 0.5, aR);\n            uv = Rotate2D(uv, -50. * aR);\n        }\n        uv *= vec2(1., 8.);\n        float l = Circle(uv, 0.5);\n        l = min(l, Circle(uv + vec2(0., 1.5), 0.5));\n        l = min(l, Circle(uv - vec2(0, 1.5), 0.5));\n        col = l < 0.? cat.darkColor : col;\n    }\n}\nfloat SceneSDF(vec2 p, out vec3 col)\n{\n    Cat cat = GetCat(p);\n    p = fract(p * 2.) - 0.5;\n    #ifdef BIGGER\n    float scale = 4.;\n    p.y += 0.1;\n    #else\n     float scale = 4.5;\n    #endif\n    \n    vec2 bodyUV = p * scale;\n   \n    col = mix(cat.baseColor, cat.baseColor * 1.2, dot(bodyUV, bodyUV) * 0.5 + 0.5);\n    cat.rotation += mix(-10., 10., cos(iTime * 0.2 * cat.f + (cat.f * 2. - 1.)) * 0.5 + 0.5);\n    bodyUV = Rotate2D(bodyUV, cat.rotation);\n    float sdf = UnevenCapsule(bodyUV, cat.butt, 0.5, cat.height);\n\n    BackPattern(bodyUV, cat, col);\n\n    vec2 bellyUV = bodyUV;\n    bellyUV.y += sin(bodyUV.x * 75.) * 0.025;\n    float b = InvLerp(-90., 90., cat.rotation);\n    float bX = 0.75;\n    bellyUV.x += mix(-bX, bX, b);\n    bellyUV.y += mix(-0.1, 0.1, b);\n    float width = mix(0.7, 0.5, abs(b * 2. - 1.));\n    float belly = UnevenCapsule(bellyUV * 1.5, width, 0.5, cat.height) - 0.2;\n    col = mix(col, cat.belly, Smooth(belly));\n    col = DoOutline(sdf, col, OUTLINE_THICKNESS, cat.outlineColor);\n\n    \/\/ head casting shadow on the body\n    float shadow = Circle(bodyUV - vec2(0., cat.height * 1.1), 0.5);\n    col = shadow < 0.? col * 0.9 : col;\n\n    vec3 headCol;\n    float headSDF = Head(bodyUV, cat, headCol);\n    col = headSDF < 0.? headCol : col;\n    sdf = min(sdf, headSDF);\n\n    float tail = Tail(p * scale, cat);\n    vec3 tailCol = DoOutline(tail, cat.baseColor, OUTLINE_THICKNESS, cat.outlineColor);\n    col = sdf < 0.? col : tailCol;\n    sdf = min(sdf, tail);\n    \n    \/\/ body casting shadow on the floor\n    vec2 sUV = Rotate2D(bodyUV, -cat.rotation);\n    sUV = sUV * vec2(1., 3.) + vec2(0., 1.7);\n    shadow = Circle(sUV, 1.);\n    vec3 shadowCol = mix(vec3(1.), vec3(0.7), \n        (1. - smoothstep(-0.5, -0.001, shadow)));\n    col = sdf < 0.? col : shadowCol;\n    sdf = min(sdf, shadow);\n\n    return sdf;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)\/iResolution.y;\n    p.x += (iTime + 3000.) * 0.25;\n    #ifdef BIGGER\n        \/\/ adjusting for how it looks different in shadertoy \n        \/\/ than from VSCode where I authored this...\n        p *= 0.5;\n        p.y += 0.01;\n    #else\n        p.y += 0.025;\n    #endif\n\n    vec3 col = vec3(1.);\n    vec3 fg = vec3(0.);\n    \n    float sdf = SceneSDF(p, fg);\n    col = sdf < 0.? fg : col;\n\tfragColor = vec4(col,1.0);\n}",
            "name": "Image",
            "description": "",
            "type": "image"
        }
    ]
}