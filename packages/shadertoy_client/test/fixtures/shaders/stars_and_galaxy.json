{
    "ver": "0.1",
    "info": {
        "id": "stBcW1",
        "date": "1649601106",
        "viewed": 6046,
        "name": "Stars and galaxy",
        "username": "mrange",
        "description": "License CC0: Stars and galaxy\nBit of sunday tinkering lead to stars and a galaxy\nDidn't turn out as I envisioned but it turned out to something\nthat I liked so sharing it.",
        "likes": 127,
        "published": 3,
        "flags": 0,
        "usePreview": 0,
        "tags": [
            "2d"
        ],
        "hasliked": 0
    },
    "renderpass": [
        {
            "inputs": [],
            "outputs": [
                {
                    "id": "4dfGRr",
                    "channel": 0
                }
            ],
            "code": "\/\/ License CC0: Stars and galaxy\n\/\/ Bit of sunday tinkering lead to stars and a galaxy\n\/\/ Didn't turn out as I envisioned but it turned out to something\n\/\/ that I liked so sharing it.\n\n\/\/ Controls how many layers of stars\n#define LAYERS            5.0\n\n#define PI                3.141592654\n#define TAU               (2.0*PI)\n#define TIME              mod(iTime, 30.0)\n#define TTIME             (TAU*TIME)\n#define RESOLUTION        iResolution\n#define ROT(a)            mat2(cos(a), sin(a), -sin(a), cos(a))\n\n\/\/ License: Unknown, author: nmz (twitter: @stormoid), found: https:\/\/www.shadertoy.com\/view\/NdfyRM\nfloat sRGB(float t) { return mix(1.055*pow(t, 1.\/2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }\n\/\/ License: Unknown, author: nmz (twitter: @stormoid), found: https:\/\/www.shadertoy.com\/view\/NdfyRM\nvec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }\n\n\/\/ License: Unknown, author: Matt Taylor (https:\/\/github.com\/64), found: https:\/\/64.github.io\/tonemapping\/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))\/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n\/\/ License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  \/\/  Found this somewhere on the interwebs\n  \/\/  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)\/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n\n\/\/ License: WTFPL, author: sam hocevar, found: https:\/\/stackoverflow.com\/a\/17897228\/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 \/ 3.0, 1.0 \/ 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n\n\/\/ License: MIT OR CC-BY-NC-4.0, author: mercury, found: https:\/\/mercury.sexy\/hg_sdf\/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)\/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n\/\/ License: Unknown, author: Unknown, found: don't remember\nvec2 hash2(vec2 p) {\n  p = vec2(dot (p, vec2 (127.1, 311.7)), dot (p, vec2 (269.5, 183.3)));\n  return fract(sin(p)*43758.5453123);\n}\n\nvec2 shash2(vec2 p) {\n  return -1.0+2.0*hash2(p);\n}\n\nvec3 toSpherical(vec3 p) {\n  float r   = length(p);\n  float t   = acos(p.z\/r);\n  float ph  = atan(p.y, p.x);\n  return vec3(r, t, ph);\n}\n\n\n\/\/ License: CC BY-NC-SA 3.0, author: Stephane Cuillerdier - Aiekick\/2015 (twitter:@aiekick), found: https:\/\/www.shadertoy.com\/view\/Mt3GW2\nvec3 blackbody(float Temp) {\n  vec3 col = vec3(255.);\n  col.x = 56100000. * pow(Temp,(-3. \/ 2.)) + 148.;\n  col.y = 100.04 * log(Temp) - 623.6;\n  if (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. \/ 2.)) + 184.;\n  col.z = 194.18 * log(Temp) - 1448.6;\n  col = clamp(col, 0., 255.)\/255.;\n  if (Temp < 1000.) col *= Temp\/1000.;\n  return col;\n}\n\n\n\/\/ License: MIT, author: Inigo Quilez, found: https:\/\/www.shadertoy.com\/view\/XslGRr\nfloat noise(vec2 p) {\n  \/\/ Found at https:\/\/www.shadertoy.com\/view\/sdlXWX\n  \/\/ Which then redirected to IQ shader\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n  vec2 u = f*f*(3.-2.*f);\n  \n  float n =\n         mix( mix( dot(shash2(i + vec2(0.,0.) ), f - vec2(0.,0.)), \n                   dot(shash2(i + vec2(1.,0.) ), f - vec2(1.,0.)), u.x),\n              mix( dot(shash2(i + vec2(0.,1.) ), f - vec2(0.,1.)), \n                   dot(shash2(i + vec2(1.,1.) ), f - vec2(1.,1.)), u.x), u.y);\n\n  return 2.0*n;              \n}\n\nfloat fbm(vec2 p, float o, float s, int iters) {\n  p *= s;\n  p += o;\n\n  const float aa = 0.5;\n  const mat2 pp = 2.04*ROT(1.0);\n\n  float h = 0.0;\n  float a = 1.0;\n  float d = 0.0;\n  for (int i = 0; i < iters; ++i) {\n    d += a;\n    h += a*noise(p);\n    p += vec2(10.7, 8.3);\n    p *= pp;\n    a *= aa;\n  }\n  h \/= d;\n  \n  return h;\n}\n\nfloat height(vec2 p) {\n  float h = fbm(p, 0.0, 5.0, 5);\n  h *= 0.3;\n  h += 0.0;\n  return (h);\n}\n\nvec3 stars(vec3 ro, vec3 rd, vec2 sp, float hh) {\n  vec3 col = vec3(0.0);\n  \n  const float m = LAYERS;\n  hh = tanh_approx(20.0*hh);\n\n  for (float i = 0.0; i < m; ++i) {\n    vec2 pp = sp+0.5*i;\n    float s = i\/(m-1.0);\n    vec2 dim  = vec2(mix(0.05, 0.003, s)*PI);\n    vec2 np = mod2(pp, dim);\n    vec2 h = hash2(np+127.0+i);\n    vec2 o = -1.0+2.0*h;\n    float y = sin(sp.x);\n    pp += o*dim*0.5;\n    pp.y *= y;\n    float l = length(pp);\n  \n    float h1 = fract(h.x*1667.0);\n    float h2 = fract(h.x*1887.0);\n    float h3 = fract(h.x*2997.0);\n\n    vec3 scol = mix(8.0*h2, 0.25*h2*h2, s)*blackbody(mix(3000.0, 22000.0, h1*h1));\n\n    vec3 ccol = col + exp(-(mix(6000.0, 2000.0, hh)\/mix(2.0, 0.25, s))*max(l-0.001, 0.0))*scol;\n    col = h3 < y ? ccol : col;\n  }\n  \n  return col;\n}\n\n\/\/ License: MIT, author: Inigo Quilez, found: https:\/\/iquilezles.org\/articles\/spherefunctions\nvec2 raySphere(vec3 ro, vec3 rd, vec4 sph) {\n  vec3 oc = ro - sph.xyz;\n  float b = dot( oc, rd );\n  float c = dot( oc, oc ) - sph.w*sph.w;\n  float h = b*b - c;\n  if( h<0.0 ) return vec2(-1.0);\n  h = sqrt( h );\n  return vec2(-b - h, -b + h);\n}\n\n\nvec4 moon(vec3 ro, vec3 rd, vec2 sp, vec3 lp, vec4 md) {\n  vec2 mi = raySphere(ro, rd, md);\n  \n  vec3 p    = ro + mi.x*rd;\n  vec3 n    = normalize(p-md.xyz);\n  vec3 r    = reflect(rd, n);\n  vec3 ld   = normalize(lp - p);\n  float fre = dot(n, rd)+1.0;\n  fre = pow(fre, 15.0);\n  float dif = max(dot(ld, n), 0.0);\n  float spe = pow(max(dot(ld, r), 0.0), 8.0);\n  float i = 0.5*tanh_approx(20.0*fre*spe+0.05*dif);\n  vec3 col = blackbody(1500.0)*i+hsv2rgb(vec3(0.6, mix(0.6, 0.0, i), i));\n\n  float t = tanh_approx(0.25*(mi.y-mi.x));\n \n  return vec4(vec3(col), t);\n}\n\nvec3 sky(vec3 ro, vec3 rd, vec2 sp, vec3 lp, out float cf) {\n  float ld = max(dot(normalize(lp-ro), rd),0.0);\n  float y = -0.5+sp.x\/PI;\n  y = max(abs(y)-0.02, 0.0)+0.1*smoothstep(0.5, PI, abs(sp.y));\n  vec3 blue = hsv2rgb(vec3(0.6, 0.75, 0.35*exp(-15.0*y)));\n  float ci = pow(ld, 10.0)*2.0*exp(-25.0*y); \n  vec3 yellow = blackbody(1500.0)*ci;\n  cf = ci;\n  return blue+yellow;\n}\n\nvec3 galaxy(vec3 ro, vec3 rd, vec2 sp, out float sf) {\n  vec2 gp = sp;\n  gp *= ROT(0.67);\n  gp += vec2(-1.0, 0.5);\n  float h1 = height(2.0*sp);\n  float gcc = dot(gp, gp);\n  float gcx = exp(-(abs(3.0*(gp.x))));\n  float gcy = exp(-abs(10.0*(gp.y)));\n  float gh = gcy*gcx;\n  float cf = smoothstep(0.05, -0.2, -h1);\n  vec3 col = vec3(0.0);\n  col += blackbody(mix(300.0, 1500.0, gcx*gcy))*gcy*gcx;\n  col += hsv2rgb(vec3(0.6, 0.5, 0.00125\/gcc));\n  col *= mix(mix(0.15, 1.0, gcy*gcx), 1.0, cf);\n  sf = gh*cf;\n  return col;\n}\n\nvec3 grid(vec3 ro, vec3 rd, vec2 sp) {\n  const float m = 1.0;\n\n  const vec2 dim = vec2(1.0\/8.0*PI);\n  vec2 pp = sp;\n  vec2 np = mod2(pp, dim);\n\n  vec3 col = vec3(0.0);\n\n  float y = sin(sp.x);\n  float d = min(abs(pp.x), abs(pp.y*y));\n  \n  float aa = 2.0\/RESOLUTION.y;\n  \n  col += 2.0*vec3(0.5, 0.5, 1.0)*exp(-2000.0*max(d-0.00025, 0.0));\n  \n  return 0.25*tanh(col);\n}\n\nvec3 color(vec3 ro, vec3 rd, vec3 lp, vec4 md) {\n  vec2 sp = toSpherical(rd.xzy).yz;\n\n  float sf = 0.0;\n  float cf = 0.0;\n  vec3 col = vec3(0.0);\n\n  vec4 mcol = moon(ro, rd, sp, lp, md);\n\n  col += stars(ro, rd, sp, sf)*(1.0-tanh_approx(2.0*cf));\n  col += galaxy(ro, rd, sp, sf);\n  col = mix(col, mcol.xyz, mcol.w);\n  col += sky(ro, rd, sp, lp, cf);\n  col += grid(ro, rd, sp);\n\n  if (rd.y < 0.0)\n  {\n    col = vec3(0.0);\n  }\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord\/iResolution.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x *= RESOLUTION.x\/RESOLUTION.y;\n\n  vec3 ro = vec3(0.0, 0.0, 0.0);\n  vec3 lp = 500.0*vec3(1.0, -0.25, 0.0);\n  vec4 md = 50.0*vec4(vec3(1.0, 1., -0.6), 0.5);\n  vec3 la = vec3(1.0, 0.5, 0.0);\n  vec3 up = vec3(0.0, 1.0, 0.0);\n  la.xz *= ROT(TTIME\/60.0-PI\/2.0);\n  \n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.0*ww);\n  vec3 col= color(ro, rd, lp, md);\n  \n  col *= smoothstep(0.0, 4.0, TIME)*smoothstep(30.0, 26.0, TIME);\n  col = aces_approx(col);\n  col = sRGB(col);\n\n  fragColor = vec4(col,1.0);\n}\n\n",
            "name": "Image",
            "description": "",
            "type": "image"
        }
    ]
}