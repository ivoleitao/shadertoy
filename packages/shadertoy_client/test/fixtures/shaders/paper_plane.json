{
    "ver": "0.1",
    "info": {
        "id": "tstczS",
        "date": "1639409611",
        "viewed": 8997,
        "name": "Paper Plane",
        "username": "zduny",
        "description": "Prototype of my mobile game:\n[url]https:\/\/play.google.com\/store\/apps\/details?id=com.zduny.paperplane[\/url]\n\nControls: \nSPACE to start\nLEFT ARROW and RIGHT ARROW - control the plane",
        "likes": 92,
        "published": 3,
        "flags": 48,
        "usePreview": 0,
        "tags": [
            "game",
            "interactive",
            "text",
            "origami"
        ],
        "hasliked": 0
    },
    "renderpass": [
        {
            "inputs": [
                {
                    "id": "4dXGzr",
                    "filepath": "\/media\/a\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png",
                    "previewfilepath": "\/media\/ap\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png",
                    "type": "texture",
                    "channel": 2,
                    "sampler": {
                        "filter": "mipmap",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "XsXGR8",
                    "filepath": "\/media\/previz\/buffer01.png",
                    "previewfilepath": "\/media\/previz\/buffer01.png",
                    "type": "buffer",
                    "channel": 1,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dfGRr",
                    "channel": 0
                }
            ],
            "code": "INCLUDE_TEXTURE_GRID_WIDTH\nINCLUDE_GAME_CONSTANTS\nINCLUDE_STATE_STRUCT\nINCLUDE_STATE_LOAD_FUNCTION\n\nconst bool showTexture = false;\n\nconst vec3 background = vec3(0.454, 0.672, 0.984);\n\nconst float aspectRatio = 8.0 \/ 16.0;\nconst float top = 1.0 \/ aspectRatio;\n\nState state;\nvec3 letterColor;\n\nvec4 blend(in vec4 under, in vec4 over) {\n  vec4 result = mix(under, over, over.a);\n  result.a = over.a + under.a * (1.0 - over.a);\n    \n  return result;\n}\n\nvec2 fixUv(in vec2 uv) {\n  uv = clamp(uv, 0.0, 1.0);\n  uv.x *= iResolution.y \/ iResolution.x;\n  return uv;\n}\n\nvec4 getPipeTexture(in vec2 uv) {\n  return texture(iChannel1, fixUv(uv) \/ float(textureGridWidth));\n}\n\nvec4 getPlaneTexture(in float angle, in vec2 uv) {\n  float total = float(textureGridWidth * textureGridWidth - 2);  \n  float i = round((angle + 0.5) * total + 1.0);\n  \n  uv = fixUv(uv);\n  uv.x += iResolution.y \/ iResolution.x * mod(i, float(textureGridWidth));\n  uv.y += floor(i \/ float(textureGridWidth));\n  \n  return texture(iChannel1, uv \/ float(textureGridWidth));\n}\n\nvoid drawLetter(inout vec4 fragColor, in vec2 fragCoord, \n                in vec2 position, in vec2 size, in int code) {\n  vec2 uv = fragCoord - position;\n  uv += size * 0.5;\n  uv \/= size;\n  \n  if (uv.x > 0.0 && uv.x < 1.0 && uv.y > 0.0 && uv.y < 1.0) {\n    uv.x += float(code % 16);\n    uv.y += float(15 - code \/ 16);\n    \n    uv *= 0.0625;\n    \n    float sd = abs(texture(iChannel2, uv).a);\n    fragColor = blend(fragColor, \n      vec4(vec3(0.0), smoothstep(0.0, 1.0, (0.55 - sd) * 50.0)));\n    fragColor = blend(fragColor, \n      vec4(letterColor, smoothstep(0.0, 1.0, (0.51 - sd) * 50.0)));\n  }\n}\n\nfloat elasticOut(float t) {\n  return sin(-13.0 * (t + 1.0) * 3.1416 * 0.5) * pow(2.0, -10.0 * t) + 1.0;\n}\n\nfloat cubicIn(float t) {\n  return t * t * t;\n}\n\nfloat cubicOut(float t) {\n  float f = t - 1.0;\n  return f * f * f + 1.0;\n}\n\nconst float HALF_PI = 3.1416 * 0.5;\nfloat elasticInOut(float t) {\n  return t < 0.5\n    ? 0.5 * sin(+13.0 * HALF_PI * 2.0 * t) * pow(2.0, 10.0 * (2.0 * t - 1.0))\n    : 0.5 * sin(-13.0 * HALF_PI * ((2.0 * t - 1.0) + 1.0)) * pow(2.0, -10.0 * (2.0 * t - 1.0)) + 1.0;\n}\n\nvoid drawPipes(inout vec4 fragColor, in vec2 fragCoord, \n               in vec2 position, in float gap) {   \n  float size = pipeSize;\n\n  vec2 uv = fragCoord - position;\n  if (uv.x > 0.0) {\n    uv.x *= -1.0;\n  }\n  uv += size * 0.5;\n  uv.x += size * 0.21 + gap;\n  uv \/= size;\n  \n  fragColor = blend(fragColor, getPipeTexture(uv));\n}\n\nvoid drawAllPipes(inout vec4 fragColor, in vec2 fragCoord) {\n  vec4 outColor = fragColor;\n\n  for (int i = 0; i < pipesCount; i++) {\n    Gap gap = state.gaps[i];\n    vec2 position = vec2(gap.position, \n      pipesStart + state.pipesOffset + float(i) * pipesGap);\n    drawPipes(outColor, fragCoord, position, gap.size);\n  }\n  \n  float time = clamp(max(iTime, state.animationTime) * 1.5, 0.0, 1.0);\n  fragColor = mix(fragColor, outColor, cubicIn(time));\n}\n\n#define INCLUDE_DRAW_STRING_FUNCTION(name, arrayName, arrayLength)         \\\n  void name(inout vec4 fragColor, in vec2 fragCoord, float offset) {       \\\n    float size = 1.0 \/ float(arrayLength);                                 \\\n                                                                           \\\n    fragCoord.y -= top - size * (1.0 + offset) - 0.2;                      \\\n    fragCoord *= 1.08;                                                     \\\n    fragCoord.x = clamp(fragCoord.x, -1.0, 1.0);                           \\\n    fragCoord.x += 1.0;                                                    \\\n    fragCoord *= 0.5;                                                      \\\n                                                                           \\\n    int code = arrayName[int(fragCoord.x \/ size - 0.01)];                  \\\n    fragCoord.x = mod(fragCoord.x, size) - size * 0.5;                     \\\n                                                                           \\\n    drawLetter(fragColor, fragCoord, vec2(0.0), vec2(size * 1.4), code);   \\\n  }\n\nconst int paperLength = 5;\nconst int[] paperLetters = int[](80, 65, 80, 69, 82);\n\nconst int planeLength = 5;\nconst int[] planeLetters = int[](80, 76, 65, 78, 69);\n\nINCLUDE_DRAW_STRING_FUNCTION(drawPaper, paperLetters, paperLength)\nINCLUDE_DRAW_STRING_FUNCTION(drawPlane, planeLetters, planeLength)\n\nvoid drawLogo(inout vec4 fragColor, in vec2 fragCoord) {\n  if (state.animationState >= STATE_IN_GAME) {\n    return;\n  }\n\n  bool inAnimation = state.animationState <= STATE_MENU;\n  float animationTime = state.animationTime;\n  \n  float time = clamp(animationTime * 1.1, 0.0, 1.0);\n  float position = inAnimation \n    ? mix(-8.0, 0.0, elasticOut(time))\n    : mix(0.0, -8.0, cubicIn(time));\n    \n  letterColor = vec3(1.0);\n  drawPaper(fragColor, fragCoord, position - 0.5);\n  drawPlane(fragColor, fragCoord, position + 2.0);\n}\n\nvoid drawScore(inout vec4 fragColor, in vec2 fragCoord) {\n  if (state.animationState < STATE_IN_GAME && state.highScore == 0) {\n    return;\n  }\n\n  bool inAnimation = state.animationState <= STATE_MENU;\n  float animationTime = state.animationTime;\n  \n  float time = state.animationState == STATE_GAME_OVER \n    ? 1.0\n    : clamp(animationTime * (inAnimation ? 1.2 : 0.5) - 0.1, 0.0, 1.0);\n  float y = inAnimation\n    ? mix(2.0, 0.0, elasticOut(time))\n    : mix(0.0, 1.55, elasticInOut(time));\n  \n  float size = 0.27;\n  \n  int[] scoreString = int[](0, 0, 0, 0, 0, 0, 0);\n  int scoreLength = 0;\n  int score;\n  if (state.animationState <= STATE_MENU) {\n    score = state.highScore;\n  } else if (state.animationState == STATE_OUTRO && time < 0.7) {\n    score = int(mix(float(state.highScore), 0.0, clamp((time - 0.5) * 4.0, 0.0, 1.0)));\n  } else if (state.animationState == STATE_OUTRO) {\n    score = 0;\n  }else if (state.animationState >= STATE_IN_GAME) {\n    score = state.score;\n  }\n  for (int i = 0; i < 6; i++) {\n    scoreString[i] = 48 + score % 10;\n    scoreLength++;\n    score = score \/ 10;\n    if (score == 0) {\n      break;\n    }\n  }\n  \n  letterColor = \n    (state.animationState >= STATE_IN_GAME && state.score <= state.highScore) ||\n    (state.animationState == STATE_OUTRO && time > 0.5)\n    ? vec3(1.0)\n    : vec3(1.0, 1.0, 0.7);\n    \n  vec4 outColor = vec4(0.0);\n  float letterWidth = size * 0.8;\n  for (int i = 0; i < scoreLength; i++) {\n    vec2 position = vec2(0.0 + float(scoreLength - i - 1) * letterWidth, y + 0.21);\n    position.x -= float(scoreLength) * 0.5 * letterWidth - letterWidth * 0.48;\n    drawLetter(outColor, fragCoord, position, vec2(size * 1.4), scoreString[i]);\n  }\n  \n  if (state.animationState == STATE_IN_GAME && state.highScore == 0) {\n    outColor.a *= cubicIn(clamp((state.animationTime - 4.0) * 3.0, 0.0, 1.0));\n  }\n  if (state.animationState == STATE_GAME_OVER && \n      state.score < 2 && \n      state.highScore == 0) {\n    outColor.a = 0.0;\n  }\n  fragColor = blend(fragColor, outColor);\n}\n\nvoid drawPaperPlaneButton(inout vec4 fragColor, in vec2 fragCoord, \n                          in vec2 position, bool shadow) {\n  vec2 size = vec2(shadow ? 0.71 : 0.68);\n  \n  position -= fragCoord;\n  position += size * 0.5;\n  \n  position \/= size;\n  float tmp = position.x;\n  position.x = 1.0 - position.y;\n  position.y = tmp;\n  \n  vec4 color = getPlaneTexture(0.0, position);\n  \n  fragColor = blend(fragColor, shadow ? vec4(vec3(0.2), color.a * 0.5) : color);\n}\n\nvoid drawPlayButton(inout vec4 fragColor, in vec2 fragCoord) {\n  if (state.animationState >= STATE_IN_GAME) {\n    return;\n  }\n\n  vec2 position = vec2(0.0, -1.0);\n  \n  bool inAnimation = state.animationState <= STATE_MENU;\n  float animationTime = state.animationTime;\n  float time = clamp(animationTime * 1.2, 0.0, 1.0);\n  \n  vec2 circlePosition = inAnimation\n    ? mix(position - vec2(0.0, 3.0), position, elasticOut(animationTime))\n    : mix(position, position - vec2(0.0, 3.0), cubicIn(animationTime));\n  \n  const float radius = 0.45;\n  float sd = distance(circlePosition, fragCoord);\n  \n  fragColor = blend(fragColor, \n    vec4(vec3(0.0), smoothstep(1.0, 0.0, (sd - radius - 0.02) * 100.0)));\n  fragColor = blend(fragColor, \n    vec4(vec3(0.0, 0.0, 0.85), smoothstep(1.0, 0.0, (sd - radius) * 100.0)));\n\n  position += vec2(0.01, 0.02);\n  \n  time = clamp(animationTime * (inAnimation ? 3.0 : 2.0), 0.0, 1.0);\n  \n  vec2 shadowPosition = inAnimation\n    ? mix(position - vec2(2.7, 0.0), position, cubicOut(time))\n    : mix(position, position + vec2(2.7, 0.0), cubicIn(time));\n  \n  if (state.isPlayPressed) {\n    position.y -= 0.025;\n  }\n  vec2 planePosition = inAnimation\n    ? mix(position - vec2(3.0, 0.0), position, cubicOut(time))\n    : mix(position, position + vec2(3.0, 0.0), cubicIn(time));\n    \n  vec4 shadow = vec4(0.0);\n  drawPaperPlaneButton(shadow, fragCoord, shadowPosition + vec2(0.0, -0.03), true);\n  shadow.a *= smoothstep(1.0, 0.0, (sd - radius - 0.02) * 100.0);\n  fragColor = blend(fragColor, shadow);\n  \n  drawPaperPlaneButton(fragColor, fragCoord, planePosition, false);\n}\n\nvoid drawPlane(inout vec4 fragColor, in vec2 fragCoord) {\n  if (state.animationState < STATE_OUTRO) {\n    return;\n  }\n  \n  vec2 size = vec2(planeSize);\n  vec2 position = state.plane.position;\n  \n  position -= fragCoord;\n  position += size * 0.5;\n  \n  position \/= size;\n  position.y = 1.0 - position.y;\n  \n  vec4 color = getPlaneTexture(state.plane.angle, position);\n  \n  fragColor = blend(fragColor, color);\n}\n\nvoid normalizeFragCoord(inout vec2 fragCoord) {\n  fragCoord -= iResolution.xy * 0.5;\n  fragCoord \/= iResolution.y * 0.5;\n  fragCoord \/= aspectRatio;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {  \n  fragColor = vec4(vec3(0.0), 1.0);\n  \n  if (showTexture) {\n    vec2 uv = fragCoord \/ iResolution.xy;\n    fragColor = vec4(background, 1.0);\n    fragColor = blend(fragColor, texture(iChannel1, uv));\n    return;\n  }\n  \n  normalizeFragCoord(fragCoord);\n  bool inFrame = abs(fragCoord.x) < 1.0;\n  if (inFrame) {\n    state = loadState(); \n    fragColor = vec4(background, 1.0);\n    drawAllPipes(fragColor, fragCoord);\n    drawLogo(fragColor, fragCoord);\n    drawPlayButton(fragColor, fragCoord);\n    drawPlane(fragColor, fragCoord);\n    drawScore(fragColor, fragCoord);\n  }\n}",
            "name": "Image",
            "description": "",
            "type": "image"
        },
        {
            "inputs": [],
            "outputs": [],
            "code": "vec3 toLinear(in vec3 color) { return pow(color, vec3(2.2)); }\nvec3 toSRGB(in vec3 color) { return pow(color, vec3(1.0 \/ 2.2)); }\n\n#define INCLUDE_TEXTURE_GRID_WIDTH                                       \\\n  const int textureGridWidth = 6;\n\n#define loadVariable(location)                                           \\\n  texelFetch(iChannel0, ivec2(location, 0), 0)\n\n#define isKeyDown(keyCode)                                               \\\n  (texelFetch(iChannel1, ivec2(keyCode, 0), 0).x > 0.0)\n \nconst int resolutionLocation = 0; \n#define INCLUDE_GAME_CONSTANTS                                           \\\n  const int pipesCount = 6;                                              \\\n  const float pipeSize = 0.5;                                            \\\n  const float pipesStart = -2.5;                                         \\\n  const float pipesGap = 1.05;                                           \\\n  const float planeMinPosition = 1.0;                                    \\\n  const float planeSize = 0.5;                                           \\\n  const float turningSpeed = 2.0;                                        \\\n  const vec2 startingPosition = vec2(-3.0, 4.0);                         \\\n  const float startingAngle = 0.5;                                       \\\n  const float startingOffset = -3.2;                                     \\\n                                                                         \\\n  const int variousLocation = 1;                                         \\\n  const int planeDataLocation = 2;                                       \\\n  const int keysLocation = 3;                                            \\\n  const int pipesLocation = 4;                                           \\\n  const int endOfData = pipesLocation + pipesCount;\n  \n#define STATE_INTRO 0\n#define STATE_MENU 1\n#define STATE_OUTRO 2\n#define STATE_IN_GAME 3\n#define STATE_GAME_OVER 4\n  \n#define INCLUDE_STATE_STRUCT                                             \\\n  struct Gap {                                                           \\\n    float position;                                                      \\\n    float size;                                                          \\\n  };                                                                     \\\n                                                                         \\\n  struct Plane {                                                         \\\n    vec2 position;                                                       \\\n    float angle;                                                         \\\n  };                                                                     \\\n                                                                         \\\n  struct State {                                                         \\\n    vec2 oldResolution;                                                  \\\n    vec2 newResolution;                                                  \\\n    Plane plane;                                                         \\\n    int animationState;                                                  \\\n    float animationTime;                                                 \\\n    float pipesOffset;                                                   \\\n    int score;                                                           \\\n    int highScore;                                                       \\\n    float traveledDistance;                                              \\\n    bool isPlayPressed;                                                  \\\n    Gap[pipesCount] gaps;                                                \\\n  };\n  \n#define INCLUDE_STATE_LOAD_FUNCTION                                      \\\n  State loadState() {                                                    \\\n    State state;                                                         \\\n                                                                         \\\n    vec4 resolutionData = loadVariable(resolutionLocation);              \\\n    state.oldResolution = resolutionData.zw;                             \\\n    state.newResolution = resolutionData.xy;                             \\\n                                                                         \\\n    vec4 planeData = loadVariable(planeDataLocation);                    \\\n                                                                         \\\n    Plane plane;                                                         \\\n    plane.position = planeData.xy;                                       \\\n    plane.angle = planeData.z;                                           \\\n                                                                         \\\n    state.plane = plane;                                                 \\\n                                                                         \\\n    vec4 variousData = loadVariable(variousLocation);                    \\\n    state.animationState = int(variousData.x);                           \\\n    state.animationTime = variousData.y;                                 \\\n    state.pipesOffset = variousData.z;                                   \\\n    state.score = int(variousData.w);                                    \\\n                                                                         \\\n    vec4 keysData = loadVariable(keysLocation);                          \\\n    state.isPlayPressed = keysData.x > 0.0;                              \\\n    state.highScore = int(keysData.y);                                   \\\n    state.traveledDistance = keysData.z;                                 \\\n                                                                         \\\n    for (int i = 0; i < pipesCount; i++) {                               \\\n      vec2 pipesData = loadVariable(pipesLocation + i).xy;               \\\n                                                                         \\\n      Gap gap;                                                           \\\n      gap.position = pipesData.x;                                        \\\n      gap.size = pipesData.y;                                            \\\n                                                                         \\\n      state.gaps[i] = gap;                                               \\\n    }                                                                    \\\n                                                                         \\\n    return state;                                                        \\\n  }\n  \n#define INCLUDE_STATE_SAVE_FUNCTION                                      \\\n  int fragmentCoordinates = 0;                                           \\\n  vec4 outputColor = vec4(0.0);                                          \\\n                                                                         \\\n  void saveState(in State state) {                                       \\\n    switch (fragmentCoordinates) {                                       \\\n      case resolutionLocation:                                           \\\n        outputColor.xy = state.newResolution;                            \\\n        outputColor.zw = state.oldResolution;                            \\\n        return;                                                          \\\n      case planeDataLocation:                                            \\\n        outputColor.xy = state.plane.position;                           \\\n        outputColor.z = state.plane.angle;                               \\\n        return;                                                          \\\n      case variousLocation:                                              \\\n        outputColor.x = float(state.animationState);                     \\\n        outputColor.y = state.animationTime;                             \\\n        outputColor.z = state.pipesOffset;                               \\\n        outputColor.w = float(state.score);                              \\\n        return;                                                          \\\n      case keysLocation:                                                 \\\n        outputColor.x = state.isPlayPressed ? 1.0 : 0.0;                 \\\n        outputColor.y = float(state.highScore);                          \\\n        outputColor.z = state.traveledDistance;                          \\\n        return;                                                          \\\n    }                                                                    \\\n                                                                         \\\n    if (fragmentCoordinates >= pipesLocation &&                          \\\n        fragmentCoordinates < endOfData) {                               \\\n      int i = fragmentCoordinates - pipesLocation;                       \\\n                                                                         \\\n      Gap gap = state.gaps[i];                                           \\\n                                                                         \\\n      outputColor.x = gap.position;                                      \\\n      outputColor.y = gap.size;                                          \\\n    }                                                                    \\\n  }     \n\n\n#define MS_STANDARD_1  vec2[](vec2(0.0))\n#define MS_STANDARD_2  vec2[](vec2(-0.25), vec2(0.25))\n#define MS_STANDARD_4  vec2[](                                           \\\n                         vec2(-0.125, -0.375), vec2(0.375, -0.125),      \\\n                         vec2(-0.375,  0.125), vec2(0.125,  0.375)       \\\n                       )\n#define MS_STANDARD_8  vec2[](                                           \\\n                         vec2( 0.0625, -0.1875), vec2(-0.0625,  0.1875), \\\n                         vec2( 0.3125,  0.0625), vec2(-0.1875, -0.3125), \\\n                         vec2(-0.3125,  0.3125), vec2(-0.4375, -0.0625), \\\n                         vec2( 0.1875,  0.4375), vec2( 0.4375, -0.4375)  \\\n                       )\n                            \n#define MS_STANDARD_16 vec2[](                                           \\\n                         vec2( 0.0625,  0.0625), vec2(-0.0625, -0.1875), \\\n                         vec2(-0.1875,  0.125 ), vec2( 0.25  , -0.0625), \\\n                         vec2(-0.3125, -0.125 ), vec2( 0.125 ,  0.3125), \\\n                         vec2( 0.3125,  0.1875), vec2( 0.1875, -0.3125), \\\n                         vec2(-0.125 ,  0.375 ), vec2( 0.0   , -0.4375), \\\n                         vec2(-0.25  , -0.375 ), vec2(-0.375 ,  0.25  ), \\\n                         vec2(-0.5   ,  0.0   ), vec2( 0.4375, -0.25  ), \\\n                         vec2( 0.375 ,  0.4375), vec2(-0.4375, -0.5   )  \\\n                       )\n                             \n#define AA_1                                                             \\\n  const int sampleCount = 1;                                             \\\n  const vec2[] samplePositions = MS_STANDARD_1;\n\n#define AA_2                                                             \\\n  const int sampleCount = 2;                                             \\\n  const vec2[] samplePositions = MS_STANDARD_2;\n\n#define AA_4                                                             \\\n  const int sampleCount = 4;                                             \\\n  const vec2[] samplePositions = MS_STANDARD_4;\n\n#define AA_8                                                             \\\n  const int sampleCount = 8;                                             \\\n  const vec2[] samplePositions = MS_STANDARD_8;\n\n#define AA_16                                                            \\\n  const int sampleCount = 16;                                            \\\n  const vec2[] samplePositions = MS_STANDARD_16;\n\n#define INCLUDE_SUPER_SAMPLE_FUNCTION(name, quality, takeSample)         \\\n  vec4 name(in vec2 fragCoord) {                                         \\\n    quality                                                              \\\n    vec4 result = vec4(0.0);                                             \\\n    for (int i = 0; i < sampleCount; i++) {                              \\\n      result += takeSample(fragCoord + samplePositions[i]);              \\\n    }                                                                    \\\n                                                                         \\\n    return result \/ float(sampleCount);                                  \\\n  }\n\n#define INCLUDE_GRID_SUPER_SAMPLE_FUNCTION(name, takeSample)             \\\n  vec4 name(in vec2 fragCoord, in int samplesSqrt) {                     \\\n    vec4 outColor = vec4(0.0);                                           \\\n    for (int x = 0; x < samplesSqrt; x++) {                              \\\n      for (int y = 0; y < samplesSqrt; y++) {                            \\\n        vec2 offset =                                                    \\\n          vec2((float(x) + 0.5) * (1.0 \/ float(samplesSqrt)) - 0.5,      \\\n               (float(y) + 0.5) * (1.0 \/ float(samplesSqrt)) - 0.5);     \\\n        vec2 samplePosition = fragCoord + offset;                        \\\n        outColor += takeSample(samplePosition);                          \\\n      }                                                                  \\\n    }                                                                    \\\n                                                                         \\\n    return outColor \/ float(samplesSqrt * samplesSqrt);                  \\\n  }",
            "name": "Common",
            "description": "",
            "type": "common"
        },
        {
            "inputs": [
                {
                    "id": "4dXGRr",
                    "filepath": "\/presets\/tex00.jpg",
                    "previewfilepath": "\/presets\/tex00.jpg",
                    "type": "keyboard",
                    "channel": 1,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dXGR8",
                    "channel": 0
                }
            ],
            "code": "INCLUDE_GAME_CONSTANTS  \nINCLUDE_STATE_STRUCT\nINCLUDE_STATE_LOAD_FUNCTION\nINCLUDE_STATE_SAVE_FUNCTION\n\n#define KEY_SPACE 32\n#define KEY_LEFT 37\n#define KEY_RIGHT 39\n\nfloat timeDelta() {\n  return iTimeDelta * 1.0;\n}\n\nfloat random(float seed) {\n  return fract(sin(seed) * 43758.5453123);\n}\n\nGap randomGap(float seed) {\n  Gap gap;\n  \n  gap.position = (random(seed) - 0.5) * 1.3;\n  gap.size = 0.2 + random(seed * 0.37) * 0.3;\n  \n  return gap;\n}\n\nvoid initPlane(inout State state) {\n  float side = random(iDate.w) < 0.5 ? -1.0 : 1.0;\n\n  Plane plane;\n  plane.position = startingPosition;\n  plane.position.x *= side;\n  plane.angle = startingAngle * side;\n  state.plane = plane;\n}\n\nState initialState() {\n  State state;\n  \n  state.oldResolution = iResolution.xy;\n  state.newResolution = iResolution.xy;\n  \n  initPlane(state);\n  \n  state.animationState = STATE_INTRO;\n  state.animationTime = 0.0;\n  state.pipesOffset = 0.0;\n  state.score = 0;\n  state.highScore = 0;\n  state.traveledDistance = 0.0;\n  \n  state.isPlayPressed = false;\n  \n  for (int i = 0; i < pipesCount; i++) {\n    state.gaps[i] = randomGap(float(i));\n  }\n  \n  return state;\n}\n\nvoid handlePlayButton(inout State state) {\n  if (state.isPlayPressed && !isKeyDown(KEY_SPACE)) {\n    state.animationState = STATE_OUTRO;\n    state.animationTime = 0.0;\n  }\n  state.isPlayPressed = isKeyDown(KEY_SPACE);\n}\n\nfloat planeFall(in Plane plane) {\n  float speed = timeDelta() * 2.0;\n  return (0.9 - pow(abs(plane.angle), 1.4)) * speed;\n}\n\nvoid movePlane(inout Plane plane) {\n  float speed = timeDelta() * 2.0;\n  plane.position.x += plane.angle * speed;\n  plane.position.y -= planeFall(plane);\n}\n\nvec2 planeHitbox(in Plane plane) {\n  float angle = plane.angle * 2.1 + 3.1416 * 0.5;\n  vec2 hitbox = plane.position - vec2(cos(angle), sin(angle)) * planeSize * 0.39;\n  hitbox.y += planeSize * 0.05;\n  return hitbox;\n}\n\nbool outOfBounds(in vec2 hitbox) {\n  return hitbox.x < -1.0 || hitbox.x > 1.0; \n}\n\nbool intersectsPipes(in vec2 hitbox, in State state) {\n  for (int i = 0; i < pipesCount; i++) {\n    Gap gap = state.gaps[i];\n    vec2 position = vec2(gap.position, \n      pipesStart + state.pipesOffset + float(i) * pipesGap);\n    float deltaY = abs(hitbox.y - position.y);\n    if (deltaY < pipeSize * 0.25) {\n      float deltaX = abs(hitbox.x - position.x);\n      if (deltaX > gap.size) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nState updateState(in State state) {\n  state.oldResolution = state.newResolution;\n  state.newResolution = iResolution.xy;\n  \n  switch (state.animationState) {\n    case STATE_INTRO:\n      if (state.score > state.highScore) {\n        state.highScore = state.score;\n      }\n      state.pipesOffset += timeDelta();\n      state.animationTime += timeDelta();\n      if (state.animationTime > 0.5) {\n        handlePlayButton(state);\n      }\n      if (state.animationTime >= 1.0) {\n        state.animationState = STATE_MENU;\n      }\n      break;\n    case STATE_MENU:\n      state.pipesOffset += timeDelta();\n      handlePlayButton(state);\n      break;\n    case STATE_OUTRO:\n      movePlane(state.plane);\n      if (state.animationTime > 0.6) {\n        if (state.animationTime < 2.5) {\n          state.pipesOffset = mix(state.pipesOffset, startingOffset, 0.05);\n        } else {\n          state.animationState = STATE_IN_GAME;\n          state.traveledDistance = 0.0;\n          state.score = 0;\n        }\n      } else {\n        state.pipesOffset += timeDelta();\n      }\n      state.animationTime += timeDelta();\n      break;\n    case STATE_IN_GAME:\n      if (isKeyDown(KEY_LEFT)) {\n        state.plane.angle -= turningSpeed * timeDelta();\n      }\n      if (isKeyDown(KEY_RIGHT)) {\n        state.plane.angle += turningSpeed * timeDelta();\n      }\n      state.plane.angle = clamp(state.plane.angle, -0.5, 0.5);\n    \n      movePlane(state.plane);\n    \n      if (state.plane.position.y < planeMinPosition) {\n        float delta = abs(state.plane.position.y - planeMinPosition);\n        state.pipesOffset += delta;\n        state.traveledDistance += delta;\n        state.plane.position.y = planeMinPosition;\n      }\n     \n      state.score = int((state.traveledDistance - 0.45) \/ pipesGap);\n      \n      vec2 hitbox = planeHitbox(state.plane); \n      if (outOfBounds(hitbox) || intersectsPipes(planeHitbox(state.plane), state)) {\n        state.animationState = STATE_GAME_OVER;\n        state.animationTime = 0.0;\n      }\n      state.animationTime += timeDelta();\n      break;\n      \n    case STATE_GAME_OVER:\n      state.animationTime += timeDelta();\n      float delta = planeFall(state.plane);\n      state.pipesOffset += delta;\n      state.plane.position.y += delta;\n      \n      if (state.animationTime > 1.0) {\n        state.animationState = STATE_INTRO;\n        state.animationTime = 0.0;\n        initPlane(state);\n      }\n      break;\n  }\n  \n  if (state.pipesOffset > pipesGap) {\n    state.pipesOffset = mod(state.pipesOffset, pipesGap);\n    for (int i = pipesCount - 1; i > 0; i--) {\n      state.gaps[i] = state.gaps[i - 1];\n    }\n    state.gaps[0] = randomGap(iTime);\n  }\n  \n  return state;\n}\n  \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  fragColor = vec4(0.0);\n  fragmentCoordinates = ivec2(fragCoord).x;\n  if (fragmentCoordinates < endOfData) {\n    if (iFrame == 0) {\n      saveState(initialState());\n    } else {\n      saveState(updateState(loadState()));\n    }\n    fragColor = outputColor;\n  }\n}\n",
            "name": "Buffer A",
            "description": "",
            "type": "buffer"
        },
        {
            "inputs": [
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "nearest",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "XsXGR8",
                    "filepath": "\/media\/previz\/buffer01.png",
                    "previewfilepath": "\/media\/previz\/buffer01.png",
                    "type": "buffer",
                    "channel": 1,
                    "sampler": {
                        "filter": "mipmap",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "XsXGR8",
                    "channel": 0
                }
            ],
            "code": "INCLUDE_TEXTURE_GRID_WIDTH\n\nconst float pi = 3.1416;\nconst float epsilon = 0.00001;\nconst vec3 right = vec3(1.0, 0.0, 0.0);\nconst vec3 up = vec3(0.0, 1.0, 0.0);\nconst vec3 forward = vec3(0.0, 0.0, -1.0);\n\nconst vec3[] points =\n    vec3[](vec3(0.0, -1.3, 0.0), vec3(-1.0, 1.0, 0.0), vec3(-0.21, 1.0, 0.0),\n           vec3(0.0, 0.92, -0.4), vec3(0.21, 1.0, 0.0), vec3(0.9, 1.0, 0.0));\nconst ivec3[] triangles =\n    ivec3[](ivec3(0, 1, 2), ivec3(2, 3, 0), ivec3(3, 4, 0), ivec3(4, 5, 0));\nconst ivec2[] lines =\n    ivec2[](ivec2(0, 1), ivec2(0, 2), ivec2(0, 3), ivec2(0, 4), ivec2(0, 5),\n            ivec2(1, 2), ivec2(2, 3), ivec2(3, 4), ivec2(4, 5));\nconst int lengthTriangles = 4;\nconst int lengthLines = 9;\n\nstruct Ray {\n  vec3 origin;\n  vec3 direction;\n};\n    \nstruct Sphere {\n  vec3 origin;\n  float radius;\n};\n    \nmat4 rotationMatrix(in vec3 axis, in float angle) {\n  axis = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n\n  return mat4(\n      oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,\n      oc * axis.z * axis.x + axis.y * s, 0.0, oc * axis.x * axis.y + axis.z * s,\n      oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, 0.0,\n      oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s,\n      oc * axis.z * axis.z + c, 0.0, 0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 translationMatrix(in vec3 translation) {\n  return mat4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0,\n              translation.x, translation.y, translation.z, 1.0);\n}\n\nRay createRayOrthographic(in vec2 screenPosition) {\n  return Ray(vec3(screenPosition, 0.0), vec3(0.0, 0.0, -1.0));\n}\n\nvec3 positionOnRay(in Ray ray, in float t) {\n  return ray.origin + ray.direction * t;\n}\n\nvoid transformRay(inout Ray ray, mat4 matrix) {\n  ray.origin = (matrix * vec4(ray.origin, 1.0)).xyz;\n  ray.direction = normalize(matrix * vec4(ray.direction, 0.0)).xyz;\n}\n\nbool rayIntersectsSphere(in Ray ray, in Sphere sphere, out float t0,\n                         out float t1) {\n  float a = dot(ray.direction, ray.direction);\n  vec3 s0_r0 = ray.origin - sphere.origin;\n  float b = 2.0 * dot(ray.direction, s0_r0);\n  float c = dot(s0_r0, s0_r0) - (sphere.radius * sphere.radius);\n  float delta = b * b - 4.0 * a * c;\n  float a_2 = 2.0 * a;\n\n  if (delta < 0.0) {\n    return false;\n  }\n\n  float delta_sqrt = sqrt(delta);\n\n  t0 = (-b - delta_sqrt) \/ a_2;\n  t1 = (-b + delta_sqrt) \/ a_2;\n\n  return true;\n}\n\nbool rayIntersectsTriangle(in Ray ray, in vec3 v0, in vec3 v1, in vec3 v2,\n                           out float t) {\n  vec3 edge1, edge2, h, s, q;\n  float a, f, u, v;\n\n  edge1 = v1 - v0;\n  edge2 = v2 - v0;\n\n  h = cross(ray.direction, edge2);\n  a = dot(edge1, h);\n\n  if (a > -epsilon && a < epsilon)\n    return false;\n\n  f = 1.0 \/ a;\n  s = ray.origin - v0;\n  u = f * dot(s, h);\n\n  if (u < 0.0 || u > 1.0)\n    return false;\n\n  q = cross(s, edge1);\n  v = f * dot(ray.direction, q);\n\n  if (v < 0.0 || u + v > 1.0)\n    return false;\n\n  \/\/ At this stage we can compute t to find out where the intersection point is\n  \/\/ on the line.\n  t = f * dot(edge2, q);\n  if (t > epsilon) \/\/ ray intersection\n  {\n    return true;\n  }\n\n  \/\/ This means that there is a line intersection but not a ray intersection.\n  return false;\n}\n\nbool rayIntersectsCylinder(in Ray ray, in vec3 pa, in vec3 pb, in float radius, \n                           out float t0, out float t1) {\n  vec3 ro = ray.origin;\n  vec3 rd = ray.direction;\n\n  vec3 cc = 0.5 * (pa + pb);\n  float ch = length(pb - pa);\n  vec3 ca = (pb - pa) \/ ch;\n  ch *= 0.5;\n\n  vec3 oc = ro - cc;\n\n  float card = dot(ca, rd);\n  float caoc = dot(ca, oc);\n\n  float a = 1.0 - card * card;\n  float b = dot(oc, rd) - caoc * card;\n  float c = dot(oc, oc) - caoc * caoc - radius * radius;\n  float h = b * b - a * c;\n  if (h < 0.0)\n    return false;\n  h = sqrt(h);\n  t0 = (-b - h) \/ a;\n  t1 = (-b + h) \/ a; \/\/ exit point\n\n  float y = caoc + t0 * card;\n\n  \/\/ body\n  if (abs(y) < ch) {\n    return true;\n  }\n\n  return false;\n}\n\nbool rayIntersectsLine(in Ray ray, in vec3 pa, in vec3 pb, in float radius, out float t) {\n  float t0, trash;\n\n  t = 100000.0;\n\n  bool i = false;\n  if (rayIntersectsSphere(ray, Sphere(pa, radius), t0, trash)) {\n    t = t0;\n    i = true;\n  }\n\n  if (rayIntersectsSphere(ray, Sphere(pb, radius), t0, trash) && t0 < t) {\n    t = t0;\n    i = true;\n  }\n\n  if (rayIntersectsCylinder(ray, pa, pb, radius, t0, trash) && t0 < t) {\n    t = t0;\n    i = true;\n  }\n\n  return i;\n}\n\n\nvec4 trace(in Ray ray, int i) {\n  vec4 color = vec4(0.0);  \n    \n  float total = float(textureGridWidth * textureGridWidth - 2);\n  float angle = float(i - 1) \/ total - 0.5;  \n    \n  mat4 transform = rotationMatrix(up, 0.0) *\n                   rotationMatrix(forward, angle * 2.2) *\n                   rotationMatrix(right, -0.6) *\n                   translationMatrix(vec3(0.0, 0.0, 12.0));\n  transformRay(ray, transform);  \n    \n  float t0 = 100000.0;\n  for (int i = 0; i < lengthTriangles; i++) {\n    ivec3 triangle = triangles[i];\n    vec3 a = points[triangle[0]];\n    vec3 b = points[triangle[1]];\n    vec3 c = points[triangle[2]];\n\n    float t;\n    if (rayIntersectsTriangle(ray, a, b, c, t) && t < t0) {\n      t0 = t - 0.0;\n      color = vec4(1.0);\n    }\n  }\n\n  for (int i = 0; i < lengthLines; i++) {\n    ivec2 line = lines[i];\n    vec3 a = points[line[0]];\n    vec3 b = points[line[1]];\n\n    float t;\n    vec3 normal;\n    if (rayIntersectsLine(ray, a, b, 0.04, t) && t < t0) {\n      t0 = t;\n      color = vec4(vec3(0.0), 1.0);\n    }\n  } \n    \n  return color;\n}\n\nvec4 drawPipe(in vec2 position) {\n  float offset = position.x < 0.0 ? 0.17 : 0.0;\n \n  if (position.x > 0.8) {\n    return vec4(0.0);\n  }\n \n  if (abs(position.y) < 0.9 - offset) {\n    if ((abs(position.y) < 0.8 - offset) && \n        !(position.x > 0.0 && position.x < 0.1) && \n        (position.x < 0.7)) {\n      float y = position.y + offset * 0.97;\n      vec3 color = vec3(0.458, 0.835, 0.184);\n      color = y > 0.57 && y < 0.73 ? vec3(0.803, 0.964, 0.505) : color;\n      color = y > 0.45 && y < 0.53 ? vec3(0.740, 0.940, 0.442) : color;\n      color = y > 0.37 && y < 0.4 ? vec3(0.658, 0.935, 0.284) : color;\n      y = position.y - offset * 0.9;\n      color = y < -0.55 && y > -0.8 ? vec3(0.380, 0.734, 0.145) : color;\n      color = y < -0.7 && y > -0.8 ? vec3(0.280, 0.634, 0.145) : color;\n      \n      return vec4(toLinear(color), 1.0);\n    }\n    \n    return vec4(toLinear(vec3(0.233, 0.227, 0.247)), 1.0);\n  }\n  \n  return vec4(0.0);\n}\n\nvec4 takeSample(in vec2 position) {\n  float size = iResolution.y \/ float(textureGridWidth);\n  ivec2 xy = ivec2(position \/ size);\n  position = mod(position, size); \n  position -= vec2(0.5 * size);\n  position \/= size * 0.33;\n    \n  int i = xy.x + xy.y * textureGridWidth;\n  if (i == 0) {\n    position *= 1.2;\n    return drawPipe(position);\n  } else {\n    Ray ray = createRayOrthographic(position);\n    return trace(ray, i);\n  }\n}\n\nbool resolutionChanged() {\n  vec4 resolutionData = loadVariable(resolutionLocation);\n  return resolutionData.xy != resolutionData.zw;\n}\n\n\nINCLUDE_SUPER_SAMPLE_FUNCTION(superSample, AA_16, takeSample)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  if (iFrame > 0 && !resolutionChanged()) {\n    vec2 uv = fragCoord \/ iResolution.xy;\n    fragColor = texture(iChannel1, uv);\n    return;\n  }   \n    \n  if (fragCoord.x > iResolution.y) {\n    fragColor = vec4(0.0);\n    return;\n  }\n    \n  fragColor = superSample(fragCoord);\n}",
            "name": "Buffer B",
            "description": "",
            "type": "buffer"
        }
    ]
}