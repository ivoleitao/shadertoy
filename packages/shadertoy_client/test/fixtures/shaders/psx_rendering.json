{
    "ver": "0.1",
    "info": {
        "id": "Mt3Gz2",
        "date": "1470515868",
        "viewed": 4691,
        "name": "PSX rendering",
        "username": "TDM",
        "description": "Lack of perspective-correct texturing, z-buffer, float data type and bilinear filtering lead to this kind of buggy rendering.",
        "likes": 66,
        "published": 3,
        "flags": 0,
        "usePreview": 0,
        "tags": [
            "barycentric",
            "rasterization",
            "playstation",
            "psx"
        ],
        "hasliked": 0
    },
    "renderpass": [
        {
            "inputs": [],
            "outputs": [
                {
                    "id": "4dfGRr",
                    "channel": 0
                }
            ],
            "code": "\/*\n\"PSX rendering\" by Alexander Alekseev aka TDM - 2016\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n*\/\n\n#define PSX_MODE\n\n#ifdef PSX_MODE\n\t#define INT_VERTICES\n\tvec2 RESOLUTION = vec2(320.0, 240.0);\n#else\n\t#define BILINEAR\n\t#define RESOLUTION iResolution.xy\n#endif\n\n\/\/ math\nfloat _cross(vec2 a, vec2 b) {\n    return a.x * b.y - a.y * b.x;\n}\nvec3 barycentric(vec2 a, vec2 b, vec2 c, vec2 p) {    \n    vec2 ab = b - a, ac = c - a, ap = p - a;\n    vec2 vw = vec2(_cross(ap,ac),_cross(ab,ap)) \/ _cross(ab,ac);\n    return vec3(1.0-vw.x-vw.y, vw);\n}\nfloat quantization(float a, float b) {\n    return floor(a * b) \/ b;\n}\nvec2 quantization(vec2 a, float b) {\n    return floor(a * b) \/ b;\n}\nvec2 quantization(vec2 a, vec2 b) {\n    return floor(a * b) \/ b;\n}\nvec3 quantization(vec3 a, float b) {\n    return floor(a * b) \/ b;\n}\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nfloat noise1(vec2 p) {\n    #ifndef BILINEAR\n\t\treturn hash(floor(p));\n    #else    \n        vec2 i = floor(p);\n        vec2 f = fract(p);\n    \tvec2 tx = mix(vec2(hash(i),hash(i+vec2(0.,1.))) ,\n                      vec2(hash(i+vec2(1.,0.)),hash(i+vec2(1.))),f.x);\n        return mix(tx.x,tx.y,f.y);\n    #endif\n}\nmat4 getRotMatrix(vec3 a) {\n    vec3 s = sin(a);\n    vec3 c = cos(a);    \n    mat4 ret;\n    ret[0] = vec4(c.y*c.z,c.y*s.z,-s.y,0.0);\n    ret[1] = vec4(s.x*s.y*c.z-c.x*s.z,s.x*s.y*s.z+c.x*c.z,s.x*c.y,0.0);\n    ret[2] = vec4(c.x*s.y*c.z+s.x*s.z, c.x*s.y*s.z-s.x*c.z,   c.x*c.y,0.0);    \n    ret[3] = vec4(0.0,0.0,0.0,1.0);\n    return ret;\n}\nmat4 getPosMatrix(vec3 p) {   \n    mat4 ret;\n    ret[0] = vec4(1.0,0.0,0.0,p.x);\n    ret[1] = vec4(0.0,1.0,0.0,p.y);\n    ret[2] = vec4(0.0,0.0,1.0,p.z);   \n    ret[3] = vec4(0.0,0.0,0.0,1.0);\n    return ret;\n}\n\n\/\/ textures\nvec4 textureGround(vec2 uv) {\n    const vec2 RES = vec2(8.0, 8.0);    \n    float n = noise1(uv * RES);\n    n = n * 0.2 + 0.5;\n    return vec4(n*0.9,n*0.6,n*0.4,1.0);\n}\n\nvec4 textureWall(vec2 uv) {\n    const vec2 RES = vec2(32.0, 16.0);\n    vec2 iuv = floor(uv * RES);    \n    float n = noise1(uv * RES);\n    n = n * 0.5 + 0.25;\n    float nc = n * (smoothstep(1.0,0.4, iuv.x \/ RES.x) * 0.5 + 0.5);    \n    return vec4(nc * 0.4, nc * 1.0, nc * 0.5, n + uv.x - abs(uv.y-0.5) );\n}\n\nvec4 textureBox(vec2 uv) {\n    const vec2 RES = vec2(8.0, 8.0);\n    vec2 iuv = (floor(uv * RES) + 0.5) \/ RES;  \n    float n = noise1(uv * RES);\n    n = max(abs(iuv.x - 0.5), abs(iuv.y - 0.5)) * 2.0;\n    n = n * n;\n    n = 0.5 + n * 0.4 + noise1(uv * RES) * 0.1;\n    return vec4(n, n*0.8, n*0.5, 1.0);\n}\n\nvec4 textureSky(vec2 uv) {\n    const vec2 RES = vec2(8.0, 32.0);    \n    float n = noise1(uv * RES);\n    n = n * 0.05 + 0.8;\n    return vec4(0.5,n*1.0,n*1.1,1.0);\n}   \n\n\/\/ rasterization\nvoid triangle(vec2 p,\n         vec2 v0, vec2 v1, vec2 v2,\n         vec2 uv0, vec2 uv1, vec2 uv2,\n         in int tex, inout vec3 color) {\n    \n    if(_cross(v2-v0,v1-v0) <= 1e-4) return;\n    \n    vec3 bary = abs(barycentric(v0,v1,v2, p));\n    if(bary.x + bary.y + bary.z <= 1.0001) {\n        vec2 uv = uv0 * bary.x + uv1 * bary.y + uv2 * bary.z; \n        vec4 frag;        \n        if(tex == 0) {\n    \t\tfrag = textureGround(uv);\n        } else if(tex == 1) {\n            frag = textureWall(uv);\n        } else {\n            frag = textureBox(uv);\n        }\n        if(frag.w > 0.5) color = frag.xyz;\n    }\n}\nvoid quad(vec2 p,\n         vec2 v0, vec2 v1, vec2 v2, vec2 v3,\n         vec2 uv0, vec2 uv1, vec2 uv2, vec2 uv3,\n        in int tex,  inout vec3 color) {    \n    triangle(p, v0,v1,v2, uv0,uv1,uv2, tex,color);\n    triangle(p, v2,v3,v0, uv2,uv3,uv0, tex,color);\n}\n\n\/\/ geometry transformation engine\nvoid gte(inout vec3 v, mat4 mat) {   \n    \n    \/\/ perspective\n    v = (vec4(v,1.0) * mat).xyz;\n    v.xy \/= max(v.z, 1.0);\n    \n    v *= 2.0;\n    \n    \/\/ quantization to simulate int\n    #ifdef INT_VERTICES    \t\n\t\tconst vec2 QUANT = vec2(320.0, 240.0) * 0.25;\n        v.xy = quantization(v.xy, QUANT);\n    #endif    \n}\n\n\/\/ renderer\nvoid gpu(vec2 p,\n         vec2 v0, vec2 v1, vec2 v2, vec2 v3,\n         vec2 uv0, vec2 uv1, vec2 uv2, vec2 uv3,\n         in int tex, inout vec3 color) {\n    \n    quad(p,\n         v0,v1,v2,v3,\n         uv0,uv1,uv2,uv3,\n         tex,color);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x \/ iResolution.y;    \n    \n    uv = quantization(uv, RESOLUTION * 0.5);\n        \n    const float WIDTH = 1.3;\n    const float HEIGHT = 6.0;\n    const float DEPTH = 4.0;  \n    const float LOD = 4.0;\n    \n    float time = iTime * 2.;    \n    \n    vec3 posv = vec3(-WIDTH*3.0,-2.0, -time+5.0);\n    vec3 rotv = vec3(sin(time)*0.05 + 0.1,\n             sin(time*0.9)*0.05,\n             sin(time*0.7)*0.05);\n    \n    \/\/ int-like position\n    #ifdef INT_VERTICES    \t\n        posv = quantization(posv, 64.0);\n        rotv = quantization(rotv, 256.0);    \t\n    #endif\n    \n    mat4 cam = getPosMatrix(posv);    \n    mat4 rot = getRotMatrix(rotv); \n    cam = cam * rot;\n        \n    vec3 c = textureSky(uv + vec2(rotv.y,-rotv.x) * 3.0).xyz;\n\n    vec3 vert[8];\n\n    \/\/ ground\n    float z_offset = -floor((posv.z + DEPTH * 1.5) \/ DEPTH) * DEPTH * 0.5;\n    float poly_depth = DEPTH;\n    \n    for(int dip = 0; dip < 32; dip++) {\n        \n        \/\/ kinda LOD\n        z_offset += step(mod(float(dip),4.0), 0.5) * poly_depth * 0.5;\n        #ifdef PSX_MODE\n        if(dip > 11) poly_depth = DEPTH * LOD; \n        #endif\n        \n        vert[0] = vec3(-WIDTH,0.0, poly_depth); \n        vert[1] = vec3(-WIDTH,0.0, 0.0);   \n        vert[2] = vec3( WIDTH,0.0, 0.0);\n        vert[3] = vec3( WIDTH,0.0, poly_depth);\n   \n        vec3 posv = vec3(mod(float(dip),4.0) * WIDTH,\n                         0.0,\n                         z_offset);        \n\n        mat4 pos = getPosMatrix(posv * 2.0);\n        mat4 mat = pos * cam;\n\n        for(int i = 0; i < 4; i++) gte(vert[i], mat);             \n        \n        gpu(uv,\n            vert[3].xy,vert[2].xy,vert[1].xy,vert[0].xy,\n            vec2(0.0),vec2(0.0,1.0),vec2(1.0),vec2(1.0,0.0),\n            0, c);\n    }\n    \n    \/\/ walls\n    z_offset = -floor((posv.z + DEPTH ) \/ DEPTH) * DEPTH * 0.5;\n    poly_depth = DEPTH;\n    \n    for(int dip = 0; dip < 8; dip++) {\n        \n        \/\/ kinda LOD\n        z_offset += poly_depth * 0.5;\n        #ifdef PSX_MODE\n        if(dip > 2) poly_depth = DEPTH * LOD;     \n        #endif\n        \n        vert[0] = vec3(0.0,HEIGHT, poly_depth); \n        vert[1] = vec3(0.0,HEIGHT, 0.0);   \n        vert[2] = vec3(0.0,0.0, 0.0);\n        vert[3] = vec3(0.0,0.0, poly_depth);\n   \n        vec3 posv = vec3(WIDTH * 3.5,\n                         0.0,\n                         z_offset);\n        \/\/posv.z -= z_offset;\n\n        mat4 posm = getPosMatrix(posv * 2.0);\n        mat4 mat = posm * cam;\n\n        for(int i = 0; i < 4; i++) gte(vert[i], mat);             \n        \n        gpu(uv,\n            vert[0].xy,vert[1].xy,vert[2].xy,vert[3].xy,\n            vec2(0.0),vec2(0.0,1.0),vec2(1.0),vec2(1.0,0.0),\n            1, c);\n        \n        \n        vert[0] = vec3(0.0,HEIGHT, poly_depth); \n        vert[1] = vec3(0.0,HEIGHT, 0.0);   \n        vert[2] = vec3( 0.0,0.0, 0.0);\n        vert[3] = vec3( 0.0,0.0, poly_depth);\n        \n        posv = vec3(-WIDTH * 0.5,\n                         0.0,\n                         z_offset);\n\n        posm = getPosMatrix(posv * 2.0);\n        mat = posm * cam;\n\n        for(int i = 0; i < 4; i++) gte(vert[i], mat);  \n        \n        gpu(uv,\n            vert[3].xy,vert[2].xy,vert[1].xy,vert[0].xy,\n            vec2(1.0,0.0), vec2(1.0), vec2(0.0,1.0),vec2(0.0),\n            1, c);\n    }\n    \n    \/\/ box\n    vert[0] = vec3(-1.0,-1.0, 1.0);\n    vert[1] = vec3(-1.0, 1.0, 1.0);    \n    vert[2] = vec3( 1.0, 1.0, 1.0);    \n    vert[3] = vec3( 1.0,-1.0, 1.0);\n    vert[4] = vec3(-1.0,-1.0,-1.0);\n    vert[5] = vec3(-1.0, 1.0,-1.0);    \n    vert[6] = vec3( 1.0, 1.0,-1.0);    \n    vert[7] = vec3( 1.0,-1.0,-1.0);\n\n    vec3 box_posv = vec3(-posv.x,\n                     2.0,\n                     -posv.z + 15.0);\n\n    rotv = vec3(time * 0.5, time * 0.6, time * 0.7);    \n    mat4 posm = getRotMatrix(rotv) * getPosMatrix(box_posv);\n    mat4 mat = posm * cam;\n\n    for(int i = 0; i < 8; i++) {\n        vert[i].y *= 0.65;\n        gte(vert[i], mat);\n    }\n\n    gpu(uv,\n        vert[3].xy,vert[2].xy,vert[1].xy,vert[0].xy,\n        vec2(0.0),vec2(0.0,1.0),vec2(1.0),vec2(1.0,0.0),\n        2, c);\n    gpu(uv,\n        vert[4].xy,vert[5].xy,vert[6].xy,vert[7].xy,\n        vec2(0.0),vec2(0.0,1.0),vec2(1.0),vec2(1.0,0.0),\n        2, c);\n    \n    gpu(uv,\n        vert[7].xy,vert[6].xy,vert[2].xy,vert[3].xy,\n        vec2(0.0),vec2(0.0,1.0),vec2(1.0),vec2(1.0,0.0),\n        2, c);\n    gpu(uv,\n        vert[0].xy,vert[1].xy,vert[5].xy,vert[4].xy,\n        vec2(0.0),vec2(0.0,1.0),vec2(1.0),vec2(1.0,0.0),\n        2, c);\n    \n    gpu(uv,\n        vert[2].xy,vert[6].xy,vert[5].xy,vert[1].xy,\n        vec2(0.0),vec2(0.0,1.0),vec2(1.0),vec2(1.0,0.0),\n        2, c);    \n    gpu(uv,\n        vert[0].xy,vert[4].xy,vert[7].xy,vert[3].xy,\n        vec2(0.0),vec2(0.0,1.0),vec2(1.0),vec2(1.0,0.0),\n        2, c);\n    \n    \/\/ fragment\n\tfragColor = vec4(c,1.0);\n}",
            "name": "Image",
            "description": "",
            "type": "image"
        }
    ]
}