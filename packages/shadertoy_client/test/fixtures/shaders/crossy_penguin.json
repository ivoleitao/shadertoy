{
    "ver": "0.1",
    "info": {
        "id": "4dKXDG",
        "date": "1466337141",
        "viewed": 6022,
        "name": "Crossy Penguin [MIGJRV]",
        "username": "RobotPenguin",
        "description": "A tribute to Crossy Road, made by Hector Barreiro-Cabrera and Rosa Ma. Sanchez-Banderas as the 2nd assignment of the PGATR course (MIGJRV master, URJC). Crossy Road is a mobile game developed by Hipster Whale. All rights to their respective owners.",
        "likes": 144,
        "published": 1,
        "flags": 112,
        "tags": [
            "procedural",
            "raymarching",
            "game",
            "road",
            "gpgpu",
            "crossy",
            "penguin",
            "madness"
        ],
        "hasliked": 0
    },
    "renderpass": [
        {
            "inputs": [
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "nearest",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "XsXGR8",
                    "filepath": "\/media\/previz\/buffer01.png",
                    "previewfilepath": "\/media\/previz\/buffer01.png",
                    "type": "buffer",
                    "channel": 1,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "MsfGDX",
                    "filepath": "https:\/\/soundcloud.com\/kade-kalka\/the-oyster-groove",
                    "previewfilepath": "https:\/\/soundcloud.com\/kade-kalka\/the-oyster-groove",
                    "type": "musicstream",
                    "channel": 3,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dfGRr",
                    "channel": 0
                }
            ],
            "code": "\/*\n\n(06\/11\/16)\n\nSome instructions on how to play:\n\nSpace: Used to start the game and restarting on Game Over.\nArrows: Move around the player character.\n1-4: Change the render buffer resolution to get a\n     big speedup (1 - 100%, 2 - 75%, 3 - 50%, 4 - 25%).\n\n--------------------------------------\n\nKnown Issues:\n\n- Some drivers might take long to compile the shader, we're currently looking into this.\n- You might find that the player moves weirdly when jumping\n  on water tiles, we'll try to figure out a better way to handle those cases.\n\nPotential Issues:\n\n- We haven't battle tested the shader on other GPUs than NVIDIA,\n  so we don't know if they'll work at all.\n\n*\/\n\n\/\/ =============================================================================\n\/\/ START OF SHARED CODE\n\/\/ =============================================================================\n\n\/\/ -- Constants ----------------------------------------------------------------\n\n\/\/ State constants.\n\nconst float kStateTitle      = 0.0;\nconst float kStateInGame     = 1.0;\nconst float kStateGameOver   = 2.0;\nconst float kStateRestarting = 3.0;\n\n\/\/ Scene constants.\n\nconst float kSceneWidth         = 5.0;\nconst float kSceneMinTileSpeed  = 2.0;\nconst float kSceneMaxTileSpeed  = 2.0;\n\nconst float kSceneNumChunks     = 3.0;     \/\/ Number of pre-defined chunks in the scene.\nconst float kSceneChunkTiles    = 5.0;     \/\/ Number of tiles per chunk.\nconst float kSceneInvChunkTiles = 0.2;     \/\/ Inverse number of tiles per chunk.\n\nconst float kSceneTileSnow      = 0.0;     \/\/ Id of the snow tile.\nconst float kSceneTileIceRoad   = 1.0;     \/\/ Id of the ice road tile.\nconst float kSceneTileWater     = 2.0;     \/\/ Id of the water tile.\n\nconst float kBehavGround        = 0.0;\nconst float kBehavWater         = 1.0;\nconst float kBehavObstacle      = 2.0;\nconst float kBehavHazard        = 3.0;\nconst float kBehavOutOfScreen   = 4.0;\n\n\/\/ Player motion constants.\n\nconst float kPlayerSpeed      = 5.0;\nconst float kPlayerJumpHeight = 0.3;\n\n\/\/ State coordinates.\n\nconst vec2 kTexState1 = vec2(0.0, 0.0); \/\/ x   = Current state,  y  = State time, w = Init\nconst vec2 kTexState2 = vec2(1.0, 0.0); \/\/ xy  = Current coords, zw = Next coords\nconst vec2 kTexState3 = vec2(2.0, 0.0); \/\/ x   = Motion time, y = Rotation, z = NextRotation, w = Scale\nconst vec2 kTexState4 = vec2(3.0, 0.0); \/\/ xyz = Coordinates, w = Rotation\nconst vec2 kTexState5 = vec2(4.0, 0.0); \/\/ x   = Death cause, y = Death time, z = Score, w = Fb. Scale\n\n\/\/ Misc constants.\n\nconst float kPi = 3.14159265359;\nconst float kOneOverPi = 0.31830988618;\nconst float kOmega = 1e20;\n\n\/\/ -- Global values ------------------------------------------------------------\n\nfloat gGameState;\nfloat gGameStateTime;\nfloat gGameInit;\nfloat gGameSeed;\nvec2  gPlayerCoords;\nvec2  gPlayerNextCoords;\nfloat gPlayerMotionTimer;\nfloat gPlayerRotation;\nfloat gPlayerNextRotation;\nfloat gPlayerScale;\nvec3  gPlayerVisualCoords;\nfloat gPlayerVisualRotation;\nfloat gPlayerDeathCause;\nfloat gPlayerDeathTime;\nfloat gScore;\nfloat gFbScale;\n\n\/\/ -- State functions ----------------------------------------------------------\n\nfloat IsInside(vec2 p, vec2 c)\n{\n    vec2 d = abs(p - 0.5 - c) - 0.5;\n    return -max(d.x, d.y);\n}\n\nvec4 LoadValue(vec2 st)\n{\n    return texture(iChannel0, (0.5 + st) \/ iChannelResolution[0].xy, -100.0);\n}\n\nvoid StoreValue(vec2 st, vec4 value, inout vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = (IsInside(fragCoord, st) > 0.0 )? value : fragColor;\n}\n\nvoid LoadState()\n{\n    vec4 state1 = LoadValue(kTexState1);\n    vec4 state2 = LoadValue(kTexState2);\n    vec4 state3 = LoadValue(kTexState3);\n    vec4 state4 = LoadValue(kTexState4);\n    vec4 state5 = LoadValue(kTexState5);\n    \n    gGameState            = state1.x;\n    gGameStateTime        = state1.y;\n    gGameSeed             = state1.z;\n    gGameInit             = state1.w;\n    gPlayerCoords         = state2.xy;\n    gPlayerNextCoords     = state2.zw;\n    gPlayerMotionTimer    = state3.x;\n    gPlayerRotation       = state3.y;\n    gPlayerNextRotation   = state3.z;\n    gPlayerScale          = state3.w;\n    gPlayerVisualCoords   = state4.xyz;\n    gPlayerVisualRotation = state4.w;\n    gPlayerDeathCause     = state5.x;\n    gPlayerDeathTime      = state5.y;\n    gScore                = state5.z;\n    gFbScale              = state5.w;\n}\n\nvoid StoreState(inout vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 state1 = vec4(gGameState, gGameStateTime, gGameSeed, gGameInit);\n    vec4 state2 = vec4(gPlayerCoords, gPlayerNextCoords);\n    vec4 state3 = vec4(gPlayerMotionTimer, gPlayerRotation, gPlayerNextRotation, gPlayerScale);\n    vec4 state4 = vec4(gPlayerVisualCoords, gPlayerVisualRotation);\n    vec4 state5 = vec4(gPlayerDeathCause, gPlayerDeathTime, gScore, gFbScale);\n    \n    StoreValue(kTexState1, state1, fragColor, fragCoord);\n    StoreValue(kTexState2, state2, fragColor, fragCoord);\n    StoreValue(kTexState3, state3, fragColor, fragCoord);\n    StoreValue(kTexState4, state4, fragColor, fragCoord);\n    StoreValue(kTexState5, state5, fragColor, fragCoord);\n}\n\n\/\/ -- Hashing functions --------------------------------------------------------\n\nvec4 Hash(float p)\n{\n    vec2 h = vec2(p) * vec2(1.271,3.117) + gGameSeed;\n    return texture(iChannel3, h \/ iChannelResolution[3].xy, -100.0);\n}\n\nvec4 Hash(vec2 p)\n{\n    vec2 h = p.xy * vec2(1.271,3.117) + gGameSeed;\n    return texture(iChannel3, h \/ iChannelResolution[3].xy, -100.0);\n}\n\nvec4 Hash(vec3 p)\n{\n    vec2 h = p.xy * vec2(1.271,3.117) + p.z * vec2(1.833,4.192) + gGameSeed;\n    return texture(iChannel3, h \/ iChannelResolution[3].xy, -100.0);\n}\n\n\/\/ -- Scene tile functions -----------------------------------------------------\n\n\/\/ Procedural tile management.\n\nfloat GetSceneTileIndex(float z)\n{\n    \/\/ The scene is separated into chunks of 5 consecutive tiles, where\n    \/\/ each chunk is simply a predefined set of tiles.\n    \n    \/\/ First, determine the chunk index and it's type, based on that index.\n    float chunkIndex = floor(z * kSceneInvChunkTiles);\n    float chunkType  = floor(kSceneNumChunks * Hash(chunkIndex).x) * step(1.0, chunkIndex);\n        \n   \t\/\/ Second, determine the tile number we're referring to inside the chunk.\n\tfloat tileNum = floor(kSceneChunkTiles * (z * kSceneInvChunkTiles - chunkIndex));\n    \n    \/\/ Finally, depending upon the chunk type, determine which tile occupies\n    \/\/ that location.\n\tfloat tileIdx = 0.0;\n\t\n\tif (chunkType == 0.0)\n\t{\n\t\ttileIdx = kSceneTileSnow;\n\t}\n\telse if (chunkType == 1.0)\n\t{\n\t\ttileIdx = mix(kSceneTileIceRoad, kSceneTileSnow, step(1.5, tileNum));\n\t\ttileIdx = mix(tileIdx, kSceneTileIceRoad,        step(2.5, tileNum));\n\t}\n\telse if (chunkType == 2.0)\n\t{\n\t\ttileIdx = mix(kSceneTileSnow, kSceneTileWater, step(0.5, tileNum));\n\t\ttileIdx = mix(tileIdx, kSceneTileSnow,         step(2.5, tileNum));\n\t}\n\t\n\treturn tileIdx;\n}\n\n\/\/ Snow tile management.\n\nfloat GetSceneSnowTileTreeChance(float coords, float treeIdx)\n{\n    return step(0.5, Hash(vec2(coords, treeIdx)).x) * step(0.5, coords);\n}\n\nfloat GetSceneSnowTileTreeCoord(float coords, float treeIdx)\n{\n    return floor(-kSceneWidth + 2.0 * kSceneWidth * Hash(vec2(coords, treeIdx)).y);\n}\n\n\/\/ Water and ice tiles common management.\n\nvec4 GetSceneTileVSS(float coords, float minWidth, float maxWidth, float playerCoef)\n{\n    vec4 t;\n    vec3 h = Hash(coords).xyz;\n    t.x = (kSceneMinTileSpeed + floor(kSceneMaxTileSpeed * h.x)) * (2.0 * step(0.5, h.y) - 1.0);\n    t.y = floor(mix(minWidth, maxWidth, h.z));\n    t.z = 2.0 * t.y;\n    t.w = playerCoef;\n    return t;\n}\n\nvec4 GetSceneTileVss(vec3 coordsTile)\n{\n    vec4 vss = vec4(0.0);\n    \n    if (coordsTile.z == kSceneTileWater)\n        vss = GetSceneTileVSS(coordsTile.y, 3.0, 6.0, 1.0);\n\n    if (coordsTile.z == kSceneTileIceRoad)\n\t\tvss = GetSceneTileVSS(coordsTile.y, 3.0, 8.0, 0.0);\n    \n    return vss;\n}\n\n\/\/ -- Scene gameplay functions -------------------------------------------------\n\n\/\/ Tile gameplay management.\n\nvec3 GetSceneCoordsTile(vec2 loc)\n{\n    return vec3(floor(loc), GetSceneTileIndex(loc.y));\n}\n\nfloat GetSceneTileLocalSpaceLoc(float loc, vec4 vss)\n{\n    loc = loc - iTime * vss.x;\n    return vss.z * fract(loc \/ vss.z);\n}\n\nvec4 GetSceneTileVss(vec2 loc)\n{\n    vec3 coordsTile = GetSceneCoordsTile(loc);\n    return GetSceneTileVss(coordsTile);\n}\n\nfloat GetSceneTileBehaviour(vec2 loc)\n{\n    vec3 coordsTile = GetSceneCoordsTile(loc);\n    vec4 vss = GetSceneTileVss(coordsTile);\n    \n    \/\/ Anything below or above the scene width is an obstacle.\n\tfloat isObstacle = max(step(1.0, -coordsTile.y), step(kSceneWidth + 0.5, abs(coordsTile.x)));\n\tfloat isWater = 0.0;\n    float isHazard = 0.0;\n    float isOutOfScreen = 0.0;\n    \n    \/\/ Check for each tile case.\n    if (coordsTile.z == kSceneTileSnow)\n    {\n        for (int i = 0; i < 5; i++)\n        {\n            float treeChance = GetSceneSnowTileTreeChance(coordsTile.y, float(i));\n            float treeCoord = GetSceneSnowTileTreeCoord(coordsTile.y, float(i));\n            \n            isObstacle = max(isObstacle, treeChance * (1.0 - step(0.5, abs(coordsTile.x - treeCoord))));\n        }\n    }\n    else if (coordsTile.z == kSceneTileWater)\n    {\n        isOutOfScreen = isObstacle;\n        isObstacle = 0.0;\n        \n        float l = GetSceneTileLocalSpaceLoc(loc.x, vss);        \n        if (l > vss.y) isWater = 1.0;\n    }\n    else if (coordsTile.z == kSceneTileIceRoad)\n    {\n        float l = GetSceneTileLocalSpaceLoc(loc.x, vss);\n        if (l < 2.0) isHazard = 1.0;\n    }\n    \n    float behav = kBehavGround;\n    behav = mix(behav, kBehavWater, isWater);\n    behav = mix(behav, kBehavHazard, isHazard);\n    behav = mix(behav, kBehavObstacle, isObstacle);\n    behav = mix(behav, kBehavOutOfScreen, isOutOfScreen);\n    \n    return behav;\n}\n\nvec2 GetNextCoordinates(vec2 loc)\n{\n    float behav = GetSceneTileBehaviour(loc);\n    vec4 vss = GetSceneTileVss(loc);\n    \n    float lsloc = vss.w == 0.0 && behav != kBehavWater? loc.x : GetSceneTileLocalSpaceLoc(loc.x, vss);\n    float lsloc0 = floor(lsloc) + 0.5;\n    \n    loc.y = floor(loc.y) + 0.5;\n    loc.x += (lsloc0 - lsloc);    \n    return loc;\n}\n\n\/\/ =============================================================================\n\/\/ END OF SHARED CODE\n\/\/ =============================================================================\n\n\/\/ =============================================================================\n\/\/ BEGIN OF FONT CODE\n\/\/ =============================================================================\n\n\/\/ --- Global values -----------------------------------------------------------\n\nfloat gCharPadding  = 2.0;\nvec2  gCharPrintPos = vec2(0.0);\n\n\/\/ --- Character printing functions --------------------------------------------\n\nfloat CharRect(vec2 p, vec2 b)\n{\n\tvec2 d = abs(p) - b;\n  \treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat CharRect(vec2 p, float minX, float minY, float maxX, float maxY)\n{\n\tvec2 minCoord = vec2(minX, minY);\n\tvec2 maxCoord = vec2(maxX, maxY);\n\tvec2 b = 0.5 * (maxCoord - minCoord);\n    vec2 c = 0.5 * (maxCoord + minCoord);\n    return CharRect(p - c, b);\n}\n\nfloat CharA(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\t\n    d = min(d, CharRect(p, 3.0, 3.0, 7.0, 12.0));\n    d = min(d, CharRect(p, 9.0, 3.0, 13.0, 12.0));\n    d = min(d, CharRect(p, 7.0, 7.0, 9.0, 9.0));\n    d = min(d, CharRect(p, 4.0, 11.0, 12.0, 13.0));\n    \n    return d;\n}\n\nfloat CharB(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\t\n    d = min(d, CharRect(p, 3.0, 3.0, 7.0, 13.0));\n    d = min(d, CharRect(p, 3.0, 3.0, 12.0, 5.0));\n    d = min(d, CharRect(p, 3.0, 7.0, 12.0, 9.0));\n    d = min(d, CharRect(p, 3.0, 11.0, 12.0, 13.0));\n    d = min(d, CharRect(p, 9.0, 4.0, 13.0, 7.0));\n    d = min(d, CharRect(p, 9.0, 9.0, 13.0, 12.0));\n    return d;\n}\n\nfloat CharC(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 3.0, 4.0, 7.0, 12.0));\n    d = min(d, CharRect(p, 4.0, 3.0, 13.0, 5.0));\n    d = min(d, CharRect(p, 4.0, 11.0, 13.0, 13.0));\n    return d;\n}\n\nfloat CharD(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 3.0, 3.0, 7.0, 13.0));\n    d = min(d, CharRect(p, 9.0, 3.0, 12.0, 13.0));\n    d = min(d, CharRect(p, 3.0, 3.0, 12.0, 5.0));\n    d = min(d, CharRect(p, 3.0, 11.0, 12.0, 13.0));\n    d = min(d, CharRect(p, 9.0, 4.0, 13.0, 12.0));\n    return d;\n}\n\nfloat CharE(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 3.0, 4.0, 7.0, 12.0));\n    d = min(d, CharRect(p, 4.0, 3.0, 13.0, 5.0));\n    d = min(d, CharRect(p, 4.0, 11.0, 13.0, 13.0));\n    d = min(d, CharRect(p, 7.0, 7.0, 10.0, 9.0));\n    return d;\n}\n\nfloat CharF(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 3.0, 3.0, 7.0, 12.0));\n    d = min(d, CharRect(p, 3.0, 7.0, 10.0, 9.0));\n    d = min(d, CharRect(p, 4.0, 11.0, 13.0, 13.0));\n    return d;\n}\n\nfloat CharG(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 3.0, 4.0, 7.0, 12.0));\n    d = min(d, CharRect(p, 4.0, 3.0, 13.0, 5.0));\n    d = min(d, CharRect(p, 9.0, 3.0, 13.0, 9.0));\n    d = min(d, CharRect(p, 8.0, 7.0, 13.0, 9.0));\n    d = min(d, CharRect(p, 4.0, 11.0, 13.0, 13.0));\n    return d;\n}\n\nfloat CharH(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 3.0, 3.0, 7.0, 13.0));\n    d = min(d, CharRect(p, 9.0, 3.0, 13.0, 13.0));\n    d = min(d, CharRect(p, 3.0, 7.0, 13.0, 9.0));\n    return d;\n}\n\nfloat CharI(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(11.0, 0.0);\n\tgCharPrintPos.x += 4.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 6.0, 3.0, 10.0, 13.0));\n    return d;\n}\n\nfloat CharJ(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 3.0, 3.0, 12.0, 5.0));\n    d = min(d, CharRect(p, 9.0, 4.0, 13.0, 13.0));\n    return d;\n}\n\nfloat CharK(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 3.0, 3.0, 7.0, 13.0));\n    d = min(d, CharRect(p, 3.0, 7.0, 12.0, 9.0));\n    d = min(d, CharRect(p, 9.0, 3.0, 13.0, 7.0));\n    d = min(d, CharRect(p, 9.0, 9.0, 13.0, 13.0));\n    return d;\n}\n\nfloat CharL(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 3.0, 3.0, 7.0, 13.0));\n    d = min(d, CharRect(p, 3.0, 3.0, 13.0, 5.0));\n    return d;\n}\n\nfloat CharM(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(5.0, 0.0);\n\tgCharPrintPos.x += 16.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 0.0, 3.0, 4.0, 13.0));\n    d = min(d, CharRect(p, 6.0, 3.0, 10.0, 13.0));\n    d = min(d, CharRect(p, 12.0, 3.0, 16.0, 12.0));\n    d = min(d, CharRect(p, 0.0, 11.0, 15.0, 13.0));\n    return d;\n}\n\nfloat CharN(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 3.0, 3.0, 7.0, 13.0));\n    d = min(d, CharRect(p, 3.0, 11.0, 12.0, 13.0));\n    d = min(d, CharRect(p, 9.0, 3.0, 13.0, 12.0));\n    return d;\n}\n\nfloat CharO(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 3.0, 4.0, 7.0, 12.0));\n    d = min(d, CharRect(p, 9.0, 4.0, 13.0, 12.0));\n    d = min(d, CharRect(p, 4.0, 3.0, 12.0, 5.0));\n    d = min(d, CharRect(p, 4.0, 11.0, 12.0, 13.0));\n    return d;\n}\n\nfloat CharP(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 3.0, 3.0, 7.0, 13.0));\n    d = min(d, CharRect(p, 6.0, 7.0, 12.0, 9.0));\n    d = min(d, CharRect(p, 9.0, 8.0, 13.0, 12.0));\n    d = min(d, CharRect(p, 6.0, 11.0, 12.0, 13.0));\n    return d;\n}\n\nfloat CharQ(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 3.0, 4.0, 7.0, 12.0));\n    d = min(d, CharRect(p, 9.0, 4.0, 13.0, 12.0));\n    d = min(d, CharRect(p, 4.0, 3.0, 12.0, 5.0));\n    d = min(d, CharRect(p, 4.0, 11.0, 12.0, 13.0));\n    d = min(d, CharRect(p, 8.0, 1.0, 13.0, 3.0));\n    return d;\n}\n\nfloat CharR(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 3.0, 3.0, 7.0, 13.0));\n    d = min(d, CharRect(p, 6.0, 7.0, 12.0, 9.0));\n    d = min(d, CharRect(p, 9.0, 8.0, 13.0, 12.0));\n    d = min(d, CharRect(p, 6.0, 11.0, 12.0, 13.0));\n    d = min(d, CharRect(p, 9.0, 3.0, 13.0, 7.0));\n    return d;\n}\n\nfloat CharS(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 3.0, 3.0, 12.0, 5.0));\n    d = min(d, CharRect(p, 4.0, 7.0, 12.0, 9.0));\n    d = min(d, CharRect(p, 4.0, 11.0, 13.0, 13.0));\n    d = min(d, CharRect(p, 9.0, 4.0, 13.0, 8.0));\n    d = min(d, CharRect(p, 3.0, 8.0, 7.0, 12.0));\n    return d;\n}\n\nfloat CharT(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 6.0, 3.0, 10.0, 13.0));\n    d = min(d, CharRect(p, 3.0, 11.0, 13.0, 13.0));\n    return d;\n}\n\nfloat CharU(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 3.0, 4.0, 7.0, 13.0));\n    d = min(d, CharRect(p, 9.0, 4.0, 13.0, 13.0));\n    d = min(d, CharRect(p, 4.0, 3.0, 12.0, 5.0));\n    return d;\n}\n\nfloat CharV(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 3.0, 3.0, 7.0, 13.0));\n    d = min(d, CharRect(p, 9.0, 4.0, 13.0, 13.0));\n    d = min(d, CharRect(p, 4.0, 3.0, 12.0, 5.0));\n    return d;\n}\n\nfloat CharW(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(5.0, 0.0);\n\tgCharPrintPos.x += 16.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 0.0, 3.0, 4.0, 13.0));\n    d = min(d, CharRect(p, 6.0, 3.0, 10.0, 13.0));\n    d = min(d, CharRect(p, 12.0, 4.0, 16.0, 13.0));\n    d = min(d, CharRect(p, 0.0, 3.0, 15.0, 6.0));\n    return d;\n}\n\nfloat CharX(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 3.0, 3.0, 7.0, 7.0));\n    d = min(d, CharRect(p, 9.0, 3.0, 13.0, 7.0));\n    d = min(d, CharRect(p, 3.0, 9.0, 7.0, 13.0));\n    d = min(d, CharRect(p, 9.0, 9.0, 13.0, 13.0));\n    d = min(d, CharRect(p, 4.0, 7.0, 12.0, 9.0));\n    return d;\n}\n\nfloat CharY(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 6.0, 3.0, 10.0, 7.0));\n    d = min(d, CharRect(p, 3.0, 8.0, 7.0, 13.0));\n    d = min(d, CharRect(p, 9.0, 8.0, 13.0, 13.0));\n    d = min(d, CharRect(p, 4.0, 7.0, 12.0, 9.0));\n    return d;\n}\n\nfloat CharZ(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 3.0, 3.0, 13.0, 5.0));\n    d = min(d, CharRect(p, 4.0, 7.0, 12.0, 9.0));\n    d = min(d, CharRect(p, 3.0, 11.0, 13.0, 13.0));\n    d = min(d, CharRect(p, 9.0, 8.0, 13.0, 13.0));\n    d = min(d, CharRect(p, 3.0, 4.0, 7.0, 8.0));\n    return d;\n}\n\nfloat Char0(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 3.0, 4.0, 7.0, 12.0));\n    d = min(d, CharRect(p, 9.0, 4.0, 13.0, 12.0));\n    d = min(d, CharRect(p, 4.0, 3.0, 12.0, 5.0));\n    d = min(d, CharRect(p, 4.0, 11.0, 12.0, 13.0));\n    d = min(d, CharRect(p, 7.0, 7.0, 9.0, 9.0));\n    return d;\n}\n\nfloat Char1(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(10.0, 0.0);\n\tgCharPrintPos.x += 8.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 7.0, 3.0, 11.0, 12.0));\n    d = min(d, CharRect(p, 6.0, 11.0, 10.0, 13.0));\n    return d;\n}\n\nfloat Char2(vec2 p, inout float d)\n{\n    return CharZ(p, d);\n}\n\nfloat Char3(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 3.0, 3.0, 12.0, 5.0));\n    d = min(d, CharRect(p, 9.0, 4.0, 13.0, 7.0));\n    d = min(d, CharRect(p, 6.0, 7.0, 12.0, 9.0));\n    d = min(d, CharRect(p, 9.0, 9.0, 13.0, 12.0));\n    d = min(d, CharRect(p, 3.0, 11.0, 12.0, 13.0));\n    return d;\n}\n\nfloat Char4(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 9.0, 3.0, 13.0, 13.0));\n    d = min(d, CharRect(p, 4.0, 7.0, 13.0, 9.0));\n    d = min(d, CharRect(p, 3.0, 8.0, 7.0, 13.0));\n    return d;\n}\n\nfloat Char5(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 3.0, 3.0, 12.0, 5.0));\n    d = min(d, CharRect(p, 4.0, 7.0, 12.0, 9.0));\n    d = min(d, CharRect(p, 3.0, 11.0, 13.0, 13.0));\n    d = min(d, CharRect(p, 9.0, 4.0, 13.0, 8.0));\n    d = min(d, CharRect(p, 3.0, 8.0, 7.0, 12.0));\n    return d;\n}\n\nfloat Char6(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 3.0, 4.0, 7.0, 12.0));\n    d = min(d, CharRect(p, 4.0, 3.0, 12.0, 5.0));\n    d = min(d, CharRect(p, 9.0, 4.0, 13.0, 8.0));\n    d = min(d, CharRect(p, 3.0, 7.0, 12.0, 9.0));\n    d = min(d, CharRect(p, 4.0, 11.0, 13.0, 13.0));\n    return d;\n}\n\nfloat Char7(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 9.0, 3.0, 13.0, 12.0));\n    d = min(d, CharRect(p, 3.0, 11.0, 12.0, 13.0));\n    return d;\n}\n\nfloat Char8(vec2 p, inout float d)\n{\n\tp -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n\n    d = min(d, CharRect(p, 3.0, 4.0, 7.0, 7.0));\n    d = min(d, CharRect(p, 9.0, 4.0, 13.0, 7.0));\n    d = min(d, CharRect(p, 3.0, 9.0, 7.0, 12.0));\n    d = min(d, CharRect(p, 9.0, 9.0, 13.0, 12.0));\n    d = min(d, CharRect(p, 4.0, 7.0, 12.0, 9.0));\n    d = min(d, CharRect(p, 4.0, 3.0, 12.0, 5.0));\n    d = min(d, CharRect(p, 4.0, 11.0, 12.0, 13.0));\n    return d;\n}\n\nfloat Char9(vec2 p, inout float d)\n{\n    p -= gCharPrintPos - vec2(8.0, 0.0);\n\tgCharPrintPos.x += 10.0 + gCharPadding;\n    \n\td = min(d, CharRect(p, 3.0, 3.0, 12.0, 5.0));\n    d = min(d, CharRect(p, 9.0, 4.0, 13.0, 12.0));\n    d = min(d, CharRect(p, 4.0, 11.0, 12.0, 13.0));\n    d = min(d, CharRect(p, 3.0, 8.0, 7.0, 12.0));\n    d = min(d, CharRect(p, 4.0, 7.0, 13.0, 9.0));\n    return d;\n}\n\nvoid CharSpace()\n{\n    gCharPrintPos.x += 10.0 + gCharPadding;\n}\n\nfloat CharDigit(vec2 p, float n, inout float d)\n{\n    n = floor(n);\n    \n    if (n == 0.0) return Char0(p, d);\n    if (n == 1.0) return Char1(p, d);\n    if (n == 2.0) return Char2(p, d);\n    if (n == 3.0) return Char3(p, d);\n    if (n == 4.0) return Char4(p, d);\n    if (n == 5.0) return Char5(p, d);\n    if (n == 6.0) return Char6(p, d);\n    if (n == 7.0) return Char7(p, d);\n    if (n == 8.0) return Char8(p, d);\n    if (n == 9.0) return Char9(p, d);\n    return d;\n}\n\nvoid Print(vec2 p, float n\n           , inout float d)\n{   \n\tfor (int i = 5; i >= 0; i--)\n    {\n        float w = pow(10.0, float(i));\n        float k = mod(n \/ w, 10.0);\n        \n        if (abs(n) > w || i == 0)\n            CharDigit(p, k, d);\n    }   \n}    \n\n\/\/ =============================================================================\n\/\/ END OF FONT CODE\n\/\/ =============================================================================\n\n\/\/ =============================================================================\n\/\/ START OF UI RENDER CODE\n\/\/ =============================================================================\n\nvoid RenderUI(inout vec4 fragColor, vec2 fragCoord, vec2 uv, float aspect)\n{\n    uv *= 128.0;\n       \n    \/\/ Render CROSSY PENGUIN logo upon the title screen or during the first\n    \/\/ seconds of the game (with an animation!).\n    \n    if (gGameState == kStateTitle || (gGameState == kStateInGame && gGameStateTime < 4.0))\n    {\n        float logoSdf = kOmega;        \n        vec2 logoUv = uv * 0.5;\n        logoUv.x -= (gGameState == kStateInGame)? 500.0 * gGameStateTime * gGameStateTime : 0.0;\n        logoUv.y += uv.x * 0.13;\n                \n        vec2 subLogoUv = logoUv * 3.0;\n        \n        gCharPrintPos = vec2(-34.0, 7.0);\n        CharC(logoUv, logoSdf);\n        CharR(logoUv, logoSdf);\n        CharO(logoUv, logoSdf);\n        CharS(logoUv, logoSdf);\n        CharS(logoUv, logoSdf);\n        CharY(logoUv, logoSdf);\n        gCharPrintPos = vec2(-38.0, -7.0);\n        CharP(logoUv, logoSdf);\n        CharE(logoUv, logoSdf);\n        CharN(logoUv, logoSdf);\n        CharG(logoUv, logoSdf);\n        CharU(logoUv, logoSdf);\n        CharI(logoUv, logoSdf);\n        CharN(logoUv, logoSdf);\n        gCharPrintPos = vec2(-132.0, -40.0);\n        CharA(subLogoUv, logoSdf);\n        CharSpace();\n        CharC(subLogoUv, logoSdf);\n        CharR(subLogoUv, logoSdf);\n        CharO(subLogoUv, logoSdf);\n        CharS(subLogoUv, logoSdf);\n        CharS(subLogoUv, logoSdf);\n        CharY(subLogoUv, logoSdf);\n        CharSpace();\n        CharR(subLogoUv, logoSdf);\n        CharO(subLogoUv, logoSdf);\n        CharA(subLogoUv, logoSdf);\n        CharD(subLogoUv, logoSdf);\n        CharSpace();\n        CharT(subLogoUv, logoSdf);\n        CharR(subLogoUv, logoSdf);\n        CharI(subLogoUv, logoSdf);\n        CharB(subLogoUv, logoSdf);\n        CharU(subLogoUv, logoSdf);\n        CharT(subLogoUv, logoSdf);\n        CharE(subLogoUv, logoSdf);\n        \n        fragColor.rgb = mix(fragColor.rgb, vec3(0.0), step(-3.0, -logoSdf));\n        fragColor.rgb = mix(fragColor.rgb, vec3(1.0), step(0.0, -logoSdf));\n    }\n    \n    \/\/ Render the score during the InGame state and hide on GameOver.\n    \n    if (gGameState == kStateInGame || (gGameState == kStateGameOver && gGameStateTime < 4.0))\n    {\n        float scoreSdf = kOmega;\n        vec2 scoreUv = uv;\n        \n        if (gGameState == kStateInGame) scoreUv.y -= 64.0 - 64.0 * min(1.0, gGameStateTime);\n        else                            scoreUv.y -= 64.0 * min(1.0, gGameStateTime);\n        \n        gCharPrintPos = vec2(-120.0 * aspect, 104.0);\n        Print(scoreUv, gScore, scoreSdf);\n        \n        fragColor.rgb = mix(fragColor.rgb, vec3(0.0), step(-3.0, -scoreSdf));\n        fragColor.rgb = mix(fragColor.rgb, vec3(1.0), step(0.0, -scoreSdf));\n    }\n    \n    \/\/ Fade to blue upon GameOver and show score.\n   \n    if (gGameState == kStateGameOver || gGameState == kStateRestarting)\n    {\n        fragColor.rgb  = mix(fragColor.rgb, vec3(0.2, 0.7, 1.0), min(0.5, gGameStateTime));\n        \n        float gameOverSdf = kOmega;        \n        vec2 gameOverUv = uv * 0.5;\n        float gameOverTime = gGameState == kStateRestarting? 1.0 : min(gGameStateTime * 0.7, 1.0);\n        \n        gameOverUv.y -= 128.0 * abs(cos(2.0 * kPi * gameOverTime * gameOverTime)) * (1.0 - gameOverTime);\n                       \n        gCharPrintPos = vec2(-45.0, 0.0);\n        CharG(gameOverUv, gameOverSdf);\n        CharA(gameOverUv, gameOverSdf);\n        CharM(gameOverUv, gameOverSdf);\n        CharE(gameOverUv, gameOverSdf);\n        CharSpace();\n        CharO(gameOverUv, gameOverSdf);\n        CharV(gameOverUv, gameOverSdf);\n        CharE(gameOverUv, gameOverSdf);\n        CharR(gameOverUv, gameOverSdf);\n        \n        fragColor.rgb = mix(fragColor.rgb, vec3(0.0), step(-3.0, -gameOverSdf));\n        fragColor.rgb = mix(fragColor.rgb, vec3(1.0), step(0.0, -gameOverSdf));\n        \n        float messageSdf = kOmega;\n        vec2 messageUv = uv * 1.5;\n        float messageTime = gGameState == kStateRestarting? 1.0 : clamp(gGameStateTime * 0.7 - 1.0, 0.0, 1.0);\n        \n        messageUv.x -= 1024.0 * (1.0 - messageTime) * (1.0 - messageTime);\n                 \n        if (gPlayerDeathCause == kBehavWater)\n        {\n            gCharPrintPos = vec2(-170.0, -40.0);\n            CharS(messageUv, messageSdf);\n            CharE(messageUv, messageSdf);\n            CharE(messageUv, messageSdf);\n            CharM(messageUv, messageSdf);\n            CharS(messageUv, messageSdf);\n            CharSpace();\n            CharL(messageUv, messageSdf);\n            CharI(messageUv, messageSdf);\n            CharK(messageUv, messageSdf);\n            CharE(messageUv, messageSdf);\n            CharSpace();\n            CharT(messageUv, messageSdf);\n            CharH(messageUv, messageSdf);\n            CharI(messageUv, messageSdf);\n            CharS(messageUv, messageSdf);\n            CharSpace();\n            CharP(messageUv, messageSdf);\n            CharE(messageUv, messageSdf);\n            CharN(messageUv, messageSdf);\n            CharG(messageUv, messageSdf);\n            CharU(messageUv, messageSdf);\n            CharI(messageUv, messageSdf);\n            CharN(messageUv, messageSdf);\n            CharSpace();\n            CharC(messageUv, messageSdf);\n            CharA(messageUv, messageSdf);\n            CharN(messageUv, messageSdf);\n            CharT(messageUv, messageSdf);\n            CharSpace();\n            CharS(messageUv, messageSdf);\n            CharW(messageUv, messageSdf);\n            CharI(messageUv, messageSdf);\n            CharM(messageUv, messageSdf);\n        }\n        else if (gPlayerDeathCause == kBehavOutOfScreen)\n        {\n            gCharPrintPos = vec2(-220.0, -40.0);\n            CharY(messageUv, messageSdf);\n            CharO(messageUv, messageSdf);\n            CharU(messageUv, messageSdf);\n            CharSpace();\n            CharW(messageUv, messageSdf);\n            CharE(messageUv, messageSdf);\n            CharN(messageUv, messageSdf);\n            CharT(messageUv, messageSdf);\n            CharSpace();\n            CharO(messageUv, messageSdf);\n            CharN(messageUv, messageSdf);\n            CharSpace();\n            CharA(messageUv, messageSdf);\n            CharSpace();\n            CharJ(messageUv, messageSdf);\n            CharO(messageUv, messageSdf);\n            CharU(messageUv, messageSdf);\n            CharR(messageUv, messageSdf);\n            CharN(messageUv, messageSdf);\n            CharE(messageUv, messageSdf);\n            CharY(messageUv, messageSdf);\n            CharSpace();\n            CharT(messageUv, messageSdf);\n            CharO(messageUv, messageSdf);\n            CharSpace();\n            CharF(messageUv, messageSdf);\n            CharA(messageUv, messageSdf);\n            CharR(messageUv, messageSdf);\n            CharSpace();\n            CharA(messageUv, messageSdf);\n            CharW(messageUv, messageSdf);\n            CharA(messageUv, messageSdf);\n            CharY(messageUv, messageSdf);\n            CharSpace();\n            CharL(messageUv, messageSdf);\n            CharA(messageUv, messageSdf);\n            CharN(messageUv, messageSdf);\n            CharD(messageUv, messageSdf);\n            CharS(messageUv, messageSdf);\n        }\n        else if (gPlayerDeathCause == kBehavHazard)\n        {\n            gCharPrintPos = vec2(-170.0, -40.0);\n            CharD(messageUv, messageSdf);\n            CharI(messageUv, messageSdf);\n            CharD(messageUv, messageSdf);\n            CharSpace();\n            CharA(messageUv, messageSdf);\n            CharN(messageUv, messageSdf);\n            CharY(messageUv, messageSdf);\n            CharO(messageUv, messageSdf);\n            CharN(messageUv, messageSdf);\n            CharE(messageUv, messageSdf);\n            CharSpace();\n            CharC(messageUv, messageSdf);\n            CharA(messageUv, messageSdf);\n            CharT(messageUv, messageSdf);\n            CharC(messageUv, messageSdf);\n            CharH(messageUv, messageSdf);\n            CharSpace();\n            CharT(messageUv, messageSdf);\n            CharH(messageUv, messageSdf);\n            CharE(messageUv, messageSdf);\n            CharSpace();\n            CharL(messageUv, messageSdf);\n            CharI(messageUv, messageSdf);\n            CharC(messageUv, messageSdf);\n            CharE(messageUv, messageSdf);\n            CharN(messageUv, messageSdf);\n            CharS(messageUv, messageSdf);\n            CharE(messageUv, messageSdf);\n            CharSpace();\n            CharP(messageUv, messageSdf);\n            CharL(messageUv, messageSdf);\n            CharA(messageUv, messageSdf);\n            CharT(messageUv, messageSdf);\n            CharE(messageUv, messageSdf);\n        }\n        \n        fragColor.rgb = mix(fragColor.rgb, vec3(0.0), step(-3.0, -gameOverSdf));\n        fragColor.rgb = mix(fragColor.rgb, vec3(1.0), step(0.0, -gameOverSdf));\n        fragColor.rgb = mix(fragColor.rgb, vec3(0.0), step(-3.0, -messageSdf));\n        fragColor.rgb = mix(fragColor.rgb, vec3(1.0), step(0.0, -messageSdf));\n    }   \n    \n    \/\/ Fade to white upon Restarting\n    \n    if (gGameState == kStateRestarting)\n        fragColor.rgb = mix(mix(fragColor.rgb, vec3(0.2, 0.7, 1.0), 0.5), vec3(1.0), min(1.0, gGameStateTime));\n    \n    \/\/ Fade from white at the title.\n    \n    if (gGameState == kStateTitle)\n    \tfragColor.rgb = mix(vec3(1.0), fragColor.rgb, min(1.0, gGameStateTime));\n    \n    \/\/ Press space to continue.\n    \n    if (step(0.5, fract(iTime * 0.75)) > 0.5 && (gGameState == kStateTitle || gGameState == kStateGameOver) && gGameStateTime > 1.0)\n    {\n        float messageSdf = kOmega;\n        vec2 messageUv = uv * 1.75;\n                 \n        gCharPrintPos = vec2(-130.0, -100.0);\n        CharP(messageUv, messageSdf);\n        CharR(messageUv, messageSdf);\n        CharE(messageUv, messageSdf);\n        CharS(messageUv, messageSdf);\n        CharS(messageUv, messageSdf);\n        CharSpace();\n        CharS(messageUv, messageSdf);\n        CharP(messageUv, messageSdf);\n        CharA(messageUv, messageSdf);\n        CharC(messageUv, messageSdf);\n        CharE(messageUv, messageSdf);\n        CharSpace();\n        CharT(messageUv, messageSdf);\n        CharO(messageUv, messageSdf);\n        CharSpace();\n        CharC(messageUv, messageSdf);\n        CharO(messageUv, messageSdf);\n        CharN(messageUv, messageSdf);\n        CharT(messageUv, messageSdf);\n        CharI(messageUv, messageSdf);\n        CharN(messageUv, messageSdf);\n        CharU(messageUv, messageSdf);\n        CharE(messageUv, messageSdf);\n        \n        fragColor.rgb = mix(fragColor.rgb, vec3(0.0), step(-3.0, -messageSdf));\n        fragColor.rgb = mix(fragColor.rgb, vec3(1.0, 1.0, 0.0), step(0.0, -messageSdf));\n    }\n}\n\n\/\/ =============================================================================\n\/\/ END OF UI RENDER CODE\n\/\/ =============================================================================\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    LoadState();\n\n\t\/\/ Compute uv coords.\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n    \n    \/\/ Render lower-res back buffer.\n    fragColor = texture(iChannel1, uv * gFbScale);\n    \n    \/\/ Render UI\n    float aspect = iResolution.x \/ iResolution.y;\n    uv = 2.0 * uv - 1.0;\n    uv.x *= aspect;    \n\n    RenderUI(fragColor, fragCoord, uv, aspect);\n}\n",
            "name": "Image",
            "description": "",
            "type": "image"
        },
        {
            "inputs": [
                {
                    "id": "Xsf3zn",
                    "filepath": "\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
                    "previewfilepath": "\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
                    "type": "texture",
                    "channel": 3,
                    "sampler": {
                        "filter": "nearest",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "4dXGRr",
                    "filepath": "\/presets\/tex00.jpg",
                    "previewfilepath": "\/presets\/tex00.jpg",
                    "type": "keyboard",
                    "channel": 1,
                    "sampler": {
                        "filter": "nearest",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "nearest",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dXGR8",
                    "channel": 0
                }
            ],
            "code": "\/*\n\n(06\/11\/16)\n\nSome instructions on how to play:\n\nSpace: Used to start the game and restarting on Game Over.\nArrows: Move around the player character.\n1-4: Change the render buffer resolution to get a\n     big speedup (1 - 100%, 2 - 75%, 3 - 50%, 4 - 25%).\n\n--------------------------------------\n\nKnown Issues:\n\n- Some drivers might take long to compile the shader, we're currently looking into this.\n- You might find that the player moves weirdly when jumping\n  on water tiles, we'll try to figure out a better way to handle those cases.\n\nPotential Issues:\n\n- We haven't battle tested the shader on other GPUs than NVIDIA,\n  so we don't know if they'll work at all.\n\n*\/\n\n\/\/ =============================================================================\n\/\/ START OF SHARED CODE\n\/\/ =============================================================================\n\n\/\/ -- Constants ----------------------------------------------------------------\n\n\/\/ State constants.\n\nconst float kStateTitle      = 0.0;\nconst float kStateInGame     = 1.0;\nconst float kStateGameOver   = 2.0;\nconst float kStateRestarting = 3.0;\n\n\/\/ Scene constants.\n\nconst float kSceneWidth         = 5.0;\nconst float kSceneMinTileSpeed  = 2.0;\nconst float kSceneMaxTileSpeed  = 2.0;\n\nconst float kSceneNumChunks     = 3.0;     \/\/ Number of pre-defined chunks in the scene.\nconst float kSceneChunkTiles    = 5.0;     \/\/ Number of tiles per chunk.\nconst float kSceneInvChunkTiles = 0.2;     \/\/ Inverse number of tiles per chunk.\n\nconst float kSceneTileSnow      = 0.0;     \/\/ Id of the snow tile.\nconst float kSceneTileIceRoad   = 1.0;     \/\/ Id of the ice road tile.\nconst float kSceneTileWater     = 2.0;     \/\/ Id of the water tile.\n\nconst float kBehavGround        = 0.0;\nconst float kBehavWater         = 1.0;\nconst float kBehavObstacle      = 2.0;\nconst float kBehavHazard        = 3.0;\nconst float kBehavOutOfScreen   = 4.0;\n\n\/\/ Player motion constants.\n\nconst float kPlayerSpeed      = 5.0;\nconst float kPlayerJumpHeight = 0.3;\n\n\/\/ State coordinates.\n\nconst vec2 kTexState1 = vec2(0.0, 0.0); \/\/ x   = Current state,  y  = State time, w = Init\nconst vec2 kTexState2 = vec2(1.0, 0.0); \/\/ xy  = Current coords, zw = Next coords\nconst vec2 kTexState3 = vec2(2.0, 0.0); \/\/ x   = Motion time, y = Rotation, z = NextRotation, w = Scale\nconst vec2 kTexState4 = vec2(3.0, 0.0); \/\/ xyz = Coordinates, w = Rotation\nconst vec2 kTexState5 = vec2(4.0, 0.0); \/\/ x   = Death cause, y = Death time, z = Score, w = Fb. Scale\n\n\/\/ Misc constants.\n\nconst float kPi = 3.14159265359;\nconst float kOneOverPi = 0.31830988618;\nconst float kOmega = 1e20;\n\n\/\/ -- Global values ------------------------------------------------------------\n\nfloat gGameState;\nfloat gGameStateTime;\nfloat gGameInit;\nfloat gGameSeed;\nvec2  gPlayerCoords;\nvec2  gPlayerNextCoords;\nfloat gPlayerMotionTimer;\nfloat gPlayerRotation;\nfloat gPlayerNextRotation;\nfloat gPlayerScale;\nvec3  gPlayerVisualCoords;\nfloat gPlayerVisualRotation;\nfloat gPlayerDeathCause;\nfloat gPlayerDeathTime;\nfloat gScore;\nfloat gFbScale;\n\n\/\/ -- State functions ----------------------------------------------------------\n\nfloat IsInside(vec2 p, vec2 c)\n{\n    vec2 d = abs(p - 0.5 - c) - 0.5;\n    return -max(d.x, d.y);\n}\n\nvec4 LoadValue(vec2 st)\n{\n    return texture(iChannel0, (0.5 + st) \/ iChannelResolution[0].xy, -100.0);\n}\n\nvoid StoreValue(vec2 st, vec4 value, inout vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = (IsInside(fragCoord, st) > 0.0 )? value : fragColor;\n}\n\nvoid LoadState()\n{\n    vec4 state1 = LoadValue(kTexState1);\n    vec4 state2 = LoadValue(kTexState2);\n    vec4 state3 = LoadValue(kTexState3);\n    vec4 state4 = LoadValue(kTexState4);\n    vec4 state5 = LoadValue(kTexState5);\n    \n    gGameState            = state1.x;\n    gGameStateTime        = state1.y;\n    gGameSeed             = state1.z;\n    gGameInit             = state1.w;\n    gPlayerCoords         = state2.xy; \n    gPlayerNextCoords     = state2.zw;\n    gPlayerMotionTimer    = state3.x;\n    gPlayerRotation       = state3.y;\n    gPlayerNextRotation   = state3.z;\n    gPlayerScale          = state3.w;\n    gPlayerVisualCoords   = state4.xyz;\n    gPlayerVisualRotation = state4.w;\n    gPlayerDeathCause     = state5.x;\n    gPlayerDeathTime      = state5.y;\n    gScore                = state5.z;\n    gFbScale              = state5.w;\n}\n\nvoid StoreState(inout vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 state1 = vec4(gGameState, gGameStateTime, gGameSeed, gGameInit);\n    vec4 state2 = vec4(gPlayerCoords, gPlayerNextCoords);\n    vec4 state3 = vec4(gPlayerMotionTimer, gPlayerRotation, gPlayerNextRotation, gPlayerScale);\n    vec4 state4 = vec4(gPlayerVisualCoords, gPlayerVisualRotation);\n    vec4 state5 = vec4(gPlayerDeathCause, gPlayerDeathTime, gScore, gFbScale);\n    \n    StoreValue(kTexState1, state1, fragColor, fragCoord);\n    StoreValue(kTexState2, state2, fragColor, fragCoord);\n    StoreValue(kTexState3, state3, fragColor, fragCoord);\n    StoreValue(kTexState4, state4, fragColor, fragCoord);\n    StoreValue(kTexState5, state5, fragColor, fragCoord);\n}\n\n\/\/ -- Hashing functions --------------------------------------------------------\n\nvec4 Hash(float p)\n{\n    vec2 h = vec2(p) * vec2(1.271,3.117) + gGameSeed;\n    return texture(iChannel3, h \/ iChannelResolution[3].xy, -100.0);\n}\n\nvec4 Hash(vec2 p)\n{\n    vec2 h = p.xy * vec2(1.271,3.117) + gGameSeed;\n    return texture(iChannel3, h \/ iChannelResolution[3].xy, -100.0);\n}\n\nvec4 Hash(vec3 p)\n{\n    vec2 h = p.xy * vec2(1.271,3.117) + p.z * vec2(1.833,4.192) + gGameSeed;\n    return texture(iChannel3, h \/ iChannelResolution[3].xy, -100.0);\n}\n\n\/\/ -- Scene tile functions -----------------------------------------------------\n\n\/\/ Procedural tile management.\n\nfloat GetSceneTileIndex(float z)\n{\n    \/\/ The scene is separated into chunks of 5 consecutive tiles, where\n    \/\/ each chunk is simply a predefined set of tiles.\n    \n    \/\/ First, determine the chunk index and it's type, based on that index.\n    float chunkIndex = floor(z * kSceneInvChunkTiles);\n    float chunkType  = floor(kSceneNumChunks * Hash(chunkIndex).x) * step(1.0, chunkIndex);\n        \n   \t\/\/ Second, determine the tile number we're referring to inside the chunk.\n\tfloat tileNum = floor(kSceneChunkTiles * (z * kSceneInvChunkTiles - chunkIndex));\n    \n    \/\/ Finally, depending upon the chunk type, determine which tile occupies\n    \/\/ that location.\n\tfloat tileIdx = 0.0;\n\t\n\tif (chunkType == 0.0)\n\t{\n\t\ttileIdx = kSceneTileSnow;\n\t}\n\telse if (chunkType == 1.0)\n\t{\n\t\ttileIdx = mix(kSceneTileIceRoad, kSceneTileSnow, step(1.5, tileNum));\n\t\ttileIdx = mix(tileIdx, kSceneTileIceRoad,        step(2.5, tileNum));\n\t}\n\telse if (chunkType == 2.0)\n\t{\n\t\ttileIdx = mix(kSceneTileSnow, kSceneTileWater, step(0.5, tileNum));\n\t\ttileIdx = mix(tileIdx, kSceneTileSnow,         step(2.5, tileNum));\n\t}\n\t\n\treturn tileIdx;\n}\n\n\/\/ Snow tile management.\n\nfloat GetSceneSnowTileTreeChance(float coords, float treeIdx)\n{\n    return step(0.5, Hash(vec2(coords, treeIdx)).x) * step(0.5, coords);\n}\n\nfloat GetSceneSnowTileTreeCoord(float coords, float treeIdx)\n{\n    return floor(-kSceneWidth + 2.0 * kSceneWidth * Hash(vec2(coords, treeIdx)).y);\n}\n\n\/\/ Water and ice tiles common management.\n\nvec4 GetSceneTileVSS(float coords, float minWidth, float maxWidth, float playerCoef)\n{\n    vec4 t;\n    vec3 h = Hash(coords).xyz;\n    t.x = (kSceneMinTileSpeed + floor(kSceneMaxTileSpeed * h.x)) * (2.0 * step(0.5, h.y) - 1.0);\n    t.y = floor(mix(minWidth, maxWidth, h.z));\n    t.z = 2.0 * t.y;\n    t.w = playerCoef;\n    return t;\n}\n\nvec4 GetSceneTileVss(vec3 coordsTile)\n{\n    vec4 vss = vec4(0.0);\n    \n    if (coordsTile.z == kSceneTileWater)\n        vss = GetSceneTileVSS(coordsTile.y, 3.0, 6.0, 1.0);\n\n    if (coordsTile.z == kSceneTileIceRoad)\n\t\tvss = GetSceneTileVSS(coordsTile.y, 3.0, 8.0, 0.0);\n    \n    return vss;\n}\n\n\/\/ -- Scene gameplay functions -------------------------------------------------\n\n\/\/ Tile gameplay management.\n\nvec3 GetSceneCoordsTile(vec2 loc)\n{\n    return vec3(floor(loc), GetSceneTileIndex(loc.y));\n}\n\nfloat GetSceneTileLocalSpaceLoc(float loc, vec4 vss)\n{\n    loc = loc - iTime * vss.x;\n    return vss.z * fract(loc \/ vss.z);\n}\n\nvec4 GetSceneTileVss(vec2 loc)\n{\n    vec3 coordsTile = GetSceneCoordsTile(loc);\n    return GetSceneTileVss(coordsTile);\n}\n\nfloat GetSceneTileBehaviour(vec2 loc)\n{\n    vec3 coordsTile = GetSceneCoordsTile(loc);\n    vec4 vss = GetSceneTileVss(coordsTile);\n    \n    \/\/ Anything below or above the scene width is an obstacle.\n\tfloat isObstacle = max(step(1.0, -coordsTile.y), step(kSceneWidth + 0.5, abs(coordsTile.x)));\n\tfloat isWater = 0.0;\n    float isHazard = 0.0;\n    float isOutOfScreen = 0.0;\n    \n    \/\/ Check for each tile case.\n    if (coordsTile.z == kSceneTileSnow)\n    {\n        for (int i = 0; i < 5; i++)\n        {\n            float treeChance = GetSceneSnowTileTreeChance(coordsTile.y, float(i));\n            float treeCoord = GetSceneSnowTileTreeCoord(coordsTile.y, float(i));\n            \n            isObstacle = max(isObstacle, treeChance * (1.0 - step(0.5, abs(coordsTile.x - treeCoord))));\n        }\n    }\n    else if (coordsTile.z == kSceneTileWater)\n    {\n        isOutOfScreen = isObstacle;\n        isObstacle = 0.0;\n        \n        float l = GetSceneTileLocalSpaceLoc(loc.x, vss);        \n        if (l > vss.y) isWater = 1.0;\n    }\n    else if (coordsTile.z == kSceneTileIceRoad)\n    {\n        float l = GetSceneTileLocalSpaceLoc(loc.x, vss);\n        if (l < 2.0) isHazard = 1.0;\n    }\n    \n    float behav = kBehavGround;\n    behav = mix(behav, kBehavWater, isWater);\n    behav = mix(behav, kBehavHazard, isHazard);\n    behav = mix(behav, kBehavObstacle, isObstacle);\n    behav = mix(behav, kBehavOutOfScreen, isOutOfScreen);\n    \n    return behav;\n}\n\nvec2 GetNextCoordinates(vec2 loc)\n{\n    float behav = GetSceneTileBehaviour(loc);\n    vec4 vss = GetSceneTileVss(loc);\n    \n    float lsloc = vss.w == 0.0 && behav != kBehavWater? loc.x : GetSceneTileLocalSpaceLoc(loc.x, vss);\n    float lsloc0 = floor(lsloc) + 0.5;\n    \n    loc.y = floor(loc.y) + 0.5;\n    loc.x += (lsloc0 - lsloc);    \n    return loc;\n}\n\n\/\/ =============================================================================\n\/\/ END OF SHARED CODE\n\/\/ =============================================================================\n\n\/\/ -- Constants ----------------------------------------------------------------\n\n\/\/ Key constants.\n\nconst float kKeyLeft  = 37.5 \/ 256.0;\nconst float kKeyUp    = 38.5 \/ 256.0;\nconst float kKeyRight = 39.5 \/ 256.0;\nconst float kKeyDown  = 40.5 \/ 256.0;\nconst float kKeySpace = 32.5 \/ 256.0;\nconst float kKey1     = 49.5 \/ 256.0;\nconst float kKey2     = 50.5 \/ 256.0;\nconst float kKey3     = 51.5 \/ 256.0;\nconst float kKey4     = 52.5 \/ 256.0;\n\n\/\/ -- Aux functions ------------------------------------------------------------\n\nfloat MixAngle(float a, float b, float t)\n{\n    float d = (b - a);\n    d -= floor(d * 0.5 * kOneOverPi) * 2.0 * kPi;\n    \n    if (d > kPi)\n        d -= 2.0 * kPi;\n    \n    return a + d * t;\n}\n\nfloat JumpCurve(float x)\n{\n    return 1.0 - 4.0 * (x - 0.5) * (x - 0.5);\n}\n\n\/\/ -- IO functions -------------------------------------------------------------\n\nfloat SampleKey(float key)\n{\n\treturn step(0.5, texture(iChannel1, vec2(key, 0.25)).x);\n}\n\nvec2 SampleAxes()\n{\n    vec2 axes;\n    axes.x = SampleKey(kKeyRight) - SampleKey(kKeyLeft);\n    axes.y = (axes.x == 0.0)? SampleKey(kKeyUp) - SampleKey(kKeyDown) : 0.0;\n    return axes;\n}\n\n\/\/ -- State functions ----------------------------------------------------------\n\nvoid GameSetState(float state)\n{\n    gGameState     = state;\n    gGameStateTime = 0.0;\n}\n\nvoid GameRestart(float state)\n{\n    GameSetState(state);\n    gGameSeed             = iTime;\n    gPlayerCoords         = vec2(0.5, 0.5);\n    gPlayerNextCoords     = vec2(0.5, 0.5);\n    gPlayerMotionTimer    = 0.0;\n    gPlayerRotation       = 0.0;\n    gPlayerNextRotation   = 0.0;\n    gPlayerScale          = 1.0;\n    gPlayerVisualCoords   = vec3(gPlayerCoords, 0.0).xzy;\n    gPlayerVisualRotation = 0.0;\n    gPlayerDeathCause     = 0.0;\n    gScore                = 1.0;\n}\n\nvoid GameUpdate()\n{\n    float behav = GetSceneTileBehaviour(gPlayerNextCoords);\n    \n    if (behav == kBehavObstacle)\n    {\n        GameSetState(kStateGameOver);\n        gPlayerDeathCause = behav;\n        gPlayerDeathTime = iTime;\n    }\n    else if (gPlayerMotionTimer >= 1.0 && gGameState != kStateGameOver)\n    {       \n        gPlayerCoords = gPlayerNextCoords;\n        gPlayerRotation = gPlayerNextRotation;\n        \n        if (behav != kBehavGround)\n        {\n            GameSetState(kStateGameOver);\n            gPlayerDeathCause = behav;\n            gPlayerDeathTime = iTime;\n        }\n        else\n        {       \n            vec2 axes = SampleAxes();\n\n            if (dot(axes, axes) > 0.0)\n            {\n                vec2 nextCoords = GetNextCoordinates(gPlayerCoords + axes);\n\n                if (GetSceneTileBehaviour(nextCoords) != kBehavObstacle)\n                {\n                    gPlayerNextCoords = nextCoords;\n                    gPlayerMotionTimer = 0.0;\n                    gPlayerNextRotation = atan(axes.x, axes.y);\n\t\t\t\t\tgScore = max(gScore, floor(nextCoords.y));\n                }\n            }\n        }\n    }\n    else\n    {\n        gPlayerMotionTimer += iTimeDelta * kPlayerSpeed;\n    }\n        \n    vec4 coordsVss = GetSceneTileVss(gPlayerCoords);\n    vec4 nextCoordsVss = GetSceneTileVss(gPlayerNextCoords);\n    gPlayerCoords.x += coordsVss.x * coordsVss.w * iTimeDelta;\n    gPlayerNextCoords.x += nextCoordsVss.x * nextCoordsVss.w * iTimeDelta;\n    gPlayerVisualCoords.xz = mix(gPlayerCoords, gPlayerNextCoords, clamp(gPlayerMotionTimer, 0.0, 1.0));\n    gPlayerVisualCoords.y  = kPlayerJumpHeight * JumpCurve(min(1.0, gPlayerMotionTimer));\n    gPlayerVisualRotation  = MixAngle(gPlayerRotation, gPlayerNextRotation, clamp(gPlayerMotionTimer, 0.0, 1.0));\n    gPlayerScale = 1.0 + 0.1 * JumpCurve(min(1.0, gPlayerMotionTimer));\n    \n    if (gGameState == kStateGameOver)\n    {\n         if (gPlayerDeathCause == kBehavWater)\n             gPlayerVisualCoords.y = kPlayerJumpHeight * JumpCurve(gPlayerMotionTimer);\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (fragCoord.x > 14.0 || fragCoord.y > 14.0)\n        discard;\n\n    LoadState();\n       \n    if (gGameInit == 0.0)\n    {\n\t\tGameRestart(kStateTitle);\n        gFbScale = 1.0;\n        gGameInit = 1.0;\n    }\n    else if (gGameState == kStateTitle)\n    {\n        if (SampleKey(kKeySpace) == 1.0)\n            GameSetState(kStateInGame);\n    }\n    else if (gGameState == kStateInGame)\n    {\n        GameUpdate();\n    }\n    else if (gGameState == kStateGameOver)\n    {\n        GameUpdate();\n        \n        if (SampleKey(kKeySpace) == 1.0)\n            GameSetState(kStateRestarting);\n    }\n    else\n    {\n        if (gGameStateTime > 1.0)\n            GameRestart(kStateTitle);\n    }\n \n    if (SampleKey(kKey1) == 1.0)\n        gFbScale = 1.0;\n    \n    if (SampleKey(kKey2) == 1.0)\n        gFbScale = 0.75;\n    \n    if (SampleKey(kKey3) == 1.0)\n        gFbScale = 0.5;\n    \n    if (SampleKey(kKey4) == 1.0)\n        gFbScale = 0.25;\n    \n   \tgGameStateTime += iTimeDelta;\n    StoreState(fragColor, fragCoord);\n}",
            "name": "Buf A",
            "description": "",
            "type": "buffer"
        },
        {
            "inputs": [
                {
                    "id": "Xsf3zn",
                    "filepath": "\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
                    "previewfilepath": "\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
                    "type": "texture",
                    "channel": 3,
                    "sampler": {
                        "filter": "nearest",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "nearest",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "XsXGR8",
                    "channel": 0
                }
            ],
            "code": "\/*\n\n(06\/11\/16)\n\nSome instructions on how to play:\n\nSpace: Used to start the game and restarting on Game Over.\nArrows: Move around the player character.\n1-4: Change the render buffer resolution to get a\n     big speedup (1 - 100%, 2 - 75%, 3 - 50%, 4 - 25%).\n\n--------------------------------------\n\nKnown Issues:\n\n- Some drivers might take long to compile the shader, we're currently looking into this.\n- You might find that the player moves weirdly when jumping\n  on water tiles, we'll try to figure out a better way to handle those cases.\n\nPotential Issues:\n\n- We haven't battle tested the shader on other GPUs than NVIDIA,\n  so we don't know if they'll work at all.\n\n*\/\n\n\/\/ =============================================================================\n\/\/ START OF SHARED CODE\n\/\/ =============================================================================\n\n\/\/ -- Constants ----------------------------------------------------------------\n\n\/\/ State constants.\n\nconst float kStateTitle      = 0.0;\nconst float kStateInGame     = 1.0;\nconst float kStateGameOver   = 2.0;\nconst float kStateRestarting = 3.0;\n\n\/\/ Scene constants.\n\nconst float kSceneWidth         = 5.0;\nconst float kSceneMinTileSpeed  = 2.0;\nconst float kSceneMaxTileSpeed  = 2.0;\n\nconst float kSceneNumChunks     = 3.0;     \/\/ Number of pre-defined chunks in the scene.\nconst float kSceneChunkTiles    = 5.0;     \/\/ Number of tiles per chunk.\nconst float kSceneInvChunkTiles = 0.2;     \/\/ Inverse number of tiles per chunk.\n\nconst float kSceneTileSnow      = 0.0;     \/\/ Id of the snow tile.\nconst float kSceneTileIceRoad   = 1.0;     \/\/ Id of the ice road tile.\nconst float kSceneTileWater     = 2.0;     \/\/ Id of the water tile.\n\nconst float kBehavGround        = 0.0;\nconst float kBehavWater         = 1.0;\nconst float kBehavObstacle      = 2.0;\nconst float kBehavHazard        = 3.0;\nconst float kBehavOutOfScreen   = 4.0;\n\n\/\/ Player motion constants.\n\nconst float kPlayerSpeed      = 5.0;\nconst float kPlayerJumpHeight = 0.3;\n\n\/\/ State coordinates.\n\nconst vec2 kTexState1 = vec2(0.0, 0.0); \/\/ x   = Current state,  y  = State time, w = Init\nconst vec2 kTexState2 = vec2(1.0, 0.0); \/\/ xy  = Current coords, zw = Next coords\nconst vec2 kTexState3 = vec2(2.0, 0.0); \/\/ x   = Motion time, y = Rotation, z = NextRotation, w = Scale\nconst vec2 kTexState4 = vec2(3.0, 0.0); \/\/ xyz = Coordinates, w = Rotation\nconst vec2 kTexState5 = vec2(4.0, 0.0); \/\/ x   = Death cause, y = Death time, z = Score, w = Fb. Scale\n\n\/\/ Misc constants.\n\nconst float kPi = 3.14159265359;\nconst float kOneOverPi = 0.31830988618;\nconst float kOmega = 1e20;\n\n\/\/ -- Global values ------------------------------------------------------------\n\nfloat gGameState;\nfloat gGameStateTime;\nfloat gGameInit;\nfloat gGameSeed;\nvec2  gPlayerCoords;\nvec2  gPlayerNextCoords;\nfloat gPlayerMotionTimer;\nfloat gPlayerRotation;\nfloat gPlayerNextRotation;\nfloat gPlayerScale;\nvec3  gPlayerVisualCoords;\nfloat gPlayerVisualRotation;\nfloat gPlayerDeathCause;\nfloat gPlayerDeathTime;\nfloat gScore;\nfloat gFbScale;\n\n\/\/ -- State functions ----------------------------------------------------------\n\nfloat IsInside(vec2 p, vec2 c)\n{\n    vec2 d = abs(p - 0.5 - c) - 0.5;\n    return -max(d.x, d.y);\n}\n\nvec4 LoadValue(vec2 st)\n{ \n    return texture(iChannel0, (0.5 + st) \/ iChannelResolution[0].xy, -100.0);\n}\n\nvoid LoadState()\n{\n    vec4 state1 = LoadValue(kTexState1);\n    vec4 state2 = LoadValue(kTexState2);\n    vec4 state3 = LoadValue(kTexState3);\n    vec4 state4 = LoadValue(kTexState4);\n    vec4 state5 = LoadValue(kTexState5);\n    \n    gGameState            = state1.x;\n    gGameStateTime        = state1.y;\n    gGameSeed             = state1.z;\n    gGameInit             = state1.w;\n    gPlayerCoords         = state2.xy;\n    gPlayerNextCoords     = state2.zw;\n    gPlayerMotionTimer    = state3.x;\n    gPlayerRotation       = state3.y;\n    gPlayerNextRotation   = state3.z;\n    gPlayerScale          = state3.w;\n    gPlayerVisualCoords   = state4.xyz;\n    gPlayerVisualRotation = state4.w;\n    gPlayerDeathCause     = state5.x;\n    gPlayerDeathTime      = state5.y;\n    gScore                = state5.z;\n    gFbScale              = state5.w;\n}\n\n\/\/ -- Hashing functions --------------------------------------------------------\n\nvec4 Hash(float p)\n{\n    vec2 h = vec2(p) * vec2(1.271,3.117) + gGameSeed;\n    return texture(iChannel3, h \/ iChannelResolution[3].xy, -100.0);\n}\n\nvec4 Hash(vec2 p)\n{\n    vec2 h = p.xy * vec2(1.271,3.117) + gGameSeed;\n    return texture(iChannel3, h \/ iChannelResolution[3].xy, -100.0);\n}\n\nvec4 Hash(vec3 p)\n{\n    vec2 h = p.xy * vec2(1.271,3.117) + p.z * vec2(1.833,4.192) + gGameSeed;\n    return texture(iChannel3, h \/ iChannelResolution[3].xy, -100.0);\n}\n\n\/\/ -- Scene tile functions -----------------------------------------------------\n\n\/\/ Procedural tile management.\n\nfloat GetSceneTileIndex(float z)\n{\n    \/\/ The scene is separated into chunks of 5 consecutive tiles, where\n    \/\/ each chunk is simply a predefined set of tiles.\n    \n    \/\/ First, determine the chunk index and it's type, based on that index.\n    float chunkIndex = floor(z * kSceneInvChunkTiles);\n    float chunkType  = floor(kSceneNumChunks * Hash(chunkIndex).x) * step(1.0, chunkIndex);\n        \n   \t\/\/ Second, determine the tile number we're referring to inside the chunk.\n\tfloat tileNum = floor(kSceneChunkTiles * (z * kSceneInvChunkTiles - chunkIndex));\n    \n    \/\/ Finally, depending upon the chunk type, determine which tile occupies\n    \/\/ that location.\n\tfloat tileIdx = 0.0;\n\t\n\tif (chunkType == 0.0)\n\t{\n\t\ttileIdx = kSceneTileSnow;\n\t}\n\telse if (chunkType == 1.0)\n\t{\n\t\ttileIdx = mix(kSceneTileIceRoad, kSceneTileSnow, step(1.5, tileNum));\n\t\ttileIdx = mix(tileIdx, kSceneTileIceRoad,        step(2.5, tileNum));\n\t}\n\telse if (chunkType == 2.0)\n\t{\n\t\ttileIdx = mix(kSceneTileSnow, kSceneTileWater, step(0.5, tileNum));\n\t\ttileIdx = mix(tileIdx, kSceneTileSnow,         step(2.5, tileNum));\n\t}\n\t\n\treturn tileIdx;\n}\n\n\/\/ Snow tile management.\n\nfloat GetSceneSnowTileTreeChance(float coords, float treeIdx)\n{\n    return step(0.5, Hash(vec2(coords, treeIdx)).x) * step(0.5, coords);\n}\n\nfloat GetSceneSnowTileTreeCoord(float coords, float treeIdx)\n{\n    return floor(-kSceneWidth + 2.0 * kSceneWidth * Hash(vec2(coords, treeIdx)).y);\n}\n\n\/\/ Water and ice tiles common management.\n\nvec4 GetSceneTileVSS(float coords, float minWidth, float maxWidth, float playerCoef)\n{\n    vec4 t;\n    vec3 h = Hash(coords).xyz;\n    t.x = (kSceneMinTileSpeed + floor(kSceneMaxTileSpeed * h.x)) * (2.0 * step(0.5, h.y) - 1.0);\n    t.y = floor(mix(minWidth, maxWidth, h.z));\n    t.z = 2.0 * t.y;\n    t.w = playerCoef;\n    return t;\n}\n\nvec4 GetSceneTileVss(vec3 coordsTile)\n{\n    vec4 vss = vec4(0.0);\n    \n    if (coordsTile.z == kSceneTileWater)\n        vss = GetSceneTileVSS(coordsTile.y, 3.0, 6.0, 1.0);\n\n    if (coordsTile.z == kSceneTileIceRoad)\n\t\tvss = GetSceneTileVSS(coordsTile.y, 3.0, 8.0, 0.0);\n    \n    return vss;\n}\n\n\/\/ -- Scene gameplay functions -------------------------------------------------\n\n\/\/ Tile gameplay management.\n\nvec3 GetSceneCoordsTile(vec2 loc)\n{\n    return vec3(floor(loc), GetSceneTileIndex(loc.y));\n}\n\nfloat GetSceneTileLocalSpaceLoc(float loc, vec4 vss)\n{\n    loc = loc - iTime * vss.x;\n    return vss.z * fract(loc \/ vss.z);\n}\n\nvec4 GetSceneTileVss(vec2 loc)\n{\n    vec3 coordsTile = GetSceneCoordsTile(loc);\n    return GetSceneTileVss(coordsTile);\n}\n\nfloat GetSceneTileBehaviour(vec2 loc)\n{\n    vec3 coordsTile = GetSceneCoordsTile(loc);\n    vec4 vss = GetSceneTileVss(coordsTile);\n    \n    \/\/ Anything below or above the scene width is an obstacle.\n\tfloat isObstacle = max(step(1.0, -coordsTile.y), step(kSceneWidth + 0.5, abs(coordsTile.x)));\n\tfloat isWater = 0.0;\n    float isHazard = 0.0;\n    float isOutOfScreen = 0.0;\n    \n    \/\/ Check for each tile case.\n    if (coordsTile.z == kSceneTileSnow)\n    {\n        for (int i = 0; i < 5; i++)\n        {\n            float treeChance = GetSceneSnowTileTreeChance(coordsTile.y, float(i));\n            float treeCoord = GetSceneSnowTileTreeCoord(coordsTile.y, float(i));\n            \n            isObstacle = max(isObstacle, treeChance * (1.0 - step(0.5, abs(coordsTile.x - treeCoord))));\n        }\n    }\n    else if (coordsTile.z == kSceneTileWater)\n    {\n        isOutOfScreen = isObstacle;\n        isObstacle = 0.0;\n        \n        float l = GetSceneTileLocalSpaceLoc(loc.x, vss);        \n        if (l > vss.y) isWater = 1.0;\n    }\n    else if (coordsTile.z == kSceneTileIceRoad)\n    {\n        float l = GetSceneTileLocalSpaceLoc(loc.x, vss);\n        if (l < 2.0) isHazard = 1.0;\n    }\n    \n    float behav = kBehavGround;\n    behav = mix(behav, kBehavWater, isWater);\n    behav = mix(behav, kBehavHazard, isHazard);\n    behav = mix(behav, kBehavObstacle, isObstacle);\n    behav = mix(behav, kBehavOutOfScreen, isOutOfScreen);\n    \n    return behav;\n}\n\n\/\/ =============================================================================\n\/\/ END OF SHARED CODE\n\/\/ =============================================================================\n\n\/\/ =============================================================================\n\/\/ START OF RENDER CODE\n\/\/ =============================================================================\n\n\/\/ -- Constants ----------------------------------------------------------------\n\n\/\/ RayMarching constants\n\nconst int   kMaxSteps          = 30;    \/\/ Max number of raymarching steps\nconst float kStepRatio         = 1.0;\nconst float kMaxDistance       = 50.0;  \/\/ Max raymarching distance\nconst float kMinDistance       = 13.0;  \/\/ Max raymarching distance\nconst float kBias              = 0.05;  \/\/ Bias offset for normal estimation\nconst float kParallelThreshold = 1e-5;\nconst float kNoHit             = -1.0;  \/\/ No intersection distance.\n        \n\/\/ Material constants.\nconst float kMaterialNone                 = 0.0;\nconst float kMaterialPenguinBlackFeathers = 1.0;\nconst float kMaterialPenguinWhiteFeathers = 2.0;\nconst float kMaterialPenguinEyes          = 3.0;\nconst float kMaterialPenguinBeak          = 4.0;\nconst float kMaterialSledMetal            = 5.0;\nconst float kMaterialSled                 = 6.0;\nconst float kMaterialMonsterSkinGreen     = 7.0;\nconst float kMaterialMonsterSkinWhite     = 8.0;\nconst float kMaterialEnvironmentSnow      = 9.0;\nconst float kMaterialEnvironmentIce       = 10.0;\nconst float kMaterialEnvironmentWater     = 11.0;\nconst float kMaterialTreeWood             = 12.0;\nconst float kMaterialTreeLeaves           = 9.0;\nconst float kMaterialRiderSkin            = 14.0;\nconst float kMaterialRiderCloth1          = 15.0;\nconst float kMaterialRiderCloth2          = 16.0;\n\n\/\/ Other constants\n\nconst vec3 kOnes = vec3(1.0, -1.0, 0.0);               \/\/ Helper vector with ones.\n\n\/\/ -- Global values ------------------------------------------------------------\n\nvec3 gCameraPosition;\nvec4 gCameraRotation;\n\n\/\/ -- Structures ---------------------------------------------------------------\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct RayHit\n{\n    float time;\n    float material;\n};\n\nstruct DistSample\n{\n    float dist;\n    float stepRatio;\n    float material;\n};\n\n    \n\/\/ --- Math funcs --------------------------------------------------------------\n\nvec4 QMul(vec4 q1, vec4 q2)\n{\n    vec4 res;\n    res.w = q1.w * q2.w - dot(q1.xyz, q2.xyz);\n    res.xyz = q1.w * q2.xyz + q2.w * q1.xyz + cross(q1.xyz, q2.xyz);\n    return res;\n}\n\nvec4 QAxisAngle(vec3 axis, float angle)\n{\n    float theta = 0.5 * angle;\n    float sine = sin(theta);\n    return vec4(sin(theta) * axis, cos(theta));\n}\n\nvec4 QConjugate(vec4 q)\n{\n    return vec4(q.xyz, -q.w);\n}\n\nvec3 QTransform(vec3 v, vec4 q)\n{\n    vec3 t = 2.0 * cross(q.xyz, v);\n    return v + q.w * t + cross(q.xyz, t);\n}\n\nvec4 QEuler(vec3 angles)\n{\n    vec4 qx = QAxisAngle(vec3(1.0, 0.0, 0.0), angles.x);\n    vec4 qy = QAxisAngle(vec3(0.0, 1.0, 0.0), angles.y);\n    vec4 qz = QAxisAngle(vec3(0.0, 0.0, 1.0), angles.z);\n    return QMul(qz, QMul(qy, qx));\n}\n\n\/\/ -- Misc. functions ----------------------------------------------------------\n\nvec3 HSV(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 \/ 3.0, 1.0 \/ 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat smin(float a, float b, float k)\n{\n    \/\/float h = clamp( 0.5+0.5*(b-a)\/k, 0.0, 1.0 );\n    \/\/return mix(b, a, h) - k*h*(1.0-h);\n    float h = clamp((b - a)\/k, -1.0, 1.0);\n    return mix(b, a, smoothstep(-1.0, 1.0, h));\n}\n\n\n\/\/ -- Noise functions ----------------------------------------------------------\n\nfloat Perlin(vec2 p)\n{    \n    vec4 i;\n    i.xy = floor(p);\n    i.zw = i.xy + vec2(1.0, 1.0);\n    \n    vec2 f = fract(p);  \n    vec2 u = smoothstep(0.0, 1.0, f);\n    \n    float f00 = mix(Hash(i.xy).x, Hash(i.zy).x, u.x);\n    float f01 = mix(Hash(i.xw).x, Hash(i.zw).x, u.x);\n    float f1 = mix(f00, f01, u.y);\n    \n    return f1;\n}\n\nfloat Cellular(vec3 p, float k)\n{\n    vec3 i = floor(p);\n\tfloat d = 1.0;\n\t\n\tfor (int x = -1; x <= 1; x++)\n\tfor (int y = -1; y <= 1; y++)\n    for (int z = -1; z <= 1; z++)\n\t{\n\t\tvec3 q = i + vec3(x, y, z);\n\t\tq += Hash(q).xyz - p;\n\t\td = smin(d, dot(q, q), k);\n\t}\n\n    return sqrt(d);\n}\n\n\/\/ -- Ray funcs ----------------------------------------------------------------\n\nRay MakeRay(vec3 ro, vec3 rd)\n{\n\tRay ray;\n\tray.origin = ro;\n\tray.direction = rd;\n\treturn ray;\n}\n\nRayHit MakeRayHit(float t, float m)\n{\n    RayHit h;\n    h.time = t;\n    h.material = m;\n    return h;\n}\n\nDistSample MakeDistSample(float d, float s, float m)\n{\n    DistSample h;\n    h.dist = d;\n    h.stepRatio = s;\n    h.material = m;\n    return h;\n}\n\n\/\/ -- SDF CGS funcs ------------------------------------------------------------\n\nDistSample OpU(DistSample d1, DistSample d2)\n{\n    if (d1.dist < d2.dist) return d1; return d2;\n}\n\nDistSample OpS(DistSample d1, DistSample d2)\n{\n    d2.dist = -d2.dist;\n    if (d1.dist > d2.dist) return d1; return d2;\n}\n\nDistSample OpI(DistSample d1, DistSample d2)\n{\n    if (d1.dist > d2.dist) return d1; return d2;\n}\n\n\/\/ -- Transform funcs ----------------------------------------------------------\n\nvec3 Tx(vec3 p, vec3 tx)\n{\n    return (p - tx);\n}\n\nvec3 Tx(vec3 p, vec3 tx, vec3 s)\n{\n    p -= tx;\n    p \/= s;\n    return p;\n}\n\nvec3 Tx(vec3 p, vec3 tx, vec4 q)\n{\n    p -= tx;\n    return QTransform(p, QConjugate(q));\n}\n\nvec3 Tx(vec3 p, vec3 tx, vec4 q, vec3 s)\n{\n    p -= tx;\n    p = QTransform(p, QConjugate(q));\n    p \/= s;    \n    return p;\n}\n\nvec3 Tx(vec3 p, vec3 tx, vec3 axis, float angle)\n{\n    return Tx(p, tx, QAxisAngle(axis, angle));\n}\n\nvec3 Tx(vec3 p, vec3 tx, vec3 axis, float angle, vec3 s)\n{\n    return Tx(p, tx, QAxisAngle(axis, angle), s);\n}\n\n\/\/ -- SDF funcs ----------------------------------------------------------------\n\nDistSample SdfBox(vec3 p, vec3 b, float mat)\n{\n  vec3 d = abs(p) - b;\n  return MakeDistSample(min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0)), 1.0, mat);\n}\n\nDistSample SdfPenguin(vec3 p)\n{\n    DistSample result = SdfBox(p, vec3(0.75), kMaterialNone);\n    \n    if (result.dist < 0.5)\n    {\n        if (gGameState == kStateGameOver && gPlayerDeathCause == kBehavHazard)\n        {\n            DistSample result = SdfBox(Tx(p, vec3(0, 0.047, -0.082)), vec3(0.2799999, 0.04, 0.1204678), kMaterialPenguinBlackFeathers);\n            result = OpU(result, SdfBox(Tx(p, vec3(0, 0.107, 0.038)), vec3(0.28, 0.02, 0.24), kMaterialPenguinBlackFeathers));\n            result = OpU(result, SdfBox(Tx(p, vec3(0, 0.047, 0.158)), vec3(0.28, 0.04, 0.12), kMaterialPenguinWhiteFeathers));\n            result = OpU(result, SdfBox(Tx(p, vec3(0, 0.031, -0.282)), vec3(0.28, 0.024, 0.08000001), kMaterialPenguinBlackFeathers));\n            result = OpU(result, SdfBox(Tx(p, vec3(0, 0.095, 0.29)), vec3(0.12, 0.008, 0.08000001), kMaterialPenguinBeak));\n            result = OpU(result, SdfBox(Tx(p, vec3(-0.152, -0.001, -0.022)), vec3(0.048, 0.01, 0.06000001), kMaterialPenguinBeak));\n            result = OpU(result, SdfBox(Tx(p, vec3(0.152, -0.001, -0.022)), vec3(0.048, 0.01, 0.06000001), kMaterialPenguinBeak));\n            result = OpU(result, SdfBox(Tx(p, vec3(0.152, -0.009, 0.01)), vec3(0.112, 0.004, 0.16), kMaterialPenguinBeak));\n            result = OpU(result, SdfBox(Tx(p, vec3(-0.152, -0.009, 0.01)), vec3(0.112, 0.004, 0.16), kMaterialPenguinBeak));\n            result = OpU(result, SdfBox(Tx(p, vec3(0.136, 0.111, 0.29)), vec3(0.032, 0.006000001, 0.012), kMaterialPenguinEyes));\n            result = OpU(result, SdfBox(Tx(p, vec3(-0.136, 0.111, 0.29)), vec3(0.032, 0.006000001, 0.012), kMaterialPenguinEyes));\n            result = OpU(result, SdfBox(Tx(p, vec3(0.323, 0.037, -0.002), vec4(0, 0, 0.1736482, 0.9848078)), vec3(0.05, 0.028, 0.12), kMaterialPenguinBlackFeathers));\n            result = OpU(result, SdfBox(Tx(p, vec3(-0.342, 0.045, -0.002), vec4(0, 0, -0.1736482, 0.9848078)), vec3(0.04999999, 0.028, 0.12), kMaterialPenguinBlackFeathers));\n            return result;\n\n        }\n        else\n        {\n            result = SdfBox(Tx(p, vec3(0, 0.296, -0.0855)), vec3(0.14, 0.2, 0.06023391), kMaterialPenguinBlackFeathers);\n            result = OpU(result, SdfBox(Tx(p, vec3(0, 0.596, -0.0255)), vec3(0.14, 0.1, 0.12), kMaterialPenguinBlackFeathers));\n            result = OpU(result, SdfBox(Tx(p, vec3(0, 0.296, 0.0345)), vec3(0.14, 0.2, 0.06000001), kMaterialPenguinWhiteFeathers));\n            result = OpU(result, SdfBox(Tx(p, vec3(0, 0.216, -0.1855)), vec3(0.14, 0.12, 0.04), kMaterialPenguinBlackFeathers));\n            result = OpU(result, SdfBox(Tx(p, vec3(0, 0.536, 0.1005)), vec3(0.06, 0.04, 0.04), kMaterialPenguinBeak));\n            result = OpU(result, SdfBox(Tx(p, vec3(-0.076, 0.056, -0.0555)), vec3(0.024, 0.05, 0.03), kMaterialPenguinBeak));\n            result = OpU(result, SdfBox(Tx(p, vec3(0.076, 0.056, -0.0555)), vec3(0.024, 0.05, 0.03), kMaterialPenguinBeak));\n            result = OpU(result, SdfBox(Tx(p, vec3(0.076, 0.016, -0.0395)), vec3(0.056, 0.02, 0.08000001), kMaterialPenguinBeak));\n            result = OpU(result, SdfBox(Tx(p, vec3(-0.076, 0.016, -0.0395)), vec3(0.056, 0.02, 0.08000001), kMaterialPenguinBeak));\n            result = OpU(result, SdfBox(Tx(p, vec3(0.068, 0.616, 0.1005)), vec3(0.016, 0.03, 0.006000001), kMaterialPenguinEyes));\n            result = OpU(result, SdfBox(Tx(p, vec3(-0.068, 0.616, 0.1005)), vec3(0.016, 0.03, 0.006000001), kMaterialPenguinEyes));\n            result = OpU(result, SdfBox(Tx(p, vec3(0.18, 0.316, -0.0455), vec4(0, 0, 0.1736482, 0.9848078)), vec3(0.025, 0.14, 0.06000001), kMaterialPenguinBlackFeathers));\n            result = OpU(result, SdfBox(Tx(p, vec3(-0.18, 0.316, -0.0455), vec4(0, 0, -0.1736482, 0.9848078)), vec3(0.025, 0.14, 0.06000001), kMaterialPenguinBlackFeathers));\n        }\n    }\n    return result;\n}\n\nDistSample SdfSled(vec3 p)\n{\n    DistSample result = SdfBox(Tx(p, vec3(0, 0.241, 0.1725)), vec3(0.294, 0.07, 0.49), kMaterialSled);\n    result = OpU(result, SdfBox(Tx(p, vec3(0, 0.42, -0.5625)), vec3(0.294, 0.25, 0.245), kMaterialSled));\n    result = OpU(result, SdfBox(Tx(p, vec3(0.168, 0.136, -0.5625)), vec3(0.0336, 0.07, 0.049), kMaterialSledMetal));\n    result = OpU(result, SdfBox(Tx(p, vec3(-0.168, 0.136, -0.5625)), vec3(0.0336, 0.07, 0.049), kMaterialSledMetal));\n    result = OpU(result, SdfBox(Tx(p, vec3(0.168, 0.136, 0.07450002)), vec3(0.0336, 0.07, 0.049), kMaterialSledMetal));\n    result = OpU(result, SdfBox(Tx(p, vec3(-0.168, 0.136, 0.07450002)), vec3(0.0336, 0.07, 0.049), kMaterialSledMetal));\n    result = OpU(result, SdfBox(Tx(p, vec3(0.168, 0.031, 0.07450002)), vec3(0.0336, 0.028, 0.833), kMaterialSledMetal));\n    result = OpU(result, SdfBox(Tx(p, vec3(-0.168, 0.031, 0.07450002)), vec3(0.0336, 0.028, 0.833), kMaterialSledMetal));\n    result = OpU(result, SdfBox(Tx(p, vec3(0.269, 0.374, 0.1725)), vec3(0.025, 0.07, 0.49), kMaterialSled));\n    result = OpU(result, SdfBox(Tx(p, vec3(-0.269, 0.374, 0.1725)), vec3(0.025, 0.07, 0.49), kMaterialSled));\n    result = OpU(result, SdfBox(Tx(p, vec3(0, 0.407, 0.562)), vec3(0.294, 0.1, 0.1), kMaterialSled));\n    result = OpU(result, SdfBox(Tx(p, vec3(0, 0.554, -0.152)), vec3(0.15, 0.225, 0.115), kMaterialRiderCloth2));\n    result = OpU(result, SdfBox(Tx(p, vec3(0.119, 0.389, 0.033)), vec3(0.08, 0.06599999, 0.3), kMaterialRiderCloth1));\n    result = OpU(result, SdfBox(Tx(p, vec3(-0.119, 0.389, 0.033)), vec3(0.08, 0.06599999, 0.3), kMaterialRiderCloth1));\n    result = OpU(result, SdfBox(Tx(p, vec3(-0.162, 0.549, 0.005), vec4(0.3420202, 0, 0, 0.9396926)), vec3(0.032, 0.06599999, 0.25), kMaterialRiderCloth2));\n    result = OpU(result, SdfBox(Tx(p, vec3(0.162, 0.549, 0.005), vec4(0.3420202, 0, 0, 0.9396926)), vec3(0.032, 0.06599999, 0.25), kMaterialRiderCloth2));\n    result = OpU(result, SdfBox(Tx(p, vec3(0, 0.871, -0.128)), vec3(0.15, 0.1, 0.125), kMaterialRiderSkin));\n    result = OpU(result, SdfBox(Tx(p, vec3(0, 1.02, -0.128)), vec3(0.15, 0.05, 0.125), kMaterialRiderCloth1));\n    return result;    \n}\n\nDistSample SdfTree(vec3 p)\n{\n    DistSample result = SdfBox(p, vec3(1.0), kMaterialNone);\n    \n    if (result.dist < 1.0)\n    {\n\t\tDistSample result = SdfBox(Tx(p, vec3(0.5, 0.589, 0.5)), vec3(0.08700001, 0.6, 0.087), kMaterialTreeWood);\n\t\tresult = OpU(result, SdfBox(Tx(p, vec3(0.5, 0.591, 0.5)), vec3(0.348, 0.19575, 0.348), kMaterialTreeLeaves));\n        result = OpU(result, SdfBox(Tx(p, vec3(0.5, 0.985, 0.5)), vec3(0.261, 0.1305, 0.261), kMaterialTreeLeaves));\n        result = OpU(result, SdfBox(Tx(p, vec3(0.5, 1.281, 0.5)), vec3(0.174, 0.1044, 0.174), kMaterialTreeLeaves));\n        return result;\n    }\n    \n    return result;\n}\n\nDistSample SdfTreeGroup(vec3 p)\n{\n    p.x = clamp(p.x, -10.0, 10.0);\n    p.x = mod(p.x + 1.0, 2.0) - 1.0;\n    return SdfTree(p);\n}\n\nDistSample SdfSnowTile(vec3 p, vec3 coordsTile, vec4 vss)\n{\n    DistSample result = SdfBox(Tx(p, vec3(0.0, -0.5, 0.5)), vec3(30, 0.5, 0.5), kMaterialEnvironmentSnow);\n    \n    for (int i = 0; i < 5; i++)\n    {\n        float treeChance = GetSceneSnowTileTreeChance(coordsTile.y, float(i));\n        float treeCoord = GetSceneSnowTileTreeCoord(coordsTile.y, float(i));\n\n        if (treeChance > 0.0)\n            result = OpU(result, SdfTree(Tx(p, vec3(treeCoord, 0.0, 0.0))));\n    }\n    \n    float offset = step(0.5, fract(coordsTile.y * 0.5));\n    result = OpU(result, SdfTreeGroup(Tx(p, vec3(-kSceneWidth - 10.0 + offset, 0.0, 0.0))));\n    result = OpU(result, SdfTreeGroup(Tx(p, vec3(kSceneWidth + 11.0 + offset, 0.0, 0.0))));\n\treturn result;\n}\n\nDistSample SdfIceTile(vec3 p, vec3 coordsTile, vec4 vss)\n{\n    DistSample result = SdfBox(Tx(p, vec3(0.0, -0.6, 0.5)), vec3(30, 0.5, 0.5), kMaterialEnvironmentIce);\n    \n    p.x = GetSceneTileLocalSpaceLoc(p.x, vss);\n    result = OpU(result, SdfSled(Tx(p, vec3(1.0, 0.0, 0.5), vec3(0.0, 1.0, 0.0), (-0.5 + step(0.0, vss.x)) * kPi)));\n   \n\treturn result;\n}\n\nDistSample SdfWaterTile(vec3 p, vec3 coordsTile, vec4 vss)\n{   \n    DistSample result = SdfBox(Tx(p, vec3(0.0, -0.7, 0.5)), vec3(30, 0.5, 0.5), kMaterialEnvironmentWater);\n    \n    p.x = GetSceneTileLocalSpaceLoc(p.x, vss);\n    result = OpU(result, SdfBox(Tx(p, vec3(0.5 * vss.y, -0.5, 0.5)), vec3(0.5 * vss.y - 0.25, 0.5, 0.25), kMaterialEnvironmentIce));\n   \n\treturn result;\n}\n\nDistSample SdfEnvironment(vec3 p, vec3 coordsTile, vec4 vss)\n{\n    p = Tx(p, vec3(0.0, 0.0, coordsTile.y));\n    \n    if (coordsTile.z == kSceneTileSnow)         return SdfSnowTile(p, coordsTile, vss);\n    else if (coordsTile.z == kSceneTileIceRoad) return SdfIceTile(p, coordsTile, vss);\n    else                                        return SdfWaterTile(p, coordsTile, vss);\n}\n\nDistSample SdfEnvironment(vec3 p)\n{\n\tvec3 coordsTile = GetSceneCoordsTile(p.xz);\n\tvec4 vss = GetSceneTileVss(coordsTile);\n    return SdfEnvironment(p, coordsTile, vss);\n}\n\n\/\/ --- Scene funcs -------------------------------------------------------------\n\nDistSample Scene(vec3 p)\n{\n    DistSample result;\n    result = SdfPenguin(Tx(p, gPlayerVisualCoords, vec3(0, 1, 0), gPlayerVisualRotation, vec2(gPlayerScale, 1.0 \/ gPlayerScale).yxy));\n    result = OpU(result, SdfEnvironment(p));\n    return result;\n}\n\nvec3 SceneNormal(vec3 position)\n{\n    vec2 offset = vec2(0.05, 0.0);\n    float d = Scene(position - offset.xyy).dist;\n    \n    return normalize(vec3\n    (\n        Scene(position + offset.xyy).dist - d,\n        Scene(position + offset.yxy).dist - d,\n        Scene(position + offset.yyx).dist - d\n    ));\n}\n\nRayHit Raymarch(Ray ray, float tmin, float tmax)\n{\n    \/\/ We need to use a bit of an special raymarcher,\n    \/\/ as we're sampling the distance field in tiles.\n        \n    DistSample d;\n\n    float t = tmin;\n    vec3  p = ray.origin + ray.direction * t;\n    vec3  s = vec3(ray.direction.xy \/ ray.direction.z, 1.0);\n    \n    for (int i = 0; i < kMaxSteps; i++)\n    {\n        \/\/ Sample scene distance field.\n        d = Scene(p);\n        \n        \/\/ Determine the current step distance.\n        float td = d.dist * d.stepRatio * kStepRatio;\n\n        \/\/ If the ray is not parallel to the Z axis,\n        \/\/ ensure we're stopping by the axis.\n        if (abs(ray.direction.z) > kParallelThreshold)\n        {\n            \/\/ Perform slope-based intersection.\n            float dz = floor(p.z) - p.z + (ray.direction.z < 0.0? -kBias : 1.0 + kBias);\n\t\t\ttd = min(td, distance(p, p + s * dz));\n        }\n\n        p += ray.direction * td;\n        t += td;\n        \n        if (abs(d.dist) < 1e-2 || (t >= tmax))\n            break;\n    }\n    \n    if (t < kMaxDistance)\n        return MakeRayHit(t, d.material);\n    \n    return MakeRayHit(kNoHit, kMaterialNone);\n}\n\n\nvoid Material(float material, vec3 position, out vec3 albedo, out float specular, out float shininess)\n{\n    if (material == kMaterialPenguinBlackFeathers)\n    {\n        albedo = vec3(0.35, 0.27, 0.82);\n        specular = 0.3;\n        shininess = 256.0;\n    }\n    else if (material == kMaterialPenguinWhiteFeathers)\n    {\n        albedo = vec3(1, 1, 1);\n        specular = 0.3;\n        shininess = 256.0;\n    }   \n    else if (material == kMaterialPenguinEyes)\n    {\n        albedo = vec3(0.1, 0.1, 0.1);\n        specular = 0.3;\n        shininess = 256.0;\n    }   \n    else if (material == kMaterialPenguinBeak)\n    {\n        albedo = vec3(1.0, 0.26, 0.055225);\n        specular = 0.3;\n        shininess = 256.0;\n    }   \n    else if (material == kMaterialMonsterSkinGreen)\n    {\n        albedo = vec3(0.0484, 0.8836, 0.0576);\n        specular = 0.3;\n        shininess = 1024.0;\n    }\n    else if (material == kMaterialEnvironmentSnow)\n    {\n        albedo = vec3(0.81, 0.9025, 1.0);\n        specular = 0.0;\n        shininess = 1024.0;\n    }\n    else if (material == kMaterialEnvironmentIce)\n    {\n        vec2 p = position.xz * vec2(1.0, 16.0);\n        \n        float texture = (1.0 \/ 56.0) * (32.0 * Perlin(p) + 16.0 * Perlin(p * 4.0) + 8.0 * Perlin(p * 8.0));\n        texture *= texture;\n        texture *= texture;\n        \n        albedo = mix(vec3(0.6, 0.8, 1.0), vec3(0.4), texture);\n        specular = 0.3;\n        shininess = 256.0;\n    }\n    else if (material == kMaterialEnvironmentWater)\n    {\n        vec3 p = position * 2.0 + vec3(iTime * 1.0, iTime * 0.7, 0.0);\n\n        float texture = Cellular(p, 0.1);\n        texture *= texture;\n        texture *= texture;\n        texture *= texture;\n        texture = max(texture, smoothstep(0.75, 0.0, abs(abs(position.x) - kSceneWidth)) * (0.3 + Perlin(p.xz * 5.0)));\n        \n        albedo = mix(vec3(0.12, 0.4, 0.7), vec3(1.0), texture);\n        specular = 1.0;\n        shininess = 8.0;\n    }\n    else if (material == kMaterialTreeWood)\n    {\n        albedo = vec3(0.36, 0.08, 0.0);\n        specular = 0.3;\n        shininess = 256.0;\n    }\n    else if (material == kMaterialSledMetal)\n    {\n        albedo = vec3(0.5476, 0.5476, 0.5476);\n        specular = 0.3;\n        shininess = 256.0;\n    }    \n    else if (material == kMaterialSled)\n    {\n        float hash = Hash(GetSceneCoordsTile(position.xz).y * 20.0).x;\n        albedo = HSV(vec3(hash, 0.8, 1.0));\n        specular = 0.3;\n        shininess = 256.0;\n    }\n    else if (material == kMaterialRiderSkin)\n    {\n        albedo = vec3(0.9231064975, 0.537777, 0.34142);\n        specular = 0.3;\n        shininess = 256.0;\n    }\n    else if (material == kMaterialRiderCloth1)\n    {\n        float hash = Hash(GetSceneCoordsTile(position.xz).y * 40.0).z;\n        albedo = HSV(vec3(hash, 0.8, 0.5));\n        albedo *= albedo;\n        specular = 0.3;\n        shininess = 256.0;\n    }\n    if (material == kMaterialRiderCloth2)\n    {\n        float hash = Hash(GetSceneCoordsTile(position.xz).y * 80.0).y;\n        albedo = HSV(vec3(hash, 0.2, 0.7));\n        albedo *= albedo;\n        specular = 0.3;\n        shininess = 256.0;\n    }\n}\n\nfloat LightingShadow(vec3 o, vec3 d, float minDist, float maxDist)\n{\n    float t = minDist;\n        \n    for (int i = 0; i < 24; i++)\n    {\n\t\tfloat h = Scene(o + d * t).dist;\n        t += h;\n        \n        if (h < 0.005) \n            return 0.0;\n        \n        if (t > maxDist)\n            break;\n    }\n\t\n    return 1.0;\n}\n\nfloat LightingAmbientOcclusion(vec3 p, vec3 n)\n{\n\tfloat ao = 0.0;\n    float sca = 1.0;\n\t\n    for (int i = 0; i < 5; i++)\n    {\n        float hr = 0.01 + 0.12 * float(i) \/ 4.0;\n        float dd = Scene(n * hr + p).dist;\n        ao += -(dd - hr) * sca;\n        sca *= 0.95;\n    }\n\t\n    return clamp(1.0 - 3.0 * ao, 0.0, 1.0);    \n}\n\nvec3 LightingIndirect(vec3 n, vec3 albedo, vec3 sky, vec3 ground)\n{\n    float a = clamp(0.5 + 0.5 * n.y, 0.0, 1.0);\n    return albedo * mix(ground, sky, a);\n}\n\nvec3 LightingDirect(vec3 l, vec3 v, vec3 p, vec3 n, vec3 albedo, float specular, float shininess)\n{  \n    vec3 h = normalize(l + v);\n    float LdotN = max(0.0, dot(l, n));\n\tfloat HdotN\t= max(0.0, dot(h, n));\n    float shadow = LightingShadow(p + n * kBias, l, 0.02, 8.0);\n    return shadow * LdotN * (albedo + vec3(specular) * pow(HdotN, shininess));\n}\n\nvec3 SkyColor(vec3 n)\n{\n    return vec3(0.1, 0.1, 0.1);\n}\n\n\/\/ --- Camera funcs ------------------------------------------------------------\n\nRay OrthographicCamera(float size, vec2 uv, vec3 offs, vec4 rot)\n{\n    uv.x = -uv.x;\n    \n    Ray ray;\n    ray.direction = QTransform(vec3(0.0, 0.0, -1.0), rot);\n    ray.origin = offs + size * (QTransform(vec3(1.0, 0.0, 0.0), rot) * uv.x + QTransform(vec3(0.0, 1.0, 0.0), rot) * uv.y);\n    \n    return ray;\n}\n\n\/\/ =============================================================================\n\/\/ END OF RENDER CODE\n\/\/ =============================================================================\n\n\/\/ --- Main --------------------------------------------------------------------\n\nvec3 DebugColor(vec2 loc)\n{   \n    \/\/ Compute tile beneath the location and output the corresponding\n    \/\/ debug color.\n    vec3 coordsTile = GetSceneCoordsTile(loc);\n\tvec3 color = HSV(vec3(coordsTile.z \/ 3.0, 1.0, 1.0));\n    \n    float behav = GetSceneTileBehaviour(loc);\n    \n    if (behav == kBehavObstacle) color = vec3(1.0, 0.5, 0.0);\n    if (behav == kBehavWater)    color = vec3(0.0, 1.0, 0.5);\n    if (behav == kBehavHazard)   color = vec3(1.0, 0.0, 0.5);\n    \n    \/\/ Display grid (visual aid).\n\tfloat grid = 0.5 + 0.5 * step(0.1, fract(loc.x)) * step(0.1, fract(loc.y));\n\tgrid *= 0.25 + 0.75 * step(0.05, fract(loc.y * kSceneInvChunkTiles));\n    color *= 0.5 + 0.5 * grid;\n    \n    \/\/ Display penguin's location.\n    color = mix(color, vec3(1.0), smoothstep(0.4, 0.35, distance(loc, gPlayerVisualCoords.xz)));\n    \n    return color;\n}\n\nvoid RenderScene(inout vec4 fragColor, vec2 fragCoord, vec2 uv)\n{\n    \/\/ Setup camera.\n\tgCameraRotation = QEuler(radians(vec3(-45.0, 160.0, 0.0)));\n    gCameraPosition = vec3(gPlayerVisualCoords.xz, 0.0).xzy;\n    gCameraPosition.x = clamp(gCameraPosition.x, -kSceneWidth * 0.4, kSceneWidth * 0.4);\n    gCameraPosition.z = max(gCameraPosition.z, kSceneWidth * 0.75);\n    gCameraPosition += QTransform(vec3(0.0, 0.0, 20.0), gCameraRotation);\n                                     \n    \/\/ Generate first ray and raymarch along scene.\n \tRay ray = OrthographicCamera(4.0, uv, gCameraPosition, gCameraRotation);\n    RayHit hit = Raymarch(ray, kMinDistance, kMaxDistance);\n\n\t\/\/ Initialize color to sky.\n\tfragColor.rgb = SkyColor(ray.direction);\n    \n    \/\/ If there was an intersection, compute normal and the hit surface color.\n    if (hit.material != kMaterialNone)\n    {\n        vec3 p = ray.direction * hit.time + ray.origin;\n        vec3 n = SceneNormal(p);\n        vec3 v = normalize(gCameraPosition - p);\n\n        vec3 albedo;\n        float shininess;\n        float specular;\n        Material(hit.material, p, albedo, specular, shininess);\n        \n        vec3 l = normalize(vec3(-0.6, 0.7, -0.5));\n        \n        float ao = LightingAmbientOcclusion(p, n);\n        fragColor.rgb = vec3(1.00, 0.85, 0.55) * LightingDirect(l, v, p, n, albedo, specular, shininess);\n        fragColor.rgb += ao * LightingIndirect(n, albedo, vec3(0.50, 0.70, 1.00), vec3(0.0, 0.0, 0.0));\n    }\n    \n    \/\/ Convert to gamma space and apply vignetting effect.\n    fragColor.rgb = sqrt(fragColor.rgb);\n    fragColor.rgb -= fragColor.rgb * 0.1 * dot(uv, uv);\n}\n\nvoid RenderSceneDebug(inout vec4 fragColor, vec2 fragCoord, vec2 uv)\n{\n\tvec2 loc = uv * 10.0 + gPlayerVisualCoords.xz;\n\tfragColor.rgb = DebugColor(loc);\n\tfragColor.a = 1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    LoadState();\n    \n    \/\/ Compute aspect ratio.\n    float aspect = iResolution.x \/ iResolution.y;\n    \n    \/\/ Compute uv coords.\n    vec2 uv = fragCoord.xy \/ (gFbScale * iResolution.xy);\n    \n    if (max(uv.x, uv.y) > 1.0)\n        discard;\n\n    uv = 2.0 * uv - 1.0;\n    uv.x *= aspect;\n    \n    \/\/ Render scene.\n\t\/\/RenderSceneDebug(fragColor, fragCoord, uv * 0.75);\n    RenderScene(fragColor, fragCoord, uv);\n}\n",
            "name": "Buf B",
            "description": "",
            "type": "buffer"
        }
    ]
}