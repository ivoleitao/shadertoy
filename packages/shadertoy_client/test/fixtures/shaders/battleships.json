{
    "ver": "0.1",
    "info": {
        "id": "7dscD2",
        "date": "1642762785",
        "viewed": 3743,
        "name": "BattleShips",
        "username": "skaplun",
        "description": "Classic battleship game!\nMany code snippets was taken all over the shadertoy.\nIts a bit raw, but I need your help so decided to post it.\nPLEASE REPORT BUGS IN COMMENTS. APPERECIATE IMPROVEMENT SUGGESTIONS.",
        "likes": 90,
        "published": 1,
        "flags": 32,
        "usePreview": 1,
        "tags": [
            "game",
            "raymarch",
            "interactive",
            "sdf"
        ],
        "hasliked": 0
    },
    "renderpass": [
        {
            "inputs": [
                {
                    "id": "Xsf3zn",
                    "filepath": "\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
                    "previewfilepath": "\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
                    "type": "texture",
                    "channel": 1,
                    "sampler": {
                        "filter": "mipmap",
                        "wrap": "repeat",
                        "vflip": "false",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "4dXGzr",
                    "filepath": "\/media\/a\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png",
                    "previewfilepath": "\/media\/ap\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png",
                    "type": "texture",
                    "channel": 3,
                    "sampler": {
                        "filter": "mipmap",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dfGRr",
                    "channel": 0
                }
            ],
            "code": "#define BULLSEYE_CLR (vec3(1.000,0.482,0.000) * 10.)\nstruct World{\n    Ray viewRay;\n    vec4 boatsBBHitDistances; \/\/draw max 2 boat per ray [closestBoatBBDst, closestBoatBBID, nextBoatBBDst, nextBoatBBID]\n} world;\n\nvoid constructWorld(Ray r, vec2 mouse){\n    world.viewRay = r;\n    vec4 dst = vec4(MAX_FLOAT);\n    for(int i = ZERO; i<SHIPS_CNT; i++){\n        Boat bb = boatFromId(i);\n        vec4 pos = texelFetch(iChannel0, ivec2(i, SHIP_POSITION_LINE), 0);\n        \n        vec3 rots = texelFetch(iChannel0, ivec2(i, SHIP_ROTATION_LINE), 0).xyz;\n        mat4 rot = mat4(rx(rots.x) * ry(rots.y) * rz(rots.z));\n        mat4 tra = translate(pos.xyz);\n        mat4 txi = tra * rot;\n        mat4 txx = inverse(txi);\n        vec2 boxHitDst = iBox(r, bb.boundingBox, txx, txi);\n        \n        if(boxHitDst.x >= 0.){\n            if(boxHitDst.x < dst.x){\n                dst.zw = dst.xy;\n                dst.xy = vec2(boxHitDst.x, float(i));\n            }if(boxHitDst.x == dst.x){\n            \n            }else if(boxHitDst.x < dst.z){\n                dst.zw = vec2(boxHitDst.x, float(i));\n            }\n        }\n    }\n    \n    if(dst.x == MAX_FLOAT)\n        dst = vec4(-1.);\n    if(dst.z == MAX_FLOAT)\n        dst.zw = vec2(-1.);\n    world.boatsBBHitDistances = dst;\n}\n\nfloat perlin(in vec3 x){\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel1, (uv+ 0.5)\/256.0, 0.0 ).yx;\n\treturn -1.0+2.4*mix( rg.x, rg.y, f.z );\n}\n\nfloat fractalPerlin(vec3 p) {\n   return perlin(p*.06125)*.5 + perlin(p*.125)*.25 + perlin(p*.25)*.125;\n}\n\n#define INCLUDE_VOLMETRIC_MARCH(funcName, minMaxDistFuncName, densityFunc, lightingFunc, fogColorFunc, densityThresh, marchStepsCount, densityMultiplier) vec4 funcName(Ray ray, float maxDepth, vec2 mouseHitCell) {    \\\n    vec2 dst = minMaxDistFuncName(ray);                                                                              \\\n    if(dst.x < 0.)                                                                                                   \\\n        return vec4(0.);                                                                                             \\\n    float sampleStep = (min(dst.y, maxDepth) - dst.x)\/float(marchStepsCount);                                        \\\n    float totalDensity = 0.;                                                                                         \\\n    vec3 totalColor = vec3(0.);                                                                                      \\\n    float localDensity = 0.;                                                                                         \\\n    for (int i = ZERO; i<marchStepsCount; i++) {                                                                     \\\n        vec3 samplePos = ray.o + ray.dir * (dst.x + sampleStep * float(i));                                          \\\n        float curDensity = densityFunc(samplePos) * densityMultiplier;                                               \\\n        localDensity = (densityThresh - curDensity) * step(curDensity, densityThresh);                               \\\n        float weight = (1. - totalDensity) * localDensity;                                                           \\\n        vec4 light = lightingFunc(samplePos, mouseHitCell);                                                          \\\n        totalColor += weight * mix(fogColorFunc(), light.rgb, light.a);                                              \\\n        totalDensity += weight;                                                                                      \\\n        if(totalDensity > .95 || samplePos.y < 0.)                                                                   \\\n           break;                                                                                                    \\\n    }                                                                                                                \\\n    totalColor *= (1.5) \/ exp(localDensity * 4.) * 1.25;                                                             \\\n    return vec4(totalColor, totalDensity);                                                                           \\\n}\n\nvec3 warFogColor(){\n    return vec3(1.);\n}\n\nvec4 warFogLights(vec3 p, vec2 mouseHitCell){\n    vec4 gameState = texelFetch(iChannel0, ivec2(0, GAME_STATE_LINE), 0);\n    int gs = int(gameState.x);\n    if(gs == GAME_STATE_FIRE || gs == GAME_STATE_AIMING){\n        float brightness = 1.;\n        if(gs == GAME_STATE_FIRE)\n            brightness *= max(smoothstep(.3, 0., iTime - gameState.y), .00001);\n        vec2 toMouse = p.xz - mouseHitCell;\n        toMouse *= r2d(iTime);\n        toMouse *= brightness;\n        \n        return vec4(BULLSEYE_CLR, bullsEye(toMouse) * brightness);\n    }else{\n        return vec4(0.);\n    }\n}\n\nfloat warFogDensity(vec3 p) {\n   float wholeField = smax(max(distance(p.x, 21.) - 5., abs(p.z) - 5.), abs(p.y) - 1., 1.);\n   ivec2 cellId = ivec2(floor(p.xz) - vec2(16., -5.));\n   cellId.y = 10 - cellId.y;\n   vec4 gameField = texelFetch(iChannel0, ivec2(cellId.x, int(iResolution.y) - cellId.y), 0);\n   vec4 lastMove = texelFetch(iChannel0, ivec2(0, LAST_SHOT_LINE), 0);\n   float hitTime = gameField.w;\n   float cutOut = -1.;\n   if(gameField.y >= 0. || lastMove.x < 0.){\n       float targetY = 3. - saturate(iTime - hitTime) * 3. * step(MIN_FLOAT, hitTime);\n       cutOut = distance(p, vec3(floor(p.x) + .5, targetY, floor(p.z) + .5));\n       cutOut = -cutOut + 1.5;\n   }else if(hitTime >= 0.){\n       vec2 cntr = lastMove.zw;\n       cutOut = distance(p, vec3(cntr.x, 0., cntr.y));\n       cutOut = -cutOut + 10. * (distance(hitTime, iTime) - .5);\n   }\n   \n   wholeField = smax(wholeField, cutOut, .5);\n   return wholeField + fractalPerlin(p * 25. + iTime * 2.) * .25;\n}\n\nvec2 warFogBBMinMax(Ray r){\n    return iBox(r, Box(vec3(21., 0., 0.), vec3(5., 1., 5.)));\n}\n\nINCLUDE_VOLMETRIC_MARCH(marchWarFog, warFogBBMinMax, warFogDensity, warFogLights, warFogColor, .05, 32, 1.5)\n\nvec3 rocketTrailColor(){\n    return vec3(.1);\n}\n\nvec4 rocketLights(vec3 p, vec2 mouseHitCell){\n    vec4 gameState = texelFetch(iChannel0, ivec2(0, GAME_STATE_LINE), 0);\n    int gs = int(gameState.x);\n    if(gs == GAME_STATE_FIRE){\n        Ray mouseRay = createRay(iMouse.xy, iResolution.xy, iTime, gameState);\n\n        float mouseHitOcean = (-mouseRay.o.y)\/mouseRay.dir.y;\n        vec3 mouseHitPoint = (mouseRay.o + mouseRay.dir * mouseHitOcean);\n        vec2 mouseHitCell = floor(mouseHitPoint.xz) + .5;\n    \n        vec3 startPoint = vec3(10., 10., 0.);\n        vec3 endPoint = vec3(mouseHitCell.x, 0., mouseHitCell.y);\n        float time = iTime - gameState.y;\n        float dst = distance(p, mix(startPoint, endPoint, smoothstep(0., .5, time) * 1.5));\n        return vec4(vec3(1., .6, .2), smoothstep(4., 0., dst));\n    }else if(gs == GAME_STATE_ENEMY_FIRE){\n        vec4 lastMove = texelFetch(iChannel0, ivec2(0, LAST_SHOT_LINE), 0);\n        vec3 startPoint = vec3(10., 10., 0.);\n        vec3 endPoint = vec3(lastMove.z + .5, 0., lastMove.w + .5);\n        \n        float time = iTime - gameState.y;\n        float dst = distance(p, mix(startPoint, endPoint, smoothstep(0., .5, time) * 1.5));\n        return vec4(vec3(1., .6, .2), smoothstep(4., 0., dst));\n    }else{\n        return vec4(0.);\n    }\n}\n\nfloat rocketDensity(vec3 p){\n    vec4 savedGameState = texelFetch(iChannel0, ivec2(0, GAME_STATE_LINE), 0);\n    Ray mouseRay = createRay(iMouse.xy, iResolution.xy, iTime, savedGameState);\n\n    float mouseHitOcean = (-mouseRay.o.y)\/mouseRay.dir.y;\n    vec3 mouseHitPoint = (mouseRay.o + mouseRay.dir * mouseHitOcean);\n    vec2 mouseHitCell = floor(mouseHitPoint.xz) + .5;\n    \n    int gs = int(savedGameState.x);\n    if(gs == GAME_STATE_FIRE){\n        vec3 startPoint = vec3(10., 10., 0.);\n        vec3 endPoint = vec3(mouseHitCell.x, 0., mouseHitCell.y);\n        float time = iTime - savedGameState.y;\n        return sdCylinder(p, mix(startPoint, endPoint, smoothstep(0., .5, time) * 1.5), mix(startPoint, endPoint, smoothstep(.4, .75, time)), .1) + fractalPerlin(p * 20. + iTime * 50.) * .35;\n    }else if(gs == GAME_STATE_ENEMY_FIRE){\n        vec4 lastMove = texelFetch(iChannel0, ivec2(0, LAST_SHOT_LINE), 0);\n        vec3 startPoint = vec3(10., 10., 0.);\n        vec3 endPoint = vec3(lastMove.z + .5, 0., lastMove.w + .5);\n        float time = saturate(iTime - savedGameState.y);\n        vec3 a = mix(startPoint, endPoint, smoothstep(MIN_FLOAT, .5, time) * 1.5);\/\/startPoint\n        vec3 b = mix(startPoint, endPoint, smoothstep(.4, .75, time));\/\/endPoint;\n        return sdCylinder(p, a, b, .1) + fractalPerlin(p * 20. - iTime * 50.) * .35;\n    }else{\n        return 0.;\n    }\n}\n\nvec2 rocketTrailMinMax(Ray cameraRay){\n    vec4 gameState = texelFetch(iChannel0, ivec2(0, GAME_STATE_LINE), 0);\n    int gs = int(gameState.x);\n    if(gs == GAME_STATE_FIRE){\n        Ray mouseRay = createRay(iMouse.xy, iResolution.xy, iTime, gameState);\n\n        float mouseHitOcean = (-mouseRay.o.y)\/mouseRay.dir.y;\n        vec3 mouseHitPoint = (mouseRay.o + mouseRay.dir * mouseHitOcean);\n        vec2 mouseHitCell = floor(mouseHitPoint.xz) + .5;\n        \n        vec3 startPoint = vec3(10., 10., 0.);\n        vec3 endPoint = vec3(mouseHitCell.x, 0., mouseHitCell.y);\n        float time = iTime - gameState.y;\n        vec3 a = mix(startPoint, endPoint, smoothstep(0., .5, time) * 1.5);\n        vec3 b = mix(startPoint, endPoint, smoothstep(.4, .75, time));\n        \n        return cylinderHit(cameraRay, Cylinder(a, b, .5));\n    }else if(gs == GAME_STATE_ENEMY_FIRE){\n        vec4 lastMove = texelFetch(iChannel0, ivec2(0, LAST_SHOT_LINE), 0);\n        vec3 startPoint = vec3(10., 10., 0.);\n        vec3 endPoint = vec3(lastMove.z + .5, 0., lastMove.w + .5);\n        float time = saturate(iTime - gameState.y);\n        vec3 a = mix(startPoint, endPoint, smoothstep(0., .5, time) * 1.5);\n        vec3 b = mix(startPoint, endPoint, smoothstep(.4, .75, time));\n        \n        return cylinderHit(cameraRay, Cylinder(a, b, .5));\n    }else{\n        return vec2(-1.);\n    }\n}\n\nINCLUDE_VOLMETRIC_MARCH(marchRocket, rocketTrailMinMax, rocketDensity, rocketLights, rocketTrailColor, .2, 32, .5)\n\nvec3 boats(vec3 p, float dist){\n    vec3 res = vec3(MAX_FLOAT);\n    for(int k=ZERO; k<2; k++){\n        float curBoatMinDist = world.boatsBBHitDistances[k * 2];\n        if(curBoatMinDist < 0. && dist >= curBoatMinDist)\n            continue;\n        int id = int(world.boatsBBHitDistances[k * 2 + 1]);\n        \n        Boat b = boatFromId(id);\n        vec4 pos = texelFetch(iChannel0, ivec2(id, SHIP_POSITION_LINE), 0);\n        b.boundingBox.o = pos.rgb;\n        \n        vec3 rots = texelFetch(iChannel0, ivec2(id, SHIP_ROTATION_LINE), 0).xyz;\n        mat4 rot = mat4(rx(rots.x) * ry(rots.y) * rz(rots.z));\n        mat4 tra = translate(b.boundingBox.o);\n        mat4 txi = tra * rot;\n        mat4 txx = inverse(txi);\n        \n        switch(b.boatType){\n            case 1:\n                res = opMin(res, vec3(boat1(p, txx, iTime), float(id)));\n                break;\n            case 2:\n                res = opMin(res, vec3(boat2(p, txx, iTime), float(id)));\n                break;\n            case 3:\n                res = opMin(res, vec3(boat3(p, txx), float(id)));\n                break;\n            case 4:\n                res = opMin(res, vec3(boat4(p, txx, iTime), float(id)));\n                break;\n            default:\n                break;\n        }\n    }\n    \n    if(max(abs(p.x), abs(p.z)) <= 5.){\n        ivec2 cellId = ivec2(floor(p.xz) + 5.);\n        cellId.y = 10 - cellId.y;\n        float hitTime = texelFetch(iChannel0, ivec2(cellId.x, int(iResolution.y) - cellId.y), 0).z;\n        if(hitTime >= 0.){\n            float dst = distance(p.yz, floor(p.yz) + vec2(.1, .5)) - (1.3 - smoothstep(.25, .65, saturate(iTime - hitTime))) + perlin(p * 5.) * .1;\n            res.x = smax(res.x, dst, .1);\n        }\n    }\n    \n    return res;\n}\n\nfloat certainBoat(vec3 p, int id){\n    Boat b = boatFromId(id);\n    vec4 pos = texelFetch(iChannel0, ivec2(id, SHIP_POSITION_LINE), 0);\n    b.boundingBox.o = pos.rgb;\n\n    vec3 rots = texelFetch(iChannel0, ivec2(id, SHIP_ROTATION_LINE), 0).xyz;\n    mat4 rot = mat4(rx(rots.x) * ry(rots.y) * rz(rots.z));\n    mat4 tra = translate(b.boundingBox.o);\n    mat4 txi = tra * rot;\n    mat4 txx = inverse(txi);\n\n    switch(b.boatType){\n        case 1:\n            return boat1(p, txx, iTime).x;\n        case 2:\n            return boat2(p, txx, iTime).x;\n        case 3:\n            return boat3(p, txx).x;\n            break;\n        case 4:\n            return boat4(p, txx, iTime).x;\n        default:\n            return MAX_FLOAT;\n    }\n}\n\nvec3 normals(vec3 pos, int id){\n    vec2 eps = vec2(0.0, EPSILON);\n    vec3 n = normalize(vec3(\n        certainBoat(pos + eps.yxx, id) - certainBoat(pos - eps.yxx, id),\n        certainBoat(pos + eps.xyx, id) - certainBoat(pos - eps.xyx, id),\n        certainBoat(pos + eps.xxy, id) - certainBoat(pos - eps.xxy, id)));\n    return n;\n}\n\nconst int MAX_MARCHING_STEPS = 32;\nvec3 march(float maxDist){\n    if(world.boatsBBHitDistances.x < 0.)\n        return vec3(MAX_FLOAT);\n    float t = world.boatsBBHitDistances.x;\n    for(int i = ZERO; i <= MAX_MARCHING_STEPS; i++){\n        vec3 p = world.viewRay.o + world.viewRay.dir * t;\n        vec3 dst = boats(p, t);\n        if(abs(dst.x) < .001)\n            return vec3(t, dst.y, dst.z);\n        t += dst.x;\n        if(p.y < 0. || t > maxDist)\n            break;\n    }\n    return vec3(MAX_FLOAT);\n}\n\nvoid letter(inout vec4 fragColor, in vec2 fragCoord, \n            in vec2 position, in vec2 size, in int code, float w, vec4 color) {\n    vec2 uv = fragCoord - position;\n    uv += size * 0.5;\n    uv \/= size;\n\n    if (uv.x > 0.0 && uv.x < 1.0 && uv.y > 0.0 && uv.y < 1.0) {\n        uv.x += float(code % 16);\n        uv.y += float(15 - code \/ 16);\n\n        uv *= 0.0625;\n\n        float sd = abs(texture(iChannel3, uv).a);\n        fragColor = blend(fragColor, vec4(color.rgb, color.a * smoothstep(0.0, 4., (0.52 + w - sd) * 50.0)));\n    }\n}\n\nvoid letter(inout vec4 fragColor, in vec2 fragCoord, \n            in vec2 position, in vec2 size, in int code, float w, vec3 color) {\n    letter(fragColor, fragCoord, position, size, code, w, vec4(color, 1.));\n}\n\nconst vec3 SHIP_GREY = vec3(111., 116., 141.)\/255.;\nconst vec3 SHIP_BLACK = vec3(38.)\/255.;\nconst vec3 HELI_YELLOW = vec3(246., 215., 21.)\/255.;\nconst vec3 SHIP_BLUE = vec3(42., 93., 148.)\/255.;\nconst vec3 SHIP_RED = vec3(168., 40., 38.)\/255.;\nvec3 albedo(vec3 pos, vec3 nrm, int id, int matId){\n    int type = boatFromId(id).boatType;\n    \n    vec4 cntr = texelFetch(iChannel0, ivec2(id, SHIP_POSITION_LINE), 0);\n    pos -= cntr.xyz;\n    vec3 rots = texelFetch(iChannel0, ivec2(id, SHIP_ROTATION_LINE), 0).xyz;\n    \n    mat3 rm = rx(rots.x) * ry(rots.y) * rz(rots.z);\n    pos *= rm;\n    \n    vec3 overlayClr = hsv2rgb(vec3(cntr.w, step(cntr.w, .1), 1.));\n    \n    switch(type){\n        case 1:\n            {\n                if(matId == MAT_BOAT1_CAB){\n                    float window = step(dot(nrm, vec3(-1., 0., 0.)), .05)\n                                 * step(dot(nrm, vec3(0., 1., 0.)), .95);\n                    return mix(SHIP_GREY, SHIP_BLUE * .5, window) * overlayClr;\n                }else{\n                    vec3 res = mix(SHIP_GREY, SHIP_RED, step(pos.y, 0.));\n                    res = mix(res, SHIP_BLACK, step(.95, dot(nrm, vec3(0., 1., 0.))));\n                    return res * overlayClr;\n                }\n            }\n            break;\n        case 2:\n            float heli = smoothstep(.025, .015, distance(distance(pos.xz, vec2(.3, 0.)), .175));\n            heli = max(heli, smoothstep(.025, .015, distance(abs(pos.x - .3), .065)) * smoothstep(.1, .09, abs(pos.z)));\n            heli = max(heli, smoothstep(.025, .015, abs(pos.z)) * step(abs(pos.x - .3), .075));\n            vec3 floorColor = mix(SHIP_BLACK, HELI_YELLOW, heli);\n            float window = smoothstep(.4, .35, length(fract(pos.xy * 7. + vec2(-.5, -.25)) - .5)) * step(abs(pos.y + .035), .055)\n                         * step(distance(pos.x, -.3), .47);\n            window = max(window, smoothstep(.4, .35, length(fract(pos.xy * 7. + vec2(-.5, -.3)) - .5)) * step(abs(pos.y - .11), .055)\n                                       * step(distance(pos.x, -.45), .2));\n            window = max(window, smoothstep(.05, .04, distance(pos.y, .11)) * smoothstep(.15, .14, abs(pos.z)) * step(pos.x, -.5));\n            window = max(window, smoothstep(.065, .06, distance(pos.y, -.04)) * smoothstep(.15, .14, abs(pos.z)) * step(pos.x, -.5));\n            \n            vec3 bodyColor = mix(SHIP_GREY * 2., SHIP_BLUE * .5, window);\n            vec4 res = vec4(mix(floorColor, bodyColor, step(dot(nrm, vec3(0., 1., 0.)), .99)), 1.);\n            float stripes = smoothstep(.02, .01, abs(pos.y + .2)) * step(.14, abs(pos.x - .78));\n            res = blend(res, vec4(vec3(2.), stripes));\n            letter(res, pos.xy, vec2(.7, -.2), vec2(.15), 49, 0.03, vec3(2.));\n            letter(res, pos.xy, vec2(.76, -.2), vec2(.15), 55, 0.03, vec3(2.));\n            letter(res, pos.xy, vec2(.82, -.2), vec2(.15), 49, 0.03, vec3(2.));\n            letter(res, pos.xy, vec2(.88, -.2), vec2(.15), 50, 0.03, vec3(2.));\n            return res.rgb * overlayClr;\n            break;\n        case 3:\n            return SHIP_BLACK * overlayClr;\n            break;\n        case 4:\n            {\n                if(matId == MAT_PLANE_MAIN)\n                    return vec3(.7);\n                else if(matId == MAT_PLANE_CABIN)\n                    return vec3(.1);\n\n                float deckLines = smoothstep(.02, .005, abs(pos.z - .05)) * smoothstep(.1, .05, fract(pos.x * 3.) - .5);\n                deckLines = max(deckLines, smoothstep(.02, .005, abs(pos.z - .29)) * step(0., pos.x));\n                deckLines = max(deckLines, smoothstep(.02, .005, abs(pos.z - pos.x * .1 - .29)) * step(0., pos.x));\n                deckLines = max(deckLines, smoothstep(.02, .005, abs(pos.z + .19)) * step(-.4, pos.x));\n                \n                deckLines = max(deckLines, smoothstep(.02, .005, distance(.2, abs(pos.z + pos.x * .2 + .48))) * step(pos.z, -.175));\/\/ * step(0., pos.x)\n                deckLines = max(deckLines, smoothstep(.015, .0, distance(.02, abs(pos.z + pos.x * .2 + .48))));\n                vec3 deck = mix(SHIP_BLACK, vec3(2.), deckLines);\n                vec3 body = mix(SHIP_GREY, SHIP_RED, step(pos.y, -.35));\n                body = mix(body, SHIP_BLUE, step(.1, distance(fract(pos.x * 10.), .5)) * smoothstep(.05, .04, distance(.075, abs(pos.y - .4))));\n                vec3 res = mix(deck, body, step(dot(nrm, vec3(0., 1., 0.)), .99));\n                return res * overlayClr;\n            }\n            break;\n        default:\n            break;\n    }\n    return vec3(0.);\n}\n\n#define SUN_DIR normalize(vec3(0., 20., 2.))\nvec4 ships(float maxDist){\n    vec3 marchBoats = march(maxDist);\n    if(marchBoats.x < MAX_FLOAT){\n        vec3 pos = world.viewRay.o + world.viewRay.dir * marchBoats.x;\n        \/\/return vec4(vec3(fract(marchBoats.x)), marchBoats.x);\n        vec3 nrm = normals(pos, int(marchBoats.z));\n        vec3 albedo = albedo(pos, nrm, int(marchBoats.z), int(marchBoats.y));\n        float diff = clamp(dot(nrm, SUN_DIR), .3, 1.);\n        return vec4(albedo * diff, marchBoats.x);\n    }else{\n        return vec4(MAX_FLOAT);\n    }\n}\n\nvec4 shipBounds(vec2 pos, out float shape){\n    shape = MAX_FLOAT;\n    ivec2 cellId = ivec2(pos + 5.);\n    cellId.y = 10 - cellId.y;\n    float ocupiedBy = texelFetch(iChannel0, ivec2(cellId.x, int(iResolution.y) - cellId.y), 0).x;\n    vec4 boundColor = vec4(MAX_FLOAT); \n    if(ocupiedBy >= 0.){\n        float tmp = ocupiedBy;\n        int neigh = 0;\n        \/\/this is awful but it works\n        if(tmp > 1000.) neigh = 4; else if(tmp > 100.) neigh = 3;else if(tmp > 10.) neigh = 2; else neigh = 1;\n        for(int i=ZERO; i<neigh; i++){\n            tmp *= .1;\n            int curOcupation = int(fract(tmp) * 10.);\n            vec4 curBoatPos = texelFetch(iChannel0, ivec2(curOcupation, SHIP_POSITION_LINE), 0) - vec4(boatOffsetsFromPos(curOcupation), 0., 0.);\n            if(abs(curBoatPos.y) < 5.){\n                float curBoatSpan =  boatSpanFromId(curOcupation);\n\n                float left = curBoatPos.x - step(1.5, curBoatSpan) - 1.;\n                float right = curBoatPos.x + curBoatSpan - step(1.5, curBoatSpan) + 1.;\n                float top = curBoatPos.z + 1.;\n                float bottom = curBoatPos.z - 1.;\n\n                vec2 interaction = texelFetch(iChannel0, ivec2(curOcupation, SHIP_INTERACTION_LINE), 0).xy;\n                float shapeWidth = .5 + smoothstep(.3, .7, distance(interaction.RELEASE_TIME, iTime)) * .7 * step(interaction.PRESSED, MIN_FLOAT);\n                float shapeStencil = smax(distance(pos.x, (floor(left) + ceil(right)) * .5) - (shapeWidth + .5 * curBoatSpan),\n                                          distance(pos.y, (floor(bottom) + ceil(top)) * .5) - shapeWidth, .125);\n                shapeStencil = smax(shapeStencil, abs(pos.x) - 5., .125);\n                shapeStencil = smax(shapeStencil, abs(pos.y) - 5., .125);\n                \n                float clr = curBoatPos.w;\n                if(clr < .1)\n                    shapeStencil = max(shapeStencil, (.25 - distance(fract(pos.x * 2. + pos.y), .5)) * step(clr, .1));\n                vec4 curShapeColor = vec4(shapeStencil, mix(vec3(1.), vec3(1., 0., 0.), step(clr, .1)));\n                boundColor = opMin(boundColor, curShapeColor);\n                \n                shape = smin(shape, shapeStencil, .125);\n            }\n        }\n    }\n    return vec4(boundColor.gba, smoothstep(.05, .0, abs(shape)) * .75);\n}\n\n#define AA .35\nvec2 shipRipple(vec2 pos){\n    float res = MAX_FLOAT;\n    ivec2 cellId = ivec2(pos + 5.);\n    cellId.y = 10 - cellId.y;\n    float ocupiedBy = texelFetch(iChannel0, ivec2(cellId.x, int(iResolution.y) - cellId.y), 0).x;\n    if(ocupiedBy >= 0.){\n        float tmp = ocupiedBy;\n        int neigh = 0;\n        \/\/this is awful but it works\n        if(tmp > 1000.) neigh = 4; else if(tmp > 100.) neigh = 3;else if(tmp > 10.) neigh = 2; else neigh = 1;\n        for(int i=ZERO; i<neigh; i++){\n            tmp *= .1;\n            int curOcupation = int(fract(tmp) * 10.);\n            vec2 curBoatPos = texelFetch(iChannel0, ivec2(curOcupation, SHIP_POSITION_LINE), 0).rb - boatOffsetsFromPos(curOcupation);\n            if(abs(curBoatPos.y) < 5.){\n                float curBoatSpan =  boatSpanFromId(curOcupation);\n                float left = curBoatPos.x - step(1.5, curBoatSpan);\n                float right = curBoatPos.x + curBoatSpan - step(1.5, curBoatSpan);\n                vec2 cntr = vec2((floor(left) + ceil(right)) * .5, curBoatPos.y);\n                float shapeDistance = smax(distance(pos.x, cntr.x) - (1. + .5 * curBoatSpan), distance(pos.y, cntr.y) - 1., 1.);\n                vec2 diff = cntr - pos;\n                float ang = atan(diff.y, diff.x) + QPI;\n                float width = distance(abs(ang), HPI)\/PI * 2.;\n                float releaseTime = texelFetch(iChannel0, ivec2(curOcupation, SHIP_INTERACTION_LINE), 0).RELEASE_TIME;\n                return vec2(step(MIN_FLOAT, releaseTime)\n                          * smoothstep(.2, .5, distance(iTime, releaseTime))\n                          * smoothstep(.4, .1, distance(shapeDistance + 1., distance(iTime, releaseTime) * 2.))\n                          * smoothstep(.65, 0., shapeDistance)\n                          * abs(sin(ang + iTime * 4.)),\n                          (iTime - releaseTime) * step(MIN_FLOAT, releaseTime));\n            }\n        }\n    }\n    return vec2(res) * step(res, 1.);\n}\n\n\/\/===================================================OCEAN============================================================\n\n#define STEPS 80.0\n#define MDIST 35.0\n#define pi 3.1415926535\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define sat(a) clamp(a,0.0,1.0)\n\n#define ITERS_TRACE 9\n#define ITERS_NORM 15\n\n#define HOR_SCALE 7.5\n#define OCC_SPEED .8\n#define DX_DET .5\n\n#define FREQ .6\n#define HEIGHT_DIV 15.\n#define WEIGHT_SCL 0.8\n#define FREQ_SCL 1.2\n#define TIME_SCL 1.095\n#define WAV_ROT 1.21\n#define DRAG 0.6\n#define SCRL_SPEED 1.5\nvec2 scrollDir = vec2(0, 0);\n\nvec2 wavedx(vec2 wavPos, int iters, float t){\n    vec2 dx = vec2(0);\n    vec2 wavDir = vec2(1,0);\n    float wavWeight = 1.0; \n    wavPos+= t*SCRL_SPEED*scrollDir;\n    wavPos*= HOR_SCALE;\n    float wavFreq = FREQ;\n    float wavTime = OCC_SPEED*t;\n    for(int i=ZERO;i<iters;i++){\n        wavDir*=rot(WAV_ROT);\n        float x = dot(wavDir,wavPos)*wavFreq+wavTime; \n        float result = exp(sin(x)-1.)*cos(x)*wavWeight; \n        dx += result * wavDir\/pow(wavWeight, DX_DET); \n        wavFreq *= FREQ_SCL; \n        wavTime *= TIME_SCL;\n        wavPos -= wavDir*result*DRAG; \n        wavWeight *= WEIGHT_SCL;\n    }\n    float wavSum = -(pow(WEIGHT_SCL, float(iters)) - 1.) * HEIGHT_DIV; \n    return dx\/pow(wavSum,1.-DX_DET);\n}\n\nfloat wave(vec2 wavPos, int iters, float t){\n    float wav = 0.0;\n    vec2 wavDir = vec2(1,0);\n    float wavWeight = 1.0;\n    wavPos+= t*SCRL_SPEED*scrollDir;\n    wavPos*= HOR_SCALE; \n    float wavFreq = FREQ;\n    float wavTime = OCC_SPEED * t;\n    for(int i=ZERO;i<iters;i++){\n        wavDir *= rot(WAV_ROT);\n        float x = dot(wavDir,wavPos)*wavFreq+wavTime;\n        float wave = exp(sin(x) - 1.0) * wavWeight;\n        wav += wave;\n        wavFreq *= FREQ_SCL;\n        wavTime *= TIME_SCL;\n        wavPos -= wavDir*wave*DRAG*cos(x);\n        wavWeight *= WEIGHT_SCL;\n    }\n    float wavSum = -(pow(WEIGHT_SCL, float(iters)) - 1.) * HEIGHT_DIV; \n    return wav\/wavSum;\n}\n\nvec3 norm(vec3 p, int iters){\n    vec2 wav = -wavedx(p.xz, iters, iTime);\n    return normalize(vec3(wav.x,1.0,wav.y));\n}\n\nfloat mapOcean(vec3 p){\n    float a = 0.;\n    int steps = ITERS_TRACE;\n    vec2 ripple = shipRipple(p.xz);\n    float h = wave(p.xz, steps, iTime) + ripple.x * .25;\n    return p.y - h;\n}\n\n\/\/===================================================OCEAN============================================================\n\nvec3 Sky(vec3 ray){\n\treturn mix(vec3(.4, .45, .5), vec3(.7), step(dot(ray, SUN_DIR), .05));\n}\n\nvec3 ShadeOcean(vec3 pos, vec3 ray,vec3 norm){\n\tfloat ndotr = dot(ray,norm);\n\tfloat fresnel = pow(1. - abs(ndotr), 4.);\n\n    vec3 reflectedRay = ray - 2. * norm * ndotr;\n\tvec3 reflection = Sky(reflectedRay);\n\treturn mix(vec3(0,.04,.04), reflection, fresnel);\n}\n\nvec4 ocean(Ray r, float start, out vec3 normal){\n    float hitDistance = start;\n    bool hit = false;\n    float maxDist = (-.5-r.o.y)\/r.dir.y;\n    if(start > 0.){\n        for(float i = 0.; i<32.; i++){\n            vec3 p = r.o + r.dir * hitDistance;\n            float d = mapOcean(p);\n            hitDistance += d;\n            if(abs(d) < 0.01){\n                hit = true;\n                break;\n            }\n            if(hitDistance > maxDist)\n                return vec4(MAX_FLOAT);\n        }\n    }\n    \n    if(hit){\n        vec3 p = r.o + r.dir * hitDistance;\n        normal = norm(p, ITERS_NORM);\n        vec4 ocean = vec4(ShadeOcean(p, r.dir, normal), 1.);\n        \n        float shipOutlinesShape = 0.;\n        vec4 shipOutlinesColor = shipBounds(p.xz, shipOutlinesShape);\n        ocean = blend(ocean, shipOutlinesColor);\n        \n        float scull = 0.;\n        if(max(abs(p.x - 21.), abs(p.z)) <= 5.){\n            ivec2 cellId = ivec2(p.xz - vec2(16., -5.));\n            cellId.y = 10 - cellId.y;\n            float ocupied = texelFetch(iChannel0, ivec2(cellId.x, int(iResolution.y) - cellId.y), 0).y;\n            scull = ASCIIskull((fract(p.xz) - .5) * 3.) * step(abs(p.z), 5.) * step(distance(p.x, 21.), 5.)\n                  * step(0., ocupied) * .5;\n        }\n        \n        float playerFieldHit = 0.;\n        if(max(abs(p.x), abs(p.z)) <= 5.)\n        {\n            vec2 cellId = p.xz + 5.;\n            cellId.y = 10. - cellId.y;\n            float ocupied = texelFetch(iChannel0, ivec2(cellId.x, iResolution.y - cellId.y), 0).z;\n            playerFieldHit = step(0., ocupied) * smoothstep(.11, .1, distance(fract(p.xz), vec2(.5)));\n        }\n        \n        {\n            p.z *= -1.;\n            if(p.x > 12. && p.x < 27.)\n                p.x = mod(p.x, 15.) - 6.;\n        }\n        \n        float w = .075;\n        float ww = .5;\n        float grid = smoothstep(ww - w, ww, distance(fract(p.x), .5));\n        grid = max(grid, smoothstep(ww - w, ww, distance(fract(p.z), .5)));\n        grid *= smoothstep(5. + w, 5., max(abs(p.x), abs(p.z)));\n        grid *= smoothstep(0., 0. + w, shipOutlinesShape);\n        \n        ocean = blend(ocean, vec4(vec3(.8), grid));\n        ocean = blend(ocean, vec4(vec3(1.), max(scull, playerFieldHit)));\n        \n        if(floor(p.x) == -6. && abs(p.z) < 5.){\n            letter(ocean, p.xz,  floor(p.xz) + .5, vec2(1.), 64 - (int(floor(p.z)) - 5), 0., vec3(1.));\n        }\n        \n        if(floor(p.z) == -6. && abs(p.x) < 5.){\n            letter(ocean, p.xz,  floor(p.xz) + .5, vec2(1.), 48 + (int(floor(p.x)) + 5), 0., vec3(1.));\n        }\n        return vec4(ocean.rgb, hitDistance);\n    }\n    return vec4(MAX_FLOAT);\n}\n\nvec3 gameScene(in vec2 fragCoord){\n    vec4 savedGameState = texelFetch(iChannel0, ivec2(0, GAME_STATE_LINE), 0);\n    Ray cameraRay = createRay(fragCoord, iResolution.xy, iTime, savedGameState);\n    Ray mouseRay = createRay(iMouse.xy, iResolution.xy, iTime, savedGameState);\n    \n    float mouseHitOcean = (-mouseRay.o.y)\/mouseRay.dir.y;\n    vec3 mouseHitPoint = (mouseRay.o + mouseRay.dir * mouseHitOcean);\n    vec2 mouseHitCell = clamp(floor(mouseHitPoint.xz) + .5, -4.5, 4.5);\n    vec3 color = vec3(0.);\n    \n    constructWorld(cameraRay, mouseHitCell);\n    \n    float hitOcean = (-cameraRay.o.y)\/cameraRay.dir.y;\n    if(hitOcean >= 0.0) {\n        {\n            vec3 pos = cameraRay.o + hitOcean * cameraRay.dir;\n            vec3 normal;\n            vec4 oc = ocean(cameraRay, hitOcean, normal);\n            color = oc.rgb;\n            hitOcean = oc.a;\n#ifdef REFLECTIONS\n            pos.y = MIN_FLOAT;\n            constructWorld(Ray(pos, reflect(cameraRay.dir, normal)), mouseHitCell);\n#endif            \n        }\n    }\n    vec4 shipssss;\n#ifdef REFLECTIONS\n    shipssss = ships(hitOcean);\n    if(shipssss.w < hitOcean)\n        color += shipssss.rgb * .35;\n    constructWorld(cameraRay, mouseHitCell);\n#endif\n    \n    shipssss = ships(hitOcean);\n    if(shipssss.w < hitOcean)\n        color = shipssss.rgb;\n    \n    {\n        vec2 enemyField = floor(mouseHitPoint.xz) + .5;\n        enemyField.x = clamp(enemyField.x, 16.5, 25.5);\n        enemyField.y = clamp(enemyField.y, -4.5, 4.5);\n        \n        vec4 warFog = marchWarFog(cameraRay, hitOcean, enemyField);\n        color = mix(color, warFog.rgb, warFog.a);\n        \n        vec4 rocketTrail = marchRocket(cameraRay, hitOcean, enemyField);\n        color = mix(color, rocketTrail.rgb, rocketTrail.a);\n    }\n    \n    return pow(color, vec3(1.\/2.2));\n}\n\n#define INCLUDE_DRAW_STRING_FUNCTION(name, arrayName, arrayLength)                   \\\n  void name(inout vec4 fragColor, in vec2 fragCoord, float offset) {                 \\\n    float size = 1.0 \/ float(arrayLength);                                           \\\n                                                                                     \\\n    fragCoord.y -= - size * (1.0 + offset) - 0.2;                                    \\\n    fragCoord.x = clamp(fragCoord.x, -1.0, 1.0);                                     \\\n    fragCoord.x += 1.0;                                                              \\\n    fragCoord *= 0.5;                                                                \\\n                                                                                     \\\n    int code = arrayName[int(fragCoord.x \/ size - 0.01)];                            \\\n    fragCoord.x = mod(fragCoord.x, size) - size * 0.5;                               \\\n                                                                                     \\\n    letter(fragColor, fragCoord, vec2(0.0), vec2(size * 1.4), code, .05, vec3(1.));  \\\n  }\n\nconst int battleWordLength = 6;\nconst int[] battleWordLetters = int[](66, 65, 84, 84, 76, 69);\nINCLUDE_DRAW_STRING_FUNCTION(battleButton, battleWordLetters, battleWordLength)\n\nconst int playerTroopsLength = 13;\nconst int[] playerTroopsLetters = int[](80, 76, 65, 89, 69, 82, 32, 84, 82, 79, 79, 80, 83);\nINCLUDE_DRAW_STRING_FUNCTION(playerTroopsWord, playerTroopsLetters, playerTroopsLength)\n\nconst int enemyTroopsLength = 12;\nconst int[] enemyTroopsLetters = int[](69, 78, 69, 77, 89, 32, 84, 82, 79, 79, 80, 83);\nINCLUDE_DRAW_STRING_FUNCTION(enemyTroopsWord, enemyTroopsLetters, enemyTroopsLength)\n\nconst int victoryLength = 8;\nconst int[] victoryLetters = int[](86, 73, 67, 84, 79, 82, 89, 33);\nINCLUDE_DRAW_STRING_FUNCTION(victoryWord, victoryLetters, victoryLength)\n\nconst int playAgainLength = 10;\nconst int[] playAgainLetters = int[](80, 76, 65, 89, 32, 65, 71, 65, 73, 78);\nINCLUDE_DRAW_STRING_FUNCTION(playAgainWord, playAgainLetters, playAgainLength)\n\nconst int loseLength = 9;\nconst int[] loseLetters = int[](89, 79, 85, 32, 76, 79, 83, 69, 40);\nINCLUDE_DRAW_STRING_FUNCTION(loseWord, loseLetters, loseLength)\n\nvec4 ui(vec2 fragCoord){\n    vec2 uv = fragCoord\/iResolution.y;\n    vec4 color = vec4(0.);\n    \n    {\/\/BATTLE_BUTTON\n        vec4 bb = texelFetch(iChannel0, ivec2(BUTTONS_BATTLE_ID, BUTTONS_LINE), 0);\n        if(bb.x == 1.)\n        {\n            vec2 bbPos = vec2(bb.y, BATTLE_BUTTON.CENTER_Y);\n        \n            float xd = distance(uv.x, bbPos.x) - BATTLE_BUTTON.WIDTH;\n            float yd = distance(uv.y, bbPos.y) - BATTLE_BUTTON.HEIGHT;\n            float buttonStencil = step(smax(xd, yd, .025), 0.);\n\n            color = blend(color, vec4(vec3(0.086,0.596,0.467), buttonStencil));\n            color = blend(color, vec4(vec3(1.), bullsEye((uv - bbPos + vec2(.17, 0.)) * 16.)));\n            battleButton(color, (uv - vec2(bbPos.x + .07, .19)) * 6., 0.);\n        }\n    }\n    vec4 gameState = texelFetch(iChannel0, ivec2(0, GAME_STATE_LINE), 0);\n    int state = int(gameState.x);\n#ifdef RENDER_SWAP_BTN\n    if(state >= GAME_STATE_AIMING){\n        vec2 bbPos = vec2(SWAP_BUTTON.CENTER_X, SWAP_BUTTON.CENTER_Y);\n        float xd = distance(uv.x, bbPos.x) - SWAP_BUTTON.WIDTH;\n        float yd = distance(uv.y, bbPos.y) - SWAP_BUTTON.HEIGHT;\n        float buttonStencil = step(smax(xd, yd, .025), 0.);\n        color = blend(color, vec4(vec3(0., .6, 1.), buttonStencil));\n        letter(color, uv, SWAP_BUTTON.xy, vec2(.15), 20, .03, vec3(1.));\n    }\n#endif\n\n#ifdef RENDER_RANDOM_BTN\n    if(state == GAME_STATE_POSITIONING || state == GAME_STATE_READY_TO_PLAY){\n        vec2 bbPos = vec2(RANDOM_BUTTON.CENTER_X, RANDOM_BUTTON.CENTER_Y);\n        float xd = distance(uv.x, bbPos.x) - RANDOM_BUTTON.WIDTH;\n        float yd = distance(uv.y, bbPos.y) - RANDOM_BUTTON.HEIGHT;\n        float buttonStencil = step(smax(xd, yd, .025), 0.);\n        color = blend(color, vec4(vec3(.6, .4, .2), buttonStencil));\n        letter(color, uv, RANDOM_BUTTON.xy, vec2(.1), 35, .03, vec3(1.));\n    }\n#endif\n\n#ifdef RENDER_SHIP_INDICATORS\n    if(gameState.x >= float(GAME_STATE_AIMING)){\n        float centerPoint = .39;\n        \n        if(gameState.x >= float(GAME_STATE_ENEMY_TURN)){\n            centerPoint += easeInExpo(saturate(iTime - gameState.y + gameState.x - float(GAME_STATE_ENEMY_TURN)));\n        }else if(gameState.x == float(GAME_STATE_AIMING)){\n            centerPoint += 1. - easeInExpo(saturate(iTime - gameState.y));\n        }\n        \n        if(gameState.x == float(GAME_STATE_END)){\n            if(gameState.z == float(GAME_STATE_FIRE)){\n                centerPoint = .39;\n            }else{\n                centerPoint = 1.39;\n            }\n        }\n        \n        vec2 reflectedUV = uv;\n        reflectedUV.x = abs(reflectedUV.x - centerPoint) - .88;\n        \n        if(gameState.z != float(GAME_STATE_READY_TO_PLAY) || (iTime - gameState.y) > .9){\n            float panel = step(0., reflectedUV.x  - .6 + reflectedUV.y * .8) * step(.35, reflectedUV.y);\n            color = blend(color, vec4(vec3(0.), .5 * panel));\n        }\n\n        vec4 playerDamageCount = texelFetch(iChannel0, ivec2(0, ENEMY_HIT_COUNT_LINE), 0);\n        vec4 enemyDamageCount = texelFetch(iChannel0, ivec2(1, ENEMY_HIT_COUNT_LINE), 0);\n        vec4 damageCount = vec4(0.);\n        if(gameState.x >= float(GAME_STATE_ENEMY_TURN)){\n            damageCount = mix(enemyDamageCount, playerDamageCount, step(float(GAME_STATE_ENEMY_TURN) + .8, gameState.x + iTime - gameState.y));\n        }else if(gameState.x >= float(GAME_STATE_AIMING)){\n            damageCount = mix(playerDamageCount, enemyDamageCount, step(float(GAME_STATE_AIMING) + .8, gameState.x + iTime - gameState.y));\n        }\n        \n        if(gameState.x == float(GAME_STATE_END)){\n            if(gameState.z == float(GAME_STATE_FIRE)){\n                damageCount = enemyDamageCount;\n            }else{\n                damageCount = playerDamageCount;\n            }\n        }\n\n        if(gameState.z != float(GAME_STATE_READY_TO_PLAY) || (iTime - gameState.y) > .9){\n            color = blend(color, vec4(vec3(1.), smoothstep(.00251, .0025, distance(reflectedUV.y, .92)) * smoothstep(.251, .25, distance(reflectedUV.x, .22))));\n            color = blend(color, ship4_2d((reflectedUV - vec2(.25, .8)) * 8., damageCount[3]));\n            color = blend(color, ship3_2d((reflectedUV - vec2(.3, .69)) * 8., damageCount[2]));\n            color = blend(color, ship2_2d_alt((reflectedUV - vec2(.33, .55)) * 8., damageCount[1]));\n            color = blend(color, ship1_2d_alt((reflectedUV - vec2(.375, .41)) * 12., damageCount[0]));\n        }\n        \n        if(gameState.z != float(GAME_STATE_READY_TO_PLAY))\n            playerTroopsWord(color, (uv - vec2(-1.075 + centerPoint, 1.04)) * 3.5, 0.);\n        enemyTroopsWord(color, (uv - vec2(1.075 + centerPoint, 1.04)) * 3.5, 0.);\n    }\n#endif\n\n    if(gameState.x >= float(GAME_STATE_AIMING)){\n        Ray mouseRay = createRay(iMouse.xy, iResolution.xy, iTime, gameState);\n        float mouseHitOcean = (-mouseRay.o.y)\/mouseRay.dir.y;\n        vec3 mouseHitPoint = (mouseRay.o + mouseRay.dir * mouseHitOcean);\n        bool isInside = max(distance(mouseHitPoint.x, 21.), abs(mouseHitPoint.z)) <= 5.;\n        if(isInside)\n            mouseHitPoint.xz = floor(mouseHitPoint.xz) + .5;\n\n        vec3 wa = mouseHitPoint, wb = wa + vec3(.5, 1.5, abs(mouseHitPoint.z * .5) * step(mouseHitPoint.z, 0.)), wc = wb + vec3(1.5, 0., 0.);\n        vec2 sa = projectPoint(wa, fragCoord, iResolution.xy, iTime, gameState);\n        vec2 sb = projectPoint(wb, fragCoord, iResolution.xy, iTime, gameState);\n        vec2 sc = projectPoint(wc, fragCoord, iResolution.xy, iTime, gameState);\n        sa.y += .5;\n        sb.y += .5;\n        sc.y += .5;\n\n        float time = pow(saturate(iTime - gameState.y), .5);\n        float gsf = float(GAME_STATE_FIRE);\n        float gsa = float(GAME_STATE_AIMING);\n        float opacity = smoothstep(gsa + .85, gsf, gameState.x + time)\n                      * smoothstep(gsf + .4, gsf, gameState.x + time);\n\n        vec2 b = mix(sb, sc, smoothstep(.5, 1., 1. - opacity));\n        vec2 a = mix(sa, b, smoothstep(0., .5, 1. - opacity));\n        vec2 c = sc;\n\n        uv = (2. * fragCoord - iResolution.xy)\/iResolution.y;\n        color = mix(color, vec4(BULLSEYE_CLR, 1.), step(.01, opacity) * smoothstep(.015, .005, line(uv, a, b)));\n        color = mix(color, vec4(BULLSEYE_CLR, 1.), step(.01, opacity) * smoothstep(.015, .005, line(uv, b, c)));\n        \n        {\n            vec2 warFogHitCell = floor(mouseHitPoint.xz - vec2(16., -5.));\n            warFogHitCell.y = 10. - warFogHitCell.y;\n            vec2 hitCell = vec2(warFogHitCell.x, iResolution.y - warFogHitCell.y);\n            vec4 hitCellOcupation = texelFetch(iChannel0, ivec2(hitCell), 0);\n            if(hitCellOcupation.w >= 0.)\n                isInside = false;\n        }\n        \n        if(isInside){\n            vec4 clr = vec4(BULLSEYE_CLR, opacity);\n            letter(color, uv, (sb + sc) * .5 + vec2(-.08, .08), vec2(.2), 70 + int(floor(mouseHitPoint.z)), .03, clr);\n            letter(color, uv, (sb + sc) * .5 + vec2(.08, .08), vec2(.2), 32 + int(floor(mouseHitPoint.x)), .03, clr);\n            letter(color, uv, (sb + sc) * .5 + vec2(0., .09), vec2(.2), 45, .03, clr);\n        }else{\n            float shape = opacity * nogologo(uv - (sb + sc) * .5 - vec2(0., .1));\n            vec4 clr = vec4(BULLSEYE_CLR, shape);\n            color = blend(color, clr);\n        }\n    }\n\n#ifdef RENDER_EXPLOSIONS\n    if(gameState.x >= float(GAME_STATE_ENEMY_FIRE)){\n        vec4 lastMove = texelFetch(iChannel0, ivec2(0, LAST_SHOT_LINE), 0);\n        if(lastMove.x >= 0.){\n            vec2 pos = projectPoint(vec3(lastMove.z + .5, .5, lastMove.w + .5), fragCoord, iResolution.xy, iTime, gameState);\n            color = blend(color, explosion((uv - pos) * 10., smoothstep(.25, 1., saturate(iTime - lastMove.y))));\n        }\n    }\n#endif\n\n    if(gameState.x >= float(GAME_STATE_END)){\n        float fade = saturate((iTime - gameState.y) * 4.);\n        float move = (1. - fade) * .5;\n        vec2 uv = fragCoord\/iResolution.y;\n        color = blend(color, vec4(0., 0., 0., .8 * fade));\n        if(gameState.z == float(GAME_STATE_FIRE))\n            victoryWord(color, uv * 2. - vec2(iResolution.x\/iResolution.y, move + 1.75), 0.);\n        else\n            loseWord(color, uv * 2. - vec2(iResolution.x\/iResolution.y, move + 1.75), 0.);\n        \n        vec2 bbPos = vec2(PLAY_AGAIN_BUTTON.CENTER_X, PLAY_AGAIN_BUTTON.CENTER_Y);\n        float xd = distance(uv.x, bbPos.x) - PLAY_AGAIN_BUTTON.WIDTH;\n        float yd = distance(uv.y, bbPos.y + move) - PLAY_AGAIN_BUTTON.HEIGHT;\n        float buttonStencil = step(smax(xd, yd, .025), 0.);\n        color = blend(color, vec4(vec3(.6, .4, .2), buttonStencil));\n        playAgainWord(color, (uv - PLAY_AGAIN_BUTTON.xy - vec2(0., move + .07)) * 4., 0.);\n    }\n\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    fragColor = vec4(gameScene(fragCoord), 1.);\n    vec4 uiOverlay = ui(fragCoord);\n    fragColor.rgb = mix(fragColor.rgb, uiOverlay.rgb, uiOverlay.a);\n}\n\n\/*\n#define SS 1\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    fragColor = vec4(0.);\n    for(int y = ZERO; y < SS; ++y)\n        for(int x = ZERO; x < SS; ++x){\n            fragColor.rgb += clamp(color(fragCoord + vec2(x, y) \/ float(SS)), 0., 1.);\n        }\n    \n    fragColor.rgb \/= float(SS * SS);\n}\n*\/",
            "name": "Image",
            "description": "",
            "type": "image"
        },
        {
            "inputs": [],
            "outputs": [],
            "code": "\/\/#define RENDER_SWAP_BTN\n\/\/#define RENDER_RANDOM_BTN\n#define RENDER_SHIP_INDICATORS\n\/\/#define REFLECTIONS\n#define RENDER_EXPLOSIONS\n\n#define ZERO min(iFrame, 0)\n#define MAX_FLOAT 1e5\n#define MIN_FLOAT 1e-5\n#define EPSILON 1e-4\n#define UP vec3(0., 1., 0.)\n#define rx(a) mat3(1.0, 0.0, 0.0, 0.0, cos(a),-sin(a), 0.0, sin(a), cos(a))\n#define ry(a) mat3(cos(a), 0.0,-sin(a), 0.0, 1.0, 0.0, sin(a), 0.0, cos(a))\n#define rz(a) mat3(cos(a),-sin(a), 0.0, sin(a), cos(a), 0.0, 0.0, 0.0, 1.0)\n#define r2d(a) mat2(cos(a),-sin(a), sin(a), cos(a))\n#define saturate(x) clamp(x, 0., 1.)\n#define WHITE vec3(1.)\n#define RED vec3(1., 0., 0.)\n\nconst float PI = acos(-1.);\nconst float PI2 = PI * 2.;\nconst float HPI = PI * .5;\nconst float QPI = PI * .25;\n\nconst int SHIPS_CNT = 10;\nconst int SHIP_POSITION_LINE = 0;\nconst int SHIP_ROTATION_LINE = 1;\nconst int SHIP_INTERACTION_LINE = 2;\n#define PRESSED x\n#define RELEASE_TIME y\n#define DEST_POINT zw\nconst int SHIP_TOTAL_LINES = 3;\nconst int GAME_STATE_LINE = 4;\nconst int GAME_STATE_START = -1;\nconst int GAME_STATE_POSITIONING = 0;\nconst int GAME_STATE_READY_TO_PLAY = 1;\nconst int GAME_STATE_AIMING = 2;\nconst int GAME_STATE_FIRE = 3;\nconst int GAME_STATE_ENEMY_TURN = 4;\nconst int GAME_STATE_ENEMY_FIRE = 5;\nconst int GAME_STATE_END = 6;\n\nconst int BUTTONS_LINE = 5;\nconst int BUTTONS_BATTLE_ID = 0;\nconst int BUTTONS_COUNT = 1;\n\nconst int LAST_SHOT_LINE = 6;\nconst int ENEMY_HIT_COUNT_LINE = 7;\n\n#define BATTLE_BUTTON vec4(.3, .125, .27, .075)\n#define SWAP_BUTTON vec4(1.6, .095, .1, .05)\n#define RANDOM_BUTTON vec4(1.65, .925, .1, .05)\n#define PLAY_AGAIN_BUTTON vec4(iResolution.x\/iResolution.y * .5, 0.5, .3, .05)\n#define CENTER_X x\n#define CENTER_Y y\n#define WIDTH z\n#define HEIGHT w\n\nstruct Ray{vec3 o, dir;};\nstruct Sphere{vec3 o; float rad;};\nstruct Box{ vec3 o; vec3 size;};\nstruct Cylinder{vec3 A, B; float r;};\nstruct Boat{Box boundingBox; int boatType;};\n\nconst Boat BOAT1 = Boat(Box(vec3(-4.2, .25, 6.2), vec3(.75, .3, .25)), 1);\nconst Boat BOAT2 = Boat(Box(vec3(-2.2, .45, 6.1), vec3(1., .25, .5)), 2);\nconst Boat BOAT3 = Boat(Box(vec3(0.4, .35, 6.1), vec3(1.5, .25, .5)), 3);\nconst Boat BOAT4 = Boat(Box(vec3(2.8, .6, 6.3), vec3(2.25, .5, .75)), 4);\n\nBoat boatFromId(int id){\n    if(id > 8)\n        return BOAT4;\n    if(id > 6)\n        return BOAT3;\n    if(id > 3)\n        return BOAT2;\n    else\n        return BOAT1;\n}\n\nfloat boatSpanFromId(int id){\n    if(id > 8)\n        return 3.;\n    if(id > 6)\n        return 2.;\n    if(id > 3)\n        return 1.;\n    else\n        return 0.;\n}\n\nvec2 boatOffsetsFromPos(int id){\n    return vec2(mod((boatSpanFromId(id)), 2.) * .5, 0.);\n}\n\n\/*\nfloat boatRotationFromId(int id){\n    if(id > 8)\n        return 0.;\n    if(id > 6)\n        return PI;\n    if(id > 3)\n        return 0.;\n    else\n        return PI;\n}\n*\/\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size \/ 2.0;\n    float z = size.y \/ tan(radians(fieldOfView) \/ 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nconst vec3 PLAYER_FIELD_LOOK_AT = vec3(-2., 0., 1.);\nconst vec3 PLAYER_FIELD_CAM_POS = vec3(-2., 13., 17.);\nconst vec3 ENEMY_FIELD_LOOK_AT = vec3(23., 0., 1.);\nconst vec3 ENEMY_FIELD_CAM_POS = vec3(21., 16., 17.);\n\n\/\/const int GAME_STATE_POSITIONING = 0;\n\/\/const int GAME_STATE_READY_TO_PLAY = 1;\n\/\/const int GAME_STATE_PLAYER_TURN = 2;\n\/\/const int GAME_STATE_ENEMY_TURN = 3;\nconst float a = HPI;\n\nvoid camera(out vec3 eye, out vec3 lookAt, float time, vec4 gameState){\n    float t = saturate(time - gameState.y);\n    switch(int(gameState.x)){\n        case GAME_STATE_AIMING:\n            if(int(gameState.z) == GAME_STATE_FIRE){\n                lookAt = ENEMY_FIELD_LOOK_AT;\n                eye = ENEMY_FIELD_CAM_POS;\n            }else{\n                lookAt = mix(PLAYER_FIELD_LOOK_AT, ENEMY_FIELD_LOOK_AT, t);\n                eye = mix(PLAYER_FIELD_CAM_POS, ENEMY_FIELD_CAM_POS, t);\n            }\n            break;\n        case GAME_STATE_END:\n            vec3 e;\n            vec3 l;\n            if(gameState.z == float(GAME_STATE_FIRE)){\n                l = ENEMY_FIELD_LOOK_AT;\n                e = ENEMY_FIELD_CAM_POS;    \n            }else{\n                l = PLAYER_FIELD_LOOK_AT;\n                e = PLAYER_FIELD_CAM_POS;\n            }\n            \n            lookAt = mix(l, vec3(10., 0., 0.), t);\n            eye = mix(e, vec3(10., 30., 30.), t);\n            break;\n        case GAME_STATE_FIRE:\n            lookAt = ENEMY_FIELD_LOOK_AT;\n            eye = ENEMY_FIELD_CAM_POS;\n            break;\n        case GAME_STATE_ENEMY_TURN:\n            lookAt = mix(ENEMY_FIELD_LOOK_AT, PLAYER_FIELD_LOOK_AT, t);\n            eye = mix(ENEMY_FIELD_CAM_POS, PLAYER_FIELD_CAM_POS, t);\n            break;\n        case GAME_STATE_ENEMY_FIRE:\n            lookAt = PLAYER_FIELD_LOOK_AT;\n            eye = PLAYER_FIELD_CAM_POS;\n            break;\n        case GAME_STATE_POSITIONING:\n            if(int(gameState.z) == GAME_STATE_START){\n                lookAt = mix(ENEMY_FIELD_LOOK_AT, PLAYER_FIELD_LOOK_AT, t);\n                eye = mix(ENEMY_FIELD_CAM_POS, PLAYER_FIELD_CAM_POS, t);\n            }else{\n                lookAt = vec3(-.25, 0., 2.4);\n                eye = vec3(-.1, 10., 16.);\n            }\n            break;\n        case GAME_STATE_READY_TO_PLAY:\n            lookAt = vec3(-.25, 0., 2.4);\n            eye = vec3(-.1, 10., 16.);\n        break;\n    }\n}\n\nRay createRay(vec2 fragCoord, vec2 res, float time, vec4 gameState){\n    vec3 lookAt;\n    vec3 eye;\n    camera(eye, lookAt, time, gameState);\n    mat3 m = viewMatrix(eye, lookAt, normalize(vec3(0., 1., 0.)));\n    return Ray(eye, m * rayDirection(45., res, fragCoord));\n}\n\nvec2 projectPoint(vec3 point, vec2 fragCoord, vec2 res, float time, vec4 gameState){\n    vec3 lookAt;\n    vec3 eye;\n    camera(eye, lookAt, time, gameState);\n    \/\/mat3 m = viewMatrix(eye, lookAt, normalize(vec3(0., 1., 0.)));\n    vec3 ro = eye;\n    vec3 ta = lookAt;\n\tvec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww, vec3(0.0,1.0,0.0)));\n    vec3 vv = normalize( cross(uu,ww));\n\t\/\/vec3 rd = normalize( p.x * uu + p.y * vv + fov * ww );\n\t\n    mat4 cam = mat4( uu.x, uu.y, uu.z, 0.0,\n\t\t\t\t\t vv.x, vv.y, vv.z, 0.0,\n\t\t\t\t\t ww.x, ww.y, ww.z, 0.0,\n\t\t\t\t\t -dot(uu,ro), -dot(vv,ro), -dot(ww,ro), 1.0 );\n    vec3 cpos = (cam * vec4(point, 1.)).xyz; \/\/ note inverse multiply\n    \/\/vec3 cpos = (point * m); \/\/ note inverse multiply\n    \/\/vec2 npos = cpos.xy \/ cpos.z  * 5. + vec2(0., .5);\n    vec2 npos = cpos.xy \/ cpos.z  * 5.;\n    \/\/vec2 spos = npos * vec2(res.xy\/res.xx);\n    vec2 spos = npos;\/\/ * vec2(res.xy\/res.xx);\n    return spos;\/\/ * res.xy\/res.x;\n}\n\nmat4 rotationMatrix(vec3 axis, float angle){\n    \/\/ taken from http:\/\/www.neilmendoza.com\/glsl-rotation-about-an-arbitrary-axis\/\n    angle = radians(angle);\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nfloat sphere_hit(const in Sphere sphere, const in Ray inray) {\n    vec3 oc = inray.o - sphere.o;\n    float a = dot(inray.dir, inray.dir);\n    float b = dot(oc, inray.dir);\n    float c = dot(oc, oc) - sphere.rad*sphere.rad;\n    float discriminant = b*b - a*c;\n    if (discriminant > 0.) {\n        return (-b - sqrt(discriminant))\/a;\n    }\n    return -1.;\n}\n\n#define MIN x\n#define MAX y\nbool box_hit(const in Box inbox, in Ray inray){\n    vec2 tx, ty, tz;\n    vec3 maxbounds = inbox.o + vec3( inbox.size);\n    vec3 minbounds = inbox.o + vec3(-inbox.size);\n    tx = ((inray.dir.x >= 0.?vec2(minbounds.x, maxbounds.x):vec2(maxbounds.x, minbounds.x)) - inray.o.x) \/ inray.dir.x;\n\tty = ((inray.dir.y >= 0.?vec2(minbounds.y, maxbounds.y):vec2(maxbounds.y, minbounds.y)) - inray.o.y) \/ inray.dir.y;\n    if ((tx.MIN > ty.MAX) || (ty.MIN > tx.MAX))\n        return false;\n    tx = vec2(max(tx.MIN, ty.MIN), min(tx.MAX, ty.MAX));\n\ttz = ((inray.dir.z >= 0.?vec2(minbounds.z, maxbounds.z):vec2(maxbounds.z, minbounds.z)) - inray.o.z) \/ inray.dir.z;\n    if ((tx.MIN > tz.MAX) || (tz.MIN > tx.MAX))\n        return false;\n    tx = vec2(max(tx.MIN, tz.MIN), min(tx.MAX, tz.MAX));\n    \n    if(tx.MIN >= 0.){\n    \treturn true;\n    }\n        \n    return false;\n}\n\nvec2 iBox(in Ray inray, const in Box inbox){\n    vec2 tx, ty, tz;\n    vec3 maxbounds = inbox.o + vec3( inbox.size);\n    vec3 minbounds = inbox.o + vec3(-inbox.size);\n    tx = ((inray.dir.x >= 0.?vec2(minbounds.x, maxbounds.x):vec2(maxbounds.x, minbounds.x)) - inray.o.x) \/ inray.dir.x;\n\tty = ((inray.dir.y >= 0.?vec2(minbounds.y, maxbounds.y):vec2(maxbounds.y, minbounds.y)) - inray.o.y) \/ inray.dir.y;\n    if ((tx.MIN > ty.MAX) || (ty.MIN > tx.MAX))\n        return vec2(-1.);\n    tx = vec2(max(tx.MIN, ty.MIN), min(tx.MAX, ty.MAX));\n\ttz = ((inray.dir.z >= 0.?vec2(minbounds.z, maxbounds.z):vec2(maxbounds.z, minbounds.z)) - inray.o.z) \/ inray.dir.z;\n    if ((tx.MIN > tz.MAX) || (tz.MIN > tx.MAX))\n        return vec2(-1.);\n    tx = vec2(max(tx.MIN, tz.MIN), min(tx.MAX, tz.MAX));\n    \n    if(tx.MIN >= 0. || tx.MAX >= 0.){\n        return vec2(max(tx.MIN, MIN_FLOAT), tx.MAX);\n    }\n        \n    return vec2(-1.);\n}\n\nmat4 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 translate(vec3 to){\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t to.x,to.y,to.z,1.0 );\n}\n\nvec2 iBox(Ray r, Box box, in mat4 txx, in mat4 txi){\n    \/\/ convert from ray to box space\n\tvec3 rdd = (txx * vec4(r.dir, 0.0)).xyz;\n\tvec3 roo = (txx * vec4(r.o, 1.0)).xyz;\n\n\t\/\/ ray-box intersection in box space\n    vec3 m = 1.0\/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m) * box.size;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return vec2(-1.0);\n\n    return vec2(max(tN, MIN_FLOAT), tF);\n\t\/*\n    vec3 nor = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    \/\/ convert to ray space\n\t\n\tnor = (txi * vec4(nor, 0.0)).xyz;\n\n\treturn vec4( tN, nor );\n    *\/\n}\n\nvec2 cylinderHit(const in Ray ray,  const in Cylinder cyl) {\n  float cxmin, cymin, czmin, cxmax, cymax, czmax;\n  if (cyl.A.z < cyl.B.z) {\n      czmin = cyl.A.z - cyl.r; czmax = cyl.B.z + cyl.r;\n  } else {\n      czmin = cyl.B.z - cyl.r; czmax = cyl.A.z + cyl.r;\n  }\n  if (cyl.A.y < cyl.B.y) {\n      cymin = cyl.A.y - cyl.r; cymax = cyl.B.y + cyl.r;\n  } else {\n      cymin = cyl.B.y - cyl.r; cymax = cyl.A.y + cyl.r;\n  }\n  if (cyl.A.x < cyl.B.x) {\n      cxmin = cyl.A.x - cyl.r; cxmax = cyl.B.x + cyl.r;\n  } else {\n      cxmin = cyl.B.x - cyl.r; cxmax = cyl.A.x + cyl.r;\n  }\n\/*\n  if (optimize) {\n   if (start.z >= czmax && (start.z + dir.z) > czmax) return;\n   if (start.z <= czmin && (start.z + dir.z) < czmin) return;\n   if (start.y >= cymax && (start.y + dir.y) > cymax) return;\n   if (start.y <= cymin && (start.y + dir.y) < cymin) return;\n   if (start.x >= cxmax && (start.x + dir.x) > cxmax) return;\n   if (start.x <= cxmin && (start.x + dir.x) < cxmin) return;\n  }\n*\/\n\n    vec3 AB = cyl.B - cyl.A;\n    vec3 AO = ray.o - cyl.A;\n    vec3 AOxAB = cross(AO, AB);\n    vec3 VxAB  = cross(ray.dir, AB);\n    float ab2 = dot(AB, AB);\n    float a = dot(VxAB, VxAB);\n    float b = 2. * dot(VxAB, AOxAB);\n    float c = dot(AOxAB, AOxAB) - (cyl.r * cyl.r * ab2);\n    float d = b * b - 4. * a * c;\n    if (d < 0.)\n        return vec2(-1.);\n    \n    \/\/rec.dist = (-b - 1. * sqrt(d)) \/ (2. * a);\n    vec2 res = vec2(-1.);\n    float[2] coef = float[2](1., -1.); \n    for(int i=0; i<2; i++){\n        res[i] = (-b - coef[i] * sqrt(d)) \/ (2. * a);\n    }\n    return res;\n}\n\nfloat sdTorus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz) - t.x,p.y);\n    return length(q)-t.y;\n}\n\nfloat sdEllipsoid(vec3 p, vec3 r){\n    float k0 = length(p\/r);\n    float k1 = length(p\/(r*r));\n    return k0*(k0-1.0)\/k1;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdRoundBox(vec3 p, vec3 b, float r){\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdPlane(vec3 p, vec3 n, float h ) {\n    return dot(p,n) + h;\n}\n\nfloat sdCapsule(vec3 p, float h, float r)\n{\n  p.x -= clamp( p.x, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r){\n    vec3  ba = b - a;\n    vec3  pa = p - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    \n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    \n    return sign(d)*sqrt(abs(d))\/baba;\n}\n\nfloat smin(float a, float b, float k){\n\tfloat h = clamp( 0.5 + 0.5*(b-a)\/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k){\n    return smin(a, b, -k);\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r ){\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdSphere(vec3 p, float rad) {\n    return length(p) - rad;\n}\n\nvec2 opMin(vec2 a, vec2 b){\n    return a.x<=b.x?a:b;\n}\n\nvec3 opMin(vec3 a, vec3 b){\n    return a.x<=b.x?a:b;\n}\n\nvec4 opMin(vec4 a, vec4 b){\n    return a.x<=b.x?a:b;\n}\n\nfloat opExtrussion( in vec3 p, in float sdf, in float h )\n{\n    vec2 w = vec2( sdf, abs(p.z) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\/*\nfloat dot2( in vec3 v ) { return dot(v,v); }\nvec2 sdBezier(vec3 pos, vec3 A, vec3 B, vec3 C)\n{    \n    vec3 a = B - A;\n    vec3 b = A - 2.0*B + C;\n    vec3 c = a * 2.0;\n    vec3 d = A - pos;\n\n    float kk = 1.0 \/ dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) \/ 3.0;\n    float kz = kk * dot(d,a);      \n\n    vec2 res;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if(h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) \/ 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0\/3.0));\n        float t = clamp(uv.x+uv.y-kx, 0.0, 1.0);\n\n        \/\/ 1 root\n        res = vec2(dot2(d+(c+b*t)*t),t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q\/(p*z*2.0) ) \/ 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0);\n        \n        \/\/ 3 roots, but only need two\n        float dis = dot2(d+(c+b*t.x)*t.x);\n        res = vec2(dis,t.x);\n\n        dis = dot2(d+(c+b*t.y)*t.y);\n        if( dis<res.x ) res = vec2(dis,t.y );\n    }\n    \n    res.x = sqrt(res.x);\n    return res;\n}\n*\/\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 \/ 3.0, 1.0 \/ 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 blend(in vec4 under, in vec4 over) {\n  vec4 result = mix(under, over, over.a);\n  result.a = over.a + under.a * (1.0 - over.a);\n    \n  return result;\n}\n\n\/\/by iq\n\nvec2 hash( in vec2 x )  \/\/ replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\n\/\/ return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n#if 1\n    \/\/ quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n#else\n    \/\/ cubic interpolation\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n#endif    \n    \n    vec2 ga = hash( i + vec2(0.0,0.0) );\n    vec2 gb = hash( i + vec2(1.0,0.0) );\n    vec2 gc = hash( i + vec2(0.0,1.0) );\n    vec2 gd = hash( i + vec2(1.0,1.0) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   \/\/ value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  \/\/ derivatives\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\n}\n\n\/*\nfloat boat1(vec3 p, mat4 txx, float time){\n    p = (txx * vec4(p, 1.)).xyz;\n    \/\/return length(p) - .25;\n    \n    float res = MAX_FLOAT;\n    {\n        vec3 mpos = p + vec3(p.y, 0., 0.);\n        mpos.z = abs(mpos.z);\n        float bodyOuter = sdEllipsoid(mpos - vec3(0., 0., -.5), vec3(1., 1., .75));\n        float bodyInner = max(max(sdEllipsoid(mpos - vec3(0., 0., -.5), vec3(1., 1., .75) * .99), -mpos.y - .17), p.x - .58);\n        \n        bodyOuter = max(bodyOuter, -bodyInner);\n        bodyOuter = max(bodyOuter, sdPlane(mpos, normalize(vec3(.1, 1., 0.)), .1));\n        bodyOuter = max(bodyOuter, -sdCappedCylinder(mpos.xzy + vec3(0.2, .0, -.25), .4, .3));\n        bodyOuter = max(bodyOuter, -sdBox(mpos.xzy + vec3(-.3, 0., -.1), vec3(.5, .5, .25)));\n        bodyOuter = smax(bodyOuter, p.x - .6, .025);\n      \n        bodyOuter = smax(bodyOuter, -sdPlane(mpos, normalize(vec3(0., 1., .1)), .5), .25);\n        bodyOuter = smax(bodyOuter, sdPlane(mpos, normalize(vec3(0., -1., .25)), -.3), .1);\n        \n        res = min(res, bodyOuter);\n    }\n    \n    {\n        vec3 mpos = p;\n        mpos.z = abs(mpos.z);\n        float cabin = -MAX_FLOAT;\n        cabin = max(cabin, sdPlane(mpos, normalize(vec3(0., .25, 1.)), -.1));\n        cabin = max(cabin, -sdPlane(mpos, normalize(vec3(1., -.3, -.5)), 0.));\n        cabin = max(cabin, -max(sdPlane(mpos, normalize(vec3(1., -.3, -.5)), -.1), -p.y));\n        \n        cabin = max(cabin, -sdPlane(mpos, normalize(vec3(-1., -.3, -.25)), 0.45));\n        cabin = max(cabin, -max(sdPlane(mpos, normalize(vec3(-1., -.3, -.25)), 0.4), -p.y));\n        \n        cabin = max(cabin, sdPlane(mpos, normalize(vec3(0., 1., .3)), -.15));\n        cabin = max(cabin, -p.y - .2);\n        \n        \/\/front lower window\n        cabin = max(cabin, -max(sdBox(mpos + vec3(-.01, .06, -.055), vec3(.05)), sdPlane(mpos, normalize(vec3(1., -.3, -.5)), -.01)));\n        \/\/front upper window\n        cabin = max(cabin, -max(max(sdBox(mpos + vec3(-.15, -.07, -.055), vec3(.05, .06, .05)), sdPlane(mpos, normalize(vec3(1., -.3, -.5)), -.11)), sdPlane(mpos, normalize(vec3(0., .25, 1.)), -.095)));\n        \/\/rear lower window\n        cabin = max(cabin, -max(sdBox(mpos + vec3(-.5, .06, -.055), vec3(.05)), sdPlane(mpos, normalize(vec3(-1., -.3, -.25)), .44)));\n        \/\/rear upper window\n        cabin = max(cabin, -max(max(sdBox(mpos + vec3(-.4, -.075, -.055), vec3(.05)), sdPlane(mpos, normalize(vec3(-1., -.3, -.25)), 0.39)), sdPlane(mpos, normalize(vec3(0., .25, 1.)), -.095)));\n        \n        {\n            vec3 mpos = vec3(p.x, p.y, abs(p.z));\n            cabin = max(cabin, -max(max(max(sdBox(mpos + vec3(-.2, -.071, -.1), vec3(.2, .06, .05)), -sdPlane(mpos, normalize(vec3(1., -.3, -.5)), -.105)), -sdPlane(mpos, normalize(vec3(-1., -.3, -.25)), 0.395)), -sdPlane(mpos, normalize(vec3(0., .25, 1.)), -.09)));\n            \n            mpos *= rx(radians(15.));\n            float illuminator = sdTorus(mpos.xzy - vec3(.1, .1, -.09), vec2(.035, .005));\n            illuminator = min(illuminator, sdTorus(mpos.xzy - vec3(.2, .1, -.09), vec2(.035, .005)));\n            illuminator = min(illuminator, sdTorus(mpos.xzy - vec3(.41, .1, -.09), vec2(.035, .005)));\n            cabin = min(cabin, illuminator);\n            \n            \/\/ door\n            cabin = min(cabin, max(max(max(sdCapsule(mpos.yzx - vec3(-.28, .1, .305), .2, .05), -sdCapsule(mpos.yzx - vec3(-.28, .1, .305), .2, .04)), sdPlane(mpos, normalize(vec3(0., 0., 1.)), -.11)), -p.y - .25));\n        }\n        \n        {\n            vec3 mpos = p;\n            float antenna = sdCapsule(mpos.yzx + vec3(-.1, 0., -.3), .1, .01);\n            vec3 center = vec3(-.3, -.2, 0.);\n            mpos += center;\n            mpos *= ry(time * 2.);\n            mpos -= center;\n            antenna = min(antenna, sdBox(mpos + center, vec3(.1, .0025, .02)));\n            res = min(res, antenna);\n        }\n        \n        res = min(res, cabin);\n    }\n    \n    {\n        vec3 mpos = p;\n        float gun = sdCapsule(mpos.yzx + vec3(0.2, 0., 0.2), .1, .025);\n        vec3 gunCenter = vec3(0.2, 0.05, 0.);\n        \/\/gun = smin(gun, length(mpos + gunCenter) - .09, .01);\n        mpos += gunCenter;\n        mpos *= ry(sin(time) * 2.);\n        mpos *= rz(cos(time) * .5 + .65);\n        mpos -= gunCenter;\n        \n        gun = smin(gun, sdRoundBox(mpos + gunCenter, vec3(.05, .05, .075), .01), .03);\n        gun = max(gun, -sdRoundBox(mpos + gunCenter + vec3(.05, 0., 0.), vec3(.05, .05, .075) * .9, .01));\n\n        \/\/TODO mergen into 1 call\n        float rockets = sdEllipsoid(mpos + gunCenter + vec3(0., 0.031, .062), vec3(.1, .02, .02));\n        rockets = min(rockets, sdEllipsoid(mpos + gunCenter + vec3(0., 0.031, .0225), vec3(.1, .02, .02)));\n        rockets = min(rockets, sdEllipsoid(mpos + gunCenter + vec3(0., 0.031, -.0225), vec3(.1, .02, .02)));\n        rockets = min(rockets, sdEllipsoid(mpos + gunCenter + vec3(0., 0.031, -.0625), vec3(.1, .02, .02)));\n        \n        rockets = min(rockets, sdEllipsoid(mpos + gunCenter + vec3(0., 0.0, .0625), vec3(.1, .02, .02)));\n        rockets = min(rockets, sdEllipsoid(mpos + gunCenter + vec3(0., 0.0, .0225), vec3(.1, .02, .02)));\n        rockets = min(rockets, sdEllipsoid(mpos + gunCenter + vec3(0., 0.0, -.0225), vec3(.1, .02, .02)));\n        rockets = min(rockets, sdEllipsoid(mpos + gunCenter + vec3(0., 0.0, -.0625), vec3(.1, .02, .02)));\n        \n        rockets = min(rockets, sdEllipsoid(mpos + gunCenter + vec3(0., -.031, .0625), vec3(.1, .02, .02)));\n        rockets = min(rockets, sdEllipsoid(mpos + gunCenter + vec3(0., -.031, .0225), vec3(.1, .02, .02)));\n        rockets = min(rockets, sdEllipsoid(mpos + gunCenter + vec3(0., -.031, -.0225), vec3(.1, .02, .02)));\n        rockets = min(rockets, sdEllipsoid(mpos + gunCenter + vec3(0., -.031, -.0625), vec3(.1, .02, .02)));\n        \n        rockets = max(rockets, mpos.x + gunCenter.x);\n        \n        gun = min(gun, rockets);\n        \n        res = min(res, gun);\n    }\n    \n    if(false){\n        vec3 mpos = p;\n        res = max(res, -(length(mpos + vec3(.54, 0.08, 0.05)) - .04));\n    \n        \n        mpos += vec3(.55, 0.02, .06);\n        mpos *= ry(radians(35.));\n        mpos.xz = abs(mpos.xz);\n        \n        float anchor = max(sdEllipsoid(mpos + vec3(.2, 0., 0.2), vec3(.5, .5, .25)), -(length(mpos + vec3(0.11, -.04, 0.)) - .25));\n        mpos = p;\n        anchor = min(anchor, sdCapsule(mpos.yzx + vec3(0.2, 0.06, 0.55), .085, .005));\n        res = min(res, anchor);\n    }\n    \n    return res;\n}\n\n\nfloat b2(vec3 p){\n    vec3 mpos = p;\n    mpos.z = abs(mpos.z);\n    float body = sdPlane(mpos, normalize(vec3(0., -1.2, 1.)), -1.);\n    \n    body = smax(body, sdPlane(mpos, normalize(vec3(-.15, 0., 1.)), -.4), .1);\n    body = smax(body, sdPlane(mpos, normalize(vec3(1., -1.2, 1.2)), -.2), .05);\n    body = smax(body, sdPlane(mpos, normalize(vec3(-1., -.6, .4)), -.5), .1);\n    \n    body = max(body, p.y - .4);\n    \n    return body;\n}\n*\/\n\n#define MAT_BOAT1 101\n#define MAT_BOAT2 102\n#define MAT_BOAT3 103\n#define MAT_BOAT4 104\n#define MAT_PLANE_MAIN 105\n#define MAT_PLANE_CABIN 106\n#define MAT_BOAT1_CAB 107\n\nvec2 boat1(vec3 p, mat4 txx, float time){\n    p = (txx * vec4(p, 1.)).xyz;\n    p.x *= -1.;\n    \n    float res = MAX_FLOAT;\n    vec3 mpos = p;\n    mpos.z = abs(mpos.z);\n    mpos.y += .2;\n    float body;\n    {\n        \n        body = sdPlane(mpos, normalize(vec3(0., -1., 1.)), 0.);\n        body = smax(body, sdPlane(mpos, normalize(vec3(0., 0., 1.)), -.2), .05);\n        body = smax(body, sdPlane(mpos, normalize(vec3(-1., -1., 1.5)), -.2), .1);\n        body = smax(body, sdPlane(mpos, normalize(vec3(1., -.1, 0.0)), -.55), .2);\n    }\n    \n    float body2;\n    {\n        vec3 mpos = p * vec3(1., 1.1, 1.15) + vec3(.02, 0., 0.);\n        mpos.z = abs(mpos.z);\n        mpos.y += .15;\n        body2 = sdPlane(mpos, normalize(vec3(0., -1., 1.)), 0.);\n        body2 = smax(body2, sdPlane(mpos, normalize(vec3(0., 0., 1.)), -.2), .05);\n        body2 = smax(body2, sdPlane(mpos, normalize(vec3(-1., -1., 1.5)), -.2), .1);\n        body2 = smax(body2, sdPlane(mpos, normalize(vec3(1., -.1, 0.0)), -.55), .2);\n    }\n\n    res = max(body, -body2);\n    res = max(res, mpos.y - .35);\n    res = min(res, max(mpos.y - .25, body));\n    res = max(res, -sdCylinder(p.xzy - vec3(-.275, 0., .175), vec3(0., 0., .1)));\n    res = max(res, -sdBox(p - vec3(.25, .275, 0.), vec3(.5, .2, .3)));\n    \n    {\n        vec3 center = vec3(.4, 0.1, 0.);\n        vec3 mpos = p;\n        mpos -= center;\n        mpos *= ry(cos(time * .5)) * rz(sin(time) * .25 + 1.);\n        mpos += center;\n        float gun = length(mpos - center) - .1;\n        gun = max(gun, mpos.y - .12);\n        gun = min(gun, length(mpos - center + vec3(0., .05, 0.)) - .1);\n        mpos.z = abs(mpos.z);\n        float barrels = max(sdCylinder(mpos - center, vec3(0., 0.035, .025)), mpos.y - .75);\n        barrels = max(barrels, -mpos.y);\n        barrels = max(barrels, mpos.y - .35);\n        gun = min(gun, barrels);\n        \n        res = min(res, gun);\n    }\n    \n    vec2 boat = vec2(res, MAT_BOAT1);\n    \n    {\n        float cabin;\n        vec3 mpos = p - vec3(.1, 0., 0.);\n        mpos.z = abs(mpos.z);\n        cabin = sdPlane(mpos, normalize(vec3(0., 0., 1.)), -.125);\n        cabin = max(cabin, mpos.y - .3);\n        cabin = max(cabin, -mpos.y);\n        cabin = max(cabin, sdPlane(mpos, normalize(vec3(-.75, .5, .75)), -.35));\n        cabin = max(cabin, sdPlane(mpos, normalize(vec3(1., 0., .25)), -.1));\n\n        float roof = sdBox(mpos - vec3(0.2, .3, 0.), vec3(1., .01, .17));\n        roof = max(roof, sdPlane(mpos, normalize(vec3(-.75, -.5, .75)), -.125));\n        roof = max(roof, sdPlane(mpos, normalize(vec3(1., 0., .25)), -.1));\n\n        cabin = min(cabin, roof);\n        boat = opMin(boat, vec2(cabin, MAT_BOAT1_CAB));\n    }\n\n    return boat;\n}\n\nvec2 boat2(vec3 p, mat4 txx, float time){\n    p = (txx * vec4(p, 1.)).xyz;\n    \/\/return length(p) - .25;\n    \n    float res = MAX_FLOAT;\n    \n    {\n        vec3 mpos = p;\n        mpos.z = abs(mpos.z);\n        mpos.z -= p.x * .2;\n        float bodyOuter = smax(sdEllipsoid(mpos - vec3(-1.38, .5, -.35), vec3(2.5, 2.5, .75)), -p.x - .97, .05);\n        float bodyInner = max(smax(sdEllipsoid(mpos - vec3(-1.38, .5, -.35), vec3(2.5, 2.5, .75) * .99),  -p.x - .96, .05), -p.y - .15);\n        bodyOuter = max(bodyOuter, -bodyInner);\n        \n        bodyOuter = max(bodyOuter, p.y + .1);\n        \n        float cabin = sdEllipsoid(mpos - vec3(-1.38, .5, -.35), vec3(2.5, 2.5, .75));\n        cabin = max(cabin, -sdPlane(mpos, normalize(vec3(-1., -.5, 0.)), 0.));\n        cabin = max(cabin, -sdPlane(mpos, normalize(vec3(-1., -.5, -.5)), 0.08));\n        \n        cabin = max(cabin, -sdPlane(mpos, normalize(vec3(1., -.5, 0.)), 0.7));\n        cabin = max(cabin, p.y - .05);\n        \n        float upperCabin = sdEllipsoid(mpos - vec3(-1.38, .5, -.35), vec3(2.5, 2.5, .75) * .95);\/\/sdBox(mpos + vec3(.5, 0., 0.), vec3(.175, .25, .3));\n        upperCabin = max(upperCabin, -sdPlane(mpos, normalize(vec3(-1., -.5, 0.)), -.2));\n        upperCabin = max(upperCabin, -sdPlane(mpos, normalize(vec3(-1., -.5, -.5)), -.1));\n        upperCabin = max(upperCabin, p.y - .175);\n        upperCabin = max(upperCabin, -p.x - .7);\n        cabin = min(cabin, upperCabin);\n        \n        {\n            vec3 mpos = p;\n            mpos.x -= .4;\n            float antenna = sdCapsule(mpos.yzx + vec3(0., 0., 0.5), .15, .01);\n            vec3 antennaCenter = vec3(-.5, .15, 0.);\n            antenna = min(antenna, length(mpos - antennaCenter) - .05);\n            mpos -= antennaCenter;\n            mpos *= ry(sin(time));\n            mpos += antennaCenter;\n            antenna = min(antenna, max(length(mpos - antennaCenter - vec3(.21, 0., 0.)) - .2, sdEllipsoid(mpos - antennaCenter, vec3(.25, .1, .25))));\n            antenna = max(antenna, -length(mpos - antennaCenter - vec3(.21, 0., 0.)) + .195);\n            cabin = min(cabin, antenna);\n        }\n        \n        {\n            vec3 mpos = p;\n            vec3 center = vec3(.75, -.1, 0.);\n            float gun = sdRoundBox(mpos - center, vec3(.05), .05);\n            gun = max(gun, p.y + .1);\n            gun = min(gun, distance(mpos, center) - .075);\n            mpos -= center;\n            mpos *= ry(cos(time * .75));\n            mpos *= rz(QPI * 1.5);\n            mpos += center;\n            mpos.z = abs(mpos.z);\n            gun = min(gun, sdBox(mpos - center - vec3(.04, .05, 0.), vec3(.01, .03, .03)));\n            gun = min(gun, sdBox(mpos - center - vec3(-.1, .08, 0.), vec3(.025, .01, .125)));\n            gun = min(gun, sdBox(mpos - center - vec3(-.04, .08, 0.125), vec3(.05, .01, .05)));\n            \n            float barrels = max(max(sdCylinder(mpos - center, vec3(-0.04, 0.035, .025)), -sdCylinder(mpos - center, vec3(-0.04, 0.035, .023))), mpos.y - .75);\n            barrels = max(barrels, mpos.y - .175);\n            barrels = max(barrels, -mpos.y - .1);\n            gun = min(gun, barrels);\n            \n            \n            cabin = min(cabin, gun);\n        }\n\n        bodyOuter = min(bodyOuter, cabin);\n        bodyOuter = max(bodyOuter, -p.y - .35);\n        \n        res = min(res, bodyOuter);\n    }\n    \n    return vec2(res, MAT_BOAT2);\n}\n\nvec2 boat3(vec3 p, mat4 txx){\n    p = (txx * vec4(p, 1.)).xyz;\n    p.x *= -1.;\n    p.y += .25;\n    \/\/return length(p) - .5;\n    \n    float res = MAX_FLOAT;\n    {\n        vec3 mpos = p;\n        mpos.yz *= 1. + p.x * .3;\n        float body = sdEllipsoid(mpos, vec3(1.5, .25, .25));\n        \n        mpos = p + vec3(.3, 0., 0.);\n        float cabin = sdEllipsoid(mpos, vec3(.35, 5., .15));\n        cabin = max(cabin, -p.y);\n        cabin = smax(cabin, p.y - .5, .075);\n        body = smin(body, cabin, .025);\n        \n        mpos.z = abs(mpos.z);\n        mpos.y -= .4;\n        mpos.x += .1;\n        float wing = sdEllipsoid(mpos, vec3(.1, .025, 2.));\n        wing = smax(wing, mpos.z - .3, .01);\n        body = smin(body, wing, .02);\n        \n        mpos = p;\n        mpos.x -= 1.2;\n        mpos.x -= p.y * .7;\n        float tail = sdEllipsoid(mpos, vec3(.15, 1., .025));\n        tail = smax(tail, p.y - .25, .01);\n        tail = max(tail, -p.y);\n        tail = smax(tail, p.x - 1.4, .05);\n        body = smin(body, tail, .05);\n        \n        mpos = p + vec3(1.2, 0., 0.);\n        float antenna = sdCylinder(mpos, vec3(1., .02, .02));\n        antenna = max(antenna, p.y - .8);\n        antenna = min(antenna, max(sdCylinder(mpos + vec3(-.025, 0., .025), vec3(1., .02, .02)), p.y - .6));\n        antenna = max(antenna, -p.y);\n        body = min(body, antenna);\n        res = min(res, body);\n    }\n    \n    return vec2(res, MAT_BOAT3);\n}\n\nvec2 plane(vec3 pos){\n    pos -= vec3(0., .05, 0.);\n    pos.z = abs(pos.z);\n    float body = sdEllipsoid(pos, vec3(.25, .05, .05));\n    float cabin = sdEllipsoid(pos - vec3(.08, .035, 0.), vec3(.1, .025, .025));\n    float wings = max(max(pos.y - .01, -pos.y + .01), sdPlane(pos, normalize(vec3(1., 0., 1.)), -.1));\n    wings = max(wings, -sdPlane(pos, normalize(vec3(1., 0., .5)), .03));\n    wings = max(wings, pos.z - .2);\n    \n    float tail = max(max(pos.y - .01, -pos.y + .01), sdPlane(pos, normalize(vec3(1., 0., 1.5)), .05));\n    tail = max(tail, -sdPlane(pos, normalize(vec3(1., 0., .5)), .225));\n    tail = min(tail, max(max(pos.z - .005, sdPlane(pos, normalize(vec3(1., 1., 0.)), .1)), -sdPlane(pos, normalize(vec3(1., 1., 0.)), .175)));\n    tail = max(tail, -pos.x - .3);\n    tail = max(tail, pos.y - .1);\n    tail = max(tail, -pos.y - .1);\n    \n    body = min(min(body, wings), tail);\n    vec2 res = vec2(MAX_FLOAT);\n    return opMin(vec2(body, MAT_PLANE_MAIN), vec2(cabin, MAT_PLANE_CABIN));\n}\n\nvec2 boat4(vec3 p, mat4 txx, float time){\n    p = (txx * vec4(p, 1.)).xyz;\n    p.y += .5;\n    \/\/p.y += .5;\n    \/\/return length(p) - .5;\n    \n    float res = MAX_FLOAT;\n    {\n        vec3 mpos = p;\n        float body = sdBox(mpos, vec3(2., .5, .25));\n        \n        mpos.z = abs(mpos.z);\n        mpos.x = abs(mpos.x);\n        mpos *= ry(radians(15.));\n        mpos *= rz(radians(-3.));\n        body = smax(body, -sdCylinder(mpos.zxy, vec3(0.7, 0.05, .35)), .1);\n        \n        mpos = p - vec3(0., .5, 0.);\n        float deck = sdBox(mpos, vec3(2., .025, .75));\n        deck = max(deck, -max(sdPlane(mpos, normalize(vec3(-.1, 0., -1.)), 0.5),\n                              -sdPlane(mpos, normalize(vec3(1., 0., 1.)), -1.)));\n        deck = max(deck, -max(sdPlane(mpos, normalize(vec3(-.1, 0., 1.)), .4),\n                              -sdPlane(mpos, normalize(vec3(1., 0., -1.)), -.5)));\n        deck = max(deck, sdPlane(mpos, normalize(vec3(-.2, 0., -1.)), -.7));\n        deck = max(deck, sdPlane(mpos, normalize(vec3(-.1, 0., 1.)), -.6));\n        body = min(body, deck);\n        \n        {\n            vec3 mpos = p - vec3(-.5, .5, .3);\n            float cabin = sdBox(mpos, vec3(.25, .4, .1));\n            cabin = max(cabin, -mpos.y);\n            cabin = min(cabin, max(mpos.y - .6, max(-mpos.y + .2, sdRoundBox(mpos - vec3(0., .4, 0.), vec3(.15, .5, .05), .2))));\n            body = min(body, cabin);\n        }\n        \n        res = min(res, body);\n    }\n    res = max(res, -p.y);\n    vec2 ship = vec2(res, MAT_BOAT4);\n    {\n        vec3 mpos = p;\n        mpos = p - vec3(0., .5, 0.);\n        \n        vec3 plane1cntr = vec3(-1.8, 0., .1);\n        vec2 plane1 = plane(mpos - plane1cntr);\n        \n        plane1cntr = vec3(.15, 0., .3);\n        mpos -= plane1cntr;\n        mpos *= ry(QPI);\n        mpos += plane1cntr;\n        vec2 plane2 = plane(mpos - plane1cntr);\n\n\n        plane1cntr = vec3(.45, 0., .65);\n        vec2 plane3 = plane(mpos - plane1cntr);\n\n        ship = opMin(ship, opMin(opMin(plane1, plane2), plane3));\n    }\n    \n    return ship;\n}\n\nfloat easeInExpo(float x) {\n    return x == 0. ? 0. : pow(2., 10. * x - 10.);\n}\n\nfloat easeOutExpo(float x) {\n    return x == 1. ? 1. : 1. - pow(2., -10. * x);\n}\n\nfloat easeOutBounce(float x) {\n    float n1 = 7.5625;\n    float d1 = 2.75;\n\n    if (x < 1. \/ d1) {\n        return n1 * x * x;\n    } else if (x < 2. \/ d1) {\n        return n1 * (x -= 1.5 \/ d1) * x + 0.75;\n    } else if (x < 2.5 \/ d1) {\n        return n1 * (x -= 2.25 \/ d1) * x + 0.9375;\n    } else {\n        return n1 * (x -= 2.625 \/ d1) * x + 0.984375;\n    }\n}\n\nfloat easeInBounce(float x) {\n    return 1. - easeOutBounce(1. - x);\n}\n\nfloat easeInOutBounce(float x) {\n    return x < .5\n      ? (1. - easeOutBounce(1. - 2. * x)) \/ 2.\n      : (1. + easeOutBounce(2. * x - 1.)) \/ 2.;\n}\n\nfloat easeOutElastic(float x) {\n    float c4 = (2. * PI) \/ 3.;\n\n    return x == 0.\n      ? 0.\n      : x == 1.\n      ? 1.\n      : pow(2., -10. * x) * sin((x * 10. - .75) * c4) + 1.;\n}\n\n\nvec2 button3d(vec3 p, mat4 txx){\n    p = (txx * vec4(p, 1.)).xyz;\n    p.z *= -1.;\n    vec2 res = vec2(MAX_FLOAT);\n    res = opMin(res, vec2(sdRoundBox(p, vec3(1., .1, .35), .05), vec3(0., 1., 0.)));\n    \n    \/*\n    p.x += .775;\n    res = opMin(res, vec2(max(sdBox(p, vec3(.2)), letter3(p.xz, vec2(0.), vec2(.7), 66) - .52), vec3(1.)));\n    p.x -= .35;\n    res = opMin(res, vec2(max(sdBox(p, vec3(.2)), letter3(p.xz, vec2(0.), vec2(.7), 65) - .52), vec3(1.)));\n    p.x -= .3;\n    res = opMin(res, vec2(max(sdBox(p, vec3(.2)), letter3(p.xz, vec2(0.), vec2(.7), 84) - .52), vec3(1.)));\n    p.x -= .35;\n    res = opMin(res, vec2(max(sdBox(p, vec3(.2)), letter3(p.xz, vec2(0.), vec2(.7), 84) - .52), vec3(1.)));\n    p.x -= .3;\n    res = opMin(res, vec2(max(sdBox(p, vec3(.2)), letter3(p.xz, vec2(0.), vec2(.7), 76) - .52), vec3(1.)));\n    p.x -= .3;\n    res = opMin(res, vec2(max(sdBox(p, vec3(.2)), letter3(p.xz, vec2(0.), vec2(.7), 69) - .52), vec3(1.)));\n    *\/\n    return res;\n}\n\nfloat ASCIIskull(vec2 p){\n    float n = 11524078.0;\n\tp = floor(p*vec2(4.0, -4.0) + 2.5); \/\/[-1,1],[-1,1] => [-4,4],[4,-4] + 2.5\n\tif (clamp(p.x, 0.0, 4.0) == p.x && clamp(p.y, 0.0, 4.0) == p.y) \/\/Creates a border for each character\n\t{\n        \/\/Read the bitmap, output 1 if there's a pixel...\n\t\tif (int(mod(n\/exp2(p.x + 5.0*p.y), 2.0)) == 1) return 1.0;\n\t}\n\treturn 0.0;\n}\n\nfloat sdEllipse(vec2 p, vec2 ab)\n{\n    \/\/ symmetry\n\tp = abs( p );\n    \n    \/\/ initial value\n    vec2 q = ab*(p-ab);\n    vec2 cs = normalize( (q.x<q.y) ? vec2(0.01,1) : vec2(1,0.01) );\n    \n    \/\/ find root with Newton solver (see https:\/\/www.shadertoy.com\/view\/4lsXDN)\n    for( int i=0; i<5; i++ )\n    {\n        vec2 u = ab*vec2( cs.x,cs.y);\n        vec2 v = ab*vec2(-cs.y,cs.x);\n        \n        float a = dot(p-u,v);\n        float c = dot(p-u,u) + dot(v,v);\n        float b = sqrt(c*c-a*a);\n        \n        cs = vec2( cs.x*b-cs.y*a, cs.y*b+cs.x*a )\/c;\n    }\n    \n    \/\/ compute final point and distance\n    float d = length(p-ab*cs);\n    \n    \/\/ return signed distance\n    return (dot(p\/ab,p\/ab)>1.0) ? d : -d;\n}\n\nfloat sdRoundSquare( in vec2 p, in float s, in float r ) \n{\n    vec2 q = abs(p)-s+r;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat line(vec2 p, vec2 a,vec2 b) {\n    p -= a, b -= a;\n    float h = clamp(dot(p, b) \/ dot(b, b), 0., 1.);\n    return length(p - b * h);\n}\n\n#define SHAPE_WIDTH .025\n#define SHAPE_AA .02\n\nvec4 ship1_2d_alt(vec2 uv, float hit){\n    uv.x *= -1.;\n    vec3 clr = mix(WHITE, RED, step((uv.x - uv.y * .5 + .15) * 2., floor(hit) - 2.));\n    clr = mix(clr, RED, easeOutBounce(fract(hit)) * step(distance((uv.x - uv.y * .5 + .15) * 1.8, floor(hit) - 2. + .5), .5));\n\n    float bg = step(fract((uv.x - uv.y * .5 + .15) * 1.8), .85) * .5 * step(abs((uv.x - uv.y * .5 + .15) * 1.8), 2.) * step(abs(uv.y - .25), .5);\n    \n    float shape = sdBox(uv + vec2(.35 + uv.y * .3, .05), vec2(.7, .2));\n    shape = min(shape, sdBox(uv + vec2(-.4 - uv.y, -.025), vec2(.3, .275)));\n    \n    float cabin = sdBox(vec2(abs(uv.x + -.15), uv.y) - vec2(-uv.y * (.25 + .5 * step(0., uv.x)) + .35, .5), vec2(.35, .3));\n    cabin = min(cabin, sdBox(uv - vec2(0.1, .8), vec2(.45, .02)));\n    \n    float gun = distance(uv, vec2(-.75, .25)) - .2;\n    float barrel = sdBox(uv - vec2(-1., -.1 - uv.x * .5), vec2(.2, .05));\n    \n    bg *= step(min(gun, min(cabin, shape)), 0.);\n    \n    cabin = smoothstep(SHAPE_WIDTH + SHAPE_AA, SHAPE_WIDTH, abs(cabin)) * smoothstep(.05, .07, shape);\n    barrel = smoothstep(SHAPE_WIDTH + SHAPE_AA, SHAPE_WIDTH, abs(barrel)) * smoothstep(.05, .07, gun);\n    gun = smoothstep(SHAPE_WIDTH + SHAPE_AA, SHAPE_WIDTH, abs(gun)) * smoothstep(.05, .07, shape);\n    shape = smoothstep(SHAPE_WIDTH + SHAPE_AA, SHAPE_WIDTH, abs(shape));\n    float window = smoothstep(SHAPE_WIDTH + SHAPE_AA, SHAPE_WIDTH, distance(distance(uv, vec2(-.2, .5)), .05));\n    return vec4(clr, max(window, max(bg, max(barrel, max(gun, max(shape, cabin))))));\n}\n\nvec4 ship2_2d_alt(vec2 uv, float hit){\n    uv.x *= -1.;\n    vec3 clr = mix(WHITE, RED, step((uv.x - uv.y * .5 + .15) * 2.9, floor(hit) - 3.));\n    clr = mix(clr, RED, easeOutBounce(fract(hit)) * step(distance((uv.x - uv.y * .5 + .15) * 2.9, floor(hit) - 3. + .5), .5));\n    \n    float bg = step(fract((uv.x - uv.y * .5 + .15) * 2.9), .85) * .5 * step(abs((uv.x - uv.y * .5 + .15) * 2.9), 3.) * step(abs(uv.y - .2), .42);\n\n    float shape = sdBox(uv + vec2(.35 + uv.y * .3, .05), vec2(.7, .2));\n    shape = min(shape, sdBox(uv + vec2(-.4 - uv.y, -.0125), vec2(.3, .275)));\n    \n    float window = smoothstep(SHAPE_WIDTH + SHAPE_AA, SHAPE_WIDTH, distance(distance(uv, vec2(.55, .07)), .05));\n    window = max(window, smoothstep(SHAPE_WIDTH + SHAPE_AA, SHAPE_WIDTH, distance(distance(uv, vec2(-.55, .35)), .05)));\n    \n    float cabin = sdBox(vec2(abs(uv.x + .45), uv.y) - vec2(-uv.y * .5 + .3, .25), vec2(.35, .15));\n    cabin = min(cabin, sdBox(vec2(abs(uv.x + .55), uv.y) - vec2(-uv.y * .5 + .3, .45), vec2(.2, .15)));\n    \n    \n    bg *= step(min(cabin, shape), 0.);\n    \n    cabin = smoothstep(SHAPE_WIDTH + SHAPE_AA, SHAPE_WIDTH, abs(cabin)) * smoothstep(.05, .07, shape);\n    shape = smoothstep(SHAPE_WIDTH + SHAPE_AA, SHAPE_WIDTH, abs(shape));\n    \n    \n    return vec4(clr, max(window, max(bg, max(shape, cabin))));\n}\n\nvec4 ship3_2d(vec2 uv, float hit){\n    uv.x *= -1.;\n    vec3 clr = mix(WHITE, RED, step((uv.x - uv.y * .5 - .1) * 1.9, floor(hit) - 3.));\n    clr = mix(clr, RED, easeOutBounce(fract(hit)) * step(distance((uv.x - uv.y * .5 - .1) * 1.9, floor(hit) - 3. + .5), .5));\n    \n    float bg = step(fract((uv.x - uv.y * .5 - .1) * 1.9), .9) * .5 * step(abs((uv.x - uv.y * .5 - .1) * 1.9), 3.) * step(abs(uv.y - .1), .4);\n    \n    float body = sdEllipse(uv - vec2(.1, 0.)\/* * vec2(1., 1. + uv.x * .5)*\/, vec2(1.4, .2 + uv.x * .07));\n    float cabin = sdRoundSquare(uv * vec2(1., 1.5) - vec2(0.35, .4),.3, .05);\n    \n    uv.y = abs(uv.y - .07);\n    float tail = sdBox(uv + vec2(.8 + uv.y, 0.), vec2(.2, .25));\n    \n    bg *= step(min(tail, min(cabin, body)), 0.);\n    \n    tail = smoothstep(SHAPE_WIDTH + SHAPE_AA, SHAPE_WIDTH, abs(tail)) * smoothstep(.05, .07, body);\n    cabin = smoothstep(SHAPE_WIDTH + SHAPE_AA, SHAPE_WIDTH, abs(cabin)) * smoothstep(.05, .07, body);\n    body = smoothstep(SHAPE_WIDTH + SHAPE_AA, SHAPE_WIDTH, abs(body));\n    \n    return vec4(clr, max(tail, max(bg, max(body, cabin))));\n}\n\nvec4 ship4_2d(vec2 uv, float hit){\n    uv.x *= -1.;\n    float bg = step(fract((uv.x - uv.y * .5 + .15) * 1.1), .95) * .5 * step(abs((uv.x - uv.y * .5 + .15) * 1.1), 2.) * step(abs(uv.y - .27), .5);\n\n    float body = sdBox(uv - vec2(0., .1), vec2(1.75, .3));\/\/sdQuad(uv, vec2(1.75, .4), vec2(1.75, -.2), vec2(-1.75, -.2), vec2(-1.75, .4));\n    body = max(body, -sdEllipse(vec2(abs(uv.x), uv.y) - vec2(1.85, -.2), vec2(1., .5)));\n    float cabin = sdRoundSquare(uv - vec2(-.3, .3),.5, .05);\n    bg *= step(min(cabin, body), 0.);\n    cabin = smoothstep(SHAPE_WIDTH + SHAPE_AA, SHAPE_WIDTH, abs(cabin)) * smoothstep(.05, .07, body);\n    body = smoothstep(SHAPE_WIDTH + SHAPE_AA, SHAPE_WIDTH, abs(body));\n    \n    float window = smoothstep(SHAPE_WIDTH + SHAPE_AA, SHAPE_WIDTH, distance(distance(uv, vec2(-.2, .65)), .05));\n    window = max(window, smoothstep(SHAPE_WIDTH + SHAPE_AA, SHAPE_WIDTH, distance(distance(uv, vec2(0., .65)), .05)));\n    \n    vec3 clr = mix(WHITE, RED, step((uv.x - uv.y * .5 + .15) * 1.1, floor(hit) - 2.));\n    clr = mix(clr, RED, easeOutBounce(fract(hit)) * step(distance((uv.x - uv.y * .5 + .15) * 1.1, floor(hit) - 2. + .5), .5));\n    \n    return vec4(clr, max(bg, max(window, max(body, cabin))));\n}\n\nfloat nogologo(vec2 uv){\n    uv *= r2d(-QPI);\n    uv *= 2.;\n    float circle = smoothstep(.0251, .025, distance(.1, length(uv)));\n    float bar = 1. - max(smoothstep(.15, .151, abs(uv.x)), smoothstep(.025, .0251, abs(uv.y)));\n    return max(circle, bar);\n}\n\n#define HASHSCALE4 vec4(.1031, .1030, .0973, .1099)\nvec4 hash41(float p){\n        vec4 p4 = fract(vec4(p) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n#define EXPLOSION_AA .01\nvec4 explosion(vec2 uv, float time){\n    vec4 res = vec4(0.);\n    \n    {\n        vec2 pol = vec2(length(uv), atan(uv.x, uv.y));\n        float n = floor((pol.y * 15.)\/PI);\n        pol.y = mod(pol.y * 15., PI)\/PI;\n        pol.y = 2. * pol.y - 1.;\n        pol.y *= pol.x * PI;\n        pol.x *= 20.;\n        \n        vec4 h = hash41(n * .17);\n        float s = (.25 + h.y * .5) * smoothstep(.25, .3, time) * smoothstep(.55, .5, time);\n        \n        float start = 40. * smoothstep(.3, .5, time) * (2. - h.x);\n        float end = 40. * smoothstep(.3, .4, time) * (2. - h.x);\n        float width = (end - start)\/2.;\n        float mid = start + width;\n        float v = mix(smoothstep(s + EXPLOSION_AA, s, abs(pol.y)),\n                      max(smoothstep(s + EXPLOSION_AA, s, distance(vec2(start, 0.), pol)),\n                          smoothstep(s + EXPLOSION_AA, s, distance(vec2(end, 0.), pol))),\n                      step(width, distance(pol.x, mid)));\n        res = mix(res, vec4(hsv2rgb(vec3(1. + (h.w * .2 - .1), smoothstep(.6, .4, time), 1.)), 1.), v * step(0., uv.y));\n    }\n    \n    for(int i=0; i<12; i++){\n        vec4 hash = hash41(float(i));\n        \n        vec3 color = hsv2rgb(vec3(time * .2 + (hash.x * .1 - .05), 1., 1.));\n        \n        float startTime = hash.x * .2;\n        float size = smoothstep(startTime, startTime + .1, time) * (.5 + hash.z * .25)\n                   * smoothstep(.65 - startTime, .6 - startTime, time);\n        float ang = hash.y * PI - HPI;\n        float rad = .3 + smoothstep(.3, .4, time) * (2. - hash.x) * .6;\n        vec2 pos = vec2(rad * sin(ang), rad * cos(ang));\n        vec4 clr = vec4(color, smoothstep(.01, 0., distance(uv, pos) - size));\n        \n        \n        size = smoothstep(startTime + .2, startTime + .3, time) * (.5 + hash.z * .25);\n        rad = smoothstep(startTime + .35, startTime + .4, time) * (2. - hash.x) * .75;\n        pos = vec2(rad * sin(ang), rad * cos(ang));\n        clr = mix(vec4(clr.rbg, 0.), clr, smoothstep(0., .01, distance(uv, pos) - size));\n        \n        res = mix(res, clr, clr.a);\n    }\n    \n    return res;\n}\n\nfloat bullsEye(vec2 uv){\n    float bullsEye = smoothstep(.15, .1, min(abs(uv.x), abs(uv.y))) * smoothstep(1.1, .9, length(uv));\n    return max(bullsEye, step(length(uv), 1.05) * smoothstep(.25, .1, distance(fract(length(uv * 2.)), .5)));\n}",
            "name": "Common",
            "description": "",
            "type": "common"
        },
        {
            "inputs": [
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dXGR8",
                    "channel": 0
                }
            ],
            "code": "float time;\n\nstruct {\n    bool mouseDown;\n    bool clickedThisFrame;\n    bool releasedThisFrame;\n} mouseState;\n\n\nbool intersects(int a, int b){\n    Boat boatA = boatFromId(a);\n    vec2 boatAPos = texelFetch(iChannel0, ivec2(a, SHIP_POSITION_LINE), 0).rb;\n    boatAPos.x -= boatOffsetsFromPos(a).x;\n    \n    Boat boatB = boatFromId(b);\n    vec2 boatBPos = texelFetch(iChannel0, ivec2(b, SHIP_POSITION_LINE), 0).rb;\n    boatBPos.x -= boatOffsetsFromPos(b).x;\n\n    if(boatAPos.y < floor(boatBPos.y) - 1. || \n       boatAPos.y > ceil(boatBPos.y) + 1.)\n       return false;\n\n    float boatASpan =  boatSpanFromId(a);\n    float boatBSpan =  boatSpanFromId(b);\n\n    float aLeft = boatAPos.x - step(1.5, boatASpan);\n    float aRight = boatAPos.x + boatASpan - step(1.5, boatASpan);\n\n    float bLeft = floor(boatBPos.x) - step(1.5, boatBSpan) - 1.;\n    float bRight = ceil(boatBPos.x) + boatBSpan - step(1.5, boatBSpan) + 1.;\n\n    if(aRight < bLeft || aLeft > bRight)\n       return false;\n\n    return true;\n}\n\nbool insideGameField(int id){\n    vec2 boatAPos = texelFetch(iChannel0, ivec2(id, SHIP_POSITION_LINE), 0).rb;\n    return abs(boatAPos.y) <= 5.;\n}\n\nbool allInsideGameField(){\n    for(int i=ZERO; i<SHIPS_CNT; i++){\n        if(!insideGameField(i)){\n            return false;\n        }\n    }\n    return true;\n}\n\nbool canDropHere(int id){\n    Boat boatA = boatFromId(id);\n    vec2 boatAPos = texelFetch(iChannel0, ivec2(id, SHIP_POSITION_LINE), 0).rb;\n    boatAPos.x -= boatOffsetsFromPos(id).x;\n    \n    float boatASpan =  boatSpanFromId(id);\n    float aLeft = boatAPos.x - step(1.5, boatASpan);\n    float aRight = boatAPos.x + boatASpan - step(1.5, boatASpan);\n    \n    if(aLeft < -5. || aRight > 5.)\n        return false;\n\n    for(int i=ZERO; i<SHIPS_CNT; i++){\n        if(id != i){\n            if(insideGameField(i) && intersects(id, i)){\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nvec3 startingRotations(int id){\n    return vec3(0., QPI * .5, 0.);\n}\n\nvec4 calcPosition(int id, vec2 mouseHitPos, vec2 mouseHitCell){\n    float color = .5;\n    Boat boat = boatFromId(id);\n    vec4 gameState = texelFetch(iChannel0, ivec2(0, GAME_STATE_LINE), 0);\n    if(iFrame == 0 || gameState.x == float(GAME_STATE_START)){\n        if(boat.boatType != 3){\n            vec3 res = boat.boundingBox.o;\n            float rad = 8.;\n            float ang = startingRotations(id).y - HPI - PI;\n            res.xz -= vec2(rad * sin(ang), rad * cos(ang));\n            return vec4(res, color);\n        }else{\n            vec3 res = boat.boundingBox.o;\n            res.y -= 4.;\n            return vec4(res, color);\n        }\n    }else{\n        vec4 pos = texelFetch(iChannel0, ivec2(id, SHIP_POSITION_LINE), 0);\n        vec4 interaction = texelFetch(iChannel0, ivec2(id, SHIP_INTERACTION_LINE), 0);\n        if(interaction.PRESSED == 1.){\n            vec2 dstPoint = mouseHitCell + boatOffsetsFromPos(id);\n            pos.rb = mix(pos.rb, dstPoint, iTimeDelta * 20.);\n            pos.y = .5 + .5 * step(3.25, float(id));\n            if(!canDropHere(id))\n                color = 0.;\n        }else if(interaction.RELEASE_TIME != 0.){\n            float diff = distance(time, interaction.RELEASE_TIME);\n            float y = 1. - easeOutElastic(diff * .5) + boat.boundingBox.o.y;\n            vec3 dest  = vec3((interaction.DEST_POINT).x, y, (interaction.DEST_POINT).y);\n            pos.xyz = mix(pos.xyz, dest, diff);\n        }\n        return vec4(pos.rgb, color);\n    }\n}\n\nvec4 calcRotation(int id, vec2 mouseHitCell){\n    vec4 gameState = texelFetch(iChannel0, ivec2(0, GAME_STATE_LINE), 0);\n    if(iFrame == 0 || gameState.x == float(GAME_STATE_START)){\n        return vec4(startingRotations(id), 1.);\n    }else{\n        vec4 pos = texelFetch(iChannel0, ivec2(id, SHIP_POSITION_LINE), 0);\n        vec4 rots = texelFetch(iChannel0, ivec2(id, SHIP_ROTATION_LINE), 0);\n        vec4 interaction = texelFetch(iChannel0, ivec2(id, SHIP_INTERACTION_LINE), 0);\n        float pressed = interaction.PRESSED;\n        if(pressed == 1.){\n            vec2 defaultPos = boatFromId(id).boundingBox.o.xz;\n            float total = max(abs(defaultPos.x), abs(defaultPos.y)) - 4.5;\n            vec2 pos = texelFetch(iChannel0, ivec2(id, SHIP_POSITION_LINE), 0).xz;\n            float cur = max(abs(pos.x), abs(pos.y)) - 4.5;\n            rots.xyz = vec3(0.);\n        }else if(interaction.RELEASE_TIME != 0. && (interaction.DEST_POINT).y > 5.){\n            float diff = distance(time, interaction.RELEASE_TIME);\n            rots = mix(rots, vec4(startingRotations(id), 1.), diff);\n        }else{\n            rots.x = noised(pos.xz + iTime * .5).x * .1;\n            rots.z = noised(pos.xz + (iTime + 134.) * .5).x * .1;\n        }\n        \n        return rots;\n    }\n}\n\nbool buttonClicked(vec4 button){\n    vec2 m = iMouse.xy\/iResolution.y;\n    return mouseState.releasedThisFrame && (distance(m.x, button.CENTER_X) <= button.WIDTH && distance(m.y, button.CENTER_Y) <= button.HEIGHT);\n}\n\nvec4 interaction(int id, vec2 mouseCell, Ray mouseRay){\n    vec4 gameState = texelFetch(iChannel0, ivec2(0, GAME_STATE_LINE), 0);\n    if(iFrame == 0 || gameState.x == float(GAME_STATE_START)){\n        Boat b = boatFromId(id);\n        return vec4(0., max(iTime, (float(b.boatType)) * .1), boatFromId(id).boundingBox.o.xz);\n    }\n    \n    if(buttonClicked(RANDOM_BUTTON)){\n        vec2 dst = vec2(0., 0.);\n        switch(id){\n            default:break;\n        }\n        return vec4(0., time, dst);\n    }\n    \n    vec4 interaction = texelFetch(iChannel0, ivec2(id, SHIP_INTERACTION_LINE), 0);\n    float dragging = interaction.PRESSED;\n    \n    if(!mouseState.mouseDown){\n        if(length(interaction.DEST_POINT) == 0.){\n            vec2 dstPos = mouseCell + boatOffsetsFromPos(id);\n            if(!canDropHere(id)){\n                Boat b = boatFromId(id);\n                dstPos = b.boundingBox.o.xz;\n            }\n            interaction.DEST_POINT = dstPos;\n        }\n        \n        \n        if(interaction.RELEASE_TIME == 0.)\n            return vec4(0., time * dragging, interaction.DEST_POINT);\n        else\n            return vec4(0., interaction.RELEASE_TIME * step(distance(interaction.RELEASE_TIME, time), 1.), interaction.DEST_POINT);\n    }\n    if(dragging == 0. && mouseState.clickedThisFrame){\n        float minDist = MAX_FLOAT;\n        int minID = 100;\n        for(int i=ZERO; i<SHIPS_CNT; i++){\n            Boat boat = boatFromId(i);\n            boat.boundingBox.o.xz = texelFetch(iChannel0, ivec2(i, SHIP_POSITION_LINE), 0).rb;\n            vec3 rots = texelFetch(iChannel0, ivec2(i, SHIP_ROTATION_LINE), 0).xyz;\n\n            mat4 rot = mat4(ry(rots.y));\n            mat4 tra = translate(boat.boundingBox.o);\n            mat4 txi = tra * rot;\n            mat4 txx = inverse(txi);\n\n            vec2 boxHitDst = iBox(mouseRay, boat.boundingBox, txx, txi);\n            if(boxHitDst.x >= 0. && boxHitDst.x < minDist){\n                minDist = boxHitDst.x;\n                minID = i;\n            }\n            if(minID == id)\n                return vec4(1., 0., 0., 0.);\n        }\n    }\n    return vec4(dragging, 0., 0., 0.);\n}\n\nbool validShot(Ray mouseRay, out vec2 hitCell){\n    vec4 gameState = texelFetch(iChannel0, ivec2(0, GAME_STATE_LINE), 0);\n    bool res = gameState.x == float(GAME_STATE_AIMING) && (gameState.w == 1.) && !mouseState.mouseDown;\n    if(!res)\n        return false;\n    float warFogDist = (-mouseRay.o.y)\/mouseRay.dir.y;\n    vec2 warFogHitCell = floor((mouseRay.o + mouseRay.dir * warFogDist).xz - vec2(16., -5.));\n    warFogHitCell.y = 10. - warFogHitCell.y;\n    hitCell = vec2(warFogHitCell.x, iResolution.y - warFogHitCell.y);\n    vec4 hitCellOcupation = texelFetch(iChannel0, ivec2(hitCell), 0);\n    \n    return hitCellOcupation.w < 0.;\n}\n\nfloat distanceToBoat(vec2 toGameFieldCenter, int id){\n    vec2 curBoatPos = texelFetch(iChannel0, ivec2(id, SHIP_POSITION_LINE), 0).rb - boatOffsetsFromPos(id);\n    float curBoatSpan =  boatSpanFromId(id);\n\n    float left = curBoatPos.x - step(1.5, curBoatSpan);\n    float right = curBoatPos.x + curBoatSpan - step(1.5, curBoatSpan);\n    \n    float res = distance(toGameFieldCenter.y, curBoatPos.y);\n    float midX = (left + right) * .5;\n    res = max(res, distance(toGameFieldCenter.x, midX) - max(0., curBoatSpan * .5));\n    return res;\n}\n\nbool boatAllCellsHit(int id){\n    vec2 curBoatPos = texelFetch(iChannel0, ivec2(id, SHIP_POSITION_LINE), 0).rb - boatOffsetsFromPos(id);\n    float curBoatSpan =  boatSpanFromId(id);\n\n    float left = curBoatPos.x - step(1.5, curBoatSpan);\n    float right = curBoatPos.x + curBoatSpan - step(1.5, curBoatSpan);\n    \n    for(float x = left; x <= right; x++){\n        vec2 coords = floor(vec2(x, curBoatPos.y)) + vec2(5.);\n        coords.y = 10. - coords.y;\n        ivec2 hitCell = ivec2(coords.x, iResolution.y - coords.y);\n        vec4 curGameField = texelFetch(iChannel0, hitCell, 0);\n        \n        if(curGameField.w < 0.)\n            return false;\n    }\n    return true;\n}\n\n\n#define INCLUDE_COUNT_FUNC(name, count, ids) float name(int field){                                                                       \\\n    float totalVal = 0.;                                                                                                         \\\n    for(int i=ZERO; i<count; i++){                                                                                                  \\\n        int id = ids[i];                                                                                                         \\\n        vec2 curBoatPos = texelFetch(iChannel0, ivec2(id, SHIP_POSITION_LINE), 0).rb - boatOffsetsFromPos(id);                   \\\n        float curBoatSpan =  boatSpanFromId(id);                                                                                 \\\n        float left = curBoatPos.x - step(1.5, curBoatSpan);                                                                      \\\n        float right = curBoatPos.x + curBoatSpan - step(1.5, curBoatSpan);                                                       \\\n        for(float x = left; x <= right; x++){                                                                                    \\\n            vec2 coords = floor(vec2(x, curBoatPos.y)) + vec2(5.);                                                               \\\n            coords.y = 10. - coords.y;                                                                                           \\\n            ivec2 hitCell = ivec2(coords.x, iResolution.y - coords.y);                                                           \\\n            vec4 curGameField = texelFetch(iChannel0, hitCell, 0);                                                               \\\n            if(curGameField[field] >= 0.)                                                                                             \\\n                totalVal += saturate(iTime - curGameField[field]);                                                                    \\\n        }                                                                                                                        \\\n    }                                                                                                                            \\\n    return totalVal;                                                                                                             \\\n}                                                                                                                                \\\n\nINCLUDE_COUNT_FUNC(countDamage1, 4, ivec4(0, 1, 2, 3))\nINCLUDE_COUNT_FUNC(countDamage2, 3, ivec4(4, 5, 6, -1))\nINCLUDE_COUNT_FUNC(countDamage3, 2, ivec4(7, 8, -1, -1))\nINCLUDE_COUNT_FUNC(countDamage4, 1, ivec4(9, -1, -1, -1))\n\nbool allHit(int id){\n    return countDamage1(id) > 3. &&\n           countDamage2(id) > 5. &&\n           countDamage3(id) > 5. &&\n           countDamage4(id) > 3.;\n}\n\nvec4 gameState(int id, Ray mouseRay){\n    if(iFrame == 0){\n        return vec4(GAME_STATE_POSITIONING, 0., GAME_STATE_POSITIONING, 0.);\n    }\n    vec4 gameState = texelFetch(iChannel0, ivec2(0, GAME_STATE_LINE), 0);\n    int prevGameState = int(gameState.x);\n    switch(prevGameState){\n        case GAME_STATE_START:\n            gameState.xy = vec2(GAME_STATE_POSITIONING, iTime);\n        case GAME_STATE_POSITIONING:\n            if(allInsideGameField()){\n                gameState.x = float(GAME_STATE_READY_TO_PLAY);\n            }\n            break;\n        case GAME_STATE_READY_TO_PLAY:\n            if(!allInsideGameField()){\n                gameState.x = float(GAME_STATE_POSITIONING);\n            }else if(buttonClicked(BATTLE_BUTTON)){\n                gameState.x = float(GAME_STATE_AIMING);\n                gameState.y = iTime;\n            }\n            break;\n        case GAME_STATE_AIMING:\n            vec2 hitCell = vec2(0.);\n            if(validShot(mouseRay, hitCell)){\n                gameState.xy = vec2(float(GAME_STATE_FIRE), iTime);\n            }\n            \n#ifdef RENDER_SWAP_BTN\n            if(buttonClicked(SWAP_BUTTON)){\n                gameState.x = float(GAME_STATE_ENEMY_TURN);\n                gameState.y = iTime;\n            }\n#endif\n            break;\n        case GAME_STATE_FIRE:\n            if(iTime - gameState.y > 1.){\n                vec4 lastMove = texelFetch(iChannel0, ivec2(0, LAST_SHOT_LINE), 0);\n                if(lastMove.x >= 0.)\n                    gameState.xy = vec2(float(GAME_STATE_AIMING), iTime - 1.);\n                else\n                    gameState.xy = vec2(float(GAME_STATE_ENEMY_TURN), iTime);\n            }\n            \n            if(allHit(3)){\n                gameState.x = float(GAME_STATE_END);\n                gameState.y = iTime;\n            }\n\n            break;\n        case GAME_STATE_ENEMY_TURN:\n            if(iTime - gameState.y > 1.){\n                gameState.xy = vec2(float(GAME_STATE_ENEMY_FIRE), iTime);\n            }\n            \n            break;\n        case GAME_STATE_ENEMY_FIRE:\n            bool timeUp = iTime - gameState.y > 1.;\n            vec4 lastMove = texelFetch(iChannel0, ivec2(0, LAST_SHOT_LINE), 0);\n            if(lastMove.x >= 0. && timeUp)\n                gameState.xy = vec2(float(GAME_STATE_ENEMY_FIRE), iTime);\n            else if(timeUp)\n                gameState.xy = vec2(float(GAME_STATE_AIMING), iTime);\n\n#ifdef RENDER_SWAP_BTN\n            if(buttonClicked(SWAP_BUTTON)){\n                gameState.x = float(GAME_STATE_END);\n                gameState.y = iTime;\n            }\n#endif\n            \n            \n            if(allHit(2) && saturate(iTime - gameState.y) > .5){\n                gameState.x = float(GAME_STATE_END);\n                gameState.y = iTime;\n            }\n\n            break;\n        case GAME_STATE_END:\n            if(buttonClicked(PLAY_AGAIN_BUTTON)){\n                gameState.x = float(GAME_STATE_START);\n                gameState.y = iTime;\n            }\n            break;\n        default:\n            break;\n    }\n    if(gameState.x != float(prevGameState))\n        gameState.z = float(prevGameState);\n    gameState.w = mouseState.mouseDown ? 1. : 0.;\n    return gameState;\n}\n\nvec4 gameField(vec2 coords, vec2 toGameFieldCenter, Ray mouseRay){\n    vec4 gameState = texelFetch(iChannel0, ivec2(0, GAME_STATE_LINE), 0);\n    if(iFrame == 0 || gameState.x == float(GAME_STATE_START)){\n            return vec4(-1.);\n    }\n    vec4 curGameField = texelFetch(iChannel0, ivec2(coords), 0);\n    switch(int(gameState.x)){\n        case GAME_STATE_POSITIONING:\n        case GAME_STATE_READY_TO_PLAY:\n            {\n                curGameField.y = -1.;\n                int shipsIntersecCount = 0;\n                float val = 0.;\n                for(int i=ZERO; i<SHIPS_CNT; i++){\n                    vec2 curBoatPos = texelFetch(iChannel0, ivec2(i, SHIP_POSITION_LINE), 0).rb - boatOffsetsFromPos(i);\n                    float curBoatSpan =  boatSpanFromId(i);\n\n                    float left = curBoatPos.x - step(1.5, curBoatSpan);\n                    float right = curBoatPos.x + curBoatSpan - step(1.5, curBoatSpan);\n                    float top = curBoatPos.y;\n                    float bottom = curBoatPos.y;\n\n                    if(toGameFieldCenter.y < ceil(top + 1.) &&\n                       toGameFieldCenter.y > floor(bottom - 1.) &&\n                       toGameFieldCenter.x > floor(left - 1.) && \n                       toGameFieldCenter.x < ceil(right + 1.))\n                           val += float(i) * pow(10., float(shipsIntersecCount++));\n\n                    if(toGameFieldCenter.y == curBoatPos.y &&\n                       toGameFieldCenter.x >= left && toGameFieldCenter.x <= right){\n                           curGameField.y = float(i);\n                    }\n                }\n                if(shipsIntersecCount > 0)\n                    return vec4(val + float(shipsIntersecCount) * .1, curGameField.y, curGameField.z, curGameField.w);\n                else\n                    return vec4(-1., curGameField.y, curGameField.z, curGameField.w);\n            }\n            break;\n        case GAME_STATE_AIMING:\n            vec2 hitPoint = vec2(0.);\n            if(validShot(mouseRay, hitPoint)){\n                if(floor(coords) == hitPoint){\n                    curGameField.w = iTime;\n                }\n            }\n            break;\n        case GAME_STATE_FIRE:\n            {\n                vec4 lastMove = texelFetch(iChannel0, ivec2(0, LAST_SHOT_LINE), 0);\n                int lastHitId = int(lastMove.x);\n                if(lastHitId >= 0 && boatAllCellsHit(lastHitId)){\n                    if(distanceToBoat(toGameFieldCenter, lastHitId) <= 1. && curGameField.w < 0.){\n                        curGameField.w = lastMove.y;\n                    }\n                }\n            }\n            break;\n        case GAME_STATE_ENEMY_FIRE:\n            {\n                if(curGameField.z < 0.){\n                    vec4 lastMove = texelFetch(iChannel0, ivec2(0, LAST_SHOT_LINE), 0);\n                    vec2 cell = floor(lastMove.zw) + 5.;\n                    cell.y = 10. - cell.y;\n                    \n                    if(ivec2(coords) == ivec2(vec2(cell.x, iResolution.y - cell.y))){\n                        curGameField.z = lastMove.y;\n                    }\n                }\n            }\n            break;\n        default:\n            break;\n    }\n    return curGameField;\n}\n\nfloat shipAtPos(vec2 toGameFieldCenter){\n    ivec2 cellId = ivec2(toGameFieldCenter + 5.);\n    cellId.y = 10 - cellId.y;\n    return texelFetch(iChannel0, ivec2(cellId.x, int(iResolution.y) - cellId.y), 0).y;\n}\n\nbool alreadyHit(vec2 toGameFieldCenter){\n    ivec2 cellId = ivec2(toGameFieldCenter + 5.);\n    cellId.y = 10 - cellId.y;\n    return texelFetch(iChannel0, ivec2(cellId.x, int(iResolution.y) - cellId.y), 0).z >= 0.;\n}\n\nvec4 lastMove(Ray mouseRay){\n    vec4 savedGameState = texelFetch(iChannel0, ivec2(0, GAME_STATE_LINE), 0);\n    if(iFrame == 0 || savedGameState.x == float(GAME_STATE_START))\n        return vec4(-1.);\n    vec4 lastMove = texelFetch(iChannel0, ivec2(0, LAST_SHOT_LINE), 0);\n    int curGameState = int(savedGameState.x);\n    int prevGameState = int(savedGameState.z);\n    if(curGameState == GAME_STATE_AIMING){\n        vec2 mouseHitCell;\n        if(validShot(mouseRay, mouseHitCell)){\n            float oceanHitDist = (-mouseRay.o.y)\/mouseRay.dir.y;\n            vec2 oceanHitCell = floor((mouseRay.o + mouseRay.dir * oceanHitDist).xz) + .5;\n            \n            vec4 hitCellOcupation = texelFetch(iChannel0, ivec2(mouseHitCell), 0);\n            return vec4(hitCellOcupation.y, iTime, oceanHitCell);\n        }\n    } else if (curGameState == GAME_STATE_ENEMY_FIRE){\n        vec2 hitCell = floor(hash(vec2(2.17, savedGameState.y)) * 5.);\n        int counter = 0;\n        while(alreadyHit(hitCell) && counter++<25){\n            hitCell = floor(hash(vec2(.17, savedGameState.y)) * 5.);\n        }\n        \n        float shipId = shipAtPos(hitCell);\n        return vec4(shipId, savedGameState.y, hitCell);\n    }\n    return lastMove;\n}\n\nvec4 buttons(int id){\n    vec4 curState = texelFetch(iChannel0, ivec2(0, GAME_STATE_LINE), 0);\n    vec4 res = vec4(0.);\n    switch(id){\n        case BUTTONS_BATTLE_ID:\n            if(iFrame == 0 || curState.x == float(GAME_STATE_START)){\n                return vec4(-1.);\n            }\n            vec4 curButton = texelFetch(iChannel0, ivec2(BUTTONS_BATTLE_ID, BUTTONS_LINE), 0);\n            float visibility = curButton.y == -BATTLE_BUTTON.CENTER_X ? 0.: 1.;\n            float dstPos = -BATTLE_BUTTON.CENTER_X;\n            if(int(curState.x) == GAME_STATE_READY_TO_PLAY){\n                dstPos = BATTLE_BUTTON.CENTER_X;\n            }\n            float curPos = mix(curButton.y, dstPos, iTimeDelta * 20.);\n            return vec4(visibility, curPos, dstPos, 0.);\n            break;\n        default:\n        break;\n    }\n    return vec4(0.);\n}\n\nvec4 countDamageLine(int field){\n    if(iFrame == 0)\n        return vec4(0.);\n    return vec4(countDamage1(field), countDamage2(field), countDamage3(field), countDamage4(field));\n}\n\n#define GAME_FIELD_CELLS_CNT_HLF 5.\n#define GAME_FIELD_CENTER vec2(GAME_FIELD_CELLS_CNT_HLF, iResolution.y - GAME_FIELD_CELLS_CNT_HLF)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec4 lastGameState = texelFetch(iChannel0, ivec2(0, GAME_STATE_LINE), 0);\n    time = iTime;\n    mouseState.mouseDown = iMouse.z > 0.;\n    mouseState.clickedThisFrame = mouseState.mouseDown && iMouse.w >= 0.;\n    mouseState.releasedThisFrame = (lastGameState.w == 1.) && !mouseState.mouseDown;\n\n    vec4 savedGameState = texelFetch(iChannel0, ivec2(0, GAME_STATE_LINE), 0);\n    Ray cameraRay = createRay(fragCoord, iResolution.xy, iTime, savedGameState);\n    Ray mouseRay = createRay(iMouse.xy, iResolution.xy, iTime, savedGameState);\n    float mouseHitOcean = (-mouseRay.o.y)\/mouseRay.dir.y;\n    vec3 mouseHitPoint = (mouseRay.o + mouseRay.dir * mouseHitOcean);\n    vec2 mouseHitCell = clamp(floor(mouseHitPoint.xz) + .5, -4.5, 4.5);\n    \n    ivec2 id = ivec2(fragCoord);\n    vec4 res = texelFetch(iChannel0, id, 0);\n    if(int(lastGameState.x) == GAME_STATE_POSITIONING || int(lastGameState.x) == GAME_STATE_READY_TO_PLAY || int(lastGameState.x) == GAME_STATE_START){\n        if(id.x < SHIPS_CNT && id.y < SHIP_TOTAL_LINES){\n            switch(id.y){\n                case SHIP_POSITION_LINE:\n                    res = calcPosition(id.x, mouseHitPoint.xz, mouseHitCell);\n                    break;\n                case SHIP_ROTATION_LINE:\n                    res = calcRotation(id.x, mouseHitCell);\n                    break;\n                case SHIP_INTERACTION_LINE:\n                    res = interaction(id.x, mouseHitCell, mouseRay);\n                    break;\n                default:\n                    break;\n            }\n        }\n    }\n    \n    vec2 toGameFieldCenter = fragCoord - GAME_FIELD_CENTER;\n    if(max(abs(toGameFieldCenter.x), abs(toGameFieldCenter.y)) <= GAME_FIELD_CELLS_CNT_HLF){\n        res = gameField(fragCoord, toGameFieldCenter, mouseRay);\n    }\n    \n    if(id.x == 0 && id.y == GAME_STATE_LINE)\n        res = gameState(id.x, mouseRay);\n        \n    if(id.x == 0 && id.y == LAST_SHOT_LINE)\n        res = lastMove(mouseRay);\n        \n    if(id.x < 2 && id.y == ENEMY_HIT_COUNT_LINE)\n        res = countDamageLine(id.x + 2);\n        \n    if(id.x <= BUTTONS_COUNT && id.y == BUTTONS_LINE)\n        res = buttons(id.x);\n    \n    fragColor = res;\n}",
            "name": "Buffer A",
            "description": "",
            "type": "buffer"
        }
    ]
}