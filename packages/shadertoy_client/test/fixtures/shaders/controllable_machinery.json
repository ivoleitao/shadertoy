{
    "ver": "0.1",
    "info": {
        "id": "fsXyDj",
        "date": "1642677044",
        "viewed": 3334,
        "name": "Controllable Machinery",
        "username": "dr2",
        "description": "Still doesn't do much, but now with speed controller (slide the knob) and more gears; mouseable",
        "likes": 76,
        "published": 3,
        "flags": 32,
        "usePreview": 1,
        "tags": [
            "interactive",
            "wheel",
            "gear",
            "widget",
            "machine"
        ],
        "hasliked": 0
    },
    "renderpass": [
        {
            "inputs": [
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dfGRr",
                    "channel": 0
                }
            ],
            "code": "\/\/ \"Controllable Machinery\" by dr2 - 2022\n\/\/ License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n\/\/ (Extension of \"Machinery\"; control widget in world space - as in \"Maze Ball Solved 2\")\n\n#define AA    0  \/\/ (= 0\/1) optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat PrCaps2Df (vec2 p, float r, float h);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nmat3 StdVuMat (float el, float az);\nvec3 HsvToRgb (vec3 c);\nvec4 Loadv4 (int idVar);\n\nvec4 wgObj;\nvec3 ltDir, vnBlk;\nvec2 qBlk;\nfloat dstFar, tCur, tMov, angRot, bEdge, tCyc, cnPos, hitBlk;\nint idObj;\nconst int idGr = 1, idPln = 2, idConv = 3, idSup = 4, idAx = 5, idBas = 6,\n   idWhl = 7, idSpl = 8, idCon = 9, idBlk = 10;\nconst float pi = 3.1415927;\nconst float nBlk = 13.;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat GearWlDf (vec3 p, float rad, float wlThk, float tWid, float nt, float aRot, \n   bool bev, float dMin)\n{\n  vec3 q;\n  float d, s;\n  q = p;\n  d = max (length (q.xy) - rad, abs (q.z) - wlThk);\n  if (d < dMin) {\n    q.xy = Rot2D (q.xy, aRot);\n    q.xy = Rot2D (q.xy, floor (nt * atan (q.y, - q.x) \/ (2. * pi) + 0.5) * 2. * pi \/ nt);\n    if (bev) q.xy *= 1.2 - 0.2 * q.z \/ wlThk;\n    s = q.x - 2. * clamp (1.5 * tWid + 0.5 * q.x * step (0., q.x) - abs (q.y), 0., tWid);\n    d = max (d, - rad - 0.95 * s);\n  }\n  return min (dMin, d);\n}\n\nvec4 BPos (float t)\n{\n  vec3 p;\n  float a;\n  t = mod (t, tCyc);\n  if (t < 5.) {\n    a = 0.;\n    p = vec3 (-1.018 + 2.118 * t \/ 5., bEdge, 0.);\n  } else if (t < 10.) {\n    a = 0.5 * pi * (t - 5.) \/ 5.;\n    p = vec3 (1.1, bEdge + 1. * sin (a), 1. - 1. * cos (a));\n  } else if ( t < 15.) {\n    a = 0.5 * pi;\n    p = vec3 (1.1 - 2.118 * (t - 10.) \/ 5., 1. + bEdge, 1.);\n  } else if (t < 17.5) {\n    a = 0.5 * pi;\n    p = vec3 (-1.018, 1. + bEdge, 1. - 1. * (t - 15.) \/ 2.5);\n  } else {\n    t -= 17.5;\n    a = -0.5 * pi * t;\n    p = vec3 (-1.018, 1. + bEdge - t * t, 0.);\n  }\n  return vec4 (p, a);\n}\n\nfloat GearDf (vec3 p)\n{\n  vec3 q;\n  float dMin, wlThk, tWid, nt, rad, gRat;\n  dMin = dstFar \/ 0.3;\n  gRat = 2.;\n  rad = 0.3;\n  wlThk = rad \/ 7.;\n  tWid = rad \/ 10.;\n  nt = 20.;\n  q = p - vec3 (-1.05, -0.21, 1.3);\n  dMin = GearWlDf (- q, rad, wlThk, tWid, nt, angRot * gRat, true, dMin);\n  dMin = GearWlDf ((q - vec3 (0.85 * rad, 0., 0.85 * rad)).yzx,\n     rad, wlThk, tWid, nt, angRot * gRat + pi \/ nt, true, dMin);\n  rad = 0.43;\n  wlThk = rad \/ 15.;\n  tWid = rad \/ 16.;\n  nt = 32.;\n  q = p -vec3 (0.1, 0., 1.);\n  dMin = GearWlDf ((q - vec3 (0., bEdge, 0.)).yzx, rad, wlThk, tWid, nt,\n     - angRot - 0.3 * pi \/ nt, false, dMin);\n  dMin = GearWlDf (- (q - vec3 (0., -0.21, 0.555)).zyx, rad \/ gRat, wlThk, tWid,\n     nt \/ gRat, - angRot * gRat, false, dMin);\n  rad = 0.32;\n  wlThk = rad \/ 15.;\n  tWid = rad \/ 12.;\n  nt = 24.;\n  q = p - vec3 (-1.05, -0.21, 0.6);\n  dMin = GearWlDf ((q - vec3 (0., 0., 0.1)), rad, wlThk, tWid, nt,\n     angRot * gRat + pi \/ nt, false, dMin);\n  dMin = GearWlDf ((q - vec3 (0., -0.47, 0.1)), rad \/ gRat, wlThk, tWid, nt \/ gRat,\n     - angRot * gRat * gRat, false, dMin);\n  dMin = GearWlDf ((q - vec3 (0., -0.47, -0.1)), rad, wlThk, tWid, nt,\n     - angRot * gRat * gRat - pi \/ nt, false, dMin);\n  dMin = GearWlDf ((q - vec3 (0., 0., -0.1)), rad \/ gRat, wlThk, tWid, nt \/ gRat,\n     angRot * gRat * gRat * gRat, false, dMin);\n  return dMin * 0.3;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec4 a4;\n  vec3 q, bPos;\n  float dMin, d, r, a;\n  dMin = dstFar;\n  q = p - vec3 (1.13 + bEdge, bEdge, 1.);\n  r = length (q.yz);\n  q.yz = Rot2D (q.yz, - angRot);\n  a = (r > 0.) ? atan (q.z, - q.y) \/ (2. * pi) : 0.;\n  q.yz = Rot2D (q.yz, 2. * pi * (floor (8. * a + 0.5)) \/ 8.);\n  q.z = abs (q.z);\n  d = SmoothMax (min (min (abs (r - 1.01) - 0.1, r - 0.3),\n     max (r - 1., dot (q.yz, vec2 (sin (0.8 * 2. * pi \/ 32.),\n     cos (0.8 * 2. * pi \/ 32.))))), abs (q.x) - 0.02, 0.01);\n  DMIN (idWhl);\n  d = min (PrBoxDf (p - vec3 (0., 0.98, 1.), vec3 (1.12, 0.02, 0.1)),\n     PrBoxDf (p - vec3 (-1.018, 0.98, 0.5), vec3 (0.1, 0.02, 0.5 - bEdge)));\n  DMIN (idPln);\n  d = SmoothMax (abs (PrCaps2Df ((p - vec3 (-0.05, -0.21, 0.)).yx, 0.2, 1.)) - 0.01,\n    abs (p.z) - 0.1, 0.02);\n  DMIN (idConv);\n  q = p - vec3 (-0.05, -0.21, 0.);\n  q.x = abs (q.x) - 1.;\n  d = PrRoundCylDf (q, 0.18, 0.01, 0.11);\n  DMIN (idSpl);\n  q = p - vec3 (0.65, -0.14, 1.);\n  q.x = abs (q.x) - 0.3;\n  d = PrRoundBoxDf (q, vec3 (0.01, 1.08, 0.06), 0.02);\n  q = p - vec3 (-0.05, -0.68, 0.);\n  q.xz = abs (q.xz) - vec2 (1., 0.2);\n  d = min (d, PrRoundBoxDf (q, vec3 (0.04, 0.55, 0.01), 0.02));\n  q = p - vec3 (-1.05, -0.14, 1.);\n  d = min (d, PrRoundBoxDf (q, vec3 (0.04, 1.08, 0.01), 0.02));\n  q = p - vec3 (-1.05, -0.68, 0.6);\n  q.z = abs (q.z) - 0.2;\n  d = min (d, PrRoundBoxDf (q, vec3 (0.04, 0.55, 0.01), 0.02));\n  q = p - vec3 (-0.33, -0.68, 1.555);\n  q.x = abs (q.x) - 0.3;\n  d = min (d, PrRoundBoxDf (q, vec3 (0.01, 0.55, 0.04), 0.02));\n  DMIN (idSup);\n  q = p - vec3 (0.65, bEdge, 1.);\n  d = PrCylDf (q.yzx, 0.04, 0.62);\n  q = p - vec3 (-0.36, -0.21, 1.555);\n  d = min (d, PrCylDf (q.yzx, 0.03, 0.51));\n  q = p - vec3 (-0.05, -0.21, 0.);\n  q.x -= 1.;\n  d = min (d, PrCylDf (q, 0.03, 0.27));\n  q.xz -= vec2 (-2., 0.14);\n  d = min (d, PrCylDf (q, 0.03, 0.4));\n  q.z -= 0.87;\n  d = min (d, PrCylDf (q, 0.03, 0.36));\n  q = p - vec3 (-1.05, -0.68, 0.6);\n  d = min (d, PrCylDf (q, 0.03, 0.25));\n  DMIN (idAx);\n  q = p - vec3 (0., -1.2, 0.9);\n  d = PrRoundBoxDf (q, vec3 (1.7, 0.03, 1.5), 0.02);\n  DMIN (idBas);\n  q = p - wgObj.xyz;\n  d = PrRoundCylDf (q.xzy, wgObj.w, 0.02, 0.02);\n  DMIN (idCon);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nfloat GearRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 250; j ++) {\n    d = GearDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 GearNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0005, -0.0005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = GearDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0005, -0.0005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat BlkHit (vec3 ro, vec3 rd)\n{\n  vec4 a4;\n  vec3 rm, rdm, u, v, tm, tp;\n  float dMin, dn, df;\n  dMin = dstFar;\n  for (float k = float (VAR_ZERO); k < nBlk; k ++) {\n    a4 = BPos (tMov + tCyc * k \/ nBlk);\n    rm = ro - a4.xyz;\n    rdm = rd;\n    rm.zy = Rot2D (rm.zy, a4.w);\n    rdm.zy = Rot2D (rdm.zy, a4.w);\n    v = rm \/ rdm;\n    tp = bEdge \/ abs (rdm) - v;\n    tm = - tp - 2. * v;\n    dn = Maxv3 (tm);\n    df = Minv3 (tp);\n    if (df > 0. && dn < min (df, dMin)) {\n      dMin = dn;\n      hitBlk = k;\n      vnBlk = - sign (rdm) * step (tm.zxy, tm) * step (tm.yzx, tm);\n      u = (v + dn) * rdm;\n      qBlk = vec2 (dot (u.zxy, vnBlk), dot (u.yzx, vnBlk));\n      vnBlk.zy = Rot2D (vnBlk.zy, - a4.w);\n    }\n  }\n  return dMin;\n}\n\nfloat BlkHitSh (vec3 ro, vec3 rd, float rng)\n{\n  vec4 a4;\n  vec3 rm, rdm, v, tm, tp;\n  float dMin, dn, df;\n  dMin = dstFar;\n  for (float k = float (VAR_ZERO); k < nBlk; k ++) {\n    a4 = BPos (tMov + tCyc * k \/ nBlk);\n    rm = ro - a4.xyz;\n    rdm = rd;\n    rm.zy = Rot2D (rm.zy, a4.w);\n    rdm.zy = Rot2D (rdm.zy, a4.w);\n    v = rm \/ rdm;\n    tp = bEdge \/ abs (rdm) - v;\n    tm = - tp - 2. * v;\n    dn = Maxv3 (tm);\n    df = Minv3 (tp);\n    if (df > 0. && dn < min (df, dMin)) dMin = dn;\n  }\n  return smoothstep (0., rng, dMin);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return sh;\n}\n\nfloat GearSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = GearDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 vn, col, q;\n  float dstObj, dstGear, dstBlk, sh, s, r, a, nDotL;\n  int idObjT;\n  bool isMet;\n  tCyc = 18.5;\n  bEdge = 0.08;\n  isMet = false;\n  angRot = 0.1 * pi * tMov;\n  dstObj = ObjRay (ro, rd);\n  idObjT = idObj;\n  dstGear = GearRay (ro, rd);\n  if (dstGear < min (dstObj, dstFar)) {\n    dstObj = dstGear;\n    idObj = idGr;\n  } else idObj = idObjT;\n  dstBlk = BlkHit (ro, rd);\n  if (min (dstBlk, dstObj) < dstFar) {\n    if (dstBlk < dstObj) {\n      dstObj = dstBlk;\n      ro += dstObj * rd;\n      idObj = idBlk;\n      vn = vnBlk;\n      col4 = vec4 (HsvToRgb (vec3 (hitBlk \/ nBlk, 1., 1.)), 0.2) *\n         (1. - 0.4 * step (0.8 * bEdge, Maxv2 (abs (qBlk))));\n    } else {\n      ro += dstObj * rd;\n      vn = (idObj == idGr) ? GearNf (ro) : ObjNf (ro);\n      if (idObj == idWhl) {\n        col4 = vec4 (0.9, 0.7, 0.3, 0.2);\n        q = ro - vec3 (1.1 + bEdge + 0.03, bEdge, 1.);\n        r = length (q.yz);\n        q.yz = Rot2D (q.yz, - angRot);\n        a = fract (64. * atan (q.z, - q.y) \/ (2. * pi) + 0.5);\n        if (r > 0.99) vn.yz = Rot2D (vn.yz, - sin (a - 0.5));\n        if (r > 0.92) col4 *= 0.7 + 0.3 * SmoothBump (0.05, 0.95, 0.01, a);\n        isMet = true;\n      } else if (idObj == idGr) {\n        col4 = vec4 (0.9, 0.8, 0.4, 0.2);\n        isMet = true;\n      } else if (idObj == idSpl) {\n        col4 = vec4 (0.8, 0.8, 0.85, 0.2) * (1. - 0.4 * step (abs (ro.z), 0.1));\n        isMet = true;\n      } else if (idObj == idAx) {\n        col4 = vec4 (0.8, 0.8, 0.85, 0.2);\n        isMet = true;\n      } else if (idObj == idPln) {\n        col4 = (abs (vn.y) > 0.99) ? vec4 (0.5, 0.6, 0.2, 0.05) : vec4 (0.7, 0.5, 0.4, 0.1);\n      } else if (idObj == idConv) {\n        q = ro - vec3 (-0.05, -0.21, 0.);\n        col4 = vec4 (0.8, 0.8, 0.4, 0.);\n        if (sign (vn.y) != sign (q.y)) {\n          if (abs (q.x) < 1. && abs (vn.y) > 0.5) col4 *= 1. - 0.1 * SmoothBump (0.45, 0.55, 0.03,\n           fract (10. * (q.x - sign (q.y) * mod (tMov, 20.) * 2.1 \/ 5.)));\n        } else col4 *= 0.8 + 0.2 * smoothstep (0., 0.01, abs (abs (q.z) - 0.07));\n      } else if (idObj == idSup) {\n        col4 = vec4 (0.7, 0.5, 0.4, 0.1);\n        isMet = true;\n      } else if (idObj == idBas) {\n        q = ro;\n        q.z -= 0.9;\n        if (Maxv2 (abs (q.xz) - vec2 (1.65, 1.45)) > 0.) {\n          col4 = vec4 (0.9, 0.9, 0.9, 0.2);\n          isMet = true;\n        } else {\n          col4 = vec4 (0.3, 0.5, 0.4, 0.);\n        }\n        col4 *= (0.5 + 0.5 * step (0., Maxv2 (abs (vec2 (q.x, q.z + 1.3)) - vec2 (0.4, 0.02)))) *\n           (0.7 + 0.3 * step (0., abs (PrCaps2Df (vec2 (q.z + 1.3, q.x), 0.08, 0.5)) - 0.01));\n      } else if (idObj == idCon) {\n        col4 = vec4 (0., 1., 1., 0.2);\n        if (length (ro.xz - wgObj.xz) < 0.6 * wgObj.w)\n           col4 = mix (0.8 * col4, vec4 (1., 0., 1., 0.2), step (0., sin (2. * pi * tCur)));\n      }\n    }\n    sh = min (ObjSShadow (ro, ltDir), GearSShadow (ro, ltDir));\n    sh = 0.6 + 0.4 * min (sh, BlkHitSh (ro + 0.01 * ltDir, ltDir, 6.));\n    nDotL = max (dot (vn, ltDir), 0.);\n    if (isMet) nDotL *= nDotL;\n    col = col4.rgb * (0.1 + 0.1 * max (- dot (vn, ltDir), 0.) + 0.9 * sh * nDotL) +\n       col4.a * step (0.95, sh) * sh * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.);\n    if (isMet) {\n      rd = reflect (rd, vn);\n      col = mix (col, vec3 (1.), 0.01 * step (0.1, Minv2 (fract (8. * vec2 (atan (rd.z, rd.x),\n         2. * asin (rd.y)) + 0.5) - 0.5)));\n    }\n  } else col = vec3 (0., 0., 0.1) * (1. + 0.9 * rd.y);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 stDat;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy \/ canvas - 1.;\n  uv.x *= canvas.x \/ canvas.y;\n  tCur = iTime;\n  dstFar = 30.;\n  stDat = Loadv4 (0);\n  tMov = stDat.x;\n  cnPos = stDat.y;\n  wgObj = vec4 (cnPos - 0.5, -1.12, -0.4, 0.08);\n  stDat = Loadv4 (1);\n  az = stDat.x;\n  el = stDat.y;\n  vuMat = StdVuMat (el, az);\n  zmFac = 4.;\n  ro = vuMat * vec3 (0., 0., -8.);\n  ro.z += 0.9;\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  ltDir = vuMat * normalize (vec3 (-0.5, 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 \/ canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. \/ naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat PrCaps2Df (vec2 p, float r, float h)\n{\n  return length (p - vec2 (0., clamp (p.y, - h, h))) - r;\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) \/ r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2.\/3., 1.\/3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 128.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi \/ txRow)) + 0.5) \/ txSize);\n}\n",
            "name": "Image",
            "description": "",
            "type": "image"
        },
        {
            "inputs": [
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dXGR8",
                    "channel": 0
                }
            ],
            "code": "\/\/ \"Controllable Machinery\" by dr2 - 2022\n\/\/ License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat Maxv2 (vec2 p);\nmat3 StdVuMat (float el, float az);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst float pi = 3.1415927;\nconst float txRow = 128.;\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, stDat, wgObj;\n  vec3 vCon, ro;\n  vec2 canvas, iFrag, ud;\n  float tCur, tMov, az, el, asp, zmFac, spd, cnPos, mPtrPz, s;\n  int pxId, wgSel, wgReg;\n  bool init;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy \/ canvas - 0.5;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (pxId >= 2) discard;\n  wgSel = -1;\n  wgReg = -2;\n  asp = canvas.x \/ canvas.y;\n  init = (iFrame <= 2);\n  if (init) {\n    tMov = 0.;\n    spd = 0.5;\n    cnPos = 0.5;\n    az = 0.;\n    el = -0.12 * pi;\n    mPtrPz = mPtr.z;\n  } else {\n    stDat = Loadv4 (0);\n    tMov = stDat.x;\n    cnPos = stDat.y;\n    spd = stDat.z;\n    tMov += 0.02 * spd;\n    stDat = Loadv4 (1);\n    az = stDat.x;\n    el = stDat.y;\n    mPtrPz = stDat.z;\n    wgSel = int (stDat.w);\n  }\n  if (! init) {\n    if (mPtr.z > 0.) {\n      vuMat = StdVuMat (el, az);\n      ro = vuMat * vec3 (0., 0., -8.);\n      ro.z += 0.9;\n      zmFac = 4.;\n      vCon = vuMat * normalize (vec3 (2. * mPtr.xy * vec2 (asp, 1.), zmFac));\n      wgObj = vec4 (cnPos - 0.5, -1.12, -0.4, 0.08);\n      ud = (ro.xz + (- (ro.y - wgObj.y) \/ vCon.y) * vCon.xz);\n      s = Maxv2 (abs (ud - wgObj.xz)) - wgObj.w - 0.1;\n      if (s < 0. || wgSel == 0) {\n        if (s < 0. && wgSel == 0) cnPos = clamp (ud.x + 0.5, 0., 1.);\n        wgReg = 0;\n      } else if (wgReg < 0) {\n        az = 2. * pi * mPtr.x;\n        el = pi * mPtr.y;\n        el = clamp (el, -0.4 * pi, 0.1 * pi);\n      }\n      if (mPtrPz <= 0.) wgSel = wgReg;\n    } else {\n      wgSel = -1;\n      wgReg = -2;\n      az = mix (az, 0., 0.003 + 0.05 * step (abs (az), 0.15));\n      el = mix (el, -0.12 * pi, 0.003 + 0.05 * step (abs (el + 0.12 * pi), 0.15));\n    }\n  }\n  spd = 2. * cnPos;\n  if      (pxId == 0) stDat = vec4 (tMov, cnPos, spd, 0.);\n  else if (pxId == 1) stDat = vec4 (az, el, mPtr.z, float (wgSel));\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi \/ txRow)) + 0.5) \/ txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  float fi;\n  fi = float (idVar);\n  if (Maxv2 (abs (fCoord - vec2 (mod (fi, txRow), floor (fi \/ txRow)) - 0.5)) < 0.5) fCol = val;\n}\n",
            "name": "Buffer A",
            "description": "",
            "type": "buffer"
        }
    ]
}