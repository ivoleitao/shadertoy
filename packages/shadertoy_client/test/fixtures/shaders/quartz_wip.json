{
    "ver": "0.1",
    "info": {
        "id": "fs2GWh",
        "date": "1617324275",
        "viewed": 3395,
        "name": "\u266b Quartz - wip ",
        "username": "patu",
        "description": "wip for https:\/\/www.pouet.net\/prod.php?which=82780\nmusic is https:\/\/soundcloud.com\/neurofunksocietyofpoland\/dronehead-02-hexyll-original-mix",
        "likes": 39,
        "published": 3,
        "flags": 96,
        "usePreview": 1,
        "tags": [
            "demoscene"
        ],
        "hasliked": 0
    },
    "renderpass": [
        {
            "inputs": [
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "XsXGR8",
                    "filepath": "\/media\/previz\/buffer01.png",
                    "previewfilepath": "\/media\/previz\/buffer01.png",
                    "type": "buffer",
                    "channel": 1,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dfGRr",
                    "channel": 0
                }
            ],
            "code": "\/\/ Fork of \"\u266b Quartz - wip - private\" by patu. https:\/\/shadertoy.com\/view\/3tjXRW\n\/\/ 2021-04-02 00:42:21\n\nvec2 hash( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*18.5453); }\n\n\/\/ return distance, and cell id\nvec2 voronoi( in vec2 x )\n{\n    vec2 n = floor( x );\n    vec2 f = fract( x );\n\n\tvec3 m = vec3( 8.0 );\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2  g = vec2( float(i), float(j) );\n        vec2  o = hash( n + g );\n      \/\/vec2  r = g - f + o;\n\t    vec2  r = g - f + (0.5+0.5*sin(iTime+6.2831*o));\n\t\tfloat d = dot( r, r );\n        if( d<m.x )\n            m = vec3( d, o );\n    }\n\n    return vec2( sqrt(m.x), m.y+m.z );\n}\n\n\nvec3 res;\n\nmat2 rot = mat2(cos(2.399),sin(2.399),-sin(2.399),cos(2.399));\n\nvec3 dof(sampler2D tex,vec2 uv,float rad)\n{\n\tvec3 acc=vec3(0);\n    vec2 pixel=vec2(.002*res.y\/res.x,.002),angle=vec2(0,rad);;\n    rad=1.;\n\tfor (int j=0;j<50;j++)\n    {  \n        rad += 1.\/rad;\n\t    angle*=rot;\n        vec4 col=texture(tex,uv+pixel*(rad-1.)*angle);\n\t\tacc+=col.xyz;\n\t}\n\treturn acc\/50.;\n}\n\n\/\/-------------------------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    res = iResolution;\n\tvec2 uv = gl_FragCoord.xy \/ res.xy;\n    vec2 c = voronoi( (14.0+6.0*abs(sin(1.2*iTime))) * uv \/ res.x * res.y \/ 4.);\n    \n    float cell = max(0., floor(abs(sin(iTime)) - fract(c.y * 0.1) + .1));\n    \/\/uv += texelFetch(iChannel1, ivec2(gl_FragCoord.xy), 0).b * .04;\n    \n    \/\/float cell = max(0., floor(abs(sin(iTime + fract(c.y * 0.1) + .9))));\n    float sh = (cell \/ 50.) * texelFetch(iChannel1, ivec2(9, 0), 0).r;\/\/cell > .2 ? c.y * 0.5 : 0.;\n    uv.x += sh * 3.;\/\/* hash(uv).x * 2.2;\n    \n    float a = abs(.7 - pow(texture(iChannel0,uv).w * 1.2, 1.4));\n\tfragColor=vec4(dof(iChannel0,uv,a),1.);\n    fragColor = mix(fragColor, pow(\n        max(\n            vec4(0.), \n            1.-normalize(fragColor)), vec4(4.)), sh * 40.);\n    \/\/fragColor.rbg -= cell * .1;\n    \/\/fragColor.rgb -= vec3(.2, .1, 0.) * cell * .5 + (cell > 0.5 ? pow(abs(cell * -c.x * 2.), 10.) : 0.);\n    \/\/fragColor = vec4(a);\n    \n   \/\/ fragColor = texelFetch(iChannel1, ivec2(0, 0), 0).aaaa;\n}",
            "name": "Image",
            "description": "",
            "type": "image"
        },
        {
            "inputs": [
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 1,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "XsXGR8",
                    "filepath": "\/media\/previz\/buffer01.png",
                    "previewfilepath": "\/media\/previz\/buffer01.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dXGR8",
                    "channel": 0
                }
            ],
            "code": "#define getNormal getNormalHex\n#define V vec3\n#define W vec2\n#define F float\n#define FAR 330.\n#define INF 1e32\n\/\/#define IT iTime\n#define mt iChannelTime[1]\n\n#define PI 3.14159265\n#define PHI (1.618033988749895)\n\nstruct Timeline {\n    float songTime;\n    float rPatternTime;\n    float nPatternTime;\n    float smoothNPatternTime;\n    \n    float patternNum;\n} timeline;\n\nstruct SdfMixer {\n \tfloat ifs1;\n    float grid;        \n    float star;\n} sdfMixer;\n\nF \n    Z = 0., \n    J = 1., \n\tvol = 0.,\n\tnoise = 0.;\n \n\n#define H(P) fract(sin(dot(P,vec2(127.1,311.7)))*43758.545)\nF n(in vec3 p) {\n    V \ti = floor(p), \n        f = fract(p), \t\n\t    u = f*f*(3.-f-f);\n    \n    W   ii = i.xy + i.z * 5. + 5.;\n    \n    #define II(a,b) H(i.xy + i.z * W(5.0) + W(a,b))\n    \n    F \tv1 = mix(mix(II(Z,Z),II(J,Z),u.x), mix(\n            II(Z,J),II(J,J),u.x), u.y);\n    \n    #define I2(a,b) H(ii + W(a,b))\n    return max(mix(v1,mix(mix(I2(Z,Z),I2(J,Z),u.x), \n        \t\tmix(I2(Z,J),I2(J,J),u.x), \n        \t\tu.y),u.z),Z);\n}\n#define A w *= .5; s *= 2.; r += w * n(s * x);\nF B(vec3 x) {\n    F \tr = Z, w = J, s = J;\n    A A A A;\n    return r;\n}\n\n#define fromRGB(a, b, c) vec3(F(a), F(b), F(c)) \/ 255.;\n    \nvec3 \n    light = vec3(0. ,1., 1.),\n\tlightDir,\n\tlightColour = normalize(vec3(0.5, .6, .5) ); \n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\n\/\/ Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)\/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { \/\/yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\n\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )\/k ;\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat opU2( float d1, float d2 ) {\n    if (d1 < d2) return d1;\n    return d2;\n}\n\nvec3 opU2( vec3 d1, vec3 d2 ) {\n    if (d1.x < d2.x) return d1;\n    return d2;\n}\n\nstruct geometry {\n    float dist;\n    float materialIndex;\n    float specular;\n    float diffuse;\n    vec3 color;  \n    vec3 space;\n    float mirror;\n    vec3 index;\n};\n\ngeometry geoU(geometry g1, geometry g2) {\n    if (g1.dist < g2.dist) return g1;\n    return g2;\n}\n\nvec3 opS2( vec3 d1, vec3 d2 ){\t\n    if (-d2.x > d1.x) return -d2;\n    return d1;\n}\n\nvec3 opI2( vec3 d1, vec3 d2 ) {\n \tif (d1.x > d2.x) return d1;\n    return d2;\n}\n\nfloat vmin(vec2 v) {\n\treturn min(v.x, v.y);\n}\n\n\n\/\/ Maximum\/minumum elements of a vector\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\n\/\/ Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x<0.)?-1.:1.;\n}\n\nvec2 sgn(vec2 v) {\n\treturn vec2((v.x<0.)?-1.:1., (v.y<0.)?-1.:1.);\n}\n\n\n\/\/ Repeat space along one axis. Use like this to repeat along the x axis:\n\/\/ <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)\/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n\n\/\/ Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)\/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n\/\/ Repeat around the origin by a fixed angle.\n\/\/ For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI\/repetitions;\n\tfloat a = atan(p.y, p.x) + angle\/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a\/angle);\n\ta = mod(a,angle) - angle\/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t\/\/ For an odd number of repetitions, fix cell index of the cell in -x direction\n\t\/\/ (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions\/2.)) c = abs(c);\n\treturn c;\n}\n\n\/\/ Mirror at an axis-aligned plane which is at a specified distance <dist> from the origin.\nfloat pMirror (inout float p, float dist) {\n\tfloat s = sgn(p);\n\tp = abs(p)-dist;\n\treturn s;\n}\n\nvec2 pMirrorOctant (inout vec2 p, vec2 dist) {\n\tvec2 s = sgn(p);\n\tpMirror(p.x, dist.x);\n\tpMirror(p.y, dist.y);\n\tif (p.y > p.x)\n\t\tp.xy = p.yx;\n\treturn s;\n}\n\nvec2 pModMirror2(inout vec2 p, vec2 size) {\n\tvec2 halfsize = size*0.5;\n\tvec2 c = floor((p + halfsize)\/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\tp *= mod(c,vec2(2))*2. - vec2(1.);\n\treturn c;\n}\n\n\/\/ Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n\/\/ Same as above, but in two dimensions (an endless box)\nfloat fBox2Cheap(vec2 p, vec2 b) {\n\treturn vmax(abs(p)-b);\n}\n\nfloat fCross(vec3 p, vec3 size) {\n    float obj = fBox(p, size);\n    obj = opU2(obj, fBox(p, size.zxy));\n    obj = opU2(obj, fBox(p, size.yzx));\n               \n               return obj;\n}\n\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nmat2x2 rot(float angle)\n{\n    return mat2x2(cos(angle), -sin(angle),\n\t\t\t\t  sin(angle), cos(angle));\n}\n\/\/IFS iterations : try 2 or 3\n#define NIFS 4\n\/\/scale and translate for the IFS in-loop transformation\n#define SCALE 1.2\n#define TRANSLATE 4.2\nvec3 sd2d(vec2 p, float o)\n{\n    p *= 1.7;\n    float time = o * .2;\/\/0.2*o+0.6*iTime;\n \tfloat s =.45, d, d2 = 1., d3= 0.;\n    p*= s;\n    float RADIUS =2.5;\/\/(1.+sin(iTime));\n    \n    int i;\n    vec3 col;  \n    \n    p = p*rot((mod(timeline.patternNum, 4.) > 1. ? -1. : 1.) * -0.9 * time);\/\/ twist\n\n    for ( i = 0; i<NIFS; i++)\n    {        \n        if (p.x < 0.) { p.x = -p.x; col.r++;}\n\t\t\/\/p = p*rot(0.1*sin(time));\n        if (p.y < 0.) {p.y = -p.y; col.g++; }\n        if (p.x-p.y < 0.){ p.xy = p.yx; col.b++;}        \n        \n      \tp = p * SCALE - TRANSLATE;\n        \/\/p = p * rot(0.1 * iTime);\n        d = 0.25 * (length(p) - RADIUS) * pow(SCALE, float(-i)) \/ s;\n\n        if (d < 1.1) {\n         \td2 = float(i);\n            d3 = 1.;\n            break;\n        }\n    }\n    \n    \n    \n    \/\/d = fCross(vec3(p.xy, 1.), vec3(1.)) - RADIUS * pow(SCALE, float(-i)) * 2.;\n    \/\/col\/=float(NIFS);\n    \/\/vec3 oc = mix(vec3(0.7,col.g,0.2),vec3(0.2,col.r,0.7), col.b);\n    \n    return vec3(d, d2, d3);\n}\n\n\/\/ Cone with correct distances to tip and base circle. Y is up, 0 is in the middle of the base.\nfloat fCone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t\n\t\/\/ distance to tip\n\tif ((q.y > height) && (projected < 0.)) {\n\t\td = max(d, length(tip));\n\t}\n\t\n\t\/\/ distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0)));\n\t}\n\treturn d;\n}\n\nvec3 opTwist(in vec3 p, float k)\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    \n    return q;\n}\n\nvec3 discoBall(vec3 p, float spikes) {\n    \n    \/\/p -= ballPos;\n    \n    \/\/p = opTwist(p, .1);\n    \/\/p = opTwist(p.yxz, .1);\/\/sin(length(p) * .01));\n    \n    \/\/pR(p.xz, iTime * .3 - min(1., iTime) * vol * 1.5);\n    \/\/pR(p.yz, iTime * .24 - min(1., iTime) * vol * .5);\n    \n    \/\/dpb = p;\n    \n    \n    float pxz = pModPolar(p.xz, 7.);\/\/ceil(vol2 * 10.));\/\/ * hash12(vec2(floor(part2Time * 3.55))) * min(part2Time, 30.));\n    float pyz = pModPolar(p.xy, 7.);\n    \n    \/\/pR(p.xz, length(p) * .01);\n    \/\/pR(p.xy, length(p) * .01);\n    \n    \n    return vec3(\n        fCone(p.zxy, 4., spikes), \n        8., 16.\n    );\n\n}\n\ngeometry map(vec3 p) {\n    geometry box, fl;\n    vec3 bp = p, bp2 = p;\n\t\/\/p.x *= sin(timeline.smoothNPatternTime + p.x);\n    p *= (sin(length(bp)) * .2 - 1.) * (1. + timeline.nPatternTime);\n    \n    \/\/p += sin(iTime);\n    \n    \/\/pR(bp.yx, p.y * .2 + sin(iTime));\n    \n    \/\/pR(bp.xy, PI \/ 4.);\n    pR(bp.xy, timeline.songTime * .02 + n(vec3(iTime * .1)) * 5.);\n    \/\/pModPolar(p.xy, 4.);\n    \/\/pModPolar(p.xz, 4.);\n    vec3 tb = bp;\n    vec3 reps = vec3(\n        pModInterval1(bp.x, 5., -2., 2.),\n        pModInterval1(bp.y, 5., -2., 2.),\n        pModInterval1(bp.z, 5., -2., 2.)\n    );\n    \n    box.dist = fSphere(bp, 1.5);\n    \n    bp = tb;\n    \n    vec3 reps2 = vec3(\n        pModInterval1(bp.x, 5., -1.5, 1.5),\n        pModInterval1(bp.y, 5., -1.5, 1.5),\n        pModInterval1(bp.z, 5., -1.5, 1.5)\n    );\n    \n    box.dist = mix(box.dist, fBox(bp, vec3(1.5)), mod(timeline.patternNum, 2.));\/\/fSphere(bp, 1.5);\n \n\tbox.diffuse = 4.;\n    box.specular = 5.;\n    box.mirror = 1.;\n    box.color = vec3(0.0);\n    \n    \/\/pR(p.xz, timeline.songTime * .1);\n    \/\/p = mix(p, p.xzy, .9);\n    vec3 s = sd2d(p.xz, p.y) * .9;\n    \n    float a = smin(s.x, box.dist, pow(sin(iTime \/ 2.) \/ 2. + .5, 3.) + .8);\n    \n    box.dist = mix(box.dist, a, sdfMixer.ifs1);    \n    \n    reps = vec3(s.y);\n    \n    \/\/box.dist = smin(box.dist, fSphere(p, 5.), abs(sin(iTime * .1)));\n    box.index = ceil(reps + (n(reps + timeline.patternNum + timeline.nPatternTime * 10.) - .5) * 3.);\n    \n    \n  \t\/\/box.dist = mix(box.dist, fBox(p, vec3(10.)), sin(iTime) \/ 2. + .5);\n    \/\/!!!  box.dist = mix(box.dist, fBox(p, vec3(10.)), 1.-n(vec3(p) * .5));\n    \/\/pR(bp2.zx, p.y * .2 + sin(iTime));\n    \n    \/\/db.yzx = opTwist(db.yzx, sin(length(db)) * .001);\n    float di = discoBall(bp2, 25. * (1.-timeline.smoothNPatternTime \/ 4.)).x;\n    box.dist = smin(box.dist, di, .9);\n    \n   \/\/ box.dist = min(box.dist, -(length(bp2) -140.));\n    box.dist = mix(fSphere(bp2, 15.), box.dist, min(timeline.songTime * .1, 1.));\n    \n    p= bp2;\n    \/\/p.zxy = opTwist(p.zxy, .03);\n    \/\/float m = pModPolar(p.xz, 10.);\n    \/\/p.x -= 35. ;\/\/+ sin(p.y * .3+ IT) * 3.;;\n    float ss = sd2d(-p.zx * 1.4, p.y).x;\n    \/\/p.y += sin(m + IT) * 10.;\n    box.dist = mix(ss, box.dist, min(1., timeline.songTime*.1));\n    \n    return box;\n    box.diffuse = 4.;\n    box.specular = 5.;\n    box.mirror = 1.;\n    box.color = vec3(.0, .0, .0);\n    box.index = vec3(1.);\n    \n    bp.x += sin(timeline.songTime * .04) * 20.;\n    pR(bp.zy, sin(timeline.songTime * .03));\n    pModPolar(bp.xy, 5.);\n    box.dist = discoBall(bp * 2., 25.).x;\n    bp = bp2;\n    bp.x += sin(timeline.songTime * .02) * 20.;\n    bp.y += cos(timeline.songTime * .02) * 20.;\n    pR(bp.xy, sin(timeline.songTime * .1));\n    pR(bp.zy, sin(timeline.songTime * .1));\n    \n    box.dist = smin(box.dist, discoBall(bp * 2., 25.).x,.1);\n    \n    \n    return box;\n}\n\n\n\nfloat t_max = FAR;\n\nfloat minDist = 1e3;\nfloat glow = 0.;\nbool firstpass = true;\n\ngeometry trace(vec3 o, vec3 d, int maxI) {\n    float omega = .3;\n    float t = .01;\n    float candidate_error = INF;\n    float candidate_t = t;\n    float previousRadius = 0.;\n    float stepLength = 0.;\n    float pixelRadius = 1. \/ 250.;\n    float functionSign = map(o).dist < 0. ? -1. : +1.;\n    \n    geometry mp;\n\n    for (int i = 0; i < 200; ++i) {\n        if (maxI > 0 && i > maxI) break; \n        mp = map(d * t + o);\n        \n        if (mp.index.x == 0. && firstpass) {\n            minDist = min(minDist, mp.dist * 1.);\n            glow = pow( 1. \/ minDist, .5);\n        } \n        \n        float signedRadius = functionSign * mp.dist;\n        float radius = abs(signedRadius);\n        bool sorFail = omega > 1. &&\n        (radius + previousRadius) < stepLength;\n        \n        if (sorFail) {\n            stepLength -= omega * stepLength;\n            omega = .1;\n        } else {\n            stepLength = signedRadius * omega;\n        }\n        \n        previousRadius = radius;\n        \n        float error = radius \/ t;\n        \n        if (!sorFail && error < candidate_error) {\n            candidate_t = t;\n            candidate_error = error;\n        }\n        \n        if (!sorFail && error < pixelRadius || t > t_max) break;\n        \n        t += stepLength;\n   \t}\n    \n    mp.dist = candidate_t;\n    \n    if (\n        (t > t_max || candidate_error > pixelRadius)\n    \t) mp.dist = INF;\n    \n    \n    return mp;\n}\n\n\nfloat softShadow(vec3 ro, vec3 lp, float k) {\n    const int maxIterationsShad = 15;\n    vec3 rd = (lp - ro); \n\n    float shade = 1.;\n    float dist = 2.05;\n    float end = max(length(rd), .01);\n    float stepDist = end \/ float(maxIterationsShad);\n\n    rd \/= end;\n    for (int i = 0; i < maxIterationsShad; i++) {\n        float h = map(ro + rd * dist).dist;\n        shade = min(shade, k*h\/dist);\n        dist += min(h, stepDist * 2.); \n        if (h < 0.001 || dist > end) break;\n    }\n    return min(max(shade, 0.0), 1.0);\n}\n\n\n\/\/\tnormal calculation\nvec3 normal(vec3 p) {\n    float e=.001, d = map(p).dist; return normalize(vec3(map(p+vec3(e,0,0)).dist-d,map(p+vec3(0,e,0)).dist-d,map(p+vec3(0,0,e)).dist-d));\n}\n\nfloat getAO(vec3 h, vec3 n, float d) { return clamp(map(h + n * d).dist \/ d, .3, 1.); }\n\nvec3 clouds(vec3 d, vec3 o) {\n    vec2 u = d.xz \/ d.y;\n   \n    return vec3(\n        B(\n            vec3(\n                u + vec2(0., o.z  * .05), 9.\n            )\n        ) * vec3(1., .5, 0.)\n\n    ) * max(0., d.y); \t\n}\n\nvec3 Sky(in vec3 rd, bool showSun, vec3 lightDir, vec3 ro)\n{\n   \n    float sunSize = .5;\n    float sunAmount = max(dot(rd, lightDir), 0.);\n    float v = pow(1. - max(rd.y, 0.0), 1.1);\n    vec3 cl = vec3(1.);\/\/fromRGB(0,136,254);\n    \/\/cl.b *= sin(p.z * 0.3);\n    vec3 sky = mix(cl, vec3(.1, .2, .3), v);\n \t\/\/vec3 lightColour = vec3(.1, .2, .3);\n    \n    sky += lightColour * sunAmount * sunAmount * 1. + lightColour * min(pow(sunAmount, 122.0)* sunSize, 1.2 * sunSize);\n    \/\/sky += vec3(0., 0., 0.) * max(0.,rd.y);\n    return clamp(sky, 0.3, 1.0) + clouds(rd, ro);\/\/ * H(vec2(IT)) * floor(B(rd * 12.1) * 1.+ .5) * 1.;\n}\n\nvec3 doColor( in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, geometry obj) {\n\tvec3 sceneCol = obj.color;\n    lp = sp + lp;\n    vec3 ld = lp - sp; \/\/ Light direction vector.\n    float lDist = max(length(ld \/ 2.), 0.01); \/\/ Light to surface distance.\n    ld \/= lDist; \/\/ Normalizing the light vector.\n\n    float atten = 1. \/ (1.0 + lDist * 0.025 + lDist * lDist * 0.5);\n\n    float diff = max(dot(sn, ld), obj.diffuse);\n    float spec = max(dot(reflect(-ld, sn), -rd), obj.specular);\n\n    \n    vec3 objCol = obj.color;\/\/getObjectColor(sp, sn, obj);\n\treturn objCol * (diff + .15) * spec * .1;\n}\n\n\nvec3 applyFog( in vec3  rgb,      \/\/ original color of the pixel\n               in float distance, \/\/ camera to point distance\n               in vec3  rayOri,   \/\/ camera position\n               in vec3  rayDir ) {  \/\/ camera to point vector\n    \n    float c = .08;\n    float b = .1;\n    \/\/rayOri.y -= 14.;\n    float fogAmount = c * exp(-rayOri.y * b) * (1.0-exp( -distance*rayDir.y*b ))\/rayDir.y;\n    \n    vec3  fogColor  = vec3(1., 1., 1.);\/\/Sky(rayDir, false, normalize(light)) * 1.;\/\/\n    \n    return mix( rgb, fogColor, fogAmount );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    timeline.songTime = texelFetch(iChannel0, ivec2(0, 0), 0).r;\n    timeline.rPatternTime = texelFetch(iChannel0, ivec2(0, 0), 0).g;\n    timeline.nPatternTime = texelFetch(iChannel0, ivec2(0, 0), 0).b;\n    timeline.smoothNPatternTime = texelFetch(iChannel0, ivec2(0, 0), 0).a;\n    \n    timeline.patternNum = texelFetch(iChannel0, ivec2(1, 0), 0).x;\n    \n    vec3 campos = texelFetch(iChannel0, ivec2(5, 0), 0).rgb;\n    sdfMixer.grid = texelFetch(iChannel0, ivec2(11, 0), 0).r;\n    sdfMixer.star = texelFetch(iChannel0, ivec2(13, 0), 0).g;\n    sdfMixer.ifs1 = texelFetch(iChannel0, ivec2(15, 0), 0).r;\n    \n    \n    \/\/if (fragCoord.x < 100.) {\n        \/\/fragColor = vec4(timeline.rPatternTime);\n        \/\/return;\n    \/\/}\n    F \tmat = 0.,\n        camShY = 0.;\n    \n    \/\/vol = (texture(iChannel0, vec2(.92, .15)).r) * 2.;\n    \n    vec2 uv = (2. * fragCoord.xy - iResolution.xy) \/ iResolution.x * 1.5;\n    \/\/if (length(uv) < .9) pR(uv, PI);\n    light = vec3(0., 0., 100.);        \n    float rr = timeline.songTime + (n(vec3(timeline.songTime * .4)) * 2.) - .5;\n    vec3 \n        vuv = vec3(0., 1., 0.4 ), \/\/ up\n    \t\n        ro = campos;\n    \n    vec3\n        vrp =  vec3(0., 0., 0.),\/\/+ ro,\n\t\t\n    \tvpn = normalize(vrp - ro),\n    \tu = normalize(cross(vuv, vpn)),\n    \trd = normalize(\n            vpn + uv.x * u  + uv.y * cross(vpn, u)\n        ),\n        hit,\n        ord = rd;\n        \n\t\n    vec3 sceneColor = vec3(1.);\n    \n    geometry tr = trace(ro, rd, 90);    \n    \n    \/\/float fog = smoothstep(FAR * FOG, 0., tr.dist) * 1.;\n    hit = ro + rd * tr.dist;\n\t\n    float odist = tr.dist;\n    \n    vec3 sn = normal(hit);\t\n    \n   \/\/ float sh = softShadow(hit, hit + light, 3.);\n    \n    float \n        ao = getAO(hit, sn, .6);\n\t\n    \/\/ao *= saturate(getAO(hit + sn * .2, sn, .5));\n    \/\/ao *= saturate(getAO(hit + sn * 1., sn, 3.0));\n    \n    float alpha = 1.;\n\tvec3 sky = Sky(rd, true, normalize(light), ro);\n    \n    if (tr.dist < FAR) { \n        sceneColor = (doColor(hit, rd, sn, light, tr) * 1.) * 1.;\n       \/\/ sceneColor *= ao; \n        \/\/sceneColor *= sh;\n        sceneColor = mix(sceneColor, sky, saturate(tr.dist * 2. \/ FAR));\n        \/\/sceneColor = mix(sceneColor, lightColour, 0.1);        \n        sceneColor *= 0.9 + vec3(length(\n            max(\n                vec2(.0),\n                .7 * max(\n                    0.,\n                    length(normalize(light.y) * max(0., sn.y))\n                )\n            )\n        ));\n        \n        firstpass = false;\n        \n        glow *= 1.- timeline.nPatternTime;\n        \n        sceneColor += pow(glow, 2.);\n        \n        if (glow < 1.) {\n            if (tr.mirror > 0.) {   \n                float mirror = tr.mirror;\n                vec3 refSceneColor = sceneColor;\n                rd = reflect(rd, sn);\/\/ + sin(t));\n                \/\/hit += rd * 3.;\n                \/\/rd += n(rd * 3.) * .2;\n                \/\/rd = normalize(rd);\n\n                tr = trace(hit, rd, 69);\n                hit = hit + rd * tr.dist;\n                \n                if (tr.dist < FAR) {\n                    sn = normal(hit);\n                    refSceneColor = mix(sceneColor, abs(doColor(hit, rd, sn, light, tr)), mirror);                \n                } else {\n                    sky = mix(Sky(rd, true, normalize(light), hit), vec3(0.), .3);\n                    sky = Sky(rd, true, normalize(light), hit);\n                    refSceneColor = mix(refSceneColor, sky, mirror);\n                }\n\n                sceneColor = mix(sceneColor, refSceneColor, mirror);\n                \n            } else {\n                sceneColor = mix(sceneColor, sky, 1.0);\n            }\n        }\n\t sceneColor *= ao; \n    \t\/\/sceneColor = mix(sceneColor, vec3(sceneColor.r + sceneColor.g + sceneColor.b)\/ 3., odist \/ 10.);\n    \n    \talpha = odist \/ 25.;        \n    } else {\n        alpha = 1.;\n        sceneColor = sky;        \n    }\n\n    sceneColor += pow(glow, 3.) * vec3(1., .5, 0.);\n    \n    \n    vec3 bsceneColor = texture(iChannel1, (fragCoord.xy + vec2(1., 0.)) \/ iResolution.xy).rgb;\n    \n    sceneColor = mix(sceneColor, bsceneColor, .2);\n    \/\/sceneColor *= timeline.smoothNPatternTime;\n    \/\/if (length(uv) < .5) sceneColor = 1.- sceneColor;\/\/pR(uv, PI);\n    fragColor = vec4(clamp(sceneColor * (1. - length(uv) \/ 2.), 0.0, 1.0), 1.0) * 1.4;\n    \/\/fragColor = pow(fragColor, 1.\/vec4(1.2));\n\tfragColor.a = alpha;\n    \n    \/\/fragColor.rgb = vec3(timeline.nPatternTime);\n}\n",
            "name": "Buffer A",
            "description": "",
            "type": "buffer"
        },
        {
            "inputs": [
                {
                    "id": "XsXGR8",
                    "filepath": "\/media\/previz\/buffer01.png",
                    "previewfilepath": "\/media\/previz\/buffer01.png",
                    "type": "buffer",
                    "channel": 1,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "MlXSW7",
                    "filepath": "https:\/\/soundcloud.com\/neurofunksocietyofpoland\/dronehead-02-hexyll-original-mix",
                    "previewfilepath": "https:\/\/soundcloud.com\/neurofunksocietyofpoland\/dronehead-02-hexyll-original-mix",
                    "type": "musicstream",
                    "channel": 0,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 0
                }
            ],
            "outputs": [
                {
                    "id": "XsXGR8",
                    "channel": 0
                }
            ],
            "code": "vec3 U[2] = vec3[2](vec3(0), vec3(0));\n\nvoid compute(in ivec2 coord, out vec4 color) {\n    float time = U[0].x,\n          pt = mod(time, PATTERN_TIME),\n          pt2 = mod(pt - PATTERN_TIME \/ 4., PATTERN_TIME) \/ 3.,\n          npt = pt \/ PATTERN_TIME,\n    \t  pn = floor(time \/ PATTERN_TIME); \/\/ pattern num\n                \n    switch (coord.x) {\n        \/\/ R - songtime, G - pattern time (1->0), B - pattern time(0->1), smootstep patterntime) \n        case 0:\n        \tcolor = vec4(U[1].x, (PATTERN_TIME - pt) \/ PATTERN_TIME, npt, smoothstep(0., 1., pt \/ PATTERN_TIME));\n            \n        \tbreak;\n        case 1:\n            \/\/ R - pattern number;\n        \tcolor = vec4(pn, 0., 0., 0.);\n        \tbreak;\n        case 5: \n        \t\/\/ RG - cam position \n        \tvec2 x = texture(iChannel1, vec2(.5, fract(time * .2))).rg * 0.4 * npt;\n        \tvec2 r = time * .95 + x - sin(pt) * npt * 6.14 * x;\n        \n        \tr += pn * .5;\n        \n        \tcolor = vec4(\n                sin(r.x) * 29., \n                -10., \n                cos(r.x) * 26., \n                0.\n            );\n        \t\n        \tbreak;\n\n        case 9:\n        \tcolor = vec4(pt);\n        \tbreak;\n        case 11:\n        \t\/\/\/ sdf mixer GRID,\n        \tcolor = vec4(pt, sin(pt), 0., 0.);\n        \tbreak;\n        case 13: \n        \tbreak;\n        \n        case 15:\n        \t\/\/\/ sdf mixer IFS1\n        \tcolor = vec4(max(0., 1.- pt2));\n        \tbreak;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tU[1].x = float(iFrame);\n    U[0].x = max(22., iChannelTime[0]);\n    \n    ivec2 store = ivec2(fragCoord.xy);\n\tvec2 uv = gl_FragCoord.xy \/ U[0].yz;   \n    \n    fragColor = vec4(0.0);\n\n    float ck = cos(iTime * .1) * .1;\n    int index = 0;\n\n    if (store.y != 0 || store.x > 15) {        \n        if (U[1].x < 10.) {\n            fragColor.r = noiseLayers(vec3(fragCoord * .03, 2.));\n            fragColor.b = noiseFF(fragCoord * .01);\n            return;\n        } else {\n        \tdiscard;\n        }\n    } else {\n        compute(store, fragColor);         \n    }\n}",
            "name": "Buffer B",
            "description": "",
            "type": "buffer"
        },
        {
            "inputs": [],
            "outputs": [],
            "code": "#define PATTERN_TIME (5.485714 \/ 4.)\n\nvec3 hash33_(vec3 p){     \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n#define M0 1597334673U\n#define M1 3812015801U\n#define M2 uvec2(M0, M1)\n#define M3 uvec3(M0, M1, 2798796413U)\n\nfloat hash11( float q )\n{\n    uvec2 n = uint(q) * M2;\n    return float((n.x ^ n.y) * M0) * (1.0\/float(0xffffffffU));\n}\n\nfloat hash12( vec2 p ) { uvec2 q = uvec2(ivec2(p)) * M2; uint n = (q.x ^ q.y) * M0; return float(n) * (1.\/float(0xffffffffU)); }\nvec3 hash33(vec3 p) { uvec3 q = uvec3(ivec3(p)) * M3; q = (q.x ^ q.y ^ q.z)*M3; return vec3(q) * (1.0\/float(0xffffffffU)); }\n\nfloat voronoi(vec3 p){\n\tvec3 b, r, g = floor(p);\n\tp = fract(p); \n\tfloat d = 1.;      \n    for(int j = -1; j <= 1; j++) {\n\t    for(int i = -1; i <= 1; i++) {    \t\t\n\t\t    b = vec3(i, j, -1); r = b - p + hash33(g+b); d = min(d, dot(r,r));    \t\t\n\t\t    b.z = 0.0; r = b - p + hash33(g+b); d = min(d, dot(r,r)); \n            b.z = 1.; r = b - p + hash33(g+b); d = min(d, dot(r,r));    \t\t\t\n\t    }\n\t}\t\n\treturn d;\n}\n\nfloat noiseLayers(in vec3 p) {\n    vec3 t = vec3(0., 0., p.z);    \n    float tot = 0., sum = 0., amp = 1.;\n    for (int i = 0; i < 2; i++) { tot += voronoi(p + t) * amp; p *= 2.0; t *= 1.5; sum += amp; amp *= 0.5; }    \n    return tot \/ sum;\n}\n\nfloat noiseF( in vec2 p )\n{\n    vec2 i = floor( p ), f = fract( p ), u = f*f*f*(3.-2.*f);\n\n    return mix( mix( hash12( i + vec2(0.,0.) ), \n                     hash12( i + vec2(1.,0.) ), u.x),\n                mix( hash12( i + vec2(0.,1.) ), \n                     hash12( i + vec2(1.,1.) ), u.x), u.y);\n}\n\nfloat noiseFF(in vec2 uv) {\n    uv *= 2.;\n    \n \tmat2 m = mat2( 1.6,  1.2, -1.2,  1.6 ) * 1.25;\n    \n    float f  = .5*noiseF( uv ); uv = m*uv;\n    f += .2500*noiseF( uv ); uv = m*uv;\n    f += .1250*noiseF( uv ); uv = m*uv;\n    f += .0625*noiseF( uv ); uv = m*uv;   \n    \n    return f;\n}",
            "name": "Common",
            "description": "",
            "type": "common"
        }
    ]
}