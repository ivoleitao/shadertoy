{
    "ver": "0.1",
    "info": {
        "id": "tls3WB",
        "date": "1557704405",
        "viewed": 5055,
        "name": "Recursive Donut",
        "username": "ShnitzelKiller",
        "description": "Everything is chrome in the future. Also mousable.",
        "likes": 78,
        "published": 3,
        "flags": 0,
        "usePreview": 0,
        "tags": [
            "fractal",
            "interactive",
            "torus",
            "mousable"
        ],
        "hasliked": 0
    },
    "renderpass": [
        {
            "inputs": [],
            "outputs": [
                {
                    "id": "4dfGRr",
                    "channel": 0
                }
            ],
            "code": "\/\/change this to increase or decrease the levels of recursion\n#define levels 4\n\n\/\/rendering and camera\n#define fdist 0.3\n#define iters 40\n#define tol 0.005\n#define maxdist 5.\n#define maxdist_refl 0.4\n#define iters_refl 20\n#define reflection_eps 0.05\n#define gradient_eps 0.01\n\n\/\/shape parameters\n#define PI 3.1415926\n#define TWO_PI 6.28318530718\n#define min_rings 3.\n#define max_rings 10.\n#define ratio 0.4\n#define ring_offset 1.5\n#define offsetdiff 0.8\n#define indent 0.2\n#define base_radius 2.\n#define repeat_offset 8.\n\n\/\/materials and lighting parameters\n#define ao_radius 0.05\n#define ao_min 0.2\n#define laplace_factor 100.\n#define reflections 1\n#define reflection_albedo 0.3\n#define light_dir vec3(0.436436,0.872872,0.218218)\n\/\/#define n1 1.0\n\/\/#define n2 1.0\n#define plane_height -2.\n#define shadow_step 0.1\n#define shadow_eps 0.01\n#define shadow_iters 5\n#define shadow_maxdist 1.5\n#define shadow_sharpness 2.\n#define ambient 0.2\n\n\n\/\/float R0 = (n1-n2)\/(n1+n2);\n\nvec3 viridis_quintic( float x )\n{\n\tx = clamp( x, 0.,1. );\n\tvec4 x1 = vec4( 1.0, x, x * x, x * x * x ); \/\/ 1 x x2 x3\n\tvec4 x2 = x1 * x1.w * x; \/\/ x4 x5 x6 x7\n\treturn vec3(\n\t\tdot( x1.xyzw, vec4( +0.280268003, -0.143510503, +2.225793877, -14.815088879 ) ) + dot( x2.xy, vec2( +25.212752309, -11.772589584 ) ),\n\t\tdot( x1.xyzw, vec4( -0.002117546, +1.617109353, -1.909305070, +2.701152864 ) ) + dot( x2.xy, vec2( -1.685288385, +0.178738871 ) ),\n\t\tdot( x1.xyzw, vec4( +0.300805501, +2.614650302, -12.019139090, +28.933559110 ) ) + dot( x2.xy, vec2( -33.491294770, +13.762053843 ) ) );\n}\n\nvec2 sdTorus( vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    float d = length(q)-t.y;\n    \n    float theta = atan(-p.z, p.x); \/\/outer angle\n    return vec2(d, theta);\n}\n\nfloat delay_sin(float t) {\n    return cos(PI*((abs(mod(t, 2.)-1.)+t)*0.5-0.5));\n}\nfloat map(vec3 p) {\n    \/\/p = mod(p+0.5*repeat_offset, repeat_offset)-0.5*repeat_offset;\n    \/\/time-varying parameters (maybe replace with some inputs, or remove)\n    float final_offset;\n    if (iMouse.z < 1.)\n        final_offset = offsetdiff*delay_sin(iTime*0.5+1.) + ring_offset;\n    else\n        final_offset = (iMouse.y\/iResolution.y-0.5)*3.+2.;\n    float final_ratio = ratio\/final_offset;\n    \n    float ringdiff = (max_rings-min_rings)*0.5;\n    float ring_count = (max_rings+min_rings)*0.5;\n    float final_ringcount;\n    if (iMouse.z < 1.)\n    \tfinal_ringcount = ringdiff*delay_sin(iTime*0.5)+ring_count;\n    else\n    \tfinal_ringcount = ringdiff*(iMouse.x\/iResolution.x-0.5)*2. + ring_count;\n    float sector = TWO_PI\/(final_ringcount);\n    float outerrad = base_radius;\n    float innerrad = outerrad*final_ratio;\n    vec2 h = sdTorus(p, vec2(outerrad, innerrad));\n    float currindent = indent;\n    vec2 minh = h;\n    \n    for (int i=0; i<levels; i++) {\n        \n        \/\/mod polar coordinates\n        float theta = mod(abs(h.y), sector)-sector\/2.;\n        \n        \/\/new cartesian coords\n        float s = length(p.zx);\n        p.z = cos(theta)*s - outerrad;\n        p.x = sin(theta)*s;\n        p = p.zxy;\n        \n        \/\/new torus\n        outerrad = innerrad*final_offset;        \n        innerrad = outerrad*final_ratio;\n        h = sdTorus(p, vec2(outerrad, innerrad));\n        \n        minh.x = max(minh.x, currindent-h.x);\n        if (h.x < minh.x) {\n            minh = h;\n        }\n        \n        currindent = currindent * final_ratio * final_offset;\n    }\n    return minh.x;\n}\n\nvec4 gradient(vec3 ro) {\n    vec2 d = vec2(gradient_eps, 0.0);\n    float x1 = map(ro+d.xyy);\n    float x2 = map(ro-d.xyy);\n    float y1 = map(ro+d.yxy);\n    float y2 = map(ro-d.yxy);\n    float z1 = map(ro+d.yyx);\n    float z2 = map(ro-d.yyx);\n    return vec4(normalize(vec3(\n        x1-x2,\n        y1-y2,\n        z1-z2)),\n        x1+x2+y1+y2+z1+z2-6.*map(ro));\n}\n\nvec2 raymarch(vec3 pos, vec3 dir, float max_dist, int num_iters) {\n    int i;\n    float d = 0.;\n    float dist;\n    for (i=0; i<num_iters; i++) {\n        dist = map(pos+d*dir);\n        d += dist;\n        if (dist < tol) {\n            return vec2(d, 2.);\n        } else if (dist > max_dist) {\n            break;\n        }\n    }\n\td = (plane_height-pos.y) \/ dir.y;\n    return vec2(d, step(-d, 0.)*step(length((pos+d*dir).zx), 50.));\n}\n\n\nvec3 skycol(vec3 rd) {\n    return vec3(0.6, 0.7, 0.8)*(1.+pow(max(dot(rd, light_dir), 0.), 2.)) + pow(max(0.,dot(rd, light_dir)), 5.);\n}\n\nfloat schlick(vec3 rd, vec3 n) {\n    \/\/return 1.-(R0+(1.-R0)*pow(max(dot(n.xyz, -rd), 0.), 5.0));\n    return 1.-pow(max(dot(n.xyz, -rd), 0.), 5.0);\n}\n\nvec3 material(vec3 ro, vec3 rd, vec4 n, vec2 record) {\n    if (record.y > 1.5) {\n        float edgefac = abs(n.w*laplace_factor);\n        vec3 color = 1.-viridis_quintic(edgefac).yxz*0.5;\n        float fac = max(ambient, dot(light_dir, n.xyz));\n        \/\/float ao = min(1.,ao_min+(record.z > ao_radius ? 1. : record.z\/(ao_radius)));\n        return fac*color;\n    } else if (record.y > 0.5) {\n        vec2 uv = (ro+rd*record.x).zx;\n        uv = abs(mod(uv, 4.)-2.);\n        float checker = abs(step(uv.x, 1.) - step(uv.y, 1.));\n        return vec3(light_dir.y*(0.5+0.5*checker));\n    } else {\n        return skycol(rd);\n    }\n}\n\n\/\/softer soft shadows\n\/\/see https:\/\/www.shadertoy.com\/view\/4tBcz3\n\/\/float shadowtrace(vec3 pos, vec3 dir) {\n\/\/    int i;\n\/\/    float d = shadow_eps;\n\/\/    float dist = map(pos+d*dir);\n\/\/    float fac = 1.0;\n\/\/    for (i=0; i<shadow_iters; i++) {\n\/\/    d += max(shadow_step, dist);\n\/\/        dist = map(pos+d*dir);\n\/\/        fac = min(fac, dist * shadow_sharpness \/ d);\n\/\/    }\n\/\/    return mix(mix(0.5, 0., -fac), mix(0.5, 1., fac), step(fac, 0.));\n\/\/}\n\n\/\/materials with reflections\nvec3 shade(vec3 ro, vec3 rd, vec4 n, vec2 record) {\n    vec3 pos = ro+rd*record.x;\n    vec3 shadedcolor = material(ro, rd, n, record);\n    if (record.y > 0.5) {\n        vec3 offsetpos = pos + n.xyz * 0.25;\n        float fac = clamp(map(offsetpos)*3., 0., 1.);\n        \/\/float fac = shadowtrace(pos, light_dir);\n        shadedcolor *= mix(fac, 1., 0.5);\n    }\n    if (record.y > 1.5) {\n        int i;\n        float final_albedo = reflection_albedo;\n        \n        for (i=0; i<reflections; i++) {\n            if (record.y < 1.5) break;\n            final_albedo *= schlick(rd, n.xyz);\n            ro = pos;\n            rd = reflect(rd, n.xyz);\n            ro += reflection_eps*rd;\n            record = raymarch(ro, rd, maxdist_refl, iters_refl);\n            pos = ro+rd*record.x;\n            n = gradient(pos);\n            shadedcolor += final_albedo * material(ro, rd, n, record);\n        }\n        \/\/compute last reflections with just envmap\n        if (record.y > 1.5) {\n            final_albedo *= schlick(rd, n.xyz);\n            shadedcolor += final_albedo * skycol(reflect(rd, n.xyz));\n        }\n    }\n    return shadedcolor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    \/\/R0*=R0;\n    \/\/camera position\n    float s = sin(iTime*0.5);\n    float ww = iTime*0.2;\n    vec3 ro = (3.-s)*vec3(cos(ww),0.5+0.5*s,sin(ww));\n    vec3 w = normalize(vec3(0.,-1.5-s,0.)-ro);\n    vec3 u = normalize(cross(w, vec3(0., 1., 0.)));\n    vec3 v = cross(u, w);\n    vec3 rd = normalize(w*fdist+(fragCoord.x\/iResolution.x-0.5)*u+(fragCoord.y-iResolution.y\/2.0)\/iResolution.x*v);\n\t\n    vec2 record = raymarch(ro, rd, maxdist, iters);\n    vec4 n = record.y > 1.5 ? gradient(ro+rd*record.x) : vec4(0., 8., 0., 1.);\n    vec3 shadedcolor = shade(ro, rd, n, record);\n    \n    fragColor = vec4(shadedcolor, 1.);\n}",
            "name": "Image",
            "description": "",
            "type": "image"
        }
    ]
}