{
    "ver": "0.1",
    "info": {
        "id": "fldXWS",
        "date": "1639698771",
        "viewed": 3715,
        "name": "Cubic Dispersal",
        "username": "Tater",
        "description": "3d version of [url]https:\/\/www.shadertoy.com\/view\/stdGz4[\/url]. I finally got around to finishing it. \n\nuse mouse to reveal perspective. ",
        "likes": 126,
        "published": 3,
        "flags": 0,
        "usePreview": 0,
        "tags": [
            "3d",
            "raymarching",
            "subdivision"
        ],
        "hasliked": 0
    },
    "renderpass": [
        {
            "inputs": [],
            "outputs": [
                {
                    "id": "4dfGRr",
                    "channel": 0
                }
            ],
            "code": "\/\/Building on ideas from\n\/\/https:\/\/www.shadertoy.com\/view\/fd3SRN\n\/\/https:\/\/www.shadertoy.com\/view\/fsySWm\n\/\/https:\/\/www.shadertoy.com\/view\/stdGz4\n\/\/https:\/\/www.shadertoy.com\/view\/7sKGRy\n\/\/https:\/\/www.shadertoy.com\/view\/fsyGD3\n\/\/https:\/\/www.shadertoy.com\/view\/fdyGDt\n\/\/https:\/\/www.shadertoy.com\/view\/7dVGDd\n\/\/https:\/\/www.shadertoy.com\/view\/NsKGDy\n\n\/\/I had some plans to make a more elaborate shape using the \"fully animated subdivision\"\n\/\/but it ended up not looking that interesting when applied to an octree and it's too\n\/\/expensive to make shapes out of multiple \"sheets\" of this.\n\n\/\/I hope you enjoy it none the less :) \n\/\/(sorry if it's expensive I didn't do much opmimizing)\n\n#define MDIST 150.0\n#define STEPS 164.0\n#define pi 3.1415926535\n#define pmod(p,x) (mod(p,x)+0.5*(x))\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n\/\/this is a useless trick but it's funny\n#define vmm(v,minOrMax) minOrMax(v.x,minOrMax(v.y,v.z))\n\n\/\/iq box sdf\nfloat ebox( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(vmm(q,max),0.0);\n}\n\/\/iq palette\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\n    return a + b*cos(2.*pi*(c*t+d));\n}\nfloat h11 (float a) {\n    return fract(sin((a)*12.9898)*43758.5453123);\n}\n\/\/https:\/\/www.shadertoy.com\/view\/fdlSDl\nvec2 tanha(vec2 x) {\n  vec2 x2 = x*x;\n  return clamp(x*(27.0 + x2)\/(27.0+9.0*x2), -1.0, 1.0);\n}\nfloat tanha(float x) {\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)\/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nstruct sdResult\n{\n    vec2 center;\n    vec2 dim;\n    float id;\n    float vol;\n};\n\nsdResult subdiv(vec2 p,float seed){\n    vec2 dMin = vec2(-10.);\n    vec2 dMax = vec2(10.);\n    float t = iTime*0.6;\n    float t2 = iTime;\n    vec2 dim = dMax - dMin;\n    float id = 0.;\n    float ITERS = 6.;\n    \n    float MIN_SIZE = 0.1;\n    float MIN_ITERS = 1.;\n    \n    \/\/big thanks to @0b5vr for letting me use his cleaner subdiv implementation\n    \/\/https:\/\/www.shadertoy.com\/view\/NsKGDy\n    vec2 diff2 = vec2(1);\n    for(float i = 0.;i<ITERS;i++){\n        vec2 divHash=tanha(vec2(sin(t2*pi\/3.+id+i*t2*0.05),cos(t2*pi\/3.+h11(id)*100.+i*t2*0.05))*3.)*0.35+0.5;\n        \/\/divHash=vec2(sin(t*pi\/3.+id),cos(t*pi\/3.+h11(id)*100.))*0.5+0.5;\n        \/\/if(iMouse.z>0.5){divHash = mix(divHash,M,0.9);}\n        divHash = mix(vec2(0.5),divHash,tanha(sin(t*0.8)*5.)*0.2+0.4);\n        vec2 divide = divHash * dim + dMin;\n        divide = clamp(divide, dMin + MIN_SIZE+0.01, dMax - MIN_SIZE-0.01);\n        vec2 minAxis = min(abs(dMin - divide), abs(dMax - divide));\n        float minSize = min( minAxis.x, minAxis.y);\n        bool smallEnough = minSize < MIN_SIZE;\n        if (smallEnough && i + 1. > MIN_ITERS) { break; }\n        dMax = mix( dMax, divide, step( p, divide ));\n        dMin = mix( divide, dMin, step( p, divide ));\n        diff2 =step( p, divide)-\n        vec2(h11(diff2.x+seed)*10.,h11(diff2.y+seed)*10.);\n        id = length(diff2)*100.0;\n        dim = dMax - dMin;\n    }\n    vec2 center = (dMin + dMax)\/2.0;\n    sdResult result;\n    result.center = center;\n    result.id = id;\n    result.dim = dim;\n    result.vol = dim.x*dim.y;\n    return result;\n}\nvec3 rdg = vec3(0);\nfloat dibox(vec3 p,vec3 b,vec3 rd){\n    vec3 dir = sign(rd)*b;   \n    vec3 rc = (dir-p)\/rd;\n    return min(rc.x,rc.z)+0.01; \n}\nbool traverse = true;\nvec3 map(vec3 p){\n    float seed = sign(p.y)-0.3;\n    seed = 1.;\n    \/\/p.y = abs(p.y)-4.;\n\n    vec2 a = vec2(99999,1);\n    vec2 b = vec2(2);\n    \n    a.x = p.y-2.0;\n    float id = 0.;\n    if(a.x<0.1||!traverse){\n        float t = iTime;\n        sdResult sdr = subdiv(p.xz,seed);\n        vec3 centerOff = vec3(sdr.center.x,0,sdr.center.y);\n        vec2 dim = sdr.dim;\n\n        float rnd = 0.05;\n        float size = min(dim.y,dim.x)*1.;\n        \/\/size = 1.;\n        size+=(sin((centerOff.x+centerOff.z)*0.6+t*4.5)*0.5+0.5)*2.;\n        size = min(size,4.0);\n        a.x = ebox(p-centerOff-vec3(0,0,0),vec3(dim.x,size,dim.y)*0.5-rnd)-rnd;\n        if(traverse){\n            b.x = dibox(p-centerOff,vec3(dim.x,1,dim.y)*0.5,rdg);\n            a = (a.x<b.x)?a:b;\n        }\n        id = sdr.id;\n    }\n    return vec3(a,id);\n}\nvec3 norm(vec3 p){\n    vec2 e = vec2(0.01,0.);\n    return normalize(map(p).x-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 R = iResolution.xy;\n    vec2 uv = (fragCoord-0.5*R.xy)\/R.y;\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0,6.,-12)*1.2;\n\n    ro.xz*=rot(0.35);\n    vec3 lk = vec3(-1,-3,0.5);\n    if(iMouse.z>0.){\n       ro*=2.;\n       lk = vec3(0);\n       ro.yz*=rot(2.0*(iMouse.y\/iResolution.y-0.5));\n       ro.zx*=rot(-9.0*(iMouse.x\/iResolution.x-0.5));\n    }\n    vec3 f = vec3(normalize(lk-ro));\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = normalize(f*(1.8)+r*uv.x+uv.y*cross(f,r));\n    rdg = rd;\n    vec3 p = ro;\n    float dO =0.;\n    vec3 d;\n    bool hit = false;\n        \n    for(float i = 0.; i<STEPS; i++){\n        p = ro+rd*dO;\n        d = map(p);\n        dO+=d.x;\n        if(d.x<0.005){\n            hit = true;\n            break;\n        }\n        if(dO>MDIST)break;\n    }\n    \n    if(hit&&d.y!=2.0){\n        traverse = false;\n        vec3 n = norm(p);\n        vec3 r = reflect(rd,n);\n        vec3 e = vec3(0.5);\n        vec3 al = pal(fract(d.z)*0.35-0.8,e*1.2,e,e*2.0,vec3(0,0.33,0.66));\n        col = al;\n        vec3 ld = normalize(vec3(0,45,0)-p);\n\n        \/\/sss from nusan\n        float sss=0.1;\n        float sssteps = 10.;\n        for(float i=1.; i<sssteps; ++i){\n            float dist = i*0.2;\n            sss += smoothstep(0.,1.,map(p+ld*dist).x\/dist)\/(sssteps*1.5);\n        }\n        sss = clamp(sss,0.0,1.0);\n        \n        float diff = max(0.,dot(n,ld))*0.7+0.3;\n        float amb = dot(n,ld)*0.45+0.55;\n        float spec = pow(max(0.,dot(r,ld)),13.0);\n        \/\/blackle ao \n        #define AO(a,n,p) smoothstep(-a,a,map(p+n*a).x)\n        float ao = AO(0.1,n,p)*AO(.2,n,p)*AO(.3,n,p);\n\n        spec = smoothstep(0.,1.,spec);\n        col = vec3(0.204,0.267,0.373)*\n        mix(vec3(0.169,0.000,0.169),vec3(0.984,0.996,0.804),mix(amb,diff,0.75))\n        +spec*0.3;\n        col+=sss*al;\n        col*=mix(ao,1.,0.65);\n        col = pow(col,vec3(0.85));\n    }\n    else{\n    col = mix(vec3(0.373,0.835,0.988),vec3(0.424,0.059,0.925),length(uv));\n\n    }\n    \n    col *=1.0-0.5*pow(length(uv*vec2(0.8,1.)),2.7);\n    vec3 col2 = smoothstep(vec3(0.0, 0.0, 0.0), vec3(1.1, 1.1, 1.3), col);\n    col = mix(col,col2,0.5)*1.05;\n\n    fragColor = vec4(col,1.0);\n}",
            "name": "Image",
            "description": "",
            "type": "image"
        }
    ]
}