{
    "ver": "0.1",
    "info": {
        "id": "WsSBzh",
        "date": "1606524984",
        "viewed": 24243,
        "name": "Selfie Girl",
        "username": "iq",
        "description": "A raymarched procedural SDF - a girl taking a selfie, this time. Making of video here: [url]https:\/\/www.youtube.com\/watch?v=8--5LwHRhjk[\/url]",
        "likes": 204,
        "published": 3,
        "flags": 32,
        "usePreview": 1,
        "tags": [
            "procedural",
            "3d",
            "raymarching",
            "sdf"
        ],
        "hasliked": 0
    },
    "renderpass": [
        {
            "inputs": [
                {
                    "id": "4sf3Rn",
                    "filepath": "\/media\/a\/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png",
                    "previewfilepath": "\/media\/ap\/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png",
                    "type": "texture",
                    "channel": 2,
                    "sampler": {
                        "filter": "mipmap",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "Xsf3zn",
                    "filepath": "\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
                    "previewfilepath": "\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
                    "type": "texture",
                    "channel": 3,
                    "sampler": {
                        "filter": "mipmap",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "4sfGRr",
                    "filepath": "\/media\/a\/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin",
                    "previewfilepath": "\/media\/ap\/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin",
                    "type": "volume",
                    "channel": 0,
                    "sampler": {
                        "filter": "mipmap",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "XsXGR8",
                    "filepath": "\/media\/previz\/buffer01.png",
                    "previewfilepath": "\/media\/previz\/buffer01.png",
                    "type": "buffer",
                    "channel": 1,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dfGRr",
                    "channel": 0
                }
            ],
            "code": "\/\/ Created by inigo quilez - iq\/2020\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ Source code of the mathematical painting \"Selfie Girl\".\n\/\/ Making-of video on Youtube:\n\/\/\n\/\/ https:\/\/www.youtube.com\/watch?v=8--5LwHRhjk\n\n\/\/ The image is a single formula, but I had to break it\n\/\/ down into 3 passes here so it could be shared without\n\/\/ breaking the WebGL implementation of the web browsers\n\/\/ (which is what Shadertoy uses to run the code below\n\/\/ that implements the formula).\n\n\/\/ This \"Image\" tab in particular renders the girl through\n\/\/ raymarching and then performs the final composition with\n\/\/ the background, which is computed in \"Buffer B\" (open\n\/\/ the rest of the tabs to see explanations of what each\n\/\/ one does). For the rendering\/computer graphics people - \n\/\/ there's no TAA in this pass because I didn't want to\n\/\/ compute velocity vectors for the animation, so things\n\/\/ alias a bit (feel free to change the AA define below to\n\/\/ 2 if you have a fast GPU)\n\n#define AA 1\n\n\n\/\/ This SDF is really 6 braids at once (through domain\n\/\/ repetition) with three strands each (brute forced)\nvec4 sdHair( vec3 p, vec3 pa, vec3 pb, vec3 pc, float an, out vec2 occ_id) \n{\n    vec4 b = sdBezier(p, pa,pb,pc );\n    vec2 q = rot(b.zw,an);\n  \t\n    vec2 id2 = round(q\/0.1);\n    id2 = clamp(id2,vec2(0),vec2(2,1));\n    q -= 0.1*id2;\n\n    float id = 11.0*id2.x + id2.y*13.0;\n\n    q += smoothstep(0.5,0.8,b.y)*0.02*vec2(0.4,1.5)*cos( 23.0*b.y + id*vec2(13,17));\n\n    occ_id.x = clamp(length(q)*8.0-0.2,0.0,1.0);\n    vec4 res = vec4(99,q,b.y);\n    for( int i=0; i<3; i++ )\n    {\n        vec2 tmp = q + 0.01*cos( id + 180.0*b.y + vec2(2*i,6-2*i));\n        float lt = length(tmp)-0.02;\n        if( lt<res.x )\n        { \n            occ_id.y = id+float(i); \n            res.x = lt; \n            res.yz = tmp;\n        }\n    }\n    return res;\n}\n\n\/\/ The SDF for the hoodie and jacket. It's a very distorted\n\/\/ ellipsoid, torus section, a segment and a sphere.\nvec4 sdHoodie( in vec3 pos )\n{\n    vec3 opos = pos;\n\n    pos.x   += 0.09*sin(3.5*pos.y-0.5)*sin(    pos.z) + 0.015;\n    pos.xyz += 0.03*sin(2.0*pos.y)*sin(7.0*pos.zyx);\n    \n    \/\/ hoodie\n    vec3 hos = pos-vec3(0.0,-0.33,0.15);\n    hos.x -= 0.031*smoothstep(0.0,1.0,opos.y+0.33);\n    hos.yz = rot(hos.yz,0.9);\n    float d1 = sdEllipsoid(hos,vec3(0.96-pos.y*0.1,1.23,1.5));\n\tfloat d2 = 0.95*pos.z-0.312*pos.y-0.9;\n    float d = max(opOnion(d1,0.01), d2 );\n    \n    \/\/ shoulders\n    vec3 sos = vec3( abs(pos.x), pos.yz );    \n    vec2 se = sdSegment(sos, vec3(0.18,-1.6,-0.3), vec3(1.1,-1.9,0.0) );\n    d = smin(d,se.x-mix(0.25,0.43,se.y),0.4);\n    d = smin(d,sdSphere(sos-vec3(0.3,-2.2,0.4), 0.5 ),0.2);\n\n    \/\/ neck\n    opos.x -= 0.02*sin(9.0*opos.y);\n    vec4 w = opElongate( opos-vec3(0.0,-1.2,0.3), vec3(0.0,0.3,0.0) );\n    d = smin(d,\n             w.w+sdCappedTorus(vec3(w.xy,-w.z),vec2(0.6,-0.8),0.6,0.02),\n             0.1);\n    \n    \/\/ bumps\n    d += 0.004*sin(pos.x*90.0)*sin(pos.y*90.0)*sin(pos.z*90.0);\n    d -= 0.002*sin(pos.x*300.0);\n    d -= 0.02*(1.0-smoothstep(0.0,0.04,abs(opOnion(pos.x,1.1))));\n    \n    \/\/ border\n    d = min(d,length(vec2(d1,d2))-0.015);\n    \n    return vec4(d,pos);\n}\n\n\/\/ moves the head (and hair and hoodie). This could be done\n\/\/ more efficiently (with a single matrix or quaternion),\n\/\/ but this code was optimized for editing, not for runtime\nvec3 moveHead( in vec3 pos, in vec3 an, in float amount)\n{\n    pos.y -= -1.0;\n    pos.xz = rot(pos.xz,amount*an.x);\n    pos.xy = rot(pos.xy,amount*an.y);\n    pos.yz = rot(pos.yz,amount*an.z);\n    pos.y += -1.0;\n    return pos;\n}\n\n\/\/ the animation state\nvec3 animData; \/\/ { blink, nose follow up, mouth } \nvec3 animHead; \/\/ { head rotation angles }\n\n\/\/ SDF of the girl. It is not as efficient as it should, \n\/\/ both in terms of performance and euclideanness of the\n\/\/ returned distance. Among other things I tweaked the\n\/\/ overal shape of the head though scaling right in the\n\/\/ middle of the design process (see 1.02 and 1.04 numbers\n\/\/ below). I should have backpropagated those adjustements\n\/\/ to the  primitives themselves, but I didn't and now it's\n\/\/ too late. So, I am paying some cost there.\n\/\/\n\/\/ Generally, she is modeled to camera (her face's shape \n\/\/ looks bad from other perspectives. She's made of five\n\/\/ ellipsoids blended together for the face, a cone and\n\/\/ three spheres for the nose, a torus for the teeh and two\n\/\/ quadratic curves for the lips. The neck is a cylinder,\n\/\/ the hair is made of three quadratic that are repeated\n\/\/ multiple times through domain repetition and each of\n\/\/ them contains three more curves in order to make the\n\/\/ braids. The hoodie is an ellipsoid deformed with\n\/\/ two sine waves and cut in half, the neck is an elongated\n\/\/ torus section and the shoulders are capsules.\n\/\/\nvec4 map( in vec3 pos, in float time, out float outMat, out vec3 uvw )\n{\n    outMat = 1.0;\n\n    vec3 oriPos = pos;\n    \n    \/\/ head deformation and transformation\n    pos.y \/= 1.04;\n    vec3 opos;\n    opos = moveHead( pos, animHead, smoothstep(-1.2, 0.2,pos.y) );\n    pos  = moveHead( pos, animHead, smoothstep(-1.4,-1.0,pos.y) );\n    pos.x *= 1.04;\n    pos.y \/= 1.02;\n    uvw = pos;\n\n    \/\/ symmetric coord systems (sharp, and smooth)\n    vec3 qos = vec3(abs(pos.x),pos.yz);\n    vec3 sos = vec3(sqrt(qos.x*qos.x+0.0005),pos.yz);\n\n    \n    \n    \/\/ head\n    float d = sdEllipsoid( pos-vec3(0.0,0.05,0.07), vec3(0.8,0.75,0.85) );\n    \n    \/\/ jaw\n    vec3 mos = pos-vec3(0.0,-0.38,0.35); mos.yz = rot(mos.yz,0.4);\n\tmos.yz = rot(mos.yz,0.1*animData.z);\n\tfloat d2 = sdEllipsoid(mos-vec3(0,-0.17,0.16),\n                 vec3(0.66+sclamp(mos.y*0.9-0.1*mos.z,-0.3,0.4),\n                 \t  0.43+sclamp(mos.y*0.5,-0.5,0.2),\n                      0.50+sclamp(mos.y*0.3,-0.45,0.5)));\n        \n    \/\/ mouth hole\n    d2 = smax(d2,-sdEllipsoid(mos-vec3(0,0.06,0.6+0.05*animData.z), vec3(0.16,0.035+0.05*animData.z,0.1)),0.01);\n    \n    \/\/ lower lip    \n    vec4 b = sdBezier(vec3(abs(mos.x),mos.yz), \n                      vec3(0,0.01,0.61),\n                      vec3(0.094+0.01*animData.z,0.015,0.61),\n                      vec3(0.18-0.02*animData.z,0.06+animData.z*0.05,0.57-0.006*animData.z));\n    float isLip = smoothstep(0.045,0.04,b.x+b.y*0.03);\n    d2 = smin(d2,b.x - 0.027*(1.0-b.y*b.y)*smoothstep(1.0,0.4,b.y),0.02);\n    d = smin(d,d2,0.19);\n\n    \/\/ chicks\n    d = smin(d,sdSphere(qos-vec3(0.2,-0.33,0.62),0.28 ),0.04);\n    \n    \/\/ who needs ears\n    \n\n    \/\/ eye sockets\n    vec3 eos = sos-vec3(0.3,-0.04,0.7);\n    eos.xz = rot(eos.xz,-0.2);\n    eos.xy = rot(eos.xy,0.3);\n    eos.yz = rot(eos.yz,-0.2);\n    d2 = sdEllipsoid( eos-vec3(-0.05,-0.05,0.2), vec3(0.20,0.14-0.06*animData.x,0.1) );\n\td = smax( d, -d2, 0.15 );\n\n    eos = sos-vec3(0.32,-0.08,0.8);\n    eos.xz = rot(eos.xz,-0.4);\n    d2 = sdEllipsoid( eos, vec3(0.154,0.11,0.1) );\n    d = smax( d, -d2, 0.05 );\n\n    vec3 oos = qos - vec3(0.25,-0.06,0.42);\n    \n    \/\/ eyelid\n    d2 = sdSphere( oos, 0.4 );\n    oos.xz = rot(oos.xz, -0.2);\n    oos.xy = rot(oos.xy, 0.2);\n    vec3 tos = oos;        \n    oos.yz = rot(oos.yz,-0.6+0.58*animData.x);\n\n    \/\/eyebags\n    tos = tos-vec3(-0.02,0.06,0.2+0.02*animData.x);\n    tos.yz = rot(tos.yz,0.8);\n    tos.xy = rot(tos.xy,-0.2);\n\td = smin( d, sdTorus(tos,0.29,0.01), 0.03 );\n    \n    \/\/ eyelids\n    eos = qos - vec3(0.33,-0.07,0.53);\n    eos.xy = rot(eos.xy, 0.2);\n    eos.yz = rot(eos.yz,0.35-0.25*animData.x);\n    d2 = smax(d2-0.005, -max(oos.y+0.098,-eos.y-0.025), 0.02 );\n    d = smin( d, d2, 0.012 );\n\n\t\/\/ eyelashes\n\toos.x -= 0.01;\n    float xx = clamp( oos.x+0.17,0.0,1.0);\n    float ra = 0.35 + 0.1*sqrt(xx\/0.2)*(1.0-smoothstep(0.3,0.4,xx))*(0.6+0.4*sin(xx*256.0));\n    float rc = 0.18\/(1.0-0.7*smoothstep(0.15,0.5,animData.x));\n    oos.y -= -0.18 - (rc-0.18)\/1.8;\n    d2 = (1.0\/1.8)*sdArc( oos.xy*vec2(1.0,1.8), vec2(0.9,sqrt(1.0-0.9*0.9)), rc )-0.001;\n    float deyelashes = max(d2,length(oos.xz)-ra)-0.003;\n    \n    \/\/ nose\n    eos = pos-vec3(0.0,-0.079+animData.y*0.005,0.86);\n    eos.yz = rot(eos.yz,-0.23);\n    float h = smoothstep(0.0,0.26,-eos.y);\n    d2 = sdCone( eos-vec3(0.0,-0.02,0.0), vec2(0.03,-0.25) )-0.04*h-0.01;\n    eos.x = sqrt(eos.x*eos.x + 0.001);\n    d2 = smin( d2, sdSphere(eos-vec3(0.0, -0.25,0.037),0.06 ), 0.07 );\n    d2 = smin( d2, sdSphere(eos-vec3(0.1, -0.27,0.03 ),0.04 ), 0.07 );\n    d2 = smin( d2, sdSphere(eos-vec3(0.0, -0.32,0.05 ),0.025), 0.04 );        \n    d2 = smax( d2,-sdSphere(eos-vec3(0.07,-0.31,0.038),0.02 ), 0.035 );\n    d = smin(d,d2,0.05-0.03*h);\n    \n    \/\/ mouth\n    eos = pos-vec3(0.0,-0.38+animData.y*0.003+0.01*animData.z,0.71);\n    tos = eos-vec3(0.0,-0.13,0.06);\n    tos.yz = rot(tos.yz,0.2);\n    float dTeeth = sdTorus(tos,0.15,0.015);\n    eos.yz = rot(eos.yz,-0.5);\n    eos.x \/= 1.04;\n\n    \/\/ nose-to-upperlip connection\n    d2 = sdCone( eos-vec3(0,0,0.03), vec2(0.14,-0.2) )-0.03;\n    d2 = max(d2,-(eos.z-0.03));\n    d = smin(d,d2,0.05);\n\n    \/\/ upper lip\n    eos.x = abs(eos.x);\n    b = sdBezier(eos, vec3(0.00,-0.22,0.17),\n                      vec3(0.08,-0.22,0.17),\n                      vec3(0.17-0.02*animData.z,-0.24-0.01*animData.z,0.08));\n    d2 = length(b.zw\/vec2(0.5,1.0)) - 0.03*clamp(1.0-b.y*b.y,0.0,1.0);\n    d = smin(d,d2,0.02);\n    isLip = max(isLip,(smoothstep(0.03,0.005,abs(b.z+0.015+abs(eos.x)*0.04))\n                 -smoothstep(0.45,0.47,eos.x-eos.y*1.15)));\n\n    \/\/ valley under nose\n    vec2 se = sdSegment(pos, vec3(0.0,-0.45,1.01),  vec3(0.0,-0.47,1.09) );\n    d2 = se.x-0.03-0.06*se.y;\n    d = smax(d,-d2,0.04);\n    isLip *= smoothstep(0.01,0.03,d2);\n\n    \/\/ neck\n    se = sdSegment(pos, vec3(0.0,-0.65,0.0), vec3(0.0,-1.7,-0.1) );\n    d2 = se.x - 0.38;\n\n    \/\/ shoulders\n    se = sdSegment(sos, vec3(0.0,-1.55,0.0), vec3(0.6,-1.65,0.0) );\n    d2 = smin(d2,se.x-0.21,0.1);\n    d = smin(d,d2,0.4);\n        \n    \/\/ register eyelases now\n    vec4 res = vec4( d, isLip, 0, 0 );\n    if( deyelashes<res.x )\n    {\n        res.x = deyelashes*0.8;\n        res.yzw = vec3(0.0,1.0,0.0);\n    }\n    \/\/ register teeth now\n    if( dTeeth<res.x )\n    {\n        res.x = dTeeth;\n        outMat = 5.0;\n    }\n \n    \/\/ eyes\n\tpos.x \/=1.05;        \n    eos = qos-vec3(0.25,-0.06,0.42);\n    d2 = sdSphere(eos,0.4);\n    if( d2<res.x ) \n    { \n        res.x = d2;\n     \toutMat = 2.0;\n        uvw = pos;\n    }\n        \n    \/\/ hair\n    {\n        vec2 occ_id, tmp;\n\t\tqos = pos; qos.x=abs(pos.x);\n\n        vec4 pres = sdHair(pos,vec3(-0.3, 0.55,0.8), \n                               vec3( 0.95, 0.7,0.85), \n                               vec3( 0.4,-1.45,0.95),\n                               -0.9,occ_id);\n\n        vec4 pres2 = sdHair(pos,vec3(-0.4, 0.6,0.55), \n                                vec3(-1.0, 0.4,0.2), \n                                vec3(-0.6,-1.4,0.7),\n                                0.6,tmp);\n        if( pres2.x<pres.x ) { pres=pres2; occ_id=tmp;  occ_id.y+=40.0;}\n\n        pres2 = sdHair(qos,vec3( 0.4, 0.7,0.4), \n                           vec3( 1.0, 0.5,0.45), \n                           vec3( 0.4,-1.45,0.55),\n                           -0.2,tmp);\n        if( pres2.x<pres.x ) { pres=pres2; occ_id=tmp;  occ_id.y+=80.0;}\n    \n\n        pres.x *= 0.8;\n        if( pres.x<res.x )\n        {\n            res = vec4( pres.x, occ_id.y, 0.0, occ_id.x );\n            uvw = pres.yzw;\n            outMat = 4.0;\n        }\n    }\n\n    \/\/ hoodie\n    vec4 tmp = sdHoodie( opos );\n    if( tmp.x<res.x )\n    {\n        res.x = tmp.x;\n        outMat = 3.0;\n        uvw  = tmp.yzw;\n    }\n\n    return res;\n}\n\n\/\/ SDF of the girl again, but with extra high frequency\n\/\/ modeling detail. While the previous one is used for\n\/\/ raymarching and shadowing, this one is used for normal\n\/\/ computation. This separation is conceptually equivalent\n\/\/ to decoupling detail from base geometry with \"normal\n\/\/ maps\", but done in 3D and with SDFs, which is way\n\/\/ simpler and can be done corretly (something rarely seen\n\/\/ in 3D engines) without any complexity.\nvec4 mapD( in vec3 pos, in float time )\n{\n    float matID;\n    vec3 uvw;\n    vec4 h = map(pos, time, matID, uvw);\n    \n    if( matID<1.5 ) \/\/ skin\n    {\n        \/\/ pores\n        float d = fbm1(iChannel0,120.0*uvw);\n        h.x += 0.0015*d*d;\n    }\n    else if( matID>3.5 && matID<4.5 ) \/\/ hair\n    {\n        \/\/ some random displacement to evoke hairs\n        float te = texture( iChannel2,vec2( 0.25*atan(uvw.x,uvw.y),8.0*uvw.z) ).x;\n    \th.x -= 0.02*te;\n    }    \n    return h;\n}\n\n\/\/ Computes the normal of the girl's surface (the gradient\n\/\/ of the SDF). The implementation is weird because of the\n\/\/ technicalities of the WebGL API that forces us to do\n\/\/ some trick to prevent code unrolling. More info here:\n\/\/\n\/\/ http:\/\/iquilezles.org\/www\/articles\/normalsSDF\/normalsSDF.htm\n\/\/\nvec3 calcNormal( in vec3 pos, in float time )\n{\n    const float eps = 0.001;\n#if 0    \n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*eps,time,kk ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps,time,kk ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps,time,kk ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps,time,kk ).x );\n#else\n    vec4 n = vec4(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec4 s = vec4(pos, 0.0);\n        float kk; vec3 kk2;\n        s[i] += eps;\n        n[i] = mapD(s.xyz, time).x;\n      \/\/if( n.x+n.y+n.z+n.w>100.0 ) break;\n    }\n    return normalize(n.xyz-n.w);\n#endif   \n}\n\n\/\/ Compute soft shadows for a given light, with a single\n\/\/ ray insead of using montecarlo integration or shadowmap\n\/\/ blurring. More info here:\n\/\/\n\/\/ http:\/\/iquilezles.org\/www\/articles\/rmshadows\/rmshadows.htm\n\/\/\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, in float time, float k )\n{\n    \/\/ first things first - let's do a bounding volume test\n    vec2 sph = iCylinderY( ro, rd, 1.5 );\n  \/\/vec2 sph = iConeY(ro-vec3(-0.05,3.7,0.35),rd,0.08);\n    tmax = min(tmax,sph.y);\n\n    \/\/ raymarch and track penumbra    \n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<128; i++ )\n    {\n        float kk; vec3 kk2;\n\t\tfloat h = map( ro + rd*t, time, kk, kk2 ).x;\n        res = min( res, k*h\/t );\n        t += clamp( h, 0.005, 0.1 );\n        if( res<0.002 || t>tmax ) break;\n    }\n    return max( res, 0.0 );\n}\n\n\/\/ Computes convexity for our girl SDF, which can be used\n\/\/ to approximate ambient occlusion. More info here:\n\/\/\n\/\/ https:\/\/iquilezles.org\/www\/material\/nvscene2008\/rwwtt.pdf\n\/\/\nfloat calcOcclusion( in vec3 pos, in vec3 nor, in float time )\n{\n    float kk; vec3 kk2;\n\tfloat ao = 0.0;\n    float off = textureLod(iChannel3,gl_FragCoord.xy\/256.0,0.0).x;\n    vec4 k = vec4(0.7012912,0.3941462,0.8294585,0.109841)+off;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tk = fract(k + H4);\n        vec3 ap = normalize(-1.0+2.0*k.xyz);\n        float h = k.w*0.1;\n        ap = (nor+ap)*h;\n        float d = map( pos+ap, time, kk, kk2 ).x;\n        ao += max(0.0,h-d);\n        if( ao>16.0 ) break;\n    }\n\tao \/= 16.0;\n    return clamp( 1.0-ao*24.0, 0.0, 1.0 );\n}\n\n\/\/ Computes the intersection point between our girl SDF and\n\/\/ a ray (coming form the camera in this case). It's a\n\/\/ traditional and basic\/uncomplicated SDF raymarcher. More\n\/\/ info here:\n\/\/\n\/\/ https:\/\/iquilezles.org\/www\/material\/nvscene2008\/rwwtt.pdf\n\/\/\nvec2 intersect( in vec3 ro, in vec3 rd, in float tmax, in float time, out vec3 cma, out vec3 uvw )\n{\n    cma = vec3(0.0);\n    uvw = vec3(0.0);\n    float matID = -1.0;\n\n    float t = 1.0;\n    \n    \/\/ bounding volume test first\n    vec2 sph = iCylinderY( ro, rd, 1.5 );\n  \/\/vec2 sph = iConeY(ro-vec3(-0.05,3.7,0.35),rd,0.08);\n    if( sph.y<0.0 ) return vec2(-1.0);\n    \n    \/\/ clip raymarch space to bonding volume\n    tmax = min(tmax,sph.y);\n    t    = max(1.0, sph.x);\n    \n    \/\/ raymarch\n    for( int i=0; i<256; i++ )\n    {\n        vec3 pos = ro + t*rd;\n\n        float tmp;\n        vec4 h = map(pos,time,tmp,uvw);\n        if( h.x<0.001 )\n        {\n            cma = h.yzw;\n            matID = tmp;\n            break;\n        }\n        t += h.x*0.95;\n        if( t>tmax ) break;\n    }\n\n    return vec2(t,matID);\n}\n\n\/\/ This is a replacement for a traditional dot(N,L) diffuse\n\/\/ lobe (called N.L in teh code) that fake some subsurface\n\/\/ scattering (transmision of light thorugh the skin that\n\/\/ surfaces as a red glow)\n\/\/\nvec3 sdif( float ndl, float ir )\n{\n    float pndl = clamp( ndl, 0.0, 1.0 );\n    float nndl = clamp(-ndl, 0.0, 1.0 );\n    return vec3(pndl) + vec3(1.0,0.1,0.01)*0.7*pow(clamp(ir*0.75-nndl,0.0,1.0),2.0);\n}\n\n\/\/ Animates the eye central position (not the actual random\n\/\/ darts). It's carefuly synched with the head motion, to\n\/\/ make the eyes anticipate the head turn (without this\n\/\/ anticipation, the eyes and the head are disconnected and\n\/\/ it all looks like a zombie\/animatronic)\n\/\/\nfloat animEye( in float time )\n{\n    const float w = 6.1;\n    float t = mod(time-0.31,w*1.0);\n    \n    float q = fract((time-0.31)\/(2.0*w));\n    float s = (q > 0.5) ? 1.0 : 0.0;\n    return (t<0.15)?1.0-s:s;\n}\n\n\/\/ Renders the girl. It finds the ray-girl intersection\n\/\/ point, computes the normal at the intersection point,\n\/\/ computes the ambient occlusion approximation, does per\n\/\/ material setup (color, specularity, subsurface\n\/\/ coefficient and paints some fake occlusion), and finally\n\/\/ does the lighting computations.\n\/\/\n\/\/ Lighting is not based on pathtracing. Instead the bounce\n\/\/ lighting occlusion signals are created manually (placed\n\/\/ and sized by hand). The subsurface scattering in the\n\/\/ nose area is also painted by hand. There's not much\n\/\/ attention to the physicall correctness of the light\n\/\/ response and materials, but generally all signal do\n\/\/ follow physically based rendering practices.\n\/\/\nvec3 renderGirl( in vec2 p, in vec3 ro, in vec3 rd, in float tmax, in vec3 col, in float time )\n{\n    \/\/ --------------------------\n    \/\/ find ray-girl intersection\n    \/\/ --------------------------\n    vec3 cma, uvw;\n    vec2 tm = intersect( ro, rd, tmax, time, cma, uvw );\n\n    \/\/ --------------------------\n    \/\/ shading\/lighting\t\n    \/\/ --------------------------\n    if( tm.y>0.0 )\n    {\n        vec3 pos = ro + tm.x*rd;\n        vec3 nor = calcNormal(pos, time);\n\n        float ks = 1.0;\n        float se = 16.0;\n        float tinterShadow = 0.0;\n        float sss = 0.0;\n        float focc = 1.0;\n        \/\/float frsha = 1.0;\n\n        \/\/ --------------------------\n        \/\/ material\n        \/\/ --------------------------\n        if( tm.y<1.5 ) \/\/ skin\n        {\n            vec3 qos = vec3(abs(uvw.x),uvw.yz);\n\n            \/\/ base skin color\n            col = mix(vec3(0.225,0.15,0.12),\n                      vec3(0.24,0.1,0.066),\n                      smoothstep(0.4 ,0.0,length( qos.xy-vec2(0.42,-0.3)))+\n                      smoothstep(0.15,0.0,length((qos.xy-vec2(0,-0.29))\/vec2(1.4,1))));\n            \n            \/\/ fix that ugly highlight\n            col -= 0.03*smoothstep(0.13,0.0,length((qos.xy-vec2(0,-0.49))\/vec2(2,1)));\n                \n            \/\/ lips\n            col = mix(col,vec3(0.14,0.06,0.1),cma.x*step(-0.7,qos.y));\n            \n            \/\/ eyelashes\n            col = mix(col,vec3(0.04,0.02,0.02)*0.6,0.9*cma.y);\n\n            \/\/ fake skin drag\n            uvw.y += 0.025*animData.x*smoothstep(0.3,0.1,length(uvw-vec3(0.0,0.1,1.0)));\n\t\t\tuvw.y -= 0.005*animData.y*smoothstep(0.09,0.0,abs(length((uvw.xy-vec2(0.0,-0.38))\/vec2(2.5,1.0))-0.12));\n            \n            \/\/ freckles\n            vec2 ti = floor(9.0+uvw.xy\/0.04);\n            vec2 uv = fract(uvw.xy\/0.04)-0.5;\n            float te = fract(111.0*sin(1111.0*ti.x+1331.0*ti.y));\n            te = smoothstep(0.9,1.0,te)*exp(-dot(uv,uv)*24.0); \n            col *= mix(vec3(1.1),vec3(0.8,0.6,0.4), te);\n\n            \/\/ texture for specular\n            ks = 0.5 + 4.0*texture(iChannel3,uvw.xy*1.1).x;\n            se = 12.0;\n            ks *= 0.5;\n            tinterShadow = 1.0;\n            sss = 1.0;\n            ks *= 1.0 + cma.x;\n            \n            \/\/ black top\n            col *= 1.0-smoothstep(0.48,0.51,uvw.y);\n            \n            \/\/ makeup\n            float d2 = sdEllipsoid(qos-vec3(0.25,-0.03,0.43),vec3(0.37,0.42,0.4));\n            col = mix(col,vec3(0.06,0.024,0.06),1.0 - smoothstep(0.0,0.03,d2));\n\n            \/\/ eyebrows\n    \t\t{\n            #if 0\n            \/\/ youtube video version\n        \tvec4 be = sdBezier( qos, vec3(0.165+0.01*animData.x,0.105-0.02*animData.x,0.89),\n                                     vec3(0.37,0.18-0.005*animData.x,0.82+0.005*animData.x), \n                                     vec3(0.53,0.15,0.69) );\n            float ra = 0.005 + 0.015*sqrt(be.y);\n            #else\n            \/\/ fixed version\n        \tvec4 be = sdBezier( qos, vec3(0.16+0.01*animData.x,0.11-0.02*animData.x,0.89),\n                                     vec3(0.37,0.18-0.005*animData.x,0.82+0.005*animData.x), \n                                     vec3(0.53,0.15,0.69) );\n            float ra = 0.005 + 0.01*sqrt(1.0-be.y);\n            #endif\n            float dd = 1.0+0.05*(0.7*sin((sin(qos.x*3.0)\/3.0-0.5*qos.y)*350.0)+\n                                 0.3*sin((qos.x-0.8*qos.y)*250.0+1.0));\n    \t\tfloat d = be.x - ra*dd;\n        \tfloat mask = 1.0-smoothstep(-0.005,0.01,d);\n        \tcol = mix(col,vec3(0.04,0.02,0.02),mask*dd );\n        \t}\n\n            \/\/ fake occlusion\n            focc = 0.2+0.8*pow(1.0-smoothstep(-0.4,1.0,uvw.y),2.0);\n            focc *= 0.5+0.5*smoothstep(-1.5,-0.75,uvw.y);\n            focc *= 1.0-smoothstep(0.4,0.75,abs(uvw.x));\n            focc *= 1.0-0.4*smoothstep(0.2,0.5,uvw.y);\n            \n            focc *= 1.0-smoothstep(1.0,1.3,1.7*uvw.y-uvw.x);\n            \n            \/\/frsha = 0.0;\n        }\n        else if( tm.y<2.5 ) \/\/ eye\n        {\n            \/\/ The eyes are fake in that they aren't 3D. Instead I simply\n\t\t\t\/\/ stamp a 2D mathematical drawing of an iris and pupil. That\n\t\t\t\/\/ includes the highlight and occlusion in the eyesballs.\n            \n            sss = 1.0;\n\n            vec3 qos = vec3(abs(uvw.x),uvw.yz);\n\t\t\tfloat ss = sign(uvw.x);\n            \n            \/\/ iris animation\n            float dt = floor(time*1.1);\n            float ft = fract(time*1.1);\n            vec2 da0 = sin(1.7*(dt+0.0)) + sin(2.3*(dt+0.0)+vec2(1.0,2.0));\n            vec2 da1 = sin(1.7*(dt+1.0)) + sin(2.3*(dt+1.0)+vec2(1.0,2.0));\n            vec2 da = mix(da0,da1,smoothstep(0.9,1.0,ft));\n\n            float gg = animEye(time);\n            da *= 1.0+0.5*gg;\n            qos.yz = rot(qos.yz,da.y*0.004-0.01);\n            qos.xz = rot(qos.xz,da.x*0.004*ss-gg*ss*(0.03-step(0.0,ss)*0.014)+0.02);\n\n            vec3 eos = qos-vec3(0.31,-0.055 - 0.03*animData.x,0.45);\n            \n            \/\/ iris\n            float r = length(eos.xy)+0.005;\n            float a = atan(eos.y,ss*eos.x);\n            vec3 iris = vec3(0.09,0.0315,0.0135);\n            iris += iris*3.0*(1.0-smoothstep(0.0,1.0, abs((a+3.14159)-2.5) ));\n            iris *= 0.35+0.7*texture(iChannel2,vec2(r,a\/6.2831)).x;\n            \/\/ base color\n            col = vec3(0.42);\n            col *= 0.1+0.9*smoothstep(0.10,0.114,r);\n            col = mix( col, iris, 1.0-smoothstep(0.095,0.10,r) );\n            col *= smoothstep(0.05,0.07,r);\n\t\t\t\n            \/\/ fake occlusion backed in\n            float edis = length((vec2(abs(uvw.x),uvw.y)-vec2(0.31,-0.07))\/vec2(1.3,1.0));\n            col *= mix( vec3(1.0), vec3(0.4,0.2,0.1), linearstep(0.07,0.16,edis) );\n\n            \/\/ fake highlight\n            qos = vec3(abs(uvw.x),uvw.yz);\n            col += (0.5-gg*0.3)*(1.0-smoothstep(0.0,0.02,length(qos.xy-vec2(0.29-0.05*ss,0.0))));\n            \n            se = 128.0;\n\n            \/\/ fake occlusion\n            focc = 0.2+0.8*pow(1.0-smoothstep(-0.4,1.0,uvw.y),2.0);\n            focc *= 1.0-linearstep(0.10,0.17,edis);\n            \/\/frsha = 0.0;\n        }\n        else if( tm.y<3.5 )\/\/ hoodie\n        {\n            sss = 0.0;\n            col = vec3(0.81*texture(iChannel0,uvw*6.0).x);\n            ks *= 2.0;\n            \n            \/\/ logo\n            if( abs(uvw.x)<0.66 )\n            {\n                float par = length(uvw.yz-vec2(-1.05,0.65));\n                col *= mix(vec3(1.0),vec3(0.6,0.2,0.8)*0.7,1.0-smoothstep(0.1,0.11,par));\n                col *= smoothstep(0.005,0.010,abs(par-0.105));\n            }                \n\n            \/\/ fake occlusion\n            focc = mix(1.0,\n                \t   0.03+0.97*smoothstep(-0.15,1.7,uvw.z),\n                       smoothstep(-1.6,-1.3,uvw.y)*(1.0-clamp(dot(nor.xz,normalize(uvw.xz)),0.0,1.0))\n                      );\n            \n            \/\/frsha = mix(1.0,\n            \/\/            clamp(dot(nor.xz,normalize(uvw.xz)),0.0,1.0),\n            \/\/            smoothstep(-1.6,-1.3,uvw.y)\n            \/\/           );\n            \/\/frsha *= smoothstep(0.85,1.0,length(uvw-vec3(0.0,-1.0,0.0)));\n        }\n        else if( tm.y<4.5 )\/\/ hair\n        {\n            sss = 0.0;\n            col = (sin(cma.x)>0.7) ? vec3(0.03,0.01,0.05)*1.5 :\n                                     vec3(0.04,0.02,0.01)*0.4;\n            ks *= 0.75 + cma.z*18.0;\n            float te = texture( iChannel2,vec2( 0.25*atan(uvw.x,uvw.y),8.0*uvw.z) ).x;\n            col *= 2.0*te;\n            ks *= 1.5*te;\n            \n\t\t\t\/\/ fake occlusion\n            focc  = 1.0-smoothstep(-0.40, 0.8, uvw.y);\n            focc *= 1.0-0.95*smoothstep(-1.20,-0.2,-uvw.z);\n            focc *= 0.5+cma.z*12.0;\n            \/\/frsha = 1.0-smoothstep(-1.3,-0.8,uvw.y);\n            \/\/frsha *= 1.0-smoothstep(-1.20,-0.2,-uvw.z);\n        }\n        else if( tm.y<5.5 )\/\/ teeth\n        {\n            sss = 1.0;\n            col = vec3(0.3);\n            ks *= 1.5;\n            \/\/frsha = 0.0;\n        }\n\n        float fre = clamp(1.0+dot(nor,rd),0.0,1.0);\n        float occ = focc*calcOcclusion( pos, nor, time );\n\n        \/\/ --------------------------\n        \/\/ lighting. just four lights\n        \/\/ --------------------------\n        vec3 lin = vec3(0.0);\n\n        \/\/ fake sss\n        float nma = 0.0;\n        if( tm.y<1.5 )\n        {\n        nma = 1.0-smoothstep(0.0,0.12,length((uvw.xy-vec2(0.0,-0.37))\/vec2(2.4,0.7)));\n        }\n\n        \/\/vec3 lig = normalize(vec3(0.5,0.4,0.6));\n        vec3 lig = vec3(0.57,0.46,0.68);\n        vec3 hal = normalize(lig-rd);\n        float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n        \/\/float sha = 0.0; if( dif>0.001 ) sha=calcSoftshadow( pos+nor*0.002, lig, 0.0001, 2.0, time, 5.0 );\n        float sha = calcSoftshadow( pos+nor*0.002, lig, 0.0001, 2.0, time, 5.0 );\n        float spe = 2.0*ks*pow(clamp(dot(nor,hal),0.0,1.0),se)*dif*sha*(0.04+0.96*pow(clamp(1.0-dot(hal,-rd),0.0,1.0),5.0));\n\n        \/\/ fake sss for key light\n        vec3 cocc = mix(vec3(occ),\n                        vec3(0.1+0.9*occ,0.9*occ+0.1*occ*occ,0.8*occ+0.2*occ*occ),\n                        tinterShadow);\n        cocc = mix( cocc, vec3(1,0.3,0.0), nma);\n        sha = mix(sha,max(sha,0.3),nma);\n\n        vec3  amb = cocc*(0.55 + 0.45*nor.y);\n        float bou = clamp(0.3-0.7*nor.x, 0.0, 1.0 );\n\n        lin +=      vec3(0.65,1.05,2.0)*amb*1.15;\n        lin += 1.50*vec3(1.60,1.40,1.2)*sdif(dot(nor,lig),0.5+0.3*nma+0.2*(1.0-occ)*tinterShadow) * mix(vec3(sha),vec3(sha,0.2*sha+0.7*sha*sha,0.2*sha+0.7*sha*sha),tinterShadow);\n        lin +=      vec3(1.00,0.30,0.1)*sss*fre*0.6*(0.5+0.5*dif*sha*amb)*(0.1+0.9*focc);\n        lin += 0.35*vec3(4.00,2.00,1.0)*bou*occ*col;\n\n        col = lin*col + spe + fre*fre*fre*0.1*occ;\n\n        \/\/ overall\n\t\tcol *= 1.1;\n    }\n\n    \/\/if( tm.x==-1.0) col=vec3(1,0,0);\n        \n    return col;\n}\n\n\/\/ Animates the head turn. This is my first time animating\n\/\/ and I am aware I'm in uncanny\/animatronic land. But I\n\/\/ have to start somwhere!\n\/\/\nfloat animTurn( in float time )\n{\t\n    const float w = 6.1;\n    float t = mod(time,w*2.0);\n    \n    vec3 p = (t<w) ? vec3(0.0,0.0,1.0) : vec3(w,1.0,-1.0);\n    return p.y + p.z*expSustainedImpulse(t-p.x,1.0,10.0);\n}\n\n\/\/ Animates the eye blinks. Blinks are motivated by head\n\/\/ turns (again, to prevent animatronic and zoombie uncanny\n\/\/ valley stuff), but also there are random blinks. This\n\/\/ same funcion is called with some delay and extra\n\/\/ smmoothness to get the blink of the eyes be followed by\n\/\/ the face muscles around the face to react.\n\/\/\nfloat animBlink( in float time, in float smo )\n{\n    \/\/ head-turn motivated blink\n    const float w = 6.1;\n    float t = mod(time-0.31,w*1.0);\n    float blink = smoothstep(0.0,0.1,t) - smoothstep(0.18,0.4,t);\n\n    \/\/ regular blink\n    float tt = mod(1.0+time,3.0);\n    blink = max(blink,smoothstep(0.0,0.07+0.07*smo,tt)-smoothstep(0.1+0.04*smo,0.35+0.3*smo,tt));\n    \n    \/\/ keep that eye alive always\n    float blinkBase = 0.04*(0.5+0.5*sin(time));\n    blink = mix( blinkBase, 1.0, blink );\n\n    \/\/ base pose is a bit down\n    float down = 0.15;\n    return down+(1.0-down)*blink;\n}\n\n\/\/ The main rendering entry point. Basically it does some\n\/\/ setup or creating the ray that will explore the 3D scene\n\/\/ in search of the girl for each pixel, computes the\n\/\/ animation variables (blink, mouth and head movements),\n\/\/ does the rendering of the girl if it finds her, and\n\/\/ finally does gamme correction and some minimal color\n\/\/ processing and vignetting to the image.\n\/\/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ render\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        \/\/ pixel coordinates\n        vec2 o = vec2(float(m),float(n)) \/ float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))\/iResolution.y;\n        float d = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n        float time = iTime - 0.5*(1.0\/24.0)*(float(m*AA+n)+d)\/float(AA*AA-1);\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)\/iResolution.y;\n        float time = iTime;\n        #endif\n        \n        time += 2.0;\n        \n        \/\/ camera movement\t\n        vec3 ro; float fl;\n        mat3 ca = calcCamera( time, ro, fl );\n    \tvec3 rd = ca * normalize( vec3((p-vec2(-0.52,0.12))\/1.1,fl));\n\n        \/\/ animation (blink, face follow up, mouth)\n        float turn = animTurn( time );\n        animData.x = animBlink(time,0.0);\n        animData.y = animBlink(time-0.02,1.0);\n        animData.z = -0.25 + 0.2*(1.0-turn)*smoothstep(-0.3,0.9,sin(time*1.1)) + 0.05*cos(time*2.7);\n\n        \/\/ animation (head orientation)\n        animHead = vec3( sin(time*0.5), sin(time*0.3), -cos(time*0.2) );\n        animHead = animHead*animHead*animHead;\n        animHead.x = -0.025*animHead.x + 0.2*(0.7+0.3*turn);\n        animHead.y =  0.1 + 0.02*animHead.y*animHead.y*animHead.y;\n        animHead.z = -0.03*(0.5 + 0.5*animHead.z) - (1.0-turn)*0.05;\n        \n        \/\/ rendering\n        vec4 tmp = texelFetch(iChannel1,ivec2(fragCoord),0);\n        vec3 col = tmp.xyz;\n        float tmin = tmp.w;\n        \n        if( p.x*1.4+p.y<0.8 && -p.x*4.5+p.y<6.5 && p.x<0.48)\n        col = renderGirl(p,ro,rd,tmin,col,time);\n        \/\/else col=vec3(0,1,0);\n        \n        \/\/ gamma        \n        col = pow( col, vec3(0.4545) );\n\t    tot += col;\n    #if AA>1\n    }\n    tot \/= float(AA*AA);\n    #endif\n \n    \/\/ compress\n    tot = 3.8*tot\/(3.0+dot(tot,vec3(0.333)));\n  \n    \/\/ vignette\n    vec2 q = fragCoord\/iResolution.xy;\n    tot *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.15);\n\n    \/\/ grade\n    tot = tot*vec3(1.02,1.00,0.99)+vec3(0.0,0.0,0.045);\n       \n    fragColor = vec4( tot, 1.0 );\n}",
            "name": "Image",
            "description": "",
            "type": "image"
        },
        {
            "inputs": [],
            "outputs": [],
            "code": "\/\/ Created by inigo quilez - iq\/2020\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\/\/ Basic utility functions (sdfs, noises, shaping functions)\n\/\/ and also the camera setup which is shaded between the\n\/\/ background rendering code (\"Buffer A\" tab) and the character\n\/\/ rendering code (\"Image\" tab)\n\n\n\n\/\/ http:\/\/iquilezles.org\/www\/articles\/smin\/smin.htm\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25\/k;\n}\n\n\/\/ http:\/\/iquilezles.org\/www\/articles\/smin\/smin.htm\nfloat smax( float a, float b, float k )\n{\n    k *= 1.4;\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*h\/(6.0*k*k);\n}\n\n\/\/ http:\/\/iquilezles.org\/www\/articles\/smin\/smin.htm\nfloat smin3( float a, float b, float k )\n{\n    k *= 1.4;\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*h\/(6.0*k*k);\n}\n\nfloat sclamp(in float x, in float a, in float b )\n{\n    float k = 0.1;\n\treturn smax(smin(x,b,k),a,k);\n}\n\n\/\/ http:\/\/iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm\nfloat opOnion( in float sdf, in float thickness )\n{\n    return abs(sdf)-thickness;\n}\n\n\/\/ http:\/\/iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm\nfloat opRepLim( in float p, in float s, in float lima, in float limb )\n{\n    return p-s*clamp(round(p\/s),lima,limb);\n}\n\n\nfloat det( vec2 a, vec2 b ) { return a.x*b.y-b.x*a.y; }\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x-a.y*b.y; }\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\n\n\/\/ http:\/\/iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm\nfloat sdTorus( in vec3 p, in float ra, in float rb )\n{\n    return length( vec2(length(p.xz)-ra,p.y) )-rb;\n}\n\n\/\/ http:\/\/iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.z) ? dot(p.xz,sc) : length(p.xz);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\n\/\/ http:\/\/iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm\nfloat sdSphere( in vec3 p, in float r ) \n{\n    return length(p)-r;\n}\n\n\/\/ http:\/\/iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    float k0 = length(p\/r);\n    float k1 = length(p\/(r*r));\n    return k0*(k0-1.0)\/k1;\n}\n\n\/\/ http:\/\/iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm\nfloat sdBox( in vec3 p, in vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min( max(max(d.x,d.y),d.z),0.0) + length(max(d,0.0));\n}\n\n\/\/ http:\/\/iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm\nfloat sdArc( in vec2 p, in vec2 scb, in float ra )\n{\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k );\n}\n\n#if 1\n\/\/ http:\/\/research.microsoft.com\/en-us\/um\/people\/hoppe\/ravg.pdf\n\/\/ { dist, t, y (above the plane of the curve, x (away from curve in the plane of the curve))\nvec4 sdBezier( vec3 p, vec3 va, vec3 vb, vec3 vc )\n{\n  vec3 w = normalize( cross( vc-vb, va-vb ) );\n  vec3 u = normalize( vc-vb );\n  vec3 v =          ( cross( w, u ) );\n  \/\/----  \n  vec2 m = vec2( dot(va-vb,u), dot(va-vb,v) );\n  vec2 n = vec2( dot(vc-vb,u), dot(vc-vb,v) );\n  vec3 q = vec3( dot( p-vb,u), dot( p-vb,v), dot(p-vb,w) );\n  \/\/----  \n  float mn = det(m,n);\n  float mq = det(m,q.xy);\n  float nq = det(n,q.xy);\n  \/\/----  \n  vec2  g = (nq+mq+mn)*n + (nq+mq-mn)*m;\n  float f = (nq-mq+mn)*(nq-mq+mn) + 4.0*mq*nq;\n  vec2  z = 0.5*f*vec2(-g.y,g.x)\/dot(g,g);\n\/\/float t = clamp(0.5+0.5*(det(z,m+n)+mq+nq)\/mn, 0.0 ,1.0 );\n  float t = clamp(0.5+0.5*(det(z-q.xy,m+n))\/mn, 0.0 ,1.0 );\n  vec2 cp = m*(1.0-t)*(1.0-t) + n*t*t - q.xy;\n  \/\/----  \n  float d2 = dot(cp,cp);\n  return vec4(sqrt(d2+q.z*q.z), t, q.z, -sign(f)*sqrt(d2) );\n}\n#else\nfloat det( vec3 a, vec3 b, in vec3 v ) { return dot(v,cross(a,b)); }\n\n\/\/ my adaptation to 3d of http:\/\/research.microsoft.com\/en-us\/um\/people\/hoppe\/ravg.pdf\n\/\/ { dist, t, y (above the plane of the curve, x (away from curve in the plane of the curve))\nvec4 sdBezier( vec3 p, vec3 b0, vec3 b1, vec3 b2 )\n{\n    b0 -= p;\n    b1 -= p;\n    b2 -= p;\n    \n    vec3  d21 = b2-b1;\n    vec3  d10 = b1-b0;\n    vec3  d20 = (b2-b0)*0.5;\n\n    vec3  n = normalize(cross(d10,d21));\n\n    float a = det(b0,b2,n);\n    float b = det(b1,b0,n);\n    float d = det(b2,b1,n);\n    vec3  g = b*d21 + d*d10 + a*d20;\n\tfloat f = a*a*0.25-b*d;\n\n    vec3  z = cross(b0,n) + f*g\/dot(g,g);\n    float t = clamp( dot(z,d10-d20)\/(a+b+d), 0.0 ,1.0 );\n    vec3 q = mix(mix(b0,b1,t), mix(b1,b2,t),t);\n    \n    float k = dot(q,n);\n    return vec4(length(q),t,-k,-sign(f)*length(q-n*k));\n}\n#endif\n\n\/\/ http:\/\/iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm\nvec2 sdSegment(vec3 p, vec3 a, vec3 b)\n{\n    vec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ), h );\n}\n\n\/\/ http:\/\/iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm\nvec2 sdSegmentOri(vec2 p, vec2 b)\n{\n\tfloat h = clamp( dot(p,b)\/dot(b,b), 0.0, 1.0 );\n\treturn vec2( length( p - b*h ), h );\n}\n\n\/\/ http:\/\/iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm\nfloat sdFakeRoundCone(vec3 p, float b, float r1, float r2)\n{\n    float h = clamp( p.y\/b, 0.0, 1.0 );\n    p.y -= b*h;\n\treturn length(p) - mix(r1,r2,h);\n}\n\n\/\/ http:\/\/iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm\nfloat sdCone( in vec3 p, in vec2 c )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n\n  vec2 a = q - c*clamp( (q.x*c.x+q.y*c.y)\/dot(c,c), 0.0, 1.0 );\n  vec2 b = q - c*vec2( clamp( q.x\/c.x, 0.0, 1.0 ), 1.0 );\n  \n  float s = -sign( c.y );\n  vec2 d = min( vec2( dot( a, a ), s*(q.x*c.y-q.y*c.x) ),\n\t\t\t    vec2( dot( b, b ), s*(q.y-c.y)  ));\n  return -sqrt(d.x)*sign(d.y);\n}\n\n\/\/ http:\/\/iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n    p = abs(p);\n    vec2 b = vec2(la,lb);\n    float f = clamp( (ndot(b,b-2.0*p.xz))\/dot(b,b), -1.0, 1.0 );\n\tvec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\n\/\/ http:\/\/iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm\nvec4 opElongate( in vec3 p, in vec3 h )\n{\n    vec3 q = abs(p)-h;\n    return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n\/\/-----------------------------------------------\n\n\/\/ ray-infinite-cylinder intersection\nvec2 iCylinderY( in vec3 ro, in vec3 rd, in float rad )\n{\n\tvec3 oc = ro;\n    float a = dot( rd.xz, rd.xz );\n\tfloat b = dot( oc.xz, rd.xz );\n\tfloat c = dot( oc.xz, oc.xz ) - rad*rad;\n\tfloat h = b*b - a*c;\n\tif( h<0.0 ) return vec2(-1.0);\n    h = sqrt(h);\n\treturn vec2(-b-h,-b+h)\/a;\n}\n\n\/\/ ray-infinite-cone intersection\nvec2 iConeY(in vec3 ro, in vec3 rd, in float k )\n{\n\tfloat a = dot(rd.xz,rd.xz) - k*rd.y*rd.y;\n    float b = dot(ro.xz,rd.xz) - k*ro.y*rd.y;\n    float c = dot(ro.xz,ro.xz) - k*ro.y*ro.y; \n        \n    float h = b*b-a*c;\n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b-h,-b+h)\/a;\n}\n\n\/\/-----------------------------------------------\n\nfloat linearstep(float a, float b, in float x )\n{\n    return clamp( (x-a)\/(b-a), 0.0, 1.0 );\n}\n\nvec2 rot( in vec2 p, in float an )\n{\n    float cc = cos(an);\n    float ss = sin(an);\n    return mat2(cc,-ss,ss,cc)*p;\n}\n\nfloat expSustainedImpulse( float t, float f, float k )\n{\n    return smoothstep(0.0,f,t)*1.1 - 0.1*exp2(-k*max(t-f,0.0));\n}\n\n\/\/-----------------------------------------------\n\nvec3 hash3( uint n ) \n{\n    \/\/ integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    uvec3 k = n * uvec3(n,n*16807U,n*48271U);\n    return vec3( k & uvec3(0x7fffffffU))\/float(0x7fffffff);\n}\n\n\/\/---------------------------------------\n\nfloat noise1( sampler3D tex, in vec3 x )\n{\n    return textureLod(tex,(x+0.5)\/32.0,0.0).x;\n}\nfloat noise1( sampler2D tex, in vec2 x )\n{\n    return textureLod(tex,(x+0.5)\/64.0,0.0).x;\n}\nfloat noise1f( sampler2D tex, in vec2 x )\n{\n    return texture(tex,(x+0.5)\/64.0).x;\n}\nfloat fbm1( sampler3D tex, in vec3 x )\n{\n    float f = 0.0;\n    f += 0.5000*noise1(tex,x); x*=2.01;\n    f += 0.2500*noise1(tex,x); x*=2.01;\n    f += 0.1250*noise1(tex,x); x*=2.01;\n    f += 0.0625*noise1(tex,x);\n    f = 2.0*f-0.9375;\n    return f;\n}\n\nfloat fbm1( sampler2D tex, in vec2 x )\n{\n    float f = 0.0;\n    f += 0.5000*noise1(tex,x); x*=2.01;\n    f += 0.2500*noise1(tex,x); x*=2.01;\n    f += 0.1250*noise1(tex,x); x*=2.01;\n    f += 0.0625*noise1(tex,x);\n    f = 2.0*f-0.9375;\n    return f;\n}\nfloat fbm1f( sampler2D tex, in vec2 x )\n{\n    float f = 0.0;\n    f += 0.5000*noise1f(tex,x); x*=2.01;\n    f += 0.2500*noise1f(tex,x); x*=2.01;\n    f += 0.1250*noise1f(tex,x); x*=2.01;\n    f += 0.0625*noise1f(tex,x);\n    f = 2.0*f-0.9375;\n    return f;\n}\nfloat bnoise( in float x )\n{\n    float i = floor(x);\n    float f = fract(x);\n    float s = sign(fract(x\/2.0)-0.5);\n    float k = 0.5+0.5*sin(i);\n    return s*f*(f-1.0)*((16.0*k-4.0)*f*(f-1.0)-1.0);\n}\n\nvec3 fbm13( in float x, in float g )\n{    \n    vec3 n = vec3(0.0);\n    float s = 1.0;\n    for( int i=0; i<6; i++ )\n    {\n        n += s*vec3(bnoise(x),bnoise(x+13.314),bnoise(x+31.7211));\n        s *= g;\n        x *= 2.01;\n        x += 0.131;\n    }\n    return n;\n}\n\n\n\/\/--------------------------------------------------\n\/\/const float X1 = 1.6180339887498948; const float H1 = float( 1.0\/X1 );\n\/\/const float X2 = 1.3247179572447460; const vec2  H2 = vec2(  1.0\/X2, 1.0\/(X2*X2) );\n\/\/const float X3 = 1.2207440846057595; const vec3  H3 = vec3(  1.0\/X3, 1.0\/(X3*X3), 1.0\/(X3*X3*X3) );\n  const float X4 = 1.1673039782614187; const vec4  H4 = vec4(  1.0\/X4, 1.0\/(X4*X4), 1.0\/(X4*X4*X4), 1.0\/(X4*X4*X4*X4) );\n\n\/\/--------------------------------------\nmat3 calcCamera( in float time, out vec3 oRo, out float oFl )\n{\n    vec3 ta = vec3( 0.0, -0.3, 0.0 );\n    vec3 ro = vec3( -0.5563, -0.2, 2.7442 );\n    float fl = 1.7;\n#if 0\n    vec3 fb = fbm13( 0.2*time, 0.5 );\n    ta += 0.025*fb;\n    float cr = -0.01 + 0.006*fb.z;\n#else\n    vec3 fb1 = fbm13( 0.15*time, 0.50 );\n    ro.xyz += 0.010*fb1.xyz;\n    vec3 fb2 = fbm13( 0.33*time, 0.65 );\n    fb2 = fb2*fb2*sign(fb2);\n    ta.xy += 0.005*fb2.xy;\n    float cr = -0.01 + 0.002*fb2.z;\n#endif\n    \n    \/\/ camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(cr),cos(cr),0.0) ) );\n    vec3 vv =          ( cross(uu,ww));\n    \n    oRo = ro;\n    oFl = fl;\n\n    return mat3(uu,vv,ww);\n}\n\n#define ZERO min(iFrame,0)\n#define ZEROU min(uint(iFrame),0u)\n",
            "name": "Common",
            "description": "",
            "type": "common"
        },
        {
            "inputs": [
                {
                    "id": "4sf3Rn",
                    "filepath": "\/media\/a\/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png",
                    "previewfilepath": "\/media\/ap\/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png",
                    "type": "texture",
                    "channel": 2,
                    "sampler": {
                        "filter": "mipmap",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "Xsf3zn",
                    "filepath": "\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
                    "previewfilepath": "\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
                    "type": "texture",
                    "channel": 3,
                    "sampler": {
                        "filter": "mipmap",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "4sfGRr",
                    "filepath": "\/media\/a\/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin",
                    "previewfilepath": "\/media\/ap\/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin",
                    "type": "volume",
                    "channel": 0,
                    "sampler": {
                        "filter": "mipmap",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 1,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dXGR8",
                    "channel": 0
                }
            ],
            "code": "\/\/ Created by inigo quilez - iq\/2020\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\/\/ Renders the background (trees, ground, river and bridge). The\n\/\/ render uses a super basic implementation of Temporal\n\/\/ Antialiasing (TAA) without color clipping or anything,\n\/\/ but it's enough to stabilize aliasing. It also outputs\n\/\/ the deph buffer into the alpha channel for the next pass\n\/\/ (\"Buffer B\") to consume and do proper Depth Of Field.\n\n\n\/\/ The ground - it's a simple sine field.\n\/\/\nfloat sdGround( in vec3 pos )\n{\n    pos -= vec3(120.0,-35.0,-700.0);\n    pos.x += -150.0;\n    pos.z += 30.0*sin(1.00*pos.x*0.016+0.0);\n    pos.z += 10.0*sin(2.20*pos.x*0.016+1.0);\n    pos.y += 20.0*sin(0.01*pos.x+2.0)*sin(0.01*pos.z+2.0);\n    \n    return sdBox(pos,vec3(1000.0,2.0,400.0))-10.0;\n}\n\n\/\/ The bridge. It's made of five boxes (repeated forever\n\/\/ with a periodic - see the mod() calls), whcih are\n\/\/ distorted with gentle sine waves so they don't look\n\/\/ like geometrically perfect. \n\/\/\nvec2 sdBridge( in vec3 pos )\n{\n    float issnow = 0.0;\n    vec3 opos = pos;\n    pos.x  += 50.0*sin(pos.z*0.01)+10.0;\n    pos.xz += 0.05*sin(pos.yx+vec2(0,2));                \n    vec3 sos = vec3(abs(pos.x),pos.yz);\n    float h = -16.0;\n    \n    \/\/ floor\n    vec3 ros = vec3(sos.xy,mod(sos.z+2.0,4.0)-2.0 )-vec3(0.0,h,0.0);\n    float d = sdBox(ros,vec3(20.0,1.0,1.85));\n\n    \/\/ thick bars\n    ros = vec3(sos.xy,mod(sos.z+5.0,10.0)-5.0 )-vec3(20.0,h+5.0-0.4,0.0);\n    float d2 = sdBox(ros,vec3(1.2,5.0,0.7)+0.1)-0.1;\n    d = min(d,d2);\n    \n    #if 0\n    {\n    float id = floor((sos.z+5.0)\/10.0);\n    ros = vec3(sos.xy,mod(sos.z+5.0,10.0)-5.0 )-vec3(20.0,h-0.4,0.0);\n\tros-=vec3(-1.5,1,0);\n    ros.x -= ros.y;\n    float ra = 0.5 + 0.5*sin(float(id)+4.0);\n    float d2 = sdEllipsoid(ros,vec3(2.0,2.0,1.3)*ra);\n    issnow = clamp( 0.5+0.5*(d-d2)\/0.7, 0.0, 1.0 );\n    d = smin(d,d2,0.7);\n    }\n    #endif\n\n    \/\/ small bars\n    ros = vec3(sos.xy,mod(sos.z+1.25,2.5)-1.25 )-vec3(20.0,h+5.0,0.0);\n    d2 = sdBox(ros,vec3(0.2,5.0,0.2))-0.05;\n    d = min(d,d2);\n    \n    \/\/ handle\n    d2 = sdBox(sos-vec3(20.0,h+10.0,0.0),vec3(0.5,0.1,300.0))-0.4;\n    d = min(d,d2);\n    \n    \/\/ foot bar\n    d2 = sdBox(sos-vec3(20.0,h+2.4,0.0),vec3(0.7,0.1,300.0))-0.2;\n    d = min(d,d2);\n    \n\treturn vec2(d,issnow);\n}\n\n\/\/ The trees are ultra basic and look really bad without\n\/\/ defocus, but all I needed was something like looked like\n\/\/ pine trees so the viewers would complete the picture in\n\/\/ their heads. Only four trees are evaluated at any time,\n\/\/ and there inifinte many of them. Yet these four trees\n\/\/ consume most of the rendering budget for the scene\n\/\/\nvec3 sdForest( in vec3 pos, float tmin )\n{\n    float shid = 0.0;\n    \n    const float per = 200.0;\n    \n    pos -= vec3(120.0,-16.0,-600.0);\n        \n    vec3 vos = pos\/per;\n    vec3 ip = floor(vos);\n    vec3 fp = fract(vos);\n    \n    bool hit = false;\n    float d = tmin;\n    float occ = 1.0;\n    \n    for( int j=0; j<=1; j++ )\n    for( int i=0; i<=1; i++ )\n    {\n        vec2 of = vec2(i,j);\n        ivec2 tid = ivec2(ip.xz + of );\n        tid.y = min(tid.y,-0);\n        \n        uint treeId = uint(tid.y)*17u+uint(tid.x)*1231u;\n        \n        vec3 rf =  hash3( uint(treeId) )-0.5;\n        \n        vec3 ros = vec3( (float(tid.x)+rf.x)*per,\n                         0.0,\n                         (float(tid.y)+rf.y)*per );\n\n\n        float hei = 1.0 + 0.2*sin( float(tid.x*115+tid.y*221) );\n        hei *= (tid.y==0) ? 1.0 : 1.5;\n          \n        hei *= 275.0;\n\n        float d2 = sdFakeRoundCone( pos-ros,hei,7.0,1.0);\n        if( d2<d)\n        {\n            d = d2;\n            hit = false;\n        }\n        \n        if( d2-150.0>d ) continue;\n        \n        vec2 qos = pos.xz - ros.xz;\n        float an = atan(qos.x,qos.y);\n        float ra = length(qos);\n        float vv = 0.3*sin(11.0*an) + 0.2*sin(28.0*an)+ 0.10*sin(53.0*an+4.0);\n\n        \n        \/\/ trick - only evalute 4 closest of the 10 cones\n        int segid = int(floor(16.0*(pos.y-ros.y)\/hei));\n        for( uint k=ZEROU; k<4u; k++ )\n        {\n            uint rk = uint( min(max(segid+int(k),5),15) );\n            \n            float h = float(rk)\/15.0;\n            \n            vec3 ran = hash3( treeId*24u+rk );\n            \n            h += 0.1*(1.0-h)*(ran.z-0.5) + 0.05*sin(1.0*an);\n\n            ros.y = h*hei;\n            \n            float hh = 0.5 + 0.5*(1.0-h);\n            float ww = 0.1 + 0.9*(1.0-h);\n            hh *= 0.7+0.2*ran.x;\n            ww *= 0.9+0.2*ran.y;\n            hh *= 1.0+0.2*vv;\n            \n            vec2 rrr = vec2( ra, pos.y-ros.y );\n            vec2 tmp = sdSegmentOri( rrr,vec2(120.0*ww,-100.0*hh));\n            float d2 = tmp.x-mix(1.0,vv,tmp.y);\n            if( d2<d )\n            {\n                hit = true;\n                d = d2;\n                shid = rf.z;\n                occ = tmp.y * clamp(ra\/100.0+h,0.0,1.0);\n            }\n        }\n    }\n    \n    if( hit )\n    {\n        float dis = 0.5+0.5*fbm1(iChannel0,0.1*pos*vec3(1,0.3,1));\n        d -= 8.0*dis-4.0;\n        \/\/occ = dis;\n    }\n    \n\treturn vec3(d,shid,occ);\n}\n\n\n\/\/ The SDF of the landscape is made by combining ground, \n\/\/ bridge, river and trees. \n\/\/\nvec4 map( in vec3 pos, in float time, out float outMat, out vec3 uvw )\n{\n    pos.xz = rot(pos.xz,0.2);\n\n    vec4 res = vec4(pos.y+36.0,0,0,0);    \n    \n    outMat = 1.0;\n    uvw = pos;\n    \n    \/\/-------\n    {\n    vec2 d2 = sdBridge(pos);\n    if( d2.x<res.x )\n    {\n        res.xy = d2;\n        outMat = 2.0;\n    }\n    }\n    \/\/-------\n    float d = sdGround(pos);\n    if( d<res.x )\n    {\n        res.x = d;\n        outMat = 4.0;\n    }\n    \/\/-------\n    float bb = pos.z+450.0;\n    if( bb<d )\n    {\n    vec3 d2 = sdForest(pos,d);\n    if( d2.x<res.x )\n    {\n        res.x = d2.x;\n        res.y = d2.y;\n        res.z = d2.z;\n        outMat = 3.0;\n    }\n    }\n    \n    return res;\n}\n\n\/\/ The landscape SDF again, but with extra high frequency\n\/\/ modeling detail. While the previous one is used for\n\/\/ raymarching and shadowing, this one is used for normal\n\/\/ computation. This separation is conceptually equivalent\n\/\/ to decoupling detail from base geometry with \"normal\n\/\/ maps\", but done in 3D and with SDFs, which is way simpler\n\/\/ and can be done corretly (something rarely seen in 3D\n\/\/ engines) without any complexity.\n\/\/\nfloat mapD( in vec3 pos, in float time )\n{\n    float matID; vec3 kk2;\n    float d = map(pos,time,matID,kk2).x;\n    \n    if( matID<1.5 ) \/\/ water\n    {\n        float g = 0.5 + 0.5*fbm1f(iChannel2,0.02*pos.xz);\n        g = g*g;\n    \tfloat f = 0.5 + 0.5*fbm1f(iChannel2,pos.xz);\n        d -= g*12.0*(0.5+0.5*f*g*2.0);\n    }\n    else if( matID<2.5 ) \/\/ bridge\n    {\n    \td -= 0.07*(0.5+0.5*fbm1(iChannel0, pos*vec3(8,1,8) ));\n    }\n    else if( matID<4.5 ) \/\/ ground\n    {\n    \tfloat dis = fbm1(iChannel0,0.1*pos);\n    \td -= 3.0*dis;\n    }\n    \n    return d;\n}\n\n\/\/ Computes the normal of the girl's surface (the gradient\n\/\/ of the SDF). The implementation is weird because of the\n\/\/ technicalities of the WebGL API that forces us to do\n\/\/ some trick to prevent code unrolling. More info here:\n\/\/\n\/\/ http:\/\/iquilezles.org\/www\/articles\/normalsSDF\/normalsSDF.htm\n\/\/\nvec3 calcNormal( in vec3 pos, in float time, in float t )\n{\n    float eps = 0.001*t;\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*mapD( pos + e.xyy*eps,time ) + \n\t\t\t\t\t  e.yyx*mapD( pos + e.yyx*eps,time ) + \n\t\t\t\t\t  e.yxy*mapD( pos + e.yxy*eps,time ) + \n\t\t\t\t\t  e.xxx*mapD( pos + e.xxx*eps,time ) );\n#else\n    vec4 n = vec4(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec4 s = vec4(pos, 0.0);\n        s[i] += eps;\n        n[i] = mapD(s.xyz, time);\n        \/\/if( n.x+n.y+n.z+n.w>100.0 ) break;\n    }\n    return normalize(n.xyz-n.w);\n#endif    \n}\n\n\/\/ Compute soft shadows for a given light, with a single ray\n\/\/ insead of using montecarlo integration or shadowmap\n\/\/ blurring. More info here:\n\/\/\n\/\/ http:\/\/iquilezles.org\/www\/articles\/rmshadows\/rmshadows.htm\n\/\/\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, in float time, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    \n    \/\/ first things first - let's do a bounding volume test\n    float tm = (480.0-ro.y)\/rd.y; if( tm>0.0 ) tmax=min(tmax,tm);\n    \n    \/\/ raymarch and track penumbra\n    for( int i=ZERO; i<128; i++ )\n    {\n        float kk; vec3 kk2;\n\t\tfloat h = map( ro + rd*t, time, kk, kk2 ).x;\n        res = min( res, k*h\/t );\n        t += clamp( h, 0.05, 25.0 );\n        if( res<0.002 || t>tmax ) break;\n    }\n    return max( res, 0.0 );\n}\n\n\/\/ Computes convexity for our landscape SDF, which can be\n\/\/ used to approximate ambient occlusion. More info here:\n\/\/\n\/\/ https:\/\/iquilezles.org\/www\/material\/nvscene2008\/rwwtt.pdf\n\/\/\nfloat calcOcclusion( in vec3 pos, in vec3 nor, in float time, float sca, in vec2 px )\n{\n    float kk; vec3 kk2;\n\tfloat ao = 0.0;\n    float off = textureLod(iChannel3,px\/256.0,0.0).x;\n    vec4 k = vec4(0.7012912,0.3941462,0.8294585,0.109841)+off;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tk = fract(k + H4);\n        vec3 ap = normalize(-1.0+2.0*k.xyz);\n        float h = k.w*1.0*sca;\n        ap = (nor+ap)*h;\n        float d = map( pos+ap, time, kk, kk2 ).x;\n        ao += max(0.0,h-d);\n        if( ao>10000.0 ) break;\n    }\n\tao \/= 16.0;\n    return clamp( 1.0-ao*2.0\/sca, 0.0, 1.0 );\n}\n\n\/\/ Computes the intersection point between our landscape SDF\n\/\/ and a ray (coming form the camera in this case). It's a\n\/\/ traditional and basic\/uncomplicated SDF raymarcher. More\n\/\/ info here:\n\/\/\n\/\/ https:\/\/iquilezles.org\/www\/material\/nvscene2008\/rwwtt.pdf\n\/\/\nvec2 intersect( in vec3 ro, in vec3 rd, in float time, out vec3 cma, out vec3 uvw )\n{\n    cma = vec3(0.0);\n    uvw = vec3(0.0);\n    float matID = -1.0;\n\n    float tmax = 2500.0;\n    float t = 15.0;\n\t\/\/ bounding volume test first    \n    float tm = (480.0-ro.y)\/rd.y; if( tm>0.0 ) tmax=min(tmax,tm);\n    \n    \/\/ raymarch\n    for( int i=ZERO; i<1024; i++ )\n    {\n        vec3 pos = ro + t*rd;\n\n        float tmp;\n        vec4 h = map(pos,time,tmp,uvw);\n        if( (h.x)<0.0002*t )\n        {\n            cma = h.yzw;\n            matID = tmp;\n            break;\n        }\n        t += h.x*0.8;\n        if( t>tmax ) break;\n    }\n\n    return vec2(t,matID);\n}\n\n\/\/ Renders the landscape. It finds the ray-landscape\n\/\/ intersection point, computes the normal at the\n\/\/ intersection point, computes the ambient occlusion\n\/\/ approximation, does per material setup (color,\n\/\/ specularity, and paints some fake occlusion), and\n\/\/ finally does the lighting computations themseleves.\n\nvec4 renderBackground( in vec2 p, in vec3 ro, in vec3 rd, in float time, in vec2 px )\n{\n    \/\/ sky color\n    vec3 col = vec3(0.45,0.75,1.1) + rd.y*0.5;\n    vec3 fogcol = vec3(0.3,0.5,1.0)*0.25;\n    col = mix( col, fogcol, exp2(-8.0*max(rd.y,0.0)) );\n    \n    \/\/ -------------------------------\n    \/\/ find ray-landscape intersection\n    \/\/ -------------------------------\n    float tmin = 1e20;\n    vec3 cma, uvw;\n    vec2 tm = intersect( ro, rd, time, cma, uvw);\n\n    \/\/ --------------------------\n    \/\/ shading\/lighting\t\n    \/\/ --------------------------\n    if( tm.y>0.0 )\n    {\n        tmin = tm.x;\n        \n        vec3 pos = ro + tmin*rd;\n        vec3 nor = calcNormal(pos, time, tmin);\n\n        col = cma;\n\n        float ks = 1.0;\n        float se = 16.0;\n        float focc = 1.0;\n        float occs = 1.0;\n        float snow = 1.0;\n        \n    \t\/\/ --------------------------\n        \/\/ materials\n    \t\/\/ --------------------------\n\n        \/\/ water\n        if( tm.y<1.5 )\n        {\n            col = vec3(0.1,0.2,0.3);\n            occs = 20.0;\n        }\n        \/\/ bridge\n        else if( tm.y<2.5 )\n        {\n            float f = 0.5 + 0.5*fbm1(iChannel0,pos*vec3(8,1,8));\n            ks = f*8.0;\n            se = 12.0;\n            col = mix(vec3(0.40,0.22,0.15)*0.63,\n                      vec3(0.35,0.07,0.02)*0.2,f);\n            f = fbm1(iChannel0,pos*0.5);\n            col *= 1.0 + 1.1*f*vec3(0.5,1.0,1.5);\n          \tcol *= 1.0 + 0.2*cos(cma.y*23.0+vec3(0,0.2,0.5));\n            \n            float g = 0.5 + 0.5*fbm1(iChannel0,0.21*pos);\n            g -= 0.8*nor.x*nor.x;\n            snow *= smoothstep(0.2,0.6,g);\n        }\n        \/\/ forest\n        else if( tm.y<3.5 )\n        {\n            col = vec3(0.2,0.1,0.02)*0.7;\n            focc = cma.y*(0.7+0.3*nor.y);\n            occs = 100.0;\n        }\n        \/\/ ground\n        else if( tm.y<4.5 )\n        {\n            col = vec3(0.7,0.3,0.1)*0.12;\n            float d = smoothstep(1.0,6.0,pos.y-(-36.0));\n            col *= 0.2+0.8*d;\n            occs = 100.0;\n            snow = 1.0;\n        }\n\n        float fre = clamp(1.0+dot(nor,rd),0.0,1.0);\n        float occ = focc*calcOcclusion( pos, nor, time, occs, px );\n\n        snow *= smoothstep(0.25,0.3,nor.y);\n        if( abs(tm.y-2.0)<0.5 )\n        {\n            snow = max(snow,clamp(1.0-occ*occ*3.5,0.0,1.0));\n            snow = max(snow,cma.x);\n        }\n\n        col = mix( col, vec3(0.7,0.75,0.8)*0.6, snow);\n\t\t\n\t\t\n    \t\/\/ --------------------------\n        \/\/ lighting\n    \t\/\/ --------------------------\n        vec3 lin = vec3(0.0);\n\n        vec3  lig = normalize(vec3(0.5,0.4,0.6));\n        vec3  hal = normalize(lig-rd);\n        float dif = clamp(dot(nor,lig), 0.0, 1.0 );\n        \/\/float sha = 0.0; if( dif>0.001 ) sha=calcSoftshadow( pos, lig, 0.001, 500.0, time, 8.0 );\n        float sha = calcSoftshadow( pos, lig, 0.001, 500.0, time, 8.0 );\n        dif *= sha;\n        float spe = ks*pow(clamp(dot(nor,hal),0.0,1.0),se)*dif*(0.04+0.96*pow(clamp(1.0+dot(hal,rd),0.0,1.0),5.0));\n        vec3  amb = occ*vec3(0.55+0.45*nor.y);\n\n        lin += col*vec3(0.4,0.7,1.1)*amb;\n        lin += col*1.4*vec3(2.3,1.5,1.1)*dif;\n        lin += spe*2.0;\n        lin += snow*vec3(0.21,0.35,0.7)*fre*fre*fre*(0.5+0.5*dif*amb)*focc;\n\n        #if 1\n        if( abs(tm.y-2.0)<0.5 )\n        {\n\t\t\tfloat dif = max(0.2+0.8*dot(nor,vec3(-1,-0.3,0)),0.0);\n\t\t\tlin += col*vec3(0.58,0.29,0.14)*dif;\n        }\n\t\t#endif\n\t\tcol = lin;\n\n        col = mix( col, vec3(0.3,0.5,1.0)*0.25, 1.0-exp2(-0.0003*tmin) );\n    }\n\n    \/\/ sun flow\n    float glow = max(dot(rd,vec3(0.5,0.4,0.2)),0.0);\n    glow *= glow;\n    col += vec3(6.0,4.0,3.6)*glow*glow;\n\n    return vec4(col,tmin);\n}\n    \n\/\/ The main rendering entry point. Basically it does some\n\/\/ setup or creating the ray that will explore the 3D\n\/\/ scene in search of the landscape for each pixel, does\n\/\/ the rendering of the landscape, and performs the\n\/\/ Temporal Antialiasing before spiting out the color (in\n\/\/ linear space, not gama) and the deph of the scene.\n\/\/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ render\n    vec2 o = hash3( uint(iFrame) ).xy - 0.5;\n    vec2 p = (2.0*(fragCoord+o)-iResolution.xy)\/iResolution.y;\n        \n    float time = 2.0 + iTime;\n    \n    \/\/ skip pixels behind girl\n    #if 1\n    if( length((p-vec2(-0.56, 0.2))\/vec2(0.78,1.0))<0.85 ||\n        length((p-vec2(-0.56,-0.4))\/vec2(1.00,1.0))<0.73)\n    {\n        fragColor = vec4( 0.55,0.55,0.65,1e20 ); return;\n    }\n    #endif\n\n    \/\/ camera movement\t\n    vec3 ro; float fl;\n    mat3 ca = calcCamera( time, ro, fl );\n    vec3 rd = ca * normalize( vec3((p-vec2(-0.52,0.12))\/1.1,fl));\n\n    vec4 tmp = renderBackground(p,ro,rd,time,fragCoord);\n    vec3 col = tmp.xyz;\n\n    \/\/---------------------------------------------------------------\n\t\/\/ reproject from previous frame and average (cheap TAA, kind of)\n    \/\/---------------------------------------------------------------\n    \n    mat4 oldCam = mat4( textureLod(iChannel1,vec2(0.5,0.5)\/iResolution.xy, 0.0),\n                        textureLod(iChannel1,vec2(1.5,0.5)\/iResolution.xy, 0.0),\n                        textureLod(iChannel1,vec2(2.5,0.5)\/iResolution.xy, 0.0),\n                        0.0, 0.0, 0.0, 1.0 );\n    bool oldStarted = textureLod(iChannel1,vec2(3.5,0.5)\/iResolution.xy, 0.0).x>0.5;\n    \n    \/\/ world space\n    vec4 wpos = vec4(ro + rd*tmp.w,1.0);\n    \/\/ camera space\n    vec3 cpos = (wpos*oldCam).xyz; \/\/ note inverse multiply\n    \/\/ ndc space\n    vec2 npos = fl * cpos.xy \/ cpos.z;\n    \/\/ undo composition hack\n    npos = npos*1.1+vec2(-0.52,0.12); \n    \/\/ screen space\n    vec2 spos = 0.5 + 0.5*npos*vec2(iResolution.y\/iResolution.x,1.0);\n    \/\/ undo dither\n    spos -= o\/iResolution.xy;\n\t\/\/ raster space\n    vec2 rpos = spos * iResolution.xy;\n    \n    if( rpos.y<1.0 && rpos.x<4.0 )\n    {\n    }\n\telse\n    {\n        vec3 ocol = textureLod( iChannel1, spos, 0.0 ).xyz;\n    \tif( !oldStarted ) ocol = col;\n        col = mix( ocol, col, 0.1 );\n    }\n\n    \/\/----------------------------------\n    bool started = textureSize(iChannel0,0).x>=2 &&\n                   textureSize(iChannel2,0).x>=2 &&\n                   textureSize(iChannel3,0).x>=2;\n                           \n\tif( fragCoord.y<1.0 && fragCoord.x<4.0 )\n    {\n        if( abs(fragCoord.x-3.5)<0.5 ) fragColor = vec4( started?1.0:0.0, 0.0, 0.0, 0.0 );\n        if( abs(fragCoord.x-2.5)<0.5 ) fragColor = vec4( ca[2], -dot(ca[2],ro) );\n        if( abs(fragCoord.x-1.5)<0.5 ) fragColor = vec4( ca[1], -dot(ca[1],ro) );\n        if( abs(fragCoord.x-0.5)<0.5 ) fragColor = vec4( ca[0], -dot(ca[0],ro) );\n    }\n    else\n    {\n        fragColor = vec4( col, tmp.w );\n    }\n    \n    if( !started ) fragColor = vec4(0.0);\n}",
            "name": "Buffer A",
            "description": "",
            "type": "buffer"
        },
        {
            "inputs": [
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "XsXGR8",
                    "channel": 0
                }
            ],
            "code": "\/\/ Created by inigo quilez - iq\/2020\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ DOF on the background. It's a basic gather approach, where each\n\/\/ pixel's neighborhood gets scanned and the Circle of Confusion\n\/\/ computed for each one of those neighbor pixels. If the distance\n\/\/ to the pixel is smaller than the Circle of Confusion, the current\n\/\/ pixel gets a contribution from it with a weight that is inversely\n\/\/ proportional to the area of the Circle of Confusion, to conserve\n\/\/ energy.\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec4 ref = texelFetch( iChannel0, ivec2(fragCoord),0);\n    \n    vec2 q = fragCoord\/iResolution.xy;\n\n    vec4 acc = vec4(0.0);\n    const int N = 9;\n\tfor( int j=-N; j<=N; j++ )\n    for( int i=-N; i<=N; i++ )\n    {\n        vec2 off = vec2(float(i),float(j));\n        \n        vec4 tmp = texture( iChannel0, q + off\/vec2(1280.0,720.0) ); \n\n        float coc = 0.01 + 9.0*(1.0-1.0\/(1.0+0.01*abs(tmp.w)));\n        \n        if( dot(off,off) < coc*coc )\n        {\n            float w = 1.0\/(coc*coc); \n            acc += vec4(tmp.xyz*w,w);\n        }\n    }\n    vec3 col = acc.xyz \/ acc.w;\n\n    fragColor = vec4(col,ref.w);\n}\n",
            "name": "Buffer B",
            "description": "",
            "type": "buffer"
        }
    ]
}