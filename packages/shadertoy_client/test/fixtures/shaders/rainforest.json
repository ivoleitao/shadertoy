{
    "ver": "0.1",
    "info": {
        "id": "4ttSWf",
        "date": "1482384986",
        "viewed": 135770,
        "name": "Rainforest",
        "username": "iq",
        "description": "Another terrain, with cheap trees made of spheres with some noise. Not complete really, but I must move on. Analytic normals for terrain, tree envelope intersection, analytical normals for clouds, and other tricks involved. Art composed to camera as usual",
        "likes": 657,
        "published": 3,
        "flags": 32,
        "tags": [
            "procedural",
            "3d",
            "raymarching",
            "reprojection"
        ],
        "hasliked": 0
    },
    "renderpass": [
        {
            "inputs": [
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dfGRr",
                    "channel": 0
                }
            ],
            "code": "\/\/ Created by inigo quilez - iq\/2016\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ You can buy a metal print of this shader here:\n\/\/ https:\/\/www.redbubble.com\/i\/metal-print\/Rainforest-by-InigoQuilez\/39843511.0JXQP\n\n\n\n\/\/ Normals are analytical (true derivatives) for the terrain and for the clouds, that \n\/\/ includes the noise, the fbm and the smoothsteps involved chain derivatives correctly.\n\/\/\n\/\/ See here for more info: http:\/\/iquilezles.org\/www\/articles\/morenoise\/morenoise.htm\n\/\/\n\/\/ Lighting and art composed for this shot\/camera\n\/\/\n\/\/ The trees are really cheap (ellipsoids with noise), but they kind of do the job in\n\/\/ distance and low image resolutions.\n\/\/\n\/\/ I used some cheap reprojection technique to smooth out the render, although it creates\n\/\/ halows and blurs the image way too much (I don't the time now to do the tricks used in \n\/\/ TAA). Enable the STATIC_CAMERA define to see a sharper image.\n\/\/\n\/\/ Lastly, it runs very slow, so I had to make a youtube capture, sorry for that!\n\/\/ \n\/\/ https:\/\/www.youtube.com\/watch?v=VqYROPZrDeU\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord\/iResolution.xy;\n\n    vec3 col = texture( iChannel0, p ).xyz;\n    \/\/vec3 col = texelFetch( iChannel0, ivec2(fragCoord-0.5), 0 ).xyz;\n    \n    col *= 0.5 + 0.5*pow( 16.0*p.x*p.y*(1.0-p.x)*(1.0-p.y), 0.05 );\n         \n    fragColor = vec4( col, 1.0 );\n}\n",
            "name": "Image",
            "description": "",
            "type": "image"
        },
        {
            "inputs": [
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dXGR8",
                    "channel": 0
                }
            ],
            "code": "\/\/ Created by inigo quilez - iq\/2016\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\/\/ Normals are analytical (true derivatives) for the terrain and for the clouds, that \n\/\/ includes the noise, the fbm and the smoothsteps involved chain derivatives correctly.\n\/\/\n\/\/ See here for more info: http:\/\/iquilezles.org\/www\/articles\/morenoise\/morenoise.htm\n\/\/\n\/\/ Lighting and art composed for this shot\/camera\n\/\/\n\/\/ The trees are really cheap (ellipsoids with noise), but they kind of do the job in\n\/\/ distance and low image resolutions.\n\/\/\n\/\/ I used some cheap reprojection technique to smooth out the render, although it creates\n\/\/ halows and blurs the image way too much (I don't have the time now to do the tricks\n\/\/ used in TAA). Enable the STATIC_CAMERA define to see a sharper image.\n\/\/\n\/\/ Lastly, it runs very slow in WebGL (but runs 2x faster in native GL), so I had to make\n\/\/ a youtube capture, sorry for that!\n\/\/ \n\/\/ https:\/\/www.youtube.com\/watch?v=VqYROPZrDeU\n\n\n\/\/#define STATIC_CAMERA\n#define LOWQUALITY\n\n\n\n\/\/==========================================================================================\n\/\/ general utilities\n\/\/==========================================================================================\n\nfloat sdEllipsoidY( in vec3 p, in vec2 r )\n{\n    float k0 = length(p\/r.xyx);\n    float k1 = length(p\/(r.xyx*r.xyx));\n    return k0*(k0-1.0)\/k1;\n}\n\n\/\/ return smoothstep and its derivative\nvec2 smoothstepd( float a, float b, float x)\n{\n\tif( x<a ) return vec2( 0.0, 0.0 );\n\tif( x>b ) return vec2( 1.0, 0.0 );\n    float ir = 1.0\/(b-a);\n    x = (x-a)*ir;\n    return vec2( x*x*(3.0-2.0*x), 6.0*x*(1.0-x)*ir );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\/\/==========================================================================================\n\/\/ hashes\n\/\/==========================================================================================\n\nfloat hash1( vec2 p )\n{\n    p  = 50.0*fract( p*0.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat hash1( float n )\n{\n    return fract( n*17.0*fract( n*0.3183099 ) );\n}\n\nvec2 hash2( float n ) { return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123)); }\n\n\nvec2 hash2( vec2 p ) \n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    p = p*k + k.yx;\n    return fract( 16.0 * k*fract( p.x*p.y*(p.x+p.y)) );\n}\n\n\/\/==========================================================================================\n\/\/ noises\n\/\/==========================================================================================\n\n\/\/ value noise, and its analytical derivatives\nvec4 noised( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n\n    float n = p.x + 317.0*p.y + 157.0*p.z;\n    \n    float a = hash1(n+0.0);\n    float b = hash1(n+1.0);\n    float c = hash1(n+317.0);\n    float d = hash1(n+318.0);\n    float e = hash1(n+157.0);\n\tfloat f = hash1(n+158.0);\n    float g = hash1(n+474.0);\n    float h = hash1(n+475.0);\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z), \n                      2.0* du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\n                                      k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\n                                      k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    \n    float n = p.x + 317.0*p.y + 157.0*p.z;\n    \n    float a = hash1(n+0.0);\n    float b = hash1(n+1.0);\n    float c = hash1(n+317.0);\n    float d = hash1(n+318.0);\n    float e = hash1(n+157.0);\n\tfloat f = hash1(n+158.0);\n    float g = hash1(n+474.0);\n    float h = hash1(n+475.0);\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z);\n}\n\nvec3 noised( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    \n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec2 du = 30.0*w*w*(w*(w-2.0)+1.0);\n    \n    float a = hash1(p+vec2(0,0));\n    float b = hash1(p+vec2(1,0));\n    float c = hash1(p+vec2(0,1));\n    float d = hash1(p+vec2(1,1));\n\n    float k0 = a;\n    float k1 = b - a;\n    float k2 = c - a;\n    float k4 = a - b - c + d;\n\n    return vec3( -1.0+2.0*(k0 + k1*u.x + k2*u.y + k4*u.x*u.y), \n                      2.0* du * vec2( k1 + k4*u.y,\n                                      k2 + k4*u.x ) );\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    \n#if 0\n    p *= 0.3183099;\n    float kx0 = 50.0*fract( p.x );\n    float kx1 = 50.0*fract( p.x+0.3183099 );\n    float ky0 = 50.0*fract( p.y );\n    float ky1 = 50.0*fract( p.y+0.3183099 );\n\n    float a = fract( kx0*ky0*(kx0+ky0) );\n    float b = fract( kx1*ky0*(kx1+ky0) );\n    float c = fract( kx0*ky1*(kx0+ky1) );\n    float d = fract( kx1*ky1*(kx1+ky1) );\n#else\n    float a = hash1(p+vec2(0,0));\n    float b = hash1(p+vec2(1,0));\n    float c = hash1(p+vec2(0,1));\n    float d = hash1(p+vec2(1,1));\n#endif\n    \n    return -1.0+2.0*( a + (b-a)*u.x + (c-a)*u.y + (a - b - c + d)*u.x*u.y );\n}\n\n\/\/==========================================================================================\n\/\/ fbm constructions\n\/\/==========================================================================================\n\nconst mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                      -0.80,  0.36, -0.48,\n                      -0.60, -0.48,  0.64 );\nconst mat3 m3i = mat3( 0.00, -0.80, -0.60,\n                       0.80,  0.36, -0.48,\n                       0.60, -0.48,  0.64 );\nconst mat2 m2 = mat2(  0.80,  0.60,\n                      -0.60,  0.80 );\nconst mat2 m2i = mat2( 0.80, -0.60,\n                       0.60,  0.80 );\n\n\/\/------------------------------------------------------------------------------------------\n\nfloat fbm_4( in vec3 x )\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*m3*x;\n    }\n\treturn a;\n}\n\nvec4 fbmd_8( in vec3 x )\n{\n    float f = 1.92;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    vec3  d = vec3(0.0);\n    mat3  m = mat3(1.0,0.0,0.0,\n                   0.0,1.0,0.0,\n                   0.0,0.0,1.0);\n    for( int i=0; i<7; i++ )\n    {\n        vec4 n = noised(x);\n        a += b*n.x;          \/\/ accumulate values\t\t\n        d += b*m*n.yzw;      \/\/ accumulate derivatives\n        b *= s;\n        x = f*m3*x;\n        m = f*m3i*m;\n    }\n\treturn vec4( a, d );\n}\n\nfloat fbm_9( in vec2 x )\n{\n    float f = 1.9;\n    float s = 0.55;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<9; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*m2*x;\n    }\n\treturn a;\n}\n\nvec3 fbmd_9( in vec2 x )\n{\n    float f = 1.9;\n    float s = 0.55;\n    float a = 0.0;\n    float b = 0.5;\n    vec2  d = vec2(0.0);\n    mat2  m = mat2(1.0,0.0,0.0,1.0);\n    for( int i=0; i<9; i++ )\n    {\n        vec3 n = noised(x);\n        a += b*n.x;          \/\/ accumulate values\t\t\n        d += b*m*n.yz;       \/\/ accumulate derivatives\n        b *= s;\n        x = f*m2*x;\n        m = f*m2i*m;\n    }\n\treturn vec3( a, d );\n}\n\nfloat fbm_4( in vec2 x )\n{\n    float f = 1.9;\n    float s = 0.55;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*m2*x;\n    }\n\treturn a;\n}\n\n\/\/==========================================================================================\n\n#define ZERO (min(iFrame,0))\n\n\n\/\/==========================================================================================\n\/\/ specifics to the actual painting\n\/\/==========================================================================================\n\n\n\/\/------------------------------------------------------------------------------------------\n\/\/ global\n\/\/------------------------------------------------------------------------------------------\n\nconst vec3  kSunDir = vec3(-0.624695,0.468521,-0.624695);\nconst float kMaxTreeHeight = 2.0;\n\nvec3 fog( in vec3 col, float t )\n{\n    vec3 fogCol = vec3(0.4,0.6,1.15);\n    return mix( col, fogCol, 1.0-exp(-0.000001*t*t) );\n}\n\n\n\/\/------------------------------------------------------------------------------------------\n\/\/ clouds\n\/\/------------------------------------------------------------------------------------------\n\nvec4 cloudsMap( in vec3 pos )\n{\n    vec4 n = fbmd_8(pos*0.003*vec3(0.6,1.0,0.6)-vec3(0.1,1.9,2.8));\n    vec2 h  =  smoothstepd( -60.0, 10.0, pos.y ) -  smoothstepd( 10.0, 500.0, pos.y );\n    h.x = 2.0*n.x + h.x - 1.3;\n    return vec4( h.x, 2.0*n.yzw*vec3(0.6,1.0,0.6)*0.003 + vec3(0.0,h.y,0.0)  );\n}\n\nfloat cloudsShadow( in vec3 ro, in vec3 rd, float tmin, float tmax )\n{\n\tfloat sum = 0.0;\n\n    \/\/ bounding volume!!\n    float tl = ( -10.0-ro.y)\/rd.y;\n    float th = ( 300.0-ro.y)\/rd.y;\n    if( tl>0.0 ) tmin = max( tmin, tl );\n    if( th>0.0 ) tmax = min( tmax, th );\n\n\tfloat t = tmin;\n\tfor(int i=ZERO; i<64; i++)\n    { \n        vec3  pos = ro + t*rd; \n        vec4  denGra = cloudsMap( pos ); \n        float den = denGra.x;\n        float dt = max(0.2,0.02*t);\n        if( den>0.001 ) \n        { \n            float alp = clamp(den*0.3*min(dt,tmax-t-dt),0.0,1.0);\n            sum = sum + alp*(1.0-sum);\n        }\n        else \n        {\n            dt *= 1.0 + 4.0*abs(den);\n        }\n        t += dt;\n        if( sum>0.995 || t>tmax ) break;\n    }\n\n    return clamp( 1.0-sum, 0.0, 1.0 );\n}\n\nvec4 renderClouds( in vec3 ro, in vec3 rd, float tmin, float tmax, inout float resT )\n{\n    vec4 sum = vec4(0.0);\n\n    \/\/ bounding volume!!\n    float tl = ( -10.0-ro.y)\/rd.y;\n    float th = ( 300.0-ro.y)\/rd.y;\n    if( tl>0.0 )   tmin = max( tmin, tl ); else return sum;\n  \/*if( th>0.0 )*\/ tmax = min( tmax, th );\n\n\n    float t = tmin;\n    float lastT = t;\n    float thickness = 0.0;\n    #ifdef LOWQUALITY\n    for(int i=ZERO; i<128; i++)\n    #else\n    for(int i=ZERO; i<300; i++)\n    #endif\n    { \n        vec3  pos = ro + t*rd; \n        vec4  denGra = cloudsMap( pos ); \n        float den = denGra.x;\n        #ifdef LOWQUALITY\n        float dt = max(0.1,0.011*t);\n        #else\n        float dt = max(0.05,0.005*t);\n        #endif\n        if( den>0.001 ) \n        { \n            #ifdef LOWQUALITY\n            float sha = 1.0;\n            #else\n            float sha = clamp( 1.0 - max(0.0,cloudsMap( pos + kSunDir*5.0 ).x), 0.0, 1.0 );\n            \/\/sha *= clamp( pos.y - terrainMap( (pos + kSunDir*5.0).xz ).x, 0.0, 1.0 );\n            #endif\n            vec3 nor = -normalize(denGra.yzw);\n            float dif = clamp( dot(nor,kSunDir), 0.0, 1.0 )*sha; \n            float fre = clamp( 1.0+dot(nor,rd), 0.0, 1.0 )*sha;\n            \/\/ lighting\n            vec3 lin  = vec3(0.70,0.80,1.00)*0.9*(0.6+0.4*nor.y);\n                 lin += vec3(0.20,0.25,0.20)*0.7*(0.5-0.5*nor.y);\n                 lin += vec3(1.00,0.70,0.40)*4.5*dif*(1.0-den);        \n            \t lin += vec3(0.80,0.70,0.50)*1.3*pow(fre,32.0)*(1.0-den);\n            \/\/ color\n            vec3 col = vec3(0.8,0.77,0.72)*clamp(1.0-4.0*den,0.0,1.0);\n\n            col *= lin;\n\n            col = fog( col, t );\n\n            \/\/ front to back blending    \n            float alp = clamp(den*0.25*min(dt,tmax-t-dt),0.0,1.0);\n            col.rgb *= alp;\n            sum = sum + vec4(col,alp)*(1.0-sum.a);\n\n            thickness += dt*den;\n            lastT = t;            \n        }\n        else \n        {\n#ifdef LOWQUALITY\n            dt *= 1.0 + 4.0*abs(den);\n#else\n            dt *= 0.8 + 2.0*abs(den);\n#endif\n        }\n        t += dt;\n        if( sum.a>0.995 || t>tmax ) break;\n    }\n\n    resT = mix( resT, lastT, sum.w );\n    \n    if( thickness>0.0)\n\t\tsum.xyz += vec3(1.00,0.60,0.40)*0.2*pow(clamp(dot(kSunDir,rd),0.0,1.0),32.0)*exp(-0.3*thickness)*clamp(thickness*4.0,0.0,1.0);\n\n    return clamp( sum, 0.0, 1.0 );\n}\n\n\n\/\/------------------------------------------------------------------------------------------\n\/\/ terrain\n\/\/------------------------------------------------------------------------------------------\n\nvec2 terrainMap( in vec2 p )\n{\n    const float sca = 0.0010;\n    const float amp = 300.0;\n\n    p *= sca;\n    float e = fbm_9( p + vec2(1.0,-2.0) );\n    float a = 1.0-smoothstep( 0.12, 0.13, abs(e+0.12) ); \/\/ flag high-slope areas (-0.25, 0.0)\n    e = e + 0.15*smoothstep( -0.08, -0.01, e );\n    e *= amp;\n    return vec2(e,a);\n}\n\nvec4 terrainMapD( in vec2 p )\n{\n\tconst float sca = 0.0010;\n    const float amp = 300.0;\n    p *= sca;\n    vec3 e = fbmd_9( p + vec2(1.0,-2.0) );\n    vec2 c = smoothstepd( -0.08, -0.01, e.x );\n\te.x = e.x + 0.15*c.x;\n\te.yz = e.yz + 0.15*c.y*e.yz;    \n    e.x *= amp;\n    e.yz *= amp*sca;\n    return vec4( e.x, normalize( vec3(-e.y,1.0,-e.z) ) );\n}\n\nvec3 terrainNormal( in vec2 pos )\n{\n#if 1\n    return terrainMapD(pos).yzw;\n#else    \n    vec2 e = vec2(0.03,0.0);\n\treturn normalize( vec3(terrainMap(pos-e.xy).x - terrainMap(pos+e.xy).x,\n                           2.0*e.x,\n                           terrainMap(pos-e.yx).x - terrainMap(pos+e.yx).x ) );\n#endif    \n}\n\nfloat terrainShadow( in vec3 ro, in vec3 rd, in float mint )\n{\n    float res = 1.0;\n    float t = mint;\n#ifdef LOWQUALITY\n    for( int i=ZERO; i<32; i++ )\n    {\n        vec3  pos = ro + t*rd;\n        vec2  env = terrainMap( pos.xz );\n        float hei = pos.y - env.x;\n        res = min( res, 32.0*hei\/t );\n        if( res<0.0001 ) break;\n        t += clamp( hei, 1.0+t*0.1, 50.0 );\n    }\n#else\n    for( int i=ZERO; i<128; i++ )\n    {\n        vec3  pos = ro + t*rd;\n        vec2  env = terrainMap( pos.xz );\n        float hei = pos.y - env.x;\n        res = min( res, 32.0*hei\/t );\n        if( res<0.0001 ) break;\n        t += clamp( hei, 0.5+t*0.05, 25.0 );\n    }\n#endif\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec2 raymarchTerrain( in vec3 ro, in vec3 rd, float tmin, float tmax )\n{\n    \/\/float tt = (150.0-ro.y)\/rd.y; if( tt>0.0 ) tmax = min( tmax, tt );\n    \n    float dis, th;\n    float t2 = -1.0;\n    float t = tmin; \n    float ot = t;\n    float odis = 0.0;\n    float odis2 = 0.0;\n    for( int i=ZERO; i<400; i++ )\n    {\n        th = 0.001*t;\n\n        vec3  pos = ro + t*rd;\n        vec2  env = terrainMap( pos.xz );\n        float hei = env.x;\n\n        \/\/ tree envelope\n        float dis2 = pos.y - (hei+kMaxTreeHeight*1.1);\n        if( dis2<th ) \n        {\n            if( t2<0.0 )\n            {\n                t2 = ot + (th-odis2)*(t-ot)\/(dis2-odis2); \/\/ linear interpolation for better accuracy\n            }\n        }\n        odis2 = dis2;\n        \n        \/\/ terrain\n        dis = pos.y - hei;\n        if( dis<th ) break;\n        \n        ot = t;\n        odis = dis;\n        t += dis*0.8*(1.0-0.75*env.y); \/\/ slow down in step areas\n        if( t>tmax ) break;\n    }\n\n    if( t>tmax ) t = -1.0;\n    else t = ot + (th-odis)*(t-ot)\/(dis-odis); \/\/ linear interpolation for better accuracy\n    return vec2(t,t2);\n}\n\nvec4 renderTerrain( in vec3 ro, in vec3 rd, in vec2 tmima, out float teShadow, out vec2 teDistance, inout float resT )\n{\n    vec4 res = vec4(0.0);\n    teShadow = 0.0;\n    teDistance = vec2(0.0);\n    \n    vec2 t = raymarchTerrain( ro, rd, tmima.x, tmima.y );\n    if( t.x>0.0 )\n    {\n        vec3 pos = ro + t.x*rd;\n        vec3 nor = terrainNormal( pos.xz );\n\n        \/\/ bump map\n        nor = normalize( nor + 0.8*(1.0-abs(nor.y))*0.8*fbmd_8( pos*0.3*vec3(1.0,0.2,1.0) ).yzw );\n        \n        vec3 col = vec3(0.18,0.11,0.10)*.75;\n        col = 1.0*mix( col, vec3(0.1,0.1,0.0)*0.3, smoothstep(0.7,0.9,nor.y) );      \n        \n\t\t\/\/col *= 1.0 + 2.0*fbm( pos*0.2*vec3(1.0,4.0,1.0) );\n        \n        float sha = 0.0;\n        float dif =  clamp( dot( nor, kSunDir), 0.0, 1.0 ); \n        if( dif>0.0001 ) \n        {\n            sha = terrainShadow( pos+nor*0.01, kSunDir, 0.01 );\n            \/\/if( sha>0.0001 ) sha *= cloudsShadow( pos+nor*0.01, kSunDir, 0.01, 1000.0 );\n            dif *= sha;\n        }\n        vec3  ref = reflect(rd,nor);\n    \tfloat bac = clamp( dot(normalize(vec3(-kSunDir.x,0.0,-kSunDir.z)),nor), 0.0, 1.0 )*clamp( (pos.y+100.0)\/100.0, 0.0,1.0);\n        float dom = clamp( 0.5 + 0.5*nor.y, 0.0, 1.0 );\n        vec3  lin  = 1.0*0.2*mix(0.1*vec3(0.1,0.2,0.0),vec3(0.7,0.9,1.0),dom);\/\/pow(vec3(occ),vec3(1.5,0.7,0.5));\n              lin += 1.0*5.0*vec3(1.0,0.9,0.8)*dif;        \n              lin += 1.0*0.35*vec3(1.0)*bac;\n        \n\t    col *= lin;\n\n        col = fog(col,t.x);\n\n        teShadow = sha;\n        teDistance = t;\n        res = vec4( col, 1.0 );\n        resT = t.x;\n    }\n    \n    return res;\n}\n\n\/\/------------------------------------------------------------------------------------------\n\/\/ trees\n\/\/------------------------------------------------------------------------------------------\n\nfloat treesMap( in vec3 p, in float rt, out float oHei, out float oMat, out float oDis )\n{\n    oHei = 1.0;\n    oDis = 0.1;\n    oMat = 0.0;\n        \n    float base = terrainMap(p.xz).x; \n    \n    float d = 10.0;\n    vec2 n = floor( p.xz );\n    vec2 f = fract( p.xz );\n    for( int j=0; j<=1; j++ )\n    for( int i=0; i<=1; i++ )\n    {\n        vec2  g = vec2( float(i), float(j) ) - step(f,vec2(0.5));\n        vec2  o = hash2( n + g );\n        vec2  v = hash2( n + g + vec2(13.1,71.7) );\n        vec2  r = g - f + o;\n\n        float height = kMaxTreeHeight * (0.4+0.8*v.x);\n        float width = 0.9*(0.5 + 0.2*v.x + 0.3*v.y);\n        vec3  q = vec3(r.x,p.y-base-height*0.5,r.y);\n        float k = sdEllipsoidY( q, vec2(width,0.5*height) );\n\n        if( k<d )\n        { \n            d = k;\n            \/\/oMat = hash1(o); \/\/fract(o.x*7.0 + o.y*15.0);\n            oMat = o.x*7.0 + o.y*15.0;\n            oHei = (p.y - base)\/height;\n            oHei *= 0.5 + 0.5*length(q) \/ width;\n        }\n    }\n    oMat = fract(oMat);\n\n    \/\/ distort ellipsoids to make them look like trees (works only in the distance really)\n    #ifdef LOWQUALITY\n    if( rt<350.0 )\n    #else\n    if( rt<500.0 )\n    #endif\n    {\n        float s = fbm_4( p*3.0 );\n        s = s*s;\n        oDis = s;\n        #ifdef LOWQUALITY\n        float att = 1.0-smoothstep(150.0,350.0,rt);\n        #else\n        float att = 1.0-smoothstep(200.0,500.0,rt);\n        #endif\n        d += 2.0*s*att*att;\n    }\n    \n    return d;\n}\n\nfloat treesShadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.02;\n#ifdef LOWQUALITY\n    for( int i=ZERO; i<50; i++ )\n    {\n        float kk1, kk2, kk3;\n        float h = treesMap( ro + rd*t, t, kk1, kk2, kk3 );\n        res = min( res, 32.0*h\/t );\n        t += h;\n        if( res<0.001 || t>20.0 ) break;\n    }\n#else\n    for( int i=ZERO; i<150; i++ )\n    {\n        float kk1, kk2, kk3;\n        float h = treesMap( ro + rd*t, t, kk1, kk2, kk3 );\n        res = min( res, 32.0*h\/t );\n        t += h;\n        if( res<0.001 || t>120.0 ) break;\n    }\n#endif\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 treesNormal( in vec3 pos, in float t )\n{\n    float kk1, kk2, kk3;\n#if 0    \n    const float eps = 0.005;\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*treesMap( pos + e.xyy, t, kk1, kk2, kk3 ) + \n                      e.yyx*treesMap( pos + e.yyx, t, kk1, kk2, kk3 ) + \n                      e.yxy*treesMap( pos + e.yxy, t, kk1, kk2, kk3 ) + \n                      e.xxx*treesMap( pos + e.xxx, t, kk1, kk2, kk3 ) );            \n#else\n    \/\/ inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*treesMap(pos+0.005*e, t, kk1, kk2, kk3);\n    }\n    return normalize(n);\n#endif    \n}\n\nvec3 treesShade( in vec3 pos, in vec3 tnor, in vec3 enor, in float hei, in float mid, in float dis, in float rt, in vec3 rd, float terrainShadow )\n{\n    vec3 nor = normalize( tnor + 2.5*enor );\n\n    \/\/ --- lighting ---\n    float sha = terrainShadow;\n    vec3  ref = reflect(rd,nor);\n    float occ = clamp(hei,0.0,1.0) * pow(1.0-2.0*dis,3.0);\n    float dif = clamp( 0.1 + 0.9*dot( nor, kSunDir), 0.0, 1.0 ); \n    if( dif>0.0001 && terrainShadow>0.001 )\n    {\n        \/\/sha *= clamp( 10.0*dot(tnor,kSunDir), 0.0, 1.0 ) * pow(clamp(1.0-13.0*dis,0.0,1.0),4.0);\/\/treesShadow( pos+nor*0.1, kSunDir ); \/\/ only cast in non-terrain-occluded areas\n        sha *= treesShadow( pos+nor*0.1, kSunDir ); \/\/ only cast in non-terrain-occluded areas\n    }\n    float dom = clamp( 0.5 + 0.5*nor.y, 0.0, 1.0 );\n    float fre = clamp(1.0+dot(nor,rd),0.0,1.0);\n    float spe = pow( clamp(dot(ref,kSunDir),0.0, 1.0), 9.0 )*dif*sha*(0.2+0.8*pow(fre,5.0))*occ;\n\n    \/\/ --- lights ---\n    vec3 lin  = 1.0*0.5*mix(0.1*vec3(0.1,0.2,0.0),vec3(0.6,1.0,1.0),dom*occ);\n\t\t #ifdef SOFTTREES\n         lin += 1.0*15.0*vec3(1.0,0.9,0.8)*dif*occ*sha;\n\t\t #else\n         lin += 1.0*10.0*vec3(1.0,0.9,0.8)*dif*occ*sha;\n\t\t #endif\n         lin += 1.0*0.5*vec3(0.9,1.0,0.8)*pow(fre,3.0)*occ;\n         lin += 1.0*0.05*vec3(0.15,0.4,0.1)*occ;\n   \n    \/\/ --- material ---\n    float brownAreas = fbm_4( pos.zx*0.03 );\n    vec3 col = vec3(0.08,0.09,0.02);\n    \t col = mix( col, vec3(0.09,0.07,0.02), smoothstep(0.2,1.0,mid) );\n         col = mix( col, vec3(0.06,0.05,0.01)*1.1, 1.0-smoothstep(0.9,0.91,enor.y) );\n         col = mix( col, vec3(0.25,0.16,0.01)*0.15, 0.7*smoothstep(0.1,0.3,brownAreas)*smoothstep(0.5,0.8,enor.y) );\n         col *= 1.6;\n\n    \/\/ --- brdf * material ---\n    col *= lin;\n    col += spe*1.2*vec3(1.0,1.1,2.5);\n\n    \/\/ --- fog ---\n    col = fog( col, rt );\n\n    return col;\n}\n\nvec4 renderTrees( in vec3 ro, in vec3 rd, float tmin, float tmax, float terrainShadow, inout float resT )\n{\n\t\/\/if( tmin>300.0 ) return vec4(0.0);\n    float t = tmin;\n    float hei, mid, displa;\n\n    for(int i=ZERO; i<64; i++) \n    { \n        vec3  pos = ro + t*rd; \n        float dis = treesMap( pos, t, hei, mid, displa); \n        if( dis<(0.00025*t) ) break;\n        t += dis;\n        if( t>tmax ) return vec4(0.0);\n    }\n    \n    vec3 pos = ro + t*rd;\n\n    vec3 enor = terrainNormal( pos.xz );\n    vec3 tnor = treesNormal( pos, t );            \n\n    vec3 col = treesShade( pos, tnor, enor, hei, mid, displa, t, rd, terrainShadow );\n\tresT = t;\n    \n    return vec4(col,1.0);\n}\n\n\n\/\/------------------------------------------------------------------------------------------\n\/\/ sky\n\/\/------------------------------------------------------------------------------------------\n\nvec3 renderSky( in vec3 ro, in vec3 rd )\n{\n    \/\/ background sky     \n    vec3 col = 0.9*vec3(0.4,0.65,1.0) - rd.y*vec3(0.4,0.36,0.4);\n\n    \/\/ clouds\n    float t = (1000.0-ro.y)\/rd.y;\n    if( t>0.0 )\n    {\n        vec2 uv = (ro+t*rd).xz;\n        float cl = fbm_9( uv*0.002 );\n        float dl = smoothstep(-0.2,0.6,cl);\n        col = mix( col, vec3(1.0), 0.4*dl );\n    }\n    \n\t\/\/ sun glare    \n    float sun = clamp( dot(kSunDir,rd), 0.0, 1.0 );\n    col += 0.6*vec3(1.0,0.6,0.3)*pow( sun, 32.0 );\n    \n\treturn col;\n}\n\n\n\/\/------------------------------------------------------------------------------------------\n\/\/ main image making function\n\/\/------------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o = hash2( float(iFrame) ) - 0.5;\n    \n    vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))\/ iResolution.y;\n    \n    \/\/----------------------------------\n    \/\/ setup\n    \/\/----------------------------------\n\n    \/\/ camera\n    #ifdef  STATIC_CAMERA\n    vec3 ro = vec3(0.0, -99.25, 5.0);\n    vec3 ta = vec3(0.0, -99.0, 0.0);\n\t#else\n    float time = iTime;\n    vec3 ro = vec3(0.0, -99.25, 5.0) + vec3(10.0*sin(0.02*time),0.0,-10.0*sin(0.2+0.031*time));\n    vec3 ta = vec3(0.0, -98.25, -45.0 + ro.z );\n    #endif\n    \n    \/\/ ray\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    vec3 rd = ca * normalize( vec3(p.xy,1.5));\n\n\tfloat resT = 1000.0;\n\n    \/\/----------------------------------\n    \/\/ sky\n    \/\/----------------------------------\n\n    vec3 col = renderSky( ro, rd );\n    \n    \/\/----------------------------------\n    \/\/ terrain\n    \/\/----------------------------------\n    vec2 teDistance;\n    float teShadow;\n    \n    vec2 tmima = vec2(15.0,1000.0);\n    {\n        vec4 res = renderTerrain( ro, rd, tmima, teShadow, teDistance, resT );\n        col = col*(1.0-res.w) + res.xyz;\n    }                        \n\n    \/\/----------------------------------\n    \/\/ trees\n    \/\/----------------------------------\n    if( teDistance.y>0.0 )\n    {\n        tmima = vec2( teDistance.y, (teDistance.x>0.0)?teDistance.x:tmima.y );\n        vec4 res = renderTrees( ro, rd, tmima.x, tmima.y, teShadow, resT );\n        col = col*(1.0-res.w) + res.xyz;\n    }\n\n    \/\/----------------------------------\n    \/\/ clouds\n    \/\/----------------------------------\n    {\n        vec4 res = renderClouds( ro, rd, 0.0, (teDistance.x>0.0)?teDistance.x:tmima.y, resT );\n        col = col*(1.0-res.w) + res.xyz;\n    }\n\n    \/\/----------------------------------\n    \/\/ final\n    \/\/----------------------------------\n    \n    \/\/ sun glare    \n    float sun = clamp( dot(kSunDir,rd), 0.0, 1.0 );\n    col += 0.25*vec3(1.0,0.4,0.2)*pow( sun, 4.0 );\n \n    \/\/ gamma\n    col = sqrt(col);\n\n    \/\/----------------------------------\n    \/\/ color grading\n    \/\/----------------------------------\n\n    col = col*0.15 + 0.85*col*col*(3.0-2.0*col);            \/\/ contrast\n    col = pow( col, vec3(1.0,0.92,1.0) );   \/\/ soft green\n    col *= vec3(1.02,0.99,0.99);            \/\/ tint red\n    col.z = (col.z+0.1)\/1.1;                \/\/ bias blue\n    col = mix( col, col.yyy, 0.15 );       \/\/ desaturate\n     \n    col = clamp( col, 0.0, 1.0 );\n    \n    \n    \/\/------------------------------------------\n\t\/\/ reproject from previous frame and average\n    \/\/------------------------------------------\n\n    mat4 oldCam = mat4( textureLod(iChannel0,vec2(0.5,0.5)\/iResolution.xy, 0.0),\n                        textureLod(iChannel0,vec2(1.5,0.5)\/iResolution.xy, 0.0),\n                        textureLod(iChannel0,vec2(2.5,0.5)\/iResolution.xy, 0.0),\n                        0.0, 0.0, 0.0, 1.0 );\n    \n    \/\/ world space\n    vec4 wpos = vec4(ro + rd*resT,1.0);\n    \/\/ camera space\n    vec3 cpos = (wpos*oldCam).xyz; \/\/ note inverse multiply\n    \/\/ ndc space\n    vec2 npos = 1.5 * cpos.xy \/ cpos.z;\n    \/\/ screen space\n    vec2 spos = 0.5 + 0.5*npos*vec2(iResolution.y\/iResolution.x,1.0);\n    \/\/ undo dither\n    spos -= o\/iResolution.xy;\n\t\/\/ raster space\n    vec2 rpos = spos * iResolution.xy;\n    \n    if( rpos.y<1.0 && rpos.x<3.0 )\n    {\n    }\n\telse\n    {\n        vec3 ocol = textureLod( iChannel0, spos, 0.0 ).xyz;\n    \tif( iFrame==0 ) ocol = col;\n        col = mix( ocol, col, 0.1 );\n    }\n\n    \/\/----------------------------------\n                           \n\tif( fragCoord.y<1.0 && fragCoord.x<3.0 )\n    {\n        if( abs(fragCoord.x-2.5)<0.5 ) fragColor = vec4( ca[2], -dot(ca[2],ro) );\n        if( abs(fragCoord.x-1.5)<0.5 ) fragColor = vec4( ca[1], -dot(ca[1],ro) );\n        if( abs(fragCoord.x-0.5)<0.5 ) fragColor = vec4( ca[0], -dot(ca[0],ro) );\n    }\n    else\n    {\n        fragColor = vec4( col, 1.0 );\n    }\n}\n",
            "name": "Buffer A",
            "description": "",
            "type": "buffer"
        }
    ]
}