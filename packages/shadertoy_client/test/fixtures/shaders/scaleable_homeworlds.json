{
  "ver": "0.1",
  "info": {
    "id": "MtBczw",
    "date": "1507883761",
    "viewed": 1013,
    "name": "Scaleable homeworlds",
    "username": "ollj",
    "description": "iMouse.y sets scaling from \"little prince comet\" to \"torodial settlers gas giant\"\n(or it oscillates over time,swap lines 19-20 )\n\nfork of\nhttps://www.shadertoy.com/view/MlBXDz",
    "likes": 18,
    "published": 3,
    "flags": 0,
    "tags": [
      "noise",
      "clouds",
      "random",
      "ocean",
      "planet",
      "alien",
      "scattering",
      "weather",
      "genesis",
      "atmospherics",
      "coast"
    ],
    "hasliked": 0
  },
  "renderpass": [
    {
      "name": "Image",
      "type": "image",
      "description": "",
      "code": "//self: https://www.shadertoy.com/view/MtBczw\n\n#define ENABLE_DETAILS\n#define ENABLE_CLOUDS\n\n//note. it is important to DISABLE VFlip for the noise buffers.\n\nconst float PI = 3.14159265359;\nconst float ROTATE_PERIOD = 240.0;\nconst float eps = .002;\nconst float iterRm=60.;\nconst float iterScatter = 10.;\nconst float iterOut = 5.;\n#define iterWaterDepth 10.\n\n\n\nfloat time()\n{vec2 m=iMouse.xy/iResolution.xy;\n;return + m.x*64.+iTime*.1;\n //;return + m.x*64.0; //+time\n}\n\n\n// Scale constants\n//noise scale, smaller scale makes \"tiny planet with very low atmosphere\"\n//#define SCALE 100.\n#define SCALEM 500.\n//#define SCALE (SCALEM+cos(acos(-1.)+iTime*.01)*(SCALEM*.98))\n#define SCALE (SCALEM+cos(acos(-1.)+iMouse.y*.01)*(SCALEM*.98))\n\n//todo make a SCALE() function\n//,so you can distinguish 2 states: mousepushed and not:\n\n#define MAX SCALE*100.0\n#define OCEAN_FLOOR 0.98\n#define OCEAN 0.99\n#define SEA_LEVEL OCEAN*SCALE\n#define ATMOSPHERE  1.05\n#define ATMOSPHERE_LOWER SCALE\n#define ATMOSPHERE_UPPER  ATMOSPHERE*SCALE\n#define ATMOSPHERE_HEIGHT  (ATMOSPHERE_UPPER-ATMOSPHERE_LOWER)\n\n#define H0  (4./ATMOSPHERE_HEIGHT)\n\n// Scatter constants\nconst float K_R = 0.05;\nconst float K_M = 0.0025;\nconst float K_C = 6.0;\nconst float E = 14.3; \t\t\t\t\t\t// light intensity\nconst vec3 C_R = vec3(0.21, 0.66, 1.0);\t\t// 1 / wavelength ^ 4\nconst vec3 C_C = vec3(1.0);\nconst float G_M = -0.81;\t\t\t\t\t// Mie g\nconst float G_C = 0.10;\n\n#define dd(a) dot(a,a)\n#define herm2(a) (a)*(a)*(3.-2.*(a))\n#define u2(a) ((a)*2.-1.)\nfloat miv(vec3 a){return min(min(a.x,a.y),a.z);}\n\nmat3 rotX(float a) { return mat3(1.0, 0.0, 0.0, 0.0, cos(a), sin(a), 0.0, -sin(a), cos(a)); }\nmat3 rotY(float a) { return mat3(cos(a), 0.0, sin(a), 0.0, 1.0, 0.0, -sin(a), 0.0, cos(a)); }\nmat3 rotZ(float a) { return mat3(cos(a), sin(a), 0.0, -sin(a), cos(a), 0.0, 0.0, 0.0, 1.0); }\n\nmat3 planetSpin() { return rotY(-iTime*PI/ROTATE_PERIOD); }\n\n\n/* From Ashima webgl noise library: https://github.com/ashima/webgl-noise/wiki */\nvec4 permute(vec4 x){return mod((34.*x+1.)*x,289.);}\nvec3 permute(vec3 x){return mod((34.*x+1.)*x,289.);}\n\n//branchless sorting,swap all .xyzw till .x is smallest:\nvec2 sortx(vec2 d){return mix(d.xy,d.yx,step(d.y,d.x));}\nvec3 sortx(vec3 d){d.xy=sortx(d.xy);return mix(d.xyz,d.zyx,step(d.z,d.x));}\nvec4 sortx(vec4 d){d.xyz=sortx(d.xyz);return mix(d.xyzw,d.wyzx,step(d.w,d.x));}\n//must use 3(step(a,b)),can not use vec3(step(a,b),nor vec3(sign(b-a)*.5+.5)\n//,because some parsers fuck that one up with non-commutativity\n//https://www.shadertoy.com/view/MtBczw\n\n// 2 vec4 dotproducts. which is a bit strange to visualize\nvec4 ashimal(vec4 Px,vec4 Py,vec4 Pz,vec3 Pf){\n;const float K=1./7.\n,Ko=.428571428571 // .5-K*.5\n,L=1./6.\n,Lo=.416666666667 //.5-Kz*.5\n,j=.9;//sqrt(2.)*.5//smaller jitter gives less errors\n;Pz*=K;\n;Px=Px+j*    (fract(Pz  )-Ko)\n;Py=Py+j*(mod(floor(Pz  ),7.)*K-Ko)\n;Pz=Pf.z+j*  (floor(Pz*K)*L-Lo);\n;float x=dd(vec3(Px.x,Py.x,Pz.x));\n;float y=dd(vec3(Px.y,Py.y,Pz.y));\n;float z=dd(vec3(Px.z,Py.z,Pz.z));\n;float w=dd(vec3(Px.w,Py.w,Pz.w));   \n;return vec4(x,y,z,w);}\n\n//this looks like unrolled 3d voronoi special case\n//uses the permute() of ashimaSimplexNoise\n//i know that voronoi and simplex are the same type of noise\n//but this makes them the very same thing, not just same type.\nvec2 cellular2x2x2(vec3 f)\n{vec3 m=mod(floor(f),289.);f=fract(f)\n;const vec4 b3=vec2(0,1).xxyy,b5=b3.xzyw;\n;vec4 a=f.x-b5,b=f.y-b3,p=permute(permute(m.x+b5)+m.y+b3)\n;vec4 d1=ashimal(a,b,permute(p+m.z   ),f);\n;vec4 d2=ashimal(a,b,permute(p+m.z+1.),f-1.);\n;vec4 d=min(d1,d2);// F1 is now in d\n;d2=max(d1,d2); // Make sure we keep all candidates for F2\n//vectorizing the step() is foiled by parser amviguity, ruining comutativity or distrobutivity.\n;d=sortx(d);//swap all with x to make .x the smallest of .xyzw\n;d.yzw=min(d2.yzw,d.yzw)// F2 now not in d2.yzw\n;d.y=min(d2.x,miv(d.yzw))// F2 is now in d.y\n;return sqrt(d.xy);// F1 and F2\n}\n\n//vec3 permute(in vec3 x) {return mod289(((x * 34.0) + 1.0) * x);\n\nfloat noise3(in vec3 u)\n{vec3 p=floor(u);u=fract(u)\n;u=herm2(u)\n;u.xy+=p.xy+vec2(37,17)*p.z\n\n//;u=mod289(u);\n//;u.xy=cellular2x2x2(u);\n    //vec2(sin(u.x)+cos(u.x)),sin(u.x)\n;u.xy=textureLod(iChannel0,(u.xy+.5)/256.,.0).yx\n;return u2(mix(u.x,u.y,u.z));\n}//iq elevated noise: https://www.shadertoy.com/view/MdX3Rr *\n\n#define sat(a) clamp(a,0.,1.)\n\nvec2 planetMap(in vec3 p)\n{p=planetSpin()*p\n;float pn1=noise3(p/32.)\n;float pn2=noise3(p*(2.1/32.))\n;float pn3=noise3(p*(4.2/32.))//3 noises\n;float pf1=pn1+.5*pn2+.25*pn3//united to a 3 octave noise\n//Ridged multi fractal\n;float s=pow((1.-abs(pn3)),2.),ss=sat(s*1.5)\n,r=pow(1.-abs(pn2),2.)+.5*s*ss\n#ifdef ENABLE_DETAILS\n,pn4=noise3(p*8.82/32.)\n,pn5=noise3(p*18.522/32.)\n,pn6=noise3(p*38.8962/32.)\n;pf1+=(pn4+pn5/2.+pn6/4.)/8.\n;r+=pow((1.-abs(pn4)),2.)*ss/4.\n;r+=pow((1.-abs(pn5)),2.)*ss/8.\n;r+=pow((1.-abs(pn6)),2.)*ss/16.\n#endif\n// Mountain\n;float mm=smoothstep(.55,1.,sat(abs(.925-pn2)))*sat(pf1)//land\n,ma=mix(1.,2.,smoothstep(0.,.5,mm)) \n;s=ATMOSPHERE_HEIGHT/4.*pf1+mix(.0,2.5*r,mm)\n;return vec2(length(p)-SEA_LEVEL-s,ma);}\n\nfloat waterDepth(vec3 u,float s){vec3 d=-normalize(u);float a=.0\n;for(float i=.0;i<iterWaterDepth;i++){a+= planetMap(u+d*a).x*s;\n}return a;}\n\n#define softcoast 0\n//your classic TextureID mixer:\n//blend texture of land ith texture of water\nvec2 opc(vec2 d1,vec2 d2){//return(d1.x<d2.x)?d1:d2;\n#if (softcoast==0)\nreturn mix(d1,d2,step(d2.x,d1.x));}\n#else\n//nope not fully implemented idea of ollj here:\nreturn mix(d1,d2,smoothstep(.1,-.1,d2.x-d1.x));}//just doesnt look good here\n#endif\n\n//return gradient (to descent in), estimated distance within a gradient.\n//.x=distance .y=gBufferId.\nvec2 gd(in vec3 u)\n{vec2 p= planetMap(u)//planet\n,w=vec2(length(u)-SCALE*OCEAN,10.);//water\n;return opc(p,w);}\n\n//return differential of gradient, 1st one is normal 2nd one is curvature...\nvec3 dg(in vec3 u){vec2 e=vec2(.25,0);return normalize(vec3\n(gd(u+e.xyy).x-gd(u-e.xyy).x\n,gd(u+e.yxy).x-gd(u-e.yxy).x\n,gd(u+e.yyx).x-gd(u-e.yyx).x));}\n\n//naive raymarcher with materialId\n//rayOrigin,RayDirection,LipschitsScale,zMin,zFat\nvec2 rayMarch(in vec3 u,vec3 t,float l,float m,float zFar)\n{float g = -1.//matrrial\n;for(float i=.0;i<iterRm;i++\n){vec2 r=gd(u+t*m);g=r.y\n ;if(r.x<eps||m>zFar)break\n ;m+=r.x*l\n;}\n;g=mix(-1.,g,step(m,zFar));\n;return vec2(m,g);}\n\n/* Atmospheric scattering code from gltracy shader: https://www.shadertoy.com/view/lslXDr\n * with additions for clouds and reflections from the planet surface. */\nvec2 lineIntersectSphere(in vec3 o, in vec3 t, float r)\n{float b=dot(o,t),d=b*b+r*r-dot(o,o)\n;if(d<.0)return vec2(MAX,-MAX)//code for no intersection?\n;return vec2(-1,1)*sqrt(d)-b;}\n\nfloat mie(float g,float c,float d){float h=g*g\n;return 1.5*(1.-h)*(1.+d)/sqrt(1.+h-2.*g*c)/(2.+g);}\nfloat phase_reyleigh(float d){return .75*(1.+d);}\nfloat airDensity(vec3 p)\n{return exp(-(max(length(p),ATMOSPHERE_LOWER)-SCALE)*H0);}\nfloat aerosolDensity(vec3 p)\n{return exp(-(max(length(p),ATMOSPHERE_LOWER)-SCALE)*H0);}\n\n/* When cloudView is non-zero, clouds are faded out as they approach right angles with this\n * vector. Helps to stop artifacts on the horizon. */\nfloat cloudDensity(vec3 u, vec3 c)\n{vec3 v=planetSpin()*u,w=normalize(v)\n;float o=abs(dot(w,vec3(0,1,0))),p=(1.-o*o)\n,h=sat((length(u)-SCALE)/ATMOSPHERE_HEIGHT);\n;u*=rotY(.5 *p*sin(2.5*w.y+iTime/75.) \n        +.25*p*cos(2.5*w.x+iTime/150.));\n;vec3 d=(vec3(1,0,0)*sin(PI*(u.x/4.)+iTime*3.) \n        +vec3(0,1,0)*cos(PI*(u.y/4.)+iTime*.7) \n        +vec3(0,0,1)*cos(PI*(u.z/4.)+iTime   ))*.5+u;\n;float n=(noise3(d/13.)-.45)/.55+3.*pow(o,1.75);\n;n=.05*n+.025*noise3(d/7.); \n#ifdef ENABLE_DETAILS\n;n+=.0125*noise3(d/3.5);\n#endif\n;n*= pow((1.-length(c))+abs(dot(normalize(u), c)), 1.5); \n;return exp(-pow(h-.35,2.)/.02)*sat(n)*2.;}\n\nvec3 density(vec3 p,vec3 c)\n#ifdef ENABLE_CLOUDS\t\n{return vec3(airDensity(p),aerosolDensity(p),cloudDensity(p,c));}\n#else\n{return vec3(airDensity(p),aerosolDensity(p),.0);}\n#endif    \n\nvec3 optic(vec3 a, vec3 b,vec3 c)\n{b=(b-a)/iterOut;vec3 r=vec3(0);a+=b*.5\n;for(float i=.0;i<iterOut;i++){r+=density(a,c);a+=b;\n}return r*length(b)/ATMOSPHERE_HEIGHT;}\n\nvec3 attenuate(vec3 a, vec3 b, vec3 c)\n{vec3 o=optic(a,b, c)*PI*4.\n;return exp(-o.x*K_R*C_R -o.y*K_M - o.z*K_C*C_C);}\n\nvec3 in_scatter(vec3 o, vec3 dir, vec2 P,vec3 sun){\n\t//vec3 sun = sunDirection;\n    float stepLength = (P.y-P.x)/iterScatter;\n    vec3 step = dir*stepLength;\n    vec3 pa = o+dir*P.x;\n    vec3 pn = pa+step*0.5;\n    \n    vec3 air = vec3(0.0);\n    vec3 aerosols = vec3(0.0);\n    vec3 clouds = vec3(0.0);\n    for (float i =.0; i < iterScatter; i++)\n    {\n        vec2 c = lineIntersectSphere(pn, sun, ATMOSPHERE_UPPER);\n        vec3 ppc = pn + sun*c.y;\n        \n        vec3 d = density(pn, dir);\n        vec3 atn = attenuate(pa, pn, dir)*attenuate(pn, ppc, dir);\n        air += d.x*atn;\n        aerosols += d.y*atn;\n        clouds += d.z*atn;\n        \n        pn += step;\n    }\n    air *= stepLength/ATMOSPHERE_HEIGHT;\n    aerosols *= stepLength/ATMOSPHERE_HEIGHT;\n    clouds *= stepLength/ATMOSPHERE_HEIGHT;\n    \n    float c = dot(dir, -sun);\n    float cc = c*c;\n    \n    vec3 I = vec3(0.0);\n    I += K_R * C_R * phase_reyleigh(cc) * air;\n    I += K_M * mie(G_M, c, cc) * aerosols;\n    I += K_C * C_C * mie(G_C, c, cc) * clouds;\n    return I * E;\n}\n\n#define u5(a) (a)*.5*.5\n\n//returns ciryLights and planetColor\n//citylights ar filtered by same things that filters planetcolor\nvec3 planetColor(in vec3 u, in float m,out vec3 e,vec3 s)\n{s.x=dot(normalize(u),s)\n;float w=waterDepth(u,.5),v=dot(normalize(u),s);\n;u=planetSpin()*u//planetspin is matrix. must be on left side\n;vec3 n=dg(u),c=vec3(0)\n;e=vec3(0); \n;vec2 cn1=cellular2x2x2(u);    \n//;float updotn = dot(n, normalize(u)); \n//;float ydotn = dot(n, vec3(0,1,0));\n;float pn0=noise3((u+59.)/16.)\n,pn1=noise3(u*.5)\n,pn2=noise3((u+59.))\n,pn3=noise3((u+129.)*2.);\n;float pf=pn1+.5*pn2+.25*pn3\n,l=sat((length(u)-SEA_LEVEL)/(ATMOSPHERE_HEIGHT))\n,cm=smoothstep(0.04, 0.15, l+(0.04*pf))\n,dm=smoothstep(.1,.3,pn0+.15*pf)//desert mask\n,cn=(smoothstep(0.26, 0.25,v))*(cn1.y-cn1.x)*dm\n,sl=.25+.75*smoothstep(.0,.1, l)\n,upf=u5(pf);\n#ifdef ENABLE_DETAILS\n;float pn4=noise3((u+129.0)*4.)\n,pn5=noise3((u+129.0)*8.)\n,pn6=noise3((u+129.0)*16.);\n;pf+=.125*pn4+.0625*pn5+.03125*pn6\n#endif\n;const vec3 cDesert = vec3(1.42, 0.8, 0.4)\n,cShore1=vec3(.62,.31,.4)\n,cShore2=vec3(1.2,.1,.1)\n,cShore3=vec3(1.2,1,1)\n,cShore4=vec3(1)//this is an odd color todefine here.\n,cGrass1=vec3(.6,.9,.4)*.65\n,cGrass2=vec3(.8,.8,.2)*.75\n,cMount1=vec3(.6,.55, .65)*.75\n,cMount2=vec3(.6,.55,.55)\n,cMount3=vec3(1.2,1.2,1.2)\n,cOcean =vec3(.1,.0,.4)\n,cShore =vec3(.4,.5,.99);\n\n;vec3 cShoreMix1=mix(cShore1,cShore2,upf)*sl\n,cShoreMix2=mix(cShore3,cShore4,upf)*sl\n,shoreCol = mix(cShoreMix1,cShoreMix2,u5(pn0))\n,cGrassMix = mix(cGrass1, cGrass2, pf)\n,biomeCol=mix(cGrassMix,cDesert,dm)\n,landCol=mix(shoreCol,biomeCol,sat(cm+.5*dm))\n;c+=mix(vec3(0),landCol,sat(1.0-abs(m - 1.)))\n// Cities in the desert only cisible at night.\n;e=mix(vec3(0), vec3(2.0,0.5,1.5)*sat(cn*pf),sat(1.-abs(m-1.)));\n;vec3 mountainTopCol=mix(cMount1,cMount3,smoothstep(.7,.8,l));\n;vec3 mountainCol=mix(cMount2, mountainTopCol, sat(pow(dot(n, normalize(u)), 12.)));\n;c += mix(vec3(0),mountainCol,sat(1.-abs(m-2.)));\n//Ocean\n;vec3 cSeaMix=mix(cOcean,cShore,smoothstep(.35,.0,w+.05*pf));\n;c+=mix(vec3(.0),cSeaMix,float(m==10.))\n;return c;\n;}\n\n\n//ma.x=distance to camera ma.y=gBufferId\nvec3 renderPlanet(vec3 u,vec3 t,vec2 m,vec3 s)\n{float tMax=SCALE*25.;u+=m.x*t\n;vec3 l=u*(ATMOSPHERE_LOWER/length(u))\n,c=u+s*lineIntersectSphere(l,s,ATMOSPHERE_UPPER).y\n,a=attenuate(u,c,vec3(0))\n+vec3(0,.235,.275)*dot(normalize(u),s)// Fake skylight\n,n=dg(u)\n;float dif=sat(dot(n,s))\n//;float fre = pow( sat(1.0+dot(n,t)),2.);//unused fresnel?\n;vec3 e\n;c=planetColor(u,m.y,e,s)\n;float spe=sat(dot(reflect(t,n),s))//specular base       \n//;vec3 land=(.1+.9*dif)*c+.01*pow(spe,12.)*dif\n//;vec3 ocean=.4*c+.2*pow(spe,16.)\n//;brdf=mix(land,ocean,step(10.,m.y));\n//;brdf=mix(land,ocean,smoothstep(0.,1.,m.y-10.));\n//above is for softcoast!=0\n//below branching code is likely faster for hard coastline:\n;bool isLand=m.y<10.    \n;if(isLand){\n ;vec3 land=(.1+.9*dif)*c+.01*pow(spe,12.)*dif\n ;c=land\n;}else{\n ;vec3 ocean=.4*c+.2*pow(spe,16.)\n ;c=ocean;}\nreturn c*a+e;}\n\nvec3 renderSpace(in vec3 t,vec3 s)//rayDirection sunDirection\n{float n=noise3(t+iTime/400.);s.x=pow(sat(dot(t,s)),30.);//sun\n;vec2 cellular=cellular2x2x2(t*78.*(1.+.25*n))// Mix in galaxy\n;vec3 c=smoothstep(.75+.05*n,1.,(1.-cellular.x))*texture(iChannel1, t.xy).xyz*2.5*(1.-s.x);\n;c*=(1.+vec3(0,0,1.5*abs(n)));\n;return c+s.x*2.*vec3(.85,.9,1);}//mix sun color\n\nvec3 render(vec3 u,vec3 t,vec3 s)//rayorigin,raydirection,sundirction\n{vec2 iAtmos=lineIntersectSphere(u,t,ATMOSPHERE_UPPER)\n,iGround=rayMarch(u, t, 0.75, 1.0, MAX)\n,P=vec2(iAtmos.x,min(iAtmos.y,iGround.x))\n;vec3 c = vec3(0)    \n;if(iAtmos.x<MAX) c=in_scatter(u,t,P,s)\n;if(iGround.x<iAtmos.y\n){vec3 a=u+t*P.x,b=u+t*P.y\n ;c+=renderPlanet(u,t,iGround,s)*attenuate(a,b,vec3(0))\n;}else c+=renderSpace(t,s)\n;return c;}\n\n//lazy camera\nmat3 setCamera(vec3 u,float r){u=normalize(u)\n;vec3 p=vec3(sin(r),cos(r),.0),c=normalize(cross(u,p))\n;return mat3(c,normalize(cross(c,u)),u);}\n\nvoid mainImage(out vec4 o,vec2 u)\n{vec2 p=u2(u.xy/iResolution.xy)\n;p.x *= iResolution.x/iResolution.y;    \n// Camera origin\n;vec3 ro = vec3(sin(time()/8.0)*SCALE*2.0635, 0.0, cos(time()/8.0)*SCALE*2.0635);\n;vec3 ta = vec3(0,0,0);//Camera target\n;vec3 t=setCamera(ta-ro,.0)*normalize(vec3(p.x,p.y,2.));// ray direction\n;const vec3 s=normalize(vec3(0,0,-1))   //sun direction \n;vec3 c=render(ro,t,s)\n//;c=pow(c,.4545)\n;o=vec4(c,1);}",
      "inputs": [
        {
          "id": "XsX3Rn",
          "src": null,
          "ctype": null,
          "channel": 1,
          "sampler": {
            "filter": "mipmap",
            "wrap": "repeat",
            "vflip": "false",
            "srgb": "false",
            "internal": "byte"
          },
          "published": 1
        },
        {
          "id": "Xsf3zn",
          "src": null,
          "ctype": null,
          "channel": 0,
          "sampler": {
            "filter": "mipmap",
            "wrap": "repeat",
            "vflip": "false",
            "srgb": "false",
            "internal": "byte"
          },
          "published": 1
        }
      ],
      "outputs": [
        {
          "id": "4dfGRr",
          "channel": 0
        }
      ]
    }
  ]
}