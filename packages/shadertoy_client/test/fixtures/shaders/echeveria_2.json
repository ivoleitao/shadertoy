{
    "ver": "0.1",
    "info": {
        "id": "WtGXWm",
        "date": "1582809862",
        "viewed": 5452,
        "name": "Echeveria II",
        "username": "tdhooper",
        "description": "This time I'm distributing leaves on a hemisphere. Using brute-force AO as the usual approach looks bad with this model; it's slow so you can toggle it with the define\n\n[url=https:\/\/media.giphy.com\/media\/Y0mfLzgzBIfgmCqyqF\/source.gif]GIF version[\/url]",
        "likes": 131,
        "published": 3,
        "flags": 0,
        "usePreview": 0,
        "tags": [
            "plant",
            "succulent"
        ],
        "hasliked": 0
    },
    "renderpass": [
        {
            "inputs": [],
            "outputs": [
                {
                    "id": "4dfGRr",
                    "channel": 0
                }
            ],
            "code": "\/\/#define AA 3\n#define AO\n\/\/#define GIF\n\n\/\/ voronoi - adapted from iq https:\/\/www.shadertoy.com\/view\/ldl3W8\n\nvec2 hash2( vec2 p )\n{\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat voronoi( in vec2 x )\n{\n    vec2 cell = floor(x);\n\n    float d = 1e12;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 offset = vec2(float(i),float(j));\n        vec2 pos = hash2( cell + offset );\n        vec2 r = cell + offset + pos;\n        d = min(d, length(x - r));\n    }\n\n    return d;\n}\n\n\/\/ HG_SDF \n\nconst float PI  = 3.14159265359;\nconst float PHI = 1.61803398875;\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat smin(float a, float b, float k){\n    float f = clamp(0.5 + 0.5 * ((a - b) \/ k), 0., 1.);\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\n}\n\nfloat smax(float a, float b, float k) {\n    return -smin(-a, -b, k);\n}\n\nfloat range(float vmin, float vmax, float value) {\n  return (value - vmin) \/ (vmax - vmin);\n}\n\nfloat rangec(float a, float b, float t) {\n    return clamp(range(a, b, t), 0., 1.);\n}\n\n\n\/\/ Modelling\n\nfloat time;\nbool lightingPass;\nmat3 modelMat;\n\nstruct Model {\n\tfloat d;\n    vec3 p;\n    vec2 uv;\n    vec2 cell;\n    float wedges;\n    float slice;\n    float len;\n};\n\nModel leaf(vec3 p, vec3 cellData) {\n    \/\/cellData = vec3(0,0,.1);\n    \n    vec2 cell = cellData.xy;\n    float cellTime = cellData.z;\n    \n    \/\/cell.x = 0.;\n    \/\/cell.y = .1;\n    \/\/cellTime = .2;\n\n    float d = 1e12;\n    float d2 = 1e12;\n    float slice = 1e12;\n    float wedge, wedges;\n\n    \/\/ orient\n    pR(p.xz, -cell.x);\n    pR(p.zy, cell.y);\n\n    vec3 pp = p;\n\n    cellTime = max(cellTime, 0.);\n\n    float core = length(p) - .1;\n\n    float len = max(cellTime*3. - .2, 0.);\n    len = pow(len, .33);\n    float llen = len;\n\n\n    if (cellTime > 0.) {\n\n        \/\/ wedge\n        float ins = .25;\n        p.z += ins;\n        vec3 n = normalize(vec3(1,0,.35));\n        wedge = -dot(p, n);\n        wedge = max(wedge, dot(p, n * vec3(1,1,-1)));\n        wedge = smax(wedge, p.z - len*1.12 - ins, len);\n        p.z -= ins;\n\n        \/\/ wedge2\n        ins = .2;\n        p.z += ins;\n        n = normalize(vec3(1,0,.4));\n        float wedge2 = -dot(p, n);\n        wedge2 = max(wedge2, dot(p, n * vec3(1,1,-1)));\n        wedge2 = smax(wedge2, p.z - len*.95 - ins, len*.6);\n        p.z -= ins;\n\n        float r = len \/ 8.;\n\n        float top = p.y - len * .5;\n        float curve = smoothstep(0., .2, cellTime);\n\n        len *= mix(1.5, .65, curve);\n        pR(p.zy, -mix(.2, .7, curve));\n        slice = length(p - vec3(0,len,0)) - len;\n        d2 = abs(slice) - .05;\n        d2 = max(d2, top);\n        \n        float d3 = smax(d2, wedge, .05);\n        float d4 = smax(d2, wedge2, .05);\n        wedges = smin(wedge, wedge2, .01);\n        d3 = smin(d3, d4, .01);\n        d = d3;\n        \n        p = pp;\n        len = llen;\n        vec2 uv = p.xz \/ len;\n        return Model(d, p, uv, cell, wedges, slice, len);\n    }\n\n\treturn Model(d, p, vec2(0), vec2(0), 0., 0., 0.);\n}\n\nvec3 calcAlbedo(Model model) {    \n    vec3 col = vec3(.15,.15,.4);\n\n\tvec3 p = model.p;\n    float len = model.len;\n    vec2 cell = model.cell;\n    float wedges = model.wedges;\n    float slice = model.slice;\n    vec2 uv = model.uv;\n    \n    float v = voronoi((uv+4.)*30.);\n    float v2 = voronoi((uv+4.)*4.+cell.x);\n\n    col = mix(col, vec3(.125,.2,.4), 1.-v2);\n    float tip = length(p - vec3(0,.2,len*.9));\n\n    tip = smoothstep(.5, .0, tip);\n    tip *= smoothstep(.07, .0, abs(slice+.01));\n    tip *= smoothstep(-.2, .0, wedges);\n    tip = pow(tip, 1.5);\n    col = mix(col, vec3(1,.2,.5), tip);\n\n    float vs = 1.-uv.y*1.;\n    vs *= smoothstep(.0, -.1, wedges);\n    vs *= smoothstep(.0, .05, abs(slice));\n    v = smoothstep(vs + .1, vs - .5, v*1.5);\n    col = mix(col, vec3(.05,.05,.2), v*v2);\n\n    col *= mix(vec3(1), vec3(.5,5.,1.8), smoothstep(.2, 1.8, cell.y) * .75);\n  \n    return col;\n}\n\nvec3 calcCellData(\n    vec2 cell,\n    vec2 offset,\n    float maxBloomOffset,\n    mat2 transform,\n    mat2 transformI,\n    float stretch,\n    float stretchStart,\n    float stretchEnd,\n    float t\n) {\n\n    float sz = maxBloomOffset + PI \/ 2.;\n\n    cell = transform * cell;\n\n    \/\/ Snap to cell center\n    cell = round(cell);\n    cell += offset;\n\n    \/\/ Hide leaves outside the growth area\n    cell = transformI * cell;\n    cell.y *= stretch \/ sz \/ stretchStart;\n    cell.y = max(cell.y, .5\/stretchStart); \/\/ clamp, not sure why this magic number\n    cell.y \/= stretch \/ sz \/ stretchStart;\n    cell = transform * cell;\n\n    \/\/ Snap after clamp\n    cell = round(cell);\n\n    cell = transformI * cell;\n\n    \/\/ calculate cell time\n    float y = cell.y * (stretch \/ sz);\n    float cellAppearTime = (stretchStart - y) \/ (stretchStart - stretchEnd);\n    float cellTime = t - cellAppearTime;\n\n    cell.y -= maxBloomOffset;\n\n    return vec3(cell, cellTime);\n}\n\nModel opU(Model a, Model b) {\n    if (a.d < b.d) {\n    \treturn a;\n    } else {\n    \treturn b;\n    }\n}\n\nmat2 phyllotaxis;\nvoid calcPhyllotaxis() {\n    vec2 cc = vec2(5., 8.);\n    float aa = atan(cc.x \/ cc.y);\n    float scale = (PI*2.) \/ sqrt(cc.x*cc.x + cc.y*cc.y);\n    mat2 mRot = mat2(cos(aa), -sin(aa), sin(aa), cos(aa));\n    mat2 mScale = mat2(1.\/scale,0,0,1.\/scale);\n\tphyllotaxis = mRot * mScale;\n}\n\nModel bloom(vec3 p, float t) {\n\n    p.y -= .05;\n\n    vec2 move = vec2(0, t);\n    float stretchStart = .25;\n    float stretchEnd = 1.;\n    float stretch = mix(stretchStart, stretchEnd, t);\n    float maxBloomOffset = PI \/ 2.;\n\n    vec2 cell = vec2(\n        atan(p.x, p.z),\n        atan(p.y, length(p.xz)) + maxBloomOffset\n    );\n\n    mat2 mStretch = mat2(1,0,0,stretch);\n    mat2 transform = phyllotaxis * mStretch;\n    mat2 transformI = inverse(transform);\n\n\tModel res = Model(1e12, p, vec2(0), vec2(0), 0., 0., 0.);\n    \/\/res.d = length(p) - 1.; return res;\n\n    \/\/ compile speed optim from IQ\n    for( int m=min(iFrame,0); m<3; m++ )\n    for( int n=min(iFrame,0); n<3; n++ )\n    {\n    \tres = opU(res, leaf(p, calcCellData(cell, vec2(m, n) - 1., maxBloomOffset, transform, transformI, stretch, stretchStart, stretchEnd, t)));\n    }\n\n    return res;\n}\n\nModel map(vec3 p) {\n    p *= modelMat;\n    float t;\n    \n    float bound = length(p) - 1.3;\n    if (bound > .01 && ! lightingPass) {\n\t\treturn Model(bound, p, vec2(0), vec2(0), 0., 0., 0.);\n    }\n\n    pR(p.xy, time * -PI);\n\n    vec3 pp = p;\n    \n    float side = sign(p.y);\n    p.y = abs(p.y);\n\tp.z *= side;\n\n    t = time + .5 * side;\n    t = sin(t * PI - PI\/2.) * .5 + .5;\n    pR(p.xz, time * PI);\n    Model model = bloom(p, t);\n    \n    if (abs(p.y) < .34) {\n        p = pp;\n    \tside *= -1.;\n        p.yz *= side;\n        t = time + .5 * side;\n    \tt = sin(t * PI - PI\/2.) * .5 + .5;\n        pR(p.xz, time * PI);\n        Model model2 = bloom(p, t);\n        model = opU(model, model2);\n    }\n\n    return model;\n}\n\n\/\/ compile speed optim from IQ https:\/\/www.shadertoy.com\/view\/Xds3zN\nvec3 calcNormal(vec3 pos){\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).d;\n    }\n    return normalize(n);\n}\n\n\/\/ https:\/\/www.shadertoy.com\/view\/3dyXzD\nvec3 randDir( vec3 n, vec2 seed ) {\n    vec3  uu = normalize( cross( n, vec3(0.0,1.0,1.0) ) );\n    vec3  vv = cross( uu, n );\n    \n    float ra = sqrt(seed.y);\n    float rx = ra*cos(6.2831*seed.x); \n    float ry = ra*sin(6.2831*seed.x);\n    float rz = sqrt( 1.0-seed.y );\n    vec3  rr = vec3( rx*uu + ry*vv + rz*n );\n\n    return normalize( rr );\n}\n\nfloat hitLength(vec3 pos, vec3 dir, float maxDist) {\n    float len = 0.;\n    const int steps = 15;\n    float dist = maxDist \/ float(steps);\n    vec3 rayPos;\n    for (int i = 0; i < steps; i++) {\n        len += dist;\n        dist = map(pos + dir * len).d;\n        if (abs(dist) < .001) {\n            break;\n        }\n        if (len > maxDist) {\n            len = maxDist;\n            break;\n        }\n    }\n    return len \/ maxDist;\n}\n\nfloat calcAO(vec3 pos, vec3 nor, vec2 seed, float maxDist) {\n    float len = 0.;\n    const float SAMPLES = 3.;\n    for (float x = 0.; x < SAMPLES; x++)\n    for (float y = 0.; y < SAMPLES; y++)\n    {\n        vec2 s = seed + vec2(x, y) \/ SAMPLES;\n        s = hash2(s);\n        vec3 dir = randDir(nor, s);\n        len += hitLength(pos, dir, maxDist);\n    }\n\n    len \/= SAMPLES * SAMPLES;\n    return len;\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nmat3 rotX(float a) {\n    return mat3(1,0,0, 0,cos(a),-sin(a), 0,sin(a),cos(a));\n}\n\nmat3 rotY(float a) {\n    return mat3(cos(a),0,sin(a), 0,1,0, -sin(a),0,cos(a));\n}\n\nmat3 rotZ(float a) {\n    return mat3(cos(a),-sin(a),0, sin(a),cos(a),0, 0,0,1);\n}\n\nfloat pat(vec2 uv) {\n    vec2 p = vec2(atan(uv.x\/uv.y), log(length(uv)));\n   \n   \tp *= phyllotaxis;\n    p = p * 4.;\n    \n    p -= vec2(0,8) * time;\n\n    p = mod(p, 1.);\n    float d = length(p - .5) - .1;\n    float fw = fwidth(d);\n\n    d = abs(d) - .01;\n    d \/= fw;\n    d = clamp(d, 0., 1.);\n    \n    return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec3 col;\n    vec3 tot = vec3(0.0);\n\n    float mTime = mod(iTime \/ 4., 1.) + .35;\n    time = mTime;\n    \n    calcPhyllotaxis();\n    modelMat = rotZ(-.9) * rotX(.05) * rotY(-1.1);\n\n    vec2 o = vec2(0);\n\n    #ifdef AA\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n    \/\/ pixel coordinates\n    o = vec2(float(m),float(n)) \/ float(AA) - 0.5;\n    \/\/ time coordinate (motion blurred, shutter=0.5)\n    float d = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n    time = mTime - 0.1*(1.0\/24.0)*(float(m*AA+n)+d)\/float(AA*AA-1);\n    #endif\n\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))\/iResolution.y;\n\n        vec3 camPos = vec3(0,0,-2.6);\n        #ifdef GIF\n        \tcamPos.z = -2.8;\n       \t#endif\n        mat3 camMat = calcLookAtMatrix( camPos, vec3(0,-.05,0), 0.);\n        vec3 rayDirection = normalize( camMat * vec3(p.xy,1.8) );\n\n        vec3 rayPosition = camPos;\n        float rayLength = 0.;\n        float dist = 0.;\n        bool bg = false;\n        Model model;\n\n        lightingPass = false;\n        \n        for (int i = 0; i < 300; i++) {\n            rayLength += dist;\n            rayPosition = camPos + rayDirection * rayLength;\n            model = map(rayPosition);\n            dist = model.d;\n\n            if (abs(dist) < .001) {\n                break;\n            }\n            \n            if (rayLength > 5.) {\n                bg = true;\n                break;\n            }\n        }\n        \n        lightingPass = true;\n        \n        col = vec3(.4,.4,1);\n        #ifndef GIF\n        \tcol = mix(col, vec3(.0,1.5,1.5)*1.5, (1.-pat(p))*.5);\n        \tcol = mix(col, vec3(.63,.7,1), smoothstep(2.5, .5, length(p)));\n        #else\n        \tcol = mix(col, vec3(.63,.7,1), .95);\n        #endif\n        col *= vec3(.9,1.,1.);\n        col += .1;\n        \n        \/\/bg = true;\n        \n        if ( ! bg) {\n\n            vec3 pos = rayPosition;\n            vec3 rd = rayDirection;\n            vec2 seed = hash2(p + time);\n            \n            #ifndef AA\n            \tseed *= .0000001;\n            #endif\n            \n            vec3  nor = calcNormal(pos);\n            \n            float occ = 1.;\n            #ifdef AO\n            \tocc = calcAO(pos, nor, seed, .85);\n            \tocc = clamp(pow(occ*1.25, 1.5), 0., 1.);\n            #endif\n            float amb = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n            float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\n            vec3 lin = vec3(0);\n            lin += 1.70 * amb * vec3(1.30,1.00,0.70) * occ;\n            lin += 0.90 * amb * vec3(0.30,0.80,1.30);\n            lin += 1.00 * fre * vec3(1.00,1.00,1.00) * occ;\n\n\n            vec3 albedo = calcAlbedo(model);\n            col = albedo * lin;\n            \n            \/\/col *= mix(vec3(1), vec3(.0,.5,.7)*.5, 1.-occ);\n\n        }\n\n        tot += col;\n    #ifdef AA\n    }\n    tot \/= float(AA*AA);\n    #endif\n\n    col = tot;\n    col = pow( col, vec3(0.4545) );\n    fragColor = vec4(col,1.0);\n}\n",
            "name": "Image",
            "description": "",
            "type": "image"
        }
    ]
}