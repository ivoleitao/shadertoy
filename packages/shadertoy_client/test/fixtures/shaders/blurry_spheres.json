{
    "ver": "0.1",
    "info": {
        "id": "4scBW8",
        "date": "1524815120",
        "viewed": 3796,
        "name": "Blurry Spheres",
        "username": "Klems",
        "description": "Short exemple of depth of field with cone tracing. Click the screen to change the focal length.",
        "likes": 105,
        "published": 3,
        "flags": 0,
        "usePreview": 0,
        "tags": [
            "3d",
            "raymarch",
            "dof"
        ],
        "hasliked": 0
    },
    "renderpass": [
        {
            "inputs": [],
            "outputs": [
                {
                    "id": "4dfGRr",
                    "channel": 0
                }
            ],
            "code": "#define PI 3.14159265359\n#define rot(a) mat2(cos(a + PI*0.25*vec4(0,6,2,0)))\n#define FOV 2.0\n#define HEX vec2(1, 1.73205080757)\n\n#define LIGHT_ENABLE\n#define LIGHT_FREQ 0.3\n#define LIGHT_COLOR vec3(0.05, 0.2, 0.8)\n\n\/\/ Dave Hoskins hash\nfloat hash13( in vec3 p3 ) {\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\/\/ hexagonal tiling\nvec2 hexCenter( in vec2 p ) {\n    vec2 centerA = (floor(p.xy*HEX)+0.5)\/HEX;\n    vec2 centerB = (floor((p.xy+HEX*0.5)*HEX)+0.5)\/HEX-HEX*0.5;\n    vec2 a = p.xy-centerA.xy; vec2 b = p.xy-centerB.xy;\n    return dot(a,a)<dot(b,b) ? centerA : centerB;\n}\n\n\/\/ control sphere height\nvec3 getSphereCenter( in vec2 c ) {\n    return vec3(c, sin(c.x-c.y*4.3+iTime)*0.2);\n}\n\n\/\/ main distance function, returns distance and color\nfloat de( in vec3 p, in vec3 dir, in float r, out vec3 color ) {\n    \n    \/\/ translate and get the center\n    p.xy += iTime;\n    vec2 center = hexCenter(p.xy);\n    \/\/ find out where the red light is\n    float red = floor(iTime*LIGHT_FREQ)+0.5;\n    float fRed = smoothstep(0.5, 0.0, abs(fract(iTime*LIGHT_FREQ)-0.5));\n    vec3 centerRed = getSphereCenter(hexCenter(red\/LIGHT_FREQ + vec2(0.5, 1.5)));\n    \n    #ifndef LIGHT_ENABLE\n    fRed = 0.0;\n    #endif\n    \n    \/\/ accumulate distance and color\n    float d = 9e9;\n    color = vec3(0);\n    float colorAcc = 0.0;\n    for (int i = 0 ; i < 7 ; i++) {\n        float theta = float(i) * (2.0*PI\/6.0);\n        vec2 offset = vec2(sin(theta), cos(theta))*min(1.0\/HEX.y, float(i));\n        vec3 sphere = getSphereCenter(center + offset);\n        vec3 inCenter = p - sphere;\n        float len = length(inCenter);\n        vec3 norm = inCenter \/ len;\n        vec3 toRed = sphere-centerRed;\n\n        \/\/ select the nearest sphere\n        float dist = len-0.3;\n        d = min(d, dist);\n\n        \/\/ colors and light\n        vec3 albedo = vec3(sin(sphere.x*90.0+sphere.y*80.0)*0.45+0.5);\n        vec3 colorHere = vec3(0);\n        \n        if (dot(toRed, toRed) < 0.001) {\n            albedo = mix(albedo, vec3(0.0), fRed);\n            colorHere += LIGHT_COLOR*fRed*4.0;\n        } else {\n            vec3 lightDir = centerRed-p;\n            float len = dot(lightDir, lightDir);\n            lightDir *= inversesqrt(len);\n            vec3 col = LIGHT_COLOR*fRed\/(len+1.0)*2.0;\n            colorHere += albedo*max(0.0, dot(norm, lightDir)+0.5\/len)*col;\n            colorHere += albedo*pow(max(0.0, dot(lightDir, reflect(dir, norm))), 8.0)*col;\n        }\n        \n        const vec3 lightDir = normalize(vec3(1, -1, 3));\n        colorHere += albedo*max(0.0, dot(lightDir, norm));\n        colorHere += albedo*pow(max(0.0, dot(lightDir, reflect(dir, norm))), 8.0);\n        \n        \/\/ accumulate color across neighborhood\n        float alpha = max(0.0001, smoothstep(r, -r, dist));\n        color += colorHere*alpha;\n        colorAcc += alpha;\n    }\n    \n    color \/= colorAcc;\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) \/ iResolution.y;\n\tvec3 from = vec3(0, 0, 1.2);\n\tvec3 dir = normalize(vec3(uv, -1.0\/tan(FOV*0.5)));\n\tdir.yz *= rot(-0.85);\n    dir.xy *= rot(0.2);\n    \n    float focal = 2.5;\n    if (iMouse.z > 0.5) focal = 1.0+iMouse.y\/iResolution.y*4.0;\n    float sinPix = sin(FOV \/ iResolution.y);\n    vec4 acc = vec4(0, 0, 0, 1);\n    vec3 dummy = vec3(0);\n    float totdist = de(from, dir, 0.0, dummy)*hash13(vec3(fragCoord, iFrame));\n    for (int i = 0 ; i < 100 ; i++) {\n\t\tvec3 p = from + totdist * dir;\n        float r = max(totdist*sinPix, abs((totdist-focal)*0.1));\n        vec3 color = vec3(1);\n        float dist = de(p, dir, r, color);\n        \n        \/\/ cone trace the surface\n\t\tfloat alpha = smoothstep(r, -r, dist);\n        acc.rgb += acc.a * (alpha*color.rgb);\n        acc.a *= (1.0 - alpha);\n        \n        \/\/ hit a surface, stop\n        if (acc.a < 0.01) break;\n        \/\/ continue forward\n        totdist += max(abs(dist), r*0.5);\n\t}\n    \n    fragColor.rgb = clamp(acc.rgb, vec3(0), vec3(1));\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0\/2.2));\n    fragColor.a = 1.0;\n}",
            "name": "Image",
            "description": "",
            "type": "image"
        }
    ]
}