{
    "ver": "0.1",
    "info": {
        "id": "NddSzl",
        "date": "1634433043",
        "viewed": 4691,
        "name": "Synthwave song (sound)",
        "username": "athibaul",
        "description": "Let's compose a synthwave song on GPU!",
        "likes": 96,
        "published": 3,
        "flags": 8,
        "usePreview": 1,
        "tags": [
            "sound",
            "analog",
            "synth",
            "bass",
            "gpusound"
        ],
        "hasliked": 0
    },
    "renderpass": [
        {
            "inputs": [],
            "outputs": [
                {
                    "id": "4dfGRr",
                    "channel": 0
                }
            ],
            "code": "\nvec4 applyColor(vec4 c1, vec4 c2)\n{\n    vec3 col = mix(c1.rgb, c2.rgb, c2.a);\n    float alpha = 1. - (1.-c1.a) * (1.-c2.a);\n    \n    return vec4(col, alpha);\n}\n\n\nvec2 wheelPos(float time)\n{\n    \/\/ Angle of the wheels of the tape machine at given time\n    \n    float phase1 = phasePortamento(time, 0., 1.25, 0.5, 4.0);\n    float phase2 = phasePortamento(time, 0., 0.48, 0.5, 4.0);\n    \n    return TAU*vec2(phase1, phase2); \n}\n\n\nvec4 drawWheel(vec2 p, float theta0)\n{\n    \/\/ theta0 : angle of symmetry (TAU\/3, TAU\/4...)\n    float d = length(p) - 1.0; \/\/ disk\n    float theta = atan(p.y,p.x);\n    theta = theta0*round(theta\/theta0);\n    p *= mat2(cos(theta), sin(theta), -sin(theta), cos(theta));\n    \n    \/\/ Symmetric pattern\n    d = max(d, 0.2-length(p-vec2(0.62,0.0)));\n    \n    vec3 col = vec3(0.5);\n    float alpha = smoothstep(0.001,-0.001,d);\n    \n    return vec4(col, alpha);\n}\n\n\nfloat scoreTime()\n{\n    return iTime - 4.;\n}\nfloat drumTime()\n{\n    return iTime - 4. - 8.*beatdur;\n}\nfloat timeSinceKick()\n{\n    float t = drumTime();\n    return (t > 0.) ? mod(t, 2.*beatdur) : 20.;\n}\nfloat timeSinceSnare()\n{\n    float t = drumTime() - beatdur;\n    return (t > 0.) ? mod(t, 2.*beatdur) : 20.;\n}\n\n\n\nvec2 lensDistortion(vec2 p, float dist)\n{\n    return (dist > 0.) ? p * (1. + dist*length(p)) : p \/ (1. - dist*length(p));\n}\n\n\nvec3 sceneOne(vec2 p)\n{\n    float dist = 1.0*smoothstep(4.0,0.0,iTime);\n    \/\/ \"Acceleration effect\": distort picture on riser\n    float riserTime = (scoreTime() - 40.*beatdur)\/(7.*beatdur);\n    riserTime = clamp(riserTime, 0., 1.);\n    dist += riserTime * (1.- 0.167\/ (1.-riserTime));\n    p = lensDistortion(p, dist);\n\n    \/\/ Horizontal grid of magenta lines\n    \n    \/\/ Calculate projection onto floor plane\n    vec2 q = vec2(p.x\/p.y, 1.\/p.y);\n    \n    \/\/ Animate depending on time\n    float offs = -0.2*iTime - phasePortamento(max(scoreTime(),0.), 1.0, 20.0, 40.*beatdur,47.*beatdur);\n    q.y += offs;\n    \n    \/\/ Find closest horizontal\/vertical line\n    vec2 qh = vec2(q.x, round(q.y));\n    vec2 qv = vec2(round(q.x), q.y);\n    qh.y -= offs;\n    qv.y -= offs;\n    \n    \/\/ Reproject onto screen\n    vec2 ph = vec2(qh.x\/qh.y, 1.\/qh.y);\n    vec2 pv = vec2(qv.x\/qv.y, 1.\/qv.y);\n    \n    \/\/ Clamp vertically to lower half\n    ph.y = min(ph.y, 0.);\n    pv.y = min(pv.y, 0.);\n    \n    \/\/ Shade according to distance\n    float dh = length(p-ph);\n    float dv = length(p-pv);\n    vec3 col = vec3(0);\n    \n    float eps = 0.01;\n    dh = max(dh-0.1*eps*abs(qh.y),0.);\n    dv = max(dv-0.1*eps*abs(qv.y),0.);\n    \n    float intensity = 0.2 + exp(-8.*timeSinceKick());\n    \n    col += vec3(1., 0.1, 1.) * 0.001\/(dh*dh+eps*eps) * intensity;\n    col += vec3(1., 0.1, 1.) * 0.001\/(dv*dv+eps*eps) * intensity;\n    \n    \/\/col = vec3(0.05) * abs(qv.y);\n    \n    \n    \/\/ Synthwave \"sun\"\n    \n    intensity = 1. + 5.*exp(-5.*timeSinceSnare());\n    float d = length(p - vec2(0,0.5)) - 0.62*0.5;\n    \n    float expo = min(1.\/abs(p.y),8.);\n    vec3 sunBase = vec3(2.,0.6,0.1);\n    vec3 sunCol = pow(sunBase, vec3(expo));\n    float occl = 0.5+0.5*sin(8.\/p.y - TAU*offs);\n    occl = max(occl - 0.5, 0.);\n    \/\/occl = mix(occl, 1., 0.03);\n    occl = mix(occl, 1., smoothstep(0.3,0.8,p.y));\n    col += 1.5 * sunCol * smoothstep(0.02,0.0,d) * occl * intensity;\n    \n    \/\/ Add sun halo\n    col += 0.2 * sunBase * min(0.03\/(d*d + 0.3*0.3), 1.) * intensity;\n    col += 0.2 * vec3(0.1,1.0,1.0) * smoothstep(0.,0.01,d) * 0.002\/(d*d+0.005) * intensity;\n    \n    \n    \/\/ Arpeggio animation\n    \n    for(float i=0.; i < 17.; i++)\n    {\n        float timeSinceArpUp = mod(scoreTime() - i*0.125*beatdur, 4.*beatdur);\n        float timeSinceArpDown = mod(scoreTime() - 4.*beatdur + i*0.125*beatdur, 4.*beatdur);\n        float timeSinceNote = min(timeSinceArpUp, timeSinceArpDown);\n        timeSinceNote = (scoreTime() >= i*0.125*beatdur) ? timeSinceNote : 10.;\n        \n        intensity = 5.*exp(-10.*timeSinceNote) + exp(-8.*timeSinceNote);\n        \n        float d = length(p + vec2(1.62,-0.5) - vec2(0.,0.05*(i-8.))) - 0.01;\n        d = min(d, length(p + vec2(-1.62,-0.5) - vec2(0.,0.05*(i-8.))) - 0.01);\n        \n        col += intensity * smoothstep(0.01,0.0,d) * vec3(0.1,1.,1.) * 2.;\n        col += intensity * smoothstep(0.0,0.01,d) * vec3(0.1,1.,1.) * 0.001 \/ (d*d+0.01);\n    }\n    \n    \n    return col * smoothstep(1.0,4.0,iTime);\n    \n}\n\n\nfloat quinticInflectionCurve(float x)\n{\n    \/\/ Polynomial of degree 5 such that:\n    \/\/  P(0) = 0 ;  P(1) = 0 ;\n    \/\/ P'(0) = 1 ; P'(1) = 0 ;\n    \/\/ P\"(0) = 0 ; P\"(1) = 0.\n    \n    \/\/ Its maximum is a bit below 0.2\n    \n    \n    return x*(1.-x) + x*x*(x-1.) + 2.*x*x*(x-1.)*(x-1.) - 3.*x*x*x*(x-1.)*(x-1.);\n}\n\nvec4 drawCar(vec2 p)\n{\n\n    \/\/ Curve of the main body \n    float hx = (p.x+0.25)\/(1.3+0.25);\n    float h = quinticInflectionCurve(hx) * 0.6 + 0.5;\n    float alpha = step(-0.25,p.x) * smoothstep(0.,0.01, h - p.y) * step(p.x, 1.3) * step(0.1,p.y);\n    \n    \/\/ Back of the car\n    float hy = (p.y-0.1)\/(0.5-0.1);\n    h = 0.2* hy * (1.-hy) + 1.3;\n    alpha = max(alpha, smoothstep(0.,0.01, h-p.x) * step(0.1,p.y) * step(p.y,0.5) * step(1.3,p.x));\n    \n    \/\/ Front of the car\n    hx = (p.x+1.35)\/(-0.25+1.35);\n    h = 0.2 * (1. -(1.-hx)*(1.-hx)) + 0.3;\n    alpha = max(alpha, smoothstep(0.,0.01,h-p.y) * step(-1.35,p.x) * step(p.x,-0.25) * step(0.1,p.y));\n    \/\/ Carve out the intake\n    hy = (p.y-0.1)\/(0.5-0.1);\n    h = -1.35 + 0.2*hy*(1.-hy);\n    alpha = min(alpha, smoothstep(0.,0.01,p.x-h));\n    \/\/ Front lower slope\n    hx = (p.x+1.1)\/(-1.1+1.35);\n    h = 0.2 - 0.1*(1. - hx*hx);\n    alpha = min(alpha, 1. - smoothstep(0.,0.01,h-p.y) * step(p.x,-1.1));\n    \/\/ Back lower slope\n    hx = (p.x-1.)\/(1.-1.3);\n    h = 0.15 - 0.05*(1. - hx*hx);\n    alpha = min(alpha, 1. - smoothstep(0.,0.01,h-p.y) * step(1.0,p.x));\n    \n    \/\/ Wheels\n    float d = length(p - vec2(-0.85,0.2)) - 0.2;\n    alpha = max(alpha, smoothstep(0.01,0.,d));\n    d = length(p - vec2(0.85,0.2)) - 0.2;\n    alpha = max(alpha, smoothstep(0.01,0.,d));\n    \n    vec3 col = vec3(0);\n    \n    \/\/ Side line\n    vec2 q = p;\n    q.x = clamp(q.x, -0.5, 0.6);\n    q.y = 0.2 + 0.2*smoothstep(-0.3,0.5,q.x);\n    d = length(q-p);\n    float intensity = pow(0.5 + 0.5*sin(TAU*p.x - 2.*iTime), 3.) + 0.1;\n    col += vec3(0.1,1,1) * 0.0001\/(d*d + 0.00001) * smoothstep(-0.8,1.,p.x) * intensity;\n    \/\/ Headlights\n    hy = (p.y-0.3)\/(0.5-0.3);\n    h = -1.1+0.4*hy*hy;\n    col += vec3(8) * smoothstep(0.32,0.33,p.y) * smoothstep(0.,0.01,h-p.x) * smoothstep(-0.95,-1.3,p.x);\n    \/\/ Backlights\n    hy = (p.y-0.1)\/(0.5-0.1);\n    h = 0.1* hy * (1.-hy) + 1.3;\n    col += vec3(2,0.01,0.01) * smoothstep(0.,0.01,p.x-h) * smoothstep(0.35,0.36,p.y);\n    \n    return vec4(col, alpha);\n}\n\nvec3 sceneTwo(vec2 p)\n{\n    vec3 col = vec3(0.);\n\n    \/\/ Backdrop: setting sun\n    float intensity = exp(-5.*timeSinceSnare());\n    float d = length(p - vec2(-1.0,0.5)) - 0.62*0.5;\n    \n    float expo = min(1.\/abs(p.y),8.);\n    vec3 sunBase = vec3(2.,0.6,0.1);\n    vec3 sunCol = pow(sunBase, vec3(expo));\n    float occl = 0.5+0.5*sin(8.\/p.y + iTime);\n    occl = max(occl - 0.5, 0.);\n    \/\/occl = mix(occl, 1., 0.03);\n    occl = mix(occl, 1., smoothstep(0.3,0.8,p.y));\n    col += 20. * sunCol * smoothstep(0.02,0.0,d) * occl;\n    \n    \/\/ Add sun halo\n    col += 2. * sunBase * min(0.03\/(d*d + 0.3*0.3), 1.) * intensity;\n    \n    \/\/ Add sky\n    expo = 4.\/(p.y+1.03);\n    vec3 fogCol = 2.*pow(vec3(0.9,0.5,0.1), vec3(expo));\n    col += fogCol;\n    \n    \/\/ Add slight grid in the sky\n    vec2 q = 10.*vec2(p.x\/(p.y+1.), 2.\/(p.y+1.));\n    vec2 qh = vec2(q.x, round(q.y)), qv = vec2(round(q.x-0.5*iTime)+0.5*iTime, q.y);\n    float dq = min(length(q-qh), length(q-qv));\n    intensity = exp(-8.*timeSinceKick());\n    col += 0.5*fogCol * smoothstep(0.1,0.0,dq) * smoothstep(-0.9,0.5,p.y) * (0.5+intensity);\n    \n    \n    \/\/ Background : add skyline\n    float bh = rand(round(p.x*10. - 2.*iTime));\n    float opacity = 0.8*step(p.y+1.,bh);\n    bh = rand(round(p.x*20. - 2.*iTime))*0.5 + 0.2;\n    opacity = max(opacity, 0.5*step(p.y+1.,bh));\n    col = (opacity > 0.) ? mix(fogCol, vec3(0), opacity) : col;\n    \n    \n    \/\/ Draw pretty car\n    vec4 car = drawCar(p + vec2(0,1));\n    \n    col = applyColor(vec4(col,1.), car).rgb;\n    \n    \n    \/\/ Add light poles (with bass rhythm)\n    float polePos = 8.*(mod(scoreTime() - 0.25*beatdur, 0.5*beatdur)\/(0.5*beatdur) - 0.5);\n    col = mix(col, vec3(0), smoothstep(0.6,0.0,abs(p.x-polePos)));\n    \n    \n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*fragCoord-iResolution.xy)\/iResolution.y;\n\n    \n    \/\/ Time varying pixel color\n    vec3 col = sceneOne(uv);\n    if(scoreTime() > 47.*beatdur)\n    {\n        \/\/ Fade from white to black on clap\n        float tClap = scoreTime() - 47.*beatdur;\n        col = vec3(10.)* exp(-8.*tClap) * smoothstep(1., 0., tClap);\n    }\n    if(scoreTime() > 48.*beatdur)\n    {\n        col = sceneTwo(uv);\n    }\n    \n\n    \/\/col = applyColor(col, drawWheel(uv, TAU\/4.));\n\n    \/\/ Output to screen\n    col.rgb = 1.-exp(-col.rgb); \/\/ Tonemap\n    col.rgb = pow(col.rgb, vec3(1.\/2.2));\n    fragColor = vec4(col, 1.);\n}",
            "name": "Image",
            "description": "",
            "type": "image"
        },
        {
            "inputs": [],
            "outputs": [],
            "code": "\/\/ See \"Common\" tab\n\n\/\/ For anyone interested, I have started a tutorial series \n\/\/ on how to make music like this\n\/\/ Making Music in Shadertoy - Episode 1 : Basics, Waveforms, and a Simple Tune\n\/\/ https:\/\/www.shadertoy.com\/view\/ssjyDD\n",
            "name": "Sound",
            "description": "",
            "type": "sound"
        },
        {
            "inputs": [],
            "outputs": [],
            "code": "\/\/ Notations :\n\/\/ t = absolute time in seconds\n\/\/ tb = time in beats\n\/\/ te = time in seconds since start of envelope\n\n#define TAU (2.*3.1415926)\n\n\/\/ ESin --- Exponentially-decaying sine wave\n\/\/     f: frequency\n\/\/     d: decay rate\n#define ESin(f,d) sin(TAU*(f)*t)*exp(-d*t)\n\n#define midiratio(x) exp2((x)\/12.)\n#define midicps(x) (440.*midiratio((x)-69.))\n\nconst float bpm = 100.;\nconst float bps = bpm\/60.; \/\/ beats per second\nconst float beatdur = 1.\/bps; \/\/ beat duration\n\n\nfloat rand(float p)\n{\n    \/\/ Hash function by Dave Hoskins\n    \/\/ https:\/\/www.shadertoy.com\/view\/4djSRW\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat noise(float s){\n    \/\/ Noise is sampled at every integer s\n    \/\/ If s = t*f, the resulting signal is close to a white noise\n    \/\/ with a sharp cutoff at frequency f.\n    \n    \/\/ For some reason float(int(x)+1) is sometimes not the same as floor(x)+1.,\n    \/\/ and the former produces fewer artifacts?\n    int si = int(floor(s));\n    float sf = fract(s);\n    sf = sf*sf*(3.-2.*sf); \/\/ smoothstep(0,1,sf)\n    return mix(rand(float(si)), rand(float(si+1)), sf) * 2. - 1.;\n}\n\nfloat coloredNoise(float t, float fc, float df)\n{\n    \/\/ Noise peak centered around frequency fc\n    \/\/ containing frequencies between fc-df and fc+df\n    \n    \/\/ Assumes fc is an integer, to avoid problems with sin(large number).\n    \n    \/\/ Modulate df-wide noise by an fc-frequency sinusoid\n    return sin(TAU*fract(fc*t))*noise(t*df);\n}\n\nvec2 coloredNoise2(float t, float fc, float df)\n{\n    \/\/ Noise peak centered around frequency fc\n    \/\/ containing frequencies between fc-df and fc+df\n    \n    \/\/ Assumes fc is an integer, to avoid problems with sin(large number).\n    \n    \/\/ Modulate df-wide noise by an fc-frequency sinusoid\n    return sin(TAU*fract(fc*t))*vec2(noise(t*df),noise(-1000.-t*df));\n}\n\nfloat sweep(float t, float dur)\n{\n    \/\/ Exponential sweep from 20kHz to 20Hz in \"dur\" seconds\n    \/\/ Running freq: 20000*exp(-t\/dt)\n    \/\/ freq=20 at t=dur  ==>  20 = 20000*exp(-dur\/dt)\n    \/\/                   ==>  exp(-dur\/dt) = 1\/1000\n    \/\/                   ==>  -dur\/dt = log(1\/1000)\n    \/\/                   ==>  dt = dur\/log(1000)\n    float dt = dur\/log(1e3);\n    float intfreq = 20000.*exp(-t\/dt)*dt;\n    float phase = TAU*fract(intfreq);\n    float sig = sin(phase);\n    float env = step(0., t) * smoothstep(dur, 0.7*dur, t);\n    return sig*env*0.1;\n}\n\n\nfloat triBipolar(float x)\n{\n    \/\/ Triangle wave going from -1 to +1, starting at zero, 4-periodic.\n    return 1. - abs(2.-mod(x+1.,4.));\n}\n\n\nfloat triUnipolar(float x)\n{\n    \/\/ Triangle wave going from 0 to +1, starting at zero, 2-periodic.\n    return abs(1.-mod(x+1.,2.));\n}\n\nfloat fold(float x, float a, float b)\n{\n    \/\/ Force x to lie between a and b, \"bounce back\" when going too far.\n    return triUnipolar((x-a)\/(b-a)) * (b-a) + a;\n}\n\n\nfloat curve(float x, float a, float b, float curvature)\n{\n    \/\/ When x is on the a-side, outputs 0\n    \/\/ When x is on the b-side, outputs 1\n    \/\/ When x is between a and b, interpolates.\n    \/\/ curvature = 0 -> linear interpolation\n    \/\/ Negative curvature gives lower values, positive gives higher values.\n    x = (x-a)\/(b-a);\n    x = clamp(x, 0., 1.);\n    return pow(x, exp(-curvature));\n}\n\nfloat percEnv(float t, float atk, float rel, float cur)\n{\n    return curve(t, 0., atk, cur) * curve(t, atk+rel, atk, cur);\n}\n\nfloat rampIntegral(float x)\n{\n    \/\/ Integral of clamp(x,0.,1.).\n    \/\/ Used to calculate phase with portamento\n    return (x<=0.) ? 0. : (x < 1.) ? x*x*0.5 : x-0.5;\n}\n\nfloat phasePortamento(float t, float f1, float f2, float t1, float t2)\n{\n    \/\/ Integral of frequency of a note with portamento\n    \/\/ Transition lasts from t1 to t2, with initial frequency f1 and final frequency f2.\n    \/\/ freq(t) = f1 for t < t1\n    \/\/ ... = f2 for t > t2\n    \/\/ ... = linear interpolation in between\n    \n    \n    \/\/ Change of variable : x = (t-t1)\/(t2-t1).\n    \/\/ dt = (t2-t1)*dx\n    \/\/ int freq(t) dt = int freq(t(x)) * (t2-t1) dx\n    \/\/ ... = int (f1 + saturate(x)*(f2-f1)) * (t2-t1) dx\n    \/\/ ... = f1*t + rampIntegral(x)*(t2-t1).\n    \n    float phase = rampIntegral((t-t1)\/(t2-t1)) * (f2-f1) * (t2-t1) + f1*t;\n    phase = mod(phase, 1.);\n    return phase;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/ SOUNDS \/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\nfloat lpfSaw3(float t, float f, float fc, float Q)\n{\n    \/\/ Low-pass-filtered sawtooth wave\n    \/\/ arguments are time, frequency, cutoff frequency, and resonance quality factor\n    \/\/ https:\/\/www.shadertoy.com\/view\/wsGyWm\n    float omega_c = 2.*3.14159*fc\/f; \/\/ relative\n    t = f*t - floor(f*t);\n    \/\/ Compute the exact response of a second order system with those parameters\n    \/\/ (value and derivative are continuous)\n    \/\/ It is expressed as\n    \/\/ 1 - 2t + A exp(-omega_c*t\/Q) * cos(omega_c*t+phi)\n    \/\/ We need to compute the amplitude A and phase phi.\n    float alpha = omega_c\/Q, beta=exp(-alpha), c = cos(omega_c), s = sin(omega_c);\n    float tanphi = (alpha*beta*c + beta*omega_c*s - alpha) \/ (omega_c + alpha*beta*s - beta*omega_c*c);\n    \/\/ We could use more trigonometric identities to avoid computing the arctangent, but whatever.\n    float phi = atan(tanphi);\n    float A = -2.\/(cos(phi) - beta*cos(omega_c+phi));\n    \n    float v = 1.-2.*t + A*exp(-alpha*t) * cos(omega_c*t+phi);\n    return v;\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/ INSTRUMENTS \/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec2 bassStab(float t, float te, float f)\n{\n    \/\/ \"Analog bass\" sound based on a filtered sawtooth wave\n    float fc = 100. + 18000.*exp(-53.*te);\n    float env = smoothstep(0.,0.001,te) * exp(-6.*te);\n    vec2 sig = vec2(0);\n    sig += vec2(1.) * lpfSaw3(t, f, fc, 1.);\n    sig += vec2(-1,1) * 0.2 * lpfSaw3(t - 0.05, f+1., fc, 1.); \/\/ Widen in stereo\n    return sig * env * 0.08;\n}\n\nfloat kick(float t, float te, float atk)\n{\n    float f0 = midicps(34.), df = 300., spd = 40.;\n    \/\/ Instantaneous frequency\n    float ifreq = f0 + df*exp(-te*spd);\n    \/\/ Integrate to obtain\n    float phase = TAU*f0*te + TAU*df\/spd * (1.-exp(-te*spd));\n    float env = exp(-8.*te) + 2.5*exp(-100.*te);\n    env *= smoothstep(-1e-6,0.,te);\n    env *= (1. + 0.3*smoothstep(0.01,0.0,te)); \/\/ Enhance attack\n    float v = sin(phase) * env;\n    float click = noise(20000.*te) * smoothstep(0.,0.001,te) * smoothstep(0.01,0.001,te) * 0.8;\n    click += sweep(te, 0.005) * 2.;\n    v \/= 1. + 0.3*abs(v);\n    v *= (1. + 4.*smoothstep(0.05,0.15,te)*smoothstep(0.2,0.1,te)); \/\/ Enhance tail\n    v += click; \/\/ Don't distort the click\n    return v * smoothstep(-1e-6,atk,te);\n}\n\nfloat snare(float t, float te, float atk)\n{\n    \/\/ Snare is \"body\" + \"white noise\" + \"click\"\n    float wnoise = noise(20000.*te) + coloredNoise(te, 6500.,1000.)*0.3;\n    float nenv = (exp(-5.*te) + exp(-30.*te)) * smoothstep(0.2,0.0,te) * 0.5;\n    \n    float spd = 50.;\n    float phase = TAU*180.*te + TAU*80.\/spd * (1.-exp(-te*spd));\n    float body = sin(phase) * 1.5 * smoothstep(0.,0.005,te) * smoothstep(0.05,0.,te);\n    float v = wnoise*nenv + body;\n    v = 0.5*v;\n    v \/= 1. + abs(v);\n    \n    \/\/float click = noise(20000.*t) * exp(-600.*t);\n    float click = sweep(te, 0.005);\n    \/\/v += click * 2.;\n    \n    v *= smoothstep(-1e-6,atk,te);\n    v *= (1. + 0.3* smoothstep(0.01,0.0,te) + 0.2*smoothstep(0.05,0.2,te));\n    \n    return v;\n}\n\n\nvec2 tomDrum(float te, float f0, float df)\n{\n    float spd = 5.;\n    \/\/ Instantaneous frequency\n    float ifreq = f0 + df*exp(-te*spd);\n    \/\/ Integrate to obtain\n    float phase = f0*te + df\/spd * (1.-exp(-te*spd));\n    \n    float env = smoothstep(0.,0.0005,te) * curve(te, 0.35, 0.0, -1.3);\n    float noiseEnv = smoothstep(0.,0.0005,te) * curve(te, 0.8, 0.0, -2.) * (1. + 5.*curve(te, 0.022,0.0,0.));\n    vec2 sig = vec2(0);\n    \n    sig += triBipolar(4.*phase) * env * 0.15;\n    vec2 noise = (coloredNoise2(te, 1000., 20000.) + coloredNoise2(te, 4500., 6000.));\n    \n    sig += (noise.xx + noise.yy)*0.7 * noiseEnv * 0.03;\n    sig \/= 1. + abs(sig);\n    sig += noise.yx * smoothstep(0.,0.05,te) * curve(te, 2.0, 0.0, -2.5) * 0.02; \/\/ Fake echo\n    \n    return sig;\n}\n\nfloat hihat(float t, float te)\n{\n    float sig = coloredNoise(te, 7500., 4500.) + coloredNoise(te, 2000., 1800.) * 0.1;\n    \/\/float env = smoothstep(0.0,0.0002,te) * (smoothstep(0.05,0.0,te) + 0.5*smoothstep(0.01,0.,te));\n    float env = smoothstep(0.0,0.0002,te) * (curve(te, 0.2,0.0,-2.) + 0.5*smoothstep(0.01,0.,te));\n    return sig * env;\n}\n\nvec2 clap(float t)\n{\n    \/\/ A \"clap\" sound effect\n    vec2 sig = vec2(0);\n    sig += (0.8*coloredNoise2(t, 1000., 800.) + 0.5*coloredNoise2(t, 3300.,3100.) + 0.4*coloredNoise2(t,8240.,8000.));\n    \n    sig *= smoothstep(0.,0.01,t) * (curve(t,1.0,0.03, -2.3) + 0.2*curve(t,5.0,0.1,-1.));\n    \/\/ Fast envelope \"stutter\" is at the root of the \"clap\" sound\n    sig *= mix(0.7, 0.5+0.5*sin(TAU*80.*t), smoothstep(0.06,0.03,t));\n    sig \/= 1.+abs(sig); \/\/ Distort\n    \n    return sig;\n}\n\nvec2 sawLead(float t, float te, float f)\n{\n    vec2 sig = vec2(0);\n    te = max(te,0.);\n    float env = exp(-5.*te) * smoothstep(0.,0.01,te);\n    float fc0 = 2.*f;\n    float fc = fc0 + (10000.-fc0)*exp(-8.*te);\n    sig += lpfSaw3(t, f, fc, 1.);\n    sig += vec2(-1,1) * lpfSaw3(t-0.05, f+1.618, fc, 2.);\n    return sig * env * 0.1;\n}\n\nvec2 analogBrass(float t, float te, vec4 f)\n{\n    vec2 sig = vec2(0);\n    float fc = 800. + 8000. * curve(te, 0.,0.3,-1.) * curve(te,2.,0.3,-2.); \/\/ Quick swell\n    float env = smoothstep(0.,0.15,te); \/\/ Fade in only\n    \n    float amp = 1.;\n    for(float i=0.; i<3.; i++){\n        float dt = 0.06 * 0.05 * noise(t+5.62*i);\n        sig += vec2(1.0,0.0) * lpfSaw3(t+dt, f.z, fc, 1.5) * amp;\n        sig += vec2(0.8,0.6) * lpfSaw3(t+dt, f.x, fc, 1.5) * amp;\n        sig += vec2(0.6,0.8) * lpfSaw3(t+dt, f.y, fc, 1.5) * amp;\n        sig += vec2(0.0,1.0) * lpfSaw3(t+dt, f.w, fc, 1.5) * amp;\n        amp *= 0.7;\n    }\n    \n    vec2 warm = vec2(0);\n    warm += vec2(1.0,0.0) * sin(TAU*f.z*t + sin(TAU*f.z*t));\n    warm += vec2(0.8,0.6) * sin(TAU*f.x*t + sin(TAU*f.x*t));\n    warm += vec2(0.6,0.8) * sin(TAU*f.y*t + sin(TAU*f.y*t));\n    warm += vec2(0.0,1.0) * sin(TAU*f.w*t + sin(TAU*f.w*t));\n    \n    return sig * 0.05 + warm * 0.03;\n}\n\nvec2 fmLead(float te, float f1, float f2, float t1, float t2, float dur)\n{\n    \/\/ Lead synth sound\n    \n    \/\/ f1, f2, t1, t2 : portamento from f1 to f2 between time t1 and t2\n    \n    float phase = phasePortamento(te, f1, f2, t1, t2);\n    vec2 phase2 = phase + te*vec2(-1,1);\n    \n    \/\/ vibrato\n    float vibHz = 5.5;\n    float vibAmp = smoothstep(0.5,1.2,te);\n    float vibrato = sin(TAU*vibHz*te) * vibAmp;\n    phase += 0.06*0.2*f1 * vibrato\/(TAU*vibHz);\n    \n    float env = smoothstep(0.,0.01,te) * (1.3 - 0.5*smoothstep(0.,0.1,te) + 0.1*vibrato) * smoothstep(dur,dur-0.1,te);\n    \n    float iom = 5500.\/max(f1,f2);\n    vec2 sig = vec2(0);\n    sig += 3.*sin(TAU*phase + sin(TAU*phase2));\n    sig += sin(TAU*phase*7. + (3.+vibrato)*sin(2.*TAU*phase2));\n    sig += sin(TAU*(phase2+2.*te) + iom*sin(TAU*phase2));\n    sig += sin(TAU*5000. + (5.+ vibrato)*sin(TAU*phase2.yx));\n    \n    return sig * env * 0.02;\n}\n\n\nvec2 shepardRiser(float t, float dt, float bandwidth)\n{\n    vec2 sig = vec2(0);\n    \n    for(float nn=30.; nn<100.; nn+=8.)\n    {\n        float midinote = nn + 15.*fract(t\/dt);\n        float fc = midicps(midinote);\n        float df = bandwidth*fc;\n        sig += coloredNoise2(mod(t,dt), fc, df) * 0.01;\n    }\n    \n    return sig;\n}\n\nvec2 noiseRiseFall(float t, float dt)\n{\n    \/\/float phase = smoothstep(0., dt, t) * dt;\n    float x = t\/dt;\n    float phase = dt * x*x*x*(3.-2.25*x);\n    vec2 sig = coloredNoise2(phase, 7000., 10000.) * 0.1;\n    sig *= smoothstep(0., 0.01, t) * smoothstep(dt, dt-0.01, t);\n    return sig;\n}\n\nvec2 machineButtonClick(float t)\n{\n    float reson = sin(TAU*805.*t + sin(TAU*302.*t) + sin(TAU*419.*t)) + 0.5*sin(TAU*100.*t);\n    float noise = coloredNoise(t, 4393., 6000.) + 0.2*coloredNoise(t, 7000., 10000.);\n    \n    float sig = 0.;\n    float env = percEnv(t, 0.001, 0.03, -1.) * 0.01 + percEnv(t-0.021, 0.001, 0.03, -1.) * 0.015\n    + percEnv(t-0.045, 0.001, 0.04, -1.)*0.1 + percEnv(t-0.056, 0.001, 0.1, -1.)*0.15 + percEnv(t-0.09, 0.001, 0.3,-1.8) * 0.1;\n    \n    sig += (reson*0.1+noise) * env;\n    \n    return vec2(sig);\n}\n\nvec2 machineButtonClickVerb(float t)\n{\n    return machineButtonClick(t) + vec2(0.5,0)*machineButtonClick(t-0.0062) + vec2(0,0.3)*machineButtonClick(t-0.01);\n}\n\nvec2 crashCymbal(float t, float atk)\n{\n    float reson = sin(TAU*429.*t + 5.*sin(TAU*1120.*t) + 5.*sin(TAU*1812.*t));\n    vec2 sig = coloredNoise2(t, 7150., 10000.) + 0.1*reson*smoothstep(0.,0.05,t);\n    float env = curve(t, 15.0, 0.0,-3.) * curve(t, 0.0, 0.08, 1.);\n    env *= (1. + smoothstep(0.02,0.0,t) * 2.);\n    env *= (1. - smoothstep(0.0,0.05,t)*smoothstep(0.5,0.0,t) * 0.5);\n    env *= smoothstep(0., atk, t);\n    return sig * env * 0.2;\n}\n\nvec2 crashCymbalVerb(float t)\n{\n    vec2 sig = crashCymbal(t, 0.);\n    sig += crashCymbal(t-0.75*beatdur, 0.05).yx * 0.5;\n    sig += crashCymbal(t-1.50*beatdur, 0.10).xy * 0.25;\n    return sig;\n}\n\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/ PATTERNS \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec2 drums(float t, float atk)\n{\n    \/\/ atk: zero, or greater for smoother signal attack.\n    vec2 v = vec2(0);\n    \n    float te = mod(t, beatdur * 2.);\n    v += kick(t, te, atk) * 0.1;\n    \n    te = mod(t-beatdur, 2.*beatdur);\n    v += snare(t, te, atk) * 0.25;\n    \n    te = mod(t, beatdur * 0.5);\n    float vel = 1. + mod(t,beatdur);\n    vec2 panHH = 1. + 0.5 * vec2(-1,1) * cos(TAU*t\/(4.*beatdur));\n    v += hihat(t, te) * 0.03 * vel * panHH;\n    \n    return v * smoothstep(-1e-6,atk,t);\n}\n\nvec2 clapPattern(float t)\n{\n    vec2 v = vec2(0);\n    float te = mod(t-7.*beatdur, 8.*beatdur);\n    v += clap(te) * 0.25;\n    \n    return v * smoothstep(-1e-6,0.,t);\n}\n\nvec2 tomFill(float t)\n{\n    if(t < 0.5*beatdur || t > 3.*beatdur) return vec2(0);\n    \n    t = t - 0.5*beatdur;\n    float te = mod(t, 0.75*beatdur);\n    float num = floor(t \/ (0.75*beatdur));\n    float f0i = 0.;\n    float dfi = (200. - 20.*num)*2.;\n    \n    vec2 sig = vec2(0);\n    sig += tomDrum(te, f0i, dfi);\n    \n    return sig;\n}\n\nvec2 pentatonicArp(float t)\n{\n    if(t < 0.) return vec2(0);\n    float notedur = beatdur \/ 8.;\n    float te = mod(t, notedur);\n    float nthNote = floor(t \/ notedur);\n    vec2 sig = vec2(0);\n    for(float ni = 0.; ni < 8.; ni++) \/\/ Also play the tail of the previous notes\n    {\n        float nn = nthNote-ni;\n        \/\/ fold back after 16 notes\n        nn = fold(nn, 0., 16.);\n        float degree = mod(nn, 5.); \/\/ degree in pentatonic scale\n        float octave = floor(nn\/5.);\n        float note = floor(12.*degree\/5.+0.6); \/\/ midi note number in pentatonic scale\n        float midiNoteNum = 69. + 12.*octave + note;\n        float f = midicps(midiNoteNum);\n\n        float tei = te+notedur*ni;\n        vec2 sigi = sawLead(t, tei, f);\n        sigi *= smoothstep(notedur*8., notedur*7., tei); \/\/ fade out note to avoid clicks\n        sig += sigi;\n    }\n    return sig;\n}\n\nvec2 pentatonicArpVerb(float t)\n{\n    vec2 pan = (1. + 0.7*vec2(-1,1)*sin(0.7*TAU*t));\n    return pan * pentatonicArp(t) + vec2(0.7,0.3)*pentatonicArp(t-3.\/8.*beatdur-0.02)\n     - vec2(0.2,0.5)*pentatonicArp(t-4.\/8.*beatdur-0.05);\n}\n\nvec2 bassLine(float t)\n{\n    float notedur = 0.5*beatdur;\n    float te = mod(t, notedur);\n    float nthNote = floor(t\/notedur);\n    nthNote = mod(nthNote + 1., 32.); \/\/ Start all chords one half note in advance\n    \n    float midiNoteNum = \n        (nthNote < 8.) ? 45. : \/\/ A\n        (nthNote < 16.) ? 43. : \/\/ G major\n        (nthNote < 28.) ? 48. : \/\/ C major\n        50.; \/\/ D\n    float freq = midicps(midiNoteNum);\n    \n    float pumping = smoothstep(0.,beatdur*0.5, mod(t,beatdur));\n    vec2 sig = vec2(0);\n    sig += bassStab(t, te, freq) * mix(1.,pumping,0.5) * 0.7;\n    sig += bassStab(t, te, freq\/2.) * mix(1.,pumping,0.6) * 0.7;\n    \n    return sig;\n}\n\nvec2 brassPad(float t)\n{\n    float nthNote = floor(t\/beatdur);\n    nthNote = mod(nthNote, 16.);\n    vec4 midiNoteNum =\n        (nthNote < 4.) ? vec4(60,62,64,69) : \/\/ A minor (+D)\n        (nthNote < 8.) ? vec4(59,62,67,69) : \/\/ G\n        (nthNote < 14.) ? vec4(60,62,64,67) : \/\/ C (+D)\n        vec4(60,62,65,69); \/\/ Dm7\n        \n    vec2 env_startend = \n        (nthNote < 4.) ? vec2(0,4) : \n        (nthNote < 8.) ? vec2(4,8) :\n        (nthNote < 14.) ? vec2(8,14) :\n        vec2(14,16);\n        \n    float te = mod(t, 16.*beatdur) - env_startend.x * beatdur;\n    float noteDur = (env_startend.y - env_startend.x) * beatdur;\n    float fadeout = smoothstep(noteDur, noteDur-0.2, te);\n    \n    vec4 freq = midicps(midiNoteNum);\n    \n    vec2 sig = analogBrass(t, te, freq);\n    sig *= fadeout;\n    \n    return sig;\n}\n\nvec2 brassPadVerb(float t)\n{\n    return brassPad(t) + 0.5*brassPad(t-0.1).yx + 0.2*brassPad(t-1.);\n}\n\nvec2 fmLeadPhrase(float t)\n{\n    if(t<0.) return vec2(0);\n    \n    t = mod(t, 32.*beatdur);\n    if(t < 28.*beatdur) t = mod(t, 16.*beatdur); \/\/ variation on second time\n    \n    float tb = t \/ beatdur;\n    \n    \/\/ Each note may contain one portamento\n    \/\/ Note data is (tb0, dur, midiNN1, midiNN2, beats until porta, porta duration in beats).\n    mat3x2 noteData = \n        (tb < 2.5) ? mat3x2(0.0, 2.5, 74, 76, 0.5, 0.1) : \/\/ D-E\n        (tb < 3.5) ? mat3x2(2.5, 1, 74, 72, 0.5, 0.2) :\/\/ D-C\n        (tb < 6.5) ? mat3x2(3.5, 3, 79, 79, 10, 10) : \/\/ G\n        (tb < 8.5) ? mat3x2(7.5, 1, 81, 83, 0.0, 0.05) : \/\/ B\n        (tb < 9.5) ? mat3x2(8.5, 1, 84, 83, 0.5, 0.2) : \/\/ C-B\n        (tb < 11.) ? mat3x2(9.5, 1.5, 76,76,10,10): \/\/ E\n        (tb < 11.5) ? mat3x2(11., 0.5, 77,79,0.0,0.1): \/\/ G\n        (tb < 12.5) ? mat3x2(11.5, 1., 77,77,10,10): \/\/ F\n        (tb < 13.5) ? mat3x2(12.5, 1., 76,76,10,10): \/\/ E\n        (tb < 15.) ? mat3x2(13.5, 1.5, 76,74,0.0,0.05): \/\/ E-D\n        (tb < 16.) ? mat3x2(15., 1., 72,72,10,10) : \/\/ C\n        \/\/ identical repeat until...\n        (tb < 29.5) ? mat3x2(27.5,2., 77,77,10,10) : \/\/ F (continued)\n        mat3x2(29.5, 1.7, 76,76,10,10) \/\/ E\n        ;\n    \n    \n    float t0 = noteData[0][0]*beatdur;\n    float te = t - t0;\n    float dur = noteData[0][1]*beatdur;\n    float f1 = midicps(noteData[1][0]);\n    float f2 = midicps(noteData[1][1]);\n    float t1 = noteData[2][0] * beatdur;\n    float t2 = t1 + noteData[2][1] * beatdur;\n    vec2 sig = fmLead(te, f1, f2, t1, t2, dur);\n    \n    return sig;\n}\n\nvec2 fmLeadPhraseVerb(float t)\n{\n    return fmLeadPhrase(t) + vec2(0.2,0.7) * fmLeadPhrase(t-beatdur+0.01) + vec2(0.5,0.1) * fmLeadPhrase(t-2.*beatdur-0.02);\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/ SONG STRUCTURE \/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec2 introSequence(float t)\n{\n    \/\/ arps intro\n    \/\/ +drums\n    \/\/ +brass\n    \/\/ +riser, tom fill\n    \n    float tb = t \/ beatdur;\n    \n    \n    vec2 sig = vec2(0);\n    \n    float te =  mod(t,beatdur);\n    float pumping = smoothstep(0.01,0.,te) + smoothstep(0.01,beatdur*0.5, te);\n    float arpPump = 0.7*smoothstep(7.9,8.0,tb);\n    sig += pentatonicArpVerb(t) * 0.09 * mix(1.,pumping,arpPump);\n    \n    t -= 8.*beatdur;\n    vec2 drumSig = drums(t, 0.);\n    sig \/= 1. + 3.*abs(drumSig); \/\/ Distort the signal according to the drums\n    sig += drumSig;\n    \n    \n    pumping = smoothstep(0.01,0.,te) + smoothstep(0.01,beatdur*0.3, te);\n    t -= 8.*beatdur;\n    sig += brassPadVerb(t) * 0.4 * mix(1.,pumping,0.9)  * curve(t, 0., 24., 0.5);\n    \n    t -= 24.*beatdur;\n    \n    sig += noiseRiseFall(t, 7.*beatdur) * 0.2;\n    \/\/ Play the first clap louder\n    pumping = smoothstep(0.05,0.,te) + smoothstep(0.05,0.3, te);\n    sig += clapPattern(t) * smoothstep(3.*beatdur,4.*beatdur,t) * (1. + 0.3*smoothstep(15.*beatdur, 8.*beatdur, t))\n     * mix(1., pumping, 0.3);\n    \n    t -= 4.*beatdur;\n    vec2 fill = tomFill(t);\n    sig \/= 1.+2.*abs(fill); \/\/ Distort signal according to toms\n    sig += fill;\n    \n    return sig;\n}\n\n\nvec2 chorusPattern(float t)\n{\n    \/\/ Should be overlayed with intro sequence (t > 48.*beatdur)\n    \n    vec2 sig = vec2(0);\n    \n    float te =  mod(t,beatdur);\n    float pumping = smoothstep(0.01,0.,te) + smoothstep(0.01,beatdur*0.5, te);\n    \n    sig += crashCymbalVerb(mod(t,32.*beatdur)) * 0.5 * mix(1., pumping, 0.5);\n    sig += fmLeadPhraseVerb(t) * mix(1.,pumping, 0.8) * 0.7;\n    sig += bassLine(t);\n    \n    return sig;\n}\n\nvec2 bootUp(float t)\n{\n    \/\/ Sequence of glitchy sounds\n    \/\/ like a tape loading up.\n    \/\/ Runs in 4 seconds\n    \n    vec2 sig = vec2(0);\n    \n    sig += machineButtonClickVerb(t-0.5);\n    \n    t -= 1.;\n    \n    float phase = rampIntegral(t \/ 3.) * 3.;\n    \n    vec2 sig1 = vec2(0);\n    sig1 += 0.1 * pentatonicArpVerb(phase);\n    sig1 += 0.02 * noise(5000.*phase);\n    sig1 *= smoothstep(0.,0.1,t) * smoothstep(3.0,2.999,t);\n    \n    sig += machineButtonClick(1.05*(t-2.9));\n    \n    return sig + sig1 * 0.5;\n}\n\n\nvec2 fullSong(float t)\n{\n    vec2 sig = vec2(0);\n    \n    if(0. < t)\n        sig += introSequence(t);\n    if (12.*4.*beatdur < t)\n    {\n        t -= 12.*4.*beatdur;\n        sig += chorusPattern(t);\n    }\n    \n    return sig;\n}\n\nvec2 mainSound( int samp, float t )\n{\n    vec2 sig = vec2(0);\n    \n    float te =  mod(t,beatdur);\n    float pumping = smoothstep(0.01,0.,te) + smoothstep(0.01,beatdur*0.5, te);\n\n    \n    \n    sig += bootUp(t);\n    \n    t -= 4.;\n    \n    sig += fullSong(t);\n    \n    \/\/sig \/= 1. + 0.5 * abs(sig);\n    \n    \n    return sig;\n}\n",
            "name": "Common",
            "description": "",
            "type": "common"
        }
    ]
}