{
    "ver": "0.1",
    "info": {
        "id": "3tsyzl",
        "date": "1593154586",
        "viewed": 4510,
        "name": "Julia - Quaternion 3",
        "username": "iq",
        "description": "The cubic Julia set used in the introduction of my video \"Geodes\" ([url]https:\/\/www.shadertoy.com\/view\/3llyzl[\/url]). It has 3 bounces of super simple GI (no specular) and some temporal reprojection to remove noise.",
        "likes": 97,
        "published": 3,
        "flags": 32,
        "usePreview": 0,
        "tags": [
            "3d",
            "raymarching",
            "fractal",
            "julia",
            "distance",
            "quaternion",
            "cubic"
        ],
        "hasliked": 0
    },
    "renderpass": [
        {
            "inputs": [
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dfGRr",
                    "channel": 0
                }
            ],
            "code": "\/\/ Created by inigo quilez - iq\/2020\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ The Julia set of f(z) = z\u00b3 + c, as rendered for the Youtube\n\/\/ video called \"Geodes\": https:\/\/www.youtube.com\/watch?v=rQ2bnU4dkso\n\/\/\n\/\/ I simplified a few things, reduced the number of GI bounces\n\/\/ and did some temporal reprojection to keep it more or less\n\/\/ real-time while looking similar to the one in the video.\n\/\/\n\/\/ Explanations:\n\/\/  https:\/\/iquilezles.org\/www\/articles\/distancefractals\/distancefractals.htm\n\/\/  https:\/\/iquilezles.org\/www\/articles\/orbittraps3d\/orbittraps3d.htm\n\/\/\n\/\/ Related shaders:\n\/\/\n\/\/ Julia - Quaternion 1 : https:\/\/www.shadertoy.com\/view\/MsfGRr\n\/\/ Julia - Quaternion 2 : https:\/\/www.shadertoy.com\/view\/lsl3W2\n\/\/ Julia - Quaternion 3 : https:\/\/www.shadertoy.com\/view\/3tsyzl\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord \/ iResolution.xy;\n\n    vec3 col = texture( iChannel0, p ).xyz;\n\n    \/\/ color grade\n    col = col*2.0\/(1.0+col);\n    col = pow( col, vec3(0.4545) );\n    col = pow(col,vec3(0.85,0.97,1.0));\n    col = col*0.5 + 0.5*col*col*(3.0-2.0*col);\n\n    \/\/ vignette\n    col *= 0.5 + 0.5*pow( 16.0*p.x*p.y*(1.0-p.x)*(1.0-p.y), 0.1 );\n    \n    fragColor = vec4( col, 1.0 );\n}",
            "name": "Image",
            "description": "",
            "type": "image"
        },
        {
            "inputs": [
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dXGR8",
                    "channel": 0
                }
            ],
            "code": "\/\/ Created by inigo quilez - iq\/2020\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ The Julia set of f(z) = z\u00b3 + c, as rendered for the Youtube\n\/\/ video called \"Geodes\": https:\/\/www.shadertoy.com\/view\/3llyzl\n\/\/\n\/\/ I simplified a few things, reduced the number of GI bounces\n\/\/ and did some temporal reprojection to keep it more or less\n\/\/ real-time while looking similar to the one in the video.\n\/\/\n\/\/ Explanations:\n\/\/  https:\/\/iquilezles.org\/www\/articles\/distancefractals\/distancefractals.htm\n\/\/  https:\/\/iquilezles.org\/www\/articles\/orbittraps3d\/orbittraps3d.htm\n\/\/\n\/\/ Related shaders:\n\/\/\n\/\/ Julia - Quaternion 1 : https:\/\/www.shadertoy.com\/view\/MsfGRr\n\/\/ Julia - Quaternion 2 : https:\/\/www.shadertoy.com\/view\/lsl3W2\n\/\/ Julia - Quaternion 3 : https:\/\/www.shadertoy.com\/view\/3tsyzl\n\n\n\/\/ disable TRAPs to see just the set\n#define TRAPS\n\n\/\/ disable CUT to see the whole set\n#define CUT\n\nconst int   kNumIte = 200;\nconst float kPrecis = 0.00025;\nconst vec4  kC = vec4(-2,6,15,-6)\/22.0;\nconst float kFocLen = 3.0;\n#ifdef TRAPS\nconst float kBSRad = 2.0;\n#else\nconst float kBSRad = 1.2;\n#endif\n#define     kNumBounces 3\n\n\/\/ --------------------------------------\n\/\/ oldschool rand() from Visual Studio\n\/\/ --------------------------------------\nint   seed = 1;\nvoid  srand(int s ) { seed = s; }\nint   rand(void) { seed=seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())\/32767.0; }\n\/\/ --------------------------------------\n\/\/ hash to initialize the random seed (copied from Hugo Elias)\n\/\/ --------------------------------------\nint hash( int n ) { n=(n<<13)^n; return n*(n*n*15731+789221)+1376312589; }\n\/\/--------------------------------------------------------------------------------\n\/\/ http:\/\/amietia.com\/lambertnotangent.html\n\/\/--------------------------------------------------------------------------------\nvec3 cosineDirection( in vec3 nor)\n{\n    float u = frand()*2.0-1.0;\n    float a = frand()*6.28318531;\n    return normalize(nor+vec3(sqrt(1.0-u*u)*vec2(cos(a),sin(a)), u) );\n}\n\/\/--------------------------------------------------------------------------------\n\/\/ quaternion manipulation\n\/\/--------------------------------------------------------------------------------\nvec4 qSquare( in vec4 q )\n{\n    return vec4(q.x*q.x - q.y*q.y - q.z*q.z - q.w*q.w, 2.0*q.x*q.yzw);\n}\nvec4 qCube( in vec4 q )\n{\n    vec4  q2 = q*q;\n    return vec4(q.x  *(    q2.x - 3.0*q2.y - 3.0*q2.z - 3.0*q2.w), \n                q.yzw*(3.0*q2.x -     q2.y -     q2.z -     q2.w));\n}\nfloat qLength2( in vec4 q ) { return dot(q,q); }\n\/\/--------------------------------------------------------------------------------\n\/\/ ray-sphere intersection\n\/\/ http:\/\/iquilezles.org\/www\/articles\/intersectors\/intersectors.htm\n\/\/--------------------------------------------------------------------------------\nvec2 iSphere( in vec3 ro, in vec3 rd, in float rad )\n{\n\tfloat b = dot( ro, rd );\n\tfloat c = dot( ro, ro ) - rad*rad;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n    h = sqrt(h);\n\treturn vec2(-b-h, -b+h );\n}\n\/\/--------------------------------------------------------------------------------\n\/\/ build camera rotation matrix\n\/\/--------------------------------------------------------------------------------\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\/\/--------------------------------------------------------------------------------\n\/\/ SDF of the Julia set z\u00b3+c\n\/\/ https:\/\/iquilezles.org\/www\/articles\/distancefractals\/distancefractals.htm\n\/\/--------------------------------------------------------------------------------\nvec2 map( in vec3 p )\n{\n    vec4 z = vec4( p, 0.0 );\n    float dz2 = 1.0;\n\tfloat m2  = 0.0;\n    float n   = 0.0;\n    #ifdef TRAPS\n    float o   = 1e10;\n    #endif\n    \n    for( int i=0; i<kNumIte; i++ ) \n\t{\n        \/\/ z' = 3z\u00b2 -> |z'|\u00b2 = 9|z\u00b2|\u00b2\n\t\tdz2 *= 9.0*qLength2(qSquare(z));\n        \n        \/\/ z = z\u00b3 + c\t\t\n\t\tz = qCube( z ) + kC;\n        \n        \/\/ stop under divergence\t\t\n        m2 = qLength2(z);\t\t\n\n        \/\/ orbit trapping : https:\/\/iquilezles.org\/www\/articles\/orbittraps3d\/orbittraps3d.htm\n        #ifdef TRAPS\n        o = min( o, length(z.xz-vec2(0.45,0.55))-0.1 );\n        #endif\n        \n        \/\/ exit condition\n        if( m2>256.0 ) break;\t\t\t\t \n\t\tn += 1.0;\n\t}\n   \n\t\/\/ sdf(z) = log|z|\u00b7|z|\/|dz| : https:\/\/iquilezles.org\/www\/articles\/distancefractals\/distancefractals.htm\n\tfloat d = 0.25*log(m2)*sqrt(m2\/dz2);\n    \n    #ifdef TRAPS\n    d = min(o,d);\n    #endif\n    #ifdef CUT\n    d = max(d, p.y);\n    #endif\n    \n\treturn vec2(d,n);        \n}\n\n\/\/--------------------------------------------------------------------------------\n\/\/ Compute Normal to SDF\n\/\/--------------------------------------------------------------------------------\n\n#if 1\n\/\/ https:\/\/iquilezles.org\/www\/articles\/normalsSDF\/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n    const vec2 e = vec2(1.0,-1.0)*0.5773*kPrecis;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n#else\n\/\/ https:\/\/iquilezles.org\/www\/articles\/juliasets3d\/juliasets3d.htm\nvec3 calcNormal( in vec3 p )\n{\n    #ifdef TRAPS\n    the code below only works for the actual Julia set, not the traps\n    #endif\n        \n    vec4 z = vec4(p,0.0);\n\n    \/\/ identity derivative\n    mat4x4 J = mat4x4(1,0,0,0,  \n                      0,1,0,0,  \n                      0,0,1,0,  \n                      0,0,0,1 );\n\n  \tfor(int i=0; i<kNumIte; i++)\n    {\n        \/\/ f(q) = q\u00b3 + c = \n        \/\/   x =  x\u00b2x - 3y\u00b2x - 3z\u00b2x - 3w\u00b2x + c.x\n        \/\/   y = 3x\u00b2y -  y\u00b2y -  z\u00b2y -  w\u00b2y + c.y\n        \/\/   z = 3x\u00b2z -  y\u00b2z -  z\u00b2z -  w\u00b2z + c.z\n        \/\/   w = 3x\u00b2w -  y\u00b2w -  z\u00b2w -  w\u00b2w + c.w\n\t\t\/\/\n        \/\/ Jacobian, J(f(q)) =\n        \/\/   3(x\u00b2-y\u00b2-z\u00b2-w\u00b2)  6xy            6xz            6xw\n        \/\/    -6xy           3x\u00b2-3y\u00b2-z\u00b2-w\u00b2 -2yz           -2yw\n        \/\/    -6xz          -2yz            3x2-y\u00b2-3z\u00b2-w\u00b2 -2zw\n        \/\/    -6xw          -2yw           -2zw            3x\u00b2-y\u00b2-z\u00b2-3w\u00b2\n        \n        float k1 = 6.0*z.x*z.y, k2 = 6.0*z.x*z.z;\n        float k3 = 6.0*z.x*z.w, k4 = 2.0*z.y*z.z;\n        float k5 = 2.0*z.y*z.w, k6 = 2.0*z.z*z.w;\n        float sx = z.x*z.x, sy = z.y*z.y;\n        float sz = z.z*z.z, sw = z.w*z.w;\n        float mx = 3.0*sx-3.0*sy-3.0*sz-3.0*sw;\n        float my = 3.0*sx-3.0*sy-    sz-    sw;\n        float mz = 3.0*sx-    sy-3.0*sz-    sw;\n        float mw = 3.0*sx-    sy-    sz-3.0*sw;\n        \n        \/\/ chain rule of jacobians\n        J = J*mat4x4( mx, -k1, -k2, -k3,\n                      k1,  my, -k4, -k5,\n                      k2, -k4,  mz, -k6,\n                      k3, -k5, -k6,  mw );\n        \/\/ q = q\u00b3 + c\n        z = qCube(z) + kC; \n        \n        \/\/ exit condition\n        if(dot2(z)>256.0) break;\n    }\n\n    return (p.y>0.0 ) ? vec3(0.0,1.0,0.0) : normalize( (J*z).xyz );\n}\n#endif\n\n\/\/--------------------------------------------------------------------------------\n\/\/ ray-scene intersection\n\/\/--------------------------------------------------------------------------------\nvec2 raycast( in vec3 ro, in vec3 rd )\n{\n    float tmax = 7.0;\n\tfloat tmin = kPrecis;    \n\n    \/\/ intersect clipping plane\n    #ifdef CUT\n    const float kSplit = 0.01;\n    float tpS = (kSplit-ro.y)\/rd.y;\n    if( tpS>0.0 )\n    {\n        if( ro.y>kSplit ) tmin = max(tmin,tpS);\n        else              tmax = min(tmax,tpS);\n    }\n\t#endif\n    \n    \/\/ intersect lower clipping plane\n    #if 1\n    {\n    float tpF = (-0.8-ro.y)\/rd.y;\n    if( tpF>0.0 ) tmax = min(tmax,tpF);\n    }\n    #endif\n\n    \/\/ intersect bounding sphere\n    #if 1\n    vec2 bv = iSphere( ro, rd, kBSRad );\n    if( bv.y<0.0 ) return vec2(-2.0,0.0);\n    tmin = max(tmin,bv.x);\n    tmax = min(tmax,bv.y);\n\t#endif\n    \n    \/\/ raymarch\n    vec2  res = vec2(-1.0);\n    float t = tmin;\n\tfloat lt = 0.0;\n\tfloat lh = 0.0;\n    for(int i=0; i<1024; i++ )\n    {\n        res = map(ro+rd*t);\n        if( res.x<kPrecis ) break;\n\t\tlt = t;\n\t\tlh = res.x;\n        #ifndef TRAPS\n        t += min(res.x,0.2);\n        #else\n        t += min(res.x,0.01)*(0.5+0.5*frand());\n        #endif\n        if( t>tmax ) break;\n    }\n    \/\/ linear interpolation for better isosurface\n\tif( lt>0.0001 && res.x<0.0 ) t = lt - lh*(t-lt)\/(res.x-lh);\n\t\n    res.x = (t<tmax)?t:-1.0;\n\n    return res;\n}\n\n\/\/--------------------------------------------------------------------------------\n\/\/ color of the surface\n\/\/--------------------------------------------------------------------------------\nvec3 colorSurface( in vec3 pos, in vec3 nor, in vec2 tn )\n{\n    vec3 col = 0.5+0.5*cos(log2(tn.y)*0.9+3.5+vec3(0.0,0.6,1.0));\n    if( pos.y>0.0 ) col = mix(col,vec3(1.0),0.2);\n    float inside = smoothstep(14.0,15.0,tn.y);\n    col *= vec3(0.45,0.42,0.40) + vec3(0.55,0.58,0.60)*inside;\n    col = mix(col*col*(3.0-2.0*col),col,inside);\n    col = mix( mix(col,vec3(dot(col,vec3(0.3333))),-0.4),\n                        col, inside);\n    return clamp(col*0.65,0.0,1.0);\n}\n\n\/\/--------------------------------------------------------------------------------\n\/\/ Render the scene through super simplified path-tracing\n\/\/--------------------------------------------------------------------------------\nvec3 render( in  vec2 fragCoord, in vec3 ro, in vec3 rd,\n             out vec3 resPos, out float resT)\n{\n    vec3 colorMask = vec3(1.0);\n \tresT = 1e20;\n    \n    \/\/ path-tracing\n    for( int bounce=0; bounce<kNumBounces; bounce++ )\n    {\n        vec2 tn = raycast( ro, rd );\n        float t = tn.x;\n        if( t < 0.0 )\n        {\n            return (bounce>0) ? colorMask*1.65*step(0.0,rd.y) \n                              : vec3(clamp(0.02+0.021*rd.y,0.0,1.0));\n        }\n        else\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal( pos );\n\n            if( bounce==0 ) { resT = t; resPos = pos; }\n\n\t\t\tcolorMask *= colorSurface( pos, nor, tn );\n            rd = cosineDirection(nor);\n        \tro = pos+nor*kPrecis;\n        }\n   }\n   \n   return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/-----------------------------------------------\n\t\/\/ init random seed\n    \/\/-----------------------------------------------\n    ivec2 q = ivec2(fragCoord);\n    srand( hash(q.x+hash(q.y+hash(1117*iFrame))));\n    \n    \/\/-----------------------------------------------\n    \/\/ camera\n    \/\/-----------------------------------------------\n    float an = 0.5+iTime*0.03;\n    vec3  ro = 2.0*vec3(sin(an),0.8,cos(an));\n    #ifdef CUT\n    vec3  ta = vec3( 0.0, -0.3, 0.0 );\n    #else\n    vec3  ta = vec3( 0.0, -0.1, 0.0 );\n\t#endif\n    mat3x3 cam = setCamera(ro,ta,0.0);\n    \n    \/\/-----------------------------------------------\n    \/\/ ray direction\n    \/\/-----------------------------------------------\n    vec2 p = (2.0*fragCoord-iResolution.xy)\/iResolution.y;\n    vec3 rd = normalize( cam*vec3(p.xy,kFocLen) );\n    \n    \/\/-----------------------------------------------\n    \/\/ render fractal\n    \/\/-----------------------------------------------\n    vec3 pos; float resT;\n    vec3 col = render(fragCoord,ro,rd,pos,resT);\n\n    \/\/-----------------------------------------------\n\t\/\/ reproject to previous frame and pull history\n    \/\/-----------------------------------------------\n\n    \/\/ fetch previous camera matrix from the bottom left three pixels\n    mat3x4 oldCam = mat3x4( texelFetch(iChannel0,ivec2(0,0), 0),\n                            texelFetch(iChannel0,ivec2(1,0), 0),\n                            texelFetch(iChannel0,ivec2(2,0), 0) );\n    \/\/ world space point\n    vec4 wpos = vec4(pos,1.0);\n    \/\/ convert to camera space (note inverse multiply)\n    vec3 cpos = wpos*oldCam;\n    \/\/ convert to NDC space (project)\n    vec2 npos = kFocLen*cpos.xy\/cpos.z;\n    \/\/ convert to screen space\n    vec2 spos = 0.5 + 0.5*npos*vec2(iResolution.y\/iResolution.x,1.0);\n\t\/\/ convert to raster space\n    vec2 rpos = spos * iResolution.xy;\n\n    \/\/ read color+depth from this point's previous screen location\n    vec4 ocolt = textureLod( iChannel0, spos, 0.0 );\n    \/\/ if we consider the data contains the history for this point\n    if( iFrame>0 && resT<100.0 && (rpos.y>1.5||rpos.x>3.5) )\n    {\n        \/\/ blend with history (it's a IIR low pas filter really)\n        col = mix( ocolt.xyz, col, 0.06 );\n    }\n    \/\/ output\n\tif( q.y==0 && q.x<3 )\n    {\n    \t\/\/ camera matrix in lower left three pixels, for next frame\n             if( q.x==0 ) fragColor = vec4( cam[0], -dot(cam[0],ro) );\n        else if( q.x==1 ) fragColor = vec4( cam[1], -dot(cam[1],ro) );\n        else              fragColor = vec4( cam[2], -dot(cam[2],ro) );\n    }\n    else\n    {\n        \/\/ color and depth\n        fragColor = vec4( col, resT );\n    }\n}",
            "name": "Buffer A",
            "description": "",
            "type": "buffer"
        }
    ]
}