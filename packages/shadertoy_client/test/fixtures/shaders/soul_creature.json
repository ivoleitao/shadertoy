{
    "ver": "0.1",
    "info": {
        "id": "WldBW2",
        "date": "1613681589",
        "viewed": 2635,
        "name": "Soul creature",
        "username": "kosmaks",
        "description": "Experiments with trying to create visuals from movie Soul. First time implementing fog effects, animation, futuristic grass and using aces film filter for color grading.\n\n(it looks nothing like soul, but still pretty cool imo :)\n\ngh: kosmaks",
        "likes": 43,
        "published": 3,
        "flags": 0,
        "usePreview": 0,
        "tags": [
            "raytracing",
            "gi",
            "raymarcher",
            "render",
            "soul"
        ],
        "hasliked": 0
    },
    "renderpass": [
        {
            "inputs": [],
            "outputs": [
                {
                    "id": "4dfGRr",
                    "channel": 0
                }
            ],
            "code": "#define MAX_COUNT (150)\n#define MIN_DIST (0.001)\n#define MAX_DIST (3.)\n\n#define SOUL_SIZE (0.2)\n\n#define M_SOUL_BODY 1\n#define C_SOUL_BODY (vec3(0.24, 0.97, 0.37) + 0.2)\n#define M_SOUL_EYE 2\n#define C_SOUL_EYE (vec3(1.))\n#define M_SOUL_EYEBALL 3\n#define C_SOUL_EYEBALL (vec3(0.1))\n#define M_SOUL_EYEBROW 4\n#define C_SOUL_EYEBROW (vec3(0.2, 0.4, 0.4))\n#define M_SOUL_CHEEK 5\n#define C_SOUL_CHEEK (vec3(0.74, 0.57, 0.17))\n#define M_TREE 6\n#define C_TREE (vec3(0.6, 0.2, 0.6) * 0.9)\n\n#define M_TERRAIN 10\n#define C_TERRAIN (vec3(0.1, 0.6, 1.7))\n#define M_GRASS 11\n#define C_GRASS1 (vec3(1.24, 4.97, 3.37))\n#define C_GRASS (vec3(3.9, 0.37, 3.9))\n\n#define C_SKY_UP (vec3(0.29, 0.44, 1.56))\n#define C_SKY_DOWN (vec3(4.5, 0.94, 4.57))\n\nstruct M {\n    vec3 emission;\n    vec3 diffuse;\n};\n\nfloat noise(in vec2 uv) {\n    return fract(sin(uv.x * 1233.52 + uv.y * 99.23423) * 324.234);\n}\n\nfloat noiseSmooth(in vec2 uv) {\n    vec2 uvs = floor(uv);\n    vec2 d = fract(uv);\n    vec2 s = vec2(1., 0.);\n    float tl = noise(uvs);\n    float tr = noise(uvs + s.xy);\n    float bl = noise(uvs + s.yx);\n    float br = noise(uvs + s.xx);\n    float top = mix(tl, tr, d.x);\n    float bottom = mix(bl, br, d.x);\n    float mx = mix(top, bottom, d.y);\n    return max(0., mx);\n}\n\nfloat rayPlane(vec3 ro, vec3 rd, vec3 n, float d) {\n    float denom = dot(n, rd);\n    if (abs(denom) > 1e-6) {\n        return dot(n*d - ro, n) \/ denom;\n    }\n    return -1.;\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp( 0.5+0.5*(b-a)\/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k) {\n    return -smin(-a, -b, k);\n}\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))\/(x*(c*x+d)+e), 0., 1.);\n}\n\nfloat getSoulCurve(in float time) {\n    return cos(time) * 0.5 + 0.5;\n}\n\nfloat sdSoulHead(in vec3 p, in float size, in float curve) {\n    float d;\n    vec3 mir = p * vec3(sign(p.x), 1., 1.);\n\n    float lowSphere = length((p) * vec3(1., 1.7, 1.) - vec3(0., -0.5, 0.) * size) - size;\n    float hiSphere = length(p * vec3(1., 1.5, 1.) - vec3(0., 0.3, 0.) * size) - size * 0.9;\n    float head = smin(lowSphere, hiSphere, 0.5 * size);\n    d = head;\n    \n    float eye = length(mir - vec3(0.7, 0.15, -1.2) * size) - size * 0.33;\n    d = smax(d, -eye, 0.4 * size);\n    \n    return d;\n}\n\n#define SEPOS (vec3(0.4, 0.05, -0.65))\nfloat sdSoulEye(in vec3 p, in float size) {\n    vec3 mir = p * vec3(sign(p.x), 1., 1.);\n    return length(mir - vec3(0.4, 0.05, -0.65) * size) - size * 0.2;\n}\n\nfloat sdSoulEyebrow(in vec3 p, in float size, in float curve) {\n    float jump = max(0., curve - 0.6);\n    vec3 mir = p * vec3(sign(p.x), 1., 1.);\n    return length((mir - vec3(0.4, 0.4 + jump * 1. * size, -.55) * size) * vec3(1., 5., 1.) ) - size * 0.2;\n}\n\nfloat sdSoulMouth(in vec3 p, in float size, in float curve) {\n    return length((p - vec3(0., -0.3 + p.x*p.x*20., -0.9) * size) * vec3(1.2, mix(9., 3., curve), 1.)) - size * 0.2;\n}\n\nfloat sdBody(in vec3 p, in float size, in float curve) {\n    p -= vec3(0., -1.4, 0.) * size;\n    \n    float spread = min(0., -cos((p.y \/ size) * 2.)) * mix(0.4, 0., curve) + 1.;\n    float shrink = mix(1.4, 1., curve);\n    p *= vec3(spread, shrink, spread);\n    \n    return max(\n        smin(\n            length(p.xz) - size * 0.3,\n            length(p - vec3(0., -0.6, 0.) * size) - size * 0.5,\n            0.35 * size\n        ),\n        length(p) - size * 0.8\n    );\n}\n\nvec2 modSoul(in vec3 pOrig, in float size, in float time) {\n    float curve = getSoulCurve(time);\n    vec3 p = pOrig;\n    \n    float jump = max(0., curve - 0.6);\n    \n    p -= vec3(0., 2.1 + mix(-0.2, 0., curve) + jump, 0.) * size;\n    \n    float body = sdBody(p, size, curve);\n    float head = sdSoulHead(p, size, curve);\n    \n    float cheekDot = abs(dot(\n        normalize(p * vec3(sign(p.x), 1., 1.)), \n        normalize(vec3(0.8, -0.45, -1.))\n    ));\n    \n    vec2 res = vec2(\n        smin(head, body, 0.5 * size), \n        cheekDot > 0.988 ? M_SOUL_CHEEK : M_SOUL_BODY\n    );\n    \n    \n    \n    float mouth = sdSoulMouth(p, size, curve);\n    if (-mouth > res.x) { res = vec2(mouth, vec3(0.1)); }\n    \n    float eye = sdSoulEye(p, size);\n    if (eye < res.x) { \n        vec3 eyePos = normalize(p * vec3(sign(p.x), 1., 1.) - SEPOS * size);\n        bool ball = dot(eyePos, normalize(vec3(0.3, 0., -1.))) > 0.95;\n        res = vec2(eye, ball ? M_SOUL_EYEBALL : M_SOUL_EYE); \n    }\n    \n    float eyebrow = sdSoulEyebrow(p, size, curve);\n    if (eyebrow < res.x) { res = vec2(eyebrow, M_SOUL_EYEBROW); }\n    \n    return res;\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdTerr(vec3 p) {\n    float cell = 0.01;\n    p -= vec3(0., -0.01, 0.);\n    vec2 fl = mod(p.xz, cell);\n    vec3 rp = vec3(fl.x, p.y, fl.y) - vec3(cell, 0., cell) \/ 2.;\n    \n    vec2 corner = floor(p.xz \/ cell) * cell;\n    \n    float disp = noise(corner * 200.);\n    disp = mix(-0.4, 0.05, disp);\n    \n    rp -= vec3(0., 0. + disp, 0.);\n    \n    float dist = sdSphere(\n        rp * vec3(1., 0.1, 1.), \n        0.004\n    );\n    \n    return min(p.y, dist);\n}\n\nfloat sdTree(vec3 p) {\n    float r = 0.3;\n    return sdSphere((p - vec3(0., r + 0.2, 0.)) * vec3(3., 1., 2.), r) * 0.8;\n}\n\n\/\/\/\n\/\/\/\n\/\/\/\n\nvec2 getDist(vec3 p, bool ignoreSouls) {\n    vec2 res = vec2(MAX_DIST, -1.);\n    \n    vec2 temp;\n    \n    if (!ignoreSouls) {\n        temp = modSoul(p - vec3(0., 0.03, 0.), SOUL_SIZE, iTime * 8.);\n        if (temp.x < res.x) { res = temp; };\n    }\n    \n    temp = vec2(sdTerr(p), M_GRASS);\n    if (temp.x < res.x) { res = temp; }\n    \n    temp = vec2(sdTree(p - vec3(-0.95, sin(iTime) * 0.03, 0.5)), M_TREE);\n    if (temp.x < res.x) { res = temp; }\n    \n    temp = vec2(sdTree((p - vec3(0.8, sin(iTime + 3.) * 0.03, 0.8)) * 1.2), M_TREE);\n    if (temp.x < res.x) { res = temp; }\n    \n    temp = vec2(sdTree((p - vec3(0.7, sin(iTime * 2.) * 0.03 - 0.4, -0.5)) * 0.4), M_TREE);\n    if (temp.x < res.x) { res = temp; }\n    \n    return res;\n}\n\n\/\/\/\n\/\/\/\n\/\/\/\n\nvec3 getNormal(vec3 p, bool ignoreSouls) {\n    float dist = getDist(p, ignoreSouls).x;\n    vec2 e = vec2(0.001, 0.);\n    vec3 n = dist - vec3(\n        getDist(p - e.xyy, ignoreSouls).x,\n        getDist(p - e.yxy, ignoreSouls).x,\n        getDist(p - e.yyx, ignoreSouls).x);\n    return normalize(n);\n}\n\nvec2 rayCast(vec3 ro, vec3 rd, bool ignoreSouls) {\n    float total = 0.;\n    \n    for (int i = 0; i < MAX_COUNT; ++i) {\n        vec2 hit = getDist(ro + rd * total, ignoreSouls);\n        float d = hit.x;\n        total += d;\n        if ((d) < MIN_DIST) return vec2(total, hit.y);\n        if (total > MAX_DIST) return vec2(total, -1.);\n    }\n    \n    return vec2(MAX_DIST + 1., -1.);\n}\n\nM getMaterial(float m, vec3 rd, vec3 touch) {\n    int im = int(m);\n    vec3 z = vec3(0.);\n    \n    if (im == M_SOUL_BODY) return M(z, C_SOUL_BODY);\n    if (im == M_SOUL_EYE) return M(z, C_SOUL_EYE);\n    if (im == M_SOUL_EYEBALL) return M(z, C_SOUL_EYEBALL);\n    if (im == M_SOUL_EYEBROW) return M(z, C_SOUL_EYEBROW);\n    if (im == M_SOUL_CHEEK) return M(z, C_SOUL_CHEEK);\n    \n    if (im == M_GRASS) {\n        float cell = 0.4;\n        vec2 corner = floor(touch.xz \/ cell) * cell;\n        float cf = noise(corner * 100.);\n        vec3 col = mix(C_GRASS1, C_GRASS, cf);\n        float f = clamp(touch.y, 0., 0.1) \/ 0.1;\n        return M(z, mix(C_TERRAIN, col * 3., f));\n    }\n    \n    if (im == M_TERRAIN) {\n        return M(z, C_TERRAIN);\n    }\n    \n    float angle = dot(rd, vec3(0., 1., 0.));\n    float axis = dot(rd, vec3(-1., 0., 0.));\n    \n    float skypow = clamp(angle, 0., 1.);\n    vec3 sky = mix(C_SKY_DOWN, C_SKY_UP, smoothstep(-0.3, 0.25, skypow));\n    \n    \n    float mount;\n    \n    mount = (sin(axis * 5.5 + 2.5)) * 0.1 - 0.;\n    mount = exp(-max(0., angle - mount)*25.);\n    sky = mix(sky, vec3(0.6, 0.5, 4.9) * mix(0.5, 1., angle\/0.2), mount);\n    \n    mount = (sin(axis * 6.) * 0.5 + 0.5) * 0.1 - 0.15;\n    mount = exp(-max(0., angle - mount)*65.);\n    sky = mix(sky, vec3(0.8, 0.9, 1.9) * mix(0.4, 0.3, angle\/0.2), mount);\n    \n    mount = (sin(axis * 6.) * 0.5 + 0.5) * 0.1 - 0.23;\n    mount = exp(-max(0., angle - mount)*65.);\n    sky = mix(sky, vec3(3.4, 2.9, 1.9) * mix(0.4, 0.3, angle\/0.2), mount);\n    \n    \n    if (im == M_TREE) {\n        return M(z, C_TREE);\n    }\n    \n    return M(sky, z);\n}\n\nvec3 getLightWithPos(in vec3 lightPos, in vec3 lightCol, in vec3 p, in vec3 n, bool occlusion) {\n    vec3 toLight = lightPos - p;\n    vec3 nToLight = normalize(toLight);\n    float dToLight = length(toLight);\n    float pLight = max(0., dot(n, nToLight));\n    if (occlusion) {\n        float occlDist = rayCast(p + nToLight * 0.01, nToLight, false).x;\n        pLight *= min(1., pow(occlDist \/ dToLight, 1.));\n    }\n    return pLight * lightCol;\n}\n\nvec3 getLight(in vec3 p, in vec3 n, bool occlusion) {\n    return getLightWithPos(vec3(1., 1., -1.), vec3(1.3), p, n, occlusion) + \n        getLightWithPos(vec3(-1., 0.4, 1.), vec3(5., .2, .2) * 2., p, n, occlusion);\n}\n\nvec3 castToLight(in vec3 ro, in vec3 rd, out vec2 hit, out vec3 n, out vec3 touch, bool ignoreSouls) {\n    vec3 col = vec3(0.);\n    \n    hit = rayCast(ro, rd, ignoreSouls);\n    if (hit.x >= MAX_DIST) {\n        return getMaterial(-1., rd, touch).emission;\n    }\n    \n    touch = ro + rd * hit.x;\n    M m = getMaterial(hit.y, rd, touch);\n    \n    vec3 ambient = C_SKY_UP;\n    col += m.diffuse * ambient;\n    \n    vec3 lightPos = vec3(2., 1.5, -3.);\n    vec3 lightCol = vec3(1.) * 2.;\n    \n    col += m.emission;\n    \n    if (length(m.diffuse) > 0.01) {\n        n = getNormal(touch, ignoreSouls);\n        col += m.diffuse * getLight(touch, n, true);\n    }\n    \n    return col;\n}\n\nvec3 renderScene(in vec3 ro, in vec3 rd) {\n    vec2 hit;\n    vec3 n, touch;\n    vec3 col = castToLight(ro, rd, hit, n, touch, false);\n    \n    int mid = int(hit.y);\n    if (mid == M_SOUL_BODY || mid == M_SOUL_CHEEK) {\n        float f = 1.-max(0., -dot(n, rd));\n        f = clamp(f, 0.5, 0.8) - 0.5;\n        f \/= 0.3;\n        if (f > 0.1) {\n            vec3 sub = castToLight(ro, rd, hit, n, touch, true);\n            col = mix(col, sub, f) * (1. - abs(n) * 0.3);\n        }\n    }\n    \n    if (mid == M_TREE) {\n        vec3 sky = getMaterial(-1., rd, touch).emission;\n        float f = 1.-max(0., -dot(n, rd));\n        f = clamp(f, 0.0, 1.);\n        f \/= 0.9;\n        f = max(0., f);\n        col = mix(col, sky, f);\n    }\n    \n    if (hit.x < MAX_DIST && touch.y < 0.1) {\n        vec3 planeN = vec3(0., 1., 0.);\n        float upDist = rayPlane(ro, rd, planeN, 0.1);\n        if (upDist > 0.) {\n            vec3 plane = ro + rd * upDist;\n            float dist = length(plane - touch);\n            \n            float scaterring = 1. - exp(-dist * 10.);\n            float absorbing = 1. - exp(-dist * 35.);\n            \n            vec3 diffuse = C_TERRAIN;\n            \n            col = mix(col, vec3(0.), absorbing) + \n                scaterring * diffuse * getLight(plane + 0.5 * dist * rd, planeN, false);\n        }\n    }\n    \n    if (hit.x < MAX_DIST && touch.y < 0.15) {\n        vec3 planeN = vec3(0., 1., 0.);\n        float upDist = rayPlane(ro, rd, planeN, 0.15);\n        if (upDist > 0.) {\n            vec3 plane = (ro + rd * upDist);\n            \n            vec3 diffuse = vec3(noiseSmooth(plane.xz * 9. + vec2(0., iTime * 0.3)));\n            col += diffuse * 0.2 * getLight(plane, planeN, false);\n            \n        }\n    }\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 vpShift = vec2(iResolution.x\/iResolution.y, 1.);\n    vec2 vp = fragCoord\/iResolution.y*2. - vpShift;\n    \n    float time = iTime * 0.5;\n    vec3 origin = vec3(sin(time) * 0.2, 0.5, -2.);\n    vec3 target = vec3(0., 0.4, 0.);\n    vec3 up = vec3(0., 1., 0.);\n     \n    vec3 camForward = normalize(target - origin);\n    vec3 camRight = normalize(cross(up, camForward));\n    vec3 camUp = cross(camForward, camRight);\n    \n    vec3 ro = origin;\n    vec3 rd = normalize(3. * camForward + camRight * 1. * vp.x + camUp * vp.y);\n\n    vec3 col = renderScene(ro, rd);\n    \n    \/\/fragColor = vec4(col, 1.);\n    fragColor = vec4(ACESFilm(col), 1.);\n}",
            "name": "Image",
            "description": "",
            "type": "image"
        }
    ]
}