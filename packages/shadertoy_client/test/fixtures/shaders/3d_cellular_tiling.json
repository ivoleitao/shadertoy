{
    "ver": "0.1",
    "info": {
        "id": "ld3Szs",
        "date": "1460906570",
        "viewed": 6862,
        "name": "3D Cellular Tiling",
        "username": "Shane",
        "description": "Creating a Voronoi surface feel with minimal instructions by way of a cellular 3D tile.",
        "likes": 131,
        "published": 3,
        "flags": 0,
        "usePreview": 0,
        "tags": [
            "3d",
            "voronoi",
            "sss",
            "volumetric",
            "scattering",
            "cellular",
            "tiling"
        ],
        "hasliked": 0
    },
    "renderpass": [
        {
            "inputs": [
                {
                    "id": "Xsf3Rr",
                    "filepath": "\/media\/a\/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg",
                    "previewfilepath": "\/media\/ap\/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg",
                    "type": "texture",
                    "channel": 0,
                    "sampler": {
                        "filter": "mipmap",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dfGRr",
                    "channel": 0
                }
            ],
            "code": "\/*\n\n    3D Cellular Tiling\n    ------------------\n    \n    Creating a Voronoi feel with minimal instructions by way of a 3D tile constructed via a \n\tsimplistic cellular pattern algorithm. It works surprisingly well under various situations,\n\tbut isn't a replacement for the standard 3D Voronoi algorithm.\n\n\tThis is a 3D counterpart to my 2D cellular tiling example. The link is below, where I explain\n\tthe process more thoroughly, for anyone interested. I came up with the idea for a repeatable\n\tcellular tile when experimenting with 3D Truchet tiles.\n\n\tNaturally, there are a few restrictions. The obvious one is that repeatable tiles with low\n\tobject density look very repetitive when you zoom out, so that has to be considered. The \n\tupside is quasi 3D celluar surfaces that are fast enough to include in a distance function.\n\n\tAnyway, the 3D tiling function is explained below. For anyone interested, the scene itself\n\tutilizes an oldschool, warping planes trick. Shadertoy user Branch uses it to great effect in \n\tthe example \"18756.2048d,\" which is well worth the look.\n\n    Related examples: \n\n    Cellular Tiling - Shane\n    https:\/\/www.shadertoy.com\/view\/4scXz2\n\n\t18756.2048d - Branch\n\thttps:\/\/www.shadertoy.com\/view\/ld3XzS\n\n*\/\n\n#define PI 3.14159265\n#define FAR 50.\n\n\/\/ Frequencies and amplitudes of tunnel \"A\" and \"B\". See then \"path\" function.\nconst float freqA = 0.15;\nconst float freqB = 0.25;\nconst float ampA = 3.6;\nconst float ampB = .85;\n\n\n\/\/ Standard 1x1 hash functions. Using \"cos\" for non-zero origin result.\nfloat hash( float n ){ return fract(cos(n)*45758.5453); }\n\n\/\/ Non-standard vec3-to-vec3 hash function.\nvec3 hash33(vec3 p){ \n    \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\n\/\/ 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n\/\/ of Fabrice Neyret's \"ouside the box\" thinking. :)\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) + a);\treturn mat2(v, -v.y, v.x); }\n\n\n\/\/ Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max(abs(n) - 0.2, 0.001); \/\/ n = max(abs(n), 0.001), etc.\n    n \/= (n.x + n.y + n.z );  \n    \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    return p*p;\n}\n\n\/\/ More concise, self contained version of IQ's original 3D noise function.\nfloat noise3D(in vec3 p){\n    \n    \/\/ Just some random figures, analogous to stride. You can change this, if you want.\n\tconst vec3 s = vec3(7, 157, 113);\n\t\n\tvec3 ip = floor(p); \/\/ Unique unit cell ID.\n    \n    \/\/ Setting up the stride vector for randomization and interpolation, kind of. \n    \/\/ All kinds of shortcuts are taken here. Refer to IQ's original formula.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    \n\tp -= ip; \/\/ Cell's fractional component.\n\t\n    \/\/ A bit of cubic smoothing, to give the noise that rounded look.\n    p = p*p*(3. - 2.*p);\n    \n    \/\/ Standard 3D noise stuff. Retrieving 8 random scalar values for each cube corner,\n    \/\/ then interpolating along X. There are countless ways to randomize, but this is\n    \/\/ the way most are familar with: fract(sin(x)*largeNumber).\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n\t\n    \/\/ Interpolating along Y.\n    h.xy = mix(h.xz, h.yw, p.y);\n    \n    \/\/ Interpolating along Z, and returning the 3D noise value.\n    return mix(h.x, h.y, p.z); \/\/ Range: [0, 1].\n\t\n}\n\n\n\/\/\/\/\/\/\/\/\n\n\/\/ The cellular tile routine. Draw a few gradient shapes (six to eight spheres, in this case) \n\/\/ using the darken (min(src, dst)) blend at various 3D locations on a cubic tile. Make the \n\/\/ tile wrappable by ensuring the objects wrap around the edges. That's it.\n\/\/\n\/\/ Believe it or not, you can get away with as few as four spheres. Of course, there is 8-tap \n\/\/ Voronoi, which has the benefit of scalability, and so forth, but if you sum the total \n\/\/ instruction count here, you'll see that it's way, way lower. Not requiring a hash function\n\/\/ provides the biggest benefit, but there is also less setup.\n\/\/ \n\/\/ The result isn't perfect, but 3D cellular tiles can enable you to put a Voronoi looking \n\/\/ surface layer on a lot of 3D objects for little cost. In fact, it's fast enough to raymarch.\n\/\/\nfloat drawSphere(in vec3 p){\n    \n    p = fract(p)-.5;    \n    return dot(p, p);\n    \n    \/\/p = abs(fract(p)-.5);\n    \/\/return dot(p, vec3(.166));\n    \n}\n\n\/\/ Draw some spheres throughout a repeatable cubic tile. The offsets were partly based on \n\/\/ science, but for the most part, you could choose any combinations you want. This \n\/\/ particular function is used by the raymarcher, so involves fewer spheres.\n\/\/\nfloat cellTile(in vec3 p){\n    \n    float c = .25; \/\/ Set the maximum.\n    \n    \/\/ Draw four overlapping objects (spheres, in this case) using the darken blend \n    \/\/ at various positions throughout the tile.\n    c = min(c, drawSphere(p - vec3(.81, .62, .53)));\n    c = min(c, drawSphere(p - vec3(.39, .2, .11)));\n    \n    c = min(c, drawSphere(p - vec3(.62, .24, .06)));\n    c = min(c, drawSphere(p - vec3(.2, .82, .64)));\n    \n    \n    \/\/ Add some smaller spheres at various positions throughout the tile.\n    \n    p *= 1.4142;\n    \n    c = min(c, drawSphere(p - vec3(.48, .29, .2)));\n    c = min(c, drawSphere(p - vec3(.06, .87, .78)));\n    \n    \/\/ More is better, but I'm cutting down to save cycles.\n    \/\/c = min(c, drawSphere(p - vec3(.6, .86, .0)));\n    \/\/c = min(c, drawSphere(p - vec3(.18, .44, .58)));\n        \n    return (c*4.); \/\/ Normalize.\n    \n}\n\n\/\/ The same as above, but with an extra two spheres. This is used by the bump map function,\n\/\/ which although expensive, isn't too bad. Just for the record, even bump mapping a\n\/\/ reasonably fast cellular function, like 8-Tap Voronoi, can still be a drain on the GPU.\n\/\/ However, the GPU can bump map this function in its sleep.\n\/\/\nfloat cellTile2(in vec3 p){\n    \n    float c = .25; \/\/ Set the maximum.\n    \n    c = min(c, drawSphere(p - vec3(.81, .62, .53)));\n    c = min(c, drawSphere(p - vec3(.39, .2, .11)));\n    \n    c = min(c, drawSphere(p - vec3(.62, .24, .06)));\n    c = min(c, drawSphere(p - vec3(.2, .82, .64)));\n    \n    p *= 1.4142;\n    \n    c = min(c, drawSphere(p - vec3(.48, .29, .2)));\n    c = min(c, drawSphere(p - vec3(.06, .87, .78)));\n\n    c = min(c, drawSphere(p - vec3(.6, .86, .0)));\n    c = min(c, drawSphere(p - vec3(.18, .44, .58)));\n        \n    return (c*4.);\n    \n}\n\n\/\/ The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){ return vec2(ampA*sin(z * freqA), ampB*cos(z * freqB)); }\n\n\n\/\/ There's a few simple, warping tricks being employed here. One is the oldscool, \"top and bottom\n\/\/ planes\" via \"abs(p.y).\" The planes are then twisted about the XY plane with respect to distance \n\/\/ using the 2D rotation function, \"rot2(p.z\/12.),\" etc, then wrapped aound a curvy path, \"path(p.z).\"\n\/\/\n\/\/ Finally, some surface detailing is added with a sinusoidal bottom layer, and the cellular layer \n\/\/ over the top of it. Normally, adding cellular layering utterly fries the GPU, but the \"cellTile\"\n\/\/ function used here merely makes it slightly uncomfortable. :)\n\/\/\nfloat map(vec3 p){\n    \n    \n     float sf = cellTile(p*.25); \/\/ Cellular layer.\n    \n     p.xy -= path(p.z); \/\/ Move the scene around a sinusoidal path.\n     p.xy = rot2(p.z\/12.)*p.xy; \/\/ Twist it about XY with respect to distance.\n    \n     float n = dot(sin(p*1. + sin(p.yzx*.5 + iTime)), vec3(.25)); \/\/ Sinusoidal layer.\n     \n     return 2. - abs(p.y) + n + sf; \/\/ Warped double planes, \"abs(p.y),\" plus surface layers.\n   \n\n     \/\/ Standard tunnel. Comment out the above first.\n     \/\/vec2 tun = p.xy - path(p.z);\n     \/\/return 3. - length(tun) - (0.5-surfFunc(p)) +  dot(sin(p*1. + sin(p.yzx*.5 + iTime)), vec3(.333))*.5+.5;\n\n \n}\n\n\/*\n\/\/ Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n\/\/ make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    \/\/ Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; \/\/ Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )\/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); \/\/ Bumped normal. \"bf\" - bump factor.\n\t\n}\n*\/\n\n\/\/ Surface bump function. Cheap, but with decent visual impact.\nfloat bumpSurf3D( in vec3 p){\n    \n    float noi = noise3D(p*64.);\n    float vor = cellTile2(p*.75);\n    \n    return vor*.98 + noi*.02;\n\n}\n\n\/\/ Standard function-based bump mapping function.\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    const vec2 e = vec2(0.001, 0);\n    float ref = bumpSurf3D(p);                 \n    vec3 grad = (vec3(bumpSurf3D(p - e.xyy),\n                      bumpSurf3D(p - e.yxy),\n                      bumpSurf3D(p - e.yyx) )-ref)\/e.x;                     \n          \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\n\/\/ Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    float t = 0.0, h;\n    for(int i = 0; i < 80; i++){\n    \n        h = map(ro+rd*t);\n        \/\/ Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        \/\/ \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(h)<0.002*(t*.25 + 1.) || t>FAR) break; \/\/ Alternative: 0.001*max(t*.25, 1.)\n        t += h*.8;\n        \n    }\n\n    return clamp(t, 0., FAR);\n}\n\n\/\/ Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical. Due to \n\/\/ the intricacies of this particular scene, it's kind of needed to reduce jagged effects.\nvec3 getNormal(in vec3 p) {\n\tconst vec2 e = vec2(0.002, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n\/*\n\/\/ XT95's really clever, cheap, SSS function. The way I've used it doesn't do it justice,\n\/\/ so if you'd like to really see it in action, have a look at the following:\n\/\/\n\/\/ Alien Cocoons - XT95: https:\/\/www.shadertoy.com\/view\/MsdGz2\n\/\/\nfloat thickness( in vec3 p, in vec3 n, float maxDist, float falloff )\n{\n\tconst float nbIte = 6.0;\n\tfloat ao = 0.0;\n    \n    for( float i=1.; i< nbIte+.5; i++ ){\n        \n        float l = (i*.75 + fract(cos(i)*45758.5453)*.25)\/nbIte*maxDist;\n        \n        ao += (l + map( p -n*l )) \/ pow(1. + l, falloff);\n    }\n\t\n    return clamp( 1.-ao\/nbIte, 0., 1.);\n}\n*\/\n\n\/\/ Using a variation of IQ's AO function to calculate thickness, but with the normal flipped.\n\/\/ IQ uses a similar setup to calculate SSS... Subsurface AO, I guess you'd call it. :)\nfloat thickness(in vec3 p, in vec3 n){\n    \n    float sNum = 4.;\n    float sca = 1., occ = 0.;\n    for(float i=0.; i<sNum + .001; i++ ){\n    \n        float hr = 0.05 + .4*i\/sNum; \n        \/\/vec3 rn = normalize(n + RandomHemisphereDir(n, hr)*rad*.5);\n        float dd = map(p - n*hr);\n        occ += (hr - min(dd, 0.))*sca;\n        sca *= .9;\n    }\n    return 1. - max(occ\/sNum, 0.); \n    \n}\n\n\/*\n\/\/ Shadows.\nfloat softShadow(vec3 ro, vec3 rd, float start, float end, float k){\n\n    float shade = 1.0;\n    const int maxIterationsShad = 24;\n\n    float dist = start;\n    float stepDist = end\/float(maxIterationsShad);\n\n    \/\/ Max shadow iterations - More iterations make nicer shadows, but slow things down.\n    for (int i=0; i<maxIterationsShad; i++){\n    \n        float h = map(ro + rd*dist);\n        shade = min(shade, k*h\/dist);\n\n        \/\/ +=h, +=clamp( h, 0.01, 0.25 ), +=min( h, 0.1 ), +=stepDist, +=min(h, stepDist*2.), etc.\n        dist += min(h, stepDist);\n        \n        \/\/ Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0.001 || dist > end) break; \n    }\n\n    \/\/ Shadow value.\n    return min(max(shade, 0.) + 0.3, 1.0); \n}\n*\/\n\n\/\/ Ambient occlusion, for that self shadowed look. Based on the original by XT95. I love this \n\/\/ function, and in many cases, it gives really, really nice results. For a better version, and \n\/\/ usage, refer to XT95's examples below:\n\/\/\n\/\/ Hemispherical SDF AO - https:\/\/www.shadertoy.com\/view\/4sdGWN\n\/\/ Alien Cocoons - https:\/\/www.shadertoy.com\/view\/MsdGz2\nfloat calculateAO( in vec3 p, in vec3 n )\n{\n\tfloat ao = 0.0, l;\n    const float maxDist = 4.;\n\tconst float nbIte = 6.0;\n\t\/\/const float falloff = 0.9;\n    for( float i=1.; i< nbIte+.5; i++ ){\n    \n        l = (i + hash(i))*.5\/nbIte*maxDist;\n        \n        ao += (l - map( p + n*l ))\/(1.+ l);\/\/ \/ pow(1.+l, falloff);\n    }\n\t\n    return clamp(1.- ao\/nbIte, 0., 1.);\n}\n\n\n\/\/ Cool curve function, by Shadertoy user, Nimitz.\n\/\/\n\/\/ Original usage (I think?) - Cheap curvature: https:\/\/www.shadertoy.com\/view\/Xts3WM\n\/\/ Other usage: Xyptonjtroz: https:\/\/www.shadertoy.com\/view\/4ts3z2\nfloat curve(in vec3 p, in float w){\n\n    vec2 e = vec2(-1., 1.)*w;\n    \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    \n    return 0.125\/(w*w) *(t1 + t2 + t3 + t4 - 4.*map(p));\n}\n\n\n\/\/\/\/\/\n\/\/ Code block to produce four layers of fine mist. Not sophisticated at all.\n\/\/ If you'd like to see a much more sophisticated version, refer to Nitmitz's\n\/\/ Xyptonjtroz example. Incidently, I wrote this off the top of my head, but\n\/\/ I did have that example in mind when writing this.\nfloat trig3(in vec3 p){\n    p = cos(p*2. + (cos(p.yzx) + 1. + iTime*4.)*1.57);\n    return dot(p, vec3(0.1666)) + 0.5;\n}\n\n\/\/ Basic low quality noise consisting of three layers of rotated, mutated \n\/\/ trigonometric functions. Needs work, but it's OK for this example.\nfloat trigNoise3D(in vec3 p){\n\n    \/\/ 3D transformation matrix.\n    const mat3 m3RotTheta = mat3(0.25, -0.866, 0.433, 0.9665, 0.25, -0.2455127, -0.058, 0.433, 0.899519 )*1.5;\n  \n\tfloat res = 0.;\n\n    float t = trig3(p*PI);\n\tp += (t - iTime*0.25);\n    p = m3RotTheta*p;\n    \/\/p = (p+0.7071)*1.5;\n    res += t;\n    \n    t = trig3(p*PI); \n\tp += (t - iTime*0.25)*0.7071;\n    p = m3RotTheta*p;\n     \/\/p = (p+0.7071)*1.5;\n    res += t*0.7071;\n\n    t = trig3(p*PI);\n\tres += t*0.5;\n\t \n\treturn res\/2.2071;\n}\n\n\/\/ Hash to return a scalar value from a 3D vector.\nfloat hash31(vec3 p){ return fract(sin(dot(p, vec3(127.1, 311.7, 74.7)))*43758.5453); }\n\n\/\/ Four layers of cheap trigonometric noise to produce some subtle mist.\n\/\/ Start at the ray origin, then take four samples of noise between it\n\/\/ and the surface point. Apply some very simplistic lighting along the \n\/\/ way. It's not particularly well thought out, but it doesn't have to be.\nfloat getMist(in vec3 ro, in vec3 rd, in vec3 lp, in float t){\n\n    float mist = 0.;\n    ro += rd*t\/8.; \/\/ Edge the ray a little forward to begin.\n    \n    for (int i = 0; i<4; i++){\n        \/\/ Lighting. Technically, a lot of these points would be\n        \/\/ shadowed, but we're ignoring that.\n        float sDi = length(lp-ro)\/FAR; \n\t    float sAtt = min(1.\/(1. + sDi*0.25 + sDi*sDi*0.05), 1.);\n\t    \/\/ Noise layer.\n        mist += trigNoise3D(ro\/2.)*sAtt;\n        \/\/ Advance the starting point towards the hit point.\n        ro += rd*t\/4.;\n    }\n    \n    \/\/ Add a little noise, then clamp, and we're done.\n    return clamp(mist\/2. + hash31(ro)*0.1-0.05, 0., 1.);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t\n\t\/\/ Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*0.5)\/iResolution.y;\n\t\n\t\/\/ Camera Setup.\n\t\/\/vec3 lookAt = vec3(0., 0.25, iTime*2.);  \/\/ \"Look At\" position.\n\t\/\/vec3 camPos = lookAt + vec3(2., 1.5, -1.5); \/\/ Camera position, doubling as the ray origin.\n\t\n\tvec3 lookAt = vec3(0., 0.0, iTime*6. + 0.1);  \/\/ \"Look At\" position.\n\tvec3 camPos = lookAt + vec3(0.0, 0.0, -0.1); \/\/ Camera position, doubling as the ray origin.\n\n \n    \/\/ Light positioning. One is a little behind the camera, and the other is further down the tunnel.\n \tvec3 light_pos = camPos + vec3(0., 1, 8);\/\/ Put it a bit in front of the camera.\n\n\t\/\/ Using the Z-value to perturb the XY-plane.\n\t\/\/ Sending the camera, \"look at,\" and two light vectors down the tunnel. The \"path\" function is \n\t\/\/ synchronized with the distance function. Change to \"path2\" to traverse the other tunnel.\n\tlookAt.xy += path(lookAt.z);\n\tcamPos.xy += path(camPos.z);\n\tlight_pos.xy += path(light_pos.z);\n\n    \/\/ Using the above to produce the unit ray-direction vector.\n    float FOV = PI\/2.; \/\/ FOV - Field of view.\n    vec3 forward = normalize(lookAt-camPos);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    \/\/ rd - Ray direction.\n    \/\/vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    \n    \n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    \/\/rd = normalize(vec3(rd.xy, rd.z - dot(rd.xy, rd.xy)*.25));    \n    \n    \/\/ Swiveling the camera about the XY-plane (from left to right) when turning corners.\n    \/\/ Naturally, it's synchronized with the path in some kind of way.\n\trd.xy = rot2( path(lookAt.z).x\/16. )*rd.xy;\n\t\t\n    \/\/ Standard ray marching routine. I find that some system setups don't like anything other than\n    \/\/ a \"break\" statement (by itself) to exit. \n\tfloat t = trace(camPos, rd);\n\t\n    \/\/ Initialize the scene color.\n    vec3 sceneCol = vec3(0);\n\t\n\t\/\/ The ray has effectively hit the surface, so light it up.\n\tif(t<FAR){\n\t\n   \t\n    \t\/\/ Surface position and surface normal.\n\t    vec3 sp = t * rd+camPos;\n\t    vec3 sn = getNormal(sp);\n        \n        \n        \/\/ Texture scale factor.\n        const float tSize0 = 1.\/4.; \n    \t\n        \/\/vec3 tsp = sp-vec3(path(sp.z), 0.);\n       \n    \t\/\/ Texture-based bump mapping.\n\t    \/\/sn = doBumpMap(iChannel0, tsp*tSize0, sn, 0.025);\/\/\n        \n        \n        \/\/ Function based bump mapping.\n        sn = doBumpMap(sp, sn, .2);\/\/\/(1.+t*.5\/FAR)\n\t    \n\t    \/\/ Ambient occlusion.\n\t    float ao = calculateAO(sp, sn);\n    \t\n    \t\/\/ Light direction vectors.\n\t    vec3 ld = light_pos-sp;\n\n        \/\/ Distance from respective lights to the surface point.\n\t    float distlpsp = max(length(ld), 0.001);\n    \t\n    \t\/\/ Normalize the light direction vectors.\n\t    ld \/= distlpsp;\n\t    \n\t    \/\/ Light attenuation, based on the distances above.\n\t    float atten = 1.\/(1. + distlpsp*0.3); \/\/ + distlpsp*distlpsp*0.025\n    \t\n    \t\/\/ Ambient light.\n\t    float ambience = 0.5;\n    \t\n    \t\/\/ Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.0);\n   \t\n    \t\/\/ Specular lighting.\n\t    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 32.);\n        \n    \t\n    \t\/\/ Curvature.\n\t    float crv = clamp(curve(sp, 0.125)*0.5+0.5, .0, 1.);\n\t    \n\t    \/\/ Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow( clamp(dot(sn, rd) + 1., .0, 1.), 1.);\n        \n        \/\/ Obtaining the texel color. \n        vec3 ref = reflect(sn, rd);\n\n        \/\/ Object texturing.\n        vec3 texCol = tex3D(iChannel0, sp*tSize0, sn);\n        texCol = smoothstep(-.05, .95, texCol)*(smoothstep(-.5, 1., crv)*.75+.25);\n        \n    \t\/\/\/\/\/\/\/\/\/   \n        \/\/ Translucency, courtesy of a mixture XT95 and IQ;s procedures - See the \"thickness\" function.\n        vec3 hf =  normalize(ld + sn);\n        \/\/float th = thickness( sp, sn, 1., 1. );\n        float th = thickness( sp, sn);\n        float tdiff =  pow( clamp( dot(rd, -hf), 0., 1.), 1.);\n        float trans = max((tdiff + .25)*th*1.5, 0.);  \n        trans = pow(trans, 4.)*1.;        \n    \t\/\/\/\/\/\/\/\/        \n\n    \t\n    \t\/\/ Darkening the crevices. Otherwise known as cheap, scientifically-incorrect shadowing.\t\n\t    float shading = 1.;\/\/ crv*0.5+0.5; \n    \t\n        \/\/ Shadows - They didn't add enough aesthetic value to justify the GPU drain, so they\n        \/\/ didn't make the cut.\n        \/\/shading *= softShadow(sp, ld, 0.05, distlpsp, 8.);\n    \t\n    \t\/\/ Combining the above terms to produce the final color. It was based more on acheiving a\n        \/\/ certain aesthetic than science.\n        sceneCol = texCol*(diff + ambience) + vec3(.7, .9, 1.)*spec + vec3(1, .6, .2)*spec*spec*spec*.5;\n        sceneCol += texCol*vec3(.8, .95, 1)*pow(fre, 4.)*2.;\n        sceneCol += vec3(1, .05, 0)*trans;\n      \n        \n        \/*\n        \/\/ Cool blue hilights. Adapted from numerous examples on here. Kali uses it to great effect.\n        float per = 10.;\n    \tfloat tanHi = abs(mod(per*.5 + t + iTime, per) - per*.5);\n    \tvec3 tanHiCol = vec3(0, .2, 1)*(1.\/tanHi*.2);\n        sceneCol += tanHiCol;\n        *\/\n        \n        \n        \/\/vec3 refCol = vec3(.5, .7, 1)*smoothstep(.2, 1., noise3D((sp + ref*2.)*2.)*.66 + noise3D((sp + ref*2.)*4.)*.34 );\n        \/\/sceneCol += refCol*.5;\n\n\n\t    \/\/ Shading.\n        sceneCol *= atten*shading*ao;\n        \n        \/\/sceneCol = vec3(ao);\n\t   \n\t\n\t}\n       \n    \/\/ Blend the scene and the background with some very basic, 4-layered fog.\n    float mist = getMist(camPos, rd, light_pos, t);\n    vec3 sky = vec3(2.5, 1.75, .875)* mix(1., .72, mist)*(rd.y*.25 + 1.);\n    sceneCol = mix(sceneCol, sky, min(pow(t, 1.5)*.25\/FAR, 1.));\n\n    \/\/ Clamp, perform rough gamma correction, then present the pixel to the screen.\n\tfragColor = vec4(sqrt(clamp(sceneCol, 0., 1.)), 1.0);\n\t\n}",
            "name": "Image",
            "description": "",
            "type": "image"
        }
    ]
}