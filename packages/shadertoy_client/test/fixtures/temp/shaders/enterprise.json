{
    "ver": "0.1",
    "info": {
        "id": "lsVBRc",
        "date": "1530184405",
        "viewed": 2134,
        "name": "Enterprise",
        "username": "noxbuds",
        "description": "Trying to re-create [url=https:\/\/www.youtube.com\/watch?v=LjUQ4RtmLiU]https:\/\/www.youtube.com\/watch?v=LjUQ4RtmLiU[\/url]. The dimensions are likely not very accurate, and there are missing details, but it looks about right.",
        "likes": 29,
        "published": 1,
        "flags": 96,
        "usePreview": 0,
        "tags": [
            "raymarch",
            "star",
            "trek"
        ],
        "hasliked": 0
    },
    "renderpass": [
        {
            "inputs": [
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dfGRr",
                    "channel": 0
                }
            ],
            "code": "\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/                                              \/\/\n\/\/  Attempting to raymarch the USS Enterprise   \/\/\n\/\/  (the Constitution-class variant as seen in  \/\/\n\/\/  the recent Star Trek movies)                \/\/\n\/\/                                   - Noxbuds  \/\/\n\/\/                                              \/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/                                             \/\/\n\/\/                 CONSTANTS                   \/\/\n\/\/                                             \/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ Bloom and a bit of anti-aliasing in reflections\n\/\/ and stuff. Comment out to disable it.\n#define BLOOM\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/                                             \/\/\n\/\/              IMAGE PROCESSING               \/\/\n\/\/                                             \/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ Burgess tonemapping - looks fairly bright\/cheerful, has quite\n\/\/ a bit of contrast aswell\nvec3 burgess(vec3 col)\n{\n    vec3 maxCol = max(vec3(0.0), col - 0.004);\n    vec3 retCol = (maxCol * (6.2 * maxCol + 0.05)) \/ (maxCol * (6.2 * maxCol + 2.3) + 0.06);\n    return pow(retCol, vec3(1.0 \/ 2.2));\n}\n\n\/\/ Final composition\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord\/iResolution.xy;\n    \n    \/\/ Shift the co-ordinates to -1 <= x <= 1\n    \/\/ and correct the aspect ratio\n    \/\/uv = uv * 2.0 - 1.0;\n    \/\/uv.x *= iResolution.x \/ iResolution.y;\n\n    \/\/ Setup colour\n    vec3 col = vec3(0.0);\n    \n    \/\/ Grab colour from Buf A\n    col = texture(iChannel0, uv).rgb;\n    \n    #ifdef BLOOM\n    \/\/ Add some bloom\n    for (float xOff = -10.0; xOff <= 10.0; xOff++)\n    {\n        for (float yOff = -10.0; yOff <= 10.0; yOff++)\n        {\n            \/\/ Distance multiplier\n            float falloff = min(0.1 \/ length(vec2(xOff, yOff)), 1.0);\n            \n            \/\/ Get colour\n            vec4 ncol = texture(iChannel0, (fragCoord + vec2(xOff, yOff)) \/ iResolution.xy);\n            \n            float bright = ncol.r * 0.2126 + ncol.g * 0.7152 + ncol.b * 0.0722;\n            if (ncol.a > 0.0)\n            \tbright = ncol.a;\n            \n            \/\/ Check if it's the bloom colour\n            col = mix(col, ncol.rgb, (falloff - 0.01) * pow(bright, 2.0));\n        }\n    }\n    #endif\n    \n    \/\/ Tonemapping to make the scene look better\n    col = pow(col, vec3(2.2));\n    col = burgess(col);\n    \n    \/\/ Output to screen\n    fragColor = vec4(col,1.0);\n}",
            "name": "Image",
            "description": "",
            "type": "image"
        },
        {
            "inputs": [
                {
                    "id": "4sfGRr",
                    "filepath": "\/media\/a\/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin",
                    "previewfilepath": "\/media\/ap\/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin",
                    "type": "volume",
                    "channel": 0,
                    "sampler": {
                        "filter": "mipmap",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "4s2Szc",
                    "filepath": "https:\/\/soundcloud.com\/belka2898\/star-trek-enterprise-main-1",
                    "previewfilepath": "https:\/\/soundcloud.com\/belka2898\/star-trek-enterprise-main-1",
                    "type": "musicstream",
                    "channel": 1,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 0
                }
            ],
            "outputs": [
                {
                    "id": "4dXGR8",
                    "channel": 0
                }
            ],
            "code": "\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/                                              \/\/\n\/\/  Attempting to raymarch the USS Enterprise   \/\/\n\/\/  (the Constitution-class variant as seen in  \/\/\n\/\/  the recent Star Trek movies)                \/\/\n\/\/                                   - Noxbuds  \/\/\n\/\/                                              \/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/                                             \/\/\n\/\/                 CONSTANTS                   \/\/\n\/\/                                             \/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n#define PI 3.14159\n#define SUN_STRENGTH 40.0\n#define SATURN_POS vec3(60.0, 20.0, 40.0)\n\n\/\/ Directional light direction (should probably\n\/\/ use area\/point lights but whatever)\n\/\/vec3 lightDir = normalize(vec3(0.0, -0.2, -0.5));\nvec3 lightDir = normalize(vec3(-0.2, -0.2, 0.2));\n\n\/\/ Gas cloud cover (titan's atmosphere?)\nvec3 gasColour = vec3(0.9, 0.4, 0.05);\n\n\/\/ Interior light colour\nvec3 intLightCol = vec3(0.9, 0.9, 1.0);\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/                                             \/\/\n\/\/              NOISE GENERATION               \/\/\n\/\/                                             \/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ 2D value noise\nfloat noisev(vec2 p)\n{\n    return fract(sin(p.x * 1234.0 + p.y * 2413.0) * 5647.0);\n}\n\n\/\/ Smoother noise\nfloat noise(vec2 uv)\n{\n    \/\/ Noise vector\n    vec2 nv = vec2(0.0);\n    \n    \/\/ Local positions\n    vec2 lv = fract(uv);\n    vec2 id = floor(uv);\n    \n    \/\/ Interpolate lv\n    lv = lv * lv * (3.0 - 2.0 * lv);\n    \n    \/\/ Calculate each corner\n    float bl = noisev(id);\n    float br = noisev(id + vec2(1, 0));\n    float tl = noisev(id + vec2(0, 1));\n    float tr = noisev(id + vec2(1, 1));\n    \n    \/\/ Interpolate values\n    float b = mix(bl, br, lv.x);\n    float t = mix(tl, tr, lv.x);\n    float n = mix(b, t, lv.y);\n    \n    \/\/ Return n\n    return n;\n}\n\n\/\/ FBM function\nfloat fbm(vec2 p)\n{\n    float f = 0.0;\n    f += 0.5000 * noise(p); p *= 2.01;\n    f += 0.2500 * noise(p+vec2(0.0, 1.0)); p *= 2.02;\n    f += 0.1250 * noise(p+vec2(1.0, 0.0)); p *= 2.03;\n    f += 0.0625 * noise(p+vec2(1.0, 1.0)); p *= 2.04;\n    f \/= 0.9375;\n    return f;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/                                             \/\/\n\/\/           INTERSECTION FUNCTIONS            \/\/\n\/\/                                             \/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ Sphere intersection\nfloat iSphere(vec4 sph, vec3 ro, vec3 rd)\n{\n    \/\/ move the sphere position\n    ro = ro - sph.xyz;\n    \n    \/\/ intersection math\n    float b = 2.0 * dot(ro, rd);\n    float c = dot(ro, ro) - sph.w * sph.w;\n    float h = b * b - 4.0 * c;\n    if (h < 0.0) return -1.0;\n    float t = (-b - sqrt(h)) \/ 2.0;\n    return t;\n}\n\n\/\/ Plane intersection (thanks to:\n\/\/ http:\/\/www.scratchapixel.com\/lessons\/3d-basic-rendering\/minimal-ray-tracer-rendering-simple-shapes\/)\nfloat iPlane(vec3 d, vec3 p, vec3 o, vec3 r)\n{\n    \/\/ Normalize vectors\n    d = normalize(d);\n    r = normalize(r);\n    \n    \/\/ Setup t\n    float t = 0.0;\n    \n    \/\/ Calculate angle between d and r\n    float angle = dot(d, r);\n    \n    \/\/ If the angle is not zero, continue\n    if (angle > 1e-6)\n    {\n        vec3 pxl = p - o;\n        t = dot(pxl, d) \/ angle;\n        return t;\n    }\n    \n    \/\/ Return -1 if we didn't hit anything\n    return -1.0;\n}\n\n\/\/ Sphere normal\nvec3 nSphere(vec3 o, vec4 sph)\n{\n    return (o - sph.xyz) \/ sph.w;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/                                             \/\/\n\/\/             DISTANCE FUNCTIONS              \/\/\n\/\/                                             \/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ Max function for 3d vectors\nfloat max3(vec3 v)\n{\n    return max(max(v.x, v.y), v.z);\n}\n\n\/\/ Smooth length function for vec2\nfloat slength(vec2 v, float n)\n{\n    return pow(v.x * v.y + v.y * v.y, 1.0 \/ n);\n}\n\n\/\/ Smooth length function for vec3\nfloat slength(vec3 v, float n)\n{\n    return pow(v.x * v.x + v.y * v.y + v.z * v.z, 1.0 \/ n);\n}\n\n\/\/ Renders a sphere\n\/\/ p = position in 3d space\n\/\/ r = radius of sphere\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n\/\/ Renders a box\n\/\/ p = position, dim = dimensions\nfloat sdBox(vec3 p, vec3 dim)\n{\n    vec3 d = abs(p) - dim;\n    return length(max(d, 0.0)) + max3(min(d, 0.0));\n}\n\n\/\/ Normal cylinder\nfloat sdCylinder(vec3 p, vec2 h)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n\/\/ Smooth-edge cylinder - base formula was made\n\/\/ by iq (http:\/\/www.iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm),\n\/\/ this is a version which was modified to use a\n\/\/ different length function\nfloat sdSCylinder(vec3 p, vec2 h, float s)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - s;\n}\n\n\/\/ Smooth minimum by iq\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5 + 0.5 * (b - a) \/ k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n\/\/ Combines two objects\nvec2 combine(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    else\n        return b;\n}\n\n\/\/ Smoothly combines two objects\nvec2 scombine(vec2 a, vec2 b, float s)\n{\n    \/\/ Take the minimum\n    float n = smin(a.x, b.x, s);\n    \n    \/\/ Decide, based on the boundary, which\n    \/\/ ID to use\n    if (a.x < b.x)\n        return vec2(n, a.y);\n    else\n        return vec2(n, b.y);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/                                             \/\/\n\/\/              SCENE CREATION                 \/\/\n\/\/                                             \/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ Map function. This calculates the\n\/\/ whole scene\nvec2 map(vec3 p)\n{\n    \/\/ v is the hit data\n    vec2 v;\n    \n    \/\/ Create a backup of p\n    vec3 bkp = p;\n    \n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ The main saucer section \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \n    \/\/ Before creating a cylinder, deform p to\n    \/\/ create a shape closer to the saucer of\n    \/\/ the Constitution-class\n    \n    \/\/ Create a top part\n    float saucerTop = sdCylinder(p, vec2(2.0, 0.2));\n    p.x *= p.z * 0.1 + 0.7;\n    p.y *= p.z * 0.2 + 0.7;\n    saucerTop = smin(saucerTop, sdCylinder((p + vec3(0.0, 0.0, -3.3)).xzy, vec2(0.3, 2.1)), 0.5);\n    \n    \/\/ Reset p and carry on with the top part\n    p = bkp;\n    saucerTop = smin(saucerTop, sdCylinder(p, vec2(0.8, 0.5)), 0.5);\n    \n    \/\/ Make the top slightly wider than the bottom\n    p = bkp;\n    p.xz *= 1.0 - p.y * 0.05;\n    \n    \/\/ Create the main saucer section and add it on\n    float saucer = sdSCylinder(p, vec2(6.0, 0.2), 0.03);\n    saucer = smin(saucerTop, saucer * 2.0 - 0.1, 0.9);\n    \n    \/\/ Add the saucer section in as ID 1\n    v = vec2(saucer, 1);\n    \n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ The 'neck' (?)          \/\/\n\t\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \n    \/\/ This can roughly be simplified to a box which\n    \/\/ has been warped on the z-axis near the bottom\n    p = bkp;\n    \n    \/\/ Warp the z-axis\n    p.z += 0.8;\n    p.z *= -0.7;\n    p.z *= 1.0 \/ (1.0 + pow(p.y, 2.0) * 0.3);\n    p.z += 3.0;\n    \n    \/\/ Draw a box\n    float neck = sdBox(p + vec3(0.0, 0.9, -0.5), vec3(0.5, 0.9, 1.0));\n    \n    \/\/ Add it in as ID 2\n    v = scombine(v, vec2(neck - 0.3, 2), 0.5);\n    \n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ The engineering hull    \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \n    \/\/ This can be done using a cylinder which is warped\n    p = bkp;\n    \n    \/\/ Sort of a smooth maximum I guess; we need a smooth\n    \/\/ transition between the front and back. Multiplying by\n    \/\/ p.z here gives us a nice curve to recreate the shape\n    \/\/ of the engineering hull on the Constitution class.\n    p.y *= smin(12.0 - p.z * 2.0, 1.0, 0.5) * -0.05 + 0.95;\n    \n    \/\/ Now we multiply the x-axis by the z-axis in order to\n    \/\/ make the middle bulge out more\n    p.x *= abs(pow(p.z - 4.0, 2.0)) * 0.01 + 0.99;\n    \n    \/\/ Draw a cylinder\n    float body = sdCylinder((p + vec3(0.0, 3.5, -7.0)).xzy, vec2(1.2, 5.0));\n    \n    \/\/ Add it in as ID 3\n    v = scombine(v, vec2(body - 0.4, 3), 1.0);\n    \n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Deflector dish          \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    p = bkp;\n    \n    \/\/ Create the deflector dish\n    float dish = sdCylinder((p + vec3(0.0, 3.85, -1.3)).xzy, vec2(1.6, 0.05));\n    \n    \/\/ Add it in as ID 4\n    v = scombine(v, vec2(dish, 4), 0.5);\n    \n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Engine nacelles         \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    p = bkp;\n    \n    \/\/ For the nacelles, we can mirror the shape in the\n    \/\/ z-axis so that we don't try and calculate both\n    \/\/ nacelles at once.\n    p.x = abs(p.x);\n    vec3 abkp = p; \/\/ Backup of the mirrored p (might use for nacelle details)\n    \n    \/\/ Make a slight gradient - the rear should be thinner\n    float nwidth = 1.0 - p.z * 0.03;\n    \n    \/\/ The nacelles are shorter near the bottom\n    float hmult = p.y * 0.1 + 0.9;\n    \n    \/\/ Warp the height a bit\n    p.y *= abs(pow(p.z - 11.0, 2.0)) * 0.005 + 0.995;\n    \n    \/\/ First do the nacelles so we know where to place the connectors.\n    \/\/ We can once again use warped cylinders.\n    float nacelle = sdCylinder((p - vec3(3.0, 1.0, 14.0)).xzy, vec2(1.0 * nwidth, 6.0 * hmult));\n    \n    \/\/ Add in the nacelle as ID 5\n    v = combine(v, vec2(nacelle - 0.4, 5));\n    \n    \/\/ In addition, there are spheres on the front which glow\n    p = abkp;\n    \n    \/\/ Just a plain sphere\n    float glowsphere = sdSphere(p - vec3(3.0, 0.95, 8.0), 1.1);\n    float glowsphere2 = sdSphere(p - vec3(3.0, 0.7, 20.0), 0.4);\n    glowsphere = min(glowsphere, glowsphere2);\n    \n    \/\/ Add it in as ID 6\n    v = combine(v, vec2(glowsphere, 6));\n    \n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Nacelle pylons          \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    p = abkp;\n    \n    \/\/ Remember that the pylons are wider at the bottom\n    float pwmult = 0.5 + p.y * p.y * 0.3;\n    \n    \/\/ Rotate the pylons correctly\n    float rot = 0.22 * PI;\n    p.xy *= mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n    \n    \/\/ Calculate the pylons\n    float pylon = sdBox(p - vec3(2.0, 0.0, 9.5), vec3(0.01, 2.5, 0.8 * pwmult));\n    \n    \/\/ Add them in as ID 7\n    v = scombine(v, vec2(pylon - 0.1, 7), 0.5);\n    \n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \/\/ Gas clouds              \/\/\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    if (iTime > 20.0 && iTime < 55.0)\n    {\n        \/\/ Reset p\n        p = bkp;\n    \t\n    \t\/\/ Calculate some clouds around the ship\n        float clouds1 = v.x - min(0.5 * (iTime - 29.0), 2.0);\n        \n        \/\/ Cut out a rectangle based on iTime\n        clouds1 = max(clouds1, -sdBox(p + vec3(0.0, iTime - 54.0, 0.0), vec3(40.0, 20.0, 100.0)));\n        \n        \/\/ Calculate the flatter clouds\n        float clouds2 = p.y + iTime - 33.0 + sin(p.x * 0.3) * cos(p.z * 0.3);\n        \n        \/\/ Combine the clouds smoothly\n        vec2 clouds = vec2(smin(clouds1, clouds2, 1.0), 8);\n        \n        \/\/ And add the clouds onto v\n        v = combine(v, clouds);\n    }\n    if (iTime >= 55.0)\n    {\n        \/\/ Draw titan\n        p = bkp;\n        float titan = sdSphere(p + vec3(0.0, 200.0, 0.0), 190.0);\n        v = combine(v, vec2(titan, 8.0));\n    }\n    \n    \/\/ Return a value\n    return v;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/                                             \/\/\n\/\/              LIGHTING\/SHADING               \/\/\n\/\/                                             \/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ Calculate the normal of a point\nvec3 calcNormal(vec3 p)\n{\n    vec2 eps = vec2(0.002, 0.0);\n    return normalize(vec3(\n        map(p + eps.xyy).x - map(p - eps.xyy).x,\n        map(p + eps.yxy).x - map(p - eps.yxy).x,\n        map(p + eps.yyx).x - map(p - eps.yyx).x\n    ));\n}\n\n\/\/ Hard shadows\nfloat hshadow(vec3 o, vec3 r, float mint, float maxt)\n{\n    for (float t = mint; t < maxt;)\n    {\n        float h = map(o + r * t).x;\n        if (h < 0.001)\n            return 0.0;\n        t += h;\n    }\n    return 1.0;\n}\n\n\/\/ Softer shadows\nfloat sshadow(vec3 o, vec3 r, float mint, float maxt, float k)\n{\n    float res = 1.0;\n    for (float t = mint; t < maxt;)\n    {\n        float h = map(o + r * t).x;\n        if (h < 0.001)\n            return 0.0;\n        res = min(res, k * h \/ t);\n        t += h;\n    }\n    return res;\n}\n\n\/\/ Diffuse shading\nvec3 diffuse(vec3 c, vec3 n)\n{\n    \/\/ Calculate diffuse angle\n    float diff = max(dot(-lightDir, n), 0.0);\n    \n    \/\/ Add ambient lighting\n    diff += 0.1;\n    \n    \/\/ Return it\n    return c * diff;\n}\n\n\/\/ Creates a checkered pattern\nvec3 checker(vec2 p, vec3 col)\n{\n    \/\/ Calculate cell co-ordinates\n    vec2 c = (p - mod(p, 2.0)) \/ 2.0;\n\n    \/\/ Result of mod\n    float modx = mod(c.x, 2.0);\n    float mody = mod(c.y, 2.0);\n\n    \/\/ Create the chess-board-style texture\n    if (modx < 0.05 && mody > 0.05)\n        col *= 0.5;\n    if (modx > 0.05 && mody < 0.05)\n        col *= 0.5;\n    \n    \/\/ Return the colour\n    return col;\n}\n\n\/\/ Material shader\nvec3 material(float id, vec3 p, vec3 n, vec3 r, out float reflective, out bool light) \n{\n    \/\/ Check the ID\n    if (id == 1.0)\n    {\n        \/\/ This is the main saucer shader. This will\n        \/\/ have a few different components so that we\n        \/\/ can have the ship's saucer section done in\n        \/\/ a single distance function.\n        reflective = 0.0;\n        \n        \/\/ Setup colour\n        vec3 col = vec3(0.6);\n        \n        \/\/ UV co-ordinates\n        vec2 uv;\n        \n        \/\/ Windows on the edges\n        if (abs(n.y) < 0.3)\n        {\n            \/\/ Calculate the theta component of\n            \/\/ the polar co-ordinates of (p.x, p.z)\n            float angle = atan(p.x, p.z);\n            \n            \/\/ Wrap the angle around\n            float modv = 1.0 \/ 40.0;\n            float c = (angle - mod(angle, modv)) \/ modv;\n            angle = mod(angle, modv) * 2.0;\n            \n            \/\/ Wrap y around twice (we have two floors)\n            float py = mod(p.y * 0.2, 1.0);\n            \n            \/\/ Calculate some noise\n            float nv = noise(vec2(c, py));\n            \n            \/\/ If the noise is above a threshold, draw\n            \/\/ a lit window. Otherwise draw a darker area\n            if (nv > 0.6)\n            {\n                \/\/ Lit window\n                \n                \/\/ Conditions for displaying a window;\n                \/\/ whether angle and py are within bounds\n                bool xcond = angle < modv * 1.5;\n                bool ycond1 = py > 0.02 && py < 0.03;\n                bool ycond2 = p.y < -0.05 && p.y > -0.10;\n                \n                \/\/ Display window if necessary\n                if (xcond && (ycond1 || ycond2))\n                {\n                    light = true;\n\t                return intLightCol;\n                }\n            }\n            \n            \/\/ If we aren't drawing lights or the grey lines,\n            \/\/ then we are drawing metal, so it must be reflective\n            reflective = 1.0;\n        }\n        \n        \/\/ Create the grey lines that separate the decks here\n        if (p.y > 0.0 && p.y < 0.06 ||\n            p.y > -0.22 && p.y < -0.15 ||\n            p.y > 0.18 && p.y < 0.25)\n        {\n            reflective = 0.05;\n            col = vec3(0.2);\n        }\n        \n        \/\/ Top and bottom sections\n        if (abs(n.y) > 0.95)\n        {\n            \/\/ Calculate UV co-ords (they are just polar co-ords)\n            uv = vec2(atan(p.x, p.z), length(p.xz));\n            \n            \/\/ Create a checker effect to make it look like\n            \/\/ it's made of different parts. Restrict this to\n            \/\/ outer parts\n            vec2 uvs = vec2(uv.x * 4.0, uv.y);\n            vec2 c = uvs - mod(uvs, vec2(0.6));\n            \n            \/\/ Only create plate effect after a radius\n            if (c.y > 1.0)\n            {\n                \/\/ Create 'pixellated' noise here\n            \tfloat nv = fbm(c * 1.5);\n            \tcol = mix(col, col * 1.2, nv);\n                reflective = pow(nv, 2.0) + 0.2;\n                \n                \/\/ Draw the registry number (NCC-1701)\n                \n                \/\/ Since uv.x wraps around weirdly, we need to map twice;\n                \/\/ once for the 'NCC', once for the '-1701'\n                float d = textMap(vec2((uv.x + PI) * -10.0, 8.0 - uv.y * 2.0));\n                float d2 = textMap(vec2((uv.x - PI) * -10.0, 8.0 - uv.y * 2.0));\n                d = min(d, d2);\n                float tw = 0.2;\n                \n                \/\/ Check if we hit something\n                if (d < tw \/ 2.0 && d > -tw \/ 2.0)\n                    col = vec3(0.0);\n            }\n            \n            \/\/ Top and bottom blue lights\n            if (uvs.y < 0.5)\n            {\n                \/\/ Create a light blue colour (navigational lights?)\n                light = true;\n                return vec3(0.3, 0.9, 1.0);\n            }\n            \n            \/\/ Make the nav lights flash\n            float st = sin(iTime * 2.0);\n            if (st > 0.75 && st < 0.95)\n            {\n                \/\/ Green lights (right nav lights)\n                if (length(uvs - vec2(-5.0, 5.5)) < 0.1 ||\n                   length(uvs - vec2(-7.0, 5.5)) < 0.1)\n                {\n                    light = true;\n                    return vec3(0.2, 1.0, 0.2);\n                }\n\n                \/\/ Red lights (left nav lights)\n                if (length(uvs - vec2(5.0, 5.5)) < 0.1 ||\n                   length(uvs - vec2(7.0, 5.5)) < 0.1)\n                {\n                    light = true;\n                    return vec3(1.0, 0.1, 0.1);\n                }\n            }\n            \n            \/\/ Thrusters\n            \/\/ Wrap angle around\n            float mx = mod(uv.x, 0.4);\n            vec2 uvMx = vec2(mx, uv.y + 4.0);\n            \n            if (iTime > 12.0 && iTime < 55.0 && n.y < 0.0)\n            {\n                \/\/ Red lights for thrusters\n                if ((uv.y > 2.5 && uv.y < 3.0) ||\n                   (uv.y > 4.0 && uv.y < 4.5))\n                {\n                    if (mx < 0.1)\n                    {\n                        light = true;\n                        return vec3(2.0, 0.2, 0.2);\n                    }\n                }\n            }\n        }\n        \n        \/\/ Return colour (specular)\n        return diffuse(col, n);\n    }\n    else if (id == 2.0)\n    {\n        \/\/ This is the neck section\n        \/\/ Based on n.x, we use either p.yz or p.xy for UVs\n        \n        \/\/ Setup colour\n        vec3 col = vec3(0.6);\n        \n        \/\/ Setup UV\n        vec2 uv;\n        \n        \/\/ Check n.x\n        if (abs(n.x) > 0.9)\n            uv = p.zy;\n        else\n            uv = p.xy;\n        \n        \/\/ Calculate local (mod) co-ordinates, and\n        \/\/ calculate the cell co-ordinates\n        vec2 c = uv - mod(uv, vec2(0.5));\n        vec2 uvm = mod(uv, vec2(0.5));\n        \n        \/\/ Generate some test lights\n        if (uvm.x < 0.3 && uvm.y < 0.1 && abs(n.x) > 0.9)\n        {\n            \/\/ Now that we have a sort of grid,\n            \/\/ generate noise to determine what lights\n            \/\/ are on or off\n            float nv = noise(c * 6.5);\n            \n            \/\/ If the noise value is above threshold,\n            \/\/ create some light\n            if (nv > 0.8)\n            {\n                light = true;\n            \treturn intLightCol;\n            }\n        }\n        \n        \/\/ Create the plated effect like on the saucer\n        reflective = 0.0;\n        \n        \/\/ Create new mod co-ords\n        c = uv - mod(uv, vec2(0.3));\n        uvm = mod(uv, vec2(0.3));\n        \n        \/\/ Create some noise\n        float nv = noise(c * 1.5);\n        \n        \/\/ Create the plate effect\n        col = mix(col, col * 1.2, nv);\n        reflective = pow(nv, 2.0) + 0.2;\n        \n        \/\/ Return specular colour\n        return diffuse(col, n);\n    }\n    else if (id == 3.0)\n    {\n        \/\/ Engineering hull\n        vec3 col = vec3(0.6);\n        reflective = 1.0;\n        \n        \/\/ Calculate UV co-ordinates; we use\n        \/\/ cylindrical mapping here\n        p = p.xzy;\n        vec2 uv = vec2(atan(n.x, n.z) \/ (2.0 * PI) + 0.5, p.y * 0.5 + 0.5);\n        \n        \/\/ Map a texture\n        uv.x *= 5.0 \/ p.z;\n        \n        \/\/ Correct the UV coordinates\n        uv = uv * 2.0 - 1.0;\n        \n        \/\/ Create new mod co-ords\n        vec2 c = uv - mod(uv, vec2(0.3));\n        vec2 uvm = mod(uv, vec2(0.3));\n        \n        \/\/ Create some noise\n        float nv = noise(c * 1.5);\n        \n        \/\/ Create the plate effect\n        col = mix(col, col * 1.2, nv);\n        reflective = pow(nv, 2.0) + 0.2;\n        \n        \/\/ Return the colour\n        return diffuse(col, n);\n    }\n    else if (id == 4.0)\n    {\n        \/\/ Deflector dish\n        vec3 col = vec3(0.6);\n        reflective = 1.0;\n        \n        \/\/ Move p.xy to local co-ords\n        p.xy += vec2(0.0, 3.85);\n        \n        \/\/ Calculate an angle based on p.xy\n        float angle = atan(p.x, p.y);\n        float r = length(p.xy);\n        \n        \/\/ Deflector light col\n        vec3 defLightCol = vec3(0.3, 0.8, 1.0);\n        \n        \/\/ Only draw lights on the front\n        if (n.z < 0.0)\n        {\n            \/\/ Draw the lights from a radius\n            if (r > 0.9)\n            {\n                \/\/ Repeat it\n                float ma = mod(angle, 0.2);\n\n                if (ma < 0.1)\n                {\n                    light = true;\n                    reflective = 0.0;\n                    return defLightCol * ((ma + 0.1) * 9.0);\n                }\n            }\n            else if (r > 0.72 && r < 0.82)\n            {\n                light = true;\n                reflective = 0.0;\n                return defLightCol;\n            }\n        }\n        \n        \/\/ Return colour\n        return diffuse(col, n);\n    }\n    else if (id == 5.0)\n    {\n        \/\/ Warp nacelles\n        vec3 col = vec3(0.6);\n        reflective = 1.0;\n        \n        \/\/ Calculate UV co-ordinates; we use\n        \/\/ cylindrical mapping here\n        p = p.xzy;\n        vec2 uv = vec2(atan(n.x, n.z) \/ (2.0 * PI) + 0.5, p.y * 0.5 + 0.5);\n        \n        \/\/ Map a texture\n        uv.x *= 6.0 \/ p.z;\n        uv.y *= 4.0;\n        \n        \/\/ Create new mod co-ords\n        vec2 c = uv - mod(uv, vec2(0.3));\n        vec2 uvm = mod(uv, vec2(0.3));\n        \n        \/\/ Create some noise\n        float nv = noise(c * 1.5);\n        \n        \/\/ Create the plate effect\n        col = mix(col, col * 1.2, nv);\n        reflective = pow(nv, 2.0) + 0.2;\n        \n        \/\/ Rotate UV\n        uv = uv.yx;\n        uv.x = 8.0 - uv.x * 0.25;\n\n        \/\/ Draw the registry number on the nacelles\n        float d = textMap(vec2(uv.x * -10.0, 8.0 - uv.y * 2.0));\n\n        \/\/ Text width\n        float tw = 0.25;\n\n        \/\/ Check if we hit something\n        if (d < tw \/ 2.0 && d > -tw \/ 2.0)\n            col = vec3(0.0);\n        \n        \/\/ Return the colour\n        return diffuse(col, n);\n    }\n    else if (id == 6.0)\n    {\n        \/\/ The glowy spheres on the warp nacelles (active when\n        \/\/ warping and stuff)\n        vec3 lightCol = vec3(0.3, 0.8, 1.0);\n        vec3 normCol = vec3(0.0, 0.0, 0.1);\n        \n        \/\/ Put some checks on...\n        bool glowing = iTime < 6.0;\n        \n        \/\/ Return colour\n        if (glowing)\n        {\n        \tlight = true;\n        \treturn lightCol;\n        }\n        else\n        {\n            reflective = 1.0;\n            return diffuse(normCol, n);\n        }\n    }\n    else if (id == 7.0)\n    {\n        \/\/ This is the shader for the engine pylons\n        vec3 col = vec3(0.6);\n        \n        \/\/ Not really going to bother with the plates here,\n        \/\/ just going to make that grey line near the front\n        if (p.z > 9.2 && p.z < 9.5 && p.y < -0.2 && p.y > -1.5)\n            col = vec3(0.3);\n        \n        \/\/ Set reflective to 1.0\n        reflective = 1.0;\n        \n        \/\/ Return the colour\n        return diffuse(col, n);\n    }\n    else if (id == 8.0)\n    {\n        \/\/ This is the gas cloud\n        vec3 col = gasColour;\n        light = true;\n        \n        \/\/ Return diffuse colour (close approximation)\n        return diffuse(col, n);\n    }\n    else if (id == 9.0)\n    {\n        \/\/ Saturn\n        vec3 col = vec3(1.0, 0.75, 0.5);\n        \n        \/\/ Return colour\n        light = true;\n        return diffuse(col, n);\n    }\n    else if (id == 10.0)\n    {\n        \/\/ Saturn's rings\n        vec3 col = vec3(0.6, 0.5, 0.4);\n        \n        \/\/ Calculate length from saturn\n        float len = length(p - SATURN_POS);\n        \n        \/\/ Create some noise based on the length\n        float nv = fbm(vec2(len * 0.2, 0.0));\n        \n        \/\/ Blend the colour\n        col = mix(vec3(0.0), col, nv);\n        \n        \/\/ Return colour\n        return diffuse(col, n);\n    }\n    else\n        \/\/ Default\n        return diffuse(vec3(1.0), n);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/                                             \/\/\n\/\/              IMAGE PROCESSING               \/\/\n\/\/                                             \/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ Raymarch function\nvec4 raymarch(vec2 uv)\n{\n    \/\/ Correct the UV co-ordinates\n    uv = (uv * 2.0 - 1.0) * vec2(iResolution.x \/ iResolution.y, 1.0);\n    \n    \/\/ Mouse co-ordinates\n    vec2 mp = (iMouse.xy \/ iResolution.xy * 2.0 - 1.0) * iResolution.x \/ iResolution.y;\n    \n    \/\/ Setup ray direction\n    vec3 r = normalize(vec3(uv, 0.5 * PI));\n    \n    \n    \/\/ Key times:\n    \/\/ 0:00 - 0:06; warping\n    \/\/ 0:06 - 0:30; rising, camera inside clouds\n    \/\/ 0:31 - end ; camera out of clouds\n    \n    \n    \/\/ Y rotation (yaw)\n    \/\/float yrot = -mp.x;\n    \/\/float yrot = 0.5 * PI;\n    \/\/r.xz *= mat2(cos(yrot), -sin(yrot), sin(yrot), cos(yrot));\n    \n    \/\/ Set origin - this is the camera position\n    vec3 o;\n    \n    \/\/ Noise for camera shake\n    vec3 noiseOff = vec3(fbm(vec2(iTime * 20.0)) * 0.1);\n    \n    \/\/ Warp camera movement\n    if (iTime < 6.0)\n    {\n        o = vec3(-10.0, -2.0, iTime * iTime * 10.0 - 150.0);\n    }\n    else if (iTime < 12.0)\n    {\n        o = vec3(-10.0, -2.0, 0.0 - 2.0 * pow(2.0, 1.0 \/ (iTime - 6.0)));\n    }\n    else if (iTime < 20.0)\n    {\n        o = vec3(-10.0, -2.0 - iTime + 12.0, -2.25);\n        o += noiseOff;\n    }\n    else\n    {\n        \/\/ Put the sun in the right place\n        lightDir = normalize(vec3(0.5, -0.4, 0.1));\n        \n        \/\/ Put the origin in the right place\n        o = vec3(-6.0, max(35.0 - iTime, -8.0), -15.0);\n    }\n    \n    \/\/ Allow the user to move the camera around a bit,\n    \/\/ but reset position if they aren't clicking\n    if (iMouse.z > 0.0)\n    {\n        float yrot = (mp.x + 1.0) * PI * 0.1;\n        o *= vec3(cos(yrot), 1.0, sin(yrot));\n        o.y += mp.y * 6.0;\n    }\n    \n    \/\/ Rotates the camera to face the Enterprise\n    \/\/ Thanks to iq for this (https:\/\/www.youtube.com\/watch?v=CHmneY8ry84)\n    vec3 ww = normalize(vec3(0.0) - o);\n    vec3 uu = normalize(cross(vec3(0.0, 1.0, 0.0), ww));\n    vec3 vv = normalize(cross(ww, uu));\n    r = normalize(uv.x * uu + uv.y * vv + 0.5 * PI * ww);\n    \n    \/\/ Setup colour\n    vec3 col = vec3(0.0);\n    \n    \/\/ Ray properties\n    float maxt = 125.0; \/\/ maximum raymarch dist\n    int rayCount = 3; \/\/ maximum ray bounces\n    bool rayCanTerminate = false;\n    float prevReflective = 1.0;\n    \n    \/\/ Whether the point is lit\n    float pointLitUp = 0.0;\n    \n    \/\/ First distance travelled\n    float t1 = 0.0;\n    \n    \/\/ Iterate through each ray\n    for (int rn = 0; rn < rayCount; rn++)\n    {\n        \/\/ Terminate if appropriate\n        if (rayCanTerminate)\n            break;\n        \n        \/\/ Ray distance travelled\n        float t = 0.0;\n        float gt = 0.0; \/\/ gas map function\n        \n        \/\/ 'Falloff multiplier'; a multiplier used to make\n        \/\/ various things weaker the more times the ray has\n        \/\/ bounced (e.g reflections, shadows)\n        float falloff = 1.0 \/ float(rn + 1);\n        \n        \/\/ Raymarch\n        \/\/ I guess 2048 max samples is a bit silly, but\n        \/\/ at least it gets rid of the artifacts :P\n        for (int i = 0; i < 2048; i++)\n        {\n            \/\/ Setup point to test. Margin added is the\n            \/\/ camera minimum clip distance\n            vec3 p = o + r * (t + 0.01);\n            \n            \/\/ Check if t is beyond the limit\n            if (t > maxt)\n            {\n                \/\/ Background code for the warping part\n                if (iTime < 6.0)\n                {\n                    \/\/ Create new co-ordinates based on maxt\n                    p = o + r * maxt;\n                    \n                    \/\/ Calculate cylinder UV\n                    vec2 uv = vec2(atan(p.x, p.y) * 2.0, p.z * 0.01 - iTime * 4.0);\n                    \n                    \/\/ Calculat enoise\n                    float nv = fbm(uv);\n                    \n                    \/\/ Warp background colour\n                    vec3 bcol = mix(vec3(0.0), vec3(0.3, 0.8, 1.0), nv);\n                    pointLitUp = nv;\n                    \n                    \/\/ Create a colour from it\n                    col += bcol * falloff;\n                }\n                \n                \/\/ Background code for titan's gas part\n                else if (iTime > 6.0 && iTime < 20.0)\n                    col += gasColour * falloff;\n                    \n                \/\/ Background code for saturn and its rings\n\t\t\t\telse if (iTime > 20.0)\n                {\n                    \/\/ Background colour\n                    vec3 bcol = vec3(0.0);\n                    \n                    \/\/ Calculate angle between viewing vector and sun\n                    float angle = max(dot(r, -lightDir), 0.0);\n                    \n    \t\t\t\t\/\/ Create a specular highlight\n    \t\t\t\tangle = pow(angle, SUN_STRENGTH);\n                    \n                    \/\/ Add the sun in\n                    bcol = mix(bcol, vec3(1.0, 1.0, 0.8), angle);\n                    \n\t\t\t\t\t\/\/ Intersect saturn\n                    vec4 saturnpos = vec4(SATURN_POS, 50.0);\n                    float saturn = iSphere(saturnpos, o, r);\n                   \t\n                    \/\/ Direction to plane\n                    vec3 pdir = normalize(vec3(0.0, 1.0, 0.1));\n                    vec3 pp = SATURN_POS;\n                    \n                    \/\/ Calculate plane intersection\n                    float tplane = iPlane(pdir, pp, o, r);\n                    \n                    \/\/ If we hit saturn, colour it in\n                    if (saturn > 0.0)\n                    {\n                        \/\/ Raytracing position\n                    \tvec3 sp = o + r * saturn;\n                        \n                        \/\/ Data about the material\n                        float sref = 0.0;\n                        bool slight = false;\n                        pointLitUp = 1.0;\n                        \n                        \/\/ Calculate normal\n                        vec3 n = nSphere(sp, saturnpos);\n                        bcol = material(9.0, sp, n, r, sref, slight);\n                    }\n                    if (tplane > 0.0 && saturn < 0.0)\n                    {\n                        \/\/ Raytracing position\n                    \tvec3 sp = o + r * tplane;\n                        \n                        \/\/ Length from planet\n                        float len = length(sp - pp);\n                        \n                        \/\/ Restrict the rings to a radius\n                        if (len > 65.0 && len < 95.0)\n                        {\n                            \/\/ Material data\n                            float rref = 0.0;\n                            bool rlight = false;\n                            pdir = normalize(pdir);\n\n                            \/\/ Add the material on\n                            bcol = material(10.0, sp, pdir, r, rref, rlight);\n                        }\n                    }\n                    \n                    \/\/ Add the colour on\n                    col += bcol * falloff;\n                }\n                \n                \/\/ Terminate ray\n                rayCanTerminate = true;\n                break;\n            }\n            \n            \/\/ Evaluate map function\n            vec2 m = map(p);\n            \n            \/\/ Fog values\n            float fog1 = 1.0 \/ (1.0 + t * t * 0.2);\n            float fog2 = 1.0 \/ (0.3 + t * t * 0.02);\n            \n            if (rn < 1)\n                t1 = t;\n            \n            \/\/ Check if we hit an object\n            if (m.x < 0.0001)\n            {\n                \/\/ Calculate normal\n                vec3 n = calcNormal(p);\n                \n                \/\/ Calculate colour\n                bool isLight = false;\n                float reflective = 0.0;\n                vec3 ncol = material(m.y, p, n, r, reflective, isLight);\n                \n                \/\/ If we hit something with reflectiveness 0, stop\n                if (reflective == 0.0)\n                    rayCanTerminate = true;\n                \n                \/\/ If we hit a light, set the status and break\n                if (isLight)\n                {\n                    rayCanTerminate = true;\n                    col += ncol * falloff * prevReflective;\n                    pointLitUp = 1.0;\n                    break;\n                }\n                \n                \/\/ Calculate shadows. Only calculate shadows if the\n                \/\/ ray y direction is negative, the colour is not\n                \/\/ the glowing dissolve colour and we haven't hit a transparent\n                \/\/ object yet\n                if (m.y != 8.0)\n                \tncol *= max(sshadow(p, -lightDir, 0.1, 10.0, 24.0), 0.0);\n                \n                \/\/ Add the colour on\n                vec3 fcol = falloff * ncol;\n\n                \/\/ Blend with the gas colour\n                if (iTime > 6.0 && iTime < 20.0)\n                {\n                    fcol = mix(fcol, gasColour, t1 \/ maxt * 5.0);\n                }\n                \n                \/\/ Mix the colour with the reflectivity\n                col += fcol * prevReflective;\n                prevReflective = reflective;\n                \n                \/\/ Move the origin to the current point\n                o = p;\n\n                \/\/ Reflect the ray\n                r = reflect(r, n);\n\n                \/\/ Break out of the loop\n                break;\n            }\n            \n            \/\/ Increment t\n            t += m.x * 0.4;\n        }\n    }\n    \n    \/\/ Darken around 0:05\n    if (iTime > 5.0 && iTime < 6.5)\n        col *= cos(iTime * 4.0 - 20.0);\n    \n    \/\/ And around 0:20\n    if (iTime > 19.0 && iTime < 20.0)\n        col *= cos(iTime * 4.0 - 76.0);\n    \n    \/\/if (iTime > 20.0)\n    \/\/    col = mix(col, gasColour, min(density, 1.0));\n    \n    \/\/ Return colour\n    return vec4(col, pointLitUp);\n}\n\n\/\/ Main image processing\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord\/iResolution.xy;\n    \n    \/\/ Raymarch the scene\n    vec4 col = raymarch(uv);\n\t\n    \/\/ Output to screen\n    fragColor = col;\n}",
            "name": "Buf A",
            "description": "",
            "type": "buffer"
        },
        {
            "inputs": [],
            "outputs": [],
            "code": "\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/                                              \/\/\n\/\/  Attempting to raymarch the USS Enterprise   \/\/\n\/\/  (the Constitution-class variant as seen in  \/\/\n\/\/  the recent Star Trek movies)                \/\/\n\/\/                                   - Noxbuds  \/\/\n\/\/                                              \/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/                                             \/\/\n\/\/             DISTANCE FUNCTIONS              \/\/\n\/\/                                             \/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ 2D functions for drawing text\n\n\/\/ 'C' distance\nfloat sdC(vec2 p, vec2 s)\n{\n    \/\/ This is a rounded square, cutoff on the right\n    \n    \/\/ Round-ness\n    float roundness = 0.5;\n    \n    \/\/ Calculate the distance from the square\n    float d = length(max(abs(p) - s * roundness, 0.0));\n    \n    \/\/ Subtract the roundness\n    d -= roundness;\n    \n    \/\/ Now cut out a box on the right\n    if (p.x > s.x * roundness && p.y > -s.y * roundness && p.y < s.y * roundness)\n        d = 1.0;\n    \n    \/\/ Return distance\n    return d;\n}\n\n\/\/ 'N' distance\nfloat sdN(vec2 p, vec2 s)\n{\n    \/\/ Two rectangles on either side, with a rotated\n    \/\/ rectangle in the middle\n    \n    \/\/ Size for left and right rectangles\n    vec2 s2 = vec2(s.x * 0.1, s.y);\n    \n    \/\/ Draw a main rectangle\n    float d = length(max(abs(p) - s, 0.0));\n    \n    \/\/ Cutout the middle\n    if (p.x > -s.x * 0.9 && p.x < s.x * 0.9)\n        d = 1.0;\n    \n    \/\/ Warp p to create a diagonal line\n    p.x += p.y * 0.93;\n    \n    \/\/ Create another rectangle\n    float d2 = length(max(abs(p) - vec2(s.x * 0.05, s.y), 0.0));\n    \n    d = min(d, d2);\n    \n    \/\/ Return distance\n    return d * 2.0;\n}\n\n\/\/ Hyphen distance\nfloat sdHyphen(vec2 p, vec2 s)\n{\n    \/\/ A small rectangle\n    float d = length(max(abs(p) - s, 0.0));\n    \n    \/\/ Cut out parts\n    if (p.x < -s.x * 0.3 || p.x > s.x * 0.3 ||\n       p.y > s.x * 0.075 || p.y < -s.x * 0.075)\n        d = 1.0;\n    \n    \/\/ Return the distance\n    return d;\n}\n\n\/\/ '1' distance\nfloat sdOne(vec2 p, vec2 s)\n{\n    \/\/ A small rectangle\n    float d = length(max(abs(p) - s, 0.0));\n    \n    \/\/ Cut out parts\n    if (p.x < -s.x * 0.075 || p.x > s.x * 0.075)\n        d = 1.0;\n    \n    \/\/ Return the distance\n    return d;\n}\n\n\/\/ '7' distance\nfloat sdSeven(vec2 p, vec2 s)\n{\n    \/\/ Rectangle on top, with a diagonal rectangle below\n    float d = length(max(abs(p) - s, 0.0));\n    if (p.y < s.y * 0.91)\n        d = 1.0;\n    \n    \/\/ Warp p\n    p.x -= p.y;\n    \n    \/\/ Create another rectangle\n    float d2 = length(max(abs(p) - vec2(s.x * 0.04, s.y), 0.0));\n    \n    d = min(d, d2);\n    \n    \/\/ Return distance\n    return d * 2.0;\n}\n\n\/\/ '0' distance\nfloat sdZero(vec2 p, vec2 s)\n{\n    \/\/ Just a cut-out rounded rectangle\n    \n    \/\/ Round-ness\n    float roundness = 0.5;\n    \n    \/\/ Calculate the distance from the square\n    float d = length(max(abs(p) - s * roundness, 0.0));\n    \n    \/\/ Subtract the roundness\n    d -= roundness;\n    \n    \/\/ Return distance\n    return d;\n}\n\n\/\/ Map function\nfloat textMap(vec2 p)\n{\n    float v = 10.0;\n    \n    \/\/ Shift everything left\n    p.x += 6.0;\n    \n    \/\/ 'N'\n    v = sdN(p, vec2(1.0));\n    \n    \/\/ 'CC'\n    v = min(v, sdC(p + vec2(-2.3, 0.0), vec2(1.0)));\n    v = min(v, sdC(p + vec2(-4.6, 0.0), vec2(1.0)));\n    \n    \/\/ '-'\n    v = min(v, sdHyphen(p + vec2(-6.3, 0.0), vec2(1.0)));\n    \n    \/\/ '1701'\n    v = min(v, sdOne(p + vec2(-6.9, 0.0), vec2(1.0)));\n    v = min(v, sdSeven(p + vec2(-8.3, 0.0), vec2(1.0)));\n    v = min(v, sdZero(p + vec2(-10.6, 0.0), vec2(1.0)));\n    v = min(v, sdOne(p + vec2(-12.0, 0.0), vec2(1.0)));\n    \n    \/\/ Return the distance\n    return v;\n}",
            "name": "Common",
            "description": "",
            "type": "common"
        }
    ]
}