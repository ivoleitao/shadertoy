{
    "ver": "0.1",
    "info": {
        "id": "ldSyRd",
        "date": "1493419573",
        "viewed": 1569,
        "name": "Kleinian variations",
        "username": "iapafoto",
        "description": "paying with kleinian fractal\nand try to create a geometric dof post process for dof",
        "likes": 70,
        "published": 3,
        "flags": 96,
        "tags": [
            "fractal",
            "dof",
            "bokeh",
            "kleinian"
        ],
        "hasliked": 0
    },
    "renderpass": [
        {
            "inputs": [
                {
                    "id": "XsXGR8",
                    "filepath": "\/media\/previz\/buffer01.png",
                    "previewfilepath": "\/media\/previz\/buffer01.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dfGRr",
                    "channel": 0
                }
            ],
            "code": "\n\/\/ Created by sebastien durand - 2017\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/-----------------------------------------------------\n\/\/ Java\/OpenCL fractal playground: https:\/\/github.com\/iapafoto\/FractalOpenCL\n\/\/ 4K Intro version: https:\/\/github.com\/iapafoto\/Intro-4Kbyte-Kelenian\n\/\/-----------------------------------------------------\n\/\/ Text - Thanks to Andre [Shadertext]\n\/\/ Andre - https:\/\/www.shadertoy.com\/view\/lddXzM \n\/\/-----------------------------------------------------\n\/\/ Music - Yann Tiersen - Summer 78 (10dens remix) (2010)\n\/\/-----------------------------------------------------\n\n\n\/\/---------------------------------------------------\n\/\/ The DOF process :\n\/\/ For each neigbourg pixels, the algo calculate if the 3D reconstruct pixelPoint is effectively in \n\/\/ the 3D cone (circle) of confusion of the pixel. Otherwise it is ignored.\n\/\/ => Avoid artfacts on the edges\n\/\/ Inspired by Dave Hoskins bokeh disc [https:\/\/www.shadertoy.com\/view\/4d2Xzw]\n\/\/ => 3D adaptation\n\/\/---------------------------------------------------\n\n\n\n\/\/#define WITH_DOF\n\n#ifdef WITH_DOF\n\nconst float fov = 3.;\nconst float aperture = 1.;\n\nconst float cosAngle = cos(radians(aperture\/2.));\nconst float GA =2.399;  \/\/ golden angle = 2pi\/(1+phi)\nconst mat2 rot = mat2(cos(GA),sin(GA),-sin(GA),cos(GA));\n\nvec2 res;\n    \n\nbool inCone(vec3 p, vec3 o, vec3 n, float side) {\n\treturn step(cosAngle,side*dot(normalize(o-p), n)) > 0.5;\n}\n\nvec3 RD(const vec2 q) {\n    return normalize(vec3((2.* q.x - 1.) * res.x\/res.y,  (2.* q.y - 1.), fov));\n}\n\n\/\/--------------------------------------------------------------------------\n\/\/ eiffie's code for calculating the aperture size for a given distance...\nfloat coc(float t) {\n\treturn max(t*.04, (2.\/iResolution.y) * (1.+t));\n}\n\nvec3 dof(sampler2D tex, vec2 uv, float fdist) {\n    \n\tvec4 colMain = texture(tex, uv);\n    \n    const float amount = 1.;\n    \n    float rad = min(.5, 10.*coc(abs(colMain.w-fdist)));\/\/.3; \/\/ TODO calculate this for Max distance on picture\n    \n    float r=1.;\n    \n    vec3 cn = RD(uv),    \/\/ Cone axis    \n         co = cn*fdist,  \/\/ Cone origin\n         sum = vec3(0.),  \n     \t bokeh = vec3(1),\n         acc = vec3(0),\n         pixPos;\n    \n\n    vec2 pixScreen,\n         pixel = 1.\/iResolution.xy,        \n         angle = vec2(0, rad);\n    \n    vec4 pixCol;\n    \n    \n\tfor (int j=0;j<80;j++) {  \n        r += 1.\/r;\n\t    angle *= rot;\n        \n        pixScreen = uv + pixel*(r-1.)*angle; \/\/ Neighbourg Pixel\n        pixCol = texture(tex, pixScreen);    \/\/ Color of pixel (w is depth)      \n        pixPos = pixCol.w * RD(pixScreen);   \/\/ Position of 3D point in camera base\n\n        if (inCone(pixPos, co, cn, sign(fdist - pixCol.w))) {        \/\/ true if the point is effectivelly in the cone\n            bokeh = pow(pixCol.xyz, vec3(9.)) * amount +.4;\n            acc += pixCol.xyz * bokeh;\t\t\t\n            sum += bokeh;\n        }\n\t}\n    \n    return (length(sum) <= 0.) ? \/\/ Enable to deal with problem of precision when at thin begining of the cone\n\t\tcolMain.xyz : acc.xyz\/sum;\n}\n\n\n#define NB 16\n\n\/\/ Deph of field animation\nfloat[] deph = float[] ( 1.,.65,.6,.4,.2,.4,\/*.055,.055,*\/.65,.11,.13,1.3,.49,1.2,1.2,.5,.65,.45,1.,1.);\n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord) {\n    \n    res = iResolution.xy;\n    \n    float t = .1*iTime,\n\tkt = smoothstep(0.,1.,fract(t));\n\n    \/\/ - Interpolate Deph of field ---------------------\n    int  i0 = int(t)%NB, i1 = i0+1;    \n    float fdist = mix(deph[i0], deph[i1], kt);\n    \n\tvec2 uv = gl_FragCoord.xy \/ iResolution.xy;\n\tfragColor=vec4(dof(iChannel0,uv,fdist),2.);\n}\n\n#else \n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n\tvec2 uv = gl_FragCoord.xy \/ iResolution.xy;\n\tfragColor= texture(iChannel0,uv);\n}\n\n\n#endif",
            "name": "Image",
            "description": "",
            "type": "image"
        },
        {
            "inputs": [
                {
                    "id": "MdsXRn",
                    "filepath": "https:\/\/soundcloud.com\/10densmusic\/10dens-yann-tiersen-summer-78",
                    "previewfilepath": "https:\/\/soundcloud.com\/10densmusic\/10dens-yann-tiersen-summer-78",
                    "type": "musicstream",
                    "channel": 1,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 0
                }
            ],
            "outputs": [
                {
                    "id": "XsXGR8",
                    "channel": 0
                }
            ],
            "code": "\n\/\/ Created by sebastien durand - 2017\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/-----------------------------------------------------\n\/\/ Text - Thanks to Andre [Shadertext]\n\/\/ Andre - https:\/\/www.shadertoy.com\/view\/lddXzM \n\/\/-----------------------------------------------------\n\/\/ Music - Yann Tiersen - Summer 78 (10dens remix) (2010)\n\/\/-----------------------------------------------------\n\n#define WITH_SHADOWS\n#define WITH_AO\n#define WITH_VIGNETING\n\n#define BACK_COLOR vec3(.08, .16, .34) \n\n#define PRECISION_FACTOR 5e-4\n#define MIN_DIST_RAYMARCHING .01\n#define MAX_DIST_RAYMARCHING 4.\n#define MAX_RAYMACING_ITERATION 132 \n\n#define MIN_DIST_SHADOW 10.*PRECISION_FACTOR\n#define MAX_DIST_SHADOW .25\n#define PRECISION_FACTOR_SHADOW 3.*PRECISION_FACTOR\n\n#define MIN_DIST_AO .5*PRECISION_FACTOR\n#define MAX_DIST_AO .02\n#define PRECISION_FACTOR_AO PRECISION_FACTOR\n\n#define LIGHT_VEC normalize(vec3(.2,.7, 1.6) )\n\n#define NB_ITERATION 7\n\n\/\/#define WITH_AA\n\n\/\/-----------------------------------------------\n\/\/                 TEXT by Andre\n\/\/-----------------------------------------------\n\/\/ Andre - https:\/\/www.shadertoy.com\/view\/lddXzM \n\/\/-----------------------------------------------\n\nfloat line(vec2 p, vec2 a, vec2 b) {\n\tvec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba)\/dot(ba,ba), 0., 1.));\n}\nfloat _u(vec2 uv,float w,float v) {\n    return length(vec2(abs(length(vec2(uv.x,max(0.,-(.4-v)-uv.y) ))-w),max(0.,uv.y-.4)));\n}\nfloat _i(vec2 uv) {\n    return length(vec2(uv.x,max(0.,abs(uv.y)-.4)));\n}\nfloat _l(vec2 uv) {\n    uv.y -= .2;\n    return length(vec2(uv.x,max(0.,abs(uv.y)-.6)));\n}\nfloat _o(vec2 uv) {\n    return abs(length(vec2(uv.x,max(0.,abs(uv.y)-.15)))-.25);\n}\nfloat aa(vec2 uv) {\n    uv = -uv;\n    float x = abs(length(vec2(max(0.,abs(uv.x)-.05),uv.y-.2))-.2);\n    x = min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.2)-.2))));\n    return min(x,(uv.x<0.?uv.y<0.:atan(uv.x,uv.y+0.15)>2.)?_o(uv):length(vec2(uv.x-.22734,uv.y+.254)));\n}\nfloat ee(vec2 uv) {\n    float x = _o(uv);\n    return min(uv.x<0.||uv.y>.05||atan(uv.x,uv.y+0.15)>2.?x:length(vec2(uv.x-.22734,uv.y+.254)),\n               length(vec2(max(0.,abs(uv.x)-.25),uv.y-.05)));\n}\nfloat ii(vec2 uv) {\n    return min(_i(uv),length(vec2(uv.x,uv.y-.7)));\n}\nfloat kk(vec2 uv) {\n    float x = line(uv,vec2(-.25,-.1), vec2(0.25,0.4));\n    x = min(x,line(uv,vec2(-.15,.0), vec2(0.25,-0.4)));\n    uv.x+=.25;\n    return min(x,_l(uv));\n}\nfloat nn(vec2 uv) {\n    uv.y *= -1.;\n    float x = _u(uv,.25,.25);\n    uv.x+=.25;\n    return min(x,_i(uv));\n}\n\n#define ch(l) if (nr++==ofs) x=min(x,l(uv));\n\nvoid drawText(float time, vec2  uv, inout vec4 color) {\n    if (time>12.6 && time <14.1) {\n        float anim = smoothstep(0.,1.,smoothstep(13.6, 14.1, time));\n\n        uv -= .5*iResolution.xy;\n        uv += (.5 + mix(vec2(-.1,.4), vec2(.2,.3), anim)) * iResolution.xy;\n        uv = (uv-.5*iResolution.xy) \/ iResolution.x * 22.0 * mix(1.,.5,anim);\n        \n        float ofs = floor(uv.x), x = 1., nr = 0.;\n        uv.x = mod(uv.x,1.)-.5;\n        \n\t\tch(kk);ch(_l);ch(ee);ch(ii);ch(nn);ch(ii);ch(aa);ch(nn); \n        \n        float px = 17.\/iResolution.x, clr = smoothstep(.06-px,.06+px, x);\n        color = mix(color, mix(vec4(0,0,0,.5), color, clr), smoothstep(12.6, 13., time)*(1.-anim));\n    }\n}\n\n\n\/\/-----------------------------------------------\n\n\nvec2 kColor;\nvec4 mins;\nvec4 maxs;\n\n\/\/knighty's pseudo kleinian\nfloat de(vec3 p) {\n    float k, scale=1.;\n    for(int i=0;i<NB_ITERATION;i++) {\n        p = 2.*clamp(p, mins.xyz,maxs.xyz)-p;\n        k = max(mins.w\/dot(p,p), 1.);\n        p *= k;\n        scale *= k;\n    }\n    float rxy = length(p.xy);\n    return .7*max(rxy-maxs.w, \/*abs*\/(rxy*p.z) \/ length(p))\/scale;\n}\n\nfloat ce(vec3 p) {\n    float k,r2, orb = 1.;\n    for(int i=0;i<NB_ITERATION;i++) {\n        p = 2.*clamp(p, mins.xyz, maxs.xyz)-p;\n        r2 = dot(p,p);\n        orb = min(orb, r2);\n        k = max(mins.w\/r2,1.);\n        p *= k;\n    }\n    return kColor.x + kColor.y*sqrt(orb);\n}\n\nfloat rayIntersect(const vec3 ro, const vec3 rd, const float prec, const float mind, const float maxd) {\n    float h, t = mind;\n    for(int i=0; i<MAX_RAYMACING_ITERATION; i++ ) {\n        h = de(ro+rd*t);\n        if (h<prec*t||t>maxd)break;\n        t += h;\n    }\n    return t;\n}\n\nvec2 trace(const vec3 ro, const vec3 rd ) {\n    float d = rayIntersect(ro, rd, PRECISION_FACTOR, MIN_DIST_RAYMARCHING, MAX_DIST_RAYMARCHING);\n    return (d>0.) ? vec2(d, ce(ro+rd*d)) : vec2(-1., 1.);\n}\n\n\n#ifdef WITH_SHADOWS\n\nfloat shadow(vec3 ro, vec3 rd) {\n    float d = rayIntersect(ro, rd, PRECISION_FACTOR_SHADOW, MIN_DIST_SHADOW, MAX_DIST_SHADOW);\n    return (d>0.) ? smoothstep(0., MAX_DIST_SHADOW, d) : 1.;\n}\n\n#endif\n\n\n#ifdef WITH_AO\n\nfloat calcAO4(const vec3 pos, const vec3 nor ) {\n    float hr, occ = 0., sca = 1.;\n    for(int i=0; i<5; i++ ) {\n        hr = MIN_DIST_AO + MAX_DIST_AO*float(i)\/4.;\n        occ += -(de( nor * hr + pos)-hr)*sca;\n        sca *= .95;\n    }\n    return clamp(1. - 10.*occ, 0., 1.);    \n}\n\n#endif\n\n\nvec3 calcNormal(const vec3 pos, const float t ){\n    vec3 e = (PRECISION_FACTOR * t * .57) * vec3(1, -1, 0);\n    return normalize(e.xyy*de(pos + e.xyy) + \n\t\t     e.yyx*de(pos + e.yyx) + \n\t\t     e.yxy*de(pos + e.yxy) + \n             e.xxx*de(pos + e.xxx) );\n}\n\nvec3 RD(const vec3 ro, const vec3 ww, const vec3 vv, const vec3 uu, const vec2 xy, const vec2 r, const float fov) { \n    vec3 er = normalize(vec3((2. * (xy.x\/r.x) - 1.)* r.x\/r.y,  (2. * (xy.y\/r.y) - 1.), fov));\n    return normalize( er.x*uu + er.y*vv + er.z*ww );\n}\n\nvec4 renderScene(const vec3 ro, const vec3 rd) {\n    \n    vec3 col = BACK_COLOR;\n    vec2 res = trace(ro, rd);\n    float t = res.x;\n\n\n    vec3 pos = ro + t*rd,\n        nor = calcNormal( pos, t),\n        ref = reflect( rd, nor),\n        lig = LIGHT_VEC;\n    \/\/ Color\n    col = .5 + .5*cos( 6.2831*res.y + vec3(0,1,2) ); \n\n    \/\/ lighting        \n    #ifdef WITH_AO\n    float occ = calcAO4(pos, nor);\n    #else\n    float occ = 1.;\n    #endif\n\n    #ifdef WITH_SHADOWS\n    float sh = .2+.8*shadow( pos, lig); \/\/, 0.1, t );\n    #else\n    float sh = 1.;\n    #endif\n\n    #ifdef ONLY_AO\n    col = (vec3)occ*(.5+.5*sh);\n    #else\n\n    float amb = .3;\n    float dif = clamp( dot( nor, lig ), 0., 1.);\n    float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.,-lig.z))), 0., 1. )*clamp( 1.-pos.y,0.,1.);\n    float dom = smoothstep( -.1, .1, ref.y );\n    float fre = clamp(1.+dot(nor,rd),0.,1.);\n    fre *= fre;\n    float spe = pow(clamp( dot( ref, lig ), 0., 1. ),99.);\n\n    vec3 lin = vec3(.3) + \n        + 1.3*sh*dif*vec3(1.,0.8,0.55)\n        + 2.*spe*vec3(1.,0.9,0.7)*dif\n        + .5*occ*( .4*amb*vec3(0.4,0.6,1.) +\n                  .5*sh*vec3(0.4,0.6,1.) +\n                  .25*fre*vec3(1.,1.,1.));\n\n    col *= lin;\n\n    #endif\n    \/\/ Shading.\n    float atten = 1.\/(1. + t*.2 + t*.1); \/\/ + distlpsp*distlpsp*0.02\n    col *= atten*col*occ;\n    col = mix(col, BACK_COLOR, smoothstep(0.2, 1., t\/MAX_DIST_RAYMARCHING));\n\n\n    return vec4(sqrt(col),t);\n}\n\n\n\/\/ - Interpolation ----------------------------------------------\n\n#define NB 16\n\nfloat[] \n    camx = float[] ( .2351, 1.2351, 1.2351, 1., .2, .41, \/*.545,.545,*\/ .5,.084,.145,  3.04,.12, .44,.44,.416, -1.404, .21,.2351, .2351),\n\tcamy = float[] (-.094,  .35,     .28,  .38,  .04, .11, \/*-.44,-.44,*\/.35,.0614,.418, 1.,-.96, .67,.8,.0, -1., -.06,-.094),\n\tcamz = float[] ( .608,  .608,    .35,   .3608, -.03, .48,\/*.032,.032,*\/ .47,0.201,.05,.28,.3, 1.445,1.,1.4, 2.019, .508,.608),\n\n \tlookx = float[] (-.73, -.627, -1., -.3, -1., -.72, \/*-.82,-.82,*\/-.67,-.5,-.07,-.67,-.27, -.35,-.35,-.775, .08, -.727),\n\tlooky = float[] (-.364, -.2,   -.2,  -.2,  0., -.39, \/*-.5, -.5,*\/-.56,-.37,-.96,-.74,-.94, -.35,-.35,-.1, .83,-.364),\n\tlookz = float[] (-.582, -.582, -.5, -.35, -.0, -.58, \/*-.2776,-.2776,*\/-.48,-.79,-.25,.06,-.18, -.87,-.87,.23, .55, -.582),\n\n\tminsx = float[] (-.3252,-.3252,-.3252,-.3252,-.3252,-.3252,\/*-.3252,-1.1,*\/ -1.05,-1.05,-1.21,-1.22,-1.04,-0.737,-.62,-10., -.653,  -.653, -.3252),\n\tminsy = float[] (-.7862,-.7862,-.7862,-.7862,-.7862,-.7862,\/*-.7862,-.787,*\/ -1.05,-1.05,-.954,-1.17,-.79,-0.73,-.71,-.75, -2.,   -2., -.7862),\n\tminsz = float[] (-.0948,-.0948,-.0948,-.0948,-.0948,-.0948,\/*-.0948,-.095,*\/-0.0001,-0.0001,-.0001,-.032,-.126,-1.23,-.85,-.787, -.822, -1.073, -.0948),\n    minsw = float[] ( .69, .69, .69, .69, .69, .678, \/*.678,  .678,*\/.7,.73,1.684,1.49,.833, .627,.77,.826,  1.8976, 1.8899, .69),\n\n\tmaxsx = float[] ( .35,.3457,.3457,.3457,.3457, .3457,\/*.3457,.3457,*\/ 1.05,1.05,.39,.85,.3457,.73,.72,5., .888,  .735, .35),\n\tmaxsy = float[] (1.,1.0218,1.0218,1.0218,1.0218,\/*1.0218,1.0218,*\/1.0218,1.05,1.05,.65,.65,1.0218,0.73,.74,1.67, .1665, 1.),\n\tmaxsz = float[] (1.22,1.2215,1.2215,1.2215,1.2215,1.2215,\/*1.2215,1.2215, *\/1.27,1.4,1.27,1.27,1.2215,.73,.74,.775, 1.2676, 1.22),\n    maxsw = float[] ( .84, .84, .84, .84, .84, .9834,\/*.9834,.9834,*\/.95,.93,2.74,1.23,.9834, .8335,.14,1.172, .7798, .84);\n\n\n#define BPM 127.\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n    float t = .1* iChannelTime[1] ,\n\t\t kt = smoothstep(0.,1.,fract(t));\n\n    \/\/ - Interpolate positions and fractal configuration ---------------------\n    int  i0 = int(t)%NB, i1 = i0+1;\n    vec4 c;\n    vec2 res = iResolution.xy,q;\n#ifdef WITH_AA\n    vec4 cSum = vec4(0);\n    for(int i=0;i<2;i++)\n        for(int j=0;j<2;j++) {\n    \t\tq = (fragCoord+.5*vec2(i,j))\/res;\n#else            \n    \t\tq = fragCoord\/res;\n#endif\n    \n    vec3 ro = mix(vec3(camx[i0],camy[i0],camz[i0]), vec3(camx[i1],camy[i1],camz[i1]), kt),\n         ww = mix(vec3(lookx[i0],looky[i0],lookz[i0]), vec3(lookx[i1],looky[i1],lookz[i1]), kt), \n         vv = -normalize(cross(ww, vec3(0,1,0))),\n         uu = -normalize(cross(vv,ww)),\n    \t er = vec3((2. * q.x - 1.) * res.x\/res.y,  (2. * q.y - 1.), 3.),\n         rd = normalize(er.x*uu + er.y*vv + er.z*ww );\n\n    mins = mix(vec4(minsx[i0],minsy[i0],minsz[i0],minsw[i0]), vec4(minsx[i1],minsy[i1],minsz[i1],minsw[i1]), kt),\n    maxs = mix(vec4(maxsx[i0],maxsy[i0],maxsz[i0],maxsw[i0]), vec4(maxsx[i1],maxsy[i1],maxsz[i1],maxsw[i1]), kt);\n\n    \/\/ - Music light (BPM by iq) ---------------------------------------------\n\tfloat h = fract( .25 + .5*iChannelTime[1]*BPM\/60. ),\n\t\t  f = (1.-smoothstep( 0., 1., h )) * smoothstep( 4.5, 4.51, iChannelTime[1]),\n\t\t  r =  exp(-4.*f);\n    \n    kColor = mix(vec2(.25,1.),vec2(.01325,1.23), r*r*(.13+smoothstep(10.,12.,t)));\n \n    \/\/ - Rendering -----------------------------------------------------------    \n    c = renderScene(ro, rd);\n\n#ifdef WITH_AA\n\tcSum += c;\n    }\n    c = cSum \/ 4.;\n#endif \n    \n#ifdef WITH_VIGNETING\n    c.rgb *= pow(16.*q.x*q.y*(1.-q.x)*(1.-q.y), .3); \n#endif\n    \n    \/\/ - Adding Text ---------------------------------------------------------\n\tdrawText(mod(t,float(NB)), fragCoord, c);\n\n    fragColor = c;\n}",
            "name": "Buffer B",
            "description": "",
            "type": "buffer"
        }
    ]
}