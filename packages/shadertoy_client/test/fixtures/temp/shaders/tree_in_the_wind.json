{
    "ver": "0.1",
    "info": {
        "id": "tdjyzz",
        "date": "1586448367",
        "viewed": 6368,
        "name": "Tree in the wind",
        "username": "Maurogik",
        "description": "Falling leaves and a full day\/night cycle.\nOnce again, it started as a simple tree experiment and got complicated really fast.",
        "likes": 217,
        "published": 3,
        "flags": 96,
        "usePreview": 1,
        "tags": [
            "landscape",
            "tree",
            "leaf"
        ],
        "hasliked": 0
    },
    "renderpass": [
        {
            "inputs": [
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 1,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "XsXGR8",
                    "filepath": "\/media\/previz\/buffer01.png",
                    "previewfilepath": "\/media\/previz\/buffer01.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "llB3Wh",
                    "filepath": "https:\/\/soundcloud.com\/musa-muh-nur\/nature-sounds-beautiful",
                    "previewfilepath": "https:\/\/soundcloud.com\/musa-muh-nur\/nature-sounds-beautiful",
                    "type": "musicstream",
                    "channel": 2,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 0
                }
            ],
            "outputs": [
                {
                    "id": "4dfGRr",
                    "channel": 0
                }
            ],
            "code": "\/\/   _____                 _         _   _                     _           _ \n\/\/  \/__   \\_ __ ___  ___  (_)_ __   | |_| |__   ___  __      _(_)_ __   __| |\n\/\/    \/ \/\\\/ '__\/ _ \\\/ _ \\ | | '_ \\  | __| '_ \\ \/ _ \\ \\ \\ \/\\ \/ \/ | '_ \\ \/ _` |\n\/\/   \/ \/  | | |  __\/  __\/ | | | | | | |_| | | |  __\/  \\ V  V \/| | | | | (_| |\n\/\/   \\\/   |_|  \\___|\\___| |_|_| |_|  \\__|_| |_|\\___|   \\_\/\\_\/ |_|_| |_|\\__,_|\n\/\/                                                                                                       \n\/\/\n\/\/----------------------------------------------------------------------------------------\n\/\/     ___                                                    _  _    \n\/\/    \/ __\\ _   _     \/\\\/\\    __ _  _   _  _ __  ___    __ _ (_)| | __\n\/\/   \/__\\\/\/| | | |   \/    \\  \/ _` || | | || '__|\/ _ \\  \/ _` || || |\/ \/\n\/\/  \/ \\\/  \\| |_| |  \/ \/\\\/\\ \\| (_| || |_| || |  | (_) || (_| || ||   < \n\/\/  \\_____\/ \\__, |  \\\/    \\\/ \\__,_| \\__,_||_|   \\___\/  \\__, ||_||_|\\_\\\n\/\/          |___\/                                      |___\/          \n\/\/\n\/\/----------------------------------------------------------------------------------------\n\n\/\/The day\/night cyle takes around 1 a minute, so sit back and relax.\n\n\/\/Text ascii art using : http:\/\/patorjk.com\/software\/taag\/\n\nfloat tonemapOp(float v)\n{\n    v = pow(v, 2.0);\n    v = v \/ (1.0 + v);\n    return pow(v, 1.0\/2.0) * 1.025;\n}\n\nvec3 tonemap(vec3 colour)\n{\n    float inputLuminance = max(0.0001, rbgToluminance(colour));\n    vec3 normalisedColour = colour \/ inputLuminance;\n    \n    vec3 tonemapColour;\n    tonemapColour.r = tonemapOp(colour.r);\n    tonemapColour.g = tonemapOp(colour.g);\n    tonemapColour.b = tonemapOp(colour.b);\n    float tonemappedLuminance = tonemapOp(inputLuminance);\n    \n    tonemapColour = (tonemapColour \/ max(0.0001, rbgToluminance(tonemapColour)));\n    \n    return tonemappedLuminance * mix(normalisedColour, tonemapColour, min(1.0, 0.35*inputLuminance));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n      \n\tvec4 colour = texture(iChannel0, uv);\n    \n    \/\/Vignette\n    colour.rgb *= smoothstep(1.15, 0.3, length(uv - 0.5*oz.xx));\n    \n\t\/\/Tonemap\n    float toeStrength = 1.25;\n    colour.rgb = tonemap(colour.rgb * toeStrength); colour.rgb = pow(colour.rgb, toeStrength*oz.xxx);\n    \n    \/\/Gamma\n    colour = pow(colour, vec4(1.0\/2.2));\n    fragColor = colour;\n    \n    \/\/Dithering\n    fragColor += ((hash12(fragCoord)) - 0.5)*4.0\/255.0;\n}",
            "name": "Image",
            "description": "",
            "type": "image"
        },
        {
            "inputs": [],
            "outputs": [],
            "code": "\/\/   __  _                            _                   _       \n\/\/  \/ _\\| |__    __ _  _ __  ___   __| |   ___  ___    __| |  ___ \n\/\/  \\ \\ | '_ \\  \/ _` || '__|\/ _ \\ \/ _` |  \/ __|\/ _ \\  \/ _` | \/ _ \\\n\/\/  _\\ \\| | | || (_| || |  |  __\/| (_| | | (__| (_) || (_| ||  __\/\n\/\/  \\__\/|_| |_| \\__,_||_|   \\___| \\__,_|  \\___|\\___\/  \\__,_| \\___|\n\/\/                                                                \n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ SDF functions from mercury : http:\/\/mercury.sexy\/hg_sdf\/ \/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define PI 3.14159265359\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\n\/\/             PRIMITIVE DISTANCE FUNCTIONS\n\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\n\/\/ Conventions:\n\/\/\n\/\/ Everything that is a distance function is called fSomething.\n\/\/ The first argument is always a point in 2 or 3-space called <p>.\n\/\/ Unless otherwise noted, (if the object has an intrinsic \"up\"\n\/\/ side or direction) the y axis is \"up\" and the object is\n\/\/ centered at the origin.\n\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nfloat fSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n\/\/ Capsule: A Cylinder with round caps on both sides\nfloat fCapsule(vec3 p, float r, float c)\n{\n    return mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\n\/\/ Distance to line segment between <a> and <b>, used for fCapsule() version 2below\nfloat fLineSegment(vec3 p, vec3 a, vec3 b)\n{\n    vec3  ab = b - a;\n    float t  = saturate(dot(p - a, ab) \/ dot(ab, ab));\n    return length((ab * t + a) - p);\n}\n\n\/\/ Capsule version 2: between two end points <a> and <b> with radius r\nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    return fLineSegment(p, a, b) - r;\n}\n\n\/\/ Cone with correct distances to tip and base circle. Y is up, 0 is in the middle of the base.\nfloat fCone(vec3 p, float radius, float height)\n{\n    vec2  q         = vec2(length(p.xz), p.y);\n    vec2  tip       = q - vec2(0.0, height);\n    vec2  mantleDir = normalize(vec2(height, radius));\n    float mantle    = dot(tip, mantleDir);\n    float d         = max(mantle, -q.y);\n    float projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\n    \/\/ distance to tip\n    if((q.y > height) && (projected < 0.0))\n    {\n        d = max(d, length(tip));\n    }\n\n    \/\/ distance to base ring\n    if((q.x > radius) && (projected > length(vec2(height, radius))))\n    {\n        d = max(d, length(q - vec2(radius, 0.0)));\n    }\n    return d;\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\n\/\/                DOMAIN MANIPULATION OPERATORS\n\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\n\/\/ Conventions:\n\/\/\n\/\/ Everything that modifies the domain is named pSomething.\n\/\/\n\/\/ Many operate only on a subset of the three dimensions. For those,\n\/\/ you must choose the dimensions that you want manipulated\n\/\/ by supplying e.g. <p.x> or <p.zx>\n\/\/\n\/\/ <inout p> is always the first argument and modified in place.\n\/\/\n\/\/ Many of the operators partition space into cells. An identifier\n\/\/ or cell index is returned, if possible. This return value is\n\/\/ intended to be optionally used e.g. as a random seed to change\n\/\/ parameters of the distance functions inside the cells.\n\/\/\n\/\/ Unless stated otherwise, for cell index 0, <p> is unchanged and cells\n\/\/ are centered on the origin so objects don't have to be moved to fit.\n\/\/\n\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\n\/\/ Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n\/\/ Read like this: R(p.xz, a) rotates \"x towards z\".\n\/\/ This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a)\n{\n    p = cos(a) * p + sin(a) * vec2(p.y, -p.x);\n}\n\n\/\/ Repeat around the origin by a fixed angle.\n\/\/ For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions)\n{\n    float angle = 2.0 * PI \/ repetitions;\n    float a     = atan(p.y, p.x) + angle \/ 2.;\n    float r     = length(p);\n    float c     = floor(a \/ angle);\n    a           = mod(a, angle) - angle \/ 2.;\n    p           = vec2(cos(a), sin(a)) * r;\n    \/\/ For an odd number of repetitions, fix cell index of the cell in -x direction\n    \/\/ (cell index would be e.g. -5 and 5 in the two halves of the cell):\n    if(abs(c) >= (repetitions \/ 2.0))\n        c = abs(c);\n    return c;\n}\n\n\/\/ Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size)\n{\n    vec2 c = floor((p + size * 0.5) \/ size);\n    p      = mod(p + size * 0.5, size) - size * 0.5;\n    return c;\n}\n\n\/\/ Repeat in three dimensions\nvec3 pMod3(inout vec3 p, vec3 size)\n{\n    vec3 c = floor((p + size * 0.5) \/ size);\n    p      = mod(p + size * 0.5, size) - size * 0.5;\n    return c;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Intersectors and other things from IQ\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ http:\/\/iquilezles.org\/www\/articles\/smin\/smin.htm\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25\/k;\n}\n\n\/\/ http:\/\/iquilezles.org\/www\/articles\/smin\/smin.htm\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25\/k;\n}\n\n\n\/\/ vertical\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdOctogon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.9238795325, 0.3826834323, 0.4142135623 );\n    p = abs(p);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\n\/\/ plane degined by p (p.xyz must be normalized)\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)+p.w)\/dot(rd,p.xyz);\n}\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)\/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x\/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat opExtrusion( in vec3 p, in float dist, in float h )\n{\n    vec2 w = vec2( dist, abs(p.z) - h );\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\n\/\/From https:\/\/www.iquilezles.org\/www\/articles\/sphereshadow\/sphereshadow.htm\nfloat sphSoftShadow( in vec3 ro, in vec3 rd, in vec3 sph, in float ra, in float k )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n\n    return (b>0.0) ? step(-0.0001,c) : smoothstep( -0.5, 0.5, h*k\/b );\n}\n\nvec3 opCheapBend( in vec3 p, float bend )\n{\n    float k = bend;\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return q;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Hashes from Dave Hopkins \n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ Hash without Sine\n\/\/ Creative Commons Attribution-ShareAlike 4.0 International Public License\n\/\/ Created by David Hoskins.\n\n\/\/----------------------------------------------------------------------------------------\n\/\/  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n\/\/----------------------------------------------------------------------------------------\n\/\/\/  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/\/  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Common Shader Code\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\n#define NON_CONST_ZERO (min(iFrame,0)) \n#define NON_CONST_ZERO_U uint(min(iFrame,0)) \n\nconst vec2 oz = vec2(1.0, 0.0);\n\nconst float kGoldenRatio = 1.618;\nconst float kGoldenRatioConjugate = 0.618;\n\nconst float kPI         = 3.14159265359;\nconst float kTwoPI      = 2.0 * kPI;\n\nconst float kMaxDist = 10000.;\nconst float kTimeScale = 1.0;\n\nfloat kIsotropicScatteringPhase = (1.0 \/ (4.0 * kPI));\n\nvec3 roughFresnel(vec3 f0, float cosA, float roughness)\n{\n    \/\/ Schlick approximation\n    return f0 + (oz.xxx - f0) * (pow(1.0 - cosA, 5.0)) * (1.0 - roughness);\n}\n\nfloat linearstep(float start, float end, float x)\n{\n    float range = end - start;\n    return saturate((x - start) \/ range);\n}\n\nfloat henyeyGreensteinPhase_schlick(float cosA, float g)\n{\n    float k = 1.55*g - 0.55*g*g*g;\n    float f = 1.0 - k * cosA;\n\treturn (1.0 - k * k) \/ (4.0 * kPI * f*f);\n}\n\nfloat henyeyGreensteinPhase(float cosA, float g)\n{\n    return henyeyGreensteinPhase_schlick(cosA, g);\n\t\/*float g2 = g*g;\n    return 1.0 \/ (4.0 * kPI) *\n        ((1.0 - g2)\/pow(1.0 + g2 - 2.0*g*cosA, 1.5));*\/\n}\n\nfloat rayleighPhase(float rayDotSun)\n{\n    float k = (3.0 \/ 4.0) * kIsotropicScatteringPhase;\n    return k * (1.0 + rayDotSun * rayDotSun);\n}\n\nfloat rbgToluminance(vec3 rgb)\n{\n    return (rgb.r * 0.3) + (rgb.g * 0.59) + (rgb.b * 0.11);\n}\n\nvec3 fixNormalBackFacingness(vec3 rayDirWS, vec3 normalWS)\n{\n    normalWS -= max(0.0, dot(normalWS, rayDirWS)) * rayDirWS;\n    return normalWS;\n}\n\n\/\/This is NOT a good way of converting from wavelgnth to RGB\nvec3 wavelengthToRGB(float wavelength)\n{\n    const float kLambdaR = 680.0;\n    const float kLambdaG = 550.0;\n    const float kLambdaB = 440.0;\n    \n    vec3 colour = oz.xxx - saturate(vec3(abs(wavelength-kLambdaR), abs(wavelength-kLambdaG), abs(wavelength-kLambdaB))\/150.0);\n\treturn colour;  \n}\n\n\n#define USE_SPHERE 0\n#define USE_TUBE 0\n#define USE_SKY 1\n#define USE_ATM 1\n#define USE_SUN 1\n\n\nconst float kSunRadius = 1.0\/180.0*kPI;\nconst float kCosSunRadius = cos(kSunRadius);\nconst float kTanSunRadius = tan(kSunRadius);\nconst float kSunDiskSolidAngle = 2.0*kPI*(1.0 - kCosSunRadius);\n\nconst float kAtmDensity = 1.0;\n\nconst vec3 kRayleighScatteringCoefsKm = vec3(5.8e-3, 1.35e-2, 3.31e-2) * kAtmDensity;\nconst float kRayleighAtmHeightKm = 8.0;\n\nconst float kMieAtmHeightKm = 1.2;\nconst float kMieScatteringCoefsKm = 0.0075 * kAtmDensity * 2.0;\n\nconst float kEarthRadiusKm = 6000.0;\n\nconst float kMultipleScatteringFakery = 0.5;\n\n\nvec3 s_dirToSunWS = normalize(vec3(0.4, -0.01, 0.5));\nvec3 s_sunColour = oz.yyy;\nvec3 s_cloudSunColour = oz.yyy;\nvec3 s_sunRadiance  = oz.yyy;\nvec3 s_averageSkyColour = oz.yyy;\nfloat s_timeOfDay = 0.0f;\nfloat s_time = 0.0f;\nfloat s_earthRotationRad = 0.0f;\nvec3 s_eyePositionWS = oz.xxx;\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Shared SDF\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nconst float kMatMapleLeaf = 0.0;\nconst float kMatFallingMapleLeaf = 1.0;\nconst float kMatMapleBark = 2.0;\nconst float kMatGrass = 3.0;\nconst float kMatMountains = 4.0;\nconst float kMatPines = 5.0;\n\nconst uint kRenderFilter = 0u;\nconst uint kShadowMapFilter = 1u;\n\nconst vec3 kWindVelocityWS = -oz.xyy * 0.75;\n\nconst vec3 kTreePosWS = vec3(0.0, 0.0, -8.0);\n\n\/\/2 triangles and some displacement\nfloat fMapleLeaf(vec3 posLeaf, float scale, float rand, bool doDetail, out vec4 material)\n{\n    posLeaf = opCheapBend(posLeaf.xzy, (rand-0.5) * 10.0).xzy;\n    \n    float normalisedHeight = saturate(0.5 + (posLeaf.y\/scale));\n    material = vec4(kMatMapleLeaf, 1.0, 0.0, 0.0);\n    \n    vec3 posTri = posLeaf - oz.yxy * scale;\n    posTri.y = -posTri.y;\n    \n    if(doDetail)\n    {\n    \tposTri.y += max(0.0, cos(abs(posTri.x)*6.0*kPI)) * 0.035;\n    }\n\n    float pointyBits = 0.0;\n    float dist2D = sdTriangleIsosceles(posTri.xy, vec2(scale*1.2, scale*2.0));\n    float innerStick = linearstep(0.01, 0.0, abs(posTri.x));\n    innerStick = max(innerStick, linearstep(0.02, 0.0, abs(abs(posTri.x)-1.75*(posTri.y-1.4*scale))));\n        \n    if(doDetail)\n    {\n        pointyBits = abs(fract((-0.08 + posTri.y + abs(posTri.x)*2.0)*8.0) - 0.5) * 0.1 \n            * saturate(1.0 - abs(-posTri.y\/scale + 0.4)*1.);\n\n        dist2D -= pointyBits;\n    }\n    \n    float distToMid = (1.0 - 2.0*abs(normalisedHeight - 0.2));\n    dist2D += distToMid*0.02;\n\n    posTri.y -= scale * 0.75;\n    posTri.x = abs(posTri.x) - scale * 1.3;\n    pR(posTri.xy,  kPI * 0.35);\n    \n    float distTriSides = sdTriangleIsosceles(posTri.xy, vec2(scale*0.55, scale*1.3));\n    innerStick = max(innerStick, linearstep(0.01, 0.0, abs(posTri.x)));\n    if(doDetail)\n    {    \n        pointyBits = abs(fract((-0.03 + posTri.y + abs(posTri.x)*2.0)*8.0) - 0.5) * 0.1 \n            * saturate(1.0 - abs(-posTri.y\/scale + 0.35)*2.5);\n        distTriSides -= pointyBits;\n    }\n\tdist2D = min(dist2D, distTriSides);\n    \n    float inside = max(0.0, -dist2D\/scale);\n    material.z = inside;\n    material.w = floor(rand * 100.0) + innerStick*0.99;\n    \n    if(doDetail)\n    {\n    \tdist2D -= abs(fract((posLeaf.y\/scale)*5.0)-0.5) * 0.02;\n    }\n    \n    float minDist = opExtrusion(posLeaf, dist2D, 0.005);\n    \n    if(doDetail)\n    {\n        vec3 posStick = posLeaf + oz.yxy * scale * 0.5;\n        float stickProgress = saturate(-posStick.y\/scale);\n        posStick.z += stickProgress*stickProgress*scale*0.3*(rand - 0.5);\n    \tfloat stickDist = fCapsule(posStick, -oz.yxy * scale * 1.0, oz.yyy, 0.003);\n        if(stickDist < minDist)\n        {\n            minDist = stickDist;\n        }        \n    }\n    \n    return minDist;\n}\n\nfloat fBranchSDF(vec3 posBranch, float len, float rad, float rand, out vec4 material)\n{\n    float branchHalfLen = len * 0.5;\n    float progressAlong = posBranch.y \/ (2.0*branchHalfLen);    \n    float branchRad = rad * (1.0 - progressAlong * 0.8);\n    \n    float wave = sin((rand + posBranch.y)\/len * 12.0)*0.25*rad;\n    posBranch.xz += oz.xx * wave;\n\tfloat minDist = fCapsule(posBranch - oz.yxy * branchHalfLen, branchRad, branchHalfLen);\n    \n    float u = atan(posBranch.z, posBranch.x);\n    material = vec4(kMatMapleBark, 0.0\/*overriden for AO*\/, u, progressAlong);\n\n    return minDist;\n}\n\nfloat fBranchSDF(vec3 posWS, float scale, float rand, out vec4 material)\n{\n    float branchLen = 1.0 * scale;\n    float branchRad = 0.03 * scale;\n\n    return fBranchSDF(posWS, branchLen, branchRad, rand, material);\n}\n\nfloat fSmallBranchesSDF(vec3 posWS, float branchDist, float branchProgress, out vec4 material)\n{\n    float branchLen = clamp(branchDist * 2.0, 0.5, 2.0);\n    \n    \/\/Shift until it looks good\n    posWS += vec3(0.53, 1.0, 0.53);\n    \n    vec3 posBranches = posWS;\n    vec3 id = pMod3(posBranches, oz.xxx * 2.0);\n    id.x += pModPolar(posBranches.yz, 3.0);\n    float rand = hash13(id * 789.5336);\n    posBranches.xz += sin((posBranches.y + rand) * 2.0 * kPI) * 0.05;\n    pR(posBranches.xy, (rand - 0.5) * kPI * 0.25);\n    float rad = 0.05 * (1.3 - ((posBranches.y\/branchLen) + 0.5));\n    float minDist = fCapsule(posBranches, rad, branchLen);\n    \n    posBranches = posWS + oz.xxx;\n    id = oz.xxx * 235.68 + pMod3(posBranches, oz.xxx * 2.0);\n    id.x += pModPolar(posBranches.yx, 3.0);\n    rand = hash13(id * 789.5336);\n    posBranches.xz += sin((posBranches.y + rand) * 2.0 * kPI) * 0.05;\n    pR(posBranches.yz, (rand - 0.5) * kPI * 0.25);\n    rad = 0.05 * (1.3 - ((posBranches.y\/branchLen) + 0.5));\n    minDist = min(minDist, fCapsule(posBranches, rad, branchLen));\n    \n    \/\/Remove branches near the center of the tree\n    minDist += saturate(0.7 - branchProgress);\n    \n    \/\/Remove small branches away from main branches\n    minDist = smax(minDist, branchDist - 3.0, 0.75);\n    \/\/Remove small branches past the end of the main branch\n    minDist += saturate((branchProgress - 1.4)*3.0);\n    \n    material = vec4(kMatMapleBark, 0.0\/*overriden for AO*\/, 0.001, branchProgress);\n    return minDist;\n}\n\nfloat fCanopy(vec3 posTreeSpace, float branchesDist, vec4 branchMaterial, out vec4 material)\n{\n    const float leafSize = 0.15;\n    const float leafRep = 0.4;\n    \n    vec3 leavesPos = posTreeSpace;\n    vec3 leafId = pMod3(leavesPos, oz.xxx * leafRep);\n    float leafRand = hash13(leafId * 347.0468);\n    leavesPos.xzy += (leafRand - 0.5) * oz.xxx * leafRep * 0.5;\n    pR(leavesPos.xz, leafRand * kPI);\n    float leavesDist = fMapleLeaf(leavesPos, leafSize, leafRand, false, material);\n    \n    leavesPos = posTreeSpace + oz.xxx * leafRep * 0.5;\n    pR(leavesPos.xz, kGoldenRatio * kPI);\n    leafId = pMod3(leavesPos, oz.xxx * leafRep);\n    leafRand = hash13(leafId * 347.0468);\n    pR(leavesPos.xz, leafRand * kPI);\n    leavesPos.xzy += (leafRand - 0.5) * oz.xxx * leafRep * 0.2;\n    leavesDist = min(leavesDist, fMapleLeaf(leavesPos, leafSize, leafRand, false, material));\n    \n    \/\/Remove leaves that are too far from branches, and too close to the trunk, and to far past the main branches\n    float branchStart = linearstep(0.6, 0.4, branchMaterial.w);\n    float branchEnd = linearstep(1.3, 1.42, branchMaterial.w);\n    leavesDist = max(leavesDist, branchesDist - (0.27 - branchEnd*0.17) + branchStart);\n    \n    return leavesDist;\n}\n\nfloat fFallenLeavesSet(vec3 posTreeSpace, float iter, float groundY, out vec4 material)\n{\n    float iterRand = fract(iter * kGoldenRatio);\n    float repSize = 0.25 + iter * 0.2;\n    vec3 leafPos = posTreeSpace - iter * kWindVelocityWS * 4.0;\n    leafPos.y = groundY - min(0.25, 0.75 - dot(leafPos.xz, leafPos.xz)*(0.01 - iter*0.002)*0.75);\n    vec2 leafId = pMod2(leafPos.xz, oz.xx * repSize);\n    float rand = hash12((leafId + oz.xx*iterRand*25.0) * 93.67);\n\n    leafPos.xz += (rand - 0.5) * oz.xx * repSize * (0.5);\n\tleafPos.y += abs(rand-0.5)*2.0 * 0.75;\n    \n    pR(leafPos.yz, kPI * (0.2 + rand * 0.8));\n    pR(leafPos.xy, kPI * 2.0 * rand);\n\n    return fMapleLeaf(leafPos, 0.15, rand, true, \/*out*\/material);\n}\n\nfloat fFallenLeaves(vec3 posTreeSpace, float groundY, out vec4 material)\n{\n    float minDist = kMaxDist;\n    \n    if(groundY < 1.)\n    {\n        vec4 fallenLeavesMaterial;\n        float fallenLeavesDist = fFallenLeavesSet(posTreeSpace, 0.0, groundY - 0.3, \/*out*\/fallenLeavesMaterial);\n        if(fallenLeavesDist < minDist)\n        {\n            minDist = fallenLeavesDist;\n            material = fallenLeavesMaterial;\n        }\n\n        fallenLeavesDist = fFallenLeavesSet(posTreeSpace, 1.0, groundY - 0.2, \/*out*\/fallenLeavesMaterial);\n        if(fallenLeavesDist < minDist)\n        {\n            minDist = fallenLeavesDist;\n            material = fallenLeavesMaterial;\n        }\n\n        fallenLeavesDist = fFallenLeavesSet(posTreeSpace, 2.0, groundY, \/*out*\/fallenLeavesMaterial);\n        if(fallenLeavesDist < minDist)\n        {\n            minDist = fallenLeavesDist;\n            material = fallenLeavesMaterial;\n        }  \n   \n    }\n    else\n    {\n        minDist = min(minDist, groundY - 0.75);\n    }\n    \n    return minDist;\n}\n\nfloat fTreeSDF(vec3 posTreeSpace, float groundY, out vec4 material)\n{\n    float minDist = kMaxDist;\n    float treeBoundingSphereDist = fSphere(posTreeSpace - oz.yxy * 8.0, 9.0);\n    \n    \/\/ If we're far from the tree and falling leaves, bail\n    if(treeBoundingSphereDist > 12.0)\n    {\n        return treeBoundingSphereDist - 10.0;\n    }\n    \n    \/\/ Falling leaves\n    {\n        vec3 leafPos = posTreeSpace - oz.yxy * 10.0;\n        pR(leafPos.xy, -kPI * 0.25);\/\/Rotate to match wind direction\n        float leafId = pModPolar(leafPos.xz, 9.0);\n        float leafRand = hash11(leafId * 68.76);\n        leafPos.x -= 4.0 + leafRand * 2.0;\n        float fallDuration = 20.0;\n        float fallTime = (s_time*1.75 + leafRand * fallDuration);\n        float iter = floor(fallTime \/ fallDuration);\n        fallTime = fallTime - iter * fallDuration;\n\t\t\n        leafPos.y += 2.0 + fallTime;\n        float xOff = sin(fallTime * 0.75 + iter * kPI) + cos(fallTime * 1.5 + iter * kPI) * 0.5;\n        leafPos.x += xOff*1.0;\n        \n        if(length(leafPos) > 0.3)\n        {\n            minDist = length(leafPos) - 0.2;\n        }\n        else\n        {\n            pR(leafPos.yz, xOff * 0.5 * kPI);\n            pR(leafPos.xy, fallTime * (leafRand + 1.0) + iter * kPI);\n\n            vec4 fallingLeavesMaterial;\n            float fallingLeavesDist = fMapleLeaf(leafPos, 0.15, leafRand, true, \/*out*\/fallingLeavesMaterial);\n            fallingLeavesMaterial.x = kMatFallingMapleLeaf;\n            if(fallingLeavesDist < minDist)\n            {\n                minDist = fallingLeavesDist;\n                material = fallingLeavesMaterial;\n            }\n        }\n    }\n    \n    \/\/ If we're far from the tree, bail early\n    if(treeBoundingSphereDist > 1.0)\n    {\n        return min(minDist, treeBoundingSphereDist);\n    }\n    \n    vec4 trunkMaterial;\n    vec3 trunkPos = posTreeSpace;\n    \n    float trunkDist = fBranchSDF(trunkPos, 10.0, 0.5, 0.0, trunkMaterial);\n        \n    if(trunkDist < minDist)\n    {\n        minDist = trunkDist;\n        material = trunkMaterial;\n    }\n    \n    float minBranchDist = kMaxDist;\n    vec4 minBranchMaterial;\n    \n    \n    float winFlexOffset = dot(sin(posTreeSpace * 0.1), oz.xxx) * 2.0 * kPI;\n    float windFlexAmount = min(8.0, trunkDist)\/8.0;\n    vec3 windOffset = vec3(kWindVelocityWS.x, 0.5, kWindVelocityWS.z) * \n        (sin(s_time * 4.0 + winFlexOffset)) * \n        0.05 * windFlexAmount;\n        \n    \n    vec4 branchMaterial;\n    vec3 branchPos;\n    float branchDist, id, rand;\n    \n    branchPos = trunkPos;\n    id = pModPolar(branchPos.xz, 6.0);\n    rand = hash11(id * 736.884);\n    branchPos.y -= 4.0 + 1.0 * rand;\n    pR(branchPos.xy, -kPI * (0.32 + rand * 0.1));\n    \n    branchDist = fBranchSDF(branchPos, 5.75, rand, branchMaterial);\n    if(branchDist < minBranchDist)\n    {\n        minBranchDist = branchDist;\n        minBranchMaterial = branchMaterial;\n    }\n    \n    branchPos = trunkPos;\n    pR(branchPos.xz, -kPI * 0.35);\n    id = pModPolar(branchPos.xz, 5.0);\n    rand = hash11(id * 736.884);\n    branchPos.y -= 7.5 + 1.0 * rand;\n    pR(branchPos.xy, -kPI * (0.35 - rand * 0.05));\n   \n    branchDist = fBranchSDF(branchPos, 5.0, 0.0, branchMaterial);\n    if(branchDist < minBranchDist)\n    {\n        minBranchDist = branchDist;\n        minBranchMaterial = branchMaterial;\n    }\n    \n    branchPos = trunkPos;\n    pR(branchPos.xz, -kPI * 0.65);\n    id = pModPolar(branchPos.xz, 3.0);\n    rand = hash11(id * 736.884);\n    branchPos.y -= 9.5 + 0.5 * rand;\n    pR(branchPos.xy, -kPI * (0.22 - 0.1 * rand));\n    \n    branchDist = fBranchSDF(branchPos, 4.0, 0.0, branchMaterial);\n    if(branchDist < minBranchDist)\n    {\n        minBranchDist = branchDist;\n        minBranchMaterial = branchMaterial;\n    }\n    \n    if(minBranchDist < minDist)\n    {\n        minDist = minBranchDist;\n        material = minBranchMaterial;\n    }\n    \n    \n    vec4 smallBranchesMaterial;\n    float smallBranchesDist = fSmallBranchesSDF(trunkPos + windOffset * 0.25, minBranchDist, minBranchMaterial.w, \n                                                \/*out*\/smallBranchesMaterial);\n    if(smallBranchesDist < minDist)\n    {\n        minDist = smallBranchesDist;\n        material = smallBranchesMaterial;\n    }\n\n    vec4 leavesMaterial;\n\tfloat leavesDist = fCanopy(trunkPos + windOffset, smallBranchesDist, minBranchMaterial, \n                               \/*out*\/leavesMaterial);\n    \n    if(leavesDist < minDist)\n    {\n        minDist = leavesDist;\n        material = leavesMaterial;\n    }\n    \n\t\/\/ Ambient occlusion is stronger at the center of the tree\n    vec3 posToCanopyCenter = vec3(0.0, 10.0, 0.0) - posTreeSpace;\n    material.y = min(1.0, dot(posToCanopyCenter, posToCanopyCenter) \/ 36.0);\n\n    return minDist;\n}\n\nfloat fGrassBladeSet(vec3 grassPosWS, float iter, float scale, float flattenAmount, inout vec4 material)\n{\n    float iterRand = hash11(iter * 967.367);\n\tfloat height = 0.45 * max(1.0, scale);\n    vec2 repSize = vec2(0.15, 0.15) * scale;\n    \n    \n    float windOffset = iterRand * 5.0 + cos(grassPosWS.z * 2.0)*1.0;\n    float wind = sin(s_time * 2.5 + windOffset + 2.0 * grassPosWS.x) * (1.0 - flattenAmount);\n    \n    \/\/Offset each set to prevet overlap\n    grassPosWS.xz += repSize * kGoldenRatio * iter * oz.xx;\n    \/\/Rotate each set in a different direction\n    pR(grassPosWS.xz, (0.25 + (iterRand - 0.5) * 0.5) * kPI);\n    \n    vec2 id = pMod2(grassPosWS.xz, repSize);\n    float rand = hash12(id);\n    \n    float normalisedHeight = saturate(grassPosWS.y \/ height);\n        \n    \/\/Rotate\/bend each blade with the wind\n    pR(grassPosWS.yz, (normalisedHeight * (0.05 + rand * 0.1) + wind * 0.025) * kPI);\n    grassPosWS.xz += (hash22(id * 37.3468) - 0.5*oz.xx) * repSize * 0.75;\n    \n    \/\/Rotate the blade arount Y to get a variety of normal directions\n    pR(grassPosWS.xz, (rand - 0.5) * 2.0 * kPI);\n    \n    const float kConeInvAngle = 0.485*PI;\n    const vec2 kRefConeSinCos = vec2(sin(kConeInvAngle), cos(kConeInvAngle));\n    float grassD = sdCone(grassPosWS - oz.yxy*height, vec3(kRefConeSinCos, height));  \n    grassD = max(grassD, abs(grassPosWS.x) - 0.005);\n    \n    grassD += flattenAmount * 0.2;\n    \n    float ambientVis = min(1.0, 1.7 * normalisedHeight)*(1.0-flattenAmount);\n    material = vec4(kMatGrass, normalisedHeight, min(material.z, ambientVis), rand);\n    \n    return grassD * 0.8;\n}\n\nfloat fGrass(vec3 posWS, float groundY, float leavesDist, out vec4 material)\n{      \n    vec3 grassPosWS;\n    \n    grassPosWS = posWS;\n    grassPosWS.y = groundY + max(0.0, length(posWS.xz - s_eyePositionWS.xz) - 15.0) \/ 60.0;\n    \n    \/\/ Early ouut if far from the ground\n    if(grassPosWS.y > 1.0)\n    {\n        return grassPosWS.y - 0.2;\n    }\n    \n    material.z = 1.0;\n    \n    float flattenAmount = linearstep(0.1, 0.0, leavesDist);\n    float grassDist = kMaxDist;    \n    \n\tgrassDist = min(grassDist, fGrassBladeSet(grassPosWS, 1.0, 1.0, flattenAmount, \/*out*\/material));\n    grassDist = min(grassDist, fGrassBladeSet(grassPosWS, 2.0, 2.0, flattenAmount, \/*out*\/material));\n    \n    material.z *= linearstep(0.0, 0.3, leavesDist);\n\n    return grassDist;\n}\n\nfloat noiseFbm(vec2 uv, sampler2D noiseSampler)\n{\n    float fbm = 0.0;\n    float noise;\n    \n    noise = textureLod(noiseSampler, uv * 1.0, 0.0).r;\n    fbm += noise * 1.0;\n    noise = textureLod(noiseSampler, uv * 1.5, 0.0).r;\n    fbm += noise * 0.55;\n    noise = textureLod(noiseSampler, uv * 3.0, 0.0).r;\n    fbm += noise * 0.35;\n    noise = textureLod(noiseSampler, uv * 4.5, 0.0).r;\n    fbm += noise * 0.25;    \n    return fbm;\n}\n\nfloat fSDF(vec3 posWS, uint filterId, sampler2D noiseSampler, out vec4 material)\n{    \n    float mountainNoise = noiseFbm(posWS.xz * 0.0001 + oz.xx * 0.28, noiseSampler);\n    \n\tfloat minDist = kMaxDist;\n    \n    float groundY = fSphere(posWS - vec3(-10.0, -500.0, -20.0), 500.0);\n    \n    float distantGroundDist = (mountainNoise - 0.25) * 30.0 + fSphere(posWS - vec3(100.0, -4995.0, 500.0), 5000.0);\n    \n    float allMountainsDist = kMaxDist;\n    \/\/ Distant mountains\n    if(filterId != kShadowMapFilter)\n    {\n        \/\/ Far left\n        float scale = 1.65;\n        vec3 moutainPosWS = posWS - scale*vec3(300.0, -100.0, 1400.0);\n        float mountainDist = mountainNoise * 60.0 * scale * linearstep(-scale*150.0, scale*100.0, posWS.y) +\n            fCone(moutainPosWS, scale*700.0, scale*600.0); \n        if(mountainDist < allMountainsDist)\n        {\n            allMountainsDist = mountainDist;\n            material = vec4(kMatMountains, scale, mountainNoise, 100.0);\n        }\n\n        \/\/ A bit to the right\n        scale = 2.7;\n        moutainPosWS = posWS - scale*vec3(600.0, -100.0, 1000.0);\n        mountainDist = mountainNoise * 40.0 * scale * linearstep(-scale*100.0, scale*100.0, posWS.y) +\n            fCone(moutainPosWS, scale*500.0, scale*340.0); \n        if(mountainDist < allMountainsDist)\n        {\n            allMountainsDist = mountainDist;\n            material = vec4(kMatMountains, scale, mountainNoise, 100.0);\n        }\n\n        scale = 4.45;\n        moutainPosWS = posWS - scale*vec3(1000.0, -200.0, 900.0);\n        mountainDist = mountainNoise * 40.0 * scale * linearstep(-scale*100.0, scale*100.0, posWS.y) +\n            fCone(moutainPosWS, scale*550.0, scale*400.0); \n        if(mountainDist < allMountainsDist)\n        {\n            allMountainsDist = mountainDist;\n            material = vec4(kMatMountains, scale, mountainNoise, 100.0);\n        }\n\n        scale = 0.85;\n        moutainPosWS = posWS - scale*vec3(50.0, -120.0, 850.0);\n        mountainDist = mountainNoise * 80.0 * scale +\n            fCone(moutainPosWS, scale*700.0, scale*250.0); \n        if(mountainDist < allMountainsDist)\n        {\n            allMountainsDist = mountainDist;\n            material = vec4(kMatMountains, scale, mountainNoise, 100.0);\n        }\n\n        \/\/ Far right\n        scale = 4.0;\n        moutainPosWS = posWS - scale*vec3(1480.0, -100.0, -700.0);\n        mountainDist = mountainNoise * 50.0 * scale +\n            fCone(moutainPosWS, scale*300.0, scale*350.0); \n        if(mountainDist < allMountainsDist)\n        {\n            allMountainsDist = mountainDist;\n            material = vec4(kMatMountains, scale, mountainNoise, 100.0);\n        }\n\n        scale = 2.0;\n        moutainPosWS = posWS - scale*vec3(1700.0, -200.0, -600.0);\n        mountainDist = mountainNoise * 50.0 * scale +\n            fCone(moutainPosWS, scale*600.0, scale*350.0); \n        if(mountainDist < allMountainsDist)\n        {\n            allMountainsDist = mountainDist;\n            material = vec4(kMatMountains, scale, mountainNoise, 100.0);\n        }\n        \n        minDist = min(allMountainsDist, minDist);\n\t}\n    \n    \/\/ Fallen leaves\n    float fallenLeavesDist = kMaxDist;\n    if(filterId != kShadowMapFilter)\n    {\n        vec4 fallenLeavesMat;\n        fallenLeavesDist = fFallenLeaves(posWS - kTreePosWS, groundY, \/*out*\/ fallenLeavesMat);\n        \n        if(fallenLeavesDist < minDist)\n        {\n            minDist = fallenLeavesDist;\n            material = fallenLeavesMat;\n        }\n    }\n    \n    \/\/ Grass\n    vec4 grassMaterial;\n    float grassDist = kMaxDist;\n    if(filterId != kShadowMapFilter)\n    {\n        grassDist = fGrass(posWS, groundY, fallenLeavesDist, \/*out*\/ grassMaterial);\n        \n        if(grassDist < minDist)\n        {\n            minDist = grassDist;\n            material = grassMaterial;\n        }\n    }\n    \n    if(filterId != kShadowMapFilter && \n       groundY < minDist)\n    {\n        minDist = groundY;\n    \tmaterial = vec4(kMatGrass, 0.0, saturate(grassDist \/ 0.2) * 0.3, 0.0);\n        \/\/material = vec4(kMatMountains, 0.01, mountainNoise, grassDist*50.0);\n    }\n    \n    \/\/ Tree\n    vec4 treeMaterial;\n\tfloat treeDist = fTreeSDF(posWS - kTreePosWS, groundY, \/*out*\/ treeMaterial);\n    \n    if(treeDist < minDist)\n    {\n        minDist = treeDist;\n        material = treeMaterial;\n    }\n    \n    \/\/ Pine cones\n    float pineDist = kMaxDist;\n\n    if(filterId != kShadowMapFilter)\n    {\n        float pineGroundDist = min(distantGroundDist, allMountainsDist + \n                                   max(0.0, posWS.y - min(300.0, (1.0 - mountainNoise)*1000.0)) * 0.05);\n        \n        if(pineGroundDist > 25.0)\n        {\n            pineDist = pineGroundDist - 15.0;\n        }\n        else\n        {\n            vec3 posPine = posWS;\n            posPine.y = pineGroundDist;\n            vec2 pineId = pMod2(posPine.xz, oz.xx * 25.0);\n            posPine .xz += hash22(pineId * 17.12) * 10.0;\n            pineDist = fCone(posPine, 2.0, 15.0 + 4.0 * hash12(pineId * 17.12));\n\n            posPine = posWS + oz.xxx * 12.5;\n            posPine.y = pineGroundDist;\n            pineId = pMod2(posPine.xz, oz.xx * 15.0);\n            posPine .xz += hash22(pineId * 17.12) * 5.0;\n            pineDist = min(pineDist, fCone(posPine, 2.0, 10.0 + 2.0 * hash12(pineId * 17.12)));\n        }\n        \n        if( pineDist < minDist)\n        {\n            minDist = pineDist;\n            material = vec4(kMatPines, pineGroundDist, mountainNoise, 1.0);\n        }\n    }\n\t\n    \n    if(filterId != kShadowMapFilter && \n       distantGroundDist < minDist)\n    {\n        minDist = distantGroundDist;\n        material = vec4(kMatMountains, 1.0, mountainNoise, pineDist);\n    }\n    \n    return minDist;\n}\n\nfloat fSDF(vec3 p, sampler2D noiseSampler)\n{\n    vec4 mat;\n    return fSDF(p, kRenderFilter, noiseSampler, mat);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Lighting\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec3 getSky(vec3 rayDirWS, float roughness, out vec3 transmittance)\n{\n    float r = max(0.0001, (rayDirWS.y + 0.1)\/1.1);\n    float cosineLobeAverage = 2.0\/kPI;\n    r = mix(r, cosineLobeAverage, roughness);\n    \n    float normalisedTravelledDensity = exp(-r)\/r;\n    \n\tfloat rayDotSun = dot(rayDirWS, s_dirToSunWS);\n    float sr = max(0.0001, (s_dirToSunWS.y + 0.12)\/1.12);    \n    \n    float rayleighPhase = rayleighPhase(rayDotSun) \/ kIsotropicScatteringPhase;\n    rayleighPhase = mix(rayleighPhase, 1.0, roughness);\n        \n    vec3 rayleighTransmittance = exp(-(kRayleighScatteringCoefsKm) * kRayleighAtmHeightKm * normalisedTravelledDensity);\n    vec3 rayleighScattering = oz.xxx - rayleighTransmittance;\n    vec3 rMsCoefs = kRayleighScatteringCoefsKm * kRayleighScatteringCoefsKm * 1000.0;\n    vec3 rayleighMultipleScattering = kMultipleScatteringFakery * mix(rayleighScattering, s_averageSkyColour, 0.5);\n    \n    \/\/Hand tweaked earth shadowing \/ sky darkening\n    float earthShadow = smoothstep(-0.15, 0.1, s_dirToSunWS.y + rayDotSun*0.02);\n    \n\tvec3 sunTransmittance = max(0.00025*oz.xxx, \/\/Max to prevent the sky from being pitch black at night\n\t\tearthShadow * mix(rayleighTransmittance, oz.xxx, 0.2 + 0.8*saturate((s_dirToSunWS.y)*3.0)));\n        \n    vec3 sky = (rayleighScattering * sunTransmittance + \n                earthShadow * rayleighTransmittance * rayleighMultipleScattering) *\n        rayleighPhase;\n\n    float mieTransmittance = exp(-kMieScatteringCoefsKm*kMieAtmHeightKm*normalisedTravelledDensity);\n    float mieG = 0.75 - roughness*0.6;\n    sky = sky * mieTransmittance + henyeyGreensteinPhase_schlick(rayDotSun, mieG) \/ kIsotropicScatteringPhase\n        * s_cloudSunColour * earthShadow * (1.0 - mieTransmittance);\n   \n    transmittance = mieTransmittance * rayleighTransmittance;\n    return sky;\n}\n\nvec3 getSky(vec3 rayDirWS, float roughness)\n{\n    vec3 unused;\n    return getSky(rayDirWS, roughness, unused);\n}\n\nvoid initScene(vec3 eyePosWS, float time)\n{\n    s_eyePositionWS = eyePosWS;\n    s_time = time * 1.0;\n    s_dirToSunWS = normalize(vec3(0.4, 0.0, 0.5));\n    \n    float sunRotationPhase = kPI * 0.025;\n    s_timeOfDay = fract(0.5 + (s_time * sunRotationPhase \/ (2.0 * kPI))) - 0.5;\n    s_earthRotationRad = s_time * sunRotationPhase - sin(s_time * sunRotationPhase*2.0)*0.4;\n    \n    pR(s_dirToSunWS.yz, s_earthRotationRad);\n    \n    float sr = max(0.0001, (s_dirToSunWS.y + 0.0)\/1.0);\n    \n    s_sunColour = float(USE_SUN) * exp(-kRayleighScatteringCoefsKm*kRayleighAtmHeightKm*\n        exp(-sr)\/sr);\n\ts_sunRadiance = s_sunColour*5.0 \/ kSunDiskSolidAngle;\n\n    sr = max(0.02, (s_dirToSunWS.y + 0.01)\/1.01);\n    s_cloudSunColour = float(USE_SUN) * exp(-kRayleighScatteringCoefsKm*kRayleighAtmHeightKm*\n        exp(-sr)\/sr);\n        \n\ts_averageSkyColour = getSky(oz.yxy, 0.5);\n}\n\nvec3 applyAtmosphere(vec3 sceneColour, vec3 rayDirWS, float travelledDist, float shadow)\n{   \n    float rayDotSun = dot(rayDirWS, s_dirToSunWS);\n    float rayleighPhase = rayleighPhase(rayDotSun) \/ kIsotropicScatteringPhase;\n    \n    float r = max(0.05, (rayDirWS.y + 0.1)\/1.1);\n    float normalisedTravelledDensity = exp(-r)\/r;\n    \n    float distKm = min(kRayleighAtmHeightKm, travelledDist \/ 1000.0);\n    vec3 rayleighTransmittance = exp(-kRayleighScatteringCoefsKm*distKm*normalisedTravelledDensity);\n    \n    float sr = max(0.0001, (s_dirToSunWS.y + 0.12)\/1.12);\n    \n    \/\/Hand tweaked earth shadowing \/ sky darkening\n\tfloat earthShadow = smoothstep(-0.15, 0.1, s_dirToSunWS.y + rayDotSun*0.02);\n    \n\tvec3 sunTransmittance = max(0.00025*oz.xxx, \/\/Max to prevent the sky from being pitch black at night\n\t\tearthShadow * mix(rayleighTransmittance, oz.xxx, 0.2 + 0.8*saturate((s_dirToSunWS.y)*3.0)));   \n    \n    vec3 rayleighLighting = mix(s_averageSkyColour, rayleighPhase * sunTransmittance, shadow);\n    vec3 rayleighInscatter = rayleighLighting * (oz.xxx - rayleighTransmittance);\n\n    distKm = min(kMieAtmHeightKm, travelledDist \/ 1000.0);\n    float mieTransmittance = exp(-kMieScatteringCoefsKm*distKm*normalisedTravelledDensity);\n    float mieG = 0.7;\n    vec3 mieLighting = mix(s_averageSkyColour, henyeyGreensteinPhase_schlick(rayDotSun, mieG) * \n        s_cloudSunColour * earthShadow * 4.0 * kPI, shadow);\n    vec3 mieInscatter = mieLighting * (1.0 - mieTransmittance);\n    \n    vec3 atmTransmittance = rayleighTransmittance*mieTransmittance;\n    vec3 atmInscatter = rayleighInscatter*mieTransmittance + mieInscatter;\n    sceneColour = sceneColour * atmTransmittance + atmInscatter;\n    \n    \n    return sceneColour;\n}\n\n\nfloat diskLight(vec3 rayDirWS, vec3 dirToLightWS,\n           float cosAngularRadius, float roughness)\n{    \n    float brdfDiskSolidAngle = 2.0*kPI*(1.0 - (cosAngularRadius-roughness*1.0));\n    float diskSolidAngle = 2.0*kPI*(1.0 - cosAngularRadius);\n    float brightness = (max(0.00001, diskSolidAngle)\/max(0.00001, brdfDiskSolidAngle));\n    \n    float sharpness = 1.0 - roughness;\n\n    float vDotL = dot(rayDirWS, dirToLightWS);\n    \n    float cosRadiusStart = cosAngularRadius - 0.0001 - roughness*1.0;\n    float cosRadiusEnd = cosAngularRadius + 0.0001 + roughness*1.0;\n    float diskVisibility = linearstep(\n        cosRadiusStart, \n        cosRadiusEnd,\n    \tvDotL)*2.0;\n    \n    float brdfPower = 7.0 - 6.0*sqrt(roughness);\n\n    diskVisibility = pow(diskVisibility, brdfPower);\n\n    \/\/Integral S = (x^n dx) is F = x^(n+1) * 1\/(n+1)\n    \/\/Integral over range [A, B] is F(B) - F(A)\n    float powIntegral = 1.0\/(brdfPower + 1.0);\n\tfloat normalisationFactor = powIntegral;\n    \/\/Renormalize\n    diskVisibility \/= max(0.00001, normalisationFactor);\n    \n    diskVisibility = min(1.0, diskVisibility * brightness);\n\n    return diskVisibility;\n}\n\nvec3 getSun(vec3 rayDirWS, vec3 normalWS, float roughness)\n{\n    float sharpness = 1.0 - roughness;\n\n    float vDotL = dot(rayDirWS, s_dirToSunWS);\n    \n    vec3 sunDisk = diskLight(rayDirWS, \n                             s_dirToSunWS, kCosSunRadius, roughness)\n        * s_sunRadiance;\n    \n    float bloomBlend = linearstep(\n        kCosSunRadius - (1.0 - kCosSunRadius)*10.0 - roughness * 1.0,\n        kCosSunRadius + roughness * 1.0,\n        vDotL);\n    \n    sunDisk += pow(bloomBlend, 4.0) * s_sunColour * 2.0 * sharpness;\n    return sunDisk;\n}\n\nvec3 getSkyAndSun(vec3 rayDirWS)\n{\n    vec3 sky = getSky(rayDirWS, 0.0);\n    sky += getSun(rayDirWS, s_dirToSunWS, 0.0);\n    \n    return sky;\n}\n\nvec3 computeSphereLighting(vec3 posWS, vec3 coneDirWS, float roughness, vec4 lightSphere, vec3 colour,\n                      out float visibility)\n{\n    vec3 posToSphereWS = lightSphere.xyz - posWS;\n    float distToSphereCenter = length(posToSphereWS);\n    float sqDistToSphere = distToSphereCenter * distToSphereCenter;\n    float sqSphereRadius = lightSphere.a * lightSphere.a;\n    \n    float distToDisk = (1.0\/max(0.001, distToSphereCenter)) * max(0.001, sqDistToSphere - sqSphereRadius);\n    float diskRadius = (lightSphere.a\/distToSphereCenter)*sqrt(max(0.001, sqDistToSphere - sqSphereRadius));\n    \n    float cosSphereAngularRadius = clamp(distToDisk\/sqrt(distToDisk*distToDisk + \n                                        diskRadius*diskRadius), -1.0, 1.0);\n    vec3 posToSphereDirWS = posToSphereWS\/distToSphereCenter;\n    \n    float sphereLighting = diskLight(coneDirWS, posToSphereDirWS, \n                                     cosSphereAngularRadius, roughness);\n    \n    \/\/The point to light can be inside the sphere, blend to 1.0 at the center\n    sphereLighting = mix(1.0, sphereLighting, min(1.0, sqDistToSphere\/sqSphereRadius));\n    \n\tvisibility = sphereLighting;\n    \n    return colour * sphereLighting;\n}\n\nvec3 computeLighting(vec3 posWS, vec3 rayDirWS, vec3 normalWS, float roughness, float ambientVis, float shadow)\n{\n    vec3 lightingConeDirWS = normalize(mix(rayDirWS, normalWS, roughness*roughness*0.75));\n    \n    vec3 sky = getSky(lightingConeDirWS, roughness);\n\n    vec3 ambient = sky;\n    \n#if USE_ATM\n    vec3 skyUpColour = s_averageSkyColour;\n#else\n    vec3 skyUpColour = getSky(oz.yxy, 1.0);\n#endif        \n    \n    vec4 treeSphere = vec4(kTreePosWS + oz.yxy * 9.5, 5.5);\n    \n    vec3 groundPosWS = posWS + lightingConeDirWS * (posWS.y\/max(0.0001, -lightingConeDirWS.y));\n    \n    float treeShadow;\n    computeSphereLighting(groundPosWS, s_dirToSunWS, roughness, vec4(treeSphere.xyz, treeSphere.a + 2.0), oz.yyy, treeShadow);\n    vec3 vecToTreePosWS = posWS - kTreePosWS;\n    vec3 treeLeavesAlbedo = vec3(0.5, 0.0075, 0.005);\n    \n    vec3 sunLight = smoothstep(0.05, 0.15, s_dirToSunWS.y) * s_sunColour;\n    vec3 groundAlbedo = vec3(0.005, 0.35, 0.015);\n\n    vec3 groundColour = (groundAlbedo * 0.63 + 0.04) * ((1.0 - treeShadow) * sunLight + skyUpColour);\n    ambient = mix(ambient, groundColour, \n                  smoothstep(0.001+roughness*1.5, -0.001-roughness*1.5, lightingConeDirWS.y));\n\n\t\/\/Fallen leaves lighting\n    {\n        vec3 leavesCenterWS = kTreePosWS - oz.yxy * 0.5;\n        vec3 posToDiskCenterWS = leavesCenterWS - posWS;\n        vec3 posToDiskCenterDirWS =  normalize(posToDiskCenterWS);\n\n        vec3 leavesLighting = treeLeavesAlbedo * (0.35 * (1.0 - treeShadow) * sunLight + skyUpColour);\n\n        float diff = linearstep(-1.0 + min(1.0, -posToDiskCenterWS.y\/10.0), \n                                0.0 + min(1.0, -posToDiskCenterWS.y\/10.0), \n                                dot(posToDiskCenterDirWS, lightingConeDirWS));\n        diff *= 1.0 - min(1.0, dot(posToDiskCenterWS, posToDiskCenterWS)\/150.0);\n        ambient *= 1.0 - diff;  \n        ambient += diff * leavesLighting;           \n    }\n    \n    float sphereVisibility;\n    vec3 sphereLight = computeSphereLighting(posWS, lightingConeDirWS, roughness, \n                                         treeSphere, treeLeavesAlbedo * (skyUpColour + 0.5 * sunLight), \n                                         sphereVisibility);\n    ambient *= mix(1.0 - sphereVisibility, 1.0, 0.0*roughness);\n    ambient += sphereLight;\n    \n    ambient *= ambientVis;\n    ambient += getSun(lightingConeDirWS, normalWS, roughness) * shadow;\n\n    return ambient;\n}\n\nvec3 computeLighting(vec3 posWS, vec3 rayDirWS, vec3 normalWS, float roughness)\n{\n    return computeLighting(posWS, rayDirWS, normalWS, roughness, 1.0, 1.0);\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ Cameras \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nconst float kCameraPlaneDist = 1.35;\n\nfloat s_pixelConeWithAtUnitLength = 0.0;\n\nvec2 getScreenspaceUvFromRayDirectionWS(\n    vec3 rayDirectionWS,\n\tvec3 cameraForwardWS,\n\tvec3 cameraUpWS,\n\tvec3 cameraRightWS,\n\tfloat aspectRatio)\n{\n    vec3 eyeToCameraPlaneCenterWS = cameraForwardWS * kCameraPlaneDist;\n    \/\/ project rayDirectionWs onto camera forward\n    float projDist                 = dot(rayDirectionWS, cameraForwardWS);\n    vec3  eyeToPosOnCameraPlaneWS = rayDirectionWS \/ projDist * kCameraPlaneDist;\n    vec3  vecFromPlaneCenterWS       = eyeToPosOnCameraPlaneWS - eyeToCameraPlaneCenterWS;\n\n    float xDist = dot(vecFromPlaneCenterWS, cameraRightWS);\n    float yDist = dot(vecFromPlaneCenterWS, cameraUpWS);\n    \n    xDist \/= aspectRatio;\n    xDist = xDist * 0.5 + 0.5;\n    yDist = yDist * 0.5 + 0.5;\n\n    return vec2(xDist, yDist);\n}\n\nvoid computeCamera(float time, vec2 mouseNorm, vec4 iMouse, vec2 iResolution,\n                   out vec3 rayOriginWS,\n                   out vec3 cameraForwardWS,\n                   out vec3 cameraUpWS,\n                   out vec3 cameraRightWS\n                  )\n{\n\ts_pixelConeWithAtUnitLength = (1.0 \/ iResolution.y) \/ kCameraPlaneDist;\n\n    rayOriginWS = vec3(-17.8, 2.0, -9.07);\n    \n\tvec3 lookAtTarget = vec3( 0.0, 5.0, 0.0);\n\t\n    cameraForwardWS = normalize(lookAtTarget - rayOriginWS);\n\n    cameraRightWS = normalize(cross(oz.yxy, cameraForwardWS));\n    cameraUpWS = normalize(cross(cameraForwardWS, cameraRightWS));\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ Shadow mapping \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nconst float kShadowMapRangeWS = 14.0;\n\nvec3 getShadowForwardDirWS(vec3 dirToSunWS)\n{\n    vec3 shadowPlaneForwardWS = dirToSunWS;\n    shadowPlaneForwardWS.y = max(0.005, shadowPlaneForwardWS.y);\n    shadowPlaneForwardWS = normalize(shadowPlaneForwardWS);\n    \n    return shadowPlaneForwardWS;\n}\n\nvec3 getShadowUvFromPosWS(vec3 posWS)\n{\n    vec3 shadowPlaneForwardWS = getShadowForwardDirWS(s_dirToSunWS);\n    vec3 shadowPlaneRightWS = normalize(cross(oz.yxy, shadowPlaneForwardWS));\n    vec3 shadowPlaneUpWS = cross(shadowPlaneForwardWS, shadowPlaneRightWS);\n    \n    vec3 shadowPlaneCenterWS = kTreePosWS + oz.yxy * 7.0 - oz.xyy * 4.0;   \n    \n    vec3 centerToPosWS = posWS - shadowPlaneCenterWS;\n    \n    vec3 uvSNorm;\n    uvSNorm.x = dot(centerToPosWS, shadowPlaneRightWS);\n    uvSNorm.y = dot(centerToPosWS, shadowPlaneUpWS);\n    uvSNorm.z = dot(shadowPlaneForwardWS, centerToPosWS);\n    \n    uvSNorm \/= kShadowMapRangeWS;\n    \n    return vec3(uvSNorm.xy * 0.5 + 0.5*oz.xx, uvSNorm.z);\n}\n\nvec3 uvSNormToShadowRayStartWS(vec2 uvSNorm, vec3 shadowPlaneForwardWS)\n{   \n    vec3 shadowPlaneRightWS = normalize(cross(oz.yxy, shadowPlaneForwardWS));\n    vec3 shadowPlaneUpWS = cross(shadowPlaneForwardWS, shadowPlaneRightWS);\n    \n    vec3 rayStartWS = kTreePosWS + oz.yxy * 7.0 - oz.xyy * 4.0 +\n        (uvSNorm.x * shadowPlaneRightWS + uvSNorm.y * shadowPlaneUpWS) * kShadowMapRangeWS;\n    \n    return rayStartWS;\n}\n",
            "name": "Common",
            "description": "",
            "type": "common"
        },
        {
            "inputs": [
                {
                    "id": "4sf3Rn",
                    "filepath": "\/media\/a\/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png",
                    "previewfilepath": "\/media\/ap\/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png",
                    "type": "texture",
                    "channel": 2,
                    "sampler": {
                        "filter": "mipmap",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dXGR8",
                    "channel": 0
                }
            ],
            "code": "\/\/   __  _                 _                                           \n\/\/  \/ _\\| |__    __ _   __| |  ___ __      __  _ __ ___    __ _  _ __  \n\/\/  \\ \\ | '_ \\  \/ _` | \/ _` | \/ _ \\\\ \\ \/\\ \/ \/ | '_ ` _ \\  \/ _` || '_ \\ \n\/\/  _\\ \\| | | || (_| || (_| || (_) |\\ V  V \/  | | | | | || (_| || |_) |\n\/\/  \\__\/|_| |_| \\__,_| \\__,_| \\___\/  \\_\/\\_\/   |_| |_| |_| \\__,_|| .__\/ \n\/\/                                                              |_|    \n\n\n#define ITER_SHADOW 128\nfloat marchShadow(vec3 rayOriginWS, vec3 rayDirWS, float t, float mt, out float lastDist)\n{\n    float d;\n    float minVisibility = 1.0;\n    lastDist = 100.0;\n    \n    vec4 material;\n    \n    for(int i = NON_CONST_ZERO; i < ITER_SHADOW && t < mt; ++i)\n    {\n        float coneWidth = max(0.00001, kTanSunRadius * t);\n        \n        vec3 posWS = rayOriginWS + rayDirWS*t;\n        d = fSDF(posWS, kShadowMapFilter, iChannel2, material);\n        \n        float stepMinVis = (d) \/ max(0.0001, coneWidth * 0.5);\n        if(stepMinVis <= minVisibility)\n        {\n            minVisibility = stepMinVis;\n            lastDist = t;\n        }\n        \n        t += max(0.01, d);           \n        \n        if(minVisibility < 0.01)\n        {\n            minVisibility = 0.0;\n        }\n    }\n      \n    return smoothstep(0.0, 1.0, minVisibility);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n    vec2 uvSNorm = uv * 2.0 - oz.xx;\n    \n    initScene(oz.xxx, iTime);\n        \n    vec3 shadowPlaneForwardWS = getShadowForwardDirWS(s_dirToSunWS);\n    \n\tvec3 rayStartWS = uvSNormToShadowRayStartWS(uvSNorm, shadowPlaneForwardWS);\n    \n    float offsetFromShadowPlane = min(100.0, rayStartWS.y\/shadowPlaneForwardWS.y);\n    rayStartWS -= shadowPlaneForwardWS * offsetFromShadowPlane;\n    \n    float shadowDist = 0.0;\n    float shadow = marchShadow(rayStartWS, shadowPlaneForwardWS, offsetFromShadowPlane - kShadowMapRangeWS, offsetFromShadowPlane + 100., shadowDist);\n    \n    shadowDist -= offsetFromShadowPlane;\n\n    fragColor = vec4(shadow, shadowDist\/kShadowMapRangeWS, 0.0, 1.0);\n}\n",
            "name": "Buffer A",
            "description": "",
            "type": "buffer"
        },
        {
            "inputs": [
                {
                    "id": "4sf3Rn",
                    "filepath": "\/media\/a\/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png",
                    "previewfilepath": "\/media\/ap\/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png",
                    "type": "texture",
                    "channel": 2,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "4sfGRr",
                    "filepath": "\/media\/a\/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin",
                    "previewfilepath": "\/media\/ap\/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin",
                    "type": "volume",
                    "channel": 3,
                    "sampler": {
                        "filter": "mipmap",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 1,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "XsXGR8",
                    "filepath": "\/media\/previz\/buffer01.png",
                    "previewfilepath": "\/media\/previz\/buffer01.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "XsXGR8",
                    "channel": 0
                }
            ],
            "code": "\/\/   __                                                                           _      _               \n\/\/  \/ _\\  ___  ___  _ __    ___   _ __  __ _  _   _  _ __ ___    __ _  _ __  ___ | |__  (_) _ __    __ _ \n\/\/  \\ \\  \/ __|\/ _ \\| '_ \\  \/ _ \\ | '__|\/ _` || | | || '_ ` _ \\  \/ _` || '__|\/ __|| '_ \\ | || '_ \\  \/ _` |\n\/\/  _\\ \\| (__|  __\/| | | ||  __\/ | |  | (_| || |_| || | | | | || (_| || |  | (__ | | | || || | | || (_| |\n\/\/  \\__\/ \\___|\\___||_| |_| \\___| |_|   \\__,_| \\__, ||_| |_| |_| \\__,_||_|   \\___||_| |_||_||_| |_| \\__, |\n\/\/                                            |___\/                                                |___\/ \n\nfloat fMaterialSDF(vec3 samplePosWS, float dist, vec4 material)\n{\n    if(abs(material.x - kMatMountains) < 0.1)\n    {\n        vec2 uv = samplePosWS.xz * 0.0015;\n       \tfloat mountainNoise = noiseFbm(uv \/ material.y, iChannel2);\n        \n        dist -= mountainNoise * 5.0 * material.y;\n    }\n    else if(abs(material.x - kMatMapleBark) < 0.1)\n    {\n        float progressAlongBranch = material.w;\n        float u = material.z\/kPI;\n\n        vec2 branchUv = vec2(u * 0.5, progressAlongBranch * 0.5);\n\n        dist -= textureLod(iChannel2, branchUv, 0.0).r * 0.05; \n    }\n    else if(abs(material.x - kMatPines) < 0.1)\n    {\n        float pineGroundDist = material.y;\n        float mountainNoise = material.z;\n        dist -= sin(pineGroundDist*kPI)*0.5*(1.0 - pineGroundDist\/20.0);\n    }\n    return dist;\n}\n\nvec3 getNormalWS(vec3 p, float dt)\n{\n    vec3 normalWS = oz.yyy;\n    for( int i = NON_CONST_ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        vec3 samplePosWS = p + e * dt;\n        vec4 mat;\n        float dist = fSDF(samplePosWS, kRenderFilter, iChannel2, mat);\n        normalWS += e*fMaterialSDF(samplePosWS, dist, mat);\n    }\n    return normalize(normalWS);    \n}\n\nfloat sampleShadowMap(vec3 p, float startOffset)\n{\n    float shadowMapRangeWS = 14.0;\n    \n    vec3 uv_depth = getShadowUvFromPosWS(p);\n    \n    vec2 shadow_depth = textureLod(iChannel1, uv_depth.xy, 0.0).xy;\n    \n    if(shadow_depth.y > (uv_depth.z + startOffset \/ kShadowMapRangeWS))\n    {\n        return shadow_depth.x;\n    }\n    else\n    {\n        return 1.0;\n    }\n}\n\nfloat globalShadow(vec3 posWS, vec3 rayDirWS)\n{    \n    float softness = 0.01;\n    \n    \/\/ Far left\n    float scale = 1.65;\n    vec3 moutainPosWS = scale*vec3(300.0, -100.0, 1400.0);\n    moutainPosWS += scale*vec3(-200.0, 100.0, 0.0);\n    float mountainShadow = sphSoftShadow(posWS, rayDirWS, moutainPosWS, scale*600.0 * 0.85, softness);\n\n    \/\/ A bit to the right\n    scale = 2.7;\n    moutainPosWS = scale*vec3(600.0, -100.0, 1000.0);\n    moutainPosWS += scale*vec3(-50.0, 0.0, 0.0);\n    mountainShadow *= sphSoftShadow(posWS, rayDirWS, moutainPosWS, scale*500.0 * 0.6, softness);\n\n    scale = 4.45;\n    moutainPosWS = scale*vec3(1000.0, -200.0, 900.0);\n    mountainShadow *= sphSoftShadow(posWS, rayDirWS, moutainPosWS, scale*500.0 * 0.7, softness);\n\n    return mountainShadow;;\n   \n}\n\nfloat getShadow(vec3 p, vec3 sd)\n{\n\treturn sampleShadowMap(p, 0.1);\n}\n\nfloat cloudNoiseFbm(vec2 uv)\n{\n    float maxNoise = 0.0;\n    float noise = 0.0;\n    \n    float amplitude = 1.0;\n    float scale = 1.0;\n    \n    vec2 windOffset = oz.yy;\n    \n    for(int i = NON_CONST_ZERO; i < 7; ++i)\n    {\n        windOffset += s_time\/scale * 0.0015 * kWindVelocityWS.xz;\n        \n        noise += amplitude * textureLod(iChannel2, uv*scale - windOffset, 0.0).r;\n    \tmaxNoise += amplitude;\n    \tamplitude *= 0.5;\n        scale *= 2.0;\n    }\n    \n    return noise \/ maxNoise;\n}\n\nvec3 computeFinalLighting(float marchedDist, vec3 rayOriginWS, vec3 rayDirWS,\n                          vec4 material)\n{    \n    vec3 endPointWS = rayOriginWS + rayDirWS * marchedDist;\n\n    vec3 sceneColour = oz.yyy;\n    \n    if(marchedDist < kMaxDist)\n    {\n        float coneWidth = max(0.001, s_pixelConeWithAtUnitLength * (marchedDist - 10.0));\n        float normalDt = coneWidth;\n        vec3 normalWS = getNormalWS(endPointWS, normalDt);\n        normalWS = fixNormalBackFacingness(rayDirWS, normalWS);\n        \n        vec3 worldShadowOffset = oz.yxy * 1000.0 * linearstep(0.1, 0.2, s_timeOfDay);\n        float worldShadow = globalShadow(endPointWS + worldShadowOffset, s_dirToSunWS);\n        float atmShadow = saturate(worldShadow + (s_dirToSunWS.y - 0.0615)*15.0);\n     \tfloat shadow = getShadow(endPointWS, s_dirToSunWS) * worldShadow;        \n        \n        vec3 albedo = oz.xyx;\n        vec3 f0Reflectance = oz.xxx * 0.04;\n        float roughness = 0.6;\n        vec4 emissive = oz.yyyy;\n        float ambientVis = 1.0;\n\n        if(abs(material.x - kMatMapleLeaf) < 0.1\n               || abs(material.x - kMatFallingMapleLeaf) < 0.1)\n        {\n            ambientVis = max(0.25, material.y);\n            shadow *= material.y;\n            \n            float inside = material.z;\n            float leafRand = floor(material.w) \/ 100.0;\n            float tint = min(1.0, leafRand*leafRand*0.5 + inside);\n                \n            albedo = mix(vec3(0.5, 0.0075, 0.005), vec3(0.5, 0.15, 0.005), tint*tint);\n\n            float stick = max(0.0, fract(material.w) - 0.75*inside);\n\t\t\talbedo = mix(albedo, vec3(0.2, 0.04, 0.005), stick);\n            \/\/Backlighting\n            emissive.rgb = henyeyGreensteinPhase(dot(s_dirToSunWS, rayDirWS), 0.5)\n                * shadow * albedo * albedo * s_sunColour * (1.0 - stick) * 4.0;\n            \/\/emissive.a = 1.0;\n            vec2 uv = material.yz;\n\n            roughness = 0.7 - stick*0.2;\n        }\n        else if(abs(material.x - kMatMapleBark) < 0.1)\n        {\n            float progressAlongBranch = material.w;\n            ambientVis = max(0.25, material.y);\n            float u = material.z;\n            \n            vec2 branchUv = vec2(u, progressAlongBranch);\n            roughness = 0.6;\n\n            albedo = vec3(0.2, 0.04, 0.005);\n        }\n        else if(abs(material.x - kMatGrass) < 0.1)\n        {\n            float normalisedHeight = material.y;\n            ambientVis = 0.15 + 0.85*material.z;\n            shadow *= min(1.0, material.z * 3.0);\n            float grassRand = material.w;\n            \n            albedo = mix(vec3(0.005, 0.35, 0.015), vec3(0.1, 0.35, 0.015), \n                         saturate(normalisedHeight*normalisedHeight + (grassRand - 0.5)));\n\n            \/\/Backlighting\n            emissive.rgb = henyeyGreensteinPhase(dot(s_dirToSunWS, rayDirWS), 0.5)\n                * shadow * albedo * albedo * s_sunColour * 4.0 * normalisedHeight;\n            \n            roughness = 0.75;\n        }\n        else if(abs(material.x - kMatMountains) < 0.1)\n        {\n            float mountainNoise = material.z;\n            float mountainScale = material.y;\n            float detailNoise = noiseFbm(endPointWS.xz * (0.002 \/ mountainScale), iChannel2);\n            float noise = (detailNoise * 0.5 + mountainNoise) \/ 1.5;\n            float treeDist = material.w;\n            \n            albedo = 0.5*vec3(0.15, 0.025, 0.001);\n            roughness = 0.85;\n            \n            float rocks = linearstep(1.15, 1.3, detailNoise * 0.3 + noise * 0.7);\n            albedo = mix(albedo, oz.xxx * 0.1, rocks);\n            roughness = mix(0.85, 0.5, rocks);\n            \n            float snowAmount = saturate((noise - 0.5)*2.0 + (endPointWS.y - 550.0)\/300.0);\n            albedo = mix(albedo, oz.xxx, snowAmount);\n            roughness = mix(roughness, 1.0, snowAmount);\n            \n            ambientVis = (0.5 + 0.5*saturate(treeDist*0.1));\n            shadow *= saturate(treeDist*0.1);\n        }\n        else if(abs(material.x - kMatPines) < 0.1)\n        {\n            float mountainNoise = material.z;\n            float bottomToTop = material.y \/ 20.0;\n            \n            albedo = mix(0.5*vec3(0.005, 0.15, 0.01), 0.25*vec3(0.005, 0.1, 0.05), linearstep(1.0, 1.2, mountainNoise));\n            ambientVis = (0.5 + 0.5*bottomToTop);\n            shadow *= saturate(bottomToTop * 5.0);\n            roughness = 0.85;\n        }        \n            \n        \/\/Lighting part\n        {            \n            vec3 reflectedRayDirWS = reflect(rayDirWS, normalWS);\n            float rDotN = max(0.0001, dot(reflectedRayDirWS, normalWS));\n            vec3 fresnelReflectance = roughFresnel(f0Reflectance, rDotN, roughness);\n\n            vec3 diffuse = albedo * computeLighting(endPointWS, normalWS, normalWS, 1.0, ambientVis, shadow);\n            vec3 specular = computeLighting(endPointWS, reflectedRayDirWS, normalWS, roughness, ambientVis, shadow);\n            vec3 surfaceLighting = mix(diffuse, specular, fresnelReflectance);\n            sceneColour = surfaceLighting * (1.0 - emissive.a) + emissive.rgb;\n        }\n        \n        sceneColour = applyAtmosphere(sceneColour, rayDirWS, marchedDist, atmShadow);\n    }\n    else\n    {\n        vec3 skyColour = getSkyAndSun(rayDirWS);\n    \tsceneColour = skyColour;\n        \n        \/\/Stars\n        float scale = 3.0;\n        vec3 stars = oz.yyy;\n        for(uint i = NON_CONST_ZERO_U; i < 4u; ++i)\n        {\n            vec3 rd = rayDirWS;\n            rd.y = max(0.0001, (rd.y + 0.5) \/ 1.5);\n            vec2 uv = rd.xz\/rd.y;\n            uv.y += s_earthRotationRad;\n            uv += oz.xx * float(i) * kGoldenRatio;\n            \n            vec2 id = pMod2(uv, oz.xx * 0.1 * scale) + oz.xx * float(i) * kGoldenRatio;\n\n            vec2 rand = hash22(id * 73.157);\n            uv += (rand - 0.5*oz.xx) * 0.1 * scale;\n            \n            float starHeat = hash12(id * 73.157);\n            vec3 starColour = oz.xxx * 0.75 + 0.5 * hash32(id * 953.56);\n\t\t\tstarHeat *= starHeat;\n            float startFade = linearstep((0.5 + starHeat*0.5)*0.003\/rd.y, 0.0, length(uv));\n            stars += startFade * startFade * starColour * 0.04 * (0.5 + starHeat*starHeat) * scale * scale;\n            \n            scale *= 0.5;\n        }\n        \n        vec3 skyTransmittance;\n        getSky(rayDirWS, 0.0, skyTransmittance);\n        stars = stars * skyTransmittance;\n        \n        float cloudPlaneInterDist = 4000.0\/max(0.0001, rayDirWS.y + 0.13);\n        vec3 cloudPosWS = rayOriginWS + rayDirWS * cloudPlaneInterDist;\n        \n        float rayDotSun = dot(s_dirToSunWS, rayDirWS);\n        float earthShadow = smoothstep(-0.06, -0.04, s_dirToSunWS.y + (rayDotSun - 0.5)*0.035);\n        \n        vec2 cloudUv = fract(cloudPosWS.xz * 0.0000035); \n        vec2 cloudShadowUv = cloudUv + s_dirToSunWS.xz * 0.002; \n        \n        float cloudNoise = cloudNoiseFbm(cloudUv);\n        \n        float phase = henyeyGreensteinPhase_schlick(dot(rayDirWS, s_dirToSunWS), 0.7);\n        float cloudTransmittance = 1.0 - smoothstep(0.6, 0.7, cloudNoise);\n        float cloudShadow = 1.0 - 0.9*smoothstep(0.5, 0.8, cloudNoiseFbm(cloudShadowUv));\n        vec3 cloudInscatter = s_averageSkyColour + max(oz.xxx * 0.00035, s_cloudSunColour * earthShadow) *\n            (1.0 + phase * 1.0 * kPI) * cloudShadow;\n        \n        cloudInscatter = applyAtmosphere(cloudInscatter, rayDirWS, cloudPlaneInterDist, 1.0);\n        \n        sceneColour += stars;\n        sceneColour = sceneColour * cloudTransmittance + (1.0 - cloudTransmittance) * cloudInscatter;\n    }\n    \n    return sceneColour;\n}\n\nfloat fogNoiseFbm(vec3 uvw)\n{\n    float maxNoise = 0.0;\n    float noise = 0.0;\n    \n    float amplitude = 1.0;\n    \n    for(int i = NON_CONST_ZERO; i < 3; ++i)\n    {\n        noise += amplitude * textureLod(iChannel3, uvw, 0.0).r;\n    \tmaxNoise += amplitude;\n    \tamplitude *= 0.5;\n        uvw *= 2.0;\n    }\n    \n    return noise \/ maxNoise;\n}\n\n#define ITER 1024\nfloat march(vec3 rayOriginWS, vec3 rayDirWS, float rand, out vec3 sceneColour, out float responsiveness)\n{\n    float phase = 4.0 * kPI * \n        (henyeyGreensteinPhase_schlick(dot(rayDirWS, s_dirToSunWS), 0.7) + \n        kIsotropicScatteringPhase);\n        \n    vec4 material;\n    \n    vec3 inscatter = oz.yyy;\n    float transmittance = 1.0;\n    \n    float t = 0.001;\n    float d;\n    \n    for(int i = NON_CONST_ZERO; i < ITER; ++i)\n    {\n        float coneWidth = max(0.001, s_pixelConeWithAtUnitLength * (t - 10.0));\n        \n        vec3 posWS = rayOriginWS + rayDirWS*t;\n        d = fSDF(posWS, kRenderFilter, iChannel2, material);\n        \n        t += d;\n        \n        if(i >= ITER - 1)\n        {\n            t = kMaxDist;\n        }              \n        \n        if(d < coneWidth || t >= kMaxDist)\n        {\n            break;\n        }\n        \n        \n        \/\/ Add some fog at the bottom of the tree, because shadowing from leaves looks cool !\n#if 1\n        vec3 fogVolumeCenterWs = kTreePosWS - oz.yxy * 99.0;\n        float distToFogVolume = fCapsule(posWS, fogVolumeCenterWs, \n                                         fogVolumeCenterWs,\n                                         100.0);\n        float distToTree = length((kTreePosWS - s_dirToSunWS * oz.xyx * 5.0) - posWS);\n        \n        float densityBias = ( max(0.0, distToTree - 2.0) * 0.035 + 0.2 ) +\n            linearstep(0.0, 10.0, distToFogVolume);\n        \n        if(densityBias < 1.0)\n        {\n            float fogNoise = fogNoiseFbm((posWS - oz.yxy * 0.75 * s_time) * 0.025);\n            fogNoise = max(0.0, fogNoise - densityBias);\n            fogNoise = saturate(fogNoise * 2.0);\n\n            float scatteringCoef = fogNoise * 0.1;\n\n            float stepTransmittance = exp(-scatteringCoef*d);\n\n            posWS = rayOriginWS + rayDirWS*(t - d*rand);\n            float shadow = sampleShadowMap(posWS, 0.0) * linearstep(0.0575, 0.1, s_dirToSunWS.y);;\n\n                vec3 stepLighting =  s_sunColour * shadow * phase;\n            stepLighting += s_averageSkyColour;\n\n            inscatter += transmittance * (1.0 - stepTransmittance) * stepLighting;\n            transmittance *= stepTransmittance;\n        }\n#endif\n        \n    }\n      \n    sceneColour = computeFinalLighting(t, rayOriginWS, rayDirWS, material);\n    \n    sceneColour = sceneColour * transmittance + inscatter;\n    \n    responsiveness = abs(material.x - kMatFallingMapleLeaf) < 0.1 ? 1.0f : 0.0f;\n    \n    return t;\n}\n\n\nvec3 applyBloom(vec3 colour, vec2 uv, vec2 subPixelJitter)\n{\n#if 1\n    float totalWeight = 0.0;\n    vec3 bloom = oz.yyy;\n    \n    float kernel = 1.0;\n    \/\/Super sample low mips to get less blocky bloom\n    for(float xo = -kernel; xo < kernel + 0.1; xo += 0.5)\n    {\n        for(float yo = -kernel; yo < kernel + 0.1; yo += 0.5)\n        {\n            vec2 vo = vec2(xo, yo);\n            float weight = (kernel*kernel*2.0) - dot(vo, vo);\n            vo += 0.5 * (subPixelJitter);\n            vec2 off = vo*(0.5\/kernel)\/iResolution.xy;\n            \n            if(weight > 0.0)\n            {\n                float maxBloom = 5.0;\n                bloom += weight * min(maxBloom*oz.xxx, textureLod(iChannel0, uv + off*exp2(5.0), 5.0).rgb);totalWeight += weight;\n                bloom += weight * min(maxBloom*oz.xxx, textureLod(iChannel0, uv + off*exp2(6.0), 6.0).rgb);totalWeight += weight;\n                bloom += weight * min(maxBloom*oz.xxx, textureLod(iChannel0, uv + off*exp2(7.0), 7.0).rgb);totalWeight += weight;\n            }\n        }\n    }\n\n    bloom.rgb \/= totalWeight;\n    \n    colour.rgb = colour.rgb * 0.8 + pow(bloom, oz.xxx*1.5) * 0.3;\n#endif\n    \n    return colour;\n}\n\n\n#define TAA 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 subPixelJitter = fract(hash22(fragCoord)\n                                + float(iFrame%256) * kGoldenRatio * oz.xx) - 0.5*oz.xx;\n    \n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n    float jitterAmount = float(TAA);\n    \n    vec2 uvJittered = (fragCoord.xy + jitterAmount * subPixelJitter) \/ iResolution.xy;\n    \n    float aspectRatio = iResolution.x\/iResolution.y;\n    vec2 uvSNorm = uvJittered * 2.0 - vec2(1.0);\n    uvSNorm.x *= aspectRatio;\n    \n    vec2 mouseUNorm = iMouse.xy\/iResolution.xy;\n    vec2 mouseNorm = mouseUNorm*2.0 - vec2(1.0);\n    \n    vec3 rayOriginWS;\n    \n    \/\/ ---- Camera setup ---- \/\/\n    vec3 cameraForwardWS, cameraUpWS, cameraRightWS;\n    computeCamera(iTime, mouseNorm, iMouse, iResolution.xy, rayOriginWS, cameraForwardWS, cameraUpWS, cameraRightWS);\n    vec3  rayDirWS = normalize(uvSNorm.x*cameraRightWS + uvSNorm.y*cameraUpWS + kCameraPlaneDist*cameraForwardWS);\n    \n    initScene(rayOriginWS, iTime);\n    \n    \/\/ ---- TAA part ---- \/\/  \n    float prevTime = iTime - iTimeDelta;\n    vec3 prevCameraPosWS, prevCameraForwardWS, prevCameraUpWS, prevCameraRightWS;\n    computeCamera(prevTime, mouseNorm, iMouse, iResolution.xy, prevCameraPosWS, \n                  prevCameraForwardWS, prevCameraUpWS, prevCameraRightWS);\n    \n    \/\/ ---- Render scene ---- \/\/\n    float responsiveness;\n    vec3 sceneColour;\n    float tt = march(rayOriginWS, rayDirWS, hash12(fragCoord), sceneColour, responsiveness);\n    \n    float nightTimeStrength = linearstep(-0.15, -0.6, s_dirToSunWS.y);\n    \n    float exposure = 1.0 + nightTimeStrength*150.0;\n    sceneColour *= exposure;\n    \n    sceneColour = applyBloom(sceneColour, uv, subPixelJitter);\n        \n    \/\/ ---- Flares ---- \/\/\n    {\n        float sunVisibility = sampleShadowMap(rayOriginWS, 0.0) * globalShadow(rayOriginWS, s_dirToSunWS);\n        float numApertureBlades = 8.0;\n\n        vec2 sunUv = getScreenspaceUvFromRayDirectionWS(s_dirToSunWS,\n                                                           cameraForwardWS, cameraUpWS, cameraRightWS, aspectRatio);\n        vec2 sunUvSNorm = sunUv * 2.0 - vec2(1.0);\n    \tsunUvSNorm.x *= aspectRatio;\n        \n        vec2 sunUvDirSNorm = normalize(sunUvSNorm);\n        \n        float rDotL = dot(rayDirWS, s_dirToSunWS);\n        \n        vec2 uvToSunSNorm = sunUvSNorm - uvSNorm;\n        float starBurst = 0.5 + 0.5*cos(1.5 * kPI + atan(uvToSunSNorm.x, uvToSunSNorm.y) * numApertureBlades);\n        float startFade = linearstep(0.97, 1.0, rDotL);\n        float starWidth = linearstep(0.5, 1.0, rDotL);\n        starBurst = pow(starBurst, max(1.0, 500.0 - starWidth*starWidth * 501.0))*startFade;\n\n        vec3 totalFlares = starBurst * 1.5 * linearstep(0.875, 1.0, rDotL*rDotL) * oz.xxx;\n\n        vec2 flareCenterUvSNorm;\n        \n        flareCenterUvSNorm = sunUvSNorm * 2.0;\n        totalFlares += 0.5 * vec3(0.1, 0.15, 0.01) * \n            linearstep(0.05, 0.0, sdOctogon(flareCenterUvSNorm - uvSNorm, 0.35));\n        \n        flareCenterUvSNorm = sunUvSNorm * 1.5;\n        totalFlares += 0.65 * vec3(0.015, 0.12, 0.09) * \n            linearstep(0.03, 0.0, sdOctogon(flareCenterUvSNorm - uvSNorm, 0.2));\n        \n        flareCenterUvSNorm = sunUvSNorm * 0.25;\n        totalFlares += 2.5 * vec3(0.1, 0.1, 0.1) * \n            linearstep(0.01, 0.0, sdOctogon(flareCenterUvSNorm - uvSNorm, 0.1));\n        \n        flareCenterUvSNorm = sunUvSNorm * 0.1;\n        totalFlares += 4.0 * vec3(0.11, 0.11, 0.1) * \n            linearstep(0.02, 0.0, sdOctogon(flareCenterUvSNorm - uvSNorm, 0.05));\n        \n        flareCenterUvSNorm = sunUvSNorm * -0.12;\n        totalFlares += 3.5 * vec3(0.15, 0.05, 0.025) * \n            linearstep(0.01, 0.0, sdOctogon(flareCenterUvSNorm - uvSNorm, 0.15));\n        \n        flareCenterUvSNorm = sunUvSNorm * -0.25;\n        totalFlares += 0.8 * vec3(0.02, 0.15, 0.1) * \n            linearstep(0.02, 0.0, sdOctogon(flareCenterUvSNorm - uvSNorm, 0.25));\n        \n        \/\/First coloured circle\n        {\n            flareCenterUvSNorm = sunUvSNorm * 0.5;\n\n            float distToDisk = length(flareCenterUvSNorm - uvSNorm) - length(flareCenterUvSNorm * 2.0);\n            float ci = smoothstep(0.2, 0.01, abs(distToDisk));\n            float colourRamp = linearstep(-0.2, 0.2, distToDisk);\n            vec2 uvToSunDir = normalize(uvToSunSNorm);\n            vec3 repColour = wavelengthToRGB(300.0 + colourRamp * 500.0);\n\n            totalFlares += 0.25 * repColour * ci * linearstep(0.75, 1.0, dot(sunUvDirSNorm, uvToSunDir));\n        }\n        \n        \/\/Second coloured circle\n        {\n            flareCenterUvSNorm = sunUvSNorm * 0.5;\n\n            float distToDisk = length(flareCenterUvSNorm - uvSNorm) - length(flareCenterUvSNorm * 1.6);\n            float ci = smoothstep(0.4, 0.0, abs(distToDisk));\n            float colourRamp = linearstep(-0.8, 0.8, distToDisk);\n\t\t\tvec2 uvToSunDir = normalize(uvToSunSNorm);\n            vec3 repColour = wavelengthToRGB(300.0 + colourRamp * 500.0);\n            totalFlares += 0.25 * repColour * ci * linearstep(0.98, 1.0, dot(sunUvDirSNorm, uvToSunDir));\n        }\n        \n        \n        flareCenterUvSNorm = sunUvSNorm * -1.4;\n        totalFlares += 0.8 * vec3(0.1, 0.15, 0.075) * \n            linearstep(0.015, 0.0, sdOctogon(flareCenterUvSNorm - uvSNorm, 0.17));\n        \n        \n        flareCenterUvSNorm = sunUvSNorm * -2.0;\n        totalFlares += 3.0 * vec3(0.1, 0.05, 0.02) * \n            linearstep(0.4, 0.0, sdOctogon(flareCenterUvSNorm - uvSNorm, 0.1));\n        \n        sceneColour += totalFlares * 0.2 * s_sunColour * sunVisibility * linearstep(3.2, 2.0, length(sunUvSNorm));\n    }\n    \n    vec2 prevFrameUv = uv;\n    vec4 prevData = texture(iChannel0, prevFrameUv);\n    \n    float defaultBlendToCurrent = (2.0\/9.0)*max(1.0, iTimeDelta\/0.066);\n    float blendedResp = mix(prevData.a, responsiveness, defaultBlendToCurrent);\n    float blendToCurrent = mix(defaultBlendToCurrent, 1.0, blendedResp);\n    \/\/Increase TAA at night to get stars trails\n    blendToCurrent = min(1.0, mix(blendToCurrent, iTimeDelta, nightTimeStrength));\n    \n#if !TAA    \n    blendToCurrent = 1.0;\n#endif\n    \n    \/\/Clamp to prevent the sun from leaving a trail\n    sceneColour = min(oz.xxx * 3.0, sceneColour);\n    sceneColour = max(oz.yyy, mix(prevData.rgb, sceneColour, blendToCurrent));\n    \n    fragColor = vec4(sceneColour, responsiveness);\n}",
            "name": "Buffer B",
            "description": "",
            "type": "buffer"
        }
    ]
}