{
    "ver": "0.1",
    "info": {
        "id": "MdyGRW",
        "date": "1453409227",
        "viewed": 1710,
        "name": "Fractal Explorer DOF",
        "username": "Dave_Hoskins",
        "description": " More fractal fun! This time with a single pass depth of field effect. MOUSE DRAG to turn WASD & cursor keys to move. SHIFT for speed up. SPACE for another spped up!\n",
        "likes": 45,
        "published": 3,
        "flags": 112,
        "tags": [
            "3d",
            "fractal",
            "dof",
            "fractalexplorerdof"
        ],
        "hasliked": 0
    },
    "renderpass": [
        {
            "inputs": [
                {
                    "id": "XsXGR8",
                    "filepath": "\/media\/previz\/buffer01.png",
                    "previewfilepath": "\/media\/previz\/buffer01.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "4sfSzH",
                    "filepath": "https:\/\/soundcloud.com\/zzzzra\/zzzzra-immanence-ep-romance-001-snippets",
                    "previewfilepath": "https:\/\/soundcloud.com\/zzzzra\/zzzzra-immanence-ep-romance-001-snippets",
                    "type": "musicstream",
                    "channel": 3,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 0
                }
            ],
            "outputs": [
                {
                    "id": "4dfGRr",
                    "channel": 0
                }
            ],
            "code": "\/\/ Fractal Explorer DOF. January 2016\n\/\/ by David Hoskins\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/ https:\/\/www.shadertoy.com\/view\/4s3GW2\n\n\n\/\/-------------------------------------------------------------------------------------------\n\nconst float GA =2.399; \nconst mat2 rot = mat2(cos(GA),sin(GA),-sin(GA),cos(GA));\n\nvec3 dof(vec2 uv,float rad, float zed)\n{\n\tvec3 acc=vec3(0);\n    vec2 pixel=vec2(iResolution.y\/iResolution.x,1.)*0.003, angle=vec2(0,rad);;\n    vec3 central = texture(iChannel0, uv, -99.0).xyz;\n    rad=1.;\n\tfor (int j=0;j<80;j++)\n    {  \n        rad += 1.\/rad;\n\t    angle*=rot;\n        vec4 col=texture(iChannel0,uv+pixel*(rad-1.)*angle);\n        acc+= (col.w >= zed) ? col.xyz: central;\n\n    }\n\treturn acc\/80.;\n}\n\n\/\/-------------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    float zed = texture(iChannel0, uv).w;\n\tfloat radius = abs(zed-1.)*.1;\n\tfragColor = vec4(dof(uv, radius, zed-2.), 1.0);\n}",
            "name": "Image",
            "description": "",
            "type": "image"
        },
        {
            "inputs": [
                {
                    "id": "4dXGRr",
                    "filepath": "\/presets\/tex00.jpg",
                    "previewfilepath": "\/presets\/tex00.jpg",
                    "type": "keyboard",
                    "channel": 3,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "nearest",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dXGR8",
                    "channel": 0
                }
            ],
            "code": "\/\/ Adaption of Ben Quantock, WASD 2016 ( https:\/\/www.shadertoy.com\/view\/ldyGzW )\n\/\/ With speed limits and frame delta added by Dave Hoskins.\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define INVERT_Y 0\n\n#define ACCEL .01\n#define DECAY  .85 \/\/ how much velocity is preserved per frame (proportionally)\n#define MAX_SPEED  .02\n\n#if INVERT_Y\nconst float yMul = 1.0;\n#else\nconst float yMul = -1.0;\n#endif\nconst int KEY_W\t\t= 87;\nconst int KEY_A\t\t= 65;\nconst int KEY_S\t\t= 83;\nconst int KEY_D\t\t= 68;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst int KEY_SPACE\t= 32;\nconst int KEY_SHIFT\t= 16;\n\n\/\/----------------------------------------------------------------------------------------\nfloat ReadKey( int key )\n{\n   \treturn step(.5,texture( iChannel3, vec2( (float(key)+.5)\/256.0, .25)).x);\n}\n\n\/\/----------------------------------------------------------------------------------------\n#define CSize vec3(1., 1.7, 1.)\n\nfloat Map( vec3 p )\n{\n\tp = p.xzy;\n\tfloat scale = 1.1;\n\tfor( int i=0; i < 8;i++ )\n\t{\n\t\tp = 2.0*clamp(p, -CSize, CSize) - p;\n\t\tfloat r2 = dot(p,p);\n        \/\/float r2 = dot(p,p+sin(p.z*.3)); \/\/Alternate fractal\n\t\tfloat k = max((2.)\/(r2), .5);\n\t\tp     *= k;\n\t\tscale *= k;\n\t}\n\tfloat l = length(p.xy);\n\tfloat rxy = l - 1.0;\n\tfloat n = l * p.z;\n\trxy = max(rxy, (n) \/ 8.);\n\treturn (rxy) \/ abs(scale);\n}\n\n\/\/----------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,0.0,1.0);\n\n    if ( int(fragCoord.y) == 0 )\n    {\n        if ( int(fragCoord.x) == 0 )\n        {\n            vec3 camPos = texture( iChannel0, vec2(.5,.5)\/iResolution.xy, -100.0 ).xyz;\n            vec3 camVel = texture( iChannel0, vec2(3.5,.5)\/iResolution.xy, -100.0 ).xyz;\n            float time  = (iTime-texture( iChannel0, vec2(4.5,.5)\/iResolution.xy, -100.0 ).x)*30.0;\n             if (iFrame == 0)\n\t\t    {\n        \t\tfragColor = vec4(-10.0,-1.2,2.5, 1.);\n            }else\n            {\n                camVel *= time*(1.0+ReadKey(KEY_SHIFT)+ReadKey(KEY_SPACE));\n                vec3 oldCam = camPos;\n                camPos.x += camVel.x;if (Map(camPos) < 0.002) camPos.x = oldCam.x;\n                camPos.y += camVel.y;if (Map(camPos) < 0.002) camPos.y = oldCam.y;\n                camPos.z += camVel.z;if (Map(camPos) < 0.002) camPos.z = oldCam.z;\n            \tfragColor = vec4(camPos, 0);\n            }\n        }\n        else if ( int(fragCoord.x) <= 2 )\n        {\n            vec4 baseCamRot = texture( iChannel0, vec2(2.5,.5)\/iResolution.xy, -100.0 );\n            vec4 camRot = texture( iChannel0, vec2(1.5,.5)\/iResolution.xy, -100.0 );\n\n            vec2 mouseRot = (iMouse.yx\/iResolution.yx-.5)*vec2(.5*yMul,1.);\n            \n            camRot.w = iMouse.z;\n            \n            bool press = (camRot.w > .0);\n            bool lastPress = (baseCamRot.w > .0);\n            bool click = press && !lastPress;\n            if ( click )\n            {\n                baseCamRot.xy -= mouseRot;\n            }\n            \n            if ( press )\n            {\n                camRot.xy = baseCamRot.xy + mouseRot;\n            }\n            else\n            {\n                \/\/update the base pos\n                baseCamRot = camRot;\n            }\n\n            baseCamRot.w = camRot.w;\n            \n            \/\/ store\n            if ( int(fragCoord.x) == 1 )\n            {\n\t\t\t\tif (iFrame == 0)\n\t\t    \t{\n        \t\t\tfragColor = vec4(1., 0.1, 0,0);\n            \t}else\n            \tfragColor = camRot;\n            }\n            else\n            {\n            \tfragColor = baseCamRot;\n            }\n        }\n        else if ( int(fragCoord.x) == 3 )\n        {\n            vec4 camVel = texture( iChannel0, vec2(3.5,.5)\/iResolution.xy, -100.0 );\n            vec4 camRot = texture( iChannel0, vec2(1.5,.5)\/iResolution.xy, -100.0 )*6.28318530718;\n            \n            vec3 forward = vec3(0,0,ACCEL);\n            vec3 right \t = vec3(ACCEL,0,0);\n\n            forward.zy = forward.zy*cos(camRot.x) + sin(camRot.x)*vec2(1,-1)*forward.yz;\n            right.zy = right.zy*cos(camRot.x) + sin(camRot.x)*vec2(1,-1)*right.yz;\n                \n            forward.xz = forward.xz*cos(camRot.y) + sin(camRot.y)*vec2(1,-1)*forward.zx;\n\t\t    right.xz = right.xz*cos(camRot.y) + sin(camRot.y)*vec2(1,-1)*right.zx;\n            \n            camVel.xyz += (ReadKey(KEY_W)-ReadKey(KEY_S)+ReadKey(KEY_UP)-ReadKey(KEY_DOWN)) * forward;\n            camVel.xyz += (ReadKey(KEY_D)-ReadKey(KEY_A)+ReadKey(KEY_RIGHT)-ReadKey(KEY_LEFT)) * right;\n            \n\n            camVel *= DECAY; \/\/ exponential decay\n            float lim = length(camVel);\n            if (lim > MAX_SPEED)\n            {\n                camVel = normalize(camVel) * MAX_SPEED;\n            }\n        \n            \n            fragColor = camVel;\n        }\n\t\telse if ( int(fragCoord.x) == 4 )\n        {\n\t\t\tfragColor = vec4(iTime);\n\t    }\n    }\n}\n",
            "name": "Buf A",
            "description": "",
            "type": "buffer"
        },
        {
            "inputs": [
                {
                    "id": "XdX3Rn",
                    "filepath": "\/media\/a\/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg",
                    "previewfilepath": "\/media\/ap\/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg",
                    "type": "texture",
                    "channel": 1,
                    "sampler": {
                        "filter": "mipmap",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "4df3Rr",
                    "filepath": "\/media\/a\/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg",
                    "previewfilepath": "\/media\/ap\/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg",
                    "type": "texture",
                    "channel": 3,
                    "sampler": {
                        "filter": "mipmap",
                        "wrap": "repeat",
                        "vflip": "false",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "nearest",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "XsXGR8",
                    "channel": 0
                }
            ],
            "code": "\/\/ Fractal Explorer DOF. January 2016\n\/\/ by David Hoskins\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/ https:\/\/www.shadertoy.com\/view\/4s3GW2\n\n\/\/--------------------------------------------------------------------------\n#define SUN_COLOUR vec3(1., .9, .85)\n#define FOG_COLOUR vec3(.13, 0.13, 0.14)\n#define MOD3 .1031\n#define TAU 6.28318530718\n#define STORE_DE\n\nvec2 fcoord;\n\nvec2 camStore = vec2(4.0,  0.0);\nvec2 rotationStore\t= vec2(1.,  0.);\nvec2 mouseStore = vec2(2.,  0.);\nvec3 sunLight  = vec3(  0.4, 0.4,  0.3 );\n\n\/\/ By TekF...\nvoid BarrelDistortion( inout vec3 ray, float degree )\n{\n\tray.z \/= degree;\n\tray.z = ( ray.z*ray.z - dot(ray.xy,ray.xy) );\n\tray.z = degree*sqrt(ray.z);\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 loadValue3( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) \/ iChannelResolution[0].xy, -100.0 ).xyz;\n}\nvec2 loadValue2( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) \/ iChannelResolution[0].xy, -100.0 ).xy;\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ From https:\/\/www.shadertoy.com\/view\/4djSRW\nfloat Hash(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nmat3 RotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n\/\/----------------------------------------------------------------------------------------\n#define CSize vec3(1., 1.7, 1.)\nvec3 Colour( vec3 p)\n{\n    p = p.xzy;\n\tfloat col\t= 0.0;\n    float r2\t= dot(p,p);\n\tfor( int i=0; i < 5;i++ )\n\t{\n\t\tvec3 p1= 2.0 * clamp(p, -CSize, CSize)-p;\n\t\tcol += abs(p.x-p1.z);\n\t\tp = p1;\n\t\tr2 = dot(p,p);\n        \/\/float r2 = dot(p,p+sin(p.z*.3)); \/\/Alternate fractal\n\t\tfloat k = max((2.)\/(r2), .5);\n\t\tp *= k;\n\t}\n    return texture(iChannel3, vec2(p.x, p.y+p.z)*.2).xyz+vec3(.4, .2, 0.2);\n}\n\n\/\/--------------------------------------------------------------------------\n\nfloat Map( vec3 p )\n{\n\tp = p.xzy;\n\tfloat scale = 1.1;\n\tfor( int i=0; i < 8;i++ )\n\t{\n\t\tp = 2.0*clamp(p, -CSize, CSize) - p;\n\t\tfloat r2 = dot(p,p);\n        \/\/float r2 = dot(p,p+sin(p.z*.3)); \/\/Alternate fractal\n\t\tfloat k = max((2.)\/(r2), .5);\n\t\tp     *= k;\n\t\tscale *= k;\n\t}\n\tfloat l = length(p.xy);\n\tfloat rxy = l - 1.0;\n\tfloat n = l * p.z;\n\trxy = max(rxy, (n) \/ 8.);\n\treturn (rxy) \/ abs(scale);\n}\n\n\/\/--------------------------------------------------------------------------\nfloat Shadow( in vec3 ro, in vec3 rd)\n{\n\tfloat res = 1.0;\n    float t = 0.05;\n\tfloat h;\n\t\n    for (int i = 0; i < 12; i++)\n\t{\n\t\th = Map( ro + rd*t );\n\t\tres = min(6.0*h \/ t, res);\n\t\tt += h+.02;\n\t}\n    return max(res, 0.0);\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 DoLighting(in vec3 mat, in vec3 pos, in vec3 normal, in vec3 eyeDir, in float d, in float sh)\n{\n    vec3 sunLight  = normalize( vec3(  0.4, 0.4,  0.3 ) );\n\/\/\tsh = Shadow(pos,  sunLight);\n    \/\/ Light surface with 'sun'...\n\tvec3 col = mat * SUN_COLOUR*(max(dot(sunLight,normal), 0.0)) *sh;\n    \/\/col += mat * vec3(0., .0, .15)*(max(dot(-sunLight,normal), 0.0));\n    \n    normal = reflect(eyeDir, normal); \/\/ Specular...\n    col += pow(max(dot(sunLight, normal), 0.0), 12.0)  * SUN_COLOUR * .5 *sh;\n    \/\/ Abmient..\n    col += mat * .2 * max(normal.y, 0.2);\n    col = mix(FOG_COLOUR,col, clamp(exp(-d*.05)+.03,0.0, 1.0));\n    \n\treturn col;\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 GetNormal(vec3 p, float sphereR)\n{\n\tvec2 eps = vec2(sphereR, 0.0);\n\treturn normalize( vec3(\n           Map(p+eps.xyy) - Map(p-eps.xyy),\n           Map(p+eps.yxy) - Map(p-eps.yxy),\n           Map(p+eps.yyx) - Map(p-eps.yyx) ) );\n}\n\n\/\/--------------------------------------------------------------------------\nfloat SphereRadius(in float t)\n{\n    t = t * .001*(500.\/iResolution.y);\n    return (t+.001);\n}\n\n\/\/--------------------------------------------------------------------------\nfloat Scene(in vec3 rO, in vec3 rD)\n{\n\n\tfloat t = .05 * Hash(fcoord);\n\t\n\tvec3 p = vec3(0.0);\n\n\tfor( int j=0; j < 180; j++ )\n\t{\n\t\tif (t > 24.0) break;\n\t\tp = rO + t*rD;\n\t\tfloat sphereR = SphereRadius(t);\n\t\tfloat de = Map(p);\n\t\tif(abs(de) < sphereR) break;\n\t\tt +=  de*.8;\n\t}\n\n\treturn t;\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 PostEffects(vec3 rgb, vec2 xy)\n{\n\t\/\/ Gamma first...\n\trgb = pow(rgb, vec3(0.45));\n\n\t\/\/ Then...\n\t#define CONTRAST 1.4\n\t#define SATURATION 1.4\n\t#define BRIGHTNESS 1.3\n\trgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*BRIGHTNESS)), rgb*BRIGHTNESS, SATURATION), CONTRAST);\n\n\t\/\/ Vignette...\n\trgb *= .4+0.6*pow(180.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.35);\t\n\n\treturn clamp(rgb, 0.0, 1.0);\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 TexCube( sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec3 x = texture( sam, p.yz ).xzy;\n\tvec3 y = texture( sam, p.zx ).xyz;\n\tvec3 z = texture( sam, p.xy ).yzx;\n\treturn (x*abs(n.x) + y*abs(n.y) + z*abs(n.z))\/(abs(n.x)+abs(n.y)+abs(n.z));\n}\n\n\/\/--------------------------------------------------------------------------\nvec3 Albedo(vec3 pos, vec3 nor)\n{\n    vec3 col = TexCube(iChannel1, pos*1.3, nor).zxy;\n    col *= Colour(pos);\n    return col;\n}\n\n\/\/----------------------------------------------------------------------------------------\n\nvec2 rot2D(inout vec2 p, float a)\n{\n    return cos(a)*p - sin(a) * vec2(p.y, -p.x);\n}\n\n\/\/--------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fcoord = fragCoord;\n\tfloat m = (iMouse.x\/iResolution.x)*20.0;\n\tfloat gTime = ((iTime+26.)*.2+m);\n    vec2 xy = fragCoord.xy \/ iResolution.xy;\n\tvec2 uv = (-1. + 2.0 * xy) * vec2(iResolution.x\/iResolution.y,1.0);\n\n  \n\t\n    \/\/vec3 cameraPos= loadValue3(camStore).xyz;\n    \/\/vec2 mou = loadValue2(rotationStore);\n    \n    vec3 cameraPos = texture( iChannel0, vec2(.5,.5)\/iResolution.xy, -100.0 ).xyz;\n    vec2 camRot = texture( iChannel0, vec2(1.5,.5)\/iResolution.xy, -100.0 ).xy;\n\n    camRot*= TAU;\n    \n    vec3 dir = normalize( vec3(uv, 1.2 ) );\n    BarrelDistortion(dir, .5);\n    dir =  normalize(dir);\n\n    float roll = .05 * sin(iTime*.3);\n    dir.xy = dir.xy*cos(roll) + sin(roll)*vec2(1,-1)*dir.yx;\n    dir.zy = dir.zy*cos(camRot.x) + sin(camRot.x)*vec2(1,-1)*dir.yz;\n    dir.xz = dir.xz*cos(camRot.y) + sin(camRot.y)*vec2(1,-1)*dir.zx;\n   \n\tvec3 col = vec3(1.0);\n\n    float dis = Scene(cameraPos, dir);\n\t\n    if (dis < 24.0)\n    {\n\t    vec3 pos = cameraPos + dir * dis;\n  \t\tfloat sphereR = SphereRadius(dis);\n        vec3 normal = GetNormal(pos, sphereR);\n\n    \tfloat sha = Shadow(pos, sunLight);\n    \n        vec3 alb = Albedo(pos, normal);\n        col = DoLighting(alb, pos, normal, dir, dis, sha);\n    }else\n    {\n   \t\tcol = FOG_COLOUR;\n        col += pow(max(dot(sunLight, dir), 0.0), 5.0)  * SUN_COLOUR;\n    }\n    \n\t   \n   \n\tcol = PostEffects(col, xy) * smoothstep(.0, 2.0, iTime);\t\n\t\n\tfragColor=vec4(col,dis);\n}\n\n\/\/--------------------------------------------------------------------------",
            "name": "Buf B",
            "description": "",
            "type": "buffer"
        }
    ]
}