{
    "ver": "0.1",
    "info": {
        "id": "XdcfDf",
        "date": "1527170479",
        "viewed": 4106,
        "name": "Underground Passageway",
        "username": "Shane",
        "description": "A simple demonstration of procedural texture construction and usage. In this case, creating a rocky surface, then mapping it onto a basic scene.",
        "likes": 142,
        "published": 3,
        "flags": 32,
        "usePreview": 0,
        "tags": [
            "procedural",
            "tunnel",
            "rocks"
        ],
        "hasliked": 0
    },
    "renderpass": [
        {
            "inputs": [
                {
                    "id": "Xsf3Rr",
                    "filepath": "\/media\/a\/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg",
                    "previewfilepath": "\/media\/ap\/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg",
                    "type": "texture",
                    "channel": 1,
                    "sampler": {
                        "filter": "mipmap",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dfGRr",
                    "channel": 0
                }
            ],
            "code": "\/*\n\n    Underground Passageway\n    ----------------------\n\n\tA simple demonstration of procedural texture construction and usage. In this case, creating \n\ta rocky surface, then mapping it onto a basic scene... I guess another way to put it would\n\tbe, yet another tunnel. :)\n\n    There's a standard technique that a lot of texture artists employ to produce rocky surfaces, \n    which involves splatting a heap of beveled looking 2D shapes onto a texture using some kind \n    of blend -- like min, max, lighten, etc. The resultant heightmap is then mapped onto the 3D \n    suface as usual. If I were to explain the process in terms the average Shadertoy user would\n\tunderstand, it'd be a more sophisticated version of Voronoi.\n\n    The method is simple enough, but to get the rocks looking right, you need some large object \n    overlap. In theory, this is trivial -- Just check a wider spread of neighboring cells. Of \n    course, something like a 7x7 cell check with non standard shapes is not currently feasible \n\tin realtime, which means the only way to benefit from the technique is to precalculate the \n\tvalues once in one of the buffers then use the buffer block to texture the scene surface. \n\tThis brings with it a whole  heap of  annoyances. The worst, I feel, is having to deal with \n\ttexture wrapping. Everything needs to be wrapped -- warping, random values, overlays, scaling. \n\tSome things are prohibitively difficult to wrap, and some won't wrap at all. There are also \n\trealtime texture mapping concerns, but for basic surfaces, that's not too difficult.\n\n\tI kind of patched a lot of this together, so there'd more than likely be some repeat\n\troutines across the two tabs that I could place in the \"common\" code tab. I'll tidy it up\n\ta bit in due course.\n\n\tAnyway, this was just a simple proof of concept. The main point of the excercise was to show \n\tthat under the right circumstances, it's possible to precalculate more complex surface \n\tdetails for realtime usage.\n\t\n\n\tRelated examples:\n\n\t\/\/ I'm using some older code of mine, but Fabrice has already produced something along\n\t\/\/ these lines. I haven't had a proper look at the code, but I will when I get a chance.\n\trocks (WIP) - FabriceNeyret2 \n\thttps:\/\/www.shadertoy.com\/view\/ls3fzj\n\n    \/\/ Precalculated terrain.\n    Scrolling Terrain - Dr2\n\thttps:\/\/www.shadertoy.com\/view\/4dlczH\n\n\n\t\/\/ One of my favorite simple coloring jobs.\n    Skin Peeler - Dave Hoskins\n    https:\/\/www.shadertoy.com\/view\/XtfSWX\n    Based on one of my all time favorites:\n    Xyptonjtroz - Nimitz\n\thttps:\/\/www.shadertoy.com\/view\/4ts3z2\n\n*\/\n\n\/\/ The far plane. I'd like this to be larger, but the extra iterations required to render the \n\/\/ additional scenery starts to slow things down on my slower machine.\n#define FAR 80.\n\n\/\/ Object identification. Usually, I like to store the individual object fields inside a vector,\n\/\/ then sort them outside of the raymarching loop. They're global, because they're sometimes\n\/\/ spread among various functions, and I'd rather not confuse matters by passing them from \n\/\/ function to function... and by that, I mean I'm lazy. :D\nfloat svObjID;\nvec4 vObjID, svVobjID;\n\n\n\/\/ Fabrice's concise, 2D rotation formula.\n\/\/mat2 rot2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\/\/ Standard 2D rotation formula - Nimitz says it's faster, so that's good enough for me. :)\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n\n\/\/ 3x1 hash function.\nfloat hash(vec3 p){ return fract(sin(dot(p, vec3(21.71, 157.97, 113.43)))*45758.5453); }\n\n\/*\n\/\/ IQ's smooth minium function. \nfloat smin(float a, float b , float s){\n    \n    float h = clamp( 0.5 + 0.5*(b-a)\/s, 0. , 1.);\n    return mix(b, a, h) - h*(1.0-h)*s;\n}\n\n\n\/\/ Smooth maximum, based on IQ's smooth minimum.\nfloat smax(float a, float b, float s){\n    \n    float h = clamp( 0.5 + 0.5*(a-b)\/s, 0., 1.);\n    return mix(b, a, h) + h*(1.0-h)*s;\n}\n*\/\n\n\/\/ Commutative smooth maximum function. Provided by Tomkh, and taken \n\/\/ from Alex Evans's (aka Statix) talk: \n\/\/ http:\/\/media.lolrus.mediamolecule.com\/AlexEvans_SIGGRAPH-2015.pdf\n\/\/ Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n    \n   float f = max(0., 1. - abs(b - a)\/k);\n   return max(a, b) + k*.25*f*f;\n}\n\n\n\/\/ Commutative smooth minimum function. Provided by Tomkh, and taken \n\/\/ from Alex Evans's (aka Statix) talk: \n\/\/ http:\/\/media.lolrus.mediamolecule.com\/AlexEvans_SIGGRAPH-2015.pdf\n\/\/ Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)\/k);\n   return min(a, b) - k*.25*f*f;\n}\n\n\n\n#define RIGID\n\/\/ Standard 2x2 hash algorithm.\nvec2 hash22(vec2 p) {\n    \n    \/\/ Faster, but probaly doesn't disperse things as nicely as other methods.\n    float n = sin(dot(p, vec2(113, 1)));\n    p = fract(vec2(2097152, 262144)*n)*2. - 1.;\n    #ifdef RIGID\n    return p;\n    #else\n    return cos(p*6.283 + iGlobalTime);\n    \/\/return abs(fract(p+ iGlobalTime*.25)-.5)*2. - .5; \/\/ Snooker.\n    \/\/return abs(cos(p*6.283 + iGlobalTime))*.5; \/\/ Bounce.\n    #endif\n\n}\n\n\n\/\/ Tri-Planar blending function. Based on an old Nvidia writeup:\n\/\/ GPU Gems 3 - Ryan Geiss: https:\/\/developer.nvidia.com\/gpugems\/GPUGems3\/gpugems3_ch01.html\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n){\n    \n    \/\/ We only want positive normal weightings. The normal is manipulated to suit\n    \/\/ your needs.\n    n = max(n*n - .2, .001); \/\/ n = max(abs(n) - .1, .001), etc.\n    \/\/n \/= dot(n, vec3(1)); \/\/ Rough renormalization approximation.\n    n \/= length(n); \/\/ Renormalizing.\n    \n\tvec3 tx = texture(t, p.yz).xyz; \/\/ Left and right sides.\n    vec3 ty = texture(t, p.zx).xyz; \/\/ Top and bottom.\n    vec3 tz = texture(t, p.xy).xyz; \/\/ Front and back.\n    \n    \/\/ Blending the surrounding textures with the normal weightings. If the surface is facing\n    \/\/ more up or down, then a larger \"n.y\" weighting would make sense, etc.\n    \/\/\n    \/\/ Textures are stored in sRGB (I think), so you have to convert them to linear space \n    \/\/ (squaring is a rough approximation) prior to working with them... or something like that. :)\n    \/\/ Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n    \n}\n\n\/*\n\/\/ More concise, self contained version of IQ's original 3D noise function.\nfloat noise3D(in vec3 p){\n    \n    \/\/ Just some random figures, analogous to stride. You can change this, if you want.\n\tconst vec3 s = vec3(113, 157, 1);\n\t\n\tvec3 ip = floor(p); \/\/ Unique unit cell ID.\n    \n    \/\/ Setting up the stride vector for randomization and interpolation, kind of. \n    \/\/ All kinds of shortcuts are taken here. Refer to IQ's original formula.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    \n\tp -= ip; \/\/ Cell's fractional component.\n\t\n    \/\/ A bit of cubic smoothing, to give the noise that rounded look.\n    p = p*p*(3. - 2.*p);\n    \n    \/\/ Standard 3D noise stuff. Retrieving 8 random scalar values for each cube corner,\n    \/\/ then interpolating along X. There are countless ways to randomize, but this is\n    \/\/ the way most are familar with: fract(sin(x)*largeNumber).\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n\t\n    \/\/ Interpolating along Y.\n    h.xy = mix(h.xz, h.yw, p.y);\n    \n    \/\/ Interpolating along Z, and returning the 3D noise value.\n    return mix(h.x, h.y, p.z); \/\/ Range: [0, 1].\n\t\n}\n*\/\n\n\n\/\/ Gradient noise. Ken Perlin came up with it, or a version of it. Either way, this is\n\/\/ based on IQ's implementation. It's a pretty simple process: Break space into squares, \n\/\/ attach random 2D vectors to each of the square's four vertices, then smoothly \n\/\/ interpolate the space between them.\nfloat gradN2D(in vec2 f){\n    \n    \/\/ Used as shorthand to write things like vec3(1, 0, 1) in the short form, e.yxy. \n   const vec2 e = vec2(0, 1);\n   \n    \/\/ Set up the cubic grid.\n    \/\/ Integer value - unique to each cube, and used as an ID to generate random vectors for the\n    \/\/ cube vertiies. Note that vertices shared among the cubes have the save random vectors attributed\n    \/\/ to them.\n    vec2 p = floor(f);\n    f -= p; \/\/ Fractional position within the cube.\n    \n\n    \/\/ Smoothing - for smooth interpolation. Use the last line see the difference.\n    \/\/vec2 w = f*f*f*(f*(f*6.-15.)+10.); \/\/ Quintic smoothing. Slower and more squarish, but derivatives are smooth too.\n    vec2 w = f*f*(3. - 2.*f); \/\/ Cubic smoothing. \n    \/\/vec2 w = f*f*f; w = ( 7. + (w - 7. ) * f ) * w; \/\/ Super smooth, but less practical.\n    \/\/vec2 w = .5 - .5*cos(f*3.14159); \/\/ Cosinusoidal smoothing.\n    \/\/vec2 w = f; \/\/ No smoothing. Gives a blocky appearance.\n    \n    \/\/ Smoothly interpolating between the four verticies of the square. Due to the shared vertices between\n    \/\/ grid squares, the result is blending of random values throughout the 2D space. By the way, the \"dot\" \n    \/\/ operation makes most sense visually, but isn't the only metric possible.\n    float c = mix(mix(dot(hash22(p + e.xx), f - e.xx), dot(hash22(p + e.yx), f - e.yx), w.x),\n                  mix(dot(hash22(p + e.xy), f - e.xy), dot(hash22(p + e.yy), f - e.yy), w.x), w.y);\n    \n    \/\/ Taking the final result, and converting it to the zero to one range.\n    return c*.5 + .5; \/\/ Range: [0, 1].\n}\n\n\n\/\/ Gradient noise fBm.\nfloat fBm(in vec2 p){\n    \n    return gradN2D(p)*.57 + gradN2D(p*2.)*.28 + gradN2D(p*4.)*.15;\n    \n}\n\n\/\/ Cheap and nasty 2D smooth noise function with inbuilt hash function - based on IQ's \n\/\/ original. Very trimmed down. In fact, I probably went a little overboard. I think it \n\/\/ might also degrade with large time values. I'll swap it for something more robust later.\nfloat n2D(vec2 p) {\n\n\tvec2 i = floor(p); p -= i; \n    \/\/p *= p*p*(p*(p*6. - 15.) + 10.);\n    p *= p*(3. - p*2.);  \n    \n\treturn dot(mat2(fract(sin(vec4(0, 1, 113, 114) + dot(i, vec2(1, 113)))*43758.5453))*\n                vec2(1. - p.y, p.y), vec2(1. - p.x, p.x) );\n\n}\n\n\n\/\/ Repeat gradient lines. How you produce these depends on the effect you're after. I've used a smoothed\n\/\/ triangle gradient mixed with a custom smoothed gradient to effect a little sharpness. It was produced\n\/\/ by trial and error. If you're not sure what it does, just call it individually, and you'll see.\nfloat grad(float x, float offs){\n    \n    \/\/ Repeat triangle wave. The tau factor and \".25\" factor aren't necessary, but I wanted its frequency\n    \/\/ to overlap a sine function.\n    x = abs(fract(x\/6.283 + offs - .25) - .5)*2.;\n    \n    float x2 = clamp(x*x*(-1. + 2.*x), 0., 1.); \/\/ Customed smoothed, peaky triangle wave.\n    \/\/x *= x*x*(x*(x*6. - 15.) + 10.); \/\/ Extra smooth.\n    x = smoothstep(0., 1., x); \/\/ Basic smoothing - Equivalent to: x*x*(3. - 2.*x).\n    return mix(x, x2, .15);\n    \n\/*    \n    \/\/ Repeat sine gradient.\n    float s = sin(x + 6.283*offs + 0.);\n    return s*.5 + .5;\n    \/\/ Sine mixed with an absolute sine wave.\n    \/\/float sa = sin((x +  6.283*offs)\/2.);\n    \/\/return mix(s*.5 + .5, 1. - abs(sa), .5);\n    \n*\/\n}\n\n\/\/ One sand function layer... which is comprised of two mixed, rotated layers of repeat gradients lines.\nfloat sandL(vec2 p){\n    \n    \/\/ Layer one. \n    vec2 q = rot2(3.14159\/18.)*p; \/\/ Rotate the layer, but not too much.\n    q.y += (gradN2D(q*18.) - .5)*.05; \/\/ Perturb the lines to make them look wavy.\n    float grad1 = grad(q.y*80., 0.); \/\/ Repeat gradient lines.\n   \n    q = rot2(-3.14159\/20.)*p; \/\/ Rotate the layer back the other way, but not too much.\n    q.y += (gradN2D(q*12.) - .5)*.05; \/\/ Perturb the lines to make them look wavy.\n    float grad2 = grad(q.y*80., .5); \/\/ Repeat gradient lines.\n      \n    \n    \/\/ Mix the two layers above with an underlying 2D function. The function you choose is up to you,\n    \/\/ but it's customary to use noise functions. However, in this case, I used a transcendental \n    \/\/ combination, because I like the way it looked better.\n    \/\/ \n    \/\/ I feel that rotating the underlying mixing layers adds a little variety. Although, it's not\n    \/\/ completely necessary.\n    q = rot2(3.14159\/4.)*p;\n    \/\/float c = mix(grad1, grad2, smoothstep(.1, .9, n2D(q*vec2(8))));\/\/smoothstep(.2, .8, n2D(q*8.))\n    \/\/float c = mix(grad1, grad2, n2D(q*vec2(6)));\/\/smoothstep(.2, .8, n2D(q*8.))\n    \/\/float c = mix(grad1, grad2, dot(sin(q*12. - cos(q.yx*12.)), vec2(.25)) + .5);\/\/smoothstep(.2, .8, n2D(q*8.))\n    \n    \/\/ The mixes above will work, but I wanted to use a subtle screen blend of grad1 and grad2.\n    float a2 = dot(sin(q*12. - cos(q.yx*12.)), vec2(.25)) + .5;\n    float a1 = 1. - a2;\n    \n    \/\/ Screen blend.\n    float c = 1. - (1. - grad1*a1)*(1. - grad2*a2);\n    \n    \/\/ Smooth max\\min\n    \/\/float c = smax(grad1*a1, grad2*a2, .5);\n   \n    return c;\n    \n    \n}\n\n\/\/ A global value to record the distance from the camera to the hit point. It's used to tone\n\/\/ down the sand height values that are further away. If you don't do this, really bad\n\/\/ Moire artifacts will arise. By the way, you should always avoid globals, if you can, but\n\/\/ I didn't want to pass an extra variable through a bunch of different functions.\n\/\/float gT;\n\nfloat sand(vec2 p){\n    \n    \/\/ Rotating by 45 degrees. I thought it looked a little better this way. Not sure why.\n    \/\/ I've also zoomed in by a factor of 4.\n    \/\/p = vec2(p.y - p.x, p.x + p.y)*.7071\/4.;\n    \n    p \/= 6.;\n    \n    \/\/ Sand layer 1.\n    float c1 = sandL(p);\n    \n    \/\/ Second layer.\n    \/\/ Rotate, then increase the frequency -- The latter is optional.\n    vec2 q = rot2(3.14159\/12.)*p;\n    float c2 = sandL(q*1.25);\n    \n    \/\/ Mix the two layers with some underlying gradient noise.\n    c1 = mix(c1, c2, smoothstep(.1, .9, gradN2D(p*vec2(4))));\n    \n\/*   \n\t\/\/ Optional screen blending of the layers. I preferred the mix method above.\n    float a2 = gradN2D(p*vec2(4));\n    float a1 = 1. - a2;\n    \n    \/\/ Screen blend.\n    c1 = 1. - (1. - c1*a1)*(1. - c2*a2);\n*\/    \n    \n    \/\/ Extra grit. Not really necessary.\n    \/\/c1 = .7 + fBm(p*128.)*.3;\n    \n    \/\/ A surprizingly simple and efficient hack to get rid of the super annoying Moire pattern \n    \/\/ formed in the distance. Simply lessen the value when it's further away. Most people would\n    \/\/ figure this out pretty quickly, but it took me far too long before it hit me. :)\n    return c1;\n}\n\n\/\/\/\/\/\/\/\/\/\n\n\/*     \nfloat t3D(sampler2D tex, vec3 p, vec3 n) {\n    float ta = texture(tex, p.yz).a;\n    float tb = texture(tex, p.xz).a;\n    float tc = texture(tex, p.xy).a;\n    return(ta + tb + tc) \/ 3.;\n}\n*\/\n\n\n\/\/ The path is a 2D sinusoid that varies over time, which depends upon the frequencies and amplitudes.\nvec2 path(in float z){ \n    \n    return vec2(4.*sin(z * .1), cos(z * .1));\n}\n\n\n\n\/\/ Crosss sectional distance. It can be cylindrical, square, hexagonal, octagonal, etc.\nfloat polDist(vec2 p){\n    \n    \n\t\/\/ Standard circular length.\n    return length(p);\n    \n    \/\/ More options, but since we're using cylindrical mapping, a lot wouldn't \n    \/\/ really work, unless you rewrote the texture mapping to match.\n    \n    \n    \/\/ A hacky arch-like variation.\n    \/\/return mix(length(p), min(length(p), max(abs(p.x), abs(p.y + 2.5 - .5) + 1.)), .5);\n\n    \/\/ Square cross section.\n    \/\/p = abs(p);\n    \/\/return max(p.x, p.y);\n    \n    \/\/ Hexagonal cross section.\n    \/\/p = abs(p);\n    \/\/return max(p.x*.8660254 + p.y*.5, p.y);\n\n    \/\/ Octagonal cross section.\n    \/\/p = abs(p);\n    \/\/return max(max(p.x, p.y), (p.x + p.y)*.7071);\n    \n    \n    \/\/ Dodecahedral cross section.\n    \/\/p = abs(p);\n    \/\/vec2 p2 = p.xy*.8660254 + p.yx*.5;\n    \/\/return max(max(p2.x, p2.y), max(p.y, p.x)); \n    \n    \n    \/\/const float pwr = 4.;\n    \/\/return pow( dot(pow(abs(p), vec2(pwr)), vec2(1)), 1.\/pwr);\n\n    \n}\n\n\n\/\/ Crosss sectional distance. It can be cylindrical,\n\/\/ square, hexagonal, octagonal, etc.\nfloat dist(vec2 p){\n    \n    \n\n    \/\/return length(p);\n    \n    \/\/ Square cross section.\n    \/\/p = abs(p);\n    \/\/return max(p.x, p.y);\n    \n    \/\/ Hexagonal cross section.\n    \/\/p = abs(p);\n    \/\/return max(p.x*.8660254 + p.y*.5, p.y);\n\n    \/\/ Octagonal cross section.\n    p = abs(p);\n    return max(max(p.x, p.y), (p.x + p.y)*.7071);\n    \n    \n    \/\/ Dodecahedral cross section.\n    \/\/p = abs(p);\n    \/\/vec2 p2 = p.xy*.8660254 + p.yx*.5;\n    \/\/return max(max(p2.x, p2.y), max(p.y, p.x)); \n    \n    \/\/const float pwr = 4.;\n    \/\/return pow( dot(pow(abs(p), vec2(pwr)), vec2(1)), 1.\/pwr);\n\n    \n}\n\n\n\nvec4 getCylTex(vec3 p){\n    \n    vec2 uv = vec2(atan(p.y, p.x)\/6.2831, p.z);\n    return texture(iChannel0, uv*vec2(1., 1.\/16.));\n}\n\n\n\n\/\/ The tunnel scene. In essence, it's a texture mapped cylinder wrapped around a path, \n\/\/ with a floor and some repetive overhead XZ cylinder-like shapes. Nothing complicatied.\nfloat map(vec3 p){\n    \n    \/\/ Perturbing the walls with a sinusoidal function just a bit to give the tunnel a \n    \/\/ less man made feel.\n    vec3 pert = p*vec3(1, 1, .5);\n    pert = sin(pert - cos(pert.yzx*2.))*.25;\n    \n    \/\/float id = floor(p.z\/16.)*16. + 8.;\n    \/\/vec3 pos = vec3(path(id), id);\n    \/\/vec3 q = p - pos;\n     \n    \/\/ Wrapping the tunnel, vents and floor around the path.\n    p.xy -= path(p.z).xy;\n    \n    \/\/ The ground. Nothing fancy. \n    float ground = p.y + 2.375 + pert.y*.125;\n    \n    \n    \/\/ A pretty hacky vent shaft object. I'll rewrite this in a better way at some\n    \/\/ stage, so I wouldn't pay too much attention to it.\n    vec3 q = p;\n    \/\/ Repeting the shafts every 16 units.\n    q.z = mod(q.z + 0., 16.) - 8.; \/\/ (q.z\/16. - floor(q.z\/16.))*16. - 8.;\n    \n\n    \/\/ The shaft cross section. I decided to make them octagonal, for whatever reason, \n    \/\/ but it's not mandatory.\n    float sCirc = dist(q.xz) - 1.15;\n   \n    \/\/ The ventilation shaft.\n    float shafts = max(abs(sCirc) - .1, abs(q.y - (4.6)) - 2.);\n    \n    \/\/ The rim under the vent.\n    float rim = dist(vec2(sCirc, q.y - 2.6)) - .15; \n    \n    shafts = min(shafts, rim);\n    \n    \n    \/\/ Shaft holes. The end bit is needed to stop the shaft holes from continuing\n    \/\/ through the floor.\n    float shaftHoles = max(min(sCirc - .05, rim - .1), -p.y);\n    \/\/shaftHoles = smin(shaftHoles, rim, 1.);\n    \n \n    \/\/ Subdividing space into smaller lots to create the vent grids. I probably should\n    \/\/ had created these separately in order to set unique materials, but I've attached \n    \/\/ them to the vent object.\n    q.xz = mod(q.xz, .25) - .25\/2.;\n    q.y -= 3. - .25;\n    float ventGrid = length(q.xy) - .035;\/\/min(length(q.yz), length(q.xy)) - .05;\n    ventGrid = max(ventGrid, sCirc);\n    \/\/shafts = min(shafts, ventGrid);\n    \n    \/\/ Cylindrically mapping the rocky texture onto the walls of the cylinder. The \n    \/\/ cylinder has been warped here and then, so it's not an exact fit, but no one\n    \/\/ will notice.\n    float sf = getCylTex(p).a;\n    \n    \/\/ Arrange for the rocky base to effect the sand level ever so slightly.\n    ground += (.5 - sf)*.25;\n\n    p.xy *= vec2(.9, 1); \/\/ Widen the tunnel just a bit.\n    \/\/ Add the sinusoidal perturbations to the tunnel via some space warping. You could\n    \/\/ also do this in height map form, but I chose this way... for some reason that\n    \/\/ escapes me at present. :)\n    p += pert; \n   \n    \/\/ The tunnel object -- otherwise known as a glorified cylinder. We're approaching\n    \/\/ the cylinder walls from the inside. Hence, the negative sign.\n    float tun =  -(polDist(p.xy) - 2.7);\n    \n    \/\/ There a light sitting about the vents outside the tunnel, so I've given the\n    \/\/ tunnel a bit of thickness. That's all this is \n    tun = max(tun + (.5-sf)*1., -(tun + 4.));\n    \/\/ Creating some holes in the tunnel roof for the vents to fit into. A smooth blend\n    \/\/ is used to smoothen the rocks around the grated end of the vent.\n    tun = smax(tun, -shaftHoles, .5);\n     \n    \n    \/\/ Save the IDs. For speed, they're sorted outside the loop.\n    vObjID = vec4(tun, shafts, ground, ventGrid);\n    \n    float df = min(min(tun, ventGrid), min(shafts, ground));\n    \n\n    \/\/ Return the distance -- Actually, a fraction of the distance, since a lot of \n    \/\/ this isn't Lipschitz friendly, for want of a better term. :)\n    return df*.86;\n \n}\n\n\n\n\/\/ Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    float t = 0., h;\n    \/\/gT = t;\n    \n    for(int i=0; i<128; i++){\n    \n        h = map(ro + rd*t);\n        \/\/ Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        \/\/ \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(h)<0.001*(t*.125 + 1.) || t>FAR) break; \/\/ Alternative: 0.001*max(t*.25, 1.), etc.\n        \n        t += h; \n        \/\/gT = t;\n    }\n\n    return min(t, FAR);\n}\n\n\/*\n\/\/ Tetrahedral normal - courtesy of IQ. I'm in saving mode, so the two \"map\" calls saved make\n\/\/ a difference. Also because of the random nature of the scene, the tetrahedral normal has the \n\/\/ same aesthetic effect as the regular - but more expensive - one, so it's an easy decision.\nvec3 normal(in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*0.001;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n*\/\n\n \n\/\/ Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 normal(in vec3 p, float ef) {\n\tvec2 e = vec2(0.001*ef, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n\n\/\/ Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n\/\/ example that explains it, if you require it.\nfloat n3D(in vec3 p){\n    \n\tconst vec3 s = vec3(113, 157, 1);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); \/\/p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); \/\/ Range: [0, 1].\n}\n\n\n\/\/ 3D noise fBm.\nfloat fBm(in vec3 p){\n    \n    return n3D(p)*.57 + n3D(p*2.)*.28 + n3D(p*4.)*.15;\n    \n}\n\n\/\/ Surface bump function..\nfloat bumpSurf3D(in vec3 p, in vec3 n){\n\/*    \n    \/\/ Obtaining some terrain samples in order to produce a gradient\n    \/\/ with which to distort the sand. Basically, it'll make it look\n    \/\/ like the underlying terrain it effecting the sand. The downside\n    \/\/ is the three extra taps per bump tap... Ouch. :) Actually, it's\n    \/\/ not that bad, but I might attempt to come up with a better way.\n    float n = surfFunc(p);\n    vec3 px = p + vec3(.001, 0, 0);\n    float nx = surfFunc(px);\n    vec3 pz = p + vec3(0, 0, .001);\n    float nz = surfFunc(pz);\n    \n    \/\/ The wavy sand, that have been perturbed by the underlying terrain.\n    return sand(p.xz + vec2(n - nx, n - nz)\/.001*1.);\n*\/\n    \n    \/\/float sf2 = t3D2(iChannel1, p\/4., n);\n    \/\/return min(sf2\/.66, 1.);\n    \n    float res = 0.;\n    \n    vec3 tSp = p;\n    tSp.xy -= path(tSp.z).xy;\n    \n    if(svObjID == 0.){\n        \n        vec4 tx4 = getCylTex(tSp*3.);\n        res = tx4.a;\n    }\n    else if(svObjID == 2.){\n        \/\/res = sand(tSp.xz);\n        \/\/vec4 tx4 = mix(texture(iChannel0, tSp.xz\/8.), 1. - texture(iChannel0, tSp.xz\/3.), .5);\n        vec4 tx4 = texture(iChannel0, tSp.xz\/4.);\n\n        res = tx4.a;\n        \/\/res *= sand(tSp.xz);\n    }\n    \n    return res;\n\n}\n\n\/\/ Standard function-based bump mapping routine: This is the cheaper four tap version. There's\n\/\/ a six tap version (samples taken from either side of each axis), but this works well enough.\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    \/\/ Larger sample distances give a less defined bump, but can sometimes lessen the aliasing.\n    const vec2 e = vec2(.001, 0); \n    \n    \/\/ Gradient vector: vec3(df\/dx, df\/dy, df\/dz);\n    float ref = bumpSurf3D(p, nor);\n    vec3 grad = (vec3(bumpSurf3D(p - e.xyy, nor),\n                      bumpSurf3D(p - e.yxy, nor),\n                      bumpSurf3D(p - e.yyx, nor)) - ref)\/e.x; \n    \n    \/*\n    \/\/ Six tap version, for comparisson. No discernible visual difference, in a lot of cases.\n    vec3 grad = vec3(bumpSurf3D(p - e.xyy) - bumpSurf3D(p + e.xyy),\n                     bumpSurf3D(p - e.yxy) - bumpSurf3D(p + e.yxy),\n                     bumpSurf3D(p - e.yyx) - bumpSurf3D(p + e.yyx))\/e.x*.5;\n    *\/\n       \n    \/\/ Adjusting the tangent vector so that it's perpendicular to the normal. It's some kind \n    \/\/ of orthogonal space fix using the Gram-Schmidt process, or something to that effect.\n    grad -= nor*dot(nor, grad);          \n         \n    \/\/ Applying the gradient vector to the normal. Larger bump factors make things more bumpy.\n    return normalize(nor + grad*bumpfactor);\n\t\n}\n\n\/\/ Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n\/\/ make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap(sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    \/\/ Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; \/\/ Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )\/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); \/\/ Bumped normal. \"bf\" - bump factor.\n    \n}\n\n\/\/ Cheap shadows are the bain of my raymarching existence, since trying to alleviate artifacts is an excercise in\n\/\/ futility. In fact, I'd almost say, shadowing - in a setting like this - with limited  iterations is impossible... \n\/\/ However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k, float t){\n\n    \/\/ More would be nicer. More is always nicer, but not really affordable.\n    const int maxIterationsShad = 32; \n    \n    vec3 rd = lp - ro; \/\/ Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = 0.001*(t*.125 + 1.);  \/\/ Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    \/\/float stepDist = end\/float(maxIterationsShad);\n    rd \/= end;\n\n    \/\/ Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    \/\/ number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n         \n        float h = map(ro + rd*dist);\n        shade = min(shade, k*h\/dist);\n        \/\/shade = min(shade, smoothstep(0.0, 1.0, k*h\/dist)); \/\/ Subtle difference. Thanks to IQ for this tidbit.\n        \/\/ So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        \/\/h = clamp(h, .1, 1.); \/\/ max(h, .02);\/\/\n        h = max(h, .1);\n        dist += h;\n\n        \n        \/\/ Early exits from accumulative distance function calls tend to be a good thing.\n        if (shade<0.001 || dist > end) break; \n    }\n\n    \/\/ I've added a constant to the final shade value, which lightens the shadow a bit. It's a preference thing. \n    \/\/ Really dark shadows look too brutal to me. Sometimes, I'll add AO also, just for kicks. :)\n    return min(max(shade, 0.) + .05, 1.); \n}\n\n\n\n\/\/ I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n\/\/ Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat ao = 0., l;\n    const float maxDist = 2.;\n\tconst float nbIte = 5.;\n\t\/\/const float falloff = .9;\n    for( float i=1.; i< nbIte+.5; i++ ){\n    \n        l = (i + .0)*.5\/nbIte*maxDist;        \n        ao += (l - map( p + n*l )); \/\/ \/ pow(1.+l, falloff);\n    }\n\t\n    return clamp(1.- ao\/nbIte, 0., 1.);\n}\n\n\n\n\/\/ Fog color. Made up. I wanted a little bit of gradential color change.\nvec3 getFogCol(vec3 rd){ \n     \n    \/\/ Mix the gradients using the Y value of the unit direction ray. \n    return mix(vec3(.672, .7, .585), vec3(.336, .6, 1.053), pow(max(rd.y*.5 + .2, 0.), .5));\n\n}\n\n\n\n\/\/ Slight modified version of Nimitz's curve function. The tetrahedral and normal six\n\/\/ tap versions are in there. If four taps gives you what you want, then that'd be the\n\/\/ one to use.\n\/\/\n\/\/ I think it's based on a discrete finite difference approximation to the continuous\n\/\/ Laplace differential operator? Either way, it gives you the curvature of a surface, \n\/\/ which is pretty handy. I used it to do a bit of fake shadowing.\n\/\/\n\/\/ Original usage (I think?) - Cheap curvature: https:\/\/www.shadertoy.com\/view\/Xts3WM\n\/\/ Other usage: Xyptonjtroz: https:\/\/www.shadertoy.com\/view\/4ts3z2\n\/\/\n\/\/ spr: sample spread, amp: amplitude, offs: offset.\nfloat curve(in vec3 p, in float spr, in float amp, in float offs){\n\n    float d = map(p);\n    \n    #if 1\n    \/\/ Tetrahedral.\n    vec2 e = vec2(-spr, spr); \/\/ Example: ef = .25;\n    float d1 = map(p + e.yxx), d2 = map(p + e.xxy);\n    float d3 = map(p + e.xyx), d4 = map(p + e.yyy);\n    return max((d1 + d2 + d3 + d4 - d*4.)\/e.y\/2.*amp + offs + .5, 0.);\n    #else  \n    \/\/ Cubic.\n    vec2 e = vec2(spr, 0); \/\/ Example: ef = .5;\n\tfloat d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\tfloat d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\tfloat d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n    return max((d1 + d2 + d3 + d4 + d5 + d6 - d*6.)\/e.x\/2.*amp + offs + .5, 0.);\n    #endif\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\t\n\n\n\t\n\t\/\/ Screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*.5)\/iResolution.y;\n\t\n\t\/\/ Camera Setup.     \n\tvec3 ro = vec3(0, 0, iTime*4.); \/\/ Camera position, doubling as the ray origin.\n    vec3 lookAt = ro + vec3(0, 0, .5);  \/\/ \"Look At\" position.\n    \n    vec3 lp = ro + vec3(0, 64, 6);\n    \n\t\n\t\/\/ Using the Z-value to perturb the XY-plane.\n\t\/\/ Sending the camera and \"look at\" vectors down the tunnel. The \"path\" function is \n\t\/\/ synchronized with the distance function.\n\tro.xy += path(ro.z);\n\tlookAt.xy += path(lookAt.z);\n\tlp.xy += path(lp.z);\n\n    \n    \/\/float lz = floor((lp.z + 4.)\/8.)*8. + 4.;\n    \/\/lz = lz + mod(lz, 8.);\n    \/\/lp = vec3(lp.xy, lz);\n     \n \n    \/\/ Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159265\/2.5; \/\/ FOV - Field of view.\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(vec3(forward.z, 0, -forward.x )); \n    vec3 up = cross(forward, right);\n\n    \/\/ rd - Ray direction.\n    vec3 rd = normalize(forward + FOV*u.x*right + FOV*u.y*up);\n    \n    \/\/ Swiveling the camera about the XY-plane (from left to right) when turning corners.\n    \/\/ Naturally, it's synchronized with the path in some kind of way.\n\trd.xy = rot2( path(lookAt.z).x\/96.)*rd.xy;\n    \n    \/\/ Subtle up and down tilt, or camera pitch, if you prefer.\n    \/\/rd.yz = rot2(-slope\/3.)*rd.yz;\n\t\n    \/\/ Usually, you'd just make this a unit directional light, and be done with it, but I\n    \/\/ like some of the angular subtleties of point lights, so this is a point light a\n    \/\/ long distance away. Fake, and probably not advisable, but no one will notice.\n    \/\/vec3 lp = vec3(FAR*.25, FAR*.35, FAR) + vec3(0, 0, ro.z);\n \n\n\t\/\/ Raymarching.\n    float t = trace(ro, rd);\n    \n    \/\/gT = t;\n    \/\/svObjID = objID; \/\/ Save the object ID.\n    svVobjID = vObjID;\n    \n    svObjID = svVobjID.x<svVobjID.y && svVobjID.x<svVobjID.z  && svVobjID.x<svVobjID.w? \n        \t  0. : svVobjID.y<svVobjID.z &&  svVobjID.y<svVobjID.w? \n              1.: svVobjID.z<svVobjID.w? 2. : 3.;\n    \n   \n    \/\/ Sky. Only retrieving a single color this time.\n    \/\/vec3 sky = getSky(rd);\n    \n    \/\/ The passage color. Can't remember why I set it to sky. I'm sure I had my reasons.\n    vec3 col = vec3(0);\n    \n    \/\/ Surface point. \"t\" is clamped to the maximum distance, and I'm reusing it to render\n    \/\/ the mist, so that's why it's declared in an untidy postion outside the block below...\n    \/\/ It seemed like a good idea at the time. :)\n    vec3 sp = ro+t*rd; \n    \n    float pathHeight = sp.y;\/\/surfFunc(sp);\/\/ - path(sp.z).y; \/\/ Path height line, of sorts.\n    \n    \/\/ If we've hit the ground, color it up.\n    if (t < FAR){\n    \n        \n        vec3 sn = normal(sp, 1.); \/\/ Surface normal. \/\/*(1. + t*.125)\n        \n        \/\/ Light direction vector. From the sun to the surface point. We're not performing\n        \/\/ light distance attenuation, since it'll probably have minimal effect.\n        vec3 ld = lp - sp;\n        float lDist = max(length(ld), 0.001);\n        ld \/= lDist; \/\/ Normalize the light direct vector.\n        \n        \/\/lDist \/= FAR; \/\/ Scaling down the distance to something workable for calculations.\n        lDist \/= 16.;\n        float atten = 1.\/(1. + lDist*lDist*.025);\n        \n        \n        \n        \/\/ Function based bump mapping.\n        sn = doBumpMap(sp, sn, .15);\/\/\/(1. + t*t\/FAR\/FAR*.25)\n        \n        \/\/ Texture bump mapping.\n        \/\/\n        \/\/ Texture scale factor.        \n        float tSize = 1.\/1.;\n        if(svObjID == 1.) tSize = 2.;\n        vec3 tSp = sp;\n        tSp.xy -= path(tSp.z).xy;\n        \n        float bf = .05;\n        if(svObjID == 1. || svObjID == 3.) bf = .01;\n        sn = doBumpMap(iChannel1, tSp*tSize, sn, bf);\n        \/\/ Getting picky, and hacky. With no anisotropic filtering, I need a finer grad of\n        \/\/ texture bumping on the rocks, but a wider coloring spread... It's not important. :)\n        if(svObjID == 0.) tSize \/= 2.;\n        \n        \n        \/\/ Soft shadows and occlusion.\n        float sh = softShadow(sp + sn*.002, lp, 8., t); \n        float ao = calcAO(sp, sn); \/\/ Ambient occlusion.\n        \n        \/\/ Using the curvature to darken the rock crevices a little more. It also has the effect of\n        \/\/ lightening the sharp convex edges a bit. Not sure if that's a geological thing, but I noticed\n        \/\/ that texture artists are fond of the look.\n        \/\/ spr: sample spread, amp: amplitude, offs: offset.\n\t\tfloat spr = .3, amp = .4, offs = .5;\n        float crv = curve(sp, spr, amp, offs)*.75 + .25;\n        \/\/float crv = curve(sp, spr, amp, offs);\n        \/\/crv = crv*.75 + smoothstep(1., 1.5, crv)*.5 + .125;\n        \n        \n        \n        \/\/ Add AO to the shadow. No science, but adding AO to things sometimes gives a bounced light look.\n        sh = min(sh + ao*.15, 1.); \n        \n        float dif = max( dot( ld, sn ), 0.0); \/\/ Diffuse term.\n        float spe = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 5.); \/\/ Specular term.\n        float fre = clamp(1.0 + dot(rd, sn), 0.0, 1.0); \/\/ Fresnel reflection term.\n \n        \/\/ Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        \/\/ so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        \/\/ used to give a sandstone consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.0);\n\t\tfloat fre2 = mix(.2, 1., Schlick);  \/\/F0 = .2 - Hard clay... or close enough.\n       \n        \/\/ Overal global ambience. It's made up, but I figured a little occlusion (less ambient light\n        \/\/ in the corners, etc) and reflectance would be in amongst it... Sounds good, anyway. :)\n        float amb = ao*.35;\/\/ + fre*fre2*.2;\n        \n\n        \n        \/\/ COLORING AND TEXTURING.\n        \/\/\n        \/\/ Starting with a bit of sandstone.\n        col = mix(vec3(1, .95, .7), vec3(.9, .6, .4), fBm(sp.xz*16.));\n        col = mix(col*1.4, col*.6, fBm(sp.xz*32. - .5));\/\/\/(1. + t*t*.001)\n        \n        \n        if(svObjID==0.){\n            \n            \/\/ A little extra rock shading.\n            col = vec3(1);\n            col *= mix(1.\/vec3(1, .875, .7875), vec3(1, .875, .7875)*1.2, crv);\n\n            \/\/crv = crv*.75 + .5;\n            \/\/ Cheaper version of curvature.\n            \/\/vec4 tx4 = getCylTex(tSp);\n            \/\/col *= max(tx4.a\/.66*1.35 - .1, 0.); \/\/ smoothstep(.0, .8, tx4.a);\n         }\n        \n        \n\n        \/\/ I couldn't be bothered going through the trouble to make a detailed texture like the\n        \/\/ one below, so I used the one you see below. \n        vec3 tx = tex3D(iChannel1, tSp*tSize, sn);\n        if(svObjID!=2.) col *= smoothstep(-.1, .7, tx)*2.;\n        \n        \/\/ Concreat shaft.\n        \/\/ I couldn't decide whether the shaft vents were going to be concrete or metallic,\n        \/\/ but concrete probably make more sense.\n        if(svObjID==1.) {\n             \n             col = mix(col, vec3(1)*dot(col, vec3(.299, .587, .114)), .7)*vec3(1, 1.2, 1.3)*1.6;\n        }\n        \n        \/\/ Metal grids accross the concrete shafts -- to adhere to health and safety regulations. :)\n        if(svObjID==3.){\n            col = mix(col, vec3(1)*dot(col, vec3(.299, .587, .114)), .7)*vec3(1, 1.2, 1.3);\n            \/\/dif *= pow(dif, 4.)*2.;\n        }\n        \n        \/\/ I think every person with an interest in computer graphics is a bit of a perfectionist\n        \/\/ at heart. Seeing the sharp geometric line between the sand and the rocks was irritating\n        \/\/ me to the point where I had to do something about it... Hence, this mess. :D\n        \/\/\n        \/\/ Anyway, the trick is to identify an isolinear region where two objects overlap, then \n        \/\/ blend the values. That means you're doubling up on calculations here and there, but not \n        \/\/ for too many pixels, so it shouldn't matter.\n        if(svObjID==0. || svObjID==2.){ \/\/ Probably not necessary... Call it paranoia. :D\n            \n                \n            \/\/ If the object is sand, or it's close to the rock, blend the sand\n            \/\/ into the rock.\n            if(abs(svVobjID.x - svVobjID.z)<.1 || svObjID == 2.){\n                \n                \/\/ Sand: svObjID = 2.\n                float bmp = sand(tSp.xz)\/(1. + t*t*.015);\n                bmp = mix(bmp, bumpSurf3D(sp, sn), .35);\n                vec3 col2 = mix(vec3(1, .95, .7), vec3(.9, .6, .4), fBm(tSp.xz*16.));\n                col2 = mix(col2*1.4, col*.6, fBm(tSp.xz*32. - .5))*2.\/vec3(1, .85, .7);\n                col2 = mix(col2 + (hash(floor(tSp*96.))*.7 + hash(floor(tSp*192.))*.3)*.3, col, min(t*t\/FAR, 1.));\n                col2 = mix(col2, vec3(1.5), .5);\n                col2 *= bmp*.85 + .3;\n                col2 *= vec3(1, .875, .7875);\n            \n                \/\/ Rocky walls: svObjID = 0.;\n                vec3 col0 = col;\n            \n                col = mix(col2, col0, smoothstep(0., .1, svVobjID.z - svVobjID.x));\n            }\n                \n           \n        }\n        \n        \n        \n        \/\/ The scene looked a little too bleak, so I've artificially warmed everything up. :)\n        \/\/ Comment it out, and you'll notice the difference.\n        \/\/col *= mix(1.\/vec3(1, .875, .7875), vec3(1, .875, .7875)*1.2, crv);\n        \/\/col *= vec3(1, .875, .7875);\n\n        \n        \/\/ Combining all the terms from above. Some diffuse, some specular - both of which are\n        \/\/ shadowed and occluded - plus some global ambience. Not entirely correct, but it's\n        \/\/ good enough for the purposes of this demonstation.        \n        col = col*(dif + amb + vec3(1, .97, .92)*spe*fre2*2.)*atten;\n        \n        \n        \/\/ SPOT LIGHTS.\n        \/\/\n        \/\/ More fake lighting. This was just a bit of trial-and-error to produce some repetitive,\n        \/\/ overhead spotlights eminating from the vent shafts. I came up with it in a hurry, so \n        \/\/ there'd no doubt be better ways to go about it, but for just a few lines, it's cheap\n        \/\/ and gets the point across.\n        \/\/\n        \/\/ In practical terms they're XZ \n        \/\/ cylinders repeated every 16 units. I tried to use a basis vector to tilt them in\n        \/\/ the direction of the sunlight emanating from the vents, but wasn't happy with the result... \n        \/\/ I was probably doing it wrong. Either way, this works well enough.\n        \/\/\n        \/\/ Cone-shaped sunlight eminating from the each vent... or something like that. :)\n        vec3 nTSp = vec3(tSp.xy, mod(tSp.z + 0., 16.) - 8.);\n        float spot = max(.5*max(-nTSp.y*.5 + 6., 0.) - length(nTSp.xz), 0.);\n        spot *= fBm(tSp*2. + iTime)*.5 + .75;\n        col = col*(.65 + spot); \/\/ + spot*spot*.25     \n        \n        if(svObjID == 1.){\n            \/\/ Lighting the inside of the vent. In theory, that's where the lights supposed\n            \/\/ to be coming from, but the natural setup isn't making it look that way, so\n            \/\/ this is a fudge... One of many downsides to fake physics is the fake physics\n            \/\/ domino effect. You have to add extra hacks to counter previous hacks, and so on. :)\n        \tcol += spot*col*smoothstep(0., .25, tSp.y - 2.55);\n        }\n\n \n        \/\/ Applying the shadows, ambient occlusion and faux curvature shading.\n        col *= sh*ao*crv;\n\n    }\n    \n  \n    \/\/ Combine the scene with a gradient fog color.\n    vec3 sky = getFogCol(rd);\n    \/\/col = mix(col, sky, min(t*t*1.5\/FAR\/FAR, 1.)); \/\/ Quadratic fade off. More subtle.\n    col = mix(col, sky, smoothstep(0., .95, t\/FAR)); \/\/ Linear fade. Much dustier. I kind of like it.\n    \n    \n    \/\/ Kind of interesting, but probably a little too much.    \n    \/\/col *= vec3(1.15, 1.025, .95);\n\n\n    \n    \/\/ Standard way to do a square vignette. Note that the maxium value value occurs at \"pow(0.5, 4.) = 1.\/16,\" \n    \/\/ so you multiply by 16 to give it a zero to one range. This one has been toned down with a power\n    \/\/ term to give it more subtlety.\n    \/\/u = fragCoord\/iResolution.xy;\n    \/\/col = min(col, 1.)*pow( 16.*u.x*u.y*(1. - u.x)*(1. - u.y) , .0625);\n \n    \/\/ Done.\n\tfragColor = vec4(sqrt(clamp(col, 0., 1.)), 1);\n}",
            "name": "Image",
            "description": "",
            "type": "image"
        },
        {
            "inputs": [
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dXGR8",
                    "channel": 0
                }
            ],
            "code": "\/*\n    Underground Passageway\n    ----------------------\n\n\tA simple demonstration of procedural texture construction and usage. In this case, creating \n\ta rocky surface, then mapping it onto a basic scene... I guess another way to put it would\n\tbe, yet another tunnel. :)\n\n    There's a standard technique that a lot of texture artists employ to produce rocky surfaces \n    which involves splatting a heap of beveled looking 2D shapes onto a texture using some kind \n    of blend -- like min, max, lighten, etc. The resultant heightmap is then mapped onto the 3D \n    suface as usual. If I were to explain the process in terms the average Shadertoy user would\n\tunderstand, it'd be a more sophisticated version of Voronoi.\n\n    The method is simple enough, but to get the rocks looking right, you need some large object \n    overlap. In theory, this is trivial -- Just check a wider spread of neighboring cells. Of \n    course, something like a 7x7 cell check with non standard shapes is not currently feasible \n\tin realtime, which means the only way to benefit from the technique is to precalculate the \n\tvalues once in one of the buffers then use the buffer block to texture the scene surface. \n\tThis brings with it a whole  heap of  annoyances. The worst, I feel, is having to deal with \n\ttexture wrapping. Everything needs to be wrapped -- warping, random values, overlays, scaling. \n\tSome things are prohibitively difficult to wrap, and some won't wrap at all. There are also \n\trealtime texture mapping concerns, but for basic surfaces, that's not too difficult.\n\n\tI kind of patched a lot of this together, so there'd more than likely be some repeat\n\troutines across the two tabs that I could place in the \"common\" code tab. I'll tidy it up\n\ta bit in due course.\n\n\tAnyway, this was just a simple proof of concept. The main point of this was to show that \n\tunder the right circumstances, it's possible to precalculate more complex surface details\n\tfor realtime usage.\n\t\n\n\tRelated examples:\n\n\t\/\/ I'm using some older code of mine, but Fabrice has already produced something along\n\t\/\/ these lines. I haven't had a proper look at the code, but I will when I get a chance.\n\trocks (WIP) - FabriceNeyret2 \n\thttps:\/\/www.shadertoy.com\/view\/ls3fzj\n\n\n\t\/\/ One of my favorite simple coloring jobs.\n    Skin Peeler - Dave Hoskins\n    https:\/\/www.shadertoy.com\/view\/XtfSWX\n    Based on one of my all time favorites:\n    Xyptonjtroz - Nimitz\n\thttps:\/\/www.shadertoy.com\/view\/4ts3z2\n\n*\/\n\n\n\/\/ Shorthand, so that the texture lines read a little better.\nvec4 tx(vec2 p){ return texture(iChannel0, p); }\n\n\/*\n\/\/ Screen blend.\nfloat screenBlend(vec2 va1, vec2 va2){ \n    return 1. - (1. - va1.x*va1.y)*(1. - va2.x*va2.y);\n}\n*\/\n\n\/\/ 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n\/\/ of Fabrice Neyret's \"ouside the box\" thinking. :)\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) + a);\treturn mat2(v, -v.y, v.x); }\n\n\n\/\/ vec2 to vec2 hash.\nfloat hash21(vec2 p, vec2 scale, float repScale) { \n\n    \/\/ The key to repeat procedural textures that are construct with random hash\n    \/\/ functions, which is pretty much all of them. :) Dave Hoskins has a \n    \/\/ beginner reference on here somewhere.\n    p = mod(p*scale, repScale);\n    \n    \/\/ Faster, but doesn't disperse things quite as nicely. However, when framerate\n    \/\/ is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    \/\/ amalgamation I put together, based on a couple of other random algorithms I've \n    \/\/ seen around... so use it with caution, because I make a tonne of mistakes. :)\n    return fract(sin(dot(p, vec2(57.927, 127.763)))*43758.5453);\n} \n\n#define RIGID\n\/\/ Standard 2x2 hash algorithm.\nvec2 hash22(vec2 p, vec2 scale, float repScale) {\n  \n    p = mod(p*scale, repScale);\n    \/\/ Faster, but probaly doesn't disperse things as nicely as other methods.\n    float n = sin(dot(p, vec2(1, 113)));\n    p = fract(vec2(2097152, 262144)*n);\n    #ifdef RIGID\n    return p;\n    #else\n    return cos(p*6.283 + iGlobalTime)*.5 + .5;\n    \/\/return abs(fract(p+ iGlobalTime*.25)-.5)*2. - .5; \/\/ Snooker.\n    \/\/return abs(cos(p*6.283 + iGlobalTime))*.5; \/\/ Bounce.\n    #endif\n\n}\n\n\/\/ Standard 2x2 hash algorithm.\nvec2 hash22G(vec2 p, vec2 scale, float repScale) {\n\n    p = mod(p*scale, repScale);\n    \/\/ Faster, but probaly doesn't disperse things as nicely as other methods.\n    float n = sin(dot(p, vec2(27, 57)));\n    return fract(vec2(2097152, 262144)*n)*2. - 1.;\n\n}\n\n\/\/ Gradient noise. Ken Perlin came up with it, or a version of it. Either way, this is\n\/\/ based on IQ's implementation. It's a pretty simple process: Break space into squares, \n\/\/ attach random 2D vectors to each of the square's four vertices, then smoothly \n\/\/ interpolate the space between them.\nfloat gradN2D(in vec2 f, vec2 scale, float repScale){\n  \n   f *= repScale;\n    \n    \/\/ Used as shorthand to write things like vec3(1, 0, 1) in the short form, e.yxy. \n   const vec2 e = vec2(0, 1);\n   \n    \/\/ Set up the cubic grid.\n    \/\/ Integer value - unique to each cube, and used as an ID to generate random vectors for the\n    \/\/ cube vertiies. Note that vertices shared among the cubes have the save random vectors attributed\n    \/\/ to them.\n    vec2 p = floor(f);\n    f -= p; \/\/ Fractional position within the cube.\n    \n\n    \/\/ Smoothing - for smooth interpolation. Use the last line see the difference.\n    \/\/vec2 w = f*f*f*(f*(f*6.-15.)+10.); \/\/ Quintic smoothing. Slower and more squarish, but derivatives are smooth too.\n    vec2 w = f*f*(3. - 2.*f); \/\/ Cubic smoothing. \n    \/\/vec2 w = f*f*f; w = ( 7. + (w - 7. ) * f ) * w; \/\/ Super smooth, but less practical.\n    \/\/vec2 w = .5 - .5*cos(f*3.14159); \/\/ Cosinusoidal smoothing.\n    \/\/vec2 w = f; \/\/ No smoothing. Gives a blocky appearance.\n    \n    \/\/ Smoothly interpolating between the four verticies of the square. Due to the shared vertices between\n    \/\/ grid squares, the result is blending of random values throughout the 2D space. By the way, the \"dot\" \n    \/\/ operation makes most sense visually, but isn't the only metric possible.\n    float c = mix(mix(dot(hash22G(p + e.xx, scale, repScale), f - e.xx), dot(hash22G(p + e.yx, scale, repScale), f - e.yx), w.x),\n                  mix(dot(hash22G(p + e.xy, scale, repScale), f - e.xy), dot(hash22G(p + e.yy, scale, repScale), f - e.yy), w.x), w.y);\n    \n    \/\/ Taking the final result, and converting it to the zero to one range.\n    return c*.5 + .5; \/\/ Range: [0, 1].\n}\n\n\/\/ Gradient noise fBm.\nfloat fBm(in vec2 p, vec2 scale, float repScale){\n    \n    p *= repScale;\n    return gradN2D(p, scale, repScale)*.57 + gradN2D(p, scale, repScale*2.)*.28 + gradN2D(p, scale, repScale*4.)*.15;\n    \n}\n\n\/\/ Commutative smooth maximum function. Provided by Tomkh, and taken \n\/\/ from Alex Evans's (aka Statix) talk: \n\/\/ http:\/\/media.lolrus.mediamolecule.com\/AlexEvans_SIGGRAPH-2015.pdf\n\/\/ Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n    \n   float f = max(0., 1. - abs(b - a)\/k);\n   return max(a, b) + k*.25*f*f;\n}\n\n\n\/\/ Commutative smooth minimum function. Provided by Tomkh, and taken \n\/\/ from Alex Evans's (aka Statix) talk: \n\/\/ http:\/\/media.lolrus.mediamolecule.com\/AlexEvans_SIGGRAPH-2015.pdf\n\/\/ Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)\/k);\n   return min(a, b) - k*.25*f*f;\n}\n\n\n\/*\n\/\/ Fancier rock function, but wasn't needed here.\nfloat rock(vec2 p, vec2 ip,  vec2 scale, float repScale){\n    \n    \/\/vec2 pert = vec2(gradN2D(p, vec2(1), 8.), gradN2D(p + .5, vec2(1), 8.)) - .5;\n    \/\/p += pert*.1;\n    \n    float rnd;\/\/ = hash21(ip);\n    \n    \n    vec2 q;\n    float taper = 0.;\/\/-(q.y)*2.*.5 + .5;\n    \/\/p = vec2(abs(p.x)*1.5, (p.y)*1.5 - .25)*2.; \/\/ Triangle.\n\n\n    \/\/ Slicing off more of the shape. In theory, it's more rock like, but\n    \/\/ I prefer a more geometric single tapering.\n    \/\/for(int i=0; i<6; i++){\n    \/\/    rnd = hash21(ip + float(i), scale, repScale); \/\/float(i)*.18;\/\/\n    \/\/    q = rot2(rnd*6.2831)*p;\n    \/\/    taper = max(taper, -(q.y)*2.*.75 + .25);\n    \/\/}\n \n    \n    taper = (p.y)*2.*.65 + .35;\n    \/\/taper = mix(taper, max(taper, .5), .35); \/\/ Flattening the sharp edge a bit.\n    \n    p = abs(p)*2.;\n    \n    float shape = max(p.x, p.y);\n    \/\/float shape = max(p.x*.866025 - p.y*.5, p.y);\n    \/\/float shape = max(p.x*.866025 + p.y*.5, p.y);\n    \/\/float shape = max(max(p.x, p.y), (p.x + p.y)*.7071);\n    \/\/float shape = length(p);\n    \/\/float shape = dot(p, p)*2.;\n    \n    \/\/shape = max(shape, -(shape - .75));\n    \n    \/\/return shape;\n    \/\/return max(length(p) - .1, shape);\n    return max(shape, taper);\n    \/\/return smoothstep(0., 1., max(shape, taper));\n    \n}\n*\/\n\n\/\/ You can make this up as you go along, but the idea is to render a beveled kind of \n\/\/ shape. In this case, it's a simplistic pyramid (square field) mixed with a linear \n\/\/ gradient that forms a kind of wedge shape. As you could imagine, wedges tend to work \n\/\/ well with rock layers. A lot of texture artists employ this trick. I don't know who\n\/\/ came up with the idea first, but I last came across it here:\n\/\/\n\/\/ Substance Designer - Rock Height Tips\n\/\/ Pierre FLEAU\n\/\/ https:\/\/pfleau.artstation.com\/projects\/K9AwG\nfloat rock(vec2 p){\n    \n    float taper = (p.y)*2.*.65 + .35; \/\/ Linear gradient of sorts.\n    \/\/float taper = p.y + .5; \/\/ Original.\n    \/\/taper = mix(taper, max(taper, .5), .35); \/\/ Flattening the sharp edge a bit.\n    \n    p = abs(p)*2.;\n    \/\/p = vec2(abs(p.x)*1.5, (p.y)*1.5 - .25)*2.; \/\/ Used with triangle.\n    \n    float shape = max(p.x, p.y); \/\/ Square.\n    \/\/float shape = max(p.x*.866025 - p.y*.5, p.y); \/\/ Triangle.\n    \/\/float shape = max(p.x*.866025 + p.y*.5, p.y); \/\/ Hexagon.\n    \/\/float shape = max(max(p.x, p.y), (p.x + p.y)*.7071); \/\/ Octagon.\n    \/\/float shape = length(p); \/\/ Circle.\n    \/\/float shape = dot(p, p); \/\/ Circle squared.\n    \n    \n    \/\/shape = (shape - .125)\/(1. - .125);\n    \/\/shape = smoothstep(0., 1., shape);\n    \n    \n    \/\/return shape;\n    return max(shape, taper);\n    \/\/return max(length(p) - .1, shape);\n    \n    \n}\n\n\/\/ This is similar to a Voronoi-like neighboring grid object function. Basically, you're \n\/\/ setting up a square grid, rendering an object in the grid cell, then comparing it with\n\/\/ its neighbors in some way. The rendered objects are a little more sophisticated than \n\/\/ the simple circles, squares, and so forth, but the premise is the same.\n\/\/\n\/\/ The particular function needs to render in a repetitive texture kind of way, so there's\n\/\/ wrapping to consider as well. There's grid scaling, object scaling, rotation, etc...\n\/\/ which between you and me was really annoying to code, but it's done now, so hopefully, \n\/\/ things will go more smoothly for anyone else who wishes to do this. :) In fact, I'm \n\/\/ hoping someone will make some improvents, etc, then produce some of the interesting \n\/\/ rock ground scenes that the Substance Designer people make.\nfloat splatter(in vec2 p, float repScale, vec2 overlapFactor){\n   \n    p *= repScale; \n\n   \n    \/\/ Must be factors of the repetition scale. If the repetition scale is, for example, \n    \/\/ 8, 1.5 won't work, but 2 would. Obviously, so would 1.\n    vec2 scale = vec2(.75, 1.5); \/\/ Expand X, if you want to expand the strip length below.\n    \n    vec2 pert = vec2(gradN2D(p, vec2(1), 8.), gradN2D(p + .5, vec2(1), 8.)) - .5;\n    p += pert*.125;\n\n    \n    vec2 ip = floor(p\/scale);\n    p = mod(p, scale) - scale\/2.;\n\n    \n    \n    vec3 d = vec3(4);\n    \n    vec2 dScale = overlapFactor;\n    \n    \/\/ There are 49 cell checks here... Ouch! Thankfully, this is only calculated on initiation,\n    \/\/ so it doesn't matter a great deal.\n    for(int j=-3; j<=3; j++){\n        for(int i=-3; i<=3; i++){\n\n            vec2 id = vec2(i, j);\n            vec2 q = id*scale - p;\n           \n            \/\/ Scaling. Depending on the effect you're after, you can scale X and Y by a single\n            \/\/ factor (using hash21), or with differing factors (hash22). You might even opt to\n            \/\/ have no scaling at all.\n            q *= 1. + (hash21(ip + id + 4., scale, repScale) - .5);\n            \n            \/\/ Random rotation. Again, the amount of rotation depends on the effect you're after.\n            \/\/ In this case, I wanted the rock shapes to align with one another slightly, so a\n            \/\/ factor of \".25\" was used. I also wanted the rock's sedimentary layer lines \n            \/\/ (strata, I think it's called) to line up along the tunnel walls, so rotated by an \n            \/\/ extra factor of \"pi\/2.\"\n            q = rot2((hash21(ip + id, scale, repScale) - .5)*6.2831*.25 + 3.14159\/2.)*q;\n            \n            \/\/ Offsetting each shape. Like scaling and rotation, this is optional, and the factors\n            \/\/ you use depend on what you're trying to achive.\n            q += (hash22(ip + id + 2., scale, repScale) - .5)*.5*dScale;\n            \n            \/\/ The cell object you wish to render. How you go about it entirely up to you. I've\n            \/\/ gone for a simple beveled square shape, but you can render far more sophisticated\n            \/\/ things. By the way, if you simply rendered a circular blob, the pattern produced\n            \/\/ would look a lot like regular cellular Voronoi.\n            \/\/d.z = rock(q\/dScale, ip + id, scale, repScale);\n            d.z = rock(q\/dScale);\n            \/\/d.z = smoothstep(0., 1., d); \/\/ Optional smoothing. Doesn't work here.\n            \n            \n            \n            \/\/ Obtain the first order and second order distanced -- just like regular Voronoi. \n            \/\/ By the way, a minimum blend isn't mandatory. Others blends, like screen blends,\n            \/\/ etc, are possible too.\n\t\t\td.y = max(d.x, min(d.y, d.z)); \/\/ Second order distance -- Not used here.\n            d.x = min(d.x, d.z); \n            \/\/d.x = smin(d.x, d.z, .2); \/\/ A smooth blend. Sometimes, this can be effective.\n            \/\/d.x += 1.\/pow(d.z, 4.); \/\/ Needs to be compensated for outside the loop.\n\n \n        }\n    }\n    \n    \/\/ Compensation, if using the \"c += 1.\/pow(d, 4.)\" additive blend.\n    \/\/d.x = min(2.\/pow(d.x, 1.\/4.), 1.);\n    \n    \/\/d.x = sqrt(max(d.x, 0.));\n   \n    \/\/ Reversing the return value. Depends what you're after.\n    return 1. - d.x;\n}\n\n\n\/*\n\/\/ The max value of the N(0,1) PDF (probability density function)\n\/\/ occurs at 0: 1.\/sqrt(2.*PI) = .39894;\nfloat nPDF(in float x, in float sigma){\n\n\treturn exp(-x*x\/(sigma*sigma)\/2.)\/sigma*.39894;\n}\n\n\/\/ Blur function. Actually, it can be adapted for any filter, but here it's used to \n\/\/ blur pixels. It's not being used in this instance, because the jagged rock texture\n\/\/ didn't seem to need it, but a lot of precalculated height maps do, this it's here\n\/\/ for future use.\nvec4 Blur(vec2 p) {\n    \n\n\t\/\/ Kernel matrix dimension, and a half dimension calculation.\n    const int mDim = 5, halfDim = (mDim - 1)\/2;\n\n    \/\/ You can experiment with different Laplacian related setups here. Obviously, when \n    \/\/ using the 3x3, you have to change \"mDim\" above to \"3.\" There are widely varying \n    \/\/ numerical variances as well, so that has to be considered also.\n    float kernel[mDim*mDim] = float[mDim*mDim](\n        \n    \/\/ Gaussian blur.\n    1.,  4., 7.,  4.,  1.,\n    4., 16.,  26., 16.,  4.,\n    7., 26.,  41., .26, 7.,\n    4., 16.,  26., 16.,  4.,\n    1.,  4., 7.,  4.,  1.);\n\n    \/\/\/\/ Average blur.\n    \/\/1.,  1., 1.,  1.,  1.,\n    \/\/1.,  1., 1.,  1.,  1.,\n    \/\/1.,  1., 1.,  1.,  1.,\n    \/\/1.,  1., 1.,  1.,  1.,\n    \/\/1.,  1., 1.,  1.,  1.);\n     \n    \n    \/\/ Calculating the Gaussian entries.\n    \/\/float sigma = 7.;\n    \/\/for (int j = 0; j < mDim*mDim; j++) kernel[j] = 0.;\n    \/\/int halfSize = (mDim*mDim - 1)\/2;\n    \/\/for (int j = 0; j <= halfSize; ++j){\n    \/\/    kernel[halfSize + j] = kernel[halfSize - j] = nPDF(float(j), sigma);\n    \/\/}\n \n    \n    float total = 0.;\n    \n    \/\/get the normalization factor (as the gaussian has been clamped)\n    \/\/for (int j = 0; j < mDim; j++)  total += kernel[j];\n    for (int j = 0; j < mDim*mDim; j++) total += kernel[j];\n    \n    \/\/ Initiate the color. In this example, we only want the XY values, but just\n    \/\/ in case you'd like to apply this elsewhere, I've included all four texture\n    \/\/ channnels.\n    vec4 col = vec4(0);\n    \n    \/\/ We're indexing neighboring pixels, so make this a pixel width.\n    float px = 1.\/iResolution.y; \n\n    \n    \/\/ There's a million boring ways to apply a kernal matrix to a pixel, and this \n    \/\/ is one of them. :)\n    for (int j=0; j<mDim; j++){\n        for (int i=0; i<mDim; i++){ \n            \n            col += kernel[j*mDim + i]*tx(fract(p + vec2(i - halfDim, j - halfDim)*px));\n        }\n    }\n\n\n    return col\/total;\n}\n\n*\/\n\n\n\/*\n\/\/ Nine tap blur.\nvec4 Blur9(vec2 p) {\n    \n    vec2 px = 1.\/iResolution.yy;\n    \/\/ Four spots aren't required in this case, but are when the above isn't aspect correct.\n    vec4 e = vec4(px, 0, -px.x);\n \n    \/\/ Averaging nine pixels.\n    return (tx(p - e.xy) +  tx(p - e.zy ) + tx(p - e.wy) + \/\/ First row.\n\t\t\ttx(p - e.xz) + tx(p) + tx(p + e.xz) + \t\t     \/\/ Seond row.\n\t\t\ttx(p + e.wy) + tx(p + e.zy) +  tx(p + e.xy))\/9.;  \/\/ Third row\n    \n \n}\n \n\/\/ Five tap Laplacian -- The simplest Laplacian filter... unless there's a more minimalistic one.\nvec4 Blur5(vec2 p) {\n    \n    vec3 e = vec3(1.\/iResolution.yy, 0);\n\n\treturn (tx(p - e.zy) + tx(p - e.xz) + tx(p) + tx(p + e.xz) + tx( p +  e.zy))\/5.;\n}\n\n*\/\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n     \n    vec4 col = texture(iChannel0, uv);\n \n        \n    if(iFrame<10 || abs(iResolution.x - col.x)>.001){\n        \n        \/\/ Not really necessary, but it's here anyway.\n        vec2 p = fract(uv);\n\n        \/\/vec2 olFact = vec2(1.5); \/\/ Vertical and horizontal overlap factor.\n        \/\/ If the grid itself is scaled by something like \"1.5,\" for instance, the frequency\n        \/\/ must be a multiple.\n    \n        \/\/ Four layers of varying frequencies. This is way too much work for a GPU to \n        \/\/ handle inside a distance field, and possibly a little too much to put together\n        \/\/ in realtime at fullscreen. Thankfully, this is calculated just the once...\n        \/\/ OK, technically for 10 frames at the beginning, but that's just to avoid things\n        \/\/ getting skipped on the first few frames.\n        float l1 = splatter(p - vec2(.5), 9., vec2(3., 1.5));\n        float l2 = splatter(p + vec2(.5), 12., vec2(3., 1.5));\n        float l3 = splatter(p, 15., vec2(3., 1.5));\n        float l4 = splatter(p + vec2(.5, .5), 64., vec2(1.5));\n \n        \/\/ Layer variations. I almost went with the less detailed \"min(l2, l1)\" option, but\n        \/\/ decided on the three layer version instead. By the way, if you do try some of these,\n        \/\/ be sure to reset to observe the change, or get rid of the \"if\" statement above.\n        float df = 1.;\n        \/\/df = l1;\n        \/\/df = min(l2, l1);\n        \/\/df = smin(l2, l1, .15);\n        df = min(min(l1, l2), (l3));\n        \/\/df = smin(smin(l3, l2, .15), l1, .15);\n        \/\/df = max(max(l3, l2), l1);\n        \/\/df = max(min(l3, l2), l1);\n        \/\/df = min(max(l2, l1), l3);\n        \/\/df = max(min(l2, l1), l3);\n        \/\/df = max(min(l3, l1), l2);\n        \/\/df = l1*.7 + l2*.2 + l3*.1;\n    \n        \/\/ Cracks... More thought should be put into this, but this will do for now.\n     \t\/\/float cracks = smoothstep(0., .5, min(l3, l4));\n     \tfloat cracks = smoothstep(0., .1, min(l1, l4) - .25);\n        \/\/cracks *= 1. - smoothstep(0., .1, gradN2D(uv, vec2(1, 1), 60.) - .65);\n    \n        df = mix(df, cracks, .03);\n        \/\/df *= (cracks*.1 + 1.);\n    \n        \/\/ Extra roughage.\n        df = mix(df, fBm(uv, vec2(1, 1), 16.), .05);\n    \n        \/\/ Putting the distance field value in the final channel. Two channels are used to store \n        \/\/ the resolution values, although only one is needed. With fixed sized buffers or a \n        \/\/ flag to signal a change in canvas size, this step wouldn't be necessary.\n        fragColor = vec4(iResolution.xy, 0., df);\n \n    }\n    \/*else if(iFrame<11){\n        \n\t    \/\/ Usually performed in a separate buffer. Also this doesn't account for screen changes.\n\t\t\/\/ The logic for that is simple enough, but I'm not using it here anyway.\n        \/\/col = Blur(uv);\n\t\tcol = Blur5(uv);\n        fragColor = vec4(col, 1.);\n    }*\/\n    else fragColor = col;\n    \n    \n    \n\n}",
            "name": "Buffer A",
            "description": "",
            "type": "buffer"
        }
    ]
}