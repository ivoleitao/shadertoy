{
    "ver": "0.1",
    "info": {
        "id": "wdfGW4",
        "date": "1567373566",
        "viewed": 6470,
        "name": "Descent 3D",
        "username": "mhnewman",
        "description": "I always wanted to do a 3D version of Descent - https:\/\/www.shadertoy.com\/view\/XtSGWD\nUses the same grid marching engine as Glow City - https:\/\/www.shadertoy.com\/view\/XlsyWB\n\nTry enabling BLACK_AND_WHITE or FAST_DESCENT",
        "likes": 141,
        "published": 1,
        "flags": 0,
        "usePreview": 0,
        "tags": [
            "procedural",
            "3d",
            "grid",
            "marching",
            "fog",
            "night",
            "city",
            "neon"
        ],
        "hasliked": 0
    },
    "renderpass": [
        {
            "inputs": [],
            "outputs": [
                {
                    "id": "4dfGRr",
                    "channel": 0
                }
            ],
            "code": "\/\/#define FAST_DESCENT\n\n\/\/#define BLACK_AND_WHITE\n\n\n#ifdef FAST_DESCENT\nconst vec3 cameraDir = normalize(vec3(-2.0, -1.0, -4.0));\nconst float cameraDist = 5.0;\nconst float speed = 3.0;\nconst float zoom = 2.5;\n\nconst vec3 windowColorA = vec3(0.0, 0.0, 1.5);\nconst vec3 windowColorB = vec3(0.5, 1.5, 2.0);\n\nconst float fogOffset = 2.5;\nconst float fogDensity = 0.6;\nconst vec3 fogColor = vec3(0.25, 0.0, 0.3);\n\nconst float lightHeight = 0.5;\nconst float lightSpeed = 0.2;\nconst vec3 lightColorA = vec3(0.7, 0.3, 0.1);\nconst vec3 lightColorB = vec3(1.0, 0.6, 0.3);\n\nconst vec3 signColorA = vec3(0.0, 0.0, 1.5);\nconst vec3 signColorB = vec3(3.0, 3.0, 3.0);\n#else\nconst vec3 cameraDir = normalize(vec3(-2.0, -1.0, -2.0));\nconst float cameraDist = 9.0;\nconst float speed = 1.0;\nconst float zoom = 3.5;\n\nconst vec3 windowColorA = vec3(0.0, 0.0, 1.5);\nconst vec3 windowColorB = vec3(0.5, 1.5, 2.0);\n\nconst float fogOffset = 7.0;\nconst float fogDensity = 0.7;\nconst vec3 fogColor = vec3(0.25, 0.0, 0.3);\n\nconst float lightHeight = 0.0;\nconst float lightSpeed = 0.15;\nconst vec3 lightColorA = vec3(0.7, 0.3, 0.1);\nconst vec3 lightColorB = vec3(1.0, 0.6, 0.3);\n\nconst vec3 signColorA = vec3(0.0, 0.0, 1.5);\nconst vec3 signColorB = vec3(3.0, 3.0, 3.0);\n#endif\n\nconst float tau = 6.283185;\n\n\nfloat hash1(float p) {\n    vec3 p3 = fract(p * vec3(5.3983, 5.4427, 6.9371));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash1(vec2 p2) {\n    p2 = fract(p2 * vec2(5.3983, 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n    return fract(p2.x * p2.y * 95.4337);\n}\n\nfloat hash1(vec2 p2, float p) {\n    vec3 p3 = fract(vec3(5.3983 * p2.x, 5.4427 * p2.y, 6.9371 * p));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash2(vec2 p2, float p) {\n    vec3 p3 = fract(vec3(5.3983 * p2.x, 5.4427 * p2.y, 6.9371 * p));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec3 hash3(vec2 p2) {\n    vec3 p3 = fract(vec3(p2.xyx) * vec3(5.3983, 5.4427, 6.9371));\n    p3 += dot(p3, p3.yxz + 19.19);\n    return fract((p3.xxy + p3.yzz) * p3.zyx);\n}\n\nvec4 hash4(vec2 p2) {\n    vec4 p4 = fract(p2.xyxy * vec4(5.3983, 5.4427, 6.9371, 7.1283));\n    p4 += dot(p4, p4.yxwz + 19.19);\n    return fract((p4.xxxy + p4.yyzz + p4.zwww) * p4.wzyx);\n}\n\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(hash1(i + vec2(0.0, 0.0)),\n                   hash1(i + vec2(1.0, 0.0)), u.x),\n               mix(hash1(i + vec2(0.0, 1.0)),\n                   hash1(i + vec2(1.0, 1.0)), u.x), u.y);\n}\n\nvec4 castRay(vec3 eye, vec3 ray, vec2 center) {\n    vec2 block = floor(eye.xy);\n    vec3 ri = 1.0 \/ ray;\n    vec3 rs = sign(ray);\n    vec3 side = 0.5 + 0.5 * rs;\n    vec2 ris = ri.xy * rs.xy;\n    vec2 dis = (block - eye.xy + 0.5 + rs.xy * 0.5) * ri.xy;\n\n    for (int i = 0; i < 16; ++i) {\n        float d = dot(block - center, cameraDir.xy);\n        float height = 3.0 * hash1(block) - 1.0 + 1.5 * d - 0.1 * d * d;\n\n        vec2 lo0 = vec2(block);\n        vec2 loX = vec2(0.45, 0.45);\n        vec2 hi0 = vec2(block + 0.55);\n        vec2 hiX = vec2(0.45, 0.45);\n\n        float dist = 500.0;\n        float face = 0.0;\n\n        {\n            vec4 signHash = hash4(block);\n            vec2 center = vec2(0.2, -0.4) + vec2(0.6, -0.8) * signHash.xy;\n            float width = 0.06 + 0.1 * signHash.w;\n\n            vec3 lo = vec3(center.x - width, 0.55, -100.0);\n            vec3 hi = vec3(center.x + width, 0.99, center.y + width + height);\n\n            float s = step(0.5, signHash.z);\n            lo = vec3(block, 0.0) + mix(lo, lo.yxz, s);\n            hi = vec3(block, 0.0) + mix(hi, hi.yxz, s);\n\n            vec3 wall = mix(hi, lo, side);\n            vec3 t = (wall - eye) * ri;\n\n            vec3 dim = step(t.zxy, t) * step(t.yzx, t);\n            float maxT = dot(dim, t);\n            float maxFace = dim.x - dim.y;\n\n            vec3 p = eye + maxT * ray;\n            dim += step(lo, p) * step(p, hi);\n\n            if (dim.x * dim.y * dim.z > 0.5) {\n                dist = maxT;\n                face = maxFace;\n            }\n        }\n\n        for (int j = 0; j < 5; ++j) {\n            float top = height - 0.4 * float(j);\n            vec3 lo = vec3(lo0 + loX * hash2(block, float(j)), -100.0);\n            vec3 hi = vec3(hi0 + hiX * hash2(block, float(j) + 0.5), top);\n\n            vec3 wall = mix(hi, lo, side);\n            vec3 t = (wall - eye) * ri;\n\n            vec3 dim = step(t.zxy, t) * step(t.yzx, t);\n            float maxT = dot(dim, t);\n            float maxFace = dim.x - dim.y;\n\n            vec3 p = eye + maxT * ray;\n            dim += step(lo, p) * step(p, hi);\n\n            if (dim.x * dim.y * dim.z > 0.5 && maxT < dist) {\n                dist = maxT;\n                face = maxFace;\n            }\n        }\n\n        if (dist < 400.0) {\n            return vec4(dist, height, face, 1.0);\n        }\n\n        float t = eye.z * ri.z;\n        vec3 p = eye - t * ray;\n        vec2 g = p.xy - block;\n\n        vec2 dim = step(dis.xy, dis.yx);\n        dis += dim * ris;\n        block += dim * rs.xy;\n    }\n\n    return vec4(100.0, 0.0, 0.0, 1.0);\n}\n\nvec3 window(float z, vec2 pos, vec2 id) {\n    float windowSize = 0.03 + 0.12 * hash1(id + 0.1);\n    float windowProb = 0.3 + 0.8 * hash1(id + 0.2);\n    float depth = z \/ windowSize;\n    float level = floor(depth);\n    vec3 colorA = mix(windowColorA, windowColorB, hash3(id));\n    vec3 colorB = mix(windowColorA, windowColorB, hash3(id + 0.1));\n    vec3 color = mix(colorA, colorB, hash1(id, level));\n    color *= 0.3 + 0.7 * smoothstep(0.1, 0.5, noise(20.0 * pos + 100.0 * hash1(level)));\n    color *= smoothstep(windowProb - 0.2, windowProb + 0.2, hash1(id, level + 0.1));\n    return color * (0.5 - 0.5 * cos(tau * depth));\n}\n\nvec3 addLight(vec3 eye, vec3 ray, float res, float time, float height) {\n    vec2 q = eye.xy + ((height - eye.z) \/ ray.z) * ray.xy;\n\n    float row = floor(q.x + 0.5);\n    time += hash1(row);\n    float col = floor(0.125 * q.y - time);\n\n    float pos = 0.4 + 0.4 * cos(time + tau * hash1(vec2(row, col)));\n    vec3 lightPos = vec3(row, 8.0 * (col + time + pos), height);\n    vec3 lightDir = vec3(0.0, 1.0, 0.0);\n\n    \/\/ http:\/\/geomalgorithms.com\/a07-_distance.html\n    vec3 w = eye - lightPos;\n    float a = dot(ray, ray);\n    float b = dot(ray, lightDir);\n    float c = dot(lightDir, lightDir);\n    float d = dot(ray, w);\n    float e = dot(lightDir, w);\n    float D = a * c - b * b;\n    float s = (b*e - c*d) \/ D;\n    float t = (a*e - b*d) \/ D;\n\n    t = max(t, 0.0);\n    float dist = distance(eye + s * ray, lightPos + t * lightDir);\n\n    float mask = smoothstep(res + 0.1, res, s);\n    float light = min(0.005 \/ (dist * dist \/ t + 0.1 * t * t), 2.0);\n    float fog = exp(-fogDensity * max(s - fogOffset, 0.0));\n    vec3 color = mix(lightColorA, lightColorB, hash3(vec2(row, col)));\n    return mask * light * fog * color;\n}\n\nvec3 addSign(vec3 color, vec3 pos, float side, vec2 id) {\n    vec4 signHash = hash4(id);\n    float s = step(0.5, signHash.z);\n    if ((s - 0.5) * side < 0.1)\n        return color;\n\n    vec2 center = vec2(0.2, -0.4) + vec2(0.6, -0.8) * signHash.xy;\n    vec2 p = mix(pos.xz, pos.yz, s);\n    float halfWidth = 0.04 + 0.06 * signHash.w;\n\n    float charCount = floor(1.0 + 8.0 * hash1(id + 0.5));\n    if (center.y - p.y > 2.0 * halfWidth * (charCount + 1.0)) {\n        center.y -= 2.0 * halfWidth * (charCount + 1.5 + 5.0 * hash1(id + 0.6));\n        charCount = floor(2.0 + 12.0 * hash1(id + 0.7));\n        id += 0.05;\n    }\n\n    vec3 signColor = mix(signColorA, signColorB, hash3(id + 0.5));\n    vec3 outlineColor = mix(signColorA, signColorB, hash3(id + 0.6));\n    float flash = 6.0 - 24.0 * hash1(id + 0.8);\n    flash *= step(3.0, flash);\n    flash = smoothstep(0.1, 0.5, 0.5 + 0.5 * cos(flash * iTime));\n\n    vec2 halfSize = vec2(halfWidth, halfWidth * charCount);\n    center.y -= halfSize.y;\n    float outline = length(max(abs(p - center) - halfSize, 0.0)) \/ halfWidth;\n    color *= smoothstep(0.1, 0.4, outline);\n\n    vec2 charPos = 0.5 * (p - center + halfSize) \/ halfWidth;\n    vec2 charId = id + 0.05 + 0.1 * floor(charPos);\n    float flicker = hash1(charId);\n    flicker = step(0.93, flicker);\n    flicker = 1.0 - flicker * step(0.96, hash1(charId, iTime));\n\n    float char = -3.5 + 8.0 * noise(id + 6.0 * charPos);\n    charPos = fract(charPos);\n    char *= smoothstep(0.0, 0.4, charPos.x) * smoothstep(1.0, 0.6, charPos.x);\n    char *= smoothstep(0.0, 0.4, charPos.y) * smoothstep(1.0, 0.6, charPos.y);\n    color = mix(color, signColor, flash * flicker * step(outline, 0.01) * clamp(char, 0.0, 1.0));\n\n    outline = smoothstep(0.0, 0.2, outline) * smoothstep(0.5, 0.3, outline);\n    return mix(color, outlineColor, flash * outline);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = -speed * iTime * cameraDir.xy;\n    vec3 eye = vec3(center, 0.0) - cameraDist * cameraDir;\n\n    vec3 forward = normalize(cameraDir);\n    vec3 right = normalize(cross(forward, vec3(0.0, 0.0, 1.0)));\n    vec3 up = cross(right, forward);\n    vec2 xy = 2.0 * fragCoord - iResolution.xy;\n    vec3 ray = normalize(xy.x * right + xy.y * up + zoom * forward * iResolution.y);\n\n    vec4 res = castRay(eye, ray, center);\n    vec3 p = eye + res.x * ray;\n\n    vec2 block = floor(p.xy);\n\tvec3 color = window(p.z - res.y, p.xy, block);\n\n    color = addSign(color, vec3(p.xy - block, p.z - res.y), res.z, block);\n    color = mix(vec3(0.0), color, abs(res.z));\n\n    float fog = exp(-fogDensity * max(res.x - fogOffset, 0.0));\n    color = mix(fogColor, color, fog);\n\n    float time = lightSpeed * iTime;\n    color += addLight(eye.xyz, ray.xyz, res.x, time, lightHeight - 0.6);\n    color += addLight(eye.yxz, ray.yxz, res.x, time, lightHeight - 0.4);\n    color += addLight(vec3(-eye.xy, eye.z), vec3(-ray.xy, ray.z), res.x, time, lightHeight - 0.2);\n    color += addLight(vec3(-eye.yx, eye.z), vec3(-ray.yx, ray.z), res.x, time, lightHeight);\n\n#ifdef BLACK_AND_WHITE\n    float c = dot(vec3(0.4, 0.3, 0.4), color);\n    c = 1.0 - pow(1.0 - pow(c, 2.0), 4.0);\n    color = vec3(c);\n#endif\n    \n    fragColor = vec4(color, 1.0);\n}\n\n",
            "name": "Image",
            "description": "",
            "type": "image"
        }
    ]
}