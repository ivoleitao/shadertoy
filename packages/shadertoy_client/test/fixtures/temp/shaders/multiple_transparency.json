{
    "ver": "0.1",
    "info": {
        "id": "XtyGWD",
        "date": "1474559035",
        "viewed": 7411,
        "name": "Multiple Transparency",
        "username": "P_Malin",
        "description": "Transparency experiment - manually using a stack to handle ray recursion.\n(works in VR mode)\n",
        "likes": 122,
        "published": 3,
        "flags": 33,
        "tags": [
            "transparency",
            "raymarch"
        ],
        "hasliked": 0
    },
    "renderpass": [
        {
            "inputs": [
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "nearest",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dfGRr",
                    "channel": 0
                }
            ],
            "code": "\/\/ Multiple Transparency - @P_Malin\n\/\/ @P_Malin\n\n\nvec3 Tonemap( vec3 x )\n{\n    float a = 0.010;\n    float b = 0.132;\n    float c = 0.010;\n    float d = 0.163;\n    float e = 0.101;\n\n    return ( x * ( a * x + b ) ) \/ ( x * ( c * x + d ) + e );\n}\n\nvec3 ColorGrade( vec3 vColor )\n{\n    vec3 vHue = vec3(1.0, .7, .2);\n    \n    vec3 vGamma = 1.0 + vHue * 0.6;\n    vec3 vGain = vec3(.9) + vHue * vHue * 8.0;\n    \n    vColor *= 2.0;\n    \n    float fMaxLum = 100.0;\n    vColor \/= fMaxLum;\n    vColor = pow( vColor, vGamma );\n    vColor *= vGain;\n    vColor *= fMaxLum;  \n    return vColor;\n}\n\n\/\/ Depth of field pass\n\n#define BLUR_TAPS 32\n\nfloat fGolden = 3.141592 * (3.0 - sqrt(5.0));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vUV = fragCoord.xy \/ iResolution.xy;\n\n    vec4 vSample = textureLod( iChannel0, vUV, 0.0 ).rgba;\n\tfloat fCoC = vSample.w;\n    \t\n\tvec3 vResult = vSample.rgb;\n    float fTot = 0.0;\n        \n    vec2 vangle = vec2(0.0, fCoC); \/\/ Start angle\n    \n    if ( abs(fCoC) > 0.0 )\n    {\n        vResult.rgb  *= fCoC;\n        fTot += fCoC;\n\n        float fBlurTaps = float(BLUR_TAPS);\n\n        for(int i=1; i<BLUR_TAPS; i++)\n        {\n            \/\/ http:\/\/blog.marmakoide.org\/?p=1\n            float t = float(i) \/ fBlurTaps;\n            float fTheta = t * fBlurTaps * fGolden;\n            float fRadius = fCoC * sqrt( t * fBlurTaps ) \/ sqrt( fBlurTaps );        \n\n            vec2 vTapUV = vUV + vec2( sin(fTheta), cos(fTheta) ) * fRadius;\n\n            vec4 vTapSample = textureLod( iChannel0, vTapUV, 0.0 ).rgba;\n            {\n                float fCoC2 = vTapSample.w;\n                float fWeight = max( 0.001, fCoC2 );\n\n                vResult += vTapSample.rgb * fWeight;\n                fTot += fWeight;\n            }\n        }\n        vResult \/= fTot;\n    }\n        \n\tfragColor = vec4(vResult, 1.0);    \n    \n    float fExposure = 3.0;    \n    \n    fragColor.rgb = fragColor.rgb * fExposure;\n    \n    fragColor.rgb = ColorGrade( fragColor.rgb );\n        \n    fragColor.rgb = Tonemap( fragColor.rgb );\n}",
            "name": "Image",
            "description": "",
            "type": "image"
        },
        {
            "inputs": [
                {
                    "id": "4sfGRn",
                    "filepath": "\/media\/a\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg",
                    "previewfilepath": "\/media\/ap\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg",
                    "type": "texture",
                    "channel": 3,
                    "sampler": {
                        "filter": "mipmap",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "XdX3zn",
                    "filepath": "\/media\/a\/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg",
                    "previewfilepath": "\/media\/ap\/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg",
                    "type": "cubemap",
                    "channel": 1,
                    "sampler": {
                        "filter": "mipmap",
                        "wrap": "clamp",
                        "vflip": "false",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "4df3Rr",
                    "filepath": "\/media\/a\/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg",
                    "previewfilepath": "\/media\/ap\/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg",
                    "type": "texture",
                    "channel": 2,
                    "sampler": {
                        "filter": "mipmap",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "nearest",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dXGR8",
                    "channel": 0
                }
            ],
            "code": "\/\/ Multiple Transparency - @P_Malin\n\n\/\/ Transparency experiment - manually using a stack to handle ray recursion.\n\n\n\/\/ Scene Render\n\n#define kMaxTraceDist 1000.0\n#define kFarDist 1100.0\n\n#define MAT_FG_BEGIN \t10\n\n#define PI 3.141592654\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Data Storage\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec4 LoadVec4( sampler2D sampler, in vec2 vAddr )\n{\n    return texelFetch( sampler, ivec2(vAddr), 0 );\n}\n\nvec3 LoadVec3( sampler2D sampler, in vec2 vAddr )\n{\n    return LoadVec4( sampler, vAddr ).xyz;\n}\n\nbool AtAddress( vec2 p, vec2 c ) { return all( equal( floor(p), floor(c) ) ); }\n\nvoid StoreVec4( in vec2 vAddr, in vec4 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = AtAddress( fragCoord, vAddr ) ? vValue : fragColor;\n}\n\nvoid StoreVec3( in vec2 vAddr, in vec3 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec4( vAddr, vec4( vValue, 0.0 ), fragColor, fragCoord);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Camera\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nstruct CameraState\n{\n    vec3 vPos;\n    vec3 vTarget;\n    float fFov;\n};\n    \nvoid Cam_LoadState( out CameraState cam, sampler2D sampler, vec2 addr )\n{\n    vec4 vPos = LoadVec4( sampler, addr + vec2(0,0) );\n    cam.vPos = vPos.xyz;\n    vec4 targetFov = LoadVec4( sampler, addr + vec2(1,0) );\n    cam.vTarget = targetFov.xyz;\n    cam.fFov = targetFov.w;\n}\n\nvoid Cam_StoreState( vec2 addr, const in CameraState cam, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec4( addr + vec2(0,0), vec4( cam.vPos, 0 ), fragColor, fragCoord );\n    StoreVec4( addr + vec2(1,0), vec4( cam.vTarget, cam.fFov ), fragColor, fragCoord );    \n}\n\nmat3 Cam_GetWorldToCameraRotMatrix( const CameraState cameraState )\n{\n    vec3 vForward = normalize( cameraState.vTarget - cameraState.vPos );\n\tvec3 vRight = normalize( cross(vec3(0, 1, 0), vForward) );\n\tvec3 vUp = normalize( cross(vForward, vRight) );\n    \n    return mat3( vRight, vUp, vForward );\n}\n\nvec2 Cam_GetViewCoordFromUV( const in vec2 vUV )\n{\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= iResolution.x \/ iResolution.y;\n\n\treturn vWindow;\t\n}\n\nvoid Cam_GetCameraRay( const vec2 vUV, const CameraState cam, out vec3 vRayOrigin, out vec3 vRayDir )\n{\n    vec2 vView = Cam_GetViewCoordFromUV( vUV );\n    vRayOrigin = cam.vPos;\n    float fPerspDist = 1.0 \/ tan( radians( cam.fFov ) );\n    vRayDir = normalize( Cam_GetWorldToCameraRotMatrix( cam ) * vec3( vView, fPerspDist ) );\n}\n\nvec2 Cam_GetUVFromWindowCoord( const in vec2 vWindow )\n{\n    vec2 vScaledWindow = vWindow;\n    vScaledWindow.x *= iResolution.y \/ iResolution.x;\n\n    return vScaledWindow * 0.5 + 0.5;\n}\n\nvec2 Cam_WorldToWindowCoord(const in vec3 vWorldPos, const in CameraState cameraState )\n{\n    vec3 vOffset = vWorldPos - cameraState.vPos;\n    vec3 vCameraLocal;\n\n    vCameraLocal = vOffset * Cam_GetWorldToCameraRotMatrix( cameraState );\n\t\n    vec2 vWindowPos = vCameraLocal.xy \/ (vCameraLocal.z * tan( radians( cameraState.fFov ) ));\n    \n    return vWindowPos;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Scene\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nstruct SceneResult\n{\n\tfloat fDist;\n\tint iObjectId;\n    vec3 vUVW;\n};\n    \nvoid Scene_Union( inout SceneResult a, const in SceneResult b )\n{\n    if ( b.fDist < a.fDist )\n    {\n        a = b;\n    }\n}\n\n    \nvoid Scene_Trim( inout SceneResult a, const in SceneResult b )\n{\n    if ( a.fDist < -b.fDist )\n    {\n        a.fDist = -b.fDist;\n    }\n}\n\nSceneResult Scene_GetDistance( const vec3 vPos, const int iInsideObject );    \n\nvec3 Scene_GetNormal(const in vec3 vPos, const int iInsideObject)\n{\n    const float fDelta = 0.001;\n    vec2 e = vec2( -1, 1 );\n    \n    vec3 vNormal = \n        Scene_GetDistance( vPos + e.yxx * fDelta, iInsideObject ).fDist * e.yxx + \n        Scene_GetDistance( vPos + e.xxy * fDelta, iInsideObject ).fDist * e.xxy + \n        Scene_GetDistance( vPos + e.xyx * fDelta, iInsideObject ).fDist * e.xyx + \n        Scene_GetDistance( vPos + e.yyy * fDelta, iInsideObject ).fDist * e.yyy;\n    \n    if ( dot( vNormal, vNormal ) < 0.00001 )\n    {\n        return vec3(0, 1, 0);\n    }\n    \n    return normalize( vNormal );\n}    \n    \nSceneResult Scene_Trace( const in vec3 vRayOrigin, const in vec3 vRayDir, float minDist, float maxDist, int iInsideObject )\n{\t\n    SceneResult result;\n    result.fDist = 0.0;\n    result.vUVW = vec3(0.0);\n    result.iObjectId = -1;\n    \n\tfloat t = minDist;\n\tconst int kRaymarchMaxIter = 96;\n\tfor(int i=0; i<kRaymarchMaxIter; i++)\n\t{\t\t\n\t\tresult = Scene_GetDistance( vRayOrigin + vRayDir * t, iInsideObject );\n        t += result.fDist;\n\n        if ( abs(result.fDist) < 0.001 )\n\t\t{\n\t\t\tbreak;\n\t\t}\t\t\n\n        if ( ( iInsideObject == -1 ) && (abs(result.fDist) > 0.1) )\n        {\n            result.iObjectId = -1;\n        }\n        \n        if ( t > maxDist )\n        {\n            result.iObjectId = -1;\n\t        t = maxDist;\n            break;\n        }        \n\t}\n    \n    result.fDist = t;\n\n\n    return result;\n}    \n\nfloat Scene_TraceShadow( const in vec3 vRayOrigin, const in vec3 vRayDir, const in float fMinDist, const in float fLightDist )\n{\n    \/\/return 1.0;\n    \/\/return ( Scene_Trace( vRayOrigin, vRayDir, 0.1, fLightDist ).fDist < fLightDist ? 0.0 : 1.0;\n    \n\tfloat res = 1.0;\n    float t = fMinDist;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = Scene_GetDistance( vRayOrigin + vRayDir * t, -1 ).fDist;\n        res = min( res, 8.0*h\/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.0001 || t>fLightDist ) break;\n    }\n    return clamp( res, 0.0, 1.0 );    \n}\n\nfloat Scene_GetAmbientOcclusion( const in vec3 vPos, const in vec3 vDir )\n{\n    float fOcclusion = 0.0;\n    float fScale = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float fOffsetDist = 0.01 + 1.0*float(i)\/4.0;\n        vec3 vAOPos = vDir * fOffsetDist + vPos;\n        float fDist = Scene_GetDistance( vAOPos, -1 ).fDist;\n        fOcclusion += (fOffsetDist - fDist) * fScale;\n        fScale *= 0.4;\n    }\n    \n    return clamp( 1.0 - 2.0*fOcclusion, 0.0, 1.0 );\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Lighting\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \nstruct SurfaceInfo\n{\n    vec3 vPos;\n    vec3 vNormal;\n    vec3 vBumpNormal;    \n    vec3 vAlbedo;\n    vec3 vR0;\n    float fSmoothness;\n    vec3 vEmissive;\n   \tfloat fTransparency;\n    float fRefractiveIndex;\n};\n    \nSurfaceInfo Scene_GetSurfaceInfo( const in vec3 vRayOrigin,  const in vec3 vRayDir, SceneResult traceResult, int iInsideObject );\n\nstruct SurfaceLighting\n{\n    vec3 vDiffuse;\n    vec3 vSpecular;\n};\n    \nSurfaceLighting Scene_GetSurfaceLighting( const in vec3 vRayDir, in SurfaceInfo surfaceInfo );\n\nfloat Light_GIV( float dotNV, float k)\n{\n\treturn 1.0 \/ ((dotNV + 0.0001) * (1.0 - k)+k);\n}\n\nvoid Light_Add(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\n\tfloat fNDotL = clamp(dot(vLightDir, surface.vBumpNormal), 0.0, 1.0);\n\t\n\tlighting.vDiffuse += vLightColour * fNDotL;\n    \n\tvec3 vH = normalize( -vViewDir + vLightDir );\n\tfloat fNdotV = clamp(dot(-vViewDir, surface.vBumpNormal), 0.0, 1.0);\n\tfloat fNdotH = clamp(dot(surface.vBumpNormal, vH), 0.0, 1.0);\n    \n\tfloat alpha = 1.0 - surface.fSmoothness;\n\t\/\/ D\n\n\tfloat alphaSqr = alpha * alpha;\n\tfloat denom = fNdotH * fNdotH * (alphaSqr - 1.0) + 1.0;\n\tfloat d = alphaSqr \/ (PI * denom * denom);\n\n\tfloat k = alpha \/ 2.0;\n\tfloat vis = Light_GIV(fNDotL, k) * Light_GIV(fNdotV, k);\n\n\tfloat fSpecularIntensity = d * vis * fNDotL;    \n\tlighting.vSpecular += vLightColour * fSpecularIntensity;    \n}\n\nvoid Light_AddPoint(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightPos, const in vec3 vLightColour)\n{    \n    vec3 vPos = surface.vPos;\n\tvec3 vToLight = vLightPos - vPos;\t\n    \n\tvec3 vLightDir = normalize(vToLight);\n\tfloat fDistance2 = dot(vToLight, vToLight);\n\tfloat fAttenuation = 100.0 \/ (fDistance2);\n\t\n\tfloat fShadowFactor = Scene_TraceShadow( surface.vPos, vLightDir, 0.1, length(vToLight) );\n\t\n\tLight_Add( lighting, surface, vViewDir, vLightDir, vLightColour * fShadowFactor * fAttenuation);\n}\n\nvoid Light_AddDirectional(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\t\n\tfloat fAttenuation = 1.0;\n\tfloat fShadowFactor = Scene_TraceShadow( surface.vPos, vLightDir, 0.1, 10.0 );\n\t\n\tLight_Add( lighting, surface, vViewDir, vLightDir, vLightColour * fShadowFactor * fAttenuation);\n}\n\nvec3 Light_GetFresnel( vec3 vView, vec3 vNormal, vec3 vR0, float fGloss )\n{\n    float NdotV = max( 0.0, dot( vView, vNormal ) );\n\n    return vR0 + (vec3(1.0) - vR0) * pow( 1.0 - NdotV, 5.0 ) * pow( fGloss, 20.0 );\n}\n\nvoid Env_AddPointLightFlare(inout vec3 vEmissiveGlow, const in vec3 vRayOrigin, const in vec3 vRayDir, const in float fIntersectDistance, const in vec3 vLightPos, const in vec3 vLightColour)\n{\n    vec3 vToLight = vLightPos - vRayOrigin;\n    float fPointDot = dot(vToLight, vRayDir);\n    fPointDot = clamp(fPointDot, 0.0, fIntersectDistance);\n\n    vec3 vClosestPoint = vRayOrigin + vRayDir * fPointDot;\n    float fDist = length(vClosestPoint - vLightPos);\n\tvEmissiveGlow += sqrt(vLightColour * 0.05 \/ (fDist * fDist));\n}\n\nvoid Env_AddDirectionalLightFlareToFog(inout vec3 vFogColour, const in vec3 vRayDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\n\tfloat fDirDot = clamp(dot(vLightDir, vRayDir) * 0.5 + 0.5, 0.0, 1.0);\n\tfloat kSpreadPower = 2.0;\n\tvFogColour += vLightColour * pow(fDirDot, kSpreadPower) * 0.25;\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Rendering\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec4 Env_GetSkyColor( const vec3 vViewPos, const vec3 vViewDir );\nvec3 Env_ApplyAtmosphere( const in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist, const int iInsideObject );\nvec3 FX_Apply( in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist);\n\nstruct RayInfo\n{\n    vec3 vRayOrigin;\n    vec3 vRayDir;\n    float fStartDist;\n    float fLengthRemaining;\n    \n    float fRefractiveIndex;\n    \n    int iObjectId;\n    float fDist;\n    vec3 vColor;\n    vec3 vAmount;\n    \n    int iChild0;\n    int iChild1;\n};\n    \n#define RAY_STACK_SIZE 12\n\nRayInfo rayStack[RAY_STACK_SIZE];\n\nvoid RayInfo_Clear( inout RayInfo rayInfo )\n{\n    rayInfo = RayInfo( vec3(0), vec3(0), 0., -1., 1.0, -1, 0., vec3(0), vec3(1), -1, -1 );\n}\n\nvoid RayStack_Reset()\n{\n    for ( int i=0; i<RAY_STACK_SIZE; i++)\n    {\n\t    RayInfo_Clear( rayStack[i] );\n    }\n}\n\nRayInfo RayStack_Get( int index )\n{\n\treturn rayStack[index];\n    \/\/if ( index < RAY_STACK_SIZE )\n    \/\/{\n\t\/\/\treturn rayStack[index];\n    \/\/}\n    \/\/\n    \/\/RayInfo result;\n    \/\/RayInfo_Clear( result );\n    \/\/return result;\n}\n\nvoid RayStack_Set( int index, RayInfo rayInfo )\n{\n    rayStack[index] = rayInfo;\n}\n\nvec4 Scene_GetColorAndDepth( const in vec3 vInRayOrigin, const in vec3 vInRayDir )\n{\n\tvec3 vResultColor = vec3(0.0);\n            \n\tSceneResult firstTraceResult;\n    \n    int stackCurrent = 0;\n    int stackEnd = 1;\n    \n    RayStack_Reset();\n        \n    rayStack[0].vRayOrigin = vInRayOrigin;\n    rayStack[0].vRayDir = vInRayDir;\n    rayStack[0].fStartDist = 0.0;\n    rayStack[0].fLengthRemaining = kMaxTraceDist;\n    rayStack[0].fRefractiveIndex = 1.0;\n    rayStack[0].vAmount = vec3(1.0);\n    rayStack[0].iChild0 = -1;\n    rayStack[0].iChild1 = -1;       \n           \n\tfor( int iPassIndex=0; iPassIndex < RAY_STACK_SIZE; iPassIndex++ )\n\t{\t                \n        if ( stackCurrent >= RAY_STACK_SIZE )\n            break;\n        \n        RayInfo rayInfo = RayStack_Get( stackCurrent );\n        \n        if ( rayInfo.fLengthRemaining <= 0.0 )\n            continue;\n        \n        rayInfo.iChild0 = -1;\n        rayInfo.iChild1 = -1;\n        \n    \tSceneResult traceResult = Scene_Trace( rayInfo.vRayOrigin, rayInfo.vRayDir, rayInfo.fStartDist, rayInfo.fLengthRemaining, rayInfo.iObjectId );\n        \n        rayInfo.fDist = traceResult.fDist;\n        \n        \/\/if ( iPassIndex == 0 )\n        \/\/{\n          \/\/  firstTraceResult = traceResult;\n        \/\/}\n        \n\t\trayInfo.vColor = vec3(0.0);\n\t\tvec3 vReflectance = vec3(1.0);\n\n\t\tif( traceResult.iObjectId < 0 )\n\t\t{\n            rayInfo.vColor = Env_GetSkyColor( rayInfo.vRayOrigin, rayInfo.vRayDir ).rgb;\n        }\n        else\n        {\n            SurfaceInfo surfaceInfo = Scene_GetSurfaceInfo( rayInfo.vRayOrigin, rayInfo.vRayDir, traceResult, rayInfo.iObjectId );\n            SurfaceLighting surfaceLighting = Scene_GetSurfaceLighting( rayInfo.vRayDir, surfaceInfo );\n                \n            \/\/ calculate reflectance (Fresnel)\n            float NdotV = clamp( dot(surfaceInfo.vBumpNormal, -rayInfo.vRayDir ), 0.0, 1.0);\n\t\t\tvReflectance = Light_GetFresnel( -rayInfo.vRayDir, surfaceInfo.vBumpNormal, surfaceInfo.vR0, surfaceInfo.fSmoothness );\n\t\t\t\n\t\t\trayInfo.vColor = (surfaceInfo.vAlbedo * surfaceLighting.vDiffuse + surfaceInfo.vEmissive) * (vec3(1.0) - vReflectance); \n            \n\t\t\tvec3 vReflectAmount = vReflectance;                \n            vec3 vTranmitAmount = vec3(1.0) - vReflectance;\n            vTranmitAmount *= surfaceInfo.fTransparency;\n            \n            bool doReflection = true;\n            \n            \/\/ superhack\n            \/\/if ( false )\n            if ( surfaceInfo.fTransparency > 0.0 )\n            {                \n                vec3 vTestAmount = vTranmitAmount * rayInfo.vAmount;\n                \n                if ( (vTestAmount.x + vTestAmount.y + vTestAmount.z) > 0.01 )\n                {\n                    RayInfo refractRayInfo;\n\n                    refractRayInfo.vAmount = vTranmitAmount;\n                    refractRayInfo.vRayOrigin = surfaceInfo.vPos;\n                    refractRayInfo.iObjectId = traceResult.iObjectId;\n                                        \n\t\t\t\t\trefractRayInfo.vRayDir = refract( rayInfo.vRayDir, surfaceInfo.vBumpNormal, rayInfo.fRefractiveIndex \/ surfaceInfo.fRefractiveIndex );\n                    if ( traceResult.iObjectId == rayInfo.iObjectId )\n                    {\n                        refractRayInfo.iObjectId = -1;\n                    }                    \n                    \/*\n                    if ( (rayInfo.fObjectId != -1.) && (traceResult.fObjectId == rayInfo.fObjectId) )\n                    {\n                        refractRayInfo.fObjectId = -1.;\n                        refractRayInfo.vRayDir = refract( rayInfo.vRayDir, surfaceInfo.vBumpNormal, surfaceInfo.fRefractiveIndex );\n                    }\n                    else\n                    {\n                        refractRayInfo.vRayDir = refract( rayInfo.vRayDir, surfaceInfo.vBumpNormal, 1.0 \/ surfaceInfo.fRefractiveIndex );\n                    }*\/\n                    \n                    if ( length( refractRayInfo.vRayDir ) > 0.0 )\n                    {\n                        refractRayInfo.vRayDir = normalize(refractRayInfo.vRayDir);\n                        \/\/refractRayInfo.vRayDir.xz *= -1.0;\n                        refractRayInfo.fStartDist = abs(0.1 \/ dot( refractRayInfo.vRayDir, surfaceInfo.vNormal ));            \n                        refractRayInfo.fLengthRemaining = rayInfo.fLengthRemaining - traceResult.fDist;                \n                        refractRayInfo.fDist = 1.0 - rayInfo.fDist;\n                        refractRayInfo.fRefractiveIndex = surfaceInfo.fRefractiveIndex;\n\n                        rayInfo.iChild1 = stackEnd;\n\n                        \/\/if ( stackEnd < RAY_STACK_SIZE )\n                        {\n                            rayInfo.vColor *= 1.0 - surfaceInfo.fTransparency;        \n                            refractRayInfo.vAmount *= surfaceInfo.fTransparency;\n                        }\n                        RayStack_Set( stackEnd, refractRayInfo );                        \n                        stackEnd++;\n                        \n                        doReflection = false;\n                    }\n                    else\n                    {\n                        vReflectAmount += vTranmitAmount;\n                    }\n                }\n            }\n                        \n            \/\/ Reflect Ray\n            if ( doReflection )\n            {\n                vec3 vTestAmount = vReflectAmount * rayInfo.vAmount;\n                \n                if ( (vTestAmount.x + vTestAmount.y + vTestAmount.z) > 0.01 )\n                {                \n                    RayInfo reflectRayInfo;\n\n                    reflectRayInfo.vAmount = vReflectAmount;\n                    reflectRayInfo.vRayOrigin = surfaceInfo.vPos;\n                    reflectRayInfo.vRayDir = normalize( reflect( rayInfo.vRayDir, surfaceInfo.vBumpNormal ) );\n                    reflectRayInfo.iObjectId = rayInfo.iObjectId;\n                    reflectRayInfo.fStartDist = abs(0.01 \/ dot( reflectRayInfo.vRayDir, surfaceInfo.vNormal ));            \n                    reflectRayInfo.fLengthRemaining = rayInfo.fLengthRemaining - traceResult.fDist;                \n                    reflectRayInfo.fRefractiveIndex = rayInfo.fRefractiveIndex;\n\n                    rayInfo.iChild0 = stackEnd;\n\n                    RayStack_Set( stackEnd, reflectRayInfo );\n                    stackEnd++;\n                }\n            }\n            \n            rayInfo.vColor += surfaceLighting.vSpecular * vReflectance;            \n        }\n        \n\t\tRayStack_Set( stackCurrent, rayInfo );\n                \n        stackCurrent++;\n    }\n        \n\tfor( int iStackPos=(RAY_STACK_SIZE-1); iStackPos >= 0; iStackPos-- )\n\t{\t    \n        RayInfo rayInfo = RayStack_Get( iStackPos );\n\n        if ( rayInfo.fLengthRemaining <= 0.0 )\n            continue;\n\n        \/\/ Accumulate colors from child rays\n        \n        if ( rayInfo.iChild0 >= 0 )\n        {\n\t        RayInfo childRayInfo = RayStack_Get( rayInfo.iChild0 );\n            if ( childRayInfo.fDist > 0.0 )\n            {\n            \trayInfo.vColor += childRayInfo.vAmount * childRayInfo.vColor;\n            }\n        }\n\n        if ( rayInfo.iChild1 >= 0 )\n        {\n\t        RayInfo childRayInfo = RayStack_Get( rayInfo.iChild1 );\n            if ( childRayInfo.fDist > 0.0 )\n            {\n\t            rayInfo.vColor += childRayInfo.vAmount * childRayInfo.vColor;\n            }\n        }\n        \n\t\trayInfo.vColor = Env_ApplyAtmosphere( rayInfo.vColor, rayInfo.vRayOrigin, rayInfo.vRayDir, rayInfo.fDist, rayInfo.iObjectId );\n\t\trayInfo.vColor = FX_Apply( rayInfo.vColor, rayInfo.vRayOrigin, rayInfo.vRayDir, rayInfo.fDist );\n            \n\t\tRayStack_Set( iStackPos, rayInfo );        \n    }    \n    \n    if ( firstTraceResult.iObjectId >= MAT_FG_BEGIN )\n    {\n        firstTraceResult.fDist = -firstTraceResult.fDist;\n    }\n        \n    return vec4( rayStack[0].vColor, rayStack[0].fDist );\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Utility Functions\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Scene Description\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ Materials\n\n#define MAT_SKY\t\t \t-1\n#define MAT_DEFAULT \t0\n#define MAT_GLASS\t \t1\n#define MAT_WINE\t \t2\n#define MAT_STEEL\t \t3\n#define MAT_GLOSS_PAINT\t 4\n\n\nSurfaceInfo Scene_GetSurfaceInfo( const in vec3 vRayOrigin,  const in vec3 vRayDir, SceneResult traceResult, int iInsideObject )\n{\n    SurfaceInfo surfaceInfo;\n    \n    surfaceInfo.vPos = vRayOrigin + vRayDir * (traceResult.fDist);\n    \n    surfaceInfo.vNormal = Scene_GetNormal( surfaceInfo.vPos, iInsideObject ); \n    surfaceInfo.vBumpNormal = surfaceInfo.vNormal;\n    surfaceInfo.vAlbedo = vec3(1.0);\n    surfaceInfo.vR0 = vec3( 0.01 );\n    surfaceInfo.fSmoothness = 1.0;\n    surfaceInfo.vEmissive = vec3( 0.0 );\n    \n    surfaceInfo.fTransparency = 0.0;\n    surfaceInfo.fRefractiveIndex = 1.0;\n        \n    if ( traceResult.iObjectId == MAT_DEFAULT )\n    {\n    \tsurfaceInfo.vR0 = vec3( 0.02 );\n\t    surfaceInfo.vAlbedo = textureLod( iChannel2, traceResult.vUVW.xz * 0.5, 0.0 ).rgb;\n        surfaceInfo.vAlbedo = surfaceInfo.vAlbedo * surfaceInfo.vAlbedo;\n                        \n    \tsurfaceInfo.fSmoothness = clamp( 1.0 - surfaceInfo.vAlbedo.r * surfaceInfo.vAlbedo.r * 2.0, 0.0, 1.0);\n        \n        surfaceInfo.vAlbedo *= 0.25;\n        \n        \/*surfaceInfo.vBumpNormal.x += surfaceInfo.vAlbedo.r;\n        surfaceInfo.vBumpNormal.z += surfaceInfo.vAlbedo.g;\n        surfaceInfo.vAlbedo = mix( vec3(0,.1,0), vec3(0.1, 0.8, 0.2), surfaceInfo.vAlbedo);\n        surfaceInfo.fSmoothness = 0.0;*\/\n        \n        \/\/surfaceInfo.vR0 = vec3(clamp(surfaceInfo.vAlbedo.r - surfaceInfo.vPos.x, 0.0, 1.0));\n        \n        float fDist = length( surfaceInfo.vPos.xz );\n        \n        float fCheckerAmount = clamp( 1.0 - fDist * 0.1 + surfaceInfo.vAlbedo.r * 0.5, 0.0, 1.0);\n        \n        vec3 vChecker;\n        float fChecker = step(fract((floor(traceResult.vUVW.x) + floor(traceResult.vUVW.z)) * 0.5), 0.25);\n        if ( fChecker > 0.0 )\n        {\n            vChecker = vec3(1.0);\n        }\n        else\n        {\n            vChecker = vec3(0.1);\n        }\n                \n        surfaceInfo.vAlbedo = mix(surfaceInfo.vAlbedo, vChecker, fCheckerAmount);\n        surfaceInfo.vR0 = mix(surfaceInfo.vR0, vec3(0.1), fCheckerAmount);\n        surfaceInfo.fSmoothness =  mix(surfaceInfo.fSmoothness, 1.0, fCheckerAmount);\n        \n    }\n\n  \/*  if ( traceResult.fObjectId == MAT_STEEL )\n    {\n\t    surfaceInfo.vAlbedo = texture( iChannel2, traceResult.vUVW.xz ).rgb;\n        surfaceInfo.vAlbedo = surfaceInfo.vAlbedo * surfaceInfo.vAlbedo;\n        \n    \tsurfaceInfo.fSmoothness = surfaceInfo.vAlbedo.r;\/\/clamp( surfaceInfo.vAlbedo.r, 0.0, 1.0);                \n        \n        surfaceInfo.vAlbedo = surfaceInfo.vAlbedo * 0.5;\n                        \n    \tsurfaceInfo.vR0 = vec3( surfaceInfo.vAlbedo.r * surfaceInfo.vAlbedo.r * 0.8 );\n\n        vec3 vDirt = texture( iChannel3, traceResult.vUVW.xz ).rgb;\n        vDirt = vDirt * vDirt;\n        surfaceInfo.vAlbedo = vDirt * ( 1.0 - surfaceInfo.vAlbedo.r) * 0.1;\/\/mix( surfaceInfo.vAlbedo, vDirt, 1.0 - surfaceInfo.vAlbedo.r );\n        \n    }*\/\n    \n    if ( traceResult.iObjectId == MAT_GLOSS_PAINT )\n    {\n        \/\/float fChecker = step(fract((floor(traceResult.vUVW.x) + floor(traceResult.vUVW.z)) * 0.5), 0.25);\n        float fStripe = step( fract( dot( traceResult.vUVW * 5.0, vec3(1.0, 0.2, 0.4) ) ), 0.5 );\n        if ( fStripe > 0.0 )\n        {\n\t        surfaceInfo.vAlbedo = vec3(0.1, 0.05, 1.0);\n        }\n        else\n        {\n\t        surfaceInfo.vAlbedo = vec3(1.0, 0.05, 0.1);\n        }        \n    }\n    \n    \n    if ( traceResult.iObjectId == MAT_GLASS )\n    {\n    \tsurfaceInfo.vR0 = vec3( 0.02 );\n\n        vec3 vAlbedo;\n        vAlbedo = textureLod( iChannel3, traceResult.vUVW.xy * 2.0, 0.0 ).rgb;\n        vAlbedo = vAlbedo * vAlbedo;\n        vAlbedo *= vec3(1.0, 0.1, 0.5);\n                \n        surfaceInfo.vAlbedo = vAlbedo;\n        \n    \t\/\/surfaceInfo.fSmoothness = 0.9;\/\/clamp( 1.0 - surfaceInfo.vAlbedo.r * surfaceInfo.vAlbedo.r * 2.0, 0.0, 1.0);\n    \tsurfaceInfo.fSmoothness = clamp( 1.0 - surfaceInfo.vAlbedo.r * 2.0, 0.0, 0.9);\n\n        surfaceInfo.fTransparency = clamp( surfaceInfo.vPos.y * 5.0 + surfaceInfo.vAlbedo.g * 3.0, 0.0, 1.0);\n\n        if ( surfaceInfo.vPos.x < 0.0 || surfaceInfo.vPos.z < 0.0 )\n        {\n        \tsurfaceInfo.vAlbedo = vec3(0.0);                \n    \t\tsurfaceInfo.fSmoothness = 0.9;\n            surfaceInfo.fTransparency = 1.0 - vAlbedo.g * 0.2;\n        }\n        \n        surfaceInfo.fRefractiveIndex = 1.5;\n        \n        \n        float fLipStickDist = length(surfaceInfo.vPos - vec3(0.3, 3.1, -2.9)) - 1.0;\n        if ( fLipStickDist < 0.0 )\n        {            \n            surfaceInfo.fTransparency = clamp(1.0 +fLipStickDist * 2.0- vAlbedo.r, 0.0, 1.0);\n            surfaceInfo.vAlbedo = vec3(0.5,0,0) * (1.0 - surfaceInfo.fTransparency);\n        }\n        \n        \/*surfaceInfo.vBumpNormal.x += surfaceInfo.vAlbedo.r;\n        surfaceInfo.vBumpNormal.z += surfaceInfo.vAlbedo.g;\n        surfaceInfo.vAlbedo = mix( vec3(0,.1,0), vec3(0.1, 0.8, 0.2), surfaceInfo.vAlbedo);\n        surfaceInfo.fSmoothness = 0.0;*\/\n    }\n\n    if ( traceResult.iObjectId == MAT_WINE )\n    {\n    \tsurfaceInfo.vR0 = vec3( 0.02 );\n        surfaceInfo.vAlbedo = vec3(0.0);\n                \n    \tsurfaceInfo.fSmoothness = 0.9;\n        \n        surfaceInfo.fTransparency = 1.0;\n        surfaceInfo.fRefractiveIndex = 1.3;        \n        \n        \/*surfaceInfo.vBumpNormal.x += surfaceInfo.vAlbedo.r;\n        surfaceInfo.vBumpNormal.z += surfaceInfo.vAlbedo.g;\n        surfaceInfo.vAlbedo = mix( vec3(0,.1,0), vec3(0.1, 0.8, 0.2), surfaceInfo.vAlbedo);\n        surfaceInfo.fSmoothness = 0.0;*\/\n    }\n    \n    if ( traceResult.iObjectId == iInsideObject )\n    {\n\t\tsurfaceInfo.fRefractiveIndex = 1.0;            \n    }\n    \n    return surfaceInfo;\n}\n\n\/\/ Scene Description\nfloat GetDistanceMug( const in vec3 vPos )\n{\n\tfloat fDistCylinderOutside = length(vPos.xz) - 1.0;\n\tfloat fDistCylinderInterior = length(vPos.xz) - 0.9;\n\tfloat fTop = vPos.y - 1.0;\n       \n\tfloat r1 = 0.6;\n\tfloat r2 = 0.15;\n\tvec2 q = vec2(length(vPos.xy + vec2(1.2, -0.1))-r1,vPos.z);\n\tfloat fDistHandle = length(q)-r2;\n       \n\tfloat fDistMug = max(max(min(fDistCylinderOutside, fDistHandle), fTop), -fDistCylinderInterior);\n\treturn fDistMug;\n}\n\nfloat SmoothMin( float a, float b, float k )\n{\n\t\/\/return min(a,b);\n\t\n\t\n    \/\/float k = 0.06;\n\tfloat h = clamp( 0.5 + 0.5*(b-a)\/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat GetDistanceWine( vec3 vPos )\n{\n    vec3 vLocalPos = vPos;\n    vLocalPos.y -= 2.0;\n    \n    vec2 vPos2 = vec2(length(vLocalPos.xz), vLocalPos.y);\n    \n    vec2 vSphOrigin = vec2(0);\n    vec2 vSphPos = vPos2 - vSphOrigin;   \n    \n    float fBowlDistance = length( vSphPos ) -  0.6 + 0.01;\n    \n    vec3 vWaterNormal = vec3(0,1,0);\n    \n    vWaterNormal.x = sin( iTime * 5.0) * 0.01;\n    vWaterNormal.z = cos( iTime * 5.0) * 0.01;\n    \n    vWaterNormal = normalize( vWaterNormal );\n    float fWaterLevel = dot(vLocalPos, vWaterNormal) - 0.1;\n        \n    return max( fBowlDistance, fWaterLevel );\n}\n\nfloat GetDistanceWineGlass( vec3 vPos )\n{\n    vec2 vPos2 = vec2(length(vPos.xz), vPos.y);\n    \n    vec2 vSphOrigin = vec2(0,2.0);\n    vec2 vSphPos = vPos2 - vSphOrigin;\n    \n    vec2 vClosest = vSphPos;\n    \n    if ( vClosest.y > 0.3 ) vClosest.y = 0.3;\n    vClosest = normalize(vClosest) * 0.6;\n    \n    float fBowlDistance = distance( vClosest, vSphPos ) - 0.015;\n    \n    vec2 vStemClosest = vPos2;\n    vStemClosest.x = 0.0;    \n    vStemClosest.y = clamp(vStemClosest.y, 0.0, 1.35);\n    \n    float fStemRadius = vStemClosest.y - 0.5;\n    fStemRadius = fStemRadius * fStemRadius * 0.02 + 0.03;\n    \n    float fStemDistance = distance( vPos2, vStemClosest ) - fStemRadius;\n    \n    \n    vec2 norm = normalize( vec2( 0.4, 1.0 ) );\n    vec2 vBaseClosest = vPos2;\n    float fBaseDistance = dot( vPos2 - vec2(0.0, 0.1), norm ) - 0.2;\n    fBaseDistance = max( fBaseDistance, vPos2.x - 0.5 ); \n\n    float fDistance = SmoothMin(fBowlDistance, fStemDistance, 0.2);\n    fDistance = SmoothMin(fDistance, fBaseDistance, 0.2);\n    \n    fDistance = max( fDistance, vSphPos.y - 0.5 );\n        \n    return fDistance;\n}\n\nfloat GetDistanceBowl( vec3 vPos )\n{    \n    vec2 vPos2 = vec2(length(vPos.xz), vPos.y);\n    \n    vec2 vSphOrigin = vec2(0,1.0 - 0.3 + 0.03);\n    vec2 vSphPos = vPos2 - vSphOrigin;\n    \n    vec2 vClosest = vSphPos;\n    \n    if ( vClosest.y > 0.1 ) vClosest.y = 0.1;\n    if ( vClosest.y < -0.7 ) vClosest.y = -0.7;\n    \n    float r = sqrt( 1.0 - vClosest.y * vClosest.y);    \n    vClosest.x = r;        \n    \n    float fBowlDistance = distance( vClosest, vSphPos );   \n    \n    vClosest = vSphPos;\n    vClosest.y = -0.7;    \n    r = sqrt( 1.0 - vClosest.y * vClosest.y);    \n    vClosest.x = min( vClosest.x, r ); \n    \n    float fBaseDistance = distance( vClosest, vSphPos );\n    \n    fBowlDistance = min( fBowlDistance, fBaseDistance );   \n    \n    return fBowlDistance- 0.03;\n}\n\n\nSceneResult Scene_GetDistance( const vec3 vPos, const int iInsideObject )\n{\n    SceneResult result;\n    \n    vec3 vWineGlassPos = vec3(0.0, 0.0, -2.0);\n    vec3 vBowlPos = vec3(1.0, 0.0, 1.0 );\n\n\tresult.fDist = vPos.y;\n    result.vUVW = vPos;\n\tresult.iObjectId = MAT_DEFAULT;\n\n        \n    SceneResult sphereResult1;\n    \n    \n    vec3 vSphere1Pos = vBowlPos + vec3(0.4, 0.5, 0.2);\n    sphereResult1.vUVW = vPos - vSphere1Pos;\n    sphereResult1.fDist = min( result.fDist, length(vPos - vSphere1Pos) - 0.4);\n\tsphereResult1.iObjectId = MAT_GLOSS_PAINT;\n    Scene_Union( result, sphereResult1 );    \n    \n\n    vec3 vSphere2Pos = vec3(2.2, 0.5, -0.9);\n    SceneResult sphereResult2;\n    sphereResult2.vUVW = (vPos - vSphere2Pos).zyx;\n\tsphereResult2.fDist = length(vPos - vSphere2Pos) - 0.5;\n\tsphereResult2.iObjectId = MAT_GLOSS_PAINT;\n    Scene_Union( result, sphereResult2 );\n    \n    if ( result.fDist > 10.0 )\n    {\n        result.iObjectId = MAT_SKY;\n    }\n    \n    SceneResult wineResult;\n    wineResult.vUVW = vPos;\n\twineResult.iObjectId = MAT_WINE;    \n    wineResult.fDist = GetDistanceWine( vPos - vWineGlassPos );\n    \n    \n    float fRadius = 1.0;\n    float fHeight = 1.0;\n    \n    SceneResult glassResult;\n    glassResult.iObjectId = MAT_GLASS;\n    glassResult.fDist = length(vPos - vec3(-2.0,fHeight,1.0)) - fRadius;\n    \n    glassResult.fDist = min(glassResult.fDist, GetDistanceBowl( vPos - vBowlPos));\n        \n    glassResult.vUVW = vPos.xzy;\n    glassResult.fDist = min( glassResult.fDist, GetDistanceWineGlass(vPos - vWineGlassPos ) );    \n\n    \/\/glassResult.fDist = min( glassResult.fDist, GetDistanceMug(vPos - vec3(-2.0, 1.0, -2.0) ) );    \n\n    Scene_Trim( wineResult, glassResult );\n    wineResult.fDist -= 0.0001;\n    \n    if ( iInsideObject == MAT_GLASS )\n    {\n        glassResult.fDist = -glassResult.fDist;\n    }\n\n    if ( iInsideObject == MAT_WINE )\n    {\n        wineResult.fDist = -wineResult.fDist;\n    }\n        \n    Scene_Union( result, glassResult );\n    Scene_Union( result, wineResult );\n    \n    return result;\n}\n\n\n\n\/\/ Scene Lighting\n\nvec3 g_vSunDir = normalize(vec3(1.0, 0.4, 0.5));\nvec3 g_vSunColor = vec3(1, 0.7, 0.5) * 5.0;\nvec3 g_vAmbientColor = vec3(0.8, 0.2, 0.1);\n\nSurfaceLighting Scene_GetSurfaceLighting( const in vec3 vViewDir, in SurfaceInfo surfaceInfo )\n{\n    SurfaceLighting surfaceLighting;\n    \n    surfaceLighting.vDiffuse = vec3(0.0);\n    surfaceLighting.vSpecular = vec3(0.0);    \n    \n    Light_AddDirectional( surfaceLighting, surfaceInfo, vViewDir, g_vSunDir, g_vSunColor );\n    \n    \/\/Light_AddPoint( surfaceLighting, surfaceInfo, vViewDir, vec3(1.4, 1.0, 5.8), vec3(1,1,1) );\n    \n    float fAO = Scene_GetAmbientOcclusion( surfaceInfo.vPos, surfaceInfo.vNormal );\n    \/\/ AO\n    surfaceLighting.vDiffuse += fAO * (surfaceInfo.vBumpNormal.y * 0.5 + 0.5) * g_vAmbientColor;\n    \n    return surfaceLighting;\n}\n\n\/\/ Environment\n\nvec4 Env_GetSkyColor( const vec3 vViewPos, const vec3 vViewDir )\n{\n\tvec4 vResult = vec4( 0.0, 0.0, 1.0, kFarDist );\n    \n    vec3 vEnvMap = textureLod( iChannel1, vViewDir, 0.0 ).rgb;\n    vEnvMap = vEnvMap * vEnvMap;\n    float kEnvmapExposure = 0.999;\n    vResult.rgb = -log2(1.0 - vEnvMap * kEnvmapExposure);\n        \n    \/*\n\tvec4 vResult = vec4( 0.0, 0.0, 0.0, kFarDist );\n\t\n    float fElevation = atan( vViewDir.y, length(vViewDir.xz) );\n    float fHeading = atan( vViewDir.x, vViewDir.z );\n    \n    float fSkyElevationMin = -PI * 0.125;\n    float fSkyElevationMax = PI * 0.5;\n\n    float fScaledElevation = 0.5 * ((fElevation - fSkyElevationMin) \/ (fSkyElevationMax - fSkyElevationMin));\n    if (fHeading < 0.0) fScaledElevation = 1.0 - fScaledElevation;\n    vec2 vUV = vec2( fract(fHeading \/ PI), fScaledElevation );\n    \n    vResult = texture( iChannel3, vUV );\n    \n    \/\/vResult = mix( vec3(0.02, 0.04, 0.06), vec3(0.1, 0.3, 0.8) * 3.0, vViewDir.y * 0.5 + 0.5 );\n\t\n    \/\/ Sun\n    float NdotV = dot( g_vSunDir, vViewDir );\n    vResult.rgb += smoothstep( cos(radians(.7)), cos(radians(.5)), NdotV ) * g_vSunColor * 5000.0;\n    \n\t*\/\n\n    return vResult;\t\n}\n\nfloat Env_GetFogFactor(const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist, const float fInsideObject)\n{    \n\tfloat kFogDensity = 0.00001;\n\treturn exp(fDist * -kFogDensity);\t\n}\n\nvec3 Env_GetFogColor(const in vec3 vDir, const float fInsideObject)\n{    \n\treturn vec3(0.2, 0.5, 0.6) * 2.0;\t\t\n}\n\nvec3 Env_ApplyAtmosphere( const in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist, const int iInsideObject )\n{\n    \/\/return vColor;\n    vec3 vResult = vColor;\n    \n    \/*\n\tfloat fFogFactor = Env_GetFogFactor( vRayOrigin, vRayDir, fDist, fInsideObject );\n\tvec3 vFogColor = Env_GetFogColor( vRayDir, fInsideObject );\t\n\tEnv_AddDirectionalLightFlareToFog( vFogColor, vRayDir, g_vSunDir, g_vSunColor * 3.0);    \n    vResult = mix( vFogColor, vResult, fFogFactor );\n\t*\/\n    \n    \/\/ Glass extinction\n    if ( iInsideObject == MAT_GLASS || iInsideObject == MAT_WINE )\n    {\n        vec3 vExtCol = vec3(0);\n\n        if ( iInsideObject == MAT_WINE )\n        {\n            vExtCol = vec3(1.0) - vec3(1.0, 0.5, 0.01);\n        }\n        else\n        {\n            if ( vRayOrigin.z > 0.0 )\n            {\n                if ( vRayOrigin.x < 0.0 )\n                {\n                    vExtCol = vec3(1.0) - vec3(0.01, 0.01, 1.0);\n                }\n                else\n                {\n                    vExtCol = vec3(1.0) - vec3(1.0, 0.2, 0.8);\n                    vExtCol *= 20.0;\n                }\n            }\n        }\n        \n\t\tvResult *= exp(fDist * -vExtCol);\t\n    }\n    \n\n    return vResult;\t    \n}\n\n\nvec3 FX_Apply( in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist)\n{    \n    return vColor;\n}\n\nfloat fPlaneInFocus = 5.0;\n\nfloat GetCoC( float fDistance, float fPlaneInFocus )\n{\n\t\/\/ http:\/\/http.developer.nvidia.com\/GPUGems\/gpugems_ch23.html\n\n    float fAperture = 0.05;\n    float fFocalLength = 0.8;\n  \n\treturn abs(fAperture * (fFocalLength * (fDistance - fPlaneInFocus)) \/\n          (fDistance * (fPlaneInFocus - fFocalLength)));  \n}\n\nvec4 MainCommon( vec3 vRayOrigin, vec3 vRayDir, float fShade )\n{\n\tvec4 vColorLinAmdDepth = Scene_GetColorAndDepth( vRayOrigin, vRayDir );    \n    vColorLinAmdDepth.rgb = max( vColorLinAmdDepth.rgb, vec3(0.0) );\n        \n    vec4 vFragColor = vColorLinAmdDepth;\n    \n    vFragColor.rgb *= fShade;\n    \n    vFragColor.a = GetCoC( vColorLinAmdDepth.w, fPlaneInFocus );    \n    \n    return vFragColor;\n}\n\nfloat GetVignetting( const in vec2 vUV, float fScale, float fPower, float fStrength )\n{\n\tvec2 vOffset = (vUV - 0.5) * sqrt(2.0) * fScale;\n\t\n\tfloat fDist = max( 0.0, 1.0 - length( vOffset ) );\n    \n\tfloat fShade = 1.0 - pow( fDist, fPower );\n    \n    fShade = 1.0 - fShade * fStrength;\n\n\treturn fShade;\n}\n\nvoid mainImage( out vec4 vFragColor, in vec2 vFragCoord )\n{\n    vec2 vUV = vFragCoord.xy \/ iResolution.xy; \n\n    CameraState cam;\n    \n    float fAngle = (iMouse.x \/ iResolution.x) * radians(360.0);\n    float fElevation = (iMouse.y \/ iResolution.y) * radians(90.0);\n\n    if ( iMouse.x <= 0.0 )\n    {\n        fAngle = -2.3;\n        fElevation = 0.5;\n    }\n    \n    float fDist = 6.0;\n    \n    cam.vPos = vec3(sin(fAngle) * fDist * cos(fElevation),sin(fElevation) * fDist,cos(fAngle) * fDist * cos(fElevation));\n    cam.vTarget = vec3(0,0.5,0);\n    cam.fFov = 20.0;\n    \n    vec3 vRayOrigin, vRayDir;\n    Cam_GetCameraRay( vUV, cam, vRayOrigin, vRayDir );\n \n    float fShade = GetVignetting( vUV, 0.7, 2.0, 1.0 );\n    \n    vFragColor= MainCommon( vRayOrigin, vRayDir, fShade );\n}\n\nvoid mainVR( out vec4 vFragColor, in vec2 vFragCoord, in vec3 vRayOrigin, in vec3 vRayDir )\n{   \n    {\n        vec3 vOrigin = vRayOrigin;\n        \n        vOrigin *= 15.0;\n        \n    \tvOrigin.y += 3.0;\n    \tvOrigin.z += 3.0;\n    \n    \tvFragColor = MainCommon( vOrigin, vRayDir, 1.0 );\n    }\n    \n    vFragColor.a = 0.0;\n    \n    \n    \/\/ read prev camera pos for both eyes\n    vec2 vLeftPosAddress = vec2(0.0, 0.0) + 0.5;\n    vec4 vLeftPos = texture( iChannel0, vLeftPosAddress \/ iChannelResolution[0].xy );\n    vec2 vLeftDirAddress = vec2(0.0, 1.0) + 0.5;\n    vec4 vLeftDir = texture( iChannel0, vLeftDirAddress \/ iChannelResolution[0].xy );\n    vec2 vRightPosAddress = vec2(floor(iChannelResolution[0].x\/2.0), 0.0) + 0.5;\n    vec4 vRightPos = texture( iChannel0, vRightPosAddress \/ iChannelResolution[0].xy );\n    vec2 vRightDirAddress = vec2(floor(iChannelResolution[0].x\/2.0), 1.0) + 0.5;\n    vec4 vRightDir = texture( iChannel0, vRightDirAddress \/ iChannelResolution[0].xy );\n    \n    \/\/ Write camera pos for current eye\n    vec2 vAddress = floor( vFragCoord.xy );\n    if ( vAddress.x == 0.0 && vAddress.y == 0.0 )\n    {\n        vFragColor.rgb = vRayOrigin;\n    }\n    if ( vAddress.x == 0.0 && vAddress.y == 1.0 )\n    {\n        vFragColor.rgb = vRayDir;\n    }\n    \n\t\/\/ store prev left and right eye info\n    if ( vAddress.x == 1.0 && vAddress.y == 0.0)\n    {\n        vFragColor = vLeftPos;\n    }\n    if ( vAddress.x == 1.0 && vAddress.y == 1.0)\n    {\n        vFragColor = vLeftDir;\n    }\n    if ( vAddress.x == 2.0 && vAddress.y == 0.0)\n    {\n        vFragColor = vRightPos;\n    }\n    if ( vAddress.x == 2.0 && vAddress.y == 1.0)\n    {\n        vFragColor = vRightDir;\n    }\n\n    if ( vAddress.x == 2.0 && vAddress.y == 0.0)\n    {\n        vFragColor = vRightPos;\n    }\n    \n}\n\n",
            "name": "Buf A",
            "description": "",
            "type": "buffer"
        }
    ]
}