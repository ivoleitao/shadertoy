{
    "ver": "0.1",
    "info": {
        "id": "Wt33zH",
        "date": "1576148732",
        "viewed": 3961,
        "name": "Geometric Cellular Surfaces",
        "username": "Shane",
        "description": "Precalculating isosurface values then packing them into the cubemap to produce scenes in realtime that would normally be prohibitively expensive.",
        "likes": 99,
        "published": 3,
        "flags": 0,
        "usePreview": 0,
        "tags": [
            "voronoi",
            "volume",
            "cubemap",
            "cellular",
            "pack"
        ],
        "hasliked": 0
    },
    "renderpass": [
        {
            "inputs": [
                {
                    "id": "4sXGRn",
                    "filepath": "\/media\/a\/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg",
                    "previewfilepath": "\/media\/ap\/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg",
                    "type": "texture",
                    "channel": 1,
                    "sampler": {
                        "filter": "mipmap",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "4dX3Rr",
                    "filepath": "\/media\/a\/\/media\/previz\/cubemap00.png",
                    "previewfilepath": "\/media\/ap\/\/media\/previz\/cubemap00.png",
                    "type": "cubemap",
                    "channel": 0,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dfGRr",
                    "channel": 0
                }
            ],
            "code": "\/*\n\n\n\tGeometric Cellular Surfaces\n\t---------------------------\n\n\n\tPrecalculating isosurface values then packing them into the cubemap to produce scenes \n    in realtime that would normally be prohibitively expensive.\n\n\tI put up an example a short while back that involved packing a 100 sided voxel cube\n    into one pixel channel of one face of the cubemap. I mentioned that if using all four \n\tchannels, you could increase the resolution to 160 pixels per dimension, so that is\n\twhat I've done here. From here, it's possible to pack a 256 pixel per side cube into \n    four faces of the cubemap, or pack other 3D surfaces into the other cubemap faces,\n\tbut for now, I'm concentrating on packing a 160 resolution cube into one face of a \n    cubemap. Of secondary importance, I'm also reading an interpolated 2D surface from \n\tanother face, in order to demonstrate the cubemap's versatility.\n\n\tFor some reason, packing 3D coordinates into a 2D texture is a task that I don't\n\tparticularly enjoy -- It reminds me of the \"trying to fit a square peg into a round \n    hole\" expression. I don't even enjoy coding the relatively easy one channel version, \n    let alone the extra fiddly four channel one. For that reason, I procrastinated a \n    while before putting this together... To be fair, Shadertoy has not exactly been \n    inundated with 3D packing examples, four channels or otherwise, so I'm guessing most \n    others feel the same way. Furthermore, I had to code this from scratch. Anyway, I'm \n    going to try my best to explain the process -- while it's still fresh in my head, so \n    others can benefit.\n\n\tBasically, you're taking a voxelated cube of dimensions X, Y and Z, then filling the \n    individual voxels with precalculated values -- In this case, it will be a 3D surface \n    isovalue at each position. In order to do this, you need to take the pixels on a 2D \n    texture surface (we'll be using cubemap faces), convert them to 3D positions, fill \n    them with values, then read them back again -- usually from within the raymarching \n    loop, but you might simply wish to texure or bump map a surface, etc.\n\n\tThe process is quite simple, once you get your head around it. The trick is to think\n\tof both the 2D space and the 3D space in one dimensional form. For instance, a\n    16 by 16 texture is 256 pixels, regardless of how things wrap. A 6 pixel-per-side voxel\n\tcube is 216 pixels, regardless of how it wraps. Therefore, all you need to do is \n    convert your 2D coordinates to a one dimensional lookup number (X + Y*texDimX), and \n    your 3D coordinates to the same (X + Y*cubeDimX + Z*cubeDimX*cubeDimY), then perform\n\tthe conversions like so:\n\n    2D to 3D (uv to voxel):\n\n    int iPos = uvX + uvY*texDimX;\n    cubeX = mod(iPos, cubeDimX); \n    cubeY = mod(floor(iPos\/cubeDimX), cubeDimY); \n    cubeZ = mod(floor(iPos\/(cubeDimX*cubeDimY)), cubeDimZ);\n\n    3D to 2D (voxel to uv):\n\n    int iPos = cubeX + cubeY*cubeDimX + cubeZ*cubeDimX*cubeDimY;\n    uvX = mod(iPos, texDimX); \n    uvY = mod(floor(iPos\/texDimX), texDimY); \n  \n    I'm ignoring a few minor details, like scaling and snapping pizels to their centers to \n    avoid seam line artifacts. In addition, putting more values into the four texture \n    channels require some extra X dimension scaling and modulo involving the number 4, but \n    that's essentially it. You can find the details in the \"Common\" tab.\n\t\n\n\t\n    \n    Other examples:\n\n    \/\/ Really nice example, and the thing that motivated me to get in amongst it\n\t\/\/ and finally learn to read and write from the cube map. I have a few 3D packing \n    \/\/ examples coming up, which use more simplistic formulas, but I couldn't tell \n    \/\/ you whether that translates to extra speed or not. Probably not. :)\n    Copper \/ Flesh - tdhooper\n    https:\/\/www.shadertoy.com\/view\/WljSWz\n\n*\/\n\n\/\/ The maximum allowable ray distance. In this case, we're using a back plane of\n\/\/ sorts, which nothing goes beyond, so it's kind of redundant, but it's here anyway.\n#define FAR 20.\n\n\n\/\/ 2D rotation formula.\nmat2 rot2(float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n\/\/ I paid hommage to the original and kept the same rotation... OK, I'm lazy. :D\nvec3 rotObj(vec3 p){\n    \n    p.yz *= rot2(iTime*.2);\n    p.zx *= rot2(iTime*.5);\n    return p;    \n}\n\n\/\/ Tri-Planar blending function. Based on an old Nvidia writeup:\n\/\/ GPU Gems 3 - Ryan Geiss: https:\/\/developer.nvidia.com\/gpugems\/GPUGems3\/gpugems3_ch01.html\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n){\n    \n    \/\/ We only want positive normal weightings. The normal is manipulated to suit\n    \/\/ your needs.\n    n = max(n*n - .2, .001); \/\/ n = max(abs(n) - .1, .001), etc.\n    \/\/n \/= dot(n, vec3(1)); \/\/ Rough renormalization approximation.\n    n \/= length(n); \/\/ Renormalizing.\n    \n\tvec3 tx = texture(t, p.yz).xyz; \/\/ Left and right sides.\n    vec3 ty = texture(t, p.zx).xyz; \/\/ Top and bottom.\n    vec3 tz = texture(t, p.xy).xyz; \/\/ Front and back.\n    \n    \/\/ Blending the surrounding textures with the normal weightings. If the surface is facing\n    \/\/ more up or down, then a larger \"n.y\" weighting would make sense, etc.\n    \/\/\n    \/\/ Textures are stored in sRGB (I think), so you have to convert them to linear space \n    \/\/ (squaring is a rough approximation) prior to working with them... or something like that. :)\n    \/\/ Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n    \n}\n\n\n\n\/\/ A scene object ID container. This is just enough for four objects.\n\/\/ If you needed more, you'd have to use other methods.\nvec4 objID;\n\n\n\/\/ The 3D surface function. This one converts the 3D position to a 3D voxel \n\/\/ position in the cubemap, then reads the isovalue. Actually, one option does\n\/\/ that, and the other is forced to read out eight neighboring values to \n\/\/ produce a smooth interpolated value. As in real life, it looks nicer, but \n\/\/ costs more. :)\nfloat txFace0(in vec3 p){\n    \n    #if 0\n    \n    \/\/ One sample... Ouch. :D It's a shame this doesn't work, because it's \n    \/\/ clearly faster. Unfortunately, it's virtually pointless from an aesthetic\n    \/\/ aspect, as you can see, but there'd be times when you could get away with it.\n    vec3 col = texMapCh(iChannel0, p).xyz;\n    \n    #else\n    \n    \/\/ Eight samples, for smooth interpolation. Still not as good as the real \n    \/\/ thing -- and by that, I mean, calculating on the fly. However, it's \n    \/\/ good enough. I'd need to think about it, but I'm wondering whether a\n    \/\/ four or five point tetrahedral interpolation would work? It makes my\n    \/\/ head hurt thinking about it right now, but it might. :)\n    vec3 col = texMapSmoothCh(iChannel0, p).xyz;\n    \n    #endif\n    \n    return col.x;\n    \n}\n\n\nfloat surfFunc3D(in vec3 p){\n    \n    p = normalize(p);\n    \n    return txFace0(p\/1.5);\n    \n}\n\n\/\/ A 2D texture lookup: GPUs don't make it easy for you. If wrapping wasn't a concern,\n\/\/ you could get away with just one GPU-filtered filtered texel read. However, there\n\/\/ are seam line issues, which means you need to interpolate by hand, so to speak.\n\/\/ Thankfully, you can at least store the four neighboring values in one pixel channel,\n\/\/ so you're left with one texel read and some simple interpolation.\n\/\/\n\/\/ By the way, I've included the standard noninterpolated option for comparisson.\nfloat txFace1(in samplerCube tx, in vec2 p){\n   \n    \n    p *= cubemapRes;\n    vec2 ip = floor(p); p -= ip;\n    vec2 uv = fract((ip + .5)\/cubemapRes) - .5;\n    \n    #if 0\n    \n    \/\/ The standard noninterpolated option. It's faster, but doesn't look very nice.\n    \/\/ You could change the texture filtering to \"mipmap,\" but that introduces seam\n    \/\/ lines at the borders -- which is fine, if they're out of site, but not when you\n    \/\/ want to wrap things, which is almost always.\n    return texture(tx, vec3(.5, uv.y, -uv.x)).x; \n    \n    #else\n    \n    \/\/ Smooth 2D texture interpolation using just one lookup. The pixels and\n    \/\/ its three neighbors are stored in each channel, then interpolated using\n    \/\/ the usual methods -- similar to the way in which smooth 2D noise is\n    \/\/ created.\n    vec4 p4 = texture(tx, vec3(.5, uv.y, -uv.x)); \n\n    return mix(mix(p4.x, p4.y, p.x), mix(p4.z, p4.w, p.x), p.y);\n    \n    \/\/ Returning the average of the neighboring pixels, for curiosity sake.\n    \/\/ Yeah, not great. :)\n    \/\/return dot(p4, vec4(.25));\n    \n    #endif\n\/*   \n    \/\/ Four texture looks ups. I realized later that I could precalculate all four of \n    \/\/ these, pack them into the individual channels of one pixel, then read them\n    \/\/ all back in one hit, which is much faster.\n    vec2 uv = fract((ip + .5)\/cubemapRes) - .5;\n    vec4 x = texture(tx, vec3(.5, uv.y, -uv.x)).x;\n    uv = fract((ip + vec2(1, 0)+ .5)\/cubemapRes) - .5;\n    vec4 y = texture(tx, vec3(.5, uv.y, -uv.x)).x;\n    uv = fract((ip + vec2(0, 1)+ .5)\/cubemapRes) - .5;\n    vec4 z = texture(tx, vec3(.5, uv.y, -uv.x)).x;\n    uv = fract((ip + vec2(1, 1)+ .5)\/cubemapRes) - .5;\n    vec4 w = texture(tx, vec3(.5, uv.y, -uv.x)).x;\n\n    return mix(mix(x, y, p.x), mix(z, w, p.x), p.y);\n*\/  \n    \n}\n\n\nfloat surfFunc2D(in vec3 p){\n    \n    \/\/ Normalizing the coordinates to pull things toward the \n    \/\/ center. A bit of overkill, but I've left it there, in\n    \/\/ case I change my mind. :)\n    \/\/p = normalize(p - vec3(0, 0, -(12. - 6.)))*12.;\n\n\treturn txFace1(iChannel0, (p.xy)\/8. - .5);\n\n}\n\n\n\nfloat map(in vec3 p){\n   \n   \n    vec4 d;\n    \n    \n    \/\/ Back wall.\n    \n    \/\/ Perturbing things a bit.\n    vec3 q = p + sin(p*2. - cos(p.zxy*3.5))*.1;\n    \n    \/\/ Grabbing the 2D surface value from the second face of the cubemap.\n    float sf2D = surfFunc2D(q);\n    \n    \/\/ Combining the 2D Voronoi value above with an extrusion process to creat some netting.\n    d.z = smax(abs(-q.z + 6. - .5) - .05, (sf2D\/2. - .025), .02);\n    \/\/d.z = -(length(q - vec3(0, 0, -(12. - 6.))) - 12.) + (.5 - sf2D)*.5;\n    \n    \/\/ The back plane itself -- created with a bit of extrusion and addition. \n    d.w = -q.z + 6.;\n    float top = (.5 - smoothstep(0., .35, sf2D - .025));\n    d.w = smin(d.w, smax(abs(d.w) - .75, -(sf2D\/2. - .025 - .04), .02) + top*.1, .02);\n    \n    \n    \/\/ The celluar geometric ball object.\n    \n    \/\/ Rotate the object.\n    q = rotObj(p);\n    \/\/ Perturb it a bit.\n    q += sin(q*3. - cos(q.yzx*5.))*.05;\n\n    \/\/ Retrieve the 3D surface value. Note (in the function) that the 3D value has been \n    \/\/ normalized. That way, everything points toward the center.\n    float sf3D = surfFunc3D(q);\n    \n    \n    \/\/ Adding a small top portion.\n    top = (.5 - smoothstep(0., .35, sf3D - .025));\n    \n    d.x = length(q) - 1.; \/\/ The warped spherical base.\n    \n    \/\/ The gold, metallic spikey ball surface -- created via an extrusion process\n    d.y = smin(d.x + .1, smax(d.x - .2, -(sf3D\/2.-.025 - .06), .02) + top*.05, .1);\n    \n    \/\/ The spherical netting with holes -- created via an extrusion process.\n    d.x = smax(abs(d.x) - .025, sf3D\/2.-.025, .01);\n    \n    \n    \n    \/\/ Store the individual object values for sorting later. Sorting multiple objects\n    \/\/ inside a raymarching loop probably isn't the best idea. :)\n    objID = d;\n    \n    \/\/ Return the minimum object in the scene.\n    return min(min(d.x, d.y), min(d.z, d.w));\n}\n\n\/*\n\/\/ Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ. In instances where there's no descernible \n\/\/ aesthetic difference between it and the six tap version, it's worth using.\nvec3 calcNormal(in vec3 p){\n\n    \/\/ Note the slightly increased sampling distance, to alleviate artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.0025, -0.0025); \n    return normalize(e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) + e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx));\n}\n*\/\n\n\n\/\/ Standard normal function. 6 taps.\nvec3 calcNormal(in vec3 p) {\n\tconst vec2 e = vec2(.002, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n\n\n\n\/\/ Raymarching: The distance function is a little on the intensive side, so I'm \n\/\/ using as fewer iterations as necessary. Even though there's a breat, the compiler\n\/\/ still has to unroll everything, and larger numbers make a difference.\nfloat trace(in vec3 ro, in vec3 rd){\n    \n    float t = 0., d;\n    \n    for(int i = min(0, iFrame); i<80; i++){\n    \n        d = map(ro + rd*t);\n        if(abs(d) < .001*(1. + t*.05) || t > FAR) break;\n        t += d*.75;\n    }\n    \n    return min(t, FAR);\n}\n\nfloat hash( float n ){ return fract(cos(n)*45758.5453); }\n\n\/\/ I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n\/\/ Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 2., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.25\/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n    \n}\n\n\/\/ Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n\/\/ iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    \/\/ More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 32; \n    \n    ro += n*.002;\n    vec3 rd = lp - ro; \/\/ Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.;\/\/.0015; \/\/ Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), .0001);\n    \/\/float stepDist = end\/float(maxIterationsShad);\n    rd \/= end;\n\n    \/\/ Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    \/\/ number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d\/t);\n        \/\/shade = min(shade, smoothstep(0., 1., k*h\/dist)); \/\/ Subtle difference. Thanks to IQ for this tidbit.\n        \/\/ So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .035, .35); \n        \n        \n        \/\/ Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    \/\/ Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    \/\/ It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    \/\/ AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    \/\/ Aspect correct screen coordinates.\n    vec2 p = (fragCoord - iResolution.xy*.5)\/iResolution.y;\n    \n    \/\/ Unit direction ray.\n    vec3 rd = normalize(vec3(p, 1));\n    \n    \/\/ Ray origin, doubling as the camera postion.\n    vec3 ro = vec3(sin(iTime\/2.)*.5, cos(iTime\/4.)*.1 - iTime*0., -3.);\n    \n    \/\/ Light position. Near the camera.\n    vec3 lp = ro + vec3(0, .65, 1.35);\n    \n    \/\/ Ray march.\n    float t = trace(ro, rd);\n    \n    \n    \/\/ Object identification: Back plane: 3, Golden joins: 2., \n    \/\/ Ball joins: 1., Silver pipes:  0.\n    float svObjID = objID.x<objID.y && objID.x<objID.z && objID.x<objID.w? 0.: \n    objID.y<objID.z && objID.y<objID.w ? 1. : objID.z<objID.w? 2. : 3.;\n\n    \n    \/\/ Initiate the scene color zero.\n    vec3 col = vec3(0);\n    \n    \/\/ Surface hit. Color it up.\n    if(t < FAR){\n    \n        \/\/ Position.\n        vec3 pos = ro + rd*t;\n        \/\/ Normal.\n        vec3 nor = calcNormal(pos);\n        \n        \/\/ Light direction vector.\n        vec3 ld = lp - pos;\n        float lDist = max(length(ld), .001);\n        ld \/= lDist;\n        \n        \/\/ Light falloff - attenuation.\n        float atten = 2.\/(1. + lDist*.05 + lDist*lDist*.025);\n        \n        \/\/ Soft shadow and occlusion.\n        float shd = softShadow(pos, lp, nor, 8.); \/\/ Shadows.\n        float ao = calcAO(pos, nor);\n        shd = min(shd + .2*ao, 1.);\n        \n        \n        float diff = max(dot(ld, nor), .0); \/\/ Diffuse.\n        float spec = pow(max(dot(reflect(-ld, nor), -rd), 0.), 32.); \/\/ Specular.\n        \/\/ Ramping up the diffuse. Sometimes, it can make things look more metallic.\n        diff = pow(diff, 4.)*3.; \n        \n        \/\/ Approximate Schlick value.\n        float Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.0);\n\t\tfloat fre2 = mix(.5, 1., Schlick);  \/\/F0 = .5.\n        \n        \n        \/\/ The rotated position and normal, for texturing the rotating\n        \/\/ spherical object.\n        vec3 txPos = rotObj(pos + vec3(0, iTime*0., 0));\n        vec3 txNor = rotObj(nor);\n        \n        \n        \/\/ Initializing the object color.\n        vec3 oCol = vec3(0);\n        \n                \n        \n        \/\/ Silver metallic spherical netting.\n        if(svObjID == 0.){\n            oCol = vec3(.5, .4, .35);\n            oCol += fre2;\n            \n            \/\/ Trusty \"Rusty Metal\" texture -- I'm trying to set a Shadertoy\n        \t\/\/ record for its overusage. :D\n        \tvec3 tx = tex3D(iChannel1, txPos*2., txNor);\n        \ttx = smoothstep(0., .5, tx);\n            oCol *= tx;\n        }\n        \n        \/\/ Gold metallic spikey ball.\n        if(svObjID == 1.){\n            oCol = vec3(.5, .4, .35); \/\/ Reddish grey.\n            oCol += vec3(2.5, .75, .1)*fre2;\n            \n            \/\/ Another sample.\n        \tvec3 tx = tex3D(iChannel1, txPos, txNor);\n        \ttx = smoothstep(0., .5, tx);\n            oCol *= tx;\n        }\n        \n        \/\/ Back mesh.\n        if(svObjID == 2.) { \n            oCol = vec3(.5, .4, .35); \/\/ Reddish grey... or is it greyish red? :)\n            oCol += fre2;\n              \n        }        \n        \n        \/\/ Spikey prutruding back wall.\n        if(svObjID == 3.) { \n            oCol = vec3(.8, 1, .7); \/\/ Greenish.\n            \n            \/\/ Since glass has a refrective index of... which means shorter wave \n            \/\/ lengths produce... Hmmm, some extra blue seems to look nice. :D\n            oCol += vec3(.2, .6, 1)*fre2;\n          \n        }\n        \n        \n        if(svObjID<1.5){ \/\/ Spherical objects.\n               \n            \/\/ Using the surface shade to color and shade some more.\n            float oShd = surfFunc3D(txPos);\n            oCol = mix(oCol, vec3(1, .0, .2), oShd\/2.);\n            oCol *= oShd*.8 + .2;\n             \n        }\n        else { \/\/ Back plane objects.\n            \n             vec3 tx = tex3D(iChannel1, pos\/6., nor);\n        \t tx = smoothstep(0., .5, tx);\n             oCol *= tx;\n                  \n             \/\/ Using the surface shade to color and shade some more.\n             float oShd = surfFunc2D(pos);\n             oCol = mix(oCol, vec3(1, .0, .2), oShd\/2.);\n             \n             oCol *= oShd*.8 + .2;\n            \n        }\n  \n        \n         \n        \/\/ Diffuse plus ambient term.\n        col = oCol*(diff + .35); \n        \/\/ Extra global Fresnel.\n        \/\/col += oCol*vec3(.3, .6, 1)*diff*fre2*fre2*.5;\n        \n        \/\/ Specular term.\n        col += oCol*vec3(1, .9, .7)*spec*4.;\n        \n        \/\/ Using the stored 3D values to apply some cheapish fake reflection.\n        vec3 refCol = col*vec3(.25, .5, 1)*smoothstep(.1, 1., txFace0(reflect(rd, nor)\/1.5));\n        vec4 refInt = vec4(12, 24, 24, 32);\n        col += refCol*refInt[int(svObjID)&3];\n\n        \n        \/\/ Applying the ambient occlusion, shadows and attenuation.\n        col *= ao*shd*atten;\n         \n    }\n    \n    \n    \/\/ Screen color, with gamma correction. No fog or postprocessing.\n    fragColor = vec4(pow(clamp(col, 0., 1.), vec3(1.\/2.2)), 1);\n}",
            "name": "Image",
            "description": "",
            "type": "image"
        },
        {
            "inputs": [],
            "outputs": [],
            "code": "\/\/ The cubemap texture resultion.\n#define cubemapRes vec2(1024)\n\n\/\/ If you use all four channels of one 1024 by 1024 cube face, that would be\n\/\/ 4096000 storage slots (1024*1024*4), which just so happens be 160 cubed.\n\/\/ In other words, you can store the isosurface values of a 160 voxel per side\n\/\/ cube into one cube face of the cubemap.\n\/\/\n\/\/ The voxel cube dimensions -- That's the one you'd change, but I don't really\n\/\/ see the point, since setting it to the maximum resolution makes the most\n\/\/ sense. For demonstrative purposes, dropping it to say, vec3(80), will show\n\/\/ how a decrease in resolution will affect things. Increasing it to above the\n\/\/ allowable resolution (for one cube face) to say, vec3(200), will display the\n\/\/ wrapping issues.\n\/\/\n\/\/ On a side note, I'm going to put up an example later that uses four of the \n\/\/ cubemap faces, which should boost the resolution to 256... and hopefully,\n\/\/ not add too much to the complexity, and consequent lag that would follow.\nconst vec3 dimsVox = vec3(160, 160, 160); \nconst vec3 scale = vec3(4, 1, 1);\nconst vec3 dims = dimsVox\/scale;\n\n\n\n\/\/ Reading into one of the cube faces, according to the face ID. To save on cycles,\n\/\/ I'd hardcode the face you're after into all but the least costly of situations.\n\/\/ This particular function is used just once for an update in the \"CubeA\" tab.\n\/\/\n\/\/ The four cube sides - Left, back, right, front.\n\/\/ NEGATIVE_X, POSITIVE_Z, POSITIVE_X, NEGATIVE_Z\n\/\/ vec3(-.5, uv.yx), vec3(uv, .5), vec3(.5, uv.y, -uv.x), vec3(-uv.x, uv.y, -.5).\n\/\/\n\/\/ Bottom and top.\n\/\/ NEGATIVE_Y, POSITIVE_Y\n\/\/ vec3(uv.x, -.5, uv.y), vec3(uv.x, .5, -uv.y).\nvec4 tx(samplerCube tx, vec2 p, int id){    \n\n    \/\/vec4 rTx;\n    \n    vec2 uv = fract(p) - .5;\n    \/\/ It's important to snap to the pixel centers. The people complaining about\n    \/\/ seam line problems are probably not doing this.\n    \/\/p = (floor(p*cubemapRes) + .5)\/cubemapRes; \n    \n    vec3[6] fcP = vec3[6](vec3(-.5, uv.yx), vec3(.5, uv.y, -uv.x), vec3(uv.x, -.5, uv.y),\n                          vec3(uv.x, .5, -uv.y), vec3(-uv.x, uv.y, -.5), vec3(uv, .5));\n \n    \n    return texture(tx, fcP[id]);\n}\n\n\nvec4 texMapCh(samplerCube tx, vec3 p){\n    \n    p *= dims;\n    int ch = (int(p.x*4.)&3);\n    p = mod(floor(p), dims);\n    float offset = dot(p, vec3(1, dims.x, dims.x*dims.y));\n    vec2 uv = mod(floor(offset\/vec2(1, cubemapRes.x)), cubemapRes);\n    \/\/ It's important to snap to the pixel centers. The people complaining about\n    \/\/ seam line problems are probably not doing this.\n    uv = fract((uv + .5)\/cubemapRes) - .5;\n    return vec4(1)*texture(tx, vec3(-.5, uv.yx))[ch];\n    \n}\n\n\/\/ Used in conjunction with the function below. When doing things eight times over, any \n\/\/ saving is important. If I could trim this down more, I would, but there's wrapping\n\/\/ and pixel snapping to consider. Having said that, I might take another look at it,\n\/\/ at some stage.\nvec4 txChSm(samplerCube tx, in vec3 p, in int ch){\n   \n    p = mod(floor(p), dims);\n    \/\/vec2 uv = mod(floor(dot(p, vec3(1, dims.x, dims.x*dims.y))\/vec2(1, cubemapRes.x)), cubemapRes);\n    \/\/ I think the fract call below already wraps things, so no \"mod\" call needed.\n    vec2 uv = floor(dot(p, vec3(1, dims.x, dims.x*dims.y))\/vec2(1, cubemapRes.x));\n    \/\/ It's important to snap to the pixel centers. The people complaining about\n    \/\/ seam line problems are probably... definitely not doing this. :)\n    uv = fract((uv + .5)\/cubemapRes) - .5;\n    return vec4(1)*texture(tx, vec3(-.5, uv.yx))[ch];\n    \n}\n\n\/\/ Smooth texture interpolation that access individual channels: You really need this -- I \n\/\/ wish you didn't, but you do. I wrote it a while ago, and I'm pretty confident that it works. \n\/\/ The smoothing factor isn't helpful at all, which surprises me -- I'm guessing it molds things \n\/\/ to the shape of a cube. Anyway, it's written in the same way that you'd write any cubic \n\/\/ interpolation: 8 corners, then a linear interpolation using the corners as boundaries.\n\/\/\n\/\/ It's possible to use more sophisticated techniques to achieve better smoothing, but as you \n\/\/ could imagine, they require more samples, and are more expensive, so you'd have to think about \n\/\/ it before heading in that direction -- Perhaps for texturing and bump mapping.\nvec4 texMapSmoothCh(samplerCube tx, vec3 p){\n\n    \/\/ Voxel corner helper vector.\n\tconst vec3 e = vec3(0, 1, 1.\/4.);\n\n    \/\/ Technically, this will center things, but it's relative, and not necessary here.\n    \/\/p -= .5\/dimsVox.x;\n    \n    p *= dimsVox;\n    vec3 ip = floor(p);\n    p -= ip;\n\n    \n    int ch = (int(ip.x)&3), chNxt = ((ch + 1)&3);  \/\/int(mod(ip.x, 4.))\n    ip.x \/= 4.;\n\n    vec4 c = mix(mix(mix(txChSm(tx, ip + e.xxx, ch), txChSm(tx, ip + e.zxx, chNxt), p.x),\n                     mix(txChSm(tx, ip + e.xyx, ch), txChSm(tx, ip + e.zyx, chNxt), p.x), p.y),\n                 mix(mix(txChSm(tx, ip + e.xxy, ch), txChSm(tx, ip + e.zxy, chNxt), p.x),\n                     mix(txChSm(tx, ip + e.xyy, ch), txChSm(tx, ip + e.zyy, chNxt), p.x), p.y), p.z);\n\n \n \t\/*   \n    \/\/ For fun, I tried a straight up average. It didn't work. :)\n    vec4 c = (txChSm(tx, ip + e.xxx*sc, ch) + txChSm(tx, ip + e.yxx*sc, chNxt) +\n             txChSm(tx, ip + e.xyx*sc, ch) + txChSm(tx, ip + e.yyx*sc, chNxt) +\n             txChSm(tx, ip + e.xxy*sc, ch) + txChSm(tx, ip + e.yxy*sc, chNxt) +\n             txChSm(tx, ip + e.xyy*sc, ch) + txChSm(tx, ip + e.yyy*sc, chNxt) + txChSm(tx, ip + e.yyy*.5, ch))\/9.;\n \t*\/\n    \n    return c;\n\n}\n\n\n\n\n\/\/ If you want things to wrap, you need a wrapping scale. It's not so important\n\/\/ here, because we're performing a wrapped blur. Wrapping is not much different\n\/\/ to regular mapping. You just need to put \"p = mod(p, gSc)\" in the hash function\n\/\/ for anything that's procedurally generated with random numbers. If you're using\n\/\/ a repeat texture, then that'll have to wrap too.\nfloat gSc;\n\n\n\/\/ IQ's vec2 to float hash.\nfloat hash21(vec2 p){\n    p = mod(p, gSc);\n    return fract(sin(dot(p, vec2(27.609, 157.583)))*43758.5453); \n}\n\n\n\/\/ Commutative smooth maximum function. Provided by Tomkh, and taken \n\/\/ from Alex Evans's (aka Statix) talk: \n\/\/ http:\/\/media.lolrus.mediamolecule.com\/AlexEvans_SIGGRAPH-2015.pdf\n\/\/ Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n    \n   float f = max(0., 1. - abs(b - a)\/k);\n   return max(a, b) + k*.25*f*f;\n}\n\n\n\/\/ Commutative smooth minimum function. Provided by Tomkh, and taken \n\/\/ from Alex Evans's (aka Statix) talk: \n\/\/ http:\/\/media.lolrus.mediamolecule.com\/AlexEvans_SIGGRAPH-2015.pdf\n\/\/ Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)\/k);\n   return min(a, b) - k*.25*f*f;\n}\n\n\/*\n\/\/ IQ's exponential-based smooth maximum function. Unlike the polynomial-based\n\/\/ smooth maximum, this one is associative and commutative.\nfloat smaxExp(float a, float b, float k){\n\n    float res = exp(k*a) + exp(k*b);\n    return log(res)\/k;\n}\n*\/\n\n\/\/ IQ's exponential-based smooth minimum function. Unlike the polynomial-based\n\/\/ smooth minimum, this one is associative and commutative.\nfloat sminExp(float a, float b, float k){\n\n    float res = exp(-k*a) + exp(-k*b);\n    return -log(res)\/k;\n}\n\n\n\/\/ With the spare cycles, I thought I'd splash out and use Dave's more reliable hash function. :)\n\/\/\n\/\/ Dave's hash function. More reliable with large values, but will still eventually break down.\n\/\/\n\/\/ Hash without Sine.\n\/\/ Creative Commons Attribution-ShareAlike 4.0 International Public License.\n\/\/ Created by David Hoskins.\n\/\/ vec3 to vec3.\nvec3 hash33G(vec3 p){\n\n    \n    p = mod(p, gSc);\n\tp = fract(p * vec3(.10313, .10307, .09731));\n    p += dot(p, p.yxz + 19.1937);\n    p = fract((p.xxy + p.yxx)*p.zyx)*2. - 1.;\n    return p;\n   \n    \/*\n    \/\/ Note the \"mod\" call. Slower, but ensures accuracy with large time values.\n    mat2  m = rot2(mod(iTime, 6.2831853));\t\n\tp.xy = m * p.xy;\/\/rotate gradient vector\n    p.yz = m * p.yz;\/\/rotate gradient vector\n    \/\/p.zx = m * p.zx;\/\/rotate gradient vector\n\treturn p;\n    *\/\n\n}\n\n\/\/ Cheap vec3 to vec3 hash. I wrote this one. It's much faster than others, but I don't trust\n\/\/ it over large values.\nvec3 hash33(vec3 p){ \n   \n    \n    p = mod(p, gSc);\n    \/\/float n = sin(dot(p, vec3(7, 157, 113)));    \n    \/\/p = fract(vec3(2097152, 262144, 32768)*n)*2. - 1.; \n    \n    \/\/mat2  m = rot2(iTime);\/\/in general use 3d rotation\n\t\/\/p.xy = m * p.xy;\/\/rotate gradient vector\n    \/\/\/\/p.yz = m * p.yz;\/\/rotate gradient vector\n    \/\/\/\/p.zx = m * p.zx;\/\/rotate gradient vector\n\t\/\/return p;\n    \n    float n = sin(dot(p, vec3(57, 113, 27)));    \n    return fract(vec3(2097152, 262144, 32768)*n)*2. - 1.;  \n\n    \n    \/\/float n = sin(dot(p, vec3(7, 157, 113)));    \n    \/\/p = fract(vec3(2097152, 262144, 32768)*n); \n    \/\/return sin(p*6.2831853 + iTime)*.5; \n}\n\n\/\/ This is a variation on a regular 2-pass Voronoi traversal that produces a Voronoi\n\/\/ pattern based on the interior cell point to the nearest cell edge (as opposed\n\/\/ to the nearest offset point). It's a slight reworking of Tomkh's example, which\n\/\/ in turn, is based on IQ's original example. The links are below:\n\/\/\n\/\/ On a side note, I have no idea whether a faster solution is possible, but when I\n\/\/ have time, I'm going to try to find one anyway.\n\/\/\n\/\/ Voronoi distances - iq\n\/\/ https:\/\/www.shadertoy.com\/view\/ldl3W8\n\/\/\n\/\/ Here's IQ's well written article that describes the process in more detail.\n\/\/ http:\/\/www.iquilezles.org\/www\/articles\/voronoilines\/voronoilines.htm\n\/\/\n\/\/ Faster Voronoi Edge Distance - tomkh\n\/\/ https:\/\/www.shadertoy.com\/view\/llG3zy\n\/\/\n\/\/\nvec3 cellID;\nint gIFrame;\n\/\/\nvec3 Voronoi(in vec3 p, in vec3 rd){\n    \n    \/\/ One of Tomkh's snippets that includes a wrap to deal with\n    \/\/ larger numbers, which is pretty cool.\n\n \n    vec3 n = floor(p);\n    p -= n + .5;\n \n    \n    \/\/ Storage for all sixteen hash values. The same set of hash values are\n    \/\/ reused in the second pass, and since they're reasonably expensive to\n    \/\/ calculate, I figured I'd save them from resuse. However, I could be\n    \/\/ violating some kind of GPU architecture rule, so I might be making \n    \/\/ things worse... If anyone knows for sure, feel free to let me know.\n    \/\/\n    \/\/ I've been informed that saving to an array of vectors is worse.\n    \/\/vec2 svO[3];\n    \n    \/\/ Individual Voronoi cell ID. Used for coloring, materials, etc.\n    cellID = vec3(0); \/\/ Redundant initialization, but I've done it anyway.\n\n    \/\/ As IQ has commented, this is a regular Voronoi pass, so it should be\n    \/\/ pretty self explanatory.\n    \/\/\n    \/\/ First pass: Regular Voronoi.\n\tvec3 mo, o;\n    \n    \/\/ Minimum distance, \"smooth\" distance to the nearest cell edge, regular\n    \/\/ distance to the nearest cell edge, and a line distance place holder.\n    float md = 8., lMd = 8., lMd2 = 8., lnDist, d;\n    \n    \/\/ Note the ugly \"gIFrame\" hack. The idea is to force the compiler not\n    \/\/ to unroll the loops, thus keep the program size down... or something. \n    \/\/ GPU compilation is not my area... Come to think of it, none of this\n    \/\/ is my area. :D\n    for( int k=min(-2, gIFrame); k<=2; k++ ){\n    for( int j=min(-2, gIFrame); j<=2; j++ ){\n    for( int i=min(-2, gIFrame); i<=2; i++ ){\n    \n        o = vec3(i, j, k);\n        o += hash33(n + o) - p;\n        \/\/ Saving the hash values for reuse in the next pass. I don't know for sure,\n        \/\/ but I've been informed that it's faster to recalculate the had values in\n        \/\/ the following pass.\n        \/\/svO[j*3 + i] = o; \n  \n        \/\/ Regular squared cell point to nearest node point.\n        d = dot(o, o); \n\n        if( d<md ){\n            \n            md = d;  \/\/ Update the minimum distance.\n            \/\/ Keep note of the position of the nearest cell point - with respect\n            \/\/ to \"p,\" of course. It will be used in the second pass.\n            mo = o; \n            cellID = vec3(i, j, k) + n; \/\/ Record the cell ID also.\n        }\n       \n    }\n    }\n    }\n    \n    \/\/ Second pass: Distance to closest border edge. The closest edge will be one of the edges of\n    \/\/ the cell containing the closest cell point, so you need to check all surrounding edges of \n    \/\/ that cell, hence the second pass... It'd be nice if there were a faster way.\n    for( int k=min(-3, gIFrame); k<=3; k++ ){\n    for( int j=min(-3, gIFrame); j<=3; j++ ){\n    for( int i=min(-3, gIFrame); i<=3; i++ ){\n        \n        \/\/ I've been informed that it's faster to recalculate the hash values, rather than \n        \/\/ access an array of saved values.\n        o = vec3(i, j, k);\n        o += hash33(n + o) - p;\n        \/\/ I went through the trouble to save all sixteen expensive hash values in the first \n        \/\/ pass in the hope that it'd speed thing up, but due to the evolving nature of \n        \/\/ modern architecture that likes everything to be declared locally, I might be making \n        \/\/ things worse. Who knows? I miss the times when lookup tables were a good thing. :)\n        \/\/ \n        \/\/o = svO[j*3 + i];\n        \n        \/\/ Skip the same cell... I found that out the hard way. :D\n        if( dot(o - mo, o - mo)>.00001 ){ \n            \n            \/\/ This tiny line is the crux of the whole example, believe it or not. Basically, it's\n            \/\/ a bit of simple trigonometry to determine the distance from the cell point to the\n            \/\/ cell border line. See IQ's article for a visual representation.\n            lnDist = dot(0.5*(o + mo), normalize(o - mo));\n            \n            \/\/ Abje's addition. Border distance using a smooth minimum. Insightful, and simple.\n            \/\/\n            \/\/ On a side note, IQ reminded me that the order in which the polynomial-based smooth\n            \/\/ minimum is applied effects the result. However, the exponentional-based smooth\n            \/\/ minimum is associative and commutative, so is more correct. In this particular case, \n            \/\/ the effects appear to be negligible, so I'm sticking with the cheaper polynomial-based \n            \/\/ smooth minimum, but it's something you should keep in mind. By the way, feel free to \n            \/\/ uncomment the exponential one and try it out to see if you notice a difference.\n            \/\/\n            \/\/ \/\/ Polynomial-based smooth minimum.\n            \/\/lMd = smin(lMd, lnDist, lnDist*.75); \/\/lnDist*.75\n            \/\/\n            \/\/ Exponential-based smooth minimum. By the way, this is here to provide a visual reference \n            \/\/ only, and is definitely not the most efficient way to apply it. To see the minor\n            \/\/ adjustments necessary, refer to Tomkh's example here: Rounded Voronoi Edges Analysis - \n            \/\/ https:\/\/www.shadertoy.com\/view\/MdSfzD\n            lMd = sminExp(lMd, lnDist, 16.); \n            \n            \/\/ Minimum regular straight-edged border distance. If you only used this distance,\n            \/\/ the web lattice would have sharp edges.\n            lMd2 = min(lMd2, lnDist);\n        }\n\n    }\n    }\n    }\n\n    \/\/ Return the smoothed and unsmoothed distance. I think they need capping at zero... but \n    \/\/ I'm not positive.\n    return max(vec3(lMd, lMd2, md), 0.);\n}\n",
            "name": "Common",
            "description": "",
            "type": "common"
        },
        {
            "inputs": [
                {
                    "id": "4dX3Rr",
                    "filepath": "\/media\/a\/\/media\/previz\/cubemap00.png",
                    "previewfilepath": "\/media\/ap\/\/media\/previz\/cubemap00.png",
                    "type": "cubemap",
                    "channel": 0,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dX3Rr",
                    "channel": 0
                }
            ],
            "code": "\n\n\n\n\/\/ It can be a bit fiddly filling all four channels in at once, but thankfully, this is\n\/\/ all calculated at startup. The idea is to put the function you wish to use in the\n\/\/ middle of the loop here, instead of writing it out four times over.\nvec4 funcFace0(vec3 p){\n   \n    \n    vec3 pix = vec3(1.\/4.\/dims.x, 0, 0);\n \n    vec4 col;\n    \n    for(int i = 0; i<4; i++){\n        \n        gSc = 5.;\n        vec3 v = Voronoi(p*gSc, vec3(0));\n     \n        \/\/ The pixel channel value: On a side note, setting it to \"v.y\" is interesting,\n        \/\/ but not the look we're going for here.\n        col[i] = v.x;\n        \n        p += pix;\n        \n    }\n    \n    \/\/ Return the four function values -- One for each channel.\n    return col;\n    \n}\n\n\n\n\n\/\/ It can be a bit fiddly filling all four channels in at once, but thankfully, this is\n\/\/ all calculated at startup. The idea is to put the function you wish to use in the\n\/\/ middle of the loop here, instead of writing it out four times over.\nvec4 funcFace1(vec2 uv){\n    \n    \/\/ It's a 2D conversion, but we're using a 3D function with constant Z value.\n    vec3 p;\n    \/\/ Just choose any Z value you like. You could actually set \"p.z\" to any constant,\n    \/\/ or whatever, but I'm keeping things consistant.\n    p.z = floor(.1*cubemapRes.x)\/cubemapRes.x; \n       \n    vec4 col;\n    \n    for(int i = 0; i<4; i++){\n\n        \/\/ Since we're performing our own 2D interpolation, it makes sense to store\n        \/\/ neighboring values in the other pixel channels. It makes things slightly\n        \/\/ more confusing, but saves four texel lookups -- usually in the middel of\n        \/\/ a raymarching loop -- later on.\n        \n        \/\/ The neighboring position for each pixel channel.\n        p.xy = mod(floor(uv*cubemapRes) + vec2(i&1, i>>1), cubemapRes)\/cubemapRes;\n\n        \/\/ Put whatever function you want here. In this case, it's rounded Voronoi.\n        gSc = 8.;\n        vec3 v = Voronoi(p*gSc, vec3(0));\n        \n        \/\/ The pixel channel value: On a side note, setting it to \"v.y\" is interesting,\n        \/\/ but not the look we're going for here.\n        col[i] = v.x;\n\n    }\n    \n    return col;\n}\n\n\/\/ Converting your UV coordinates to 3D coordinates. I've seen some pretty longwinded\n\/\/ obfuscated conversions out there, but it shouldn't require anything more than \n\/\/ the following. By the way, the figure \"dims.x\" is factored down by four to account\n\/\/ for the four pixel channels being utilized, but the logic is the same.\nvec3 convert2DTo3D(vec2 uv){\n    \n    \/\/ Converting the fract(uv) coordinates from the zero to one range to the whole\n    \/\/ number, zero to... 1023 range.\n    uv = floor(uv*cubemapRes);\n    \n    \/\/ Converting the UV coordinate to a linear representation. The idea is to convert the\n    \/\/ 2D UV coordinates to a linear value, then use that to represent the 3D coordinates.\n    \/\/ This way, you can effectively fit all kinds of 3D dimensions into a 2D texture array\n    \/\/ without having to concern yourself with 2D texture wrapping issues. In theory, so \n    \/\/ long as the dimensions fit, and the X dimension is a multiple of four, then anything\n    \/\/ goes. As mentioned, the maximum cubic dimension allowable for one cube face is \n    \/\/ 160 cubed. In that respect, rectangular dimensions, like vec3(160, 80, 320), etc, \n    \/\/ would also fit.\n    \/\/\n    \/\/ For instance, the 137th pixel in the third row on a 1024 by 1024 cubemap face texture \n    \/\/ would be the number 2185 (2*1024 + 137).\n    float iPos = dot(uv, vec2(1, cubemapRes.x));\n    \n    \/\/ In this case the XY slices comprise of 160 pixels (or whatever number we choose) along \n    \/\/ X and Y, so the pixel position in any block would be modulo 160*160. The xyBlock position \n    \/\/ would have to be converted to X and Y positions, which would be xyBlock mod dimX, and \n    \/\/ floor(xyBlock\/dimX) mod dimY respectively. The Z position would depend on how many \n    \/\/ 160 by 160 blocks deep we're in, which translates to floor(iPos\/(dimX*dimY)).\n    \/\/\n    \/\/ Anyway, that's what the following lines represent.\n    \n    \/\/ XY block (or slice) linear position.\n    float xyBlock = mod(iPos, dims.x*dims.y);\n    \n    \/\/ Converting to X, Y and Z position.\n    vec3 p = vec3(mod(floor(vec3(xyBlock, xyBlock, iPos)\/vec3(1, dims.x, dims.x*dims.y)), dims));\n    \n    \/\/vec3 p = vec3(mod(xySlice, dims.x), mod(floor((xySlice)\/dims.x), dims.y),\n                  \/\/floor((iPos)\/(dims.x*dims.y)));\n    \n    \/\/ It's not necessary, but I'm converting the 3D coordinates back to the zero to one\n    \/\/ range... There'd be nothing stopping you from centralizing things (p\/dims - .5), but \n    \/\/ this will do.\n    return p\/dims;\n}\n\n\n\n\/\/ Cube mapping - Adapted from one of Fizzer's routines. \nint CubeFaceCoords(vec3 p){\n\n    \/\/ Elegant cubic space stepping trick, as seen in many voxel related examples.\n    vec3 f = abs(p); f = step(f.zxy, f)*step(f.yzx, f); \n    \n    ivec3 idF = ivec3(p.x<.0? 0 : 1, p.y<.0? 2 : 3, p.z<0.? 4 : 5);\n    \n    return f.x>.5? idF.x : f.y>.5? idF.y : idF.z; \n}\n\n\n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir){\n    \n    \n    \/\/ UV coordinates.\n    \/\/\n    \/\/ For whatever reason (which I'd love expained), the Y coordinates flip each\n    \/\/ frame if I don't negate the coordinates here -- I'm assuming this is internal, \n    \/\/ a VFlip thing, or there's something I'm missing. If there are experts out there, \n    \/\/ any feedback would be welcome. :)\n    vec2 uv = fract(fragCoord\/iResolution.y*vec2(1, -1));\n    \n    \/\/ Adapting one of Fizzer's old cube mapping routines to obtain the cube face ID \n    \/\/ from the ray direction vector.\n    int faceID = CubeFaceCoords(rayDir);\n  \n  \n    \/\/ Pixel storage.\n    vec4 col;\n    \n\n    \/\/ Initial conditions -- Performed upon initiation.\n    if(abs(tx(iChannel0, uv, 5).w - iResolution.y)>.001){\n    \/\/if(iFrame==0){\n        \n        \/\/ This is part of an ugly hack that attempts to force the GPU compiler\n        \/\/ to not unroll the Voronoi loops. Not sure if it'll work, but I'm \n        \/\/ trying it anyway, in the hope to get compiler times down on some\n        \/\/ machines. For the record, this takes about 3 seconds to compile on \n        \/\/ my machine.\n        gIFrame = iFrame;\n        \n        \n        \/*\n        \/\/ Debug information for testing individual cubeface access.\n        if(faceID==0) col = vec4(0, 1, 0, 1);\n        else if(faceID==1) col = vec4(0, .5, 1, 1);\n        else if(faceID==2) col = vec4(1, 1, 0, 1);\n        else if(faceID==3) col = vec4(1, 0, 0, 1);\n        else if(faceID==4) col = vec4(.5, .5, .5, 1);\n        else col = vec4(1, 1, 1, 1);\n        *\/\n        \n        \n        \/\/ Fill the first cube face with a custum 3D function.\n        if(faceID==0){\n            \n            vec3 p = convert2DTo3D(uv);\n            \n            col = funcFace0(p);\n           \n        }\n        \n        \/\/ Fill the second cube face with a custom 2D function... We're actually\n        \/\/ reusing a 3D function, but it's in slice form, which essentially makes\n        \/\/ it a 2D function.\n        if(faceID==1){\n\n            col = funcFace1(uv);\n            \n        }\n        \n        \n        \/\/ Last channel on the last face: Used to store the current \n        \/\/ resolution to ensure loading... Yeah, it's wasteful and it\n        \/\/ slows things down, but until there's a reliable initiation\n        \/\/ variable, I guess it'll have to do. :)\n        if(faceID==5){\n            \n            col.w = iResolution.y;\n        }\n\n        \n    }\n    else {\n        \t\n        \/\/ The cube faces have already been initialized with values, so from this point,\n        \/\/ read the values out... There's probably a way to bypass this by using the \n        \/\/ \"discard\" operation, but this isn't too expensive, so I'll leave it for now.\n        col = tx(iChannel0, uv, faceID);\n    }\n    \n    \n    \/\/ Update the cubemap faces.\n    fragColor = col;\n    \n}\n\n",
            "name": "Cube A",
            "description": "",
            "type": "cubemap"
        }
    ]
}