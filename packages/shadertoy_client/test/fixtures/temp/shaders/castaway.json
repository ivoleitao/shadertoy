{
    "ver": "0.1",
    "info": {
        "id": "wt3XDj",
        "date": "1585951890",
        "viewed": 2112,
        "name": "Castaway",
        "username": "P_Malin",
        "description": "SPACE = Toggle Flycam\nWASD \/ click + mouse to move\nShift = Move faster",
        "likes": 98,
        "published": 3,
        "flags": 112,
        "usePreview": 0,
        "tags": [
            "raymarch",
            "sea",
            "water",
            "sky",
            "beach"
        ],
        "hasliked": 0
    },
    "renderpass": [
        {
            "inputs": [
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 3,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "4sXGR8",
                    "filepath": "\/media\/previz\/buffer02.png",
                    "previewfilepath": "\/media\/previz\/buffer02.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "XtB3Wh",
                    "filepath": "https:\/\/soundcloud.com\/soundsofnaturewhitenoisesoundeffects\/waves-tropical-ocean-waves",
                    "previewfilepath": "https:\/\/soundcloud.com\/soundsofnaturewhitenoisesoundeffects\/waves-tropical-ocean-waves",
                    "type": "musicstream",
                    "channel": 2,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 0
                }
            ],
            "outputs": [
                {
                    "id": "4dfGRr",
                    "channel": 0
                }
            ],
            "code": "\/\/     _____             _                                \n\/\/    \/ ____|           | |                               \n\/\/   | |      __ _  ___ | |_  __ _ __      __ __ _  _   _ \n\/\/   | |     \/ _` |\/ __|| __|\/ _` |\\ \\ \/\\ \/ \/\/ _` || | | |\n\/\/   | |____| (_| |\\__ \\| |_| (_| | \\ V  V \/| (_| || |_| |\n\/\/    \\_____|\\__,_||___\/ \\__|\\__,_|  \\_\/\\_\/  \\__,_| \\__, |\n\/\/                                                   __\/ |\n\/\/                                                  |___\/ \n\n\/\/ Castaway by @P_Malin\n\n\/\/ https:\/\/www.shadertoy.com\/view\/wt3XDj\n\n\/\/ Controls:\n\/\/ SPACE = Toggle Flycam\n\/\/ WASD \/ click + mouse to move\n\/\/ Shift = Move faster\n\n\/\/ YouTube Video Here: https:\/\/youtu.be\/bSg5nb_UTVM\n\n\/\/ ASCII Comments: http:\/\/patorjk.com\/software\/taag\/#p=display&h=2&c=c%2B%2B&f=Big&t=My%20Comment\n\n\/\/    _____                               _____ _               _                      _____          _   ______    \n\/\/   |_   _|                             \/ ____| |             | |                    |  __ \\        | | |  ____|   \n\/\/     | |  _ __ ___   __ _  __ _  ___  | (___ | |__   __ _  __| | ___ _ __   ______  | |__) |__  ___| |_| |____  __\n\/\/     | | | '_ ` _ \\ \/ _` |\/ _` |\/ _ \\  \\___ \\| '_ \\ \/ _` |\/ _` |\/ _ \\ '__| |______| |  ___\/ _ \\\/ __| __|  __\\ \\\/ \/\n\/\/    _| |_| | | | | | (_| | (_| |  __\/  ____) | | | | (_| | (_| |  __\/ |             | |  | (_) \\__ \\ |_| |   >  < \n\/\/   |_____|_| |_| |_|\\__,_|\\__, |\\___| |_____\/|_| |_|\\__,_|\\__,_|\\___|_|             |_|   \\___\/|___\/\\__|_|  \/_\/\\_\\\n\/\/                           __\/ |                                                                                  \n\/\/                          |___\/                                                                                   \n\nfloat Vignette( vec2 uv, float size )\n{\n    float d = length( (uv - 0.5f) * 2.0f ) \/ length(vec2(1.0));\n    \n    d \/= size;\n    \n    float s = d * d * ( 3.0f - 2.0f * d );\n    \n    float v = mix ( d, s, 0.6f );\n    \n    return max(0.0, 1.0f - v);\n}\n\n\nvec3 PostProcessColour( vec3 color )\n{\n    float exposure = 1.0f;\n    \n    color = color * exposure;\n    \n    color = 1.0f - exp( -color );    \n    float gamma = 2.2f;    \n    color = pow( color, vec3( 1.0f \/ gamma ) );\n\n            \n    return color;\n}\n\n\n#define ENABLE_DOF\n\nfloat GetCoC( float fDistance, float fPlaneInFocus )\n{\n#ifdef ENABLE_DOF    \n\t\/\/ http:\/\/http.developer.nvidia.com\/GPUGems\/gpugems_ch23.html\n\n    float fAperture = min(1.0, fPlaneInFocus * fPlaneInFocus * 0.5);\n    float fFocalLength = 0.02;\n    \n\treturn abs(fAperture * (fFocalLength * (fDistance - fPlaneInFocus)) \/\n          (fDistance * (fPlaneInFocus - fFocalLength)));  \n#else\n    return 0.0f;\n#endif    \n}\n\nvec3 SampleWithDOF( ivec2 pos, float planeInFocus )\n{\n\tvec4 vCenterSample = texelFetch( iChannel0, pos, 0 );    \n    float CoC = GetCoC( vCenterSample.w, planeInFocus );\n        \n\t#define DOF_SIZE 6\n    #define DOF_SIZE_F float( DOF_SIZE )\n    \n    #define DOF_BLOOM_STRENGTH 2.0\n    \n    CoC = CoC * 500.0;\n        \n    float testRadius = CoC * CoC;\n    \n    bool bloom = false;\n    if ( CoC <= 1.0f )\n    {\n        testRadius = DOF_SIZE_F;\n        bloom = true;\n    }\n    \n\tvec3 vResult = vec3(0.0);    \n    float fTot = 0.0;\n    \n    {\n        float fY = -DOF_SIZE_F;\n        for( int y=-DOF_SIZE; y<=DOF_SIZE; y++ )\n        {\n            float fX = -DOF_SIZE_F;\n            for( int x=-DOF_SIZE; x<=DOF_SIZE; x++ )\n            {            \n                vec2 vOffset = vec2( fX, fY );\n                float r2 = dot( vOffset, vOffset );\n                if ( r2 < testRadius )\n                {                \n                    ivec2 iOffset = ivec2( x,y );\n                    vec4 vTapSample = texelFetch( iChannel0, pos + iOffset, 0 );\n                    \n                    float fWeight = 1.0f;\n                    \n                    if ( bloom )\n                    {\n\t\t            \tfWeight = exp2( -r2 * DOF_BLOOM_STRENGTH );                        \n                    }\n                    \n                    vResult += vTapSample.rgb * fWeight;\n                    fTot += fWeight;\n                }\n                fX+=1.0f;\n            }\n            fY+=1.0f;\n        }\n    }\n    \n    vResult = vResult \/ fTot;\n    \n    return vResult;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n\n\tvec4 vCenterScreenSample = texelFetch( iChannel0, ivec2(iResolution.xy \/ 2.), 0 );\n    float planeInFocus = vCenterScreenSample.w;\n    \n    vec3 sceneColour = SampleWithDOF( ivec2( fragCoord ), planeInFocus );\n    \n    sceneColour.rgb *= 0.2 + 0.8 * Vignette( uv, 1.0 );\n    \n    vec3 outputColour = PostProcessColour( sceneColour.rgb );    \n\n#if 0\n    CameraState cam;\n    Cam_LoadState( cam, iChannel3, ivec2(0,0) );\n    \n    Cam_DebugOverlay( outputColour, cam, uv, planeInFocus );\n#endif\n    \n    fragColor = vec4(outputColour, 1.0);    \n}\n",
            "name": "Image",
            "description": "",
            "type": "image"
        },
        {
            "inputs": [],
            "outputs": [],
            "code": "\/\/     _____                                           \n\/\/    \/ ____|                                          \n\/\/   | |      ___   _ __ ___   _ __ ___    ___   _ __  \n\/\/   | |     \/ _ \\ | '_ ` _ \\ | '_ ` _ \\  \/ _ \\ | '_ \\ \n\/\/   | |____| (_) || | | | | || | | | | || (_) || | | |\n\/\/    \\_____|\\___\/ |_| |_| |_||_| |_| |_| \\___\/ |_| |_|\n\/\/                                                     \n\/\/                                                     \n\n#define PI\t3.141592654\n#define TAU 6.283185308\n\n#define ZERO (min(0,iFrame))\n\n\n#define IOR_AIR \t1.0f\n#define IOR_WATER \t1.33f\n\n\nfloat RadianceChange( float IA, float IB )\n{\n    float x = IB \/ IA;\n    return x * x;\n}\n\n\n\/\/  ____        _          ____  _                             \n\/\/ |  _ \\  __ _| |_ __ _  \/ ___|| |_ ___  _ __ __ _  __ _  ___ \n\/\/ | | | |\/ _` | __\/ _` | \\___ \\| __\/ _ \\| '__\/ _` |\/ _` |\/ _ \\\n\/\/ | |_| | (_| | || (_| |  ___) | || (_) | | | (_| | (_| |  __\/\n\/\/ |____\/ \\__,_|\\__\\__,_| |____\/ \\__\\___\/|_|  \\__,_|\\__, |\\___|\n\/\/                                                  |___\/      \n\/\/\n\nvec4 LoadVec4( sampler2D sampler, in ivec2 addr )\n{\n    return texelFetch( sampler, addr, 0 );\n}\n\nvec3 LoadVec3( sampler2D sampler, in ivec2 addr )\n{\n    return LoadVec4( sampler, addr ).xyz;\n}\n\nbool AtAddress( ivec2 p, ivec2 c ) { return all( equal( p, c ) ); }\n\nvoid StoreVec4( in ivec2 addr, in vec4 value, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    fragColor = AtAddress( fragCoord, addr ) ? value : fragColor;\n}\n\nvoid StoreVec3( in ivec2 addr, in vec3 value, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    StoreVec4( addr, vec4( value, 0.0 ), fragColor, fragCoord );\n}\n\n\/\/\n\/\/  ____       _        _   _             \n\/\/ |  _ \\ ___ | |_ __ _| |_(_) ___  _ __  \n\/\/ | |_) \/ _ \\| __\/ _` | __| |\/ _ \\| '_ \\ \n\/\/ |  _ < (_) | || (_| | |_| | (_) | | | |\n\/\/ |_| \\_\\___\/ \\__\\__,_|\\__|_|\\___\/|_| |_|\n\/\/                                        \n\/\/\n\nvec3 RotateX( const in vec3 pos, const in float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    \n    vec3 result = vec3( pos.x, c * pos.y + s * pos.z, -s * pos.y + c * pos.z );\n    \n    return result;\n}\n\nvec3 RotateY( const in vec3 pos, const in float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    \n    vec3 result = vec3( c * pos.x + s * pos.z, pos.y, -s * pos.x + c * pos.z );\n    \n    return result;\n}\n\nvec3 RotateZ( const in vec3 pos, const in float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    \n    vec3 result = vec3( c * pos.x + s * pos.y, -s * pos.x + c * pos.y, pos.z );\n    \n    return result;\n}\n\n\nmat3 MatFromAngles( vec3 angles )\n{\n    mat3 rotX = mat3(1.0, 0.0, 0.0, \n                     0.0, cos(angles.x), sin(angles.x), \n                     0.0, -sin(angles.x), cos(angles.x));\n    \n    mat3 rotY = mat3(cos(angles.y), 0.0, -sin(angles.y), \n                     0.0, 1.0, 0.0, \n                     sin(angles.y), 0.0, cos(angles.y));    \n\n    mat3 rotZ = mat3(cos(angles.z), sin(angles.z), 0.0,\n                     -sin(angles.z), cos(angles.z), 0.0,\n                     0.0, 0.0, 1.0 );\n    \n    \n    mat3 m = rotY * rotX * rotZ;\n    \n    return m;\n}\n\n\n\/\/   ___              _                  _             \n\/\/  \/ _ \\ _   _  __ _| |_ ___ _ __ _ __ (_) ___  _ __  \n\/\/ | | | | | | |\/ _` | __\/ _ \\ '__| '_ \\| |\/ _ \\| '_ \\ \n\/\/ | |_| | |_| | (_| | ||  __\/ |  | | | | | (_) | | | |\n\/\/  \\__\\_\\\\__,_|\\__,_|\\__\\___|_|  |_| |_|_|\\___\/|_| |_|\n\/\/                                                     \n\/\/\n\nvec4 QuatMul( vec4 lhs, vec4 rhs ) \n{\n      return vec4( lhs.y * rhs.z - lhs.z * rhs.y + lhs.x * rhs.w + lhs.w *rhs.x,\n                   lhs.z * rhs.x - lhs.x * rhs.z + lhs.y * rhs.w + lhs.w *rhs.y,\n                   lhs.x * rhs.y - lhs.y * rhs.x + lhs.z * rhs.w + lhs.w *rhs.z,\n                   lhs.w * rhs.w - lhs.x * rhs.x - lhs.y * rhs.y - lhs.z *rhs.z );\n}\n\nvec4 QuatFromAxisAngle( vec3 axis, float angle )\n{\n\treturn vec4( normalize(axis) * sin( angle ), cos( angle ) );    \n}\n\nvec4 QuatFromVec3( vec3 rot )\n{\n    float l = length( rot );\n    if ( l <= 0.0 )\n    {\n        return vec4( 0.0, 0.0, 0.0, 1.0 );\n    }\n    return QuatFromAxisAngle( rot, l );\n}\n\nmat3 QuatToMat3( const in vec4 q )\n{\n\tvec4 qSq = q * q;\n\tfloat xy2 = q.x * q.y * 2.0;\n\tfloat xz2 = q.x * q.z * 2.0;\n\tfloat yz2 = q.y * q.z * 2.0;\n\tfloat wx2 = q.w * q.x * 2.0;\n\tfloat wy2 = q.w * q.y * 2.0;\n\tfloat wz2 = q.w * q.z * 2.0;\n \n\treturn mat3 (\t\n     qSq.w + qSq.x - qSq.y - qSq.z, xy2 - wz2, xz2 + wy2,\n     xy2 + wz2, qSq.w - qSq.x + qSq.y - qSq.z, yz2 - wx2,\n     xz2 - wy2, yz2 + wx2, qSq.w - qSq.x - qSq.y + qSq.z );\n}\n\nvec3 QuatMul( vec3 v, vec4 q )\n{\n    \/\/ TODO Validate vs other quat code\n    vec3 t = 2.0 * cross(q.xyz, v);\n\treturn v + q.w * t + cross(q.xyz, t);\n}\n\n\/\/\n\/\/  _  __          _                         _ \n\/\/ | |\/ \/___ _   _| |__   ___   __ _ _ __ __| |\n\/\/ | ' \/\/ _ \\ | | | '_ \\ \/ _ \\ \/ _` | '__\/ _` |\n\/\/ | . \\  __\/ |_| | |_) | (_) | (_| | | | (_| |\n\/\/ |_|\\_\\___|\\__, |_.__\/ \\___\/ \\__,_|_|  \\__,_|\n\/\/           |___\/                             \n\/\/\n\nconst int KEY_SPACE = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\nconst int KEY_COMMA = 188;\nconst int KEY_PER   = 190;\n\nconst int KEY_1 = \t49;\nconst int KEY_2 = \t50;\nconst int KEY_3 = \t51;\nconst int KEY_ENTER = 13;\nconst int KEY_SHIFT = 16;\nconst int KEY_CTRL  = 17;\nconst int KEY_ALT   = 18;\nconst int KEY_TAB\t= 9;\n\nbool Key_IsPressed( sampler2D samp, int key )\n{\n    return texelFetch( samp, ivec2(key, 0), 0 ).x > 0.0;    \n}\n\nbool Key_IsToggled(sampler2D samp, int key )\n{\n    return texelFetch( samp, ivec2(key, 2), 0 ).x > 0.0;    \n}\n\n\/\/ ---- 8< ---- GLSL Number Printing - @P_Malin ---- 8< ----\n\/\/ Creative Commons CC0 1.0 Universal (CC-0) \n\/\/ https:\/\/www.shadertoy.com\/view\/4sBSWW\n\nfloat DigitBin( const int x )\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue( vec2 vStringCoords, float fValue, float fMaxDigits, float fDecimalPlaces )\n{       \n    if ((vStringCoords.y < 0.0) || (vStringCoords.y >= 1.0)) return 0.0;\n    \n    bool bNeg = ( fValue < 0.0 );\n\tfValue = abs(fValue);\n    \n\tfloat fLog10Value = log2(abs(fValue)) \/ log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n\t\t\tif((bNeg) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} else {\n                float fReducedRangeValue = fValue;\n                if(fDigitIndex < 0.0) { fReducedRangeValue = fract( fValue ); fDigitIndex += 1.0; }\n\t\t\t\tfloat fDigitValue = (abs(fReducedRangeValue \/ (pow(10.0, fDigitIndex))));\n                fCharBin = DigitBin(int(floor(mod(fDigitValue, 10.0))));\n\t\t\t}\n        }\n\t}\n    return floor(mod((fCharBin \/ pow(2.0, floor(fract(vStringCoords.x) * 4.0) + (floor(vStringCoords.y * 5.0) * 4.0))), 2.0));\n}\n\n\/\/ ---- 8< -------- 8< -------- 8< -------- 8< ----\n\n\n\/\/\n\/\/   ____                               \n\/\/  \/ ___|__ _ _ __ ___   ___ _ __ __ _ \n\/\/ | |   \/ _` | '_ ` _ \\ \/ _ \\ '__\/ _` |\n\/\/ | |__| (_| | | | | | |  __\/ | | (_| |\n\/\/  \\____\\__,_|_| |_| |_|\\___|_|  \\__,_|\n\/\/                                      \n\n\nstruct CameraState\n{\n    vec3 vPos;\n    vec3 vTarget;\n    vec3 vUp;\n    float fFov;\n    vec2 vJitter;\n    float fPlaneInFocus;\n};\n    \nvoid Cam_LoadState( out CameraState cam, sampler2D sampler, ivec2 addr )\n{\n    vec4 vPos = LoadVec4( sampler, addr + ivec2(0,0) );\n    cam.vPos = vPos.xyz;\n    vec4 targetFov = LoadVec4( sampler, addr + ivec2(1,0) );\n    cam.vTarget = targetFov.xyz;\n    cam.fFov = targetFov.w;\n    vec4 vUp = LoadVec4( sampler, addr + ivec2(2,0) );\n    cam.vUp = vUp.xyz;\n    \n    vec4 jitterDof = LoadVec4( sampler, addr + ivec2(3,0) );\n    cam.vJitter = jitterDof.xy;\n    cam.fPlaneInFocus = jitterDof.z;\n}\n\nvoid Cam_StoreState( ivec2 addr, const in CameraState cam, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    StoreVec4( addr + ivec2(0,0), vec4( cam.vPos, 0 ), fragColor, fragCoord );\n    StoreVec4( addr + ivec2(1,0), vec4( cam.vTarget, cam.fFov ), fragColor, fragCoord );    \n    StoreVec4( addr + ivec2(2,0), vec4( cam.vUp, 0 ), fragColor, fragCoord );    \n    StoreVec4( addr + ivec2(3,0), vec4( cam.vJitter, cam.fPlaneInFocus, 0 ), fragColor, fragCoord );    \n}\n\nmat3 Cam_GetWorldToCameraRotMatrix( const CameraState cameraState )\n{\n    vec3 vForward = normalize( cameraState.vTarget - cameraState.vPos );\n\tvec3 vRight = normalize( cross( cameraState.vUp, vForward) );\n\tvec3 vUp = normalize( cross(vForward, vRight) );\n    \n    return mat3( vRight, vUp, vForward );\n}\n\nvec2 Cam_GetViewCoordFromUV( vec2 vUV, float fAspectRatio )\n{\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= fAspectRatio;\n\n\treturn vWindow;\t\n}\n\nvoid Cam_GetCameraRay( const vec2 vUV, const float fAspectRatio, const CameraState cam, out vec3 vRayOrigin, out vec3 vRayDir )\n{\n    vec2 vView = Cam_GetViewCoordFromUV( vUV, fAspectRatio );\n    vRayOrigin = cam.vPos;\n    float fPerspDist = 1.0 \/ tan( radians( cam.fFov ) );\n    vRayDir = normalize( Cam_GetWorldToCameraRotMatrix( cam ) * vec3( vView, fPerspDist ) );\n}\n\n\/\/ fAspectRatio = iResolution.x \/ iResolution.y;\nvec2 Cam_GetUVFromWindowCoord( const in vec2 vWindow, float fAspectRatio )\n{\n    vec2 vScaledWindow = vWindow;\n    vScaledWindow.x \/= fAspectRatio;\n\n    return (vScaledWindow * 0.5 + 0.5);\n}\n\nvec2 Cam_WorldToWindowCoord(const in vec3 vWorldPos, const in CameraState cameraState )\n{\n    vec3 vOffset = vWorldPos - cameraState.vPos;\n    vec3 vCameraLocal;\n\n    vCameraLocal = vOffset * Cam_GetWorldToCameraRotMatrix( cameraState );\n\t\n    vec2 vWindowPos = vCameraLocal.xy \/ (vCameraLocal.z * tan( radians( cameraState.fFov ) ));\n    \n    return vWindowPos;\n}\n\nvoid Cam_DebugOverlay( inout vec3 colour, CameraState cam, vec2 uv, float depth )\n{\n    vec2 pos = uv * vec2(80,30);\n    pos.x -= 2.0;\n    pos.y -= 28.0;\n    \n    if ( pos.x > -0.5 && pos.y < 1.5 && pos.x < 40.5 && pos.y > -4.5 )\n    {\n        colour = vec3(0);\n    }\n    \n    vec2 hpos = pos;\n    colour = mix( colour, vec3(0,0,1), PrintValue( hpos, cam.vPos.x, 3.0, 3.0 ) );\n    hpos.x -= 10.0;\n    colour = mix( colour, vec3(0,0,1), PrintValue( hpos, cam.vPos.y, 3.0, 3.0 ) );\n    hpos.x -= 10.0;\n    colour = mix( colour, vec3(0,0,1), PrintValue( hpos, cam.vPos.z, 3.0, 3.0 ) );\n    hpos.x -= 10.0;\n    \n    pos.y += 1.3;\n    \n\thpos = pos;\n    colour = mix( colour, vec3(1,0,1), PrintValue( hpos, cam.vTarget.x, 3.0, 3.0 ) );\n    hpos.x -= 10.0;\n    colour = mix( colour, vec3(1,0,1), PrintValue( hpos, cam.vTarget.y, 3.0, 3.0 ) );\n    hpos.x -= 10.0;\n    colour = mix( colour, vec3(1,0,1), PrintValue( hpos, cam.vTarget.z, 3.0, 3.0 ) );\n    hpos.x -= 10.0;\n    \n    pos.y += 1.3;\n    \n\thpos = pos;\n    colour = mix( colour, vec3(0,1,0), PrintValue( hpos, cam.fFov, 3.0, 3.0 ) );\n    hpos.x -= 10.0;\n    colour = mix( colour, vec3(0,1,0), PrintValue( hpos, depth, 3.0, 3.0 ) );\n    \n    \n    vec3 vDir = normalize(cam.vTarget - cam.vPos);\n    vec3 vTarget2 = cam.vPos + vDir * depth;\n    \n    pos.y += 1.3;\n    \n\thpos = pos;\n    colour = mix( colour, vec3(0,1,1), PrintValue( hpos, vTarget2.x, 3.0, 3.0 ) );\n    hpos.x -= 10.0;\n    colour = mix( colour, vec3(0,1,1), PrintValue( hpos, vTarget2.y, 3.0, 3.0 ) );\n    hpos.x -= 10.0;\n    colour = mix( colour, vec3(0,1,1), PrintValue( hpos, vTarget2.z, 3.0, 3.0 ) );\n    hpos.x -= 10.0;    \n}\n\n\/\/  _   _           _       _____                 _   _                 \n\/\/ | | | | __ _ ___| |__   |  ___|   _ _ __   ___| |_(_) ___  _ __  ___ \n\/\/ | |_| |\/ _` \/ __| '_ \\  | |_ | | | | '_ \\ \/ __| __| |\/ _ \\| '_ \\\/ __|\n\/\/ |  _  | (_| \\__ \\ | | | |  _|| |_| | | | | (__| |_| | (_) | | | \\__ \\\n\/\/ |_| |_|\\__,_|___\/_| |_| |_|   \\__,_|_| |_|\\___|\\__|_|\\___\/|_| |_|___\/\n\/\/                                                                      \n\n\/\/ From: Hash without Sine by Dave Hoskins\n\/\/ https:\/\/www.shadertoy.com\/view\/4djSRW\n\n\/\/ *** Use this for integer stepped ranges, ie Value-Noise\/Perlin noise functions.\n\/\/#define HASHSCALE1 .1031\n\/\/#define HASHSCALE3 vec3(.1031, .1030, .0973)\n\/\/#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\n\/\/ For smaller input rangers like audio tick or 0-1 UVs use these...\n#define HASHSCALE1 443.8975\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n#define HASHSCALE4 vec3(443.897, 441.423, 437.195, 444.129)\n\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ Hash without Sine\n\/\/ MIT License...\n\/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and\/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*\/\n\n\/\/----------------------------------------------------------------------------------------\n\/\/  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/\/  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/\/  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n\/\/----------------------------------------------------------------------------------------\n\/\/\/  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/\/  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n\n\/\/ http:\/\/www.iquilezles.org\/www\/articles\/intersectors\/intersectors.htm\n\/\/ sphere of size ra centered at point ce\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); \/\/ no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\n\/\/ http:\/\/iquilezles.org\/www\/articles\/smin\/smin.htm\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)\/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\/\/ http:\/\/iquilezles.org\/www\/articles\/smin\/smin.htm\nfloat smax( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)\/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Smoothnoise\n\nvec2 SmoothNoise22( vec2 o ) \n{\n\tvec2 p = floor(o);\n\tvec2 f = fract(o);\n\t\t\n\tfloat n = p.x + p.y*57.0;\n\n\tvec2 a = hash21(n+  0.0);\n\tvec2 b = hash21(n+  1.0);\n\tvec2 c = hash21(n+ 57.0);\n\tvec2 d = hash21(n+ 58.0);\n\t\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\t\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\t\n\tfloat u = t.x;\n\tfloat v = t.y;\n\n\tvec2 res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n    \n    return res;\n}\n\n\nvec3 SmoothNoise32( vec2 o ) \n{\n\tvec2 p = floor(o);\n\tvec2 f = fract(o);\n\t\t\n\tfloat n = p.x + p.y*57.0;\n\n\tvec3 a = hash31(n+  0.0);\n\tvec3 b = hash31(n+  1.0);\n\tvec3 c = hash31(n+ 57.0);\n\tvec3 d = hash31(n+ 58.0);\n\t\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\t\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\t\n\tfloat u = t.x;\n\tfloat v = t.y;\n\n\tvec3 res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n    \n    return res;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Sky \/ Environment sampling\n\t   \nstruct EnvironmentSettings\n{\n    float time;\n    \n    vec3 skyZenithCol;\n    vec3 skyHorizonCol;\n    \n    vec3 sunDiscCol;\n    vec3 sunLightCol;\n    \n    vec3 ambientCol;\n    \n    float sunElevation;\n    float sunHeading;\n    vec3 sunDir;\n    \n    vec3 fogCol;\n    float fogDensity;\n    float skyFogDensity;\n};\n\nfloat CloudSample( sampler2D iChannel, vec2 uv, float time, float spread )\n{\n    vec2 cloudUV0 = uv;\n    cloudUV0 += time * 0.0005;\n    vec2 cloudUV1 = cloudUV0 * 2.0f; \n    cloudUV1 += time * 0.0005;\n    float cloudSampleA0 = texture( iChannel, cloudUV0, spread ).r;    \n    float cloudSampleA1 = texture( iChannel, cloudUV1, spread ).b;\n\tfloat cloudDensityA = cloudSampleA0 * 0.7 + cloudSampleA1 * 0.3;\n    \n    return cloudDensityA;\n}\n\nvec4 TraceSky( EnvironmentSettings env, sampler2D iChannel, vec3 dir, float time, float spread, bool sunDisc )\n{       \n    \/\/ sky gradient\n    float f = clamp( 1.0 - dir.y, 0.0f, 1.0f );    \n    f = f * f * f * f;\n    vec3 col = mix( env.skyZenithCol, env.skyHorizonCol, f );    \n    \n    \/\/ sun disc\n    float VdotL = dot( dir, env.sunDir );        \n    \n    if ( sunDisc )\n    {\n        const float a0 = cos( radians( 1.0 ) );\n        const float a1 = cos( radians( 0.8 ) );\n\n        float sunBlend = smoothstep( a0, a1, VdotL );\n        col = mix( col, env.sunDiscCol, sunBlend );    \n    }\n    \n    float dist = 100000.0;\n    \n    \/\/ cloud layer \n    if ( dir.y > 0.0 )\n    {\n        float earthRadius = 6371000.0f;\n        vec3 earthOrigin = vec3(0.0f, -earthRadius, 0.0f );\n        float cloudHeight = 6000.0f;\n        float cloudRadius = earthRadius + cloudHeight;\n\n        vec2 cloudInt = sphIntersect( vec3(0), dir, earthOrigin, cloudRadius );\n        float cloudT = cloudInt.y;\n        \n        dist = cloudT;\n\n\n        vec3 cloudPos = dir * cloudT;\n\n        vec3 cloudN = normalize( cloudPos - earthOrigin );\n\n        vec2 cloudUV = cloudPos.xz * 0.00001f;\n        float cloudDensityA = CloudSample( iChannel, cloudUV, time, spread );\n        float bumpOffset = 0.0003f;\n        float cloudDensityB = CloudSample( iChannel, cloudUV - env.sunDir.xz * bumpOffset, time, spread );\n\n        float cloudDensity = (cloudDensityA + cloudDensityB) * 0.5;\n\n        \/\/ bumpmap towards sun\n        float cloudBumpLight = max( 0.0f, (cloudDensityB - cloudDensityA) * 1.5 + 0.5);\n\n        float sunThicknessFactor = 1.0 \/ dot( cloudN, env.sunDir );\n        \n        sunThicknessFactor = abs( sunThicknessFactor );\n\n\n        float toSunFactor = 1.0 - max( 0.0, dot(dir, env.sunDir));\n        float toSunAmount = exp( toSunFactor * -20.0 );\n        \n        float cloudSunLight = cloudBumpLight * (1.0 + toSunAmount * 2.5);\n\n        float viewThicknessFactor = 1.0 \/ dot( cloudN, dir );\n\n        float cover = 0.2;\n        float density = 0.1;\n\n        float thickness = max( 0.0, (cloudDensity - cover) \/ (1.0 - cover) );\n\n        float cloudOpticalDepth = thickness * viewThicknessFactor;\n        float sunCloudOpticalDepth = thickness * sunThicknessFactor;\n        \n        vec3 litCloudCol = env.sunLightCol * cloudSunLight * ( exp( sunCloudOpticalDepth * -density ) ) * 10.0; \n        vec3 cloudCol = litCloudCol + env.ambientCol;\n\n\n        float cloudBlend = 1.0 - exp( cloudOpticalDepth * -density );\n        col = mix( col, cloudCol, cloudBlend );       \n    }\n    \n    return vec4( col, dist );   \n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Terrain Height\n\n\nfloat Terrain_GetShape( vec2 mapPos )\n{\n    float d = length(mapPos);\n        \n    float h = SmoothNoise22( mapPos * 0.02 ).x * 100.0 + 50.0;\n\n   \treturn min( h, d );\n}\n\nfloat Terrain_GetBaseHeight( vec2 mapPos )\n{\n    float dist = Terrain_GetShape( mapPos );\n    float hIsland = 2.0 - dist * dist * 0.0005;\n\n\treturn hIsland;\n}\n\nvec3 GetRockSample( sampler2D rockSampler, vec2 mapPos, float mipLod )\n{\n    vec2 uv = mapPos * 0.1;\n    vec3 textureSample = textureLod( rockSampler, uv.yx, mipLod ).rgb;\n    \/\/textureSample.r = (textureSample.r - textureSample.g) \/ (1.0f - textureSample.g);\n    return textureSample = textureSample * textureSample;\n}\n\n\n\nvec2 Terrain_GetHeights( sampler2D rockSampler,vec2 mapPos, bool detail )\n{\n    \/\/h = 1.0 - exp( h * -1. );\n    \/\/float dist = length( mapPos );\n    \n    vec2 smoothNoise = SmoothNoise22( mapPos * 20.0 );\n        \n    float h0 = Terrain_GetBaseHeight( mapPos );\n    \n    float rockRelief = 0.05;\n    \n    \/\/ + smoothNoise.y\n    float rockScale = smoothstep( 2.0, -2.5, h0 );\n    \/\/rockScale -= (smoothNoise.y - 0.5) * 0.25;\n    vec3 rockSample = GetRockSample( rockSampler, mapPos, 0.0 );\n    float rockh = h0 + ((rockSample.g * rockSample.b) - 1.0 + rockScale * 1.5 ) * rockRelief ;\/\/ + rockScale - 2.0 * (1.0 - rockScale);\n    \n    \/\/h += hIsland + 10.0;\n    \/\/h = smax( h, hIsland, 0.5 );\n\n    \/\/h= hIsland - h;\n    \n    \/\/h = 1.0 - exp( h * -0.5 );\n    float h = h0 + smoothNoise.x * 0.001;\n    \n    if ( detail )\n    {\n        float sandWaveBlend = smoothstep( 0.5, 1.5, h );\n        float f = mapPos.y * 20.0 + sin( mapPos.x * 0.3) * 10.0+ cos( mapPos.x * 0.5) * 10.0;\n        \n    \tfloat w = sin(f) * 0.5 + 0.5;\n    \n    \tw = pow ( 1.0 - w, 1.5 );        \n        \n        float wave = w * 0.005 * sandWaveBlend;\n        \n        float rough = SmoothNoise22( mapPos * 2.0 ).x * 0.03;\n        \n        h += mix( wave, rough, smoothstep( 1.3, 1.5, h ) );\n        \n        h += SmoothNoise22( mapPos * 1.0 ).x * 0.02;\n\t    h += SmoothNoise22( mapPos * 1000.0 ).x * 0.001;\t\n    \n        \/\/ todo: footsteps?\n        \/\/h += (0.5 - textureLod( iChannel2, mapPos * 0.1, 0.0 ).r) * 0.1;\n    \n#if 1\n        if ( h > rockh )\n        {\n\t        float delta = h - rockh;\n            float amount = exp2( -delta * 50.0 );\n            h -= amount * 0.01;\n        }\n#endif     \n            \n    }\n    \n    return vec2(h,rockh);\n}\n\n\nfloat Terrain_GetHeight( sampler2D rockSampler, vec2 mapPos, bool detail, bool onlySand )\n{\n    vec2 heights = Terrain_GetHeights( rockSampler, mapPos, detail );   \n\n    if ( onlySand )\n        return heights.x;\n    \n    return max( heights.x, heights.y );\n}\n\n",
            "name": "Common",
            "description": "",
            "type": "common"
        },
        {
            "inputs": [
                {
                    "id": "4sfGRn",
                    "filepath": "\/media\/a\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg",
                    "previewfilepath": "\/media\/ap\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg",
                    "type": "texture",
                    "channel": 1,
                    "sampler": {
                        "filter": "mipmap",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "4dXGRr",
                    "filepath": "\/presets\/tex00.jpg",
                    "previewfilepath": "\/presets\/tex00.jpg",
                    "type": "keyboard",
                    "channel": 3,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dXGR8",
                    "channel": 0
                }
            ],
            "code": "\/\/     _____                                       _____  _          _        \n\/\/    \/ ____|                                     \/ ____|| |        | |       \n\/\/   | |      __ _  _ __ ___    ___  _ __  __ _  | (___  | |_  __ _ | |_  ___ \n\/\/   | |     \/ _` || '_ ` _ \\  \/ _ \\| '__|\/ _` |  \\___ \\ | __|\/ _` || __|\/ _ \\\n\/\/   | |____| (_| || | | | | ||  __\/| |  | (_| |  ____) || |_| (_| || |_|  __\/\n\/\/    \\_____|\\__,_||_| |_| |_| \\___||_|   \\__,_| |_____\/  \\__|\\__,_| \\__|\\___|\n\/\/                                                                            \n\/\/                                                                            \n\n#define iChannelState\t\t\tiChannel0\n#define iChannelRockTexture\t\tiChannel1\n#define iChannelKeyboard \t\tiChannel3\n\n#define FLY_CAM_INVERT_Y 1\n\n\/\/   __          __             _           _                _____                               \n\/\/   \\ \\        \/ \/            | |         (_)              \/ ____|                              \n\/\/    \\ \\  \/\\  \/ \/_ _ _ __   __| | ___ _ __ _ _ __   __ _  | |     __ _ _ __ ___   ___ _ __ __ _ \n\/\/     \\ \\\/  \\\/ \/ _` | '_ \\ \/ _` |\/ _ \\ '__| | '_ \\ \/ _` | | |    \/ _` | '_ ` _ \\ \/ _ \\ '__\/ _` |\n\/\/      \\  \/\\  \/ (_| | | | | (_| |  __\/ |  | | | | | (_| | | |___| (_| | | | | | |  __\/ | | (_| |\n\/\/       \\\/  \\\/ \\__,_|_| |_|\\__,_|\\___|_|  |_|_| |_|\\__, |  \\_____\\__,_|_| |_| |_|\\___|_|  \\__,_|\n\/\/                                                   __\/ |                                       \n\/\/                                                  |___\/                                        \n\nstruct WanderCamState\n{\n    vec3 pos;\n    vec3 lookAt;\n    \n    float targetAngle;\n    float lookAtAngle;\n    \n    float eyeHeight;\n\n    float timer;\n    \n    float shoreDistance;\n    \n    int iSitting;\n    \n    float lookAtElevation;\n};\n\nvoid WanderCam_LoadState( out WanderCamState wanderCam, sampler2D sampler, ivec2 addr )\n{\n    vec4 vPos = LoadVec4( sampler, addr + ivec2(0,0) );\n    wanderCam.pos = vPos.xyz;\n    vec4 vLookAt = LoadVec4( sampler, addr + ivec2(1,0) );\n    wanderCam.lookAt = vLookAt.xyz;\n    vec4 vMisc = LoadVec4( sampler, addr + ivec2(2,0) );    \n    wanderCam.targetAngle = vMisc.x;\n    wanderCam.lookAtAngle = vMisc.y;\n    wanderCam.eyeHeight = vMisc.z;\n    wanderCam.timer = vMisc.w;\n    \n    vec4 vMisc2 = LoadVec4( sampler, addr + ivec2(3,0) );    \n    wanderCam.iSitting = int( vMisc2.y );\n    wanderCam.shoreDistance = vMisc2.z;\n    wanderCam.lookAtElevation = vMisc2.w;\n}\n\nvoid WanderCam_StoreState( ivec2 addr, const WanderCamState wanderCam, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    StoreVec4( addr + ivec2(0,0), vec4( wanderCam.pos, 0 ), fragColor, fragCoord );\n    StoreVec4( addr + ivec2(1,0), vec4( wanderCam.lookAt, 0 ), fragColor, fragCoord );\n    StoreVec4( addr + ivec2(2,0), vec4( wanderCam.targetAngle, wanderCam.lookAtAngle, wanderCam.eyeHeight, wanderCam.timer ), fragColor, fragCoord );\n    StoreVec4( addr + ivec2(3,0), vec4( 0, wanderCam.iSitting, wanderCam.shoreDistance, wanderCam.lookAtElevation ), fragColor, fragCoord );\n}\n\nvoid WanderCam_Init( inout WanderCamState wanderCam )\n{\n    if ( iFrame == 0 )\n    {\n        wanderCam.pos = vec3(0, 2, 40);\n        wanderCam.lookAt = vec3(0,2,10);\n        wanderCam.targetAngle = 0.;\n        wanderCam.lookAtAngle = 0.3;\n        wanderCam.lookAtElevation = -0.3;\n        wanderCam.eyeHeight = 1.5;\n\t\twanderCam.timer = 5.0;\n        wanderCam.iSitting = 0;\n        wanderCam.shoreDistance = 5.;\n    }\n}\n\nvec2 WanderCam_GetTarget( WanderCamState wanderCam )\n{\n    float theta = wanderCam.targetAngle;\n    return vec2( sin( theta ), cos( theta ) ) * (60.0 - wanderCam.shoreDistance);\n}\n\nvec3 WanderCam_GetLookAt( WanderCamState wanderCam )\n{\n    float theta = wanderCam.lookAtAngle;\n    float phi = wanderCam.lookAtElevation;\n    return vec3( sin( theta ) * cos(phi), sin(phi), cos( theta ) * cos(phi) );\n}\n\nvoid WanderCam_Update( inout WanderCamState wanderCam )\n{\n    vec2 target = WanderCam_GetTarget( wanderCam );\n    vec2 toTarget = target - wanderCam.pos.xz;\n    \n    float len = length( toTarget );\n    \n    if ( len > 0.0 )\n    {\n        float moveRate = min( len * 0.5, 1.0 );\n\t    float currSpeed = 0.04f * moveRate;\n        \n        float speed = min( len, currSpeed );\n        vec2 delta = normalize( toTarget ) * speed;\n\n        wanderCam.pos.xz += delta;\n    }\n    \n    if ( len < 0.1 )\n    {\n        wanderCam.timer -= iTimeDelta;\n        if ( wanderCam.timer < 0.0 )\n        {\n            \/\/ do something different\n            float rnd = hash11(iTime + 31.);\n\n            if ( rnd < 0.1 )                \n            {\n                \/\/ extend timer\n                wanderCam.timer = 2.0;\n            }\n\t\t\telse\n            if ( rnd < 0.4 )\n            {\n                \/\/ change lookat target\n                wanderCam.lookAtAngle = hash11(iTime+7.) * 2. - 1.;\n                wanderCam.lookAtElevation = hash11(iTime+29.) * -0.6 + 0.1;\n                wanderCam.timer = 2.0;\n            }\n            else\n            {\n                \/\/ random chance to sit here if we haven't\n                float rndSit = hash11(iTime + 45.);\n                if ( wanderCam.iSitting == 0 && rndSit < 0.25 )\n                {\n                    wanderCam.iSitting = 1;\n                    wanderCam.timer = 1.5;\n                }\n                else\n                {\n                    if ( wanderCam.iSitting == 1 )\n                    {\n\t                    \/\/ stand up\n                        wanderCam.iSitting = -1; \/\/ don't sit again\n                        wanderCam.timer = 1.5;\n                    }\n                    else\n                    {\n                        \/\/ Move to a different location\n                        wanderCam.targetAngle += (hash11(iTime) - 0.5) * 0.5;\n                        wanderCam.targetAngle = clamp( wanderCam.targetAngle, -1.5, 1.5);\n                        wanderCam.shoreDistance = hash11(iTime+27.) * 5.0;\n                        wanderCam.timer = 5.0;\n                    }                    \n                }                \n            }           \n        }        \n    }\n    else\n    {\n        wanderCam.iSitting = 0;\n    }\n\n    float targeth = 1.5;\n    if ( wanderCam.iSitting != 0 )\n    {\n    \ttargeth = 0.9;\n    }\n    \n    wanderCam.eyeHeight = wanderCam.eyeHeight + (targeth - wanderCam.eyeHeight) * 0.03;\n    \n    wanderCam.pos.y = Terrain_GetHeight( iChannelRockTexture, wanderCam.pos.xz, false, true );\n    wanderCam.pos.y += wanderCam.eyeHeight;\n\n    vec3 lookAt = WanderCam_GetLookAt( wanderCam );\n    \n    vec3 idealLookAt = lookAt;\n    wanderCam.lookAt = wanderCam.lookAt + (idealLookAt - wanderCam.lookAt) * 0.01;\n}\n\n\/\/    _____ _          ____                \n\/\/   |  ___| |_   _   \/ ___|__ _ _ __ ___  \n\/\/   | |_  | | | | | | |   \/ _` | '_ ` _ \\ \n\/\/   |  _| | | |_| | | |__| (_| | | | | | |\n\/\/   |_|   |_|\\__, |  \\____\\__,_|_| |_| |_|\n\/\/            |___\/                        \n\/\/\n\nstruct FlyCamState\n{\n    vec3 vPos;\n    vec3 vAngles;\n    vec4 vPrevMouse;\n};\n\nvoid FlyCam_LoadState( out FlyCamState flyCam, sampler2D sampler, ivec2 addr )\n{\n    vec4 vPos = LoadVec4( sampler, addr + ivec2(0,0) );\n    flyCam.vPos = vPos.xyz;\n    vec4 vAngles = LoadVec4( sampler, addr + ivec2(1,0) );\n    flyCam.vAngles = vAngles.xyz;\n    vec4 vPrevMouse = LoadVec4( sampler, addr + ivec2(2,0) );    \n    flyCam.vPrevMouse = vPrevMouse;\n}\n\nvoid FlyCam_StoreState( ivec2 addr, const in FlyCamState flyCam, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    StoreVec4( addr + ivec2(0,0), vec4( flyCam.vPos, 0 ), fragColor, fragCoord );\n    StoreVec4( addr + ivec2(1,0), vec4( flyCam.vAngles, 0 ), fragColor, fragCoord );\n    StoreVec4( addr + ivec2(2,0), vec4( iMouse ), fragColor, fragCoord );\n}\n\nmat3 Mat_FromAngles( vec3 vAngles )\n{\n    mat3 rotX = mat3(1.0, 0.0, 0.0, \n                     0.0, cos(vAngles.x), sin(vAngles.x), \n                     0.0, -sin(vAngles.x), cos(vAngles.x));\n    \n    mat3 rotY = mat3(cos(vAngles.y), 0.0, -sin(vAngles.y), \n                     0.0, 1.0, 0.0, \n                     sin(vAngles.y), 0.0, cos(vAngles.y));    \n\n    mat3 rotZ = mat3(cos(vAngles.z), sin(vAngles.z), 0.0,\n                     -sin(vAngles.z), cos(vAngles.z), 0.0,\n                     0.0, 0.0, 1.0 );\n    \n    \n    return rotY * rotX * rotZ;    \n}\n\nvoid FlyCam_GetAxes( FlyCamState flyCam, out vec3 vRight, out vec3 vUp, out vec3 vForwards )\n{\n    vec3 vAngles = flyCam.vAngles;\n    \n    mat3 m = Mat_FromAngles( vAngles );\n    \n    vRight = m[0];\n    vUp = m[1];\n    vForwards = m[2];\n}\n\nvoid FlyCam_Init( inout FlyCamState flyCam, vec3 vStartPos, vec3 vStartAngles )\n{\n    if ( iFrame == 0 )\n    {\n        flyCam.vPos = vStartPos;\n        flyCam.vAngles = vStartAngles;\n        flyCam.vPrevMouse = iMouse;    \n    }\n}\n\nvoid FlyCam_Update( inout FlyCamState flyCam )\n{    \n    \/\/float fMoveSpeed = 0.01;\n    float fMoveSpeed = iTimeDelta * 4.0;\n    float fRotateSpeed = 3.0;\n    \n    if ( Key_IsPressed( iChannelKeyboard, KEY_SHIFT ) )\n    {\n        fMoveSpeed *= 4.0;\n    }\n          \n    vec3 vMove = vec3(0.0);\n        \n    if ( Key_IsPressed( iChannelKeyboard, KEY_W ) )\n    {\n        vMove.z += fMoveSpeed;\n    }\n    if ( Key_IsPressed( iChannelKeyboard, KEY_S ) )\n    {\n        vMove.z -= fMoveSpeed;\n    }\n\n    if ( Key_IsPressed( iChannelKeyboard, KEY_A ) )\n    {\n        vMove.x -= fMoveSpeed;\n    }\n    if ( Key_IsPressed( iChannelKeyboard, KEY_D ) )\n    {\n        vMove.x += fMoveSpeed;\n    }\n    \n    vec3 vForwards, vRight, vUp;\n    FlyCam_GetAxes( flyCam, vRight, vUp, vForwards );\n        \n    flyCam.vPos += vRight * vMove.x + vForwards * vMove.z;\n    \n    vec3 vRotate = vec3(0);\n    \n    bool bMouseDown = iMouse.z > 0.0;\n    bool bMouseWasDown = flyCam.vPrevMouse.z > 0.0;\n    \n    if ( bMouseDown && bMouseWasDown )\n    {\n    \tvRotate.yx += ((iMouse.xy - flyCam.vPrevMouse.xy) \/ iResolution.xy) * fRotateSpeed;\n    }\n    \n#if FLY_CAM_INVERT_Y    \n    vRotate.x *= -1.0;\n#endif    \n    \n    if ( Key_IsPressed( iChannelKeyboard, KEY_E ) )\n    {\n        vRotate.z -= fRotateSpeed * 0.01;\n    }\n    if ( Key_IsPressed( iChannelKeyboard, KEY_Q ) )\n    {\n        vRotate.z += fRotateSpeed * 0.01;\n    }\n        \n\tflyCam.vAngles += vRotate;\n    \n    flyCam.vAngles.x = clamp( flyCam.vAngles.x, -PI * .5, PI * .5 );\n}\n\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iAddr = ivec2(fragCoord.xy);\n    if ( iAddr.y != 0 || iAddr.x > 16 ) \n    {\n        discard; \n        return;\n    }\n    \n\tfragColor = vec4(0.0f, 0.0f, 0.0f, 1.0f);\n    \n   \/\/ Setup Cam\n    CameraState cam;\n    \n    \/\/ Set defaults\n    \n    vec3 vCameraInitialPos = vec3(-0.1, 5.0, 3.5);\n    \n    cam.vPos = vCameraInitialPos;\n    cam.vTarget =  vCameraInitialPos + vec3(0,0, 3.0);\n    cam.vUp = vec3(0,1,0);\n    cam.fFov = 25.0;\n    cam.fPlaneInFocus = length(cam.vTarget - cam.vPos);\n    cam.vJitter = vec2(0.0);        \n        \n    WanderCamState wanderCam;\n    WanderCam_LoadState( wanderCam, iChannelState, ivec2(11,0) );\n    \n    WanderCam_Init( wanderCam );\n \n    \n    \/\/ Update FlyCam\n    FlyCamState flyCam;\n    FlyCam_LoadState( flyCam, iChannelState, ivec2(8,0) );\n    \n    float pitch = 0.1;\n    \n\tFlyCam_Init( flyCam, vCameraInitialPos, vec3(pitch, 0.0, 0) );    \n\n    if ( Key_IsToggled( iChannelKeyboard, KEY_SPACE ) )\n    {    \n        FlyCam_Update( flyCam );\n\n        vec3 vForwards, vRight, vUp;\n        FlyCam_GetAxes( flyCam, vRight, vUp, vForwards );\n\n        cam.vPos = flyCam.vPos;\n        cam.vTarget = flyCam.vPos + vForwards;\n        cam.vUp = vUp;\n        cam.fPlaneInFocus = length(flyCam.vPos);        \n\n        cam.fPlaneInFocus = -1.0; \/\/ auto focus\n    }\n    else\n    {\n\t\tWanderCam_Update( wanderCam );\n        \n        \/\/ set cam from wander cam\n        cam.vPos = wanderCam.pos;\n        cam.vTarget = wanderCam.pos + wanderCam.lookAt;\n        \n        vec3 vNoise = SmoothNoise32( cam.vPos.xz + iTime * 0.5 );\n        \n        vec3 vShakyCamAngles = (vNoise - 0.5) * vec3( 0.05, 0.03, 0.01 );\n        mat3 m = Mat_FromAngles( vShakyCamAngles );\n        \n        vec3 vToTarget = cam.vTarget - cam.vPos;\n        cam.vTarget = cam.vPos + vToTarget * m;\n        \n        cam.vUp = vec3(0,1,0) * m;\n        \n        \/\/ update flycam position from wander cam\n        flyCam.vPos = cam.vPos;\n        vec3 vDir = cam.vTarget - cam.vPos;\n        flyCam.vAngles = vec3( 0, atan(vDir.x, vDir.z), 0);\n    }\n\n    \n#ifdef ENABLE_TAA_JITTER\n    cam.vJitter = hash21( fract( iTime ) ) - 0.5f;\n#endif    \n\n\tCam_StoreState( ivec2(0), cam, fragColor, iAddr );    \n    FlyCam_StoreState( ivec2(8,0), flyCam, fragColor, iAddr );\n    WanderCam_StoreState( ivec2(11,0), wanderCam, fragColor, iAddr );\n}",
            "name": "Buffer A",
            "description": "",
            "type": "buffer"
        },
        {
            "inputs": [
                {
                    "id": "4sfGRn",
                    "filepath": "\/media\/a\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg",
                    "previewfilepath": "\/media\/ap\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg",
                    "type": "texture",
                    "channel": 1,
                    "sampler": {
                        "filter": "mipmap",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "XsXGR8",
                    "filepath": "\/media\/previz\/buffer01.png",
                    "previewfilepath": "\/media\/previz\/buffer01.png",
                    "type": "buffer",
                    "channel": 2,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4sXGR8",
                    "channel": 0
                }
            ],
            "code": "\/\/    __  __         _           _____                           _____                   _             \n\/\/   |  \\\/  |       (_)         \/ ____|                         |  __ \\                 | |            \n\/\/   | \\  \/ |  __ _  _  _ __   | (___    ___  ___  _ __    ___  | |__) | ___  _ __    __| |  ___  _ __ \n\/\/   | |\\\/| | \/ _` || || '_ \\   \\___ \\  \/ __|\/ _ \\| '_ \\  \/ _ \\ |  _  \/ \/ _ \\| '_ \\  \/ _` | \/ _ \\| '__|\n\/\/   | |  | || (_| || || | | |  ____) || (__|  __\/| | | ||  __\/ | | \\ \\|  __\/| | | || (_| ||  __\/| |   \n\/\/   |_|  |_| \\__,_||_||_| |_| |_____\/  \\___|\\___||_| |_| \\___| |_|  \\_\\\\___||_| |_| \\__,_| \\___||_|   \n\/\/                                                                                                     \n\/\/                                                                                                     \n\n#define iChannelState\t\t\tiChannel0\n#define iChannelRockTexture\t\tiChannel1\n\n\nEnvironmentSettings GetEnvironmentSettings()\n{\n    EnvironmentSettings env;\n    \n    env.time = iTime;\n\n    env.sunElevation = (0.2f * PI * 0.5);\n    env.sunHeading = (PI * 0.15);\n    \n#if 1\n    \/\/ day\n    env.skyZenithCol = vec3( 0.005f, 0.1f, 1.0f ) * 0.3;\n    env.skyHorizonCol = vec3( 0.1f, 0.4f, 1.0f ) * 1.0;\n    \n\tvec3 sunCol = vec3(1.0f, 0.95f, 0.65f);\n    \n    env.fogCol =  vec3( 0.6, 0.85, 0.9 ) * 2.0;\n    \n    env.sunDiscCol = sunCol * 4096.0;\n    env.sunLightCol = sunCol * 2.0;\n    \n#endif\n    \n#if 0\n    \/\/ sunset-ish\n    env.sunElevation = (0.05f * PI * 0.5);\n    \n    env.skyZenithCol = vec3(1,0.2,0) * 0.25;\n    env.skyHorizonCol = vec3( 1,0,0);\n    \n\tvec3 sunCol = vec3(1.0f, 0.25f, 0.001f);\n    \n    env.fogCol =  vec3( 1.0, 0.5, 0.0 );\n    \n    env.sunDiscCol = sunCol * 64.0;\n    env.sunLightCol = sunCol * 2.0;\n    \n#endif\n    \n#if 0\n    \/\/ night-ish\n    env.skyZenithCol = vec3(0,0,0.001);\n    env.skyHorizonCol = vec3( 0,0.01,0.05);\n    \n\tvec3 sunCol = vec3(0.2f);\n    env.sunElevation = (0.1f * PI * 0.5);\n    \n    env.fogCol =  env.skyHorizonCol;\n    \n    env.sunDiscCol = sunCol * 32.0;\n    env.sunLightCol = sunCol;\/\/ * 2.0;\n    \n#endif\n    \n#if 0\n    \/\/ Hello darkness my old friend. I've found some bugs with you again.\n    env.skyZenithCol = vec3(0);\n    env.skyHorizonCol = vec3( 0);\n    \n\tvec3 sunCol = vec3(0.0f);\n    env.sunElevation = (0.1f * PI * 0.5);\n    \n    env.fogCol =  env.skyHorizonCol;\n    \n    env.sunDiscCol = sunCol * 32.0;\n    env.sunLightCol = sunCol;\/\/ * 2.0;\n    \n#endif    \n    \n    env.ambientCol = (env.skyZenithCol + env.skyHorizonCol) * 0.5 * 0.25;\n        \n    env.ambientCol =env.fogCol;\n    env.fogDensity = 0.001f;\n    env.skyFogDensity = 0.00001f;\n        \n    \/\/env.sunElevation = iMouse.y * PI * 0.5 \/ iResolution.y;\n    \/\/env.sunHeading = iMouse.x * TAU \/ iResolution.x;\n\n    float se = sin( env.sunElevation );\n    float ce = cos( env.sunElevation );\n    float sh = sin( env.sunHeading );\n    float ch = cos( env.sunHeading );\n    \n    env.sunDir = normalize( vec3( ce * sh, se, ce * ch ) );\n    \n    return env;\n}\n\n\nvec3 GetExtinction( vec2 mapPos )\n{\n\/\/ https:\/\/aslopubs.onlinelibrary.wiley.com\/doi\/pdf\/10.4319\/lo.1997.42.2.0379\n\/\/ green seawater\n    vec3 extA = vec3( 0.29, 0.10, 0.43 );\n    \n    vec3 extB = vec3( 0.3, 0.11, 0.11 );    \n    float blend = SmoothNoise22( mapPos * 0.01 ).x;    \n    return mix( extA, extB, blend );\n}\n\nvec3 GetSunGlow( EnvironmentSettings env, vec3 dir )\n{\n\tfloat VdotL = dot( dir, env.sunDir );\n    \n    VdotL = VdotL * 0.5 + 0.5;\n        \n    float gf = 1.0 - VdotL;\n    \n    float scale = (1.0 \/ (gf * 150.0 + 0.45));\n    \n    \/\/float scale = (1.0 \/ (gf * 1000.0 + 1.0));\n\n    return env.sunLightCol * scale;    \n}\n\n\nvec2 GetShorelineWaves( vec2 pos, float water_terrain_dh )\n{\n    \/\/return vec2(0);\n    water_terrain_dh = max( 0.0f, water_terrain_dh );\n    float p = water_terrain_dh * 8.0 + iTime * 1.5;\n    \/\/float p = pos.y;\n    \/\/p *= water_terrain_dh * 0.05 + 1.0;\n    \/\/p += iTime * 2.0;\n    \n    vec2 noise = SmoothNoise22( pos * 0.1 );\n    \n    p = p + noise.x * 4.0;\n    \n    float waveMag = exp( -water_terrain_dh * 0.7);\n    \n    \n    float sw = sin( p + cos(p) * (1.0 - waveMag) ) * -0.5 + 0.5;    \n    \n    \/\/float chop = 3.0 - waveMag * 3.0;\n    \/\/sw = pow ( 1.0 - sw, chop );    \n    \n    float fm = (sin( p - PI * 0.85 ) * 0.5 + 0.5);\n        \n    return vec2( sw * sqrt( waveMag ), fm * waveMag ) * noise.y ;\n}\n\n\nfloat Water_WaveShape( vec2 uv, float chop )\n{\n\tuv += SmoothNoise22( uv * 0.6) * 2.0;\n    \n    vec2 w = sin(uv * 2.0) * 0.5 + 0.5;\n    \n    w = 1.0 - pow ( 1.0 - w, vec2(chop) );\n    \n    float h = (w.x + w.y) * 0.5;\n    \n    return h;\/\/pow( h, 0.1 );\n}\n\nfloat Water_GetWaves( vec2 mapPos, int waterOctaves, float time )\n{\n    float a = 1.0f;\n    \n    float h = 0.0f;\n    \n    float tot = 0.0;\n    \n    float r = 2.5f;\n    mat2 rm = mat2( cos(r), -sin(r), sin(r), cos(r) ) * 2.1f;\n    \n    vec2 aPos = mapPos;\n    \n    float waveTime = time;\n    \n    float chopA = 0.7;\n    float chopB = 0.9;\n    \n    int maxOctaveCount = 8;\n        \n    for ( int octave = 0; octave < maxOctaveCount; octave++ )\n    {            \n        if ( octave > waterOctaves )\n            break;\n\n        float chop = mix(chopA, chopB, float(octave) \/ float(waterOctaves-1));\n        \n        h += Water_WaveShape( aPos + waveTime , chop ) * a;\n        tot += a;\n                \n        aPos = aPos * rm;\n                \n        a *= .3;\n        \n        waveTime *= 1.6;\n        \n    }\n    \n    return h \/ tot;    \n}\n\nfloat Water_GetHeight( vec2 origMapPos, int waterOctaves, float time )\n{\n    \n    \/\/return 0.0;\n    vec2 mapPos = origMapPos \/ 4.0;\n            \n\tfloat h = Water_GetWaves( mapPos, waterOctaves, time );\n    \n    bool detail = false;\n    float terrainHeight = Terrain_GetHeight( iChannelRockTexture, origMapPos, false, true );\n    float waveScale = smoothstep( 0.0, -2.0, terrainHeight ) * 0.8 + 0.2;\n    \/\/waveScale = 0.0f;\n    \n    \/\/waveScale *= 1.0 - smoothstep( 1.8f, 1.9f, terrainHeight );\n    \n    \/\/waveScale = 1.0f;\n    \n    float result = h * waveScale;\n\n    float shorelineWaves = GetShorelineWaves(origMapPos, -terrainHeight).x * waveScale * 1.5;\n    \n    float water_terrain_dh = result - terrainHeight;\n#if 0\n    float foamFactor = smoothstep( 0.3, 0.0f, water_terrain_dh );\n    \n    float t= ( foamFactor * foamFactor *  foamFactor ) *  1.5;\n    float bump = 3.0 * t * t - 2.0f * t * t * t;\n    result += bump * 0.1;\n#endif  \n    \n#if 1\n    float edge = (water_terrain_dh+shorelineWaves*0.5+0.02)*5.;\n    edge = clamp(1.0-edge, 0.0, 1.0);    \n    edge = sqrt( 1.0 - edge * edge );\n    \/\/edge = smoothstep( 0.0, 1.0, edge );\n    result += edge * 0.1;\n#endif\n    \n    \/\/result = 0.0f;\n    \n    result += shorelineWaves;\n    \n    return result;\n}\n\nstruct MapHeight\n{\n    float height;\n    int objectId;\n};\n\nMapHeight Map_GetHeight( vec2 mapPos, int waterOctaves, bool detail )\n{\n    float groudHeight = Terrain_GetHeight( iChannelRockTexture, mapPos, detail, false );\n    MapHeight result = MapHeight( groudHeight, 0 );\n    \n    if ( waterOctaves > 0 )\n    {\n        float waterHeight = Water_GetHeight(mapPos, waterOctaves, iTime );\n        if (waterHeight > result.height )\n        {\n            result.height = waterHeight;\n            result.objectId = 1;\n        }\n    }\n    \n    return result;\n}\n\nMapHeight Map_GetAltitude( vec3 pos, int waterOctaves, bool detail )\n{\n    MapHeight mapHeight = Map_GetHeight( pos.xz, waterOctaves, detail );\n    return MapHeight( pos.y - mapHeight.height, mapHeight.objectId );    \n}\n\nvec3 Map_GetNormal( vec3 pos )\n{\n    const float delta = 0.01;\n    \n    const int normalOctaves = 8;\n    vec3 normal = vec3(1.0f, 0.0f, 1.0f) * Map_GetHeight( pos.xz, normalOctaves, true ).height\n           + Map_GetHeight( pos.xz + vec2(delta, 0.0f), normalOctaves, true ).height * vec3(-1.0f, 0.0, 0.0)\n        + Map_GetHeight( pos.xz + vec2(0.0f, delta), normalOctaves, true ).height * vec3(0.0f, 0.0, -1.0) + vec3(0.0, delta, 0.0);\n    \n    return normalize( normal );\n} \n\nstruct MapTraceResult\n{\n    float dist;\n    int objectId;\n};\n\nMapTraceResult Map_Trace( vec3 rayOrigin, vec3 rayDir, int waterOctaves, bool detail )\n{\n    MapTraceResult result = MapTraceResult( -1., -1 );\n    \/\/if ( rayDir.y > 0.0f )\n    \/\/{\n        \/\/return -1.0f;\n    \/\/}\n        \n    float minT;\n    vec3 minPos;\n    float minH;\n    \n    float maxT = 0.0f;\n    vec3 maxPos = rayOrigin + rayDir * maxT;\n\tMapHeight mapHeight = Map_GetAltitude( maxPos, waterOctaves, detail );\n    float maxH = mapHeight.height;    \n    result.dist = maxT;    \n    result.objectId = mapHeight.objectId;  \n\n    float yMax = 2.0f;\n    float yMin = -8.0f;\n    \n    yMax = min( yMax, rayOrigin.y );\n    \n    int maxIterA = 16;\n    \n    \/\/float traceStep = 1.0;\n    \n    for( int iter = 1; iter <= maxIterA; iter++ )\n    {\n        minT = maxT;\n        minH = maxH;\n\n        float fr = float(iter) \/ float(maxIterA);\n        float y = yMax + (yMin - yMax) * fr;\n        \n        maxT = (y - rayOrigin.y) \/ rayDir.y;               \n        \n        maxPos = rayOrigin + rayDir * maxT;\n\t\tMapHeight mapHeight = Map_GetAltitude( maxPos, waterOctaves, detail );\n        maxH = mapHeight.height;\n        \n        result.dist = maxT;\n\t    result.objectId = mapHeight.objectId;  \n                \n        if ( maxH < 0.0 )\n        {\n            break;\n        }        \n    }    \n    \n    \n    int maxIterB = 11;\n    \n    for( int iter = 0; iter < maxIterB; iter++ )\n    {\n        float midT = (minT + maxT) * 0.5f;        \n        \/\/float midT = mix( minT, maxT, ( (maxH + minH) * 0.5 - minH ) \/ (maxH-minH) );\n        \n        vec3 midPos = rayOrigin + rayDir * midT;\n\t\tMapHeight mapHeight = Map_GetAltitude( midPos, waterOctaves, detail );\n        float midH = mapHeight.height;\n        \n        if ( midH < 0.0f )\n        {\n            maxT = midT;\n            maxH = midH;\n            result.dist = maxT;\n\t\t    result.objectId = mapHeight.objectId;  \n        }\n        else\n        {\n            minT = midT;\n            minH = midH;\n        }      \n        \n        if ( abs( minH - maxH ) < 0.001)\n        {\n            break;\n        }\n    }\n    \n    return result;\n}\n\nvec3 GetSkyColour( EnvironmentSettings env, vec3 rayOrigin, vec3 rayDir, float mipLod, bool sunDisc )\n{\n    vec4 skyResult = TraceSky( env, iChannel1, rayDir, iTime * 3.0, mipLod, sunDisc );\n    \n    \n    vec3 result = skyResult.rgb;\n\n    float dist = skyResult.w;\n    \n    float fogFactor = 1.0 - exp( dist * -env.skyFogDensity );\n    result = mix ( result, env.fogCol, fogFactor );\n    return result; \n}\n\nvec3 GetInscatter( EnvironmentSettings env, float heading, float cosRefract, vec3 extinction )\n{\n    \/\/ hardcode LUT\n    vec3 result = vec3(0.0, 0.0, 0.0);\n\n    \/\/ some average sky color\n    vec3 skyCol = (env.skyHorizonCol * 3.0f + env.skyZenithCol * 1.0f) \/ 4.0f;       \n\n    \/\/ Parameters:\n    float lightIntensity = 0.07f; \/\/ overall intensity of result - don't just rely on extinction to darken color\n    float scatteringScale = 40.0f;\n    float scatteringOffset = 4.0f;\n    \/\/\/\/\/\/\/\n\n\n    float cosSunHeading = cos( heading - env.sunHeading );\n\n    float spread = -0.5 -cosRefract * 1.5; \/\/ wrap sunlight more with \"depth\"\n\n    float sunIntensityX = cosSunHeading * ( 1.0f - spread ) + spread;\n    sunIntensityX = max( 0.0f, sunIntensityX );\n\n    float sunIntensityY = max( 0.0f, -cosRefract );\n\n\n    float sunIntensity = sunIntensityX * sunIntensityX + sunIntensityY * sunIntensityY;\n    sunIntensity *= (1.0 + cosRefract) * 8.0; \/\/ decrease sun intensity with \"spread\"\n\n    vec3 light = env.sunLightCol * sunIntensity + skyCol;\n\n    light *= lightIntensity;        \n\n    float dist = (cosRefract * cosRefract) * scatteringScale + scatteringOffset;\n\n    result.rgb = light * (exp( dist * -extinction)); \/\/ could be exp2 if we change scatteringScale and scatteringOffset values\n\n    return result;\n}\n\nfloat GIV( float dotNV, float k)\n{\n\treturn 1.0 \/ ((dotNV + 0.0001) * (1.0 - k)+k);\n}\n\n\nvec4 GetSandCol( vec3 pos, float mipLod )\n{\n    vec3 textureSample = textureLod( iChannel1, pos.zx * 2.0, mipLod ).rgb;\n    textureSample = textureSample * textureSample;\n\n    \/\/ darker, browner sand\n    vec3 sandColA = vec3( 0.9f, 0.63f, 0.4f );\n    sandColA = sandColA * sandColA;\n    \n    \/\/ ligher, whiter sand\n    vec3 sandColB = vec3( 1.0f, 0.8f, 0.6f );\n    sandColB = sandColB * sandColB;    \n    \n    \/\/ todo - pass in sand type factor - define regions somewhere\n    \n    float blendFactor = smoothstep(1.2, 2.0, pos.y);\n        \n\tvec3 sandCol = mix( sandColA, sandColB, blendFactor );\n    \n    \/\/float rockFactor = clamp(-pos.y +textureSample.g * 0.75 + 0.25 + 0.0, 0.0, 1.0);\n    \n    vec2 heights = Terrain_GetHeights( iChannelRockTexture, pos.xz, true );\n        \n    float rockFactor = clamp( (heights.y - heights.x + 0.01) * 500.0, 0.0f, 1.0 );\n    \n    \n    sandCol = mix( sandCol, textureSample, rockFactor );\n    \n    \/\/vec3 textureSampleB = textureLod( iChannel1, uv * 10.0, mipLod ).rgb;\n    \/\/sandCol *= (textureSample.g * 0.5 + textureSampleB.r * 0.5);\n    \n    return vec4( sandCol, rockFactor );\n    \/*\n    col = col * col;            \n    \n    float rawCol = col.r;\n    \n    float fade = clamp( 0.5 + pos.y, 0.0f, 1.0);\n\tfade = 0.3 + fade * 0.6f;\n    \n    col = col * (1.0f - fade) + fade;\n    col *= vec3( 1.0f, 0.85f, 0.5f );\n    \n    return vec4( col, rawCol );\n    *\/\n}\n\nvec3 WaterCaustics( EnvironmentSettings env, vec3 pos )\n{    \n    \/\/return sunLightCol; \/\/ no caustics\n    \n    float h = Water_GetWaves( pos.xz, 3, iTime * 3.0 );\n    float i = 0.5f + 0.7f * h * h;\n    return env.sunLightCol * i;\n}\n\nvec3 GetSceneColour( EnvironmentSettings env, vec3 rayOrigin, vec3 rayDir, out float sceneDist )\n{\n    vec3 result = vec3(0);\n\n    float wetDiffuseFactor = 0.5;\n    \n    int waterOctaves = 3;\n    MapTraceResult mapTrace = Map_Trace( rayOrigin, rayDir, waterOctaves, false );\n    \n    if ( mapTrace.dist < 0.0 )\n    {        \n        result.rgb = GetSkyColour( env, rayOrigin, rayDir, 0.0f, true );\n        sceneDist = 10000.0;\n    }\n    else\n    if ( mapTrace.dist >= 0.0 )\n    {        \n        sceneDist = mapTrace.dist;\n        \n        vec3 hitPos = rayOrigin + rayDir * mapTrace.dist;\n        vec3 normal = Map_GetNormal( hitPos );\n                \n\n        float vR0 = 0.02f;\n        \n        float roughness = 0.0002f;\n\n        vec3 albedo = vec3(1);\n        float transparency = 1.0f;\n        vec3 colTransmitted = vec3(0);\n        \n        if ( mapTrace.objectId == 1 )\n        {\n            vec3 waterExtinction = GetExtinction( hitPos.xz );\n            {\n                \n                float terrainHeight = Terrain_GetHeight( iChannelRockTexture, hitPos.xz, false, true );\n                \n                float water_terrain_dh = hitPos.y - terrainHeight;\n                \n                float foamAmount = clamp( 1.0 - water_terrain_dh * (1.0f \/ 0.5f), 0.0f, 1.0f );\n                foamAmount = foamAmount * foamAmount;\n                \n\t\t\t\tfloat waveFactor = GetShorelineWaves( hitPos.xz, water_terrain_dh ).y;\n                \n                foamAmount = max( foamAmount, waveFactor );\n\n                vec2 foamMapUV = hitPos.xz; \/\/mix(hitPos.xz, refractHitPos.xz, 0.25);\n                foamMapUV = foamMapUV * 20.0 + water_terrain_dh * 100.0;\n                \n                \n\t            \/\/normal.xz += (SmoothNoise2( foamMapUV * 2.0) * 2.0f - 1.0f) * foamAmount * 0.2;\n                \/\/normal = normalize( normal );\n                \n\t            vec3 rayRefracted = refract( rayDir, normal, 1.0f \/ 1.3333f );\n                \n                \n                \n                MapTraceResult refractTrace = Map_Trace( hitPos, rayRefracted, 0, false );\n                vec3 refractHitPos = hitPos + rayRefracted * refractTrace.dist;\n                \n                float dh = refractHitPos.y - hitPos.y;\n\n                vec3 diffuseCol = GetSandCol( refractHitPos, (log( refractTrace.dist )+1.) * 4.0).rgb;\n                \n                diffuseCol *= wetDiffuseFactor;\n\n                vec3 seabedLighting = WaterCaustics( env, refractHitPos );\n                \n                float seabedNdotL = env.sunDir.y;\n                vec3 diffuseLight  = seabedNdotL * seabedLighting * exp( (-dh \/ -env.sunDir.y) * waterExtinction );\n                \n                diffuseLight += env.ambientCol * exp( dh * waterExtinction );\n                                \n                colTransmitted = diffuseLight * diffuseCol;\n                \n                vec3 extinction = exp( (-refractTrace.dist ) * waterExtinction );\n\n                \n                colTransmitted *= extinction;  \n\n                {\n                    float inscatterFactor = clamp( 1.0 - rayRefracted.y, 0.0f, 1.0f );\n\n                    \/\/vec3 inscatterScale =  exp( -inscatterFactor * waterExtinction * inscatterScaleFactor );\n\n                    float lookupU = atan(rayRefracted.x, rayRefracted.z);\n                             \n\n                    float lookupV = clamp( -rayRefracted.y, 0.0f, 1.0f);\n                    vec3 inscatterScale = GetInscatter( env, lookupU, lookupV, waterExtinction );\n\t\t\t\t\tcolTransmitted += inscatterScale;\n                }\n            \/\/}\n            \n\t\t\t\t\/\/colTransmitted *= RadianceChange( IOR_AIR, IOR_WATER );                \n\t            \/\/colTransmitted *= RadianceChange( IOR_WATER, IOR_AIR );\n                \n            \/\/{\n\n                \n                \/\/float foam = SmoothNoise2( foamMapUV ).x;\n                vec2 foamSampleUV = foamMapUV * 0.005 + iTime * 0.1;\n                vec4 foamSample = texture( iChannel1, foamSampleUV, 0.0 );\n                float foam = foamSample.x;\n                \n                \n                foam = 1.f - foam;\n                foam = 1.f - foam* foam;\n                \n                float foamFactor = foamAmount * 0.8f;\n                \n                foamFactor = max( 0.0, foamFactor - foam * (1.0f - foamFactor));\n                \n                \/\/foamFactor *= 0.25 + 0.75 * SmoothNoise2( hitPos.xz * 10000.0 ).x;\n                                \n                float foamThicknessFactor = 1.0;\n                \/\/if ( abs( dh ) < 0.02 ) { foamThicknessFactor = 0.5; }\n                \n                \/\/ foam shadow\n                colTransmitted *= 1.0 - foamFactor * foamThicknessFactor;\n                \n                \/\/ foam bubbles\n                \/\/colTransmitted += diffuseLight * exp( -foamAmount * waterExtinction * 10.0 ) * foamSample.b * 0.2;\n                \n                \/\/albedo = vec3( SmoothNoise2( hitPos.xz * 10000.0 ).x * 0.5 + 0.5 );\n                albedo = vec3( 1.0f );\n                \n                normal.x += (foamSample.x - texture( iChannel1, foamSampleUV - vec2(0.2, 0), 0.0 ).x) * foamFactor * 0.4;\n                normal.z += (foamSample.x - texture( iChannel1, foamSampleUV - vec2(0, 0.2), 0.0 ).x) * foamFactor * 0.4;\n                normal = normalize( normal );\n                \n                \n                transparency = 1.0 - foamFactor * foamThicknessFactor;                                \n                roughness = mix( roughness, 0.3f, foamFactor * foamFactor );                \n            }            \n        }\n        else\n        {\n            vec3 mapPos = rayOrigin + rayDir * mapTrace.dist;\n            \n            vec4 sandColSample = GetSandCol( mapPos, 0.0f );\n            albedo = sandColSample.rgb;\n            transparency = 0.0f;\n            \n            float wetness = 0.0f;\n            \n            vec2 noiseLow = SmoothNoise22(mapPos.xz * 0.2);\n\n            roughness = 1.0f - sandColSample.a * (0.5 + sandColSample.r * 0.5);\n            \n            \/\/float roughnessHeight = smoothstep( 2.0, 1.2, mapPos.y );            \n            \/\/roughness = mix( roughness, noiseLow.y * 0.08, roughnessHeight );\n            \n#if 1\n            \n            \n            \/\/float wetRoughness = mix( 2.0f, 1.2f, noiseLow.x );\n            float wetnessHeightFactor = smoothstep( 1.5, 0.6, mapPos.y );\n            float wetnessHeight = mix( wetness, 0.8+noiseLow.x * 0.2, wetnessHeightFactor);\n            \n            wetness = max( wetness, wetnessHeight );\n                        \n                        \n                                                \n#endif      \n            \n\t        float waterOldHeight = Water_GetHeight(mapPos.xz, 2, iTime - 0.05 );                        \n            float wetnessShorline = smoothstep( 0.4, 0.0, mapPos.y - waterOldHeight);\n            \n            wetnessShorline *= 1.0;\n                \n            wetness = max( wetness, wetnessShorline );\n            \n            \n            roughness = mix ( roughness, 0.001, wetness );            \n            albedo *= (1.0 - wetness ) * (1.0f - wetDiffuseFactor) + wetDiffuseFactor;\n            \n            \/\/albedo = clamp( albedo + max(0.0f, wetnessShorline - 0.9), 0.0, 1.0); \/\/ attempt to hack persistent foam\n        }\n\n        vec3 h = normalize( -rayDir + env.sunDir );\n        float NdotL = max( 0.0f, dot( normal, env.sunDir ) );\n        float NdotH = dot( h, normal );\n        float NdotV = dot( rayDir, normal );\n               \n        vec3 diffuseIntensity = (NdotL * env.sunLightCol + env.ambientCol) * albedo;\n\n        colTransmitted = mix( diffuseIntensity, colTransmitted, transparency );\n        \n        roughness = roughness * 0.995 + 0.005;\n        \n        float gloss = (1.0f - roughness);\n        float glossFactor = pow( gloss, 20.0 );\n        \n        vec3 rayReflected = reflect( rayDir, normal );\n        \n        vec3 colReflected = GetSkyColour( env, hitPos, rayReflected, glossFactor * 16.0, false );\n        \n        {\n\t\t\tfloat alpha = roughness;\n            float alphaSqr = alpha * alpha;\n            float denom = NdotH * NdotH * (alphaSqr - 1.0) + 1.0f;\n            float k = alpha \/ 2.0;\n            float vis = GIV(NdotL, k) * GIV(NdotV, k);\n            float f = alphaSqr \/ (PI * denom * denom);\n            colReflected += f * NdotL * env.sunLightCol;\n        }\n        \n        \n        {\n            float NdotV = max( 0.0, dot( rayDir, -normal ) );\n\n            vec3 fresnel = vR0 + (vec3(1.0) - vR0) * pow( 1.0 - NdotV, 5.0 ) * glossFactor;\n\n            result.rgb = mix( colTransmitted, colReflected, fresnel );\n        }            \n        \n    \n        float dist = mapTrace.dist;\n        float fogFactor = 1.0 - exp( dist * -env.fogDensity );\n        result.rgb = mix ( result.rgb, env.fogCol, fogFactor );\n\t}\n\n    vec3 sunGlow = GetSunGlow( env, rayDir );\n    result.rgb += sunGlow;\n\n    return result;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{       \n    vec2 uv = fragCoord.xy \/ iResolution.xy;;\n\n    CameraState cam;\n\tCam_LoadState( cam, iChannelState, ivec2(0,0) );\n    \n    \/\/ Trace Scene\n    float fAspectRatio = iResolution.x \/ iResolution.y;            \n    \n    vec3 rayOrigin, rayDir;\n    vec2 vJitterUV = uv + cam.vJitter \/ iResolution.xy;\n    Cam_GetCameraRay( vJitterUV, fAspectRatio, cam, rayOrigin, rayDir );    \n\n\tEnvironmentSettings env = GetEnvironmentSettings();\n    \n    float dist = 0.0f;\n    vec3 sceneColor = GetSceneColour( env, rayOrigin, rayDir, dist );\n    \n    fragColor = vec4(sceneColor,dist);\n}\n",
            "name": "Buffer C",
            "description": "",
            "type": "buffer"
        }
    ]
}