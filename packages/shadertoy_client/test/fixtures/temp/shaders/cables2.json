{
    "ver": "0.1",
    "info": {
        "id": "wlKXWc",
        "date": "1583773251",
        "viewed": 2627,
        "name": "cables2",
        "username": "yuntaRobo",
        "description": "Sphere and cables.",
        "likes": 95,
        "published": 3,
        "flags": 0,
        "usePreview": 0,
        "tags": [
            "raymarching",
            "torus",
            "sphere",
            "cables"
        ],
        "hasliked": 0
    },
    "renderpass": [
        {
            "inputs": [],
            "outputs": [
                {
                    "id": "4dfGRr",
                    "channel": 0
                }
            ],
            "code": "const float PI = 3.1415926;\nconst float TAU = PI * 2.0;\nconst float E = 0.01;\n\nstruct Ray\n{\n    vec3 pos;\n    vec3 dir;\n};\n\nmat2 rotate2D(float rad)\n{\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat2(c, s, -s, c);\n}\n\nvec2 de(vec3 p)\n{\n    float d = 100.0;\n    float a = 0.0;\n\n    p.yz *= rotate2D(PI \/ 5.0);\n    p.y -= 0.5;\n\n    \/\/ reaction\n    vec3 reaction = vec3(cos(iTime), 0.0, sin(iTime)) * 3.0;\n    p += exp(-length(reaction - p) * 1.0) * normalize(reaction - p);\n    \n    \/\/ cables\n    float r = atan(p.z, p.x) * 3.0;\n    const int ite = 50;\n    for (int i = 0; i < ite; i++)\n    {\n        r += 0.5 \/ float(ite) * TAU;\n        float s = 0.5 + sin(float(i) * 1.618 * TAU) * 0.25;\n        s += sin(iTime + float(i)) * 0.1;\n        vec2 q = vec2(length(p.xz) + cos(r) * s - 3.0, p.y + sin(r) * s);\n        float dd = length(q) - 0.035;\n        a = dd < d ? float(i) : a;\n    \td = min(d, dd);\n    }\n\n    \/\/ sphere\n    float dd = length(p - reaction) - 0.1;\n    a = dd < d ? 0.0 : a;\n    d = min(d, dd);\n\n    return vec2(d, a);\n}\n\nvoid trace(Ray ray, inout vec3 color, float md)\n{\n    float ad = 0.0;\n    for (float i = 1.0; i > 0.0; i -= 1.0 \/ 128.0)\n    {\n        vec2 o = de(ray.pos);\n        if (o.x < E)\n        {\n            color = mix(vec3(0.1, 0.1, 0.5), vec3(0.0, 0.0, 1.0), fract(o.y * 1.618));\n            color = mix(vec3(1.0, 1.0, 1.0), color, step(0.05, fract(o.y * 1.618)));\n            color = mix(vec3(0.175, 0.1, 0.1), color, step(0.35, fract(o.y * 1.618 + 0.9)));\n            color *= exp(-(1.0 - i) * 15.0);\n            return;\n        }\n\n        o.x *= 0.6;\n        ray.pos += ray.dir * o.x;\n        ad += o.x;\n        if (ad > md)\n        {\n            break;\n        }\n    }\n    \n    color = mix(vec3(0.0), vec3(1.0), ray.dir.y * ray.dir.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) \/ min(iResolution.x, iResolution.y);\n    vec3 color = vec3(0.0);\n\n    vec3 view = vec3(0.0, 0.0, 10.0);\n    vec3 at = normalize(vec3(0.0, 0.0, 0.0) - view);\n    vec3 right = normalize(cross(at, vec3(0.0, 1.0, 0.0)));\n    vec3 up = cross(right, at);\n    float focallength = 3.0;\n\n    Ray ray;\n    ray.pos = view;\n    ray.dir = normalize(right * p.x + up * p.y + at * focallength);\n    \n    trace(ray, color, 20.0);\n\n    color = pow(color, vec3(0.454545));\n    fragColor = vec4(color, 1.0);\n}",
            "name": "Image",
            "description": "",
            "type": "image"
        }
    ]
}