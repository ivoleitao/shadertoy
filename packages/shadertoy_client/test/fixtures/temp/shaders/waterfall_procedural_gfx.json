{
    "ver": "0.1",
    "info": {
        "id": "ts2cWD",
        "date": "1586707880",
        "viewed": 4873,
        "name": "Waterfall - Procedural GFX",
        "username": "NuSan",
        "description": "Procural image made for Revision 2020 4k Excutable Graphics competition\nIt's a direct reference to M.C. Escher's \"Waterfall\" with an awesome impossible geometry.\nhttps:\/\/www.pouet.net\/prod.php?which=85268",
        "likes": 127,
        "published": 1,
        "flags": 32,
        "usePreview": 0,
        "tags": [
            "pathtrace",
            "escher",
            "toon",
            "proceduralgraphics",
            "reproduction"
        ],
        "hasliked": 0
    },
    "renderpass": [
        {
            "inputs": [
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "nearest",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dfGRr",
                    "channel": 0
                }
            ],
            "code": "\/*\nProcural image made for Revision 2020 4k Excutable Graphics competition\nIt's a direct reference to M.C. Escher's \"Waterfall\" with an awesome impossible geometry.\nhttps:\/\/www.pouet.net\/prod.php?which=85268\n\nSee a bit behind the magic here: https:\/\/twitter.com\/NuSan_fx\/status\/1249424629783027712\n*\/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t       \n    vec2 res = iResolution.xy;\n\tvec2 frag = fragCoord.xy;\n\tvec2 uv = frag\/res.xy;\n\t\n\tvec4 value=texture(iChannel0,uv);\n    \n\tfragColor = vec4(value.xyz\/value.w, 1);\n}\n",
            "name": "Image",
            "description": "",
            "type": "image"
        },
        {
            "inputs": [
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dXGR8",
                    "channel": 0
                }
            ],
            "code": "\/*\nProcural image made for Revision 2020 4k Excutable Graphics competition\nIt's a direct reference to M.C. Escher's \"Waterfall\" with an awesome impossible geometry.\nhttps:\/\/www.pouet.net\/prod.php?which=85268\n\nSee a bit behind the magic here: https:\/\/twitter.com\/NuSan_fx\/status\/1249424629783027712\n*\/\n\n\/\/ sin-hash\n\nfloat rnd11(float t) { return fract(sin(t*274.577)*352.841);}\nvec3 rnd23(vec2 uv) {return fract(sin(uv.xyy*427.512+uv.yxx*374.524+uv.xyx*742.814)*342.554);}\nfloat rnd31(vec3 t) {return fract(dot(sin(t*274.577+t.yzx*427.544),vec3(352.841)));}\n\nfloat rnd21(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat srnd21(vec2 p)\n{\n    vec2 ip=floor(p);\n    p=fract(p);\n    \/\/p=smoothstep(0.,1.,p);\n    \n    float p1 = mix(rnd21(ip),rnd21(ip+vec2(1,0)),p.x);\n    float p2 = mix(rnd21(ip+vec2(0,1)),rnd21(ip+vec2(1,1)),p.x);\n    \n    return mix(p1,p2,p.y);\n}\n\nfloat noise21(vec2 p, float pro, float st) {\n    float v=0.0;\n    float s=0.5;\n    for(float i=0.; i<st; ++i) {\n        v+=srnd21(p+i*72.3)*s;\n        p*=pro;\n        s*=0.5;\n    }\n    return v;\n}\n\nfloat pi=acos(-1.);\nmat2 rot(float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat c01(float a) {return clamp(a,0.,1.);}\n\n\/\/ stroke effects\nfloat samp(vec2 uv, float col) {\n    \n    float base = col;\n    float ret = 1.0;\n        \n\tfloat alpha=0.7;\n    for(float i=1.0; i>0.0; i-=0.1) {\n        alpha=min(alpha,smoothstep(0.01,0.1,i-base));\n        vec2 scale = vec2(40.0,1.0)*45.0*(1.0+0.2*rnd11(i+232.1));\n        \/\/vec2 uv3 = uv*rot(sin(rnd11(i+72.84))*.9 - 1.5);\n\t\tvec2 uv3 = uv*rot((rnd11(i+72.84)-.5)*.5);\n        uv3.x += rnd11(i*3.2+12.7);\n        float tval = noise21(uv3*scale,1.7,10.);\n        \/\/col *= mix(1.,step(tval*1.2-0.1,base),0.5);\n        \/\/tval=smoothstep(0.3,0.6,tval);\n\t\ttval=smoothstep(0.3,0.4,tval);\n        ret *= mix(1.0,tval,alpha);\n    }\n    return ret;\n}\n\n\/\/ FIRST PASS\n\n\/\/ noise value per pixel\/frame\n\/\/ to use for visual trickeries\nfloat blend=0.0;\n\nvec3 s,r,n=vec3(0);\nvec3 boxid=vec3(0);\n\nvec3 localpos=vec3(0);\nfloat nd = 10000.0;\n\nvec3 cutplane=vec3(0,1,0);\n\nfloat box(vec3 p, vec3 s) {\n    p=abs(p)-s;\n    return max(p.x, max(p.y,p.z));\n\t\/\/return length(max(p,vec3(0))) + min(0.,max(p.x,max(p.y,p.z)));\n}\n\nfloat box2(vec2 p, vec2 s) {\n    p=abs(p)-s;\n    return max(p.x, p.y);\n}\n\nfloat rep(float a, float d) {\n\treturn (fract(a\/d+.5)-.5)*d;\n}\n\nvec2 rep2(vec2 a, vec2 d) {\n\treturn (fract(a\/d+.5)-.5)*d;\n}\n\nfloat octa(vec3 p, float s) {\n\tp = abs(p);\n    float m = p.x + p.y + p.z - s;\n\treturn m*0.577;\n}\n\nfloat pathpart(vec3 p, float h) {\n    \n    vec3 bp=p;\n    \n    float d = box(p,vec3(6,h,1));\n    p.y+=1.;    \n    \n    p.x-=0.0;\n    p.x=abs(p.x);\n    p.x-=5.0;\n    p.xz=abs(p.xz);\n    p.xz-=1.0;\n    \n    \/\/ we cut and blend the parts of the bridge\n\tfloat cut = dot(bp, cutplane)-1.0 - blend*2.;\n    float d2 = box(p, vec3(0.2,10.0,0.2));\n    d2 = max(d2, cut);\n    \n    d=min(d, d2);\n    \n    return d;\n}\n\nfloat pathtop(vec3 p) {\n    \n    vec3 bp=p;\n    \n\tvec3 p2 = p+vec3(-5,7,0);\n\tp2.yz *= rot(-pi*0.5);\n    p2.xy *= rot(-1.8);\n\tp2=abs(p2);\n    p2.xy *= rot(pi*0.25);\n    p2.yz *= rot(pi*0.25);\n    p2=abs(p2);\n    p2.yz *= rot(pi*0.25);\n    p2.xy *= rot(pi*0.25);\n\n\tvec3 p3 = p+vec3(5,7,0);\n\tp3.yz *= rot(pi*0.5);\n    p3.xy *= rot(.4);\n\tfloat b2 = box(p3, vec3(1.4));\n\tp3.xy*=rot(pi*.25);\n\tp3.yz*=rot(pi*.25);\n\tb2=min(b2, box(p3, vec3(1.4)));\n\tp3.yz*=rot(pi*.25);\n\tp3.xy*=rot(pi*.25);\n\tb2=min(b2, box(p3, vec3(1.4)));\n\n    p.x=abs(p.x);\n    p.x-=5.0;\n    \n    p.y+=5.0;\n    float d = box(p,vec3(2.0,0.2,2.0));\n\n\td=min(d, octa(p2, 2.5));\n\td=min(d, b2);\n    \t\n    p.y-=5.0;\n\n    p.xz=abs(p.xz);\n    p.xz-=1.0;\n    \n    float d2 = box(p, vec3(0.2,5.0,0.2));\n    \n    d=min(d, d2);\n\t    \n    return d;\n}\n\nfloat waterpath(vec3 p) {\n    \n    vec3 bp=p;\n    \n    p.xz=-p.xz;\n    p.xz+=vec2(15.,0.);\n    if(p.x<p.z) p.xz=p.zx;\n    p.x-=10.;\n    if(p.x<p.z) p.xz=p.zx;\n    p.y+=1.;\n    return box(p,vec3(11,max(0.0,0.95 - bp.x*0.03),0.8));\n}\n\nfloat path(vec3 p){\n    \n    p.z+=10.;\n    p.y+=3.;\n\n    float d = pathpart(p,1.);\n    p.xz=-p.zx+vec2(5,-5);\n    d=min(d,pathpart(p,0.6));\n    p.xz=-p.zx+vec2(5,-5);\n    d=min(d,pathpart(p,0.4));\n    p.xz=-p.zx+vec2(5,-5);\n    d=min(d,pathpart(p,0.2));\n    \n    d=max(d, -waterpath(p));\n    d=min(d, pathtop(p));\n    \n    p+=vec3(5,-0.1,2);\n    d=min(d, box(p,vec3(1,0.3,1)));\n    p.y+=0.33;\n    d=max(d, -box(p,vec3(0.8,0.3,1.9)));\n    \n    return d;\n}\n\nvec3 cx,cy,cz=vec3(0);\n\nfloat hou1(vec3 p) {\n\n\tvec3 bp=p;\n\tvec3 bp2=p;\n\tp+=vec3(-9,-.5,6);\n\n\tfloat d1=box2(p.xz,vec2(5,8));\n\td1=min(d1, box2(p.xz-vec2(5,2.),vec2(3,5)));\n\n\tvec2 p2 = vec2(d1,p.y);\n\tfloat d = box2(p2, vec2(1,4.5));\n\t\n\tp.y+=5.0;\n\td=min(d,max(abs(abs(p.y+0.3)-.3)-0.1, abs(d1)-0.2));\n\n\tp.xz=rep2(p.xz,vec2(1.0));\n\td=min(d,box(p,vec3(0.1,1,0.1)));\n\td=max(d,box2(p2,vec2(0.5,10)));\n\n\tbp+=vec3(-8,4,4);\n\tfloat d3 = box(bp,vec3(5,10,3));\n\tbp.z=-abs(bp.z);\n\tbp.y+=10.;\n\tfloat d4=dot(bp.yz,vec2(-0.7));\n\td3=max(d3,d4);\n\td3=min(d3, max(abs(d4)-0.15, box2(bp.xz-vec2(.5,0),vec2(5.5,4))));\n\td3=max(d3, -box(bp2+vec3(-13.5,5.2,5.5), vec3(1,1.5,0.7)));\n\tvec3 bp3=bp2+vec3(-12.5,13,5);\n\td3=min(d3, box(bp3, vec3(0.5,3,0.3)));\n\tfloat d5=dot(vec2(bp3.y+3.5,-abs(bp3.z)),vec2(-0.7));\n\td3=min(d3,max(abs(d5)-0.1, max(abs(bp3.x),abs(bp3.z))-0.6));\n\t\t\n\td=min(d, d3);\n\td=min(d, max(d1,10.4-bp.y));\n\n\t\/\/ water entry\n\td=max(d, -box(bp2+vec3(-3,7.5,10),vec3(5,4,1)));\n\t\n\treturn d;\n}\n\nfloat wheel(vec3 p) {\n\tp+=vec3(-8,5.5,10);\n\tfloat d=max(abs(length(p.xy)-1.1)-.2,abs(p.z)-1.6);\n\tvec3 p3 = p-cz*35.;\n\td=min(d, max(length(p3.xy)-0.8,abs(p3.z-2.5)-3.));\n\tfloat a=atan(p.x,-p.y)*pi*2.;\n\ta=rep(a,3.);\n\tvec3 p2=vec3(a, length(p.xy),p.z);\n\tp2.y-=1.3;\n\td=min(d, box(p2, vec3(0.2,0.6,1.3))*.5);\n\n\tp+=vec3(-2,-2.5,0);\n\n\tp += sin(p.yzx*7.0+vec3(.4,.3,2.9))*.5;\n\tfloat s=(length(p)-1.0)*.3;\n\ts=max(s,length(p)-3.);\n\n\td=min(d,s);\n\n\treturn d;\n}\n\nfloat water(vec3 p) {\n\tp+=vec3(-9.5,5.,9.7);\n\tfloat d1 = length(p.xy+vec2(2,10.1))-2.0;\n\td1=min(d1,box2(p.xy,vec2(.0,10.0)));\n\t\n\tfloat d= max(abs(d1)-.1,abs(p.z)-0.7);\n\t\n\td=max(d, min((10.+p.y), -.1-p.x));\n\td=max(d,-2.6-p.x);\n\td=min(d, box(p+vec3(3.8,12,0),vec3(1.8,0.2,0.7)));\n\td=min(d, box(p+vec3(4.8,12.1,3),vec3(0.8,0.1,3.0)));\n\treturn d;\n}\n\nfloat stair(vec3 p, float size, float w, float h) {\n  vec3 bp=p;\n  p.xy *= rot(pi*0.25);\n  p.x=rep(p.x,size*2.0);\n  p.xy *= rot(pi*0.25);\n  float d=box(p, vec3(size,size,w));\n  d=max(d, abs(bp.y)-h);\n  return d;\n}\n\nfloat back(vec3 p) {\n\n\tp+=vec3(10,12,0);\n\n\tvec3 ra = vec3(atan(p.x,p.z)*pi*2., p.y,length(p.xz)-80.0);\n\n\tra.zy *= rot(-0.7);\n\tra.z=rep(ra.z, 3.);\n\tra.zy *= rot(0.7);\n\n\tfloat d = box(ra, vec3(20,1,1));\n\td=max(d,dot(p.zx,normalize(vec2(-1.2,1))));\n\n\td=max(d, 10.-abs(p.y-5.));\n\n\treturn d;\n}\n\nfloat fore(vec3 p) {\n\tp+=vec3(3,0,17);\n\tfloat d=box(p, vec3(3,3,7));\n\td=max(d,-box(p+vec3(0,4.5,0), vec3(2.5,2,5.5)));\n\tvec3 p2=p+vec3(0,1,-3.5);\n\tp2.y=max(0.,-p2.y);\n\td=max(d, 1.-length(p2.zy));\n\tp.z+=5.;\n\td=min(d,box(p, vec3(3.5,6,3.5)));\n\td=max(d,-box(p+vec3(0,7,0), vec3(3,1.5,3)));\n\n\treturn d;\n}\n\nfloat map(vec3 p){\n    float d=10000.0;\n\n\tvec3 p5=p-vec3(10,11,-26);\n\td=min(d, box(p5,vec3(20,10,15)));\n\tp5+=vec3(-4,6,-10.5);\n\td=max(d, -box(p5,vec3(10,5,4)));\n\tp5+=vec3(5.5,0,13.5);\n\td=max(d, -box(p5,vec3(7,10,9)));\n\t\n    d=min(d, path(p));\n    \n    \/\/ close house\n\td=min(d, max(hou1(p),p.z+9.5+blend*1.));\n\n\t\/\/ duplicated house but farer for visual trickery\n\tvec3 p3 = p-cz*35.;\n\td=min(d, max(hou1(p3),-p.z-1.5));\n    \n    \/\/ left part\n\tp3+=vec3(1.5,0,1);\n\tvec3 p4=p3;\n\tp4.y=max(0.,-p4.y);\n\td=max(d, 3.-length(p4.xy+vec2(-19,0)));\n\td=min(d, box(p3+vec3(-20,-5,3),vec3(5,4,5)));\n\td=max(d, -box(p3+vec3(-20,-1,3),vec3(4,1,4)));\n\t\t\n\t\/\/ arc 2\n\tvec3 p2=p+vec3(-7,0,0);\n\tp2.y=max(0.,-p2.y);\n\td=max(d, -max(length(p2.xy)-2., abs(p2.z)-18.));\n\t\n\td=min(d,wheel(p));\n\n\tfloat limw = -13.-p.y+blend*8.;\n\td=min(d,max(water(p),limw));\n\td=min(d,water(p-cz*31.2));\n\n\td=min(d, back(p));\n\td=min(d, fore(p));\n\n\t\/\/ Bottom part\n    p5+=vec3(2.5,2,-14);\n\td=min(d, box(p5,vec3(15,1,4)));\n\tp5+=vec3(1.5,1.25,0);\n\td=min(d, stair(p5.zyx*vec3(-1.2,1.2,1), 0.35, 0.5, 2.));\n\tp5+=vec3(2.5,-1.25,7);\n\td=min(d, stair(p5.zyx*vec3(-1,1,1), 0.25, 2.0, 2.));\n\n    d=min(d, -p.y+50.);\n    \n    return d;\n}\n\n\nbool gotclose = false;\nbool gotfar = false;\n\n\n\/\/ suggested from tdhooper. Thanks!\n\/\/ improve compilation time & overall fps.\nconst int NORMAL_STEPS = 6;\nvec3 normal(vec3 pos) {\n\tvec3 eps = vec3(.01, 0, 0);\n\tvec3 nor = vec3(0);\n\tfloat invert = 1.;\n\tfor (int i = 0; i < NORMAL_STEPS; i++) {\n\t\tnor += map(pos + eps * invert) * eps * invert;\n\t\teps = eps.zxy;\n\t\tinvert *= -1.;\n\t}\n\treturn normalize(nor);\n}\n\nvoid trace() {\n  \n  vec3 p=s;\n  for(int i=0; i<100; ++i) {\n\tfloat d=map(p);\n      if(d<0.05) gotclose=true;\n      if(gotclose && d>0.05) gotfar=true;\n      if(d<0.001) break;\n      if(d>100.0) break;\n      p+=r*d;\n  }\n    \n  vec2 off=vec2(0.01,0);\n  n=normal(p);\n    \n  s = p;\n}\n\nfloat shadow(vec3 l) {\n    float shad=1.0;\n    vec3 p=s+n*0.1+l*0.1;\n    float dd=0.;\n    for(int i=0;i<50; ++i) {\n        float d=map(p);\n        \/\/shad=min(shad,(abs(d)-.1)*10.);\n        if(d<0.1) {\n            shad=0.0;\n            break;\n        }\n        if(dd>20.) break;\n        p+=l*d;\n        dd+=d;\n    }\n    return shad;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t         \n    vec2 frag = fragCoord.xy;\n\tvec2 uv = (frag-iResolution.xy*0.5)\/iResolution.y;\n    \n    vec4 finalcolor = vec4(0);\n    if(iFrame>0) {\n        finalcolor += texture(iChannel0, fragCoord\/iResolution.xy);\n    }\n    \n    \/\/ verify if middle mouse clicked or if resolution changed\n    if(iMouse.z > .5 || texelFetch(iChannel0, ivec2(0),0).y != iResolution.y) {\n        finalcolor=vec4(0);\n    }\n\t\n    int tilecount = 10;\n    int curtile = int(frag.y*float(tilecount)\/iResolution.y);\n    \n    if(iFrame%tilecount == curtile) {\n        float col=0.0;\n\n        bool isback=false;\n\n        if(abs(uv.x)<0.43) {\n            uv+=vec2(0.02,0.045);\n\n            vec3 finalp=vec3(0);\n            vec3 finals=vec3(0);\n            vec3 finaln=vec3(0,1,0);\n\n            s=vec3(50,-40,-50);\n            vec3 t = vec3(0,-4,0);\n\n            cz=normalize(t-s);\n            cx=normalize(cross(cz,vec3(0,1,0)));\n            cy=cross(cz,cx);\n\n            cutplane = cy;\n\n            float fov = 34.0;\n\n            float motime = iTime;\n\n            float edge=1.0;\n            float edge2=1.0;\n\n            blend = rnd21(frag+vec2(motime,0));\n\n            vec2 h = rnd23(frag-13.6+motime*37.7).xy * vec2(1.,6.283);\n            vec3 voff = sqrt(h.x)*(cx*sin(h.y)+cy*cos(h.y))*.3\/iResolution.y;\n            \/\/ ortho\n            s += vec3((uv.x*cx+uv.y*cy)*fov);\n            r=normalize(cz + voff);\n            \/\/ persp\n            \/\/r=normalize(uv.x*cx+uv.y*cy+fov*cz + voff*fov);\n            finals=s;\n\n            vec3 bs = s;\n            float alpha=1.0;\n            int bounce=4;\n            int ZERO = min(0,iFrame);\n            for(int j=ZERO; j<bounce; ++j) {\n                trace();\n                if(j==0) {\n                    finalp=s; \/\/ s;\n                    finaln=n;\n                    if(gotfar) {\n                        edge=0.0;\n                    }\n                }\n\n                if(length(s)>200.) {\n                    \/\/col +=2.0*alpha*abs(r.y);\n                    col += 2.7*alpha*c01(-r.y*2.);\n                    break;\n                } else {\n\n                    vec3 id2 = floor(s*1.0+.01);\n                    float r3d2 = rnd31(id2*27.33);\n\n\n\n                    float fre=pow(max(0.,1.-abs(dot(r,n))),1.0);\n\n                    float val=0.0;\n\n                    vec3 l = normalize(vec3(4,-11,-1));\n                    vec3 l2 = normalize(vec3(4,-3,-2)); \/\/ cheating !\n                    float shad = shadow(l2);\n                    \/\/val += shad * 0.4;\n                    val += shad * max(0.,dot(n,l)) * 1.2;\n\n                    val=max(0.0,val);\n\n                    col += val*alpha;\n\n\n                    float rough = 1.0;\/\/ 0.0+1.0*r3d2;\n\n                    if(j==0) {\n                        \/\/col = mix(col, 0.1, smoothstep(30,70,length(s)));\n                        if(length(s)>38.) isback=true;\n                        else {\n                            edge2 *= step(0.9,map(s+n*0.05)\/0.05);\n                            edge2 *= step(0.9,-map(s-n*0.05)\/0.05);\n                        }\n                    }\n\n                    r=normalize(reflect(r,n) + normalize(rnd23(frag+vec2(0,j*375)+motime*172.3)-.5)*rough);\n\n                    alpha *= fre;\n                    s+=n*0.005;\n                }\n            }\n\n            col *= mix(edge*edge2,1.,0.4);\t\n\n            #if 1\n            \/\/ apply stroke effect\n            float base=pow(col*.7,0.8)-0.0;\n            vec3 projpos = finalp*2.0\/length(finalp-finals);\n            \/\/vec3 projpos = finalp*0.02;\n            vec3 vals = vec3(samp(projpos.zy, base), samp(projpos.zx, base), samp(projpos.xy, base));\n            vec3 facts = abs(finaln);\n            facts \/= dot(facts,vec3(1.0));\n            float newcol = dot(vals,facts);\n\n            col *= mix(newcol,1.,0.3);\n            #endif\n\n            if(isback) {\n                col=c01(col)*.4+.4;\n            }\n\n        }\n\n        finalcolor += vec4(vec3(col)*mix(vec3(0.9,0.7,0.5), vec3(1.), smoothstep(0.8,0.9, col)), 1);\n    }\n    \n    \/\/ store last rendered resolution\n    if(ivec2(fragCoord)==ivec2(0)) {\n        finalcolor=iResolution.xyxy;\n    }\n    \n    fragColor = finalcolor;\n}\n",
            "name": "Buffer A",
            "description": "",
            "type": "buffer"
        }
    ]
}