{
    "ver": "0.1",
    "info": {
        "id": "wlVGRz",
        "date": "1578176135",
        "viewed": 3880,
        "name": "Echeveria",
        "username": "tdhooper",
        "description": "Click to see different distributions",
        "likes": 123,
        "published": 3,
        "flags": 0,
        "usePreview": 0,
        "tags": [
            "plant",
            "succulent"
        ],
        "hasliked": 0
    },
    "renderpass": [
        {
            "inputs": [],
            "outputs": [
                {
                    "id": "4dfGRr",
                    "channel": 0
                }
            ],
            "code": "const float PI  = 3.14159265359;\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat smin(float a, float b, float k){\n    float f = clamp(0.5 + 0.5 * ((a - b) \/ k), 0., 1.);\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\n}\n\nfloat smax(float a, float b, float k) {\n    return -smin(-a, -b, k);\n}\n\nfloat time;\n\nvec4 leaf(vec3 p, vec2 uv) {\n    float thick = clamp(uv.y, .7, 1.);\n    thick = 1.;\n    float th = thick * .16;\n    pR(p.xz, -uv.x);\n    float width = mix(.5, .1, min(uv.y, 1.));\n    width = .75 \/ uv.y;\n    width *= thick;\n    vec3 n = normalize(vec3(1,0,width));\n    float d = -dot(p, n);\n    d = max(d, dot(p, n * vec3(1,1,-1)));\n    float len = mix(PI \/ 1.2, PI \/ 2., pow(uv.y\/2.9, 2.));\n    len = max(len, 0.);\n    pR(p.yz, PI \/ 2. - len);\n    d = smax(d, p.y, thick);\n    d = smax(d, abs(length(p) - uv.y) - thick * th, th);\n    vec2 uuv = vec2(\n        atan(p.y, p.z) \/ -len,\n        p.x\n   \t);\n    vec3 col = mix(vec3(0), vec3(.5,1,.7) * .05, 1.-smoothstep(.0, .5, uuv.x));\n    col += vec3(.06,.0,.03) * max(1. - uv.y \/ 2., 0.);\n    col = mix(col, col * .2, 1.-smoothstep(.0, .2, uuv.x));\n    return vec4(d, col);\n}\n\nbool lightingPass;\n\nvec4 opU(vec4 a, vec4 b) {\n    return a.x < b.x ? a : b;\n}\n\nvec4 bloom(vec3 p) {\n\n    float bound = length(p - vec3(0,-1.2,0)) - 3.3;\n    bound = max(bound, p.y - 1.1);\n    if (bound > .01 && ! lightingPass) {\n        return vec4(bound, 0, 0, 0);\n    }\n\n    vec2 cc = vec2(5., 8.);\n    if (iMouse.z > 0.) {\n    \tcc = floor(iMouse.xy \/ iResolution.xy * 10.);\n    }\n    float aa = atan(cc.x \/ cc.y);\n    float r = (PI*2.) \/ sqrt(cc.x*cc.x + cc.y*cc.y);\n    mat2 rot = mat2(cos(aa), -sin(aa), sin(aa), cos(aa));\n    \n    vec2 offset = vec2(1, 2) * time * r * rot;\n    \n    vec2 uv = vec2(\n        atan(p.x, p.z),\n        length(p)\n    );\n\n    uv -= offset;\n\n    uv = rot * uv;\n    vec2 cell = round(uv \/ r);\n\n    vec4 d = vec4(1e12, vec3(0));\n\n    d = opU(d, leaf(p, ((cell + vec2(-1, 0)) * rot * r) + offset));\n    d = opU(d, leaf(p, ((cell + vec2(0, -1)) * rot * r) + offset));\n    d = opU(d, leaf(p, ((cell + vec2(0, 0)) * rot * r) + offset));\n    d = opU(d, leaf(p, ((cell + vec2(1, -1)) * rot * r) + offset));\n    d = opU(d, leaf(p, ((cell + vec2(1, 0)) * rot * r) + offset));\n\n    \/\/*\n    d = opU(d, leaf(p, ((cell + vec2(-1, -1)) * rot * r) + offset));\n   \td = opU(d, leaf(p, ((cell + vec2(-1, 1)) * rot * r) + offset));\n    d = opU(d, leaf(p, ((cell + vec2(0, 1)) * rot * r) + offset));\n    d = opU(d, leaf(p, ((cell + vec2(1, 1)) * rot * r) + offset));\n\t\/\/*\/\n\n    return d;\n}\n\nvec4 map(vec3 p) {\n    return bloom(p);\n}\n\nvec3 calcNormal(vec3 pos){\n    float eps = .0005;\n    vec2 e = vec2(1.0,-1.0) * 0.5773;\n    return normalize(\n        e.xyy * map(pos + e.xyy * eps).x + \n\t\te.yyx * map(pos + e.yyx * eps).x + \n\t\te.yxy * map(pos + e.yxy * eps).x + \n\t\te.xxx * map(pos + e.xxx * eps).x\n    );\n}\n\n\/\/ https:\/\/www.shadertoy.com\/view\/lsKcDD\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    float ph = 1e10;\n    \n    for( int i=0; i<64; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        res = min( res, 10.0*h\/t );\n        t += h;\n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\/\/ https:\/\/www.shadertoy.com\/view\/Xds3zN\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)\/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n\/\/#define AA 3\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec3 col;\n    vec3 tot = vec3(0.0);\n\n    float mTime = mod(iTime \/ 2., 1.);\n    time = mTime;\n\n    vec2 o = vec2(0);\n\n    #ifdef AA\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n    \/\/ pixel coordinates\n    o = vec2(float(m),float(n)) \/ float(AA) - 0.5;\n    \/\/ time coordinate (motion blurred, shutter=0.5)\n    float d = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n    time = mTime - 0.1*(1.0\/24.0)*(float(m*AA+n)+d)\/float(AA*AA-1);\n    #endif\n        lightingPass = false;\n\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))\/iResolution.y;\n\n        vec3 camPos = vec3(0.5, 7.4, -8.7) * .9;\n        mat3 camMat = calcLookAtMatrix( camPos, vec3(0,-1.4,0), -0.5);\n        vec3 rd = normalize( camMat * vec3(p.xy,2.8) );\n\n        vec3 pos = camPos;\n        float rayLength = 0.;\n        float dist = 0.;\n        bool bg = false;\n        vec4 res;\n\n        for (int i = 0; i < 100; i++) {\n            rayLength += dist;\n            pos = camPos + rd * rayLength;\n            res = map(pos);\n            dist = res.x;\n\n            if (abs(dist) < .001) {\n                break;\n            }\n            \n            if (rayLength > 16.) {\n                bg = true;\n                break;\n            }\n        }\n\n        col = vec3(.19,.19,.22) * 1.9;\n        col = vec3(.35,.24,.0) * 1.8;\n\t\tcol = vec3(.5,1,.7) * .05;\n        \n        if ( ! bg) {\n            \n            lightingPass = true;\n            \n\t\t\tvec3 nor = calcNormal(pos);\n            float occ = calcAO( pos, nor );\n            vec3  lig = normalize( vec3(-.2, 1.5, .3) );\n            vec3  lba = normalize( vec3(.5, -1., -.5) );\n            vec3  hal = normalize( lig - rd );\n            float amb = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n            float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n            float bac = clamp( dot( nor, lba ), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n            float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\n            occ = mix(1., occ, .8);\n            \n            dif *= softshadow( pos, lig, 0.001, .9 );\n\n            float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                        dif *\n                        (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n            vec3 lin = vec3(0.0);\n            lin += 2.80*dif*vec3(1.30,1.00,0.70);\n            lin += 0.55*amb*vec3(0.40,0.60,1.15)*occ;\n            lin += 1.55*bac*vec3(0.25,0.25,0.25)*occ*vec3(2,0,1);\n            lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\n            col = res.yzw;\n        \tcol = col*lin;\n\t\t\tcol += 5.00*spe*vec3(1.10,0.90,0.70);\n\n            \/\/col = nor * .5 + .5;\n            \/\/col = max(dot(vec3(.1,1,-.2), nor), 0.) * vec3(.2);\n        }\n\n        tot += col;\n    #ifdef AA\n    }\n    tot \/= float(AA*AA);\n    #endif\n\n    col = tot;\n    col *= 1.3;    \n    col = pow( col, vec3(0.4545) );\n\n    fragColor = vec4(col,1.0);\n}\n",
            "name": "Image",
            "description": "",
            "type": "image"
        }
    ]
}