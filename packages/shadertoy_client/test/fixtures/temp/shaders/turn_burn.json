{
    "ver": "0.1",
    "info": {
        "id": "MlscWX",
        "date": "1509015241",
        "viewed": 14807,
        "name": "Turn n' Burn",
        "username": "ingagard",
        "description": "Please read description in the top of Image for information about controls and optimizations.\nUse the mouse while holding down the left mouse button to control the camera.\n\nEnjoy!",
        "likes": 167,
        "published": 3,
        "flags": 48,
        "tags": [
            "3d",
            "terrain",
            "raymarch",
            "raycast",
            "cloud",
            "explosion",
            "texture",
            "light",
            "camera",
            "sky",
            "raytrace",
            "plane",
            "air",
            "missile",
            "highmap"
        ],
        "hasliked": 0
    },
    "renderpass": [
        {
            "inputs": [
                {
                    "id": "XsX3Rn",
                    "filepath": "\/media\/a\/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg",
                    "previewfilepath": "\/media\/ap\/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg",
                    "type": "texture",
                    "channel": 3,
                    "sampler": {
                        "filter": "mipmap",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "Xsf3zn",
                    "filepath": "\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
                    "previewfilepath": "\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
                    "type": "texture",
                    "channel": 1,
                    "sampler": {
                        "filter": "mipmap",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "4sXGR8",
                    "filepath": "\/media\/previz\/buffer02.png",
                    "previewfilepath": "\/media\/previz\/buffer02.png",
                    "type": "buffer",
                    "channel": 2,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dfGRr",
                    "channel": 0
                }
            ],
            "code": "\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Copyright \u00a9 2017 Kim Berkeby\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/*\n\n CONTROLS:\n ---------\n SPACE  FIRE MISSILE\n \n S      ROLL LEFT\n F      ROLL RIGHT  \n E      PITCH DOWN\n D      PITCH UP\n \n W      YAW LEFT   (PLANE TURN) \n R      YAW RIGHT   (PLANE TURN)\n \n SHIFT  INCREASE SPEED\n CTRL   DECCREASE SPEED \n \n F1     ZOOM OUT\n F2     ZOOM IN\n \n NOTICE:\n Controls can be changed to use arrow keys if you uncomment the alternative controls in Buf A. \n \n \n Toggle effects by pressing folloving keys:\n ------------------------------------------\n 1-key  = Lens dirt  on\/off               (default off)\n 2-key  = Grain filter  on\/off            (default on)\n 3-key  = Chromatic aberration  on\/off    (default on)    \n 4-key  = Anti aliasing  on\/off           (default on)\n 5-key  = Lens flare  on\/off              (default on)\n \n --------------------------------------------------------\n TO INCREASE PERFORMANCE:\n \n Delete one or several defines from Buf B:\n \n #define SHADOWS\n #define QUALITY_TREE\n #define QUALITY_REFLECTIONS\n #define EXACT_EXPLOSIONS\n --------------------------------------------------------\n \n This shader was made by using distance functions found in HG_SDF:\n http:\/\/mercury.sexy\n \n Special thanks to Inigo Quilez for his great tutorials on:\n http:\/\/iquilezles.org\/\n \n Last but not least, thanks to all the nice people here at ShaderToy! :-D\n\n*\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ POST EFFECTS BUFFER\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Channel 0 = Buffer A. Read data from data-buffer.\n\/\/ Channel 1 = LowRes noise texture. Used in fast noise functions.\n\/\/ Channel 2 = Buffer C. Get the colors of the render from the last buffer.\n\/\/ Channel 3 = Organic 2 texture. Used in lens dirt filter.\n\n\n  #define FastNoise(posX) (  textureLod(iChannel1, (posX+0.5)\/iResolution.xy, 0.0).r)\n  #define readAlpha(memPos) (  textureLod(iChannel2, memPos, 0.0).a)\n  #define read(memPos) (  texelFetch(iChannel0, memPos, 0).a)\n  #define readRGB(memPos) (  texelFetch(iChannel0, memPos, 0).rgb)\n  #define CLOUDLEVEL -70.0\n  #define PI acos(-1.)\n  #pragma optimize(off) \nmat3 cameraMatrix;\nvec3 planePos=vec3(0.);\nvec3 sunPos=vec3(0.);\nconst vec3 eps = vec3(0.02, 0.0, 0.0);\n\nfloat GetExplosionIntensity(float life)\n{\n  return mix(1., .0, smoothstep(0., 5.0, distance(life, 5.)));\n}\n\n\/\/ 3D noise function (IQ)\nfloat fastFBM(vec3 p)\n{\n  vec3 ip=floor(p);\n  p-=ip; \n  vec3 s=vec3(7, 157, 113);\n  vec4 h=vec4(0., s.yz, s.y+s.z)+dot(ip, s);\n  p=p*p*(3.-2.*p); \n  h=mix(fract(sin(h)*43758.5), fract(sin(h+s.x)*43758.5), p.x);\n  h.xy=mix(h.xz, h.yw, p.y);\n  return mix(h.x, h.y, p.z);\n}\n\nmat3 setCamera(  vec3 ro, vec3 ta, float cr )\n{\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n  vec3 cu = normalize( cross(cw, cp) );\n  vec3 cv = normalize( cross(cu, cw) );\n  return mat3( cu, cv, cw );\n}\n\nvec2 GetScreenPos(vec3 pos)\n{\n  return vec2(PI*dot( pos, cameraMatrix[0].xyz ), PI* dot( pos, cameraMatrix[1].xyz ));\n}\n\nvec3 CalculateSunFlare(vec3 rayDir, vec3 rayOrigin, vec2 screenSpace, float alpha, float enableFlare)\n{\n  float visibility = pow(max(0., dot(sunPos, rayDir)), 8.0);  \n  if (visibility<=0.05) return vec3(0.);\n\n  vec2 sunScreenPos = GetScreenPos(sunPos);\n\n  vec2 uvT = screenSpace-sunScreenPos;\n  float sunIntensity = (1.0\/(pow(length(uvT)*4.0+1.0, 1.30)))*visibility;\n\n  vec3 flareColor = vec3(0.);\n  vec2 offSet = uvT;\n  vec2 offSetStep=  0.4*sunScreenPos;\n  vec3 color;\n  float size=.0, dist=0.;\n  \n  if(enableFlare>0.)\n  {\n  \/\/ check if center of sun is covered by any object. MATH IS OFF AT SCREEN CHECK POS! sunScreenPos\/2.0 +0.5 IS NOT EXACTLY SUN MIDDLE!\n  \/\/ only draw if not covered by any object\n  if (readAlpha( sunScreenPos\/2.0 +0.5)<0.50)\n  {\n    \/\/ create flare rings\n    for (float i =1.; i<8.; i++)\n    {\n      color.rg = vec2(abs((sin(i*53.))), 0.65);\n      color.b = abs((cos(i*25.)));\n      offSet += offSetStep;\n\n      size = 0.05+((1.-sin(i*0.54))*0.28);\n      dist = pow(distance(sunScreenPos, offSet), 1.20);\n\n      flareColor += mix(vec3(0.), sunIntensity*(10.*size) * color, smoothstep(size, size-dist, dist))\/(1.0-size);\n    }\n  }\n  flareColor*=mix(0., 1.0, smoothstep(0., 0.1, visibility));\n  }\n    \n  \/\/ flare star shape\n  vec3 sunSpot = vec3(1.30, 1., .80)*sunIntensity*(sin(FastNoise((sunScreenPos.x+sunScreenPos.y)*2.3+atan(uvT.x, uvT.y)*15.)*5.0)*.12);\n  \/\/ sun glow\n  sunSpot+=vec3(1.0, 0.96, 0.90)*sunIntensity*.75;\n  sunSpot+=vec3(1.0, 0.76, 0.20)*visibility*0.15;\n\n  return flareColor+(sunSpot*(1.0-alpha));\n}\nvec3 CalculateExplosionFlare(vec3 rayDir, vec3 rayOrigin, vec2 screenSpace, float alpha, vec3 explosionPos, float enableFlare)\n{\n\n  float visibility = max(0., dot(explosionPos, rayDir));  \n  if (visibility<=0.15) return vec3(0.);\n\n  vec2 flareScreenPos = GetScreenPos(explosionPos);\n  vec2 uvT = screenSpace-flareScreenPos;\n  float flareIntensity = 0.2*visibility;\n  vec3 flareColor = vec3(0.);\n  vec2 offSet = uvT;\n  vec2 offSetStep=  0.4*flareScreenPos;\n  vec3 color;\n  float size=.0, dist=0.; \n\n    if(enableFlare>0.)\n    {\n  \/\/ create flare rings\n  for (float i =1.; i<8.; i++)\n  {\n    color.rg = vec2(0.75+(0.25*sin(i*i)));\n    color.b = 0.75+(0.35*cos(i*i));\n    offSet += offSetStep;\n    size = 0.05+((1.-sin(i*0.54))*0.38);\n    dist = pow(distance(flareScreenPos, offSet), 1.20);\n\n    flareColor += mix(vec3(0.), flareIntensity*(4.*size) * color, smoothstep(size, size-dist, dist))\/(1.0-size);\n  }\n  flareColor\/=2.;\n    }\n  \/\/ flare star shape\n  vec3 flareSpot = vec3(1.30, 1., .80)*flareIntensity*(sin(FastNoise((flareScreenPos.x+flareScreenPos.y)*5.+atan(uvT.x, uvT.y)*10.)*4.0)*.2+3.5*flareIntensity);\n  \/\/ flare glow\n  flareSpot+=vec3(1.0, 0.7, 0.2)*pow(visibility, 12.0)*0.3;\n\n  return (flareColor+flareSpot)*(1.0-alpha);\n}\n\nvoid pR(inout vec2 p, float a)\n{\n  p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat DrawExplosion(int id, inout vec4 color, vec3 rayDir, vec3 rayOrigin, vec2 screenSpace, float enableFlare)\n{\n  id *= 100; \n  float dist =-10000.;\n  float life = read(ivec2(122+id, 0));\n\n  \/\/ check if explosion has been spawned\n  if (life>0. )\n  {     \n    vec3 pos = normalize(readRGB(ivec2(120+id, 0))-planePos); \n    float eDist = pow(max(0., dot(pos, rayDir)), 2.0); \n    float intensity =GetExplosionIntensity(life);\n    dist = eDist*intensity*1.4;\n    color.rgb += CalculateExplosionFlare(rayDir, rayOrigin, screenSpace, 1.0-intensity, pos, enableFlare);\n    color.rgb = mix(color.rgb, color.rgb+vec3(1.0, 0.4, 0)*0.5, eDist*intensity);\n  }   \n  return dist;\n}  \n\n\nvec3 AntiAliasing(vec2 uv)\n{\n  vec2 offset = vec2(0.11218413712, 0.33528304367) * (1.0 \/ iResolution.xy);\n\n  return (texture(iChannel2, uv + vec2(-offset.x, offset.y)) +\n    texture(iChannel2, uv + vec2( offset.y, offset.x)) +\n    texture(iChannel2, uv + vec2( offset.x, -offset.y)) +\n    texture(iChannel2, uv + vec2(-offset.y, -offset.x))).rgb * 0.25;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{  \n  vec2 mo = iMouse.xy\/iResolution.xy;\n  vec2 uv = fragCoord.xy \/ iResolution.xy;\n  vec2 screenSpace = (-iResolution.xy + 2.0*(fragCoord))\/iResolution.y;\n\n  \/\/ read values from buffer\n  vec3 effects = readRGB(ivec2(20, 0));  \n  vec3 effects2 = readRGB(ivec2(22, 0)); \n  float turn = read(ivec2(1, 10));\n  sunPos = readRGB(ivec2(50, 0));\n  planePos = readRGB(ivec2(55, 0));\n  \/\/ setup camera and ray direction\n  vec2 camRot = readRGB(ivec2(57, 0)).xy;\n  float CAMZOOM = read(ivec2(52, 0));  \n  vec3 rayOrigin = vec3(CAMZOOM*cos(camRot.x), 3.+CAMZOOM*sin(camRot.y), -3.+CAMZOOM*sin(camRot.x) );\n  pR(rayOrigin.xz, -turn);\n  cameraMatrix  = setCamera( rayOrigin, vec3(0., 0., -3. ), 0.0 );\n  vec3 rayDir = cameraMatrix * normalize( vec3(screenSpace.xy, 2.0) );\n\n  vec2 d = abs((uv - 0.5) * 2.0);\n  d = pow(d, vec2(2.0, 2.0));\n  float minDist = -1000.0;\n\n\n  vec4 color;\n\n  \/\/ chromatic aberration?\n  if (effects.z>0.)\n  {\n    float offSet = distance(uv, vec2(0.5))*0.005;\n    \/\/ AA pass?\n    if (effects2.y>0.)\n    {\n      color.rgb = vec3(AntiAliasing(uv + offSet).r, AntiAliasing(uv).g, AntiAliasing(uv - offSet).b);\n    } else\n    {\n      color.rgb = vec3(texture(iChannel2, uv + offSet).r, texture(iChannel2, uv).g, texture(iChannel2, uv - offSet).b);\n    }\n  }\n  \/\/ no chromatic aberration \n  else\n  {\n    \/\/ AA pass?\n    if (effects2.y>0.)\n    {\n      color.rgb=AntiAliasing(uv);\n    } else\n    {\n      color.rgb = texture(iChannel2, uv).rgb;\n    }\n  }\n\n  color.a=textureLod(iChannel2, uv, 0.).a;\n\n  \/\/ add sun with lens flare effect\n  color.rgb += CalculateSunFlare(rayDir, rayOrigin, screenSpace, clamp(color.a, 0., 1.0),effects2.x);\n\n  \/\/ add explosion light effects\n  minDist = max(minDist, DrawExplosion(0, color, rayDir, rayOrigin, screenSpace,effects2.x));\n  minDist = max(minDist, DrawExplosion(1, color, rayDir, rayOrigin, screenSpace,effects2.x));\n\n  float cloudDistance = distance(rayOrigin.y+planePos.y, -CLOUDLEVEL);\n\n  \/\/ grain noise\n  if (effects.y>0.)\n  {\n    vec2 grainTexPos = ((fragCoord.xy + iTime*60.0*vec2(10, 35.))*mix(0.6, 0.2, smoothstep(5.0, 0., cloudDistance)))\/iChannelResolution[0].xy;\n    vec2 filmNoise = textureLod( iChannel1, grainTexPos, 0. ).rb;\n    \/\/ scale up effect when flying through clouds\n    color.rgb *= mix( vec3(1), mix(vec3(1, .5, 0), vec3(0, .5, 1), filmNoise.x), mix(.04, 0.7, smoothstep(5.0, 0., cloudDistance))*filmNoise.y );\n  }\n\n  \/\/ flying though clouds\n  color = mix(color, clamp(color+max(0.4, fastFBM(rayOrigin+planePos)*2.), 0., 1.0), smoothstep(5.0, 0., cloudDistance));\n\n\n  \/\/ Lens dirt when looking into strong light source\n  if (effects.x>0.)\n  {\n    minDist=max(minDist, pow(max(0., dot(sunPos, rayDir)), 2.0));     \n    float dirtTex = textureLod( iChannel3, (fragCoord.xy \/ iResolution.x), 0.3 ).r*2.5;\n\n    color.rgb += 0.04*dirtTex*minDist;\n  }\n\n  fragColor =  vec4(pow(color.rgb, vec3(1.0\/1.1)), 1.0 ) * (0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.2 ));\n}\n",
            "name": "Image",
            "description": "",
            "type": "image"
        },
        {
            "inputs": [
                {
                    "id": "4sfGRn",
                    "filepath": "\/media\/a\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg",
                    "previewfilepath": "\/media\/ap\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg",
                    "type": "texture",
                    "channel": 3,
                    "sampler": {
                        "filter": "mipmap",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "XdXGzn",
                    "filepath": "\/media\/a\/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png",
                    "previewfilepath": "\/media\/ap\/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png",
                    "type": "texture",
                    "channel": 1,
                    "sampler": {
                        "filter": "mipmap",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "4dXGRr",
                    "filepath": "\/presets\/tex00.jpg",
                    "previewfilepath": "\/presets\/tex00.jpg",
                    "type": "keyboard",
                    "channel": 0,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 2,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dXGR8",
                    "channel": 0
                }
            ],
            "code": "\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ DATA BUFFER  -  PLANE MOVEMENT, KEYBOARD CHECKS AND MISSILE UPDATE (IF LAUNCHED)\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Channel 0 = Keyoard input. Used to capture key-presses.\n\/\/ Channel 1 = LowRes noise texture. Used in fast noise functions.\n\/\/ Channel 2 = This buffer (A). Read and write data to update movement in this shader.\n\/\/ Channel 3 = Lichen texture. Used to create landscape height map used in collision detection.\n\n  #define PI acos(-1.)\n  #define keyClick(ascii)   ( texelFetch(iChannel0, ivec2(ascii, 0), 0).x > 0.)\n  #define keyPress(ascii)   ( texelFetch(iChannel0, ivec2(ascii, 1), 0).x > 0.)\n  #define read(memPos) (  texelFetch(iChannel2, memPos, 0).a)\n  #define readRGB(memPos) (  texelFetch(iChannel2, memPos, 0).rgb)\n  #define MAX_HEIGHT 150. \n  #define MIN_HEIGHT 0. \n  #define STARTHEIGHT 40.\n  #pragma optimize(off) \n\/\/ SPACE   FIRE MISSILE\n#define MISSILE_KEY 32  \n\/\/ S    ROLL LEFT\n#define ROLL_LEFT_KEY 83  \n\/\/ F    ROLL RIGHT\n#define ROLL_RIGHT_KEY 70      \n\/\/ W    YAW LEFT   (PLANE STRIFE)\n#define LEFT_KEY 87    \n\/\/ R    YAW RIGHT   (PLANE STRIFE)\n#define RIGHT_KEY 82     \n\/\/ E    PITCH DOWN\n#define UP_KEY 69     \n\/\/ D    PITCH UP\n#define DOWN_KEY 68     \n\/\/ SHIFT  INC SPEED\n#define SPEED_INCREASE_KEY 16     \n\/\/ CTRL   DEC SPEED\n#define SPEED_DECREASE_KEY 17    \n\/\/ F1     ZOOM OUT\n#define ZOOMOUT_KEY 112\n\/\/ F2     ZOOM IN\n#define ZOOMIN_KEY 113\n\n\/\/ Alternative controls if uncommented  (lets you use arrow keys to control the plane)\n\/* \n\/\/ ENTER   FIRE MISSILE\n#define MISSILE_KEY 13\n\/\/ LEFT ARROW    ROLL LEFT\n#define ROLL_LEFT_KEY 37  \n\/\/ RIGHT ARROW    ROLL RIGHT\n#define ROLL_RIGHT_KEY 39     \n\/\/ DELETE   YAW LEFT   (PLANE STRIFE)\n#define LEFT_KEY 46    \n\/\/ PAGE DOWN    YAW RIGHT   (PLANE STRIFE)\n#define RIGHT_KEY 34     \n\/\/ UP ARROW    PITCH DOWN\n#define UP_KEY 38     \n\/\/ DOWN ARROW    PITCH UP\n#define DOWN_KEY 40     \n\/\/ SHIFT  INC SPEED\n#define SPEED_INCREASE_KEY 16     \n\/\/ CTRL   DEC SPEED\n#define SPEED_DECREASE_KEY 17    \n\/\/ F1     ZOOM OUT\n#define ZOOMOUT_KEY 112\n\/\/ F2     ZOOM IN\n#define ZOOMIN_KEY 113\n*\/\n\n\nvec3 sunPos=vec3(0.);\nvec3 planePos=vec3(0.);\nfloat explosionCount=0.;\n\n\nstruct Missile\n{ \n  vec3 pos;\n  float life;\n  vec3 orientation;   \/\/ roll,pitch,turn amount\n    vec3 startPos;\n};\n\nstruct Explosion\n{ \n  vec3 pos;\n  float life;\n};\n\n\n\nmat3 setCamera(  vec3 ro, vec3 ta, float cr )\n{\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n  vec3 cu = normalize( cross(cw, cp) );\n  vec3 cv = normalize( cross(cu, cw) );\n  return mat3( cu, cv, cw );\n}\n\nmat2 r2(float r) {\n  float c=cos(r), s=sin(r);\n  return mat2(c, s, -s, c);\n}\n\nvoid pR(inout vec2 p, float a) \n{\n  p*=r2(a);\n}\n\nfloat noise2D( in vec2 pos, float lod)\n{   \n  vec2 f = fract(pos);\n  f = f*f*(3.0-2.0*f);\n  vec2 rg = textureLod( iChannel1, (((floor(pos).xy+vec2(37.0, 17.0)) + f.xy)+ 0.5)\/64.0, lod).yx;  \n  return -1.0+2.0*mix( rg.x, rg.y, 0.5 );\n}\n\nfloat noise2D( in vec2 pos )\n{\n  return noise2D(pos, 0.0);\n}\n\n\/\/ 3D noise function (IQ)\nfloat fastFBM(vec3 p)\n{\n  vec3 ip=floor(p);\n  p-=ip; \n  vec3 s=vec3(7, 157, 113);\n  vec4 h=vec4(0., s.yz, s.y+s.z)+dot(ip, s);\n  p=p*p*(3.-2.*p); \n  h=mix(fract(sin(h)*43758.5), fract(sin(h+s.x)*43758.5), p.x);\n  h.xy=mix(h.xz, h.yw, p.y);\n  return mix(h.x, h.y, p.z);\n}\n\nfloat hash(float h) \n{\n  return fract(sin(h) * 43758.5453123);\n}\n\nfloat noise(vec3 x) \n{\n  vec3 p = floor(x);\n  vec3 f = fract(x);\n  f = f * f * (3.0 - 2.0 * f);\n\n  float n = p.x + p.y * 157.0 + 113.0 * p.z;\n  return -1.0+2.0*mix(\n    mix(mix(hash(n + 0.0), hash(n + 1.0), f.x), \n    mix(hash(n + 157.0), hash(n + 158.0), f.x), f.y), \n    mix(mix(hash(n + 113.0), hash(n + 114.0), f.x), \n    mix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\n\nfloat NoTreeZone(vec3 p)\n{\n    float dist = distance(readRGB(ivec2(140, 0)).xz,p.xz);\n    dist = min(dist,distance(readRGB(ivec2(142, 0)).xz,p.xz));\n    dist = min(dist,distance(readRGB(ivec2(144, 0)).xz,p.xz));\n    dist = min(dist,distance(readRGB(ivec2(146, 0)).xz,p.xz));\n    dist = min(dist,distance(readRGB(ivec2(148, 0)).xz,p.xz));\n    return dist;\n}\nfloat GetTerrainHeight( vec3 p)\n{\n  vec2 p2 = (p.xz+planePos.xz)*0.0005;\n\n  float heightDecrease = mix(1.0,0.,smoothstep(0.,15.0,NoTreeZone(p+planePos)));\n    \n  float mainHeight = -2.3+fastFBM((p+vec3(planePos.x, 0., planePos.z))*0.025)*max(11., abs(22.*noise2D(p2))); \n  mainHeight-=heightDecrease;\n    \n  float terrainHeight=mainHeight;\n  p2*=4.0;\n  terrainHeight += textureLod( iChannel3, p2, 2.7 ).x*1.; \n  p2*=2.0;\n  terrainHeight -= textureLod( iChannel3, p2, 1.2 ).x*.7;\n  p2*=3.0;\n  terrainHeight -= textureLod( iChannel3, p2, 0.5 ).x*.1;\n\n  terrainHeight=mix(terrainHeight, mainHeight*1.4, smoothstep(1.5, 3.5, terrainHeight)); \n\n  return   terrainHeight;\n}\n\nfloat GetTreeHeight( vec3 p, float terrainHeight)\n{\n  if(NoTreeZone(p+planePos)<25.) return 0.;\n  float treeHeight = textureLod(iChannel3, (p.xz+planePos.xz)*0.006, .1).x;\n  float tree = mix(0., mix(0., mix(0., 2.0, smoothstep(0.3, 0.86, treeHeight)), smoothstep(1.5, 3.5, terrainHeight)), step(0.3, treeHeight)); \n  tree -= tree*0.75;\n  tree*=4.0;\n\n  return  tree;\n}\n\nvec3 TranslatePos(vec3 p, float _direction, float _pitch, float _roll)\n{\n  pR(p.xz, _direction);\n  pR(p.zy, _pitch);\n\n  return p;\n}\n\nvoid LaunchMissile(inout Missile missile, vec3 startPos, vec3 orientation)\n{\n  missile.life=4.0; \n  missile.orientation = orientation;\n  missile.pos =  startPos;\n  missile.startPos= planePos;\n  missile.orientation.y *=cos(missile.orientation.x-PI);\n}\n\nvoid UpdateMissile(inout Missile missile, float id, inout vec4 fragColor, vec2 fragCoord, vec3 moveDiff)\n{\n  float adressStep = id*100.;\n     \n  Explosion explosion;\n \n  \/\/ read variables for explosion s\n  explosion.pos = readRGB(ivec2(120+int(adressStep), 0));    \n  explosion.life = read(ivec2(122+int(adressStep), 0));\n\n  \/\/ update active missile and save variables\n  if ( missile.life>0.)\n  {\n    missile.life-= 0.015;\n    vec3 velocityAdd = vec3(0., 0., 1.4);\n\n    pR(velocityAdd.yz, missile.orientation.y);\n    pR(velocityAdd.xz, -missile.orientation.z);\n\n    missile.pos += velocityAdd; \/\/ add velocity movement to pos\n    missile.pos.xz-=moveDiff.xz; \/\/ add plane movement to pos\n\n    \/\/ ground collision check                 \n    vec3 testPoint = missile.pos;\n      \n    testPoint+=vec3(4.8 - (9.6*id), -0.4, -3.0);\n    pR(testPoint.xz, missile.orientation.z);\n    testPoint-=vec3(4.8 - (9.6*id), -0.4, -3.0);\n    testPoint.y+=missile.startPos.y;\n      \n    float tHeight = GetTerrainHeight(testPoint);\n    tHeight+=GetTreeHeight(testPoint, tHeight);\n\n    \/\/ does missile hit terrain?\n    if (testPoint.y<tHeight)\n    {\n      \/\/ if colliding, kill missile and spawn explosion.             \n       explosion.pos =  missile.pos+missile.startPos;\n       explosion.pos.y = tHeight-3.0;\n       explosion.life=10.0;\n       missile.life=-10.;\n       explosionCount+=2.0;\n       explosionCount = mod(explosionCount,10.);\n    }\n\n    fragColor.a = mix(missile.life, fragColor.a, step(1., distance(fragCoord.xy, vec2(100.0+adressStep, 0.0))));\n    fragColor.rgb = mix(missile.startPos, fragColor.rgb, step(1., distance(fragCoord.xy, vec2(102.0+adressStep, 0.0))));\n    fragColor.rgb = mix(missile.orientation, fragColor.rgb, step(1., distance(fragCoord.xy, vec2(108.0+adressStep, 0.0)))); \n    fragColor.rgb = mix(missile.pos, fragColor.rgb, step(1., distance(fragCoord.xy, vec2(116.0+adressStep, 0.0))));\n            \n  }\n  \/\/ ##################################################################\n\n  \/\/ update explosion\n  if ( explosion.life>0.)\n  {   \n    explosion.life-= 0.115;\n   \/\/ explosion.life= 9.715;\n    fragColor.rgb = mix(explosion.pos, fragColor.rgb, step(1., distance(fragCoord.xy, vec2(120.0+adressStep, 0.0)))); \n    fragColor.a = mix(explosion.life, fragColor.a, step(1., distance(fragCoord.xy, vec2(122.0+adressStep, 0.0))));\n      \n    \/\/ terrain holes\n    fragColor.rgb = mix(mix(explosion.pos, fragColor.rgb, step(1., distance(fragCoord.xy, vec2(140.0+explosionCount, 0.0)))),fragColor.rgb,step(0.4,distance(5.0,explosion.life)));\n  }\n}\n\n\nvoid ToggleEffects(inout vec4 fragColor, vec2 fragCoord)\n{\n   \/\/ read and save effect values from buffer  \n   vec3 effects =  mix(vec3(-1.0,1.0,1.0), readRGB(ivec2(20, 0)), step(1.0, float(iFrame)));\n   effects.x*=1.0+(-2.*float(keyPress(49))); \/\/1-key  LENSDIRT\n   effects.y*=1.0+(-2.*float(keyPress(50))); \/\/2-key  GRAINFILTER\n   effects.z*=1.0+(-2.*float(keyPress(51))); \/\/3-key  ChromaticAberration\n   \n   vec3 effects2 =  mix(vec3(1.0,1.0,1.0), readRGB(ivec2(22, 0)), step(1.0, float(iFrame)));\n   effects2.y*=1.0+(-2.*float(keyPress(52))); \/\/4-key  AA-pass\n   effects2.x*=1.0+(-2.*float(keyPress(53))); \/\/5-key  lens flare\n\n   fragColor.rgb = mix(effects, fragColor.rgb, step(1., distance(fragCoord.xy, vec2(20.0, 0.0))));  \n   fragColor.rgb = mix(effects2, fragColor.rgb, step(1., distance(fragCoord.xy, vec2(22.0, 0.0))));  \n}\n\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{  \n  vec2 mo = iMouse.xy\/iResolution.xy;\n  vec2 uv = fragCoord.xy \/ iResolution.xy;\n  vec2 screenSpace = (-iResolution.xy + 2.0*(fragCoord))\/iResolution.y;\n\n  \/\/ read plane values from buffer\n  float turn = mix(1.0, read(ivec2(1, 10)), step(1.0, float(iFrame)));\n  float roll = mix(3.14, read(ivec2(1, 1)), step(1.0, float(iFrame)));\n  float rudderAngle = read(ivec2(6, 1));\n  float speed = read(ivec2(10, 1));\n  float pitch = read(ivec2(15, 1));\n  explosionCount = read(ivec2(3, 0));  \n    \n  sunPos = mix(normalize( vec3(-1.0, 0.3, -.50) ), readRGB(ivec2(50, 0)), step(1.0, float(iFrame)));\n  planePos = mix(vec3(-400, STARTHEIGHT, -100), readRGB(ivec2(55, 0)), step(1.0, float(iFrame)));\n  float CAMZOOM = mix(13.9, read(ivec2(52, 0)), step(1.0, float(iFrame)));  \n  vec2 camRot = vec2(-1., 0.340);\n\n  \/\/ setup camera and ray direction\n  camRot.x+=mo.x*16.; \n  camRot.y+=mo.y*16.; \n \n  \/\/ limit roll\n  roll=mod(roll, 6.28);\n \n    \/\/ add turn angle based on roll  \n  float turnAmount = mix(0., 1.57, smoothstep(0., 1.57, 1.57-distance(1.57, roll-3.14)));\n  turnAmount += mix(0., -1.57, smoothstep(0., 1.57, 1.57-distance(-1.57, roll-3.14)));\n  float PitchAdd = sin(pitch);\n \n  \/\/ YAW\n  turn+=0.02*rudderAngle;\n  \/\/ add turn angle  \n  turn+=turnAmount*0.015;\n  turn-=0.1*(((pitch*0.25)*cos(roll-1.57)));\n  \n    turn= mod(turn,PI*2.);\n  vec3 oldPlanePos = vec3(planePos.x, planePos.y, planePos.z);\n\n  \/\/ move plane\n  planePos.xz += vec2(cos(turn+1.5707963)*0.5,  sin(turn+1.5707963)*0.5)*(0.7+speed)*cos(pitch);\n  planePos.y = clamp(planePos.y+((PitchAdd*0.25)*cos(roll-PI)), MIN_HEIGHT, MAX_HEIGHT);\n\n  rudderAngle*=0.97;\n  \/\/ check key inputs\n  rudderAngle-=0.03*float(keyClick(LEFT_KEY));\n  rudderAngle+=0.03*float(keyClick(RIGHT_KEY));\n  rudderAngle=clamp(rudderAngle, -0.4, 0.4);;\n  roll-=0.055*float(keyClick(ROLL_LEFT_KEY));\n  roll+=0.055*float(keyClick(ROLL_RIGHT_KEY));\n\n  speed+=(0.02*float(keyClick(SPEED_INCREASE_KEY)));\n  speed-=(0.02*float(keyClick(SPEED_DECREASE_KEY)));\n  speed=clamp(speed, -0.3, 1.);\n   \n  \/\/ prevent plane from getting into terrain\n  float tHeight = GetTerrainHeight(planePos);\n  tHeight+=GetTreeHeight(planePos, tHeight);\n  float minHeight = tHeight+12.;\n  planePos.y = max(planePos.y,minHeight);\n    \n   \/\/ pitch = sin(pitch);\n  pitch-=(mix(0.02, 0., smoothstep(0., 3., 3.0-abs(distance(planePos.y, minHeight))))*float(keyClick(UP_KEY))); \/\/e-key\n  pitch+=(mix(0.02, 0., smoothstep(0., 3., 3.0-abs(distance(planePos.y, MAX_HEIGHT))))*float(keyClick(DOWN_KEY))); \/\/d-key\n  pitch = clamp(pitch, -1.25, 1.25);\n  pitch*=0.97;\n\n  turnAmount += mix(0., -1.57, smoothstep(0., 1.57, 1.57-distance(-1.57, roll-3.14)));\n  fragColor = vec4(textureLod(iChannel2, uv,0.).rgb,0.);\n    \n  \/\/ ------------------------- MISSILES ------------------------------\n  \/\/ NOTE: MISSILES ARE RENDERED IN BUFFER B TOGETHER WITH THE TERRAIN     \n  int adressStep = 0;\n  bool launchLocked=false;\n  Missile missile;\n  for (int i=0; i<2; i++)\n  {\n    adressStep = i*100;\n      \n    \/\/ read variables for missiles\n    missile.life = read(ivec2(100 + adressStep, 0));\n    missile.startPos = readRGB(ivec2(102 + adressStep, 0));  \n    missile.orientation = readRGB(ivec2(108 + adressStep, 0));\n    missile.pos = readRGB(ivec2(116 + adressStep, 0));\n\n  \/\/ if missile is \"dead\" check if a new missile is being lanched by pressing the M-key\n  if (keyPress(MISSILE_KEY) && !launchLocked)\n  {    \n   if (missile.life<=0.)\n   {\n      LaunchMissile(missile, vec3(4.8- (9.6*float(i)), -0.4, -3.0), vec3(roll, pitch, turn));  \n      launchLocked=true;\n   } \n }    \n\n  UpdateMissile(missile, float(i), fragColor, fragCoord, (planePos-oldPlanePos));\n  \/\/ ##################################################################\n  }\n\n  ToggleEffects(fragColor, fragCoord);\n   \n  CAMZOOM-=0.3*float(keyClick(ZOOMIN_KEY));\n  CAMZOOM+=0.3*float(keyClick(ZOOMOUT_KEY));\n  CAMZOOM=clamp(CAMZOOM, 10., 30.);;\n  \n  \/\/ save roll,speed and scroll values etc to buffer A \n  fragColor.a = mix(turn, fragColor.a, step(1., distance(fragCoord.xy, vec2(1.0, 10.0)))); \n  fragColor.a = mix(speed, fragColor.a, step(1., distance(fragCoord.xy, vec2(10.0, 1.0)))); \n  fragColor.a = mix(roll, fragColor.a, step(1., distance(fragCoord.xy, vec2(1.0, 1.0)))); \n  fragColor.a = mix(pitch, fragColor.a, step(1., distance(fragCoord.xy, vec2(15.0, 1.0)))); \n  fragColor.a = mix(rudderAngle, fragColor.a, step(1., distance(fragCoord.xy, vec2(6.0, 1.0))));\n  fragColor.a = mix(explosionCount, fragColor.a, step(1., distance(fragCoord.xy, vec2(3.0, 0.0)))); \n  fragColor.rgb = mix(sunPos, fragColor.rgb, step(1., distance(fragCoord.xy, vec2(50.0, 0.0))));\n  fragColor.a = mix(CAMZOOM, fragColor.a, step(1., distance(fragCoord.xy, vec2(52.0, 0.0))));\n  fragColor.rgb = mix(planePos, fragColor.rgb, step(1., distance(fragCoord.xy, vec2(55.0, 0.0))));\n  fragColor.rgb = mix(vec3(camRot.xy, 0.), fragColor.rgb, step(1., distance(fragCoord.xy, vec2(57.0, 0.0))));\n}\n",
            "name": "Buf A",
            "description": "",
            "type": "buffer"
        },
        {
            "inputs": [
                {
                    "id": "4sfGRn",
                    "filepath": "\/media\/a\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg",
                    "previewfilepath": "\/media\/ap\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg",
                    "type": "texture",
                    "channel": 3,
                    "sampler": {
                        "filter": "mipmap",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "XdXGzn",
                    "filepath": "\/media\/a\/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png",
                    "previewfilepath": "\/media\/ap\/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png",
                    "type": "texture",
                    "channel": 1,
                    "sampler": {
                        "filter": "mipmap",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "Xsf3zn",
                    "filepath": "\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
                    "previewfilepath": "\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
                    "type": "texture",
                    "channel": 0,
                    "sampler": {
                        "filter": "mipmap",
                        "wrap": "repeat",
                        "vflip": "false",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 2,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "XsXGR8",
                    "channel": 0
                }
            ],
            "code": "\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ TERRAIN BUFFER  -   RENDERS TERRAIN AND LAUNCHED MISSILES + EXPLOSIONS \n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Channel 0 = Fine noise texture. Used in noise functions.\n\/\/ Channel 1 = LowRes noise texture. Used in fast noise functions.\n\/\/ Channel 2 = Buffer A. Read data from data-buffer.\n\/\/ Channel 3 = Lichen texture. Used to create landscape height map and textures.\n\n  #define read(memPos) (  texelFetch(iChannel2, memPos, 0).a)\n  #define readRGB(memPos) (  texelFetch(iChannel2, memPos, 0).rgb)\n  #define MAX_HEIGHT 150. \n  #define WATER_LOD 0.4\n  #define CLOUDLEVEL -70.0\n  #define PI acos(-1.)\n  #pragma optimize(off) \n  \/\/ remove on or several of below defines, if FPS is too low\n  #define SHADOWS\n  #define QUALITY_TREE\n  #define QUALITY_REFLECTIONS\n  #define EXACT_EXPLOSIONS\n  \/\/ ---------------------------------------------------------\n\nfloat turn=0.;\nvec2 cloudPos=vec2(0.);\nfloat eFlameDist=10000.0;\nvec3 checkPos=vec3(0.);\nvec3 sunPos=vec3(0.);\nconst vec3 sunColor = vec3(1.00, 0.90, 0.85);\n\nconst vec3 eps = vec3(0.02, 0.0, 0.0);\nvec3 planePos=vec3(0.);\n\nstruct RayHit\n{\n  bool hit;  \n  vec3 hitPos;\n  vec3 normal;\n  float dist;\n  float depth;\n  float eFlameDist;\n};\n\nstruct Missile\n{ \n  vec3 pos;\n  float life;\n  vec3 orientation;   \/\/ roll,pitch,turn amount\n  vec3 origin;\n};\n    \nstruct Explosion\n{ \n  vec3 pos;\n  float life;\n};\n\nmat2 r2(float r) {\n  float c=cos(r), s=sin(r);\n  return mat2(c, s, -s, c);\n}\n\n#define r3(r) mat2(sin(vec4(-1, 0, 0, 1)*acos(0.)+r))\n\nvoid pR(inout vec2 p, float a)\n{\n  p*=r2(a);\n}\n\nfloat sgn(float x)\n{   \n  return (x<0.)?-1.:1.;\n}\n\nfloat hash(float h) \n{\n  return fract(sin(h) * 43758.5453123);\n}\n\nfloat noise(vec3 x) \n{\n  vec3 p = floor(x);\n  vec3 f = fract(x);\n  f = f * f * (3.0 - 2.0 * f);\n\n  float n = p.x + p.y * 157.0 + 113.0 * p.z;\n  return -1.0+2.0*mix(\n    mix(mix(hash(n + 0.0), hash(n + 1.0), f.x), \n    mix(hash(n + 157.0), hash(n + 158.0), f.x), f.y), \n    mix(mix(hash(n + 113.0), hash(n + 114.0), f.x), \n    mix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\n\nfloat fbm(vec3 p) \n{\n  float f = 0.5000 * noise(p);\n  p *= 2.01;\n  f += 0.2500 * noise(p);\n  p *= 2.02;\n  f += 0.1250 * noise(p);\n  return f;\n}\n\nfloat noise2D( in vec2 pos, float lod)\n{   \n  vec2 f = fract(pos);\n  f = f*f*(3.0-2.0*f);\n  vec2 rg = textureLod( iChannel1, (((floor(pos).xy+vec2(37.0, 17.0)) + f.xy)+ 0.5)\/64.0, lod).yx;  \n  return -1.0+2.0*mix( rg.x, rg.y, 0.5 );\n}\nfloat noise2D( in vec2 pos )\n{\n  return noise2D(pos, 0.0);\n}\n\n\/\/ 3D noise function (IQ)\nfloat fastFBM(vec3 p)\n{\n  vec3 ip=floor(p);\n  p-=ip; \n  vec3 s=vec3(7, 157, 113);\n  vec4 h=vec4(0., s.yz, s.y+s.z)+dot(ip, s);\n  p=p*p*(3.-2.*p); \n  h=mix(fract(sin(h)*43758.5), fract(sin(h+s.x)*43758.5), p.x);\n  h.xy=mix(h.xz, h.yw, p.y);\n  return mix(h.x, h.y, p.z);\n}\nfloat fastFBMneg(vec3 p)\n{\n  return -1.0+2.0*fastFBM(p);\n}\nvec2 pModPolar(vec2 p, float repetitions) {\n  float angle = 2.*PI\/repetitions;\n  float a = atan(p.y, p.x) + angle\/2.;\n  float r = length(p);\n  float c = floor(a\/angle);\n  a = mod(a, angle) - angle\/2.;\n  p = vec2(cos(a), sin(a))*r;\n  if (abs(c) >= (repetitions\/2.)) c = abs(c);\n  return p;\n}\n\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)\/size);\n  p = mod(p+halfsize, size) - halfsize;\n  if (c > stop) {\n    p += size*(c - stop);\n    c = stop;\n  }\n  if (c <start) {\n    p += size*(c - start);\n    c = start;\n  }\n  return c;\n}\nfloat pMirror (inout float p, float dist) {\n  float s = sgn(p);\n  p = abs(p)-dist;\n  return s;\n}\n\nfloat fCylinder(vec3 p, float r, float height) {\n  float d = length(p.xy) - r;\n  d = max(d, abs(p.z) - height);\n  return d;\n}\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  return (length( p\/r.xyz ) - 1.0) * r.y;\n}\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.y-h.y, max((q.z*0.866025+q.x*0.5), q.x)-h.x);\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\nfloat fSphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat GetExplosionIntensity(Explosion ex)\n{\n  return mix(1., .0, smoothstep(0., 5.0, distance(ex.life, 5.)));\n}\n\nfloat NoTreeZone(vec3 p)\n{\n  float dist = distance(readRGB(ivec2(140, 0)).xz, p.xz);\n  dist = min(dist, distance(readRGB(ivec2(142, 0)).xz, p.xz));\n  dist = min(dist, distance(readRGB(ivec2(144, 0)).xz, p.xz));\n  dist = min(dist, distance(readRGB(ivec2(146, 0)).xz, p.xz));\n  dist = min(dist, distance(readRGB(ivec2(148, 0)).xz, p.xz));\n  return dist;\n}\nfloat GetTerrainHeight( vec3 p)\n{\n  vec2 p2 = (p.xz+planePos.xz)*0.0005;\n\n  float heightDecrease = mix(1.0, 0., smoothstep(0., 15.0, NoTreeZone(p+planePos)));\n\n  float mainHeight = -2.3+fastFBM((p+vec3(planePos.x, 0., planePos.z))*0.025)*max(11., abs(22.*noise2D(p2))); \n  mainHeight-=heightDecrease;\n\n  float terrainHeight=mainHeight;\n  p2*=4.0;\n  terrainHeight += textureLod( iChannel3, p2, 2.7 ).x*1.; \n  p2*=2.0;\n  terrainHeight -= textureLod( iChannel3, p2, 1.2 ).x*.7;\n  p2*=3.0;\n  terrainHeight -= textureLod( iChannel3, p2, 0.5 ).x*.1;\n\n  terrainHeight=mix(terrainHeight, mainHeight*1.4, smoothstep(1.5, 3.5, terrainHeight)); \n\n  return   terrainHeight;\n}\n\nfloat GetTreeHeight( vec3 p, float terrainHeight)\n{\n  if (NoTreeZone(p+planePos)<25.) return 0.;\n  float treeHeight = textureLod(iChannel3, (p.xz+planePos.xz)*0.006, .1).x;\n  float tree = mix(0., mix(0., mix(0., 2.0, smoothstep(0.3, 0.86, treeHeight)), smoothstep(1.5, 3.5, terrainHeight)), step(0.3, treeHeight)); \n  tree -= tree*0.75;\n  tree*=4.0;\n\n  return  tree;\n}\n\nfloat MapTerrainSimple( vec3 p)\n{\n  float terrainHeight = GetTerrainHeight(p);   \n  return  p.y - max((terrainHeight+GetTreeHeight(p, terrainHeight)), 0.);\n}\n\nfloat GetStoneHeight(vec3 p, float terrainHeight)\n{\n  return (textureLod(iChannel1, (p.xz+planePos.xz)*0.05, 0.).x*max(0., -0.3+(1.25*terrainHeight)));\n}\n\nfloat MapTerrain( vec3 p)\n{   \n  float terrainHeight = GetTerrainHeight(p);   \n  terrainHeight= mix(terrainHeight+GetStoneHeight(p, terrainHeight), terrainHeight, smoothstep(0., 1.5, terrainHeight));\n  terrainHeight= mix(terrainHeight+(textureLod(iChannel1, (p.xz+planePos.xz)*0.0015, 0.).x*max(0., -0.3+(.5*terrainHeight))), terrainHeight, smoothstep(1.2, 12.5, terrainHeight));\n\n  terrainHeight= mix(terrainHeight-0.30, terrainHeight, smoothstep(-0.5, 0.25, terrainHeight));\n  float water=0.;\n  if (terrainHeight<=0.)\n  {   \n    water = (-0.5+(0.5*(noise2D((p.xz+planePos.xz+ vec2(-iTime*0.4, iTime*0.25))*2.60, WATER_LOD))));\n    water*=(-0.5+(0.5*(noise2D((p.xz+planePos.xz+ vec2(iTime*.3, -iTime*0.25))*2.90), WATER_LOD)));\n  }\n  return   p.y -  max((terrainHeight+GetTreeHeight(p, terrainHeight)), -water*0.04);\n}\n\n\nfloat MapTree( vec3 p)\n{  \n  float terrainHeight = GetTerrainHeight(p);\n  float treeHeight =GetTreeHeight(p, terrainHeight);\n\n  \/\/ get terrain height at position and tree height onto that\n  return  p.y - terrainHeight-treeHeight;\n}\n\nvec3 calcTreeNormal( in vec3 pos )\n{    \n  return normalize( vec3(MapTree(pos+eps.xyy) - MapTree(pos-eps.xyy), 0.5*2.0*eps.x, MapTree(pos+eps.yyx) - MapTree(pos-eps.yyx) ) );\n}\n\nvec4 TraceTrees( vec3 origin, vec3 direction, int steps, float terrainHeight)\n{\n  vec4 treeCol =vec4(0.5, 0.5, 0.5, 0.0);\n  float intensity=0.0, t = .0, dist = 0.0;\n  vec3 rayPos, nn;\n  float precis=.0, dif =0.0, densAdd =.0;\n  float treeHeight = 0.0;\n  float td =.0;\n  for ( int i=0; i<steps; i++ )\n  {\n    rayPos = origin+direction*t;\n    treeHeight = GetTreeHeight(rayPos, terrainHeight);\n    dist = rayPos.y - (terrainHeight + treeHeight);  \n    precis = 0.015*t;\n\n    if (treeHeight>0.1 && dist<precis)\n    {\n      nn= calcTreeNormal(rayPos);  \n      dif = clamp( dot( nn, sunPos ), 0.0, 1.0 );\n\n      densAdd = (precis-dist)*3.0*td;\n      treeCol.rgb+=(0.5*td)*dif;\n      treeCol.a+=(1.-treeCol.a)*densAdd;\n    } \n    if (treeCol.a > 0.99) \n    {\n      break;\n    }\n    td = max(0.04, dist*0.5);\n    t+=td;\n  }\n\n  return clamp(treeCol, 0., 1.);\n}\n\n\nRayHit TraceTerrainReflection( vec3 origin, vec3 direction, int steps)\n{\n  RayHit result;\n  float precis = 0.0, maxDist = 100.0, t = 0.0, dist = 0.0;\n  vec3 rayPos;\n\n  for ( int i=0; i<steps; i++ )\n  {\n    rayPos =origin+direction*t; \n    dist = MapTerrainSimple( rayPos);\n    precis = 0.01*t;\n\n    if (dist<precis || t>maxDist )\n    {             \n      result.hit=!(t>maxDist);\n      result.depth = t; \n      result.dist = dist;                              \n      result.hitPos = origin+((direction*t));     \n      break;\n    }\n\n    t += dist*0.5;\n  }\n\n  return result;\n}\n\nRayHit TraceTerrain( vec3 origin, vec3 direction, int steps)\n{\n  RayHit result;\n  float precis = 0.0, maxDist = 400.0, t = 0.0, dist = 0.0;\n  vec3 rayPos;\n\n  for ( int i=0; i<steps; i++ )\n  {\n    rayPos =origin+direction*t; \n    dist = MapTerrain( rayPos);\n    precis = 0.001*t;\n\n    if (dist<precis || t>maxDist )\n    {             \n      result.hit=!(t>maxDist);\n      result.depth = t; \n      result.dist = dist;                              \n      result.hitPos = origin+((direction*t));     \n      break;\n    }\n\n    t += dist*0.5;\n  }\n\n  return result;\n}\n\nfloat SoftShadow( in vec3 origin, in vec3 direction )\n{\n  float res = 2.0, t = 0.0, h;\n  for ( int i=0; i<16; i++ )\n  {\n    h = MapTerrain(origin+direction*t);\n    res = min( res, 3.5*h\/t );\n    t += clamp( h, 0.02, 0.8);\n    if ( h<0.002 ) break;\n  }\n  return clamp( res, 0.0, 1.0 );\n}\n\n\nvec3 calcNormal( in vec3 pos )\n{    \n  return normalize( vec3(MapTerrain(pos+eps.xyy) - MapTerrain(pos-eps.xyy), 0.5*2.0*eps.x, MapTerrain(pos+eps.yyx) - MapTerrain(pos-eps.yyx) ) );\n}\n\nfloat GetCloudHeight(vec3 p)\n{    \n  vec3 p2 = (p+vec3(planePos.x, 0., planePos.z)+vec3(cloudPos.x, 0., cloudPos.y))*0.03;\n\n  float i  = (-0.3+noise(p2))*4.4; \n  p2*=2.52;\n  i +=abs(noise( p2 ))*1.7; \n  p2*=2.53;\n  i += noise( p2 )*1.; \n  p2*=2.51;\n  i += noise(p2 )*0.5;\n  p2*=4.22;\n  i += noise( p2)*0.2;\n  return i*3.;\n}\n\nfloat GetCloudHeightBelow(vec3 p)\n{    \n  vec3 p2 = (p+vec3(planePos.x, 0., planePos.z)+vec3(cloudPos.x, 0., cloudPos.y))*0.03;\n\n  float i  = (-0.3+noise(p2))*4.4; \n  p2*=2.52;\n  i +=noise( p2 )*1.7; \n  p2*=2.53;\n  i += noise( p2 )*1.; \n  p2*=2.51;\n  i += noise(p2 )*0.5;\n  p2*=3.42;\n  i += noise( p2)*0.2;\n  i*=0.5;\n  i-=0.25*i; \n\n  return i*5.;\n}\n\nfloat GetHorizon( vec3 p)\n{\n  return sdEllipsoid(p, vec3(1000., -CLOUDLEVEL, 1000.));\n}\n\nfloat MapCloud( vec3 p)\n{\n  return GetHorizon(p) - max(-3., (1.3*GetCloudHeight(p)));\n}\n\nvec4 TraceClouds( vec3 origin, vec3 direction, vec3 skyColor, int steps)\n{\n  vec4 cloudCol=vec4(skyColor*vec3(0.65, 0.69, 0.72)*1.3, 0.0);\n  cloudCol.rgb=mix(cloudCol.rgb, sunColor, 0.32);\n\n  float density = 0.0, t = .0, dist = 0.0;\n  vec3 rayPos;\n  float precis; \n  float td =.0;\n  float densAdd;\n  float sunDensity;\n  for ( int i=0; i<steps; i++ )\n  {\n    rayPos = origin+direction*t;\n    density = max(-5., 1.7+(GetCloudHeight(rayPos)*1.3));\n    dist = GetHorizon(rayPos)-(density);\n\n    precis = 0.01*t;\n    if (dist<precis && density>-5.1)\n    {    \n      sunDensity = MapCloud(rayPos+sunPos*3.);\n      densAdd =  mix(0., 0.5*(1.0-cloudCol.a), smoothstep(-5.1, 4.3, density));\n      cloudCol.rgb-=clamp((density-sunDensity), 0., 1.0)*0.06*sunColor*densAdd;\n      cloudCol.rgb += 0.003*max(0., sunDensity)*density*densAdd;\n      \n\n      cloudCol.a+=(1.-cloudCol.a)*densAdd;\n    } \n\n    if (cloudCol.a > 0.99) break; \n\n    td = max(0.12, dist*0.45);\n    t+=td;\n  }\n\n  \/\/ mix clouds color with sky color\n  float mixValue = smoothstep(100., 620., t);\n  cloudCol.rgb = mix(cloudCol.rgb, skyColor, mixValue);\n\n  return cloudCol;\n}\n\nvec4 TraceCloudsBelow( vec3 origin, vec3 direction, vec3 skyColor, int steps)\n{\n  vec4 cloudCol=vec4(vec3(0.95, 0.95, 0.98)*0.7, 0.0);\n  cloudCol.rgb=mix(cloudCol.rgb, sunColor, 0.2);\n\n  float density = 0.0, t = .0, dist = 0.0;\n  vec3 rayPos;\n  float precis; \n  float td =.0;\n  float energy=1.0;\n  float densAdd=0.;\n  float sunDensity;\n\n  for ( int i=0; i<steps; i++ )\n  {\n    rayPos = origin+direction*t;\n    density = clamp(GetCloudHeightBelow(rayPos), 0., 1.)*2.;          \n    dist = -GetHorizon(rayPos);\n\n    precis = 0.015*t;\n    if (dist<precis && density>0.001)\n    {    \n      densAdd = 0.14*density\/td;\n      sunDensity = clamp(GetCloudHeightBelow(rayPos+sunPos*3.), -0.6, 2.)*2.; \n      cloudCol.rgb-=sunDensity*0.02*cloudCol.a*densAdd; \n      cloudCol.a+=(1.-cloudCol.a)*densAdd;\n\n      cloudCol.rgb += 0.03*max(0., density-sunDensity)*densAdd;\n\n      cloudCol.rgb+=mix(vec3(0.), vec3(1.0, 1.0, 0.9)*0.013, energy)*sunColor;\n      energy*=0.96;\n    } \n\n    if (cloudCol.a > 0.99) break; \n\n    td = max(1.4, dist);\n    t+=td;\n  }\n    \n  \/\/ mix clouds color with sky color\n  cloudCol.rgb = mix(cloudCol.rgb, vec3(0.97), smoothstep(100., 960., t)); \n  cloudCol.a = mix(cloudCol.a, 0., smoothstep(0., 960., t));\n\n  return cloudCol;\n}\n\nfloat getTrailDensity( vec3 p)\n{\n  return noise(p*3.)*1.;\n}\n\nvoid TranslateMissilePos(inout vec3 p, Missile missile)\n{  \n  p = p-(missile.pos);  \n  p+=missile.origin;\n  pR(p.xz, missile.orientation.z);\n  pR(p.xy, -missile.orientation.x +PI);\n  p-=missile.origin;\n}\n\nvec2 MapSmokeTrail( vec3 p, Missile missile)\n{\n  TranslateMissilePos(p, missile);\n  float spreadDistance = 1.5;\n  p.z+=3.82;\n\n  \/\/ map trail by using mod op and ellipsoids\n  float s = pModInterval1(p.z, -spreadDistance, .0, min(12., (missile.pos.z-planePos.z)\/spreadDistance));     \n  float dist = sdEllipsoid(p+vec3(0.0, 0.0, .4), vec3(0.6, 0.6, 3.));   \n  dist-= getTrailDensity(p+vec3(10.*s))*0.25;\n\n  return vec2(dist, s);\n}\n\n\nvec4 TraceSmoketrail( vec3 origin, vec3 direction, int steps, Missile missile)\n{\n  vec4 trailCol =vec4(0.5, 0.5, 0.5, 0.0);\n  float height = 0.0, t = .0;\n  vec2 dist = vec2(0.0);\n  vec3 rayPos;\n  float precis; \n  float td =.0;\n  for ( int i=0; i<steps; i++ )\n  {\n    rayPos = origin+direction*t;\n    dist = MapSmokeTrail(rayPos, missile);  \n    precis = 0.002*t;\n    if (dist.x<precis)\n    {     \n      trailCol.rgb+=(0.5*(getTrailDensity(rayPos+sunPos*.17)))*0.03;\n\n      float densAdd =(precis-dist.x)*0.20;\n      trailCol.a+=(1.-trailCol.a)*densAdd\/(1.+(pow(dist.y, 2.0)*0.021));\n    } \n\n    if (trailCol.a > 0.99) break; \n\n    td = max(0.04, dist.x);\n    t+=td;\n  }\n\n  return clamp(trailCol, 0., 1.);\n}\n\n\nfloat MapExplosion( vec3 p, Explosion ex)\n{ \n  checkPos = (ex.pos)-vec3(planePos.x, 0., planePos.z); \n  checkPos=p-checkPos;\n\n  float testDist = fSphere(checkPos, 20.0);\n  if (testDist>10.)  return testDist;\n\n  float intensity =GetExplosionIntensity(ex);\n  float d= fSphere(checkPos, intensity*15.);  \n\n  \/\/ terrain clipping\n  #ifdef EXACT_EXPLOSIONS\n    d=max(d, -MapTerrain(p));\n  #else\n    d = max(d, -sdBox(checkPos+vec3(0., 50., 0.), vec3(50., 50.0, 50.0)));\n  #endif\n\n  \/\/ add explosion \"noise\/flames\"\n  float displace = fbm(((checkPos) + vec3(1, -2, -1)*iTime)*0.5);\n  return d + (displace * 1.5*max(0., 4.*intensity));\n}\n\n\nRayHit TraceExplosion(in vec3 origin, in vec3 direction, int steps, Explosion ex)\n{\n  RayHit result;\n  float precis = 0.0, maxDist = 350.0, t = 0.0, dist = 0.0;\n  vec3 rayPos;\n\n  for ( int i=0; i<steps; i++ )\n  {\n    rayPos =origin+direction*t; \n    dist = MapExplosion( rayPos, ex);\n    precis = 0.01*t;\n\n    if (dist<precis || t>maxDist )\n    {             \n      result.hit=!(t>maxDist);\n      result.depth = t; \n      result.dist = dist;                              \n      result.hitPos = origin+((direction*t));     \n      break;\n    }\n\n    t += dist*0.5;\n  }\n\n  return result;\n}\n\n\/\/ inspired by https:\/\/www.shadertoy.com\/view\/XdfGz8\nvec3 GetExplosionColor(float x)\n{\n  vec3 col1= vec3(240., 211., 167.)\/255.;\n  vec3 col2 = vec3(210., 90., 60.)\/255.;\n  vec3 col3 = vec3(84., 20., 13.)\/255.;\n\n  float t = fract(x*3.);\n  vec3 c= mix(col2, col3, t);\n  c= mix(mix(col1, col2, t), c, step(0.666, x));\n  return mix(mix(vec3(4, 4, 4), col1, t), c, step(0.333, x));\n}\n\nvec3 GetExplosionLight(float specLevel, vec3 normal, RayHit rayHit, vec3 rayDir, vec3 origin)\n{                \n  vec3 reflectDir = reflect( rayDir, normal );\n\n  vec3 lightTot = vec3(0.0);\n  float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );\n  float dif = clamp( dot( normal, sunPos ), 0.0, 1.0 );\n  float bac = clamp( dot( normal, normalize(vec3(-sunPos.x, 0.0, -sunPos.z)) ), 0.0, 1.0 ) * clamp(1.0-rayHit.hitPos.y\/20.0, 0.0, 1.0);\n\n  float fre = pow( clamp(1.0+dot(normal, rayDir), 0.0, 1.0), 2.0 );\n  specLevel*= pow(clamp( dot( reflectDir, sunPos ), 0.0, 1.0 ), 7.0);\n  float skylight = smoothstep( -0.1, 0.1, reflectDir.y );\n\n  lightTot += 1.5*dif*vec3(1.00, 0.90, 0.85);\n  lightTot += 0.50*skylight*vec3(0.40, 0.60, 0.95);\n  lightTot += 1.00*specLevel*vec3(0.9, 0.8, 0.7)*dif;\n  lightTot += 0.50*bac*vec3(0.25, 0.25, 0.25);\n  lightTot += 0.25*fre*vec3(1.00, 1.00, 1.00);\n\n  return clamp(lightTot, 0., 10.);\n}\n\n\nvoid DrawExplosion(int id, RayHit marchResult, inout vec3 color, vec3 rayDir, vec3 rayOrigin)\n{\n  Explosion explosion;\n  id *= 100;\n  explosion.life = read(ivec2(122+id, 0));\n\n  \/\/ check if explosion has been spawned\n  if (explosion.life>0.)\n  {  \n    explosion.pos = readRGB(ivec2(120+id, 0)); \n\n    vec3 testPoint = explosion.pos-planePos;\n    \/\/ ensure the explosions starts on ground\n    \/\/ explosion.pos.y=GetTerrainHeight(testPoint);\n\n    \/\/ explosion light flash    \n    if (marchResult.hit)\n    {\n      float intensity = GetExplosionIntensity(explosion);\n\n      vec3 testCol = color.rgb+vec3(1.0, 0.59, 0.28)*2.5;\n      color.rgb=mix(color.rgb, mix(testCol, color.rgb, smoothstep(0., 40.0*intensity, distance(testPoint.xz, marchResult.hitPos.xz))), intensity);\n    }\n\n    \/\/ trace explosion  \n    RayHit exploTest = TraceExplosion(rayOrigin, rayDir, 68, explosion);   \n    if (exploTest.hit)\n    {\n      color.rgb = GetExplosionColor(clamp(0.5+((fbm((exploTest.hitPos + vec3(1, -2, -1)*iTime)*0.5))), 0.0, 0.99));\n      color.rgb = mix(color.rgb, color.rgb*0.45, smoothstep(0., 12., distance(exploTest.hitPos.y, GetTerrainHeight(testPoint))));\n    }\n\n    color.rgb = mix(color.rgb*3.0, color.rgb, smoothstep(0., 12.4, exploTest.dist));\n  }\n  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n}\n\nfloat MapFlare( vec3 p, Missile missile)\n{\n  TranslateMissilePos(p, missile);\n  return sdEllipsoid( p+ vec3(0., 0., 2.4), vec3(.05, 0.05, .15));\n}\n\nfloat TraceEngineFlare(in vec3 origin, in vec3 direction, Missile missile)\n{\n  float t = 0.0;\n  vec3 rayPos = vec3(0.0);\n  float dist=10000.;\n\n  for ( int i=0; i<10; i++ )\n  {\n    rayPos =origin+direction*t;\n    dist = min(dist, MapFlare( rayPos, missile));\n    t += dist;\n  }\n\n  return dist;\n}\n\nfloat MapMissile(vec3 p, Missile missile)\n{\n  float d= fCylinder( p, 0.70, 1.7);\n  if (d<1.0)\n  {\n    d = fCylinder( p, 0.12, 1.2);   \n    d =min(d, sdEllipsoid( p- vec3(0, 0, 1.10), vec3(0.12, 0.12, 1.0))); \n\n    checkPos = p;  \n    pR(checkPos.xy, 0.785);\n    checkPos.xy = pModPolar(checkPos.xy, 4.0);\n\n    d=min(d, sdHexPrism( checkPos-vec3(0., 0., .60), vec2(0.50, 0.01)));\n    d=min(d, sdHexPrism( checkPos+vec3(0., 0., 1.03), vec2(0.50, 0.01)));\n    d = max(d, -sdBox(p+vec3(0., 0., 3.15), vec3(3.0, 3.0, 2.0)));\n    d = max(d, -fCylinder(p+vec3(0., 0., 2.15), 0.09, 1.2));\n  }\n  return d;\n}\n\nfloat MapFlyingMissile( vec3 p, Missile missile)\n{\n  TranslateMissilePos(p, missile);  \n  \/\/ map missile flame\n  eFlameDist = min(eFlameDist, sdEllipsoid( p+ vec3(0., 0., 2.2+cos(iTime*90.0)*0.23), vec3(.17, 0.17, 1.0)));\n  \/\/ map missile \n  return min(MapMissile(p, missile), eFlameDist);\n}\n\nRayHit TraceMissile(in vec3 origin, in vec3 direction, int steps, Missile missile)\n{\n  RayHit result;\n  float maxDist = 450.0;\n  float t = 0.0, glassDist = 0.0, dist = 100000.0;\n  vec3 rayPos;\n  eFlameDist=10000.0;\n  for ( int i=0; i<steps; i++ )\n  {\n    rayPos =origin+direction*t;\n    dist = MapFlyingMissile(rayPos, missile);\n\n    if (dist<0.01 || t>maxDist )\n    {                \n      result.hit=!(t>maxDist);\n      result.depth = t; \n      result.dist = dist;                              \n      result.hitPos = origin+((direction*t));   \n\n      result.eFlameDist = eFlameDist;\n      break;\n    }\n    t += dist;\n  }\n\n  return result;\n}\n\nfloat SoftShadowMissile( in vec3 origin, in vec3 direction, Missile missile )\n{\n  float res = 2.0, t = 0.02, h;\n  for ( int i=0; i<8; i++ )\n  {\n    h = MapMissile(origin+direction*t, missile);\n    res = min( res, 7.5*h\/t );\n    t += clamp( h, 0.05, 0.2 );\n    if ( h<0.001 || t>2.5 ) break;\n  }\n  return clamp( res, 0.0, 1.0 );\n}\n\nvec3 GetMissileLightning(float specLevel, vec3 normal, RayHit rayHit, vec3 rayDir, vec3 origin, Missile missile)\n{       \n  float dif = clamp( dot( normal, sunPos ), 0.0, 1.0 );\n  vec3 reflectDir = reflect( rayDir, normal );\n  specLevel= 3.5*pow(clamp( dot( reflectDir, sunPos ), 0.0, 1.0 ), 9.0\/3.);\n\n  float fre = pow( 1.0-abs(dot( normal, rayDir )), 2.0 );\n  fre = mix( .03, 1.0, fre );   \n  float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );\n\n  float shadow = SoftShadowMissile(origin+((rayDir*rayHit.depth)*0.998), sunPos, missile);\n  dif*=shadow;\n  float skyLight = smoothstep( -0.1, 0.1, reflectDir.y );\n\n  vec3 lightTot = (vec3(0.7)*amb); \n  lightTot+=vec3(0.85)*dif;\n  lightTot += 1.00*specLevel*dif;\n  lightTot += 0.80*skyLight*vec3(0.40, 0.60, 1.00);\n  lightTot= mix(lightTot*.7, lightTot*1.2, fre );\n\n  return lightTot*sunColor;\n}\n\nvec3 calcMissileNormal( in vec3 pos, Missile missile )\n{    \n  return normalize( vec3(MapFlyingMissile(pos+eps.xyy, missile) - MapFlyingMissile(pos-eps.xyy, missile), 0.5*2.0*eps.x, MapFlyingMissile(pos+eps.yyx, missile) - MapFlyingMissile(pos-eps.yyx, missile) ) );\n}\n\nmat3 setCamera(  vec3 ro, vec3 ta, float cr )\n{\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n  vec3 cu = normalize( cross(cw, cp) );\n  vec3 cv = normalize( cross(cu, cw) );\n  return mat3( cu, cv, cw );\n}\n\n\/\/ set sky color tone. 2 gradient passes using MIX.\nvec3 GetSkyColor(vec3 rayDir)\n{ \n  return mix(mix(vec3(0.15, 0.19, 0.24), vec3(220., 230., 240.0)\/255., smoothstep(1.0, .30, rayDir.y)), mix(vec3(229.0, 221., 230)\/200., sunColor, 0.15), smoothstep(0.15, -0.13, rayDir.y));\n}\n\n\/\/ scene lightning\nvec3 GetSceneLight(float specLevel, vec3 normal, RayHit rayHit, vec3 rayDir, vec3 origin)\n{                \n  vec3 reflectDir = reflect( rayDir, normal );\n\n  vec3 lightTot = vec3(0.0);\n  float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );\n  float dif = clamp( dot( normal, sunPos ), 0.0, 1.0 );\n  float bac = clamp( dot( normal, normalize(vec3(-sunPos.x, 0.0, -sunPos.z)) ), 0.0, 1.0 ) * clamp(1.0-rayHit.hitPos.y\/20.0, 0.0, 1.0);\n  ;\n  float fre = pow( clamp(1.0+dot(normal, rayDir), 0.0, 1.0), 2.0 );\n  specLevel*= pow(clamp( dot( reflectDir, sunPos ), 0.0, 1.0 ), 7.0);\n  float skylight = smoothstep( -0.1, 0.1, reflectDir.y );\n\n  float shadow=1.; \n  #ifdef SHADOWS\n    shadow = SoftShadow(origin+((rayDir*rayHit.depth)*0.988), sunPos);\n  #endif\n\n    lightTot += 1.5*dif*vec3(1.00, 0.90, 0.85)*shadow;\n  lightTot += 0.50*skylight*vec3(0.40, 0.60, 0.95);\n  lightTot += 1.00*specLevel*vec3(0.9, 0.8, 0.7)*dif;\n  lightTot += 0.50*bac*vec3(0.25, 0.25, 0.25);\n  lightTot += 0.25*fre*vec3(1.00, 1.00, 1.00)*shadow;\n\n  return clamp(lightTot, 0., 10.)*sunColor;\n}\n\nvec3 GetSceneLightWater(float specLevel, vec3 normal, RayHit rayHit, vec3 rayDir, vec3 origin)\n{                \n  vec3 reflectDir = reflect( rayDir, normal );\n  float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );\n  float dif = clamp( dot( normal, sunPos ), 0.0, 1.0 );\n  float bac = clamp( dot( normal, normalize(vec3(-sunPos.x, 0.0, -sunPos.z)) ), 0.0, 1.0 ) * clamp(1.0-rayHit.hitPos.y\/20.0, 0.0, 1.0);\n\n  specLevel*= pow(clamp( dot( reflectDir, sunPos ), 0.0, 1.0 ), 9.0);\n\n  float skylight = smoothstep( -0.1, 0.1, reflectDir.y );\n  float fre = pow( 1.0-abs(dot( normal, rayDir )), 4.0 );\n  fre = mix( .03, 1.0, fre );   \n\n  vec3 reflection = vec3(1.0);\n  vec3 lightTot = vec3(0.0);\n\n  lightTot += 1.15*dif*vec3(1.00, 0.90, 0.85);\n  lightTot += 1.00*specLevel*vec3(0.9, 0.8, 0.7)*dif;    \n  lightTot= mix(lightTot, reflection, fre );\n  lightTot += 0.70*skylight*vec3(0.70, 0.70, 0.85);\n  lightTot += 1.30*bac*vec3(0.25, 0.25, 0.25);\n  lightTot += 0.25*amb*vec3(0.80, 0.90, 0.95);  \n  return clamp(lightTot, 0., 10.);\n}\n\n\nvoid ApplyFog(inout vec3 color, vec3 skyColor, vec3 rayOrigin, vec3 rayDir, float depth)   \n{\n  float mixValue = smoothstep(50., 15000., pow(depth, 2.)*0.1);\n  float sunVisibility = max(0., dot(sunPos, rayDir));\n  \/\/ horizontal fog\n  vec3 fogColor = mix(sunColor*0.7, skyColor, mixValue);  \n  fogColor = mix(fogColor, sunColor, smoothstep(0., 1., sunVisibility));   \n  color = mix(color, fogColor, mixValue);\n\n  \/\/ vertical fog\n  float heightAmount = .01;\n  float fogAmount = 0.2 * exp(-rayOrigin.y*heightAmount) * (1.0-exp( -depth*rayDir.y*heightAmount ))\/rayDir.y;\n  color = mix(color, fogColor, fogAmount);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{  \n  vec2 mo = iMouse.xy\/iResolution.xy;\n  vec2 uv = fragCoord.xy \/ iResolution.xy;\n  vec2 screenSpace = (-iResolution.xy + 2.0*(fragCoord))\/iResolution.y;\n\n  \/\/ read plane data from buffer\n  turn = read(ivec2(1, 10));\n  float roll = read(ivec2(1, 1));\n  float speed = read(ivec2(10, 1));\n  float pitch = read(ivec2(15, 1));\n  sunPos =  readRGB(ivec2(50, 0));\n  planePos = readRGB(ivec2(55, 0));\n  float CAMZOOM = read(ivec2(52, 0));  \n\n  \/\/ setup camera and ray direction\n  vec2 camRot = readRGB(ivec2(57, 0)).xy;\n\n  cloudPos = vec2(-iTime*0.3, iTime*0.45);\n\n  vec3 rayOrigin = vec3(CAMZOOM*cos(camRot.x), planePos.y+CAMZOOM*sin(camRot.y), -3.+CAMZOOM*sin(camRot.x) );    \n  pR(rayOrigin.xz, -turn);\n  mat3 ca = setCamera( rayOrigin, vec3(0., planePos.y, -3. ), 0.0 );\n  vec3 rayDir = ca * normalize( vec3(screenSpace.xy, 2.0) );\n\n  \/\/ create sky color fade\n  vec3 skyColor = GetSkyColor(rayDir);\n  vec3 color = skyColor;\n  float alpha=0.;\n\n  RayHit marchResult = TraceTerrain(rayOrigin, rayDir, 1200);\n\n  \/\/ is terrain hit?\n  if (marchResult.hit)\n  { \n\n    alpha=1.0;\n    marchResult.normal = calcNormal(marchResult.hitPos);  \n\n    float specLevel=0.7;\n    color=vec3(0.5);\n\n    \/\/ create terrain texture\n    vec3 colorRocks= vec3(mix(texture(iChannel3, (marchResult.hitPos.xz+planePos.xz)*.01).rgb, texture(iChannel3, (marchResult.hitPos.xz+vec2(10000.0, 10000.0)+planePos.xz)*.01).rgb, fastFBM(marchResult.hitPos)));\n    color =colorRocks;\n    color.rgb = mix(color.rgb, color*3., abs(noise2D((marchResult.hitPos.xz+planePos.xz)*0.4, 1.0))); \n\n    \/\/ grass\n    color.rgb = mix(color.rgb, ((color+noise2D((marchResult.hitPos.xz+planePos.xz)*24., 1.0))+vec3(0.5, 0.4, .1))*0.3, smoothstep(0.2, 2.0, marchResult.hitPos.y)); \n\n    float stoneHeight = GetStoneHeight(marchResult.hitPos, (GetTerrainHeight(marchResult.hitPos)));     \n    color.rgb = mix(color.rgb, vec3(0.5+(noise(marchResult.hitPos+vec3(planePos.x, 0., planePos.z))*0.3)), smoothstep(1., .0, stoneHeight));\n    specLevel = mix(specLevel, specLevel*2.6, smoothstep(1., .0, stoneHeight));\n\n    \/\/ beach\n    color.rgb = mix((color+vec3(1.2, 1.1, 1.0))*0.5, color.rgb, smoothstep(0.3, 0.7, marchResult.hitPos.y)); \n\n\n    float burn = NoTreeZone(marchResult.hitPos+planePos);\n    color=mix(color*0.1, color, smoothstep(0., 25., burn));\n\n    \/\/ create slight wave difference between water and beach level\n    float wave = max(0., cos(abs(noise2D((marchResult.hitPos.xz+planePos.xz)))+(iTime*.5)+(length(marchResult.hitPos.xz)*0.03))*0.09);\n\n    vec3 light;\n    \/\/ check if terrain is below water level\n    if (marchResult.hitPos.y<0.3+wave)\n    {\n      vec3 terrainHit = rayOrigin+((rayDir*marchResult.depth)*0.998);\n      vec3 refDir = reflect(rayDir, marchResult.normal);\n      vec4 testClouds = TraceCloudsBelow(terrainHit, refDir, skyColor, 30);\n\n      color = vec3(0.3);\n\n      float sunVisibility = max(0., dot(sunPos, rayDir));\n\n      \/\/ calculate water fresnel  \n      float dotNormal = dot(rayDir, marchResult.normal);\n      float fresnel = pow(1.0-abs(dotNormal), 4.);  \n      vec3 rayRef = rayDir-marchResult.normal*dotNormal;\n\n      \/\/color.rgb  = mix(mix(vec3(1.0), (vec3(0.7)+sunColor)*1.50, smoothstep(150., 350.,marchResult.depth)), color.rgb, smoothstep(-TERRAINLEVEL-0.37, -TERRAINLEVEL+0.25, marchResult.hitPos.y));\n      color.rgb  = mix(color*.7, color.rgb, smoothstep(-3.0, -0.15, marchResult.hitPos.y));\n\n      color = color+(sunColor*pow(sunVisibility, 5.0));\n\n      \/\/ sea color\n      color = mix(mix(color, color+fresnel, fresnel ), color, smoothstep(-0.1, 0.15, marchResult.hitPos.y));\n\n      vec3 reflection = color;\n\n      #ifdef QUALITY_REFLECTIONS\n        \/\/ cast rays from water surface onto terrain. If terrain is hit, color water dark in these areas.\n        RayHit reflectResult = TraceTerrainReflection(terrainHit, refDir, 100); \n\n      if (reflectResult.hit==true)\n      {\n        reflection  = mix(color, vec3(.01, 0.03, .0), 0.9);\n      }\n      #endif\n        light = GetSceneLightWater(specLevel, marchResult.normal, marchResult, rayDir, rayOrigin);   \n      color=mix(mix(color.rgb, testClouds.rgb, testClouds.a*.26), mix(color.rgb, testClouds.rgb, testClouds.a), smoothstep(0., 0.7, fresnel)); \n      color=mix(mix(color.rgb, reflection, 0.5), reflection, smoothstep(0., 0.7, fresnel)); \n      color=mix(color, color+(0.5*fresnel), smoothstep(0., 0.3, fresnel)); \n\n      color=color*light;\n      color = mix(color, skyColor, smoothstep(320., 400., marchResult.depth));\n    } \n    \/\/ terrain is ABOVE water level  \n    else\n    {\n      \/\/ get lightning based on material\n      light = GetSceneLight(specLevel, marchResult.normal, marchResult, rayDir, rayOrigin);   \n\n      \/\/ apply lightning\n      color = color*light;\n\n      #ifdef QUALITY_TREE\n        \/\/ add trees\n        vec4 treeColor = TraceTrees(rayOrigin, rayDir, 28, marchResult.hitPos.y-0.3 );      \n      color =clamp( mix( color, treeColor.rgb*((noise2D((marchResult.hitPos.xz+planePos.xz)*36., 3.0)+vec3(0.56, 0.66, .45))*0.6)*sunColor*(.30+(0.6*light)), treeColor.a ), 0.02, 1.); \n      #endif\n    }\n\n    color = mix(color, (color+sunColor)*0.6, smoothstep(70., 300., marchResult.depth));\n    \/\/ add haze when high above ground  \n    color = mix(color, color+vec3(0.37, 0.58, 0.9)*sunColor, mix(0., 0.75, smoothstep(-CLOUDLEVEL*0.65, MAX_HEIGHT, planePos.y)));  \n    ApplyFog(color, skyColor, rayOrigin, rayDir, marchResult.depth);\n  } else\n  {\n    \/\/ add volumetric clouds \n    \/\/ below cloud level\n    if (rayOrigin.y<-CLOUDLEVEL && rayDir.y>0.)\n    {  \n      vec4 cloudColor=TraceCloudsBelow(rayOrigin, rayDir, skyColor, 60);    \n\n      \/\/ make clouds slightly light near the sun\n      float sunVisibility = pow(max(0., dot(sunPos, rayDir)), 2.0)*0.10;\n      color.rgb = mix(color.rgb, max(vec3(0.), cloudColor.rgb+sunVisibility), cloudColor.a);      \n      \/\/color.rgb = mix(color.rgb, cloudColor.rgb, cloudColor.a);       \n      alpha+=cloudColor.a*0.86;\n    }\n  }\n\n  \/\/ add volumetric clouds \n  \/\/ above cloud level\n  if (rayOrigin.y>=-CLOUDLEVEL)\n  {  \n    vec4 cloudColor=TraceClouds(rayOrigin, rayDir, skyColor, 80);    \n    color.rgb = mix(color.rgb, cloudColor.rgb, cloudColor.a);\n  }\n\n  rayDir = ca * normalize( vec3(screenSpace.xy, 2.0) );\n  DrawExplosion(0, marchResult, color, rayDir, rayOrigin);\n  DrawExplosion(1, marchResult, color, rayDir, rayOrigin);\n\n\n  \/\/ #################################################################### \/\/    \n  \/\/ ##############             MISSILES             #################### \/\/     \n  \/\/ #################################################################### \/\/    \n\n  rayOrigin = vec3(CAMZOOM*cos(camRot.x), CAMZOOM*sin(camRot.y), CAMZOOM*sin(camRot.x) );\n  pR(rayOrigin.xz, -turn);\n  ca = setCamera( rayOrigin, vec3(0., 0., 0. ), 0.0 );\n  rayDir = ca * normalize( vec3(screenSpace.xy, 2.0) );\n\n  int adressStep = 0;\n  Missile missile;\n  for (int i=0; i<2; i++)\n  {\n    adressStep = i*100;\n    missile.life = read(ivec2(100 + adressStep, 0));\n    \/\/ check if missile is launched\n    if (missile.life>0.)\n    {\n      missile.origin = vec3(4.8 - (9.6*float(i)), -0.4, -3.0);       \n      missile.orientation = readRGB(ivec2(108+adressStep, 0));\n      missile.pos = readRGB(ivec2(116+adressStep, 0));\n\n      \/\/ calculate engine flare\n      float lightDist = TraceEngineFlare(rayOrigin, rayDir, missile);\n\n      \/\/ add engine flares for missiles based on engine distance\n      vec3 lightFlares=vec3(0.);\n      lightFlares =  mix((vec3(1., 0.4, 0.2)), vec3(0.), smoothstep(0., 1.1, lightDist));             \n      lightFlares =  mix(lightFlares+(2.*vec3(1., 0.5, 0.2)), lightFlares, smoothstep(0., 0.7, lightDist));\n      lightFlares =  mix(lightFlares+vec3(1., 1., 1.), lightFlares, smoothstep(0., 0.2, lightDist));\n\n      \/\/ rayTrace missile\n      RayHit marchResult = TraceMissile(rayOrigin, rayDir, 64, missile);\n\n      \/\/ apply color and lightning to missile if hit in raymarch test    \n      if (marchResult.hit)\n      {\n        marchResult.normal = calcMissileNormal(marchResult.hitPos, missile);  \n\n        \/\/ create texture map and set specular levels\n        vec4 col = vec4(0.45, 0.45, 0.45, 0.8);\n\n        \/\/ flame\n        col.rgb=mix(col.rgb, vec3(1.2, .55, 0.30)*2.5, smoothstep(.16, 0., marchResult.eFlameDist));\n\n        \/\/ get lightning based on material\n        vec3 light = GetMissileLightning(col.a, marchResult.normal, marchResult, rayDir, rayOrigin, missile);   \n\n        \/\/ apply lightning\n        color.rgb = col.rgb*light;\n\n        alpha = 1.; \n\n        lightFlares = mix(lightFlares, vec3(.0), step(0.1, distance(marchResult.dist, marchResult.eFlameDist)));\n      }\n\n      color.rgb+=lightFlares;\n\n      \/\/draw smoke trail behind missile\n      vec4 trailColor = TraceSmoketrail(rayOrigin, rayDir, 48, missile);     \n      color.rgb = mix(color.rgb, trailColor.rgb, trailColor.a);\n      alpha+=trailColor.a;   \n\n      if (marchResult.hit) \n      { \n        break;\n      }\n    }\n  }\n  \/\/ #################################################################### \/\/\n  \/\/ #################################################################### \/\/\n\n  fragColor = vec4(color.rgb, min(1.0, alpha));\n}\n",
            "name": "Buf B",
            "description": "",
            "type": "buffer"
        },
        {
            "inputs": [
                {
                    "id": "XdXGzn",
                    "filepath": "\/media\/a\/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png",
                    "previewfilepath": "\/media\/ap\/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png",
                    "type": "texture",
                    "channel": 1,
                    "sampler": {
                        "filter": "mipmap",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "4sX3zn",
                    "filepath": "\/media\/a\/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png",
                    "previewfilepath": "\/media\/ap\/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png",
                    "type": "cubemap",
                    "channel": 3,
                    "sampler": {
                        "filter": "mipmap",
                        "wrap": "repeat",
                        "vflip": "false",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 2,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "XsXGR8",
                    "filepath": "\/media\/previz\/buffer01.png",
                    "previewfilepath": "\/media\/previz\/buffer01.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4sXGR8",
                    "channel": 0
                }
            ],
            "code": "\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ PLANE BUFFER   -   RENDERS PLANE ONLY\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Channel 0 = Buffer B. Get the colors of the terrain buffer render.\n\/\/ Channel 1 = LowRes noise texture. Used in fast noise functions.\n\/\/ Channel 2 = Buffer A. Read data from data-buffer.\n\/\/ Channel 3 = Forest blurred cube map. Used in reflections in plane window and hull.\n\n  #pragma optimize(off) \n#define PI acos(-1.)\n  #define read(memPos) (  texelFetch(iChannel2, memPos, 0).a)\n  #define readRGB(memPos) (  texelFetch(iChannel2, memPos, 0).rgb)\n  #define RAYSTEPS 300\n  #define CLOUDLEVEL -70.0\n  float turn=0., pitch = 0., roll=0., rudderAngle = 0.;\nfloat speed = 0.5;\nvec3 checkPos=vec3(0.);\nvec3 sunPos=vec3(0.);\nconst vec3 sunColor = vec3(1.00, 0.90, 0.85);\nvec3 planePos=vec3(0.);\nconst vec3 eps = vec3(0.02, 0.0, 0.0);\n\nfloat winDist=10000.0;\nfloat engineDist=10000.0;\nfloat eFlameDist=10000.0;\nfloat blackDist=10000.0;\nfloat bombDist=10000.0;\nfloat bombDist2=10000.0;\nfloat missileDist=10000.0;\nfloat frontWingDist=10000.0;\nfloat rearWingDist=10000.0;\nfloat topWingDist=10000.0;\nvec2 missilesLaunched=vec2(0.);\n\nfloat sgn(float x) \n{   \n  return (x<0.)?-1.:1.;\n}\n\nstruct RayHit\n{\n  bool hit;  \n  vec3 hitPos;\n  vec3 normal;\n  float dist;\n  float depth;\n\n  float winDist;\n  float engineDist;\n  float eFlameDist;\n  float blackDist;\n  float bombDist;\n  float bombDist2;\n  float missileDist;\n  float frontWingDist;\n  float rearWingDist;\n  float topWingDist;\n};\n\nfloat noise2D( in vec2 pos, float lod)\n{   \n  vec2 f = fract(pos);\n  f = f*f*(3.0-2.0*f);\n  vec2 rg = textureLod( iChannel1, (((floor(pos).xy+vec2(37.0, 17.0)) + f.xy)+ 0.5)\/64.0, lod).yx;  \n  return -1.0+2.0*mix( rg.x, rg.y, 0.5 );\n}\nfloat noise2D( in vec2 pos )\n{\n  return noise2D(pos, 0.0);\n}\n\nfloat noise( in vec3 x )\n{\n  vec3 p = floor(x);\n  vec3 f = fract(x);\n\n  float a = textureLod( iChannel1, x.xy\/64.0 + (p.z+0.0)*120.7123, 0.1 ).x;\n  float b = textureLod( iChannel1, x.xy\/64.0 + (p.z+1.0)*120.7123, 0.1 ).x;\n  return mix( a, b, f.z );\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x, p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa, ba)\/dot(ba, ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  return (length( p\/r.xyz ) - 1.0) * r.y;\n}\n\nfloat sdConeSection( vec3 p, float h, float r1, float r2 )\n{\n  float d1 = -p.z - h;\n  float q = p.z - h;\n  float si = 0.5*(r1-r2)\/h;\n  float d2 = max( sqrt( dot(p.xy, p.xy)*(1.0-si*si)) + q*si - r2, q );\n  return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.);\n}\n\nfloat fCylinder(vec3 p, float r, float height) {\n  float d = length(p.xy) - r;\n  d = max(d, abs(p.z) - height);\n  return d;\n}\nfloat fSphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.y-h.y, max((q.z*0.866025+q.x*0.5), q.x)-h.x);\n}\n\nfloat fOpPipe(float a, float b, float r) {\n  return length(vec2(a, b)) - r;\n}\n\nvec2 pModPolar(vec2 p, float repetitions) {\n  float angle = 2.*PI\/repetitions;\n  float a = atan(p.y, p.x) + angle\/2.;\n  float r = length(p);\n  float c = floor(a\/angle);\n  a = mod(a, angle) - angle\/2.;\n  p = vec2(cos(a), sin(a))*r;\n  if (abs(c) >= (repetitions\/2.)) c = abs(c);\n  return p;\n}\n\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)\/size);\n  p = mod(p+halfsize, size) - halfsize;\n  if (c > stop) {\n    p += size*(c - stop);\n    c = stop;\n  }\n  if (c <start) {\n    p += size*(c - start);\n    c = start;\n  }\n  return c;\n}\n\nfloat pMirror (inout float p, float dist) {\n  float s = sgn(p);\n  p = abs(p)-dist;\n  return s;\n}\n\nmat2 r2(float r)\n{\n  float c=cos(r), s=sin(r);\n  return mat2(c, s, -s, c);\n}\n\n#define r3(r) mat2(sin(vec4(-1, 0, 0, 1)*acos(0.)+r))\n  void pR(inout vec2 p, float a) \n{\n  p*=r2(a);\n}\n\nfloat fOpUnionRound(float a, float b, float r) {\n  vec2 u = max(vec2(r - a, r - b), vec2(0));\n  return max(r, min (a, b)) - length(u);\n}\n\nfloat fOpIntersectionRound(float a, float b, float r) {\n  vec2 u = max(vec2(r + a, r + b), vec2(0));\n  return min(-r, max (a, b)) + length(u);\n}\n\n\/\/ limited by euler rotation. I wont get a good plane rotation without quaternions! :-(\nvec3 TranslatePos(vec3 p, float _pitch, float _roll)\n{\n  pR(p.xy, _roll-PI);\n  p.z+=5.;\n  pR(p.zy, _pitch);\n  p.z-=5.; \n  return p;\n}\n\nfloat MapEsmPod(vec3 p)\n{\n  float dist = fCylinder( p, 0.15, 1.0);   \n  checkPos =  p- vec3(0, 0, -1.0);\n  pModInterval1(checkPos.z, 2.0, .0, 1.0);\n  return min(dist, sdEllipsoid(checkPos, vec3(0.15, 0.15, .5)));\n}\n\nfloat MapMissile(vec3 p)\n{\n  float d= fCylinder( p, 0.70, 1.7);\n  if (d<1.0)\n  {\n    missileDist = min(missileDist, fCylinder( p, 0.12, 1.2));   \n    missileDist =min(missileDist, sdEllipsoid( p- vec3(0, 0, 1.10), vec3(0.12, 0.12, 1.0))); \n\n    checkPos = p;  \n    pR(checkPos.xy, 0.785);\n    checkPos.xy = pModPolar(checkPos.xy, 4.0);\n\n    missileDist=min(missileDist, sdHexPrism( checkPos-vec3(0., 0., .60), vec2(0.50, 0.01)));\n    missileDist=min(missileDist, sdHexPrism( checkPos+vec3(0., 0., 1.03), vec2(0.50, 0.01)));\n    missileDist = max(missileDist, -sdBox(p+vec3(0., 0., 3.15), vec3(3.0, 3.0, 2.0)));\n    missileDist = max(missileDist, -fCylinder(p+vec3(0., 0., 2.15), 0.09, 1.2));\n  }\n  return missileDist;\n}\n\nfloat MapFrontWing(vec3 p, float mirrored)\n{\n  missileDist=10000.0;\n\n  checkPos = p;\n  pR(checkPos.xy, -0.02);\n  float wing =sdBox( checkPos- vec3(4.50, 0.25, -4.6), vec3(3.75, 0.04, 2.6)); \n\n  if (wing<5.) \/\/Bounding Box test\n  {\n    \/\/ cutouts\n    checkPos = p-vec3(3.0, 0.3, -.30);\n    pR(checkPos.xz, -0.5);\n    wing=fOpIntersectionRound(wing, -sdBox( checkPos, vec3(6.75, 1.4, 2.0)), 0.1);\n\n    checkPos = p - vec3(8.0, 0.3, -8.80);\n    pR(checkPos.xz, -0.05);\n    wing=fOpIntersectionRound(wing, -sdBox( checkPos, vec3(10.75, 1.4, 2.0)), 0.1);\n\n    checkPos = p- vec3(9.5, 0.3, -8.50);\n    wing=fOpIntersectionRound(wing, -sdBox( checkPos, vec3(2.0, 1.4, 6.75)), 0.6);\n\n    \/\/ join wing and engine\n    wing=min(wing, sdCapsule(p- vec3(2.20, 0.3, -4.2), vec3(0, 0, -1.20), vec3(0, 0, 0.8), 0.04));\n    wing=min(wing, sdCapsule(p- vec3(3., 0.23, -4.2), vec3(0, 0, -1.20), vec3(0, 0, 0.5), 0.04));    \n\n    checkPos = p;\n    pR(checkPos.xz, -0.03);\n    wing=min(wing, sdConeSection(checkPos- vec3(0.70, -0.1, -4.52), 5.0, 0.25, 0.9));   \n\n    checkPos = p;\n    pR(checkPos.yz, 0.75);\n    wing=fOpIntersectionRound(wing, -sdBox( checkPos- vec3(3.0, -.5, 1.50), vec3(3.75, 3.4, 2.0)), 0.12); \n    pR(checkPos.yz, -1.95);\n    wing=fOpIntersectionRound(wing, -sdBox( checkPos- vec3(2.0, .70, 2.20), vec3(3.75, 3.4, 2.0)), 0.12); \n\n    checkPos = p- vec3(0.47, 0.0, -4.3);\n    pR(checkPos.yz, 1.57);\n    wing=min(wing, sdTorus(checkPos-vec3(0.0, -3., .0), vec2(.3, 0.05)));   \n\n    \/\/ flaps\n    wing =max(wing, -sdBox( p- vec3(3.565, 0.1, -6.4), vec3(1.50, 1.4, .5)));\n    wing =max(wing, -max(sdBox( p- vec3(5.065, 0.1, -8.4), vec3(0.90, 1.4, 2.5)), -sdBox( p- vec3(5.065, 0., -8.4), vec3(0.89, 1.4, 2.49))));\n\n    checkPos = p- vec3(3.565, 0.18, -6.20+0.30);\n    pR(checkPos.yz, -0.15+(0.8*pitch));\n    wing =min(wing, sdBox( checkPos+vec3(0.0, 0.0, 0.30), vec3(1.46, 0.007, 0.3)));\n\n    \/\/ missile holder\n    float holder = sdBox( p- vec3(3.8, -0.26, -4.70), vec3(0.04, 0.4, 0.8));\n\n    checkPos = p;\n    pR(checkPos.yz, 0.85);\n    holder=max(holder, -sdBox( checkPos- vec3(2.8, -1.8, -3.0), vec3(1.75, 1.4, 1.0))); \n    holder=max(holder, -sdBox( checkPos- vec3(2.8, -5.8, -3.0), vec3(1.75, 1.4, 1.0))); \n    holder =fOpUnionRound(holder, sdBox( p- vec3(3.8, -0.23, -4.70), vec3(1.0, 0.03, 0.5)), 0.1); \n\n    \/\/ bomb\n    bombDist = fCylinder( p- vec3(3.8, -0.8, -4.50), 0.35, 1.);   \n    bombDist =min(bombDist, sdEllipsoid( p- vec3(3.8, -0.8, -3.50), vec3(0.35, 0.35, 1.0)));   \n    bombDist =min(bombDist, sdEllipsoid( p- vec3(3.8, -0.8, -5.50), vec3(0.35, 0.35, 1.0)));   \n\n    \/\/ missiles\n    checkPos = p-vec3(2.9, -0.45, -4.50);\n\n    \/\/ check if any missile has been fired. If so, do NOT mod missile position  \n    float maxMissiles =0.; \n    if (mirrored>0.) maxMissiles =  mix(1.0, 0., step(1., missilesLaunched.x));\n    else maxMissiles =  mix(1.0, 0., step(1., missilesLaunched.y)); \n\n    pModInterval1(checkPos.x, 1.8, .0, maxMissiles);\n    holder = min(holder, MapMissile(checkPos));\n\n    \/\/ ESM Pod\n    holder = min(holder, MapEsmPod(p-vec3(7.2, 0.06, -5.68)));\n\n    \/\/ wheelholder\n    wing=min(wing, sdBox( p- vec3(0.6, -0.25, -3.8), vec3(0.8, 0.4, .50)));\n\n    wing=min(bombDist, min(wing, holder));\n  }\n\n  return wing;\n}\n\nfloat MapRearWing(vec3 p)\n{\n  float wing2 =sdBox( p- vec3(2.50, 0.1, -8.9), vec3(1.5, 0.017, 1.3)); \n  if (wing2<0.15) \/\/Bounding Box test\n  {\n    \/\/ cutouts\n    checkPos = p-vec3(3.0, 0.0, -5.9);\n    pR(checkPos.xz, -0.5);\n    wing2=fOpIntersectionRound(wing2, -sdBox( checkPos, vec3(6.75, 1.4, 2.0)), 0.2); \n\n    checkPos = p-vec3(0.0, 0.0, -4.9);\n    pR(checkPos.xz, -0.5);\n    wing2=fOpIntersectionRound(wing2, -sdBox( checkPos, vec3(3.3, 1.4, 1.70)), 0.2);\n\n    checkPos = p-vec3(3.0, 0.0, -11.70);\n    pR(checkPos.xz, -0.05);\n    wing2=fOpIntersectionRound(wing2, -sdBox( checkPos, vec3(6.75, 1.4, 2.0)), 0.1); \n\n    checkPos = p-vec3(4.30, 0.0, -11.80);\n    pR(checkPos.xz, 1.15);\n    wing2=fOpIntersectionRound(wing2, -sdBox( checkPos, vec3(6.75, 1.4, 2.0)), 0.1);\n  }\n  return wing2;\n} \n\nfloat MapTailFlap(vec3 p, float mirrored)\n{\n  p.z+=0.3;\n  pR(p.xz, rudderAngle*(-1.*mirrored)); \n  p.z-=0.3;\n\n  float tailFlap =sdBox(p- vec3(0., -0.04, -.42), vec3(0.025, .45, .30));\n\n  \/\/ tailFlap front cutout\n  checkPos = p- vec3(0., 0., 1.15);\n  pR(checkPos.yz, 1.32);\n  tailFlap=max(tailFlap, -sdBox( checkPos, vec3(.75, 1.41, 1.6)));\n\n  \/\/ tailFlap rear cutout\n  checkPos = p- vec3(0., 0, -2.75);  \n  pR(checkPos.yz, -0.15);\n  tailFlap=fOpIntersectionRound(tailFlap, -sdBox( checkPos, vec3(.75, 1.4, 2.0)), 0.05);\n\n  checkPos = p- vec3(0., 0., -.65);\n  tailFlap = min(tailFlap, sdEllipsoid( checkPos-vec3(0.00, 0.25, 0), vec3(0.06, 0.05, 0.15)));\n  tailFlap = min(tailFlap, sdEllipsoid( checkPos-vec3(0.00, 0.10, 0), vec3(0.06, 0.05, 0.15)));\n\n  return tailFlap;\n}\n\nfloat MapTopWing(vec3 p, float mirrored)\n{    \n  checkPos = p- vec3(1.15, 1.04, -8.5);\n  pR(checkPos.xy, -0.15);  \n  float topWing = sdBox( checkPos, vec3(0.014, 0.8, 1.2));\n  if (topWing<.15) \/\/Bounding Box test\n  {\n    float flapDist = MapTailFlap(checkPos, mirrored);\n\n    checkPos = p- vec3(1.15, 1.04, -8.5);\n    pR(checkPos.xy, -0.15);  \n    \/\/ top border    \n    topWing = min(topWing, sdBox( checkPos-vec3(0, 0.55, 0), vec3(0.04, 0.1, 1.25)));\n\n    float flapCutout = sdBox(checkPos- vec3(0., -0.04, -1.19), vec3(0.02, .45, 1.0));\n    \/\/ tailFlap front cutout\n    checkPos = p- vec3(1.15, 2., -7.65);\n    pR(checkPos.yz, 1.32);\n    flapCutout=max(flapCutout, -sdBox( checkPos, vec3(.75, 1.41, 1.6)));\n\n    \/\/ make hole for tail flap\n    topWing=max(topWing, -flapCutout);\n\n    \/\/ front cutouts\n    checkPos = p- vec3(1.15, 2., -7.);\n    pR(checkPos.yz, 1.02);\n    topWing=fOpIntersectionRound(topWing, -sdBox( checkPos, vec3(.75, 1.41, 1.6)), 0.05);\n\n    \/\/ rear cutout\n    checkPos = p- vec3(1.15, 1., -11.25);  \n    pR(checkPos.yz, -0.15);\n    topWing=fOpIntersectionRound(topWing, -sdBox( checkPos, vec3(.75, 1.4, 2.0)), 0.05);\n\n    \/\/ top roll \n    topWing=min(topWing, sdCapsule(p- vec3(1.26, 1.8, -8.84), vec3(0, 0, -.50), vec3(0, 0, 0.3), 0.06)); \n\n    topWing = min(topWing, flapDist);\n  }\n  return topWing;\n}\n\nfloat MapPlane( vec3 p)\n{\n  float  d=100000.0;\n  vec3 pOriginal = p;\n  \/\/ rotate position \n  p=TranslatePos(p, pitch, roll);\n  float mirrored=0.;\n  \/\/ AABB TEST  \n  float test = sdBox( p- vec3(0., -0., -3.), vec3(7.5, 4., 10.6));    \n  if (test>1.0) return test;\n\n  \/\/ mirror position at x=0.0. Both sides of the plane are equal.\n  mirrored = pMirror(p.x, 0.0);\n\n  float body= min(d, sdEllipsoid(p-vec3(0., 0.1, -4.40), vec3(0.50, 0.30, 2.)));\n  body=fOpUnionRound(body, sdEllipsoid(p-vec3(0., 0., .50), vec3(0.50, 0.40, 3.25)), 1.);\n  body=min(body, sdConeSection(p- vec3(0., 0., 3.8), 0.1, 0.15, 0.06));   \n\n  body=min(body, sdConeSection(p- vec3(0., 0., 3.8), 0.7, 0.07, 0.01));   \n\n  \/\/ window\n  winDist =sdEllipsoid(p-vec3(0., 0.3, -0.10), vec3(0.45, 0.4, 1.45));\n  winDist =fOpUnionRound(winDist, sdEllipsoid(p-vec3(0., 0.3, 0.60), vec3(0.3, 0.6, .75)), 0.4);\n  winDist = max(winDist, -body);\n  body = min(body, winDist);\n  body=min(body, fOpPipe(winDist, sdBox(p-vec3(0., 0., 1.0), vec3(3.0, 1., .01)), 0.03));\n  body=min(body, fOpPipe(winDist, sdBox(p-vec3(0., 0., .0), vec3(3.0, 1., .01)), 0.03));\n\n  \/\/ front (nose)\n  body=max(body, -max(fCylinder(p-vec3(0, 0, 2.5), .46, 0.04), -fCylinder(p-vec3(0, 0, 2.5), .35, 0.1)));\n  checkPos = p-vec3(0, 0, 2.5);\n  pR(checkPos.yz, 1.57);\n  body=fOpIntersectionRound(body, -sdTorus(checkPos+vec3(0, 0.80, 0), vec2(.6, 0.05)), 0.015);\n  body=fOpIntersectionRound(body, -sdTorus(checkPos+vec3(0, 2.30, 0), vec2(.62, 0.06)), 0.015);\n\n  \/\/ wings       \n  frontWingDist = MapFrontWing(p, mirrored);\n  d=min(d, frontWingDist);   \n  rearWingDist = MapRearWing(p);\n  d=min(d, rearWingDist);\n  topWingDist = MapTopWing(p, mirrored);\n  d=min(d, topWingDist);\n\n  \/\/ bottom\n  checkPos = p-vec3(0., -0.6, -5.0);\n  pR(checkPos.yz, 0.07);  \n  d=fOpUnionRound(d, sdBox(checkPos, vec3(0.5, 0.2, 3.1)), 0.40);\n\n  float holder = sdBox( p- vec3(0., -1.1, -4.30), vec3(0.08, 0.4, 0.8));  \n  checkPos = p;\n  pR(checkPos.yz, 0.85);\n  holder=max(holder, -sdBox( checkPos- vec3(0., -5.64, -2.8), vec3(1.75, 1.4, 1.0))); \n  d=fOpUnionRound(d, holder, 0.25);\n\n  \/\/ large bomb\n  bombDist2 = fCylinder( p- vec3(0., -1.6, -4.0), 0.45, 1.);   \n  bombDist2 =min(bombDist2, sdEllipsoid( p- vec3(0., -1.6, -3.20), vec3(0.45, 0.45, 2.)));   \n  bombDist2 =min(bombDist2, sdEllipsoid( p- vec3(0., -1.6, -4.80), vec3(0.45, 0.45, 2.)));   \n\n  d=min(d, bombDist2);\n\n  d=min(d, sdEllipsoid(p- vec3(1.05, 0.13, -8.4), vec3(0.11, 0.18, 1.0)));    \n\n  checkPos = p- vec3(0, 0.2, -5.0);\n  d=fOpUnionRound(d, fOpIntersectionRound(sdBox( checkPos, vec3(1.2, 0.14, 3.7)), -sdBox( checkPos, vec3(1., 1.14, 4.7)), 0.2), 0.25);\n\n  d=fOpUnionRound(d, sdEllipsoid( p- vec3(0, 0., -4.), vec3(1.21, 0.5, 2.50)), 0.75);\n\n  \/\/ engine cutout\n  blackDist = max(d, fCylinder(p- vec3(.8, -0.15, 0.), 0.5, 2.4)); \n  d=max(d, -fCylinder(p- vec3(.8, -0.15, 0.), 0.45, 2.4)); \n\n  \/\/ engine\n  d =max(d, -sdBox(p-vec3(0., 0, -9.5), vec3(1.5, 0.4, 0.7)));\n\n  engineDist=fCylinder(p- vec3(0.40, -0.1, -8.7), .42, 0.2);\n  checkPos = p- vec3(0.4, -0.1, -8.3);\n  pR(checkPos.yz, 1.57);\n  engineDist=min(engineDist, sdTorus(checkPos, vec2(.25, 0.25)));\n  engineDist=min(engineDist, sdConeSection(p- vec3(0.40, -0.1, -9.2), 0.3, .22, .36));\n\n  checkPos = p-vec3(0., 0., -9.24);  \n  checkPos.xy-=vec2(0.4, -0.1);\n  checkPos.xy = pModPolar(checkPos.xy, 22.0);\n\n  float engineCone = fOpPipe(engineDist, sdBox( checkPos, vec3(.6, 0.001, 0.26)), 0.015);\n  engineDist=min(engineDist, engineCone);\n\n  d=min(d, engineDist);\n  eFlameDist = sdEllipsoid( p- vec3(0.4, -0.1, -9.45-(speed*0.07)+cos(iTime*40.0)*0.014), vec3(.17, 0.17, .10));\n  d=min(d, eFlameDist);\n\n  d=min(d, winDist);\n  d=min(d, body);\n\n  d=min(d, sdBox( p- vec3(1.1, 0., -6.90), vec3(.33, .12, .17))); \n  checkPos = p-vec3(0.65, 0.55, -1.4);\n  pR(checkPos.yz, -0.35);\n  d=min(d, sdBox(checkPos, vec3(0.2, 0.1, 0.45)));\n\n  return min(d, eFlameDist);\n}\n\nRayHit TracePlane(in vec3 origin, in vec3 direction)\n{\n  RayHit result;\n  float maxDist = 150.0;\n  float t = 0.0, dist = 0.0;\n  vec3 rayPos;\n  eFlameDist=10000.0;\n  for ( int i=0; i<RAYSTEPS; i++ )\n  {\n    rayPos =origin+direction*t;\n    dist = MapPlane( rayPos);\n\n    if (abs(dist)<0.003 || t>maxDist )\n    {                \n      result.hit=!(t>maxDist);\n      result.depth = t; \n      result.dist = dist;                              \n      result.hitPos = origin+((direction*t));   \n      result.winDist = winDist;\n      result.engineDist = engineDist;\n      result.eFlameDist = eFlameDist;\n      result.blackDist = blackDist;\n      result.bombDist = bombDist;\n      result.bombDist2 = bombDist2;\n      result.missileDist = missileDist;\n      result.frontWingDist = frontWingDist;\n      result.rearWingDist = rearWingDist;\n      result.topWingDist = topWingDist;\n      break;\n    }\n    t += dist;\n  }\n\n  return result;\n}\n\nfloat MapLights( vec3 p)\n{\n  vec3 pOriginal = p;\n  \/\/ rotate position \n  p=TranslatePos(p, pitch, roll);   \n  \/\/ mirror position at x=0.0. Both sides of the plane are equal.\n  pMirror(p.x, 0.0);\n\n  return max(sdEllipsoid( p- vec3(0.4, -0.1, -9.5), vec3(0.03, 0.03, 0.03+max(0., (speed*0.07)))), -sdBox(p- vec3(0.4, -0.1, -9.6+2.0), vec3(2.0, 2.0, 2.0)));\n}\n\nfloat TraceLights(in vec3 origin, in vec3 direction)\n{\n  float maxDist = 150.0;\n  float t = 0.0;\n  vec3 rayPos;\n  float dist=10000.;\n\n  for ( int i=0; i<10; i++ )\n  {\n    rayPos =origin+direction*t;\n    dist = min(dist, MapLights( rayPos));\n    t += dist;\n  }\n\n  return dist;\n}\n\nvec3 calcNormal( in vec3 pos )\n{    \n  return normalize( vec3(MapPlane(pos+eps.xyy) - MapPlane(pos-eps.xyy), 0.5*2.0*eps.x, MapPlane(pos+eps.yyx) - MapPlane(pos-eps.yyx) ) );\n}\n\nfloat SoftShadow( in vec3 origin, in vec3 direction )\n{\n  float res = 2.0, t = 0.02, h;\n  for ( int i=0; i<24; i++ )\n  {\n    h = MapPlane(origin+direction*t);\n    res = min( res, 7.5*h\/t );\n    t += clamp( h, 0.05, 0.2 );\n    if ( h<0.001 || t>2.5 ) break;\n  }\n  return clamp( res, 0.0, 1.0 );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n  vec3 cu = normalize( cross(cw, cp) );\n  vec3 cv = normalize( cross(cu, cw) );\n  return mat3( cu, cv, cw );\n}\n\n\n\/\/ Advanced lightning pass\nvec3 GetSceneLight(float specLevel, vec3 normal, RayHit rayHit, vec3 rayDir, vec3 origin, float specSize)\n{          \n  float dif = clamp( dot( normal, sunPos ), 0.0, 1.0 );\n  vec3 reflectDir = reflect( rayDir, normal );\n  specLevel*= pow(clamp( dot( reflectDir, sunPos ), 0.0, 1.0 ), 9.0\/specSize);\n  vec3 reflection = vec3(texture(iChannel3, reflectDir ).r*1.5);\n\n  float fre = pow( 1.0-abs(dot( normal, rayDir )), 2.0 );\n  fre = mix( .03, 1.0, fre );   \n  float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );\n\n  vec3 shadowPos = origin+((rayDir*rayHit.depth)*0.998);\n\n  float shadow = SoftShadow(shadowPos, sunPos);\n  dif*=shadow;\n  float skyLight = smoothstep( -0.1, 0.1, reflectDir.y );\n  skyLight *= SoftShadow(shadowPos, reflectDir );\n\n  vec3 lightTot = (vec3(0.2)*amb); \n  lightTot+=vec3(0.85)*dif;\n  lightTot= mix(lightTot, reflection*max(0.3, shadow), fre );\n  lightTot += 1.00*specLevel*dif;\n  lightTot += 0.50*skyLight*vec3(0.40, 0.60, 1.00);\n  lightTot= mix(lightTot*.7, lightTot*1.2, fre );\n\n  fre = pow( 1.0-abs(dot(rayHit.normal, rayDir)), 4.0);\n  fre = mix(0., mix( .1, 1.0, specLevel*0.5), fre );\n  lightTot = mix( lightTot, lightTot+ vec3(1.6), fre );\n\n  return lightTot*sunColor;\n}\n\nfloat drawRect(vec2 p1, vec2 p2, vec2 uv) \n{\n  vec4 rect = vec4(p1, p2);\n  vec2 hv = step(rect.xy, uv) * step(uv, rect.zw);\n  return hv.x * hv.y;\n}\n\n\/\/ Thanks I\u00c3\u00b1igo Quilez!\nfloat line(vec2 p, vec2 a, vec2 b, float size)\n{\n  vec2 pa = -p - a;\n  vec2 ba = b - a;\n  float h = clamp( dot(pa, ba)\/dot(ba, ba), 0.0, 1.0 );\n  float d = length( pa - ba*h );\n\n  return clamp((((1.0+size) - d)-0.99)*100.0, 0.0, 1.0);\n}\n\nvoid AddLetters(vec2 hitPos, inout vec3 col, vec2 linePos)\n{\n  \/\/ text\n  vec3 textColor = vec3(0.2);\n  vec2 absHitPos2 = vec2(hitPos.x-1.05, hitPos.y);\n\n  pModInterval1(absHitPos2.x, 8., linePos.x, linePos.x+10.);\n\n  \/\/ E\n  col =mix(col, textColor, line(absHitPos2, linePos+vec2(1.45, 0.4), linePos+vec2(1.45, .9), 0.06));\n  col =mix(col, textColor, line(absHitPos2, linePos+vec2(1.45, 0.9), linePos+vec2(1.1, .9), 0.06));\n  col =mix(col, textColor, line(absHitPos2, linePos+vec2(1.45, 0.65), linePos+vec2(1.25, 0.65), 0.06));\n  col =mix(col, textColor, line(absHitPos2, linePos+vec2(1.45, 0.4), linePos+vec2(1.1, .4), 0.06));\n  \/\/ F            \n  col =mix(col, textColor, line(absHitPos2, linePos+vec2(0.9, 0.4), linePos+vec2(0.9, .9), 0.06));\n  col =mix(col, textColor, line(absHitPos2, linePos+vec2(0.9, 0.9), linePos+vec2(.65, .9), 0.06));\n  col =mix(col, textColor, line(absHitPos2, linePos+vec2(0.9, 0.65), linePos+vec2(.75, 0.65), 0.06));\n  \/\/ Z\n  col =mix(col, textColor, line(absHitPos2, linePos+vec2(0.45, 0.4), linePos+vec2(.1, 0.9), 0.06));\n  col =mix(col, textColor, line(absHitPos2, linePos+vec2(0.45, 0.9), linePos+vec2(.1, 0.9), 0.06));\n  col =mix(col, textColor, line(absHitPos2, linePos+vec2(0.45, 0.4), linePos+vec2(.1, 0.4), 0.06));\n}\n\n\nvec3 GetReflectionMap(vec3 rayDir, vec3 normal)\n{\n  return texture(iChannel3, reflect( rayDir, normal )).rgb;\n}\n\nvec4 GetMaterial(vec3 rayDir, inout RayHit rayHit, vec2 fragCoord, inout float specSize)\n{\n  vec3 hitPos =TranslatePos(rayHit.hitPos, pitch, roll);\n  vec2 center;\n  float dist;\n\n  float specLevel=0.7;\n  specSize=0.7;\n\n  float fre = pow( 1.0-abs(dot( rayHit.normal, rayDir )), 3.0 );\n  fre = mix( .03, 1.0, fre );   \n\n  \/\/ vec3 tint = vec3(0.62,.50,0.40)*1.15;\n  vec3 tint = vec3(1.62, 1.50, 1.30)*0.65;\n  vec3 brightCamo =1.15*tint;\n  vec3 darkCamo = 0.78*tint;\n\n\n  vec3 baseTexture = mix(brightCamo, darkCamo, smoothstep(0.5, 0.52, noise(hitPos*1.6)));\n\n  \/\/ baseTexture = col;\n  vec3 col=mix(brightCamo, darkCamo, smoothstep(0.5, 0.52, noise(hitPos*1.6)));\n  vec3 reflection = GetReflectionMap(rayDir, rayHit.normal);\n  \/\/ create base color mixes\n  vec3 lightColor = (vec3(1.0));\n  vec3 darkColor = (vec3(0.25));\n  vec3 missilBaseCol =  lightColor*0.5;\n  vec3 missilBaseCol2 =  darkColor;\n  vec3 missilCol = lightColor;\n  vec3 missilCol2 = lightColor*0.27;\n\n  if (distance(rayHit.dist, rayHit.topWingDist)<.01)\n  { \n    \/\/ top wing stripes\n    col=mix(darkColor, baseTexture, smoothstep(0.55, 0.57, distance(0.85, hitPos.y)));\n    col=mix(lightColor, col, smoothstep(.32, 0.34, distance(0.95, hitPos.y)));\n\n    \/\/ create star (top wings)    \n    center = vec2(-8.73, 0.95)-vec2(hitPos.z, hitPos.y);\n    dist = length(center); \n    col=mix(darkColor, col, smoothstep(0.24, 0.26, dist));\n    col=mix(lightColor, col, smoothstep(0.24, 0.26, (dist*1.15)+abs(cos( atan(center.y, center.x)*2.5)*0.13)));\n  } else if (distance(rayHit.dist, rayHit.winDist)<.01)\n  { \n    \/\/ windows\n    col=vec3(0.2, 0.21, 0.22)*reflection;\n    specSize=3.2;\n    specLevel=3.5;\n    fre = pow( 1.0-abs(dot(rayHit.normal, rayDir)), 3.0);\n    fre = mix( mix( .0, .01, specLevel ), mix( .4, 1.0, specLevel ), fre );\n    col = mix(col, vec3(1.5), fre );\n  } else if (distance(rayHit.dist, rayHit.missileDist)<.01)\n  {  \n    specSize=2.;\n    specLevel=2.;\n    \/\/ small missiles\n    col=mix(missilBaseCol, missilCol2, smoothstep(-3.35, -3.37, hitPos.z));\n    col=mix(col, missilCol, smoothstep(-3.2, -3.22, hitPos.z));\n    col=mix(missilCol2, col, smoothstep(.32, 0.34, distance(-4.75, hitPos.z)));\n    col=mix(missilBaseCol, col, smoothstep(.25, 0.27, distance(-4.75, hitPos.z)));\n  } else if (distance(rayHit.dist, rayHit.bombDist)<.01)\n  { \n    specSize=2.;\n    specLevel=1.7;\n    \/\/ small bombs   \n    col=mix(missilCol, missilBaseCol, smoothstep(1.18, 1.2, distance(-4.5, hitPos.z)));      \n    col=mix(col, missilCol2, smoothstep(1.3, 1.32, distance(-4.5, hitPos.z)));\n  } else if (distance(rayHit.dist, rayHit.bombDist2)<.01)\n  {   \n    specSize=2.;\n    specLevel=1.8;\n    \/\/ large bomb  \n    col=mix(missilBaseCol2, missilCol, smoothstep(1.48, 1.5, distance(-4.1, hitPos.z)));      \n    col=mix(col, missilBaseCol, smoothstep(1.6, 1.62, distance(-4.1, hitPos.z)));      \n    col=mix(missilBaseCol, col, smoothstep(0.45, 0.47, distance(-4.1, hitPos.z)));\n  } else\n  {\n    \/\/ remove camo from wing tip\n    col =mix(col, brightCamo, line(vec2(abs(hitPos.x), hitPos.z), vec2(-7.25, 5.), vec2(-1.45, 1.7), 0.3));\n\n    \/\/ color bottom gray\n    col=mix(lightColor*0.7, col, step(0.01, hitPos.y));\n\n    \/\/ front\n    col = mix(col, lightColor, smoothstep(3.0, 3.02, hitPos.z));  \n    col = mix(col, darkColor, smoothstep(3.08, 3.1, hitPos.z));\n    col =mix(col*1.4, col, smoothstep(.07, .09, distance(1.8, hitPos.z)));\n\n\n    \/\/ front wing stripes\n    col=mix(darkColor, col, smoothstep(1.4, 1.42, distance(-6.90, hitPos.z)));\n    col=mix(lightColor, col, smoothstep(1.3, 1.32, distance(-6.90, hitPos.z)));\n    col=mix(darkColor, col, smoothstep(.84, 0.86, distance(-6.7, hitPos.z)));\n    col=mix(lightColor, col, smoothstep(.22, 0.235, distance(-6.94, hitPos.z)));\n\n    \/\/ vertical stripes   \n    float xMod = mod(hitPos.x-0.5, 11.0);\n    col=mix(darkColor, col, smoothstep(0.5, 0.52, distance(5., xMod)));\n    col=mix(lightColor, col, smoothstep(0.4, 0.42, distance(5., xMod)));\n\n\n    \/\/ boxes \n    vec2 absHitPos = abs(hitPos.xz);\n\n    col =mix(col, col*1.40, drawRect(vec2(0.4, 2.0)-0.05, vec2(0.8, 2.0)+0.05+0.25, absHitPos));\n    col =mix(col, col*0.2, drawRect(vec2(0.4, 2.0), vec2(0.8, 2.0)+0.2, absHitPos));\n\n    \/\/ side 17      \n    vec2 linePos = vec2(-0.55, 0.);\n    vec3 textColor = vec3(0.2);\n    if (hitPos.x<0.)\n    {\n      col =mix(col, textColor, line(hitPos.zy, linePos+vec2(0., -0.2), linePos+vec2(0., .2), 0.04));\n      col =mix(col, textColor, line(hitPos.zy, linePos+vec2(-0.2, -0.2), linePos+vec2(-.4, -.2), 0.04));\n      col =mix(col, textColor, line(hitPos.zy, linePos+vec2(-0.4, -0.2), linePos+vec2(-.25, .2), 0.04));\n    } else\n    {\n      col =mix(col, textColor, line(hitPos.zy, linePos+vec2(-0.35, -0.2), linePos+vec2(-0.35, .2), 0.04));\n      col =mix(col, textColor, line(hitPos.zy, linePos+vec2(0.1, -0.2), linePos+vec2(-.15, -.2), 0.04));\n      col =mix(col, textColor, line(hitPos.zy, linePos+vec2(-0.15, 0.2), linePos+vec2(.10, -.2), 0.04));\n    }  \n\n    if (hitPos.y>0.15)\n    {\n      \/\/ letters BoundingBox\n      if (drawRect(vec2(3.2, 3.8)-0.05, vec2(4.9, 4.8), absHitPos)>=1.)\n      {\n        AddLetters(hitPos.xz, col, vec2(-3.70, 3.60));\n      }\n\n      \/\/ more boxes \n      col =mix(col, col*1.40, drawRect(vec2(0.2, 3.6)-0.05, vec2(1., 3.6)+0.05+0.35, absHitPos)); \n      col =mix(col, col*0.2, drawRect(vec2(0.2, 3.6), vec2(1., 3.6)+0.3, absHitPos));          \n      col =mix(col, col*0.2, drawRect(vec2(3.5, 4.8), vec2(4.5, 5.3), absHitPos));\n\n      \/\/ create star (front wings)         \n      center = vec2(5., -5.1)-vec2(xMod, hitPos.z);\n      dist = length(center);\n      col=mix(lightColor, col, smoothstep(0.8, 0.82, dist));\n      col=mix(darkColor, col, smoothstep(0.7, 0.72, dist));\n      col=mix(lightColor, col, smoothstep(0.7, 0.72, (dist*1.15)+abs(cos( atan(center.y, center.x)*2.5)*0.3)));\n      col=mix(darkColor, col, smoothstep(0.6, 0.62, (dist*1.50)+abs(cos( atan(center.y, center.x)*2.5)*0.3)));\n    } else\n    {\n      \/\/ bottom details\n      col =mix(col, darkColor, line(vec2(abs(hitPos.x), hitPos.z), vec2(0., -1.5), vec2(-0.3, -1.5), 0.06));\n      col =mix(col, darkColor, line(vec2(abs(hitPos.x), hitPos.z), vec2(-0.3, -1.5), vec2(-0.3, -1.), 0.085));\n    }\n\n    \/\/ rear wing stripes\n    col=mix(darkColor, col, smoothstep(.55, 0.57, distance(-9.6, hitPos.z)));\n    col=mix(lightColor, col, smoothstep(.5, 0.52, distance(-9.6, hitPos.z)));\n    col=mix(darkColor, col, smoothstep(.4, 0.42, distance(-9.6, hitPos.z)));\n\n    \/\/ esm pods\n    col = mix(col, lightColor*0.75, smoothstep(7.02, 7.04, abs(hitPos.x)));\n\n    \/\/ stabilizer\n    col = mix(col, lightColor*0.75, smoothstep(1.72, 1.74, abs(hitPos.y)));\n\n    \/\/ engines exhaust\n    col=mix(mix(vec3(0.7), reflection, fre), col, step(.05, rayHit.engineDist));\n    specSize=mix(4., specSize, step(.05, rayHit.engineDist));\n    col=mix(col*0.23, col, step(.02, rayHit.blackDist));\n    col=mix(col+0.5, col, smoothstep(.04, 0.10, distance(2.75, hitPos.z)));\n  }\n  fre = pow( 1.0-abs(dot(rayHit.normal, rayDir)), 7.0);\n  fre = mix( 0., mix( .2, 1.0, specLevel*0.5 ), fre );\n  col = mix( col, vec3(1.0, 1.0, 1.1)*1.5, fre );\n\n  return vec4(col, specLevel);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n  vec2 mo = iMouse.xy\/iResolution.xy;\n  vec2 uv = fragCoord.xy \/ iResolution.xy;\n  vec2 screenSpace = (-iResolution.xy + 2.0*(fragCoord))\/iResolution.y;\n  vec2 cloudPos = vec2(-iTime*1.3, -iTime*.95);\n  float CAMZOOM = read(ivec2(52, 0));  \n\n  \/\/ read missile data\n  missilesLaunched = vec2(read(ivec2(100, 0)), read(ivec2(200, 0)));\n\n  \/\/ read roll and speed values from buffer\n  turn = read(ivec2(1, 10));\n  roll = read(ivec2(1, 1));\n  speed = read(ivec2(10, 1));\n  pitch = read(ivec2(15, 1));\n  rudderAngle = read(ivec2(6, 1));\n  sunPos = readRGB(ivec2(50, 0));\n  planePos = readRGB(ivec2(55, 0));\n  pR(sunPos.xz, turn);\n\n  \/\/ setup camera and ray direction\n  vec2 camRot = readRGB(ivec2(57, 0)).xy;\n\n  vec3 rayOrigin = vec3(CAMZOOM*cos(camRot.x), CAMZOOM*sin(camRot.y), -3.+CAMZOOM*sin(camRot.x) );\n  mat3 ca = setCamera( rayOrigin, vec3(0., 0., -3. ), 0.0 );\n  vec3 rayDir = ca * normalize( vec3(screenSpace.xy, 2.0) );\n\n  \/\/ load background from buffer A\n  vec4 color =  texture(iChannel0, uv);\n\n  \/\/ calculate engine flare\n  float lightDist = TraceLights(rayOrigin, rayDir);\n    \n  vec3 lightFlares = vec3(0.);\n  lightFlares =  mix((vec3(1., 0.4, 0.2)), vec3(0.), smoothstep(0., .35, lightDist));             \n  lightFlares =  mix(lightFlares+(2.*vec3(1., 0.5, 0.2)), lightFlares, smoothstep(0., 0.15, lightDist));\n  lightFlares =  mix(lightFlares+vec3(1., 1., 1.), lightFlares, smoothstep(0., 0.08, lightDist));\n  RayHit marchResult = TracePlane(rayOrigin, rayDir);\n\n  if (marchResult.hit)\n  {\n    float specSize=1.0;\n\n    marchResult.normal = calcNormal(marchResult.hitPos); \n\n    \/\/ create texture map and set specular levels\n    color = GetMaterial(rayDir, marchResult, fragCoord, specSize);\n\n    if (marchResult.dist != marchResult.eFlameDist)\n    {\n      \/\/ get lightning based on material\n      vec3 light = GetSceneLight(color.a, marchResult.normal, marchResult, rayDir, rayOrigin, specSize);   \n\n      \/\/ cloud shadows on plane if below cloud level\n      if (planePos.y<=-CLOUDLEVEL)\n      {  \n        \/\/ get cloud shadows at rayMarch hitpos\n        float clouds =clamp(max(0., -0.15+noise(marchResult.hitPos+planePos+vec3(cloudPos.x, 0., cloudPos.y))), 0., 1.)*.5;\n\n        color.rgb*= 1.0-clouds;\n        \/\/ sun light  \n        color.rgb*= 1.+(clouds);\n      }   \n\n      \/\/ apply lightning\n      color.rgb *=light;\n\n      \/\/ balance colors\n      color.rgb = pow(color.rgb, vec3(1.0\/1.1));\n    }\n\n    color.rgb = mix(color.rgb, vec3(0.3, 0.5, 0.7), 0.1);    \n    color.a=1.0;  \n\n    lightFlares = mix(lightFlares, lightFlares*0., step(0.1, distance(marchResult.dist, marchResult.eFlameDist)));\n  }\n\n  color.rgb+=lightFlares;\n  fragColor = color;\n}\n",
            "name": "Buf C",
            "description": "",
            "type": "buffer"
        }
    ]
}