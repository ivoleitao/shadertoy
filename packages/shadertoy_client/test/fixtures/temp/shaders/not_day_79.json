{
    "ver": "0.1",
    "info": {
        "id": "tlySDV",
        "date": "1583601981",
        "viewed": 1829,
        "name": "Not Day 79",
        "username": "jeyko",
        "description": "hm",
        "likes": 58,
        "published": 3,
        "flags": 0,
        "usePreview": 0,
        "tags": [
            "mdtmjvm"
        ],
        "hasliked": 0
    },
    "renderpass": [
        {
            "inputs": [
                {
                    "id": "Xsf3zn",
                    "filepath": "\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
                    "previewfilepath": "\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
                    "type": "texture",
                    "channel": 0,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dfGRr",
                    "channel": 0
                }
            ],
            "code": "\/\/ Sorry I changed the shader, I just really don't like the one original day 79.\n\/\/ I've commented the old one if you would like to see it.\n\n\/\/ So this is actually Day 110\n\n#define tsp iTime + 1.1\n\n\n#define pmod(p,z) mod(p,z) - 0.5*z\n#define dmin(a,b) a.x < b.x ? a : b\n#define pi acos(-1.)\n#define tau (2.*pi)\n\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x)) \n#define pal(a,b,c,d,e) ((a) + (b)*sin((c)*(d) + (e)))\nvec3 glow = vec3(0);\n\nvec3 path (float z){\n    z *= 0.29;\n\treturn vec3(0. + sin(z),0. + cos(z),0.)*1.;\n}\n\nfloat sdBox(vec3 p, vec3 s){\n\tp = abs(p) - s;\n\treturn max(p.y, max(p.z,p.x));\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)\/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)\/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)\/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nvec2 map(vec3 p){\n\tvec2 d= vec2(10e7);\n    \n    vec3 k = p;\n    p -= path(p.z);\n    \n    \n    p.z *= 0.5;\n    \n    \n    vec3 par = vec3(2.8,2.14,0.9);\n    vec4 q = vec4(p.xyz, 1.);\n    \n    \n    for(float i = 0.; i < 9.;i++){\n        q.xyz = abs(mod(q.xyz - par*0.5,par) - 0.5*par);\n        \n    \tfloat dpp = dot(q.xyz, q.xyz);\n        \n        q.xy *= rot(0.4);\n        q = q\/dpp;\n    }\n    \n    float dF = length(q.xz)\/q.w;\n    d.x = min(d.x, dF);\n    \n    d.x = opSmoothIntersection( d.x, -length(p.xy) + 0.36 , 0.4 );\n    \n    d.x -= 0.04;\n    d.x = abs(d.x) + 0.003;\n    glow -= 0.1\/(0.001 + d.x*d.x*200.);\n    \n    \n    \n    float dL = length(q.zx)\/q.w;\n\n    d.x = max(d.x,  -length(p.xy) + 0.2 );\n    \n    d.x *= 0.45;\n    \n    \n    return d;\n}\n\nfloat dith;\n\nvec2 march(vec3 ro, vec3 rd, inout vec3 p, inout float t, inout bool hit){\n\tvec2 d = vec2(10e7);\n    \n    p = ro;; t = 0.; hit = false;\n    \n    for(float i = 0.; i < 150.; i++){\n    \td = map(p)*dith;\n        float eps = 0.001 + 0.001*5.0*pow(float(i)\/200.0,2.0);\n        if(d.x < eps){\n            t += 0.005;\n        }\n        \n    \tt += d.x;\n        p = ro + rd*t;\n    }\n    return d;\n}\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up = normalize(cross(dir, right));\n    return normalize(dir + right*uv.x + up*uv.y);\n}\n\nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.001, 0.);\n    return -normalize(vec3(\n        map(p - t.xyy).x - map(p + t.xyy).x,\n        map(p - t.yxy).x - map(p + t.yxy).x,\n        map(p - t.yyx).x - map(p + t.yyx).x\n    ));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)\/iResolution.y;\n\n    uv *= rot(sin(iTime*0.5)*0.6);\n    \n    uv *= 1. - dot(uv,uv)*.1;\n    \n    dith = mix(0.95,1.,texture(iChannel0,iResolution.xy*(uv + iTime*10.)\/256.).x);\n    \n    vec3 col = vec3(0);\n\n\tvec3 ro = vec3(0);\n    \n    ro.z += iTime*1.7 + 0.1;\n    \n    ro += path(ro.z);\n    \n    vec3 lookAt = vec3(0);\n    lookAt.z = ro.z + 2.;\n    lookAt += path(lookAt.z + .5);\n    \n    vec3 rd = getRd(ro, lookAt,uv);\n    \n    \n    vec3 p; float t; bool hit;\n    vec2 d = march(ro, rd, p, t, hit);\n    \n    col += glow*0.001;\n    \n    vec3 fc = pal(0.6,0.5,vec3(1.,0.5,0.6) + cos(rd.xyz)*1., 1.7  - dot(uv,uv)*0.2,-2.1 - dot(uv,uv)*0.2);\n    fc = max(fc,0.);\n    col = mix(col,fc, smoothstep(0.,1.,t*0.1));\n    \n    fragColor = vec4(col,1.0);\n}\n\n\/\/ The following comment is Day 79\n\n\/*\n\n\n\/\/ Made shader having not slept for 2 days (was in a game jam) \n\/\/ in like 30 minutes. \n\/\/ not really something I thought about or put much effort in. \n\n#define pmod(p,x) (mod(p,x) - 0.5*x)\n#define dmin(a,b) a.x < b.x ? a : b\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n#define pal(a,b,c,d,e) ((a) + (b)*sin(tau*((c)*(d) + e)))\n\n#define coolPal(a,b) pal(0.5,0.6,vec3(0.97 + sin(iTime*0.02 + p.z*0.04),3.4 + sin(b)*0.2,0.8),0.4 + (a),3.3 + (b))\n#define tunnW 0.8\n\n#define mx (10.*iMouse.x\/iResolution.x)\n#define my (10.*iMouse.y\/iResolution.x)\n\n#define pi acos(-1.)\n#define tau (2.*pi)\n\n\n\/\/ The \"Stairs\" flavour produces n-1 steps of a staircase:\n\/\/ much less stupid version by paniq\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r\/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\n\n\/\/ We can just call Union since stairs are symmetric.\nfloat fOpIntersectionStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, -b, r, n);\n}\n\nfloat fOpDifferenceStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, b, r, n);\n}\nvec3 glow = vec3(0);\nvec3 glowFog = vec3(0);\nvec3 glowCol = vec3(0);\n\n\nfloat sdSphere(vec3 p, float s){\n\treturn length(p) -s;\n}\nfloat sdBox(vec3 p, vec3 r){\n    p = abs(p) - r;\n\treturn max(p.x, max(p.y, p.z));\n}\n\nvec4 valueNoise(float t){\n\treturn mix(texture(iChannel0, vec2(t)\/256.),texture(iChannel0, vec2(t+1.)\/256.),smoothstep(0.,1.,fract(t)));\n}\n\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e6);\n\t\n    p.xy *= rot(p.z*0.3);\n    vec3 z = p;\n    #define modDist 2.\n    \n    vec3 id = floor(p\/modDist )- max(sign(vec3(p.x,p.y,p.z)), 0.);\n   \tp -= modDist*0.5;\n    \n    p = pmod(p , modDist);\n    \n    vec3 q = p;\n    \n    q = abs(q);\n    q -= modDist*0.5;\n    \n    for(int i = 0; i < 3; i++){\n    \n    \tq = abs(q);\n        q.x-= 0.1;\n        \n        q.xz *= rot(0.25*pi);\n        q.yz *= rot(0.25*pi);\n    }\n    \n    float cube = sdBox(q, vec3(0.5));\n    \n    \/\/sph = fOpIntersectionStairs(sph, -length(p.xz) + 0.1,5.,0.1);\n    d = dmin(d, vec2(cube, 0.));\n    \n    float cubeWalls = cube - 0.06;\n    cubeWalls = max(cubeWalls, -sdBox(q, vec3(0.4,0.4,0.6)));\n    cubeWalls = max(cubeWalls, -sdBox(q, vec3(0.4,0.6,0.4)));\n    cubeWalls = max(cubeWalls, -sdBox(q, vec3(0.6,0.4,0.4)));\n    \n    d = dmin(d, vec2(cubeWalls, 2.));\n    \n    \n    \n    float ball = sdSphere(abs(p) - vec3(modDist*0.5,0,modDist*0.5),0.1);\n    d = dmin(d, vec2(ball, 1.));\n    \n    \n    vec4 n = valueNoise(id.x + id.z + iTime);\n    \n    vec3 c = pal(0.8,0.9,vec3(0.6,0.2+ abs(sin(z.x*0.5 +iTime*0.3))*0.6,0.5),0.4,3.7 + sin(z.z)*0.1);\n    c = max(c, 0.);\n    glow += min(exp(-max(ball, 0.)*6.)*4. * pow(n.x,5.)*40.*c, 3.);\n\n    \n    \n    \/\/ TUBE\n    \n    vec3 pC = vec3(atan(p.x,p.z)\/tau,length(p.xz), p.y);\n    \n    pC.x = pmod(pC.x, 0.1);\n    \n    pC.y -= 1.05;\n    \n    pC.y += pow(smoothstep(0.,1.,abs(p.y)*0.8), 1.7)*0.8;\n    \n    \/\/pC.y += pow(abs(p.y), 1.2);\n    \n    float glowTube = max(abs(pC.x),abs(pC.y)) - 0.01;\n    \n    glowTube = max(glowTube, -length(vec3(pC.x*3., pC.y - 0.02, pmod(pC.z, 0.3))) + 0.04);\n    \/\/glowTube = max(glowTube, 0.);\n    glow += exp(-glowTube*190.)*max(pal(0.4,0.6,vec3(0.,0.5,0.7),0.8,0.7 + sin(p.z)), 0.)*3.;\n    \n    d = dmin(d,vec2(glowTube + 0.02, 0.));\n    \n    \n    d.x *= 0.5;\n    return d;\n}\n\nfloat N;\nvec2 march(vec3 ro, vec3 rd,inout vec3 p,inout float t,inout bool hit){\n\tvec2 d = vec2(10e6);\n\tt = 0.; hit = false; p = ro;\n    \n    \n\tfloat a = mix(0.8,1.,N); \/\/ remove banding from glow\n    \n    for(int i = 0; i < 150; i++){\n    \td = map(p)*a;\n        glowFog += exp(-d.x*50.);\n        if(d.x < 0.001 || t > 10.){\n        \thit = true;\n            break;\n        }\n    \tt += d.x;\n        p = ro + rd*t;\n    }\n    \n    \n    return d;\n}\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n\tvec3 dir = normalize(lookAt - ro);\n\tvec3 right = cross(vec3(0,1,0), dir);\n\tvec3 up = cross(dir, right);\n    float fov = 1. + sin(iTime)*0.;\n\treturn normalize(dir + right*uv.x*fov + up*uv.y*fov);\n}\nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.001, 0.);\n    return normalize(map(p).x - vec3(\n    \tmap(p-t.xyy).x,\n    \tmap(p-t.yxy).x,\n    \tmap(p-t.yyx).x\n    ));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)\/iResolution.y;\n\tN = texture(iChannel0,(uv)*256.).x*1.;\n    uv *= 1. + dot(uv,uv)*0.25;\n    vec3 col = vec3(0);\n\n    vec3 ro = vec3(0);\n    \n    vec3 lookAt = vec3(0);\n    \n    ro.z += iTime*1.;\n    lookAt.z = ro.z + 2.;\n    \n    ro.xz += vec2(\n    \tsin(iTime),\n    \tcos(iTime)\n    )*0.1;\n    \n    \n    \n    vec3 rd = getRd(ro, lookAt, uv);\n\n    \/\/rd.xz *= rot(sin(0.5*pi*(floor(iTime*0.125) + pow(smoothstep(0.,1.,fract(iTime*0.125)), 2.5))));\n    float t; bool hit; vec3 p;\n    \n    vec2 d = march(ro, rd, p, t, hit);\n    \n    \n    if (hit){\n    \tvec3 n = getNormal(p);\n    \n        vec3 ld = normalize(vec3(1));\n        \n        \/\/col += 0.7 + n;\n        float diff = max(dot(ro,ld), 0.);\n        float fres = pow(1. - max(dot(n,-rd), 0.), 5.);\n        float spec = pow(max(dot(n, normalize(ld - rd)), 0.), 20.);\n        \n            float ao = clamp(map(p + n*0.5).x\/0.5,0.,1.);\n        if(d.y == 2.){\n        \tcol += min(diff*fres, 1.)*0.5*vec3(0.2,0.2,0.4);\n        \n        }\n        if(d.y == 0.){\n        \tcol += min(diff*fres, 1.)*0.4*vec3(0.4,0.3,0.62) + spec*vec3(0.4,0.,0.2)*0.1;\n        \t\n        }\n        \n        col *= ao*0.5 + 0.25;\n    }\n    \n    col += glow*0.01;\n    \n    col = mix(col, vec3(0.3,0.,0.6)*0.1, smoothstep(0.,1., t*0.12));\n    col += vec3(0.3,0.,0.1)*0.01*smoothstep(0.,1., t*0.12)*glowFog;\n    col = max(col, 0.);\n    col = col*0. + smoothstep(0.,1.,col)*0.8;\n    col = pow(col, vec3(0.4545 + dot(uv,uv)*0.15));\n    \n    \n    fragColor = vec4(col,1.0);\n}\n*\/",
            "name": "Image",
            "description": "",
            "type": "image"
        }
    ]
}