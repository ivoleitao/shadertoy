{
    "ver": "0.1",
    "info": {
        "id": "wtfBDf",
        "date": "1597929249",
        "viewed": 10096,
        "name": "Warped Extruded Skewed Grid",
        "username": "Shane",
        "description": "A warped extruded skewed dual tile grid, rendered in an early 2000s demoscene style. :)",
        "likes": 208,
        "published": 3,
        "flags": 0,
        "usePreview": 0,
        "tags": [
            "grid",
            "demo",
            "square",
            "quad",
            "extruded",
            "dystopian",
            "skewed"
        ],
        "hasliked": 0
    },
    "renderpass": [
        {
            "inputs": [
                {
                    "id": "XsX3Rn",
                    "filepath": "\/media\/a\/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg",
                    "previewfilepath": "\/media\/ap\/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg",
                    "type": "texture",
                    "channel": 0,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dfGRr",
                    "channel": 0
                }
            ],
            "code": "\/*\n\n    Warped Extruded Skewed Grid\n    ---------------------------\n\n    This is a warped extruded skewed grid, rendered in an early 2000s demoscene \n    style. In particular, the grid cell centers have been skewed into position, \n    then two different sized nonskewed squares have been constructed around them\n    to form a pinwheel arrangement.\n\n\tI've been putting up a bunch of tech-like examples lately, so to break the\n\tmonotony for myself, I decided to code something artsy and more reminiscent \n    of a cliche 2000s demo scene. A lot of 2000s demos were rendered in a grungey \n    dystopian graphic art style, so I kind of went with that. On the technical \n    side, it's a demonstration of grid construction consisting of two different \n    kinds of tiles rendered in a staggered fashion. There's nothing in here \n    that's particularly difficult to implement.\n\n\tOne of the many things I've always admired about demo coders in general is \n    their ability to identify the most visually enticing effects that can be\n    produced with the least amount of effort on whatever machine they're running \n    on.\n\n\tI've attempted to emulate that philosophy by employing a few simple \n    techniques that demoscoders take for granted. These include things like\n    rendering minor details outside the main loop and concentrating on the cheap \n    aspects that have the largest visual impact, like color palettes and camera \n    motion.\n\n    Decent color palettes and textures usually account for a large part of the \n    the final image, and they cost virtually nothing. Camera movements can add \n    interest to a scene, and in the grand scheme of things are very cheap to \n    implement. Warping space can be a little fiddly, especially when positioning \n    lights and so forth, but it's also cheap and interesting, so I've made use\n    of that too.\n\n    The only thing here that I'd consider new is the grid arrangement. I like it \n    because it's a completely ordered grid that looks randomized in height map \n    form, which makes it visually interesting and relatively cheap to produce. \n    Having said that, there are still 8 taps and some skewing involved, so it's \n    probably not the kind of scene that a slow system would be happy with.\n\n    The frame rate in window form was surprisingly better than I'd expected. \n    Having said that, I'm on a pretty quick machine, and it doesn't like running \n    in fullscreen, so it's all relative. There are at least two things that could\n    improve performance (like face and height storage), but that would be at the \n    expense of readability, so I'm going to leave it alone.\n\n    By the way, for anyone interested in just the grid code, I'll put up a much\n\tsimpler example later.\n\n\n\n    More interesting tilings:\n\n    \/\/ Tiling on steroids. Very cool.\n    Wythoffian Tiling Generator - mla\n    https:\/\/www.shadertoy.com\/view\/wlGSWc\n    \/\/\n    Based on:\n    \/\/ \n\tWythoff Uniform Tilings + Duals - fizzer\n\thttps:\/\/www.shadertoy.com\/view\/3tyXWw\n    \/\/\n    Tilings - knighty\n    https:\/\/www.shadertoy.com\/view\/4sf3zX\n\n\n*\/\n\n\n#define SKEW_GRID\n\n\/\/ Snap the pylons to discreet height units. It looks neater, but I wanted \n\/\/ haphazored heights, so it's off by default.\n\/\/#define QUANTIZE_HEIGHTS\n\n\/\/ Flattening the grid in order to discern the 2D face pattern more clearly.\n\/\/#define FLAT_GRID\n\n\/\/ Grid positioning independant of the camera path.\n\/\/#define PTH_INDPNT_GRD\n\n\/\/ Grayscale, for that artsy look. Technically, a touch of color has been \n\/\/ left in, but the palette has a gray feel.\n\/\/#define GRAYSCALE\n\n\/\/ Reverse the color palette.\n\/\/#define REVERSE_PALETTE\n\n\/\/ Max ray distance: If deliberately set this up close for artistic effect (and to\n\/\/ save a few cycles), but you'd normally set this higher to put the horizon further away.\n#define FAR 20.\n\n\n\n\/\/ Scene object ID to separate the floor object from the pylons.\nfloat objID;\n\n\n\/\/ Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n\/\/ IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n\/\/ vec3 to float.\nfloat hash31(vec3 p){\n    return fract(sin(dot(p, vec3(12.989, 78.233, 57.263)))*43758.5453);\n}\n\n\n\/\/ The path is a 2D sinusoid that varies over time, which depends upon the frequencies and amplitudes.\nvec2 path(in float z){ \n    \n    \/\/return vec2(0);\n    return vec2(3.*sin(z*.1) + .5*cos(z*.4), 0);\n}\n\n\n\/\/ 2D texture function.\n\/\/\nvec3 getTex(in vec2 p){\n    \n    \/\/ Stretching things out so that the image fills up the window.\n    \/\/p *= vec2(iResolution.y\/iResolution.x, 1);\n    vec3 tx = texture(iChannel0, p\/8.).xyz;\n    \/\/vec3 tx = textureLod(iChannel0, p, 0.).xyz;\n    return tx*tx; \/\/ Rough sRGB to linear conversion.\n}\n\n\/\/ Height map value, which is just the pixel's greyscale value.\nfloat hm(in vec2 p){ return dot(getTex(p), vec3(.299, .587, .114)); }\n\n\n\/\/ IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h, in float sf){\n    \n    \/\/ Slight rounding. A little nicer, but slower.\n    vec2 w = vec2( sdf, abs(pz) - h - sf\/2.);\n  \treturn min(max(w.x, w.y), 0.) + length(max(w + sf, 0.)) - sf;    \n}\n\n\/*\n\/\/ IQ's unsigned box formula.\nfloat sBoxSU(in vec2 p, in vec2 b, in float sf){\n\n  return length(max(abs(p) - b + sf, 0.)) - sf;\n}\n*\/\n\n\/\/ IQ's signed box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  p = abs(p) - b + sf;\n  return length(max(p, 0.)) + min(max(p.x, p.y), 0.) - sf;\n}\n\n\/\/ Skewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 skewXY(vec2 p, vec2 s){\n    \n    return mat2(1, -s.y, -s.x, 1)*p;\n}\n\n\/\/ Unskewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 unskewXY(vec2 p, vec2 s){\n\n    return inverse(mat2(1, -s.y, -s.x, 1))*p;\n}\n\n\n\/\/ A dual face extruded block grid with additional skewing. This particular one\n\/\/ is rendered in a pinwheel arrangement.\n\/\/\n\/\/ The idea is very simple: Produce a skewed grid full of packed objects.\n\/\/ That is, use the center pixel of each object within the cell to obtain a height \n\/\/ value (read in from a height map), then render a pylon at that height.\n \n\/\/ Global local coordinates. It's lazy putting them here, but I'll tidy this up later.\nvec2 gP;\n\n\nvec4 blocks(vec3 q){\n\n    \n    \/\/ Scale... Kind of redundant here, but sometimes there's a distinction\n    \/\/ between scale and dimension.\n\tconst vec2 scale = vec2(1.\/5.);\n\n    \/\/ Block dimension: Length to height ratio with additional scaling.\n\tconst vec2 dim = scale;\n    \/\/ A helper vector, but basically, it's the size of the repeat cell.\n\tconst vec2 s = dim*2.;\n    \n    \n    #ifdef SKEW_GRID\n    \/\/ Skewing half way along X, and Y.\n    const vec2 sk = vec2(-.5, .5);\n    #else\n    const vec2 sk = vec2(0);\n    #endif\n    \n    \/\/ Distance.\n    float d = 1e5;\n    \/\/ Cell center, local coordinates and overall cell ID.\n    vec2 p, ip;\n    \n    \/\/ Individual brick ID.\n    vec2 id = vec2(0);\n    vec2 cntr = vec2(0);\n    \n    \/\/ Four block corner postions.\n    const vec2[4] ps4 = vec2[4](vec2(-.5, .5), vec2(.5), vec2(.5, -.5), vec2(-.5)); \n    \n    \/\/ Height scale.\n    #ifdef FLAT_GRID\n    const float hs = 0.; \/\/ Zero height pylons for the flat grid.\n    #else\n    const float hs = .4;\n    #endif\n    \n    float height = 0.; \/\/ Pylon height.\n\n\n    \/\/ Local cell coordinate copy.\n    gP = vec2(0);\n    \n    for(int i = 0; i<4; i++){\n\n        \/\/ Block center.\n        cntr = ps4[i]\/2. -  ps4[0]\/2.;\n        \n        \/\/ Skewed local coordinates.\n        p = skewXY(q.xz, sk);\n        ip = floor(p\/s - cntr) + .5; \/\/ Local tile ID.\n        p -= (ip + cntr)*s; \/\/ New local position.\n        \n        \/\/ Unskew the local coordinates.\n        p = unskewXY(p, sk);\n        \n        \/\/ Correct positional individual tile ID.\n        vec2 idi = ip + cntr;\n \n        \n        \/\/ Unskewing the rectangular cell ID.\n\t    idi = unskewXY(idi*s, sk); \n        \n \n        \/\/ The larger grid cell face.\n        \/\/\n        vec2 idi1 = idi; \/\/ Block's central position, and ID.\n        float h1 = hm(idi1);\n        #ifdef QUANTIZE_HEIGHTS\n        h1 = floor(h1*20.999)\/20.; \/\/ Discreet height units.\n        #endif\n        h1 *= hs; \/\/ Scale the height.\n        \n        \/\/ Larger face and height extrusion.\n        float face1 = sBoxS(p, 2.\/5.*dim - .02*scale.x, .015);\n        \/\/float face1 = length(p) - 2.\/5.*dim.x;\n        float face1Ext = opExtrusion(face1, q.y + h1, h1, .006); \n    \n        \n        \/\/ The second, smaller face.\n        \/\/\n        \/\/vec2 offs = vec2(3.\/5., -1.\/5.)*dim;\n        vec2 offs = unskewXY(dim*.5, sk);\n        vec2 idi2 = idi + offs;  \/\/ Block's central position, and ID.\n        float h2 = hm(idi2);\n        #ifdef QUANTIZE_HEIGHTS\n        h2 = floor(h2*20.999)\/20.; \/\/ Discreet height units.\n        #endif\n        h2 *= hs; \/\/ Scale the height.\n     \n        \/\/ Smaller face and height extrusion.\n        float face2 = sBoxS(p - offs, 1.\/5.*dim - .02*scale.x, .015);\n        \/\/float face2 = length(p - offs) - 1.\/5.*dim.x;\n        float face2Ext = opExtrusion(face2, q.y + h2, h2, .006);\n         \n        \/\/ Pointed face tips, for an obelisque look, but I wasn't feeling it. :)\n        \/\/face1Ext += face1*.25;\n        \/\/face2Ext += face2*.25;\n        \n        vec4 di = face1Ext<face2Ext? vec4(face1Ext, idi1, h1) : vec4(face2Ext, idi2, h2);\n   \n        \n        \n        \/\/ If applicable, update the overall minimum distance value,\n        \/\/ ID, and box ID. \n        if(di.x<d){\n            d = di.x;\n            id = di.yz;\n            height = di.w;\n            \n            \/\/ Setting the local coordinates: This is hacky, but I needed a \n            \/\/ copy for the rendering portion, so put this in at the last minute.\n            gP = p;\n     \n        }\n        \n    }\n    \n    \/\/ Return the distance, position-based ID and pylong height.\n    return vec4(d, id, height);\n}\n\nfloat getTwist(float z){ return z*.08; }\n\n\n\n\/\/ Block ID -- It's a bit lazy putting it here, but it works. :)\nvec3 gID;\n\n\/\/ Speaking of lazy, here's some global glow variables. :D\n\/\/ Glow: XYZ is for color (unused), and W is for individual \n\/\/ blocks.\nvec4 gGlow = vec4(0);\n\n\/\/ The extruded image.\nfloat map(vec3 p){\n    \n    \/\/ Wrap the scene around the path. This mutates the geometry,\n    \/\/ but it's easier to implement. By the way, it's possible to\n    \/\/ snap the geometry around the path, and I've done that in\n    \/\/ other examples.\n    p.xy -= path(p.z);\n    \n    \/\/ Twist the geometry along Z. It's cheap and visually effective.\n    \/\/ Demosceners having been doing this for as long as I can remember.\n    p.xy *= rot2(getTwist(p.z));\n\n    \n    \/\/ Turning one plane into two. It's an old trick.\n    p.y = abs(p.y) - 1.25;\n  \n    \/\/ There are gaps between the pylons, so a floor needs to go in\n    \/\/ to stop light from getting though.\n    float fl = -p.y + .01;\n    \n    #ifdef PTH_INDPNT_GRD\n    \/\/ Keep the blocks independent of the camera movement, but still \n    \/\/ twisting with warped space.\n    p.xy += path(p.z);\n    #endif\n    \n    \/\/ The extruded blocks.\n    vec4 d4 = blocks(p);\n    gID = d4.yzw; \/\/ Individual block ID.\n    \n    \/\/ Only alowing certain blocks to glow. We're including some \n    \/\/ animation in there as well.\n    float rnd = hash21(gID.xy);\n    \/\/\n    \/\/ Standard blinking lights animation.\n    gGlow.w = smoothstep(.992, .997, sin(rnd*6.2831 + iTime\/4.)*.5 + .5);\n    \/\/gGlow.w = rnd>.05? 0. : 1.; \/\/ Static version.\n \n \n    \/\/ Overall object ID.\n    objID = fl<d4.x? 1. : 0.;\n    \n    \/\/ Combining the floor with the extruded blocks.\n    return min(fl, d4.x);\n \n}\n\n  \n\/\/ Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    \/\/ Overall ray distance and scene distance.\n    float t = 0., d;\n     \n    \/\/ Zero out the glow.\n    gGlow = vec4(0);\n    \n    \/\/ Random dithering -- This is on the hacky side, but we're trying to cheap out \n    \/\/ on the glow by calculating it inside the raymarching loop instead of it's \n    \/\/ own one. If the the jump off point was too close to the closest object in the\n    \/\/ scene, you wouldn't do this.\n    t = hash31(ro.zxy + rd.yzx)*.25;\n    \n    for(int i = 0; i<128; i++){\n    \n        d = map(ro + rd*t); \/\/ Distance function.\n        \n        \/\/ Adding in the glow. There'd be better and worse ways to do it.\n        float ad = abs(d + (hash31(ro + rd) - .5)*.05);\n        const float dst = .25;\n        if(ad<dst){\n            gGlow.xyz += gGlow.w*(dst - ad)*(dst - ad)\/(1. + t);\n        }\n \n        \/\/ Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        \/\/ \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001*(1. + t*.05) || t>FAR) break; \/\/ Alternative: 0.001*max(t*.25, 1.), etc.\n        \n        t += i<32? d*.4 : d*.7; \n        \/\/t += d*.5; \n    }\n\n    return min(t, FAR);\n}\n\n\n\/\/ Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p){\n\t\n    const vec2 e = vec2(.001, 0);\n    \n    \/\/vec3 n = normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n    \/\/map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n    \n    \/\/ This mess is an attempt to speed up compiler time by contriving a break... It's \n    \/\/ based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = 0; i<6; i++){\n\t\tmp[i] = map(p + sgn*e6[i\/2]);\n        sgn = -sgn;\n        if(sgn>2.) break; \/\/ Fake conditional break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\n\n\n\/\/ Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n\/\/ iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    \/\/ More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int iter = 24; \n    \n    ro += n*.0015;\n    vec3 rd = lp - ro; \/\/ Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.;\/\/.0015; \/\/ Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    \/\/float stepDist = end\/float(maxIterationsShad);\n    rd \/= end;\n\n    \/\/ Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    \/\/ number to give a decent shadow is the best one to choose. \n    for (int i = 0; i<iter; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d\/t);\n        \/\/shade = min(shade, smoothstep(0., 1., k*h\/dist)); \/\/ Subtle difference. Thanks to IQ for this tidbit.\n        \/\/ So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        \/\/ Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    \/\/ Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    \/\/ It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    \/\/ AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n\/\/ I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n\/\/ Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 3., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15\/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n}\n\n\/*\n\/\/ Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n\/\/ example that explains it, if you require it.\nfloat n3D(in vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); \/\/p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); \/\/ Range: [0, 1].\n}\n\n\/\/ Very basic pseudo environment mapping... and by that, I mean it's fake. :) However, it \n\/\/ does give the impression that the surface is reflecting the surrounds in some way.\n\/\/\n\/\/ More sophisticated environment mapping:\n\/\/ UI easy to integrate - XT95    \n\/\/ https:\/\/www.shadertoy.com\/view\/ldKSDm\nvec3 envMap(vec3 p){\n    \n    p *= 6.;\n    p.y += iTime;\n    \n    float n3D2 = n3D(p*2.);\n   \n    \/\/ A bit of fBm.\n    float c = n3D(p)*.57 + n3D2*.28 + n3D(p*4.)*.15;\n    c = smoothstep(.45, 1., c); \/\/ Putting in some dark space.\n    \n    p = vec3(c, c*c, c*c*c*c); \/\/ Bluish tinge.\n    \n    return mix(p, p.xzy, n3D2*.4); \/\/ Mixing in a bit of purple.\n\n}\n*\/ \n \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    \/\/ Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)\/iResolution.y;\n\t\n\t\/\/ Camera Setup.\n\tvec3 ro = vec3(0, 0, iTime*1.5); \/\/ Camera position, doubling as the ray origin.\n    ro.xy += path(ro.z); \n    vec2 roTwist = vec2(0, 0);\n    roTwist *= rot2(-getTwist(ro.z));\n    ro.xy += roTwist;\n    \n\tvec3 lk = vec3(0, 0, ro.z + .25); \/\/ \"Look At\" position.\n    lk.xy += path(lk.z); \n    vec2 lkTwist = vec2(0, -.1); \/\/ Only twist horizontal and vertcal.\n    lkTwist *= rot2(-getTwist(lk.z));\n    lk.xy += lkTwist;\n    \n\tvec3 lp = vec3(0, 0, ro.z + 3.); \/\/ Light.\n    lp.xy += path(lp.z);\n    vec2 lpTwist = vec2(0, -.3); \/\/ Only twist horizontal and vertcal.\n    lpTwist *= rot2(-getTwist(lp.z));\n    lp.xy += lpTwist;\n    \n\n    \n    \/\/ Using the above to produce the unit ray-direction vector.\n    float FOV = 1.; \/\/ FOV - Field of view.\n    float a = getTwist(ro.z);\n    \/\/ Swiveling the camera about the XY-plane.\n    a += (path(ro.z).x - path(lk.z).x)\/(ro.z - lk.z)\/4.;\n\tvec3 fw = normalize(lk - ro);\n\t\/\/vec3 up = normalize(vec3(-fw.x, 0, -fw.z));\n\tvec3 up = vec3(sin(a), cos(a), 0);\n\t\/\/vec3 up = vec3(0, 1, 0);\n    vec3 cu = normalize(cross(up, fw));\n\tvec3 cv = cross(fw, cu);   \n    \n    \/\/ Unit direction ray.\n    vec3 rd = normalize(uv.x*cu + uv.y*cv + fw\/FOV);\t\n\t \n    \n    \/\/ Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    \/\/ Save the block ID, object ID and local coordinates.\n    vec3 svGID = gID;\n    float svObjID = objID;\n    vec2 svP = gP; \n    \n    vec3 svGlow = gGlow.xyz;\n   \n\t\n    \/\/ Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t\/\/ The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t\/\/ Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    \/\/vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp);\n        \n          \n        \/\/ Texel color. \n\t    vec3 texCol;   \n        \n        \/\/ Transforming the texture coordinates according to the camera path\n        \/\/ and Z warping.\n        vec3 txP = sp;\n        txP.xy -= path(txP.z);\n        txP.xy *= rot2(getTwist(txP.z));\n        #ifdef PTH_INDPNT_GRD\n        txP.xy += path(txP.z);\n        #endif\n\n        \/\/ The extruded grid.\n        if(svObjID<.5){\n            \n            \/\/ Coloring the individual blocks with the saved ID.\n            vec3 tx = getTex(svGID.xy);\n            \n            \/\/ Ramping the shade up a bit.\n            texCol = smoothstep(-.5, 1., tx)*vec3(1, .8, 1.8);\n            \n            \n            \/\/ Very fake, but very cheap, bump mapping. Render some equispaced horizontal\n            \/\/ dark lines, and some light adjacent ones. As you can see, it gives the\n            \/\/ impression of horizontally segmented grooves on the pylons.\n            const float lvls = 8.;\n            \n            \/\/ Vertical lines... A bit too much for this example, but useful for a fake\n            \/\/ voxel setup.\n            \/\/float vLn = min(abs(txP.x - svGID.x), abs(txP.z - svGID.y));\n            \n            \/\/ Horizontal lines (planes, technically) around the pylons.\n            float yDist = (1.25 + abs(txP.y) + svGID.z*2.);\n            float hLn = abs(mod(yDist  + .5\/lvls, 1.\/lvls) - .5\/lvls);\n            float hLn2 = abs(mod(yDist + .5\/lvls - .008, 1.\/lvls) - .5\/lvls);\n            \n            \/\/ Omitting the top and bottom planes... I was in a hurry, and it seems to\n            \/\/ work, but there'd be better ways to do this. \n            if(yDist - 2.5<.25\/lvls) hLn = 1e5;\n            if(yDist - 2.5<.25\/lvls) hLn2 = 1e5;\n            \n            \/\/ Rendering the dark and light lines using 2D layering techniques.\n            texCol = mix(texCol, texCol*2., 1. - smoothstep(0., .003, hLn2 - .0035));\n       \t\ttexCol = mix(texCol, texCol\/2.5, 1. - smoothstep(0., .003, hLn - .0035));\n       \t\t \n            \n            \/\/ Render a dot on the face center of each extruded block for whatever reason...\n            \/\/ They were there as markers to begin with, so I got used to them. :)\n            float fDot = length(txP.xz - svGID.xy) - .0086;\n            texCol = mix(texCol, texCol*2., 1. - smoothstep(0., .005, fDot - .0035));\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., .005, fDot));\n  \n\n \n        }\n        else {\n            \n            \/\/ The dark floor in the background. Hidden behind the pylons, but\n            \/\/ there are very slight gaps, so it's still necessary.\n            texCol = vec3(0);\n        }\n       \n    \t\n    \t\/\/ Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        \/\/ Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t\/\/ Normalize the light direction vector.\n\t    ld \/= lDist;\n        \n        \n        \/\/ Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 16.);\n    \tfloat ao = calcAO(sp, sn); \/\/ Ambient occlusion.\n        sh = min(sh + ao*.25, 1.);\n\t    \n\t    \/\/ Light attenuation, based on the distances above.\n\t    float atten = 3.\/(1. + lDist*lDist*.5);\n\n    \t\n    \t\/\/ Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        diff *= diff*1.35; \/\/ Ramping up the diffuse.\n    \t\n    \t\/\/ Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 32.); \n\t    \n\t    \/\/ Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow(clamp(1. - abs(dot(sn, rd))*.5, 0., 1.), 4.);\n        \n\t\t\/\/ Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        \/\/ so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        \/\/ used to give a hard clay consistency... It \"kind of\" works.\n\t\t\/\/float Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\t\/\/float freS = mix(.15, 1., Schlick);  \/\/F0 = .2 - Glass... or close enough.        \n        \n        \/\/ Combining the above terms to procude the final color.\n        col = texCol*(diff + ao*.25 + vec3(1, .4, .2)*fre*.25 + vec3(1, .4, .2)*spec*4.);\n        \n       \n        \/\/ Fake environmental lighting: Interesting, but I couldn't justify it, both\n        \/\/ from a visual and logical standpoint.\n        \/\/vec3 cTex = envMap(reflect(rd, sn)); \/\/ Be sure to uncomment the function above.\n        \/\/col += col*cTex.zyx*4.;\n\n    \n        \/\/ Shading.\n        col *= ao*sh*atten;\n\t\n\t}\n\n    \n    \/\/ Applying the glow -- You perform this outside the hit logic block. The reason\n    \/\/ I mention this is that I make this mistake all the time and spend ages trying\n    \/\/ to figure out why it's not working. :) As for how you apply it, that's up to\n    \/\/ you. I made the following up, and I'd imagine there'd be nicer ways to apply \n    \/\/ it, but it'll do.\n    svGlow.xyz *= mix(vec3(4, 1, 2), vec3(4, 2, 1), min(svGlow.xyz*3.5, 1.25));\n    col *= .25 + svGlow.xyz*8.;\n   \n    \/\/ Some colorful fog: Like the above, it's been tweaked to produce something\n    \/\/ colorful that, hopefully, helps the scene. The cool thing about fog is that\n    \/\/ it's about as cheap an operation as you could hope for, but has virtually\n    \/\/ no impact on the frame rate. With that in mind, it's definitely worth taking\n    \/\/ the time to get it looking the way you'd like it to look.\n    vec3 fog =  mix(vec3(4, 1, 2), vec3(4, 2, 1), rd.y*.5 + .5);\n    fog = mix(fog, fog.zyx, smoothstep(0., .35, uv.y - .35));\n    col = mix(col, fog\/1.5, smoothstep(0., .99, t*t\/FAR\/FAR));\n    \n    \n    #ifdef GRAYSCALE\n    \/\/ Grayscale... or almost grayscale. :)\n    col = mix(col, vec3(1)*dot(col, vec3(.299, .587, .114)), .75);\n    #endif \n \n    \n    #ifdef REVERSE_PALETTE\n    col = col.zyx; \/\/ A more calming blue, for those who don't like fiery things.\n    #endif\n\n    \n    \/*\n    \/\/ Uncomment this block if you'd like to see the 2D pattern on its own.\n    uv = fragCoord\/iResolution.y;\n    vec4 d = blocks(vec3(uv*2. + iTime\/4., 0.));\n    \/\/vec2 offs = inCentRad(gV[0], gV[1], gV[2]).xy;\n    vec3 oCol = smoothstep(-.05, .5, getTex(d.yz));\n    float quadD = sBoxS(gP, 3.\/5.*vec2(1.\/5.) - .04, .015);\n    #ifdef SKEW_GRID\n    \/\/ Skewing half way along X, and not skewing in the Y direction.\n    const vec2 sk = vec2(-.5, .5);\/\/;\n    #else\n    const vec2 sk = vec2(0);\n    #endif\n    gP -= unskewXY(vec2(1.\/2.), sk)\/5.;\n    quadD = min(quadD, sBoxS(gP, 3.\/10.*vec2(1.\/5.) - .04\/2., .015));\n    float sf = 1.\/iResolution.y;\n    col = mix(vec3(.1), vec3(0), 1. - smoothstep(0., sf, quadD));\n    col = mix(col, oCol, 1. - smoothstep(0., sf, quadD + .006));\n    *\/      \n    \n    \/\/ Rought gamma correction.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n\t\n}",
            "name": "Image",
            "description": "",
            "type": "image"
        }
    ]
}