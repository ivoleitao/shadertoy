{
    "ver": "0.1",
    "info": {
        "id": "4dSfRc",
        "date": "1501424188",
        "viewed": 18827,
        "name": "[SH17C] Raymarching tutorial",
        "username": "reinder",
        "description": "The shader used as example in this tutorial can be found [url=https:\/\/www.shadertoy.com\/view\/4dSBz3]here[\/url].\n\nYou can navigate the slides using your arrow keys.",
        "likes": 257,
        "published": 3,
        "flags": 48,
        "tags": [
            "raymarching",
            "tutorial",
            "distance",
            "fields",
            "sh17c"
        ],
        "hasliked": 0
    },
    "renderpass": [
        {
            "inputs": [
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "XsXGR8",
                    "filepath": "\/media\/previz\/buffer01.png",
                    "previewfilepath": "\/media\/previz\/buffer01.png",
                    "type": "buffer",
                    "channel": 1,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "4sXGR8",
                    "filepath": "\/media\/previz\/buffer02.png",
                    "previewfilepath": "\/media\/previz\/buffer02.png",
                    "type": "buffer",
                    "channel": 2,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "XdfGR8",
                    "filepath": "\/media\/previz\/buffer03.png",
                    "previewfilepath": "\/media\/previz\/buffer03.png",
                    "type": "buffer",
                    "channel": 3,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dfGRr",
                    "channel": 0
                }
            ],
            "code": "\/\/ [SH17C] Raymarching tutorial. Created by Reinder Nijhoff 2017\n\/\/ Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n\/\/ @reindernijhoff\n\/\/ \n\/\/ https:\/\/www.shadertoy.com\/view\/4dSfRc\n\/\/\n\/\/ In this tutorial you will learn how to render a 3d-scene in Shadertoy\n\/\/ using distance fields.\n\/\/\n\/\/ The tutorial itself is created in Shadertoy, and is rendered\n\/\/ using ray marching a distance field.\n\/\/\n\/\/ The shader studied in the tutorial can be found here: \n\/\/     https:\/\/www.shadertoy.com\/view\/4dSBz3\n\/\/\n\/\/ Created for the Shadertoy Competition 2017 \n\/\/\n\/\/ Most of the render code is taken from: 'Raymarching - Primitives' by Inigo Quilez.\n\/\/\n\/\/ You can find this shader here:\n\/\/     https:\/\/www.shadertoy.com\/view\/Xds3zN\n\/\/\n\n\/\/ COMPOSITE IMAGE\n\n#define SLIDE_FADE_STEPS 60\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    int SLIDE_STEPS_VISIBLE = int(texelFetch( iChannel0, ivec2(0,0), 0 ).y);\n    \n    vec4 current = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    vec4 prev    = texelFetch(iChannel2, ivec2(fragCoord), 0);\n    vec4 font    = texelFetch(iChannel3, ivec2(fragCoord), 0);\n\n\tfragColor = mix( prev, current, clamp( float(SLIDE_STEPS_VISIBLE)\/float(SLIDE_FADE_STEPS), 0., 1.) );\n    fragColor = mix( fragColor * .75, font, font.a );\n}",
            "name": "Image",
            "description": "",
            "type": "image"
        },
        {
            "inputs": [
                {
                    "id": "4dXGRr",
                    "filepath": "\/presets\/tex00.jpg",
                    "previewfilepath": "\/presets\/tex00.jpg",
                    "type": "keyboard",
                    "channel": 1,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "4dXGzr",
                    "filepath": "\/media\/a\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png",
                    "previewfilepath": "\/media\/ap\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png",
                    "type": "texture",
                    "channel": 2,
                    "sampler": {
                        "filter": "mipmap",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dXGR8",
                    "channel": 0
                }
            ],
            "code": "\/\/ [SH17C] Raymarching tutorial. Created by Reinder Nijhoff 2017\n\/\/ @reindernijhoff\n\/\/ \n\/\/ https:\/\/www.shadertoy.com\/view\/4dSfRc\n\/\/\n\/\/ In this tutorial you will learn how to render a 3d-scene in Shadertoy\n\/\/ using distance fields.\n\/\/\n\/\/ The tutorial itself is created in Shadertoy, and is rendered\n\/\/ using ray marching a distance field.\n\/\/\n\/\/ The shader studied in the tutorial can be found here: \n\/\/     https:\/\/www.shadertoy.com\/view\/4dSBz3\n\/\/\n\/\/ Created for the Shadertoy Competition 2017 \n\/\/\n\/\/ Most of the render code is taken from: 'Raymarching - Primitives' by Inigo Quilez.\n\/\/\n\/\/ You can find this shader here:\n\/\/     https:\/\/www.shadertoy.com\/view\/Xds3zN\n\/\/\n\n\/\/ SLIDE NAVIGATION FUNCTIONS\n\n\/\/ Load & store functions\n\n#define SLIDE_FADE_STEPS 45\n\n#define TITLE_DELAY   45\n#define BODY_DELAY   90\n#define CODE_DELAY   135\n#define FOOTER_DELAY 180\n\n#define NUM_SLIDES 25\n\nint SLIDE = 0;\nint SLIDE_STEPS_VISIBLE = 0;\n\nivec4 LoadVec4( in ivec2 vAddr ) {\n    return ivec4( texelFetch( iChannel0, vAddr, 0 ) );\n}\n\nbool AtAddress( ivec2 p, ivec2 c ) { return all( equal( floor(vec2(p)), vec2(c) ) ); }\n\nvoid StoreVec4( in ivec2 vAddr, in ivec4 vValue, inout vec4 fragColor, in ivec2 fragCoord ) {\n    fragColor = AtAddress( fragCoord, vAddr ) ? vec4(vValue) : fragColor;\n}\n\nvec4 LoadFVec4( in ivec2 vAddr ) {\n    return texelFetch( iChannel0, vAddr, 0 );\n}\n\nvoid StoreFVec4( in ivec2 vAddr, in vec4 vValue, inout vec4 fragColor, in ivec2 fragCoord ) {\n    fragColor = AtAddress( fragCoord, vAddr ) ? vValue : fragColor;\n}\n\n\/\/ key functions\n\n\/\/ Keyboard constants definition\nconst int KEY_SPACE = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_D     = 68;\nconst int KEY_S     = 83;\nconst int KEY_W     = 87;\n\n\nbool KP(int key) {\n\treturn texelFetch( iChannel1, ivec2(key, 0), 0 ).x > 0.0;\n}\n\nbool KT(int key) {\n\treturn texelFetch( iChannel1, ivec2(key, 2), 0 ).x > 0.0;\n}\n\n\/\/ slide logic\n\nstruct SlideDataStruct {\n    int title;\n    int titleDelay;\n    int body;\n    int bodyDelay;\n    int code;\n    int codeDelay;\n    vec3 ro;\n    vec3 ta;\n    int sceneMode;\n    int codeS;\n    int codeE;\n    int distMode;\n};\n\nSlideDataStruct temp;\nint tempCounter;\n\nbool createSlideData( \n    const int title,\n    const int titleDelay,\n    const int body,\n    const int bodyDelay,\n    const int code,\n    const int codeDelay,\n    const vec3 ro,\n    const vec3 ta,\n    const int sceneMode,\n    const int codeS,\n    const int codeE,\n\tconst int distMode ) {\n        \n    if(tempCounter == SLIDE) {\n        temp.title = title;\n  \t  \ttemp.titleDelay = titleDelay;\n   \t \ttemp.body = body;\n   \t \ttemp.bodyDelay =bodyDelay;\n   \t \ttemp.code = code;\n   \t\ttemp.codeDelay =codeDelay;\n   \t\ttemp.ro = ro;\n   \t\ttemp.ta = ta;\n   \t \ttemp.sceneMode = sceneMode;\n  \t \ttemp.codeS = codeS;\n  \t  \ttemp.codeE = codeE;\n\t\ttemp.distMode = distMode;\n        return true;\n    } else {\n    \ttempCounter++;\n        return false;\n    }\n}\n\nSlideDataStruct getSlideData() {\n    tempCounter = 0;\n    \n    \/\/ intro\n   if( createSlideData(1,TITLE_DELAY,1,BODY_DELAY,0,0, vec3(.0,0.,1.),vec3(0.,0.,-.5), 0, 0, 0, 0) ) return temp;\n\n    \/\/ intro - show bw scene\n   if( createSlideData(1,0,2,0,0,0, vec3(.0,0.,1.), vec3(0.,0.,-5.), -1, 0, 0, 0)) return temp;\n    \n    \/\/ create a ray - origin\n   if( createSlideData(2,TITLE_DELAY,3,BODY_DELAY,0,0, vec3(2.,1.,2.),vec3(0.,0.2,-1.3), 1, 0, 0, 0)) return temp;\n        \n    \/\/ create a ray - origin \/ code    \n   if( createSlideData(2,0,4,0,1,TITLE_DELAY, vec3(2.,1.,2.),vec3(0.,0.2,-1.3), 1, 1, 3, 0)) return temp;\n    \n    \/\/ place screen\n   if( createSlideData(2,0,5,TITLE_DELAY,0,0, vec3(2.,1.,2.),vec3(0.,0.2,-1.3), 2, 0, 0, 0)) return temp;\n    \n    \/\/ create rd\n   if( createSlideData(2,0,6,TITLE_DELAY,0,0, vec3(2.5,3.,2.5),vec3(0.,0.2,-1.3), 3, 0, 0, 0)) return temp;\n\n\t\/\/ create rd \/ code\n   if( createSlideData(2,0,7,0,1,TITLE_DELAY, vec3(2.5,3.,2.5),vec3(0.,0.2,-1.3), 3, 3, 0, 0)) return temp;\n   \n    \/\/ interact with scene\n   if( createSlideData(2,0,8,0,0,0, vec3(2.5,3.,2.5),vec3(0.,0.2,-1.3), 3, 3, 0, 0)) return temp;\n    \n    \/\/ distance fields intro\n   if( createSlideData(3,TITLE_DELAY,9,BODY_DELAY,0,0, vec3(1.,6.,2.),vec3(0.,0.2,-1.3), 3, 0, 0, 0)) return temp;\n    \n    \/\/ distance fields def\n   if( createSlideData(3,0,10,TITLE_DELAY,0,0, vec3(1.,6.,2.),vec3(0.,0.2,-1.3), 3, 0, 0, 0)) return temp;\n        \n    \/\/ distance fields one sphere\n   if( createSlideData(3,TITLE_DELAY,11,BODY_DELAY,0,0, vec3(1.,6.,-2.),vec3(-1.,-0.5,-2.), 4, 0, 0, 0)) return temp;\n    \n     \/\/ distance fields one sphere\n   if( createSlideData(3,0,11,0,0,0, vec3(1.,6.,-2.),vec3(-1.,-0.5,-2.), 4, 0, 0, 1)) return temp;\n      \n    \/\/ distance fields one sphere - code\n   if( createSlideData(3,0,12,0,2,TITLE_DELAY, vec3(1.,6.,-2.),vec3(-1.,-0.5,-2.), 4, 0, 3, 1)) return temp;\n    \n    \/\/ distance fields one three spheres\n   if( createSlideData(3,0,13,TITLE_DELAY,0,0, vec3(1.,6.,-2.),vec3(-1.,-0.5,-2.), 2, 0, 5, 2)) return temp;\n    \n    \/\/ distance fields one three spheres - in code\n   if( createSlideData(3,0,14,0,2,TITLE_DELAY, vec3(1.,6.,-2.),vec3(-1.,-0.5,-2.), 2, 0, 5, 2)) return temp;\n    \n    \/\/ distance fields one three spheres - full code\n   if( createSlideData(3,0,15,TITLE_DELAY,2,BODY_DELAY, vec3(1.,6.,-2.),vec3(-1.,-0.5,-2.), 2, 0, 0, 3)) return temp;\n        \n    \/\/ distance fields one three spheres - march\n   if( createSlideData(3,0,16,TITLE_DELAY,0,0, vec3(2.5,3.,1.5),vec3(0.,0.2,-1.3), 5, 0, 0, 4)) return temp;\n    \n    \/\/ distance fields one three spheres - march code\n   if( createSlideData(3,0,17,0,3,TITLE_DELAY, vec3(2.5,3.,1.5),vec3(0.,0.2,-1.3), 5, 0, 0, 4)) return temp;\n        \n    \/\/ distance fields one three spheres - interact\n   if( createSlideData(3,0,8,TITLE_DELAY,0,0, vec3(.5,2.,2.5),vec3(0.,0.2,-.3), 5, 0, 0, 4)) return temp;\n\n    \/\/ lighting - normal intro\n   if( createSlideData(4,TITLE_DELAY,18,BODY_DELAY,0,0, vec3(2.5,3.,1.5),vec3(0.,0.2,-1.3), 6, 0, 0, 0)) return temp;\n\n   \/\/ lighting - normal full\n   if( createSlideData(4,0,19,TITLE_DELAY,4,BODY_DELAY, vec3(4.5,3.,-1.5),vec3(0.,0.2,-1.3), 6, 0, 0, 0)) return temp;\n\n   \/\/ lighting - interact\n   if( createSlideData(4,0,8,TITLE_DELAY,0,0, vec3(4.5,3.,-1.5),vec3(0.,0.2,-1.3), 6, 0, 0, 0)) return temp;\n\n   \/\/ lighting - diffuse\n   if( createSlideData(4,0,20,TITLE_DELAY,0,0, vec3(.0,0.,1.),vec3(0.,0.,-.5), 0, 0, 0, 0)) return temp;\n\n   \/\/ lighting - diffuse\n   if( createSlideData(4,0,21,0,5,TITLE_DELAY, vec3(.0,0.,1.),vec3(0.,0.,-.5), -1, 0, 0, 0)) return temp;\n \n   \/\/ done\n   if( createSlideData(1,TITLE_DELAY,22,BODY_DELAY,0,0, vec3(.0,0.,1.),vec3(0.,0.,-.5), -1, 0, 0, 0)) return temp;\n \n    \n    return temp;\n}\n    \nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nfloat sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph ) {\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return 10000.0;\n\treturn -b - sqrt( h );\n}\n\nfloat iPlane(in vec3 ro, in vec3 rd, in float d) {\n\t\/\/ equation of a plane, y=0 = ro.y + t*rd.y\n    return -(ro.y+d)\/rd.y;\n}\n\nvec3 intersectScene( vec3 ro, vec3 ta, vec2 p,  bool intersectPlane ) {    \n    mat3 ca = setCamera( ro, ta, 0.0 );\n    vec3 rd = ca * normalize( vec3(p.xy,1.0) );\n    \n    float d = 1000.;\n    \/\/ sphere intersections ..\n    if( intersectPlane ) {\n\t    if( rd.y < 0. ) d = min(d, iPlane(ro, rd, 0.));\n    } else {\n    \td = min( d, sphIntersect( ro, rd, vec4(-1,0,-5,1) ));\n   \t\td = min( d, sphIntersect( ro, rd, vec4(2,0,-3,1) ));\n  \t  \td = min( d, sphIntersect( ro, rd, vec4(-2,0,-2,1) ));\n\n\t    if( rd.y < 0. ) d = min(d, iPlane(ro, rd, 1.));\n    }\n    \n    if( d < 100. ) {\n        return ro + d*rd;\n    } else {\n        return vec3(-1,0,-4);\n    }\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tivec2 uv = ivec2(fragCoord.xy);\n    \n    \/\/ wait for font-texture to load\n    if( iFrame == 0 || texelFetch(iChannel2, ivec2(0,0), 0).b < .1) {\n        vec4 ro = vec4(0,0,1,0);\n\t\tvec4 ta = vec4(0);\n        \n\t\tStoreFVec4( ivec2(0,3), ro, fragColor, uv);\n\t\tStoreFVec4( ivec2(0,4), ta, fragColor, uv);\n    } else if( uv.x < 2 && uv.y < 6) {\n        ivec4 slideData = LoadVec4( ivec2(0,0) );\n        SLIDE = slideData.x;\n        SLIDE_STEPS_VISIBLE = slideData.y;\n        SLIDE_STEPS_VISIBLE++;\n\n        if( SLIDE_STEPS_VISIBLE > 16 ) {\n            if( KP(KEY_SPACE) || KP(KEY_RIGHT) || KP(KEY_D) ) {\n                SLIDE++;\n                SLIDE_STEPS_VISIBLE=0;\n            }\n            if( KP(KEY_LEFT) || KP(KEY_W) ) {\n                SLIDE = (SLIDE + NUM_SLIDES - 1);\n                SLIDE_STEPS_VISIBLE=0;\n            }\n            \n            SLIDE = SLIDE % NUM_SLIDES; \n        }\n        \n        SlideDataStruct slide = getSlideData();\n        \n        \/\/ screen resolution\n        ivec4 res = LoadVec4( ivec2(1,0) );\n        if( res.x != int(iResolution.x) || res.y != int(iResolution.y) ) {\n            SLIDE_STEPS_VISIBLE = 0;\n        }\n        StoreVec4( ivec2(1,0), ivec4(iResolution.xy, 0,0), fragColor, uv );\n        \n\t\t\/\/ slide navigation               \n\t\tStoreVec4( ivec2(0,0), ivec4(SLIDE, SLIDE_STEPS_VISIBLE, slide.sceneMode, slide.distMode), fragColor, uv);\n        \n        \/\/ text \n        ivec4 showText1 = ivec4(0);\n        ivec4 showText2 = ivec4(0);\n        \n        if( SLIDE_STEPS_VISIBLE == 0) showText1.x = 1;\n        \n        if( slide.titleDelay == SLIDE_STEPS_VISIBLE) showText2.x = slide.title;\n        if( slide.bodyDelay == SLIDE_STEPS_VISIBLE) showText2.y = slide.body;\n        if( slide.codeDelay == SLIDE_STEPS_VISIBLE) showText2.z = slide.code;\n\n        showText1.y = slide.codeS;\n        showText1.z = slide.codeE;\n        \n\t\tStoreVec4( ivec2(0,1), showText1, fragColor, uv);\n\t\tStoreVec4( ivec2(0,2), showText2, fragColor, uv);\n        \n        \/\/ camera\n        \n        vec4 ro = LoadFVec4( ivec2(0,3) );\n        vec4 ta = LoadFVec4( ivec2(0,4) );\n        \n\t\tif(SLIDE_STEPS_VISIBLE > SLIDE_FADE_STEPS) {\n            ro.xyz = mix( ro.xyz, slide.ro, 0.055 );\n            ta.xyz = mix( ta.xyz, slide.ta, 0.055 );\n        }\n        \n\t\tStoreFVec4( ivec2(0,3), ro, fragColor, uv);\n\t\tStoreFVec4( ivec2(0,4), ta, fragColor, uv);\n                \n        if(iMouse.z > 0.) {\n            vec2 q = (iMouse.xy - .5 * iResolution.xy ) \/ iResolution.y;\n\t\t\tStoreFVec4( ivec2(0,5), vec4(intersectScene(ro.xyz, ta.xyz, q, slide.sceneMode == 5),1), fragColor, uv);\n        } else {\n\t\t\tStoreFVec4( ivec2(0,5), vec4(intersectScene(vec3(0,0,1), vec3(1,0,0), vec2(0), slide.sceneMode == 5),1), fragColor, uv);\n        }\n    } else {  \n\t    fragColor = vec4(0);\n    }\n}",
            "name": "Buffer A",
            "description": "",
            "type": "buffer"
        },
        {
            "inputs": [
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "XsXGR8",
                    "channel": 0
                }
            ],
            "code": "\/\/ [SH17C] Raymarching tutorial. Created by Reinder Nijhoff 2017\n\/\/ @reindernijhoff\n\/\/ \n\/\/ https:\/\/www.shadertoy.com\/view\/4dSfRc\n\/\/\n\/\/ In this tutorial you will learn how to render a 3d-scene in Shadertoy\n\/\/ using distance fields.\n\/\/\n\/\/ The tutorial itself is created in Shadertoy, and is rendered\n\/\/ using ray marching a distance field.\n\/\/\n\/\/ The shader studied in the tutorial can be found here: \n\/\/     https:\/\/www.shadertoy.com\/view\/4dSBz3\n\/\/\n\/\/ Created for the Shadertoy Competition 2017 \n\/\/\n\/\/ Most of the render code is taken from: 'Raymarching - Primitives' by Inigo Quilez.\n\/\/\n\/\/ You can find this shader here:\n\/\/     https:\/\/www.shadertoy.com\/view\/Xds3zN\n\/\/\n\n\/\/ RENDER SCENE\n\n\n\/\/ Load & store functions\n\n#define SLIDE_FADE_STEPS 60\n\nint SLIDE = 0;\nint SLIDE_STEPS_VISIBLE = 0;\nint SCENE_MODE = 0;\nint DIST_MODE = 0;\nint MAX_MARCH_STEPS;\n\nvec3 intersections[7];\nvec3 intersectionNormal;\n\nfloat aspect;\nvec3 USER_INTERSECT;\n\nivec4 LoadVec4( in ivec2 vAddr ) {\n    return ivec4( texelFetch( iChannel0, vAddr, 0 ) );\n}\n\nvec4 LoadFVec4( in ivec2 vAddr ) {\n    return texelFetch( iChannel0, vAddr, 0 );\n}\n\nbool AtAddress( ivec2 p, ivec2 c ) { return all( equal( floor(vec2(p)), vec2(c) ) ); }\n\nvoid StoreVec4( in ivec2 vAddr, in ivec4 vValue, inout vec4 fragColor, in ivec2 fragCoord ) {\n    fragColor = AtAddress( fragCoord, vAddr ) ? vec4(vValue) : fragColor;\n}\n\nvoid loadData() {\n    ivec4 slideData = LoadVec4( ivec2(0,0) );\n    SLIDE = slideData.x;\n    SLIDE_STEPS_VISIBLE = slideData.y;\n    SCENE_MODE = slideData.z;\n\tDIST_MODE = slideData.w;\n}\n\n\n\/\/ tutorial Scene\nfloat tut_map(vec3 p) {\n    float d = distance(p, vec3(-1, 0, -5)) - 1.;\n    d = min(d, distance(p, vec3(2, 0, -3)) - 1.);\n    d = min(d, distance(p, vec3(-2, 0, -2)) - 1.);\n    d = min(d, p.y + 1.);\n    return d;\n}\n\nvec3 tut_calcNormal(in vec3 pos) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\n    return normalize(\n        e.xyy * tut_map(pos + e.xyy) +\n        e.yyx * tut_map(pos + e.yyx) +\n        e.yxy * tut_map(pos + e.yxy) +\n        e.xxx * tut_map(pos + e.xxx));\n}\n\nvec4 tut_render(in vec2 uv, const int steps) {\n    vec3 ro = vec3(0, 0, 1);\n    vec3 rd = normalize(vec3(uv, 0.) - ro);\n\n    float h, t = 1.;\n    for (int i = 0; i < steps; i++) {\n        h = tut_map((ro + rd * t));\n        t += h;\n        if (h < 0.01) break;\n    }\n\n    if (h < 0.01) {\n        vec3 p = ro + rd * t;\n        vec3 normal = tut_calcNormal(p);\n        vec3 light = vec3(0, 2, 0);\n\n        float dif = clamp(dot(normal, normalize(light - p)), 0., 1.);\n        dif *= 5. \/ dot(light - p, light - p);\n        return vec4(pow(vec3(dif), vec3(1. \/ 2.2)), 1);\n    } else {\n        return vec4(0, 0, 0, 1);\n    }\n}\n\n\/\/\n\/\/ render full scene\n\/\/\n\/\/ Most of this is taken from: 'Raymarching - Primitives' by Inigo Quilez.\n\/\/\n\/\/ You can find this shader here:\n\/\/     https:\/\/www.shadertoy.com\/view\/Xds3zN\n\/\/\n\n\/\/------------------------------------------------------------------\n\nfloat sdPlane( vec3 p, float d ) {\n\treturn p.y - d;\n}\n\nfloat sdSphere( vec3 p, float s ) {\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n\/\/------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 ) {\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n\/\/------------------------------------------------------------------\n\nvec2 map_0( in vec3 pos ) { \/\/ basic scene\n    vec2 res = opU( vec2( sdPlane(     pos, -1.), 1.0 ),\n\t                vec2( sdSphere(    pos-vec3(-1,0,-5),1.), 50. ) );\n    res = opU( res, vec2( sdSphere(    pos-vec3(2,0,-3),1.), 65. ) );\n    res = opU( res, vec2( sdSphere(    pos-vec3(-2,0,-2),1.),41. ) );\n        \n    return res;\n}\n\nvec2 map_1( in vec3 pos ) { \/\/ scene + ro\n    vec2 res = map_0(pos);\n    res = opU( res, vec2( sdSphere(    pos-vec3(0,0,1),.1),2. ) );\n    return res;\n}\n\nvec2 map_2( in vec3 pos ) { \/\/ scene + ro + screen\n    vec2 res = map_0(pos);\n            \n    res = opU( res, vec2( sdSphere(    pos-vec3(0,0,1),.1),3. ) );\n    res = opU( res, vec2( sdBox( pos,  vec3(.5*aspect, .5,.025)), 4.));\n    return res;\n}\n\nvec2 map_3( in vec3 pos ) { \/\/ scene + ro + rd + intersection\n    vec2 res = map_2(pos);\n    \n    res = opU( res, vec2( sdSphere(     pos-USER_INTERSECT,.1),2. ) );\n    res = opU( res, vec2( sdCapsule(    pos, vec3(0,0,1.), USER_INTERSECT,.025),2. ) );\n    \n    return res;\n}\n\nvec2 map_4( in vec3 pos ) { \/\/ scene + ro + one sphere\n    vec2 res = opU( vec2( sdPlane(     pos, -1.), 1.0 ),\n\t                vec2( sdSphere(    pos-vec3(-1,0,-5),1.), 50. ) );\n    \n    res = opU( res, vec2( sdSphere(    pos-vec3(0,0,1),.1),3. ) );\n    res = opU( res, vec2( sdBox( pos,  vec3(.5*aspect, .5,.025)), 4.));\n    \n    return res;\n}\n\nvec2 map_5( in vec3 pos ) { \/\/ scene + ro + screen + march steps\n    vec2 res = map_2(pos);\n    \n    res = opU( res, vec2( sdCapsule(    pos, vec3(0,0,1.), USER_INTERSECT,.025),3. ) );\n    for( int i=0; i<intersections.length(); i++ ){\n        if (i <= MAX_MARCH_STEPS) {\n\t    \tres = opU( res, vec2( sdSphere( pos-intersections[i],.1), (i==MAX_MARCH_STEPS)?2.:3. ) );\n        }\n    }\n    \n    return res;\n}\n\nvec2 map_6( in vec3 pos ) { \/\/ scene + ro + rd + intersection + normal\n    vec2 res = map_2(pos);\n    \n    res = opU( res, vec2( sdSphere(     pos-USER_INTERSECT,.1),3. ) );\n    res = opU( res, vec2( sdCapsule(    pos, USER_INTERSECT + intersectionNormal, USER_INTERSECT,.025),2. ) );\n    \n    res = opU( res, vec2( sdCapsule(    pos, vec3(0,0,1.), USER_INTERSECT,.025),3. ) );\n    return res;\n}\n\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = .5;\n    float tmax = 20.0;\n       \n    float t = tmin;\n    float m = -1.0;\n\n    if( SCENE_MODE == 0 ) {\n        for( int i=0; i<64; i++ )\n        {\n            float precis = 0.00005*t;\n            vec2 res = map_0( ro+rd*t );\n            if( res.x<precis || t>tmax ) break;\n            t += res.x;\n            m = res.y;\n        }\n    } else if( SCENE_MODE == 1 ) {\n        for( int i=0; i<64; i++ )\n        {\n            float precis = 0.00005*t;\n            vec2 res = map_1( ro+rd*t );\n            if( res.x<precis || t>tmax ) break;\n            t += res.x;\n            m = res.y;\n        }\n    } else if( SCENE_MODE == 2 ) {\n        for( int i=0; i<64; i++ )\n        {\n            float precis = 0.00005*t;\n            vec2 res = map_2( ro+rd*t );\n            if( res.x<precis || t>tmax ) break;\n            t += res.x;\n            m = res.y;\n        }\n    } else if( SCENE_MODE == 3 ) {\n        for( int i=0; i<64; i++ )\n        {\n            float precis = 0.00005*t;\n            vec2 res = map_3( ro+rd*t );\n            if( res.x<precis || t>tmax ) break;\n            t += res.x;\n            m = res.y;\n        }\n    } else if( SCENE_MODE == 4 ) {\n        for( int i=0; i<64; i++ )\n        {\n            float precis = 0.00005*t;\n            vec2 res = map_4( ro+rd*t );\n            if( res.x<precis || t>tmax ) break;\n            t += res.x;\n            m = res.y;\n        }\n    } else if( SCENE_MODE == 5 ) {\n        for( int i=0; i<64; i++ )\n        {\n            float precis = 0.00005*t;\n            vec2 res = map_5( ro+rd*t );\n            if( res.x<precis || t>tmax ) break;\n            t += res.x;\n            m = res.y;\n        }\n    }  else if( SCENE_MODE == 6 ) {\n        for( int i=0; i<64; i++ )\n        {\n            float precis = 0.00005*t;\n            vec2 res = map_6( ro+rd*t );\n            if( res.x<precis || t>tmax ) break;\n            t += res.x;\n            m = res.y;\n        }\n    } \n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint, h;\n    for( int i=0; i<16; i++ )\n    {\n        \n\t    if( SCENE_MODE == 0 ) {\n\t\t\th = map_0( ro + rd*t ).x;\n    \t} else if( SCENE_MODE == 1 ) {\n\t\t\th = map_1( ro + rd*t ).x;\n    \t} else if( SCENE_MODE == 2 ) {\n\t\t\th = map_2( ro + rd*t ).x;\n   \t\t} else if( SCENE_MODE == 3 ) {\n\t\t\th = map_3( ro + rd*t ).x;\n   \t\t} else if( SCENE_MODE == 4 ) {\n\t\t\th = map_4( ro + rd*t ).x;\n   \t\t} else if( SCENE_MODE == 5 ) {\n\t\t\th = map_5( ro + rd*t ).x;\n   \t\t} else if( SCENE_MODE == 6 ) {\n\t\t\th = map_6( ro + rd*t ).x;\n   \t\t}\n        \n        res = min( res, 8.0*h\/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    \n    if( SCENE_MODE == 0 ) {\n \t   return normalize( e.xyy*map_0( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map_0( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map_0( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map_0( pos + e.xxx ).x );\n    } else if( SCENE_MODE == 1 ) {\n            return normalize( e.xyy*map_1( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map_1( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map_1( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map_1( pos + e.xxx ).x );\n    } else if( SCENE_MODE == 2 ) {\n            return normalize( e.xyy*map_2( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map_2( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map_2( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map_2( pos + e.xxx ).x );\n    } else if( SCENE_MODE == 3 ) {\n            return normalize( e.xyy*map_3( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map_3( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map_3( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map_3( pos + e.xxx ).x );\n    } else if( SCENE_MODE == 4 ) {\n            return normalize( e.xyy*map_4( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map_4( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map_4( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map_4( pos + e.xxx ).x );\n    } else if( SCENE_MODE == 5 ) {\n            return normalize( e.xyy*map_5( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map_5( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map_5( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map_5( pos + e.xxx ).x );\n    } else if( SCENE_MODE == 6 ) {\n            return normalize( e.xyy*map_6( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map_6( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map_6( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map_6( pos + e.xxx ).x );\n    }\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0, dd;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)\/4.0;\n        vec3 aopos =  nor * hr + pos;\n\t    if( SCENE_MODE == 0 ) {\n\t\t\tdd = map_0( aopos ).x;\n    \t} else if( SCENE_MODE == 1 ) {\n\t\t\tdd = map_1( aopos ).x;\n    \t} else if( SCENE_MODE == 2 ) {\n\t\t\tdd = map_2( aopos ).x;\n   \t\t} else if( SCENE_MODE == 3 ) {\n\t\t\tdd = map_3( aopos ).x;\n   \t\t} else if( SCENE_MODE == 4 ) {\n\t\t\tdd = map_4( aopos ).x;\n   \t\t} else if( SCENE_MODE == 5 ) {\n\t\t\tdd = map_5( aopos ).x;\n   \t\t} else if( SCENE_MODE == 6 ) {\n\t\t\tdd = map_6( aopos ).x;\n   \t\t}\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.75,0.9,1.0) + max(rd.y*.8,0.);\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        \/\/ material        \n\t\tcol = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        if( m<1.5 ) {            \n            float f = mod( floor(1.0*pos.z) + floor(1.0*pos.x), 2.0);\n            col = 0.35 + 0.05*f*vec3(1.0);\n        } else if (m < 2.5 ) {\n            col = vec3(.5 + .3*sin(iTime*6.28318530718 ),0,0);\n        } else if (m < 3.5 ) {\n            col = vec3(.8,0,0);\n        } else if (m < 4.5 ) {\n            col = tut_render(pos.xy, 64).rgb;\n        }\n\n        \/\/ lighitng        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(0.4, 0.7, 0.6) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.30*dif*vec3(1.00,0.80,0.55);\n\t\tlin += 2.00*spe*vec3(1.00,0.90,0.70)*dif;\n        lin += 0.40*amb*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\n        \n        if( DIST_MODE > 0 ) {\n            \/\/ intersect with plane;\n            float d = -(ro.y)\/rd.y;\n            vec3 dint = ro + d*rd;\n            \n            float m = sdSphere(dint-vec3(-1,0,-5),1.);\n            \n            if( DIST_MODE > 1 ) { \n                m = min( m, sdSphere(dint-vec3(2,0,-3),1.));\n                m = min( m, sdSphere(dint-vec3(-2,0,-2),1.));\n            }\n            if( DIST_MODE > 2 ) { \n                m = min( m, dint.y + 1.);\n            }\n            vec3 dcol = vec3(abs(mod(m, 0.1)\/0.1 - 0.5));\n            dcol = mix( dcol, pal( m*.115+.6, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) ), .7);\n            \n            if( SCENE_MODE == 5) {\n                for( int i=0; i<intersections.length(); i++ ){\n                    if (i<MAX_MARCH_STEPS) {\n                        float dti = distance(intersections[i], dint);\n                        float mai = map_0(intersections[i]).x;\n                        float outer = smoothstep( mai-0.15, mai, dti);\n                        dcol = mix( dcol, vec3(1,0,0), .3*smoothstep( mai+0.01, mai, dti)*(outer+1.) );\n                    }\n                }            \n            }\n            if( d < t ) {\n                col = mix(col, dcol, .6);\n            }\n        }\n        \n    \tcol = mix( col, vec3(0.75,0.9,1.0), .05+.95* smoothstep(10.,20.,t) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nvec3 calcNormal_0( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    \n    return normalize( e.xyy*map_0( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map_0( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map_0( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map_0( pos + e.xxx ).x );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvec3 renderScene( vec2 p, vec3 ro, vec3 ta ) {\n    \/\/ camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \/\/ ray direction\n    vec3 rd = ca * normalize( vec3(p.xy,1.0) );\n    \/\/ render\t\n    vec3 col = render( ro, rd );\n    \n    return col;\n}\n\n\nvoid initIntersecions( in vec3 ro, in vec3 rd ) {\n    float t = 1.;\n    \n    for( int i=0; i<intersections.length(); i++ ){\n        vec2 res = map_0( ro+rd*t );\n        t += res.x;\n        intersections[i] = ro + rd*t;\n    }\n}\n\n\/\/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 q = (fragCoord.xy - .5 * iResolution.xy ) \/ iResolution.y;\n    \n    aspect = iResolution.x\/iResolution.y;\n    \n    loadData();\n    \n    if(SCENE_MODE == -1) {\n        fragColor = tut_render(q, 96);\n    } else {\n        vec3 ro = LoadFVec4( ivec2(0,3) ).xyz;\n        vec3 ta = LoadFVec4( ivec2(0,4) ).xyz;\n        USER_INTERSECT = LoadFVec4( ivec2(0,5) ).xyz;\n        \n        if( SCENE_MODE == 5 ) {\n            MAX_MARCH_STEPS = min(max(int( SLIDE_STEPS_VISIBLE\/40-1),0), intersections.length()-1);\n            \n            initIntersecions(vec3(0,0,1), normalize(USER_INTERSECT - vec3(0,0,1)) );\n            for (int i=0; i<intersections.length(); i++) {\n                if (i<MAX_MARCH_STEPS+1) {\n            \t\tUSER_INTERSECT = intersections[i];\n                }\n            }\n        }\n        if( SCENE_MODE == 6 ) {\n            intersectionNormal = calcNormal_0(USER_INTERSECT) * .5;\n        }\n        \n        fragColor = vec4(renderScene(q, ro, ta),1);\n    }\n}",
            "name": "Buffer B",
            "description": "",
            "type": "buffer"
        },
        {
            "inputs": [
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "XsXGR8",
                    "filepath": "\/media\/previz\/buffer01.png",
                    "previewfilepath": "\/media\/previz\/buffer01.png",
                    "type": "buffer",
                    "channel": 1,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "4sXGR8",
                    "filepath": "\/media\/previz\/buffer02.png",
                    "previewfilepath": "\/media\/previz\/buffer02.png",
                    "type": "buffer",
                    "channel": 2,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4sXGR8",
                    "channel": 0
                }
            ],
            "code": "\/\/ [SH17C] Raymarching tutorial. Created by Reinder Nijhoff 2017\n\/\/ @reindernijhoff\n\/\/ \n\/\/ https:\/\/www.shadertoy.com\/view\/4dSfRc\n\/\/\n\/\/ In this tutorial you will learn how to render a 3d-scene in Shadertoy\n\/\/ using distance fields.\n\/\/\n\/\/ The tutorial itself is created in Shadertoy, and is rendered\n\/\/ using ray marching a distance field.\n\/\/\n\/\/ The shader studied in the tutorial can be found here: \n\/\/     https:\/\/www.shadertoy.com\/view\/4dSBz3\n\/\/\n\/\/ Created for the Shadertoy Competition 2017 \n\/\/\n\/\/ Most of the render code is taken from: 'Raymarching - Primitives' by Inigo Quilez.\n\/\/\n\/\/ You can find this shader here:\n\/\/     https:\/\/www.shadertoy.com\/view\/Xds3zN\n\/\/\n\n\/\/ COPY LAST FRAME FOR FADES\n\n#define SLIDE_FADE_STEPS 60 \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    int SLIDE_STEPS_VISIBLE = int(texelFetch( iChannel0, ivec2(0,0), 0 ).y);\n    \n    if(iFrame == 0) {\n  \t\tfragColor = vec4(0,0,0,1);\n    } else if(SLIDE_STEPS_VISIBLE > SLIDE_FADE_STEPS) {\n  \t\tfragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    } else {\n    \tfragColor = texelFetch(iChannel2, ivec2(fragCoord), 0);\n    }\n}",
            "name": "Buffer C",
            "description": "",
            "type": "buffer"
        },
        {
            "inputs": [
                {
                    "id": "4dXGzr",
                    "filepath": "\/media\/a\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png",
                    "previewfilepath": "\/media\/ap\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png",
                    "type": "texture",
                    "channel": 2,
                    "sampler": {
                        "filter": "mipmap",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "XdfGR8",
                    "filepath": "\/media\/previz\/buffer03.png",
                    "previewfilepath": "\/media\/previz\/buffer03.png",
                    "type": "buffer",
                    "channel": 1,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "XdfGR8",
                    "channel": 0
                }
            ],
            "code": "\/\/ [SH17C] Raymarching tutorial. Created by Reinder Nijhoff 2017\n\/\/ @reindernijhoff\n\/\/ \n\/\/ https:\/\/www.shadertoy.com\/view\/4dSfRc\n\/\/\n\/\/ In this tutorial you will learn how to render a 3d-scene in Shadertoy\n\/\/ using distance fields.\n\/\/\n\/\/ The tutorial itself is created in Shadertoy, and is rendered\n\/\/ using ray marching a distance field.\n\/\/\n\/\/ The shader studied in the tutorial can be found here: \n\/\/     https:\/\/www.shadertoy.com\/view\/4dSBz3\n\/\/\n\/\/ Created for the Shadertoy Competition 2017 \n\/\/\n\/\/ Most of the render code is taken from: 'Raymarching - Primitives' by Inigo Quilez.\n\/\/\n\/\/ You can find this shader here:\n\/\/     https:\/\/www.shadertoy.com\/view\/Xds3zN\n\/\/\n\n\/\/ FONT RENDERING\n\n#define FONT_UV_WIDTH 160.\n\nivec4 LoadVec4( in ivec2 vAddr ) {\n    return ivec4( texelFetch( iChannel0, vAddr, 0 ) );\n}\n\nvoid drawStr(const uint str, const ivec2 c, const vec2 uv, const vec2 caret, const float size, const vec3 fontCol, inout vec4 outCol) {    \n    if( !(str == 0x0U || c.y < 0 || c.x < 0) ) {\n        int x = c.x % 4;\n        uint xy = (str >> ((3 - x) * 8)) % 256U;\n\n        if( xy > 0x0aU ) {\n            vec2 K = fract((uv - caret) \/ vec2(size * .45, size));\n            K.x = K.x * .6 + .2;\n            K.y = K.y * .95 - .05;\n            float d = textureLod(iChannel2, (K + vec2( xy & 0xFU, 0xFU - (xy >> 4))) \/ 16.,0.).a;\n\n            outCol.rgb = mix( fontCol, vec3(0) , smoothstep(.0,1.,smoothstep(.47,.53,d)) * .9 );\n            outCol.a = smoothstep(1.,0., smoothstep(.53,.59,d));\n        } \n    }\n}\n\nvoid mainImage( out vec4 outCol, in vec2 fragCoord ) {\n    ivec4 slideData = LoadVec4( ivec2(0,0) );\n    ivec4 text1 = LoadVec4(ivec2(0,1));\n    ivec4 text2 = LoadVec4(ivec2(0,2));\n\n    if( text1.x == 1 ) {\n        outCol = vec4(0);\n    } else {\n        outCol = texelFetch(iChannel1, ivec2(fragCoord), 0);    \n    }\n\n    vec2 uv = ((fragCoord-iResolution.xy*.5)\/iResolution.y) * FONT_UV_WIDTH;\n\n    if(text2.x > 0) { \/\/ title\n        int i = text2.x;\n\t\tuint f = 0x0U;\n\t\tif( i == 1 ) {\n\t\t\tivec2 c = ivec2( (uv - vec2(-79, 60)) * (1.\/vec2(5.85, -13)) + vec2(1,2)) - 1;\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x5261796dU : c.x < 8 ? 0x61726368U : c.x < 12 ? 0x696e6720U : c.x < 16 ? 0x64697374U : c.x < 20 ? 0x616e6365U : c.x < 24 ? 0x20666965U : c.x < 28 ? 0x6c647320U : f;\n\t\t\tdrawStr( f, c, uv, vec2(-79, 60), 13., vec3(255.\/255., 208.\/255., 128.\/255.), outCol );\t\t}\n\t\telse if( i == 2 ) {\n\t\t\tivec2 c = ivec2( (uv - vec2(-35.1, 60)) * (1.\/vec2(5.85, -13)) + vec2(1,2)) - 1;\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x43726561U : c.x < 8 ? 0x74652061U : c.x < 12 ? 0x20726179U : f;\n\t\t\tdrawStr( f, c, uv, vec2(-35.1, 60), 13., vec3(255.\/255., 208.\/255., 128.\/255.), outCol );\t\t}\n\t\telse if( i == 3 ) {\n\t\t\tivec2 c = ivec2( (uv - vec2(-43.9, 60)) * (1.\/vec2(5.85, -13)) + vec2(1,2)) - 1;\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x44697374U : c.x < 8 ? 0x616e6365U : c.x < 12 ? 0x20666965U : c.x < 16 ? 0x6c647320U : f;\n\t\t\tdrawStr( f, c, uv, vec2(-43.9, 60), 13., vec3(255.\/255., 208.\/255., 128.\/255.), outCol );\t\t}\n\t\telse if( i == 4 ) {\n\t\t\tivec2 c = ivec2( (uv - vec2(-23.4, 60)) * (1.\/vec2(5.85, -13)) + vec2(1,2)) - 1;\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x4c696768U : c.x < 8 ? 0x74696e67U : f;\n\t\t\tdrawStr( f, c, uv, vec2(-23.4, 60), 13., vec3(255.\/255., 208.\/255., 128.\/255.), outCol );\t\t}\n\n    }\n    if(text2.y > 0) { \/\/ body\n        int i = text2.y;\n\t\tivec2 c = ivec2( (uv - vec2(-120, 40)) * (1.\/vec2(3.6, -8)) + vec2(1,2)) - 1;\n\t\tuint f = 0x0U;\n\t\tif( i == 1 || i == 2 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x496e2074U : c.x < 8 ? 0x68697320U : c.x < 12 ? 0x7475746fU : c.x < 16 ? 0x7269616cU : c.x < 20 ? 0x20796f75U : c.x < 24 ? 0x2077696cU : c.x < 28 ? 0x6c206c65U : c.x < 32 ? 0x61726e20U : c.x < 36 ? 0x686f7720U : c.x < 40 ? 0x746f2072U : c.x < 44 ? 0x656e6465U : c.x < 48 ? 0x7220200aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x61203364U : c.x < 8 ? 0x2d736365U : c.x < 12 ? 0x6e652069U : c.x < 16 ? 0x6e205368U : c.x < 20 ? 0x61646572U : c.x < 24 ? 0x746f7920U : c.x < 28 ? 0x7573696eU : c.x < 32 ? 0x67206469U : c.x < 36 ? 0x7374616eU : c.x < 40 ? 0x63652066U : c.x < 44 ? 0x69656c64U : c.x < 48 ? 0x732e2020U : f;\n\t\t}\n\t\tif( i == 2 ) {\n\t\t\tif(c.y == 3) f = c.x < 4 ? 0x41732061U : c.x < 8 ? 0x6e206578U : c.x < 12 ? 0x616d706cU : c.x < 16 ? 0x652c2077U : c.x < 20 ? 0x65207769U : c.x < 24 ? 0x6c6c2063U : c.x < 28 ? 0x72656174U : c.x < 32 ? 0x65207468U : c.x < 36 ? 0x69732062U : c.x < 40 ? 0x6c61636bU : c.x < 44 ? 0x20616e64U : c.x < 48 ? 0x2020200aU : f;\n\t\t\tif(c.y == 4) f = c.x < 4 ? 0x77686974U : c.x < 8 ? 0x65207363U : c.x < 12 ? 0x656e6520U : c.x < 16 ? 0x6f662074U : c.x < 20 ? 0x68726565U : c.x < 24 ? 0x20737068U : c.x < 28 ? 0x65726573U : c.x < 32 ? 0x206f6e20U : c.x < 36 ? 0x6120706cU : c.x < 40 ? 0x616e652eU : f;\n\t\t}\n\t\telse if( i == 3 || i == 4 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x46697273U : c.x < 8 ? 0x74207765U : c.x < 12 ? 0x20637265U : c.x < 16 ? 0x61746520U : c.x < 20 ? 0x61207261U : c.x < 24 ? 0x792e200aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x54686520U : c.x < 8 ? 0x72617920U : c.x < 12 ? 0x6f726967U : c.x < 16 ? 0x696e2028U : c.x < 20 ? 0x726f2920U : c.x < 24 ? 0x77696c6cU : c.x < 28 ? 0x20626520U : c.x < 32 ? 0x61742028U : c.x < 36 ? 0x302c302cU : c.x < 40 ? 0x31292e20U : f;\n\t\t}\n\t\tif( i == 4 ) {\n\t\t\tif(c.y == 3) f = c.x < 4 ? 0x496e2063U : c.x < 8 ? 0x6f64653aU : f;\n\t\t}\n\t\telse if( i == 5 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x4e6f7720U : c.x < 8 ? 0x77652070U : c.x < 12 ? 0x6c616365U : c.x < 16 ? 0x20612076U : c.x < 20 ? 0x69727475U : c.x < 24 ? 0x616c2073U : c.x < 28 ? 0x63726565U : c.x < 32 ? 0x6e20696eU : c.x < 36 ? 0x20746865U : c.x < 40 ? 0x20736365U : c.x < 44 ? 0x6e652e0aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x49742069U : c.x < 8 ? 0x73206c6fU : c.x < 12 ? 0x63617465U : c.x < 16 ? 0x64206174U : c.x < 20 ? 0x20746865U : c.x < 24 ? 0x206f7269U : c.x < 28 ? 0x67696e20U : c.x < 32 ? 0x616e6420U : c.x < 36 ? 0x6861730aU : f;\n\t\t\tif(c.y == 2) f = c.x < 4 ? 0x64696d65U : c.x < 8 ? 0x6e73696fU : c.x < 12 ? 0x6e73206fU : c.x < 16 ? 0x66206173U : c.x < 20 ? 0x70656374U : c.x < 24 ? 0x5f726174U : c.x < 28 ? 0x696f2078U : c.x < 32 ? 0x20312e20U : f;\n\t\t}\n\t\telse if( i == 6 || i == 7 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x57652063U : c.x < 8 ? 0x6f6d7075U : c.x < 12 ? 0x74652074U : c.x < 16 ? 0x68652072U : c.x < 20 ? 0x61792064U : c.x < 24 ? 0x69726563U : c.x < 28 ? 0x74696f6eU : c.x < 32 ? 0x20287264U : c.x < 36 ? 0x2920666fU : c.x < 40 ? 0x72206561U : c.x < 44 ? 0x6368200aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x70697865U : c.x < 8 ? 0x6c202866U : c.x < 12 ? 0x72616743U : c.x < 16 ? 0x6f6f7264U : c.x < 20 ? 0x2e787929U : c.x < 24 ? 0x206f6620U : c.x < 28 ? 0x6f757220U : c.x < 32 ? 0x76697274U : c.x < 36 ? 0x75616c20U : c.x < 40 ? 0x73637265U : c.x < 44 ? 0x656e2e20U : f;\n\t\t}\n\t\tif( i == 7 ) {\n\t\t\tif(c.y == 3) f = c.x < 4 ? 0x496e2063U : c.x < 8 ? 0x6f64653aU : f;\n\t\t}\n\t\telse if( i == 8 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x55736520U : c.x < 8 ? 0x796f7572U : c.x < 12 ? 0x206d6f75U : c.x < 16 ? 0x73652074U : c.x < 20 ? 0x6f20696eU : c.x < 24 ? 0x74657261U : c.x < 28 ? 0x63742077U : c.x < 32 ? 0x69746820U : c.x < 36 ? 0x74686520U : c.x < 40 ? 0x7363656eU : c.x < 44 ? 0x652e2020U : f;\n\t\t}\n\t\telse if( i == 9 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x41206469U : c.x < 8 ? 0x7374616eU : c.x < 12 ? 0x63652066U : c.x < 16 ? 0x69656c64U : c.x < 20 ? 0x20697320U : c.x < 24 ? 0x75736564U : c.x < 28 ? 0x20746f20U : c.x < 32 ? 0x66696e64U : c.x < 36 ? 0x20746865U : c.x < 40 ? 0x2020200aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x696e7465U : c.x < 8 ? 0x72736563U : c.x < 12 ? 0x74696f6eU : c.x < 16 ? 0x206f6620U : c.x < 20 ? 0x6f757220U : c.x < 24 ? 0x72617920U : c.x < 28 ? 0x28726f2cU : c.x < 32 ? 0x20726429U : c.x < 36 ? 0x20616e64U : c.x < 40 ? 0x20746865U : c.x < 44 ? 0x20737068U : c.x < 48 ? 0x65726573U : c.x < 52 ? 0x2020200aU : f;\n\t\t\tif(c.y == 2) f = c.x < 4 ? 0x616e6420U : c.x < 8 ? 0x706c616eU : c.x < 12 ? 0x65206f66U : c.x < 16 ? 0x20746865U : c.x < 20 ? 0x20736365U : c.x < 24 ? 0x6e652e20U : f;\n\t\t}\n\t\telse if( i == 10 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x41206469U : c.x < 8 ? 0x7374616eU : c.x < 12 ? 0x63652066U : c.x < 16 ? 0x69656c64U : c.x < 20 ? 0x20697320U : c.x < 24 ? 0x61206675U : c.x < 28 ? 0x6e637469U : c.x < 32 ? 0x6f6e2074U : c.x < 36 ? 0x68617420U : c.x < 40 ? 0x67697665U : c.x < 44 ? 0x7320616eU : c.x < 48 ? 0x2020200aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x65737469U : c.x < 8 ? 0x6d617465U : c.x < 12 ? 0x20286120U : c.x < 16 ? 0x6c6f7765U : c.x < 20 ? 0x7220626fU : c.x < 24 ? 0x756e6420U : c.x < 28 ? 0x6f662920U : c.x < 32 ? 0x74686520U : c.x < 36 ? 0x64697374U : c.x < 40 ? 0x616e6365U : c.x < 44 ? 0x20746f20U : c.x < 48 ? 0x7468650aU : f;\n\t\t\tif(c.y == 2) f = c.x < 4 ? 0x636c6f73U : c.x < 8 ? 0x65737420U : c.x < 12 ? 0x73757266U : c.x < 16 ? 0x61636520U : c.x < 20 ? 0x61742061U : c.x < 24 ? 0x6e792070U : c.x < 28 ? 0x6f696e74U : c.x < 32 ? 0x20696e20U : c.x < 36 ? 0x73706163U : c.x < 40 ? 0x652e2020U : f;\n\t\t}\n\t\telse if( i == 11 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x54686520U : c.x < 8 ? 0x64697374U : c.x < 12 ? 0x616e6365U : c.x < 16 ? 0x2066756eU : c.x < 20 ? 0x6374696fU : c.x < 24 ? 0x6e20666fU : c.x < 28 ? 0x72206120U : c.x < 32 ? 0x73706865U : c.x < 36 ? 0x72652069U : c.x < 40 ? 0x73207468U : c.x < 44 ? 0x65206469U : c.x < 48 ? 0x7374616eU : c.x < 52 ? 0x63652074U : c.x < 56 ? 0x6f20200aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x74686520U : c.x < 8 ? 0x63656e74U : c.x < 12 ? 0x6572206fU : c.x < 16 ? 0x66207468U : c.x < 20 ? 0x65207370U : c.x < 24 ? 0x68657265U : c.x < 28 ? 0x206d696eU : c.x < 32 ? 0x75732074U : c.x < 36 ? 0x68652072U : c.x < 40 ? 0x61646975U : c.x < 44 ? 0x73206f66U : c.x < 48 ? 0x20746865U : c.x < 52 ? 0x20737068U : c.x < 56 ? 0x6572652eU : f;\n\t\t}\n\t\telse if( i == 12 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x54686520U : c.x < 8 ? 0x636f6465U : c.x < 12 ? 0x20666f72U : c.x < 16 ? 0x20612073U : c.x < 20 ? 0x70686572U : c.x < 24 ? 0x65206c6fU : c.x < 28 ? 0x63617465U : c.x < 32 ? 0x64206174U : c.x < 36 ? 0x20282d31U : c.x < 40 ? 0x2c302c2dU : c.x < 44 ? 0x35293a20U : f;\n\t\t}\n\t\telse if( i == 13 || i == 14 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x57652063U : c.x < 8 ? 0x6f6d6269U : c.x < 12 ? 0x6e652064U : c.x < 16 ? 0x69666665U : c.x < 20 ? 0x72656e74U : c.x < 24 ? 0x20646973U : c.x < 28 ? 0x74616e63U : c.x < 32 ? 0x65206675U : c.x < 36 ? 0x6e637469U : c.x < 40 ? 0x6f6e7320U : c.x < 44 ? 0x62792074U : c.x < 48 ? 0x616b696eU : c.x < 52 ? 0x6720200aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x74686520U : c.x < 8 ? 0x6d696e69U : c.x < 12 ? 0x6d756d20U : c.x < 16 ? 0x76616c75U : c.x < 20 ? 0x65206f66U : c.x < 24 ? 0x20746865U : c.x < 28 ? 0x73652066U : c.x < 32 ? 0x756e6374U : c.x < 36 ? 0x696f6e73U : c.x < 40 ? 0x2e202020U : f;\n\t\t}\n\t\tif( i == 14 ) {\n\t\t\tif(c.y == 3) f = c.x < 4 ? 0x496e2063U : c.x < 8 ? 0x6f64653aU : f;\n\t\t}\n\t\telse if( i == 15 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x54686520U : c.x < 8 ? 0x746f7461U : c.x < 12 ? 0x6c206469U : c.x < 16 ? 0x7374616eU : c.x < 20 ? 0x63652066U : c.x < 24 ? 0x756e6374U : c.x < 28 ? 0x696f6e20U : c.x < 32 ? 0x666f7220U : c.x < 36 ? 0x74686973U : c.x < 40 ? 0x20736365U : c.x < 44 ? 0x6e65200aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x28696e63U : c.x < 8 ? 0x6c756469U : c.x < 12 ? 0x6e672074U : c.x < 16 ? 0x68652070U : c.x < 20 ? 0x6c616e65U : c.x < 24 ? 0x29206973U : c.x < 28 ? 0x20676976U : c.x < 32 ? 0x656e2062U : c.x < 36 ? 0x793a2020U : f;\n\t\t}\n\t\telse if( i == 16 || i == 17 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x4e6f7720U : c.x < 8 ? 0x77652063U : c.x < 12 ? 0x616e206dU : c.x < 16 ? 0x61726368U : c.x < 20 ? 0x20746865U : c.x < 24 ? 0x20736365U : c.x < 28 ? 0x6e652066U : c.x < 32 ? 0x726f6d20U : c.x < 36 ? 0x726f2069U : c.x < 40 ? 0x6e206469U : c.x < 44 ? 0x72656374U : c.x < 48 ? 0x696f6e20U : c.x < 52 ? 0x72642e0aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x45616368U : c.x < 8 ? 0x20737465U : c.x < 12 ? 0x70207369U : c.x < 16 ? 0x7a652069U : c.x < 20 ? 0x73206769U : c.x < 24 ? 0x76656e20U : c.x < 28 ? 0x62792074U : c.x < 32 ? 0x68652064U : c.x < 36 ? 0x69737461U : c.x < 40 ? 0x6e636520U : c.x < 44 ? 0x6669656cU : c.x < 48 ? 0x642e2020U : f;\n\t\t}\n\t\tif( i == 17 ) {\n\t\t\tif(c.y == 3) f = c.x < 4 ? 0x57652073U : c.x < 8 ? 0x746f7020U : c.x < 12 ? 0x74686520U : c.x < 16 ? 0x6d617263U : c.x < 20 ? 0x68207768U : c.x < 24 ? 0x656e2077U : c.x < 28 ? 0x65206669U : c.x < 32 ? 0x6e642061U : c.x < 36 ? 0x6e20696eU : c.x < 40 ? 0x74657273U : c.x < 44 ? 0x65637469U : c.x < 48 ? 0x6f6e3a20U : f;\n\t\t}\n\t\telse if( i == 18 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x4e6f7720U : c.x < 8 ? 0x74686174U : c.x < 12 ? 0x20776520U : c.x < 16 ? 0x68617665U : c.x < 20 ? 0x20666f75U : c.x < 24 ? 0x6e642074U : c.x < 28 ? 0x68652069U : c.x < 32 ? 0x6e746572U : c.x < 36 ? 0x73656374U : c.x < 40 ? 0x696f6e20U : c.x < 44 ? 0x2870203dU : c.x < 48 ? 0x20726f20U : c.x < 52 ? 0x2b207264U : c.x < 56 ? 0x202a2074U : c.x < 60 ? 0x2920200aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x666f7220U : c.x < 8 ? 0x6f757220U : c.x < 12 ? 0x7261792cU : c.x < 16 ? 0x20776520U : c.x < 20 ? 0x63616e20U : c.x < 24 ? 0x67697665U : c.x < 28 ? 0x20746865U : c.x < 32 ? 0x20736365U : c.x < 36 ? 0x6e652073U : c.x < 40 ? 0x6f6d6520U : c.x < 44 ? 0x6c696768U : c.x < 48 ? 0x74696e67U : c.x < 52 ? 0x2e20200aU : f;\n\t\t\tif(c.y == 2) f = c.x < 4 ? 0x2020200aU : f;\n\t\t\tif(c.y == 3) f = c.x < 4 ? 0x546f2061U : c.x < 8 ? 0x70706c79U : c.x < 12 ? 0x20646966U : c.x < 16 ? 0x66757365U : c.x < 20 ? 0x206c6967U : c.x < 24 ? 0x6874696eU : c.x < 28 ? 0x67207765U : c.x < 32 ? 0x20686176U : c.x < 36 ? 0x6520746fU : c.x < 40 ? 0x2063616cU : c.x < 44 ? 0x63756c61U : c.x < 48 ? 0x7465200aU : f;\n\t\t\tif(c.y == 4) f = c.x < 4 ? 0x74686520U : c.x < 8 ? 0x6e6f726dU : c.x < 12 ? 0x616c206fU : c.x < 16 ? 0x66207368U : c.x < 20 ? 0x6164696eU : c.x < 24 ? 0x6720706fU : c.x < 28 ? 0x696e7420U : c.x < 32 ? 0x702e2020U : f;\n\t\t}\n\t\telse if( i == 19 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x54686520U : c.x < 8 ? 0x6e6f726dU : c.x < 12 ? 0x616c2063U : c.x < 16 ? 0x616e2062U : c.x < 20 ? 0x65206361U : c.x < 24 ? 0x6c63756cU : c.x < 28 ? 0x61746564U : c.x < 32 ? 0x20627920U : c.x < 36 ? 0x74616b69U : c.x < 40 ? 0x6e672074U : c.x < 44 ? 0x68652063U : c.x < 48 ? 0x656e7472U : c.x < 52 ? 0x616c200aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x64696666U : c.x < 8 ? 0x6572656eU : c.x < 12 ? 0x63657320U : c.x < 16 ? 0x6f6e2074U : c.x < 20 ? 0x68652064U : c.x < 24 ? 0x69737461U : c.x < 28 ? 0x6e636520U : c.x < 32 ? 0x6669656cU : c.x < 36 ? 0x643a2020U : f;\n\t\t}\n\t\telse if( i == 20 || i == 21 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x57652063U : c.x < 8 ? 0x616c6375U : c.x < 12 ? 0x6c617465U : c.x < 16 ? 0x20746865U : c.x < 20 ? 0x20646966U : c.x < 24 ? 0x66757365U : c.x < 28 ? 0x206c6967U : c.x < 32 ? 0x6874696eU : c.x < 36 ? 0x6720666fU : c.x < 40 ? 0x7220610aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x706f696eU : c.x < 8 ? 0x74206c69U : c.x < 12 ? 0x67687420U : c.x < 16 ? 0x61742070U : c.x < 20 ? 0x6f736974U : c.x < 24 ? 0x696f6e20U : c.x < 28 ? 0x28302c32U : c.x < 32 ? 0x2c30292eU : f;\n\t\t}\n\t\tif( i == 21 ) {\n\t\t\tif(c.y == 3) f = c.x < 4 ? 0x496e2063U : c.x < 8 ? 0x6f64653aU : f;\n\t\t}\n\t\telse if( i == 22 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x416e6420U : c.x < 8 ? 0x77652061U : c.x < 12 ? 0x72652064U : c.x < 16 ? 0x6f6e6521U : c.x < 20 ? 0x2020200aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x2020200aU : f;\n\t\t\tif(c.y == 2) f = c.x < 4 ? 0x41646469U : c.x < 8 ? 0x6e672061U : c.x < 12 ? 0x6d626965U : c.x < 16 ? 0x6e74206fU : c.x < 20 ? 0x63636c75U : c.x < 24 ? 0x73696f6eU : c.x < 28 ? 0x2c202866U : c.x < 32 ? 0x616b6529U : c.x < 36 ? 0x20726566U : c.x < 40 ? 0x6c656374U : c.x < 44 ? 0x696f6e73U : c.x < 48 ? 0x2c20200aU : f;\n\t\t\tif(c.y == 3) f = c.x < 4 ? 0x736f6674U : c.x < 8 ? 0x20736861U : c.x < 12 ? 0x646f7773U : c.x < 16 ? 0x2c20666fU : c.x < 20 ? 0x672c2061U : c.x < 24 ? 0x6d626965U : c.x < 28 ? 0x6e74206cU : c.x < 32 ? 0x69676874U : c.x < 36 ? 0x696e6720U : c.x < 40 ? 0x616e6420U : c.x < 44 ? 0x73706563U : c.x < 48 ? 0x756c6172U : c.x < 52 ? 0x206c6967U : c.x < 56 ? 0x6874696eU : c.x < 60 ? 0x6720200aU : f;\n\t\t\tif(c.y == 4) f = c.x < 4 ? 0x6973206cU : c.x < 8 ? 0x65667420U : c.x < 12 ? 0x61732061U : c.x < 16 ? 0x6e206578U : c.x < 20 ? 0x65726369U : c.x < 24 ? 0x73652066U : c.x < 28 ? 0x6f722074U : c.x < 32 ? 0x68652072U : c.x < 36 ? 0x65616465U : c.x < 40 ? 0x722e2020U : f;\n\t\t}\n\t\tdrawStr( f, c, uv, vec2(-120, 40), 8., vec3(1), outCol );\n    }\n    if(text2.z > 0) { \/\/ code\n        int i = text2.z;\n\t\tivec2 c = ivec2( (uv - vec2(-120, 0)) * (1.\/vec2(3.6, -8)) + vec2(1,2)) - 1;\n\t\tuint f = 0x0U;\n\t\tif( i == 1 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x766f6964U : c.x < 8 ? 0x206d6169U : c.x < 12 ? 0x6e496d61U : c.x < 16 ? 0x6765286fU : c.x < 20 ? 0x75742076U : c.x < 24 ? 0x65633420U : c.x < 28 ? 0x66726167U : c.x < 32 ? 0x436f6c6fU : c.x < 36 ? 0x722c2069U : c.x < 40 ? 0x6e207665U : c.x < 44 ? 0x63322066U : c.x < 48 ? 0x72616743U : c.x < 52 ? 0x6f6f7264U : c.x < 56 ? 0x29207b0aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x76656333U : c.x < 12 ? 0x20726f20U : c.x < 16 ? 0x3d207665U : c.x < 20 ? 0x63332830U : c.x < 24 ? 0x2c20302cU : c.x < 28 ? 0x2031293bU : c.x < 32 ? 0x2020200aU : f;\n\t\t\tif(c.y == 2) f = c.x < 4 ? 0x2020200aU : f;\n\t\t\tif(c.y == 3) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x76656332U : c.x < 12 ? 0x2071203dU : c.x < 16 ? 0x20286672U : c.x < 20 ? 0x6167436fU : c.x < 24 ? 0x6f72642eU : c.x < 28 ? 0x7879202dU : c.x < 32 ? 0x202e3520U : c.x < 36 ? 0x2a206952U : c.x < 40 ? 0x65736f6cU : c.x < 44 ? 0x7574696fU : c.x < 48 ? 0x6e2e7879U : c.x < 52 ? 0x2029202fU : c.x < 56 ? 0x20695265U : c.x < 60 ? 0x736f6c75U : c.x < 64 ? 0x74696f6eU : c.x < 68 ? 0x2e793b0aU : f;\n\t\t\tif(c.y == 4) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x76656333U : c.x < 12 ? 0x20726420U : c.x < 16 ? 0x3d206e6fU : c.x < 20 ? 0x726d616cU : c.x < 24 ? 0x697a6528U : c.x < 28 ? 0x76656333U : c.x < 32 ? 0x28712c20U : c.x < 36 ? 0x302e2920U : c.x < 40 ? 0x2d20726fU : c.x < 44 ? 0x293b200aU : f;\n\t\t}\n\t\telse if( i == 2 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x666c6f61U : c.x < 8 ? 0x74206d61U : c.x < 12 ? 0x70287665U : c.x < 16 ? 0x63332070U : c.x < 20 ? 0x29207b0aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x666c6f61U : c.x < 12 ? 0x74206420U : c.x < 16 ? 0x3d206469U : c.x < 20 ? 0x7374616eU : c.x < 24 ? 0x63652870U : c.x < 28 ? 0x2c207665U : c.x < 32 ? 0x6333282dU : c.x < 36 ? 0x312c2030U : c.x < 40 ? 0x2c202d35U : c.x < 44 ? 0x2929202dU : c.x < 48 ? 0x20312e3bU : c.x < 52 ? 0x2020200aU : f;\n\t\t\tif(c.y == 2) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x64203d20U : c.x < 12 ? 0x6d696e28U : c.x < 16 ? 0x642c2064U : c.x < 20 ? 0x69737461U : c.x < 24 ? 0x6e636528U : c.x < 28 ? 0x702c2076U : c.x < 32 ? 0x65633328U : c.x < 36 ? 0x322c2030U : c.x < 40 ? 0x2c202d33U : c.x < 44 ? 0x2929202dU : c.x < 48 ? 0x20312e29U : c.x < 52 ? 0x3b20200aU : f;\n\t\t\tif(c.y == 3) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x64203d20U : c.x < 12 ? 0x6d696e28U : c.x < 16 ? 0x642c2064U : c.x < 20 ? 0x69737461U : c.x < 24 ? 0x6e636528U : c.x < 28 ? 0x702c2076U : c.x < 32 ? 0x65633328U : c.x < 36 ? 0x2d322c20U : c.x < 40 ? 0x302c202dU : c.x < 44 ? 0x32292920U : c.x < 48 ? 0x2d20312eU : c.x < 52 ? 0x293b200aU : f;\n\t\t\tif(c.y == 4) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x64203d20U : c.x < 12 ? 0x6d696e28U : c.x < 16 ? 0x642c2070U : c.x < 20 ? 0x2e79202bU : c.x < 24 ? 0x20312e29U : c.x < 28 ? 0x3b20200aU : f;\n\t\t\tif(c.y == 5) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x72657475U : c.x < 12 ? 0x726e2064U : c.x < 16 ? 0x3b20200aU : f;\n\t\t\tif(c.y == 6) f = c.x < 4 ? 0x7d202020U : f;\n\t\t}\n\t\telse if( i == 3 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x666c6f61U : c.x < 8 ? 0x7420682cU : c.x < 12 ? 0x2074203dU : c.x < 16 ? 0x20312e3bU : c.x < 20 ? 0x2020200aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x666f7220U : c.x < 8 ? 0x28696e74U : c.x < 12 ? 0x2069203dU : c.x < 16 ? 0x20303b20U : c.x < 20 ? 0x69203c20U : c.x < 24 ? 0x3235363bU : c.x < 28 ? 0x20692b2bU : c.x < 32 ? 0x29207b0aU : f;\n\t\t\tif(c.y == 2) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x68203d20U : c.x < 12 ? 0x6d617028U : c.x < 16 ? 0x726f202bU : c.x < 20 ? 0x20726420U : c.x < 24 ? 0x2a207429U : c.x < 28 ? 0x3b20200aU : f;\n\t\t\tif(c.y == 3) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x74202b3dU : c.x < 12 ? 0x20683b0aU : f;\n\t\t\tif(c.y == 4) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x69662028U : c.x < 12 ? 0x68203c20U : c.x < 16 ? 0x302e3031U : c.x < 20 ? 0x29206272U : c.x < 24 ? 0x65616b3bU : c.x < 28 ? 0x2020200aU : f;\n\t\t\tif(c.y == 5) f = c.x < 4 ? 0x7d202020U : f;\n\t\t}\n\t\telse if( i == 4 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x76656333U : c.x < 8 ? 0x2063616cU : c.x < 12 ? 0x634e6f72U : c.x < 16 ? 0x6d616c28U : c.x < 20 ? 0x696e2076U : c.x < 24 ? 0x65633320U : c.x < 28 ? 0x7029207bU : c.x < 32 ? 0x2020200aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x76656332U : c.x < 12 ? 0x2065203dU : c.x < 16 ? 0x20766563U : c.x < 20 ? 0x3228312eU : c.x < 24 ? 0x302c202dU : c.x < 28 ? 0x312e3029U : c.x < 32 ? 0x202a2030U : c.x < 36 ? 0x2e303030U : c.x < 40 ? 0x353b200aU : f;\n\t\t\tif(c.y == 2) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x72657475U : c.x < 12 ? 0x726e206eU : c.x < 16 ? 0x6f726d61U : c.x < 20 ? 0x6c697a65U : c.x < 24 ? 0x2820200aU : f;\n\t\t\tif(c.y == 3) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x20202020U : c.x < 12 ? 0x652e7879U : c.x < 16 ? 0x79202a20U : c.x < 20 ? 0x6d617028U : c.x < 24 ? 0x70202b20U : c.x < 28 ? 0x652e7879U : c.x < 32 ? 0x7929202bU : c.x < 36 ? 0x2020200aU : f;\n\t\t\tif(c.y == 4) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x20202020U : c.x < 12 ? 0x652e7979U : c.x < 16 ? 0x78202a20U : c.x < 20 ? 0x6d617028U : c.x < 24 ? 0x70202b20U : c.x < 28 ? 0x652e7979U : c.x < 32 ? 0x7829202bU : c.x < 36 ? 0x2020200aU : f;\n\t\t\tif(c.y == 5) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x20202020U : c.x < 12 ? 0x652e7978U : c.x < 16 ? 0x79202a20U : c.x < 20 ? 0x6d617028U : c.x < 24 ? 0x70202b20U : c.x < 28 ? 0x652e7978U : c.x < 32 ? 0x7929202bU : c.x < 36 ? 0x2020200aU : f;\n\t\t\tif(c.y == 6) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x20202020U : c.x < 12 ? 0x652e7878U : c.x < 16 ? 0x78202a20U : c.x < 20 ? 0x6d617028U : c.x < 24 ? 0x70202b20U : c.x < 28 ? 0x652e7878U : c.x < 32 ? 0x7829293bU : c.x < 36 ? 0x2020200aU : f;\n\t\t\tif(c.y == 7) f = c.x < 4 ? 0x7d202020U : f;\n\t\t}\n\t\telse if( i == 5 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x69662028U : c.x < 8 ? 0x68203c20U : c.x < 12 ? 0x302e3031U : c.x < 16 ? 0x29207b0aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x76656333U : c.x < 12 ? 0x2070203dU : c.x < 16 ? 0x20726f20U : c.x < 20 ? 0x2b207264U : c.x < 24 ? 0x202a2074U : c.x < 28 ? 0x3b20200aU : f;\n\t\t\tif(c.y == 2) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x76656333U : c.x < 12 ? 0x206e6f72U : c.x < 16 ? 0x6d616c20U : c.x < 20 ? 0x3d206361U : c.x < 24 ? 0x6c634e6fU : c.x < 28 ? 0x726d616cU : c.x < 32 ? 0x2870293bU : c.x < 36 ? 0x2020200aU : f;\n\t\t\tif(c.y == 3) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x76656333U : c.x < 12 ? 0x206c6967U : c.x < 16 ? 0x6874203dU : c.x < 20 ? 0x20766563U : c.x < 24 ? 0x3328302cU : c.x < 28 ? 0x20322c20U : c.x < 32 ? 0x30293b0aU : f;\n\t\t\tif(c.y == 4) f = c.x < 4 ? 0x2020200aU : f;\n\t\t\tif(c.y == 5) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x666c6f61U : c.x < 12 ? 0x74206469U : c.x < 16 ? 0x66203d20U : c.x < 20 ? 0x636c616dU : c.x < 24 ? 0x7028646fU : c.x < 28 ? 0x74286e6fU : c.x < 32 ? 0x726d616cU : c.x < 36 ? 0x2c206e6fU : c.x < 40 ? 0x726d616cU : c.x < 44 ? 0x697a6528U : c.x < 48 ? 0x6c696768U : c.x < 52 ? 0x74202d20U : c.x < 56 ? 0x7029292cU : c.x < 60 ? 0x20302e2cU : c.x < 64 ? 0x20312e29U : c.x < 68 ? 0x3b20200aU : f;\n\t\t\tif(c.y == 6) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x64696620U : c.x < 12 ? 0x2a3d2035U : c.x < 16 ? 0x2e202f20U : c.x < 20 ? 0x646f7428U : c.x < 24 ? 0x6c696768U : c.x < 28 ? 0x74202d20U : c.x < 32 ? 0x702c206cU : c.x < 36 ? 0x69676874U : c.x < 40 ? 0x202d2070U : c.x < 44 ? 0x293b200aU : f;\n\t\t\tif(c.y == 7) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x66726167U : c.x < 12 ? 0x436f6c6fU : c.x < 16 ? 0x72203d20U : c.x < 20 ? 0x76656334U : c.x < 24 ? 0x28766563U : c.x < 28 ? 0x3328706fU : c.x < 32 ? 0x77286469U : c.x < 36 ? 0x662c2030U : c.x < 40 ? 0x2e343534U : c.x < 44 ? 0x3529292cU : c.x < 48 ? 0x2031293bU : c.x < 52 ? 0x2020200aU : f;\n\t\t\tif(c.y == 8) f = c.x < 4 ? 0x7d202020U : f;\n\t\t}\n\t\tdrawStr( f, c, uv, vec2(-120, 0), 8., vec3(.8,.95,1.), outCol );\n        if( text1.y > 0 ) {\n           if(uv.y >  - (-1.+float(text1.y))*8. && c.y >= 0 ) {\n                outCol *= vec4(.5,.2,.6,.8);\n            }\n        }\n        if( text1.z > 0 ) {\n            if(uv.y <  - (-2.+float(text1.z))*8. && c.y >= 0 ) {\n                outCol *= vec4(.5,.2,.6,.8);\n            }\n        }\n    }\n    if(slideData.y == 120) { \/\/ footer\n        int i = 1;\n\t\tuint f = 0x0U;\n\t\tif( i == 1 ) {\n\t\t\tivec2 c = ivec2( (uv - vec2(-38.8, -78)) * (1.\/vec2(3.38, -7.5)) + vec2(1,2)) - 1;\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x50726573U : c.x < 8 ? 0x73207370U : c.x < 12 ? 0x61636520U : c.x < 16 ? 0x746f2063U : c.x < 20 ? 0x6f6e7469U : c.x < 24 ? 0x6e756520U : f;\n\t\t\tdrawStr( f, c, uv, vec2(-38.8, -78), 7.5, vec3(.9), outCol );\t\t}\n\n    }\n}",
            "name": "Buffer D",
            "description": "",
            "type": "buffer"
        }
    ]
}