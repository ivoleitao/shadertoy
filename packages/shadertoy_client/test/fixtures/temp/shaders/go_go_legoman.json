{
    "ver": "0.1",
    "info": {
        "id": "MsB3zK",
        "date": "1390945344",
        "viewed": 3308,
        "name": "Go Go LegoMan !",
        "username": "iapafoto",
        "description": "[mouse drag] - camera position\n#define ANTIALIASING - Activate antialiasing (line 4)",
        "likes": 83,
        "published": 1,
        "flags": 32,
        "usePreview": 0,
        "tags": [
            "raymarching",
            "distancefunction",
            "lego",
            "legoman",
            "minifig"
        ],
        "hasliked": 0
    },
    "renderpass": [
        {
            "inputs": [
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dfGRr",
                    "channel": 0
                }
            ],
            "code": "\/\/ Created by sebastien durand - 05\/2017\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/---------------------------------------------------\n\/\/ The DOF process :\n\/\/ For each neigbourg pixels, the algo calculate if the 3D reconstruct pixelPoint is effectively in \n\/\/ the 3D cone (circle) of confusion of the pixel. Otherwise it is ignored.\n\/\/ => Avoid artfacts on the edges\n\/\/\n\/\/ Inspired by Dave Hoskins bokeh disc [https:\/\/www.shadertoy.com\/view\/4d2Xzw]\n\/\/---------------------------------------------------\n\n\n\n#define WITH_DOF\n#define WITH_CONE_TEST\n\n\n#ifdef WITH_DOF\n\nconst float fov = 12.;\nconst float aperture = 1.;\n\nconst float cosAngle = cos(radians(aperture\/2.));\nconst float GA =2.399;  \/\/ golden angle = 2pi\/(1+phi)\nconst mat2 rot = mat2(cos(GA),sin(GA),-sin(GA),cos(GA));\n\nvec2 res;\n    \n\n\nbool inCone(vec3 p, vec3 o, vec3 n, float side) {\n\treturn side*dot(normalize(o-p), n) >= cosAngle;\n}\n\nvec3 RD(const vec2 q) {\n    return normalize(vec3((2.* q.x - 1.) * res.x\/res.y,  (2.* q.y - 1.), fov));\n}\n\n\/\/--------------------------------------------------------------------------\n\/\/ eiffie's code for calculating the aperture size for a given distance...\nfloat coc(float t) {\n\treturn max(t*.04, (2.\/iResolution.y) * (1.+t));\n}\n\nvec3 dof(sampler2D tex, vec2 uv, float fdist) {\n    \n\tvec4 colMain = texture(tex, uv);\n    \n    const float amount = 1.;\n    \n    float rad = min(.3, coc(abs(colMain.w-fdist)));\/\/.3; \/\/ TODO calculate this for Max distance on picture\n    \n    float r=1.;\n    \n    vec3 cn = RD(uv),    \/\/ Cone axis    \n         co = cn*fdist,  \/\/ Cone origin\n         sum = vec3(0.),  \n     \t bokeh = vec3(1),\n         acc = vec3(0),\n         pixPos;\n    \n\n    vec2 pixScreen,\n         pixel = 1.\/iResolution.xy,        \n         angle = vec2(0, rad);\n    \n    vec4 pixCol;\n    \n    bool isInCone = false;\n\tfor (int j=0;j<120;j++) {  \n        r += 1.\/r;\n\t    angle *= rot;\n        \n        pixScreen = uv + pixel*(r-1.)*angle; \/\/ Neighbourg Pixel\n        pixCol = texture(tex, pixScreen);    \/\/ Color of pixel (w is depth)      \n        pixPos = pixCol.w * RD(pixScreen);   \/\/ Position of 3D point in camera base\n#ifdef WITH_CONE_TEST\n        if (inCone(pixPos, co, cn, sign(fdist - pixCol.w))) \n#endif            \n        {        \/\/ true if the point is effectivelly in the cone\n            bokeh = pow(pixCol.xyz, vec3(9.)) * amount +.4;\n            acc += pixCol.xyz * bokeh;\t\t\t\n            sum += bokeh;\n            isInCone = true;\n        }\n\t}\n        \n    \n \treturn (!isInCone) ? colMain.xyz : \/\/ Enable to deal with problem of precision when at thin begining of the cone\n       acc.xyz\/sum;\n}\n\n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord) {\n    \n    res = iResolution.xy;\n    vec2 mouse = (iMouse.xy\/iResolution.xy)*6.28;\n    vec3 ro = 45.*vec3(-cos(mouse.x), max(.8,mouse.x-2.+sin(mouse.x)*cos(mouse.y)), -.5-sin(mouse.y));\n\n    float fdist = length(ro);\/\/; 64.;\n    \n\tvec2 uv = gl_FragCoord.xy \/ iResolution.xy;\n\tfragColor=vec4(dof(iChannel0,uv,fdist),2.);\n}\n\n#else \n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n\tvec2 uv = gl_FragCoord.xy \/ iResolution.xy;\n\tfragColor= texture(iChannel0,uv);\n}\n\n\n#endif",
            "name": "Image",
            "description": "",
            "type": "image"
        },
        {
            "inputs": [],
            "outputs": [
                {
                    "id": "4dXGR8",
                    "channel": 0
                }
            ],
            "code": "\/\/ Created by sebastien durand - 01\/2014\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/#define ANTIALIASING\nconst float AA = 1.;\/\/3.; \/\/ Anti-Aliasing Level\n\n\n#define TAO 6.28318530718\n#define NB_ITER 120\n#define MAX_DIST 400.\n#define PRECISION .002\n\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\nconst vec2 \n\tV01 = vec2(0,1),\n\tVe = vec2(.001,0),\n\tleg1 = vec2(0,-.1),\n\tleg2 = vec2(0,-.8),\n\thand2 = vec2(-.1,.25);\t\n\nconst vec3\n\tv0 = vec3(0),\n\thead0 = vec3(0,-1.4,0),\n\tbody0 = vec3(0,-.15,0),\n\tmiddle1 = vec3(0,.44,0),\n\tmiddle2 = vec3(.65,.1,.325),\n\tmiddle3 = vec3(.76,0,0),\n\tarm0 = vec3(.7,-.55,0),\n\thand0 = vec3(.4,1.,.5),\n\tbbody = vec3(.47,.14,.45),\n\tbbody1 = vec3(.75,.6,1.),\n\tarm1 = vec3(-.25,-.5,0),\n\tarm2 = vec3(-.4,-1.,-.5),\n\thand1 = vec3(.02,.15,0);\n\nconst lowp float \n\tlegh = 1., \n\tlege=.34, \n\tlegx=.31, \n\thanda = -.7,\n\tface_a = 1.1,\n\tface_r = 27.;\n\nconst float \n\tface_x = 27.*0.453596121, \/\/face_r*cos(a); \/\/ precalcul\n\tface_y = -27.*0.89120736; \/\/face_r*sin(a); \/\/ precalcul\n\n\n\/\/ Global variables\nfloat time;\nvec3 sunLight, deltaMan, armn;\nvec2 boby2;\nmat2 handmat;\nvec2 fCoord;\nint scene;\n\n\nfloat hash( const in vec3 p ) {\n\tfloat h = dot(p,vec3(127.1,311.7,758.5453123));\t\n    return fract(sin(h)*43758.5453123);\n}\n\n\nfloat sdCapsule(in vec3 p, in vec3 a, in vec3 b, in float r0, in float r1 ) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)\/dot(ba,ba), 0., 1.);\n    return length( pa - ba*h ) - mix(r0,r1,h);\n}\n\nfloat smin(in float a, in float b, in float k ) {\n    float h = clamp( .5+.5*(b-a)\/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.-h);\n}\n\n\/\/ h = .5, \/\/  half of height\n\/\/ r1 = 1., \/\/main rayon\n\/\/ r2 = .2, \/\/ top border\nfloat roundCylinder(in vec3 p, in float h, in float r1, in float r2) {\n    float\n        a = abs(p.y)-(h-r2),\n        b = length(p.xz)-r1;\n    return min(min(max(a, b), max(a-r2, b+r2)), length(vec2(b+r2,a))-r2);\n}\n\nfloat head(in vec3 p) {\n    float d = max(abs(p.y+.4)-.3, length(p.xz)-.326);\n    d = min(d, roundCylinder(p, .425,.51,.1));\n    p.y -=.425;\n    return min(d, roundCylinder(p, .173, .245,.025));\n}\n\nfloat body(in vec3 p) {\n    vec3 vd = abs(p) - bbody1;\n    float d = min(max(vd.x,max(vd.y,vd.z)),0.0) + length(max(vd,0.0));\n    p.x = abs(p.x);\n    d = max(dot(p.xy, boby2)-.7,d);\n    p.y -= .4;    \n    d = min(d, length(max(abs(p)-bbody,0.0))-.16);\n    return max(abs(p.z)-.392, d);\n}\n\nfloat leg(in vec3 p) {\n    float d = length(p.zy)-lege;\n    d = min(d, length(max(abs(p+vec3(0.,legh*.5,-.08))-vec3(legx,legh*.5,lege-.08),0.)));\n    d = min(d, length(max(abs(p+vec3(0.,legh,.02))-vec3(legx,.15,lege+.02),0.)));\n    d = max(abs(p.x)-legx, d)-.02;\n    vec3 dd = abs(p+vec3(0.,legh,-.08))-vec3(legx-.1,legh+.2,lege-.18);\n    float d2 = min(max(dd.x,max(dd.y,dd.z)),0.) + length(max(dd,0.));\n    dd = abs(p+vec3(0.,legh+.1,.02))-vec3(legx-.1,.15,lege-.98);\n    d2 = min(d2, min(max(dd.x,max(dd.y,dd.z)),0.0) + length(max(dd,0.)));\n    d2 = min(d2, max(-p.z-.05, length(p.xy-leg1)-.24));\n    d2 = min(d2, max(-p.z-.05, length(p.xy-leg2)-.24));\n    return max(-d2,d);\n}\n\nfloat arm(in vec3 p) {\n    float d = smin(sdCapsule(p, v0, arm1, .22, .23), \n\t\t\t\t   sdCapsule(p, arm1, arm2, .23, .24),.02); \n    return max(dot(p, armn) - .9, d);\n}\n\nfloat hand(in vec3 p) {\n    p.yz *= handmat;\n    float d1 = length(p-hand1)-.15;\n    p.zy+=.08;\n    float d = length(p.xy);\n    d = max(-d+.18, smin(d1, d-.26,.02));\n    d = max(-length(p.xy+hand2)+.2,d);\n    return max(abs(p.z)-.2, d);\n}\n\nvec2 minObj(in vec2 o1, in vec2 o2) {\n    return (o1.x<o2.x) ? o1 : o2;\n}\n\nivec2 getId(in vec3 p) {\n    float k = 5.;\n    return (ivec2((k*100.+p.x)\/k, (k*100.+p.z)\/k)-100);\n}\n\nvec2 legoman(in vec3 p, in ivec2 id) {\n\n\tfloat a, bodyA;\n\tvec3 p0 = p;\n\tfloat sa,ca, anim=0.;\n\n\tif (scene!=1) {\n\t\tanim = -1.1+cos(float(-id.y)*.7 + 6.*iTime);\n\t} else { \/\/ walking\n\t\tanim = (p0.x<0.?1.:-1.)*cos(6.*iTime-4.);\n\t} \n\t\n\tif (scene==1) {\n\t\tp += deltaMan;\n\t}\n\telse if(scene==2) {\n  \t\tbodyA = .12*anim;\n        R(p.yz, -bodyA);\n\t}\t\n\t\n\tvec2 dHead = vec2(head(p+head0),1.);\n    vec2 dBody = vec2(body(p+body0),2.);\n   \n    float middle = length(max(abs(p+middle1)- middle2,0.0))-.05;\n    middle = min(middle,roundCylinder(p.yxz+middle3,.06,.39,.02));\n    vec2 dMiddle = vec2(middle,3.);   \n    p.x = -abs(p.x);\n           \n\tvec3 p1 = p;\n\tp1.y +=.77;\n\n\tif (scene==1) { \/\/ id.x==0 && id.y==0) {\n\t\tR(p1.yz, .4*anim); \n\t} else if (scene == 2) {\n        R(p1.yz, 2.*bodyA); \n\t}\n\t\n\tvec2 dLeg = vec2(leg(p1+vec3(.38,.77-.77,0)),4.);\n\n    p += arm0;\n\n    if (scene!=0 || id.x==0 && id.y==0) {\n        R(p.yz, .5 - anim);\n\t}\n\n    vec2 dArm = vec2(arm(p),5.);\n    vec2 dHand = vec2(hand(p+hand0),6.);\n\n    return minObj(minObj(minObj(minObj(minObj(dHead, dBody),dHand),dArm),dMiddle),dLeg);\n}\n\nvec2 DE(in vec3 p) {\n    float k = 5.;\n    ivec2 id = getId(p);\n    p.xz = mod(p.xz, k)-0.5*k;\n    return minObj(legoman(p, id), vec2(p.y+1.93,10.));\n}\n\n\nvec3 Normal(in vec3 p, in vec3 ray, in float t) {\n\tfloat pitch = .2 * t \/ iResolution.x;\n    \n\t\n\tvec2 d = vec2(-1,1) * pitch;\n\n\tvec3 p0 = p+d.xxx; \/\/ tetrahedral offsets\n\tvec3 p1 = p+d.xyy;\n\tvec3 p2 = p+d.yxy;\n\tvec3 p3 = p+d.yyx;\n\t\n\tfloat f0 = DE(p0).x;\n\tfloat f1 = DE(p1).x;\n\tfloat f2 = DE(p2).x;\n\tfloat f3 = DE(p3).x;\n\t\n\tvec3 grad = p0*f0+p1*f1+p2*f2+p3*f3 - p*(f0+f1+f2+f3);\n\t\/\/return normalize(grad);\t\/\/ prevent normals pointing away from camera (caused by precision errors)\n\treturn normalize(grad - max(.0,dot (grad,ray ))*ray);\n}\n\n\n\nfloat softshadow(in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k) {\n    float res = 1.0, h, t = mint+.1*hash(ro+rd);\n    for( int i=0; i<48; i++ ) {\n      \/\/  if (t < maxt) {\n            h = DE( ro + rd*t ).x;\n            res = min( res, k*h\/t );\n            t += .1;\n      \/\/  }\n    }\n    return clamp(res, 0., 1.);\n}\n\nfloat calcAO(in vec3 pos, in vec3 nor) {\n    float dd, hr=.01, totao=.0, sca=1.;\n    for(int aoi=0; aoi<5; aoi++ ) {\n        dd = DE(nor * hr + pos).x;\n        totao += -(dd-hr)*sca;\n        sca *= .7;\n        hr += .05;\n    }\n    return clamp(1.-4.*totao, 0., 1.);\n}\n\n\nvec3 mandelbrot(in vec2 uv) {\n\tfloat k = .5+.5*cos(iTime);\n    uv *= mix(.02, 2., k);\n\tuv.x-=(1.-k)*1.8;\n    vec2 z = vec2(0);\n    vec3 c = vec3(0);\n    for(float i=0.;i<14.;i++) {\n        if(length(z) >= 4.) continue;\n        z = vec2(z.x*z.x-z.y*z.y, 2.*z.y*z.x) + uv;\n        if(length(z) >= 2.0) {\n            c.r = i*.05;\n            c.b = sin(i*.2);\n        }\n    }\n    return sqrt(c);\n}\n\nvec3 getTexture(in vec3 p, in float m) {\n    ivec2 id = getId(p);\n\n\tvec3 p0 = p;\n    float k = 5.;\n    p.xz = mod(p.xz, k)-0.5*k;\n    \n\tif (scene==1) {\n\t\tp += deltaMan;\n\t} else if (scene == 2) {\n\t\t\n\t\tfloat anim = -1.1+cos(float(-id.y)*.7 + 6.*iTime);\n\t\t\n  \t\tfloat bodyA = .12*anim;\n\t\tfloat sa=sin(bodyA); \n\t\tfloat ca=cos(bodyA);\n\t\tp.yz *= mat2(ca, -sa, sa, ca);\n\t}\t\n    vec3 c;   \n  \n    if (m==1.) {\n\t\tc = vec3(1.,1.,0);\n\t\tfloat g = mod(iTime, TAO*3.);\n\t\tif (id.x==0 && id.y==0 && g > 2.5*TAO) {\n\t\t\tR(p.xz, -.8*cos(2.*g+1.57));\n\t\t}\n\t\tif (p.z<0.) {\n\t\t\t\/\/ Draw face\n\t\t\tvec2 p2 = p.xy;\n\t\t\tp2.y -= 1.46;\n\t\t\tp2 *= 100.;\n\t\t\tfloat px = abs(p2.x);\n\t\t\tfloat e = 4.-.08*px;\n\t\t\tfloat v = \n\t\t\t\t\t(px<face_x && p2.y<-e) ? abs(length(p2)-face_r)-e : \n\t\t\t\t\t(p2.y<-e) ? length(vec2(px,p2.y)-vec2(face_x,face_y))-e :\n\t\t\t\t\tlength(vec2(px,p2.y)-vec2(face_x,-face_y*.1))-1.8*e; \n\t\t\tv = clamp(v, 0., 1.);\n\t\t\tc = mix(vec3(0), c, v);\n\t\t}\n    }\n    else if (m==2.) {\n        c = (id.x==0 && id.y==0) ? mandelbrot(p.xy - vec2(.14,.15)) : vec3(1,0,0);\n       \n\t} else if (m==10.) {\n\t\tif (scene!=1) time = 0.;\n\t\tfloat d = .3*sin(2.2+time);\n\t\tc = vec3(.75-.25*(mod(floor(p0.x),2.)+mod(floor(p0.z+d-time*.18),2.)));\n\t \t\/\/c = vec3(.5+.5*smin(mod(floor(p0.x),2.),mod(floor(p0.z+d-time*.18),2.),1.));\n\t} else {\n        c = m == 6. ? vec3(1.,1.,0)  :\n\t\t\tm == 3. ? vec3(.2,.2,.4) :\n\t\t\tm == 4. ? vec3(.1,.1,.2) :\n\t\t\t          vec3(1.,1.,1.);\n\t\t\n    }\n    if (m==10. || !(id.x==0 && id.y==0)) {\n\t\t\/\/ black & white\n        float a = (c.r+c.g+c.b)*.33;\n\t\tc = vec3(1.,.95,.85)*a;\n    }\n\n\treturn c;\n}\n\n\nvec3 Render(in vec3 p, in vec3 rd, in float t, in float m) {\n    vec3  col = getTexture(p, m),\n    \t  nor = Normal(p, rd, t);\n\tfloat sh = 1.,\n          ao = calcAO(p, nor ),\n          amb = clamp(.5+.5*nor.y, .0, 1.),\n          dif = clamp(dot( nor, sunLight ), 0., 1.),\n          bac = clamp(dot( nor, normalize(vec3(-sunLight.x,0.,-sunLight.z))), 0., 1.)*clamp( 1.0-p.y,0.0,1.0);\n\n\tif( dif>.02 ) { sh = softshadow( p, sunLight, .02, 10., 12.); dif *= (.1+sh); }\n\t\n\tvec3 brdf = vec3(0.0);\n\tbrdf += .2*ao*amb*vec3(0.10,0.11,0.13);\n\tbrdf += .2*ao*bac*vec3(0.15);\n\tbrdf += 1.2*dif*vec3(1.,.9,.7);\n\t\n\tfloat pp = \/*1.1**\/clamp( dot(reflect(rd,nor), sunLight ), 0.0, 1.);\n\tfloat spe = 1.2*sh*pow(pp,16.0);\n\tfloat fre = .2*ao*pow(clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\n\tcol = col*(brdf + spe) + .2*fre*(0.5+0.5*col);\n    return col;\n}\n\n\nmat3 lookat(in vec3 ro, in vec3 up){\n    vec3 fw=normalize(ro),\n    \t rt=normalize(cross(fw,up));\n    return mat3(rt, cross(rt,fw),fw);\n}\n\nvec3 RD(in vec3 ro, in vec3 cp) {\n    return lookat(cp-ro, V01.xyx)*normalize(vec3((2.*fCoord-iResolution.xy)\/iResolution.y, 12.0));\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n\/\/ - Precalcul global variables ------------------------------\n\ttime = 3.14+12.*iTime;\n\tsunLight = normalize(vec3(-10.25,30.33,-7.7));\n\tdeltaMan = vec3(0,.05*sin(1.72+time),0);\n\tarmn = normalize(arm2 - arm1);\n\tboby2 = normalize(vec2(1,.15));\n\thandmat = mat2(cos(handa), -sin(handa), sin(handa), cos(handa));\n\t\n\tfloat tAnim = mod(iTime, 3.14*9.);  \n\tscene = tAnim > 3.14*9. ? 1:\n\t        tAnim > 3.14*7. ? 2:\n\t        tAnim > 3.14*6. ? 0 : 1;\n\t\n\/\/------------------------------------------------------------\n\t\n    vec2 \n\t\tobj, \n\t\tmouse = (iMouse.xy\/iResolution.xy)*6.28,\n\t\tq = fragCoord.xy\/iResolution.xy;\n\n    vec3 \n\t\tro = 45.*vec3(-cos(mouse.x), max(.8,mouse.x-2.+sin(mouse.x)*cos(mouse.y)), -.5-sin(mouse.y)),\n    \trd, cp = V01.xxx;\n\t\n    vec3 ctot = vec3(0);\n\t\n#ifdef ANTIALIASING \n\tfor (float i=0.;i<AA;i++) \n    {\n        fCoord = fragCoord.xy+.4*vec2(cos(6.28*i\/AA),sin(6.28*i\/AA));\t\n \/\/   \tfCoord = fragCoord.xy+.5*mod(vec2(iFrame\/2, iFrame),2.);\t\n#else\n\t\tfCoord = fragCoord.xy;\n#endif\n    \/\/ Camera origin (o) and direction (d)\n        rd = RD(ro, cp);\n\n        \/\/ Ray marching\n\t\tfloat m=0.;\n        float t=0.,d=1.;\n\t\t\n        for(int i=0;i<NB_ITER;i++){\n            if (abs(d)<PRECISION || t>MAX_DIST) break;\n            obj = DE(ro+rd*t);\n            t+=d=obj.x *.85;\n            if (abs(d)<PRECISION) {\n                m=obj.y;\n            }\n        }\n \n        \/\/ Render colors\n        if(t<MAX_DIST){\/\/ if we hit a surface color it\n            ctot += Render(ro + rd*t, rd,t, m);\n        }\n#ifdef ANTIALIASING \t\t\n    }\n\tctot \/=AA;\t\n#endif \n\tctot = pow(ctot, vec3(.6));\n\tctot *= pow(16.*q.x*q.y*(1.-q.x)*(1.-q.y), .11); \/\/ vigneting\n\tfragColor = vec4(ctot,t);\n\n}",
            "name": "Buf A",
            "description": "",
            "type": "buffer"
        }
    ]
}