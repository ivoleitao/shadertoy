{
    "ver": "0.1",
    "info": {
        "id": "3tKGDW",
        "date": "1579802265",
        "viewed": 5179,
        "name": "Piranha Plant",
        "username": "PixelPhil",
        "description": "A Piranah Plant inspired by Mario Bros with procedural animations and PBR-ish Lighting.\nDrag around the screen to move the camera.\n\nMusic: Underworld Remix by Zifur ",
        "likes": 80,
        "published": 3,
        "flags": 64,
        "usePreview": 0,
        "tags": [
            "procedural",
            "mario",
            "pbr",
            "plant",
            "animations",
            "piranha"
        ],
        "hasliked": 0
    },
    "renderpass": [
        {
            "inputs": [
                {
                    "id": "lt2Gz1",
                    "filepath": "https:\/\/soundcloud.com\/zifur\/underworld-remix-super-mario",
                    "previewfilepath": "https:\/\/soundcloud.com\/zifur\/underworld-remix-super-mario",
                    "type": "musicstream",
                    "channel": 0,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 0
                }
            ],
            "outputs": [
                {
                    "id": "4dfGRr",
                    "channel": 0
                }
            ],
            "code": "\/\/\n\/\/ Piranah Plant by Philippe Desgranges\n\/\/ Email: Philippe.desgranges@gmail.com\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/\n\n#define MAX_DST 50.0\n#define MIN_DST 0.004\n#define S(a,b,c) smoothstep(a,b,c)\n#define sat(a) clamp(a,0.0,1.0)\n#define ZERO (min(iFrame,0))\n\n\/\/Material regions\n#define LEAF\t\t \t0.0\n#define STEM   \t\t\t1.0\n#define HEAD\t\t\t2.0\n#define LIPS\t\t\t3.0\n#define INSIDE_MOUTH \t4.0\n#define TONGUE\t\t\t5.0\n#define\tTEETH\t\t\t6.0\n#define\tPOT\t\t\t\t7.0\n#define\tSOIL\t\t\t8.0\n#define\tHILL\t\t\t9.0\n#define SKY\t\t\t\t10.0\n\nconst vec3 leafGreen  = vec3(0.21, 0.66, 0.23);\nconst vec3 leafInside = vec3(0.52, 1.00, 0.36);\n\n\/\/ All the parametters for an animation pose\nstruct KeyFrame\n{\n    float leafAngle;\n    float mouthAngle;\n    float spine1;\n    float spine2;\n    float spine3;\n    float neck;\n};\n\n\/\/ Linear interpolation between two animation frames\nvoid mixKeyFrame(KeyFrame a, KeyFrame b, float ratio, out KeyFrame c)\n{\n    ratio = ratio*ratio*(3.0-2.0*ratio); \/\/ Thanks iq :D\n    \n    c.leafAngle\t\t= mix(a.leafAngle , b.leafAngle\t  , ratio);\n    c.mouthAngle\t= mix(a.mouthAngle, b.mouthAngle  , ratio);\n    c.spine1\t\t= mix(a.spine1\t  , b.spine1\t  , ratio);\n    c.spine2\t\t= mix(a.spine2\t  , b.spine2\t  , ratio);\n    c.spine3\t\t= mix(a.spine3\t  , b.spine3\t  , ratio);\n    c.neck\t\t\t= mix(a.neck\t  , b.neck\t\t  , ratio);\n}\n\n\/\/ all matrices and offsets that needs to be pre-computed\n\/\/ in order to keep the SDF relatively straightforward\nstruct PlantSpace\n{\n   \/\/mat4 viewMat;\n   \n   \/\/ Leaf Matrix\n   mat2 matLeaf;\n   \n   \/\/ Spine\n   float joint1AngleZ;\n   float joint2AngleZ;\n   float joint3AngleZ;\n   mat4 joint1;\n   mat4 joint2;\n   mat4 head;\n   \n   \/\/ Head \/ Mouth\n   float mouthAngle;\n   mat2 mouthRot;\n   mat2 teethRot;\n   mat2 teethRot2;\n   vec3 tPos1;\n   vec3 tPos2;\n   vec3 tPos3;\n   vec3 tPos4;\n   vec3 tPos5;\n};\n\n\/\/ Attributes of a PBR material\nstruct PBRMat\n{\n    vec3 albedo;\n    float metalness;\n    float roughness;\n    float occlusion;\n};\n\n\/\/ From world space to leaf space (before symmetry)\nvec3 leafSpace(vec3 pos, PlantSpace ps)\n{\n    vec3 leafPos = pos;\n    \n    leafPos.z = abs(leafPos.z) - 2.8;\n    leafPos.y  += ps.matLeaf[0][1] * 2.8;\n    leafPos.zy = ps.matLeaf * leafPos.zy;\n    \n    return leafPos;\n}\n\n\/\/ Distance to the leaf cutout pattern (on xz)\nfloat dstLeaf(vec3 leafPos)\n{\n    float c1 = 1.1 - length(leafPos.zx - vec2(2.8, 1.1));\n    float c2 = 1.25 - length(leafPos.zx - vec2(1.1, 2.5));\n    return max(c1, c2);\n}\n\n\/\/ Color of the LEAF region from pos in world space\nvec3 LeafColor(vec3 pos, PlantSpace ps)\n{\n    vec3 leafPos = leafSpace(pos, ps);\n   \n    leafPos.x = abs(leafPos.x); \/\/ The fishbone pattern uses x symetry in leaf space\n    \n    float d = leafPos.x - 0.15; \/\/ central line\n    float l = abs(0.5 - fract(leafPos.z + leafPos.x * 0.5 + 0.20)) * 2.0 - 0.25; \/\/ 'fins'\n    \n    leafPos.z = abs(leafPos.z); \/\/ The lighter area uses x and z symettry\n   \n    float dst = dstLeaf(leafPos); \n    \n    float p = smin(d, l, 0.3) + S(-1.2, -0.0, dst) * 0.28;\n    float pattern = S(-0.05, 0.05, p); \/\/ Fishbone pattern mask\n    \n    float area = S(-0.5, -0.6, dst); \/\/ Lighter area\n    \n    vec3 col = mix(leafGreen, leafInside, min(area, pattern));\n    \n    return col;\n}\n\n\/\/ Computes the color of the HEAD region from pos in world space\nvec3 HeadColor(vec3 pos, PlantSpace ps)\n{\n    \/\/ Compute a unit vector from inside the head in head space\n    vec3 headPos = normalize((ps.head * vec4(pos, 1.0)).xyz - vec3(0, 3, 0));\n    \n    \n    vec3 dir = vec3(0, -length(headPos.xy), headPos.z); \/\/Longitudinal vector on the \n    \n    \/\/ The vector is rotated around the jaw taking into account the mouth opening\n    \/\/ To simulate the skin 'stretching'\n    float zAngle = atan(headPos.x, -headPos.y) * (pi \/ (pi - ps.mouthAngle));\n    dir = (rotationZ(zAngle) * vec4(dir, 0.0)).xyz;\n    \n    dir.xz = abs(dir.xz); \/\/ Symetry on x & z for more dots faster\n\n    \/\/ Compute the distances with all the dots in the unit sphere\n    \/\/ hopefully the compiler optimizes out all these normalize()\n    float d = S(0.95, 0.96, dot(dir, normalize(vec3(1, 0.1, 0))));\n    d += S(0.96, 0.97, dot(dir, normalize(vec3(1, 1, 0.9))));\n    d += S(0.94, 0.95, dot(dir, normalize(vec3(0.7, -0.3, 0.9))));\n    d += S(0.96, 0.97, dot(dir, normalize(vec3(0.6, -0.6, 0.0))));\n    d += S(0.97, 0.98, dot(dir, normalize(vec3(0.0, -1.25, 1.0))));\n    \n    return mix(vec3(0.8, 0.18, 0.25), vec3(1.0),  d);\n}\n\n\/\/ Astro turf on the hill\nvoid HillColor(vec3 pos, out PBRMat mat)\n{\n    vec2 noizeUV = pos.xz * 0.65;\n    \n    \/\/ Compute a low frequency 2D vector field\n    vec2 noise = vec2(Noise2(noizeUV.xy + vec2(455.0, 123.9)) - 0.5, Noise2(noizeUV.xy + vec2(-6.8, 467.23)) - 0.5);\n    \n    \/\/ Compute a high frequency noise stretched by the vector field\n    float grass = sat(Noise2(pos.xz * 7.0 + noise.xy * 15.0) + length(noise) * 2.0);\n    \n    \/\/ Mix in some octaves of noise\n    grass -= (Noise2(pos.xz * 5.0) + Noise2(pos.xz * 10.0) + Noise2(pos.xz * 20.0))  * 0.3;\n\n    vec3 strands = mix(vec3(0.3, 1.0, 0.4), vec3(0.1, 0.5, 0.4), grass);\n    \n    \/\/use the strands mask as occlusion for richer shadows\n    mat = PBRMat(strands, 0.2, 0.8 , sat(grass)); \n}\n\n\n\/\/ Computes a PBR Material from material ID and world position\nvoid GetColor(float id, vec3 pos, PlantSpace ps, out PBRMat mat, out vec3 normalBend)\n{   \n    normalBend = vec3(0);\n    \n    if (id == LEAF){\n        mat = PBRMat(LeafColor(pos, ps), 0.3, 0.2, 1.0);\n    \treturn;\n    }\n    else if (id == STEM){\n        mat = PBRMat(leafGreen, 0.3, 0.2, 1.0);\n    \treturn;\n    }\n    else if (id == HEAD){\n        mat = PBRMat(HeadColor(pos, ps), 0.5, 0.1, 1.0);\n    \treturn;\n    }\n    else if (id == LIPS){\n        mat = PBRMat(vec3(1.0, 1.0, 1.0), 0.05, 1.0, 1.0);\n    \treturn;\n    }\n    else if (id == INSIDE_MOUTH){\n        mat = PBRMat(vec3(0.7, 0.0, 0.5), 0.3, 0.2, 1.0);\n    \treturn;\n    }\n    else if (id == TONGUE){\n        mat = PBRMat(vec3(1.0, 0.4, 0.4), 0.7, 0.8, 1.0);\n    \treturn;\n    }\n    else if (id == TEETH){\n        mat = PBRMat(vec3(1.0, 1.0, 1.0), 0.4, 0.2, 1.0);\n    \treturn;\n    }\n    else if (id == POT){\n        mat = PBRMat(vec3(0.2, 0.2, 0.6), 1.0, 0.3, 1.0);\n    \treturn;\n    } \n    else if (id == SOIL){\n        vec2 nCoords = pos.xz * 4.0;\n    \tnormalBend = vec3(Noise2(nCoords) - 0.5, 0.0, Noise2(nCoords.yx + vec2(45.5, 45.5)) - 0.5);\n        mat = PBRMat(vec3(0.31, 0.2, 0.08), 0.15, 1.0, 1.0);\n        return;\n    }\n    else if (id == HILL){\n        HillColor(pos, mat);\n    \treturn;\n    }\n\telse if (id == SKY){\n        mat = PBRMat(vec3(0.5, 0.6, 1.0), 0.0, 0.0, 1.0);\n    \treturn;\n    }  \t\n}\n\n\/\/ Somehow the switch block didn't work with the iOS compiler\n\/*\nvoid GetColor(float id, vec3 pos, PlantSpace ps, out PBRMat mat, out vec3 normalBend)\n{   \n    normalBend = vec3(0);\n    \n    switch(int(id))\n    {\n      case int(LEAF):\n        mat = PBRMat(LeafColor(pos, ps), 0.3, 0.2, 1.0);\n        return;\n      case int(STEM):\n        mat = PBRMat(leafGreen, 0.3, 0.2, 1.0);\n        return;\n      case int(HEAD):\n        mat = PBRMat(HeadColor(pos, ps), 0.6, 0.1, 1.0);\n        return;\n      case int(LIPS):\n        mat = PBRMat(vec3(1.0, 1.0, 1.0), 0.05, 1.0, 1.0);\n        return;\n      case int(INSIDE_MOUTH):\n        mat = PBRMat(vec3(0.7, 0.0, 0.5), 0.3, 0.2, 1.0);\n        return;\n      case int(TONGUE):\n        mat = PBRMat(vec3(1.0, 0.4, 0.4), 0.8, 0.6, 1.0);\n        return;\n      case int(TEETH):\n        mat = PBRMat(vec3(1.0, 1.0, 1.0), 0.4, 0.2, 1.0);\n        return;\n      case int(POT):\n        mat = PBRMat(vec3(0.2, 0.2, 0.6), 1.0, 0.3, 1.0);\n        return; \n      case int(SOIL):\n        vec2 nCoords = pos.xz * 4.0;\n        normalBend = vec3(Noise2(nCoords) - 0.5, 0.0, Noise2(nCoords.yx + vec2(45.5, 45.5)) - 0.5);\n        mat = PBRMat(vec3(0.31, 0.2, 0.08), 0.15, 1.0, 1.0);\n        return;\n      case int(HILL):\n        HillColor(pos, normalBend, mat);\n        return;\n      case int(SKY):\n        mat = PBRMat(vec3(0.5, 0.6, 1.0), 0.0, 0.0, 1.0);\n        return;  \t\n    }\n}\n*\/\n\n\/\/ Build all the matrices and offsets necessary to compute the SDF\n\/\/ leaving all that in would lead to bad perfs and crazy compile times\nvoid buildPlantSpace(KeyFrame frame, out PlantSpace res)\n{\n    \/\/ Leaves\n    float leafAngle = frame.leafAngle;\/\/  -(sin(iTime) * 0.2 + 0.1);\n    float leafSin = sin(leafAngle);\n    float leafCos = cos(leafAngle);\n    \n    res.matLeaf = mat2(-leafCos, leafSin, leafSin, leafCos);\n\n    \/\/ Spine\n    res.joint1AngleZ = frame.spine1;\n    res.joint2AngleZ = frame.spine2;\n    res.joint3AngleZ = frame.spine3;\n    \n    res.joint1 = joint3DMatrix(3.0, res.joint1AngleZ);\n    res.joint2 = rotationY(frame.neck) * joint3DMatrix(3.0, res.joint2AngleZ) * res.joint1;\n    \n    \n    \/\/ Head \/ Mouth\n    float MouthAngle = frame.mouthAngle;\n    res.mouthAngle = MouthAngle;\n    \n    float scale = 1.0 - MouthAngle * 0.07;\n    res.head = scaleMatrix(vec3(scale, 1, 1)) * joint3DMatrix(3.0, res.joint3AngleZ) * res.joint2;\n\n    float c = cos(MouthAngle);\n    float s = sin(MouthAngle);\n   \t\n    res.mouthRot = mat2(c, s, s, -c);\n\t\n    \n    float c2 = cos(MouthAngle * 0.5);\n    float s2 = sin(MouthAngle * 0.5);\n    \n    res.teethRot = mat2(s2, -c2,\n                     c2, s2);\n    \n    res.teethRot2 = mat2(s2,  c2,\n                        -c2, s2);\n    \n    res.tPos1 = vec3(s * 1.5, -1.1, 0.0);\n    res.tPos2 = vec3(s * 1.2, -0.8, 1.1);\n    res.tPos3 = vec3(s * 0.6, -1.0, 1.5);\n    res.tPos4 = vec3(-s * 1.5, -1.0, 0.56);\n    res.tPos5 = vec3(-s * 1.2, -1.3, 1.3);\n}\n\n\/\/ Signed distance foe a leaf (pos in leaf space)\nfloat sdLeaf(vec3 pos)\n{\n    pos.xz = abs(pos.xz); \/\/ Leaf geometry uses symetry on x & z\n    \n    \/\/ Starts with an ellipsoid slightly offset from symmetry plane.\n    float leaf = sdEllipsoid(pos - vec3(0.5, 0, 0), vec3(1.4, 0.9, 3));\n    \n    if (leaf > 0.8)\n    {\n        \/\/Early exit with bounding volume\n        return leaf - 0.05;\n    }\n    \n    \n    leaf = abs(leaf) - 0.11; \/\/ Onioning\n    \n    float patternDist = dstLeaf(pos); \/\/ Cutout pattern SDF\n    \n    float offset = 0.0;\n    \n    leaf = smax(leaf, patternDist, 0.2); \/\/Cutout the shape\n    leaf = smax(leaf, -pos.y, 0.2); \/\/remove the lower part\n    \n    return (leaf - offset) * 0.6; \/\/ the 0.6 ratio removed ray marching artefacts\n}\n\n\/\/ Computes the sdf to the head (y is material id)\nvec2 sdHead(vec3 pos, PlantSpace ps)\n{\n    \/\/Head space is Mouth Up\n    \n    \/\/ Head starts with a sphere\n    float head = sdSphere(pos - vec3(0, 3, 0), 2.8);\n    \n    if (head > 1.0)\n    {\n        \/\/Early exit with bounding volume\n        return vec2(head - 0.5, HEAD);\n    }\n    \n    pos.z = abs(pos.z); \/\/ Right\/Left Symmetry\n    \n    vec2 ac = vec2(1,0);\n    \n    \n    \n    \/\/ Compute teeth implantation positions\n    \/\/ 5 teeth for the 9 on the plant (The top middle one is on the symmetry plane)\n    vec3 teethPos = vec3(ps.teethRot * (pos.xy - vec2(0, 3)), pos.z);\n  \n    vec3 tPos = teethPos - ps.tPos1;\n    vec3 tPos2 = teethPos - ps.tPos2;\n    vec3 tPos3 = teethPos - ps.tPos3;\n    \n    vec3 teethPos2 = vec3(ps.teethRot2 * (pos.xy - vec2(0, 3)), pos.z);\n    \n    vec3 tPos4 = teethPos2 - ps.tPos4;\n    vec3 tPos5 = teethPos2 - ps.tPos5;\n    \n    \/\/ Compute teeths SDFs\n    float teeth =      sdRoundCone(tPos, 0.5, 0.15, 1.5);\n    teeth = min(teeth, sdRoundCone(tPos2, 0.5, 0.15, 1.2));\n    teeth = min(teeth, sdRoundCone(tPos3, 0.5, 0.15, 1.2));\n    teeth = min(teeth, sdRoundCone(tPos4, 0.5, 0.15, 1.2));\n    teeth = min(teeth, sdRoundCone(tPos5, 0.5, 0.15, 1.2));\n    \n\n    \n    \/\/ Inside of the mouth is a soft compooud of 3 speres \n    float mouthInside = sdSphere(pos - vec3(0, 3.5, 0), 2.2);\n\tmouthInside = smin(mouthInside, sdSphere(pos - vec3(0.2, 1.5, 0.0), 0.9), 0.3);\n    mouthInside = smax(mouthInside, -sdSphere(pos - vec3(0.8, 1.6, 0.0), 0.4), 0.5);\n    \n    \/\/ Tongue is an ellipsoid\n    float tongue = sdEllipsoid(pos - vec3(-1.0, 2.2, 0.0), vec3(0.7, 1.7, 1.2));\n\n    \/\/ Adds X symmetry to compute both lips simultaneously\n\tpos.x = abs(pos.x); \n    \n    vec3 lp = pos.zyx;\n    lp.y -= 3.0;\n    lp.yz = lp.yz * ps.mouthRot;\n    \n    float lips = sdCappedTorus(lp, ac, 2.6, 0.8);\n    \n    \/\/ Cut open the head like a Pac Man \n    vec2 pc = pos.xy - vec2(0, 3.0);\n    float plane2 = dot(pc, vec2(ps.mouthRot[1][1], ps.mouthRot[0][1]));\n    head = max(plane2, head);\n    \n    \/\/ Combine all parts of the head with material ids\n    vec2 res = vec2(head, HEAD);\n    res = combineMax(res, vec2(-mouthInside, INSIDE_MOUTH));\n    res = combineMin(res, vec2(teeth, TEETH));\n    res = combineMin(res, vec2(lips, LIPS));\n    res = combineMin(res, vec2(tongue, TONGUE));\n    \n    return res;\n}\n\n\n\/\/ SDF of the scene\nvec2 SDF(vec3 pos, PlantSpace ps)\n{\n    \/\/ Hill\n    vec3 hillPos = pos - vec3(0, -20, 0);\n    hillPos.y = max(0.0, hillPos.y);\n    float hillDst = length(hillPos);\n    \n    float hill = (hillDst - 17.0);\n    \n    \n    float cDist = length(pos.xz);\/\/ Infinite cylinder to carve a hole in the Pot\n    \n    float pot = sdRoundedCylinder(pos - vec3(0, -0.5, 0), 1.3, 0.25, 0.5);\n    pot = smax(pot, 1.9 - cDist, 0.25);\n    \n    vec2 pipe = combineMax(vec2(cDist - 2.0, POT), vec2(pos.y, SOIL));\n    \n    \/\/ Pipe + Soil with materila Ids\n    vec2 potCol = combineMin(vec2(pot, POT), pipe);\n    \n    float leaf = sdLeaf(leafSpace(pos, ps));\n    \n    \/\/ The stem is 3 Joint3DSphere chained\n    float stem = smin(sdSphere(pos, 0.8), sdJoint3DSphere(pos,  3.0, ps.joint1AngleZ \/*0.4*\/, 0.5), 0.8);\n    \n    vec3 newPos = (ps.joint1 * vec4(pos, 1.0)).xyz;\n    stem = min(stem, sdJoint3DSphere(newPos,  3.0, ps.joint2AngleZ \/*-0.75*\/, 0.5));\n    \n    newPos = (ps.joint2 * vec4(pos, 1.0)).xyz;\n    stem = min(stem, sdJoint3DSphere(newPos,  3.0, ps.joint3AngleZ \/*sin(iTime * 0.7) * 0.2 - 0.5*\/, 0.5));\n    \n    vec3 headPos = (ps.head * vec4(pos, 1.0)).xyz;\n    \n    \/\/ A rounded cylinder is addded as the 'neck'\n    stem = smin(stem, sdRoundedCylinder(headPos, 0.5, 0.4, 0.0), 0.3);\n    \n    \/\/ Combine all parts together with materil ids\n    vec2 res = sdHead(headPos, ps);\n    res = combineMin(res, vec2(leaf, LEAF));\n    res = combineMin(res, vec2(stem, STEM));\n\tres = combineMin(res, potCol);\n    res = combineMin(res, vec2(hill, HILL));\n\n\treturn res;\n}\n\n\n\/\/ http:\/\/iquilezles.org\/www\/articles\/normalsSDF\/normalsSDF.htm\nvec3 calcNormal( vec3 pos, PlantSpace ps)\n{\n    \/\/ inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    \n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e * SDF(pos+0.0005*e, ps).x;\n    }\n    return normalize(n);\n}\n\n\/\/ inspired by\n\/\/ http:\/\/iquilezles.org\/www\/articles\/rmshadows\/rmshadows.htm\nfloat shadow(vec3 pos, vec3 lPos, PlantSpace ps)\n{   \n    vec3 dir = lPos - pos;  \/\/ Light direction & disantce\n    \n    float len = length(dir);\n    dir \/= len;\t\t\t\t\/\/ It's normalized now\n    \n    pos += dir * MIN_DST * 2.0;  \/\/ Get out of the surface\n    \n    float dst = SDF(pos, ps).x; \/\/ Get the SDF\n    \n    \/\/ Start casting the ray\n    float t = 0.0;\n    float obscurance = 1.0;\n    \n    while (t < len)\n    {\n        if (dst < MIN_DST) return 0.0; \n        obscurance = min(obscurance, (20.0 * dst \/ t)); \n        t += dst;\n        pos += dst * dir;\n        dst = SDF(pos, ps).x;\n    }\n    return obscurance;     \n}\n\nfloat shadow(vec3 p, vec3 n, vec3 lPos, PlantSpace ps)\n{\n    return shadow(p + n * MIN_DST * 40.0, lPos, ps);\n}\n\n\/\/ Cast a ray across the SDF return x: Distance, y: Materila Id\nvec2 castRay(vec3 pos, vec3 dir, float maxDst, float minDst, PlantSpace ps)\n{\n    vec2 dst = vec2(minDst * 2.0, 0.0);\n    \n    float t = 0.0;\n    \n    while (dst.x > minDst && t < maxDst)\n    {\n        dst = SDF(pos, ps);\n        t += dst.x;\n        pos += dst.x * dir;\n    }\n    \n    return vec2(t + dst.x, dst.y);\n}\n\n\/\/ A 2D blurrable cloud \nfloat cloudSky(vec2 skyUv, float blur)\n{\n    float sum = Noise2(skyUv);\n    float div = 1.0;\n    \n    if (blur < 0.75)\n    {\n        sum += Noise2(skyUv * 8.0) * 0.1 - 0.05;\n        \n        if (blur < 0.50)\n        {\n    \t\tsum += Noise2(skyUv * 4.0) * 0.25 - 0.125;\n            \n            if (blur < 0.25)\n        \t{\n    \t\t\tsum += Noise2(skyUv * 2.0) * 0.5 - 0.25;\n            }\n        }\n    }\n    sum \/= 3.0;\n    return sum;\n}\n\n\/\/ A blurrable cloud environement map\nvec3 SkyDome(vec3 rayDir, float blur)\n{\n    float blue = sat(rayDir.y * 2.0 + 0.7);\n    vec3    col = mix(vec3(0.8, 0.9, 1.0), vec3(0.5, 0.6, 1.0), blue);\n    \n    vec2 dome = rayDir.xz;\n    float len = length(dome);\n    \n    float a = atan(rayDir.x, rayDir.z);\n    \n    \/\/ Compute 2 layers of clouds and blend them with longitude to mask the vertical seam\n    vec2 skyUv = vec2(a * 7.5 - iTime * 0.1, rayDir.y * 10.0);\n    float cloud1 = cloudSky(skyUv, blur);\n    \n    vec2 skyUv2 = vec2((a + pi2) * 7.5 - iTime * 0.1, rayDir.y * 10.0);\n    float cloud2 = cloudSky(skyUv2, blur);\n    \n    float ratio = 1.0 - (a + pi) \/ pi2;\n    float cloud =  mix(cloud1, cloud2, ratio);\n    \n    \/\/ Mask the cloud across a horizontal band\n    float cloudMask = S(0.8, 0.0, abs(rayDir.y + 0.2));\n    cloud *= cloudMask;\n    \n    \/\/ When blurred the clouds are merely the mask itself\n    cloud = mix(cloud, cloudMask * (1.0 - blur * 0.6), blur);\n\n    \/\/ Add some burn around the sun\n    float sun = max(0.0, dot(rayDir, normalize(vec3(-1.0, 0.4, -1))) - 0.3);\n          \n    col.rgb += cloud;\n    col.rgb += sun * sun * sun;\n    \n    \/\/col.rgb = mix(col.rgb, vec3(0, 1, 0), S(-0.5, -1.0, rayDir.y));\n    \n    return col;\n}\n\n\n\/\/ A PBR-ish lighting model\nvec3 PBRLight(vec3 pos, vec3 normal, vec3 view, PBRMat mat, vec3 lightPos, vec3 lightColor, float lightRadius, float fresnel, PlantSpace ps, bool AddEnv)\n{\n    \/\/Basic lambert shading stuff\n    \n    vec3 key_Dir = lightPos - pos;\n    float key_len = length(key_Dir);\n    \n    float atten = sat(1.0 - key_len \/ lightRadius);\n    atten *= atten;\n    \n    key_Dir \/= key_len;\n    \n\n    float key_lambert = max(0.0, dot(normal, key_Dir)) * atten;\n    float key_shadow = shadow(pos, normal, lightPos, ps); \n    \n    float diffuseRatio = key_lambert * key_shadow;\n    \n    vec3 key_diffuse = vec3(diffuseRatio);\n    \n    \/\/ The more metalness the more present the Fresnel\n    float f = pow(fresnel + 0.5 * mat.metalness, mix(2.5, 0.5, mat.metalness));\n    \n    \/\/ metal specular color is albedo, it is white for dielectrics\n    vec3 specColor = mix(vec3(1.0), mat.albedo, mat.metalness);\n    \n    vec3 col = mat.albedo * key_diffuse * (1.0 - mat.metalness);\n    \n    \/\/ Reflection vector\n    vec3 refDir = reflect(view, normal);\n    \n    \/\/ Specular highlight (softer with roughness)\n    float key_spec = max(0.0, dot(key_Dir, refDir));\n    key_spec = pow(key_spec, 10.0 - 9.0 * mat.roughness) * atten * key_shadow;\n    \n    float specRatio = mat.metalness * diffuseRatio;\n    \n    col += vec3(key_spec) * specColor * specRatio;\n    col *= lightColor;\n    \n    \/\/Optionnal environment reflection (only for key light)\n    if (AddEnv)\n    {\n       vec3 dome = SkyDome(refDir, mat.roughness);\n       dome *= dome; \/\/linear space conversion;\n       col += f * dome * specRatio;\n    }\n    \n    return col;\n}\n\n\/\/ Some 3 octave 1D noise for animation\nfloat Noise13(float x, float seed)\n{\n    float res = Noise1(x, seed);\n    res += Noise1(x * 2.0, seed) * 0.5;\n    res += Noise1(x * 4.0, seed) * 0.25;\n    return res;\n}\n\n\/\/ A calm animation where the plant is idle\nvoid CalmAnim(out KeyFrame kf)\n{\n    kf.leafAngle = -0.15 + Noise13(iTime * 0.25, 45.0) * 0.5; \/\/-0.5 to 0.2;\n    kf.mouthAngle = 0.27; \/\/0.27 to 1.4\n    \n    float spineNoise = Noise13(iTime * 0.2, 155.0);\n    \n    kf.spine1 = 0.5 + spineNoise * 0.2;     \/\/rest at 0.5\n    kf.spine2 = -0.7 - spineNoise * 0.15;    \/\/rest at -0.7\n    kf.spine3 = -0.65 - spineNoise * 0.15;\t \/\/rest at -0.65\n    \n    kf.neck = Noise1(iTime * 0.25, 456.0) * 0.8;\t\t \/\/-1.3 to 1.3\n}\n\n\/\/ A menacing animation where the plant is mouth opened ready to bite\nvoid AgressiveAnim(out KeyFrame kf)\n{\n    float spineNoise = Noise13(iTime * 0.4, 155.0);\n    \n    kf.leafAngle = -0.15 - spineNoise * 0.5; \/\/-0.5 to 0.2;\n    kf.mouthAngle = 1.3 + Noise13(iTime * 1.0, 45.0) * 0.2; \/\/0.27 to 1.4\n    \n    kf.spine1 = 0.6 + spineNoise * 0.2;     \/\/rest at 0.5\n    kf.spine2 = -0.7 - spineNoise * 0.15;    \/\/rest at -0.7\n    kf.spine3 = -0.7 - spineNoise * 0.15;\t \/\/rest at -0.65\n    \n    kf.neck = Noise1(iTime * 0.6, 456.0) * 2.3;\t\t \/\/-1.3 to 1.3\n}\n\n\/\/ An animation where the plant attacks repeatedly\nvoid ChompAnim(out KeyFrame kf)\n{\n    float a = sin(iTime * 20.0) * 0.5 + 0.5;\n    \n    float spineNoise = Noise13(iTime * 0.4, 155.0);\n    \n    kf.leafAngle = -0.25 - a * spineNoise; \/\/-0.5 to 0.2;\n    \n    kf.mouthAngle = mix(0.27, 1.6, a * a);\n    \n    kf.spine1 = 0.4 + spineNoise * 0.2;     \/\/rest at 0.5\n    kf.spine2 = -0.8 - spineNoise * 0.15 - a * 0.1;    \/\/rest at -0.7\n    kf.spine3 = -0.5 - spineNoise * 0.15 + a * 0.1;\t \/\/rest at -0.65\n    \n    kf.neck = Noise1(iTime * 1.0, 456.0) * 2.3;\t\t \/\/-1.3 to 1.3\n}\n\n\nvec4 render(vec3 camPos, vec3 rayDir)\n{\n       \n    PlantSpace plantSpace;\n    \n    KeyFrame kf1;\n    KeyFrame kf2;\n    KeyFrame kf;\n    \n    \/\/ Varies the plant agressivity with time\n    float aggro = mix(-0.5, 2.0, Noise1(iTime * 0.3, 236.8) + 0.5);\n    \n    \/\/ compute two animation poses and a blending factor\n    if (aggro < 1.0)\n    {\n        CalmAnim(kf1);\n    \tAgressiveAnim(kf2);\n    }\n    else\n    {\n        AgressiveAnim(kf1);\n    \tChompAnim(kf2);\n        aggro -= 1.0;\n    }\n    \n\tmixKeyFrame(kf1, kf2, sat(aggro * 2.0), kf); \n    \n    \/\/ Build matrices\n    buildPlantSpace(kf, plantSpace);\n    \n    vec3 col;\n    \n    vec2 d = castRay(camPos, rayDir, MAX_DST, MIN_DST, plantSpace);\n    \n    \n    if (d.x > MAX_DST)\n    {\n        \/\/ sky dome\n        col = SkyDome(rayDir, 0.0);\n    }\n    else   \n    {\n        vec3 pos = camPos + rayDir * d.x;\n \n        vec3 n;\n        \n        vec3 normalOffset = vec3(0);\n        \n        \n        PBRMat mat;\n        \n        GetColor(d.y, pos, plantSpace, mat, normalOffset);\n        \n        mat.albedo *= mat.albedo; \/\/ Convert albedo to linear space\n        \n        n = normalize(calcNormal(pos, plantSpace) + normalOffset);\n        \n        \/\/ Some bogus ambient term\n        vec3 ambient = mix(vec3(0.5, 1, 0.5), vec3(0.5, 0.5, 1), n.y * 0.5 + 0.5);\n        ambient += vec3(0.5, 0.2, 0.2) * (1.0- abs(n.y * n.y));\n        \n        \/\/ Fake AO\n        float dst = 1.0 - sat(SDF(pos + n * 0.2, plantSpace).x * 1.0);\n        ambient *= (1.0 - dst * dst) * 0.8 + 0.2;\n        ambient *= mat.occlusion * 0.5;\n  \n        col =  mat.albedo * ambient;\n        \n        \/\/ Fresnel\n        float fresnel = pow(1.0 - sat(dot(n, -rayDir)), 1.0);\n\n\t\tvec3 key_LightPos = vec3(-10.0, 10.0, -13.0);\n        col += PBRLight(pos, n, rayDir, mat, key_LightPos, vec3(0.9), 1000.0, fresnel, plantSpace, true);\n        \n                \n        vec3 fill_LightPos = vec3(-8.0, 10.0, 10.0);\n        col += PBRLight(pos, n, rayDir, mat, fill_LightPos, vec3(0.8), 50.0, fresnel, plantSpace, false);\n\n    \tcol = pow(col,vec3(0.4545));\n    }\n\n    return vec4(col, d);\n}\n\n\/\/ Classic stuff\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv =(fragCoord - .5 * iResolution.xy) \/ iResolution.y; \n\n    vec3 camPos = vec3(0.0, 2.8, -40.0);\n    vec3 camDir = vec3(0.0, 0.0,  1.0);\n    \n    vec3 rayDir = camDir + vec3(uv * 0.45, 0.0);\n    \n    \n   \tvec3 res = vec3(0.0);\n    \n    vec2 mouse = iMouse.xy\/iResolution.xy;\n    if(mouse.x<.001) mouse = vec2(0.5, 0.5);\n    \n    vec2 viewAngle = vec2((-mouse.x - 0.6) * pi2, (mouse.y - 0.65) * halfPi);\n    \n    mat4 viewMat = rotationY(viewAngle.x) * rotationX(viewAngle.y);\n    \n    camPos = (viewMat * vec4(camPos, 1.0)).xyz;\n    rayDir = (viewMat * vec4(rayDir, 0.0)).xyz;\n    \n\n    res = render(camPos, rayDir).rgb;\n\n    \/\/ Output to screen\n    fragColor = vec4(res.rgb,1.0);\n}",
            "name": "Image",
            "description": "",
            "type": "image"
        },
        {
            "inputs": [],
            "outputs": [],
            "code": "#define pi 3.14159265359\n#define pi2 (pi * 2.0)\n#define halfPi (pi * 0.5)\n\nmat4 scaleMatrix( in vec3 sc ) {\n\treturn mat4(sc.x, 0,\t0,\t0,\n\t\t\t \t0, \t sc.y,\t0,\t0,\n\t\t\t\t0, \t 0,\t sc.z,\t0,\n\t\t\t\t0, \t 0,  0,\t1);\n}\n\nmat4 rotationX( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4(1.0, 0,\t 0,\t0,\n\t\t\t \t0, \t c,\t-s,\t0,\n\t\t\t\t0, \t s,\t c,\t0,\n\t\t\t\t0, \t 0,  0,\t1);\n}\n\nmat4 rotationY( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4( c, 0,\t s,\t0,\n\t\t\t \t 0,\t1.0, 0,\t0,\n\t\t\t\t-s,\t0,\t c,\t0,\n\t\t\t\t 0, 0,\t 0,\t1);\n}\n\nmat4 rotationZ( in float angle ) {\n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4(c, -s,\t0,\t0,\n\t\t\t \ts,\tc,\t0,\t0,\n\t\t\t\t0,\t0,\t1,\t0,\n\t\t\t\t0,\t0,\t0,\t1);\n}\n\nmat4 translate( in vec3 p) {\n\n\treturn mat4(1,  0,\t0,\t0,\n\t\t\t \t0,\t1,\t0,\t0,\n\t\t\t\t0,\t0,\t1,\t0,\n\t\t\t\tp.x, p.y, p.z, 1);\n}\n\n\n\/\/ http:\/\/iquilezles.org\/www\/articles\/smin\/smin.htm\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25\/k;\n}\n\n\/\/ http:\/\/iquilezles.org\/www\/articles\/smin\/smin.htm\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25\/k;\n}\n\n\/\/ http:\/\/www.iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdSphere(vec3 pos, vec3 center, float radius)\n{\n    return length(pos - center) - radius;\n}\n\n\n\/\/ http:\/\/www.iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n\n\/\/ http:\/\/www.iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)\/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n    \n  float edge = dot(p.xy,sc);\n  float k = (sc.y*p.x>sc.x*p.y) ? edge : length(p.xy);\n  float ratio = max(0.5, 1.0 - edge * edge * 0.055);\n  return (sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb * ratio) * ratio;\n}\n\nfloat dot2( vec2 v ) { return dot(v,v); }\n\n\nvec2 combineMin(vec2 a, vec2 b)\n{\n    return (a.x < b.x)? a : b;\n}\n\nvec2 combineMax(vec2 a, vec2 b)\n{\n    return (a.x > b.x)? a : b;\n}\n\n\/\/ returns distance in .x and UVW parametrization in .yzw\nfloat sdJoint3DSphere( in vec3 p, in float l, in float a, in float w)\n{\n  if( abs(a)<0.001 )\n  {\n      return length(p-vec3(0,clamp(p.y,0.0,l),0))-w;\n  }\n    \n  vec2  sc = vec2(sin(a),cos(a));\n  float ra = 0.5 * l \/ a;\n  p.x -= ra;\n  vec2 q = p.xy - 2.0*sc*max(0.0,dot(sc,p.xy));\n  float u = abs(ra)-length(q);\n  float d2 = (q.y<0.0) ? dot2( q + vec2(ra,0.0) ) : u*u;\n\n  return sqrt(d2+p.z*p.z)-w;\n}\n\n\/\/ A matrix to the tip of a sdJoint3DSphere\n\/\/ Could probably use some optimisations\nmat4 joint3DMatrix(in float l, in float a)\n{\n  if( abs(a)<0.001 )\n  {\n      return translate(vec3(0, -l, 0));\n  }\n    \n  float ra = 0.5 * l \/ a;\n  float ara = abs(ra);\n  return  rotationZ(-a * 2.0) * translate(vec3(-ra + cos(2.0 * a) * ra, -sin(2.0 * a) * ra, 0.0));\n}\n\n\n\n\/\/ http:\/\/www.iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \/\/ approximated\n{\n    float k0 = length(p\/r);\n    float k1 = length(p\/(r*r));\n    return k0*(k0-1.0)\/k1;\n}\n\n\n\/\/ Some hash function 2->1\nfloat N2(vec2 p)\n{\t\/\/ Dave Hoskins - https:\/\/www.shadertoy.com\/view\/4djSRW\n    p = mod(p, vec2(1456.2346));\n\tvec3 p3  = fract(vec3(p.xyx) * vec3(443.897, 441.423, 437.195));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\/\/ A 2d Noise\nfloat Noise2(vec2 uv)\n{\n    vec2 corner = floor(uv);\n\tfloat c00 = N2(corner + vec2(0.0, 0.0));\n\tfloat c01 = N2(corner + vec2(0.0, 1.0));\n\tfloat c11 = N2(corner + vec2(1.0, 1.0));\n\tfloat c10 = N2(corner + vec2(1.0, 0.0));\n    \n    vec2 diff = fract(uv);\n    \n    diff = diff * diff * (vec2(3) - vec2(2) * diff);\n    \/\/diff = smoothstep(vec2(0), vec2(1), diff);\n    \n    return mix(mix(c00, c10, diff.x), mix(c01, c11, diff.x), diff.y);\n}\n\n\/\/ 1d Noise, y is seed\nfloat Noise1(float x, float seed)\n{\n    vec2 uv = vec2(x, seed);\n    vec2 corner = floor(uv);\n\tfloat c00 = N2(corner + vec2(0.0, 0.0));\n\tfloat c10 = N2(corner + vec2(1.0, 0.0));\n    \n    float diff = fract(uv.x);\n    \n    diff = diff * diff * (3.0 - 2.0 * diff);\n    \n    return mix(c00, c10, diff) - 0.5;\n}\n\n",
            "name": "Common",
            "description": "",
            "type": "common"
        }
    ]
}