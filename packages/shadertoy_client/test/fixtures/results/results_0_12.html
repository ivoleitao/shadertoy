<!DOCTYPE HTML>
<html lang="en">
<head>

    
<title>Browse (1) - Shadertoy BETA</title>
<meta charset="utf-8" />
<meta name="Keywords" content="shadertoy, shader toy, quilez, inigo, jeremias, pol, fractals, demoscene, computer graphics, mathematics, rendering, demo, 3D, realtime, shader, raytracing, raymarching, webgl, glsl" />
<meta name="Description" content="Build shaders, share them, and learn from the best community." />
<meta name="Author" content="Beautypi" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<link rel="image_src" href="https://www.shadertoy.com/img/logo.png" />
<link rel="apple-touch-icon" href="/img/launch_icon_57.png"/>
<link rel="apple-touch-icon" sizes="72x72" href="/img/launch_icon_72.png"/>
<link rel="apple-touch-icon" sizes="114x114" href="/img/launch_icon_114.png"/>
<link rel="shortcut icon" href="/img/favicon.ico"/>

<style>::-webkit-scrollbar {
    height: 8px;
    width: 8px;
    background: #404040;
}

::-webkit-scrollbar-thumb
{
    background: #909090;
    border-radius: 0ex;
}

::-webkit-scrollbar-corner
{
    background: #000;
}

::-webkit-input-placeholder
{
	font-style:italic;
}
input:-moz-placeholder, textarea:-moz-placeholder
{
	font-style:italic;
}
input.placeholder-text, textarea.placeholder-text
{
	font-style:italic;
}

pre 
{
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
    white-space: -pre-wrap;
    white-space: -o-pre-wrap;
    word-wrap: break-word;
}

@font-face
{
    font-family: Lobster;
    src: url("/img/lobster.otf") format("opentype");
}

div#centerScreen
{
    left: 50%;
    top: 50%;
    position: absolute;
}

a.headerLinks:hover
{
    background-color:#505050;
    color : #ff8020;
}

body
{
    color: #000000;
    font-size:12px;
    font-style:normal;
    font-family:Tahoma,Arial;
    background-repeat: no-repeat;
    //background-attachment: fixed;
    padding:0px;
    margin:0px;
    text-align: left;
    background-color: #d0d0d0;
    background-repeat: repeat;
    user-select: text;
}

a,
a:hover,
a:visited
{
  color : inherit;
}

div#content {
    width: 95%;
    overflow: hidden;
    margin: auto;
    padding: 0px;
    min-height: calc(100vh - 80px);
    //box-sizing: border-box;
}


.notificationCount
{
 background-color:#ff0000;
 padding-left:3px;
 padding-right:1px;
 padding-top:1px;
 padding-bottom:1px;
}

div#header
{
    background-color: #404040;
    top: 0px;
    left: 0px;
    width: 100%;
    padding: 0;
    margin: 0;
    color: #ffffff;
    display: flex;
    flex-direction:row;
}

#headerBlock1
{
    width: 50%;
    display:flex;
    align-items:center;
}

a#headerTitle
{
    font-size: 2.25em;
    font-family: Lobster,Tahoma,Arial;
    text-decoration: none;
    padding-left:32px;
    padding-right:32px;
}

#headerSearch
{
    display: inline-block;
    color: #000000;
    width: 300px;
}

input[type=search]#mySearch
{
    width: 100%;
    border-radius: 6px;
    border: 1px solid black;
    padding:12px;
}

#headerBlock2
{
    width: 50%;
    margin-left: auto;
    display: flex;
    justify-content: flex-end;
}


a#headerTitle:hover
{
    color : #ff8020;
}

a.headerLinks
{
    font-weight: bold;
    padding-top: 14px;
    padding-bottom: 14px;
    padding-left: 14px;
    padding-right: 14px;
    margin:0px;
    text-decoration: none;
    transition: background-color 0.15s linear, color 0.15s linear;
}

#footer
{
    background-color: rgba(64,64,64,0.25);
    color: #000000;
    padding: 0px;
    margin: 0px;
    width: 100%;
    display: flex;
    justify-content: space-between;
    flex-wrap: wrap;
}

#footer div
{
    padding-top:10px;
    padding-bottom:0px;
    padding-left:16px;
    padding-right:16px;
}

#footer div ul
{
    margin-left:0px;
    padding-left:16px;
}

#footer div ul li
{
    padding-top:6px;
}

a.regular
{
    font-weight:bold;
    text-decoration:none
}

a.regular:hover
{
  color : #ff8020;
}

a.user
{
    font-weight:bold;
    text-decoration:none;
}

a.user:hover
{
  color : #ff8020;
  text-decoration: underline;
}

.uiButton
{
    border: none;
    outline: none;
    margin: 0px;
    padding: 0px;
    width: 22px;
    height: 22px;
    position: absolute;
    cursor: pointer;
    border-radius: 4px;
}

.uiButton:hover
{
    box-shadow: inset 0px 0px 1px 1px #808080, 0px 0px 1px 1px #808080;
}

.uiDivBUtton
{
    cursor:pointer;
}

.uiDivBUtton:hover
{
    color: #ffffff;
}


.dialog
{
    display: block;
    background-color: #e0e0e0;
    color: #000000;
    border:1px solid #000;
    padding:0px;
    margin:0px;
    text-align:left;
    border-radius: 4px;
    box-shadow:4px 4px 6px 0px rgba(0,0,0,0.5);
    overflow: hidden;
    z-index:1000;
    visibility: hidden;
    opacity:0;
    -moz-transition: opacity 0.25s linear,visibility 0.25s linear;
    -webkit-transition: opacity 0.25s linear,visibility 0.25s linear;
    transition: opacity 0.25s linear,visibility 0.25s linear;
}

.dialogHeader
{
    left:0px;
    top: 0px;
    width:100%;
    height:32px;
    position: absolute;
    background-color: #808080;
    cursor:move;
}

.dialogTitle
{
    left: 12px;
    top: 4px;
    position: absolute;
    padding: 0px;
    margin: 0px;
    color:#000000;
    font-size:1.5em;
    text-align: left;
    user-select: none;
    -moz-user-select: -moz-none;
    -webkit-user-select: none;
}

.dialogOverlay
{
    z-index:1000;

    visibility: hidden;
    opacity:0;
    -moz-transition: opacity 0.25s linear,visibility 0.25s linear;
    -webkit-transition: opacity 0.25s linear,visibility 0.25s linear;
    transition: opacity 0.25s linear,visibility 0.25s linear;

    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    width:100%;
    height:100%;
    position:absolute;

    background-color:rgba(0,0,0,.4);
}

.viewsIcon, .likesIcon
{
    border: none;
    outline: none;
    display:inline-block;
    background-repeat:no-repeat;
    top:0px;
    left:0px;
    padding:0px;
    padding-right: 2px;
    margin:0px;
    position:relative;
}

.userPictureSmall
{
    background-color:#808080;
    border: 1px solid #000000;
    width:32px;
    height:32px;
}

.dialogCloseButton
{
    right:8px;
    top: 4px;
    width:22px;
    height:22px;
    position: absolute;
    background-image: url("/img/close.png");
    cursor: pointer;
    border-radius: 4px;
}

.dialogCloseButton:hover
{
    box-shadow: inset 0px 0px 4px 2px #ffffff, 0px 0px 4px 2px #ffffff;
}

.dialogContentButtons
{
     padding:0;
     border:0;
     text-align: justify;
     left: 24px;
     bottom:40px;
     position:absolute;
}

.dialogButton
{
    text-align: center;
    vertical-align: middle;
    display: inline-block;
    border-radius: 4px;
    font-weight: bold;
    cursor: pointer;
    padding-bottom:5px;
    padding-top:4px;
    padding-left: 8px;
    padding-right: 8px;
    margin-left:4px;
    margin-right:4px;
    text-decoration: none;
    color:#000000;
    width: 80px;
    -moz-transition:    background-color 0.15s linear, color 0.15s linear;
    -webkit-transition: background-color 0.15s linear, color 0.15s linear;
    transition:         background-color 0.15s linear, color 0.15s linear;
}

.dialogButton:hover
{
  background-color:#808080;
  color : #ff8020;
}

.dialogCloseButton:hover
{
    box-shadow: inset 0px 0px 4px 2px #ffffff, 0px 0px 4px 2px #ffffff;
}

.dialogContent
{
    color: inherit;
    overflow: auto;
    width:100%;
    height:100%;
    left: 0px;
    top: 32px;
    position:absolute
}

.dialogContentBody
{
    color: inherit;
    width:100%;
    height:auto;
    padding-top:24px;
    padding-bottom:24px;
    padding-left:24px;
    padding-right:24px;
    text-align: left;
}

.formButton
{
    font-weight:bold;
	color:#ffffff;
	border:none;
    text-align:center;
	background-color:#808080;
    border-radius: 4px;
	padding-left:8px;
	padding-right:8px;
	padding-top:4px;
	padding-bottom:4px;
    cursor:pointer;
    min-width:80px;
    box-sizing: border-box;
}
.formInput {
    border-radius: 6px;
    border: 1px solid black;
    padding: 4px;
    border: none;
}
.formButton:hover {
    background-color: #e0e0e0;
}
.formButton:disabled
{
	color:#b0b0b0;
	background-color:#808080;
}

.formButtonSmall
{
    color:#ffffff;
    border:none;
    text-align:center;
    background-color:#808080;
    border-radius: 4px;
    padding-left:2px;
    padding-right:2px;
    padding-top:2px;
    padding-bottom:2px;
    cursor:pointer;
    min-width:40px;
}

.formButtonSmall:hover
{
    background-color: #e0e0e0;
}

.formButtonSmall:disabled
{
    color:#b0b0b0;
    background-color:#808080;
}

.formButtonSmall.disabled2,
.formButton.disabled2 { color:#b0b0b0; background-color:#808080; pointer-events: none; }

.inputForm
{
    padding-left:2%;
    padding-right:2%;
    resize: none;
    text-align: left;
    background-color:#e0e0e0;
    outline: none;
    border-radius: 4px;
    border: 1px solid #808080;
    color:inherit;
    box-sizing: border-box;
}

.inputForm:focus
{
    border: 1px solid #AFCDD8;
    background-color: #EBF2F4;
}

.transparentPannel
{
    background-color:rgba(64,64,64,0.1);
    padding:16px;
}

.comment, .commentSelf, .commentNew
{
    border-radius: 4px;
    width: 100%;
    margin-left: 0px;
    margin-right: 0px;
    margin-top: 0px;
    margin-bottom: 6px;

    padding: 14px;
    box-sizing: border-box;
    display: grid;
    grid-template-columns: 32px auto 8px;
    grid-template-rows: 1fr;
    grid-gap:8px;
}

.comment:nth-child(even)
{
    background-color: rgba(64,64,64,0.1);
}

.comment:nth-child(odd)
{
    background-color: rgba(128,128,128,0.1);
}

.commentSelf
{
    background-color: rgba(240,160,64,0.1);
}

.commentNew
{
    padding-right: 0px;
    grid-template-columns: 40px auto;
}

.commentContent
{
    vertical-align: top;
    text-align: left;
    word-break: break-all;
    word-break: break-word;
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
}


/* ----------------------- media resolutions ------------------------ */

@media screen and (max-width:799px)
{
    div#header {flex-direction:column; }
    #headerBlock1 { width:100%; }
    #headerBlock2 { width:100%; justify-content: space-around;}
    div#headerSearch {width:200px;}
    input#mySearch { width:200px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .previewText { width:130px; }
    .transparentPannel { padding:10px; }
}

@media screen and (min-width:800px) and (max-width:1279px)
{
    body { font-size: 9px; }
    div#headerSearch {width: 250px;}
    input#mySearch { width:250px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .previewText { width:130px; }
    .transparentPannel { padding:11px; }
}

@media screen and (min-width:1280px) and (max-width:1439px)
{
    body { font-size: 10px; }
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:28px; }
    .previewText { width:180px; }
    .transparentPannel { padding:12px; }
}

@media screen and (min-width:1440px) and (max-width:1919px)
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:28px; }
    .previewText { width:180px; }
    .transparentPannel { padding:12px; }
}

@media screen and (min-width:1920px) and (max-width:2559px)
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:32px; }
    .previewText { width:220px; }
    .transparentPannel { padding:16px; }
}

@media screen and (min-width:2560px) 
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:32px; }
    .previewText { width:220px; }
    .transparentPannel { padding:16px; }
}
body
{
    background-image: url("/img/themes/classic/background.jpg");
}
</style>



    <script>"use strict"

//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piCamera
//
//==============================================================================

function piCamera()
{
    var mMatrix = setIdentity();
    var mMatrixInv = setIdentity();

    var mPosition = [0.0,0.0,0.0];
    var mXRotation = 0.0;
    var mYRotation = 0.0;

    var mPositionTarget = [0.0,0.0,0.0];
    var mXRotationTarget = 0.0;
    var mYRotationTarget = 0.0;

    var me = {};
/*
    me.Set = function( pos, dir, roll) 
             {
                 mMatrix    = setLookat( pos, add(pos,dir), [Math.sin(roll),Math.cos(roll),Math.sin(roll)] );
                 mMatrixInv = invertFast( mMatrix );
             };
*/
    me.SetPos = function(pos)
                {
                    mPosition = pos;
                    //mMatrix[ 3] = -(mMatrix[0] * pos[0] + mMatrix[1] * pos[1] + mMatrix[ 2] * pos[2]);
                    //mMatrix[ 7] = -(mMatrix[4] * pos[0] + mMatrix[5] * pos[1] + mMatrix[ 6] * pos[2]);
                    //mMatrix[11] = -(mMatrix[8] * pos[0] + mMatrix[9] * pos[1] + mMatrix[10] * pos[2]);
                };
/*
    me.GlobalMove = function(pos)
                    {
                        mMatrix[ 3] -= (mMatrix[0] * pos[0] + mMatrix[1] * pos[1] + mMatrix[ 2] * pos[2]);
                        mMatrix[ 7] -= (mMatrix[4] * pos[0] + mMatrix[5] * pos[1] + mMatrix[ 6] * pos[2]);
                        mMatrix[11] -= (mMatrix[8] * pos[0] + mMatrix[9] * pos[1] + mMatrix[10] * pos[2]);
                        mMatrixInv = invertFast(mMatrix);
                    };
*/
    me.LocalMove = function( dis )
                    {
                        dis = matMulvec( setRotationY(-mYRotation), dis);
                        mPositionTarget = sub(mPositionTarget,dis)
                    };

    me.RotateXY = function( x, y)
                  {
                    mXRotationTarget -= x;
                    mYRotationTarget -= y;
                    mXRotationTarget = Math.min( Math.max( mXRotationTarget, -Math.PI/2), Math.PI/2 );
                  };


    me.CameraExectue = function( dt )
    {
        // smooth position
        mXRotation += (mXRotationTarget-mXRotation) * 12.0*dt;
        mYRotation += (mYRotationTarget-mYRotation) * 12.0*dt;
        mPosition = add(mPosition, mul( sub(mPositionTarget, mPosition), 12.0*dt));

        // Make Camera matrix
        mMatrix = matMul( matMul(setRotationX(mXRotation), 
                                 setRotationY(mYRotation)),  
                                 setTranslation(mPosition));
        mMatrixInv = invertFast(mMatrix);

    }

    me.GetMatrix = function() { return mMatrix; };
    me.GetMatrixInverse = function() { return mMatrixInv; };
    me.SetMatrix = function( mat ) 
                    {
                        mMatrix = mat;
                        mMatrixInv = invertFast(mMatrix);

                        mPosition = getXYZ(matMulpoint(mat, [0.0,0.0,0.0]));
                        mPositionTarget = mPosition;
                    };

    me.GetPos = function() { return getXYZ(matMulpoint(mMatrixInv, [0.0,0.0,0.0])); }
    me.GetDir = function() { return getXYZ(normalize(matMulvec(mMatrixInv, [0.0,0.0,-1.0]))); }

    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piFile
//
//==============================================================================

function piFile( binaryDataArrayBuffer )
{
    // private
    //var mDataView = new DataView( binaryDataArrayBuffer, 0 );
    var mDataView = binaryDataArrayBuffer;
    var mOffset = 0;

    // public members
    var me = {};
    me.mDummy = 0;
/*
    // public functions
    me.Seek = function( off ) { mOffset = off - 3; };
    me.ReadUInt16 = function()  { var res = mDataView.getUint16( mOffset ); mOffset+=2; return res; };
    me.ReadUInt32 = function()  { var res = mDataView.getUint32( mOffset ); mOffset+=4; return res; };
    me.ReadUInt64 = function()  { return me.ReadUInt32() + (me.ReadUInt32()<<32); };
    me.ReadFloat32 = function() { var res = mDataView.getFloat32( mOffset ); mOffset+=4; return res; };
*/

    me.Seek = function( off ) { mOffset = off; };
    me.ReadUInt8  = function()  { var res = (new Uint8Array(mDataView,mOffset))[0]; mOffset+=1; return res; };
    me.ReadUInt16 = function()  { var res = (new Uint16Array(mDataView,mOffset))[0]; mOffset+=2; return res; };
    me.ReadUInt32 = function()  { var res = (new Uint32Array(mDataView,mOffset))[0]; mOffset+=4; return res; };
    me.ReadUInt64 = function()  { return me.ReadUInt32() + (me.ReadUInt32()<<32); };
    me.ReadFloat32 = function() { var res = (new Float32Array(mDataView,mOffset))[0]; mOffset+=4; return res; };
    me.ReadFloat32Array = function(n) 
                          { 
                              var src = new Float32Array(mDataView, mOffset);
                              var res = [];  for( var i=0; i<n; i++ ) { res[i] = src[i]; }
                              mOffset += 4*n;
                              return res;
                          };
    me.ReadFloat32ArrayNative = function(n) { var src = new Float32Array(mDataView, mOffset); mOffset += 4*n; return src; };
    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piMesh
//
//==============================================================================

function piMesh()
{
    this.mChunks = [];
    this.mPrimitiveType = 0;
    this.mVertexFormat = null;
}

/*
piMesh.prototype.normalize = function( ppos, npos )
{
    var numv = this.mVertexData.length;
    var numt = this.mIndices.length;

    for( var i=0; i<numv; i++ )
    {
        //float *v = (float*)piMesh_GetVertexData( me, i, npos );
        //v[0] = 0.0f;
        //v[1] = 0.0f;
        //v[2] = 0.0f;
        this.mVerts[8 * i + 3] = 0.0;
        this.mVerts[8 * i + 4] = 0.0;
        this.mVerts[8 * i + 5] = 0.0;
    }

    for( var i=0; i<numt; i++ )
    {
        piMeshFace *face = me->mFaceData.mIndexArray[0].mBuffer + i;

        const int ft = face->mNum;
        
        vec3 nor = vec3( 0.0f, 0.0f, 0.0f );
        for( int j=0; j<ft; j++ )
        {
            const vec3 va = *((vec3*)piMesh_GetVertexData( me, face->mIndex[ j      ], ppos ));
            const vec3 vb = *((vec3*)piMesh_GetVertexData( me, face->mIndex[(j+1)%ft], ppos ));

            nor += cross( va, vb );
        }

        for( int j=0; j<ft; j++ )
        {
            vec3 *n = (vec3*)piMesh_GetVertexData( me, face->mIndex[j], npos );
            n->x += nor.x;
            n->y += nor.y;
            n->z += nor.z;
        }
    }

    for( var i=0; i<numv; i++ )
    {
        vec3 *v = (vec3*)piMesh_GetVertexData( me, i, npos );
        *v = normalize( *v );
    }
}
*/

piMesh.prototype.createCube = function(renderer)
{
    this.mPrimitiveType = 0;

    this.mChunks[0] = { mVerts : new Float32Array([ -1.0, -1.0, -1.0,
                                       1.0, -1.0, -1.0,
                                      -1.0,  1.0, -1.0,
                                       1.0,  1.0, -1.0,
                                      -1.0, -1.0,  1.0,
                                       1.0, -1.0,  1.0,
                                      -1.0,  1.0,  1.0,
                                       1.0,  1.0,  1.0 ]),

                        mIndices : new Uint16Array([ 0, 2, 1,   1, 2, 3,   5, 1, 3,   5, 3, 7,   4, 5, 7,   4, 7, 6,   4, 6, 2,   4, 2, 0,   6, 7, 3,   6, 3, 2,   4, 0, 1,   4, 1, 5 ]),
                        mNumVertices : 8,
                        mNumFaces : 12, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };

    this.mVertexFormat = { mStride:12, mChannels:[ { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false } ] };

    return true;
}

piMesh.prototype.createCubeSharp = function (renderer)
{
    this.mPrimitiveType = 0;

    this.mChunks[0] = { mVerts : new Float32Array([-1.0, 1.0,-1.0,   0.0, 1.0, 0.0,   0.0, 0.0,
                                    -1.0, 1.0, 1.0,   0.0, 1.0, 0.0,   0.0, 1.0,
                                     1.0, 1.0, 1.0,   0.0, 1.0, 0.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   0.0, 1.0, 0.0,   1.0, 0.0,

                                    -1.0,-1.0, 1.0,   0.0, 0.0, 1.0,   0.0, 0.0,
                                     1.0,-1.0, 1.0,   0.0, 0.0, 1.0,   0.0, 1.0,
                                     1.0, 1.0, 1.0,   0.0, 0.0, 1.0,   1.0, 1.0,
                                    -1.0, 1.0, 1.0,   0.0, 0.0, 1.0,   1.0, 0.0,

                                     1.0, 1.0, 1.0,   1.0, 0.0, 0.0,   0.0, 0.0,
                                     1.0,-1.0, 1.0,   1.0, 0.0, 0.0,   0.0, 1.0,
                                     1.0,-1.0,-1.0,   1.0, 0.0, 0.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   1.0, 0.0, 0.0,   1.0, 0.0,

                                     1.0,-1.0,-1.0,   0.0, 0.0,-1.0,   0.0, 0.0,
                                    -1.0,-1.0,-1.0,   0.0, 0.0,-1.0,   0.0, 1.0,
                                    -1.0, 1.0,-1.0,   0.0, 0.0,-1.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   0.0, 0.0,-1.0,   1.0, 0.0,

                                    -1.0,-1.0, 1.0,   0.0,-1.0, 0.0,   0.0, 0.0,
                                    -1.0,-1.0,-1.0,   0.0,-1.0, 0.0,   0.0, 1.0,
                                     1.0,-1.0,-1.0,   0.0,-1.0, 0.0,   1.0, 1.0,
                                     1.0,-1.0, 1.0,   0.0,-1.0, 0.0,   1.0, 0.0,

                                    -1.0, 1.0, 1.0,  -1.0, 0.0, 0.0,   0.0, 0.0,
                                    -1.0, 1.0,-1.0,  -1.0, 0.0, 0.0,   0.0, 1.0,
                                    -1.0,-1.0,-1.0,  -1.0, 0.0, 0.0,   1.0, 1.0,
                                    -1.0,-1.0, 1.0,  -1.0, 0.0, 0.0,   1.0, 0.0 ]),

                        mIndices : new Uint16Array([0,1,2, 0,2,3,   4,5,6, 4,6,7,    8,9,10,8,10,11,   12,13,14,12,14,15,   16,17,18,16,18,19,   20,21,22,20,22,23]),
                        mNumVertices : 24,
                        mNumFaces : 12, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };


    this.mVertexFormat = { mStride:32, mChannels:[ { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false },
                                                   { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false },
                                                   { mNumComponents:2, mType: renderer.TYPE.FLOAT32, mNormalize: false } ] };

    return true;
}


piMesh.prototype.createUnitQuad = function (renderer)
{
    this.mPrimitiveType = 0;
    this.mVertexFormat = { mStride:8, mChannels: [ {mNumComponents:2, mType: renderer.TYPE.FLOAT32, mNormalize: false} ] };

    this.mChunks[0] = { mVerts : new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0,  1.0, 1.0,  1.0]),
                        mIndices : new Uint16Array([0, 2, 1, 1, 2, 3]),
                        mNumVertices : 4,
                        mNumFaces : 2, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };
 
    return true;
}




piMesh.prototype.destroy = function()
{
    //delete this.mVerts;   this.mVerts = null;
    //delete this.mIndices; this.mIndices = null;
}

piMesh.prototype.scale = function (x, y, z)
{
    var stride = this.mVertexFormat.mStride/4;
    for( var j=0; j<this.mChunks.length; j++ )
    {
        var nv = this.mChunks[j].mNumVertices;
        for (var i = 0; i < nv; i++) 
        {
            this.mChunks[j].mVerts[stride * i + 0] *= x;
            this.mChunks[j].mVerts[stride * i + 1] *= y;
            this.mChunks[j].mVerts[stride * i + 2] *= z;
        }
    }
}

piMesh.prototype.translate = function (x, y, z) 
{
    var stride = this.mVertexFormat.mStride/4;
    for( var j=0; j<this.mChunks.length; j++ )
    {
        var nv = this.mChunks[j].mNumVertices;
        for (var i = 0; i < nv; i++) 
        {
            this.mChunks[j].mVerts[stride * i + 0] += x;
            this.mChunks[j].mVerts[stride * i + 1] += y;
            this.mChunks[j].mVerts[stride * i + 2] += z;
        }
    }
}

piMesh.prototype.GPULoad = function (renderer)
{
    for( var i=0; i<this.mChunks.length; i++ )
    {
        var vbo = renderer.CreateVertexArray(this.mChunks[i].mVerts, renderer.BUFTYPE.STATIC );
        if (vbo == null)
            return false;

        var ibo = renderer.CreateIndexArray(this.mChunks[i].mIndices, renderer.BUFTYPE.STATIC);
        if (ibo == null)
            return false;

        this.mChunks[i].mVBO = vbo;
        this.mChunks[i].mIBO = ibo;
    }
    return true;
}

piMesh.prototype.GPURender = function (renderer, positions )//, matPrj, matCam )
{
    //renderer.SetShaderConstantMat4F("unMPrj", matPrj, false );

    var num = this.mChunks.length;
    for( var i=0; i<num; i++ )
    {
        //var mat =  matMul( matCam, this.mChunks[i].mTransform );
        //renderer.SetShaderConstantMat4F("unMMod", mat, false);

        renderer.AttachVertexArray(this.mChunks[i].mVBO, this.mVertexFormat, positions );
        renderer.AttachIndexArray(this.mChunks[i].mIBO );
        renderer.DrawPrimitive(renderer.PRIMTYPE.TRIANGLES, this.mChunks[i].mNumFaces * 3, true, 1);
        renderer.DetachIndexArray(this.mChunks[i].mIBO);
        renderer.DetachVertexArray(this.mChunks[i].mVBO, this.mVertexFormat );
    }
}
//==============================================================================
//
// piLibs 2014-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piRenderer
//
//==============================================================================

function piRenderer()
{
    // private members

    var mGL = null;
    var mBindedShader = null;
    var mIs20 = false;
    var mFloat32Textures;
    var mFloat32Filter;
    var mFloat16Textures;
    var mDrawBuffers;
    var mDepthTextures;
    var mDerivatives;
    var mFloat16Filter;
    var mShaderTextureLOD;
    var mAnisotropic;
    var mRenderToFloat32F;
    var mDebugShader;
    var mAsynchCompile;

    var mVBO_Quad = null;
    var mVBO_Tri = null;
    var mVBO_CubePosNor = null;
    var mVBO_CubePos = null;
    var mShaderHeader = ["",""];
    var mShaderHeaderLines = [0,0];

    // public members
    var me = {};

    me.CLEAR      = { Color: 1, Zbuffer : 2, Stencil : 4 };
    me.TEXFMT     = { C4I8 : 0, C1I8 : 1, C1F16 : 2, C4F16 : 3, C1F32 : 4, C4F32 : 5, Z16 : 6, Z24 : 7, Z32 : 8, C3F32:9 };
    me.TEXWRP     = { CLAMP : 0, REPEAT : 1 };
    me.BUFTYPE    = { STATIC : 0, DYNAMIC : 1 };
    me.PRIMTYPE   = { POINTS : 0, LINES : 1, LINE_LOOP : 2, LINE_STRIP : 3, TRIANGLES : 4, TRIANGLE_STRIP : 5 };
    me.RENDSTGATE = { WIREFRAME : 0, FRONT_FACE : 1, CULL_FACE : 2, DEPTH_TEST : 3, ALPHA_TO_COVERAGE : 4 };
    me.TEXTYPE    = { T2D : 0, T3D : 1, CUBEMAP : 2 };
    me.FILTER     = { NONE : 0, LINEAR : 1, MIPMAP : 2, NONE_MIPMAP : 3 };
    me.TYPE       = { UINT8 : 0, UINT16 : 1, UINT32 : 2, FLOAT16: 3, FLOAT32 : 4, FLOAT64: 5 };

    // private functions

    var iFormatPI2GL = function( format )
    {
        if( mIs20 )
        {
             if (format === me.TEXFMT.C4I8)  return { mGLFormat: mGL.RGBA8,           mGLExternal: mGL.RGBA,             mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1I8)  return { mGLFormat: mGL.R8,              mGLExternal: mGL.RED,              mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1F16) return { mGLFormat: mGL.R16F,            mGLExternal: mGL.RED,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F16) return { mGLFormat: mGL.RGBA16F,         mGLExternal: mGL.RGBA,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C1F32) return { mGLFormat: mGL.R32F,            mGLExternal: mGL.RED,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F32) return { mGLFormat: mGL.RGBA32F,         mGLExternal: mGL.RGBA,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C3F32) return { mGLFormat: mGL.RGB32F,          mGLExternal: mGL.RGB,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.Z16)   return { mGLFormat: mGL.DEPTH_COMPONENT16, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        else if (format === me.TEXFMT.Z24)   return { mGLFormat: mGL.DEPTH_COMPONENT24, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        else if (format === me.TEXFMT.Z32)   return { mGLFormat: mGL.DEPTH_COMPONENT32F, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        }
        else
        {
             if (format === me.TEXFMT.C4I8)  return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1I8)  return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.LUMINANCE,       mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1F16) return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.LUMINANCE,       mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F16) return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C1F32) return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.RED,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F32) return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.Z16)   return { mGLFormat: mGL.DEPTH_COMPONENT, mGLExternal: mGL.DEPTH_COMPONENT, mGLType: mGL.UNSIGNED_SHORT }
        }

        return null;
     }

    // public functions

    me.Initialize = function( gl )
                    {
                        mGL = gl;

                        mIs20 = !(gl instanceof WebGLRenderingContext);

                        if( mIs20 )
                        {
                            mFloat32Textures  = true;
                            mFloat32Filter    = mGL.getExtension( 'OES_texture_float_linear');
                            mFloat16Textures  = true;
                            mFloat16Filter    = mGL.getExtension( 'OES_texture_half_float_linear' );
                            mDerivatives      = true;
                            mDrawBuffers      = true;
                            mDepthTextures    = true;
                            mShaderTextureLOD = true;
                            mAnisotropic = mGL.getExtension( 'EXT_texture_filter_anisotropic' );
                            mRenderToFloat32F = mGL.getExtension( 'EXT_color_buffer_float');
                            mDebugShader = mGL.getExtension('WEBGL_debug_shaders');
                            mAsynchCompile = mGL.getExtension('KHR_parallel_shader_compile');

							mGL.hint( mGL.FRAGMENT_SHADER_DERIVATIVE_HINT, mGL.NICEST);
                        }
                        else
                        {
                            mFloat32Textures  = mGL.getExtension( 'OES_texture_float' );
                            mFloat32Filter    = mGL.getExtension( 'OES_texture_float_linear');
                            mFloat16Textures  = mGL.getExtension( 'OES_texture_half_float' );
                            mFloat16Filter    = mGL.getExtension( 'OES_texture_half_float_linear' );
                            mDerivatives      = mGL.getExtension( 'OES_standard_derivatives' );
                            mDrawBuffers      = mGL.getExtension( 'WEBGL_draw_buffers' );
                            mDepthTextures    = mGL.getExtension( 'WEBGL_depth_texture' );
                            mShaderTextureLOD = mGL.getExtension( 'EXT_shader_texture_lod' );
                            mAnisotropic      = mGL.getExtension( 'EXT_texture_filter_anisotropic' );
                            mRenderToFloat32F = mFloat32Textures;
                            mDebugShader      = null;
                            mAsynchCompile    = null;
							
							if( mDerivatives !== null) mGL.hint( mDerivatives.FRAGMENT_SHADER_DERIVATIVE_HINT_OES, mGL.NICEST);
                        }
                        
                        
                        var maxTexSize = mGL.getParameter( mGL.MAX_TEXTURE_SIZE );
                        var maxCubeSize = mGL.getParameter( mGL.MAX_CUBE_MAP_TEXTURE_SIZE );
                        var maxRenderbufferSize = mGL.getParameter( mGL.MAX_RENDERBUFFER_SIZE );
                        var extensions = mGL.getSupportedExtensions();
                        var textureUnits = mGL.getParameter( mGL.MAX_TEXTURE_IMAGE_UNITS );
                        console.log("WebGL (2.0=" + mIs20 + "):" +
                                    " Asynch Compile: "  + ((mAsynchCompile !==null) ? "yes" : "no") +
                                    ", Textures: F32 ["   + ((mFloat32Textures !==null) ? "yes" : "no") +
                                    "], F16 ["   + ((mFloat16Textures !==null) ? "yes" : "no") +
                                    "], Depth [" + ((mDepthTextures   !==null) ? "yes" : "no") +
                                    "], LOD ["    + ((mShaderTextureLOD!==null) ? "yes" : "no") +
                                    "], Aniso ["   + ((mAnisotropic     !==null) ? "yes" : "no") +
                                    "], Units [" + textureUnits +
                                    "], Max Size [" + maxTexSize +
                                    "], Cube Max Size [" + maxCubeSize +
                                    "], Targets: MRT ["            + ((mDrawBuffers     !==null) ? "yes" : "no") +
                                    "], F32 ["     + ((mRenderToFloat32F!==null) ? "yes" : "no") +
                                    "], Max Size [" + maxRenderbufferSize + "]");

                        // create a 2D quad Vertex Buffer
                        var vertices = new Float32Array( [ -1.0, -1.0,   1.0, -1.0,    -1.0,  1.0,     1.0, -1.0,    1.0,  1.0,    -1.0,  1.0] );
                        mVBO_Quad = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Quad );
                        mGL.bufferData( mGL.ARRAY_BUFFER, vertices, mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 2D triangle Vertex Buffer
                        mVBO_Tri = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Tri );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0,   3.0, -1.0,    -1.0,  3.0] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 3D cube Vertex Buffer
                        mVBO_CubePosNor = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePosNor );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0, -1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0, -1.0,  1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0,  1.0, -1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0,  1.0,  1.0,  -1.0,  0.0,  0.0,
                                                                               1.0,  1.0, -1.0,   1.0,  0.0,  0.0,
                                                                               1.0,  1.0,  1.0,   1.0,  0.0,  0.0,
                                                                               1.0, -1.0, -1.0,   1.0,  0.0,  0.0,
                                                                               1.0, -1.0,  1.0,   1.0,  0.0,  0.0,
                                                                               1.0,  1.0,  1.0,   0.0,  1.0,  0.0,
                                                                               1.0,  1.0, -1.0,   0.0,  1.0,  0.0,
                                                                              -1.0,  1.0,  1.0,   0.0,  1.0,  0.0,
                                                                              -1.0,  1.0, -1.0,   0.0,  1.0,  0.0,
                                                                               1.0, -1.0, -1.0,   0.0, -1.0,  0.0,
                                                                               1.0, -1.0,  1.0,   0.0, -1.0,  0.0,
                                                                              -1.0, -1.0, -1.0,   0.0, -1.0,  0.0,
                                                                              -1.0, -1.0,  1.0,   0.0, -1.0,  0.0,
                                                                              -1.0,  1.0,  1.0,   0.0,  0.0,  1.0,
                                                                              -1.0, -1.0,  1.0,   0.0,  0.0,  1.0,
                                                                               1.0,  1.0,  1.0,   0.0,  0.0,  1.0,
                                                                               1.0, -1.0,  1.0,   0.0,  0.0,  1.0,
                                                                              -1.0, -1.0, -1.0,   0.0,  0.0, -1.0,
                                                                              -1.0,  1.0, -1.0,   0.0,  0.0, -1.0,
                                                                               1.0, -1.0, -1.0,   0.0,  0.0, -1.0,
                                                                               1.0,  1.0, -1.0,   0.0,  0.0, -1.0 ] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 3D cube Vertex Buffer
                        mVBO_CubePos = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePos );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0, -1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                               1.0,  1.0, -1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0, -1.0,  1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0,  1.0, -1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0, -1.0,  1.0,
                                                                              -1.0, -1.0, -1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0, -1.0,  1.0,
                                                                              -1.0, -1.0, -1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0,  1.0, -1.0 ] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        //-------------------------------------------------------------------

                        mShaderHeader[0] = "";
                        mShaderHeaderLines[0] = 0;
                        if( mIs20 ) 
                        { 
                            mShaderHeader[0] += "#version 300 es\n" +
                                                "#ifdef GL_ES\n"+
                                                "precision highp float;\n" +
                                                "precision highp int;\n"+
                                                "precision mediump sampler3D;\n"+
                                                "#endif\n"; 
                            mShaderHeaderLines[0] += 6;
                        }
                        else
                        {
                            mShaderHeader[0] += "#ifdef GL_ES\n"+
                                                "precision highp float;\n" +
                                                "precision highp int;\n"+
                                                "#endif\n"+
                                                "float round( float x ) { return floor(x+0.5); }\n"+
                                                "vec2 round(vec2 x) { return floor(x + 0.5); }\n"+
                                                "vec3 round(vec3 x) { return floor(x + 0.5); }\n"+
                                                "vec4 round(vec4 x) { return floor(x + 0.5); }\n"+
                                                "float trunc( float x, float n ) { return floor(x*n)/n; }\n"+
                                                "mat3 transpose(mat3 m) { return mat3(m[0].x, m[1].x, m[2].x, m[0].y, m[1].y, m[2].y, m[0].z, m[1].z, m[2].z); }\n"+
                                                "float determinant( in mat2 m ) { return m[0][0]*m[1][1] - m[0][1]*m[1][0]; }\n"+
                                                "float determinant( mat4 m ) { float b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0], b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0], b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0], b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1], b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1], b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2], b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0], b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0], b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0], b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1], b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1], b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;}\n"+
                                                "mat2 inverse(mat2 m) { float det = determinant(m); return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / det; }\n"+
                                                "mat4 inverse(mat4 m ) { float inv0 = m[1].y*m[2].z*m[3].w - m[1].y*m[2].w*m[3].z - m[2].y*m[1].z*m[3].w + m[2].y*m[1].w*m[3].z + m[3].y*m[1].z*m[2].w - m[3].y*m[1].w*m[2].z; float inv4 = -m[1].x*m[2].z*m[3].w + m[1].x*m[2].w*m[3].z + m[2].x*m[1].z*m[3].w - m[2].x*m[1].w*m[3].z - m[3].x*m[1].z*m[2].w + m[3].x*m[1].w*m[2].z; float inv8 = m[1].x*m[2].y*m[3].w - m[1].x*m[2].w*m[3].y - m[2].x  * m[1].y * m[3].w + m[2].x  * m[1].w * m[3].y + m[3].x * m[1].y * m[2].w - m[3].x * m[1].w * m[2].y; float inv12 = -m[1].x  * m[2].y * m[3].z + m[1].x  * m[2].z * m[3].y +m[2].x  * m[1].y * m[3].z - m[2].x  * m[1].z * m[3].y - m[3].x * m[1].y * m[2].z + m[3].x * m[1].z * m[2].y; float inv1 = -m[0].y*m[2].z * m[3].w + m[0].y*m[2].w * m[3].z + m[2].y  * m[0].z * m[3].w - m[2].y  * m[0].w * m[3].z - m[3].y * m[0].z * m[2].w + m[3].y * m[0].w * m[2].z; float inv5 = m[0].x  * m[2].z * m[3].w - m[0].x  * m[2].w * m[3].z - m[2].x  * m[0].z * m[3].w + m[2].x  * m[0].w * m[3].z + m[3].x * m[0].z * m[2].w - m[3].x * m[0].w * m[2].z; float inv9 = -m[0].x  * m[2].y * m[3].w +  m[0].x  * m[2].w * m[3].y + m[2].x  * m[0].y * m[3].w - m[2].x  * m[0].w * m[3].y - m[3].x * m[0].y * m[2].w + m[3].x * m[0].w * m[2].y; float inv13 = m[0].x  * m[2].y * m[3].z - m[0].x  * m[2].z * m[3].y - m[2].x  * m[0].y * m[3].z + m[2].x  * m[0].z * m[3].y + m[3].x * m[0].y * m[2].z - m[3].x * m[0].z * m[2].y; float inv2 = m[0].y  * m[1].z * m[3].w - m[0].y  * m[1].w * m[3].z - m[1].y  * m[0].z * m[3].w + m[1].y  * m[0].w * m[3].z + m[3].y * m[0].z * m[1].w - m[3].y * m[0].w * m[1].z; float inv6 = -m[0].x  * m[1].z * m[3].w + m[0].x  * m[1].w * m[3].z + m[1].x  * m[0].z * m[3].w - m[1].x  * m[0].w * m[3].z - m[3].x * m[0].z * m[1].w + m[3].x * m[0].w * m[1].z; float inv10 = m[0].x  * m[1].y * m[3].w - m[0].x  * m[1].w * m[3].y - m[1].x  * m[0].y * m[3].w + m[1].x  * m[0].w * m[3].y + m[3].x * m[0].y * m[1].w - m[3].x * m[0].w * m[1].y; float inv14 = -m[0].x  * m[1].y * m[3].z + m[0].x  * m[1].z * m[3].y + m[1].x  * m[0].y * m[3].z - m[1].x  * m[0].z * m[3].y - m[3].x * m[0].y * m[1].z + m[3].x * m[0].z * m[1].y; float inv3 = -m[0].y * m[1].z * m[2].w + m[0].y * m[1].w * m[2].z + m[1].y * m[0].z * m[2].w - m[1].y * m[0].w * m[2].z - m[2].y * m[0].z * m[1].w + m[2].y * m[0].w * m[1].z; float inv7 = m[0].x * m[1].z * m[2].w - m[0].x * m[1].w * m[2].z - m[1].x * m[0].z * m[2].w + m[1].x * m[0].w * m[2].z + m[2].x * m[0].z * m[1].w - m[2].x * m[0].w * m[1].z; float inv11 = -m[0].x * m[1].y * m[2].w + m[0].x * m[1].w * m[2].y + m[1].x * m[0].y * m[2].w - m[1].x * m[0].w * m[2].y - m[2].x * m[0].y * m[1].w + m[2].x * m[0].w * m[1].y; float inv15 = m[0].x * m[1].y * m[2].z - m[0].x * m[1].z * m[2].y - m[1].x * m[0].y * m[2].z + m[1].x * m[0].z * m[2].y + m[2].x * m[0].y * m[1].z - m[2].x * m[0].z * m[1].y; float det = m[0].x * inv0 + m[0].y * inv4 + m[0].z * inv8 + m[0].w * inv12; det = 1.0 / det; return det*mat4( inv0, inv1, inv2, inv3,inv4, inv5, inv6, inv7,inv8, inv9, inv10, inv11,inv12, inv13, inv14, inv15);}\n"+                                                
                                                "float sinh(float x)  { return (exp(x)-exp(-x))/2.; }\n"+
                                                "float cosh(float x)  { return (exp(x)+exp(-x))/2.; }\n"+
                                                "float tanh(float x)  { return sinh(x)/cosh(x); }\n"+
                                                "float coth(float x)  { return cosh(x)/sinh(x); }\n"+
                                                "float sech(float x)  { return 1./cosh(x); }\n"+
                                                "float csch(float x)  { return 1./sinh(x); }\n"+
                                                "float asinh(float x) { return    log(x+sqrt(x*x+1.)); }\n"+
                                                "float acosh(float x) { return    log(x+sqrt(x*x-1.)); }\n"+
                                                "float atanh(float x) { return .5*log((1.+x)/(1.-x)); }\n"+
                                                "float acoth(float x) { return .5*log((x+1.)/(x-1.)); }\n"+
                                                "float asech(float x) { return    log((1.+sqrt(1.-x*x))/x); }\n"+
                                                "float acsch(float x) { return    log((1.+sqrt(1.+x*x))/x); }\n";
                            mShaderHeaderLines[0] += 26;
                        }

                        //-------------------------------------------------------

                        mShaderHeader[1] = "";
                        mShaderHeaderLines[1] = 0;
                        if( mIs20 ) 
                        { 
                            mShaderHeader[1] += "#version 300 es\n"+
                                                "#ifdef GL_ES\n"+
                                                "precision highp float;\n"+
                                                "precision highp int;\n"+
                                                "precision mediump sampler3D;\n"+
                                                "#endif\n"; 
                            mShaderHeaderLines[1] += 6;
                        }
                        else
                        {
                            if( mDerivatives ) { mShaderHeader[1] += "#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n"; mShaderHeaderLines[1]+=3; }
                            if( mShaderTextureLOD  ) { mShaderHeader[1] += "#extension GL_EXT_shader_texture_lod : enable\n"; mShaderHeaderLines[1]++; }
                            mShaderHeader[1] += "#ifdef GL_ES\n"+
                                                "precision highp float;\n"+
                                                "precision highp int;\n"+
                                                "#endif\n"+ 
                                                "vec4 texture(     sampler2D   s, vec2 c)                   { return texture2D(s,c); }\n"+
                                                "vec4 texture(     sampler2D   s, vec2 c, float b)          { return texture2D(s,c,b); }\n"+
                                                "vec4 texture(     samplerCube s, vec3 c )                  { return textureCube(s,c); }\n"+
                                                "vec4 texture(     samplerCube s, vec3 c, float b)          { return textureCube(s,c,b); }\n"+
                                                "float round( float x ) { return floor(x+0.5); }\n"+
                                                "vec2 round(vec2 x) { return floor(x + 0.5); }\n"+
                                                "vec3 round(vec3 x) { return floor(x + 0.5); }\n"+
                                                "vec4 round(vec4 x) { return floor(x + 0.5); }\n"+
                                                "float trunc( float x, float n ) { return floor(x*n)/n; }\n"+
                                                "mat3 transpose(mat3 m) { return mat3(m[0].x, m[1].x, m[2].x, m[0].y, m[1].y, m[2].y, m[0].z, m[1].z, m[2].z); }\n"+
                                                "float determinant( in mat2 m ) { return m[0][0]*m[1][1] - m[0][1]*m[1][0]; }\n"+
                                                "float determinant( mat4 m ) { float b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0], b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0], b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0], b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1], b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1], b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2], b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0], b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0], b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0], b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1], b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1], b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;}\n"+
                                                "mat2 inverse(mat2 m) { float det = determinant(m); return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / det; }\n"+
                                                "mat4 inverse(mat4 m ) { float inv0 = m[1].y*m[2].z*m[3].w - m[1].y*m[2].w*m[3].z - m[2].y*m[1].z*m[3].w + m[2].y*m[1].w*m[3].z + m[3].y*m[1].z*m[2].w - m[3].y*m[1].w*m[2].z; float inv4 = -m[1].x*m[2].z*m[3].w + m[1].x*m[2].w*m[3].z + m[2].x*m[1].z*m[3].w - m[2].x*m[1].w*m[3].z - m[3].x*m[1].z*m[2].w + m[3].x*m[1].w*m[2].z; float inv8 = m[1].x*m[2].y*m[3].w - m[1].x*m[2].w*m[3].y - m[2].x  * m[1].y * m[3].w + m[2].x  * m[1].w * m[3].y + m[3].x * m[1].y * m[2].w - m[3].x * m[1].w * m[2].y; float inv12 = -m[1].x  * m[2].y * m[3].z + m[1].x  * m[2].z * m[3].y +m[2].x  * m[1].y * m[3].z - m[2].x  * m[1].z * m[3].y - m[3].x * m[1].y * m[2].z + m[3].x * m[1].z * m[2].y; float inv1 = -m[0].y*m[2].z * m[3].w + m[0].y*m[2].w * m[3].z + m[2].y  * m[0].z * m[3].w - m[2].y  * m[0].w * m[3].z - m[3].y * m[0].z * m[2].w + m[3].y * m[0].w * m[2].z; float inv5 = m[0].x  * m[2].z * m[3].w - m[0].x  * m[2].w * m[3].z - m[2].x  * m[0].z * m[3].w + m[2].x  * m[0].w * m[3].z + m[3].x * m[0].z * m[2].w - m[3].x * m[0].w * m[2].z; float inv9 = -m[0].x  * m[2].y * m[3].w +  m[0].x  * m[2].w * m[3].y + m[2].x  * m[0].y * m[3].w - m[2].x  * m[0].w * m[3].y - m[3].x * m[0].y * m[2].w + m[3].x * m[0].w * m[2].y; float inv13 = m[0].x  * m[2].y * m[3].z - m[0].x  * m[2].z * m[3].y - m[2].x  * m[0].y * m[3].z + m[2].x  * m[0].z * m[3].y + m[3].x * m[0].y * m[2].z - m[3].x * m[0].z * m[2].y; float inv2 = m[0].y  * m[1].z * m[3].w - m[0].y  * m[1].w * m[3].z - m[1].y  * m[0].z * m[3].w + m[1].y  * m[0].w * m[3].z + m[3].y * m[0].z * m[1].w - m[3].y * m[0].w * m[1].z; float inv6 = -m[0].x  * m[1].z * m[3].w + m[0].x  * m[1].w * m[3].z + m[1].x  * m[0].z * m[3].w - m[1].x  * m[0].w * m[3].z - m[3].x * m[0].z * m[1].w + m[3].x * m[0].w * m[1].z; float inv10 = m[0].x  * m[1].y * m[3].w - m[0].x  * m[1].w * m[3].y - m[1].x  * m[0].y * m[3].w + m[1].x  * m[0].w * m[3].y + m[3].x * m[0].y * m[1].w - m[3].x * m[0].w * m[1].y; float inv14 = -m[0].x  * m[1].y * m[3].z + m[0].x  * m[1].z * m[3].y + m[1].x  * m[0].y * m[3].z - m[1].x  * m[0].z * m[3].y - m[3].x * m[0].y * m[1].z + m[3].x * m[0].z * m[1].y; float inv3 = -m[0].y * m[1].z * m[2].w + m[0].y * m[1].w * m[2].z + m[1].y * m[0].z * m[2].w - m[1].y * m[0].w * m[2].z - m[2].y * m[0].z * m[1].w + m[2].y * m[0].w * m[1].z; float inv7 = m[0].x * m[1].z * m[2].w - m[0].x * m[1].w * m[2].z - m[1].x * m[0].z * m[2].w + m[1].x * m[0].w * m[2].z + m[2].x * m[0].z * m[1].w - m[2].x * m[0].w * m[1].z; float inv11 = -m[0].x * m[1].y * m[2].w + m[0].x * m[1].w * m[2].y + m[1].x * m[0].y * m[2].w - m[1].x * m[0].w * m[2].y - m[2].x * m[0].y * m[1].w + m[2].x * m[0].w * m[1].y; float inv15 = m[0].x * m[1].y * m[2].z - m[0].x * m[1].z * m[2].y - m[1].x * m[0].y * m[2].z + m[1].x * m[0].z * m[2].y + m[2].x * m[0].y * m[1].z - m[2].x * m[0].z * m[1].y; float det = m[0].x * inv0 + m[0].y * inv4 + m[0].z * inv8 + m[0].w * inv12; det = 1.0 / det; return det*mat4( inv0, inv1, inv2, inv3,inv4, inv5, inv6, inv7,inv8, inv9, inv10, inv11,inv12, inv13, inv14, inv15);}\n"+
                                                "float sinh(float x)  { return (exp(x)-exp(-x))/2.; }\n"+
                                                "float cosh(float x)  { return (exp(x)+exp(-x))/2.; }\n"+
                                                "float tanh(float x)  { return sinh(x)/cosh(x); }\n"+
                                                "float coth(float x)  { return cosh(x)/sinh(x); }\n"+
                                                "float sech(float x)  { return 1./cosh(x); }\n"+
                                                "float csch(float x)  { return 1./sinh(x); }\n"+
                                                "float asinh(float x) { return    log(x+sqrt(x*x+1.)); }\n"+
                                                "float acosh(float x) { return    log(x+sqrt(x*x-1.)); }\n"+
                                                "float atanh(float x) { return .5*log((1.+x)/(1.-x)); }\n"+
                                                "float acoth(float x) { return .5*log((x+1.)/(x-1.)); }\n"+
                                                "float asech(float x) { return    log((1.+sqrt(1.-x*x))/x); }\n"+
                                                "float acsch(float x) { return    log((1.+sqrt(1.+x*x))/x); }\n";
                            mShaderHeaderLines[1] += 30;
                            if( mShaderTextureLOD )
                            {
                            mShaderHeader[1] += "vec4 textureLod(  sampler2D   s, vec2 c, float b)          { return texture2DLodEXT(s,c,b); }\n";
                            mShaderHeader[1] += "vec4 textureGrad( sampler2D   s, vec2 c, vec2 dx, vec2 dy) { return texture2DGradEXT(s,c,dx,dy); }\n";
                            mShaderHeaderLines[1] += 2;

                            //mShaderHeader[1] += "vec4 texelFetch( sampler2D s, ivec2 c, int l) { return texture2DLodEXT(s,(vec2(c)+0.5)/vec2(800,450),float(l)); }\n";
                            //mShaderHeaderLines[1] += 1;
                            }
                        }

                        return true;
                    };

        me.GetCaps =    function ()
                        {   
                            return { mIsGL20 : mIs20,
                                     mFloat32Textures: mFloat32Textures != null,
                                     mFloat16Textures: mFloat16Textures != null,
                                     mDrawBuffers: mDrawBuffers != null,
                                     mDepthTextures: mDepthTextures != null,
                                     mDerivatives: mDerivatives != null,
                                     mShaderTextureLOD: mShaderTextureLOD != null };
                        };

        me.GetShaderHeaderLines = function (shaderType)
                        {   
                            return mShaderHeaderLines[shaderType];
                        };

        me.CheckErrors = function()
                         {
                                var error = mGL.getError();
                                if( error != mGL.NO_ERROR ) 
                                { 
                                    for( var prop in mGL ) 
                                    {
                                        if( typeof mGL[prop] == 'number' ) 
                                        {
                                            if( mGL[prop] == error )
                                            {
                                                console.log( "GL Error " + error + ": " + prop );
                                                break;
                                            }
                                        }
                                    }
                                }
                         };

        me.Clear =  function( flags, ccolor, cdepth, cstencil )
                    {
                        var mode = 0;
                        if( flags & 1 ) { mode |= mGL.COLOR_BUFFER_BIT;   mGL.clearColor( ccolor[0], ccolor[1], ccolor[2], ccolor[3] ); }
                        if( flags & 2 ) { mode |= mGL.DEPTH_BUFFER_BIT;   mGL.clearDepth( cdepth ); }
                        if( flags & 4 ) { mode |= mGL.STENCIL_BUFFER_BIT; mGL.clearStencil( cstencil ); }
                        mGL.clear( mode );
                    };


        me.CreateTexture = function ( type, xres, yres, format, filter, wrap, buffer)
                           {
                                if( mGL===null ) return null;

                                var id = mGL.createTexture();

                                var glFoTy = iFormatPI2GL( format );
                                var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                if( type===me.TEXTYPE.T2D )
                                {
                                    mGL.bindTexture( mGL.TEXTURE_2D, id );
//if( buffer==null )
    //mGL.texStorage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, xres, yres);
//else
                                    mGL.texImage2D( mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texParameteri( mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap );
                                    mGL.texParameteri( mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap );

                                    if (filter === me.FILTER.NONE)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }

                                    mGL.bindTexture( mGL.TEXTURE_2D, null );
                                }
                                else if( type===me.TEXTYPE.T3D )
                                {
                                    if( mIs20 )
                                    {
                                        mGL.bindTexture( mGL.TEXTURE_3D, id );
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_BASE_LEVEL, 0);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAX_LEVEL, Math.log2(xres));
                                        if (filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                        }
                                        else if (filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        }
                                        else
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_3D);
                                        }
                                        mGL.texImage3D( mGL.TEXTURE_3D, 0, glFoTy.mGLFormat, xres, yres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );

                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_R, glWrap );
                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_S, glWrap );
                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_T, glWrap );

                                        if (filter === me.FILTER.MIPMAP)
                                            mGL.generateMipmap( mGL.TEXTURE_3D );
                                        mGL.bindTexture( mGL.TEXTURE_3D, null );
                                    }
                                    else 
                                    {
                                        return null;
                                    }
                                }
                                else 
                                {
                                    mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );

                                    // this works great if we know the number of required mipmaps in advance (1, or other)
                                   //mGL.texStorage2D( mGL.TEXTURE_CUBE_MAP, 1, glFoTy.mGLFormat, xres, yres );

                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );

                                    if( filter === me.FILTER.NONE)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR)
                                    {
                                        mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR );
                                        mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR );
                                    }
                                    else if (filter === me.FILTER.MIPMAP)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                    }

                                    if (filter === me.FILTER.MIPMAP)
                                        mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );

                                    mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                }
                        return { mObjectID: id, mXres: xres, mYres: yres, mFormat: format, mType: type, mFilter: filter, mWrap: wrap, mVFlip:false };
                        };

        me.CreateTextureFromImage = function ( type, image, format, filter, wrap, flipY) 
                                {
                                    if( mGL===null ) return null;

                                    var id = mGL.createTexture();

                                    var glFoTy = iFormatPI2GL( format );

                                    var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                    if( type===me.TEXTYPE.T2D )
                                    {
                                        mGL.bindTexture(mGL.TEXTURE_2D, id);

                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, flipY);
                                        mGL.pixelStorei(mGL.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                                        if( mIs20 ) mGL.pixelStorei(mGL.UNPACK_COLORSPACE_CONVERSION_WEBGL, mGL.NONE );

                                        mGL.texImage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image);

                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap);

                                        if (filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                        }
                                        else if( filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_2D);
                                        }
                                        else
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_2D);
                                        }
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                        mGL.bindTexture(mGL.TEXTURE_2D, null);
                                    }
                                    else if( type===me.TEXTYPE.T3D )
                                    {
                                        return null;
                                    }
                                    else 
                                    {
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, flipY);
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[0] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[1] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (flipY ? image[3] : image[2]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (flipY ? image[2] : image[3]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[4] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[5] );

                                        if( filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR );
                                            mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR );
                                        }
                                        else if (filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                            mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );
                                        }
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                    }
                                    return { mObjectID: id, mXres: image.width, mYres: image.height, mFormat: format, mType: type, mFilter: filter, mWrap:wrap, mVFlip:flipY };
                                };

        me.SetSamplerFilter = function (te, filter, doGenerateMipsIfNeeded) 
                            {
                                if (te.mFilter === filter) return;

                                if (te.mType === me.TEXTYPE.T2D) 
                                {
                                    mGL.bindTexture(mGL.TEXTURE_2D, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_2D, null);

                                }
                                else if (te.mType === me.TEXTYPE.T3D) 
                                {
                                    mGL.bindTexture(mGL.TEXTURE_3D, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_3D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_3D);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_3D, null);

                                }
                                else
                                {
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_CUBE_MAP);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_CUBE_MAP);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                                }


                                te.mFilter = filter;
                            };

        me.SetSamplerWrap = function (te, wrap)
                            {
                                if (te.mWrap === wrap) return;

                                var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                var id = te.mObjectID;

                                if (te.mType === me.TEXTYPE.T2D)
                                {
                                    mGL.bindTexture(mGL.TEXTURE_2D, id);
                                    mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap);
                                    mGL.bindTexture(mGL.TEXTURE_2D, null);

                                }
                                else if (te.mType === me.TEXTYPE.T3D)
                                {
                                    mGL.bindTexture(mGL.TEXTURE_3D, id);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_R, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_S, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_T, glWrap);
                                    mGL.bindTexture(mGL.TEXTURE_3D, null);
                                }

                                te.mWrap = wrap;
                            };

        me.SetSamplerVFlip = function (te, vflip, image)
                            {
                                if (te.mVFlip === vflip) return;

                                var id = te.mObjectID;

                                if (te.mType === me.TEXTYPE.T2D)
                                {
                                    if( image != null)
                                    {
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture(mGL.TEXTURE_2D, id);
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, vflip);
                                        var glFoTy = iFormatPI2GL( te.mFormat );
                                        mGL.texImage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image);
                                        mGL.bindTexture(mGL.TEXTURE_2D, null);
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
                                }
                                else if (te.mType === me.TEXTYPE.CUBEMAP)
                                {
                                    if( image != null)
                                    {
                                        var glFoTy = iFormatPI2GL( te.mFormat );
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );
                                        mGL.pixelStorei( mGL.UNPACK_FLIP_Y_WEBGL, vflip);
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[0] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[1] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (vflip ? image[3] : image[2]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (vflip ? image[2] : image[3]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[4] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[5] );
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
        
                                }

                                te.mVFlip = vflip;
                            };

        me.CreateMipmaps =  function (te)
                            {
                                if( te.mType===me.TEXTYPE.T2D )
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                    mGL.bindTexture(mGL.TEXTURE_2D, te.mObjectID);
                                    mGL.generateMipmap(mGL.TEXTURE_2D);
                                    mGL.bindTexture(mGL.TEXTURE_2D, null);
                                }
                                else if( te.mType===me.TEXTYPE.CUBEMAP )
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, te.mObjectID);
                                    mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                                }
                            };

        me.UpdateTexture =  function( tex, x0, y0, xres, yres, buffer )
                            {
                                var glFoTy = iFormatPI2GL( tex.mFormat );
                                if( tex.mType===me.TEXTYPE.T2D )
                                {
                                    mGL.activeTexture( mGL.TEXTURE0);
                                    mGL.bindTexture( mGL.TEXTURE_2D, tex.mObjectID );
                                    mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, tex.mVFlip );
                                    mGL.texSubImage2D( mGL.TEXTURE_2D, 0, x0, y0, xres, yres, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.bindTexture( mGL.TEXTURE_2D, null );
                                    mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                }
                            };

        me.UpdateTextureFromImage = function( tex, image )
                                {
                                    var glFoTy = iFormatPI2GL( tex.mFormat );
                                    if( tex.mType===me.TEXTYPE.T2D )
                                    {
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture( mGL.TEXTURE_2D, tex.mObjectID );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, tex.mVFlip );
                                        mGL.texImage2D(  mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image );
                                        mGL.bindTexture( mGL.TEXTURE_2D, null );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
                                };

        me.DestroyTexture = function( te )
                            {
                                 mGL.deleteTexture( te.mObjectID );
                            };

        me.AttachTextures = function (num, t0, t1, t2, t3) 
                            {
                                if (num > 0 && t0 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                         if (t0.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t0.mObjectID);
                                    else if (t0.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t0.mObjectID);
                                    else if (t0.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t0.mObjectID);
                                }

                                if (num > 1 && t1 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE1);
                                         if (t1.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t1.mObjectID);
                                    else if (t1.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t1.mObjectID);
                                    else if (t1.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t1.mObjectID);
                                }

                                if (num > 2 && t2 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE2);
                                         if (t2.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t2.mObjectID);
                                    else if (t2.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t2.mObjectID);
                                    else if (t2.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t2.mObjectID);
                                }

                                if (num > 3 && t3 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE3);
                                         if (t3.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t3.mObjectID);
                                    else if (t3.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t3.mObjectID);
                                    else if (t3.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t3.mObjectID);
                                }
                            };

        me.DettachTextures = function()
                             {
                                mGL.activeTexture(mGL.TEXTURE0);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE1);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE2);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE3);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                             };

        me.CreateRenderTarget = function ( color0, color1, color2, color3, depth, wantZbuffer )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if (depth === null)
                                    {
                                        if( wantZbuffer===true )
                                        {
                                            var zb = mGL.createRenderbuffer();
                                            mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);
                                            mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, color0.mXres, color0.mYres);

                                            mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                        }
                                    }
                                    else
                                    {
                                        mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.TEXTURE_2D, depth.mObjectID, 0);
                                    }

                                    if( color0 !=null ) mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_2D, color0.mObjectID, 0);

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                        return null;

                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mTex0: color0 };
                                };

        me.DestroyRenderTarget = function ( tex )
                                 {
                                     mGL.deleteFramebuffer(tex.mObjectID);
                                 };

        me.SetRenderTarget = function (tex)
                             {
                                if( tex===null )
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                else
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, tex.mObjectID);

                                //mGL.drawBuffers([mGL.COLOR_ATTACHMENT0, mGL.COLOR_ATTACHMENT1]);
                             };

        me.CreateRenderTargetNew = function ( wantColor0, wantZbuffer, xres, yres, samples )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if( wantZbuffer===true )
                                    {
                                        var zb = mGL.createRenderbuffer();
                                        mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);

                                        if( samples==1 )
                                        mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, xres, yres);
                                        else
                                        mGL.renderbufferStorageMultisample(mGL.RENDERBUFFER, samples, mGL.DEPTH_COMPONENT16, xres, yres);
                                        mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                    }

                                    if( wantColor0 )
                                    {
                                        var cb = mGL.createRenderbuffer();
                                        mGL.bindRenderbuffer(mGL.RENDERBUFFER, cb);
                                        if( samples==1 )
                                        mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.RGBA8, xres, yres);
                                        else
                                        mGL.renderbufferStorageMultisample(mGL.RENDERBUFFER, samples, mGL.RGBA8, xres, yres);
                                        mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.RENDERBUFFER, cb);
                                    }

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                    {
                                        return null;
                                    }
                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mXres: xres, mYres:yres, mTex0: color0 };
                                };

        me.CreateRenderTargetCubeMap = function ( color0, depth, wantZbuffer )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if (depth === null)
                                    {
                                        if( wantZbuffer===true )
                                        {
                                            var zb = mGL.createRenderbuffer();
                                            mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);
                                            mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, color0.mXres, color0.mYres);
                                            mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                        }
                                    }
                                    else
                                    {
                                        mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.TEXTURE_2D, depth.mObjectID, 0);
                                    }

                                    if( color0 !=null ) mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_CUBE_MAP_POSITIVE_X, color0.mObjectID, 0);

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                        return null;

                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mTex0: color0 };
                                };

        me.SetRenderTargetCubeMap = function (fbo, face)
                             {
                                if( fbo===null )
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                else
                                {
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, fbo.mObjectID);
                                    mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_CUBE_MAP_POSITIVE_X+face, fbo.mTex0.mObjectID, 0);
                                }
                             };


        me.BlitRenderTarget = function( dst, src )
                                {
                                    mGL.bindFramebuffer(mGL.READ_FRAMEBUFFER, src.mObjectID);
                                    mGL.bindFramebuffer(mGL.DRAW_FRAMEBUFFER, dst.mObjectID);
                                    mGL.clearBufferfv(mGL.COLOR, 0, [0.0, 0.0, 0.0, 1.0]);
                                    mGL.blitFramebuffer( 0, 0, src.mXres, src.mYres,
                                                         0, 0, src.mXres, src.mYres,
                                                         mGL.COLOR_BUFFER_BIT, mGL.LINEAR
                                    );
                                };

        me.SetViewport = function( vp )
                         {
                              mGL.viewport( vp[0], vp[1], vp[2], vp[3] );
                         };

        me.SetWriteMask = function( c0, c1, c2, c3, z )
                          {
                              mGL.depthMask(z);
                              mGL.colorMask(c0,c0,c0,c0);
                          };

        me.SetState = function( stateName, stateValue )
                      {
                            if (stateName === me.RENDSTGATE.WIREFRAME)
                            {
                                if( stateValue ) mGL.polygonMode( mGL.FRONT_AND_BACK, mGL.LINE );
                                else             mGL.polygonMode( mGL.FRONT_AND_BACK, mGL.FILL );
                            }
                            else if (stateName === me.RENDSTGATE.FRONT_FACE)
                            {
                                if( stateValue ) mGL.cullFace( mGL.BACK );
                                else             mGL.cullFace( mGL.FRONT );
                            }
                            else if (stateName === me.RENDSTGATE.CULL_FACE)
                            {
                                if( stateValue ) mGL.enable( mGL.CULL_FACE );
                                else             mGL.disable( mGL.CULL_FACE );
                            }
                            else if (stateName === me.RENDSTGATE.DEPTH_TEST)
                            {
                                if( stateValue ) mGL.enable( mGL.DEPTH_TEST );
                                else             mGL.disable( mGL.DEPTH_TEST );
                            }
                            else if (stateName === me.RENDSTGATE.ALPHA_TO_COVERAGE)
                            {
                                if( stateValue ) { mGL.enable(  mGL.SAMPLE_ALPHA_TO_COVERAGE ); }
                                else             { mGL.disable( mGL.SAMPLE_ALPHA_TO_COVERAGE ); }
                            }
                      };

        me.SetMultisample = function( v)
                    {
                        if( v===true )
                        {
                            mGL.enable(mGL.SAMPLE_COVERAGE);
                            mGL.sampleCoverage(1.0, false);
                        }
                        else
                        {
                            mGL.disable(mGL.SAMPLE_COVERAGE);
                        }
                    };

        me.GetTranslatedShaderSource = function (shader) 
                          {
                            if( mGL===null ) return null;
                            if( mDebugShader===null ) return null;
                            let vfs = mGL.getAttachedShaders(shader.mProgram);
                            let str = mDebugShader.getTranslatedShaderSource(vfs[1]);
                            let parts = str.split("GLSL END"); str = (parts.length<2) ? str : parts[1];
                            return str;
                          };

        me.CreateShader = function (vsSource, fsSource, preventCache, forceSynch, onResolve) 
                          {
                            if( mGL===null ) return;

                            var vs = mGL.createShader( mGL.VERTEX_SHADER   );
                            var fs = mGL.createShader( mGL.FRAGMENT_SHADER );

                            vsSource = mShaderHeader[0] + vsSource;
                            fsSource = mShaderHeader[1] + fsSource;

                            if( preventCache )
                            {
                                let vran = Math.random().toString(36).substring(7);
                                let fran = Math.random().toString(36).substring(7);
                                vsSource += "\n#define K" + vran + "\n";
                                fsSource += "\n#define K" + fran + "\n";
                            }

                            var timeStart = getRealTime();

                            mGL.shaderSource(vs, vsSource);
                            mGL.shaderSource(fs, fsSource);
                            mGL.compileShader(vs);
                            mGL.compileShader(fs);

                            var pr = mGL.createProgram();
                            mGL.attachShader(pr, vs);
                            mGL.attachShader(pr, fs);
                            mGL.linkProgram(pr);

                            //-------------
                            let checkErrors = function()
                            {
                                if (!mGL.getProgramParameter(pr, mGL.LINK_STATUS))
                                {
                                    // vs error
                                    if (!mGL.getShaderParameter(vs, mGL.COMPILE_STATUS))
                                    {
                                        let vsLog = mGL.getShaderInfoLog(vs);
                                        onResolve(false, { mErrorType: 0, mErrorStr: vsLog });
                                        mGL.deleteProgram(pr);
                                    }
                                    // fs error
                                    else if (!mGL.getShaderParameter(fs, mGL.COMPILE_STATUS))
                                    {
                                        let fsLog = mGL.getShaderInfoLog(fs);
                                        onResolve(false, { mErrorType: 1, mErrorStr: fsLog });
                                        mGL.deleteProgram(pr);
                                    }
                                    // link error
                                    else
                                    {
                                        let infoLog = mGL.getProgramInfoLog(pr);
                                        onResolve(false, { mErrorType: 2, mErrorStr: infoLog });
                                        mGL.deleteProgram(pr);
                                    }
                                }
                                // no errors
                                else
                                {
                                    let compilationTime = getRealTime() - timeStart;
                                    onResolve(true, { mProgram: pr, mTime: compilationTime });
                                }
                            };

                            // check compilation
                            if (mAsynchCompile === null || forceSynch===true )
                            {
                                checkErrors();
                            }
                            else
                            {
                                let loopCheckCompletion = function ()
                                {
                                    if( mGL.getProgramParameter(pr, mAsynchCompile.COMPLETION_STATUS_KHR) === true )
                                        checkErrors();
                                    else
                                        setTimeout(loopCheckCompletion, 10);
                                };
                                setTimeout(loopCheckCompletion, 10);
                            }
                        };

        me.AttachShader = function( shader )
                          {
                                if( shader===null )
                                {
                                    mBindedShader = null;
                                    mGL.useProgram( null );
                                }
                                else
                                {
                                    mBindedShader = shader;
                                    mGL.useProgram(shader.mProgram);
                                }
                          };

        me.DetachShader = function ()
                        {
                            mGL.useProgram(null);
                        };

        me.DestroyShader = function( tex )
                        {
                            mGL.deleteProgram(tex.mProgram);
                        };

        me.GetAttribLocation = function (shader, name)
                        {
                            return mGL.getAttribLocation(shader.mProgram, name);
                        };

        me.SetShaderConstantLocation = function (shader, name)
                        {
                            return mGL.getUniformLocation(shader.mProgram, name);
                        };

        me.SetShaderConstantMat4F = function( uname, params, istranspose )
                        {
                            var program = mBindedShader;

                            let pos = mGL.getUniformLocation( program.mProgram, uname );
                            if( pos===null )
                                return false;

                            if( istranspose===false )
                            {
                                var tmp = new Float32Array( [ params[0], params[4], params[ 8], params[12],
                                                              params[1], params[5], params[ 9], params[13],
                                                              params[2], params[6], params[10], params[14],
                                                              params[3], params[7], params[11], params[15] ] );
	                            mGL.uniformMatrix4fv(pos,false,tmp);
                            }
                            else
                                mGL.uniformMatrix4fv(pos,false,new Float32Array(params) );
                            return true;
                        };

        me.SetShaderConstant1F_Pos = function(pos, x)
                        {
                            mGL.uniform1f(pos, x);
                            return true;
                        };

        me.SetShaderConstant1FV_Pos = function(pos, x)
                        {
                            mGL.uniform1fv(pos, x);
                            return true;
                        };

        me.SetShaderConstant1F = function( uname, x )
                        {
                            var pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1f(pos, x);
                            return true;
                        };

        me.SetShaderConstant1I = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1i(pos, x);
                            return true;
                        };
        me.SetShaderConstant1I_Pos = function(pos, x)
                        {
                            mGL.uniform1i(pos, x);
                            return true;
                        };


        me.SetShaderConstant2F = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform2fv(pos, x);
                            return true;
                        };

        me.SetShaderConstant3F = function(uname, x, y, z)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform3f(pos, x, y, z);
                            return true;
                        };

        me.SetShaderConstant1FV = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1fv(pos, new Float32Array(x));
                            return true;
                        };

        me.SetShaderConstant3FV = function(uname, x) 
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform3fv(pos, new Float32Array(x) );
                            return true;
                        };

        me.SetShaderConstant4FV = function(uname, x) 
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform4fv(pos, new Float32Array(x) );
                            return true;
                        };

        me.SetShaderTextureUnit = function( uname, unit )
                        {
                            var program = mBindedShader;
                            let pos = mGL.getUniformLocation(program.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform1i(pos, unit);
                            return true;
                        };

        me.CreateVertexArray = function( data, mode )
                        {
                            let id = mGL.createBuffer();
                            mGL.bindBuffer(mGL.ARRAY_BUFFER, id);
                            if (mode === me.BUFTYPE.STATIC)
                                mGL.bufferData(mGL.ARRAY_BUFFER, data, mGL.STATIC_DRAW);
                            else
                                mGL.bufferData(mGL.ARRAY_BUFFER, data, mGL.DYNAMIC_DRAW);
                            return { mObject: id };
                        };

        me.CreateIndexArray = function( data, mode )
                        {
                            let id = mGL.createBuffer();
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, id );
                            if (mode === me.BUFTYPE.STATIC)
                                mGL.bufferData(mGL.ELEMENT_ARRAY_BUFFER, data, mGL.STATIC_DRAW);
                            else
                                mGL.bufferData(mGL.ELEMENT_ARRAY_BUFFER, data, mGL.DYNAMIC_DRAW);
                            return { mObject: id };
                        };

        me.DestroyArray = function( tex )
                        {
                            mGL.destroyBuffer(tex.mObject);
                        };

        me.AttachVertexArray = function( tex, attribs, pos )
                        {
                            let shader = mBindedShader;

                            mGL.bindBuffer( mGL.ARRAY_BUFFER, tex.mObject);

                            var num = attribs.mChannels.length;
                            var stride = attribs.mStride;

                            var offset = 0;
                            for (var i = 0; i < num; i++)
                            {
                                var id = pos[i];
                                mGL.enableVertexAttribArray(id);
                                var dtype = mGL.FLOAT;
                                var dsize = 4;
                                     if( attribs.mChannels[i].mType === me.TYPE.UINT8   ) { dtype = mGL.UNSIGNED_BYTE;  dsize = 1; }
                                else if( attribs.mChannels[i].mType === me.TYPE.UINT16  ) { dtype = mGL.UNSIGNED_SHORT; dsize = 2; }
                                else if( attribs.mChannels[i].mType === me.TYPE.FLOAT32 ) { dtype = mGL.FLOAT;          dsize = 4; }
                                mGL.vertexAttribPointer(id, attribs.mChannels[i].mNumComponents, dtype, attribs.mChannels[i].mNormalize, stride, offset);
                                offset += attribs.mChannels[i].mNumComponents * dsize;
                            }
                        };

        me.AttachIndexArray = function( tex )
                        {
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, tex.mObject);
                        };

        me.DetachVertexArray = function (tex, attribs)
                        {
                            let num = attribs.mChannels.length;
                            for (let i = 0; i < num; i++)
                                mGL.disableVertexAttribArray(i);
                            mGL.bindBuffer(mGL.ARRAY_BUFFER, null);
                        };

        me.DetachIndexArray = function( tex )
                        {
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, null);
                        };

        me.DrawPrimitive = function( typeOfPrimitive, num, useIndexArray, numInstances )
                        {
                            let glType = mGL.POINTS;
                            if( typeOfPrimitive===me.PRIMTYPE.POINTS ) glType = mGL.POINTS;
                            if( typeOfPrimitive===me.PRIMTYPE.LINES ) glType = mGL.LINES;
                            if( typeOfPrimitive===me.PRIMTYPE.LINE_LOOP ) glType = mGL.LINE_LOOP;
                            if( typeOfPrimitive===me.PRIMTYPE.LINE_STRIP ) glType = mGL.LINE_STRIP;
                            if( typeOfPrimitive===me.PRIMTYPE.TRIANGLES ) glType = mGL.TRIANGLES;
                            if( typeOfPrimitive===me.PRIMTYPE.TRIANGLE_STRIP ) glType = mGL.TRIANGLE_STRIP;

                            if( numInstances<=1 )
                            {
  	                            if( useIndexArray ) mGL.drawElements( glType, num, mGL.UNSIGNED_SHORT, 0 );
	                            else                mGL.drawArrays( glType, 0, num );
                            }
                            else
                            {
                                mGL.drawArraysInstanced(glType, 0, num, numInstances);
                                mGL.drawElementsInstanced( glType, num, mGL.UNSIGNED_SHORT, 0, numInstances);
                            }
                        };


        me.DrawFullScreenTriangle_XY = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Tri );
                            mGL.vertexAttribPointer( vpos, 2, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays( mGL.TRIANGLES, 0, 3 );
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        };


        me.DrawUnitQuad_XY = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Quad );
                            mGL.vertexAttribPointer( vpos, 2, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays( mGL.TRIANGLES, 0, 6 );
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        };

        me.DrawUnitCube_XYZ_NOR = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePosNor );
                            mGL.vertexAttribPointer( vpos[0], 3, mGL.FLOAT, false, 0, 0 );
                            mGL.vertexAttribPointer( vpos[1], 3, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos[0] );
                            mGL.enableVertexAttribArray( vpos[1] );
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 0, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 4, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 8, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 12, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 16, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 20, 4);
                            mGL.disableVertexAttribArray( vpos[0] );
                            mGL.disableVertexAttribArray( vpos[1] );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        }

        me.DrawUnitCube_XYZ = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePos );
                            mGL.vertexAttribPointer( vpos, 3, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 0, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 4, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 8, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 12, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 16, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 20, 4);
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        }

        me.SetBlend = function( enabled )
                    {
                        if( enabled )
                        {
                            mGL.enable( mGL.BLEND );
                            mGL.blendEquationSeparate( mGL.FUNC_ADD, mGL.FUNC_ADD );
                            mGL.blendFuncSeparate( mGL.SRC_ALPHA, mGL.ONE_MINUS_SRC_ALPHA, mGL.ONE, mGL.ONE_MINUS_SRC_ALPHA );
                        }
                        else
                        {
                            mGL.disable( mGL.BLEND );
                        }
                    };

        me.GetPixelData = function( data, offset, xres, yres )
                        {
                            mGL.readPixels(0, 0, xres, yres, mGL.RGBA, mGL.UNSIGNED_BYTE, data, offset);
                        };

        me.GetPixelDataRenderTarget = function( obj, data, xres, yres )
                        {
                            mGL.bindFramebuffer(mGL.FRAMEBUFFER, obj.mObjectID);
                            mGL.readBuffer(mGL.COLOR_ATTACHMENT0);
                            mGL.readPixels(0, 0, xres, yres, mGL.RGBA, mGL.FLOAT, data, 0);
                            mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                        };
    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piShading
//
//==============================================================================

function smoothstep(a, b, x)
{
    x = (x - a) / (b - a);
    if (x < 0) x = 0; else if (x > 1) x = 1;
    return x * x * (3.0 - 2.0 * x);
}

function clamp01(x)
{
    if( x < 0.0 ) x = 0.0;
    if( x > 1.0 ) x = 1.0;
    return x;
}

function clamp(x, a, b)
{
    if( x < a ) x = a;
    if( x > b ) x = b;
    return x;
}

function screen(a, b)
{
    return 1.0 - (1.0 - a) * (1.0 - b);
}

function parabola(x)
{
    return 4.0 * x * (1.0 - x);
}

function min(a, b)
{
    return (a < b) ? a : b;
}

function max(a, b)
{
    return (a > b) ? a : b;
}

function noise( x )
{
    function grad(i, j, x, y)
    {
        var h = 7 * i + 131 * j;
        h = (h << 13) ^ h;
        h = (h * (h * h * 15731 + 789221) + 1376312589);

        var rx = (h & 0x20000000) ? x : -x;
        var ry = (h & 0x10000000) ? y : -y;

        return rx + ry;
    }

    var i = [ Math.floor(x[0]), Math.floor(x[1]) ];
    var f = [ x[0] - i[0], x[1] - i[1] ];
    var w = [ f[0]*f[0]*(3.0-2.0*f[0]), f[1]*f[1]*(3.0-2.0*f[1]) ];

    var a = grad( i[0]+0, i[1]+0, f[0]+0.0, f[1]+0.0 );
    var b = grad( i[0]+1, i[1]+0, f[0]-1.0, f[1]+0.0 );
    var c = grad( i[0]+0, i[1]+1, f[0]+0.0, f[1]-1.0 );
    var d = grad( i[0]+1, i[1]+1, f[0]-1.0, f[1]-1.0 );

    return a + (b-a)*w[0] + (c-a)*w[1] + (a-b-c+d)*w[0]*w[1];
}//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piVecTypes
//
//==============================================================================


function vec3( a, b, c )
{
    return [ a, b, c ];
}

function add( a, b )
{
    return [ a[0]+b[0], a[1]+b[1], a[2]+b[2] ];
}

function sub( a, b )
{
    return [ a[0]-b[0], a[1]-b[1], a[2]-b[2] ];
}

function mul( a, s ) 
{
    return [ a[0]*s, a[1]*s, a[2]*s ];
}

function cross( a, b )
{
    return [ a[1]*b[2] - a[2]*b[1],
             a[2]*b[0] - a[0]*b[2],
             a[0]*b[1] - a[1]*b[0] ];
}

function dot( a, b ) 
{
    return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
}

function normalize( v ) 
{
    var is = 1.0 / Math.sqrt( v[0]*v[0] + v[1]*v[1] + v[2]*v[2] );
    return [ v[0]*is, v[1]*is, v[2]*is ];
}

function createCirclePoint( cen, uuu, vvv, rad, s, t )
{
    return [ cen[0] + rad*(uuu[0]*s + vvv[0]*t),
             cen[1] + rad*(uuu[1]*s + vvv[1]*t),
             cen[2] + rad*(uuu[2]*s + vvv[2]*t) ];
}

function createTangent( a, b, c )
{
    var cb = normalize( [ c[0]-b[0], c[1]-b[1], c[2]-b[2] ] );
    var ba = normalize( [ b[0]-a[0], b[1]-a[1], b[2]-a[2] ] );
    return normalize( [ ba[0]+cb[0], ba[1]+cb[1], ba[2]+cb[2] ] );

}

//===================================

function vec4( a, b, c, d )
{
    return [ a, b, c, d ];
}

function getXYZ( v )
{
    return [ v[0], v[1], v[2] ];
}

//===================================

function setIdentity()
{
    return [ 1.0, 0.0, 0.0, 0.0,
             0.0, 1.0, 0.0, 0.0,
             0.0, 0.0, 1.0, 0.0,
             0.0, 0.0, 0.0, 1.0 ];
}

function setRotationX( t )
{
    var sint = Math.sin(t);
    var cost = Math.cos(t);

    return [ 1.0,   0.0,   0.0, 0.0,
             0.0,  cost, -sint, 0.0, 
             0.0,  sint,  cost, 0.0,
             0.0,   0.0,   0.0, 1.0 ];
}

function setRotationY( t )
{
    var sint = Math.sin(t);
    var cost = Math.cos(t);

    return [ cost, 0.0, -sint, 0.0,
              0.0, 1.0,   0.0, 0.0, 
             sint, 0.0,  cost, 0.0,
              0.0, 0.0,   0.0, 1.0 ];
}

function extractRotationEuler( m)
{
    var res = [];
    if (m[0] == 1.0)
    {
        res[0] = Math.atan2(m[2], m[11]);
        res[1] = 0.0;
        res[2] = 0.0;

    }
    else if (m[0] == -1.0)
    {
        res[0] = Math.atan2( m[2], m[11]);
        res[1] = 0.0;
        res[2] = 0.0;
    }
    else
    {
        res[0] = Math.atan2( -m[9], m[10]);
        res[1] = Math.atan2( m[8], Math.sqrt(m[9]*m[9] + m[10]*m[10]));
        res[2] = Math.atan2( m[4], m[0]);
    }
    return res;
}

function setFromQuaternion( q )
{
    var ww = q[3]*q[3];
    var xx = q[0]*q[0];
    var yy = q[1]*q[1];
    var zz = q[2]*q[2];

    return [ ww+xx-yy-zz,                   2.0*(q[0]*q[1] - q[3]*q[2]), 2.0*(q[0]*q[2] + q[3]*q[1]), 0.0,
               2.0*(q[0]*q[1] + q[3]*q[2]),   ww-xx+yy-zz,                 2.0*(q[1]*q[2] - q[3]*q[0]), 0.0,
               2.0*(q[0]*q[2] - q[3]*q[1]),   2.0*(q[1]*q[2] + q[3]*q[0]), ww-xx-yy+zz,                 0.0,
               0.0,                           0.0,                         0.0,                         1.0 ];
}

function setPerspective( fovy, aspect, znear, zfar )
{
    var tan = Math.tan(fovy * Math.PI/180.0);
    var x = 1.0 / (tan*aspect);
    var y = 1.0 / (tan);
    var c = -(zfar + znear) / ( zfar - znear);
    var d = -(2.0 * zfar * znear) / (zfar - znear);

    return [ x,    0.0,  0.0,  0.0,
             0.0,  y,    0.0,  0.0,
             0.0,  0.0,  c,     d,
             0.0,  0.0, -1.0,  0.0 ];
}

function setLookAt( eye, tar, up )
{
    var dir = [ -tar[0]+eye[0], -tar[1]+eye[1], -tar[2]+eye[2] ];

	var m00 = dir[2]*up[1] - dir[1]*up[2]; 
    var m01 = dir[0]*up[2] - dir[2]*up[0];
    var m02 = dir[1]*up[0] - dir[0]*up[1];
    var im = 1.0/Math.sqrt( m00*m00 + m01*m01 + m02*m02 );
    m00 *= im;
    m01 *= im;
    m02 *= im;

	var m04 = m02*dir[1] - m01*dir[2]; 
    var m05 = m00*dir[2] - m02*dir[0];
    var m06 = m01*dir[0] - m00*dir[1];
    im = 1.0/Math.sqrt( m04*m04 + m05*m05 + m06*m06 );
    m04 *= im;
    m05 *= im;
    m06 *= im;

	var m08 = dir[0];
	var m09 = dir[1];
	var m10 = dir[2];
    im = 1.0/Math.sqrt( m08*m08 + m09*m09 + m10*m10 );
    m08 *= im;
    m09 *= im;
    m10 *= im;

	var m03 = -(m00*eye[0] + m01*eye[1] + m02*eye[2] );
	var m07 = -(m04*eye[0] + m05*eye[1] + m06*eye[2] );
	var m11 = -(m08*eye[0] + m09*eye[1] + m10*eye[2] );

    return [ m00, m01, m02, m03,
             m04, m05, m06, m07,
             m08, m09, m10, m11,
             0.0, 0.0, 0.0, 1.0 ];
}


function setOrtho( left, right, bottom, top, znear, zfar )
{
   var x = 2.0 / (right - left);
   var y = 2.0 / (top - bottom);
   var a = (right + left) / (right - left);
   var b = (top + bottom) / (top - bottom);
   var c = -2.0 / (zfar - znear);
   var d = -(zfar + znear) / ( zfar - znear);

   return [  x, 0.0, 0.0,   a,
           0.0,   y, 0.0,   b,
           0.0, 0.0,   c,   d,
           0.0, 0.0, 0.0, 1.0 ];
}

function setTranslation( p )
{
    return [ 1.0, 0.0, 0.0, p[0],
             0.0, 1.0, 0.0, p[1],
             0.0, 0.0, 1.0, p[2],
             0.0, 0.0, 0.0, 1.0 ];
}

function setScale( s )
{
    return [ s[0], 0.0,  0.0,  0.0,
             0.0,  s[1], 0.0,  0.0,
             0.0,  0.0,  s[2], 0.0,
             0.0,  0.0,  0.0,  1.0];
}

function setProjection( fov, znear, zfar )
{
    var x = 2.0 / (fov[3]+fov[2]);
    var y = 2.0 / (fov[0]+fov[1]);
    var a = (fov[3]-fov[2]) / (fov[3]+fov[2]);
    var b = (fov[0]-fov[1]) / (fov[0]+fov[1]);
    var c = -(zfar + znear) / ( zfar - znear);
    var d = -(2.0*zfar*znear) / (zfar - znear);
    return [   x, 0.0,    a, 0.0,
             0.0,   y,    b, 0.0,
             0.0, 0.0,    c,   d,
             0.0, 0.0, -1.0, 0.0 ];
   // inverse is:
   //return mat4x4( 1.0/x, 0.0f,  0.0f,   a/x,
   //               0.0f,  1.0/y, 0.0f,   b/x,
   //               0.0f,  0.0f,  0.0f,   -1.0,
   //               0.0f,  0.0f,  1.0f/d, c/d );
}


function invertFast( m )
{
    var inv = [
   
             m[5]  * m[10] * m[15] - 
             m[5]  * m[11] * m[14] - 
             m[9]  * m[6]  * m[15] + 
             m[9]  * m[7]  * m[14] +
             m[13] * m[6]  * m[11] - 
             m[13] * m[7]  * m[10],

             -m[1]  * m[10] * m[15] + 
              m[1]  * m[11] * m[14] + 
              m[9]  * m[2] * m[15] - 
              m[9]  * m[3] * m[14] - 
              m[13] * m[2] * m[11] + 
              m[13] * m[3] * m[10],

             m[1]  * m[6] * m[15] - 
             m[1]  * m[7] * m[14] - 
             m[5]  * m[2] * m[15] + 
             m[5]  * m[3] * m[14] + 
             m[13] * m[2] * m[7] - 
             m[13] * m[3] * m[6],

             -m[1] * m[6] * m[11] + 
              m[1] * m[7] * m[10] + 
              m[5] * m[2] * m[11] - 
              m[5] * m[3] * m[10] - 
              m[9] * m[2] * m[7] + 
              m[9] * m[3] * m[6],

             -m[4]  * m[10] * m[15] + 
              m[4]  * m[11] * m[14] + 
              m[8]  * m[6]  * m[15] - 
              m[8]  * m[7]  * m[14] - 
              m[12] * m[6]  * m[11] + 
              m[12] * m[7]  * m[10],

             m[0]  * m[10] * m[15] - 
             m[0]  * m[11] * m[14] - 
             m[8]  * m[2] * m[15] + 
             m[8]  * m[3] * m[14] + 
             m[12] * m[2] * m[11] - 
             m[12] * m[3] * m[10],

             -m[0]  * m[6] * m[15] + 
              m[0]  * m[7] * m[14] + 
              m[4]  * m[2] * m[15] - 
              m[4]  * m[3] * m[14] - 
              m[12] * m[2] * m[7] + 
              m[12] * m[3] * m[6],


             m[0] * m[6] * m[11] - 
             m[0] * m[7] * m[10] - 
             m[4] * m[2] * m[11] + 
             m[4] * m[3] * m[10] + 
             m[8] * m[2] * m[7] - 
             m[8] * m[3] * m[6],


             m[4]  * m[9] * m[15] - 
             m[4]  * m[11] * m[13] - 
             m[8]  * m[5] * m[15] + 
             m[8]  * m[7] * m[13] + 
             m[12] * m[5] * m[11] - 
             m[12] * m[7] * m[9],



             -m[0]  * m[9] * m[15] + 
              m[0]  * m[11] * m[13] + 
              m[8]  * m[1] * m[15] - 
              m[8]  * m[3] * m[13] - 
              m[12] * m[1] * m[11] + 
              m[12] * m[3] * m[9],

              m[0]  * m[5] * m[15] - 
              m[0]  * m[7] * m[13] - 
              m[4]  * m[1] * m[15] + 
              m[4]  * m[3] * m[13] + 
              m[12] * m[1] * m[7] - 
              m[12] * m[3] * m[5],

              -m[0] * m[5] * m[11] + 
               m[0] * m[7] * m[9] + 
               m[4] * m[1] * m[11] - 
               m[4] * m[3] * m[9] - 
               m[8] * m[1] * m[7] + 
               m[8] * m[3] * m[5],

              -m[4]  * m[9] * m[14] + 
               m[4]  * m[10] * m[13] +
               m[8]  * m[5] * m[14] - 
               m[8]  * m[6] * m[13] - 
               m[12] * m[5] * m[10] + 
               m[12] * m[6] * m[9],

              m[0]  * m[9] * m[14] - 
              m[0]  * m[10] * m[13] - 
              m[8]  * m[1] * m[14] + 
              m[8]  * m[2] * m[13] + 
              m[12] * m[1] * m[10] - 
              m[12] * m[2] * m[9],

              -m[0]  * m[5] * m[14] + 
               m[0]  * m[6] * m[13] + 
               m[4]  * m[1] * m[14] - 
               m[4]  * m[2] * m[13] - 
               m[12] * m[1] * m[6] + 
               m[12] * m[2] * m[5],

              m[0] * m[5] * m[10] - 
              m[0] * m[6] * m[9] - 
              m[4] * m[1] * m[10] + 
              m[4] * m[2] * m[9] + 
              m[8] * m[1] * m[6] - 
              m[8] * m[2] * m[5] ];

    var det = m[0] * inv[0] + m[1] * inv[4] + m[2] * inv[8] + m[3] * inv[12];

    det = 1.0/det;

    for( var i = 0; i<16; i++ ) inv[i] = inv[i] * det;

    return inv;
}

function matMul( a, b )
{
    var res = [];
    for( var i=0; i<4; i++ )
    {
        var x = a[4*i+0];
        var y = a[4*i+1];
        var z = a[4*i+2];
        var w = a[4*i+3];

        res[4*i+0] = x * b[ 0] + y * b[ 4] + z * b[ 8] + w * b[12];
        res[4*i+1] = x * b[ 1] + y * b[ 5] + z * b[ 9] + w * b[13];
        res[4*i+2] = x * b[ 2] + y * b[ 6] + z * b[10] + w * b[14];
        res[4*i+3] = x * b[ 3] + y * b[ 7] + z * b[11] + w * b[15];
    }

    return res;
}

function matMulpoint( m, v )
{
    return [ m[0]*v[0] + m[1]*v[1] + m[ 2]*v[2] + m[ 3],
             m[4]*v[0] + m[5]*v[1] + m[ 6]*v[2] + m[ 7],
             m[8]*v[0] + m[9]*v[1] + m[10]*v[2] + m[11] ];
}

function matMulvec( m, v )
{
    return [ m[0]*v[0] + m[1]*v[1] + m[ 2]*v[2],
             m[4]*v[0] + m[5]*v[1] + m[ 6]*v[2],
             m[8]*v[0] + m[9]*v[1] + m[10]*v[2] ];
}


function bound3( infi )
{
    return [ infi, -infi, infi, -infi, infi, -infi ];
}

function bound3_include( a, p )
{
    return [
        (p[0]<a[0]) ? p[0] : a[0],
        (p[0]>a[1]) ? p[0] : a[1],
        (p[1]<a[2]) ? p[1] : a[2],
        (p[1]>a[3]) ? p[1] : a[3],
        (p[2]<a[4]) ? p[2] : a[4],
        (p[2]>a[5]) ? p[2] : a[5] ];
}

function bound3_center( b )
{
    return [ 0.5*(b[0]+b[1]),
             0.5*(b[2]+b[3]),
             0.5*(b[4]+b[5]) ];
}

function bound3_radius( b )
{
    return [ 0.5*(b[1]-b[0]),
             0.5*(b[3]-b[2]),
             0.5*(b[5]-b[4]) ];
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piWebVR
//
//==============================================================================

function WebVR( isVREnabledCallback, canvasElement )
{
    isVREnabledCallback(false);
    /*


    this.mSupportVR = false;
    this.mHMD = null;

    var me = this;
    var listVRDisplays = function (vrdevs) {
        for (var i = 0; i < vrdevs.length; i++)
        {
            if (vrdevs[i] instanceof VRDisplay)
            {
                me.mHMD = vrdevs[i];
                console.log("WebVR is available.");
                console.log(me.mHMD);
                break;
            }
        }

        isVREnabledCallback(true);
        me.mSupportVR = true;
    }

    if (navigator.getVRDisplays)
    {
        navigator.getVRDisplays().then(listVRDisplays);
    }

    isVREnabledCallback(false);
    this.mCanvas = canvasElement;
    */
}

WebVR.prototype.IsSupported = function()
{
    return false;
    //return this.mSupportVR;
}

WebVR.prototype.GetData = function( id )
{
    return {};
    /*
    var frameData = new VRFrameData();
    var s = this.mHMD.getFrameData(frameData);
    var ss = frameData.pose;
    
    var fovL = this.mHMD.getEyeParameters("left");
    var fovR = this.mHMD.getEyeParameters( "right" );

    // camera info
    var cPos = vec3(0.0, 0.0, 0.0);
    if (ss.position)
        cPos = vec3(-ss.position[0], -ss.position[1], -ss.position[2]);
    var rot = vec4(0.0, 0.0, 0.0, 0.0);
    if (ss.orientation)
        rot = vec4(ss.orientation[0], ss.orientation[1], ss.orientation[2], ss.orientation[3]);
    var cRot = setFromQuaternion(rot);
    var cTra = setTranslation(cPos);
    var cMat = matMul(invertFast(cRot), cTra);
    
    // per eye info
    var lTra = setTranslation( vec3(-fovL.offset[0], -fovL.offset[1], -fovL.offset[2]) );
    var lMat = matMul(lTra, cMat);
    var lPrj = [ Math.tan( fovL.fieldOfView.upDegrees * Math.PI/180.0),
                 Math.tan(fovL.fieldOfView.downDegrees * Math.PI / 180.0),
                 Math.tan(fovL.fieldOfView.leftDegrees * Math.PI / 180.0),
                 Math.tan(fovL.fieldOfView.rightDegrees * Math.PI / 180.0)];

    var rTra = setTranslation(vec3(-fovR.offset[0], -fovR.offset[1], -fovR.offset[2]));
    var rMat = matMul(rTra, cMat);
    var rPrj = [Math.tan(fovR.fieldOfView.upDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.downDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.leftDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.rightDegrees * Math.PI / 180.0)];

    return {
        mCamera   : { mCamera: cMat },
        mLeftEye  : { mVP:[0,0,fovL.renderWidth,fovL.renderHeight], mProjection:lPrj, mCamera:lMat },
        mRightEye : { mVP:[fovR.renderWidth/2,0,fovR.renderWidth,fovR.renderHeight], mProjection:rPrj, mCamera:rMat }
           };
    */
}

WebVR.prototype.Enable = function( id )
{
    /*
    this.mHMD.requestPresent([{ source: this.mCanvas }]).then(
        function ()
        {
        },
        function (err)
        {
            console.log("webVR : requestPresent failed.");
        }
    );
    */
}

WebVR.prototype.Disable = function( id )
{
    /*
    if (!this.mHMD.isPresenting)
    {
        return;
    }

    this.mHMD.exitPresent().then(
        function ()
        {
        },
        function (err)
        {
            console.log("webVR : exitPresent failed.");
        }
    );
    */
}

WebVR.prototype.RequestAnimationFrame = function (id)
{
    //this.mHMD.requestAnimationFrame(id);
}

WebVR.prototype.IsPresenting = function (id)
{
    /*
    if (this.mHMD.isPresenting)
    {
        return true;
    }
    */
    return false;
}

WebVR.prototype.Finish = function (id)
{
    /*
    if (this.mHMD.isPresenting)
    {
        this.mHMD.submitFrame();
    }
    */
}

//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piWebUtils
//
//==============================================================================


// RequestAnimationFrame
window.requestAnimFrame = ( function () { return window.requestAnimationFrame    || window.webkitRequestAnimationFrame ||
                                                 window.mozRequestAnimationFrame || window.oRequestAnimationFrame ||
                                                 window.msRequestAnimationFrame  || function( cb ) { window.setTimeout(cb,1000/60); };
                                        } )();

// performance.now
window.getRealTime = ( function() { if ("performance" in window ) return function() { return window.performance.now(); }
                                                                  return function() { return (new Date()).getTime(); }
                                  } )();

window.URL = window.URL || window.webkitURL;

navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;

function htmlEntities(str) 
{
    return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g,'&apos;');
}

function piDisableTouch()
{
    document.body.addEventListener('touchstart', function(e){ e.preventDefault(); });
}

var piGetTime = function ( timestamp )
{
    if (timestamp == 0)
        return "";
    return new Date(timestamp * 1000).toISOString().substr(0, 10);
}

function piGetCoords( obj )
{
    var x = 0;
    var y = 0; 
    do
    {
         x += obj.offsetLeft;
         y += obj.offsetTop;
    }while( obj = obj.offsetParent );

    return { mX:x, mY:y };
}

function piGetMouseCoords( ev, canvasElement )
{
    var pos = piGetCoords(canvasElement );
    var mcx =                        (ev.pageX - pos.mX) * canvasElement.width / canvasElement.offsetWidth;
    var mcy = canvasElement.height - (ev.pageY - pos.mY) * canvasElement.height / canvasElement.offsetHeight;

    return { mX: mcx, mY: mcy };

}

function piGetSourceElement( e )
{
    var ele = null;
    if( e.target )     ele = e.target;
    if( e.srcElement ) ele = e.srcElement;
    return ele;
}

function piRequestFullScreen( ele )
{
    if( ele==null ) ele =   document.documentElement;
         if( ele.requestFullscreen       ) ele.requestFullscreen();
    else if( ele.msRequestFullscreen     ) ele.msRequestFullscreen();
    else if( ele.mozRequestFullScreen    ) ele.mozRequestFullScreen();
    else if( ele.webkitRequestFullscreen ) ele.webkitRequestFullscreen( Element.ALLOW_KEYBOARD_INPUT );
}

function piIsFullScreen()
{
    return document.fullscreen || document.mozFullScreen || document.webkitIsFullScreen || document.msFullscreenElement || false;
}

function piExitFullScreen()
{
       if( document.exitFullscreen       ) document.exitFullscreen();
  else if( document.msExitFullscreen     ) document.msExitFullscreen();
  else if( document.mozCancelFullScreen  ) document.mozCancelFullScreen();
  else if( document.webkitExitFullscreen ) document.webkitExitFullscreen();
}

function piIsMobile()
{
    return (navigator.userAgent.match(/Android/i) ||
            navigator.userAgent.match(/webOS/i) ||
            navigator.userAgent.match(/iPhone/i) ||
            navigator.userAgent.match(/iPad/i) ||
            navigator.userAgent.match(/iPod/i) ||
            navigator.userAgent.match(/BlackBerry/i) ||
            navigator.userAgent.match(/Windows Phone/i)) ? true : false;
}

function piCreateGlContext( cv, useAlpha, useDepth, usePreserveBuffer, useSupersampling )
{
    var opts = { alpha: useAlpha, 
                 depth: useDepth, 
                 stencil: false, 
                 premultipliedAlpha: false, 
                 antialias: useSupersampling, 
                 preserveDrawingBuffer: usePreserveBuffer, 
                 powerPreference: "high-performance" }; // "low_power", "high_performance", "default"

    var gl = null;
    if( gl === null) gl = cv.getContext( "webgl2", opts );
    if( gl === null) gl = cv.getContext( "experimental-webgl2", opts );
    if( gl === null) gl = cv.getContext( "webgl", opts );
    if( gl === null) gl = cv.getContext( "experimental-webgl", opts );

    return gl;
}

function piCreateAudioContext()
{
    var res = null;
    try
    {
        if( window.AudioContext ) res = new AudioContext();
        if( res==null && window.webkitAudioContext ) res = new webkitAudioContext();
    }
    catch( e )
    {
        res = null;
    }
    return res;
}

function piHexColorToRGB(str) // "#ff3041"
{
    var rgb = parseInt(str.slice(1), 16);
    var r = (rgb >> 16) & 255;
    var g = (rgb >> 8) & 255;
    var b = (rgb >> 0) & 255;
    return [r, g, b];
}

function piCreateFPSCounter()
{
    var mFrame;
    var mTo;
    var mFPS;

    var iReset = function( time )
    {
        mFrame = 0;
        mTo = time;
        mFPS = 60.0;
    }

    var iCount = function( time )
    {
        mFrame++;

        if( (time-mTo)>500.0 )
        {
            mFPS = 1000.0*mFrame/(time-mTo);
            mFrame = 0;
            mTo = time;
            return true;
        }
        return false;
    }

    var iGetFPS = function()
    {
        return mFPS;
    }
    
    return { Reset : iReset, Count : iCount, GetFPS : iGetFPS };
}

function piCanMediaRecorded(canvas)
{
    if (typeof window.MediaRecorder !== 'function' || typeof canvas.captureStream !== 'function') {
        return false;
    }
    return true;
}

function piCreateMediaRecorder(isRecordingCallback, canvas) 
{
    if (piCanMediaRecorded(canvas) == false)
    {
        return null;
    }
    
    var options = { audioBitsPerSecond : 0, videoBitsPerSecond : 8000000 }; 
	     if (MediaRecorder.isTypeSupported('video/webm;codecs=h264')) options.mimeType = 'video/webm;codecs=h264';
    else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9' )) options.mimeType = 'video/webm;codecs=vp9';
    else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8' )) options.mimeType = 'video/webm;codecs=vp8';
    else                                                              options.mimeType = 'video/webm;';

    var mediaRecorder = new MediaRecorder(canvas.captureStream(), options);
    var chunks = [];
    
    mediaRecorder.ondataavailable = function(e) 
    {
        if (e.data.size > 0) 
        {
            chunks.push(e.data);
        }
    };
 
    mediaRecorder.onstart = function(){ 
        isRecordingCallback( true );
    };
    
    mediaRecorder.onstop = function()
    {
         isRecordingCallback( false );
         let blob     = new Blob(chunks, {type: "video/webm"});
         chunks       = [];
         let videoURL = window.URL.createObjectURL(blob);
         let url      = window.URL.createObjectURL(blob);
         let a        = document.createElement("a");
         document.body.appendChild(a);
         a.style      = "display: none";
         a.href       = url;
         a.download   = "capture.webm";
         a.click();
         window.URL.revokeObjectURL(url);
     };
    
    return mediaRecorder;
}

function piExportToEXR(width, height, numComponents, type, bytes)
{
    var bytesPerComponent = 0;
    if      (type=="Uint")   bytesPerComponent = 4; 
    else if (type=="Half")   bytesPerComponent = 2;
    else if (type=="Float")  bytesPerComponent = 4;

    var tHeader = 258 + (18 * numComponents + 1);
    var tTable = 8 * height;
    var tScanlines = height * (4 + 4 + (numComponents * bytesPerComponent * width));
    var tTotal = tHeader + tTable + tScanlines;

    //console.log("    header size = " + tHeader);
    //console.log("    table size = " + tTable);
    //console.log("    scanlines size = " + tScanlines);
    //console.log("    total = " + tTotal);

    var buffer = new ArrayBuffer(tTotal); 
    var data = new DataView(buffer);

    // Header
    {
        // Header : 4 bytes -> 0x76, 0x2f, 0x31, 0x01
        var c = 0;
        data.setUint8 (c++, 0x76);
        data.setUint8 (c++, 0x2f);
        data.setUint8 (c++, 0x31);
        data.setUint8 (c++, 0x01);

        // Version : 4 bytes -> 2, 0, 0, 0
        data.setUint8 (c++, 0x02);
        data.setUint8 (c++, 0x0);
        data.setUint8 (c++, 0x0);
        data.setUint8 (c++, 0x0);
        
        // Write channel info
        // Write attribute name : "channels"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x73);
            data.setUint8 (c++, 0x0);

            // Write attribute type : "chlist"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00);

            // Write attribute size : 18 x 3 + 1 = 55
            var attribSize = 18 * numComponents + 1;
            data.setUint8 (c++, attribSize); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            var i;
            for (i = 0; i < numComponents; i++)
            {
                // Attribute : "B" (42) "G" (47) "R" (52)
                if (i==0)       data.setUint8 (c++, 0x42);
                else if (i==1)  data.setUint8 (c++, 0x47);
                else if (i==2)  data.setUint8 (c++, 0x52);
                data.setUint8 (c++, 0x00);
                
                // Value : Float (2), Half (1), Uint (0)
                if      (type=="Uint")   data.setUint8 (c++, 0x00); 
                else if (type=="Half")   data.setUint8 (c++, 0x01);
                else if (type=="Float")  data.setUint8 (c++, 0x02);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);

                // Plinear
                data.setUint8 (c++, 0x01);

                // Reserved
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 

                // X sampling
                data.setUint8 (c++, 0x01); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                
                // Y sampling
                data.setUint8 (c++, 0x01);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
            }
            // End attribute
            data.setUint8 (c++, 0x00);
    
        // Write attribute name : "compression"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6d); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x00);

            // Write attribute type : "compression"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6d); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x00);

            // Write attribute size : "1"
            data.setUint8 (c++, 0x01); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // Write attribute value : "0" (None)
            data.setUint8 (c++, 0x00);

        // datawindow
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x00); 

            // box2i
            data.setUint8 (c++, 0x62); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x00);

            // size 16
            data.setUint8 (c++, 0x10); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0 3 2
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 

            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint32 (c, width-1, true);
            c += 4;
            
            data.setUint32 (c, height-1, true); 
            c += 4;

        // displayWindow
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x79); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x00);

            // box2i
            data.setUint8 (c++, 0x62); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x00); 

            // size 16
            data.setUint8 (c++, 0x10); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0 3 2
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint32 (c, width-1, true);
            c += 4;
            
            data.setUint32 (c, height-1, true); 
            c += 4;

        // lineOrder
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x4f); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00); 
            
            // lineOrder
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x4f); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00); 
            
            // size
            data.setUint8 (c++, 0x01);
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);
            
            // value 
            data.setUint8 (c++, 0x00);

        // PixelAspectRatio
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x41); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x52); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x00); 

            // float
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00);
        
            // size 4
            data.setUint8 (c++, 0x04); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 1.0
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x80); 
            data.setUint8 (c++, 0x3f);
        
        // screenWindowCenter
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x63);
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x43); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e);
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00);

            // v2f
            data.setUint8 (c++, 0x76); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x00);

            // size 8
            data.setUint8 (c++, 0x08); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

        // screenWindowWidth
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x00); 
            
            // float
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00); 

            // size
            data.setUint8 (c++, 0x04); 
            data.setUint8 (c++, 0x00);
            data.setUint8 (c++, 0x00);
            data.setUint8 (c++, 0x00);

            // value
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x80); 
            data.setUint8 (c++, 0x3f);

        // End of header
        data.setUint8 (c++, 0x00);
    }
    //console.log("header size = " + c);

    // Scanline table
    var initc = c + height * 8;
    for (var scanline = 0 ; scanline < height ; scanline ++)
    {
        var jump = initc + scanline * (8 + width * bytesPerComponent * numComponents); 
        data.setUint32 (c, jump, true);
        c += 4; 

        data.setUint32 (c, 0x00, true);
        c += 4;
    }
    //console.log("header + scanlines table size = " + c);

    // Scanlines
    for (var scanline = 0 ; scanline < height ; scanline ++)
    {
        // Scanline
        data.setUint32(c, scanline, true);
        c += 4;

        // size 24
        var size = width * numComponents * bytesPerComponent; 
        data.setUint32(c, size, true);
        c += 4;

        var numComponentsSource = 4; // number of components in the SOURCE image
        for (var component = 0; component < numComponents ; component ++) 
        {
            for (var pixel = 0 ; pixel < width ; pixel ++) 
            {
                // flip vertical, so we read OpenGL buffers without JS image flipping
                var v = bytes[(height-1-scanline) * width *numComponentsSource + pixel * numComponentsSource + (2-component)];
                if      (type=="Float") data.setFloat32(c, v, true);
                else if (type=="Half")  data.setUint16(c, v, true);

                c += bytesPerComponent;
            }
        }
    }
    //console.log("total size = " + c);
    return new Blob([buffer], {type: 'application/octet-stream'});
}


function piExportToWAV(numSamples, rate, bits, numChannels, words)
{
    let numBytes = numSamples * numChannels * bits/8;

    let buffer = new ArrayBuffer(44 + numBytes); 
    let data = new DataView(buffer);

    {
        data.setUint32( 0, 0x46464952, true );  // RIFF
        data.setUint32( 4, numBytes + 36, true);
        {
            data.setUint32( 8, 0x45564157, true );  // WAV_WAVE
            data.setUint32( 12, 0x20746D66, true );  // WAV_FMT
            {
                data.setUint32( 16, 16, true);
                data.setUint16( 20, 1, true ); // WAV_FORMAT_PCM
                data.setUint16( 22, numChannels, true);
                data.setUint32( 24, rate, true);
                data.setUint32( 28, rate*numChannels*bits / 8, true);
                data.setUint16( 32, numChannels*bits / 8, true);
                data.setUint16( 34, bits, true);
            }

            data.setUint32( 36, 0x61746164, true);  // WAV_DATA
            {
                data.setUint32( 40, numBytes, true);
                let numWords = numSamples * numChannels;
                for(let i=0; i<numWords; i++ )
                {
                    data.setInt16( 44 + i*2, words[i], true );
                }
            }
        }
    }


    //console.log("total size = " + c);
    return new Blob([buffer], {type: 'application/octet-stream'});
}

function piTriggerDownload(name, blob)
{
    let url = URL.createObjectURL(blob);
    let aElement = document.createElement("a");
    aElement.href     = url;
    aElement.target   = "_self";
    aElement.download = name;
    document.body.appendChild(aElement);
    aElement.click();
    document.body.removeChild(aElement);
}</script>
    <script>"use strict"

function bufferID_to_assetID( id )
{
    if( id===0 ) return '4dXGR8';
    if( id===1 ) return 'XsXGR8';
    if( id===2 ) return '4sXGR8';
    if( id===3 ) return 'XdfGR8';
    return 'none';
}
function assetID_to_bufferID( id )
{
    if( id==='4dXGR8' ) return 0;
    if( id==='XsXGR8' ) return 1;
    if( id==='4sXGR8' ) return 2;
    if( id==='XdfGR8' ) return 3;
    return -1;
}

function assetID_to_cubemapBuferID( id )
{
    if( id==='4dX3Rr' ) return 0;
    return -1;
}
function cubamepBufferID_to_assetID( id )
{
    if( id===0 ) return '4dX3Rr';
    return 'none';
}

function EffectPass( renderer, is20, isLowEnd, hasShaderTextureLOD, callback, obj, forceMuted, forcePaused, outputGainNode, copyProgram, id, effect  )
{
    this.mID = id;
    this.mInputs  = [null, null, null, null ];
    this.mOutputs = [null, null, null, null ];
    this.mSource = null;

    this.mGainNode = outputGainNode;
    this.mSoundShaderCompiled = false;

    this.mEffect = effect;
    this.mRenderer = renderer;
    this.mProgramCopy = copyProgram; 
    this.mCompilationTime = 0;

    this.mType = "none";
    this.mName = "none";
    this.mFrame = 0;

    this.mShaderTextureLOD = hasShaderTextureLOD;
    this.mIs20 = is20;
    this.mIsLowEnd = isLowEnd;
    this.mTextureCallbackFun = callback;
    this.mTextureCallbackObj = obj;
    this.mForceMuted = forceMuted;
    this.mForcePaused = forcePaused;
}

EffectPass.prototype.MakeHeader_Image = function()
{
    let header = "";

    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for( let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        // old API
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                  header += "uniform sampler2D iChannel" + i + ";\n";

        // new API (see shadertoy.com/view/wtdGW8)
        header += "uniform struct {\n";
             if( inp===null )                  header += "  sampler2D";
        else if( inp.mInfo.mType==="cubemap" ) header += "  samplerCube";
        else if( inp.mInfo.mType==="volume"  ) header += "  sampler3D";
        else                                  header += "  sampler2D";
        header +=        " sampler;\n";
        header += "  vec3  size;\n";
        header += "  float time;\n";
        header += "  int   loaded;\n";
        header += "}iCh" + i + ";\n";
    }
	header += "void mainImage( out vec4 c, in vec2 f );\n";
    header += "void st_assert( bool cond );\n";
    header += "void st_assert( bool cond, int v );\n";

    if( this.mIs20 ) 
    {
        header += "\nout vec4 shadertoy_out_color;\n" +
        "void st_assert( bool cond, int v ) {if(!cond){if(v==0)shadertoy_out_color.x=-1.0;else if(v==1)shadertoy_out_color.y=-1.0;else if(v==2)shadertoy_out_color.z=-1.0;else shadertoy_out_color.w=-1.0;}}\n" +
        "void st_assert( bool cond        ) {if(!cond)shadertoy_out_color.x=-1.0;}\n" +
        "void main( void )" +
        "{" +
            "shadertoy_out_color = vec4(1.0,1.0,1.0,1.0);" + 
            "vec4 color = vec4(0.0,0.0,0.0,1.0);" +
            "mainImage( color, gl_FragCoord.xy );" +
            "if(shadertoy_out_color.x<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(shadertoy_out_color.y<0.0) color=vec4(0.0,1.0,0.0,1.0);" +
            "if(shadertoy_out_color.z<0.0) color=vec4(0.0,0.0,1.0,1.0);" +
            "if(shadertoy_out_color.w<0.0) color=vec4(1.0,1.0,0.0,1.0);" +
            "shadertoy_out_color = vec4(color.xyz,1.0);" +
        "}";
    }
    else
    {
        header += "" +
        "void st_assert( bool cond, int v ) {if(!cond){if(v==0)gl_FragColor.x=-1.0;else if(v==1)gl_FragColor.y=-1.0;else if(v==2)gl_FragColor.z=-1.0;else gl_FragColor.w=-1.0;}}\n" +
        "void st_assert( bool cond        ) {if(!cond)gl_FragColor.x=-1.0;}\n" +
        "void main( void )" +
        "{" +
            "gl_FragColor = vec4(0.0,0.0,0.0,1.0);" + 
            "vec4 color = vec4(0.0,0.0,0.0,1.0);" +
            "mainImage( color, gl_FragCoord.xy );" +
            "color.w = 1.0;" +
            "if(gl_FragColor.w<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(gl_FragColor.x<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(gl_FragColor.y<0.0) color=vec4(0.0,1.0,0.0,1.0);" +
            "if(gl_FragColor.z<0.0) color=vec4(0.0,0.0,1.0,1.0);" +
            "if(gl_FragColor.w<0.0) color=vec4(1.0,1.0,0.0,1.0);" +
            "gl_FragColor = vec4(color.xyz,1.0);"+
        "}";
    }
    header += "\n";

    /*
    this.mImagePassFooterVR = "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 ) 
        this.mImagePassFooterVR += "\nout vec4 outColor;\n";
    this.mImagePassFooterVR += "void main( void )" +
    "{" +
        "vec4 color = vec4(0.0,0.0,0.0,1.0);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainVR( color, gl_FragCoord.xy-unViewport.xy, ro, rd );" +
        "color.w = 1.0;"
    if( this.mIs20 ) 
        this.mImagePassFooterVR +=  "outColor = color;}";
    else
        this.mImagePassFooterVR +=  "gl_FragColor = color;}";
    */
    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Buffer = function()
{
    let header = "";
    
    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                  header += "uniform sampler2D iChannel" + i + ";\n";
    }

	header += "void mainImage( out vec4 c,  in vec2 f );\n"

    if( this.mIs20 )
        header += "\nout vec4 outColor;\n";
    header += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(0.0,0.0,0.0,1.0);" +
        "mainImage( color, gl_FragCoord.xy );";
    if( this.mIs20 )
        header +="outColor = color; }";
    else
        header +="gl_FragColor = color; }";
    header += "\n";

    /*
    this.mImagePassFooterVR = "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 )
    this.mImagePassFooterVR += "\nout vec4 outColor;\n";
    this.mImagePassFooterVR += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(0.0,0.0,0.0,1.0);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainVR( color, gl_FragCoord.xy-unViewport.xy, ro, rd );";
    if( this.mIs20 )
        this.mImagePassFooterVR +="outColor = color; }";
    else
        this.mImagePassFooterVR +="gl_FragColor = color; }";
    */
    this.mHeader = header;
    this.mHeaderLength = 0;
}


EffectPass.prototype.MakeHeader_Cubemap = function()
{
    let header = "";
    
    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                   header += "uniform sampler2D iChannel" + i + ";\n";
    }

	header += "void mainCubemap( out vec4 c, in vec2 f, in vec3 ro, in vec3 rd );\n"

    header += "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 )
        header += "\nout vec4 outColor;\n";
    header += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(0.0,0.0,0.0,1.0);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainCubemap( color, gl_FragCoord.xy-unViewport.xy, ro, rd );";
    if( this.mIs20 )
        header +="outColor = color; }";
    else
        header +="gl_FragColor = color; }";
    header += "\n";

    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Sound = function()
{
    let header = "";

    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform float     iChannelTime[4];\n" +
              "uniform float     iTimeOffset;\n" +
              "uniform int       iSampleOffset;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n";

    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp!==null && inp.mInfo.mType==="cubemap" )
            header += "uniform samplerCube iChannel" + i + ";\n";
        else
            header += "uniform sampler2D iChannel" + i + ";\n";
    }
    header += "\n";
    header += "vec2 mainSound( in int samp, float time );\n";

    if( this.mIs20 )
    {
        header += "out vec4 outColor; void main()" +
            "{" +
            "float t = iTimeOffset + ((gl_FragCoord.x-0.5) + (gl_FragCoord.y-0.5)*512.0)/iSampleRate;" +
            "int   s = iSampleOffset + int(gl_FragCoord.y-0.2)*512 + int(gl_FragCoord.x-0.2);" +
            "vec2 y = mainSound( s, t );" +
            "vec2 v  = floor((0.5+0.5*y)*65536.0);" +
            "vec2 vl =   mod(v,256.0)/255.0;" +
            "vec2 vh = floor(v/256.0)/255.0;" +
            "outColor = vec4(vl.x,vh.x,vl.y,vh.y);" +
            "}";
    }
    else
    {
        header += "void main()" +
            "{" +
            "float t = iTimeOffset + ((gl_FragCoord.x-0.5) + (gl_FragCoord.y-0.5)*512.0)/iSampleRate;" +
            "vec2 y = mainSound( 0, t );" +
            "vec2 v  = floor((0.5+0.5*y)*65536.0);" +
            "vec2 vl =   mod(v,256.0)/255.0;" +
            "vec2 vh = floor(v/256.0)/255.0;" +
            "gl_FragColor = vec4(vl.x,vh.x,vl.y,vh.y);" +
            "}";
    }
    header += "\n";
    this.mHeader = header;
    this.mHeaderLength = 0;
}


EffectPass.prototype.MakeHeader_Common = function ()
{
    let header = "";
    let headerlength = 0;

    header += "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n";
    headerlength += 2;

    if (this.mIs20)
    {
        header += "out vec4 outColor;\n";
        headerlength += 1;
    }
    header += "void main( void )\n";
    headerlength += 1;

    if (this.mIs20)
        header += "{ outColor = vec4(0.0); }";
    else
        header += "{ gl_FragColor = vec4(0.0); }";
    headerlength += 1;
    header += "\n";
    headerlength += 1;

    this.mHeader = header;
    this.mHeaderLength = headerlength;
}

EffectPass.prototype.MakeHeader = function()
{
         if( this.mType==="image" ) this.MakeHeader_Image();
    else if( this.mType==="sound" ) this.MakeHeader_Sound();
    else if( this.mType==="buffer") this.MakeHeader_Buffer();
    else if( this.mType==="common") this.MakeHeader_Common();
    else if( this.mType==="cubemap") this.MakeHeader_Cubemap();
    else console.log("ERROR 4");
}

EffectPass.prototype.Create_Image = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mSupportsVR = false;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    //this.mProgramVR = null;
}
EffectPass.prototype.Destroy_Image = function( wa )
{
}

EffectPass.prototype.Create_Buffer = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mSupportsVR = false;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    //this.mProgramVR = null;
}

EffectPass.prototype.Destroy_Buffer = function( wa )
{
}

EffectPass.prototype.Create_Cubemap = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
}

EffectPass.prototype.Destroy_Cubemap = function( wa )
{
}

EffectPass.prototype.Create_Common = function( wa )
{
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.MakeHeader();
}
EffectPass.prototype.Destroy_Common = function( wa )
{
}

EffectPass.prototype.Create_Sound = function (wa)
{
    this.MakeHeader();


    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    this.mSampleRate = 44100;
    this.mPlayTime = 60*3;
    this.mPlaySamples = this.mPlayTime*this.mSampleRate;
    this.mBuffer = wa.createBuffer( 2, this.mPlaySamples, this.mSampleRate );

    //-------------------
    this.mTextureDimensions = 512;
    this.mRenderTexture = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D, 
                                                       this.mTextureDimensions, this.mTextureDimensions,
                                                       this.mRenderer.TEXFMT.C4I8,
                                                       this.mRenderer.FILTER.NONE,
                                                       this.mRenderer.TEXWRP.CLAMP, null);
    this.mRenderFBO = this.mRenderer.CreateRenderTarget(this.mRenderTexture, null, null, null, null, false);

    //-----------------------------

    // ArrayBufferView pixels;
    this.mTmpBufferSamples = this.mTextureDimensions*this.mTextureDimensions;
    this.mData = new Uint8Array( this.mTmpBufferSamples*4 );

    this.mPlaying = false;
}

EffectPass.prototype.Destroy_Sound = function( wa )
{
    if( this.mPlayNode!==null ) this.mPlayNode.stop();
    this.mPlayNode = null;
    this.mBuffer = null;
    this.mData = null;

    this.mRenderer.DestroyRenderTarget(this.mRenderFBO);
    this.mRenderer.DestroyTexture(this.mRenderTexture);
}

EffectPass.prototype.Create = function( passType, wa )
{
    this.mType = passType;
    this.mSource = null;

         if( passType==="image" ) this.Create_Image( wa );
    else if( passType==="sound" ) this.Create_Sound( wa );
    else if( passType==="buffer") this.Create_Buffer( wa );
    else if( passType==="common") this.Create_Common( wa );
    else if( passType==="cubemap") this.Create_Cubemap( wa );
    else alert("ERROR 1");
}

EffectPass.prototype.SetName = function (passName)
{
    this.mName = passName;
}

EffectPass.prototype.SetCode = function (src)
{
    this.mSource = src;
}

EffectPass.prototype.Destroy = function( wa )
{
    this.mSource = null;
         if( this.mType==="image" ) this.Destroy_Image( wa );
    else if( this.mType==="sound" ) this.Destroy_Sound( wa );
    else if( this.mType==="buffer") this.Destroy_Buffer( wa );
    else if( this.mType==="common") this.Destroy_Common( wa );
    else if( this.mType==="cubemap") this.Destroy_Cubemap( wa );
    else alert("ERROR 2");
}

EffectPass.prototype.NewShader_Sound = function( shaderCode, commonShaderCodes)
{
    let vsSource = null;

    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for( let i=0; i<commonShaderCodes.length; i++ )
    {
        fsSource += commonShaderCodes[i]+'\n';
    }
    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;
    fsSource += shaderCode;

    this.mSoundShaderCompiled = false;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader_Image = function ( shaderCode, commonShaderCodes )
{
    this.mSupportsVR = false;


    let vsSource = null;
    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for (let i = 0; i < commonShaderCodes.length; i++)
    {
        fsSource += commonShaderCodes[i]+'\n';
    }
    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;
    fsSource += shaderCode;

    return [vsSource, fsSource];


    /*
    let n1 = shaderCode.indexOf("mainVR(");
    let n2 = shaderCode.indexOf("mainVR (");
    let n3 = shaderCode.indexOf("mainVR  (");
    if( n1>0 || n2>0 || n3>0 )
    {
        let vsSourceVR;
        if( this.mIs20 )
            vsSourceVR = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        else
            vsSourceVR = "attribute in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

        let fsSourceVR = this.mHeader;
        for (let i = 0; i < commonShaderCodes.length; i++) {
            fsSourceVR += commonShaderCodes[i];
        }
        fsSourceVR += shaderCode;
        fsSourceVR += this.mImagePassFooterVR;

        let res = this.mRenderer.CreateShader(vsSource, fsSourceVR, preventCache);
        if( res.mResult == false )
        {
            return res.mInfo;
        }
        if( this.mProgramVR != null )
            this.mRenderer.DestroyShader( this.mProgramVR );

        this.mSupportsVR = true;
        this.mProgramVR = res;
    }
    */
}

EffectPass.prototype.NewShader_Cubemap = function( shaderCode, commonShaderCodes )
{
    let vsSource = null;
    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for (let i = 0; i < commonShaderCodes.length; i++)
    {
        fsSource += commonShaderCodes[i]+'\n';
    }

    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;

    fsSource += shaderCode;

    return [vsSource, fsSource];
}


EffectPass.prototype.NewShader_Common = function (shaderCode )
{
    let vsSource = null;
    if (this.mIs20)
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader + shaderCode;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader = function ( commonSourceCodes, preventCache, onResolve)
{
    if( this.mRenderer===null ) return;

    let vs_fs = null;

         if( this.mType==="sound"  ) vs_fs = this.NewShader_Sound(   this.mSource, commonSourceCodes );
    else if( this.mType==="image"  ) vs_fs = this.NewShader_Image(   this.mSource, commonSourceCodes );
    else if( this.mType==="buffer" ) vs_fs = this.NewShader_Image(   this.mSource, commonSourceCodes );
    else if( this.mType==="common" ) vs_fs = this.NewShader_Common(  this.mSource,                   );
    else if( this.mType==="cubemap") vs_fs = this.NewShader_Cubemap( this.mSource, commonSourceCodes );
    else { console.log("ERROR 3: \"" + this.mType + "\""); return; }

    let me = this;
    this.mRenderer.CreateShader(vs_fs[0], vs_fs[1], preventCache, false,
        function (worked, info)
        {
            if (worked === true)
            {
                if (me.mType === "sound")
                {
                    me.mSoundShaderCompiled = true;
                }

                me.mCompilationTime = info.mTime;
                me.mError = false;
                me.mErrorStr = "No Errors";
                if (me.mProgram !== null)
                    me.mRenderer.DestroyShader(me.mProgram);
                me.mTranslatedSource = me.mRenderer.GetTranslatedShaderSource(info);
                me.mProgram = info;
            }
            else
            {
                me.mError = true;
                me.mErrorStr = info.mErrorStr;
            }
            onResolve();
        });
}

EffectPass.prototype.DestroyInput = function( id )
{
    if( this.mInputs[id]===null ) return;

    if( this.mInputs[id].mInfo.mType==="texture" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    if( this.mInputs[id].mInfo.mType==="volume" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="webcam" )
    {
        this.mInputs[id].video.pause();
        this.mInputs[id].video.src = "";

        if( this.mInputs[id].video.srcObject!==null )
        {
        let tracks = this.mInputs[id].video.srcObject.getVideoTracks();
        if( tracks ) tracks[0].stop();
        }
        this.mInputs[id].video = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="video" )
    {
        this.mInputs[id].video.pause();
        this.mInputs[id].video = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="music" || this.mInputs[id].mInfo.mType==="musicstream")
    {
        this.mInputs[id].audio.pause();
        this.mInputs[id].audio.mSound.mFreqData = null;
        this.mInputs[id].audio.mSound.mWaveData = null;
        this.mInputs[id].audio = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="cubemap" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="keyboard" )
    {
        //if( this.mInputs[id].globject != null )
          //  this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="mic" )
    {
        this.mInputs[id].mic = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }

    this.mInputs[id] = null;
}

EffectPass.prototype.TooglePauseInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused )
        {
            inp.video.play();
            inp.video.mPaused = false;
        }
        else
        {
            inp.video.pause();
            inp.video.mPaused = true;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        wa.resume()
        if( inp.audio.mPaused )
        {
            if( inp.loaded )
            {
                inp.audio.play();
            }
            inp.audio.mPaused = false;
        }
        else
        {
            inp.audio.pause();
            inp.audio.mPaused = true;
        }
        return inp.audio.mPaused;
    }

    return null;
}

EffectPass.prototype.StopInput = function( id )
{
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused === false )
        {
            inp.video.pause();
            inp.video.mPaused = true;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
    {
        if( inp.audio.mPaused === false )
        {
            inp.audio.pause();
            inp.audio.mPaused = true;
        }
        return inp.audio.mPaused;
    }
    return null;
}

EffectPass.prototype.ResumeInput = function( id )
{
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused )
        {
            inp.video.play();
            inp.video.mPaused = false;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
    {
        if( inp.audio.mPaused )
        {
            inp.audio.play();
            inp.audio.mPaused = false;
        }
        return inp.audio.mPaused;
    }
    return null;
}

EffectPass.prototype.RewindInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];

    if( inp==null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.loaded )
        {
            inp.video.currentTime = 0;
        }
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        wa.resume()
        if( inp.loaded )
        {
            inp.audio.currentTime = 0;
        }
    }
}

EffectPass.prototype.MuteInput = function( wa, id )
{
    let inp = this.mInputs[id];
    if( inp===null ) return;

    if( inp.mInfo.mType==="video" )
    {
        inp.video.muted = true;
        inp.video.mMuted = true;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if (wa !== null) inp.audio.mSound.mGain.gain.value = 0.0;
        inp.audio.mMuted = true;
    }
}

EffectPass.prototype.UnMuteInput = function( wa, id )
{
    let inp = this.mInputs[id];
    if( inp===null ) return;

    if( inp.mInfo.mType==="video" )
    {
        inp.video.muted = false;
        inp.video.mMuted = false;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if (wa !== null) inp.audio.mSound.mGain.gain.value = 1.0;
        inp.audio.mMuted = false;
    }
}

EffectPass.prototype.ToggleMuteInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];
    if( inp===null ) return null;

    if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mMuted ) this.UnMuteInput(wa,id);
        else                   this.MuteInput(wa,id);
        return inp.video.mMuted;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if( inp.audio.mMuted ) this.UnMuteInput(wa,id);
        else                   this.MuteInput(wa,id);
        return inp.audio.mMuted;
    }

    return null;
}

EffectPass.prototype.UpdateInputs = function( wa, forceUpdate, keyboard )
{
   for (let i=0; i<this.mInputs.length; i++ )
   {
        let inp = this.mInputs[i];

        if( inp===null )
        {
            if( forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, null, false, 0, 0, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.image, true, 1, 1, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mPreview, true, 1, 1, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
            if( inp.loaded && forceUpdate )
            {
                if( this.mTextureCallbackFun!==null )
                {
                    let img = (assetID_to_cubemapBuferID(inp.mInfo.mID)===-1) ? inp.image[0] : inp.mImage;
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, img, true, 2, 1, -1.0, this.mID );
                }
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:keyboard.mIcon,mData:keyboard.mData}, false, 6, 0, -1.0, this.mID );
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, -1, this.mID );
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
              if( inp.loaded && inp.audio.mPaused === false && inp.audio.mForceMuted === false )
              {
                  if( wa !== null )
                  {
                      inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                      inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                  }

                  if (this.mTextureCallbackFun!==null)
                  {
                           if (inp.mInfo.mType === "music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:(wa==null)?null:inp.audio.mSound.mFreqData}, false, 4, 1, inp.audio.currentTime, this.mID);
                      else if (inp.mInfo.mType === "musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:(wa==null)?null:inp.audio.mSound.mFreqData, info: inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                  }
              }
              else if( inp.loaded===false )
              {
                  if (this.mTextureCallbackFun!==null)
                      this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:null}, false, 4, 0, -1.0, this.mID);
              }
        }
        else if( inp.mInfo.mType==="mic" )
        {
              if( inp.loaded && inp.mForceMuted === false )
              {
                  if( wa !== null )
                  {
                      inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                      inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
                  }
                  if( this.mTextureCallbackFun!==null )
                      this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave: ((wa==null)?null:inp.mFreqData) }, false, 5, 1, 0, this.mID );
              }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:null}, true, 9, 1, -1.0, this.mID );
            }
        }
    }
}

EffectPass.prototype.Sampler2Renderer = function (sampler)
{
    let filter = this.mRenderer.FILTER.NONE;
    if (sampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
    if (sampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
    let wrap = this.mRenderer.TEXWRP.REPEAT;
    if (sampler.wrap === "clamp") wrap = this.mRenderer.TEXWRP.CLAMP;
    let vflip = false;
    if (sampler.vflip === "true") vflip = true;

    return { mFilter: filter, mWrap: wrap, mVFlip: vflip };
}

EffectPass.prototype.GetSamplerVFlip = function (id)
{
    let inp = this.mInputs[id];
    return inp.mInfo.mSampler.vflip;
}

EffectPass.prototype.GetTranslatedShaderSource = function ()
{
    return this.mTranslatedSource;
}


EffectPass.prototype.SetSamplerVFlip = function (id, str) 
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let filter = false;
    if (str === "true") filter = true;

    if (inp === null)
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
    }
    else if (inp.mInfo.mType === "video")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "webcam")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, null);
            inp.mInfo.mSampler.vflip = str;
        }
    }
}

EffectPass.prototype.GetAcceptsVFlip = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return false;
    if (inp.mInfo.mType === "video")  return true;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return true;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return false;
    return true;
}

EffectPass.prototype.GetSamplerFilter = function (id)
{
    let inp = this.mInputs[id];
    if( inp===null) return;
    return inp.mInfo.mSampler.filter;
}

EffectPass.prototype.SetSamplerFilter = function (id, str, buffers, cubeBuffers) 
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let filter = renderer.FILTER.NONE;
    if (str === "linear") filter = renderer.FILTER.LINEAR;
    if (str === "mipmap") filter = renderer.FILTER.MIPMAP;

    if (inp === null)
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "video")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap")
    {
        if (inp.loaded) 
        {
            if( assetID_to_cubemapBuferID(inp.mInfo.mID)===0)
            {
                renderer.SetSamplerFilter(cubeBuffers[0].mTexture[0], filter, true);
                renderer.SetSamplerFilter(cubeBuffers[0].mTexture[1], filter, true);
                inp.mInfo.mSampler.filter = str;
            }
            else
            {
                renderer.SetSamplerFilter(inp.globject, filter, true);
                inp.mInfo.mSampler.filter = str;
            }
        }
    }
    else if (inp.mInfo.mType === "webcam")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "buffer")
    {
        renderer.SetSamplerFilter(buffers[inp.id].mTexture[0], filter, true);
        renderer.SetSamplerFilter(buffers[inp.id].mTexture[1], filter, true);
        inp.mInfo.mSampler.filter = str;
    }
    else if (inp.mInfo.mType === "keyboard")
    {
        inp.mInfo.mSampler.filter = str;
    }
}



EffectPass.prototype.GetAcceptsMipmapping = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return this.mIs20;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return this.mIs20;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return this.mIs20;
    return false;
}

EffectPass.prototype.GetAcceptsLinear = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return true;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return true;
    if (inp.mInfo.mType === "music")  return true;
    if (inp.mInfo.mType === "musicstream") return true;
    if (inp.mInfo.mType === "mic")  return true;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return true;
    return false;
}


EffectPass.prototype.GetAcceptsWrapRepeat = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return this.mIs20;
    if (inp.mInfo.mType === "cubemap") return false;
    if (inp.mInfo.mType === "webcam")  return this.mIs20;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return this.mIs20;
    return false;
}

EffectPass.prototype.GetSamplerWrap = function (id)
{
    let inp = this.mInputs[id];
    return inp.mInfo.mSampler.wrap;
}
EffectPass.prototype.SetSamplerWrap = function (id, str, buffers)
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let restr = renderer.TEXWRP.REPEAT;
    if (str === "clamp") restr = renderer.TEXWRP.CLAMP;

    if (inp === null) 
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "video") 
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap") 
    {
        if (inp.loaded)
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "webcam") 
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "buffer")
    {
        renderer.SetSamplerWrap(buffers[inp.id].mTexture[0], restr);
        renderer.SetSamplerWrap(buffers[inp.id].mTexture[1], restr);
        inp.mInfo.mSampler.wrap = str;
    }
}


EffectPass.prototype.GetTexture = function( slot )
{
    let inp = this.mInputs[slot];
    if( inp===null ) return null;
    return inp.mInfo;

}

EffectPass.prototype.SetOutputs = function( slot, id )
{
    this.mOutputs[slot] = id;
}

EffectPass.prototype.SetOutputsByBufferID = function( slot, id )
{
    if( this.mType==="buffer" )
    {
        this.mOutputs[slot] = bufferID_to_assetID( id );

        this.mEffect.ResizeBuffer( id, this.mEffect.mXres, this.mEffect.mYres, false );
    }
    else if( this.mType==="cubemap" )
    {
        this.mOutputs[slot] = cubamepBufferID_to_assetID( id );
        this.mEffect.ResizeCubemapBuffer(id, 1024, 1024 );
    }
}

EffectPass.prototype.NewTexture = function( wa, slot, url, buffers, cubeBuffers, keyboard )
{
    var me = this;
    var renderer = this.mRenderer;

    if( renderer===null ) return;

    let texture = null;

    if( url===null || url.mType===null )
    {
        if( me.mTextureCallbackFun!==null )
            me.mTextureCallbackFun( this.mTextureCallbackObj, slot, null, true, 0, 0, -1.0, me.mID );
        me.DestroyInput( slot );
        me.mInputs[slot] = null;
        me.MakeHeader();
        return { mFailed:false, mNeedsShaderCompile:false };
    }
    else if( url.mType==="texture" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.image = new Image();
        texture.image.crossOrigin = '';
        texture.image.onload = function()
        {
            let rti = me.Sampler2Renderer(url.mSampler);

            // O.M.G. FIX THIS
            let channels = renderer.TEXFMT.C4I8;
            if (url.mID === "Xdf3zn" || url.mID === "4sf3Rn" || url.mID === "4dXGzn" || url.mID === "4sf3Rr")
                channels = renderer.TEXFMT.C1I8;
            
            texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.image, channels, rti.mFilter, rti.mWrap, rti.mVFlip);

            texture.loaded = true;
            if( me.mTextureCallbackFun!==null )
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.image, true, 1, 1, -1.0, me.mID );
        }
        texture.image.src = url.mSrc;


        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="volume" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.mImage = { mData:null, mXres:1, mYres:0, mZres:0 };
        texture.mPreview = new Image();
        texture.mPreview.crossOrigin = '';

	    var xmlHttp = new XMLHttpRequest();
        if( xmlHttp===null ) return { mFailed:true };

        xmlHttp.open('GET', url.mSrc, true);
        xmlHttp.responseType = "arraybuffer";
        xmlHttp.onerror = function()
        {
            console.log( "Error 1 loading Volume" );
        }
        xmlHttp.onload = function()
        {
            let data = xmlHttp.response;
            if (!data ) { console.log( "Error 2 loading Volume" ); return; }

            let file = piFile(data);

            let signature = file.ReadUInt32();
            texture.mImage.mXres = file.ReadUInt32();
            texture.mImage.mYres = file.ReadUInt32();
            texture.mImage.mZres = file.ReadUInt32();
            let binNumChannels = file.ReadUInt8();
            let binLayout = file.ReadUInt8();
            let binFormat = file.ReadUInt16();
            let format = renderer.TEXFMT.C1I8;
                 if( binNumChannels===1 && binFormat===0 )  format = renderer.TEXFMT.C1I8;
            else if( binNumChannels===2 && binFormat===0 )  format = renderer.TEXFMT.C2I8;
            else if( binNumChannels===3 && binFormat===0 )  format = renderer.TEXFMT.C3I8;
            else if( binNumChannels===4 && binFormat===0 )  format = renderer.TEXFMT.C4I8;
            else if( binNumChannels===1 && binFormat===10 ) format = renderer.TEXFMT.C1F32;
            else if( binNumChannels===2 && binFormat===10 ) format = renderer.TEXFMT.C2F32;
            else if( binNumChannels===3 && binFormat===10 ) format = renderer.TEXFMT.C3F32;
            else if( binNumChannels===4 && binFormat===10 ) format = renderer.TEXFMT.C4F32;
            else return;

            let buffer = new Uint8Array(data, 20); // skip 16 bytes (header of .bin)

            let rti = me.Sampler2Renderer(url.mSampler);

            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T3D, texture.mImage.mXres, texture.mImage.mYres, format, rti.mFilter, rti.mWrap, buffer);

            if( texture.globject===null )
            {
                console.log( "Error 4: loading Volume" ); 
                return { mFailed:true };
            }

            if (me.mTextureCallbackFun !== null)
            {
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mPreview, true, 1, 1, -1.0, me.mID );
            }

            texture.loaded = true;

            // load icon for it
            texture.mPreview.onload = function()
            {
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mPreview, true, 1, 1, -1.0, me.mID );
            }
            texture.mPreview.src = url.mPreviewSrc;
        }
        xmlHttp.send("");


        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]==null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="volume")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="cubemap" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;

        let rti = me.Sampler2Renderer(url.mSampler);

        if( assetID_to_cubemapBuferID(url.mID)!==-1 )
        {
            texture.mImage = new Image();
            texture.mImage.onload = function()
            {
                texture.loaded = true;
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mImage, true, 2, 1, -1.0, me.mID );
            }
            texture.mImage.src = "/media/previz/cubemap00.png";

            this.mEffect.ResizeCubemapBuffer(0, 1024, 1024 );

        }
        else
        {
            texture.image = [ new Image(), new Image(), new Image(), new Image(), new Image(), new Image() ];

            let numLoaded = 0;
            for (var i=0; i<6; i++ )
            {
                texture.image[i].mId = i;
                texture.image[i].crossOrigin = '';
                texture.image[i].onload = function()
                {
                    var id = this.mId;
                    numLoaded++;
                    if( numLoaded===6 )
                    {
                        texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.CUBEMAP, texture.image, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                        texture.loaded = true;
                        if (me.mTextureCallbackFun !== null)
                            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, texture.image[0], true, 2, 1, -1.0, me.mID);
                    }
                }

                if( i === 0) 
                {
                    texture.image[i].src = url.mSrc;
                } 
                else 
                {
                    let n = url.mSrc.lastIndexOf(".");
                    texture.image[i].src = url.mSrc.substring(0, n) + "_" + i + url.mSrc.substring(n, url.mSrc.length);
                }
            }
        }

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]==null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="cubemap")) };

        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="webcam" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;

        texture.video = document.createElement('video');
    	texture.video.width = 320;
    	texture.video.height = 240;
    	texture.video.autoplay = true;
    	texture.video.loop = true;
        texture.mForceMuted = this.mForceMuted;
        texture.mImage = null;

        let rti = me.Sampler2Renderer(url.mSampler);

        var loadImageInsteadOfWebCam = function()
        {
            texture.mImage = new Image();
            texture.mImage.onload = function()
            {
                texture.loaded = true;
                texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.mImage, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mImage, true, 7, 1, -1.0, me.mID );
            }
            texture.mImage.src = "/media/previz/webcam.png";
        }
        
        loadImageInsteadOfWebCam();

        if( typeof navigator.getUserMedia !== "undefined"  && texture.mForceMuted===false )
        {
            texture.video.addEventListener("canplay", function (e)
            {
				try
				{
                    texture.mImage = null;
                    if( texture.globject != null )
                        renderer.DestroyTexture( texture.globject );
					texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.video, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
					texture.loaded = true;
                }
                catch(e)
                {
                    loadImageInsteadOfWebCam();
	                alert( 'Your browser can not transfer webcam data to the GPU.');
                }
            } );

            navigator.mediaDevices.getUserMedia( 
                                { "video": { width: 1280, height: 720 }, "audio": false } )
                                .then( function(stream)
                                       {
                                            texture.video.srcObject = stream;
    	                               } )
                                .catch( function(error)
                                        {
                                            loadImageInsteadOfWebCam();
    		                                alert( 'Unable to capture WebCam. Please reload the page.' );
    	                                } );
        }
        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]==null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!="music") && 
                                                                (this.mInputs[slot].mInfo.mType!="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="mic" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.mForceMuted = this.mForceMuted;
        texture.mAnalyser = null;
        let num = 512;
        texture.mFreqData = new Uint8Array( num );
        texture.mWaveData = new Uint8Array( num );

        if( wa === null || typeof navigator.getUserMedia === "undefined" )
        {
            if( !texture.mForceMuted ) alert( "Shadertoy: Web Audio not implement in this browser" );
            texture.mForceMuted = true; 
        }

        if( texture.mForceMuted )
        {
            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, num, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null)
            texture.loaded = true;
        }
        else
        {
        navigator.getUserMedia( { "audio": true },
                                function(stream)
                                {
                                  texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, null)
                                  texture.mic = wa.createMediaStreamSource(stream);
                                  texture.mAnalyser = wa.createAnalyser();
                                  texture.mic.connect( texture.mAnalyser );
                                  texture.loaded = true;
    	                        },
                                function(error)
                                {
    		                        alert( 'Unable open Mic. Please reload the page.' );
    	                        } );
        }
        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="video" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.video = document.createElement('video');
    	texture.video.loop = true;
        texture.video.preload = "auto";
        texture.video.mPaused = this.mForcePaused;
        texture.video.mMuted = true;//this.mForceMuted;
    	texture.video.muted  = true;//this.mForceMuted;
        if( this.mForceMuted===true )
            texture.video.volume = 0;
    	texture.video.autoplay = false;
        texture.video.hasFalled = false;
        
        let rti = me.Sampler2Renderer(url.mSampler);

        texture.video.addEventListener("canplay", function (e)
        {
            texture.video.play().then( function()
                                       {
                                           texture.video.mPaused = false;

                                           texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.video, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                                           texture.loaded = true;
            
                                           if( me.mTextureCallbackFun!=null )
                                               me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.video, true, 3, 1, -1.0, me.mID );
                                        } )
                               .catch( function(error)
                                       {
                                           console.log( error );
                                       }
                                );
        } );

        texture.video.addEventListener( "error", function(e)
        {
               if( texture.video.hasFalled===true ) { alert("Error: cannot load video" ); return; }
               let str = texture.video.src;
               str = str.substr(0,str.lastIndexOf('.') ) + ".mp4";
               texture.video.src = str;
               texture.video.hasFalled = true;
        } );

        texture.video.src = url.mSrc;

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]==null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!="music") && 
                                                                (this.mInputs[slot].mInfo.mType!="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="music" || url.mType==="musicstream" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.audio = document.createElement('audio');
    	texture.audio.loop = true;
        texture.audio.mMuted = this.mForceMuted;
        texture.audio.mForceMuted = this.mForceMuted;
        texture.audio.muted = this.mForceMuted;
        if( this.mForceMuted===true )
            texture.audio.volume = 0;
        texture.audio.autoplay = false;
        texture.audio.hasFalled = false;
        texture.audio.mPaused = false;
        texture.audio.mSound = {};

        if( this.mForceMuted===false )
        {
            if(url.mType==="musicstream" && SC === null)
            {
                alert( "Shadertoy: Soundcloud could not be reached" );
                texture.audio.mForceMuted = true;
            }
            }

        if( wa === null && this.mForceMuted===false )
        {
            alert( "Shadertoy: Web Audio not implement in this browser" );
            texture.audio.mForceMuted = true;
        }

        if( texture.audio.mForceMuted )
        {
            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null);
            let num = 512;
            texture.audio.mSound.mFreqData = new Uint8Array( num );
            texture.audio.mSound.mWaveData = new Uint8Array( num );
            texture.loaded = true;
        }

        texture.audio.addEventListener( "canplay", function()
        {
            if( texture===null || texture.audio===null ) return;
            if( this.mForceMuted  ) return;
            if( texture.loaded === true ) return;

            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null)

            texture.audio.mSound.mSource   = wa.createMediaElementSource( texture.audio );
            texture.audio.mSound.mAnalyser = wa.createAnalyser();
            texture.audio.mSound.mGain     = wa.createGain();

            texture.audio.mSound.mSource.connect(   texture.audio.mSound.mAnalyser );
            texture.audio.mSound.mAnalyser.connect( texture.audio.mSound.mGain );
            texture.audio.mSound.mGain.connect(me.mGainNode);

            texture.audio.mSound.mFreqData = new Uint8Array( texture.audio.mSound.mAnalyser.frequencyBinCount );
            texture.audio.mSound.mWaveData = new Uint8Array( texture.audio.mSound.mAnalyser.frequencyBinCount );

            if( texture.audio.mPaused )
            {
                texture.audio.pause();
            }
            else
            {
                texture.audio.play().then( function() {/*console.log("ok");*/} ).catch( function(e){console.log("error " + e);} );
            }
            texture.loaded = true;
        } );

        texture.audio.addEventListener( "error", function(e)
        {
               if( this.mForceMuted  ) return;

               if( texture.audio.hasFalled===true ) { return; }
               let str = texture.audio.src;
               str = str.substr(0,str.lastIndexOf('.') ) + ".ogg";
               texture.audio.src = str;
               texture.audio.hasFalled = true;
        } );

        if( !texture.audio.mForceMuted )
        {
            if(url.mType==="musicstream")
            {
                SC.resolve(url.mSrc, 
                    function(song) 
                    {
                        if( song.streamable===true )
                        {
                            texture.audio.crossOrigin = 'anonymous';
                            texture.audio.src = song.stream_url;
                            texture.audio.soundcloudInfo = song;
                        }
                        else
                        {
                            alert('Shadertoy: Soundcloud 3 - This track cannot be streamed' );
                        }
                    },
                    function(error)
                    {
                        if (me.mTextureCallbackFun!==null)
                        {
                            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null}, false, 4, 0, -1.0, me.mID);
                        }
                    } );
            } 
            else
            {
                texture.audio.src = url.mSrc;
            }
        }

        if (me.mTextureCallbackFun!==null)
        {
            if (url.mType === "music")            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null}, false, 4, 0, -1.0, me.mID);
            else if (url.mType === "musicstream") me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null, info: texture.audio.soundcloudInfo}, false, 8, 0, -1.0, me.mID);
        }

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="keyboard" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = true;

        texture.keyboard = {};

        if( me.mTextureCallbackFun!==null )
            me.mTextureCallbackFun( me.mTextureCallbackObj, slot, {mImage: keyboard.mIcon, mData: keyboard.mData}, false, 6, 1, -1.0, me.mID );

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!="music") && 
                                                                (this.mInputs[slot].mInfo.mType!="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="buffer" )
    {
        texture = {};
        texture.mInfo = url;

        texture.image = new Image();
        texture.image.onload = function()
        {
            if( me.mTextureCallbackFun!=null )
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, {texture: texture.image, data:null}, true, 9, 1, -1.0, me.mID );
        }
        texture.image.src = url.mSrc;
        texture.id = assetID_to_bufferID( url.mID );
        texture.loaded = true;

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!="music") && 
                                                                (this.mInputs[slot].mInfo.mType!="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!="video")) };

        this.DestroyInput( slot );
        this.mInputs[slot] = texture;

        this.mEffect.ResizeBuffer(texture.id, this.mEffect.mXres, this.mEffect.mYres, false );

        this.SetSamplerFilter(slot, url.mSampler.filter, buffers, cubeBuffers, true);
        this.SetSamplerVFlip(slot, url.mSampler.vflip);
        this.SetSamplerWrap(slot, url.mSampler.wrap, buffers);

        this.MakeHeader();
        return returnValue;
    }
    else
    {
        alert( "input type error" );
        return { mFailed: true };
    }

    return { mFailed: true };
}

EffectPass.prototype.Paint_Image = function( vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    let times = [ 0.0, 0.0, 0.0, 0.0 ];

    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds()  + d.getMilliseconds()/1000.0 ];

    let mouse = [  mousePosX, mousePosY, mouseOriX, mouseOriY ];


    //------------------------
    
    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];
    let texIsLoaded = [0, 0, 0, 0 ];
    let texID = [ null, null, null, null];

    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            texID[i] = keyboard.mTexture;
            texIsLoaded[i] = 1;
            resos[3*i+0] = 256;
            resos[3*i+1] = 3;
            resos[3*i+2] = 1;
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
            if (inp.loaded === true)
            {
                let id = assetID_to_cubemapBuferID(inp.mInfo.mID);
                if( id!==-1 )
                {
                    texID[i] = cubeBuffers[id].mTexture[ cubeBuffers[id].mLastRenderDone ];
                    resos[3*i+0] = cubeBuffers[id].mResolution[0];
                    resos[3*i+1] = cubeBuffers[id].mResolution[1];
                    resos[3*i+2] = 1;
                    texIsLoaded[i] = 1;

                    // hack. in webgl2.0 we have samplers, so we don't need this crap here
                    let filter = this.mRenderer.FILTER.NONE;
                         if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                    else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                    this.mRenderer.SetSamplerFilter( texID[i], filter, false);
                }
                else
                {
                    texID[i] = inp.globject;
                    texIsLoaded[i] = 1;
                }
            }
        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mImage, false, 7, 1, -1, this.mID );

                    texID[i] = inp.globject;
                    texIsLoaded[i] = 1;
                    resos[3*i+0] = inp.mImage.width;
                    resos[3*i+1] = inp.mImage.height;
                    resos[3*i+2] = 1;
                }
                else  if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {

                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 7, 1, -1, this.mID );

                    texID[i] = inp.globject;
                    this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                    resos[3*i+0] = inp.video.videoWidth;
                    resos[3*i+1] = inp.video.videoHeight;
                    resos[3*i+2] = 1;
                    texIsLoaded[i] = 1;
                }
            }
            else 
            {
                texID[i] = null;
                texIsLoaded[i] = 0;
                resos[3*i+0] = inp.video.width;
                resos[3*i+1] = inp.video.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.mPaused === false )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, inp.video.currentTime, this.mID );
            }

            if( inp.loaded===true )
            { 
                times[i] = inp.video.currentTime;
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;

      	        if( inp.video.mPaused === false )
      	        {
      	            this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
                resos[3*i+0] = inp.video.videoWidth;
                resos[3*i+1] = inp.video.videoHeight;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.audio.mPaused === false && inp.audio.mForceMuted === false && inp.loaded===true )
            {
                if( wa !== null )
                {
                    inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                    inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                }

                if( this.mTextureCallbackFun!==null )
                {
                         if( inp.mInfo.mType==="music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa === null) ? null : { wave : inp.audio.mSound.mFreqData }, false, 4, 1, inp.audio.currentTime, this.mID);
                    else if( inp.mInfo.mType==="musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa === null) ? null : { wave : inp.audio.mSound.mFreqData, info : inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                }
            }

            if( inp.loaded===true )
            {
                times[i] = inp.audio.currentTime;
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;

                if( inp.audio.mForceMuted === true )
                {
                    times[i] = 10.0 + time;
                    let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.audio.mSound.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                  //let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.audio.mSound.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }

                }

      	        if( inp.audio.mPaused === false )
                {
      	            let waveLen = Math.min(inp.audio.mSound.mWaveData.length, 512);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512, 1, inp.audio.mSound.mFreqData);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 1, 512, 1, inp.audio.mSound.mWaveData);
                }

                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                    times[i] = 10.0 + time;
                    let num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                    //var num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }
            }
            else
            {
                inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
            }

            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave:inp.mFreqData}, false, 5, 1, -1, this.mID );

            if( inp.loaded===true )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                let waveLen = Math.min( inp.mWaveData.length, 512 );
                this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512,     1, inp.mFreqData);
                this.mRenderer.UpdateTexture(inp.globject, 0, 1, waveLen, 1, inp.mWaveData);
                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            let id = inp.id;
            if( inp.loaded===true  )
            {
                texID[i] = buffers[id].mTexture[ buffers[id].mLastRenderDone ];
                texIsLoaded[i] = 1;
                resos[3*i+0] = xres;
                resos[3*i+1] = yres;
                resos[3*i+2] = 1;
                // hack. in webgl2.0 we have samplers, so we don't need this crap here
                let filter = this.mRenderer.FILTER.NONE;
                     if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                this.mRenderer.SetSamplerFilter( texID[i], filter, false);
            }

            if( this.mTextureCallbackFun!==null )
            {
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:buffers[id].mThumbnailBuffer}, false, 9, 1, -1, this.mID );
            }
        }
    }

    this.mRenderer.AttachTextures( 4, texID[0], texID[1], texID[2], texID[3] );

    //-----------------------------------

    let prog = this.mProgram;

    //if( vrData!=null && this.mSupportsVR ) prog = this.mProgramVR;



    this.mRenderer.AttachShader(prog);

    this.mRenderer.SetShaderConstant1F(  "iTime", time);
    this.mRenderer.SetShaderConstant3F(  "iResolution", xres, yres, 1.0);
    this.mRenderer.SetShaderConstant4FV( "iMouse", mouse);
    this.mRenderer.SetShaderConstant1FV( "iChannelTime", times );              // OBSOLETE
    this.mRenderer.SetShaderConstant4FV( "iDate", dates );
    this.mRenderer.SetShaderConstant3FV( "iChannelResolution", resos );        // OBSOLETE
    this.mRenderer.SetShaderConstant1F(  "iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit( "iChannel0", 0 );
    this.mRenderer.SetShaderTextureUnit( "iChannel1", 1 );
    this.mRenderer.SetShaderTextureUnit( "iChannel2", 2 );
    this.mRenderer.SetShaderTextureUnit( "iChannel3", 3 );
    this.mRenderer.SetShaderConstant1I(  "iFrame", this.mFrame );
    this.mRenderer.SetShaderConstant1F(  "iTimeDelta", dtime);
    this.mRenderer.SetShaderConstant1F(  "iFrameRate", fps );

    this.mRenderer.SetShaderConstant1F(  "iCh0.time", times[0] );
    this.mRenderer.SetShaderConstant1F(  "iCh1.time", times[1] );
    this.mRenderer.SetShaderConstant1F(  "iCh2.time", times[2] );
    this.mRenderer.SetShaderConstant1F(  "iCh3.time", times[3] );
    this.mRenderer.SetShaderConstant3F(  "iCh0.size", resos[0], resos[ 1], resos[ 2] );
    this.mRenderer.SetShaderConstant3F(  "iCh1.size", resos[3], resos[ 4], resos[ 5] );
    this.mRenderer.SetShaderConstant3F(  "iCh2.size", resos[6], resos[ 7], resos[ 8] );
    this.mRenderer.SetShaderConstant3F(  "iCh3.size", resos[9], resos[10], resos[11] );
    this.mRenderer.SetShaderConstant1I(  "iCh0.loaded",       texIsLoaded[0] );
    this.mRenderer.SetShaderConstant1I(  "iCh1.loaded",       texIsLoaded[1] );
    this.mRenderer.SetShaderConstant1I(  "iCh2.loaded",       texIsLoaded[2] );
    this.mRenderer.SetShaderConstant1I(  "iCh3.loaded",       texIsLoaded[3] );

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");


    if( (vrData !== null) && this.mSupportsVR )
    {
        for (let i=0; i<2; i++ )
        {
            let ei = (i===0) ? vrData.mLeftEye : vrData.mRightEye;

            let vp = [i * xres / 2, 0, xres / 2, yres];

            this.mRenderer.SetViewport(vp);

            let fov = ei.mProjection;
            let corA = [ -fov[2], -fov[1], -1.0 ];
            let corB = [  fov[3], -fov[1], -1.0 ];
            let corC = [  fov[3],  fov[0], -1.0 ];
            let corD = [ -fov[2],  fov[0], -1.0 ];
            let apex = [ 0.0, 0.0, 0.0 ];

            let ma = invertFast( ei.mCamera );
            corA = matMulpoint( ma, corA ); 
            corB = matMulpoint( ma, corB ); 
            corC = matMulpoint( ma, corC ); 
            corD = matMulpoint( ma, corD ); 
            apex = matMulpoint( ma, apex ); 

            let corners = [ corA[0], corA[1], corA[2], 
                            corB[0], corB[1], corB[2], 
                            corC[0], corC[1], corC[2], 
                            corD[0], corD[1], corD[2],
                            apex[0], apex[1], apex[2]];

            this.mRenderer.SetShaderConstant3FV("unCorners", corners);
            this.mRenderer.SetShaderConstant4FV("unViewport", vp);

            this.mRenderer.DrawUnitQuad_XY(l1);
        }
    }
    else 
    {
        this.mRenderer.SetViewport([0, 0, xres, yres]);
        this.mRenderer.DrawFullScreenTriangle_XY( l1 );
    }

    this.mRenderer.DettachTextures();
}

EffectPass.prototype.iRenderSound = function(d, callback )
{
    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds() ];

    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];

    this.mRenderer.SetRenderTarget(this.mRenderFBO);

    this.mRenderer.SetViewport([0, 0, this.mTextureDimensions, this.mTextureDimensions]);
    this.mRenderer.AttachShader(this.mProgram);
    this.mRenderer.SetBlend( false );

    let texID = [null, null, null, null];
    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
    }

    this.mRenderer.AttachTextures(4, texID[0], texID[1], texID[2], texID[3]);

    let l2 = this.mRenderer.SetShaderConstantLocation(this.mProgram, "iTimeOffset");
    let l3 = this.mRenderer.SetShaderConstantLocation(this.mProgram, "iSampleOffset");
    this.mRenderer.SetShaderConstant4FV("iDate", dates);
    this.mRenderer.SetShaderConstant3FV("iChannelResolution", resos);
    this.mRenderer.SetShaderConstant1F("iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit("iChannel0", 0);
    this.mRenderer.SetShaderTextureUnit("iChannel1", 1);
    this.mRenderer.SetShaderTextureUnit("iChannel2", 2);
    this.mRenderer.SetShaderTextureUnit("iChannel3", 3);

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    //--------------------------------
    let numSamples = this.mTmpBufferSamples;
    let numBlocks = this.mPlaySamples / numSamples;
    for (let j=0; j<numBlocks; j++ )
    {
        let off = j*numSamples;
        
        this.mRenderer.SetShaderConstant1F_Pos(l2, off / this.mSampleRate);
        this.mRenderer.SetShaderConstant1I_Pos(l3, off );
        this.mRenderer.DrawUnitQuad_XY(l1);

        this.mRenderer.GetPixelData(this.mData, 0, this.mTextureDimensions, this.mTextureDimensions);

        callback( off, this.mData, numSamples );
    }

    this.mRenderer.DetachShader();
    this.mRenderer.DettachTextures();
    this.mRenderer.SetRenderTarget(null);
}

EffectPass.prototype.Paint_Sound = function( wa, d )
{
    let bufL = this.mBuffer.getChannelData(0); // Float32Array
    let bufR = this.mBuffer.getChannelData(1); // Float32Array

    this.iRenderSound( d, function(off, data, numSamples)
                         {
                            for( let i=0; i<numSamples; i++ )
                            {
                                bufL[off+i] = -1.0 + 2.0*(data[4*i+0]+256.0*data[4*i+1])/65535.0;
                                bufR[off+i] = -1.0 + 2.0*(data[4*i+2]+256.0*data[4*i+3])/65535.0;
                            }
                         }
                     );
}

EffectPass.prototype.SetUniforms = function(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    let times = [ 0.0, 0.0, 0.0, 0.0 ];

    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds()  + d.getMilliseconds()/1000.0 ];

    let mouse = [  mousePosX, mousePosY, mouseOriX, mouseOriY ];

    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];

    //------------------------
    
    let texID = [ null, null, null, null];

    for( let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            texID[i] = keyboard.mTexture;
        }
        else if( inp.mInfo.mType=="cubemap" )
        {
            if (inp.loaded === true)
            {
                let id = assetID_to_cubemapBuferID(inp.mInfo.mID);
                if( id!==-1 )
                {
                    texID[i] = cubeBuffers[id].mTexture[ cubeBuffers[id].mLastRenderDone ];
                    resos[3*i+0] = cubeBuffers[id].mResolution[0];
                    resos[3*i+1] = cubeBuffers[id].mResolution[1];
                    resos[3*i+2] = 1;
    
                    // hack. in webgl2.0 we have samplers, so we don't need this crap here
                    let filter = this.mRenderer.FILTER.NONE;
                         if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                    else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                    this.mRenderer.SetSamplerFilter( texID[i], filter, false);
                }
                else
                {
                    texID[i] = inp.globject;
                }
            }

        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    texID[i] = inp.globject;
                    resos[3*i+0] = inp.mImage.width;
                    resos[3*i+1] = inp.mImage.height;
                    resos[3*i+2] = 1;
                }
                else  if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {
                    texID[i] = inp.globject;
                    resos[3*i+0] = inp.video.videoWidth;
                    resos[3*i+1] = inp.video.videoHeight;
                    resos[3*i+2] = 1;
                }
            }
            else 
            {
                texID[i] = null;
                resos[3*i+0] = inp.video.width;
                resos[3*i+1] = inp.video.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
           if( inp.loaded===true )
           { 
                times[i] = inp.video.currentTime;
                texID[i] = inp.globject;
                resos[3*i+0] = inp.video.videoWidth;
                resos[3*i+1] = inp.video.videoHeight;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.loaded===true )
            {
                times[i] = inp.audio.currentTime;
                texID[i] = inp.globject;

                if( inp.audio.mForceMuted === true )
                {
                    times[i] = 10.0 + time;
                }

                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                times[i] = 10.0 + time;
            }

            if( inp.loaded===true )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = buffers[inp.id].mTexture[ buffers[inp.id].mLastRenderDone ];
                resos[3*i+0] = buffers[inp.id].mResolution[0];
                resos[3*i+1] = buffers[inp.id].mResolution[1];
                resos[3*i+2] = 1;
            }
        }
    }

    this.mRenderer.AttachTextures( 4, texID[0], texID[1], texID[2], texID[3] );

    //-----------------------------------

    this.mRenderer.AttachShader(this.mProgram);

    this.mRenderer.SetShaderConstant1F(  "iTime", time);
    this.mRenderer.SetShaderConstant3F(  "iResolution", xres, yres, 1.0);
    this.mRenderer.SetShaderConstant4FV( "iMouse", mouse);
    this.mRenderer.SetShaderConstant1FV( "iChannelTime", times );              // OBSOLETE
    this.mRenderer.SetShaderConstant4FV( "iDate", dates );
    this.mRenderer.SetShaderConstant3FV( "iChannelResolution", resos );        // OBSOLETE
    this.mRenderer.SetShaderConstant1F(  "iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit( "iChannel0", 0 );
    this.mRenderer.SetShaderTextureUnit( "iChannel1", 1 );
    this.mRenderer.SetShaderTextureUnit( "iChannel2", 2 );
    this.mRenderer.SetShaderTextureUnit( "iChannel3", 3 );
    this.mRenderer.SetShaderConstant1I(  "iFrame", this.mFrame );
    this.mRenderer.SetShaderConstant1F(  "iTimeDelta", dtime);
    this.mRenderer.SetShaderConstant1F(  "iFrameRate", fps );

    this.mRenderer.SetShaderConstant1F(  "iChannel[0].time",       times[0] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[1].time",       times[1] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[2].time",       times[2] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[3].time",       times[3] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[0].resolution", resos[0], resos[ 1], resos[ 2] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[1].resolution", resos[3], resos[ 4], resos[ 5] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[2].resolution", resos[6], resos[ 7], resos[ 8] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[3].resolution", resos[9], resos[10], resos[11] );
}

EffectPass.prototype.ProcessInputs = function(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
        }
        else if( inp.mInfo.mType==="volume" )
        {
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mImage, false, 7, 1, -1, this.mID );
                }
                else if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 7, 1, -1, this.mID );

                    this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.mPaused === false )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, inp.video.currentTime, this.mID );
            }

            if( inp.loaded===true )
            { 
      	        if( inp.video.mPaused === false )
      	        {
      	            this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.audio.mPaused === false && inp.audio.mForceMuted === false && inp.loaded===true )
            {
                if( wa !== null )
                {
                    inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                    inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                }

                if( this.mTextureCallbackFun!==null )
                {
                         if( inp.mInfo.mType==="music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa == null) ? null : { wave : inp.audio.mSound.mFreqData }, false, 4, 1, inp.audio.currentTime, this.mID);
                    else if( inp.mInfo.mType==="musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa == null) ? null : { wave : inp.audio.mSound.mFreqData, info : inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                }
            }

            if( inp.loaded===true )
            {
                if( inp.audio.mForceMuted === true )
                {
                    let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.audio.mSound.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                  //let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.audio.mSound.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }

                }

      	        if( inp.audio.mPaused === false )
                {
      	            let waveLen = Math.min(inp.audio.mSound.mWaveData.length, 512);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512, 1, inp.audio.mSound.mFreqData);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 1, 512, 1, inp.audio.mSound.mWaveData);
                }
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                    let num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                    for( let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }
            }
            else
            {
                inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
            }

            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave:inp.mFreqData}, false, 5, 1, -1, this.mID );

            if( inp.loaded===true )
            {
                let waveLen = Math.min( inp.mWaveData.length, 512 );
                this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512,     1, inp.mFreqData);
                this.mRenderer.UpdateTexture(inp.globject, 0, 1, waveLen, 1, inp.mWaveData);
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded===true  )
            {
                let id = inp.id;
                let texID = buffers[id].mTexture[ buffers[id].mLastRenderDone ];

                // hack. in webgl2.0 we have samplers, so we don't need this crap here
                let filter = this.mRenderer.FILTER.NONE;
                     if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                this.mRenderer.SetSamplerFilter( texID, filter, false);
            }

            if( this.mTextureCallbackFun!==null )
            {
				let id = inp.id;
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:buffers[id].mThumbnailBuffer}, false, 9, 1, -1, this.mID );
            }
        }
    }
}

EffectPass.prototype.Paint_Cubemap = function( vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face )
{
    this.ProcessInputs(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face );
    this.SetUniforms(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    let vp = [0, 0, xres, yres];

    this.mRenderer.SetViewport(vp);

    let corA = [ -1.0, -1.0, -1.0 ];
    let corB = [  1.0, -1.0, -1.0 ];
    let corC = [  1.0,  1.0, -1.0 ];
    let corD = [ -1.0,  1.0, -1.0 ];
    let apex = [  0.0,  0.0,  0.0 ];

    if( face===0 )
    {
        corA = [  1.0,  1.0,  1.0 ];
        corB = [  1.0,  1.0, -1.0 ];
        corC = [  1.0, -1.0, -1.0 ];
        corD = [  1.0, -1.0,  1.0 ];
    }
    else if( face===1 ) // -X
    {
        corA = [ -1.0,  1.0, -1.0 ];
        corB = [ -1.0,  1.0,  1.0 ];
        corC = [ -1.0, -1.0,  1.0 ];
        corD = [ -1.0, -1.0, -1.0 ];
    }
    else if( face===2 ) // +Y
    {
        corA = [ -1.0,  1.0, -1.0 ];
        corB = [  1.0,  1.0, -1.0 ];
        corC = [  1.0,  1.0,  1.0 ];
        corD = [ -1.0,  1.0,  1.0 ];
    }
    else if( face===3 ) // -Y
    {
        corA = [ -1.0, -1.0,  1.0 ];
        corB = [  1.0, -1.0,  1.0 ];
        corC = [  1.0, -1.0, -1.0 ];
        corD = [ -1.0, -1.0, -1.0 ];
    }
    else if( face===4 ) // +Z
    {
        corA = [ -1.0,  1.0,  1.0 ];
        corB = [  1.0,  1.0,  1.0 ];
        corC = [  1.0, -1.0,  1.0 ];
        corD = [ -1.0, -1.0,  1.0 ];
    }
    else //if( face===5 ) // -Z
    {
        corA = [  1.0,  1.0, -1.0 ];
        corB = [ -1.0,  1.0, -1.0 ];
        corC = [ -1.0, -1.0, -1.0 ];
        corD = [  1.0, -1.0, -1.0 ];
    }

    let corners = [ corA[0], corA[1], corA[2], 
                    corB[0], corB[1], corB[2], 
                    corC[0], corC[1], corC[2], 
                    corD[0], corD[1], corD[2],
                    apex[0], apex[1], apex[2]];

    this.mRenderer.SetShaderConstant3FV("unCorners", corners);
    this.mRenderer.SetShaderConstant4FV("unViewport", vp);

    this.mRenderer.DrawUnitQuad_XY(l1);

    this.mRenderer.DettachTextures();
}


EffectPass.prototype.Paint = function( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, bufferNeedsMimaps, buffers, cubeBuffers, keyboard, effect )
{
    if( this.mType==="sound" )
    {
        if (this.mSoundShaderCompiled === true)
        {
            // make sure all textures are loaded
            for (let i=0; i<this.mInputs.length; i++ )
            {
                let inp = this.mInputs[i];
                if (inp === null) continue;

                if (inp.mInfo.mType === "texture" && !inp.loaded) return;
                if (inp.mInfo.mType === "cubemap" && !inp.loaded) return;
            }

            this.Paint_Sound(wa, da);
            this.mSoundShaderCompiled = false;
        }
        if (this.mFrame === 0)
        {
            if (this.mPlaying===true)
            {
                this.mPlayNode.disconnect();
                this.mPlayNode.stop();
                this.mPlayNode = null;
            }
            this.mPlaying = true;

            this.mPlayNode = wa.createBufferSource();
            this.mPlayNode.buffer = this.mBuffer;
            this.mPlayNode.connect(this.mGainNode);
            this.mPlayNode.start(0);
        }
        this.mFrame++;
    }
    else if( this.mType==="image" )
    {
        this.mRenderer.SetRenderTarget( null );
        this.Paint_Image( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );
        this.mFrame++;
    }
    else if( this.mType==="common" )
    {
        //console.log("rendering common");
    }
    else if( this.mType==="buffer" )
    {
        this.mEffect.ResizeBuffer(bufferID, this.mEffect.mXres, this.mEffect.mYres, false );

        let buffer = buffers[bufferID];

        let dstID = 1 - buffer.mLastRenderDone;

        this.mRenderer.SetRenderTarget( buffer.mTarget[dstID] );
        this.Paint_Image( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );

        // compute mipmaps if needd
        if( bufferNeedsMimaps )
        {
            this.mRenderer.CreateMipmaps( buffer.mTexture[dstID]);
        }

        // make thumbnail
        //if( this.mTextureCallbackFun != null )
        /*
        {
            this.mRenderer.SetRenderTarget( buffer.mThumbnailRenderTarget );
            let v = [0, 0, buffer.mThumbnailRes[0], buffer.mThumbnailRes[1]];
            this.mRenderer.SetBlend(false);
            this.mRenderer.SetViewport(v);
            this.mRenderer.AttachShader(this.mProgramCopy);
            let l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, "pos");
            this.mRenderer.SetShaderConstant4FV("v", v);
            this.mRenderer.AttachTextures(1, buffer.mTexture[dstID], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);
            this.mRenderer.DettachTextures();
            this.mRenderer.DetachShader();
            this.mRenderer.GetPixelData( new Uint8Array(buffer.mThumbnailBuffer.data.buffer), buffer.mThumbnailRes[0], buffer.mThumbnailRes[1] );
            this.mRenderer.SetRenderTarget(null);
        }
        */
        buffers[bufferID].mLastRenderDone = 1 - buffers[bufferID].mLastRenderDone;
        this.mFrame++;
    }
    else if( this.mType==="cubemap" )
    {
        this.mEffect.ResizeCubemapBuffer(bufferID, 1024, 1024, false );

        let buffer = cubeBuffers[bufferID];

        xres = buffer.mResolution[0];
        yres = buffer.mResolution[1];
        let dstID = 1 - buffer.mLastRenderDone;
        for( let face=0; face<6; face++ )
        {
            this.mRenderer.SetRenderTargetCubeMap( buffer.mTarget[dstID], face );
            this.Paint_Cubemap( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face );
        }
        this.mRenderer.SetRenderTargetCubeMap( null, 0 );

        // compute mipmaps if needd
        if( bufferNeedsMimaps )
        {
            this.mRenderer.CreateMipmaps( buffer.mTexture[dstID]);
        }
        cubeBuffers[bufferID].mLastRenderDone = 1 - cubeBuffers[bufferID].mLastRenderDone;

        this.mFrame++;
    }

}

EffectPass.prototype.StopOutput_Sound = function( wa )
{
    if( this.mPlayNode===null ) return;
    this.mPlayNode.disconnect();

};

EffectPass.prototype.ResumeOutput_Sound = function( wa )
{
    if( this.mPlayNode===null ) return;

    wa.resume()
    this.mPlayNode.connect( this.mGainNode );
};

EffectPass.prototype.StopOutput_Image = function( wa )
{
};

EffectPass.prototype.ResumeOutput_Image = function( wa )
{
};

EffectPass.prototype.StopOutput = function( wa )
{
    for (let j=0; j<this.mInputs.length; j++ )
        this.StopInput(j);

    if( this.mType==="sound" )
         this.StopOutput_Sound( wa );
    else
         this.StopOutput_Image( wa );
}

EffectPass.prototype.ResumeOutput = function( wa )
{
    for (let j=0; j<this.mInputs.length; j++ )
        this.ResumeInput(j);

    if( this.mType==="sound" )
         this.ResumeOutput_Sound( wa );
    else
         this.ResumeOutput_Image( wa );
}

EffectPass.prototype.GetCompilationTime = function()
{
    return this.mCompilationTime;
}

//============================================================================================================
function Screenshots()
{
    // private
    let mTexture = null;
    let mTarget = null;
    let mXres = 0;
    let mYres = 0;
    let mCubemapToEquirectProgram;
    let mRenderer = null;

    // public
    var me = {};

    me.Initialize = function(renderer)
    {
        mRenderer = renderer;
        let caps = mRenderer.GetCaps();
        let is20 = caps.mIsGL20;


        let vsSourceC, fsSourceC;
        if( is20 )
        {
            vsSourceC = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
            fsSourceC = "uniform samplerCube t; out vec4 outColor; void main() { vec2 px = gl_FragCoord.xy/vec2(4096.0,2048.0); vec2 an = 3.1415926535898 * (px*vec2(2.0, 1.0) - vec2(0.0,0.5)); vec3 rd = vec3(-cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x)); outColor = texture(t, rd); }";
        }
        else
        {
            vsSourceC = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
            fsSourceC = "uniform samplerCube t; void main() { vec2 px = gl_FragCoord.xy/vec2(4096.0,2048.0); vec2 an = 3.1415926535898 * (px*vec2(2.0, 1.0) - vec2(0.0,0.5)); vec3 rd = vec3(-cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x)); gl_FragColor = texture(t, rd); }";
        }

        let compileShader = function (worked, info)
        {
            if (worked === false)
            {
                console.log("Failed to compile cubemap resample shader (" + errorType + "): " + log);
            }
            else
            {
                mCubemapToEquirectProgram = info;
            }
        }
        mRenderer.CreateShader(vsSourceC, fsSourceC, false, true, compileShader);

        return true;
    };

    me.Allocate = function( xres, yres )
    {
        if( xres>mXres || yres>mYres )
        {
            let texture = mRenderer.CreateTexture(mRenderer.TEXTYPE.T2D, xres, yres, mRenderer.TEXFMT.C4F32, mRenderer.FILTER.NONE, mRenderer.TEXWRP.CLAMP, null);
            let target = mRenderer.CreateRenderTarget( texture, null, null, null, null, false);

            if( mXres!==0 )
            {
                mRenderer.DestroyTexture(mTexture);
                mRenderer.DestroyRenderTarget(mTarget);
            }

            mTexture = texture;
            mTarget = target;
            mXres = xres;
            mYres = yres;
        }
    };

    me.GetProgram = function()
    {
        return mCubemapToEquirectProgram;
    };
    me.GetTarget = function()
    {
        return mTarget;
    };

    return me;
};

//============================================================================================================

function Effect(vr, ac, canvas, callback, obj, forceMuted, forcePaused, resizeCallback, crashCallback )
{
    let xres = canvas.width;
    let yres = canvas.height;

    let me = this;
    this.mCanvas = canvas;
    this.mCreated = false;
    this.mRenderer = null;
    this.mAudioContext = ac;
    this.mGLContext = null;
    this.mWebVR = vr;
    this.mRenderingStereo = false;
    this.mXres = xres;
    this.mYres = yres;
    this.mForceMuted = forceMuted;
    if( ac===null ) this.mForceMuted = true;
    this.mForcePaused = forcePaused;
    this.mGainNode = null;
    this.mPasses = [];
    this.mFrame = 0;
    this.mTextureCallbackFun = callback;
    this.mTextureCallbackObj = obj;
    this.mMaxBuffers = 4;
    this.mMaxCubeBuffers = 1;
    this.mMaxPasses = this.mMaxBuffers + 1 + 1 + 1 + 1; // some day decouple passes from buffers (4 buffers + common + Imagen + sound + cubemap)
    this.mBuffers = [];
    this.mCubeBuffers = [];
    this.mScreenshotSytem = null;
    this.mCompilationTime = 0;
    this.mIsLowEnd = piIsMobile();

    this.mGLContext = piCreateGlContext(canvas, false, false, true, false); // need preserve-buffe to true in order to capture screenshots
    if (this.mGLContext === null)
    {
        return;
    }

    canvas.addEventListener("webglcontextlost", function (event)
        {
            event.preventDefault();
            crashCallback();
        }, false);

    this.mRenderer = piRenderer();
    if (!this.mRenderer.Initialize(this.mGLContext))
        return;

    this.mScreenshotSytem = Screenshots();
    if (!this.mScreenshotSytem.Initialize(this.mRenderer))
        return;

    var caps = this.mRenderer.GetCaps();
    this.mIs20 = caps.mIsGL20;
    this.mShaderTextureLOD = caps.mShaderTextureLOD;
    //-------------
    if( ac!==null )
    {   
        this.mGainNode = ac.createGain();
        if( !forceMuted )
        {
            this.mGainNode.connect( ac.destination);
        }
        if (this.mForceMuted )
            this.mGainNode.gain.value = 0.0;
        else
            this.mGainNode.gain.value = 1.0;
    }

    //-------------
    let vsSourceC, fsSourceC;
    if( this.mIs20 )
    {
        vsSourceC = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceC = "uniform vec4 v; uniform sampler2D t; out vec4 outColor; void main() { outColor = textureLod(t, gl_FragCoord.xy / v.zw, 0.0); }";
    }
    else
    {
        vsSourceC = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceC = "uniform vec4 v; uniform sampler2D t; void main() { gl_FragColor = texture2D(t, gl_FragCoord.xy / v.zw, -100.0); }";
    }

    this.mRenderer.CreateShader(vsSourceC, fsSourceC, false, true, function(worked, info)
        {
            if (worked === false) console.log("Failed to compile shader to copy buffers : " + info.mErrorStr);
            else me.mProgramCopy = info;
        });

    let vsSourceD, fsSourceD;
    if( this.mIs20 )
    {
        vsSourceD = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceD = "uniform vec4 v; uniform sampler2D t; out vec4 outColor; void main() { vec2 uv = gl_FragCoord.xy / v.zw; outColor = texture(t, vec2(uv.x,1.0-uv.y)); }";
    }
    else
    {
        vsSourceD = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceD = "uniform vec4 v; uniform sampler2D t; void main() { vec2 uv = gl_FragCoord.xy / v.zw; gl_FragColor = texture2D(t, vec2(uv.x,1.0-uv.y)); }";
    }

    this.mRenderer.CreateShader(vsSourceD, fsSourceD, false, true, function (worked, info)
        {
            if (worked === false) console.log("Failed to compile shader to downscale buffers : " + info.mErrorStr);
            else me.mProgramDownscale = info;
        });


    // set all buffers and cubemaps to null
    for( let i=0; i<this.mMaxBuffers; i++ )
    {
        this.mBuffers[i] = { mTexture: [null, null], 
                             mTarget:  [null, null], 
                             mResolution: [0, 0],
                             mLastRenderDone: 0,
                             mThumbnailRenderTarget: null,
                             mThumbnailTexture: null,
                             mThumbnailBuffer:  null,
                             mThumbnailRes: [0, 0] };
    }

    for( let i=0; i<this.mMaxCubeBuffers; i++ )
    {
        this.mCubeBuffers[i] = { mTexture: [null, null], 
                                mTarget:  [null, null], 
                                mResolution: [0, 0],
                                mLastRenderDone: 0,
                                mThumbnailRenderTarget: null,
                                mThumbnailTexture: null,
                                mThumbnailBuffer:  null,
                                mThumbnailRes: [0, 0] };
    }

    //-------

    let keyboardData = new Uint8Array( 256*3 );
    for (let j=0; j<(256*3); j++ ) { keyboardData[j] = 0; }
    let kayboardTexture = this.mRenderer.CreateTexture( this.mRenderer.TEXTYPE.T2D, 256, 3, this.mRenderer.TEXFMT.C1I8, this.mRenderer.FILTER.NONE, this.mRenderer.TEXWRP.CLAMP, null);
    let keyboardImage = new Image();
    if( callback!==null )
        keyboardImage.src = "/img/keyboard.png"; // don't load PNG if no UI 
    this.mKeyboard = { mData: keyboardData, mTexture: kayboardTexture, mIcon: keyboardImage };

    let iResize = function( xres, yres )
    {
        me.mCanvas.width = xres;
        me.mCanvas.height = yres;
        me.mXres = xres;
        me.mYres = yres;
        me.ResizeBuffers(xres, yres);
        resizeCallback(xres, yres);
    };

    let bestAttemptFallback = function()
    {
        let devicePixelRatio = window.devicePixelRatio || 1;
        let xres = Math.round(me.mCanvas.offsetWidth  * devicePixelRatio) | 0;
        let yres = Math.round(me.mCanvas.offsetHeight * devicePixelRatio) | 0;
        iResize(xres, yres);
    };

    if(!window.ResizeObserver)
    {
        console.log("WARNING: This browser doesn't support ResizeObserver.");
        bestAttemptFallback();
        window.addEventListener("resize", bestAttemptFallback);
    }
    else
    {
        this.mRO = new ResizeObserver( function(entries, observer)
        {
            var entry = entries[0];
            if (!entry['devicePixelContentBoxSize'])
            {
                observer.unobserve(me.mCanvas);
                console.log("WARNING: This browser doesn't support ResizeObserver + device-pixel-content-box (2)");
                bestAttemptFallback();
                window.addEventListener("resize", bestAttemptFallback);
            }
            else
            {
                let box = entry.devicePixelContentBoxSize[0];
                let xres = box.inlineSize;
                let yres = box.blockSize;
                iResize(xres, yres);
            }
        });
        try
        {
            this.mRO.observe(this.mCanvas, { box: ["device-pixel-content-box"] });
            //this.mRO.observe(this.mCanvas);
        }
        catch (e)
        {
            console.log("WARNING: This browser doesn't support ResizeObserver + device-pixel-content-box (1)");
            bestAttemptFallback();
            window.addEventListener("resize", bestAttemptFallback);
        }
    }

    this.mCreated = true;
}


Effect.prototype.ResizeCubemapBuffer = function(i, xres, yres )
{
    let oldXres = this.mCubeBuffers[i].mResolution[0];
    let oldYres = this.mCubeBuffers[i].mResolution[1];

    if( this.mCubeBuffers[i].mTexture[0]===null || oldXres !== xres || oldYres !== yres )
    {
        let texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.CUBEMAP,
            xres, yres,
            this.mRenderer.TEXFMT.C4F16,
            this.mRenderer.FILTER.LINEAR,
            this.mRenderer.TEXWRP.CLAMP, 
            null);
        let target1 = this.mRenderer.CreateRenderTargetCubeMap( texture1, null, false);

        let texture2 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.CUBEMAP,
            xres, yres,
            this.mRenderer.TEXFMT.C4F16,
            this.mRenderer.FILTER.LINEAR,
            this.mRenderer.TEXWRP.CLAMP, 
            null);

        let target2 = this.mRenderer.CreateRenderTargetCubeMap( texture2, null, false);

        // Store new buffers
        this.mCubeBuffers[i].mTexture = [texture1,texture2], 
        this.mCubeBuffers[i].mTarget =  [target1, target2 ], 
        this.mCubeBuffers[i].mLastRenderDone = 0;
        this.mCubeBuffers[i].mResolution[0] = xres;
        this.mCubeBuffers[i].mResolution[1] = yres;
    }
}


Effect.prototype.ResizeBuffer = function( i, xres, yres, skipIfNotExists )
{
    if( skipIfNotExists && this.mBuffers[i].mTexture[0]===null ) return;

    let oldXres = this.mBuffers[i].mResolution[0];
    let oldYres = this.mBuffers[i].mResolution[1];

    if( oldXres !== xres || oldYres !== yres )
    {
        let needCopy = (this.mBuffers[i].mTexture[0]!==null);

        let texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,
            xres, yres,
            this.mRenderer.TEXFMT.C4F32,
            (needCopy) ? this.mBuffers[i].mTexture[0].mFilter : this.mRenderer.FILTER.NONE,
            (needCopy) ? this.mBuffers[i].mTexture[0].mWrap   : this.mRenderer.TEXWRP.CLAMP, 
            null);

        let texture2 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,
            xres, yres,
            this.mRenderer.TEXFMT.C4F32,
            (needCopy) ? this.mBuffers[i].mTexture[1].mFilter : this.mRenderer.FILTER.NONE,
            (needCopy) ? this.mBuffers[i].mTexture[1].mWrap   : this.mRenderer.TEXWRP.CLAMP, 
            null);

        let target1 = this.mRenderer.CreateRenderTarget( texture1, null, null, null, null, false);
        let target2 = this.mRenderer.CreateRenderTarget( texture2, null, null, null, null, false);

        if( needCopy )
        {
            let v = [0, 0, Math.min(xres, oldXres), Math.min(yres, oldYres)];
            this.mRenderer.SetBlend(false);
            this.mRenderer.SetViewport(v);
            this.mRenderer.AttachShader(this.mProgramCopy);
            let l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, "pos");
            let vOld = [0, 0, oldXres, oldYres];
            this.mRenderer.SetShaderConstant4FV("v", vOld);

            // Copy old buffers 1 to new buffer
            this.mRenderer.SetRenderTarget(target1);
            this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[0], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);

            // Copy old buffers 2 to new buffer
            this.mRenderer.SetRenderTarget(target2);
            this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[1], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);

            // Deallocate old memory
            this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[0]);
            this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[0]);
            this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[1]);
            this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[1]);
            //this.mRenderer.DestroyTexture(this.mBuffers[i].thumbnailTexture);
        }

        // Store new buffers
        this.mBuffers[i].mTexture = [texture1,texture2], 
        this.mBuffers[i].mTarget =  [target1, target2 ], 
        this.mBuffers[i].mLastRenderDone = 0;
        this.mBuffers[i].mResolution[0] = xres;
        this.mBuffers[i].mResolution[1] = yres;
    }
}

Effect.prototype.saveScreenshot = function(passid)
{
    let pass = this.mPasses[passid];

    if( pass.mType === "buffer" )
    {
        let bufferID = assetID_to_bufferID( this.mPasses[passid].mOutputs[0] );

        let texture = this.mBuffers[bufferID].mTarget[ this.mBuffers[bufferID].mLastRenderDone ];

        let numComponents = 3;
        let width = texture.mTex0.mXres;
        let height = texture.mTex0.mYres;
        let type = "Float"; // Other options Float, Half, Uint
        let bytes = new Float32Array(width * height * 4 );//numComponents);
        this.mRenderer.GetPixelDataRenderTarget( texture, bytes, width, height );
        let blob = piExportToEXR(width, height, numComponents, type, bytes);

        // Offer download automatically to the user
        piTriggerDownload("image.exr", blob);
    }
    else if( pass.mType === "cubemap" )
    {
        let xres = 4096;
        let yres = 2048;
        this.mScreenshotSytem.Allocate( xres, yres );

        let cubeBuffer = this.mCubeBuffers[0];

        let target = this.mScreenshotSytem.GetTarget();
        this.mRenderer.SetRenderTarget( target );

        let program = this.mScreenshotSytem.GetProgram();

        this.mRenderer.AttachShader(program);
        let l1 = this.mRenderer.GetAttribLocation(program, "pos");
        this.mRenderer.SetViewport( [0, 0, xres, yres] );
        this.mRenderer.AttachTextures(1, cubeBuffer.mTexture[ cubeBuffer.mLastRenderDone ], null, null, null);
        this.mRenderer.DrawUnitQuad_XY(l1);
        this.mRenderer.DettachTextures();
        this.mRenderer.SetRenderTarget( null );

        let data = new Float32Array(xres*yres*4);
        this.mRenderer.GetPixelDataRenderTarget( target, data, xres, yres );

        let blob = piExportToEXR(xres, yres, 3, "Float", data );
        piTriggerDownload("image.exr", blob);
    }
    else if( pass.mType === "sound" )
    {
        let offset = 0;
        const bits = 16;
        const numChannels = 2;
        let words = new Int16Array(60*pass.mSampleRate*numChannels );

        pass.iRenderSound( new Date(), function(off, data, numSamples)
                                         {
                                            for( let i=0; i<numSamples; i++ )
                                            {
                                                words[offset++] = (data[4*i+0]+256.0*data[4*i+1]) - 32767;
                                                words[offset++] = (data[4*i+2]+256.0*data[4*i+3]) - 32767;
                                            }
                                         }
                                     );

        let blob = piExportToWAV( 60*pass.mSampleRate, pass.mSampleRate, bits, numChannels, words);

        piTriggerDownload("sound.wav", blob);
    }    
}

Effect.prototype.ResizeBuffers = function(xres, yres)
{
    for (let i=0; i<this.mMaxBuffers; i++ )
    {
        this.ResizeBuffer(i, xres, yres, true);
    }
}

Effect.prototype.IsEnabledVR = function ()
{
    if (this.mRenderingStereo) return true;
    return false;
}

Effect.prototype.EnableVR = function()
{
    if( !this.mWebVR.IsSupported() ) return;
    if( this.mRenderingStereo ) return;

    this.mRenderingStereo = true;
    this.mWebVR.Enable();
}

Effect.prototype.DisableVR = function()
{
    if( !this.mWebVR.IsSupported() ) return;
    if( !this.mRenderingStereo ) return;

    this.mRenderingStereo = false;
    this.mWebVR.Disable();
}

Effect.prototype.GetTexture = function( passid, slot )
{
    return this.mPasses[passid].GetTexture( slot );
}

Effect.prototype.NewTexture = function( passid, slot, url )
{
    return this.mPasses[passid].NewTexture( this.mAudioContext, slot, url, this.mBuffers, this.mCubeBuffers, this.mKeyboard );
}

Effect.prototype.SetOutputs = function( passid, slot, url )
{
    this.mPasses[passid].SetOutputs( slot, url );
}

Effect.prototype.SetOutputsByBufferID = function( passid, slot, id )
{
    this.mPasses[passid].SetOutputsByBufferID( slot, id );
}

Effect.prototype.GetAcceptsLinear = function (passid, slot) 
{
    return this.mPasses[passid].GetAcceptsLinear(slot);
}

Effect.prototype.GetAcceptsMipmapping = function (passid, slot) 
{
    return this.mPasses[passid].GetAcceptsMipmapping(slot);
}

Effect.prototype.GetAcceptsWrapRepeat = function (passid, slot) 
{
    return this.mPasses[passid].GetAcceptsWrapRepeat(slot);
}

Effect.prototype.GetAcceptsVFlip = function (passid, slot)
{
    return this.mPasses[passid].GetAcceptsVFlip(slot);
}

Effect.prototype.SetSamplerFilter = function (passid, slot, str) 
{
    this.mPasses[passid].SetSamplerFilter(slot, str, this.mBuffers, this.mCubeBuffers);
}

Effect.prototype.GetTranslatedShaderSource = function (passid)
{
    return this.mPasses[passid].GetTranslatedShaderSource();
}

Effect.prototype.GetSamplerFilter = function (passid, slot) {
    return this.mPasses[passid].GetSamplerFilter(slot);
}

Effect.prototype.SetSamplerWrap = function (passid, slot, str) {
    this.mPasses[passid].SetSamplerWrap(slot, str, this.mBuffers);
}

Effect.prototype.GetSamplerWrap = function (passid, slot) {
    return this.mPasses[passid].GetSamplerWrap(slot);
}

Effect.prototype.SetSamplerVFlip = function (passid, slot, str) {
    this.mPasses[passid].SetSamplerVFlip(slot, str);
}

Effect.prototype.GetSamplerVFlip = function (passid, slot) {
    return this.mPasses[passid].GetSamplerVFlip(slot);
}

Effect.prototype.GetHeaderSize = function (passid)
{
    return this.mPasses[passid].mHeaderLength + 
           this.mRenderer.GetShaderHeaderLines(1);
 
}

Effect.prototype.ToggleVolume = function()
{
    this.mForceMuted = !this.mForceMuted;

    // outp
    if (this.mForceMuted)
        this.mGainNode.gain.value = 0.0;
    else
        this.mGainNode.gain.value = 1.0;

    // inp
    let num = this.mPasses.length;
    for( let j=0; j<num; j++ )
    {
        for( let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            if( this.mForceMuted )
                this.mPasses[j].MuteInput( this.mAudioContext, i );
            else
                this.mPasses[j].UnMuteInput( this.mAudioContext, i );
        }
    }

    return this.mForceMuted;
}

Effect.prototype.SetKeyDown = function( passid, k )
{
    if( this.mKeyboard.mData[ k + 0*256 ] == 255 ) return;

    this.mKeyboard.mData[ k + 0*256 ] = 255;
    this.mKeyboard.mData[ k + 1*256 ] = 255;
    this.mKeyboard.mData[ k + 2*256 ] = 255 - this.mKeyboard.mData[ k + 2*256 ];
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    let num = this.mPasses.length;
    for (let j=0; j<num; j++ )
    {
        for (let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            let inp = this.mPasses[j].mInputs[i];
            if( inp!==null && inp.mInfo.mType==="keyboard" )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:this.mKeyboard.mIcon, mData: this.mKeyboard.mData}, false, 6, 1, -1.0, this.mPasses[j].mID );
            }
        }
    }
}

Effect.prototype.SetKeyUp = function( passid, k )
{
    this.mKeyboard.mData[ k + 0*256 ] = 0;
    this.mKeyboard.mData[ k + 1*256 ] = 0;
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    let num = this.mPasses.length;
    for (let j=0; j<num; j++ )
    {
        for (let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            let inp = this.mPasses[j].mInputs[i];
            if( inp!==null && inp.mInfo.mType==="keyboard" )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:this.mKeyboard.mIcon, mData: this.mKeyboard.mData}, false, 6, 1, -1.0, this.mPasses[j].mID );
            }
        }
    }

}

Effect.prototype.StopOutputs = function()
{
    let wa = this.mAudioContext;

    let num = this.mPasses.length;
    for (let i=0; i<num; i++ )
    {
        this.mPasses[i].StopOutput( wa );
    }
}

Effect.prototype.ResumeOutputs = function()
{
    let wa = this.mAudioContext;

    let num = this.mPasses.length;
    for (let i=0; i<num; i++ )
    {
        this.mPasses[i].ResumeOutput( wa );
    }
}

Effect.prototype.PauseInput = function( passid, id )
{
    return this.mPasses[passid].TooglePauseInput( this.mAudioContext, id );
}

Effect.prototype.ToggleMuteInput = function( passid, id )
{
    return this.mPasses[passid].ToggleMuteInput( this.mAudioContext, id );
}

Effect.prototype.RewindInput = function( passid, id )
{
    this.mPasses[passid].RewindInput( this.mAudioContext, id );
}

Effect.prototype.UpdateInputs = function( passid, forceUpdate )
{
   this.mPasses[passid].UpdateInputs( this.mAudioContext, forceUpdate, this.mKeyboard );
}

Effect.prototype.ResetTime = function()
{
    this.mFrame = 0;
    this.mAudioContext.resume()

    let num = this.mPasses.length;
    for( let i=0; i<num; i++ )
    {
        this.mPasses[i].mFrame = 0;
        for( let j=0; j<this.mPasses[i].mInputs.length; j++ )
            this.mPasses[i].RewindInput(this.mAudioContext, j)
    }
}

Effect.prototype.RequestAnimationFrame = function (id)
{
    if (this.mRenderingStereo && this.mWebVR.IsPresenting())
    {
        this.mWebVR.RequestAnimationFrame(id);
    }
    else
    {
        requestAnimFrame(id);
    }
}

Effect.prototype.Paint = function(time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, isPaused)
{
    let wa = this.mAudioContext;
    let da = new Date();
    let vrData = null; if (this.mRenderingStereo) vrData = this.mWebVR.GetData();
    let xres = this.mXres / 1;
    let yres = this.mYres / 1;

    if( this.mFrame===0 )
    {
        for( let i=0; i<this.mMaxBuffers; i++ )
        {
            if( this.mBuffers[i].mTexture[0]!==null )
            {
                this.mRenderer.SetRenderTarget( this.mBuffers[i].mTarget[0] );
                this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
                this.mRenderer.SetRenderTarget( this.mBuffers[i].mTarget[1] );
                this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
				
				this.mRenderer.CreateMipmaps( this.mBuffers[i].mTexture[0] );
				this.mRenderer.CreateMipmaps( this.mBuffers[i].mTexture[1] );
            }
        }
        for( let i=0; i<this.mMaxCubeBuffers; i++ )
        {
            if( this.mCubeBuffers[i].mTexture[0]!==null )
            {
                for( let face=0; face<6; face++ )
                {
                    this.mRenderer.SetRenderTargetCubeMap( this.mCubeBuffers[i].mTarget[0], face );
                    this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
                    this.mRenderer.SetRenderTargetCubeMap( this.mCubeBuffers[i].mTarget[1], face );
                    this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
					this.mRenderer.CreateMipmaps( this.mCubeBuffers[i].mTexture[0] );
				    this.mRenderer.CreateMipmaps( this.mCubeBuffers[i].mTexture[1] );
                }
            }
        }
    }

    let num = this.mPasses.length;

    // render sound first
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "sound" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, null, false, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render buffers second
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "buffer" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        let bufferID = assetID_to_bufferID( this.mPasses[i].mOutputs[0] );

        // check if any downstream pass needs mipmaps when reading from this buffer
        let needMipMaps = false;
        for (let j=0; j<num; j++ )
        {
            for (let k=0; k<this.mPasses[j].mInputs.length; k++ )
            {
                let inp = this.mPasses[j].mInputs[k];
                if( inp!==null && inp.mInfo.mType==="buffer" && inp.id === bufferID && inp.mInfo.mSampler.filter === "mipmap")
                {
                    needMipMaps = true;
                    break;
                }
            }
        }

        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, needMipMaps, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }


    // render cubemap buffers second
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "cubemap" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        let bufferID = 0;//assetID_to_bufferID( this.mPasses[i].mOutputs[0] );

        // check if any downstream pass needs mipmaps when reading from this buffer
        let needMipMaps = false;

        for (let j=0; j<num; j++ )
        {
            for (let k=0; k<this.mPasses[j].mInputs.length; k++ )
            {
                let inp = this.mPasses[j].mInputs[k];
                if( inp!==null && inp.mInfo.mType==="cubemap" )
                {
                    if( assetID_to_cubemapBuferID(inp.mInfo.mID)===0 && inp.mInfo.mSampler.filter === "mipmap" )
                    {
                        needMipMaps = true;
                        break;
                    }
                }
            }
        }

        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, needMipMaps, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render image last
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "image" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, null, false, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }   

    // erase keypresses
    for (let k=0; k<256; k++ )
    {
       this.mKeyboard.mData[ k + 1*256 ] = 0;
    }
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    if( this.mRenderingStereo ) this.mWebVR.Finish();

    this.mFrame++;
}

Effect.prototype.NewShader = function( passid, preventCache, onResolve )
{
    let commonSourceCodes = [];
    for (let i=0; i<this.mPasses.length; i++ )
    {
        if( this.mPasses[i].mType==="common")
        {
            commonSourceCodes.push(this.mPasses[i].mSource);
        }
    }

    this.mPasses[passid].NewShader(commonSourceCodes, preventCache, onResolve );
}

Effect.prototype.GetNumPasses = function()
{
    return this.mPasses.length;
}

Effect.prototype.GetNumOfType = function(passtype)
{
    let id = 0;
    for (let j=0; j<this.mPasses.length; j++ )
    {
        if( this.mPasses[j].mType===passtype )
        {
            id++;
        }
    }
    return id;
}

Effect.prototype.GetPassType = function( id )
{
    return this.mPasses[id].mType;
}
Effect.prototype.GetPassName = function( id )
{
    return this.mPasses[id].mName;
}
Effect.prototype.GetCode = function( id )
{
    return this.mPasses[id].mSource;
}
Effect.prototype.SetCode = function( id, source )
{
    this.mPasses[id].SetCode(source);
}
Effect.prototype.GetError = function (id)
{
    return this.mPasses[id].mError;
}
Effect.prototype.GetErrorStr = function (id)
{
    return this.mPasses[id].mErrorStr;
}
Effect.prototype.GetErrorGlobal = function()
{
    for (let i = 0; i < this.mPasses.length; i++)
    {
        if (this.mPasses[i].mError)
        {
            return true;
        }
    }
    return false;
}

Effect.prototype.Load = function (jobj )
{
    if (jobj.ver !== "0.1")
    {
        console.log("Wrong Format");
        return false;
    }

    let numPasses = jobj.renderpass.length;

    if( numPasses<1 || numPasses>this.mMaxPasses )
    {
        console.log("Corrupted Shader - " + numPasses);
        return false;
    }

    this.mPasses = [];
    for (let j = 0; j < numPasses; j++)
    {
        let rpass = jobj.renderpass[j];

        // skip sound passes if in thumbnail mode
        if( this.mForceMuted && rpass.type === "sound" ) continue;

        let wpass = new EffectPass(this.mRenderer, this.mIs20, this.mIsLowEnd, this.mShaderTextureLOD,
                                   this.mTextureCallbackFun, this.mTextureCallbackObj, this.mForceMuted, this.mForcePaused, this.mGainNode,
                                   this.mProgramDownscale, j, this);

        wpass.Create(rpass.type, this.mAudioContext);

        let numInputs = rpass.inputs.length;

        for (let i = 0; i < 4; i++)
        {
            wpass.NewTexture(this.mAudioContext, i, null, null, null);
        }
        for (let i = 0; i < numInputs; i++)
        {
            let lid  = rpass.inputs[i].channel;
            let styp = rpass.inputs[i].type;
            let sid  = rpass.inputs[i].id;
            let ssrc = rpass.inputs[i].filepath;
            let psrc = rpass.inputs[i].previewfilepath;
            let samp = rpass.inputs[i].sampler;

            wpass.NewTexture(this.mAudioContext, lid, { mType: styp, mID: sid, mSrc: ssrc, mSampler: samp, mPreviewSrc: psrc }, this.mBuffers, this.mCubeBuffers, this.mKeyboard);
        }

        for (let i = 0; i < 4; i++)
        {
            wpass.SetOutputs(i, null);
        }

        let numOutputs = rpass.outputs.length;
        for (let i = 0; i < numOutputs; i++)
        {
            let outputID = rpass.outputs[i].id;
            let outputCH = rpass.outputs[i].channel;
            wpass.SetOutputs(outputCH, outputID);
        }

        // create some hardcoded names. This should come from the DB
        let rpassName = "";
        if (rpass.type === "common" ) rpassName = "Common";
        if (rpass.type === "sound"  ) rpassName = "Sound";
        if (rpass.type === "image"  ) rpassName = "Image";
        if (rpass.type === "buffer") rpassName = "Buffer " + String.fromCharCode(65 + assetID_to_bufferID(wpass.mOutputs[0]));
        if (rpass.type === "cubemap") rpassName = "Cube A";// " + String.fromCharCode(65 + assetID_to_bufferID(this.mPasses[j].mOutputs[0]));
        wpass.SetName(rpassName);
        wpass.SetCode(rpass.code);

        this.mPasses.push(wpass);
    }
    return true;
}

Effect.prototype.CompileSome = function ( passes, preventCache, onResolve )
{
    let me = this;

    let to = getRealTime();
    let allPromisses = [];
    for (let j = 0; j < passes.length; j++)
    {
        allPromisses.push(new Promise(function (resolve, reject)
        {
            me.NewShader(passes[j], preventCache, function () { resolve(1); });
        }));
    }

    // aggregated callback when all passes have been compiled
    Promise.all(allPromisses).then(function (values)
    {
        let totalError = false;
        for (let j = 0; j < me.mPasses.length; j++)
        {
            if (me.mPasses[j].mError)
            {
                totalError = true;
                break;
            }
        }
        me.mCompilationTime = getRealTime() - to;
        onResolve(!totalError);
    }).catch(console.log);
}

Effect.prototype.Compile = function (preventCache, onResolve )
{
    let me = this;

    let to = getRealTime();
    let allPromisses = [];
    let numPasses = this.mPasses.length;
    for (let j = 0; j < numPasses; j++)
    {
        allPromisses.push(new Promise(function (resolve, reject)
        {
            me.NewShader(j, preventCache, function () { resolve(1); });
        }));
    }

    // aggregated callback when all passes have been compiled
    Promise.all(allPromisses).then(function (values)
    {
        let totalError = false;
        for (let j = 0; j < numPasses; j++)
        {
            if (me.mPasses[j].mError)
            {
                totalError = true;
                break;
            }
        }
        me.mCompilationTime = getRealTime() - to;
        onResolve(!totalError);
    }).catch(console.log);
}

Effect.prototype.GetCompilationTime = function( id )
{
    return this.mPasses[id].GetCompilationTime()/1000.0;
}
Effect.prototype.GetTotalCompilationTime = function()
{
    return this.mCompilationTime/1000.0;
}

Effect.prototype.DestroyPass = function( id )
{
   this.mPasses[id].Destroy( this.mAudioContext );
   this.mPasses.splice(id, 1);
}

Effect.prototype.AddPass = function( passType, passName, onResolve )
{
    let shaderStr = null;

    if( passType==="sound"   ) shaderStr = "vec2 mainSound( int samp, float time )\n{\n    // A 440 Hz wave that attenuates quickly overt time\n    return vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );\n}";
    if( passType==="buffer"  ) shaderStr = "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}";
    if( passType==="common"  ) shaderStr = "vec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}";
    if( passType==="cubemap" ) shaderStr = "void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Ray direction as color\n    vec3 col = 0.5 + 0.5*rayDir;\n\n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}";

    let id = this.GetNumPasses();
    this.mPasses[id] = new EffectPass( this.mRenderer, this.mIs20, this.mIsLowEnd, this.mShaderTextureLOD,
                                       this.mTextureCallbackFun, this.mTextureCallbackObj, this.mForceMuted, this.mForcePaused, this.mGainNode, 
                                       this.mProgramDownscale, id, this );

    this.mPasses[id].Create( passType, this.mAudioContext );
    this.mPasses[id].SetName( passName );
    this.mPasses[id].SetCode( shaderStr );
    this.NewShader(id, false, function ()
    {
        onResolve();
    });

    return { mId : id, mShader : shaderStr };
}

// this should be removed once we have MultiPass 2.0 and passes render to arbitrary buffers
Effect.prototype.IsBufferPassUsed = function( bufferID )
{
    for (let j=0; j<this.mPasses.length; j++ )
    {
        if( this.mPasses[j].mType !== "buffer" ) continue;
        if( this.mPasses[j].mOutputs[0] === bufferID_to_assetID(bufferID) ) return true;
    }
    return false;
}

Effect.prototype.Save = function()
{
    var result = {};

    result.ver = "0.1";

    result.renderpass = [];

    let numPasses = this.mPasses.length;
    for (let j=0; j<numPasses; j++ )
    {
        result.renderpass[j] = {};

        result.renderpass[j].outputs = new Array();
        for (let i = 0; i<4; i++ )
        {
            let outputID = this.mPasses[j].mOutputs[i];
            if( outputID===null ) continue;
            result.renderpass[j].outputs.push( { channel: i, id: outputID } );
        }
        result.renderpass[j].inputs = new Array();
        for (let i = 0; i<4; i++ )
        {
            if( this.mPasses[j].mInputs[i]===null ) continue;
            result.renderpass[j].inputs.push( {channel: i,
                                               type    : this.mPasses[j].mInputs[i].mInfo.mType,
                                               id      : this.mPasses[j].mInputs[i].mInfo.mID,
                                               filepath: this.mPasses[j].mInputs[i].mInfo.mSrc,
                                               sampler : this.mPasses[j].mInputs[i].mInfo.mSampler });
        }

        result.renderpass[j].code = this.mPasses[j].mSource;
        result.renderpass[j].name = this.mPasses[j].mName
        result.renderpass[j].description = "";
        result.renderpass[j].type = this.mPasses[j].mType;
    }

    result.flags = this.calcFlags();

    return result;
}

Effect.prototype.calcFlags = function ()
{
    let flagVR = false;
    let flagWebcam = false;
    let flagSoundInput = false;
    let flagSoundOutput = false;
    let flagKeyboard = false;
    let flagMultipass = false;
    let flagMusicStream = false;

    let numPasses = this.mPasses.length;
    for (let j = 0; j < numPasses; j++)
    {
        let pass = this.mPasses[j];

        if (pass.mType === "sound") flagSoundOutput = true;
        if (pass.mType === "buffer") flagMultipass = true;

        for (let i = 0; i < 4; i++)
        {
            if (pass.mInputs[i] === null) continue;

            if (pass.mInputs[i].mInfo.mType === "webcam") flagWebcam = true;
            else if (pass.mInputs[i].mInfo.mType === "keyboard") flagKeyboard = true;
            else if (pass.mInputs[i].mInfo.mType === "mic") flagSoundInput = true;
            else if (pass.mInputs[i].mInfo.mType === "musicstream") flagMusicStream = true;
        }

        let n1 = pass.mSource.indexOf("mainVR(");
        let n2 = pass.mSource.indexOf("mainVR (");
        if (n1 > 0 || n2 > 0) flagVR = true;
    }

    return {
        mFlagVR: flagVR,
        mFlagWebcam: flagWebcam,
        mFlagSoundInput: flagSoundInput,
        mFlagSoundOutput: flagSoundOutput,
        mFlagKeyboard: flagKeyboard,
        mFlagMultipass: flagMultipass,
        mFlagMusicStream: flagMusicStream
    };
}</script>
    <script>"use strict"

const kMaxCompileTime = 10.0;

function iReportCrash(shaderID)
{
    let req = new XMLHttpRequest();
    req.onload = function ()
    {
        let jsn = req.response;
        if (jsn === null) return;
        if (jsn.result === 0)
        {
            // yep
        }
    };
    req.open("POST", "/shadertoy", true);
    req.responseType = "json";
    req.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    req.send( "s=" + shaderID + "&r=2" );
}
</script>
    <script>"use strict"

var gActive = -1;
var mShaders = [];
var gNumCanvases = 0;

function myrefresh( id, slot, img, forceFrame, gui, guiID, renderID, time )
{
    if( mShaders[id].mReady===false ) return;
    if( forceFrame )
    {
        if (mShaders[id].mScreenshot === false)
        {
            mShaders[id].gEffect.Paint(mShaders[id].mTime / 1000.0, 1.0 / 60.0, 60.0, 0, 0, 0, 0, false);
        }
    }
}

function startRendering()
{
    if( gActive<0 ) return;
    if( mShaders[gActive].mReady===false ) return;
    if( mShaders[gActive].mScreenshot===true ) return;

    let time = getRealTime();

    mShaders[gActive].mFPS.Count( time );
    mShaders[gActive].mTime = mShaders[gActive].mTime0 + (time - mShaders[gActive].mTo);
    let dtime = 1000.0/60.0;
    mShaders[gActive].gEffect.Paint( mShaders[gActive].mTime/1000.0, dtime/1000.0, mShaders[gActive].mFPS.GetFPS(), 0,0,0,0, false);

    requestAnimFrame( startRendering );
}

function iLoadAndCompile(jsn, i )
{
    var shaderObj = jsn[i];
    if (shaderObj === null) return;

    var resizeCB = function (xres, yres) { myrefresh(i, 0, null, true, false, 0, -1.0) };
    var crashCB = function () { alert('crash');/*iReportCrash(gShaderIDs[i])*/ };
    mShaders[i].gEffect = new Effect(null, null, mShaders[i].mPreview.mCanvas, myrefresh, i, true, true, resizeCB, crashCB);

    if (!mShaders[i].gEffect.Load(shaderObj)) return;

    mShaders[i].gEffect.Compile(false, function (worked)
    {
        if (worked === true)
        {
            previewShowRender(mShaders[i].mPreview);

            mShaders[i].mScreenshot = false;
            mShaders[i].mReady = true;
            mShaders[i].mTime = 10.0 * 1000.0;
            mShaders[i].mTime0 = 0.0;
            mShaders[i].mTo = 0.0;
            mShaders[i].mFPS = piCreateFPSCounter();
            mShaders[i].mPreview.mCanvas.addEventListener("mouseout", function (ev) { gActive = -1; }, true);
            mShaders[i].mPreview.mBase.addEventListener("mouseover", function (ev) { if (mShaders[i].mPreview.mUI !== null) mShaders[i].mPreview.mUI.classList.add('isVisible'); }, true);
            mShaders[i].mPreview.mBase.addEventListener("mouseout", function (ev) { if (mShaders[i].mPreview.mUI !== null) mShaders[i].mPreview.mUI.classList.remove('isVisible'); }, true);
            mShaders[i].mPreview.mCanvas.addEventListener("mouseover", function (ev)
            {
                let ele = piGetSourceElement(ev);
                if (ele.mId === undefined) return;

                gActive = ele.mId;
                if (!mShaders[gActive].mReady) return;
                let time = getRealTime();
                mShaders[gActive].mTo = time;
                mShaders[gActive].mTime0 = mShaders[gActive].mTime;
                mShaders[gActive].mFPS.Reset(time);

                startRendering();
            }, true);


            /*
            let compilationTime = mShaders[i].gEffect.GetTotalCompilationTime();
            if (compilationTime > kMaxCompileTime)
            {
                iReportCrash(mShaders[i].mShaderID);
            }*/

            myrefresh(i, null, null, true, false, 0, -1.0);
        }
        else
        {
            mShaders[i].mReady = false;
            previewShowError(mShaders[i].mPreview);
        }
    });
};


function iProcessShader( jsn, i )
{
    var shaderObj = jsn[i];
    if( shaderObj===null ) return;

    if ((shaderObj.info.usePreview === 0 && !gUseScreenshots) || (mShaders[i].mPreviewReady !== 1))
    {
        iLoadAndCompile(jsn, i);
    }
    else
    {
        mShaders[i].mScreenshot = true;
        if( shaderObj.info.usePreview === 1 )
            previewShowScreenshot(mShaders[i].mPreview, 1); // comp
        else if (gUseScreenshots)
            previewShowScreenshot(mShaders[i].mPreview, 2); // sett
    }

    if( i<(jsn.length-1) ) setTimeout( function(){iProcessShader(jsn,i+1);}, 10 );
}

function iInitUI(numCanvases, uiCallback, windowTitle)
{
    gNumCanvases = numCanvases;
    document.getElementById("mySearch").focus();

    //-----------------------------------------------------------------
    // window
    //-----------------------------------------------------------------
    if (windowTitle !== null) {
        document.title = windowTitle;
    }

    //-----------------------------------------------------------------
    // ui
    //-----------------------------------------------------------------
    var num = Math.min(gShaders.length, gNumCanvases);

    //var base = document.getElementsByClassName( "searchResult" );

    for (let i = 0; i < gNumCanvases; i++)
    {
        let pv = createPreview(i);

        if (i >= num) {
            previewHide(pv);
            continue;
        }

        let shaderID = gShaders[i].info.id;
        
        if (pv.mUI !== null && uiCallback !== null) {
            pv.mUI.addEventListener('click', function (ev) {
                uiCallback(shaderID);
                ev.preventDefault();
            }, false);
        }
        
        previewShowLoading(pv);
        
        mShaders[i] = {};
        mShaders[i].mShaderID = shaderID;
        mShaders[i].mPreview = pv;
        mShaders[i].mScreenshot = false;
        mShaders[i].mPreview.mLink.href = "/view/" + shaderID;
        mShaders[i].mPreviewReady = 0;
        mShaders[i].mReady = false;
        mShaders[i].gEffect = null;

        previewLoadScreenshot(mShaders[i].mPreview,
            function () { mShaders[i].mPreviewReady = 1; if (mShaders[i].mReady === false) previewShowScreenshot(mShaders[i].mPreview, 0); },
            function () { mShaders[i].mPreviewReady = 2; },
            shaderID);
    }

    if (num <= 0) {
        return;
    }
}

function iInitShaders(jsn)
{
    for (let i = 0; i < jsn.length; i++)
    {
        let shaderObj = jsn[i];
        if (shaderObj === null) continue;
        let inf = shaderObj.info;
        mShaders[i].mPreview.mTextA.textContent = inf.name;
        mShaders[i].mPreview.mTextB.innerHTML = "<a class='user' href='/user/" + htmlEntities(inf.username) + "'>" + htmlEntities(inf.username) + "</a>";
        mShaders[i].mPreview.mTextC.innerHTML = "<img src='/img/themes/" + gThemeName + "/views.png' class='viewsIcon'></img>" + inf.viewed + "    &nbsp;&nbsp;  <img src='/img/themes/" + gThemeName + "/likes.png' class='likesIcon'></img>" + inf.likes;
    }

    setTimeout(function () { iProcessShader(jsn, 0); }, 10);
}

function resultsInitStatic(numCanvases, uiCallback, windowTitle)
{
    iInitUI(numCanvases, uiCallback, windowTitle);

    iInitShaders(gShaders);
}

function resultsInit(numCanvases, uiCallback, windowTitle)
{	
    iInitUI(numCanvases, uiCallback, windowTitle);

    var num = Math.min(gShaderIDs.length, gNumCanvases);

    var mHttpReq = new XMLHttpRequest();

    mHttpReq.abort();

    var str = "{ \"shaders\" : [";
    for( let i=0; i<num; i++ )
    {
         str += "\"" + gShaderIDs[i] + "\"";
         if( i!==(num-1) ) str += ", ";
    }
    str += "] }";

    str = "s=" + encodeURIComponent( str ) + "&nt=0&nl=0&np=0";

    mHttpReq.open( "POST", "/shadertoy", true );
    mHttpReq.responseType = "json";
    mHttpReq.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    mHttpReq.onload = function ()
    {
        let jsn = this.response;
        if( jsn===null )
        {
            console.log( "Could not load shaders" );
            return;
        }

        iInitShaders(jsn);
    }
    mHttpReq.send( str );
}</script>
    <style>
    .shaderPreview
    {
    display: block;
    background-color: #000000;
    background-image: url("/img/loading.gif");
    background-repeat: no-repeat;
    background-position: center;
    padding: 0px;
    margin: 0px;
    border: 0px solid #000000;
    border-radius: 8px;
    width:100%;
    height:100%;
    position: absolute;
    overflow:hidden;
    }

    .previewInfo
    {
    width: 100%;
    left: 0px;
    top: 2px;
    position: relative;
    visibility: hidden;
    }

    .previewCanvas
    {
    left: 0px;
    top: 0px;
    padding: 0px;
    margin: 0px;
    position: absolute;
    cursor: pointer;
    width:100%;
    height:100%;
    border-radius: 8px;
    border: 0px solid #000000;
    backgroundColor: transparent;
visibility: hidden;
opacity:0;
transition: opacity 1.0s ease;
    }

    .previewText
    {
        text-overflow: ellipsis;
    white-space: nowrap;
    padding-right: 1px;
    }

    .previewTextUser
    {
    text-overflow: ellipsis;
    white-space: nowrap;
    padding-left: 3px;
    }

    .previewStats
    {
    padding-right: 1px;
    right: 0px;
    top: 0px;
    position: absolute;
    }

    .previewErrorContainer
    {
    left:0px;
    top:0px;
    width:100%;
    height:100%;
    padding:0px;
    margin:0px;
    background-color:#000000;
    border-radius:8px;
    cursor:pointer;
    visibility:hidden;
    }

    .previewErrorMessage
    {
    top:50%;
    position:absolute;
    width:100%;
    text-align:center;
    padding:0;
    margin:auto;
    color:#ff0000;
    font-size:2em;
    font-style:italic;
    }

    .previewNoGLContainter
    {
    left:0px;
    top:0px;
    width:100%;
    height:100%;
    padding:0px;
    margin:0px;
    position:absolute;
    background-color:#000000;
    border-radius:8px;
    cursor:pointer;
    pointer-events:none;
    visibility:hidden;
    font-size:2em;
    }

    .previewNoGLMessage
    {
    width:86%;
    height:90%;
    padding-left:7%;
    padding-right:7%;
    padding-top:10%;
    padding-bottom:0px;
    color:#ff0000;
    position:absolute;
    visibility:hidden;
    }

    .previewThumbnailContainer
    {
    width:100%;
    height:100%;
    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    cursor:pointer;
    visibility:hidden;
    border-radius:8px;
    border:0px solid #000000;
    }

    .previewThumbnailImage
    {
    width:100%;
    height:100%;
    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    cursor:pointer;
    border-radius:8px;
    border:0px solid #000000;
opacity: 0.0;
transition: opacity 1.0s ease;
    }

    .previewThumbnailIcon
    {
    width:64px;
    height:32px;
    left:0px;
    top:0px;
    padding:0px;
    padding-top:12px;
    margin:0px;
    position:absolute;
    color:#ffffff;
    background-color:#ff8020;
    font-weight:bold;
    border-radius:0px 0px 8px 0px;
    text-align:center;
    //visibility:hidden;
    }


    .previewUIContainter
    {
    display: block;
    right:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    //cursor:pointer;
    //pointer-events:none;
    //visibility:hidden;
    }
</style>

<script>
    function previewHide(me)
    {
    me.mBase.style.visibility = "hidden";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "hidden";
    }

    function previewShowRender(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "visible";
me.mCanvas.style.opacity = 1.0;
    me.mCanvas.style.borderRadius ="8px;";
//  me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "visible";
    }

    function previewShowScreenshot(me, message)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "visible";
me.mThumbnailImg.style.opacity = 1.0;
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "visible";
    me.mThumbnailWar1.style.visibility = (message===1)?"visible":"hidden";
    me.mThumbnailWar2.style.visibility = (message===2)?"visible":"hidden";
    }

    function previewShowLoading(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "hidden";

    me.mLink.style.visibility = "visible";
    me.mBase.style.backgroundColor = "#ff0000;"
    me.mCont.style.visibility = "visible";
    }

    function previewShowNoWebGL(me, shaderID)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "visible";
    me.mError.style.visibility = "visible";
    me.mThumbnailImgNoWebGL.onerror = function(ev) 
                                      { 
                                            me.mThumbnailImgNoWebGL.style.visibility="hidden"; 
                                            me.mMessageNoWebGL.style.visibility="visible"; 
                                      };
    me.mThumbnailImgNoWebGL.src = "/media/shaders/" + shaderID + ".jpg";
    }

    function previewShowError(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "visible";
    me.mCont.style.visibility = "visible";
    }

    function previewLoadScreenshot( me, cbSuccess, cbError, shaderID )
    {
    var url = "/media/shaders/" + shaderID + ".jpg";
    me.mThumbnailImg.onload = cbSuccess;
    me.mThumbnailImg.onerror = function(ev) { cbError(); };
    me.mThumbnailImg.src = url;
    }
        
    function createPreview(id)
    {
        var bar = document.getElementById( "Preview_"+id+"_Canvas" );
        bar.width = bar.offsetWidth;
        bar.height = bar.offsetHeight;
        bar.mId = id;

        return { mBase: document.getElementById( "Preview_"+id+"_Container" ),
        mLink: document.getElementById( "Preview_"+id+"_Link" ),
        mCanvas: bar,
        mCont: document.getElementById( "Preview_"+id+"_Info" ),
        mTextA: document.getElementById( "Preview_"+id+"_Text" ),
        mTextB: document.getElementById( "Preview_"+id+"_TextUser" ),
        mTextC: document.getElementById( "Preview_"+id+"_Stats" ),
        mNoWebGL: document.getElementById( "Preview_"+id+"_NoWebGL" ),
        mError: document.getElementById( "Preview_"+id+"_Error" ),
        mCanvas2D: document.getElementById( "Preview_"+id+"_Thumnail" ),
        mThumbnailImg: document.getElementById( "Preview_"+id+"_ThumnailImage" ),
        mThumbnailWar1: document.getElementById( "Preview_"+id+"_ThumnailWarning1" ),
        mThumbnailWar2: document.getElementById( "Preview_"+id+"_ThumnailWarning2" ),
        mThumbnailImgNoWebGL: document.getElementById( "Preview_"+id+"_ThumnailImageNoWebGL" ),
        mMessageNoWebGL: document.getElementById( "Preview_"+id+"_MessageNoWebGL"),
        mUI: document.getElementById( "Preview_"+id+"_UI" )
        };
    }
</script>

    <style>

    div#shaderGrid
    {
        width:100%;
        padding:0px;
        margin:0px;
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        grid-template-rows: repeat(3, 1fr);
        grid-column-gap: 64px;
        grid-row-gap: 24px;
    }
    .searchResult
    {
        margin: 0px;
        padding: 0px;
        width: 100%;
    }
    .searchResultContainer
    {
        width: 100%;
        padding-bottom:56.25%;
        height: 0;
        position: relative;
    }
    .navigation
    {
        display:flex;
        align-items:center;
    }
    div#navBottom
    {
        display:none;
        justify-content:center;
    }
    a.pageButtons, .pageButtonsCurrent
    {
        border-style: solid;
        border-width: 1px;
        border-color: #808080;
        text-align: center;
        vertical-align: middle;
        margin-left: 12px;
        display: inline-block;
        border-radius: 4px;
		font-weight:bold;
        cursor: pointer;
        padding-bottom:5px;
        padding-top:4px;
        padding-left: 8px;
        padding-right: 8px;
        margin:8px;
    }
    a.pageButtons
    {
        text-decoration: none;
        -moz-transition:    background-color 0.15s linear, color 0.15s linear;
        -webkit-transition: background-color 0.15s linear, color 0.15s linear;
        transition:         background-color 0.15s linear, color 0.15s linear;
    }
    a.pageButtons:hover
    {
      background-color:#808080;
      color : #ff8020;
    }
    .pageButtonsCurrent
    {
        background-color: #808080;
        color:#000000;
    }
    div#controls
    {
        width:100%;
        padding-top:16px;
        padding-bottom:16px;
        display:flex;
        justify-content:space-between; 
        flex-wrap:wrap;
    }
    div#controls > div
    {
        display:inline-flex;
    }
    .controlOptions
    {
        display:inline-block;
    }

    /* ----------------------- media resolutions ------------------------ */

    @media screen and (max-width:799px) 
    {
        div#shaderGrid  { grid-template-columns: 1fr; grid-template-rows: repeat(12, 1fr); grid-column-gap: 0px; grid-row-gap: 16px; }
        div#controls
        {
            width:100%;
            display:flex;
            justify-content:flex-start; 
            flex-wrap:wrap;
        }
        div#controls > div
        {
            display:inline-flex;
            width:100%;
            margin-left: 0px;
            margin-right: 0px;
            padding-bottom:16px;
        }
        div#navBottom
        {
            display: flex;
        }
    }
    
    </style>
    <script>
    var gShaders=[{"ver":"0.1","info":{"id":"4ttSWf","date":"1482384986","viewed":225427,"name":"Rainforest","username":"iq","description":"Another terrain, with cheap trees made of ellipsoids and noise. It computes analytic normals for the terrain and clouds. The art composed to camera as usual. Making-of Tutorial: [url]https:\/\/www.youtube.com\/watch?v=BFld4EBO2RE[\/url]","likes":1029,"published":3,"flags":32,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Copyright Inigo Quilez, 2016 - https:\/\/iquilezles.org\/\n\/\/ I am the sole copyright owner of this Work.\n\/\/ You cannot host, display, distribute or share this Work in any form,\n\/\/ including physical and digital. You cannot use this Work in any\n\/\/ commercial or non-commercial product, website or project. You cannot\n\/\/ sell this Work and you cannot mint an NFTs of it.\n\/\/ I share this Work for educational purposes, and you can link to it,\n\/\/ through an URL, proper attribution and unmodified screenshot, as part\n\/\/ of your educational material. If these conditions are too restrictive\n\/\/ please contact me and we'll definitely work it out.\n\n\/\/ A rainforest landscape.\n\/\/\n\/\/ Making of Tutorial: https:\/\/www.youtube.com\/watch?v=BFld4EBO2RE\n\/\/ Buy a metal or paper print: https:\/\/www.redbubble.com\/shop\/ap\/39843511\n\/\/\n\/\/ Normals are analytical (true derivatives) for the terrain and for the\n\/\/ clouds, including the noise, the fbm and the smoothsteps.\n\/\/\n\/\/ Lighting and art composed for this shot\/camera. The trees are really\n\/\/ ellipsoids with noise, but they kind of do the job in distance and low\n\/\/ image resolutions Also I used some basic reprojection technique to \n\/\/ smooth out the render.\n\/\/\n\/\/ See here for more info: \n\/\/  https:\/\/iquilezles.org\/articles\/fbm\n\/\/  https:\/\/iquilezles.org\/articles\/morenoise\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord\/iResolution.xy;\n\n    vec3 col = texture( iChannel0, p ).xyz;\n  \/\/vec3 col = texelFetch( iChannel0, ivec2(fragCoord-0.5), 0 ).xyz;\n\n    col *= 0.5 + 0.5*pow( 16.0*p.x*p.y*(1.0-p.x)*(1.0-p.y), 0.05 );\n         \n    fragColor = vec4( col, 1.0 );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define LOWQUALITY\n\n\/\/==========================================================================================\n\/\/ general utilities\n\/\/==========================================================================================\n#define ZERO (min(iFrame,0))\n\nfloat sdEllipsoidY( in vec3 p, in vec2 r )\n{\n    float k0 = length(p\/r.xyx);\n    float k1 = length(p\/(r.xyx*r.xyx));\n    return k0*(k0-1.0)\/k1;\n}\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p\/r);\n    float k1 = length(p\/(r*r));\n    return k0*(k0-1.0)\/k1;\n}\n\n\/\/ return smoothstep and its derivative\nvec2 smoothstepd( float a, float b, float x)\n{\n\tif( x<a ) return vec2( 0.0, 0.0 );\n\tif( x>b ) return vec2( 1.0, 0.0 );\n    float ir = 1.0\/(b-a);\n    x = (x-a)*ir;\n    return vec2( x*x*(3.0-2.0*x), 6.0*x*(1.0-x)*ir );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\/\/==========================================================================================\n\/\/ hashes (low quality, do NOT use in production)\n\/\/==========================================================================================\n\nfloat hash1( vec2 p )\n{\n    p  = 50.0*fract( p*0.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat hash1( float n )\n{\n    return fract( n*17.0*fract( n*0.3183099 ) );\n}\n\nvec2 hash2( vec2 p ) \n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    float n = 111.0*p.x + 113.0*p.y;\n    return fract(n*fract(k*n));\n}\n\n\/\/==========================================================================================\n\/\/ noises\n\/\/==========================================================================================\n\n\/\/ value noise, and its analytical derivatives\nvec4 noised( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    #if 1\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n    #else\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    #endif\n\n    float n = p.x + 317.0*p.y + 157.0*p.z;\n    \n    float a = hash1(n+0.0);\n    float b = hash1(n+1.0);\n    float c = hash1(n+317.0);\n    float d = hash1(n+318.0);\n    float e = hash1(n+157.0);\n\tfloat f = hash1(n+158.0);\n    float g = hash1(n+474.0);\n    float h = hash1(n+475.0);\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z), \n                      2.0* du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\n                                      k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\n                                      k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    #if 1\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    #else\n    vec3 u = w*w*(3.0-2.0*w);\n    #endif\n    \n\n\n    float n = p.x + 317.0*p.y + 157.0*p.z;\n    \n    float a = hash1(n+0.0);\n    float b = hash1(n+1.0);\n    float c = hash1(n+317.0);\n    float d = hash1(n+318.0);\n    float e = hash1(n+157.0);\n\tfloat f = hash1(n+158.0);\n    float g = hash1(n+474.0);\n    float h = hash1(n+475.0);\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z);\n}\n\nvec3 noised( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    #if 1\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec2 du = 30.0*w*w*(w*(w-2.0)+1.0);\n    #else\n    vec2 u = w*w*(3.0-2.0*w);\n    vec2 du = 6.0*w*(1.0-w);\n    #endif\n    \n    float a = hash1(p+vec2(0,0));\n    float b = hash1(p+vec2(1,0));\n    float c = hash1(p+vec2(0,1));\n    float d = hash1(p+vec2(1,1));\n\n    float k0 = a;\n    float k1 = b - a;\n    float k2 = c - a;\n    float k4 = a - b - c + d;\n\n    return vec3( -1.0+2.0*(k0 + k1*u.x + k2*u.y + k4*u.x*u.y), \n                 2.0*du * vec2( k1 + k4*u.y,\n                            k2 + k4*u.x ) );\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    #if 1\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    #else\n    vec2 u = w*w*(3.0-2.0*w);\n    #endif\n\n    float a = hash1(p+vec2(0,0));\n    float b = hash1(p+vec2(1,0));\n    float c = hash1(p+vec2(0,1));\n    float d = hash1(p+vec2(1,1));\n    \n    return -1.0+2.0*(a + (b-a)*u.x + (c-a)*u.y + (a - b - c + d)*u.x*u.y);\n}\n\n\/\/==========================================================================================\n\/\/ fbm constructions\n\/\/==========================================================================================\n\nconst mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                      -0.80,  0.36, -0.48,\n                      -0.60, -0.48,  0.64 );\nconst mat3 m3i = mat3( 0.00, -0.80, -0.60,\n                       0.80,  0.36, -0.48,\n                       0.60, -0.48,  0.64 );\nconst mat2 m2 = mat2(  0.80,  0.60,\n                      -0.60,  0.80 );\nconst mat2 m2i = mat2( 0.80, -0.60,\n                       0.60,  0.80 );\n\n\/\/------------------------------------------------------------------------------------------\n\nfloat fbm_4( in vec2 x )\n{\n    float f = 1.9;\n    float s = 0.55;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=ZERO; i<4; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*m2*x;\n    }\n\treturn a;\n}\n\nfloat fbm_4( in vec3 x )\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=ZERO; i<4; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*m3*x;\n    }\n\treturn a;\n}\n\nvec4 fbmd_7( in vec3 x )\n{\n    float f = 1.92;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    vec3  d = vec3(0.0);\n    mat3  m = mat3(1.0,0.0,0.0,\n                   0.0,1.0,0.0,\n                   0.0,0.0,1.0);\n    for( int i=ZERO; i<7; i++ )\n    {\n        vec4 n = noised(x);\n        a += b*n.x;          \/\/ accumulate values\t\t\n        d += b*m*n.yzw;      \/\/ accumulate derivatives\n        b *= s;\n        x = f*m3*x;\n        m = f*m3i*m;\n    }\n\treturn vec4( a, d );\n}\n\nvec4 fbmd_8( in vec3 x )\n{\n    float f = 2.0;\n    float s = 0.65;\n    float a = 0.0;\n    float b = 0.5;\n    vec3  d = vec3(0.0);\n    mat3  m = mat3(1.0,0.0,0.0,\n                   0.0,1.0,0.0,\n                   0.0,0.0,1.0);\n    for( int i=ZERO; i<8; i++ )\n    {\n        vec4 n = noised(x);\n        a += b*n.x;          \/\/ accumulate values\t\t\n        if( i<4 )\n        d += b*m*n.yzw;      \/\/ accumulate derivatives\n        b *= s;\n        x = f*m3*x;\n        m = f*m3i*m;\n    }\n\treturn vec4( a, d );\n}\n\nfloat fbm_9( in vec2 x )\n{\n    float f = 1.9;\n    float s = 0.55;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=ZERO; i<9; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*m2*x;\n    }\n    \n\treturn a;\n}\n\nvec3 fbmd_9( in vec2 x )\n{\n    float f = 1.9;\n    float s = 0.55;\n    float a = 0.0;\n    float b = 0.5;\n    vec2  d = vec2(0.0);\n    mat2  m = mat2(1.0,0.0,0.0,1.0);\n    for( int i=ZERO; i<9; i++ )\n    {\n        vec3 n = noised(x);\n        n.x = n.x;\n        \n        a += b*n.x;          \/\/ accumulate values\t\t\n        d += b*m*n.yz;       \/\/ accumulate derivatives\n        b *= s;\n        x = f*m2*x;\n        m = f*m2i*m;\n    }\n\n\treturn vec3( a, d );\n}\n\n\/\/==========================================================================================\n\/\/ specifics to the actual painting\n\/\/==========================================================================================\n\n\n\/\/------------------------------------------------------------------------------------------\n\/\/ global\n\/\/------------------------------------------------------------------------------------------\n\nconst vec3  kSunDir = vec3(-0.624695,0.468521,-0.624695);\nconst float kMaxTreeHeight = 4.8;\nconst float kMaxHeight = 840.0;\n\nvec3 fog( in vec3 col, float t )\n{\n    vec3 ext = exp2(-t*0.00025*vec3(1,1.5,4)); \n    return col*ext + (1.0-ext)*vec3(0.55,0.55,0.58); \/\/ 0.55\n}\n\n\/\/------------------------------------------------------------------------------------------\n\/\/ clouds\n\/\/------------------------------------------------------------------------------------------\n\nvec4 cloudsFbm( in vec3 pos )\n{\n    return fbmd_8(pos*0.0015+vec3(2.0,1.1,1.0)+0.07*vec3(iTime,0.5*iTime,-0.15*iTime));\n}\n\nvec4 cloudsMap( in vec3 pos, out float nnd )\n{\n    float d = abs(pos.y-900.0)-40.0;\n    vec3 gra = vec3(0.0,sign(pos.y-900.0),0.0);\n    \n    vec4 n = cloudsFbm(pos);\n    d += 400.0*n.x * (0.7+0.3*gra.y);\n    \n    if( d>0.0 ) return vec4(-d,0.0,0.0,0.0);\n    \n    nnd = -d;\n    d = min(-d\/100.0,0.25);\n    \n    \/\/gra += 0.1*n.yzw *  (0.7+0.3*gra.y);\n    \n    return vec4( d, gra );\n}\n\nfloat cloudsShadowFlat( in vec3 ro, in vec3 rd )\n{\n    float t = (900.0-ro.y)\/rd.y;\n    if( t<0.0 ) return 1.0;\n    vec3 pos = ro + rd*t;\n    return cloudsFbm(pos).x;\n}\n\nfloat terrainShadow( in vec3 ro, in vec3 rd, in float mint );\n\nvec4 renderClouds( in vec3 ro, in vec3 rd, float tmin, float tmax, inout float resT, in vec2 px )\n{\n    vec4 sum = vec4(0.0);\n\n    \/\/ bounding volume!!\n    float tl = ( 600.0-ro.y)\/rd.y;\n    float th = (1200.0-ro.y)\/rd.y;\n    if( tl>0.0 ) tmin = max( tmin, tl ); else return sum;\n    if( th>0.0 ) tmax = min( tmax, th );\n\n    float t = tmin;\n    \/\/t += 1.0*hash1(gl_FragCoord.xy);\n    float lastT = -1.0;\n    float thickness = 0.0;\n    for(int i=ZERO; i<128; i++)\n    { \n        vec3  pos = ro + t*rd; \n        float nnd;\n        vec4  denGra = cloudsMap( pos, nnd ); \n        float den = denGra.x;\n        float dt = max(0.2,0.011*t);\n        \/\/dt *= hash1(px+float(i));\n        if( den>0.001 ) \n        { \n            float kk;\n            cloudsMap( pos+kSunDir*70.0, kk );\n            float sha = 1.0-smoothstep(-200.0,200.0,kk); sha *= 1.5;\n            \n            vec3 nor = normalize(denGra.yzw);\n            float dif = clamp( 0.4+0.6*dot(nor,kSunDir), 0.0, 1.0 )*sha; \n            float fre = clamp( 1.0+dot(nor,rd), 0.0, 1.0 )*sha;\n            float occ = 0.2+0.7*max(1.0-kk\/200.0,0.0) + 0.1*(1.0-den);\n            \/\/ lighting\n            vec3 lin  = vec3(0.0);\n                 lin += vec3(0.70,0.80,1.00)*1.0*(0.5+0.5*nor.y)*occ;\n                 lin += vec3(0.10,0.40,0.20)*1.0*(0.5-0.5*nor.y)*occ;\n                 lin += vec3(1.00,0.95,0.85)*3.0*dif*occ + 0.1;\n\n            \/\/ color\n            vec3 col = vec3(0.8,0.8,0.8)*0.45;\n\n            col *= lin;\n\n            col = fog( col, t );\n\n            \/\/ front to back blending    \n            float alp = clamp(den*0.5*0.125*dt,0.0,1.0);\n            col.rgb *= alp;\n            sum = sum + vec4(col,alp)*(1.0-sum.a);\n\n            thickness += dt*den;\n            if( lastT<0.0 ) lastT = t;            \n        }\n        else \n        {\n            dt = abs(den)+0.2;\n\n        }\n        t += dt;\n        if( sum.a>0.995 || t>tmax ) break;\n    }\n    \n    \/\/resT = min(resT, (150.0-ro.y)\/rd.y );\n    if( lastT>0.0 ) resT = min(resT,lastT);\n    \/\/if( lastT>0.0 ) resT = mix( resT, lastT, sum.w );\n    \n    \n    sum.xyz += max(0.0,1.0-0.0125*thickness)*vec3(1.00,0.60,0.40)*0.3*pow(clamp(dot(kSunDir,rd),0.0,1.0),32.0);\n\n    return clamp( sum, 0.0, 1.0 );\n}\n\n\n\/\/------------------------------------------------------------------------------------------\n\/\/ terrain\n\/\/------------------------------------------------------------------------------------------\n\nvec2 terrainMap( in vec2 p )\n{\n    float e = fbm_9( p\/2000.0 + vec2(1.0,-2.0) );\n    float a = 1.0-smoothstep( 0.12, 0.13, abs(e+0.12) ); \/\/ flag high-slope areas (-0.25, 0.0)\n    e = 600.0*e + 600.0;\n    \n    \/\/ cliff\n    e += 90.0*smoothstep( 552.0, 594.0, e );\n    \/\/e += 90.0*smoothstep( 550.0, 600.0, e );\n    \n    return vec2(e,a);\n}\n\nvec4 terrainMapD( in vec2 p )\n{\n    vec3 e = fbmd_9( p\/2000.0 + vec2(1.0,-2.0) );\n    e.x  = 600.0*e.x + 600.0;\n    e.yz = 600.0*e.yz;\n\n    \/\/ cliff\n    vec2 c = smoothstepd( 550.0, 600.0, e.x );\n\te.x  = e.x  + 90.0*c.x;\n\te.yz = e.yz + 90.0*c.y*e.yz;     \/\/ chain rule\n    \n    e.yz \/= 2000.0;\n    return vec4( e.x, normalize( vec3(-e.y,1.0,-e.z) ) );\n}\n\nvec3 terrainNormal( in vec2 pos )\n{\n#if 1\n    return terrainMapD(pos).yzw;\n#else    \n    vec2 e = vec2(0.03,0.0);\n\treturn normalize( vec3(terrainMap(pos-e.xy).x - terrainMap(pos+e.xy).x,\n                           2.0*e.x,\n                           terrainMap(pos-e.yx).x - terrainMap(pos+e.yx).x ) );\n#endif    \n}\n\nfloat terrainShadow( in vec3 ro, in vec3 rd, in float mint )\n{\n    float res = 1.0;\n    float t = mint;\n#ifdef LOWQUALITY\n    for( int i=ZERO; i<32; i++ )\n    {\n        vec3  pos = ro + t*rd;\n        vec2  env = terrainMap( pos.xz );\n        float hei = pos.y - env.x;\n        res = min( res, 32.0*hei\/t );\n        if( res<0.0001 || pos.y>kMaxHeight ) break;\n        t += clamp( hei, 2.0+t*0.1, 100.0 );\n    }\n#else\n    for( int i=ZERO; i<128; i++ )\n    {\n        vec3  pos = ro + t*rd;\n        vec2  env = terrainMap( pos.xz );\n        float hei = pos.y - env.x;\n        res = min( res, 32.0*hei\/t );\n        if( res<0.0001 || pos.y>kMaxHeight  ) break;\n        t += clamp( hei, 0.5+t*0.05, 25.0 );\n    }\n#endif\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec2 raymarchTerrain( in vec3 ro, in vec3 rd, float tmin, float tmax )\n{\n    \/\/ bounding plane\n    float tp = (kMaxHeight+kMaxTreeHeight-ro.y)\/rd.y;\n    if( tp>0.0 ) tmax = min( tmax, tp );\n    \n    \/\/ raymarch\n    float dis, th;\n    float t2 = -1.0;\n    float t = tmin; \n    float ot = t;\n    float odis = 0.0;\n    float odis2 = 0.0;\n    for( int i=ZERO; i<400; i++ )\n    {\n        th = 0.001*t;\n\n        vec3  pos = ro + t*rd;\n        vec2  env = terrainMap( pos.xz );\n        float hei = env.x;\n\n        \/\/ tree envelope\n        float dis2 = pos.y - (hei+kMaxTreeHeight*1.1);\n        if( dis2<th ) \n        {\n            if( t2<0.0 )\n            {\n                t2 = ot + (th-odis2)*(t-ot)\/(dis2-odis2); \/\/ linear interpolation for better accuracy\n            }\n        }\n        odis2 = dis2;\n        \n        \/\/ terrain\n        dis = pos.y - hei;\n        if( dis<th ) break;\n        \n        ot = t;\n        odis = dis;\n        t += dis*0.8*(1.0-0.75*env.y); \/\/ slow down in step areas\n        if( t>tmax ) break;\n    }\n\n    if( t>tmax ) t = -1.0;\n    else t = ot + (th-odis)*(t-ot)\/(dis-odis); \/\/ linear interpolation for better accuracy\n    \n    return vec2(t,t2);\n}\n\n\/\/------------------------------------------------------------------------------------------\n\/\/ trees\n\/\/------------------------------------------------------------------------------------------\n\nfloat treesMap( in vec3 p, in float rt, out float oHei, out float oMat, out float oDis )\n{\n    oHei = 1.0;\n    oDis = 0.0;\n    oMat = 0.0;\n        \n    float base = terrainMap(p.xz).x; \n    \n    float bb = fbm_4(p.xz*0.075);\n\n    float d = 20.0;\n    vec2 n = floor( p.xz\/2.0 );\n    vec2 f = fract( p.xz\/2.0 );\n    for( int j=0; j<=1; j++ )\n    for( int i=0; i<=1; i++ )\n    {\n        vec2  g = vec2( float(i), float(j) ) - step(f,vec2(0.5));\n        vec2  o = hash2( n + g );\n        vec2  v = hash2( n + g + vec2(13.1,71.7) );\n        vec2  r = g - f + o;\n\n        float height = kMaxTreeHeight * (0.4+0.8*v.x);\n        float width = 0.5 + 0.2*v.x + 0.3*v.y;\n\n        if( bb<0.0 ) width *= 0.5; else height *= 0.7;\n        \n        vec3  q = vec3(r.x,p.y-base-height*0.5,r.y);\n        \n        float k = sdEllipsoidY( q, vec2(width,0.5*height) );\n\n        if( k<d )\n        { \n            d = k;\n            oMat = 0.5*hash1(n+g+111.0);\n            if( bb>0.0 ) oMat += 0.5;\n            oHei = (p.y - base)\/height;\n            oHei *= 0.5 + 0.5*length(q) \/ width;\n        }\n    }\n\n    \/\/ distort ellipsoids to make them look like trees (works only in the distance really)\n    if( rt<1200.0 )\n    {\n        p.y -= 600.0;\n        float s = fbm_4( p*3.0 );\n        s = s*s;\n        float att = 1.0-smoothstep(100.0,1200.0,rt);\n        d += 4.0*s*att;\n        oDis = s*att;\n    }\n    \n    return d;\n}\n\nfloat treesShadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.02;\n#ifdef LOWQUALITY\n    for( int i=ZERO; i<64; i++ )\n    {\n        float kk1, kk2, kk3;\n        vec3 pos = ro + rd*t;\n        float h = treesMap( pos, t, kk1, kk2, kk3 );\n        res = min( res, 32.0*h\/t );\n        t += h;\n        if( res<0.001 || t>50.0 || pos.y>kMaxHeight+kMaxTreeHeight ) break;\n    }\n#else\n    for( int i=ZERO; i<150; i++ )\n    {\n        float kk1, kk2, kk3;\n        float h = treesMap( ro + rd*t, t, kk1, kk2, kk3 );\n        res = min( res, 32.0*h\/t );\n        t += h;\n        if( res<0.001 || t>120.0 ) break;\n    }\n#endif\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 treesNormal( in vec3 pos, in float t )\n{\n    float kk1, kk2, kk3;\n#if 0    \n    const float eps = 0.005;\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*treesMap( pos + e.xyy, t, kk1, kk2, kk3 ) + \n                      e.yyx*treesMap( pos + e.yyx, t, kk1, kk2, kk3 ) + \n                      e.yxy*treesMap( pos + e.yxy, t, kk1, kk2, kk3 ) + \n                      e.xxx*treesMap( pos + e.xxx, t, kk1, kk2, kk3 ) );            \n#else\n    \/\/ inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*treesMap(pos+0.005*e, t, kk1, kk2, kk3);\n    }\n    return normalize(n);\n#endif    \n}\n\n\/\/------------------------------------------------------------------------------------------\n\/\/ sky\n\/\/------------------------------------------------------------------------------------------\n\nvec3 renderSky( in vec3 ro, in vec3 rd )\n{\n    \/\/ background sky     \n    \/\/vec3 col = vec3(0.45,0.6,0.85)\/0.85 - rd.y*vec3(0.4,0.36,0.4);\n    \/\/vec3 col = vec3(0.4,0.6,1.1) - rd.y*0.4;\n    vec3 col = vec3(0.42,0.62,1.1) - rd.y*0.4;\n\n    \/\/ clouds\n    float t = (2500.0-ro.y)\/rd.y;\n    if( t>0.0 )\n    {\n        vec2 uv = (ro+t*rd).xz;\n        float cl = fbm_9( uv*0.00104 );\n        float dl = smoothstep(-0.2,0.6,cl);\n        col = mix( col, vec3(1.0), 0.12*dl );\n    }\n    \n\t\/\/ sun glare    \n    float sun = clamp( dot(kSunDir,rd), 0.0, 1.0 );\n    col += 0.2*vec3(1.0,0.6,0.3)*pow( sun, 32.0 );\n    \n\treturn col;\n}\n\n\/\/------------------------------------------------------------------------------------------\n\/\/ main image making function\n\/\/------------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o = hash2( vec2(iFrame,1) ) - 0.5;\n    \n    vec2 p = (2.0*(fragCoord+o)-iResolution.xy)\/ iResolution.y;\n    \n    \/\/----------------------------------\n    \/\/ setup\n    \/\/----------------------------------\n\n    \/\/ camera\n    float time = iTime;\n    vec3 ro = vec3(0.0, 401.5, 6.0);\n    vec3 ta = vec3(0.0, 403.5, -90.0 + ro.z );\n    \n    \/\/ro += vec3(10.0*sin(0.02*time),0.0,-10.0*sin(0.2+0.031*time))\n    \n    ro.x -= 80.0*sin(0.01*time);\n    ta.x -= 86.0*sin(0.01*time);\n\n    \/\/ ray\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    vec3 rd = ca * normalize( vec3(p,1.5));\n\n\tfloat resT = 2000.0;\n\n    \/\/----------------------------------\n    \/\/ sky\n    \/\/----------------------------------\n\n    vec3 col = renderSky( ro, rd );\n\n\n    \/\/----------------------------------\n    \/\/ raycast terrain and tree envelope\n    \/\/----------------------------------\n    {\n    const float tmax = 2000.0;\n    int   obj = 0;\n    vec2 t = raymarchTerrain( ro, rd, 15.0, tmax );\n    if( t.x>0.0 )\n    {\n        resT = t.x;\n        obj = 1;\n    }\n\n    \/\/----------------------------------\n    \/\/ raycast trees, if needed\n    \/\/----------------------------------\n    float hei, mid, displa;\n    \n    if( t.y>0.0 )\n    {\n        float tf = t.y;\n        float tfMax = (t.x>0.0)?t.x:tmax;\n        for(int i=ZERO; i<64; i++) \n        { \n            vec3  pos = ro + tf*rd; \n            float dis = treesMap( pos, tf, hei, mid, displa); \n            if( dis<(0.000125*tf) ) break;\n            tf += dis;\n            if( tf>tfMax ) break;\n        }\n        if( tf<tfMax )\n        {\n            resT = tf;\n            obj = 2;\n        }\n    }\n\n    \/\/----------------------------------\n    \/\/ shade\n    \/\/----------------------------------\n    if( obj>0 )\n    {\n        vec3 pos  = ro + resT*rd;\n        vec3 epos = pos + vec3(0.0,4.8,0.0);\n\n        float sha1  = terrainShadow( pos+vec3(0,0.02,0), kSunDir, 0.02 );\n        \/\/sha1 *= smoothstep(-0.3,0.0,cloudsShadowFlat(epos, kSunDir));\n        sha1 *= smoothstep(-0.325,-0.075,cloudsShadowFlat(epos, kSunDir));\n        \n        #ifndef LOWQUALITY\n        float sha2  = treesShadow( pos+vec3(0,0.02,0), kSunDir );\n        #endif\n\n        vec3 tnor = terrainNormal( pos.xz );\n        vec3 nor;\n        \n        vec3 speC = vec3(1.0);\n        \/\/----------------------------------\n        \/\/ terrain\n        \/\/----------------------------------\n        if( obj==1 )\n        {\n            \/\/ bump map\n            nor = normalize( tnor + 0.8*(1.0-abs(tnor.y))*0.8*fbmd_7( (pos-vec3(0,600,0))*0.15*vec3(1.0,0.2,1.0) ).yzw );\n\n            col = vec3(0.18,0.12,0.10)*.85;\n\n            col = 1.0*mix( col, vec3(0.1,0.1,0.0)*0.2, smoothstep(0.7,0.9,nor.y) );      \n            float dif = clamp( dot( nor, kSunDir), 0.0, 1.0 ); \n            dif *= sha1;\n            #ifndef LOWQUALITY\n            dif *= sha2;\n            #endif\n\n            float bac = clamp( dot(normalize(vec3(-kSunDir.x,0.0,-kSunDir.z)),nor), 0.0, 1.0 );\n            float foc = clamp( (pos.y\/2.0-180.0)\/130.0, 0.0,1.0);\n            float dom = clamp( 0.5 + 0.5*nor.y, 0.0, 1.0 );\n            vec3  lin  = 1.0*0.2*mix(0.1*vec3(0.1,0.2,0.1),vec3(0.7,0.9,1.5)*3.0,dom)*foc;\n                  lin += 1.0*8.5*vec3(1.0,0.9,0.8)*dif;        \n                  lin += 1.0*0.27*vec3(1.1,1.0,0.9)*bac*foc;\n            speC = vec3(4.0)*dif*smoothstep(20.0,0.0,abs(pos.y\/2.0-310.0)-20.0);\n\n            col *= lin;\n        }\n        \/\/----------------------------------\n        \/\/ trees\n        \/\/----------------------------------\n        else \/\/if( obj==2 )\n        {\n            vec3 gnor = treesNormal( pos, resT );\n            \n            nor = normalize( gnor + 2.0*tnor );\n\n            \/\/ --- lighting ---\n            vec3  ref = reflect(rd,nor);\n            float occ = clamp(hei,0.0,1.0) * pow(1.0-2.0*displa,3.0);\n            float dif = clamp( 0.1 + 0.9*dot( nor, kSunDir), 0.0, 1.0 ); \n            dif *= sha1;\n            if( dif>0.0001 )\n            {\n                float a = clamp( 0.5+0.5*dot(tnor,kSunDir), 0.0, 1.0);\n                a = a*a;\n                a *= occ;\n                a *= 0.6;\n                a *= smoothstep(60.0,200.0,resT);\n                \/\/ tree shadows with fake transmission\n                #ifdef LOWQUALITY\n                float sha2  = treesShadow( pos+kSunDir*0.1, kSunDir );\n                #endif\n                dif *= a+(1.0-a)*sha2;\n            }\n            float dom = clamp( 0.5 + 0.5*nor.y, 0.0, 1.0 );\n            float bac = clamp( 0.5+0.5*dot(normalize(vec3(-kSunDir.x,0.0,-kSunDir.z)),nor), 0.0, 1.0 );                 \n            float fre = clamp(1.0+dot(nor,rd),0.0,1.0);\n            \/\/float spe = pow( clamp(dot(ref,kSunDir),0.0, 1.0), 9.0 )*dif*(0.2+0.8*pow(fre,5.0))*occ;\n\n            \/\/ --- lights ---\n            vec3 lin  = 12.0*vec3(1.2,1.0,0.7)*dif*occ*(2.5-1.5*smoothstep(0.0,120.0,resT));\n                 lin += 0.55*mix(0.1*vec3(0.1,0.2,0.0),vec3(0.6,1.0,1.0),dom*occ);\n                 lin += 0.07*vec3(1.0,1.0,0.9)*bac*occ;\n                 lin += 1.10*vec3(0.9,1.0,0.8)*pow(fre,5.0)*occ*(1.0-smoothstep(100.0,200.0,resT));\n            speC = dif*vec3(1.0,1.1,1.5)*1.2;\n\n            \/\/ --- material ---\n            float brownAreas = fbm_4( pos.zx*0.015 );\n            col = vec3(0.2,0.2,0.05);\n            col = mix( col, vec3(0.32,0.2,0.05), smoothstep(0.2,0.9,fract(2.0*mid)) );\n            col *= (mid<0.5)?0.65+0.35*smoothstep(300.0,600.0,resT)*smoothstep(700.0,500.0,pos.y):1.0;\n            col = mix( col, vec3(0.25,0.16,0.01)*0.825, 0.7*smoothstep(0.1,0.3,brownAreas)*smoothstep(0.5,0.8,tnor.y) );\n            col *= 1.0-0.5*smoothstep(400.0,700.0,pos.y);\n            col *= lin;\n        }\n\n        \/\/ spec\n        vec3  ref = reflect(rd,nor);            \n        float fre = clamp(1.0+dot(nor,rd),0.0,1.0);\n        float spe = 3.0*pow( clamp(dot(ref,kSunDir),0.0, 1.0), 9.0 )*(0.05+0.95*pow(fre,5.0));\n        col += spe*speC;\n\n        col = fog(col,resT);\n    }\n    }\n\n\n\n    float isCloud = 0.0;\n    \/\/----------------------------------\n    \/\/ clouds\n    \/\/----------------------------------\n    {\n        vec4 res = renderClouds( ro, rd, 0.0, resT, resT, fragCoord );\n        col = col*(1.0-res.w) + res.xyz;\n        isCloud = res.w;\n    }\n\n    \/\/----------------------------------\n    \/\/ final\n    \/\/----------------------------------\n    \n    \/\/ sun glare    \n    float sun = clamp( dot(kSunDir,rd), 0.0, 1.0 );\n    col += 0.25*vec3(0.8,0.4,0.2)*pow( sun, 4.0 );\n \n\n    \/\/ gamma\n    \/\/col = sqrt( clamp(col,0.0,1.0) );\n    col = pow( clamp(col*1.1-0.02,0.0,1.0), vec3(0.4545) );\n\n    \/\/ contrast\n    col = col*col*(3.0-2.0*col);            \n    \n    \/\/ color grade    \n    col = pow( col, vec3(1.0,0.92,1.0) );   \/\/ soft green\n    col *= vec3(1.02,0.99,0.9 );            \/\/ tint red\n    col.z = col.z+0.1;                      \/\/ bias blue\n    \n    \/\/------------------------------------------\n\t\/\/ reproject from previous frame and average\n    \/\/------------------------------------------\n\n    mat4 oldCam = mat4( textureLod(iChannel0,vec2(0.5,0.5)\/iResolution.xy, 0.0),\n                        textureLod(iChannel0,vec2(1.5,0.5)\/iResolution.xy, 0.0),\n                        textureLod(iChannel0,vec2(2.5,0.5)\/iResolution.xy, 0.0),\n                        0.0, 0.0, 0.0, 1.0 );\n    \n    \/\/ world space\n    vec4 wpos = vec4(ro + rd*resT,1.0);\n    \/\/ camera space\n    vec3 cpos = (wpos*oldCam).xyz; \/\/ note inverse multiply\n    \/\/ ndc space\n    vec2 npos = 1.5 * cpos.xy \/ cpos.z;\n    \/\/ screen space\n    vec2 spos = 0.5 + 0.5*npos*vec2(iResolution.y\/iResolution.x,1.0);\n    \/\/ undo dither\n    spos -= o\/iResolution.xy;\n\t\/\/ raster space\n    vec2 rpos = spos * iResolution.xy;\n    \n    if( rpos.y<1.0 && rpos.x<3.0 )\n    {\n    }\n\telse\n    {\n        vec3 ocol = textureLod( iChannel0, spos, 0.0 ).xyz;\n    \tif( iFrame==0 ) ocol = col;\n        col = mix( ocol, col, 0.1+0.8*isCloud );\n    }\n\n    \/\/----------------------------------\n                           \n\tif( fragCoord.y<1.0 && fragCoord.x<3.0 )\n    {\n        if( abs(fragCoord.x-2.5)<0.5 ) fragColor = vec4( ca[2], -dot(ca[2],ro) );\n        if( abs(fragCoord.x-1.5)<0.5 ) fragColor = vec4( ca[1], -dot(ca[1],ro) );\n        if( abs(fragCoord.x-0.5)<0.5 ) fragColor = vec4( ca[0], -dot(ca[0],ro) );\n    }\n    else\n    {\n        fragColor = vec4( col, 1.0 );\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"MdX3Rr","date":"1360495251","viewed":193104,"name":"Elevated","username":"iq","description":"A raymarched version of the demo Elevated from 2009.","likes":854,"published":3,"flags":32,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Copyright Inigo Quilez, 2013 - https:\/\/iquilezles.org\/\n\/\/ I am the sole copyright owner of this Work.\n\/\/ You cannot host, display, distribute or share this Work in any form,\n\/\/ including physical and digital. You cannot use this Work in any\n\/\/ commercial or non-commercial product, website or project. You cannot\n\/\/ sell this Work and you cannot mint an NFTs of it.\n\/\/ I share this Work for educational purposes, and you can link to it,\n\/\/ through an URL, proper attribution and unmodified screenshot, as part\n\/\/ of your educational material. If these conditions are too restrictive\n\/\/ please contact me and we'll definitely work it out.\n\n\n\/\/ on the derivatives based noise: https:\/\/iquilezles.org\/articles\/morenoise\n\/\/ on the soft shadow technique: https:\/\/iquilezles.org\/articles\/rmshadows\n\/\/ on the fog calculations: https:\/\/iquilezles.org\/articles\/fog\n\/\/ on the lighting: https:\/\/iquilezles.org\/articles\/outdoorslighting\n\/\/ on the raymarching: https:\/\/iquilezles.org\/articles\/terrainmarching\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord\/iResolution.xy;\n    vec4 data = texture( iChannel0, uv );\n\n    vec3 col = vec3(0.0);\n    if( data.w < 0.0 )\n    {\n        col = data.xyz;\n    }\n    else\n    {\n        \/\/ decompress velocity vector\n        float ss = mod(data.w,1024.0)\/1023.0;\n        float st = floor(data.w\/1024.0)\/1023.0;\n\n        \/\/ motion blur (linear blur across velocity vectors\n        vec2 dir = (-1.0 + 2.0*vec2( ss, st ))*0.25;\n        col = vec3(0.0);\n        for( int i=0; i<32; i++ )\n        {\n            float h = float(i)\/31.0;\n            vec2 pos = uv + dir*h;\n            col += texture( iChannel0, pos ).xyz;\n        }\n        col \/= 32.0;\n    }\n    \n    \/\/ vignetting\t\n\tcol *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 );\n\n    col = clamp(col,0.0,1.0);\n    col = col*0.6 + 0.4*col*col*(3.0-2.0*col) + vec3(0.0,0.0,0.04);\n    \n\n    \n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"\/media\/a\/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"\/media\/ap\/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ Copyright Inigo Quilez, 2016 - https:\/\/iquilezles.org\/\n\/\/ I am the sole copyright owner of this Work.\n\/\/ You cannot host, display, distribute or share this Work in any form,\n\/\/ including physical and digital. You cannot use this Work in any\n\/\/ commercial or non-commercial product, website or project. You cannot\n\/\/ sell this Work and you cannot mint an NFTs of it.\n\/\/ I share this Work for educational purposes, and you can link to it,\n\/\/ through an URL, proper attribution and unmodified screenshot, as part\n\/\/ of your educational material. If these conditions are too restrictive\n\/\/ please contact me and we'll definitely work it out.\n\n\/\/ on the derivatives based noise: https:\/\/iquilezles.org\/articles\/morenoise\n\/\/ on the soft shadow technique: https:\/\/iquilezles.org\/articles\/rmshadows\n\/\/ on the fog calculations: https:\/\/iquilezles.org\/articles\/fog\n\/\/ on the lighting: https:\/\/iquilezles.org\/articles\/outdoorslighting\n\/\/ on the raymarching: https:\/\/iquilezles.org\/articles\/terrainmarching\n\n\n#define AA 1   \/\/ make this 2 or even 3 if you have a really powerful GPU\n\n#define USE_SMOOTH_NOISE 0   \/\/ enable to prevent discontinuities\n\n#define SC (250.0)\n\n\/\/ value noise, and its analytical derivatives\nvec3 noised( in vec2 x )\n{\n    vec2 f = fract(x);\n    #if USE_SMOOTH_NOISE==0\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n    #else\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n    #endif\n\n#if 1\n    \/\/ texel fetch version\n    ivec2 p = ivec2(floor(x));\n    float a = texelFetch( iChannel0, (p+ivec2(0,0))&255, 0 ).x;\n\tfloat b = texelFetch( iChannel0, (p+ivec2(1,0))&255, 0 ).x;\n\tfloat c = texelFetch( iChannel0, (p+ivec2(0,1))&255, 0 ).x;\n\tfloat d = texelFetch( iChannel0, (p+ivec2(1,1))&255, 0 ).x;\n#else    \n    \/\/ texture version    \n    vec2 p = floor(x);\n\tfloat a = textureLod( iChannel0, (p+vec2(0.5,0.5))\/256.0, 0.0 ).x;\n\tfloat b = textureLod( iChannel0, (p+vec2(1.5,0.5))\/256.0, 0.0 ).x;\n\tfloat c = textureLod( iChannel0, (p+vec2(0.5,1.5))\/256.0, 0.0 ).x;\n\tfloat d = textureLod( iChannel0, (p+vec2(1.5,1.5))\/256.0, 0.0 ).x;\n#endif\n    \n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\tdu*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\nconst mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\n\n\nfloat terrainH( in vec2 x )\n{\n\tvec2  p = x*0.003\/SC;\n    float a = 0.0;\n    float b = 1.0;\n\tvec2  d = vec2(0.0);\n    for( int i=0; i<16; i++ )\n    {\n        vec3 n = noised(p);\n        d += n.yz;\n        a += b*n.x\/(1.0+dot(d,d));\n\t\tb *= 0.5;\n        p = m2*p*2.0;\n    }\n\n    #if USE_SMOOTH_NOISE==1\n    a *= 0.9;\n    #endif\n\treturn SC*120.0*a;\n}\n\nfloat terrainM( in vec2 x )\n{\n\tvec2  p = x*0.003\/SC;\n    float a = 0.0;\n    float b = 1.0;\n\tvec2  d = vec2(0.0);\n    for( int i=0; i<9; i++ )\n    {\n        vec3 n = noised(p);\n        d += n.yz;\n        a += b*n.x\/(1.0+dot(d,d));\n\t\tb *= 0.5;\n        p = m2*p*2.0;\n    }\n    #if USE_SMOOTH_NOISE==1\n    a *= 0.9;\n    #endif\n\treturn SC*120.0*a;\n}\n\nfloat terrainL( in vec2 x )\n{\n\tvec2  p = x*0.003\/SC;\n    float a = 0.0;\n    float b = 1.0;\n\tvec2  d = vec2(0.0);\n    for( int i=0; i<3; i++ )\n    {\n        vec3 n = noised(p);\n        d += n.yz;\n        a += b*n.x\/(1.0+dot(d,d));\n\t\tb *= 0.5;\n        p = m2*p*2.0;\n    }\n    #if USE_SMOOTH_NOISE==1\n    a *= 0.9;\n    #endif\n\treturn SC*120.0*a;\n}\n\nfloat raycast( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\n{\n    float t = tmin;\n\tfor( int i=0; i<300; i++ )\n\t{\n        vec3 pos = ro + t*rd;\n\t\tfloat h = pos.y - terrainM( pos.xz );\n\t\tif( abs(h)<(0.0015*t) || t>tmax ) break;\n\t\tt += 0.4*h;\n\t}\n\n\treturn t;\n}\n\nfloat softShadow(in vec3 ro, in vec3 rd, float dis )\n{\n    float minStep = clamp(dis*0.01,SC*0.5,SC*50.0);\n\n    float res = 1.0;\n    float t = 0.001;\n\tfor( int i=0; i<80; i++ )\n\t{\n\t    vec3  p = ro + t*rd;\n        float h = p.y - terrainM( p.xz );\n\t\tres = min( res, 16.0*h\/t );\n\t\tt += max(minStep,h);\n\t\tif( res<0.001 ||p.y>(SC*200.0) ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos, float t )\n{\n    vec2  eps = vec2( 0.001*t, 0.0 );\n    return normalize( vec3( terrainH(pos.xz-eps.xy) - terrainH(pos.xz+eps.xy),\n                            2.0*eps.x,\n                            terrainH(pos.xz-eps.yx) - terrainH(pos.xz+eps.yx) ) );\n}\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*texture( iChannel0, p\/256.0 ).x; p = m2*p*2.02;\n    f += 0.2500*texture( iChannel0, p\/256.0 ).x; p = m2*p*2.03;\n    f += 0.1250*texture( iChannel0, p\/256.0 ).x; p = m2*p*2.01;\n    f += 0.0625*texture( iChannel0, p\/256.0 ).x;\n    return f\/0.9375;\n}\n\nconst float kMaxT = 5000.0*SC;\n\nvec4 render( in vec3 ro, in vec3 rd )\n{\n    vec3 light1 = normalize( vec3(-0.8,0.4,-0.3) );\n    \/\/ bounding plane\n    float tmin = 1.0;\n    float tmax = kMaxT;\n#if 1\n    float maxh = 250.0*SC;\n    float tp = (maxh-ro.y)\/rd.y;\n    if( tp>0.0 )\n    {\n        if( ro.y>maxh ) tmin = max( tmin, tp );\n        else            tmax = min( tmax, tp );\n    }\n#endif\n\tfloat sundot = clamp(dot(rd,light1),0.0,1.0);\n\tvec3 col;\n    float t = raycast( ro, rd, tmin, tmax );\n    if( t>tmax)\n    {\n        \/\/ sky\t\t\n        col = vec3(0.3,0.5,0.85) - rd.y*rd.y*0.5;\n        col = mix( col, 0.85*vec3(0.7,0.75,0.85), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n        \/\/ sun\n\t\tcol += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n\t\tcol += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n\t\tcol += 0.2*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );\n        \/\/ clouds\n\t\tvec2 sc = ro.xz + rd.xz*(SC*1000.0-ro.y)\/rd.y;\n\t\tcol = mix( col, vec3(1.0,0.95,1.0), 0.5*smoothstep(0.5,0.8,fbm(0.0005*sc\/SC)) );\n        \/\/ horizon\n        col = mix( col, 0.68*vec3(0.4,0.65,1.0), pow( 1.0-max(rd.y,0.0), 16.0 ) );\n        t = -1.0;\n\t}\n\telse\n\t{\n        \/\/ mountains\t\t\n\t\tvec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, t );\n        \/\/nor = normalize( nor + 0.5*( vec3(-1.0,0.0,-1.0) + vec3(2.0,1.0,2.0)*texture(iChannel1,0.01*pos.xz).xyz) );\n        vec3 ref = reflect( rd, nor );\n        float fre = clamp( 1.0+dot(rd,nor), 0.0, 1.0 );\n        vec3 hal = normalize(light1-rd);\n        \n        \/\/ rock\n\t\tfloat r = texture( iChannel0, (7.0\/SC)*pos.xz\/256.0 ).x;\n        col = (r*0.25+0.75)*0.9*mix( vec3(0.08,0.05,0.03), vec3(0.10,0.09,0.08), \n                                     texture(iChannel0,0.00007*vec2(pos.x,pos.y*48.0)\/SC).x );\n\t\tcol = mix( col, 0.20*vec3(0.45,.30,0.15)*(0.50+0.50*r),smoothstep(0.70,0.9,nor.y) );\n        \n        \n        col = mix( col, 0.15*vec3(0.30,.30,0.10)*(0.25+0.75*r),smoothstep(0.95,1.0,nor.y) );\n\t\tcol *= 0.1+1.8*sqrt(fbm(pos.xz*0.04)*fbm(pos.xz*0.005));\n\n\t\t\/\/ snow\n\t\tfloat h = smoothstep(55.0,80.0,pos.y\/SC + 25.0*fbm(0.01*pos.xz\/SC) );\n        float e = smoothstep(1.0-0.5*h,1.0-0.1*h,nor.y);\n        float o = 0.3 + 0.7*smoothstep(0.0,0.1,nor.x+h*h);\n        float s = h*e*o;\n        col = mix( col, 0.29*vec3(0.62,0.65,0.7), smoothstep( 0.1, 0.9, s ) );\n\t\t\n         \/\/ lighting\t\t\n        float amb = clamp(0.5+0.5*nor.y,0.0,1.0);\n\t\tfloat dif = clamp( dot( light1, nor ), 0.0, 1.0 );\n\t\tfloat bac = clamp( 0.2 + 0.8*dot( normalize( vec3(-light1.x, 0.0, light1.z ) ), nor ), 0.0, 1.0 );\n\t\tfloat sh = 1.0; if( dif>=0.0001 ) sh = softShadow(pos+light1*SC*0.05,light1,t);\n\t\t\n\t\tvec3 lin  = vec3(0.0);\n\t\tlin += dif*vec3(8.00,5.00,3.00)*1.3*vec3( sh, sh*sh*0.5+0.5*sh, sh*sh*0.8+0.2*sh );\n\t\tlin += amb*vec3(0.40,0.60,1.00)*1.2;\n        lin += bac*vec3(0.40,0.50,0.60);\n\t\tcol *= lin;\n        \n        col += (0.7+0.3*s)*(0.04+0.96*pow(clamp(1.0+dot(hal,rd),0.0,1.0),5.0))*\n               vec3(7.0,5.0,3.0)*dif*sh*\n               pow( clamp(dot(nor,hal), 0.0, 1.0),16.0);\n        \n        col += s*0.65*pow(fre,4.0)*vec3(0.3,0.5,0.6)*smoothstep(0.0,0.6,ref.y);\n\n        \/\/col = col*3.0\/(1.5+col);\n        \n\t\t\/\/ fog\n        float fo = 1.0-exp(-pow(0.001*t\/SC,1.5) );\n        vec3 fco = 0.65*vec3(0.4,0.65,1.0);\/\/ + 0.1*vec3(1.0,0.8,0.5)*pow( sundot, 4.0 );\n        col = mix( col, fco, fo );\n\n\t}\n    \/\/ sun scatter\n    col += 0.3*vec3(1.0,0.7,0.3)*pow( sundot, 8.0 );\n\n    \/\/ gamma\n\tcol = sqrt(col);\n    \n\treturn vec4( col, t );\n}\n\nvec3 camPath( float time )\n{\n\treturn SC*1100.0*vec3( cos(0.0+0.23*time), 0.0, cos(1.5+0.21*time) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, in float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid moveCamera( float time, out vec3 oRo, out vec3 oTa, out float oCr, out float oFl )\n{\n\tvec3 ro = camPath( time );\n\tvec3 ta = camPath( time + 3.0 );\n\tro.y = terrainL( ro.xz ) + 22.0*SC;\n\tta.y = ro.y - 20.0*SC;\n\tfloat cr = 0.2*cos(0.1*time);\n    oRo = ro;\n    oTa = ta;\n    oCr = cr;\n    oFl = 3.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*0.1 - 0.1 + 0.3 + 4.0*iMouse.x\/iResolution.x;\n\n    \/\/ camera position\n    vec3 ro, ta; float cr, fl;\n    moveCamera( time, ro, ta, cr, fl );\n\n    \/\/ camera2world transform    \n    mat3 cam = setCamera( ro, ta, cr );\n\n    \/\/ pixel\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)\/iResolution.y;\n\n    float t = kMaxT;\n    vec3 tot = vec3(0.0);\n\t#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        \/\/ pixel coordinates\n        vec2 o = vec2(float(m),float(n)) \/ float(AA) - 0.5;\n        vec2 s = (-iResolution.xy + 2.0*(fragCoord+o))\/iResolution.y;\n\t#else    \n        vec2 s = p;\n\t#endif\n\n        \/\/ camera ray    \n        vec3 rd = cam * normalize(vec3(s,fl));\n\n        vec4 res = render( ro, rd );\n        t = min( t, res.w );\n \n        tot += res.xyz;\n\t#if AA>1\n    }\n    tot \/= float(AA*AA);\n\t#endif\n\n\n    \/\/-------------------------------------\n\t\/\/ velocity vectors (through depth reprojection)\n    \/\/-------------------------------------\n    float vel = 0.0;\n    if( t<0.0 )\n    {\n        vel = -1.0;\n    }\n    else\n    {\n\n        \/\/ old camera position\n        float oldTime = time - 0.1 * 1.0\/24.0; \/\/ 1\/24 of a second blur\n        vec3 oldRo, oldTa; float oldCr, oldFl;\n        moveCamera( oldTime, oldRo, oldTa, oldCr, oldFl );\n        mat3 oldCam = setCamera( oldRo, oldTa, oldCr );\n\n        \/\/ world space\n        #if AA>1\n        vec3 rd = cam * normalize(vec3(p,fl));\n        #endif\n        vec3 wpos = ro + rd*t;\n        \/\/ camera space\n        vec3 cpos = vec3( dot( wpos - oldRo, oldCam[0] ),\n                          dot( wpos - oldRo, oldCam[1] ),\n                          dot( wpos - oldRo, oldCam[2] ) );\n        \/\/ ndc space\n        vec2 npos = oldFl * cpos.xy \/ cpos.z;\n        \/\/ screen space\n        vec2 spos = 0.5 + 0.5*npos*vec2(iResolution.y\/iResolution.x,1.0);\n\n\n        \/\/ compress velocity vector in a single float\n        vec2 uv = fragCoord\/iResolution.xy;\n        spos = clamp( 0.5 + 0.5*(spos - uv)\/0.25, 0.0, 1.0 );\n        vel = floor(spos.x*1023.0) + floor(spos.y*1023.0)*1024.0;\n    }\n    \n    fragColor = vec4( tot, vel );\n}","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"XsX3RB","date":"1372830991","viewed":172786,"name":"Volcanic","username":"iq","description":"An alien volcanic landscape. It started as an experiment on 2d-texture based 3d noise. But then I played with the noise shape, the added some shading, put lighting in it, etc..., until I got this.","likes":672,"published":3,"flags":32,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Copyright Inigo Quilez, 2013 - https:\/\/iquilezles.org\/\n\/\/ I am the sole copyright owner of this Work.\n\/\/ You cannot host, display, distribute or share this Work in any form,\n\/\/ including physical and digital. You cannot use this Work in any\n\/\/ commercial or non-commercial product, website or project. You cannot\n\/\/ sell this Work and you cannot mint an NFTs of it.\n\/\/ I share this Work for educational purposes, and you can link to it,\n\/\/ through an URL, proper attribution and unmodified screenshot, as part\n\/\/ of your educational material. If these conditions are too restrictive\n\/\/ please contact me and we'll definitely work it out.\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord\/iResolution.xy;\n    vec4 data = textureLod( iChannel0, uv, 0.0 );\n\n    vec3 col = vec3(0.0);\n    \n    if( data.w < 0.0 )\n    {\n        col = textureLod( iChannel0, uv, 0.0 ).xyz;\n    }\n    else\n    {\n        \/\/ decompress velocity vector\n        float ss =   mod(data.w,1024.0)\/1023.0;\n        float st = floor(data.w\/1024.0)\/1023.0;\n\n        \/\/ motion blur (linear blur across velocity vectors)\n        vec2 dir = (2.0*vec2(ss,st)-1.0)*0.25;\n        float tot = 0.0;\n        for( int i=0; i<32; i++ )\n        {\n            float h = float(i)\/31.0;\n            vec2  p = uv + dir*h;\n            float w = 1.0-h;\n            col += w*textureLod( iChannel0, p, 0.0 ).xyz;\n            tot += w;\n        }\n        col \/= tot;\n    }\n\n    \/\/ vignetting\t\n\tcol *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 );\n\n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sfGRn","filepath":"\/media\/a\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"\/media\/ap\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3Rn","filepath":"\/media\/a\/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"\/media\/ap\/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/#define HIGH_QUALITY_NOISE\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n#ifndef HIGH_QUALITY_NOISE\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)\/256.0, 0.0 ).yx;\n#else\n\tvec2 uv  = (p.xy+vec2(37.0,17.0)*p.z);\n\tvec2 rg1 = textureLod( iChannel0, (uv+ vec2(0.5,0.5))\/256.0, 0.0 ).yx;\n\tvec2 rg2 = textureLod( iChannel0, (uv+ vec2(1.5,0.5))\/256.0, 0.0 ).yx;\n\tvec2 rg3 = textureLod( iChannel0, (uv+ vec2(0.5,1.5))\/256.0, 0.0 ).yx;\n\tvec2 rg4 = textureLod( iChannel0, (uv+ vec2(1.5,1.5))\/256.0, 0.0 ).yx;\n\tvec2 rg  = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\n#endif\t\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\n\treturn textureLod( iChannel0, (uv+118.4)\/256.0, 0.0 ).x;\n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nfloat fbm4( in vec3 q )\n{\n    float f  = 0.5000*noise( q ); q = m*q*2.02;\n          f += 0.2500*noise( q ); q = m*q*2.03;\n          f += 0.1250*noise( q ); q = m*q*2.01;\n          f += 0.0625*noise( q );\n    return f;\n}\n    \nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n )\n{\n\treturn texture( sam, p.yz )*abs(n.x) +\n           texture( sam, p.zx )*abs(n.y) +\n           texture( sam, p.xy )*abs(n.z);\n}\n\n\/\/=====================================================================\n\nfloat lava( in vec2 p )\n{\n\tp += vec2(2.0,4.0);\n    float f  = 0.5000*noise( p ); p = p*2.02;\n          f += 0.2500*noise( p ); p = p*2.03;\n          f += 0.1250*noise( p ); p = p*2.01;\n          f += 0.0625*noise( p );\n    return f;\n}\n\nfloat displacement( in vec3 p )\n{\n    float dis = textureLod( iChannel2, p.xz, 0.0 ).x;\n    return fbm4(p+vec3(1.0,0.0,0.8)) - dis*0.01;\n}\n\nfloat mapTerrain( in vec3 pos )\n{\n\treturn pos.y*0.1 + (displacement(pos*vec3(0.8,1.0,0.8)) - 0.4)*(1.0-smoothstep(1.0,3.0,pos.y));\n}\n\nfloat raymarchTerrain( in vec3 ro, in vec3 rd )\n{\n    \/\/ bounding plane\n    const float hmax = 1.9;\n    float tp = (hmax-ro.y)\/rd.y;\n    float tmax = (tp<0.0)?30.0:tp;\n\n    \/\/ raymarch\n    float t = 0.1;\n    for( int i=0; i<350; i++ )\n    {\n\t    float h = mapTerrain( ro+rd*t );\n        if( abs(h)<(0.00025*t) || t>tmax ) break;\n        t += h*0.8;\n    }\n    return (t>tmax) ? -1.0 : t;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/rmshadows\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    \/\/ bounding plane\n    const float hmax = 1.9;\n    float tp = (hmax-ro.y)\/rd.y;\n    float tmax = (tp<0.0)?30.0:tp;\n\n    \/\/ raymarch\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<100; i++ )\n    {\n        float h = mapTerrain(ro + rd*t);\n        res = min( res, k*max(h,0.0)\/t );\n        t += clamp( h, 0.01, 0.4 );\n\t\tif( res<0.001 || t>tmax ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/normalsSDF\nvec3 calcNormal( in vec3 pos, in float t )\n{\n    float eps = max(0.02,0.001*t);\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*mapTerrain(pos+e.xyy) + \n\t\t\t\t\t  e.yyx*mapTerrain(pos+e.yyx) + \n\t\t\t\t\t  e.yxy*mapTerrain(pos+e.yxy) + \n\t\t\t\t\t  e.xxx*mapTerrain(pos+e.xxx) );\n}\n\nconst vec3 lig = normalize( vec3(-0.3,0.4,0.7) );\n\nvec4 mapClouds( in vec3 pos )\n{\n\tvec3 q = pos*0.5 + vec3(0.0,-iTime,0.0);\n\t\n\tfloat d = clamp( fbm4(q)-0.55, 0.0, 1.0 );\n\td *= smoothstep( 0.5, 0.55, lava(0.1*pos.xz)+0.01 );\n\t\n\tvec4 res = vec4( d );\n\tres.xyz  = 0.25*mix( vec3(1.0,0.8,0.7), 0.2*vec3(0.4,0.4,0.4), d );\n\tres.xyz *= 0.5 + 0.5*smoothstep(-2.0, 1.0, pos.y);\n\treturn res;\n}\n\nvec4 raymarchClouds( in vec3 ro, in vec3 rd, in vec3 bcol, float tmax, in vec2 px )\n{\n\tvec4 sum = vec4( 0.0 );\n\tfloat sun = pow( clamp( dot(rd,lig), 0.0, 1.0 ), 6.0 );\n\tfloat t = texture(iChannel0,px\/256.0).x*0.1;\n\tfor( int i=0; i<60; i++ )\n\t{\n\t\tvec4 col = mapClouds( ro + t*rd );\n\t\t\n        col.xyz += vec3(1.0,0.7,0.4)*0.4*sun*(1.0-col.w);\n\t\tcol.xyz = mix( col.xyz, bcol, 1.0-exp(-0.00006*t*t*t) );\n        col.a *= 2.0;\n\t\tcol.rgb *= col.a;\n\t\tsum = sum + col*(1.0 - sum.a);\t\n\n\t\tt += max(0.1,0.05*t);\n\t\tif( t>tmax || sum.w>0.95 ) break;\n\t}\n\tsum.xyz \/= (0.001+sum.w);\n\treturn clamp( sum, 0.0, 1.0 );\n}\n\nvec3 path( float time )\n{\n\treturn vec3( 16.0*cos(0.2+0.075*time), 1.5, 16.0*sin(0.1+0.0825*time) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid moveCamera( in float time, out vec3 oRo, out vec3 oTa, out float oCr, out float oFl )\n{\n    oFl = 2.1;\n    oCr = 0.3*sin(1.0+0.07*time);\n    oRo = path( time+0.0 );\n    oTa = path( time+1.6 );\n\toTa.y *= 0.35 + 0.25*sin(0.09*time);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)\/iResolution.y;\n\t\n    \/\/ camera\t\n\tfloat off = step( 0.001, iMouse.z )*6.0*iMouse.x\/iResolution.x;\n    float time = 3.4 + iTime + off;\n    vec3 ro, ta; float cr, fl;\n    moveCamera( time, ro, ta, cr, fl );\n    \n\t\/\/ camera2world transform\n    mat3 cam = setCamera( ro, ta, cr );\n\n    \/\/ ray    \n    vec3 rd = cam * normalize(vec3(p.xy,fl));\n\n    \/\/ sky\t \n    vec3  col = vec3(0.36,0.43,0.54) - rd.y*0.5;\n    float sun = clamp( dot(rd,lig), 0.0, 1.0 );\n\tcol += vec3(1.0,0.8,0.4)*0.24*pow( sun, 6.0 );\n\n\tvec3 bcol = col;\n    \n    \/\/ terrain\t\n\tfloat t = raymarchTerrain(ro, rd);\n    float st = t;\n    if( t>0.0 )\n\t{\n\t\tvec3 pos = ro + t*rd;\n\t\tvec3 nor = calcNormal( pos, t );\n\t\tvec3 ref = reflect( rd, nor );\n\t\t\n        \/\/ lighting\n\t\tfloat hhh = 1.0 - smoothstep(-2.0, 1.0, pos.y);\n\t\tfloat sun = clamp( dot( nor, lig ), 0.0, 1.0 );\n\t\tfloat sha = 0.0; if( sun>0.01) sha=softshadow(pos,lig,0.001,32.0);\n\t\tfloat bac = clamp( dot( nor, normalize(lig*vec3(-1.0,0.0,-1.0)) ), 0.0, 1.0 );\n\t\tfloat sky = 0.5 + 0.5*nor.y;\n        float lav = smoothstep( 0.5, 0.55, lava(0.1*pos.xz) )*hhh*clamp(0.5-0.5*nor.y,0.0,1.0);\n\t\tfloat occ = pow( (1.0-displacement(pos*vec3(0.8,1.0,0.8)))*1.6-0.5, 2.0 );\n\t\tfloat amb = 1.0;\n        float fre = 1.0+dot(nor,rd); fre = fre*fre;\n\n\t\tvec3 lin = vec3(0.0);\n\t\tlin += 1.3*sun*vec3(1.80,1.27,0.99)*pow(vec3(sha),vec3(1.0,1.2,1.5));\n\t\tlin += 1.0*sky*vec3(0.16,0.20,0.40)*occ;\n\t\tlin += 1.0*bac*vec3(0.40,0.28,0.20)*occ;\n\t\tlin += 1.0*amb*vec3(0.15,0.17,0.20)*occ;\n\t\tlin += lav*vec3(3.00,0.61,0.00);\n\n        \/\/ surface shading\/material\t\t\n        vec3 te = texcube( iChannel1, 0.5*pos, nor ).xyz;\n\t\tcol = te;\n\t\tcol = col*(0.2+0.8*texcube( iChannel2, 4.0*vec3(2.0,8.0,2.0)*pos, nor ).x);\n\n\t\tvec3 lava = vec3(1.0,0.9,0.2);\n\t\tlava *= texture( iChannel2, pos.xz ).xyz;\n\t\tcol = mix( col, 0.8*lava, hhh );\n\t\t\n\t\tvec3 verde = vec3(0.2,0.2,0.05);\n\t\tverde *= 0.2+1.6*texture( iChannel1, 7.1*pos.xz ).xyz;\n\t\tverde += 0.1*texture( iChannel1, 1.0*pos.xz ).xyz;\n        verde *= 1.0+fre*fre;\n\t\tcol = mix( col, verde, smoothstep(0.0, 0.8, nor.y)*smoothstep(0.0, 0.1, pos.y-0.8 ) );\n\t\t\n\t\tcol = lin * col;\n\n        \/\/ sun spec\n        vec3 hal = normalize(lig-rd);\n        col += (te.x*te.x)*vec3(11.0,8.0,5.0)*sun*sha*\n               pow( clamp(dot(nor,hal),0.0,1.0), 8.0 ) *\n               (0.04+0.96*pow(clamp(1.0+dot(hal,rd),0.0,1.0),5.0));\n            \n\t\t\/\/ atmospheric\n        vec3 ext = exp2(-t*t*0.001*vec3(0.5,1.0,2.0) );\n        col = col*ext + 0.6*(1.0-ext)*(1.0-0.7*hhh);\n    }\n\n    \/\/ sun glow\n    col += vec3(1.0,0.6,0.2)*0.2*sun*sun*clamp( (rd.y+0.4)\/(0.0+0.4),0.0,1.0);\n\t\n    \/\/ smoke\t\n    vec4 res = raymarchClouds( ro, rd, bcol, (t<0.0)?600.0:t, fragCoord );\n\tcol = mix( col, res.xyz, res.w );\n\n    \/\/ gain\n    col *= 1.6\/(1.0+col);\n    col *= vec3(1.02,1.04,1.0);\n\n    \/\/ gamma\t\n\tcol = pow( clamp( col, 0.0, 1.0 ), vec3(0.45) );\n\n    \/\/ contrast, desat, tint and vignetting\t\n\tcol = col*col*(3.0-2.0*col);\n\tcol = mix( col, vec3(col.x+col.y+col.z)*0.33, 0.2 );\n      \n    \/\/-------------------------------------\n\t\/\/ velocity vectors\n    \/\/-------------------------------------\n    float vel = -1.0;\n    if( st>0.0 )\n    {\n        \/\/ old camera position\n        float oldTime = time - 1.0\/30.0; \/\/ 1\/30 of a second blur\n        vec3 oldRo, oldTa; float oldCr, oldFl;\n        moveCamera( oldTime, oldRo, oldTa, oldCr, oldFl );\n        mat3 oldCam = setCamera( oldRo, oldTa, oldCr );\n        \/\/ world space\n        vec3 wpos = ro + rd*st;\n        \/\/ camera space\n        vec3 cpos = vec3( dot( wpos - oldRo, oldCam[0] ),\n                          dot( wpos - oldRo, oldCam[1] ),\n                          dot( wpos - oldRo, oldCam[2] ) );\n        \/\/ ndc space\n        vec2 npos = oldFl * cpos.xy \/ cpos.z;\n        \/\/ screen space\n        vec2 spos = 0.5 + 0.5*npos*vec2(iResolution.y\/iResolution.x,1.0);\n        \/\/ compress velocity vector in a single float\n        vec2 uv = fragCoord\/iResolution.xy;\n        spos = clamp( 0.5 + 0.5*(spos - uv)\/0.25, 0.0, 1.0 );\n        vel = floor(spos.x*1023.0) + floor(spos.y*1023.0)*1024.0;\n    }\n\n    fragColor = vec4( col, vel );\n}","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"XsyGWV","date":"1458155905","viewed":37309,"name":"Sirenian Dawn","username":"nimitz","description":"Experiments in raymarched terrain rendering.","likes":629,"published":1,"flags":32,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Sirenian Dawn by nimitz (twitter: @stormoid)\n\/\/ https:\/\/www.shadertoy.com\/view\/XsyGWV\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\/\/ Contact the author for other licensing options\n\n\/*\n\tSee: https:\/\/en.wikipedia.org\/wiki\/Terra_Sirenum\n\n\tThings of interest in this shader:\n\t\t-A technique I call \"relaxation marching\", see march() function\n\t\t-A buffer based technique for anti-alisaing\n\t\t-Cheap and smooth procedural starfield\n\t\t-Non-constant fog from iq\n\t\t-Completely faked atmosphere :)\n\t\t-Terrain based on noise derivatives\n*\/\n\n\/*\n\tMore about the antialiasing:\n\t\tThe fragments with high enough iteration count\/distance ratio \n\t\tget blended with the past frame, I tried a few different \n\t\tinput for the blend trigger: distance delta, color delta, \n\t\tnormal delta, scene curvature.  But none of them provides \n\t\tgood enough info about the problem areas to allow for proper\n\t\tantialiasing without making the whole scene blurry.\n\t\t\n\t\tOn the other hand iteration count (modulated by a power\n\t\tof distance) does a pretty good job without requiring to\n\t\tstore past frame info in the alpha channel (which can then\n\t\tbe used for something else, nothing in this case)\n\n*\/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4(texture(iChannel0, fragCoord.xy\/iResolution.xy).rgb, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"\/media\/a\/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"\/media\/ap\/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/Sirenian Dawn by nimitz (twitter: @stormoid)\n\/\/ https:\/\/www.shadertoy.com\/view\/XsyGWV\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define ITR 90\n#define FAR 400.\n#define time iTime\n\nconst vec3 lgt = vec3(-.523, .41, -.747);\nmat2 m2 = mat2( 0.80,  0.60, -0.60,  0.80 );\n\n\/\/form iq, see: https:\/\/iquilezles.org\/articles\/morenoise\nvec3 noised( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    vec2 u = f*f*(3.0-2.0*f);\n\tfloat a = textureLod(iChannel0,(p+vec2(0.5,0.5))\/256.0,0.0).x;\n\tfloat b = textureLod(iChannel0,(p+vec2(1.5,0.5))\/256.0,0.0).x;\n\tfloat c = textureLod(iChannel0,(p+vec2(0.5,1.5))\/256.0,0.0).x;\n\tfloat d = textureLod(iChannel0,(p+vec2(1.5,1.5))\/256.0,0.0).x;\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\t6.0*f*(1.0-f)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\nfloat terrain( in vec2 p)\n{\n    float rz = 0.;\n    float z = 1.;\n\tvec2  d = vec2(0.0);\n    float scl = 2.95;\n    float zscl = -.4;\n    float zz = 5.;\n    for( int i=0; i<5; i++ )\n    {\n        vec3 n = noised(p);\n        d += pow(abs(n.yz),vec2(zz));\n        d -= smoothstep(-.5,1.5,n.yz);\n        zz -= 1.;\n        rz += z*n.x\/(dot(d,d)+.85);\n        z *= zscl;\n        zscl *= .8;\n        p = m2*p*scl;\n    }\n    \n    rz \/= smoothstep(1.5,-.5,rz)+.75;\n    return rz;\n}\n\nfloat map(vec3 p)\n{\n    return p.y-(terrain(p.zx*0.07))*2.7-1.;\n}\n\n\/*\tThe idea is simple, as the ray gets further from the eye, I increase \n\tthe step size of the raymarching and lower the target precision, \n\tthis allows for better performance with virtually no loss in visual quality. *\/\nfloat march(in vec3 ro, in vec3 rd, out float itrc)\n{\n    float t = 0.;\n    float d = map(rd*t+ro);\n    float precis = 0.0001;\n    for (int i=0;i<=ITR;i++)\n    {\n        if (abs(d) < precis || t > FAR) break;\n        precis = t*0.0001;\n        float rl = max(t*0.02,1.);\n        t += d*rl;\n        d = map(rd*t+ro)*0.7;\n        itrc++;\n    }\n\n    return t;\n}\n\nvec3 rotx(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n\nvec3 roty(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(c*p.x + s*p.z, p.y, -s*p.x + c*p.z);\n}\n\nvec3 rotz(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nvec3 normal(in vec3 p, in float ds)\n{  \n    vec2 e = vec2(-1., 1.)*0.0005*pow(ds,1.);\n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\nfloat noise(in vec2 x){return texture(iChannel0, x*.01).x;}\nfloat fbm(in vec2 p)\n{\t\n\tfloat z=.5;\n\tfloat rz = 0.;\n\tfor (float i= 0.;i<3.;i++ )\n\t{\n        rz+= (sin(noise(p)*5.)*0.5+0.5) *z;\n\t\tz *= 0.5;\n\t\tp = p*2.;\n\t}\n\treturn rz;\n}\n\nfloat bnoise(in vec2 p){ return fbm(p*3.); }\nvec3 bump(in vec3 p, in vec3 n, in float ds)\n{\n    vec2 e = vec2(0.005*ds,0);\n    float n0 = bnoise(p.zx);\n    vec3 d = vec3(bnoise(p.zx+e.xy)-n0, 1., bnoise(p.zx+e.yx)-n0)\/e.x*0.025;\n    d -= n*dot(n,d);\n    n = normalize(n-d);\n    return n;\n}\n\nfloat curv(in vec3 p, in float w)\n{\n    vec2 e = vec2(-1., 1.)*w;   \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    return .15\/e.y *(t1 + t2 + t3 + t4 - 4. * map(p));\n}\n\n\/\/Based on: https:\/\/iquilezles.org\/articles\/fog\nvec3 fog(vec3 ro, vec3 rd, vec3 col, float ds)\n{\n    vec3 pos = ro + rd*ds;\n    float mx = (fbm(pos.zx*0.1-time*0.05)-0.5)*.2;\n    \n    const float b= 1.;\n    float den = 0.3*exp(-ro.y*b)*(1.0-exp( -ds*rd.y*b ))\/rd.y;\n    float sdt = max(dot(rd, lgt), 0.);\n    vec3  fogColor  = mix(vec3(0.5,0.2,0.15)*1.2, vec3(1.1,0.6,0.45)*1.3, pow(sdt,2.0)+mx*0.5);\n    return mix( col, fogColor, clamp(den + mx,0.,1.) );\n}\n\nfloat linstep(in float mn, in float mx, in float x){\n\treturn clamp((x - mn)\/(mx - mn), 0., 1.);\n}\n\n\/\/Complete hack, but looks good enough :)\nvec3 scatter(vec3 ro, vec3 rd)\n{   \n    float sd= max(dot(lgt, rd)*0.5+0.5,0.);\n    float dtp = 13.-(ro + rd*(FAR)).y*3.5;\n    float hori = (linstep(-1500., 0.0, dtp) - linstep(11., 500., dtp))*1.;\n    hori *= pow(sd,.04);\n    \n    vec3 col = vec3(0);\n    col += pow(hori, 200.)*vec3(1.0, 0.7,  0.5)*3.;\n    col += pow(hori, 25.)* vec3(1.0, 0.5,  0.25)*.3;\n    col += pow(hori, 7.)* vec3(1.0, 0.4, 0.25)*.8;\n    \n    return col;\n}\n\nvec3 nmzHash33(vec3 q)\n{\n    uvec3 p = uvec3(ivec3(q));\n    p = p*uvec3(374761393U, 1103515245U, 668265263U) + p.zxy + p.yzx;\n    p = p.yzx*(p.zxy^(p >> 3U));\n    return vec3(p^(p >> 16U))*(1.0\/vec3(0xffffffffU));\n}\n\n\/\/Very happy with this star function, cheap and smooth\nvec3 stars(in vec3 p)\n{\n    vec3 c = vec3(0.);\n    float res = iResolution.x*0.8;\n    \n\tfor (float i=0.;i<3.;i++)\n    {\n        vec3 q = fract(p*(.15*res))-0.5;\n        vec3 id = floor(p*(.15*res));\n        vec2 rn = nmzHash33(id).xy;\n        float c2 = 1.-smoothstep(0.,.6,length(q));\n        c2 *= step(rn.x,.0005+i*i*0.001);\n        c += c2*(mix(vec3(1.0,0.49,0.1),vec3(0.75,0.9,1.),rn.y)*0.25+0.75);\n        p *= 1.4;\n    }\n    return c*c*.7;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 q = fragCoord.xy \/ iResolution.xy;\n    vec2 p = q - 0.5;\n\tp.x*=iResolution.x\/iResolution.y;\n\tvec2 mo = iMouse.xy \/ iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(-.2,0.3):mo;\n    mo.x *= 1.2;\n    mo -= vec2(1.2,-0.1);\n\tmo.x *= iResolution.x\/iResolution.y;\n    mo.x += sin(time*0.15)*0.2;\n\t\n    vec3 ro = vec3(650., sin(time*0.2)*0.25+10.,-time);\n    vec3 eye = normalize(vec3(cos(mo.x),-0.5+mo.y,sin(mo.x)));\n    vec3 right = normalize(vec3(cos(mo.x+1.5708),0.,sin(mo.x+1.5708)));\n    vec3 up = normalize(cross(right, eye));\n\tvec3 rd = normalize((p.x*right + p.y*up)*1.05 + eye);\n    rd.y += abs(p.x*p.x*0.015);\n    rd = normalize(rd);\n\t\n    float count = 0.;\n\tfloat rz = march(ro,rd, count);\n    \n    vec3 scatt = scatter(ro, rd);\n    \n    vec3 bg = stars(rd)*(1.0-clamp(dot(scatt, vec3(1.3)),0.,1.));\n    vec3 col = bg;\n    \n    vec3 pos = ro+rz*rd;\n    vec3 nor= normal( pos, rz );\n    if ( rz < FAR )\n    {\n        nor = bump(pos,nor,rz);\n        float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lgt ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lgt.x,0.0,-lgt.z))), 0.0, 1.0 );\n        float spe = pow(clamp( dot( reflect(rd,nor), lgt ), 0.0, 1.0 ),500.);\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        vec3 brdf = 1.*amb*vec3(0.10,0.11,0.12);\n        brdf += bac*vec3(0.15,0.05,0.04);\n        brdf += 2.3*dif*vec3(.9,0.4,0.25);\n        col = vec3(0.25,0.25,0.3);\n        float crv = curv(pos, 2.)*1.;\n        float crv2 = curv(pos, .4)*2.5;\n        \n        col += clamp(crv*0.9,-1.,1.)*vec3(0.25,.6,.5);\n        col = col*brdf + col*spe*.1 +.1*fre*col;\n        col *= crv*1.+1.;\n        col *= crv2*1.+1.;\n    }\n\t\n    col = fog(ro, rd, col, rz);\n    col = mix(col,bg,smoothstep(FAR-150., FAR, rz));\n    col += scatt;\n    \n    col = pow( col, vec3(0.93,1.0,1.0) );\n    col = mix(col, smoothstep(0.,1.,col), 0.2);\n    col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1)*0.9+0.1;\n    \n    vec4 past = texture(iChannel1, q);\n    float tOver = clamp(iTimeDelta-(1.\/60.),0.,1.);\n    \n    \/\/if (count\/pow(rz, 0.65) > 3.3) col = mix(col, past.rgb, clamp(1.0-iResolution.x*0.0003,0.,1.));\n    if (count\/pow(rz, 0.65) > 3.3) col = mix(col, past.rgb, clamp(0.85-iTimeDelta*7.,0.,1.));\n    \n\tfragColor = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"WsSBzh","date":"1606524984","viewed":124578,"name":"Selfie Girl","username":"iq","description":"A raymarched procedural SDF - a girl taking a selfie, this time. Making of video here: [url]https:\/\/www.youtube.com\/watch?v=8--5LwHRhjk[\/url]","likes":495,"published":3,"flags":32,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"\/media\/a\/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"\/media\/ap\/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"\/media\/a\/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"\/media\/ap\/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Copyright Inigo Quilez, 2020 - https:\/\/iquilezles.org\/\n\/\/ I am the sole copyright owner of this Work.\n\/\/ You cannot host, display, distribute or share this Work in any form,\n\/\/ including physical and digital. You cannot use this Work in any\n\/\/ commercial or non-commercial product, website or project. You cannot\n\/\/ sell this Work and you cannot mint an NFTs of it.\n\/\/ I share this Work for educational purposes, and you can link to it,\n\/\/ through an URL, proper attribution and unmodified screenshot, as part\n\/\/ of your educational material. If these conditions are too restrictive\n\/\/ please contact me and we'll definitely work it out.\n\n\n\/\/ Source code of the mathematical painting \"Selfie Girl\".\n\/\/ Making-of video on Youtube:\n\/\/\n\/\/ https:\/\/www.youtube.com\/watch?v=8--5LwHRhjk\n\n\/\/ The image is a single formula, but I had to split it\n\/\/ down into 3 passes here so it could be shared without\n\/\/ breaking the WebGL implementation of the web browsers\n\/\/ (which is what Shadertoy uses to run the code below\n\/\/ that implements the formula).\n\n\/\/ This \"Image\" tab in particular renders the girl through\n\/\/ raymarching and then performs the final composition with\n\/\/ the background, which is computed in \"Buffer B\" (open\n\/\/ the rest of the tabs to see explanations of what each\n\/\/ one does). For the rendering\/computer graphics people - \n\/\/ there's no TAA in this pass because I didn't want to\n\/\/ compute velocity vectors for the animation, so things\n\/\/ alias a bit (feel free to change the AA define below to\n\/\/ 2 if you have a fast GPU)\n\n#define AA 1\n\n\n\/\/ This SDF is really 6 braids at once (through domain\n\/\/ repetition) with three strands each (brute forced)\nvec4 sdHair( vec3 p, vec3 pa, vec3 pb, vec3 pc, float an, out vec2 occ_id) \n{\n    vec4 b = sdBezier(p, pa,pb,pc );\n    vec2 q = rot(b.zw,an);\n  \t\n    vec2 id2 = round(q\/0.1);\n    id2 = clamp(id2,vec2(0),vec2(2,1));\n    q -= 0.1*id2;\n\n    float id = 11.0*id2.x + id2.y*13.0;\n\n    q += smoothstep(0.5,0.8,b.y)*0.02*vec2(0.4,1.5)*cos( 23.0*b.y + id*vec2(13,17));\n\n    occ_id.x = clamp(length(q)*8.0-0.2,0.0,1.0);\n    vec4 res = vec4(99,q,b.y);\n    for( int i=0; i<3; i++ )\n    {\n        vec2 tmp = q + 0.01*cos( id + 180.0*b.y + vec2(2*i,6-2*i));\n        float lt = length(tmp)-0.02;\n        if( lt<res.x )\n        { \n            occ_id.y = id+float(i); \n            res.x = lt; \n            res.yz = tmp;\n        }\n    }\n    return res;\n}\n\n\/\/ The SDF for the hoodie and jacket. It's a very distorted\n\/\/ ellipsoid, torus section, a segment and a sphere.\nvec4 sdHoodie( in vec3 pos )\n{\n    vec3 opos = pos;\n\n    pos.x   += 0.09*sin(3.5*pos.y-0.5)*sin(    pos.z) + 0.015;\n    pos.xyz += 0.03*sin(2.0*pos.y)*sin(7.0*pos.zyx);\n    \n    \/\/ hoodie\n    vec3 hos = pos-vec3(0.0,-0.33,0.15);\n    hos.x -= 0.031*smoothstep(0.0,1.0,opos.y+0.33);\n    hos.yz = rot(hos.yz,0.9);\n    float d1 = sdEllipsoid(hos,vec3(0.96-pos.y*0.1,1.23,1.5));\n\tfloat d2 = 0.95*pos.z-0.312*pos.y-0.9;\n    float d = max(opOnion(d1,0.01), d2 );\n    \n    \/\/ shoulders\n    vec3 sos = vec3( abs(pos.x), pos.yz );    \n    vec2 se = sdSegment(sos, vec3(0.18,-1.6,-0.3), vec3(1.1,-1.9,0.0) );\n    d = smin(d,se.x-mix(0.25,0.43,se.y),0.4);\n    d = smin(d,sdSphere(sos-vec3(0.3,-2.2,0.4), 0.5 ),0.2);\n\n    \/\/ neck\n    opos.x -= 0.02*sin(9.0*opos.y);\n    vec4 w = opElongate( opos-vec3(0.0,-1.2,0.3), vec3(0.0,0.3,0.0) );\n    d = smin(d,\n             w.w+sdCappedTorus(vec3(w.xy,-w.z),vec2(0.6,-0.8),0.6,0.02),\n             0.1);\n    \n    \/\/ bumps\n    d += 0.004*sin(pos.x*90.0)*sin(pos.y*90.0)*sin(pos.z*90.0);\n    d -= 0.002*sin(pos.x*300.0);\n    d -= 0.02*(1.0-smoothstep(0.0,0.04,abs(opOnion(pos.x,1.1))));\n    \n    \/\/ border\n    d = min(d,length(vec2(d1,d2))-0.015);\n    \n    return vec4(d,pos);\n}\n\n\/\/ moves the head (and hair and hoodie). This could be done\n\/\/ more efficiently (with a single matrix or quaternion),\n\/\/ but this code was optimized for editing, not for runtime\nvec3 moveHead( in vec3 pos, in vec3 an, in float amount)\n{\n    pos.y -= -1.0;\n    pos.xz = rot(pos.xz,amount*an.x);\n    pos.xy = rot(pos.xy,amount*an.y);\n    pos.yz = rot(pos.yz,amount*an.z);\n    pos.y += -1.0;\n    return pos;\n}\n\n\/\/ the animation state\nvec3 animData; \/\/ { blink, nose follow up, mouth } \nvec3 animHead; \/\/ { head rotation angles }\n\n\/\/ SDF of the girl. It is not as efficient as it should, \n\/\/ both in terms of performance and euclideanness of the\n\/\/ returned distance. Among other things I tweaked the\n\/\/ overal shape of the head though scaling right in the\n\/\/ middle of the design process (see 1.02 and 1.04 numbers\n\/\/ below). I should have backpropagated those adjustements\n\/\/ to the  primitives themselves, but I didn't and now it's\n\/\/ too late. So, I am paying some cost there.\n\/\/\n\/\/ She is modeled to camera (her face's shape looks bad\n\/\/ from other perspectives. She's made of five ellipsoids\n\/\/ blended together for the face, a cone and three spheres\n\/\/ for the nose, a torus for the teeh and two quadratic \n\/\/ curves for the lips. The neck is a cylinder, the hair\n\/\/ is made of three quadratic curves that are repeated\n\/\/ multiple times through domain repetition and each of\n\/\/ them contains three more curves in order to make the\n\/\/ braids. The hoodie is an ellipsoid deformed with\n\/\/ two sine waves and cut in half, the neck is an elongated\n\/\/ torus section and the shoulders are capsules.\n\/\/\nvec4 map( in vec3 pos, in float time, out float outMat, out vec3 uvw )\n{\n    outMat = 1.0;\n\n    vec3 oriPos = pos;\n    \n    \/\/ head deformation and transformation\n    pos.y \/= 1.04;\n    vec3 opos;\n    opos = moveHead( pos, animHead, smoothstep(-1.2, 0.2,pos.y) );\n    pos  = moveHead( pos, animHead, smoothstep(-1.4,-1.0,pos.y) );\n    pos.x *= 1.04;\n    pos.y \/= 1.02;\n    uvw = pos;\n\n    \/\/ symmetric coord systems (sharp, and smooth)\n    vec3 qos = vec3(abs(pos.x),pos.yz);\n    vec3 sos = vec3(sqrt(qos.x*qos.x+0.0005),pos.yz);\n    \n    \/\/ head\n    float d = sdEllipsoid( pos-vec3(0.0,0.05,0.07), vec3(0.8,0.75,0.85) );\n    \n    \/\/ jaw\n    vec3 mos = pos-vec3(0.0,-0.38,0.35); mos.yz = rot(mos.yz,0.4);\n\tmos.yz = rot(mos.yz,0.1*animData.z);\n\tfloat d2 = sdEllipsoid(mos-vec3(0,-0.17,0.16),\n                 vec3(0.66+sclamp(mos.y*0.9-0.1*mos.z,-0.3,0.4),\n                 \t  0.43+sclamp(mos.y*0.5,-0.5,0.2),\n                      0.50+sclamp(mos.y*0.3,-0.45,0.5)));\n        \n    \/\/ mouth hole\n    d2 = smax(d2,-sdEllipsoid(mos-vec3(0,0.06,0.6+0.05*animData.z), vec3(0.16,0.035+0.05*animData.z,0.1)),0.01);\n    \n    \/\/ lower lip    \n    vec4 b = sdBezier(vec3(abs(mos.x),mos.yz), \n                      vec3(0,0.01,0.61),\n                      vec3(0.094+0.01*animData.z,0.015,0.61),\n                      vec3(0.18-0.02*animData.z,0.06+animData.z*0.05,0.57-0.006*animData.z));\n    float isLip = smoothstep(0.045,0.04,b.x+b.y*0.03);\n    d2 = smin(d2,b.x - 0.027*(1.0-b.y*b.y)*smoothstep(1.0,0.4,b.y),0.02);\n    d = smin(d,d2,0.19);\n\n    \/\/ chicks\n    d = smin(d,sdSphere(qos-vec3(0.2,-0.33,0.62),0.28 ),0.04);\n    \n    \/\/ who needs ears\n    \n    \/\/ eye sockets\n    vec3 eos = sos-vec3(0.3,-0.04,0.7);\n    eos.xz = rot(eos.xz,-0.2);\n    eos.xy = rot(eos.xy,0.3);\n    eos.yz = rot(eos.yz,-0.2);\n    d2 = sdEllipsoid( eos-vec3(-0.05,-0.05,0.2), vec3(0.20,0.14-0.06*animData.x,0.1) );\n\td = smax( d, -d2, 0.15 );\n\n    eos = sos-vec3(0.32,-0.08,0.8);\n    eos.xz = rot(eos.xz,-0.4);\n    d2 = sdEllipsoid( eos, vec3(0.154,0.11,0.1) );\n    d = smax( d, -d2, 0.05 );\n\n    vec3 oos = qos - vec3(0.25,-0.06,0.42);\n    \n    \/\/ eyelid\n    d2 = sdSphere( oos, 0.4 );\n    oos.xz = rot(oos.xz, -0.2);\n    oos.xy = rot(oos.xy, 0.2);\n    vec3 tos = oos;        \n    oos.yz = rot(oos.yz,-0.6+0.58*animData.x);\n\n    \/\/eyebags\n    tos = tos-vec3(-0.02,0.06,0.2+0.02*animData.x);\n    tos.yz = rot(tos.yz,0.8);\n    tos.xy = rot(tos.xy,-0.2);\n\td = smin( d, sdTorus(tos,0.29,0.01), 0.03 );\n    \n    \/\/ eyelids\n    eos = qos - vec3(0.33,-0.07,0.53);\n    eos.xy = rot(eos.xy, 0.2);\n    eos.yz = rot(eos.yz,0.35-0.25*animData.x);\n    d2 = smax(d2-0.005, -max(oos.y+0.098,-eos.y-0.025), 0.02 );\n    d = smin( d, d2, 0.012 );\n\n\t\/\/ eyelashes\n\toos.x -= 0.01;\n    float xx = clamp( oos.x+0.17,0.0,1.0);\n    float ra = 0.35 + 0.1*sqrt(xx\/0.2)*(1.0-smoothstep(0.3,0.4,xx))*(0.6+0.4*sin(xx*256.0));\n    float rc = 0.18\/(1.0-0.7*smoothstep(0.15,0.5,animData.x));\n    oos.y -= -0.18 - (rc-0.18)\/1.8;\n    d2 = (1.0\/1.8)*sdArc( oos.xy*vec2(1.0,1.8), vec2(0.9,sqrt(1.0-0.9*0.9)), rc )-0.001;\n    float deyelashes = max(d2,length(oos.xz)-ra)-0.003;\n    \n    \/\/ nose\n    eos = pos-vec3(0.0,-0.079+animData.y*0.005,0.86);\n    eos.yz = rot(eos.yz,-0.23);\n    float h = smoothstep(0.0,0.26,-eos.y);\n    d2 = sdCone( eos-vec3(0.0,-0.02,0.0), vec2(0.03,-0.25) )-0.04*h-0.01;\n    eos.x = sqrt(eos.x*eos.x + 0.001);\n    d2 = smin( d2, sdSphere(eos-vec3(0.0, -0.25,0.037),0.06 ), 0.07 );\n    d2 = smin( d2, sdSphere(eos-vec3(0.1, -0.27,0.03 ),0.04 ), 0.07 );\n    d2 = smin( d2, sdSphere(eos-vec3(0.0, -0.32,0.05 ),0.025), 0.04 );        \n    d2 = smax( d2,-sdSphere(eos-vec3(0.07,-0.31,0.038),0.02 ), 0.035 );\n    d = smin(d,d2,0.05-0.03*h);\n    \n    \/\/ mouth\n    eos = pos-vec3(0.0,-0.38+animData.y*0.003+0.01*animData.z,0.71);\n    tos = eos-vec3(0.0,-0.13,0.06);\n    tos.yz = rot(tos.yz,0.2);\n    float dTeeth = sdTorus(tos,0.15,0.015);\n    eos.yz = rot(eos.yz,-0.5);\n    eos.x \/= 1.04;\n\n    \/\/ nose-to-upperlip connection\n    d2 = sdCone( eos-vec3(0,0,0.03), vec2(0.14,-0.2) )-0.03;\n    d2 = max(d2,-(eos.z-0.03));\n    d = smin(d,d2,0.05);\n\n    \/\/ upper lip\n    eos.x = abs(eos.x);\n    b = sdBezier(eos, vec3(0.00,-0.22,0.17),\n                      vec3(0.08,-0.22,0.17),\n                      vec3(0.17-0.02*animData.z,-0.24-0.01*animData.z,0.08));\n    d2 = length(b.zw\/vec2(0.5,1.0)) - 0.03*clamp(1.0-b.y*b.y,0.0,1.0);\n    d = smin(d,d2,0.02);\n    isLip = max(isLip,(smoothstep(0.03,0.005,abs(b.z+0.015+abs(eos.x)*0.04))\n                 -smoothstep(0.45,0.47,eos.x-eos.y*1.15)));\n\n    \/\/ valley under nose\n    vec2 se = sdSegment(pos, vec3(0.0,-0.45,1.01),  vec3(0.0,-0.47,1.09) );\n    d2 = se.x-0.03-0.06*se.y;\n    d = smax(d,-d2,0.04);\n    isLip *= smoothstep(0.01,0.03,d2);\n\n    \/\/ neck\n    se = sdSegment(pos, vec3(0.0,-0.65,0.0), vec3(0.0,-1.7,-0.1) );\n    d2 = se.x - 0.38;\n\n    \/\/ shoulders\n    se = sdSegment(sos, vec3(0.0,-1.55,0.0), vec3(0.6,-1.65,0.0) );\n    d2 = smin(d2,se.x-0.21,0.1);\n    d = smin(d,d2,0.4);\n        \n    \/\/ register eyelases now\n    vec4 res = vec4( d, isLip, 0, 0 );\n    if( deyelashes<res.x )\n    {\n        res.x = deyelashes*0.8;\n        res.yzw = vec3(0.0,1.0,0.0);\n    }\n    \/\/ register teeth now\n    if( dTeeth<res.x )\n    {\n        res.x = dTeeth;\n        outMat = 5.0;\n    }\n \n    \/\/ eyes\n\tpos.x \/=1.05;        \n    eos = qos-vec3(0.25,-0.06,0.42);\n    d2 = sdSphere(eos,0.4);\n    if( d2<res.x ) \n    { \n        res.x = d2;\n     \toutMat = 2.0;\n        uvw = pos;\n    }\n        \n    \/\/ hair\n    {\n        vec2 occ_id, tmp;\n\t\tqos = pos; qos.x=abs(pos.x);\n\n        vec4 pres = sdHair(pos,vec3(-0.3, 0.55,0.8), \n                               vec3( 0.95, 0.7,0.85), \n                               vec3( 0.4,-1.45,0.95),\n                               -0.9,occ_id);\n\n        vec4 pres2 = sdHair(pos,vec3(-0.4, 0.6,0.55), \n                                vec3(-1.0, 0.4,0.2), \n                                vec3(-0.6,-1.4,0.7),\n                                0.6,tmp);\n        if( pres2.x<pres.x ) { pres=pres2; occ_id=tmp;  occ_id.y+=40.0;}\n\n        pres2 = sdHair(qos,vec3( 0.4, 0.7,0.4), \n                           vec3( 1.0, 0.5,0.45), \n                           vec3( 0.4,-1.45,0.55),\n                           -0.2,tmp);\n        if( pres2.x<pres.x ) { pres=pres2; occ_id=tmp;  occ_id.y+=80.0;}\n    \n\n        pres.x *= 0.8;\n        if( pres.x<res.x )\n        {\n            res = vec4( pres.x, occ_id.y, 0.0, occ_id.x );\n            uvw = pres.yzw;\n            outMat = 4.0;\n        }\n    }\n\n    \/\/ hoodie\n    vec4 tmp = sdHoodie( opos );\n    if( tmp.x<res.x )\n    {\n        res.x = tmp.x;\n        outMat = 3.0;\n        uvw  = tmp.yzw;\n    }\n\n    return res;\n}\n\n\/\/ SDF of the girl again, but with extra high frequency\n\/\/ modeling detail. While the previous one is used for\n\/\/ raymarching and shadowing, this one is used for normal\n\/\/ computation. This separation is conceptually equivalent\n\/\/ to decoupling detail from base geometry with \"normal\n\/\/ maps\", but done in 3D and with SDFs, which is way\n\/\/ simpler and can be done corretly (something rarely seen\n\/\/ in 3D engines) without any complexity.\nvec4 mapD( in vec3 pos, in float time )\n{\n    float matID;\n    vec3 uvw;\n    vec4 h = map(pos, time, matID, uvw);\n    \n    if( matID<1.5 ) \/\/ skin\n    {\n        \/\/ pores\n        float d = fbm1(iChannel0,120.0*uvw);\n        h.x += 0.0015*d*d;\n    }\n    else if( matID>3.5 && matID<4.5 ) \/\/ hair\n    {\n        \/\/ some random displacement to evoke hairs\n        float te = texture( iChannel2,vec2( 0.25*atan(uvw.x,uvw.y),8.0*uvw.z) ).x;\n    \th.x -= 0.02*te;\n    }    \n    return h;\n}\n\n\/\/ Computes the normal of the girl's surface (the gradient\n\/\/ of the SDF). The implementation is weird because of the\n\/\/ technicalities of the WebGL API that forces us to do\n\/\/ some trick to prevent code unrolling. More info here:\n\/\/\n\/\/ https:\/\/iquilezles.org\/articles\/normalsSDF\n\/\/\nvec3 calcNormal( in vec3 pos, in float time )\n{\n    const float eps = 0.001;\n#if 0    \n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*eps,time,kk ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps,time,kk ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps,time,kk ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps,time,kk ).x );\n#else\n    vec4 n = vec4(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec4 s = vec4(pos, 0.0);\n        float kk; vec3 kk2;\n        s[i] += eps;\n        n[i] = mapD(s.xyz, time).x;\n      \/\/if( n.x+n.y+n.z+n.w>100.0 ) break;\n    }\n    return normalize(n.xyz-n.w);\n#endif   \n}\n\n\/\/ Compute soft shadows for a given light, with a single\n\/\/ ray insead of using montecarlo integration or shadowmap\n\/\/ blurring. More info here:\n\/\/\n\/\/ https:\/\/iquilezles.org\/articles\/rmshadows\n\/\/\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, in float time, float k )\n{\n    \/\/ first things first - let's do a bounding volume test\n    vec2 sph = iCylinderY( ro, rd, 1.5 );\n  \/\/vec2 sph = iConeY(ro-vec3(-0.05,3.7,0.35),rd,0.08);\n    tmax = min(tmax,sph.y);\n\n    \/\/ raymarch and track penumbra    \n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<128; i++ )\n    {\n        float kk; vec3 kk2;\n\t\tfloat h = map( ro + rd*t, time, kk, kk2 ).x;\n        res = min( res, k*h\/t );\n        t += clamp( h, 0.005, 0.1 );\n        if( res<0.002 || t>tmax ) break;\n    }\n    return max( res, 0.0 );\n}\n\n\/\/ Computes convexity for our girl SDF, which can be used\n\/\/ to approximate ambient occlusion. More info here:\n\/\/\n\/\/ https:\/\/iquilezles.org\/www\/material\/nvscene2008\/rwwtt.pdf\n\/\/\nfloat calcOcclusion( in vec3 pos, in vec3 nor, in float time )\n{\n    float kk; vec3 kk2;\n\tfloat ao = 0.0;\n    float off = textureLod(iChannel3,gl_FragCoord.xy\/256.0,0.0).x;\n    vec4 k = vec4(0.7012912,0.3941462,0.8294585,0.109841)+off;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tk = fract(k + H4);\n        vec3 ap = normalize(-1.0+2.0*k.xyz);\n        float h = k.w*0.1;\n        ap = (nor+ap)*h;\n        float d = map( pos+ap, time, kk, kk2 ).x;\n        ao += max(0.0,h-d);\n        if( ao>16.0 ) break;\n    }\n\tao \/= 16.0;\n    return clamp( 1.0-ao*24.0, 0.0, 1.0 );\n}\n\n\/\/ Computes the intersection point between our girl SDF and\n\/\/ a ray (coming form the camera in this case). It's a\n\/\/ traditional and basic\/uncomplicated SDF raymarcher. More\n\/\/ info here:\n\/\/\n\/\/ https:\/\/iquilezles.org\/www\/material\/nvscene2008\/rwwtt.pdf\n\/\/\nvec2 intersect( in vec3 ro, in vec3 rd, in float tmax, in float time, out vec3 cma, out vec3 uvw )\n{\n    cma = vec3(0.0);\n    uvw = vec3(0.0);\n    float matID = -1.0;\n\n    float t = 1.0;\n    \n    \/\/ bounding volume test first\n    vec2 sph = iCylinderY( ro, rd, 1.5 );\n  \/\/vec2 sph = iConeY(ro-vec3(-0.05,3.7,0.35),rd,0.08);\n    if( sph.y<0.0 ) return vec2(-1.0);\n    \n    \/\/ clip raymarch space to bonding volume\n    tmax = min(tmax,sph.y);\n    t    = max(1.0, sph.x);\n    \n    \/\/ raymarch\n    for( int i=0; i<256; i++ )\n    {\n        vec3 pos = ro + t*rd;\n\n        float tmp;\n        vec4 h = map(pos,time,tmp,uvw);\n        if( h.x<0.001 )\n        {\n            cma = h.yzw;\n            matID = tmp;\n            break;\n        }\n        t += h.x*0.95;\n        if( t>tmax ) break;\n    }\n\n    return vec2(t,matID);\n}\n\n\/\/ This is a replacement for a traditional dot(N,L) diffuse\n\/\/ lobe (called N.L in the code) that fakes some subsurface\n\/\/ scattering (transmision of light thorugh the skin that\n\/\/ surfaces as a red glow)\n\/\/\nvec3 sdif( float ndl, float ir )\n{\n    float pndl = clamp( ndl, 0.0, 1.0 );\n    float nndl = clamp(-ndl, 0.0, 1.0 );\n    return vec3(pndl) + vec3(1.0,0.1,0.01)*0.7*pow(clamp(ir*0.75-nndl,0.0,1.0),2.0);\n}\n\n\/\/ Animates the eye central position (not the actual random\n\/\/ darts). It's carefuly synched with the head motion, to\n\/\/ make the eyes anticipate the head turn (without this\n\/\/ anticipation, the eyes and the head are disconnected and\n\/\/ it all looks like a zombie\/animatronic)\n\/\/\nfloat animEye( in float time )\n{\n    const float w = 6.1;\n    float t = mod(time-0.31,w*1.0);\n    \n    float q = fract((time-0.31)\/(2.0*w));\n    float s = (q > 0.5) ? 1.0 : 0.0;\n    return (t<0.15)?1.0-s:s;\n}\n\n\/\/ Renders the girl. It finds the ray-girl intersection\n\/\/ point, computes the normal at the intersection point,\n\/\/ computes the ambient occlusion approximation, does per\n\/\/ material setup (color, specularity, subsurface\n\/\/ coefficient and paints some fake occlusion), and finally\n\/\/ does the lighting computations.\n\/\/\n\/\/ Lighting is not based on pathtracing. Instead the bounce\n\/\/ light occlusion signals are created manually (placed\n\/\/ and sized by hand). The subsurface scattering in the\n\/\/ nose area is also painted by hand. There's not much\n\/\/ attention to the physicall correctness of the light\n\/\/ response and materials, but generally all signal do\n\/\/ follow physically based rendering practices.\n\/\/\nvec3 renderGirl( in vec2 p, in vec3 ro, in vec3 rd, in float tmax, in vec3 col, in float time )\n{\n    \/\/ --------------------------\n    \/\/ find ray-girl intersection\n    \/\/ --------------------------\n    vec3 cma, uvw;\n    vec2 tm = intersect( ro, rd, tmax, time, cma, uvw );\n\n    \/\/ --------------------------\n    \/\/ shading\/lighting\t\n    \/\/ --------------------------\n    if( tm.y>0.0 )\n    {\n        vec3 pos = ro + tm.x*rd;\n        vec3 nor = calcNormal(pos, time);\n\n        float ks = 1.0;\n        float se = 16.0;\n        float tinterShadow = 0.0;\n        float sss = 0.0;\n        float focc = 1.0;\n        \/\/float frsha = 1.0;\n\n        \/\/ --------------------------\n        \/\/ material\n        \/\/ --------------------------\n        if( tm.y<1.5 ) \/\/ skin\n        {\n            vec3 qos = vec3(abs(uvw.x),uvw.yz);\n\n            \/\/ base skin color\n            col = mix(vec3(0.225,0.15,0.12),\n                      vec3(0.24,0.1,0.066),\n                      smoothstep(0.4 ,0.0,length( qos.xy-vec2(0.42,-0.3)))+\n                      smoothstep(0.15,0.0,length((qos.xy-vec2(0,-0.29))\/vec2(1.4,1))));\n            \n            \/\/ fix that ugly highlight\n            col -= 0.03*smoothstep(0.13,0.0,length((qos.xy-vec2(0,-0.49))\/vec2(2,1)));\n                \n            \/\/ lips\n            col = mix(col,vec3(0.14,0.06,0.1),cma.x*step(-0.7,qos.y));\n            \n            \/\/ eyelashes\n            col = mix(col,vec3(0.04,0.02,0.02)*0.6,0.9*cma.y);\n\n            \/\/ fake skin drag\n            uvw.y += 0.025*animData.x*smoothstep(0.3,0.1,length(uvw-vec3(0.0,0.1,1.0)));\n\t\t\tuvw.y -= 0.005*animData.y*smoothstep(0.09,0.0,abs(length((uvw.xy-vec2(0.0,-0.38))\/vec2(2.5,1.0))-0.12));\n            \n            \/\/ freckles\n            vec2 ti = floor(9.0+uvw.xy\/0.04);\n            vec2 uv = fract(uvw.xy\/0.04)-0.5;\n            float te = fract(111.0*sin(1111.0*ti.x+1331.0*ti.y));\n            te = smoothstep(0.9,1.0,te)*exp(-dot(uv,uv)*24.0); \n            col *= mix(vec3(1.1),vec3(0.8,0.6,0.4), te);\n\n            \/\/ texture for specular\n            ks = 0.5 + 4.0*texture(iChannel3,uvw.xy*1.1).x;\n            se = 12.0;\n            ks *= 0.5;\n            tinterShadow = 1.0;\n            sss = 1.0;\n            ks *= 1.0 + cma.x;\n            \n            \/\/ black top\n            col *= 1.0-smoothstep(0.48,0.51,uvw.y);\n            \n            \/\/ makeup\n            float d2 = sdEllipsoid(qos-vec3(0.25,-0.03,0.43),vec3(0.37,0.42,0.4));\n            col = mix(col,vec3(0.06,0.024,0.06),1.0 - smoothstep(0.0,0.03,d2));\n\n            \/\/ eyebrows\n    \t\t{\n            #if 0\n            \/\/ youtube video version\n        \tvec4 be = sdBezier( qos, vec3(0.165+0.01*animData.x,0.105-0.02*animData.x,0.89),\n                                     vec3(0.37,0.18-0.005*animData.x,0.82+0.005*animData.x), \n                                     vec3(0.53,0.15,0.69) );\n            float ra = 0.005 + 0.015*sqrt(be.y);\n            #else\n            \/\/ fixed version\n        \tvec4 be = sdBezier( qos, vec3(0.16+0.01*animData.x,0.11-0.02*animData.x,0.89),\n                                     vec3(0.37,0.18-0.005*animData.x,0.82+0.005*animData.x), \n                                     vec3(0.53,0.15,0.69) );\n            float ra = 0.005 + 0.01*sqrt(1.0-be.y);\n            #endif\n            float dd = 1.0+0.05*(0.7*sin((sin(qos.x*3.0)\/3.0-0.5*qos.y)*350.0)+\n                                 0.3*sin((qos.x-0.8*qos.y)*250.0+1.0));\n    \t\tfloat d = be.x - ra*dd;\n        \tfloat mask = 1.0-smoothstep(-0.005,0.01,d);\n        \tcol = mix(col,vec3(0.04,0.02,0.02),mask*dd );\n        \t}\n\n            \/\/ fake occlusion\n            focc = 0.2+0.8*pow(1.0-smoothstep(-0.4,1.0,uvw.y),2.0);\n            focc *= 0.5+0.5*smoothstep(-1.5,-0.75,uvw.y);\n            focc *= 1.0-smoothstep(0.4,0.75,abs(uvw.x));\n            focc *= 1.0-0.4*smoothstep(0.2,0.5,uvw.y);\n            \n            focc *= 1.0-smoothstep(1.0,1.3,1.7*uvw.y-uvw.x);\n            \n            \/\/frsha = 0.0;\n        }\n        else if( tm.y<2.5 ) \/\/ eye\n        {\n            \/\/ The eyes are fake in that they aren't 3D. Instead I simply\n\t\t\t\/\/ stamp a 2D mathematical drawing of an iris and pupil. That\n\t\t\t\/\/ includes the highlight and occlusion in the eyesballs.\n            \n            sss = 1.0;\n\n            vec3 qos = vec3(abs(uvw.x),uvw.yz);\n\t\t\tfloat ss = sign(uvw.x);\n            \n            \/\/ iris animation\n            float dt = floor(time*1.1);\n            float ft = fract(time*1.1);\n            vec2 da0 = sin(1.7*(dt+0.0)) + sin(2.3*(dt+0.0)+vec2(1.0,2.0));\n            vec2 da1 = sin(1.7*(dt+1.0)) + sin(2.3*(dt+1.0)+vec2(1.0,2.0));\n            vec2 da = mix(da0,da1,smoothstep(0.9,1.0,ft));\n\n            float gg = animEye(time);\n            da *= 1.0+0.5*gg;\n            qos.yz = rot(qos.yz,da.y*0.004-0.01);\n            qos.xz = rot(qos.xz,da.x*0.004*ss-gg*ss*(0.03-step(0.0,ss)*0.014)+0.02);\n\n            vec3 eos = qos-vec3(0.31,-0.055 - 0.03*animData.x,0.45);\n            \n            \/\/ iris\n            float r = length(eos.xy)+0.005;\n            float a = atan(eos.y,ss*eos.x);\n            vec3 iris = vec3(0.09,0.0315,0.0135);\n            iris += iris*3.0*(1.0-smoothstep(0.0,1.0, abs((a+3.14159)-2.5) ));\n            iris *= 0.35+0.7*texture(iChannel2,vec2(r,a\/6.2831)).x;\n            \/\/ base color\n            col = vec3(0.42);\n            col *= 0.1+0.9*smoothstep(0.10,0.114,r);\n            col = mix( col, iris, 1.0-smoothstep(0.095,0.10,r) );\n            col *= smoothstep(0.05,0.07,r);\n\t\t\t\n            \/\/ fake occlusion backed in\n            float edis = length((vec2(abs(uvw.x),uvw.y)-vec2(0.31,-0.07))\/vec2(1.3,1.0));\n            col *= mix( vec3(1.0), vec3(0.4,0.2,0.1), linearstep(0.07,0.16,edis) );\n\n            \/\/ fake highlight\n            qos = vec3(abs(uvw.x),uvw.yz);\n            col += (0.5-gg*0.3)*(1.0-smoothstep(0.0,0.02,length(qos.xy-vec2(0.29-0.05*ss,0.0))));\n            \n            se = 128.0;\n\n            \/\/ fake occlusion\n            focc = 0.2+0.8*pow(1.0-smoothstep(-0.4,1.0,uvw.y),2.0);\n            focc *= 1.0-linearstep(0.10,0.17,edis);\n            \/\/frsha = 0.0;\n        }\n        else if( tm.y<3.5 )\/\/ hoodie\n        {\n            sss = 0.0;\n            col = vec3(0.81*texture(iChannel0,uvw*6.0).x);\n            ks *= 2.0;\n            \n            \/\/ logo\n            if( abs(uvw.x)<0.66 )\n            {\n                float par = length(uvw.yz-vec2(-1.05,0.65));\n                col *= mix(vec3(1.0),vec3(0.6,0.2,0.8)*0.7,1.0-smoothstep(0.1,0.11,par));\n                col *= smoothstep(0.005,0.010,abs(par-0.105));\n            }                \n\n            \/\/ fake occlusion\n            focc = mix(1.0,\n                \t   0.03+0.97*smoothstep(-0.15,1.7,uvw.z),\n                       smoothstep(-1.6,-1.3,uvw.y)*(1.0-clamp(dot(nor.xz,normalize(uvw.xz)),0.0,1.0))\n                      );\n            \n            \/\/frsha = mix(1.0,\n            \/\/            clamp(dot(nor.xz,normalize(uvw.xz)),0.0,1.0),\n            \/\/            smoothstep(-1.6,-1.3,uvw.y)\n            \/\/           );\n            \/\/frsha *= smoothstep(0.85,1.0,length(uvw-vec3(0.0,-1.0,0.0)));\n        }\n        else if( tm.y<4.5 )\/\/ hair\n        {\n            sss = 0.0;\n            col = (sin(cma.x)>0.7) ? vec3(0.03,0.01,0.05)*1.5 :\n                                     vec3(0.04,0.02,0.01)*0.4;\n            ks *= 0.75 + cma.z*18.0;\n            float te = texture( iChannel2,vec2( 0.25*atan(uvw.x,uvw.y),8.0*uvw.z) ).x;\n            col *= 2.0*te;\n            ks *= 1.5*te;\n            \n\t\t\t\/\/ fake occlusion\n            focc  = 1.0-smoothstep(-0.40, 0.8, uvw.y);\n            focc *= 1.0-0.95*smoothstep(-1.20,-0.2,-uvw.z);\n            focc *= 0.5+cma.z*12.0;\n            \/\/frsha = 1.0-smoothstep(-1.3,-0.8,uvw.y);\n            \/\/frsha *= 1.0-smoothstep(-1.20,-0.2,-uvw.z);\n        }\n        else if( tm.y<5.5 )\/\/ teeth\n        {\n            sss = 1.0;\n            col = vec3(0.3);\n            ks *= 1.5;\n            \/\/frsha = 0.0;\n        }\n\n        float fre = clamp(1.0+dot(nor,rd),0.0,1.0);\n        float occ = focc*calcOcclusion( pos, nor, time );\n\n        \/\/ --------------------------\n        \/\/ lighting. just four lights\n        \/\/ --------------------------\n        vec3 lin = vec3(0.0);\n\n        \/\/ fake sss\n        float nma = 0.0;\n        if( tm.y<1.5 )\n        {\n        nma = 1.0-smoothstep(0.0,0.12,length((uvw.xy-vec2(0.0,-0.37))\/vec2(2.4,0.7)));\n        }\n\n        \/\/vec3 lig = normalize(vec3(0.5,0.4,0.6));\n        vec3 lig = vec3(0.57,0.46,0.68);\n        vec3 hal = normalize(lig-rd);\n        float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n        \/\/float sha = 0.0; if( dif>0.001 ) sha=calcSoftshadow( pos+nor*0.002, lig, 0.0001, 2.0, time, 5.0 );\n        float sha = calcSoftshadow( pos+nor*0.002, lig, 0.0001, 2.0, time, 5.0 );\n        float spe = 2.0*ks*pow(clamp(dot(nor,hal),0.0,1.0),se)*dif*sha*(0.04+0.96*pow(clamp(1.0-dot(hal,-rd),0.0,1.0),5.0));\n\n        \/\/ fake sss for key light\n        vec3 cocc = mix(vec3(occ),\n                        vec3(0.1+0.9*occ,0.9*occ+0.1*occ*occ,0.8*occ+0.2*occ*occ),\n                        tinterShadow);\n        cocc = mix( cocc, vec3(1,0.3,0.0), nma);\n        sha = mix(sha,max(sha,0.3),nma);\n\n        vec3  amb = cocc*(0.55 + 0.45*nor.y);\n        float bou = clamp(0.3-0.7*nor.x, 0.0, 1.0 );\n\n        lin +=      vec3(0.65,1.05,2.0)*amb*1.15;\n        lin += 1.50*vec3(1.60,1.40,1.2)*sdif(dot(nor,lig),0.5+0.3*nma+0.2*(1.0-occ)*tinterShadow) * mix(vec3(sha),vec3(sha,0.2*sha+0.7*sha*sha,0.2*sha+0.7*sha*sha),tinterShadow);\n        lin +=      vec3(1.00,0.30,0.1)*sss*fre*0.6*(0.5+0.5*dif*sha*amb)*(0.1+0.9*focc);\n        lin += 0.35*vec3(4.00,2.00,1.0)*bou*occ*col;\n\n        col = lin*col + spe + fre*fre*fre*0.1*occ;\n\n        \/\/ overall\n\t\tcol *= 1.1;\n    }\n        \n    return col;\n}\n\n\/\/ Animates the head turn. This is my first time animating\n\/\/ and I am aware I'm in uncanny\/animatronic land. But I\n\/\/ have to start somwhere!\n\/\/\nfloat animTurn( in float time )\n{\t\n    const float w = 6.1;\n    float t = mod(time,w*2.0);\n    \n    vec3 p = (t<w) ? vec3(0.0,0.0,1.0) : vec3(w,1.0,-1.0);\n    return p.y + p.z*expSustainedImpulse(t-p.x,1.0,10.0);\n}\n\n\/\/ Animates the eye blinks. Blinks are motivated by head\n\/\/ turns (again, in an attempt tp avoid animatronic and\n\/\/ zoombie feel), but also there are random blinks. This\n\/\/ same funcion is called with some delay and extra\n\/\/ smmoothness to get the blink of the eyes be followed by\n\/\/ the face muscles around the face.\n\/\/\nfloat animBlink( in float time, in float smo )\n{\n    \/\/ head-turn motivated blink\n    const float w = 6.1;\n    float t = mod(time-0.31,w*1.0);\n    float blink = smoothstep(0.0,0.1,t) - smoothstep(0.18,0.4,t);\n\n    \/\/ regular blink\n    float tt = mod(1.0+time,3.0);\n    blink = max(blink,smoothstep(0.0,0.07+0.07*smo,tt)-smoothstep(0.1+0.04*smo,0.35+0.3*smo,tt));\n    \n    \/\/ keep that eye alive always\n    float blinkBase = 0.04*(0.5+0.5*sin(time));\n    blink = mix( blinkBase, 1.0, blink );\n\n    \/\/ base pose is a bit down\n    float down = 0.15;\n    return down+(1.0-down)*blink;\n}\n\n\/\/ The main rendering entry point. Basically it does some\n\/\/ setup, creating the ray that will explore the 3D scene\n\/\/ in search of the girl for each pixel, computes the\n\/\/ animation variables (blink, mouth and head movements),\n\/\/ does the rendering of the girl if it finds her under\n\/\/ the current pixel, and finally does gamme correction\n\/\/ and some minimal color processing and vignetting to the\n\/\/ image.\n\/\/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ render\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        \/\/ pixel coordinates\n        vec2 o = vec2(float(m),float(n)) \/ float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))\/iResolution.y;\n        float d = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n        float time = iTime - 0.5*(1.0\/24.0)*(float(m*AA+n)+d)\/float(AA*AA-1);\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)\/iResolution.y;\n        float time = iTime;\n        #endif\n        \n        time += 2.0;\n        \n        \/\/ camera movement\t\n        vec3 ro; float fl;\n        mat3 ca = calcCamera( time, ro, fl );\n    \tvec3 rd = ca * normalize( vec3((p-vec2(-0.52,0.12))\/1.1,fl));\n\n        \/\/ animation (blink, face follow up, mouth)\n        float turn = animTurn( time );\n        animData.x = animBlink(time,0.0);\n        animData.y = animBlink(time-0.02,1.0);\n        animData.z = -0.25 + 0.2*(1.0-turn)*smoothstep(-0.3,0.9,sin(time*1.1)) + 0.05*cos(time*2.7);\n\n        \/\/ animation (head orientation)\n        animHead = vec3( sin(time*0.5), sin(time*0.3), -cos(time*0.2) );\n        animHead = animHead*animHead*animHead;\n        animHead.x = -0.025*animHead.x + 0.2*(0.7+0.3*turn);\n        animHead.y =  0.1 + 0.02*animHead.y*animHead.y*animHead.y;\n        animHead.z = -0.03*(0.5 + 0.5*animHead.z) - (1.0-turn)*0.05;\n        \n        \/\/ rendering\n        vec4 tmp = texelFetch(iChannel1,ivec2(fragCoord),0);\n        vec3 col = tmp.xyz;\n        float tmin = tmp.w;\n        \n        if( p.x*1.4+p.y<0.8 && -p.x*4.5+p.y<6.5 && p.x<0.48)\n        col = renderGirl(p,ro,rd,tmin,col,time);\n        \/\/else col=vec3(0,1,0);\n        \n        \/\/ gamma        \n        col = pow( col, vec3(0.4545) );\n\t    tot += col;\n    #if AA>1\n    }\n    tot \/= float(AA*AA);\n    #endif\n \n    \/\/ compress\n    tot = 3.8*tot\/(3.0+dot(tot,vec3(0.333)));\n  \n    \/\/ vignette\n    vec2 q = fragCoord\/iResolution.xy;\n    tot *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.15);\n\n    \/\/ grade\n    tot = tot*vec3(1.02,1.00,0.99)+vec3(0.0,0.0,0.045);\n       \n    fragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\/\/ Basic utility functions (SDFs, noises, shaping functions)\n\/\/ and also the camera setup which is shared between the\n\/\/ background rendering code (\"Buffer A\" tab) and the character\n\/\/ rendering code (\"Image\" tab)\n\n\n\n\/\/ https:\/\/iquilezles.org\/articles\/smin\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25\/k;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/smin\nfloat smax( float a, float b, float k )\n{\n    k *= 1.4;\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*h\/(6.0*k*k);\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/smin\nfloat smin3( float a, float b, float k )\n{\n    k *= 1.4;\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*h\/(6.0*k*k);\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/smin\nfloat sclamp(in float x, in float a, in float b )\n{\n    float k = 0.1;\n\treturn smax(smin(x,b,k),a,k);\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nfloat opOnion( in float sdf, in float thickness )\n{\n    return abs(sdf)-thickness;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nfloat opRepLim( in float p, in float s, in float lima, in float limb )\n{\n    return p-s*clamp(round(p\/s),lima,limb);\n}\n\nfloat det( vec2 a, vec2 b ) { return a.x*b.y-b.x*a.y; }\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x-a.y*b.y; }\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nfloat sdTorus( in vec3 p, in float ra, in float rb )\n{\n    return length( vec2(length(p.xz)-ra,p.y) )-rb;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.z) ? dot(p.xz,sc) : length(p.xz);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nfloat sdSphere( in vec3 p, in float r ) \n{\n    return length(p)-r;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    float k0 = length(p\/r);\n    float k1 = length(p\/(r*r));\n    return k0*(k0-1.0)\/k1;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nfloat sdBox( in vec3 p, in vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min( max(max(d.x,d.y),d.z),0.0) + length(max(d,0.0));\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nfloat sdArc( in vec2 p, in vec2 scb, in float ra )\n{\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k );\n}\n\n#if 1\n\/\/ http:\/\/research.microsoft.com\/en-us\/um\/people\/hoppe\/ravg.pdf\n\/\/ { dist, t, y (above the plane of the curve, x (away from curve in the plane of the curve))\nvec4 sdBezier( vec3 p, vec3 va, vec3 vb, vec3 vc )\n{\n  vec3 w = normalize( cross( vc-vb, va-vb ) );\n  vec3 u = normalize( vc-vb );\n  vec3 v =          ( cross( w, u ) );\n  \/\/----  \n  vec2 m = vec2( dot(va-vb,u), dot(va-vb,v) );\n  vec2 n = vec2( dot(vc-vb,u), dot(vc-vb,v) );\n  vec3 q = vec3( dot( p-vb,u), dot( p-vb,v), dot(p-vb,w) );\n  \/\/----  \n  float mn = det(m,n);\n  float mq = det(m,q.xy);\n  float nq = det(n,q.xy);\n  \/\/----  \n  vec2  g = (nq+mq+mn)*n + (nq+mq-mn)*m;\n  float f = (nq-mq+mn)*(nq-mq+mn) + 4.0*mq*nq;\n  vec2  z = 0.5*f*vec2(-g.y,g.x)\/dot(g,g);\n\/\/float t = clamp(0.5+0.5*(det(z,m+n)+mq+nq)\/mn, 0.0 ,1.0 );\n  float t = clamp(0.5+0.5*(det(z-q.xy,m+n))\/mn, 0.0 ,1.0 );\n  vec2 cp = m*(1.0-t)*(1.0-t) + n*t*t - q.xy;\n  \/\/----  \n  float d2 = dot(cp,cp);\n  return vec4(sqrt(d2+q.z*q.z), t, q.z, -sign(f)*sqrt(d2) );\n}\n#else\nfloat det( vec3 a, vec3 b, in vec3 v ) { return dot(v,cross(a,b)); }\n\n\/\/ my adaptation to 3d of http:\/\/research.microsoft.com\/en-us\/um\/people\/hoppe\/ravg.pdf\n\/\/ { dist, t, y (above the plane of the curve, x (away from curve in the plane of the curve))\nvec4 sdBezier( vec3 p, vec3 b0, vec3 b1, vec3 b2 )\n{\n    b0 -= p;\n    b1 -= p;\n    b2 -= p;\n    \n    vec3  d21 = b2-b1;\n    vec3  d10 = b1-b0;\n    vec3  d20 = (b2-b0)*0.5;\n\n    vec3  n = normalize(cross(d10,d21));\n\n    float a = det(b0,b2,n);\n    float b = det(b1,b0,n);\n    float d = det(b2,b1,n);\n    vec3  g = b*d21 + d*d10 + a*d20;\n\tfloat f = a*a*0.25-b*d;\n\n    vec3  z = cross(b0,n) + f*g\/dot(g,g);\n    float t = clamp( dot(z,d10-d20)\/(a+b+d), 0.0 ,1.0 );\n    vec3 q = mix(mix(b0,b1,t), mix(b1,b2,t),t);\n    \n    float k = dot(q,n);\n    return vec4(length(q),t,-k,-sign(f)*length(q-n*k));\n}\n#endif\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nvec2 sdSegment(vec3 p, vec3 a, vec3 b)\n{\n    vec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ), h );\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nvec2 sdSegmentOri(vec2 p, vec2 b)\n{\n\tfloat h = clamp( dot(p,b)\/dot(b,b), 0.0, 1.0 );\n\treturn vec2( length( p - b*h ), h );\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nfloat sdFakeRoundCone(vec3 p, float b, float r1, float r2)\n{\n    float h = clamp( p.y\/b, 0.0, 1.0 );\n    p.y -= b*h;\n\treturn length(p) - mix(r1,r2,h);\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nfloat sdCone( in vec3 p, in vec2 c )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n\n  vec2 a = q - c*clamp( (q.x*c.x+q.y*c.y)\/dot(c,c), 0.0, 1.0 );\n  vec2 b = q - c*vec2( clamp( q.x\/c.x, 0.0, 1.0 ), 1.0 );\n  \n  float s = -sign( c.y );\n  vec2 d = min( vec2( dot( a, a ), s*(q.x*c.y-q.y*c.x) ),\n\t\t\t    vec2( dot( b, b ), s*(q.y-c.y)  ));\n  return -sqrt(d.x)*sign(d.y);\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n    p = abs(p);\n    vec2 b = vec2(la,lb);\n    float f = clamp( (ndot(b,b-2.0*p.xz))\/dot(b,b), -1.0, 1.0 );\n\tvec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nvec4 opElongate( in vec3 p, in vec3 h )\n{\n    vec3 q = abs(p)-h;\n    return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n\n\/\/-----------------------------------------------\n\n\/\/ ray-infinite-cylinder intersection\nvec2 iCylinderY( in vec3 ro, in vec3 rd, in float rad )\n{\n\tvec3 oc = ro;\n    float a = dot( rd.xz, rd.xz );\n\tfloat b = dot( oc.xz, rd.xz );\n\tfloat c = dot( oc.xz, oc.xz ) - rad*rad;\n\tfloat h = b*b - a*c;\n\tif( h<0.0 ) return vec2(-1.0);\n    h = sqrt(h);\n\treturn vec2(-b-h,-b+h)\/a;\n}\n\n\/\/ ray-infinite-cone intersection\nvec2 iConeY(in vec3 ro, in vec3 rd, in float k )\n{\n\tfloat a = dot(rd.xz,rd.xz) - k*rd.y*rd.y;\n    float b = dot(ro.xz,rd.xz) - k*ro.y*rd.y;\n    float c = dot(ro.xz,ro.xz) - k*ro.y*ro.y; \n        \n    float h = b*b-a*c;\n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b-h,-b+h)\/a;\n}\n\n\/\/-----------------------------------------------\n\nfloat linearstep(float a, float b, in float x )\n{\n    return clamp( (x-a)\/(b-a), 0.0, 1.0 );\n}\n\nvec2 rot( in vec2 p, in float an )\n{\n    float cc = cos(an);\n    float ss = sin(an);\n    return mat2(cc,-ss,ss,cc)*p;\n}\n\nfloat expSustainedImpulse( float t, float f, float k )\n{\n    return smoothstep(0.0,f,t)*1.1 - 0.1*exp2(-k*max(t-f,0.0));\n}\n\n\/\/-----------------------------------------------\n\nvec3 hash3( uint n ) \n{\n    \/\/ integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    uvec3 k = n * uvec3(n,n*16807U,n*48271U);\n    return vec3( k & uvec3(0x7fffffffU))\/float(0x7fffffff);\n}\n\n\/\/---------------------------------------\n\nfloat noise1( sampler3D tex, in vec3 x )\n{\n    return textureLod(tex,(x+0.5)\/32.0,0.0).x;\n}\nfloat noise1( sampler2D tex, in vec2 x )\n{\n    return textureLod(tex,(x+0.5)\/64.0,0.0).x;\n}\nfloat noise1f( sampler2D tex, in vec2 x )\n{\n    return texture(tex,(x+0.5)\/64.0).x;\n}\nfloat fbm1( sampler3D tex, in vec3 x )\n{\n    float f = 0.0;\n    f += 0.5000*noise1(tex,x); x*=2.01;\n    f += 0.2500*noise1(tex,x); x*=2.01;\n    f += 0.1250*noise1(tex,x); x*=2.01;\n    f += 0.0625*noise1(tex,x);\n    f = 2.0*f-0.9375;\n    return f;\n}\n\nfloat fbm1( sampler2D tex, in vec2 x )\n{\n    float f = 0.0;\n    f += 0.5000*noise1(tex,x); x*=2.01;\n    f += 0.2500*noise1(tex,x); x*=2.01;\n    f += 0.1250*noise1(tex,x); x*=2.01;\n    f += 0.0625*noise1(tex,x);\n    f = 2.0*f-0.9375;\n    return f;\n}\nfloat fbm1f( sampler2D tex, in vec2 x )\n{\n    float f = 0.0;\n    f += 0.5000*noise1f(tex,x); x*=2.01;\n    f += 0.2500*noise1f(tex,x); x*=2.01;\n    f += 0.1250*noise1f(tex,x); x*=2.01;\n    f += 0.0625*noise1f(tex,x);\n    f = 2.0*f-0.9375;\n    return f;\n}\nfloat bnoise( in float x )\n{\n    float i = floor(x);\n    float f = fract(x);\n    float s = sign(fract(x\/2.0)-0.5);\n    float k = 0.5+0.5*sin(i);\n    return s*f*(f-1.0)*((16.0*k-4.0)*f*(f-1.0)-1.0);\n}\nvec3 fbm13( in float x, in float g )\n{    \n    vec3 n = vec3(0.0);\n    float s = 1.0;\n    for( int i=0; i<6; i++ )\n    {\n        n += s*vec3(bnoise(x),bnoise(x+13.314),bnoise(x+31.7211));\n        s *= g;\n        x *= 2.01;\n        x += 0.131;\n    }\n    return n;\n}\n\n\/\/--------------------------------------------------\n\/\/const float X1 = 1.6180339887498948; const float H1 = float( 1.0\/X1 );\n\/\/const float X2 = 1.3247179572447460; const vec2  H2 = vec2(  1.0\/X2, 1.0\/(X2*X2) );\n\/\/const float X3 = 1.2207440846057595; const vec3  H3 = vec3(  1.0\/X3, 1.0\/(X3*X3), 1.0\/(X3*X3*X3) );\n  const float X4 = 1.1673039782614187; const vec4  H4 = vec4(  1.0\/X4, 1.0\/(X4*X4), 1.0\/(X4*X4*X4), 1.0\/(X4*X4*X4*X4) );\n\n\/\/--------------------------------------\nmat3 calcCamera( in float time, out vec3 oRo, out float oFl )\n{\n    vec3 ta = vec3( 0.0, -0.3, 0.0 );\n    vec3 ro = vec3( -0.5563, -0.2, 2.7442 );\n    float fl = 1.7;\n#if 0\n    vec3 fb = fbm13( 0.2*time, 0.5 );\n    ta += 0.025*fb;\n    float cr = -0.01 + 0.006*fb.z;\n#else\n    vec3 fb1 = fbm13( 0.15*time, 0.50 );\n    ro.xyz += 0.010*fb1.xyz;\n    vec3 fb2 = fbm13( 0.33*time, 0.65 );\n    fb2 = fb2*fb2*sign(fb2);\n    ta.xy += 0.005*fb2.xy;\n    float cr = -0.01 + 0.002*fb2.z;\n#endif\n    \n    \/\/ camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(cr),cos(cr),0.0) ) );\n    vec3 vv =          ( cross(uu,ww));\n    \n    oRo = ro;\n    oFl = fl;\n\n    return mat3(uu,vv,ww);\n}\n\n#define ZERO min(iFrame,0)\n#define ZEROU min(uint(iFrame),0u)\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sf3Rn","filepath":"\/media\/a\/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"\/media\/ap\/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"\/media\/a\/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"\/media\/ap\/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ Renders the background (trees, ground, river and bridge).\n\/\/ The render uses a super basic implementation of Temporal\n\/\/ Antialiasing (TAA) without color clipping or anything,\n\/\/ but it's enough to stabilize aliasing. It also outputs\n\/\/ the deph buffer into the alpha channel for the next pass\n\/\/ (\"Buffer B\") to consume and do proper Depth Of Field.\n\n\n\/\/ The ground - it's a simple box deformed by a few sine waves\n\/\/\nfloat sdGround( in vec3 pos )\n{\n    pos -= vec3(120.0,-35.0,-700.0);\n    pos.x += -150.0;\n    pos.z += 30.0*sin(1.00*pos.x*0.016+0.0);\n    pos.z += 10.0*sin(2.20*pos.x*0.016+1.0);\n    pos.y += 20.0*sin(0.01*pos.x+2.0)*sin(0.01*pos.z+2.0);\n    \n    return sdBox(pos,vec3(1000.0,2.0,400.0))-10.0;\n}\n\n\/\/ The bridge. It's made of five boxes repeated forever\n\/\/ with some mod() call, which are distorted with gentle\n\/\/ sine waves so they don't look like perfectly geometrical. \n\/\/\nvec2 sdBridge( in vec3 pos )\n{\n    float issnow = 0.0;\n    vec3 opos = pos;\n    pos.x  += 50.0*sin(pos.z*0.01)+10.0;\n    pos.xz += 0.05*sin(pos.yx+vec2(0,2));                \n    vec3 sos = vec3(abs(pos.x),pos.yz);\n    float h = -16.0;\n    \n    \/\/ floor\n    vec3 ros = vec3(sos.xy,mod(sos.z+2.0,4.0)-2.0 )-vec3(0.0,h,0.0);\n    float d = sdBox(ros,vec3(20.0,1.0,1.85));\n\n    \/\/ thick bars\n    ros = vec3(sos.xy,mod(sos.z+5.0,10.0)-5.0 )-vec3(20.0,h+5.0-0.4,0.0);\n    float d2 = sdBox(ros,vec3(1.2,5.0,0.7)+0.1)-0.1;\n    d = min(d,d2);\n    \n    #if 0\n    {\n    float id = floor((sos.z+5.0)\/10.0);\n    ros = vec3(sos.xy,mod(sos.z+5.0,10.0)-5.0 )-vec3(20.0,h-0.4,0.0);\n\tros-=vec3(-1.5,1,0);\n    ros.x -= ros.y;\n    float ra = 0.5 + 0.5*sin(float(id)+4.0);\n    float d2 = sdEllipsoid(ros,vec3(2.0,2.0,1.3)*ra);\n    issnow = clamp( 0.5+0.5*(d-d2)\/0.7, 0.0, 1.0 );\n    d = smin(d,d2,0.7);\n    }\n    #endif\n\n    \/\/ small bars\n    ros = vec3(sos.xy,mod(sos.z+1.25,2.5)-1.25 )-vec3(20.0,h+5.0,0.0);\n    d2 = sdBox(ros,vec3(0.2,5.0,0.2))-0.05;\n    d = min(d,d2);\n    \n    \/\/ handle\n    d2 = sdBox(sos-vec3(20.0,h+10.0,0.0),vec3(0.5,0.1,300.0))-0.4;\n    d = min(d,d2);\n    \n    \/\/ foot bar\n    d2 = sdBox(sos-vec3(20.0,h+2.4,0.0),vec3(0.7,0.1,300.0))-0.2;\n    d = min(d,d2);\n    \n\treturn vec2(d,issnow);\n}\n\n\/\/ The trees are ultra basic and look really bad without\n\/\/ defocus, but all I needed was something that looked like\n\/\/ pine trees so the viewers would complete the picture in\n\/\/ their heads. Only four trees are evaluated at any time,\n\/\/ even though  there are inifinte many of them. Yet these\n\/\/ four trees consume most of the rendering budget for the\n\/\/ painting.\n\/\/\nvec3 sdForest( in vec3 pos, float tmin )\n{\n    float shid = 0.0;\n    \n    const float per = 200.0;\n    \n    pos -= vec3(120.0,-16.0,-600.0);\n        \n    vec3 vos = pos\/per;\n    vec3 ip = floor(vos);\n    vec3 fp = fract(vos);\n    \n    bool hit = false;\n    float d = tmin;\n    float occ = 1.0;\n    \n    for( int j=0; j<=1; j++ )\n    for( int i=0; i<=1; i++ )\n    {\n        vec2 of = vec2(i,j);\n        ivec2 tid = ivec2(ip.xz + of );\n        tid.y = min(tid.y,-0);\n        \n        uint treeId = uint(tid.y)*17u+uint(tid.x)*1231u;\n        \n        vec3 rf =  hash3( uint(treeId) )-0.5;\n        \n        vec3 ros = vec3( (float(tid.x)+rf.x)*per,\n                         0.0,\n                         (float(tid.y)+rf.y)*per );\n\n\n        float hei = 1.0 + 0.2*sin( float(tid.x*115+tid.y*221) );\n        hei *= (tid.y==0) ? 1.0 : 1.5;\n          \n        hei *= 275.0;\n\n        float d2 = sdFakeRoundCone( pos-ros,hei,7.0,1.0);\n        if( d2<d)\n        {\n            d = d2;\n            hit = false;\n        }\n        \n        if( d2-150.0>d ) continue;\n        \n        vec2 qos = pos.xz - ros.xz;\n        float an = atan(qos.x,qos.y);\n        float ra = length(qos);\n        float vv = 0.3*sin(11.0*an) + 0.2*sin(28.0*an)+ 0.10*sin(53.0*an+4.0);\n\n        \n        \/\/ trick - only evalute 4 closest of the 10 cones\n        int segid = int(floor(16.0*(pos.y-ros.y)\/hei));\n        for( uint k=ZEROU; k<4u; k++ )\n        {\n            uint rk = uint( min(max(segid+int(k),5),15) );\n            \n            float h = float(rk)\/15.0;\n            \n            vec3 ran = hash3( treeId*24u+rk );\n            \n            h += 0.1*(1.0-h)*(ran.z-0.5) + 0.05*sin(1.0*an);\n\n            ros.y = h*hei;\n            \n            float hh = 0.5 + 0.5*(1.0-h);\n            float ww = 0.1 + 0.9*(1.0-h);\n            hh *= 0.7+0.2*ran.x;\n            ww *= 0.9+0.2*ran.y;\n            hh *= 1.0+0.2*vv;\n            \n            vec2 rrr = vec2( ra, pos.y-ros.y );\n            vec2 tmp = sdSegmentOri( rrr,vec2(120.0*ww,-100.0*hh));\n            float d2 = tmp.x-mix(1.0,vv,tmp.y);\n            if( d2<d )\n            {\n                hit = true;\n                d = d2;\n                shid = rf.z;\n                occ = tmp.y * clamp(ra\/100.0+h,0.0,1.0);\n            }\n        }\n    }\n    \n    if( hit )\n    {\n        float dis = 0.5+0.5*fbm1(iChannel0,0.1*pos*vec3(1,0.3,1));\n        d -= 8.0*dis-4.0;\n        \/\/occ = dis;\n    }\n    \n\treturn vec3(d,shid,occ);\n}\n\n\n\/\/ The SDF of the landscape is made by combining ground, \n\/\/ bridge, river and trees. \n\/\/\nvec4 map( in vec3 pos, in float time, out float outMat, out vec3 uvw )\n{\n    pos.xz = rot(pos.xz,0.2);\n\n    vec4 res = vec4(pos.y+36.0,0,0,0);    \n    \n    outMat = 1.0;\n    uvw = pos;\n    \n    \/\/-------\n    {\n    vec2 d2 = sdBridge(pos);\n    if( d2.x<res.x )\n    {\n        res.xy = d2;\n        outMat = 2.0;\n    }\n    }\n    \/\/-------\n    float d = sdGround(pos);\n    if( d<res.x )\n    {\n        res.x = d;\n        outMat = 4.0;\n    }\n    \/\/-------\n    float bb = pos.z+450.0;\n    if( bb<d )\n    {\n    vec3 d2 = sdForest(pos,d);\n    if( d2.x<res.x )\n    {\n        res.x = d2.x;\n        res.y = d2.y;\n        res.z = d2.z;\n        outMat = 3.0;\n    }\n    }\n    \n    return res;\n}\n\n\/\/ The landscape SDF again, but with extra high frequency\n\/\/ modeling detail. While the previous one is used for\n\/\/ raymarching and shadowing, this one is used for normal\n\/\/ computation. This separation is conceptually equivalent\n\/\/ to decoupling detail from base geometry with \"normal\n\/\/ maps\", but done in 3D and with SDFs, which is way simpler\n\/\/ and can be done correctly (something rarely seen in 3D\n\/\/ engines) without any complexity.\n\/\/\nfloat mapD( in vec3 pos, in float time )\n{\n    float matID; vec3 kk2;\n    float d = map(pos,time,matID,kk2).x;\n    \n    if( matID<1.5 ) \/\/ water\n    {\n        float g = 0.5 + 0.5*fbm1f(iChannel2,0.02*pos.xz);\n        g = g*g;\n    \tfloat f = 0.5 + 0.5*fbm1f(iChannel2,pos.xz);\n        d -= g*12.0*(0.5+0.5*f*g*2.0);\n    }\n    else if( matID<2.5 ) \/\/ bridge\n    {\n    \td -= 0.07*(0.5+0.5*fbm1(iChannel0, pos*vec3(8,1,8) ));\n    }\n    else if( matID<4.5 ) \/\/ ground\n    {\n    \tfloat dis = fbm1(iChannel0,0.1*pos);\n    \td -= 3.0*dis;\n    }\n    \n    return d;\n}\n\n\/\/ Computes the normal of the girl's surface (the gradient\n\/\/ of the SDF). The implementation is weird because of the\n\/\/ technicalities of the WebGL API that forces us to do\n\/\/ some trick to prevent code unrolling. More info here:\n\/\/\n\/\/ https:\/\/iquilezles.org\/articles\/normalsSDF\n\/\/\nvec3 calcNormal( in vec3 pos, in float time, in float t )\n{\n    float eps = 0.001*t;\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*mapD( pos + e.xyy*eps,time ) + \n\t\t\t\t\t  e.yyx*mapD( pos + e.yyx*eps,time ) + \n\t\t\t\t\t  e.yxy*mapD( pos + e.yxy*eps,time ) + \n\t\t\t\t\t  e.xxx*mapD( pos + e.xxx*eps,time ) );\n#else\n    vec4 n = vec4(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec4 s = vec4(pos, 0.0);\n        s[i] += eps;\n        n[i] = mapD(s.xyz, time);\n        \/\/if( n.x+n.y+n.z+n.w>100.0 ) break;\n    }\n    return normalize(n.xyz-n.w);\n#endif    \n}\n\n\/\/ Compute soft shadows for a given light, with a single ray\n\/\/ insead of using montecarlo integration or shadowmap\n\/\/ blurring. More info here:\n\/\/\n\/\/ https:\/\/iquilezles.org\/articles\/rmshadows\n\/\/\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, in float time, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    \n    \/\/ first things first - let's do a bounding volume test\n    float tm = (480.0-ro.y)\/rd.y; if( tm>0.0 ) tmax=min(tmax,tm);\n    \n    \/\/ raymarch and track penumbra\n    for( int i=ZERO; i<128; i++ )\n    {\n        float kk; vec3 kk2;\n\t\tfloat h = map( ro + rd*t, time, kk, kk2 ).x;\n        res = min( res, k*h\/t );\n        t += clamp( h, 0.05, 25.0 );\n        if( res<0.002 || t>tmax ) break;\n    }\n    return max( res, 0.0 );\n}\n\n\/\/ Computes convexity for our landscape SDF, which can be\n\/\/ used to approximate ambient occlusion. More info here:\n\/\/\n\/\/ https:\/\/iquilezles.org\/www\/material\/nvscene2008\/rwwtt.pdf\n\/\/\nfloat calcOcclusion( in vec3 pos, in vec3 nor, in float time, float sca, in vec2 px )\n{\n    float kk; vec3 kk2;\n\tfloat ao = 0.0;\n    float off = textureLod(iChannel3,px\/256.0,0.0).x;\n    vec4 k = vec4(0.7012912,0.3941462,0.8294585,0.109841)+off;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tk = fract(k + H4);\n        vec3 ap = normalize(-1.0+2.0*k.xyz);\n        float h = k.w*1.0*sca;\n        ap = (nor+ap)*h;\n        float d = map( pos+ap, time, kk, kk2 ).x;\n        ao += max(0.0,h-d);\n        if( ao>10000.0 ) break;\n    }\n\tao \/= 16.0;\n    return clamp( 1.0-ao*2.0\/sca, 0.0, 1.0 );\n}\n\n\/\/ Computes the intersection point between our landscape SDF\n\/\/ and a ray (coming form the camera in this case). It's a\n\/\/ traditional and uncomplicated SDF raymarcher. More info:\n\/\/\n\/\/ https:\/\/iquilezles.org\/www\/material\/nvscene2008\/rwwtt.pdf\n\/\/\nvec2 intersect( in vec3 ro, in vec3 rd, in float time, out vec3 cma, out vec3 uvw )\n{\n    cma = vec3(0.0);\n    uvw = vec3(0.0);\n    float matID = -1.0;\n\n    float tmax = 2500.0;\n    float t = 15.0;\n\t\/\/ bounding volume test first    \n    float tm = (480.0-ro.y)\/rd.y; if( tm>0.0 ) tmax=min(tmax,tm);\n    \n    \/\/ raymarch\n    for( int i=ZERO; i<1024; i++ )\n    {\n        vec3 pos = ro + t*rd;\n\n        float tmp;\n        vec4 h = map(pos,time,tmp,uvw);\n        if( (h.x)<0.0002*t )\n        {\n            cma = h.yzw;\n            matID = tmp;\n            break;\n        }\n        t += h.x*0.8;\n        if( t>tmax ) break;\n    }\n\n    return vec2(t,matID);\n}\n\n\/\/ Renders the landscape. It finds the ray-landscape\n\/\/ intersection point, computes the normal at the\n\/\/ intersection point, computes the ambient occlusion\n\/\/ approximation, does per material setup (color,\n\/\/ specularity, and paints some fake occlusion), and\n\/\/ finally does the lighting computation.\n\/\/\nvec4 renderBackground( in vec2 p, in vec3 ro, in vec3 rd, in float time, in vec2 px )\n{\n    \/\/ sky color\n    vec3 col = vec3(0.45,0.75,1.1) + rd.y*0.5;\n    vec3 fogcol = vec3(0.3,0.5,1.0)*0.25;\n    col = mix( col, fogcol, exp2(-8.0*max(rd.y,0.0)) );\n    \n    \/\/ -------------------------------\n    \/\/ find ray-landscape intersection\n    \/\/ -------------------------------\n    float tmin = 1e20;\n    vec3 cma, uvw;\n    vec2 tm = intersect( ro, rd, time, cma, uvw);\n\n    \/\/ --------------------------\n    \/\/ shading\/lighting\t\n    \/\/ --------------------------\n    if( tm.y>0.0 )\n    {\n        tmin = tm.x;\n        \n        vec3 pos = ro + tmin*rd;\n        vec3 nor = calcNormal(pos, time, tmin);\n\n        col = cma;\n\n        float ks = 1.0;\n        float se = 16.0;\n        float focc = 1.0;\n        float occs = 1.0;\n        float snow = 1.0;\n        \n    \t\/\/ --------------------------\n        \/\/ materials\n    \t\/\/ --------------------------\n\n        \/\/ water\n        if( tm.y<1.5 )\n        {\n            col = vec3(0.1,0.2,0.3);\n            occs = 20.0;\n        }\n        \/\/ bridge\n        else if( tm.y<2.5 )\n        {\n            float f = 0.5 + 0.5*fbm1(iChannel0,pos*vec3(8,1,8));\n            ks = f*8.0;\n            se = 12.0;\n            col = mix(vec3(0.40,0.22,0.15)*0.63,\n                      vec3(0.35,0.07,0.02)*0.2,f);\n            f = fbm1(iChannel0,pos*0.5);\n            col *= 1.0 + 1.1*f*vec3(0.5,1.0,1.5);\n          \tcol *= 1.0 + 0.2*cos(cma.y*23.0+vec3(0,0.2,0.5));\n            \n            float g = 0.5 + 0.5*fbm1(iChannel0,0.21*pos);\n            g -= 0.8*nor.x*nor.x;\n            snow *= smoothstep(0.2,0.6,g);\n        }\n        \/\/ forest\n        else if( tm.y<3.5 )\n        {\n            col = vec3(0.2,0.1,0.02)*0.7;\n            focc = cma.y*(0.7+0.3*nor.y);\n            occs = 100.0;\n        }\n        \/\/ ground\n        else if( tm.y<4.5 )\n        {\n            col = vec3(0.7,0.3,0.1)*0.12;\n            float d = smoothstep(1.0,6.0,pos.y-(-36.0));\n            col *= 0.2+0.8*d;\n            occs = 100.0;\n            snow = 1.0;\n        }\n\n        float fre = clamp(1.0+dot(nor,rd),0.0,1.0);\n        float occ = focc*calcOcclusion( pos, nor, time, occs, px );\n\n        snow *= smoothstep(0.25,0.3,nor.y);\n        if( abs(tm.y-2.0)<0.5 )\n        {\n            snow = max(snow,clamp(1.0-occ*occ*3.5,0.0,1.0));\n            snow = max(snow,cma.x);\n        }\n\n        col = mix( col, vec3(0.7,0.75,0.8)*0.6, snow);\n\t\t\n\t\t\n    \t\/\/ --------------------------\n        \/\/ lighting\n    \t\/\/ --------------------------\n        vec3 lin = vec3(0.0);\n\n        vec3  lig = normalize(vec3(0.5,0.4,0.6));\n        vec3  hal = normalize(lig-rd);\n        float dif = clamp(dot(nor,lig), 0.0, 1.0 );\n        \/\/float sha = 0.0; if( dif>0.001 ) sha=calcSoftshadow( pos, lig, 0.001, 500.0, time, 8.0 );\n        float sha = calcSoftshadow( pos, lig, 0.001, 500.0, time, 8.0 );\n        dif *= sha;\n        float spe = ks*pow(clamp(dot(nor,hal),0.0,1.0),se)*dif*(0.04+0.96*pow(clamp(1.0+dot(hal,rd),0.0,1.0),5.0));\n        vec3  amb = occ*vec3(0.55+0.45*nor.y);\n\n        lin += col*vec3(0.4,0.7,1.1)*amb;\n        lin += col*1.4*vec3(2.3,1.5,1.1)*dif;\n        lin += spe*2.0;\n        lin += snow*vec3(0.21,0.35,0.7)*fre*fre*fre*(0.5+0.5*dif*amb)*focc;\n\n        #if 1\n        if( abs(tm.y-2.0)<0.5 )\n        {\n\t\t\tfloat dif = max(0.2+0.8*dot(nor,vec3(-1,-0.3,0)),0.0);\n\t\t\tlin += col*vec3(0.58,0.29,0.14)*dif;\n        }\n\t\t#endif\n\t\tcol = lin;\n\n        col = mix( col, vec3(0.3,0.5,1.0)*0.25, 1.0-exp2(-0.0003*tmin) );\n    }\n\n    \/\/ sun flow\n    float glow = max(dot(rd,vec3(0.5,0.4,0.2)),0.0);\n    glow *= glow;\n    col += vec3(6.0,4.0,3.6)*glow*glow;\n\n    return vec4(col,tmin);\n}\n    \n\/\/ The main rendering entry point. Basically it does some\n\/\/ setup or creating the ray that will explore the 3D\n\/\/ scene in search of the landscape for each pixel, does\n\/\/ the rendering of the landscape, and performs the\n\/\/ Temporal Antialiasing before spiting out the color (in\n\/\/ linear space, not gama) and the deph of the scene.\n\/\/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ render\n    vec2 o = hash3( uint(iFrame) ).xy - 0.5;\n    vec2 p = (2.0*(fragCoord+o)-iResolution.xy)\/iResolution.y;\n        \n    float time = 2.0 + iTime;\n    \n    \/\/ skip pixels behind girl\n    #if 1\n    if( length((p-vec2(-0.56, 0.2))\/vec2(0.78,1.0))<0.85 ||\n        length((p-vec2(-0.56,-0.4))\/vec2(1.00,1.0))<0.73)\n    {\n        fragColor = vec4( 0.55,0.55,0.65,1e20 ); return;\n    }\n    #endif\n\n    \/\/ camera movement\t\n    vec3 ro; float fl;\n    mat3 ca = calcCamera( time, ro, fl );\n    vec3 rd = ca * normalize( vec3((p-vec2(-0.52,0.12))\/1.1,fl));\n\n    vec4 tmp = renderBackground(p,ro,rd,time,fragCoord);\n    vec3 col = tmp.xyz;\n\n    \/\/---------------------------------------------------------------\n\t\/\/ reproject from previous frame and average (cheap TAA, kind of)\n    \/\/---------------------------------------------------------------\n    \n    mat4 oldCam = mat4( textureLod(iChannel1,vec2(0.5,0.5)\/iResolution.xy, 0.0),\n                        textureLod(iChannel1,vec2(1.5,0.5)\/iResolution.xy, 0.0),\n                        textureLod(iChannel1,vec2(2.5,0.5)\/iResolution.xy, 0.0),\n                        0.0, 0.0, 0.0, 1.0 );\n    bool oldStarted = textureLod(iChannel1,vec2(3.5,0.5)\/iResolution.xy, 0.0).x>0.5;\n    \n    \/\/ world space\n    vec4 wpos = vec4(ro + rd*tmp.w,1.0);\n    \/\/ camera space\n    vec3 cpos = (wpos*oldCam).xyz; \/\/ note inverse multiply\n    \/\/ ndc space\n    vec2 npos = fl * cpos.xy \/ cpos.z;\n    \/\/ undo composition hack\n    npos = npos*1.1+vec2(-0.52,0.12); \n    \/\/ screen space\n    vec2 spos = 0.5 + 0.5*npos*vec2(iResolution.y\/iResolution.x,1.0);\n    \/\/ undo dither\n    spos -= o\/iResolution.xy;\n\t\/\/ raster space\n    vec2 rpos = spos * iResolution.xy;\n    \n    if( rpos.y<1.0 && rpos.x<4.0 )\n    {\n    }\n\telse\n    {\n        vec3 ocol = textureLod( iChannel1, spos, 0.0 ).xyz;\n    \tif( !oldStarted ) ocol = col;\n        col = mix( ocol, col, 0.1 );\n    }\n\n    \/\/----------------------------------\n    bool started = textureSize(iChannel0,0).x>=2 &&\n                   textureSize(iChannel2,0).x>=2 &&\n                   textureSize(iChannel3,0).x>=2;\n                           \n\tif( fragCoord.y<1.0 && fragCoord.x<4.0 )\n    {\n        if( abs(fragCoord.x-3.5)<0.5 ) fragColor = vec4( started?1.0:0.0, 0.0, 0.0, 0.0 );\n        if( abs(fragCoord.x-2.5)<0.5 ) fragColor = vec4( ca[2], -dot(ca[2],ro) );\n        if( abs(fragCoord.x-1.5)<0.5 ) fragColor = vec4( ca[1], -dot(ca[1],ro) );\n        if( abs(fragCoord.x-0.5)<0.5 ) fragColor = vec4( ca[0], -dot(ca[0],ro) );\n    }\n    else\n    {\n        fragColor = vec4( col, tmp.w );\n    }\n    \n    if( !started ) fragColor = vec4(0.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\/\/ Depth of Field (depth defocus) on the background. It's a basic\n\/\/ gather approach, where each pixel's neighborhood gets scanned\n\/\/ and the Circle of Confusion computed for each one of those\n\/\/ neighbor pixels. If the distance to the pixel is smaller than\n\/\/ the Circle of Confusion, the current pixel gets a contribution\n\/\/ from it with a weight that is inversely proportional to the\n\/\/ area of the Circle of Confusion, to conserve energy.\n\/\/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec4 ref = texelFetch( iChannel0, ivec2(fragCoord),0);\n    \n    vec2 q = fragCoord\/iResolution.xy;\n\n    vec4 acc = vec4(0.0);\n    const int N = 9;\n\tfor( int j=-N; j<=N; j++ )\n    for( int i=-N; i<=N; i++ )\n    {\n        vec2 off = vec2(float(i),float(j));\n        \n        vec4 tmp = texture( iChannel0, q + off\/vec2(1280.0,720.0) ); \n\n        float coc = 0.01 + 9.0*(1.0-1.0\/(1.0+0.01*abs(tmp.w)));\n        \n        if( dot(off,off) < coc*coc )\n        {\n            float w = 1.0\/(coc*coc); \n            acc += vec4(tmp.xyz*w,w);\n        }\n    }\n    vec3 col = acc.xyz \/ acc.w;\n\n    fragColor = vec4(col,ref.w);\n}\n","name":"Buffer B","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"MdlGW7","date":"1372661086","viewed":85252,"name":"Cloudy Terrain","username":"iq","description":"A terrain full of trees or something (up to your interpretation). Distance field raymarching for the terrain. Linearly volumetric raymarching for the foliage. Linearly volumetric raymarching for clouds. Plain plane Raytraced for lakes.","likes":486,"published":3,"flags":32,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Copyright Inigo Quilez, 2013 - https:\/\/iquilezles.org\/\n\/\/ I am the sole copyright owner of this Work.\n\/\/ You cannot host, display, distribute or share this Work in any form,\n\/\/ including physical and digital. You cannot use this Work in any\n\/\/ commercial or non-commercial product, website or project. You cannot\n\/\/ sell this Work and you cannot mint an NFTs of it.\n\/\/ I share this Work for educational purposes, and you can link to it,\n\/\/ through an URL, proper attribution and unmodified screenshot, as part\n\/\/ of your educational material. If these conditions are too restrictive\n\/\/ please contact me and we'll definitely work it out.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord\/iResolution.xy;\n    vec4 data = texture( iChannel0, uv );\n\n    vec3 col = vec3(0.0);\n    if( data.w < 0.0 )\n    {\n        col = texture( iChannel0, uv ).xyz;\n    }\n    else\n    {\n        \/\/ decompress velocity vector\n        float ss = mod(data.w,256.0)\/255.0;\n        float st = floor(data.w\/256.0)\/255.0;\n\n        \/\/ motion blur (linear blur across velocity vectors\n        vec2 dir = (-1.0 + 2.0*vec2( ss, st ))*0.25;\n        col = vec3(0.0);\n        for( int i=0; i<32; i++ )\n        {\n            float h = float(i)\/31.0;\n            vec2 pos = uv + dir*h;\n            col += texture( iChannel0, pos ).xyz;\n        }\n        col \/= 32.0;\n    }\n    \n    \/\/ vignetting\t\n\tcol *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 );\n\n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3Rn","filepath":"\/media\/a\/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"\/media\/ap\/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzn","filepath":"\/media\/a\/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"\/media\/ap\/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"\/media\/a\/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"\/media\/ap\/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    float a = textureLod( iChannel0, x.xy\/256.0 + (p.z+0.0)*120.7123, 0.0 ).x;\n    float b = textureLod( iChannel0, x.xy\/256.0 + (p.z+1.0)*120.7123, 0.0 ).x;\n\treturn mix( a, b, f.z );\n}\n\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n\nfloat envelope( vec3 p )\n{\n\tfloat isLake = 1.0-smoothstep( 0.62, 0.72, textureLod( iChannel0, 0.001*p.zx, 0.0).x );\n\treturn 0.1 + isLake*0.9*textureLod( iChannel1, 0.01*p.xz, 0.0 ).x;\n}\n\nfloat mapTerrain( in vec3 pos )\n{\n\treturn pos.y - envelope(pos);\n}\n\nfloat raymarchTerrain( in vec3 ro, in vec3 rd )\n{\n\tfloat maxd = 50.0;\n\tfloat precis = 0.001;\n    float h = 1.0;\n    float t = 0.0;\n    for( int i=0; i<80; i++ )\n    {\n        if( abs(h)<precis||t>maxd ) break;\n        t += h;\n\t    h = mapTerrain( ro+rd*t );\n    }\n\n    if( t>maxd ) t=-1.0;\n    return t;\n}\n\nvec3 lig = normalize( vec3(0.7,0.4,0.2) );\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.02,0.0,0.0);\n\treturn normalize( vec3(\n           mapTerrain(pos+eps.xyy) - mapTerrain(pos-eps.xyy),\n           0.5*2.0*eps.x,\n           mapTerrain(pos+eps.yyx) - mapTerrain(pos-eps.yyx) ) );\n\n}\n\nvec4 mapTrees( in vec3 pos, in vec3 rd )\n{\n    vec3  col = vec3(0.0);\t\n\tfloat den = 1.0;\n\n\tfloat kklake = textureLod( iChannel0, 0.001*pos.zx, 0.0).x;\n\tfloat isLake = smoothstep( 0.7, 0.71, kklake );\n\t\n\tif( pos.y>1.0 || pos.y<0.0 ) \n\t{\n\t\tden = 0.0;\n\t}\n\telse\n\t{\n\t\t\n\t\tfloat h = pos.y;\n\t\tfloat e = envelope( pos );\n\t\tfloat r = clamp(h\/e,0.0,1.0);\n\t\t\n        den = smoothstep( r, 1.0, textureLod(iChannel0, pos.xz*0.15, 0.0).x );\n        \n\t\tden *= 1.0-0.95*clamp( (r-0.75)\/(1.0-0.75) ,0.0,1.0);\n\t\t\n        float id = textureLod( iChannel0, pos.xz, 0.0).x;\n        float oc = pow( r, 2.0 );\n\n\t\tvec3  nor = calcNormal( pos );\n\t\tvec3  dif = vec3(1.0)*clamp( dot( nor, lig ), 0.0, 1.0 );\n\t\tfloat amb = 0.5 + 0.5*nor.y;\n\t\t\n\t\tfloat w = (2.8-pos.y)\/lig.y;\n\t\tfloat c = fbm( (pos+w*lig)*0.35 );\n\t\tc = smoothstep( 0.38, 0.6, c );\n\t\tdif *= pow( vec3(c), vec3(0.8, 1.0, 1.5 ) );\n\t\t\t\n\t\tvec3  brdf = 1.7*vec3(1.5,1.0,0.8)*dif*(0.1+0.9*oc) + 1.3*amb*vec3(0.1,0.15,0.2)*oc;\n\n\t\tvec3 mate = 0.6*vec3(0.5,0.5,0.1);\n\t\tmate += 0.3*textureLod( iChannel1, 0.1*pos.xz, 0.0 ).zyx;\n\t\t\n\t\tcol = brdf * mate;\n\n\t\tden *= 1.0-isLake;\n\t}\n\n\treturn vec4( col, den );\n}\n\n\nvec4 raymarchTrees( in vec3 ro, in vec3 rd, float tmax, vec3 bgcol, out float resT )\n{\n\tvec4 sum = vec4(0.0);\n    float t = tmax;\n\tfor( int i=0; i<512; i++ )\n\t{\n\t\tvec3 pos = ro + t*rd;\n\t\tif( sum.a>0.99 || pos.y<0.0  || t>20.0 ) break;\n\t\t\n\t\tvec4 col = mapTrees( pos, rd );\n\n\t\tcol.xyz = mix( col.xyz, bgcol, 1.0-exp(-0.0018*t*t) );\n        \n\t\tcol.rgb *= col.a;\n\n\t\tsum = sum + col*(1.0 - sum.a);\t\n\t\t\n\t\tt += 0.0035*t;\n\t}\n    \n    resT = t;\n\n\treturn clamp( sum, 0.0, 1.0 );\n}\n\nvec4 mapClouds( in vec3 p )\n{\n\tfloat d = 1.0-0.3*abs(2.8 - p.y);\n\td -= 1.6 * fbm( p*0.35 );\n\n\td = clamp( d, 0.0, 1.0 );\n\t\n\tvec4 res = vec4( d );\n\n\tres.xyz = mix( 0.8*vec3(1.0,0.95,0.8), 0.2*vec3(0.6,0.6,0.6), res.x );\n\tres.xyz *= 0.65;\n\t\n\treturn res;\n}\n\n\nvec4 raymarchClouds( in vec3 ro, in vec3 rd, in vec3 bcol, float tmax, out float rays, ivec2 px )\n{\n\tvec4 sum = vec4(0, 0, 0, 0);\n\trays = 0.0;\n    \n\tfloat sun = clamp( dot(rd,lig), 0.0, 1.0 );\n\tfloat t = 0.1*texelFetch( iChannel0, px&ivec2(255), 0 ).x;\n\tfor(int i=0; i<64; i++)\n\t{\n\t\tif( sum.w>0.99 || t>tmax ) break;\n\t\tvec3 pos = ro + t*rd;\n\t\tvec4 col = mapClouds( pos );\n\n\t\tfloat dt = max(0.1,0.05*t);\n\t\tfloat h = (2.8-pos.y)\/lig.y;\n\t\tfloat c = fbm( (pos + lig*h)*0.35 );\n\t\t\/\/kk += 0.05*dt*(smoothstep( 0.38, 0.6, c ))*(1.0-col.a);\n\t\trays += 0.02*(smoothstep( 0.38, 0.6, c ))*(1.0-col.a)*(1.0-smoothstep(2.75,2.8,pos.y));\n\t\n\t\t\n\t\tcol.xyz *= vec3(0.4,0.52,0.6);\n\t\t\n        col.xyz += vec3(1.0,0.7,0.4)*0.4*pow( sun, 6.0 )*(1.0-col.w);\n\t\t\n\t\tcol.xyz = mix( col.xyz, bcol, 1.0-exp(-0.0018*t*t) );\n\t\t\n\t\tcol.a *= 0.5;\n\t\tcol.rgb *= col.a;\n\n\t\tsum = sum + col*(1.0 - sum.a);\t\n\n\t\tt += dt;\/\/max(0.1,0.05*t);\n\t}\n    rays = clamp( rays, 0.0, 1.0 );\n\n\treturn clamp( sum, 0.0, 1.0 );\n}\n\nvec3 path( float time )\n{\n\treturn vec3( 32.0*cos(0.2+0.75*.1*time*1.5), 1.2, 32.0*sin(0.1+0.75*0.11*time*1.5) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid moveCamera( float time, out vec3 oRo, out vec3 oTa, out float oCr, out float oFl )\n{\n    \/\/ camera\t\n\toRo = path( time );\n\toTa = path( time+1.0 );\n\toTa.y *= 0.2;\n\toCr = 0.3*cos(0.07*time);\n    oFl = 1.75;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy \/ iResolution.xy;\n\tvec2 p = -1.0 + 2.0*q;\n\tp.x *= iResolution.x \/ iResolution.y;\n\t\n\tfloat time = 23.5+iTime;\n\t\n    \/\/ camera\t\n\tvec3 ro, ta;\n    float roll, fl;\n    moveCamera( time, ro, ta, roll, fl );\n        \n\t\/\/ camera tx\n    mat3 cam = setCamera( ro, ta, roll );\n\n    \/\/ ray direction\n    vec3 rd = normalize( cam * vec3(p.xy,fl) );\n\n    \/\/ sky\t \n\tvec3 col = vec3(0.84,0.95,1.0)*0.77 - rd.y*0.6;\n\tcol *= 0.75;\n\tfloat sun = clamp( dot(rd,lig), 0.0, 1.0 );\n    col += vec3(1.0,0.7,0.3)*0.3*pow( sun, 6.0 );\n\tvec3 bcol = col;\n\n    \/\/ lakes\n    float gt = (0.0-ro.y)\/rd.y;\n    if( gt>0.0 )\n    {\n        vec3 pos = ro + rd*gt;\n\n\t\tvec3 nor = vec3(0.0,1.0,0.0);\n\t    nor.xz  = 0.10*(-1.0 + 2.0*texture( iChannel3, 1.5*pos.xz ).xz);\n\t    nor.xz += 0.15*(-1.0 + 2.0*texture( iChannel3, 3.2*pos.xz ).xz);\n\t    nor.xz += 0.20*(-1.0 + 2.0*texture( iChannel3, 6.0*pos.xz ).xz);\n\tnor = normalize(nor);\n\n\t\tvec3 ref = reflect( rd, nor );\n\t    vec3 sref = reflect( rd, vec3(0.0,1.0,0.0) );\n\t\tfloat sunr = clamp( dot(ref,lig), 0.0, 1.0 );\n\n\t    float kklake = texture( iChannel0, 0.001*pos.zx).x;\n\t\tcol = vec3(0.1,0.1,0.0);\n        vec3 lcol = vec3(0.2,0.5,0.7);\n\t\tcol = mix( lcol, 1.1*vec3(0.2,0.6,0.7), 1.0-smoothstep(0.7,0.81,kklake) );\n\t\t\n\t\tcol *= 0.12;\n\n\t    float fre = 1.0 - max(sref.y,0.0);\n\t\tcol += 0.8*vec3(1.0,0.9,0.8)*pow( sunr, 64.0 )*pow(fre,1.0);\n\t\tcol += 0.5*vec3(1.0,0.9,0.8)*pow( fre, 10.0 );\n\n\t\tfloat h = (2.8-pos.y)\/lig.y;\n        float c = fbm( (pos+h*lig)*0.35 );\n\t\tcol *= 0.4 + 0.6*smoothstep( 0.38, 0.6, c );\n\n\t    col *= smoothstep(0.7,0.701,kklake);\n\n\t    col.xyz = mix( col.xyz, bcol, 1.0-exp(-0.0018*gt*gt) );\n    }\n\n\n    \/\/ terrain\t\n\tfloat t = raymarchTerrain(ro, rd);\n    if( t>0.0 )\n\t{\n        \/\/ trees\t\t\n        float ot;\n        vec4 res = raymarchTrees( ro, rd, t, bcol, ot );\n        t = ot;\n\t    col = col*(1.0-res.w) + res.xyz;\n\t}\n\n\t\/\/ sun glow\n    col += vec3(1.0,0.5,0.2)*0.35*pow( sun, 3.0 );\n\n    float rays = 0.0;\n    \/\/ clouds\t\n    {\n\tif( t<0.0 ) t=600.0;\n    vec4 res = raymarchClouds( ro, rd, bcol, t, rays, ivec2(fragCoord) );\n\tcol = col*(1.0-res.w) + res.xyz;\n\t}\n\n\tcol += (1.0-0.8*col)*rays*rays*rays*0.4*vec3(1.0,0.8,0.7);\n\tcol = clamp( col, 0.0, 1.0 );\n\n\t\n    \/\/ gamma\t\n\tcol = pow( col, vec3(0.45) );\n\n    \/\/ contrast, desat, tint and vignetting\t\n\tcol = col*0.1 + 0.9*col*col*(3.0-2.0*col);\n\tcol = mix( col, vec3(col.x+col.y+col.z)*0.33, 0.2 );\n\tcol *= vec3(1.06,1.05,1.0);\n\n    \/\/-------------------------------------\n\t\/\/ velocity vectors (through depth reprojection)\n    \/\/-------------------------------------\n    float vel = 0.0;\n    if( t<0.0 )\n    {\n        vel = -1.0;\n    }\n    else\n    {\n\n        \/\/ old camera position\n        float oldTime = time - 1.0\/30.0; \/\/ 1\/30 of a second blur\n        vec3 oldRo, oldTa; float oldCr, oldFl;\n        moveCamera( oldTime, oldRo, oldTa, oldCr, oldFl );\n        mat3 oldCam = setCamera( oldRo, oldTa, oldCr );\n\n        \/\/ world space\n        vec3 wpos = ro + rd*t;\n        \/\/ camera space\n        vec3 cpos = vec3( dot( wpos - oldRo, oldCam[0] ),\n                          dot( wpos - oldRo, oldCam[1] ),\n                          dot( wpos - oldRo, oldCam[2] ) );\n        \/\/ ndc space\n        vec2 npos = oldFl * cpos.xy \/ cpos.z;\n        \/\/ screen space\n        vec2 spos = 0.5 + 0.5*npos*vec2(iResolution.y\/iResolution.x,1.0);\n\n\n        \/\/ compress velocity vector in a single float\n        vec2 uv = fragCoord\/iResolution.xy;\n        spos = clamp( 0.5 + 0.5*(spos - uv)\/0.25, 0.0, 1.0 );\n        vel = floor(spos.x*255.0) + floor(spos.y*255.0)*256.0;\n    }\n    \n    fragColor = vec4( col, vel );\n}","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"lllBDM","date":"1512136004","viewed":21656,"name":"Goo","username":"noby","description":"A quick one evening doodle with semi-translucent material shading.","likes":486,"published":1,"flags":32,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Tone mapping and post processing\nfloat hash(float c){return fract(sin(dot(c,12.9898))*43758.5453);}\n\n\/\/ linear white point\nconst float W = 1.2;\nconst float T2 = 7.5;\n\nfloat filmic_reinhard_curve (float x) {\n    float q = (T2*T2 + 1.0)*x*x;    \n\treturn q \/ (q + x + T2*T2);\n}\n\nvec3 filmic_reinhard(vec3 x) {\n    float w = filmic_reinhard_curve(W);\n    return vec3(\n        filmic_reinhard_curve(x.r),\n        filmic_reinhard_curve(x.g),\n        filmic_reinhard_curve(x.b)) \/ w;\n}\n\nconst int N = 8;\nvec3 ca(sampler2D t, vec2 UV, vec4 sampl){\n\tvec2 uv = 1.0 - 2.0 * UV;\n\tvec3 c = vec3(0);\n\tfloat rf = 1.0;\n\tfloat gf = 1.0;\n    float bf = 1.0;\n\tfloat f = 1.0\/float(N);\n\tfor(int i = 0; i < N; ++i){\n\t\tc.r += f*texture(t, 0.5-0.5*(uv*rf) ).r;\n\t\tc.g += f*texture(t, 0.5-0.5*(uv*gf) ).g;\n\t\tc.b += f*texture(t, 0.5-0.5*(uv*bf) ).b;\n\t\trf *= 0.9972;\n\t\tgf *= 0.998;\n        bf \/= 0.9988;\n\t\tc = clamp(c,0.0, 1.0);\n\t}\n\treturn c;\n}\n\nvoid mainImage(out vec4 fragColor,vec2 fragCoord){\n    const float brightness = 1.0;\n    vec2 pp = fragCoord.xy\/iResolution.xy;\n    vec2 r = iResolution.xy;\n    vec2 p = 1.-2.*fragCoord.xy\/r.xy;\n    p.y *= r.y\/r.x;\n   \n    \/\/ a little chromatic aberration\n    vec4 sampl = texture(iChannel0, pp);\n    vec3 color = ca(iChannel0, pp, sampl).rgb;\n    \n    \/\/ final output\n    float vignette = 1.25 \/ (1.1 + 1.1*dot(p, p));\n    vignette *= vignette;\n    vignette = mix(1.0, smoothstep(0.1, 1.1, vignette), 0.25);\n    float noise = .012*vec3(hash(length(p)*iTime)).x;\n    color = color*vignette+noise;\n    color = filmic_reinhard(brightness*color);\n    \n    color = smoothstep(-0.025, 1.0,color);\n    \n    color = pow(color, vec3(1.0\/2.2));\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ MIT License: https:\/\/opensource.org\/licenses\/MIT\nconst float pi = 3.14159;\nmat3 rotate( in vec3 v, in float angle){\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\treturn mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n\t\t(1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n\t\t(1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\n\t\t);\n}\n\nvec3 hash(vec3 p){\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n\/\/ Gradient noise from iq\n\/\/ return value noise (in x) and its derivatives (in yzw)\nvec4 noised(vec3 x){\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n    \n    vec3 ga = hash( p+vec3(0.0,0.0,0.0) );\n    vec3 gb = hash( p+vec3(1.0,0.0,0.0) );\n    vec3 gc = hash( p+vec3(0.0,1.0,0.0) );\n    vec3 gd = hash( p+vec3(1.0,1.0,0.0) );\n    vec3 ge = hash( p+vec3(0.0,0.0,1.0) );\n\tvec3 gf = hash( p+vec3(1.0,0.0,1.0) );\n    vec3 gg = hash( p+vec3(0.0,1.0,1.0) );\n    vec3 gh = hash( p+vec3(1.0,1.0,1.0) );\n    \n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    \/\/ value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   \/\/ derivatives\n                 du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\n}\n\nfloat map(vec3 p){\n    \/\/ ugly hacky slow distance field with bad gradients\n    float d = p.y;\n    float c = max(0.0, pow(distance(p.xz, vec2(0,16)), 1.0));\n    float cc = pow(smoothstep(20.0, 5.0, c), 2.0);\n    \/\/p.xz *= cc;\n    vec4 n = noised(vec3(p.xz*0.07, iTime*0.5));\n    float nn = n.x * (length((n.yzw)));\n    n = noised(vec3(p.xz*0.173, iTime*0.639));\n    nn += 0.25*n.x * (length((n.yzw)));\n    nn = smoothstep(-0.5, 0.5, nn);\n    d = d-6.0*nn*(cc);\n    return d;\n}\n\nfloat err(float dist){\n    dist = dist\/100.0;\n    return min(0.01, dist*dist);\n}\n\nvec3 dr(vec3 origin, vec3 direction, vec3 position){\n    const int iterations = 3;\n    for(int i = 0; i < iterations; i++){\n        position = position + direction * (map(position) - err(distance(origin, position)));\n    }\n    return position;\n}\n\nvec3 intersect(vec3 ro, vec3 rd){\n\tvec3 p = ro+rd;\n\tfloat t = 0.;\n\tfor(int i = 0; i < 150; i++){\n        float d = 0.5*map(p);\n        t += d;\n        p += rd*d;\n\t\tif(d < 0.01 || t > 60.0) break;\n\t}\n    \n    \/\/ discontinuity reduction as described (somewhat) in\n    \/\/ their 2014 sphere tracing paper\n    p = dr(ro, rd, p);\n    return p;\n}\n\nvec3 normal(vec3 p){\n\tfloat e=0.01;\n\treturn normalize(vec3(map(p+vec3(e,0,0))-map(p-vec3(e,0,0)),\n\t                      map(p+vec3(0,e,0))-map(p-vec3(0,e,0)),\n\t                      map(p+vec3(0,0,e))-map(p-vec3(0,0,e))));\n}\n\nfloat G1V(float dnv, float k){\n    return 1.0\/(dnv*(1.0-k)+k);\n}\n\nfloat ggx(vec3 n, vec3 v, vec3 l, float rough, float f0){\n    float alpha = rough*rough;\n    vec3 h = normalize(v+l);\n    float dnl = clamp(dot(n,l), 0.0, 1.0);\n    float dnv = clamp(dot(n,v), 0.0, 1.0);\n    float dnh = clamp(dot(n,h), 0.0, 1.0);\n    float dlh = clamp(dot(l,h), 0.0, 1.0);\n    float f, d, vis;\n    float asqr = alpha*alpha;\n    const float pi = 3.14159;\n    float den = dnh*dnh*(asqr-1.0)+1.0;\n    d = asqr\/(pi * den * den);\n    dlh = pow(1.0-dlh, 5.0);\n    f = f0 + (1.0-f0)*dlh;\n    float k = alpha\/1.0;\n    vis = G1V(dnl, k)*G1V(dnv, k);\n    float spec = dnl * d * f * vis;\n    return spec;\n}\n\nfloat subsurface(vec3 p, vec3 v, vec3 n){\n    \/\/vec3 d = normalize(mix(v, -n, 0.5));\n    \/\/ suggested by Shane\n    vec3 d = refract(v, n, 1.0\/1.5);\n    vec3 o = p;\n    float a = 0.0;\n    \n    const float max_scatter = 2.5;\n    for(float i = 0.1; i < max_scatter; i += 0.2)\n    {\n        o += i*d;\n        float t = map(o);\n        a += t;\n    }\n    float thickness = max(0.0, -a);\n    const float scatter_strength = 16.0;\n\treturn scatter_strength*pow(max_scatter*0.5, 3.0)\/thickness;\n}\n\nvec3 shade(vec3 p, vec3 v){\n    vec3 lp = vec3(50,20,10);\n    vec3 ld = normalize(p+lp);\n    \n    vec3 n = normal(p);\n    float fresnel = pow( max(0.0, 1.0+dot(n, v)), 5.0 );\n    \n    vec3 final = vec3(0);\n    vec3 ambient = vec3(0.1, 0.06, 0.035);\n    vec3 albedo = vec3(0.75, 0.9, 0.35);\n    vec3 sky = vec3(0.5,0.65,0.8)*2.0;\n    \n    float lamb = max(0.0, dot(n, ld));\n    float spec = ggx(n, v, ld, 3.0, fresnel);\n    float ss = max(0.0, subsurface(p, v, n));\n    \n    \/\/ artistic license\n    lamb = mix(lamb, 3.5*smoothstep(0.0, 2.0, pow(ss, 0.6)), 0.7);\n    final = ambient + albedo*lamb+ 25.0*spec + fresnel*sky;\n    return vec3(final*0.5);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord \/ iResolution.xy;\n    vec3 a = vec3(0);\n    \n    \/\/ leftover stuff from something else, too lazy to remove\n    \/\/ don't ask\n    const float campos = 5.1;\n    float lerp = 0.5+0.5*cos(campos*0.4-pi);\n    lerp = smoothstep(0.13, 1.0, lerp);\n    vec3 c = mix(vec3(-0,217,0), vec3(0,4.4,-190), pow(lerp,1.0));\n    mat3 rot = rotate(vec3(1,0,0), pi\/2.0);\n    mat3 ro2 = rotate(vec3(1,0,0), -0.008*pi\/2.0);\n    \n    vec2 u2 = -1.0+2.0*uv;\n    u2.x *= iResolution.x\/iResolution.y;\n\n    vec3 d = mix(normalize(vec3(u2, 20)*rot), normalize(vec3(u2, 20))*ro2, pow(lerp,1.11));\n    d = normalize(d);\n\n    vec3 ii = intersect(c+145.0*d, d);\n    vec3 ss = shade(ii, d);\n    a += ss;\n    \n    fragColor.rgb = a*(0.99+0.02*hash(vec3(uv,0.001*iTime)));\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\/\/ FXAA implementation by mudlord (I think?)\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n    vec2 p = fragCoord.xy\/iResolution.xy;\n    vec2 pp = 1.0 \/ iResolution.xy;\n    vec4 color = texture(iChannel0, vec2(fragCoord.xy * pp));\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(texture(iChannel0, (fragCoord.xy + vec2(-1.0, -1.0)) * pp).xyz, luma);\n    float lumaNE = dot(texture(iChannel0, (fragCoord.xy + vec2(1.0, -1.0)) * pp).xyz, luma);\n    float lumaSW = dot(texture(iChannel0, (fragCoord.xy + vec2(-1.0, 1.0)) * pp).xyz, luma);\n    float lumaSE = dot(texture(iChannel0, (fragCoord.xy + vec2(1.0, 1.0)) * pp).xyz, luma);\n    float lumaM  = dot(color.xyz,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir = vec2(-((lumaNW + lumaNE) - (lumaSW + lumaSE)), ((lumaNW + lumaSW) - (lumaNE + lumaSE)));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * (1.0\/8.0)), (1.0\/128.0));\n\n    float rcpDirMin = 2.5 \/ (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(8.0, 8.0),\n              max(vec2(-8.0, -8.0),\n              dir * rcpDirMin)) * pp;\n\n    vec3 rgbA = 0.5 * (\n        texture(iChannel0, fragCoord.xy * pp + dir * (1.0 \/ 3.0 - 0.5)).xyz +\n        texture(iChannel0, fragCoord.xy * pp + dir * (2.0 \/ 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n        texture(iChannel0, fragCoord.xy * pp + dir * -0.5).xyz +\n        texture(iChannel0, fragCoord.xy * pp + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax)){\n        fragColor = vec4(rgbA, color.w);\n    } else {\n        fragColor = vec4(rgbB, color.w);\n    }\n\n}","name":"Buf B","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"4dSfRc","date":"1501424188","viewed":27004,"name":"[SH17C] Raymarching tutorial","username":"reinder","description":"The shader used as example in this tutorial can be found [url=https:\/\/www.shadertoy.com\/view\/4dSBz3]here[\/url].\n\nYou can navigate the slides using your arrow keys.","likes":333,"published":3,"flags":48,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"\/media\/previz\/buffer03.png","previewfilepath":"\/media\/previz\/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ [SH17C] Raymarching tutorial. Created by Reinder Nijhoff 2017\n\/\/ Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n\/\/ @reindernijhoff\n\/\/ \n\/\/ https:\/\/www.shadertoy.com\/view\/4dSfRc\n\/\/\n\/\/ In this tutorial you will learn how to render a 3d-scene in Shadertoy\n\/\/ using distance fields.\n\/\/\n\/\/ The tutorial itself is created in Shadertoy, and is rendered\n\/\/ using ray marching a distance field.\n\/\/\n\/\/ The shader studied in the tutorial can be found here: \n\/\/     https:\/\/www.shadertoy.com\/view\/4dSBz3\n\/\/\n\/\/ Created for the Shadertoy Competition 2017 \n\/\/\n\/\/ Most of the render code is taken from: 'Raymarching - Primitives' by Inigo Quilez.\n\/\/\n\/\/ You can find this shader here:\n\/\/     https:\/\/www.shadertoy.com\/view\/Xds3zN\n\/\/\n\n\/\/ COMPOSITE IMAGE\n\n#define SLIDE_FADE_STEPS 60\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    int SLIDE_STEPS_VISIBLE = int(texelFetch( iChannel0, ivec2(0,0), 0 ).y);\n    \n    vec4 current = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    vec4 prev    = texelFetch(iChannel2, ivec2(fragCoord), 0);\n    vec4 font    = texelFetch(iChannel3, ivec2(fragCoord), 0);\n\n\tfragColor = mix( prev, current, clamp( float(SLIDE_STEPS_VISIBLE)\/float(SLIDE_FADE_STEPS), 0., 1.) );\n    fragColor = mix( fragColor * .75, font, font.a );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"\/presets\/tex00.jpg","previewfilepath":"\/presets\/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"\/media\/a\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"\/media\/ap\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ [SH17C] Raymarching tutorial. Created by Reinder Nijhoff 2017\n\/\/ @reindernijhoff\n\/\/ \n\/\/ https:\/\/www.shadertoy.com\/view\/4dSfRc\n\/\/\n\/\/ In this tutorial you will learn how to render a 3d-scene in Shadertoy\n\/\/ using distance fields.\n\/\/\n\/\/ The tutorial itself is created in Shadertoy, and is rendered\n\/\/ using ray marching a distance field.\n\/\/\n\/\/ The shader studied in the tutorial can be found here: \n\/\/     https:\/\/www.shadertoy.com\/view\/4dSBz3\n\/\/\n\/\/ Created for the Shadertoy Competition 2017 \n\/\/\n\/\/ Most of the render code is taken from: 'Raymarching - Primitives' by Inigo Quilez.\n\/\/\n\/\/ You can find this shader here:\n\/\/     https:\/\/www.shadertoy.com\/view\/Xds3zN\n\/\/\n\n\/\/ SLIDE NAVIGATION FUNCTIONS\n\n\/\/ Load & store functions\n\n#define SLIDE_FADE_STEPS 45\n\n#define TITLE_DELAY   45\n#define BODY_DELAY   90\n#define CODE_DELAY   135\n#define FOOTER_DELAY 180\n\n#define NUM_SLIDES 25\n\nint SLIDE = 0;\nint SLIDE_STEPS_VISIBLE = 0;\n\nivec4 LoadVec4( in ivec2 vAddr ) {\n    return ivec4( texelFetch( iChannel0, vAddr, 0 ) );\n}\n\nbool AtAddress( ivec2 p, ivec2 c ) { return all( equal( floor(vec2(p)), vec2(c) ) ); }\n\nvoid StoreVec4( in ivec2 vAddr, in ivec4 vValue, inout vec4 fragColor, in ivec2 fragCoord ) {\n    fragColor = AtAddress( fragCoord, vAddr ) ? vec4(vValue) : fragColor;\n}\n\nvec4 LoadFVec4( in ivec2 vAddr ) {\n    return texelFetch( iChannel0, vAddr, 0 );\n}\n\nvoid StoreFVec4( in ivec2 vAddr, in vec4 vValue, inout vec4 fragColor, in ivec2 fragCoord ) {\n    fragColor = AtAddress( fragCoord, vAddr ) ? vValue : fragColor;\n}\n\n\/\/ key functions\n\n\/\/ Keyboard constants definition\nconst int KEY_SPACE = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_D     = 68;\nconst int KEY_S     = 83;\nconst int KEY_W     = 87;\n\n\nbool KP(int key) {\n\treturn texelFetch( iChannel1, ivec2(key, 0), 0 ).x > 0.0;\n}\n\nbool KT(int key) {\n\treturn texelFetch( iChannel1, ivec2(key, 2), 0 ).x > 0.0;\n}\n\n\/\/ slide logic\n\nstruct SlideDataStruct {\n    int title;\n    int titleDelay;\n    int body;\n    int bodyDelay;\n    int code;\n    int codeDelay;\n    vec3 ro;\n    vec3 ta;\n    int sceneMode;\n    int codeS;\n    int codeE;\n    int distMode;\n};\n\nSlideDataStruct temp;\nint tempCounter;\n\nbool createSlideData( \n    const int title,\n    const int titleDelay,\n    const int body,\n    const int bodyDelay,\n    const int code,\n    const int codeDelay,\n    const vec3 ro,\n    const vec3 ta,\n    const int sceneMode,\n    const int codeS,\n    const int codeE,\n\tconst int distMode ) {\n        \n    if(tempCounter == SLIDE) {\n        temp.title = title;\n  \t  \ttemp.titleDelay = titleDelay;\n   \t \ttemp.body = body;\n   \t \ttemp.bodyDelay =bodyDelay;\n   \t \ttemp.code = code;\n   \t\ttemp.codeDelay =codeDelay;\n   \t\ttemp.ro = ro;\n   \t\ttemp.ta = ta;\n   \t \ttemp.sceneMode = sceneMode;\n  \t \ttemp.codeS = codeS;\n  \t  \ttemp.codeE = codeE;\n\t\ttemp.distMode = distMode;\n        return true;\n    } else {\n    \ttempCounter++;\n        return false;\n    }\n}\n\nSlideDataStruct getSlideData() {\n    tempCounter = 0;\n    \n    \/\/ intro\n   if( createSlideData(1,TITLE_DELAY,1,BODY_DELAY,0,0, vec3(.0,0.,1.),vec3(0.,0.,-.5), 0, 0, 0, 0) ) return temp;\n\n    \/\/ intro - show bw scene\n   if( createSlideData(1,0,2,0,0,0, vec3(.0,0.,1.), vec3(0.,0.,-5.), -1, 0, 0, 0)) return temp;\n    \n    \/\/ create a ray - origin\n   if( createSlideData(2,TITLE_DELAY,3,BODY_DELAY,0,0, vec3(2.,1.,2.),vec3(0.,0.2,-1.3), 1, 0, 0, 0)) return temp;\n        \n    \/\/ create a ray - origin \/ code    \n   if( createSlideData(2,0,4,0,1,TITLE_DELAY, vec3(2.,1.,2.),vec3(0.,0.2,-1.3), 1, 1, 3, 0)) return temp;\n    \n    \/\/ place screen\n   if( createSlideData(2,0,5,TITLE_DELAY,0,0, vec3(2.,1.,2.),vec3(0.,0.2,-1.3), 2, 0, 0, 0)) return temp;\n    \n    \/\/ create rd\n   if( createSlideData(2,0,6,TITLE_DELAY,0,0, vec3(2.5,3.,2.5),vec3(0.,0.2,-1.3), 3, 0, 0, 0)) return temp;\n\n\t\/\/ create rd \/ code\n   if( createSlideData(2,0,7,0,1,TITLE_DELAY, vec3(2.5,3.,2.5),vec3(0.,0.2,-1.3), 3, 3, 0, 0)) return temp;\n   \n    \/\/ interact with scene\n   if( createSlideData(2,0,8,0,0,0, vec3(2.5,3.,2.5),vec3(0.,0.2,-1.3), 3, 3, 0, 0)) return temp;\n    \n    \/\/ distance fields intro\n   if( createSlideData(3,TITLE_DELAY,9,BODY_DELAY,0,0, vec3(1.,6.,2.),vec3(0.,0.2,-1.3), 3, 0, 0, 0)) return temp;\n    \n    \/\/ distance fields def\n   if( createSlideData(3,0,10,TITLE_DELAY,0,0, vec3(1.,6.,2.),vec3(0.,0.2,-1.3), 3, 0, 0, 0)) return temp;\n        \n    \/\/ distance fields one sphere\n   if( createSlideData(3,TITLE_DELAY,11,BODY_DELAY,0,0, vec3(1.,6.,-2.),vec3(-1.,-0.5,-2.), 4, 0, 0, 0)) return temp;\n    \n     \/\/ distance fields one sphere\n   if( createSlideData(3,0,11,0,0,0, vec3(1.,6.,-2.),vec3(-1.,-0.5,-2.), 4, 0, 0, 1)) return temp;\n      \n    \/\/ distance fields one sphere - code\n   if( createSlideData(3,0,12,0,2,TITLE_DELAY, vec3(1.,6.,-2.),vec3(-1.,-0.5,-2.), 4, 0, 3, 1)) return temp;\n    \n    \/\/ distance fields one three spheres\n   if( createSlideData(3,0,13,TITLE_DELAY,0,0, vec3(1.,6.,-2.),vec3(-1.,-0.5,-2.), 2, 0, 5, 2)) return temp;\n    \n    \/\/ distance fields one three spheres - in code\n   if( createSlideData(3,0,14,0,2,TITLE_DELAY, vec3(1.,6.,-2.),vec3(-1.,-0.5,-2.), 2, 0, 5, 2)) return temp;\n    \n    \/\/ distance fields one three spheres - full code\n   if( createSlideData(3,0,15,TITLE_DELAY,2,BODY_DELAY, vec3(1.,6.,-2.),vec3(-1.,-0.5,-2.), 2, 0, 0, 3)) return temp;\n        \n    \/\/ distance fields one three spheres - march\n   if( createSlideData(3,0,16,TITLE_DELAY,0,0, vec3(2.5,3.,1.5),vec3(0.,0.2,-1.3), 5, 0, 0, 4)) return temp;\n    \n    \/\/ distance fields one three spheres - march code\n   if( createSlideData(3,0,17,0,3,TITLE_DELAY, vec3(2.5,3.,1.5),vec3(0.,0.2,-1.3), 5, 0, 0, 4)) return temp;\n        \n    \/\/ distance fields one three spheres - interact\n   if( createSlideData(3,0,8,TITLE_DELAY,0,0, vec3(.5,2.,2.5),vec3(0.,0.2,-.3), 5, 0, 0, 4)) return temp;\n\n    \/\/ lighting - normal intro\n   if( createSlideData(4,TITLE_DELAY,18,BODY_DELAY,0,0, vec3(2.5,3.,1.5),vec3(0.,0.2,-1.3), 6, 0, 0, 0)) return temp;\n\n   \/\/ lighting - normal full\n   if( createSlideData(4,0,19,TITLE_DELAY,4,BODY_DELAY, vec3(4.5,3.,-1.5),vec3(0.,0.2,-1.3), 6, 0, 0, 0)) return temp;\n\n   \/\/ lighting - interact\n   if( createSlideData(4,0,8,TITLE_DELAY,0,0, vec3(4.5,3.,-1.5),vec3(0.,0.2,-1.3), 6, 0, 0, 0)) return temp;\n\n   \/\/ lighting - diffuse\n   if( createSlideData(4,0,20,TITLE_DELAY,0,0, vec3(.0,0.,1.),vec3(0.,0.,-.5), 0, 0, 0, 0)) return temp;\n\n   \/\/ lighting - diffuse\n   if( createSlideData(4,0,21,0,5,TITLE_DELAY, vec3(.0,0.,1.),vec3(0.,0.,-.5), -1, 0, 0, 0)) return temp;\n \n   \/\/ done\n   if( createSlideData(1,TITLE_DELAY,22,BODY_DELAY,0,0, vec3(.0,0.,1.),vec3(0.,0.,-.5), -1, 0, 0, 0)) return temp;\n \n    \n    return temp;\n}\n    \nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nfloat sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph ) {\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return 10000.0;\n\treturn -b - sqrt( h );\n}\n\nfloat iPlane(in vec3 ro, in vec3 rd, in float d) {\n\t\/\/ equation of a plane, y=0 = ro.y + t*rd.y\n    return -(ro.y+d)\/rd.y;\n}\n\nvec3 intersectScene( vec3 ro, vec3 ta, vec2 p,  bool intersectPlane ) {    \n    mat3 ca = setCamera( ro, ta, 0.0 );\n    vec3 rd = ca * normalize( vec3(p.xy,1.0) );\n    \n    float d = 1000.;\n    \/\/ sphere intersections ..\n    if( intersectPlane ) {\n\t    if( rd.y < 0. ) d = min(d, iPlane(ro, rd, 0.));\n    } else {\n    \td = min( d, sphIntersect( ro, rd, vec4(-1,0,-5,1) ));\n   \t\td = min( d, sphIntersect( ro, rd, vec4(2,0,-3,1) ));\n  \t  \td = min( d, sphIntersect( ro, rd, vec4(-2,0,-2,1) ));\n\n\t    if( rd.y < 0. ) d = min(d, iPlane(ro, rd, 1.));\n    }\n    \n    if( d < 100. ) {\n        return ro + d*rd;\n    } else {\n        return vec3(-1,0,-4);\n    }\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tivec2 uv = ivec2(fragCoord.xy);\n    \n    \/\/ wait for font-texture to load\n    if( iFrame == 0 || texelFetch(iChannel2, ivec2(0,0), 0).b < .1) {\n        vec4 ro = vec4(0,0,1,0);\n\t\tvec4 ta = vec4(0);\n        \n\t\tStoreFVec4( ivec2(0,3), ro, fragColor, uv);\n\t\tStoreFVec4( ivec2(0,4), ta, fragColor, uv);\n    } else if( uv.x < 2 && uv.y < 6) {\n        ivec4 slideData = LoadVec4( ivec2(0,0) );\n        SLIDE = slideData.x;\n        SLIDE_STEPS_VISIBLE = slideData.y;\n        SLIDE_STEPS_VISIBLE++;\n\n        if( SLIDE_STEPS_VISIBLE > 16 ) {\n            if( KP(KEY_SPACE) || KP(KEY_RIGHT) || KP(KEY_D) ) {\n                SLIDE++;\n                SLIDE_STEPS_VISIBLE=0;\n            }\n            if( KP(KEY_LEFT) || KP(KEY_W) ) {\n                SLIDE = (SLIDE + NUM_SLIDES - 1);\n                SLIDE_STEPS_VISIBLE=0;\n            }\n            \n            SLIDE = SLIDE % NUM_SLIDES; \n        }\n        \n        SlideDataStruct slide = getSlideData();\n        \n        \/\/ screen resolution\n        ivec4 res = LoadVec4( ivec2(1,0) );\n        if( res.x != int(iResolution.x) || res.y != int(iResolution.y) ) {\n            SLIDE_STEPS_VISIBLE = 0;\n        }\n        StoreVec4( ivec2(1,0), ivec4(iResolution.xy, 0,0), fragColor, uv );\n        \n\t\t\/\/ slide navigation               \n\t\tStoreVec4( ivec2(0,0), ivec4(SLIDE, SLIDE_STEPS_VISIBLE, slide.sceneMode, slide.distMode), fragColor, uv);\n        \n        \/\/ text \n        ivec4 showText1 = ivec4(0);\n        ivec4 showText2 = ivec4(0);\n        \n        if( SLIDE_STEPS_VISIBLE == 0) showText1.x = 1;\n        \n        if( slide.titleDelay == SLIDE_STEPS_VISIBLE) showText2.x = slide.title;\n        if( slide.bodyDelay == SLIDE_STEPS_VISIBLE) showText2.y = slide.body;\n        if( slide.codeDelay == SLIDE_STEPS_VISIBLE) showText2.z = slide.code;\n\n        showText1.y = slide.codeS;\n        showText1.z = slide.codeE;\n        \n\t\tStoreVec4( ivec2(0,1), showText1, fragColor, uv);\n\t\tStoreVec4( ivec2(0,2), showText2, fragColor, uv);\n        \n        \/\/ camera\n        \n        vec4 ro = LoadFVec4( ivec2(0,3) );\n        vec4 ta = LoadFVec4( ivec2(0,4) );\n        \n\t\tif(SLIDE_STEPS_VISIBLE > SLIDE_FADE_STEPS) {\n            ro.xyz = mix( ro.xyz, slide.ro, 0.055 );\n            ta.xyz = mix( ta.xyz, slide.ta, 0.055 );\n        }\n        \n\t\tStoreFVec4( ivec2(0,3), ro, fragColor, uv);\n\t\tStoreFVec4( ivec2(0,4), ta, fragColor, uv);\n                \n        if(iMouse.z > 0.) {\n            vec2 q = (iMouse.xy - .5 * iResolution.xy ) \/ iResolution.y;\n\t\t\tStoreFVec4( ivec2(0,5), vec4(intersectScene(ro.xyz, ta.xyz, q, slide.sceneMode == 5),1), fragColor, uv);\n        } else {\n\t\t\tStoreFVec4( ivec2(0,5), vec4(intersectScene(vec3(0,0,1), vec3(1,0,0), vec2(0), slide.sceneMode == 5),1), fragColor, uv);\n        }\n    } else {  \n\t    fragColor = vec4(0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\/\/ [SH17C] Raymarching tutorial. Created by Reinder Nijhoff 2017\n\/\/ @reindernijhoff\n\/\/ \n\/\/ https:\/\/www.shadertoy.com\/view\/4dSfRc\n\/\/\n\/\/ In this tutorial you will learn how to render a 3d-scene in Shadertoy\n\/\/ using distance fields.\n\/\/\n\/\/ The tutorial itself is created in Shadertoy, and is rendered\n\/\/ using ray marching a distance field.\n\/\/\n\/\/ The shader studied in the tutorial can be found here: \n\/\/     https:\/\/www.shadertoy.com\/view\/4dSBz3\n\/\/\n\/\/ Created for the Shadertoy Competition 2017 \n\/\/\n\/\/ Most of the render code is taken from: 'Raymarching - Primitives' by Inigo Quilez.\n\/\/\n\/\/ You can find this shader here:\n\/\/     https:\/\/www.shadertoy.com\/view\/Xds3zN\n\/\/\n\n\/\/ RENDER SCENE\n\n\n\/\/ Load & store functions\n\n#define SLIDE_FADE_STEPS 60\n\nint SLIDE = 0;\nint SLIDE_STEPS_VISIBLE = 0;\nint SCENE_MODE = 0;\nint DIST_MODE = 0;\nint MAX_MARCH_STEPS;\n\nvec3 intersections[7];\nvec3 intersectionNormal;\n\nfloat aspect;\nvec3 USER_INTERSECT;\n\nivec4 LoadVec4( in ivec2 vAddr ) {\n    return ivec4( texelFetch( iChannel0, vAddr, 0 ) );\n}\n\nvec4 LoadFVec4( in ivec2 vAddr ) {\n    return texelFetch( iChannel0, vAddr, 0 );\n}\n\nbool AtAddress( ivec2 p, ivec2 c ) { return all( equal( floor(vec2(p)), vec2(c) ) ); }\n\nvoid StoreVec4( in ivec2 vAddr, in ivec4 vValue, inout vec4 fragColor, in ivec2 fragCoord ) {\n    fragColor = AtAddress( fragCoord, vAddr ) ? vec4(vValue) : fragColor;\n}\n\nvoid loadData() {\n    ivec4 slideData = LoadVec4( ivec2(0,0) );\n    SLIDE = slideData.x;\n    SLIDE_STEPS_VISIBLE = slideData.y;\n    SCENE_MODE = slideData.z;\n\tDIST_MODE = slideData.w;\n}\n\n\n\/\/ tutorial Scene\nfloat tut_map(vec3 p) {\n    float d = distance(p, vec3(-1, 0, -5)) - 1.;\n    d = min(d, distance(p, vec3(2, 0, -3)) - 1.);\n    d = min(d, distance(p, vec3(-2, 0, -2)) - 1.);\n    d = min(d, p.y + 1.);\n    return d;\n}\n\nvec3 tut_calcNormal(in vec3 pos) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\n    return normalize(\n        e.xyy * tut_map(pos + e.xyy) +\n        e.yyx * tut_map(pos + e.yyx) +\n        e.yxy * tut_map(pos + e.yxy) +\n        e.xxx * tut_map(pos + e.xxx));\n}\n\nvec4 tut_render(in vec2 uv, const int steps) {\n    vec3 ro = vec3(0, 0, 1);\n    vec3 rd = normalize(vec3(uv, 0.) - ro);\n\n    float h, t = 1.;\n    for (int i = 0; i < steps; i++) {\n        h = tut_map((ro + rd * t));\n        t += h;\n        if (h < 0.01) break;\n    }\n\n    if (h < 0.01) {\n        vec3 p = ro + rd * t;\n        vec3 normal = tut_calcNormal(p);\n        vec3 light = vec3(0, 2, 0);\n\n        float dif = clamp(dot(normal, normalize(light - p)), 0., 1.);\n        dif *= 5. \/ dot(light - p, light - p);\n        return vec4(pow(vec3(dif), vec3(1. \/ 2.2)), 1);\n    } else {\n        return vec4(0, 0, 0, 1);\n    }\n}\n\n\/\/\n\/\/ render full scene\n\/\/\n\/\/ Most of this is taken from: 'Raymarching - Primitives' by Inigo Quilez.\n\/\/\n\/\/ You can find this shader here:\n\/\/     https:\/\/www.shadertoy.com\/view\/Xds3zN\n\/\/\n\n\/\/------------------------------------------------------------------\n\nfloat sdPlane( vec3 p, float d ) {\n\treturn p.y - d;\n}\n\nfloat sdSphere( vec3 p, float s ) {\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n\/\/------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 ) {\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n\/\/------------------------------------------------------------------\n\nvec2 map_0( in vec3 pos ) { \/\/ basic scene\n    vec2 res = opU( vec2( sdPlane(     pos, -1.), 1.0 ),\n\t                vec2( sdSphere(    pos-vec3(-1,0,-5),1.), 50. ) );\n    res = opU( res, vec2( sdSphere(    pos-vec3(2,0,-3),1.), 65. ) );\n    res = opU( res, vec2( sdSphere(    pos-vec3(-2,0,-2),1.),41. ) );\n        \n    return res;\n}\n\nvec2 map_1( in vec3 pos ) { \/\/ scene + ro\n    vec2 res = map_0(pos);\n    res = opU( res, vec2( sdSphere(    pos-vec3(0,0,1),.1),2. ) );\n    return res;\n}\n\nvec2 map_2( in vec3 pos ) { \/\/ scene + ro + screen\n    vec2 res = map_0(pos);\n            \n    res = opU( res, vec2( sdSphere(    pos-vec3(0,0,1),.1),3. ) );\n    res = opU( res, vec2( sdBox( pos,  vec3(.5*aspect, .5,.025)), 4.));\n    return res;\n}\n\nvec2 map_3( in vec3 pos ) { \/\/ scene + ro + rd + intersection\n    vec2 res = map_2(pos);\n    \n    res = opU( res, vec2( sdSphere(     pos-USER_INTERSECT,.1),2. ) );\n    res = opU( res, vec2( sdCapsule(    pos, vec3(0,0,1.), USER_INTERSECT,.025),2. ) );\n    \n    return res;\n}\n\nvec2 map_4( in vec3 pos ) { \/\/ scene + ro + one sphere\n    vec2 res = opU( vec2( sdPlane(     pos, -1.), 1.0 ),\n\t                vec2( sdSphere(    pos-vec3(-1,0,-5),1.), 50. ) );\n    \n    res = opU( res, vec2( sdSphere(    pos-vec3(0,0,1),.1),3. ) );\n    res = opU( res, vec2( sdBox( pos,  vec3(.5*aspect, .5,.025)), 4.));\n    \n    return res;\n}\n\nvec2 map_5( in vec3 pos ) { \/\/ scene + ro + screen + march steps\n    vec2 res = map_2(pos);\n    \n    res = opU( res, vec2( sdCapsule(    pos, vec3(0,0,1.), USER_INTERSECT,.025),3. ) );\n    for( int i=0; i<intersections.length(); i++ ){\n        if (i <= MAX_MARCH_STEPS) {\n\t    \tres = opU( res, vec2( sdSphere( pos-intersections[i],.1), (i==MAX_MARCH_STEPS)?2.:3. ) );\n        }\n    }\n    \n    return res;\n}\n\nvec2 map_6( in vec3 pos ) { \/\/ scene + ro + rd + intersection + normal\n    vec2 res = map_2(pos);\n    \n    res = opU( res, vec2( sdSphere(     pos-USER_INTERSECT,.1),3. ) );\n    res = opU( res, vec2( sdCapsule(    pos, USER_INTERSECT + intersectionNormal, USER_INTERSECT,.025),2. ) );\n    \n    res = opU( res, vec2( sdCapsule(    pos, vec3(0,0,1.), USER_INTERSECT,.025),3. ) );\n    return res;\n}\n\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = .5;\n    float tmax = 20.0;\n       \n    float t = tmin;\n    float m = -1.0;\n\n    if( SCENE_MODE == 0 ) {\n        for( int i=0; i<64; i++ )\n        {\n            float precis = 0.00005*t;\n            vec2 res = map_0( ro+rd*t );\n            if( res.x<precis || t>tmax ) break;\n            t += res.x;\n            m = res.y;\n        }\n    } else if( SCENE_MODE == 1 ) {\n        for( int i=0; i<64; i++ )\n        {\n            float precis = 0.00005*t;\n            vec2 res = map_1( ro+rd*t );\n            if( res.x<precis || t>tmax ) break;\n            t += res.x;\n            m = res.y;\n        }\n    } else if( SCENE_MODE == 2 ) {\n        for( int i=0; i<64; i++ )\n        {\n            float precis = 0.00005*t;\n            vec2 res = map_2( ro+rd*t );\n            if( res.x<precis || t>tmax ) break;\n            t += res.x;\n            m = res.y;\n        }\n    } else if( SCENE_MODE == 3 ) {\n        for( int i=0; i<64; i++ )\n        {\n            float precis = 0.00005*t;\n            vec2 res = map_3( ro+rd*t );\n            if( res.x<precis || t>tmax ) break;\n            t += res.x;\n            m = res.y;\n        }\n    } else if( SCENE_MODE == 4 ) {\n        for( int i=0; i<64; i++ )\n        {\n            float precis = 0.00005*t;\n            vec2 res = map_4( ro+rd*t );\n            if( res.x<precis || t>tmax ) break;\n            t += res.x;\n            m = res.y;\n        }\n    } else if( SCENE_MODE == 5 ) {\n        for( int i=0; i<64; i++ )\n        {\n            float precis = 0.00005*t;\n            vec2 res = map_5( ro+rd*t );\n            if( res.x<precis || t>tmax ) break;\n            t += res.x;\n            m = res.y;\n        }\n    }  else if( SCENE_MODE == 6 ) {\n        for( int i=0; i<64; i++ )\n        {\n            float precis = 0.00005*t;\n            vec2 res = map_6( ro+rd*t );\n            if( res.x<precis || t>tmax ) break;\n            t += res.x;\n            m = res.y;\n        }\n    } \n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint, h;\n    for( int i=0; i<16; i++ )\n    {\n        \n\t    if( SCENE_MODE == 0 ) {\n\t\t\th = map_0( ro + rd*t ).x;\n    \t} else if( SCENE_MODE == 1 ) {\n\t\t\th = map_1( ro + rd*t ).x;\n    \t} else if( SCENE_MODE == 2 ) {\n\t\t\th = map_2( ro + rd*t ).x;\n   \t\t} else if( SCENE_MODE == 3 ) {\n\t\t\th = map_3( ro + rd*t ).x;\n   \t\t} else if( SCENE_MODE == 4 ) {\n\t\t\th = map_4( ro + rd*t ).x;\n   \t\t} else if( SCENE_MODE == 5 ) {\n\t\t\th = map_5( ro + rd*t ).x;\n   \t\t} else if( SCENE_MODE == 6 ) {\n\t\t\th = map_6( ro + rd*t ).x;\n   \t\t}\n        \n        res = min( res, 8.0*h\/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    \n    if( SCENE_MODE == 0 ) {\n \t   return normalize( e.xyy*map_0( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map_0( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map_0( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map_0( pos + e.xxx ).x );\n    } else if( SCENE_MODE == 1 ) {\n            return normalize( e.xyy*map_1( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map_1( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map_1( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map_1( pos + e.xxx ).x );\n    } else if( SCENE_MODE == 2 ) {\n            return normalize( e.xyy*map_2( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map_2( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map_2( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map_2( pos + e.xxx ).x );\n    } else if( SCENE_MODE == 3 ) {\n            return normalize( e.xyy*map_3( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map_3( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map_3( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map_3( pos + e.xxx ).x );\n    } else if( SCENE_MODE == 4 ) {\n            return normalize( e.xyy*map_4( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map_4( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map_4( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map_4( pos + e.xxx ).x );\n    } else if( SCENE_MODE == 5 ) {\n            return normalize( e.xyy*map_5( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map_5( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map_5( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map_5( pos + e.xxx ).x );\n    } else if( SCENE_MODE == 6 ) {\n            return normalize( e.xyy*map_6( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map_6( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map_6( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map_6( pos + e.xxx ).x );\n    }\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0, dd;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)\/4.0;\n        vec3 aopos =  nor * hr + pos;\n\t    if( SCENE_MODE == 0 ) {\n\t\t\tdd = map_0( aopos ).x;\n    \t} else if( SCENE_MODE == 1 ) {\n\t\t\tdd = map_1( aopos ).x;\n    \t} else if( SCENE_MODE == 2 ) {\n\t\t\tdd = map_2( aopos ).x;\n   \t\t} else if( SCENE_MODE == 3 ) {\n\t\t\tdd = map_3( aopos ).x;\n   \t\t} else if( SCENE_MODE == 4 ) {\n\t\t\tdd = map_4( aopos ).x;\n   \t\t} else if( SCENE_MODE == 5 ) {\n\t\t\tdd = map_5( aopos ).x;\n   \t\t} else if( SCENE_MODE == 6 ) {\n\t\t\tdd = map_6( aopos ).x;\n   \t\t}\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.75,0.9,1.0) + max(rd.y*.8,0.);\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        \/\/ material        \n\t\tcol = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        if( m<1.5 ) {            \n            float f = mod( floor(1.0*pos.z) + floor(1.0*pos.x), 2.0);\n            col = 0.35 + 0.05*f*vec3(1.0);\n        } else if (m < 2.5 ) {\n            col = vec3(.5 + .3*sin(iTime*6.28318530718 ),0,0);\n        } else if (m < 3.5 ) {\n            col = vec3(.8,0,0);\n        } else if (m < 4.5 ) {\n            col = tut_render(pos.xy, 64).rgb;\n        }\n\n        \/\/ lighitng        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(0.4, 0.7, 0.6) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.30*dif*vec3(1.00,0.80,0.55);\n\t\tlin += 2.00*spe*vec3(1.00,0.90,0.70)*dif;\n        lin += 0.40*amb*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\n        \n        if( DIST_MODE > 0 ) {\n            \/\/ intersect with plane;\n            float d = -(ro.y)\/rd.y;\n            vec3 dint = ro + d*rd;\n            \n            float m = sdSphere(dint-vec3(-1,0,-5),1.);\n            \n            if( DIST_MODE > 1 ) { \n                m = min( m, sdSphere(dint-vec3(2,0,-3),1.));\n                m = min( m, sdSphere(dint-vec3(-2,0,-2),1.));\n            }\n            if( DIST_MODE > 2 ) { \n                m = min( m, dint.y + 1.);\n            }\n            vec3 dcol = vec3(abs(mod(m, 0.1)\/0.1 - 0.5));\n            dcol = mix( dcol, pal( m*.115+.6, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) ), .7);\n            \n            if( SCENE_MODE == 5) {\n                for( int i=0; i<intersections.length(); i++ ){\n                    if (i<MAX_MARCH_STEPS) {\n                        float dti = distance(intersections[i], dint);\n                        float mai = map_0(intersections[i]).x;\n                        float outer = smoothstep( mai-0.15, mai, dti);\n                        dcol = mix( dcol, vec3(1,0,0), .3*smoothstep( mai+0.01, mai, dti)*(outer+1.) );\n                    }\n                }            \n            }\n            if( d < t ) {\n                col = mix(col, dcol, .6);\n            }\n        }\n        \n    \tcol = mix( col, vec3(0.75,0.9,1.0), .05+.95* smoothstep(10.,20.,t) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nvec3 calcNormal_0( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    \n    return normalize( e.xyy*map_0( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map_0( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map_0( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map_0( pos + e.xxx ).x );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvec3 renderScene( vec2 p, vec3 ro, vec3 ta ) {\n    \/\/ camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \/\/ ray direction\n    vec3 rd = ca * normalize( vec3(p.xy,1.0) );\n    \/\/ render\t\n    vec3 col = render( ro, rd );\n    \n    return col;\n}\n\n\nvoid initIntersecions( in vec3 ro, in vec3 rd ) {\n    float t = 1.;\n    \n    for( int i=0; i<intersections.length(); i++ ){\n        vec2 res = map_0( ro+rd*t );\n        t += res.x;\n        intersections[i] = ro + rd*t;\n    }\n}\n\n\/\/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 q = (fragCoord.xy - .5 * iResolution.xy ) \/ iResolution.y;\n    \n    aspect = iResolution.x\/iResolution.y;\n    \n    loadData();\n    \n    if(SCENE_MODE == -1) {\n        fragColor = tut_render(q, 96);\n    } else {\n        vec3 ro = LoadFVec4( ivec2(0,3) ).xyz;\n        vec3 ta = LoadFVec4( ivec2(0,4) ).xyz;\n        USER_INTERSECT = LoadFVec4( ivec2(0,5) ).xyz;\n        \n        if( SCENE_MODE == 5 ) {\n            MAX_MARCH_STEPS = min(max(int( SLIDE_STEPS_VISIBLE\/40-1),0), intersections.length()-1);\n            \n            initIntersecions(vec3(0,0,1), normalize(USER_INTERSECT - vec3(0,0,1)) );\n            for (int i=0; i<intersections.length(); i++) {\n                if (i<MAX_MARCH_STEPS+1) {\n            \t\tUSER_INTERSECT = intersections[i];\n                }\n            }\n        }\n        if( SCENE_MODE == 6 ) {\n            intersectionNormal = calcNormal_0(USER_INTERSECT) * .5;\n        }\n        \n        fragColor = vec4(renderScene(q, ro, ta),1);\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\/\/ [SH17C] Raymarching tutorial. Created by Reinder Nijhoff 2017\n\/\/ @reindernijhoff\n\/\/ \n\/\/ https:\/\/www.shadertoy.com\/view\/4dSfRc\n\/\/\n\/\/ In this tutorial you will learn how to render a 3d-scene in Shadertoy\n\/\/ using distance fields.\n\/\/\n\/\/ The tutorial itself is created in Shadertoy, and is rendered\n\/\/ using ray marching a distance field.\n\/\/\n\/\/ The shader studied in the tutorial can be found here: \n\/\/     https:\/\/www.shadertoy.com\/view\/4dSBz3\n\/\/\n\/\/ Created for the Shadertoy Competition 2017 \n\/\/\n\/\/ Most of the render code is taken from: 'Raymarching - Primitives' by Inigo Quilez.\n\/\/\n\/\/ You can find this shader here:\n\/\/     https:\/\/www.shadertoy.com\/view\/Xds3zN\n\/\/\n\n\/\/ COPY LAST FRAME FOR FADES\n\n#define SLIDE_FADE_STEPS 60 \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    int SLIDE_STEPS_VISIBLE = int(texelFetch( iChannel0, ivec2(0,0), 0 ).y);\n    \n    if(iFrame == 0) {\n  \t\tfragColor = vec4(0,0,0,1);\n    } else if(SLIDE_STEPS_VISIBLE > SLIDE_FADE_STEPS) {\n  \t\tfragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    } else {\n    \tfragColor = texelFetch(iChannel2, ivec2(fragCoord), 0);\n    }\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGzr","filepath":"\/media\/a\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"\/media\/ap\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"\/media\/previz\/buffer03.png","previewfilepath":"\/media\/previz\/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\/\/ [SH17C] Raymarching tutorial. Created by Reinder Nijhoff 2017\n\/\/ @reindernijhoff\n\/\/ \n\/\/ https:\/\/www.shadertoy.com\/view\/4dSfRc\n\/\/\n\/\/ In this tutorial you will learn how to render a 3d-scene in Shadertoy\n\/\/ using distance fields.\n\/\/\n\/\/ The tutorial itself is created in Shadertoy, and is rendered\n\/\/ using ray marching a distance field.\n\/\/\n\/\/ The shader studied in the tutorial can be found here: \n\/\/     https:\/\/www.shadertoy.com\/view\/4dSBz3\n\/\/\n\/\/ Created for the Shadertoy Competition 2017 \n\/\/\n\/\/ Most of the render code is taken from: 'Raymarching - Primitives' by Inigo Quilez.\n\/\/\n\/\/ You can find this shader here:\n\/\/     https:\/\/www.shadertoy.com\/view\/Xds3zN\n\/\/\n\n\/\/ FONT RENDERING\n\n#define FONT_UV_WIDTH 160.\n\nivec4 LoadVec4( in ivec2 vAddr ) {\n    return ivec4( texelFetch( iChannel0, vAddr, 0 ) );\n}\n\nvoid drawStr(const uint str, const ivec2 c, const vec2 uv, const vec2 caret, const float size, const vec3 fontCol, inout vec4 outCol) {    \n    if( !(str == 0x0U || c.y < 0 || c.x < 0) ) {\n        int x = c.x % 4;\n        uint xy = (str >> ((3 - x) * 8)) % 256U;\n\n        if( xy > 0x0aU ) {\n            vec2 K = fract((uv - caret) \/ vec2(size * .45, size));\n            K.x = K.x * .6 + .2;\n            K.y = K.y * .95 - .05;\n            float d = textureLod(iChannel2, (K + vec2( xy & 0xFU, 0xFU - (xy >> 4))) \/ 16.,0.).a;\n\n            outCol.rgb = mix( fontCol, vec3(0) , smoothstep(.0,1.,smoothstep(.47,.53,d)) * .9 );\n            outCol.a = smoothstep(1.,0., smoothstep(.53,.59,d));\n        } \n    }\n}\n\nvoid mainImage( out vec4 outCol, in vec2 fragCoord ) {\n    ivec4 slideData = LoadVec4( ivec2(0,0) );\n    ivec4 text1 = LoadVec4(ivec2(0,1));\n    ivec4 text2 = LoadVec4(ivec2(0,2));\n\n    if( text1.x == 1 ) {\n        outCol = vec4(0);\n    } else {\n        outCol = texelFetch(iChannel1, ivec2(fragCoord), 0);    \n    }\n\n    vec2 uv = ((fragCoord-iResolution.xy*.5)\/iResolution.y) * FONT_UV_WIDTH;\n\n    if(text2.x > 0) { \/\/ title\n        int i = text2.x;\n\t\tuint f = 0x0U;\n\t\tif( i == 1 ) {\n\t\t\tivec2 c = ivec2( (uv - vec2(-79, 60)) * (1.\/vec2(5.85, -13)) + vec2(1,2)) - 1;\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x5261796dU : c.x < 8 ? 0x61726368U : c.x < 12 ? 0x696e6720U : c.x < 16 ? 0x64697374U : c.x < 20 ? 0x616e6365U : c.x < 24 ? 0x20666965U : c.x < 28 ? 0x6c647320U : f;\n\t\t\tdrawStr( f, c, uv, vec2(-79, 60), 13., vec3(255.\/255., 208.\/255., 128.\/255.), outCol );\t\t}\n\t\telse if( i == 2 ) {\n\t\t\tivec2 c = ivec2( (uv - vec2(-35.1, 60)) * (1.\/vec2(5.85, -13)) + vec2(1,2)) - 1;\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x43726561U : c.x < 8 ? 0x74652061U : c.x < 12 ? 0x20726179U : f;\n\t\t\tdrawStr( f, c, uv, vec2(-35.1, 60), 13., vec3(255.\/255., 208.\/255., 128.\/255.), outCol );\t\t}\n\t\telse if( i == 3 ) {\n\t\t\tivec2 c = ivec2( (uv - vec2(-43.9, 60)) * (1.\/vec2(5.85, -13)) + vec2(1,2)) - 1;\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x44697374U : c.x < 8 ? 0x616e6365U : c.x < 12 ? 0x20666965U : c.x < 16 ? 0x6c647320U : f;\n\t\t\tdrawStr( f, c, uv, vec2(-43.9, 60), 13., vec3(255.\/255., 208.\/255., 128.\/255.), outCol );\t\t}\n\t\telse if( i == 4 ) {\n\t\t\tivec2 c = ivec2( (uv - vec2(-23.4, 60)) * (1.\/vec2(5.85, -13)) + vec2(1,2)) - 1;\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x4c696768U : c.x < 8 ? 0x74696e67U : f;\n\t\t\tdrawStr( f, c, uv, vec2(-23.4, 60), 13., vec3(255.\/255., 208.\/255., 128.\/255.), outCol );\t\t}\n\n    }\n    if(text2.y > 0) { \/\/ body\n        int i = text2.y;\n\t\tivec2 c = ivec2( (uv - vec2(-120, 40)) * (1.\/vec2(3.6, -8)) + vec2(1,2)) - 1;\n\t\tuint f = 0x0U;\n\t\tif( i == 1 || i == 2 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x496e2074U : c.x < 8 ? 0x68697320U : c.x < 12 ? 0x7475746fU : c.x < 16 ? 0x7269616cU : c.x < 20 ? 0x20796f75U : c.x < 24 ? 0x2077696cU : c.x < 28 ? 0x6c206c65U : c.x < 32 ? 0x61726e20U : c.x < 36 ? 0x686f7720U : c.x < 40 ? 0x746f2072U : c.x < 44 ? 0x656e6465U : c.x < 48 ? 0x7220200aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x61203364U : c.x < 8 ? 0x2d736365U : c.x < 12 ? 0x6e652069U : c.x < 16 ? 0x6e205368U : c.x < 20 ? 0x61646572U : c.x < 24 ? 0x746f7920U : c.x < 28 ? 0x7573696eU : c.x < 32 ? 0x67206469U : c.x < 36 ? 0x7374616eU : c.x < 40 ? 0x63652066U : c.x < 44 ? 0x69656c64U : c.x < 48 ? 0x732e2020U : f;\n\t\t}\n\t\tif( i == 2 ) {\n\t\t\tif(c.y == 3) f = c.x < 4 ? 0x41732061U : c.x < 8 ? 0x6e206578U : c.x < 12 ? 0x616d706cU : c.x < 16 ? 0x652c2077U : c.x < 20 ? 0x65207769U : c.x < 24 ? 0x6c6c2063U : c.x < 28 ? 0x72656174U : c.x < 32 ? 0x65207468U : c.x < 36 ? 0x69732062U : c.x < 40 ? 0x6c61636bU : c.x < 44 ? 0x20616e64U : c.x < 48 ? 0x2020200aU : f;\n\t\t\tif(c.y == 4) f = c.x < 4 ? 0x77686974U : c.x < 8 ? 0x65207363U : c.x < 12 ? 0x656e6520U : c.x < 16 ? 0x6f662074U : c.x < 20 ? 0x68726565U : c.x < 24 ? 0x20737068U : c.x < 28 ? 0x65726573U : c.x < 32 ? 0x206f6e20U : c.x < 36 ? 0x6120706cU : c.x < 40 ? 0x616e652eU : f;\n\t\t}\n\t\telse if( i == 3 || i == 4 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x46697273U : c.x < 8 ? 0x74207765U : c.x < 12 ? 0x20637265U : c.x < 16 ? 0x61746520U : c.x < 20 ? 0x61207261U : c.x < 24 ? 0x792e200aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x54686520U : c.x < 8 ? 0x72617920U : c.x < 12 ? 0x6f726967U : c.x < 16 ? 0x696e2028U : c.x < 20 ? 0x726f2920U : c.x < 24 ? 0x77696c6cU : c.x < 28 ? 0x20626520U : c.x < 32 ? 0x61742028U : c.x < 36 ? 0x302c302cU : c.x < 40 ? 0x31292e20U : f;\n\t\t}\n\t\tif( i == 4 ) {\n\t\t\tif(c.y == 3) f = c.x < 4 ? 0x496e2063U : c.x < 8 ? 0x6f64653aU : f;\n\t\t}\n\t\telse if( i == 5 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x4e6f7720U : c.x < 8 ? 0x77652070U : c.x < 12 ? 0x6c616365U : c.x < 16 ? 0x20612076U : c.x < 20 ? 0x69727475U : c.x < 24 ? 0x616c2073U : c.x < 28 ? 0x63726565U : c.x < 32 ? 0x6e20696eU : c.x < 36 ? 0x20746865U : c.x < 40 ? 0x20736365U : c.x < 44 ? 0x6e652e0aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x49742069U : c.x < 8 ? 0x73206c6fU : c.x < 12 ? 0x63617465U : c.x < 16 ? 0x64206174U : c.x < 20 ? 0x20746865U : c.x < 24 ? 0x206f7269U : c.x < 28 ? 0x67696e20U : c.x < 32 ? 0x616e6420U : c.x < 36 ? 0x6861730aU : f;\n\t\t\tif(c.y == 2) f = c.x < 4 ? 0x64696d65U : c.x < 8 ? 0x6e73696fU : c.x < 12 ? 0x6e73206fU : c.x < 16 ? 0x66206173U : c.x < 20 ? 0x70656374U : c.x < 24 ? 0x5f726174U : c.x < 28 ? 0x696f2078U : c.x < 32 ? 0x20312e20U : f;\n\t\t}\n\t\telse if( i == 6 || i == 7 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x57652063U : c.x < 8 ? 0x6f6d7075U : c.x < 12 ? 0x74652074U : c.x < 16 ? 0x68652072U : c.x < 20 ? 0x61792064U : c.x < 24 ? 0x69726563U : c.x < 28 ? 0x74696f6eU : c.x < 32 ? 0x20287264U : c.x < 36 ? 0x2920666fU : c.x < 40 ? 0x72206561U : c.x < 44 ? 0x6368200aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x70697865U : c.x < 8 ? 0x6c202866U : c.x < 12 ? 0x72616743U : c.x < 16 ? 0x6f6f7264U : c.x < 20 ? 0x2e787929U : c.x < 24 ? 0x206f6620U : c.x < 28 ? 0x6f757220U : c.x < 32 ? 0x76697274U : c.x < 36 ? 0x75616c20U : c.x < 40 ? 0x73637265U : c.x < 44 ? 0x656e2e20U : f;\n\t\t}\n\t\tif( i == 7 ) {\n\t\t\tif(c.y == 3) f = c.x < 4 ? 0x496e2063U : c.x < 8 ? 0x6f64653aU : f;\n\t\t}\n\t\telse if( i == 8 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x55736520U : c.x < 8 ? 0x796f7572U : c.x < 12 ? 0x206d6f75U : c.x < 16 ? 0x73652074U : c.x < 20 ? 0x6f20696eU : c.x < 24 ? 0x74657261U : c.x < 28 ? 0x63742077U : c.x < 32 ? 0x69746820U : c.x < 36 ? 0x74686520U : c.x < 40 ? 0x7363656eU : c.x < 44 ? 0x652e2020U : f;\n\t\t}\n\t\telse if( i == 9 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x41206469U : c.x < 8 ? 0x7374616eU : c.x < 12 ? 0x63652066U : c.x < 16 ? 0x69656c64U : c.x < 20 ? 0x20697320U : c.x < 24 ? 0x75736564U : c.x < 28 ? 0x20746f20U : c.x < 32 ? 0x66696e64U : c.x < 36 ? 0x20746865U : c.x < 40 ? 0x2020200aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x696e7465U : c.x < 8 ? 0x72736563U : c.x < 12 ? 0x74696f6eU : c.x < 16 ? 0x206f6620U : c.x < 20 ? 0x6f757220U : c.x < 24 ? 0x72617920U : c.x < 28 ? 0x28726f2cU : c.x < 32 ? 0x20726429U : c.x < 36 ? 0x20616e64U : c.x < 40 ? 0x20746865U : c.x < 44 ? 0x20737068U : c.x < 48 ? 0x65726573U : c.x < 52 ? 0x2020200aU : f;\n\t\t\tif(c.y == 2) f = c.x < 4 ? 0x616e6420U : c.x < 8 ? 0x706c616eU : c.x < 12 ? 0x65206f66U : c.x < 16 ? 0x20746865U : c.x < 20 ? 0x20736365U : c.x < 24 ? 0x6e652e20U : f;\n\t\t}\n\t\telse if( i == 10 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x41206469U : c.x < 8 ? 0x7374616eU : c.x < 12 ? 0x63652066U : c.x < 16 ? 0x69656c64U : c.x < 20 ? 0x20697320U : c.x < 24 ? 0x61206675U : c.x < 28 ? 0x6e637469U : c.x < 32 ? 0x6f6e2074U : c.x < 36 ? 0x68617420U : c.x < 40 ? 0x67697665U : c.x < 44 ? 0x7320616eU : c.x < 48 ? 0x2020200aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x65737469U : c.x < 8 ? 0x6d617465U : c.x < 12 ? 0x20286120U : c.x < 16 ? 0x6c6f7765U : c.x < 20 ? 0x7220626fU : c.x < 24 ? 0x756e6420U : c.x < 28 ? 0x6f662920U : c.x < 32 ? 0x74686520U : c.x < 36 ? 0x64697374U : c.x < 40 ? 0x616e6365U : c.x < 44 ? 0x20746f20U : c.x < 48 ? 0x7468650aU : f;\n\t\t\tif(c.y == 2) f = c.x < 4 ? 0x636c6f73U : c.x < 8 ? 0x65737420U : c.x < 12 ? 0x73757266U : c.x < 16 ? 0x61636520U : c.x < 20 ? 0x61742061U : c.x < 24 ? 0x6e792070U : c.x < 28 ? 0x6f696e74U : c.x < 32 ? 0x20696e20U : c.x < 36 ? 0x73706163U : c.x < 40 ? 0x652e2020U : f;\n\t\t}\n\t\telse if( i == 11 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x54686520U : c.x < 8 ? 0x64697374U : c.x < 12 ? 0x616e6365U : c.x < 16 ? 0x2066756eU : c.x < 20 ? 0x6374696fU : c.x < 24 ? 0x6e20666fU : c.x < 28 ? 0x72206120U : c.x < 32 ? 0x73706865U : c.x < 36 ? 0x72652069U : c.x < 40 ? 0x73207468U : c.x < 44 ? 0x65206469U : c.x < 48 ? 0x7374616eU : c.x < 52 ? 0x63652074U : c.x < 56 ? 0x6f20200aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x74686520U : c.x < 8 ? 0x63656e74U : c.x < 12 ? 0x6572206fU : c.x < 16 ? 0x66207468U : c.x < 20 ? 0x65207370U : c.x < 24 ? 0x68657265U : c.x < 28 ? 0x206d696eU : c.x < 32 ? 0x75732074U : c.x < 36 ? 0x68652072U : c.x < 40 ? 0x61646975U : c.x < 44 ? 0x73206f66U : c.x < 48 ? 0x20746865U : c.x < 52 ? 0x20737068U : c.x < 56 ? 0x6572652eU : f;\n\t\t}\n\t\telse if( i == 12 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x54686520U : c.x < 8 ? 0x636f6465U : c.x < 12 ? 0x20666f72U : c.x < 16 ? 0x20612073U : c.x < 20 ? 0x70686572U : c.x < 24 ? 0x65206c6fU : c.x < 28 ? 0x63617465U : c.x < 32 ? 0x64206174U : c.x < 36 ? 0x20282d31U : c.x < 40 ? 0x2c302c2dU : c.x < 44 ? 0x35293a20U : f;\n\t\t}\n\t\telse if( i == 13 || i == 14 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x57652063U : c.x < 8 ? 0x6f6d6269U : c.x < 12 ? 0x6e652064U : c.x < 16 ? 0x69666665U : c.x < 20 ? 0x72656e74U : c.x < 24 ? 0x20646973U : c.x < 28 ? 0x74616e63U : c.x < 32 ? 0x65206675U : c.x < 36 ? 0x6e637469U : c.x < 40 ? 0x6f6e7320U : c.x < 44 ? 0x62792074U : c.x < 48 ? 0x616b696eU : c.x < 52 ? 0x6720200aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x74686520U : c.x < 8 ? 0x6d696e69U : c.x < 12 ? 0x6d756d20U : c.x < 16 ? 0x76616c75U : c.x < 20 ? 0x65206f66U : c.x < 24 ? 0x20746865U : c.x < 28 ? 0x73652066U : c.x < 32 ? 0x756e6374U : c.x < 36 ? 0x696f6e73U : c.x < 40 ? 0x2e202020U : f;\n\t\t}\n\t\tif( i == 14 ) {\n\t\t\tif(c.y == 3) f = c.x < 4 ? 0x496e2063U : c.x < 8 ? 0x6f64653aU : f;\n\t\t}\n\t\telse if( i == 15 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x54686520U : c.x < 8 ? 0x746f7461U : c.x < 12 ? 0x6c206469U : c.x < 16 ? 0x7374616eU : c.x < 20 ? 0x63652066U : c.x < 24 ? 0x756e6374U : c.x < 28 ? 0x696f6e20U : c.x < 32 ? 0x666f7220U : c.x < 36 ? 0x74686973U : c.x < 40 ? 0x20736365U : c.x < 44 ? 0x6e65200aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x28696e63U : c.x < 8 ? 0x6c756469U : c.x < 12 ? 0x6e672074U : c.x < 16 ? 0x68652070U : c.x < 20 ? 0x6c616e65U : c.x < 24 ? 0x29206973U : c.x < 28 ? 0x20676976U : c.x < 32 ? 0x656e2062U : c.x < 36 ? 0x793a2020U : f;\n\t\t}\n\t\telse if( i == 16 || i == 17 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x4e6f7720U : c.x < 8 ? 0x77652063U : c.x < 12 ? 0x616e206dU : c.x < 16 ? 0x61726368U : c.x < 20 ? 0x20746865U : c.x < 24 ? 0x20736365U : c.x < 28 ? 0x6e652066U : c.x < 32 ? 0x726f6d20U : c.x < 36 ? 0x726f2069U : c.x < 40 ? 0x6e206469U : c.x < 44 ? 0x72656374U : c.x < 48 ? 0x696f6e20U : c.x < 52 ? 0x72642e0aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x45616368U : c.x < 8 ? 0x20737465U : c.x < 12 ? 0x70207369U : c.x < 16 ? 0x7a652069U : c.x < 20 ? 0x73206769U : c.x < 24 ? 0x76656e20U : c.x < 28 ? 0x62792074U : c.x < 32 ? 0x68652064U : c.x < 36 ? 0x69737461U : c.x < 40 ? 0x6e636520U : c.x < 44 ? 0x6669656cU : c.x < 48 ? 0x642e2020U : f;\n\t\t}\n\t\tif( i == 17 ) {\n\t\t\tif(c.y == 3) f = c.x < 4 ? 0x57652073U : c.x < 8 ? 0x746f7020U : c.x < 12 ? 0x74686520U : c.x < 16 ? 0x6d617263U : c.x < 20 ? 0x68207768U : c.x < 24 ? 0x656e2077U : c.x < 28 ? 0x65206669U : c.x < 32 ? 0x6e642061U : c.x < 36 ? 0x6e20696eU : c.x < 40 ? 0x74657273U : c.x < 44 ? 0x65637469U : c.x < 48 ? 0x6f6e3a20U : f;\n\t\t}\n\t\telse if( i == 18 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x4e6f7720U : c.x < 8 ? 0x74686174U : c.x < 12 ? 0x20776520U : c.x < 16 ? 0x68617665U : c.x < 20 ? 0x20666f75U : c.x < 24 ? 0x6e642074U : c.x < 28 ? 0x68652069U : c.x < 32 ? 0x6e746572U : c.x < 36 ? 0x73656374U : c.x < 40 ? 0x696f6e20U : c.x < 44 ? 0x2870203dU : c.x < 48 ? 0x20726f20U : c.x < 52 ? 0x2b207264U : c.x < 56 ? 0x202a2074U : c.x < 60 ? 0x2920200aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x666f7220U : c.x < 8 ? 0x6f757220U : c.x < 12 ? 0x7261792cU : c.x < 16 ? 0x20776520U : c.x < 20 ? 0x63616e20U : c.x < 24 ? 0x67697665U : c.x < 28 ? 0x20746865U : c.x < 32 ? 0x20736365U : c.x < 36 ? 0x6e652073U : c.x < 40 ? 0x6f6d6520U : c.x < 44 ? 0x6c696768U : c.x < 48 ? 0x74696e67U : c.x < 52 ? 0x2e20200aU : f;\n\t\t\tif(c.y == 2) f = c.x < 4 ? 0x2020200aU : f;\n\t\t\tif(c.y == 3) f = c.x < 4 ? 0x546f2061U : c.x < 8 ? 0x70706c79U : c.x < 12 ? 0x20646966U : c.x < 16 ? 0x66757365U : c.x < 20 ? 0x206c6967U : c.x < 24 ? 0x6874696eU : c.x < 28 ? 0x67207765U : c.x < 32 ? 0x20686176U : c.x < 36 ? 0x6520746fU : c.x < 40 ? 0x2063616cU : c.x < 44 ? 0x63756c61U : c.x < 48 ? 0x7465200aU : f;\n\t\t\tif(c.y == 4) f = c.x < 4 ? 0x74686520U : c.x < 8 ? 0x6e6f726dU : c.x < 12 ? 0x616c206fU : c.x < 16 ? 0x66207368U : c.x < 20 ? 0x6164696eU : c.x < 24 ? 0x6720706fU : c.x < 28 ? 0x696e7420U : c.x < 32 ? 0x702e2020U : f;\n\t\t}\n\t\telse if( i == 19 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x54686520U : c.x < 8 ? 0x6e6f726dU : c.x < 12 ? 0x616c2063U : c.x < 16 ? 0x616e2062U : c.x < 20 ? 0x65206361U : c.x < 24 ? 0x6c63756cU : c.x < 28 ? 0x61746564U : c.x < 32 ? 0x20627920U : c.x < 36 ? 0x74616b69U : c.x < 40 ? 0x6e672074U : c.x < 44 ? 0x68652063U : c.x < 48 ? 0x656e7472U : c.x < 52 ? 0x616c200aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x64696666U : c.x < 8 ? 0x6572656eU : c.x < 12 ? 0x63657320U : c.x < 16 ? 0x6f6e2074U : c.x < 20 ? 0x68652064U : c.x < 24 ? 0x69737461U : c.x < 28 ? 0x6e636520U : c.x < 32 ? 0x6669656cU : c.x < 36 ? 0x643a2020U : f;\n\t\t}\n\t\telse if( i == 20 || i == 21 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x57652063U : c.x < 8 ? 0x616c6375U : c.x < 12 ? 0x6c617465U : c.x < 16 ? 0x20746865U : c.x < 20 ? 0x20646966U : c.x < 24 ? 0x66757365U : c.x < 28 ? 0x206c6967U : c.x < 32 ? 0x6874696eU : c.x < 36 ? 0x6720666fU : c.x < 40 ? 0x7220610aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x706f696eU : c.x < 8 ? 0x74206c69U : c.x < 12 ? 0x67687420U : c.x < 16 ? 0x61742070U : c.x < 20 ? 0x6f736974U : c.x < 24 ? 0x696f6e20U : c.x < 28 ? 0x28302c32U : c.x < 32 ? 0x2c30292eU : f;\n\t\t}\n\t\tif( i == 21 ) {\n\t\t\tif(c.y == 3) f = c.x < 4 ? 0x496e2063U : c.x < 8 ? 0x6f64653aU : f;\n\t\t}\n\t\telse if( i == 22 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x416e6420U : c.x < 8 ? 0x77652061U : c.x < 12 ? 0x72652064U : c.x < 16 ? 0x6f6e6521U : c.x < 20 ? 0x2020200aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x2020200aU : f;\n\t\t\tif(c.y == 2) f = c.x < 4 ? 0x41646469U : c.x < 8 ? 0x6e672061U : c.x < 12 ? 0x6d626965U : c.x < 16 ? 0x6e74206fU : c.x < 20 ? 0x63636c75U : c.x < 24 ? 0x73696f6eU : c.x < 28 ? 0x2c202866U : c.x < 32 ? 0x616b6529U : c.x < 36 ? 0x20726566U : c.x < 40 ? 0x6c656374U : c.x < 44 ? 0x696f6e73U : c.x < 48 ? 0x2c20200aU : f;\n\t\t\tif(c.y == 3) f = c.x < 4 ? 0x736f6674U : c.x < 8 ? 0x20736861U : c.x < 12 ? 0x646f7773U : c.x < 16 ? 0x2c20666fU : c.x < 20 ? 0x672c2061U : c.x < 24 ? 0x6d626965U : c.x < 28 ? 0x6e74206cU : c.x < 32 ? 0x69676874U : c.x < 36 ? 0x696e6720U : c.x < 40 ? 0x616e6420U : c.x < 44 ? 0x73706563U : c.x < 48 ? 0x756c6172U : c.x < 52 ? 0x206c6967U : c.x < 56 ? 0x6874696eU : c.x < 60 ? 0x6720200aU : f;\n\t\t\tif(c.y == 4) f = c.x < 4 ? 0x6973206cU : c.x < 8 ? 0x65667420U : c.x < 12 ? 0x61732061U : c.x < 16 ? 0x6e206578U : c.x < 20 ? 0x65726369U : c.x < 24 ? 0x73652066U : c.x < 28 ? 0x6f722074U : c.x < 32 ? 0x68652072U : c.x < 36 ? 0x65616465U : c.x < 40 ? 0x722e2020U : f;\n\t\t}\n\t\tdrawStr( f, c, uv, vec2(-120, 40), 8., vec3(1), outCol );\n    }\n    if(text2.z > 0) { \/\/ code\n        int i = text2.z;\n\t\tivec2 c = ivec2( (uv - vec2(-120, 0)) * (1.\/vec2(3.6, -8)) + vec2(1,2)) - 1;\n\t\tuint f = 0x0U;\n\t\tif( i == 1 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x766f6964U : c.x < 8 ? 0x206d6169U : c.x < 12 ? 0x6e496d61U : c.x < 16 ? 0x6765286fU : c.x < 20 ? 0x75742076U : c.x < 24 ? 0x65633420U : c.x < 28 ? 0x66726167U : c.x < 32 ? 0x436f6c6fU : c.x < 36 ? 0x722c2069U : c.x < 40 ? 0x6e207665U : c.x < 44 ? 0x63322066U : c.x < 48 ? 0x72616743U : c.x < 52 ? 0x6f6f7264U : c.x < 56 ? 0x29207b0aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x76656333U : c.x < 12 ? 0x20726f20U : c.x < 16 ? 0x3d207665U : c.x < 20 ? 0x63332830U : c.x < 24 ? 0x2c20302cU : c.x < 28 ? 0x2031293bU : c.x < 32 ? 0x2020200aU : f;\n\t\t\tif(c.y == 2) f = c.x < 4 ? 0x2020200aU : f;\n\t\t\tif(c.y == 3) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x76656332U : c.x < 12 ? 0x2071203dU : c.x < 16 ? 0x20286672U : c.x < 20 ? 0x6167436fU : c.x < 24 ? 0x6f72642eU : c.x < 28 ? 0x7879202dU : c.x < 32 ? 0x202e3520U : c.x < 36 ? 0x2a206952U : c.x < 40 ? 0x65736f6cU : c.x < 44 ? 0x7574696fU : c.x < 48 ? 0x6e2e7879U : c.x < 52 ? 0x2029202fU : c.x < 56 ? 0x20695265U : c.x < 60 ? 0x736f6c75U : c.x < 64 ? 0x74696f6eU : c.x < 68 ? 0x2e793b0aU : f;\n\t\t\tif(c.y == 4) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x76656333U : c.x < 12 ? 0x20726420U : c.x < 16 ? 0x3d206e6fU : c.x < 20 ? 0x726d616cU : c.x < 24 ? 0x697a6528U : c.x < 28 ? 0x76656333U : c.x < 32 ? 0x28712c20U : c.x < 36 ? 0x302e2920U : c.x < 40 ? 0x2d20726fU : c.x < 44 ? 0x293b200aU : f;\n\t\t}\n\t\telse if( i == 2 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x666c6f61U : c.x < 8 ? 0x74206d61U : c.x < 12 ? 0x70287665U : c.x < 16 ? 0x63332070U : c.x < 20 ? 0x29207b0aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x666c6f61U : c.x < 12 ? 0x74206420U : c.x < 16 ? 0x3d206469U : c.x < 20 ? 0x7374616eU : c.x < 24 ? 0x63652870U : c.x < 28 ? 0x2c207665U : c.x < 32 ? 0x6333282dU : c.x < 36 ? 0x312c2030U : c.x < 40 ? 0x2c202d35U : c.x < 44 ? 0x2929202dU : c.x < 48 ? 0x20312e3bU : c.x < 52 ? 0x2020200aU : f;\n\t\t\tif(c.y == 2) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x64203d20U : c.x < 12 ? 0x6d696e28U : c.x < 16 ? 0x642c2064U : c.x < 20 ? 0x69737461U : c.x < 24 ? 0x6e636528U : c.x < 28 ? 0x702c2076U : c.x < 32 ? 0x65633328U : c.x < 36 ? 0x322c2030U : c.x < 40 ? 0x2c202d33U : c.x < 44 ? 0x2929202dU : c.x < 48 ? 0x20312e29U : c.x < 52 ? 0x3b20200aU : f;\n\t\t\tif(c.y == 3) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x64203d20U : c.x < 12 ? 0x6d696e28U : c.x < 16 ? 0x642c2064U : c.x < 20 ? 0x69737461U : c.x < 24 ? 0x6e636528U : c.x < 28 ? 0x702c2076U : c.x < 32 ? 0x65633328U : c.x < 36 ? 0x2d322c20U : c.x < 40 ? 0x302c202dU : c.x < 44 ? 0x32292920U : c.x < 48 ? 0x2d20312eU : c.x < 52 ? 0x293b200aU : f;\n\t\t\tif(c.y == 4) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x64203d20U : c.x < 12 ? 0x6d696e28U : c.x < 16 ? 0x642c2070U : c.x < 20 ? 0x2e79202bU : c.x < 24 ? 0x20312e29U : c.x < 28 ? 0x3b20200aU : f;\n\t\t\tif(c.y == 5) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x72657475U : c.x < 12 ? 0x726e2064U : c.x < 16 ? 0x3b20200aU : f;\n\t\t\tif(c.y == 6) f = c.x < 4 ? 0x7d202020U : f;\n\t\t}\n\t\telse if( i == 3 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x666c6f61U : c.x < 8 ? 0x7420682cU : c.x < 12 ? 0x2074203dU : c.x < 16 ? 0x20312e3bU : c.x < 20 ? 0x2020200aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x666f7220U : c.x < 8 ? 0x28696e74U : c.x < 12 ? 0x2069203dU : c.x < 16 ? 0x20303b20U : c.x < 20 ? 0x69203c20U : c.x < 24 ? 0x3235363bU : c.x < 28 ? 0x20692b2bU : c.x < 32 ? 0x29207b0aU : f;\n\t\t\tif(c.y == 2) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x68203d20U : c.x < 12 ? 0x6d617028U : c.x < 16 ? 0x726f202bU : c.x < 20 ? 0x20726420U : c.x < 24 ? 0x2a207429U : c.x < 28 ? 0x3b20200aU : f;\n\t\t\tif(c.y == 3) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x74202b3dU : c.x < 12 ? 0x20683b0aU : f;\n\t\t\tif(c.y == 4) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x69662028U : c.x < 12 ? 0x68203c20U : c.x < 16 ? 0x302e3031U : c.x < 20 ? 0x29206272U : c.x < 24 ? 0x65616b3bU : c.x < 28 ? 0x2020200aU : f;\n\t\t\tif(c.y == 5) f = c.x < 4 ? 0x7d202020U : f;\n\t\t}\n\t\telse if( i == 4 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x76656333U : c.x < 8 ? 0x2063616cU : c.x < 12 ? 0x634e6f72U : c.x < 16 ? 0x6d616c28U : c.x < 20 ? 0x696e2076U : c.x < 24 ? 0x65633320U : c.x < 28 ? 0x7029207bU : c.x < 32 ? 0x2020200aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x76656332U : c.x < 12 ? 0x2065203dU : c.x < 16 ? 0x20766563U : c.x < 20 ? 0x3228312eU : c.x < 24 ? 0x302c202dU : c.x < 28 ? 0x312e3029U : c.x < 32 ? 0x202a2030U : c.x < 36 ? 0x2e303030U : c.x < 40 ? 0x353b200aU : f;\n\t\t\tif(c.y == 2) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x72657475U : c.x < 12 ? 0x726e206eU : c.x < 16 ? 0x6f726d61U : c.x < 20 ? 0x6c697a65U : c.x < 24 ? 0x2820200aU : f;\n\t\t\tif(c.y == 3) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x20202020U : c.x < 12 ? 0x652e7879U : c.x < 16 ? 0x79202a20U : c.x < 20 ? 0x6d617028U : c.x < 24 ? 0x70202b20U : c.x < 28 ? 0x652e7879U : c.x < 32 ? 0x7929202bU : c.x < 36 ? 0x2020200aU : f;\n\t\t\tif(c.y == 4) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x20202020U : c.x < 12 ? 0x652e7979U : c.x < 16 ? 0x78202a20U : c.x < 20 ? 0x6d617028U : c.x < 24 ? 0x70202b20U : c.x < 28 ? 0x652e7979U : c.x < 32 ? 0x7829202bU : c.x < 36 ? 0x2020200aU : f;\n\t\t\tif(c.y == 5) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x20202020U : c.x < 12 ? 0x652e7978U : c.x < 16 ? 0x79202a20U : c.x < 20 ? 0x6d617028U : c.x < 24 ? 0x70202b20U : c.x < 28 ? 0x652e7978U : c.x < 32 ? 0x7929202bU : c.x < 36 ? 0x2020200aU : f;\n\t\t\tif(c.y == 6) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x20202020U : c.x < 12 ? 0x652e7878U : c.x < 16 ? 0x78202a20U : c.x < 20 ? 0x6d617028U : c.x < 24 ? 0x70202b20U : c.x < 28 ? 0x652e7878U : c.x < 32 ? 0x7829293bU : c.x < 36 ? 0x2020200aU : f;\n\t\t\tif(c.y == 7) f = c.x < 4 ? 0x7d202020U : f;\n\t\t}\n\t\telse if( i == 5 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x69662028U : c.x < 8 ? 0x68203c20U : c.x < 12 ? 0x302e3031U : c.x < 16 ? 0x29207b0aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x76656333U : c.x < 12 ? 0x2070203dU : c.x < 16 ? 0x20726f20U : c.x < 20 ? 0x2b207264U : c.x < 24 ? 0x202a2074U : c.x < 28 ? 0x3b20200aU : f;\n\t\t\tif(c.y == 2) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x76656333U : c.x < 12 ? 0x206e6f72U : c.x < 16 ? 0x6d616c20U : c.x < 20 ? 0x3d206361U : c.x < 24 ? 0x6c634e6fU : c.x < 28 ? 0x726d616cU : c.x < 32 ? 0x2870293bU : c.x < 36 ? 0x2020200aU : f;\n\t\t\tif(c.y == 3) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x76656333U : c.x < 12 ? 0x206c6967U : c.x < 16 ? 0x6874203dU : c.x < 20 ? 0x20766563U : c.x < 24 ? 0x3328302cU : c.x < 28 ? 0x20322c20U : c.x < 32 ? 0x30293b0aU : f;\n\t\t\tif(c.y == 4) f = c.x < 4 ? 0x2020200aU : f;\n\t\t\tif(c.y == 5) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x666c6f61U : c.x < 12 ? 0x74206469U : c.x < 16 ? 0x66203d20U : c.x < 20 ? 0x636c616dU : c.x < 24 ? 0x7028646fU : c.x < 28 ? 0x74286e6fU : c.x < 32 ? 0x726d616cU : c.x < 36 ? 0x2c206e6fU : c.x < 40 ? 0x726d616cU : c.x < 44 ? 0x697a6528U : c.x < 48 ? 0x6c696768U : c.x < 52 ? 0x74202d20U : c.x < 56 ? 0x7029292cU : c.x < 60 ? 0x20302e2cU : c.x < 64 ? 0x20312e29U : c.x < 68 ? 0x3b20200aU : f;\n\t\t\tif(c.y == 6) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x64696620U : c.x < 12 ? 0x2a3d2035U : c.x < 16 ? 0x2e202f20U : c.x < 20 ? 0x646f7428U : c.x < 24 ? 0x6c696768U : c.x < 28 ? 0x74202d20U : c.x < 32 ? 0x702c206cU : c.x < 36 ? 0x69676874U : c.x < 40 ? 0x202d2070U : c.x < 44 ? 0x293b200aU : f;\n\t\t\tif(c.y == 7) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x66726167U : c.x < 12 ? 0x436f6c6fU : c.x < 16 ? 0x72203d20U : c.x < 20 ? 0x76656334U : c.x < 24 ? 0x28766563U : c.x < 28 ? 0x3328706fU : c.x < 32 ? 0x77286469U : c.x < 36 ? 0x662c2030U : c.x < 40 ? 0x2e343534U : c.x < 44 ? 0x3529292cU : c.x < 48 ? 0x2031293bU : c.x < 52 ? 0x2020200aU : f;\n\t\t\tif(c.y == 8) f = c.x < 4 ? 0x7d202020U : f;\n\t\t}\n\t\tdrawStr( f, c, uv, vec2(-120, 0), 8., vec3(.8,.95,1.), outCol );\n        if( text1.y > 0 ) {\n           if(uv.y >  - (-1.+float(text1.y))*8. && c.y >= 0 ) {\n                outCol *= vec4(.5,.2,.6,.8);\n            }\n        }\n        if( text1.z > 0 ) {\n            if(uv.y <  - (-2.+float(text1.z))*8. && c.y >= 0 ) {\n                outCol *= vec4(.5,.2,.6,.8);\n            }\n        }\n    }\n    if(slideData.y == 120) { \/\/ footer\n        int i = 1;\n\t\tuint f = 0x0U;\n\t\tif( i == 1 ) {\n\t\t\tivec2 c = ivec2( (uv - vec2(-38.8, -78)) * (1.\/vec2(3.38, -7.5)) + vec2(1,2)) - 1;\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x50726573U : c.x < 8 ? 0x73207370U : c.x < 12 ? 0x61636520U : c.x < 16 ? 0x746f2063U : c.x < 20 ? 0x6f6e7469U : c.x < 24 ? 0x6e756520U : f;\n\t\t\tdrawStr( f, c, uv, vec2(-38.8, -78), 7.5, vec3(.9), outCol );\t\t}\n\n    }\n}","name":"Buffer D","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"lstSRS","date":"1460054893","viewed":24386,"name":"Gargantua With HDR Bloom","username":"sonicether","description":"My attempt at recreating the black hole Gargantua from the movie Interstellar. High-quality bloom was essential for the right look, so I did what I could with only four passes. No background stars\/nebulae, maybe I'll do that in the future.","likes":294,"published":3,"flags":32,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"\/media\/previz\/buffer03.png","previewfilepath":"\/media\/previz\/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 saturate(vec3 x)\n{\n    return clamp(x, vec3(0.0), vec3(1.0));\n}\n\nvec4 cubic(float x)\n{\n    float x2 = x * x;\n    float x3 = x2 * x;\n    vec4 w;\n    w.x =   -x3 + 3.0*x2 - 3.0*x + 1.0;\n    w.y =  3.0*x3 - 6.0*x2       + 4.0;\n    w.z = -3.0*x3 + 3.0*x2 + 3.0*x + 1.0;\n    w.w =  x3;\n    return w \/ 6.0;\n}\n\nvec4 BicubicTexture(in sampler2D tex, in vec2 coord)\n{\n\tvec2 resolution = iResolution.xy;\n\n\tcoord *= resolution;\n\n\tfloat fx = fract(coord.x);\n    float fy = fract(coord.y);\n    coord.x -= fx;\n    coord.y -= fy;\n\n    fx -= 0.5;\n    fy -= 0.5;\n\n    vec4 xcubic = cubic(fx);\n    vec4 ycubic = cubic(fy);\n\n    vec4 c = vec4(coord.x - 0.5, coord.x + 1.5, coord.y - 0.5, coord.y + 1.5);\n    vec4 s = vec4(xcubic.x + xcubic.y, xcubic.z + xcubic.w, ycubic.x + ycubic.y, ycubic.z + ycubic.w);\n    vec4 offset = c + vec4(xcubic.y, xcubic.w, ycubic.y, ycubic.w) \/ s;\n\n    vec4 sample0 = texture(tex, vec2(offset.x, offset.z) \/ resolution);\n    vec4 sample1 = texture(tex, vec2(offset.y, offset.z) \/ resolution);\n    vec4 sample2 = texture(tex, vec2(offset.x, offset.w) \/ resolution);\n    vec4 sample3 = texture(tex, vec2(offset.y, offset.w) \/ resolution);\n\n    float sx = s.x \/ (s.x + s.y);\n    float sy = s.z \/ (s.z + s.w);\n\n    return mix( mix(sample3, sample2, sx), mix(sample1, sample0, sx), sy);\n}\n\nvec3 ColorFetch(vec2 coord)\n{\n \treturn texture(iChannel0, coord).rgb;   \n}\n\nvec3 BloomFetch(vec2 coord)\n{\n \treturn BicubicTexture(iChannel3, coord).rgb;   \n}\n\nvec3 Grab(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord \/= scale;\n    coord -= offset;\n\n    return BloomFetch(coord);\n}\n\nvec2 CalcOffset(float octave)\n{\n    vec2 offset = vec2(0.0);\n    \n    vec2 padding = vec2(10.0) \/ iResolution.xy;\n    \n    offset.x = -min(1.0, floor(octave \/ 3.0)) * (0.25 + padding.x);\n    \n    offset.y = -(1.0 - (1.0 \/ exp2(octave))) - padding.y * octave;\n\n\toffset.y += min(1.0, floor(octave \/ 3.0)) * 0.35;\n    \n \treturn offset;   \n}\n\nvec3 GetBloom(vec2 coord)\n{\n \tvec3 bloom = vec3(0.0);\n    \n    \/\/Reconstruct bloom from multiple blurred images\n    bloom += Grab(coord, 1.0, vec2(CalcOffset(0.0))) * 1.0;\n    bloom += Grab(coord, 2.0, vec2(CalcOffset(1.0))) * 1.5;\n\tbloom += Grab(coord, 3.0, vec2(CalcOffset(2.0))) * 1.0;\n    bloom += Grab(coord, 4.0, vec2(CalcOffset(3.0))) * 1.5;\n    bloom += Grab(coord, 5.0, vec2(CalcOffset(4.0))) * 1.8;\n    bloom += Grab(coord, 6.0, vec2(CalcOffset(5.0))) * 1.0;\n    bloom += Grab(coord, 7.0, vec2(CalcOffset(6.0))) * 1.0;\n    bloom += Grab(coord, 8.0, vec2(CalcOffset(7.0))) * 1.0;\n\n\treturn bloom;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n    \n    vec3 color = ColorFetch(uv);\n    \n    \n    color += GetBloom(uv) * 0.08;\n    \n    color *= 200.0;\n    \n\n    \/\/Tonemapping and color grading\n    color = pow(color, vec3(1.5));\n    color = color \/ (1.0 + color);\n    color = pow(color, vec3(1.0 \/ 1.5));\n\n    \n    color = mix(color, color * color * (3.0 - 2.0 * color), vec3(1.0));\n    color = pow(color, vec3(1.3, 1.20, 1.0));    \n\n\tcolor = saturate(color * 1.01);\n    \n    color = pow(color, vec3(0.7 \/ 2.2));\n\n    fragColor = vec4(color, 1.0);\n\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGRn","filepath":"\/media\/a\/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"\/media\/ap\/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/*  \nMain render. \n\nTemporal AA for a smooth image. Temporal accumulation is disabled while moving the view to prevent ghosting.\n*\/\n\n#define ITERATIONS 200          \/\/Increase for less grainy result\n#define TEMPORAL_AA\n\n\nconst vec3 MainColor = vec3(1.0);\n\n\/\/noise code by iq\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n    vec2 rg = textureLod( iChannel0, (uv+ 0.5)\/256.0, 0.0 ).yx;\n    return -1.0+2.0*mix( rg.x, rg.y, f.z );\n}\n\nfloat saturate(float x)\n{\n    return clamp(x, 0.0, 1.0);\n}\n\nvec3 saturate(vec3 x)\n{\n    return clamp(x, vec3(0.0), vec3(1.0));\n}\n\nfloat rand(vec2 coord)\n{\n    return saturate(fract(sin(dot(coord, vec2(12.9898, 78.223))) * 43758.5453));\n}\n\nfloat pcurve( float x, float a, float b )\n{\n    float k = pow(a+b,a+b) \/ (pow(a,a)*pow(b,b));\n    return k * pow( x, a ) * pow( 1.0-x, b );\n}\n\nconst float pi = 3.14159265;\n\nfloat atan2(float y, float x)\n{\n    if (x > 0.0)\n    {\n        return atan(y \/ x);\n    }\n    else if (x == 0.0)\n    {\n        if (y > 0.0)\n        {\n            return pi \/ 2.0;\n        }\n        else if (y < 0.0)\n        {\n            return -(pi \/ 2.0);\n        }\n        else\n        {\n            return 0.0;\n        }\n    }\n    else \/\/(x < 0.0)\n    {\n        if (y >= 0.0)\n        {\n            return atan(y \/ x) + pi;\n        }\n        else\n        {\n            return atan(y \/ x) - pi;\n        }\n    }\n}\n\nfloat sdTorus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q)-t.y;\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n  return length(p)-r;\n}\n\nvoid Haze(inout vec3 color, vec3 pos, float alpha)\n{\n    vec2 t = vec2(1.0, 0.01);\n\n    float torusDist = length(sdTorus(pos + vec3(0.0, -0.05, 0.0), t));\n\n    float bloomDisc = 1.0 \/ (pow(torusDist, 2.0) + 0.001);\n    vec3 col = MainColor;\n    bloomDisc *= length(pos) < 0.5 ? 0.0 : 1.0;\n\n    color += col * bloomDisc * (2.9 \/ float(ITERATIONS)) * (1.0 - alpha * 1.0);\n}\n\nvoid GasDisc(inout vec3 color, inout float alpha, vec3 pos)\n{\n    float discRadius = 3.2;\n    float discWidth = 5.3;\n    float discInner = discRadius - discWidth * 0.5;\n    float discOuter = discRadius + discWidth * 0.5;\n    \n    vec3 origin = vec3(0.0, 0.0, 0.0);\n    float mouseZ = iMouse.y \/ iResolution.y;\n    vec3 discNormal = normalize(vec3(0.0, 1.0, 0.0));\n    float discThickness = 0.1;\n\n    float distFromCenter = distance(pos, origin);\n    float distFromDisc = dot(discNormal, pos - origin);\n    \n    float radialGradient = 1.0 - saturate((distFromCenter - discInner) \/ discWidth * 0.5);\n\n    float coverage = pcurve(radialGradient, 4.0, 0.9);\n\n    discThickness *= radialGradient;\n    coverage *= saturate(1.0 - abs(distFromDisc) \/ discThickness);\n\n    vec3 dustColorLit = MainColor;\n    vec3 dustColorDark = vec3(0.0, 0.0, 0.0);\n\n    float dustGlow = 1.0 \/ (pow(1.0 - radialGradient, 2.0) * 290.0 + 0.002);\n    vec3 dustColor = dustColorLit * dustGlow * 8.2;\n\n    coverage = saturate(coverage * 0.7);\n\n\n    float fade = pow((abs(distFromCenter - discInner) + 0.4), 4.0) * 0.04;\n    float bloomFactor = 1.0 \/ (pow(distFromDisc, 2.0) * 40.0 + fade + 0.00002);\n    vec3 b = dustColorLit * pow(bloomFactor, 1.5);\n    \n    b *= mix(vec3(1.7, 1.1, 1.0), vec3(0.5, 0.6, 1.0), vec3(pow(radialGradient, 2.0)));\n    b *= mix(vec3(1.7, 0.5, 0.1), vec3(1.0), vec3(pow(radialGradient, 0.5)));\n\n    dustColor = mix(dustColor, b * 150.0, saturate(1.0 - coverage * 1.0));\n    coverage = saturate(coverage + bloomFactor * bloomFactor * 0.1);\n    \n    if (coverage < 0.01)\n    {\n        return;   \n    }\n    \n    \n    vec3 radialCoords;\n    radialCoords.x = distFromCenter * 1.5 + 0.55;\n    radialCoords.y = atan2(-pos.x, -pos.z) * 1.5;\n    radialCoords.z = distFromDisc * 1.5;\n\n    radialCoords *= 0.95;\n    \n    float speed = 0.06;\n    \n    float noise1 = 1.0;\n    vec3 rc = radialCoords + 0.0;               rc.y += iTime * speed;\n    noise1 *= noise(rc * 3.0) * 0.5 + 0.5;      rc.y -= iTime * speed;\n    noise1 *= noise(rc * 6.0) * 0.5 + 0.5;      rc.y += iTime * speed;\n    noise1 *= noise(rc * 12.0) * 0.5 + 0.5;     rc.y -= iTime * speed;\n    noise1 *= noise(rc * 24.0) * 0.5 + 0.5;     rc.y += iTime * speed;\n\n    float noise2 = 2.0;\n    rc = radialCoords + 30.0;\n    noise2 *= noise(rc * 3.0) * 0.5 + 0.5;      rc.y += iTime * speed;\n    noise2 *= noise(rc * 6.0) * 0.5 + 0.5;      rc.y -= iTime * speed;\n    noise2 *= noise(rc * 12.0) * 0.5 + 0.5;     rc.y += iTime * speed;\n    noise2 *= noise(rc * 24.0) * 0.5 + 0.5;     rc.y -= iTime * speed;\n    noise2 *= noise(rc * 48.0) * 0.5 + 0.5;     rc.y += iTime * speed;\n    noise2 *= noise(rc * 92.0) * 0.5 + 0.5;     rc.y -= iTime * speed;\n\n    dustColor *= noise1 * 0.998 + 0.002;\n    coverage *= noise2;\n    \n    radialCoords.y += iTime * speed * 0.5;\n    \n    dustColor *= pow(texture(iChannel1, radialCoords.yx * vec2(0.15, 0.27)).rgb, vec3(2.0)) * 4.0;\n\n    coverage = saturate(coverage * 1200.0 \/ float(ITERATIONS));\n    dustColor = max(vec3(0.0), dustColor);\n\n    coverage *= pcurve(radialGradient, 4.0, 0.9);\n\n    color = (1.0 - alpha) * dustColor * coverage + color;\n\n    alpha = (1.0 - alpha) * coverage + alpha;\n}\n\n\n\nvec3 rotate(vec3 p, float x, float y, float z)\n{\n    mat3 matx = mat3(1.0, 0.0, 0.0,\n                     0.0, cos(x), sin(x),\n                     0.0, -sin(x), cos(x));\n\n    mat3 maty = mat3(cos(y), 0.0, -sin(y),\n                     0.0, 1.0, 0.0,\n                     sin(y), 0.0, cos(y));\n\n    mat3 matz = mat3(cos(z), sin(z), 0.0,\n                     -sin(z), cos(z), 0.0,\n                     0.0, 0.0, 1.0);\n\n    p = matx * p;\n    p = matz * p;\n    p = maty * p;\n\n    return p;\n}\n\nvoid RotateCamera(inout vec3 eyevec, inout vec3 eyepos)\n{\n    float mousePosY = iMouse.y \/ iResolution.y;\n    float mousePosX = iMouse.x \/ iResolution.x;\n\n    vec3 angle = vec3(mousePosY * 0.05 + 0.05, 1.0 + mousePosX * 1.0, -0.45);\n\n    eyevec = rotate(eyevec, angle.x, angle.y, angle.z);\n    eyepos = rotate(eyepos, angle.x, angle.y, angle.z);\n}\n\nvoid WarpSpace(inout vec3 eyevec, inout vec3 raypos)\n{\n    vec3 origin = vec3(0.0, 0.0, 0.0);\n\n    float singularityDist = distance(raypos, origin);\n    float warpFactor = 1.0 \/ (pow(singularityDist, 2.0) + 0.000001);\n\n    vec3 singularityVector = normalize(origin - raypos);\n    \n    float warpAmount = 5.0;\n\n    eyevec = normalize(eyevec + singularityVector * warpFactor * warpAmount \/ float(ITERATIONS));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n    \n    float aspect = iResolution.x \/ iResolution.y;\n\n    vec2 uveye = uv;\n    \n    #ifdef TEMPORAL_AA\n    uveye.x += (rand(uv + sin(iTime * 1.0)) \/ iResolution.x) * (iMouse.z > 1.0 ? 0.0 : 1.0);\n    uveye.y += (rand(uv + 1.0 + sin(iTime * 1.0)) \/ iResolution.y) * (iMouse.z > 1.0 ? 0.0 : 1.0);\n    #endif\n    \n    vec3 eyevec = normalize(vec3((uveye * 2.0 - 1.0) * vec2(aspect, 1.0), 6.0));\n    vec3 eyepos = vec3(0.0, -0.0, -10.0);\n    \n    vec2 mousepos = iMouse.xy \/ iResolution.xy;\n    if (mousepos.x == 0.0)\n    {\n        mousepos.x = 0.35;\n    }\n    eyepos.x += mousepos.x * 3.0 - 1.5;\n    \n    const float far = 15.0;\n\n    RotateCamera(eyevec, eyepos);\n\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    \n    float dither = rand(uv \n                        #ifdef TEMPORAL_AA\n                        + sin(iTime * 1.0) * (iMouse.z > 1.0 ? 0.0 : 1.0)\n                        #endif\n                       ) * 2.0;\n\n\n    float alpha = 0.0;\n    vec3 raypos = eyepos + eyevec * dither * far \/ float(ITERATIONS);\n    for (int i = 0; i < ITERATIONS; i++)\n    {        \n        WarpSpace(eyevec, raypos);\n        raypos += eyevec * far \/ float(ITERATIONS);\n        GasDisc(color, alpha, raypos);\n        Haze(color, raypos, alpha);\n    }\n    \n    color *= 0.0001;\n\n    \n    #ifdef TEMPORAL_AA\n    const float p = 1.0;\n    vec3 previous = pow(texture(iChannel2, uv).rgb, vec3(1.0 \/ p));\n    \n    color = pow(color, vec3(1.0 \/ p));\n    \n    float blendWeight = 0.9 * (iMouse.z > 1.0 ? 0.0 : 1.0);\n    \n    color = mix(color, previous, blendWeight);\n    \n    color = pow(color, vec3(p));\n    #endif\n    \n    fragColor = vec4(saturate(color), 1.0);\n\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\/\/First bloom pass, mipmap tree thing\n\nvec3 ColorFetch(vec2 coord)\n{\n \treturn texture(iChannel0, coord).rgb;   \n}\n\nvec3 Grab1(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = ColorFetch(coord);\n\n    return color;\n}\n\nvec3 Grab4(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = vec3(0.0);\n    float weights = 0.0;\n    \n    const int oversampling = 4;\n    \n    for (int i = 0; i < oversampling; i++)\n    {    \t    \n        for (int j = 0; j < oversampling; j++)\n        {\n\t\t\tvec2 off = (vec2(i, j) \/ iResolution.xy + vec2(0.0) \/ iResolution.xy) * scale \/ float(oversampling);\n            color += ColorFetch(coord + off);\n            \n\n            weights += 1.0;\n        }\n    }\n    \n    color \/= weights;\n    \n    return color;\n}\n\nvec3 Grab8(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = vec3(0.0);\n    float weights = 0.0;\n    \n    const int oversampling = 8;\n    \n    for (int i = 0; i < oversampling; i++)\n    {    \t    \n        for (int j = 0; j < oversampling; j++)\n        {\n\t\t\tvec2 off = (vec2(i, j) \/ iResolution.xy + vec2(0.0) \/ iResolution.xy) * scale \/ float(oversampling);\n            color += ColorFetch(coord + off);\n            \n\n            weights += 1.0;\n        }\n    }\n    \n    color \/= weights;\n    \n    return color;\n}\n\nvec3 Grab16(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = vec3(0.0);\n    float weights = 0.0;\n    \n    const int oversampling = 16;\n    \n    for (int i = 0; i < oversampling; i++)\n    {    \t    \n        for (int j = 0; j < oversampling; j++)\n        {\n\t\t\tvec2 off = (vec2(i, j) \/ iResolution.xy + vec2(0.0) \/ iResolution.xy) * scale \/ float(oversampling);\n            color += ColorFetch(coord + off);\n            \n\n            weights += 1.0;\n        }\n    }\n    \n    color \/= weights;\n    \n    return color;\n}\n\nvec2 CalcOffset(float octave)\n{\n    vec2 offset = vec2(0.0);\n    \n    vec2 padding = vec2(10.0) \/ iResolution.xy;\n    \n    offset.x = -min(1.0, floor(octave \/ 3.0)) * (0.25 + padding.x);\n    \n    offset.y = -(1.0 - (1.0 \/ exp2(octave))) - padding.y * octave;\n\n\toffset.y += min(1.0, floor(octave \/ 3.0)) * 0.35;\n    \n \treturn offset;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n    \n    \n    vec3 color = vec3(0.0);\n    \n    \/*\n    Create a mipmap tree thingy with padding to prevent leaking bloom\n   \t\n\tSince there's no mipmaps for the previous buffer and the reduction process has to be done in one pass,\n    oversampling is required for a proper result\n\t*\/\n    color += Grab1(uv, 1.0, vec2(0.0,  0.0)   );\n    color += Grab4(uv, 2.0, vec2(CalcOffset(1.0))   );\n    color += Grab8(uv, 3.0, vec2(CalcOffset(2.0))   );\n    color += Grab16(uv, 4.0, vec2(CalcOffset(3.0))   );\n    color += Grab16(uv, 5.0, vec2(CalcOffset(4.0))   );\n    color += Grab16(uv, 6.0, vec2(CalcOffset(5.0))   );\n    color += Grab16(uv, 7.0, vec2(CalcOffset(6.0))   );\n    color += Grab16(uv, 8.0, vec2(CalcOffset(7.0))   );\n\n\n    fragColor = vec4(color, 1.0);\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\/\/Horizontal gaussian blur leveraging hardware filtering for fewer texture lookups.\n\nvec3 ColorFetch(vec2 coord)\n{\n \treturn texture(iChannel0, coord).rgb;   \n}\n\nfloat weights[5];\nfloat offsets[5];\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    \n    weights[0] = 0.19638062;\n    weights[1] = 0.29675293;\n    weights[2] = 0.09442139;\n    weights[3] = 0.01037598;\n    weights[4] = 0.00025940;\n    \n    offsets[0] = 0.00000000;\n    offsets[1] = 1.41176471;\n    offsets[2] = 3.29411765;\n    offsets[3] = 5.17647059;\n    offsets[4] = 7.05882353;\n    \n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n    \n    vec3 color = vec3(0.0);\n    float weightSum = 0.0;\n    \n    if (uv.x < 0.52)\n    {\n        color += ColorFetch(uv) * weights[0];\n        weightSum += weights[0];\n\n        for(int i = 1; i < 5; i++)\n        {\n            vec2 offset = vec2(offsets[i]) \/ iResolution.xy;\n            color += ColorFetch(uv + offset * vec2(0.5, 0.0)) * weights[i];\n            color += ColorFetch(uv - offset * vec2(0.5, 0.0)) * weights[i];\n            weightSum += weights[i] * 2.0;\n        }\n\n        color \/= weightSum;\n    }\n\n    fragColor = vec4(color,1.0);\n}","name":"Buf C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\/\/Vertical gaussian blur leveraging hardware filtering for fewer texture lookups.\n\nvec3 ColorFetch(vec2 coord)\n{\n \treturn texture(iChannel0, coord).rgb;   \n}\n\nfloat weights[5];\nfloat offsets[5];\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    \n    weights[0] = 0.19638062;\n    weights[1] = 0.29675293;\n    weights[2] = 0.09442139;\n    weights[3] = 0.01037598;\n    weights[4] = 0.00025940;\n    \n    offsets[0] = 0.00000000;\n    offsets[1] = 1.41176471;\n    offsets[2] = 3.29411765;\n    offsets[3] = 5.17647059;\n    offsets[4] = 7.05882353;\n    \n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n    \n    vec3 color = vec3(0.0);\n    float weightSum = 0.0;\n    \n    if (uv.x < 0.52)\n    {\n        color += ColorFetch(uv) * weights[0];\n        weightSum += weights[0];\n\n        for(int i = 1; i < 5; i++)\n        {\n            vec2 offset = vec2(offsets[i]) \/ iResolution.xy;\n            color += ColorFetch(uv + offset * vec2(0.0, 0.5)) * weights[i];\n            color += ColorFetch(uv - offset * vec2(0.0, 0.5)) * weights[i];\n            weightSum += weights[i] * 2.0;\n        }\n\n        color \/= weightSum;\n    }\n\n    fragColor = vec4(color,1.0);\n}","name":"Buf D","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"ldScDh","date":"1492933322","viewed":43906,"name":"Greek Temple","username":"iq","description":"A basic temple model. Terrain is false perspective. No global illumination. Two sun directions. Ambient occlusion is mostly painted by hand. Bounce lighting is also painted by hand. Live coded: [url]https:\/\/www.youtube.com\/watch?v=-pdSjBPH3zM[\/url]","likes":287,"published":3,"flags":32,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Copyright Inigo Quilez, 2017 - https:\/\/iquilezles.org\/\n\/\/ I am the sole copyright owner of this Work.\n\/\/ You cannot host, display, distribute or share this Work in any form,\n\/\/ including physical and digital. You cannot use this Work in any\n\/\/ commercial or non-commercial product, website or project. You cannot\n\/\/ sell this Work and you cannot mint an NFTs of it.\n\/\/ I share this Work for educational purposes, and you can link to it,\n\/\/ through an URL, proper attribution and unmodified screenshot, as part\n\/\/ of your educational material. If these conditions are too restrictive\n\/\/ please contact me and we'll definitely work it out.\n\n\/\/ You can buy a metal print of this shader here:\n\/\/ https:\/\/www.redbubble.com\/i\/metal-print\/Greek-Temple-by-InigoQuilez\/39845587.0JXQP\n\n\/\/ A basic temple model. No global illumination, all cheated and composed to camera:\n\/\/\n\/\/ - the terrain is false perspective\n\/\/ - there are two different sun directions for foreground and background. \n\/\/ - ambient occlusion is mostly painted by hand\n\/\/ - bounce lighting is also painted by hand\n\/\/\n\/\/ This shader was made as a continuation to a live coding session I did for the students\n\/\/ of UPENN. After the initial live coded session I decided to rework it and improve it,\n\/\/ and that turned out to be a bit of a pain because when looking for the final look I got\n\/\/ trapped in more local minima that I usually do and it took me a while to leave them. \n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tivec2 p = ivec2(fragCoord-0.5);\n    \n    vec3 col = texelFetch( iChannel0, p, 0 ).xyz;\n    \n    vec2 q = fragCoord \/ iResolution.xy;\n    col *= 0.8 + 0.2*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.2 );\n\n    \n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3Rn","filepath":"\/media\/a\/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"\/media\/ap\/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"\/media\/a\/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"\/media\/ap\/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ Created by inigo quilez - iq\/2017\n\/\/ I share this piece (art and code) here in Shadertoy and through its Public API, only for educational purposes. \n\/\/ You cannot use, sell, share or host this piece or modifications of it as part of your own commercial or non-commercial product, website or project.\n\/\/ You can share a link to it or an unmodified screenshot of it provided you attribute \"by Inigo Quilez, @iquilezles and iquilezles.org\". \n\/\/ If you are a teacher, lecturer, educator or similar and these conditions are too restrictive for your needs, please contact me and we'll work it out.\n\n\n\/\/ A basic temple model\n\/\/\n\/\/ - the terrain is false perspective\n\/\/ - there are two different sun directions for foreground and background. \n\/\/ - ambient occlusion is mostly painted by hand\n\/\/ - bounce lighting is also painted by hand\n\/\/\n\/\/ This shader was made as a continuation to a live coding session I\n\/\/ did for the students of UPENN. Check it here:\n\/\/\n\/\/ https:\/\/www.youtube.com\/watch?v=-pdSjBPH3zM\n\n\n\n\/\/#define STATICCAM\n\nfloat hash1( vec2 p )\n{\n    p  = 50.0*fract( p*0.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat hash( uint n ) \n{\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    \/\/ floating point conversion from https:\/\/iquilezles.org\/articles\/sfrand\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\nvec2 hash2( float n ) { return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123)); }\n\nfloat noise( in vec2 p )\n{\n    ivec2 i = ivec2(floor(p));\n    vec2  f = fract(p);\n\tf = f*f*(3.0-2.0*f);\n\tfloat a = texelFetch( iChannel1, (i+ivec2(0,0))&255, 0 ).x;\n    float b = texelFetch( iChannel1, (i+ivec2(1,0))&255, 0 ).x;\n    float c = texelFetch( iChannel1, (i+ivec2(0,1))&255, 0 ).x;\n    float d = texelFetch( iChannel1, (i+ivec2(1,1))&255, 0 ).x;\n    return mix( mix(a,b,f.x), mix(c,d,f.x), f.y );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel1, (uv+0.5)\/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat fbm4( in vec3 p )\n{\n    float n = 0.0;\n    n += 1.000*noise( p*1.0 );\n    n += 0.500*noise( p*2.0 );\n    n += 0.250*noise( p*4.0 );\n    n += 0.125*noise( p*8.0 );\n    return n;\n}\n\nfloat fbm6( in vec3 p )\n{\n    float n = 0.0;\n    n += 1.00000*noise( p*1.0 );\n    n += 0.50000*noise( p*2.0 );\n    n += 0.25000*noise( p*4.0 );\n    n += 0.12500*noise( p*8.0 );\n    n += 0.06250*noise( p*16.0 );\n    n += 0.03125*noise( p*32.0 );\n    return n;\n}\n\nfloat fbm6( in vec2 p )\n{\n    float n = 0.0;\n    n += 1.00000*noise( p*1.0 );\n    n += 0.50000*noise( p*2.0 );\n    n += 0.25000*noise( p*4.0 );\n    n += 0.12500*noise( p*8.0 );\n    n += 0.06250*noise( p*16.0 );\n    n += 0.03125*noise( p*32.0 );\n    return n;\n}\n\nfloat fbm4( in vec2 p )\n{\n    float n = 0.0;\n    n += 1.00000*noise( p*1.0 );\n    n += 0.50000*noise( p*2.0 );\n    n += 0.25000*noise( p*4.0 );\n    n += 0.12500*noise( p*8.0 );\n    return n;\n}\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdRhombus( in vec2 p, in vec2 b, in float r ) \n{\n    vec2 q = abs(p);\n    float h = clamp( (-2.0*ndot(q,b) + ndot(b,b) )\/dot(b,b), -1.0, 1.0 );\n    float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\n    d *= sign( q.x*b.y + q.y*b.x - b.x*b.y );\n\treturn d - r;\n}\n\nfloat usdBox( in vec3 p, in vec3 b )\n{\n    return length( max(abs(p)-b,0.0 ) );\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdBox( float p, float b )\n{\n  return abs(p) - b;\n}\n\nvec2 opRepLim( in vec2 p, in float s, in vec2 lim )\n{\n    return p-s*clamp(round(p\/s),-lim,lim);\n}\n\nvec2 opRepLim( in vec2 p, in float s, in vec2 limmin, in vec2 limmax )\n{\n    return p-s*clamp(round(p\/s),-limmin,limmax);\n}\n\nvec4 textureGood( in sampler2D sam, in vec2 uv )\n{\n    ivec2 res = textureSize(sam,0).xy;\n    uv = uv*vec2(res) - 0.5;\n    ivec2 i = ivec2(floor(uv));\n    vec2  f = fract(uv);\n    f = f*f*(3.0-2.0*f);\n    vec4 a = texelFetch( sam, (i+ivec2(0,0))&(res-1), 0 );\n    vec4 b = texelFetch( sam, (i+ivec2(1,0))&(res-1), 0 );\n    vec4 c = texelFetch( sam, (i+ivec2(0,1))&(res-1), 0 );\n    vec4 d = texelFetch( sam, (i+ivec2(1,1))&(res-1), 0 );\n    return mix( mix(a,b,f.x), mix(c,d,f.x), f.y );\n}\n\n#define ZERO (min(iFrame,0))\n\n\/\/------------\n\nfloat terrain( in vec2 p )\n{\n    float h = 90.0*textureGood( iChannel2, p.yx*0.0001 + 0.35 + vec2(0.02,0.05) ).x - 70.0 + 5.0;\n    h = mix( h, -7.2, 1.0-smoothstep(16.0,60.0,length(p)));\n    h -= 7.0*textureGood( iChannel2, p*0.002 ).x;\n    float d = textureLod( iChannel0, p*0.01, 0.0 ).x;\n    h -= 1.0*d*d*d;\n    return h;\n}\n\nconst float ocean = -25.0;\n\nvec3 temple( in vec3 p )\n{\n    vec3 op = p;    \n    vec3 res = vec3(-1.0,-1.0,0.5);\n\n    p.y += 2.0;\n\n    \/\/ columns\n    vec3 q = p; q.xz = opRepLim( q.xz, 4.0, vec2(4.0,2.0) );\n    vec2 id = floor((p.xz+2.0)\/4.0);\n    float d = length(q.xz) - 0.9 + 0.05*p.y;\n    d = max(d,p.y-6.0);\n    d = max(d,-p.y-5.0);\n    d -= 0.05*pow(0.5+0.5*sin(atan(q.x,q.z)*16.0),2.0);\n    d -= 0.15*pow(0.5+0.5*sin(q.y*3.0+0.6),0.12) - 0.15;\n    res.z = hash1( id + 11.0*floor(0.25 + (q.y*3.0+0.6)\/6.2831) );\n    d *= 0.85;\n    vec3 w = vec3(q.x,abs(q.y-0.3)-5.5, q.z );\n    d = min( d,  sdBox(w,vec3(1.4,0.2,1.4)+sign(q.y-0.3)*vec3(0.1,0.05,0.1))-0.1 ); \/\/ base\n    d = max( d, -sdBox(p,vec3(14.0,10.0,6.0)) ); \/\/ clip in\n\n    \/\/ floor upper bounding plane\n    float bb1 = op.y+7.0;\n    if( bb1<d )\n    {\n    float ra = 0.15 * hash1(id+vec2(1.0,3.0));\n\tq = p; q.xz = opRepLim( q.xz, 4.0, vec2(4.0,3.0) );\n    float b = sdBox( q-vec3(0.0,-6.0+0.1-ra,0.0), vec3(2.0,0.5,2.0)-0.15-ra )-0.15;\n    b *= 0.5;\n    if( b<d ) { d = b; res.z = hash1(id); }\n    \n    p.xz -= 2.0;\n    id = floor((p.xz+2.0)\/4.0);\n    ra = 0.15 * hash1(id+vec2(1.0,3.0)+23.1);\n    q = p; q.xz = opRepLim( q.xz, 4.0, vec2(5.0,4.0), vec2(5.0,3.0) );\n\tb = sdBox( q-vec3(0.0,-7.0-ra,0.0), vec3(2.0,0.6,2.0)-0.15-ra )-0.15;\n    b *= 0.8;\n    if( b<d ) { d = b; res.z = hash1( id + 13.5 ); }\n    p.xz += 2.0;\n    \n    id = floor((p.xz+2.0)\/4.0);\n    ra = 0.15 * hash1(id+vec2(1.0,3.0)+37.7);\n    q = p; q.xz = opRepLim( q.xz, 4.0, vec2(5.0,4.0) );\n\tb = sdBox( q-vec3(0.0,-8.0-ra-1.0,0.0), vec3(2.0,0.6+1.0,2.0)-0.15-ra )-0.15;\n    b *= 0.5;\n    if( b<d ) { d = b; res.z = hash1( id*7.0 + 31.1 ); }\n    }\n\n\n    \/\/ roof lower bounding plane\n    float bb2 = -(op.y-4.0);\n    if( bb2<d )\n    {\n    q = vec3( mod(p.x+2.0,4.0)-2.0, p.y, mod(p.z+0.0,4.0)-2.0 );\n    float b = sdBox( q-vec3(0.0,7.0,0.0), vec3(1.95,1.0,1.95)-0.15 )-0.15;\n    b = max( b, sdBox(p-vec3(0.0,7.0,0.0),vec3(18.0,1.0,10.0)) );\n    if( b<d ) { d = b; res.z = hash1( floor((p.xz+vec2(2.0,0.0))\/4.0) + 31.1 ); }\n    \n    q = vec3( mod(p.x+0.5,1.0)-0.5, p.y, mod(p.z+0.5,1.0)-0.5 );\n    b = sdBox( q-vec3(0.0,8.0,0.0), vec3(0.45,0.5,0.45)-0.02 )-0.02;\n    b = max( b, sdBox(p-vec3(0.0,8.0,0.0),vec3(19.0,0.2,11.0)) );\n    if( b<d ) { d = b; res.z = hash1( floor((p.xz+0.5)\/1.0) + 7.8 ); }\n    \n    b = sdRhombus( p.yz-vec2(8.2,0.0), vec2(3.0,11.0), 0.05 ) ;\n    q = vec3( mod(p.x+1.0,2.0)-1.0, p.y, mod(p.z+1.0,2.0)-1.0 );\n    b = max( b, -sdBox( vec3( abs(p.x)-20.0,p.y,q.z)-vec3(0.0,8.0,0.0), vec3(2.0,5.0,0.1) )-0.02 );\n    \n    b = max( b, -p.y+8.2 );\n    b = max( b, usdBox(p-vec3(0.0,8.0,0.0),vec3(19.0,12.0,11.0)) );\n    float c = sdRhombus( p.yz-vec2(8.3,0.0), vec2(2.25,8.5), 0.05 );\n    c = max( c, sdBox(abs(p.x)-19.0,2.0) );\n    b = max( b, -c );    \n\n    d = min( d, b );\n    d = max( d,-sdBox(p-vec3(0.0,9.5,0.0),vec3(15.0,4.0,9.0)) );\n    }\n\n    if( d<0.1 )\n    {\n    d -= 0.02*smoothstep(0.5,1.0,fbm4( p.zxy ));\n    d -= 0.01*smoothstep(0.4,0.8,fbm4( op*3.0 ));\n    d += 0.005;\n    }\n    \n    return vec3( d, 1.0, res.z );\n}\n\nvec3 map( in vec3 p )\n{\n    vec3 res = vec3( p.y+25.0, 3.0, 0.0 );\n\n    float bb = p.y+6.0; \/\/ bounding plane for terrain\n    if( bb<res.x )\n    {\n        float h = terrain( p.xz );\n        float m = (p.y-h)*0.35;\n        if( m<res.x ) res=vec3( m, 2.0, 0.0 );\n    }\n\n    bb = usdBox(p-vec3(0.0,-1.0,0.0),vec3(22.0,11.0,20.0) ); \/\/ bounding box for temple\n    if( bb<res.x )\n    {\n        vec3 tmp = temple(p);\n        if( tmp.x<res.x ) res=tmp;\n    }\n    \n    return res;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/normalsSDF\nvec3 calcNormal( in vec3 p, in float t )\n{\n#if 0    \n    float e = 0.001*t;\n\n    vec2 h = vec2(1.0,-1.0)*0.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e ).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e ).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e ).x );\n#else    \n    \/\/ inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*0.001*t).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n    vec2 ma = vec2(0.0);\n\n    vec3 res = vec3(-1.0);\n    \n    float tmax = 1000.0;\n\n    \/\/ bottom bounding plane\n    {\n    float tp = (ocean-ro.y)\/rd.y;\n    if( tp>0.0 ) { tmax = tp; res = vec3( tp, 3.0, 0.0 ); }\n    }\n    \/\/ top bounding plane\n    {\n    float tp = (10.0-ro.y)\/rd.y;\n    if( tp>0.0 ) { tmax = tp;  }\n    }\n        \n    float t = 10.0;\n    for( int i=0; i<256; i++ )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 h = map( pos );\n        ma = h.yz;\n        if( h.x<(0.0001*t) || t>tmax ) break;\n        t += h.x;\n    }\n\n    if( t<tmax )\n    {\n    \tres = vec3(t, ma);\n    }\n\n    return res;\n}\n\nvec4 textureBox( in sampler2D tex, in vec3 pos, in vec3 nor )\n{\n    vec4 cx = texture( tex, pos.yz );\n    vec4 cy = texture( tex, pos.xz );\n    vec4 cz = texture( tex, pos.xy );\n    vec3 m = nor*nor;\n    return (cx*m.x + cy*m.y + cz*m.z)\/(m.x+m.y+m.z);\n}\n\nfloat calcShadow( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n\n    float t = 0.01;\n    for( int i=0; i<128; i++ )\n    {\n        vec3 pos = ro + t*rd;\n        float h = map( pos ).x;\n        res = min( res, k*max(h,0.0)\/t );\n        if( res<0.0001 || pos.y>10.0) break;\n        t += clamp(h,0.01,5.0);\n    }\n\n    return res;\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor, float ra )\n{\n    float occ = 0.0;\n    for( int i=ZERO; i<32; i++ )\n    {\n        float h = 0.01 + 4.0*pow(float(i)\/31.0,2.0);\n        vec2 an = hash2( ra + float(i)*13.1 )*vec2( 3.14159, 6.2831 );\n        vec3 dir = vec3( sin(an.x)*sin(an.y), sin(an.x)*cos(an.y), cos(an.x) );\n        dir *= sign( dot(dir,nor) );\n        occ += clamp( 5.0*map( pos + h*dir ).x\/h, -1.0, 1.0);\n    }\n    return clamp( occ\/32.0, 0.0, 1.0 );\n}\n\nconst vec3 sunLig = normalize(vec3(0.7,0.1,0.4));\n\nvec3 skyColor( in vec3 ro, in vec3 rd )\n{\n    vec3 col = vec3(0.3,0.4,0.5)*0.3 - 0.3*rd.y;\n\n    float t = (1000.0-ro.y)\/rd.y;\n    if( t>0.0 )\n    {\n        vec2 uv = (ro+t*rd).xz;\n        float cl = texture( iChannel0, .000003*uv.yx ).x;\n        cl = smoothstep(0.3,0.7,cl);\n        col = mix( col, vec3(0.3,0.2,0.1), 0.1*cl );\n    }\n    \n    col = mix( col, vec3(0.2,0.25,0.30)*0.5, exp(-30.0*rd.y) ) ;\n    \n    float sd = pow( clamp( 0.25 + 0.75*dot(sunLig,rd), 0.0, 1.0 ), 4.0 );\n    col = mix( col, vec3(1.2,0.30,0.05)\/1.2, sd*exp(-abs((60.0-50.0*sd)*rd.y)) ) ;\n    \n    return col;\n}\n\nvec3 doBumpMap( in vec3 pos, in vec3 nor )\n{\n    float e = 0.002;\n    float b = 0.015;\n    \n\tfloat ref = fbm6( 4.0*pos );\n    vec3 gra = -b*vec3( fbm6(4.0*vec3(pos.x+e, pos.y, pos.z))-ref,\n                        fbm6(4.0*vec3(pos.x, pos.y+e, pos.z))-ref,\n                        fbm6(4.0*vec3(pos.x, pos.y, pos.z+e))-ref )\/e;\n\t\n\tvec3 tgrad = gra - nor * dot ( nor , gra );\n    return normalize( nor - tgrad );\n}\n\nvec3 doBumpMapGrass( in vec2 pos, in vec3 nor, out float hei )\n{\n    const float e = 0.002;\n    const float b = 0.03;\n    \n\tfloat ref = fbm6( 4.0*pos );\n    hei = ref;\n    \n    vec3 gra = -b*vec3( fbm6(4.0*vec2(pos.x+e, pos.y))-ref,\n                        e,\n                        fbm6(4.0*vec2(pos.x, pos.y+e))-ref )\/e;\n\t\n\tvec3 tgrad = gra - nor*dot( nor, gra );\n    return normalize( nor - tgrad );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float isThumbnail = step(iResolution.x,499.0);\n    \n    vec2 o = (1.0-isThumbnail)*(hash2( float(iFrame) ) - 0.5);\n    \n\tvec2 p = (-iResolution.xy + 2.0*(fragCoord+o)) \/ iResolution.y;\n    \n    uvec2 px = uvec2(fragCoord);\n    float ran = hash( px.x + 1920U*px.y + (1920U*1080U)*uint(iFrame*0) );    \n    \n    #ifdef STATICCAM\n    float an = -0.96;\n    #else\n    float an = -0.96 + sin(iTime*0.05)*0.1;\n    #endif\n    float ra = 70.0;\n    float fl = 3.0;\n    vec3 ta = vec3(0.0,-3.0,-23.0);\n    vec3 ro = ta + vec3(ra*sin(an),10.0,ra*cos(an));\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    vec3 rd = ca * normalize( vec3(p.xy,fl));\n    \n    \n    vec3 col = skyColor( ro, rd );\n    \n    float resT = 10000.0;\n    vec3 res = intersect( ro, rd );\n    if( res.y>0.0 )\n    {\n        float t = res.x;\n        resT = t;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, t );\n        \n        float fre = pow( clamp( 1.0+dot(nor,rd), 0.0, 1.0), 5.0 );\n\t\tfloat foc = 1.0;\n        \n        vec3 mate = vec3(0.2);\n        vec2 mspe = vec2(0.0);\n        float mbou = 0.0;\n        float mter = 0.0;\n        if( res.y<1.5 )\n        {\n            vec3 te = textureBox( iChannel0, pos*0.05, nor ).xyz;\n            mate = vec3(0.14,0.10,0.07) + 0.1*te;\n            mate *= 0.8 + 0.4*res.z;\n            mate *= 1.15;            \n            mspe = vec2(1.0,8.0);\n            mbou = 1.0;\n\n            nor = doBumpMap( pos, nor );\n            \n            foc = 0.7 + 0.3*smoothstep(0.4,0.7,fbm4( 3.0*pos ));\n\n            float ho = 1.0;\n            if( pos.y>-7.5 ) ho *= smoothstep( 0.0, 5.0, (pos.y+7.5)  );\n            ho = mix( 0.1+ho*0.3, 1.0, clamp( 0.6 + 0.4*dot( normalize(nor.xz*vec2(0.5,1.0)), normalize(pos.xz*vec2(0.5,1.0)) ) + 1.0*nor.y*nor.y, 0.0, 1.0 ) );\n            foc *= ho;\n            foc *= 0.4 + 0.6*smoothstep( 2.0, 15.0, length(pos*vec3(0.5,0.25,1.0)) );\n            float rdis = clamp( -0.15*max(sdRhombus( pos.yz-vec2(8.3,0.0)+vec2(2.0,0.0), vec2(2.25,8.5), 0.05 ),-(pos.y-8.3+2.0)), 0.0, 1.0 );\n            if( rdis>0.0001 ) foc = 0.1 + sqrt(rdis);\n\t\t\tif( pos.y<5.8 ) foc *= 0.6 + 0.4*smoothstep( 0.0, 1.5, -(pos.y-5.8) );\n            if( pos.y<3.4 ) foc *= 0.6 + 0.4*smoothstep( 0.0, 2.5, -(pos.y-3.4)  );\n\n            foc *= 0.8;            \n        }\n        else if( res.y<2.5 )\n        {\n            mate = vec3(0.95,0.9,0.85) * 0.4*texture( iChannel0, pos.xz*0.015 ).xyz;\n            mate *= 0.25 + 0.75*smoothstep( -25.0, -24.0, pos.y );\n            mate *= 0.32;            \n\t\t\tfloat h;\n            vec3 mor = doBumpMapGrass( pos.xz, nor, h );\n            mspe = vec2(2.5,4.0);\n            float is_grass = smoothstep( 0.9,0.95,mor.y);\n            \n            mate = mix( mate, vec3(0.15,0.1,0.0)*0.8*0.7 + h*h*h*vec3(0.12,0.1,0.05)*0.15, is_grass );\n            mspe = mix( mspe, vec2(0.5,4.0), is_grass );\n            nor = mor;\n            mter = 1.0;\n        }\n\t\telse\n        {\n            mate = vec3(0.1,0.21,0.25)*0.45;\n            mate += 2.0*vec3(0.01,0.03,0.03)*(1.0-smoothstep(0.0,10.0,pos.y-terrain(pos.xz)));\n            mate *= 0.4;            \n            float foam = (1.0-smoothstep(0.0,1.0,pos.y-terrain(pos.xz)));\n            foam *= smoothstep( 0.35,0.5,texture(iChannel0,pos.xz*0.07).x );\n            mate += vec3(0.08)*foam;\n            mspe = vec2(0.5,8.0);\n\n            vec2 e = vec2(0.01,0.0);\n            float ho = fbm4( (pos.xz     )*vec2(2.0,0.5) );\n            float hx = fbm4( (pos.xz+e.xy)*vec2(2.0,0.5) );\n            float hy = fbm4( (pos.xz+e.yx)*vec2(2.0,0.5) );\n            float sm = (1.0-smoothstep(0.0,4.0,pos.y-terrain(pos.xz)));\n            sm *= 0.02 + 0.03*foam;\n            ho *= sm;\n            hx *= sm;\n            hy *= sm;\n                \n            nor = normalize( vec3(ho-hx,e.x,ho-hy) );\n        }\n\n        float occ = 0.33 + 0.5*nor.y;\n        occ = calcOcclusion(pos,nor,ran) * foc;\n        \n        float lf = 1.0 - smoothstep( 30.0,80.0,length(pos.z));\n        vec3 lig = normalize( vec3(sunLig.x,sunLig.y+0.245*lf,sunLig.z) );\n        vec3 ligbak = normalize(vec3(-lig.x,0.0,-lig.z));\n        float dif = dot( nor, lig );\n        float sha = 1.0; if( dif>0.0 ) sha=calcShadow( pos+nor*0.001, lig, 32.0 );\n              dif = clamp(dif*sha,0.0,1.0);\n        float amb = (0.8 + 0.2*nor.y);\n              amb = mix( amb, amb*(0.5+0.5*smoothstep( -8.0,-1.0,pos.y)), mbou );\n\n        vec3 qos = pos\/1.5 - vec3(0.0,1.0,0.0);\n\n        float bak = clamp( 0.4+0.6*dot( nor, ligbak ), 0.0, 1.0 );\n              bak *= 0.6 + 0.4*smoothstep( -8.0,-1.0,qos.y);\n        \n        float bou = 0.3*clamp( 0.7-0.3*nor.y, 0.0, 1.0 );\n              bou *= smoothstep( 8.0,0.0,qos.y+6.0)*smoothstep(-6.7,-6.4,qos.y);\n              bou *= (0.7*smoothstep( 3.0,1.0,length( (qos.xz-vec2(1.0,6.0))*vec2(0.2,1.0)) )+\n                          smoothstep( 5.0,1.0,length( (qos.xz-vec2(5.0,-3.0))*vec2(0.4,1.0)) ));\n              bou +=  0.1*smoothstep( 5.0,1.0,length( (qos-vec3(-5.0,0.0,-5.0))*vec3(0.7,0.8,1.5)) );\n        \n        vec3 hal = normalize( lig -rd );\n        float spe = pow( clamp( dot(nor,hal), 0.0, 1.0), mspe.y )*(0.1+0.9*fre)*sha*(0.5+0.5*occ);\n\n        col = vec3(0.0);\n        col += amb*1.0*vec3(0.15,0.25,0.35)*occ*(1.0+mter);\n        col += dif*5.0*vec3(0.90,0.55,0.35);\n        col += bak*1.7*vec3(0.10,0.11,0.12)*occ*mbou;\n        col += bou*3.0*vec3(1.00,0.50,0.15)*occ*mbou;\n        col += spe*6.0*mspe.x*occ;\n        \n        col *= mate;\n\n        vec3 fogcol = vec3(0.1,0.125,0.15);\n        float sd = pow( clamp( 0.25 + 0.75*dot(lig,rd), 0.0, 1.0 ), 4.0 );\n\t    fogcol = mix( fogcol, vec3(1.0,0.25,0.042), sd*exp(-abs((60.0-50.0*sd)*abs(rd.y))) ) ;\n\n        float fog = 1.0 - exp(-0.0013*t);\n        col *= 1.0-0.5*fog;\n        col = mix( col, fogcol, fog );\n    }\n\n    col = max( col, 0.0 );\n    \n    col += 0.15*vec3(1.0,0.8,0.7)*pow( clamp( dot(rd,sunLig), 0.0, 1.0 ), 6.0 );\n\n    col = 1.2*col\/(1.0+col);\n    \n    col = sqrt( col );\n\n    col = clamp( 1.9*col-0.1, 0.0, 1.0 );\n    col = col*0.1 + 0.9*col*col*(3.0-2.0*col);\n    col = pow( col, vec3(0.76,0.98,1.0) );    \n    \n    \/\/------------------------------------------\n\t\/\/ reproject from previous frame and average\n    \/\/------------------------------------------\n\t#ifdef STATICCAM\n        vec3 ocol = texelFetch( iChannel3, ivec2(fragCoord-0.5), 0 ).xyz;\n        if( iFrame==0 ) ocol = col;\n        col = mix( ocol, col, 0.05 );\n        fragColor = vec4( col, 1.0 );\n    #else\n        mat4 oldCam = mat4( texelFetch(iChannel3,ivec2(0,0),0),\n                            texelFetch(iChannel3,ivec2(1,0),0),\n                            texelFetch(iChannel3,ivec2(2,0),0),\n                            0.0, 0.0, 0.0, 1.0 );\n\n        \/\/ world space\n        vec4 wpos = vec4(ro + rd*resT,1.0);\n        \/\/ camera space\n        vec3 cpos = (wpos*oldCam).xyz; \/\/ note inverse multiply\n        \/\/ ndc space\n        vec2 npos = fl * cpos.xy \/ cpos.z;\n        \/\/ screen space\n        vec2 spos = 0.5 + 0.5*npos*vec2(iResolution.y\/iResolution.x,1.0);\n        \/\/ undo dither\n        spos -= o\/iResolution.xy;\n        \/\/ raster space\n        vec2 rpos = spos * iResolution.xy;\n\n        if( (rpos.y<1.0 && rpos.x<3.0) || (isThumbnail>0.5)  )\n        {\n        }\n        else\n        {\n            vec4 data = textureLod( iChannel3, spos, 0.0 );\n            vec3 ocol = data.xyz;\n            float dt = abs(data.w - resT)\/resT;\n            if( iFrame==0 ) ocol = col;\n            col = mix( ocol, col, 0.1 + 0.5*smoothstep(0.1,0.2,dt) );\n        }\n\n        if( fragCoord.y<1.0 && fragCoord.x<3.0 )\n        {\n            if( abs(fragCoord.x-2.5)<0.5 ) fragColor = vec4( ca[2], -dot(ca[2],ro) );\n            if( abs(fragCoord.x-1.5)<0.5 ) fragColor = vec4( ca[1], -dot(ca[1],ro) );\n            if( abs(fragCoord.x-0.5)<0.5 ) fragColor = vec4( ca[0], -dot(ca[0],ro) );\n        }\n        else\n        {\n            fragColor = vec4( col, resT );\n        }\n    #endif\n}","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"4tByz3","date":"1511132429","viewed":57020,"name":"Ladybug","username":"iq","description":"A ladybug on a mushroom. It renders really slowly. Sorry for that, this is not meant to be rendered with raymarching really, but well, here we are. I'll get a pass later","likes":263,"published":3,"flags":32,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Copyright Inigo Quilez, 2017 - https:\/\/iquilezles.org\/\n\/\/ I am the sole copyright owner of this Work.\n\/\/ You cannot host, display, distribute or share this Work in any form,\n\/\/ including physical and digital. You cannot use this Work in any\n\/\/ commercial or non-commercial product, website or project. You cannot\n\/\/ sell this Work and you cannot mint an NFTs of it.\n\/\/ I share this Work for educational purposes, and you can link to it,\n\/\/ through an URL, proper attribution and unmodified screenshot, as part\n\/\/ of your educational material. If these conditions are too restrictive\n\/\/ please contact me and we'll definitely work it out.\n\n\/\/ You can buy a metal print of this shader here:\n\/\/ https:\/\/www.redbubble.com\/i\/metal-print\/Ladybug-by-InigoQuilez\/39845563.0JXQP\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord \/ iResolution.xy;\n    \n    \n    \/\/ dof\n    const float focus = 2.35;\n\n    vec4 acc = vec4(0.0);\n    const int N = 12;\n\tfor( int j=-N; j<=N; j++ )\n    for( int i=-N; i<=N; i++ )\n    {\n        vec2 off = vec2(float(i),float(j));\n        \n        vec4 tmp = texture( iChannel0, q + off\/vec2(800.0,450.0) ); \n        \n        float depth = tmp.w;\n        \n        vec3  color = tmp.xyz;\n        \n        float coc = 0.05 + 12.0*abs(depth-focus)\/depth;\n        \n        if( dot(off,off) < (coc*coc) )\n        {\n            float w = 1.0\/(coc*coc); \n            acc += vec4(color*w,w);\n        }\n    }\n    \n    vec3 col = acc.xyz \/ acc.w;\n\n    \n    \/\/ gamma\n    col = pow( col, vec3(0.4545) );\n    \n    \/\/ color correct - it seems my laptop has a fucked up contrast\/gamma seeting, so I need\n    \/\/                 to do this for the picture to look okey in all computers but mine...\n    col = col*1.1 - 0.06;\n    \n    \/\/ vignetting\n    col *= 0.8 + 0.3*sqrt( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y) );\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3Rn","filepath":"\/media\/a\/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"\/media\/ap\/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ Created by inigo quilez - iq\/2017\n\/\/ I share this piece (art and code) here in Shadertoy and through its Public API, only for educational purposes. \n\/\/ You cannot use, sell, share or host this piece or modifications of it as part of your own commercial or non-commercial product, website or project.\n\/\/ You can share a link to it or an unmodified screenshot of it provided you attribute \"by Inigo Quilez, @iquilezles and iquilezles.org\". \n\/\/ If you are a teacher, lecturer, educator or similar and these conditions are too restrictive for your needs, please contact me and we'll work it out.\n\n\n#define MAT_MUSH_HEAD 1.0\n#define MAT_MUSH_NECK 2.0\n#define MAT_LADY_BODY 3.0\n#define MAT_LADY_HEAD 4.0\n#define MAT_LADY_LEGS 5.0\n#define MAT_GRASS     6.0\n#define MAT_GROUND    7.0\n#define MAT_MOSS      8.0\n#define MAT_CITA      9.0\n\nvec2  hash2( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*18.5453); }\nvec3  hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(338.5453123,278.1459123,191.1234)); }\nfloat dot2(in vec2 p ) { return dot(p,p); }\nfloat dot2(in vec3 p ) { return dot(p,p); }\n\nvec2 sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n    return vec2( length(pa-h*ba), h );\n}\nvec2 sdLine( in vec3 p, in vec3 a, in vec3 b )\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n    return vec2( length(pa-h*ba), h );\n}\nvec2 sdLineOri( in vec3 p, in vec3 b )\n{\n    float h = clamp( dot(p,b)\/dot(b,b), 0.0, 1.0 );\n    \n    return vec2( length(p-h*b), h );\n}\nvec2 sdLineOriY( in vec3 p, in float b )\n{\n    float h = clamp( p.y\/b, 0.0, 1.0 );\n    p.y -= b*h;\n    return vec2( length(p), h );\n}\nfloat sdEllipsoid( in vec3 pos, in vec3 cen, in vec3 rad )\n{\n    vec3 p = pos - cen;\n    float k0 = length(p\/rad);\n    float k1 = length(p\/(rad*rad));\n    return k0*(k0-1.0)\/k1;\n}\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25\/k;\n}\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25\/k;\n}\nvec3 rotateX( in vec3 p, float t )\n{\n    float co = cos(t);\n    float si = sin(t);\n    p.yz = mat2(co,-si,si,co)*p.yz;\n    return p;\n}\nvec3 rotateY( in vec3 p, float t )\n{\n    float co = cos(t);\n    float si = sin(t);\n    p.xz = mat2(co,-si,si,co)*p.xz;\n    return p;\n}\nvec3 rotateZ( in vec3 p, float t )\n{\n    float co = cos(t);\n    float si = sin(t);\n    p.xy = mat2(co,-si,si,co)*p.xy;\n    return p;\n}\n\n\/\/==================================================\n\n#define ZERO (min(iFrame,0))\n\n\/\/==================================================\n\nvec3 mapLadyBug( vec3 p )\n{\n    float dBody = sdEllipsoid( p, vec3(0.0), vec3(0.8, 0.75, 1.0) );\n    dBody = smax( dBody, -sdEllipsoid( p, vec3(0.0,-0.1,0.0), vec3(0.75, 0.7, 0.95) ), 0.05 );\n    dBody = smax( dBody, -sdEllipsoid( p, vec3(0.0,0.0,0.8), vec3(0.35, 0.35, 0.5) ), 0.05 );\n  \tdBody = smax( dBody, sdEllipsoid( p, vec3(0.0,1.7,-0.1), vec3(2.0, 2.0, 2.0) ), 0.05 );\n  \tdBody = smax( dBody, -abs(p.x)+0.005, 0.02 + 0.1*clamp(p.z*p.z*p.z*p.z,0.0,1.0) );\n\n    vec3 res = vec3( dBody, MAT_LADY_BODY, 0.0 );\n\n    \/\/ --------\n    vec3 hc = vec3(0.0,0.1,0.8);\n    vec3 ph = rotateX(p-hc,0.5);\n    float dHead = sdEllipsoid( ph, vec3(0.0,0.0,0.0), vec3(0.35, 0.25, 0.3) );\n    dHead = smax( dHead, -sdEllipsoid( ph, vec3(0.0,-0.95,0.0), vec3(1.0) ), 0.03 );\n    dHead = min( dHead, sdEllipsoid( ph, vec3(0.0,0.1,0.3), vec3(0.15,0.08,0.15) ) );\n\n    if( dHead < res.x ) res = vec3( dHead, MAT_LADY_HEAD, 0.0 );\n    \n    res.x += 0.0007*sin(150.0*p.x)*sin(150.0*p.z)*sin(150.0*p.y); \/\/ iqiq\n\n    \/\/ -------------\n    \n    vec3 k1 = vec3(0.42,-0.05,0.92);\n    vec3 k2 = vec3(0.49,-0.2,1.05);\n    float dLegs = 10.0;\n\n    float sx = sign(p.x);\n    p.x = abs(p.x);\n    for( int k=0; k<3; k++ )\n    {   \n        vec3 q = p;\n        q.y -= min(sx,0.0)*0.1;\n        if( k==0) q += vec3( 0.0,0.11,0.0);\n        if( k==1) q += vec3(-0.3,0.1,0.2);\n        if( k==2) q += vec3(-0.3,0.1,0.6);\n        \n        vec2 se = sdLine( q, vec3(0.3,0.1,0.8), k1 );\n        se.x -= 0.015 + 0.15*se.y*se.y*(1.0-se.y);\n        dLegs = min(dLegs,se.x);\n\n        se = sdLine( q, k1, k2 );\n        se.x -= 0.01 + 0.01*se.y;\n        dLegs = min(dLegs,se.x);\n\n        se = sdLine( q, k2, k2 + vec3(0.1,0.0,0.1) );\n        se.x -= 0.02 - 0.01*se.y;\n        dLegs = min(dLegs,se.x);\n    }\n    \n    if( dLegs<res.x ) res = vec3(dLegs,MAT_LADY_LEGS, 0.0);\n\n\n    return res;\n}\n\nvec3 worldToMushrom( in vec3 pos )\n{\n    vec3 qos = pos;\n    qos.xy = (mat2(60,11,-11,60)\/61.0) * qos.xy;\n    qos.y += 0.03*sin(3.0*qos.z - 2.0*sin(3.0*qos.x));\n    qos.y -= 0.4;\n    return qos;\n}\n\nvec3 mapMushroom( in vec3 pos )\n{\n    vec3 res;\n\n    vec3 qos = worldToMushrom(pos);\n\n    {\n        \/\/ head\n        float d1 = sdEllipsoid( qos, vec3(0.0, 1.4,0.0), vec3(0.8,1.0,0.8) );\n\n        \/\/ displacement\n        float f;\n        vec3 tos = qos*0.5;\n        f  = 1.00*(sin( 63.0*tos.x+sin( 23.0*tos.z)));\n        f += 0.50*(sin(113.0*tos.z+sin( 41.0*tos.x)));\n        f += 0.25*(sin(233.0*tos.x+sin(111.0*tos.z)));\n        f = 0.5*(f + f*f*f);\n        d1 -= 0.0005*f - 0.01;\n\n        \/\/ cut the lower half\n        float d2 = sdEllipsoid( qos, vec3(0.0, 0.5,0.0), vec3(1.3,1.2,1.3) );\n        float d = smax( d1, -d2, 0.1 );\n        res = vec3( d, MAT_MUSH_HEAD, 0.0 );\n    }\n\n\n    {\n        \/\/ stem\n        pos.x += 0.3*sin(pos.y) - 0.65;\n        float pa = sin( 20.0*atan(pos.z,pos.x) );\n        vec2 se = sdLine( pos, vec3(0.0,2.0,0.0), vec3(0.0,0.0,0.0) );\n        float tt = 0.25 - 0.1*4.0*se.y*(1.0-se.y);\n        float d3 = se.x - tt;\n        \n        \/\/ skirt\n        vec2 ros = vec2(length(pos.xz),pos.y);\n        se = sdLine( ros, vec2(0.0,1.9), vec2(0.31,1.5) );\n        float d4 = se.x - 0.02;\/\/*(1.0-se.y);\n        d3 = smin( d3, d4, 0.05);\n\n        d3 += 0.003*pa;\n        d3 *= 0.7;\n\n        if( d3<res.x )\n            res = vec3( d3, MAT_MUSH_NECK, 0.0 );\n    }\n\n    return res;\n}\n\nvec3 mapGrass( in vec3 pos, float h )\n{\n    vec3 res = vec3(1e20,0.0,0.0);\n    \n    const float gf = 4.0;\n\n    vec3 qos = pos * gf;\n\n    vec2 n = floor( qos.xz );\n    vec2 f = fract( qos.xz );\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2  g = vec2( float(i), float(j) );\n\n        vec2 ra2 = hash2( n + g + vec2(31.0,57.0) );\n\n        if( ra2.x<0.73 ) continue;\n\n        vec2  o = hash2( n + g );\n        vec2  r = g - f + o;\n        vec2 ra = hash2( n + g + vec2(11.0,37.0) );\n\n        float gh = 2.0*(0.3+0.7*ra.x);\n\n        float rosy = qos.y - h*gf;\n\n        r.xy = reflect( r.xy, normalize(-1.0+2.0*ra) );\n        r.x -= 0.03*rosy*rosy;\n        \n        r.x *= 4.0;\n        float mo = 0.1*sin( 2.0*iTime + 20.0*ra.y )*(0.2+0.8*ra.x);\n        vec2 se = sdLineOri( vec3(r.x,rosy,r.y), vec3(4.0 + mo,gh*gf,mo) );\n        float gr = 0.3*sqrt(1.0-0.99*se.y);\n        float d = se.x - gr;\n        d \/= 4.0;\n\n        d \/= gf;\n        if( d<res.x )\n        {\n            res.x = d;\n            res.y = MAT_GRASS;\n            res.z = r.y;\n        }\n    }\n    \n    return res;\n}\n\nvec3 mapCrapInTheAir( in vec3 pos)\n{\n    ivec2 id = ivec2(floor((pos.xz+2.0)\/4.0));\n    pos.xz = mod(pos.xz+2.0,4.0)-2.0;\n    float dm = 1e10;\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 o = vec3(0.0,3.2,0.0);\n        o += vec3(1.7,1.50,1.7)*(-1.0 + 2.0*hash3(float(i)));\n        o += vec3(0.3,0.15,0.3)*sin(0.3*iTime + vec3(float(i+id.y),float(i+3+id.x),float(i*2+1+2*id.x)));\n        float d = dot2(pos - o);\n        dm = min(d,dm);\n    }\n    dm = sqrt(dm)-0.02;\n    \n    return vec3( dm, MAT_CITA, 0.0);\n}\n\nvec3 mapMoss( in vec3 pos, float h)\n{\n    vec3 res = vec3(1e20,0.0,0.0);\n\n    const float gf = 2.0;\n    \n    vec3 qos = pos * gf;\n    vec2 n = floor( qos.xz );\n    vec2 f = fract( qos.xz );\n\n    for( int k=ZERO; k<2; k++ )\n    {\n        for( int j=-1; j<=1; j++ )\n        for( int i=-1; i<=1; i++ )\n        {\n            vec2  g = vec2( float(i), float(j) );\n            vec2  o = hash2( n + g + vec2(float(k),float(k*5)));\n            vec2  r = g - f + o;\n\n            vec2 ra  = hash2( n + g + vec2(11.0, 37.0) + float(2*k) );\n            vec2 ra2 = hash2( n + g + vec2(41.0,137.0) + float(3*k) );\n\n            float mh = 0.5 + 1.0*ra2.y;\n            vec3 ros = qos - vec3(0.0,h*gf,0.0);\n\n            vec3 rr = vec3(r.x,ros.y,r.y);\n\n            rr.xz = reflect( rr.xz, normalize(-1.0+2.0*ra) );\n\n            rr.xz += 0.5*(-1.0+2.0*ra2);\n            vec2 se  = sdLineOriY( rr, gf*mh );\n            float sey = se.y;\n            float d = se.x - 0.05*(2.0-smoothstep(0.0,0.1,abs(se.y-0.9)));\n\n            vec3 pp = vec3(rr.x,mod(rr.y+0.2*0.0,0.4)-0.2*0.0,rr.z);\n\n            float an = mod( 21.0*floor( (rr.y+0.2*0.0)\/0.4 ), 1.57 );\n            float cc = cos(an);\n            float ss = sin(an);\n            pp.xz = mat2(cc,ss,-ss,cc)*pp.xz;\n\n            pp.xz = abs(pp.xz);\n            vec3 ppp = (pp.z>pp.x) ? pp.zyx : pp; \n            vec2 se2 = sdLineOri( ppp, vec3( 0.4,0.3,0.0) );\n            vec2 se3 = sdLineOri( pp,  vec3( 0.2,0.3,0.2) ); if( se3.x<se2.x ) se2 = se3;\n            float d2 = se2.x - (0.02 + 0.03*se2.y);\n\n            d2 = max( d2, (rr.y-0.83*gf*mh) );\n            d = smin( d, d2, 0.05 );\n\n            d \/= gf;\n            d *= 0.9;\n            if( d<res.x )\n            {\n                res.x = d;\n                res.y = MAT_MOSS;\n                res.z = clamp(length(rr.xz)*4.0+rr.y*0.2,0.0,1.0);\n                float e = clamp((pos.y - h)\/1.0,0.0,1.0);\n                res.z *= 0.02 + 0.98*e*e;\n                \n                if( ra.y>0.85 && abs(se.y-0.95)<0.1 ) res.z = -res.z;\n            }\n        }\n    }\n    \n    return res;\n}\n\nvec3 worldToLadyBug( in vec3 p )\n{\n    \/\/ TODO: combine all of the above in a single 4x4 matrix\n    p = 4.0*(p - vec3(-0.0,3.2-0.6,-0.57));\n    p = rotateY( rotateZ( rotateX( p, -0.92 ), 0.49), 3.5 );\n    p.y += 0.2;\n    return p;\n}\n\nconst vec3 mushroomPos1 = vec3( 0.0,0.1,0.0);\nconst vec3 mushroomPos2 = vec3(-3.0,0.0,3.0);\n\nfloat terrain( in vec2 pos )\n{\n    return 0.3 - 0.3*sin(pos.x*0.5 - sin(pos.y*0.5));\n}\n\nvec3 mapShadow( in vec3 pos )\n{\n    \/\/ terrain\n    float h = terrain( pos.xz );\n    float d = pos.y - h;\n    vec3 res = vec3( d, MAT_GROUND, 0.0 );\n    \n    \/\/ mushrooms\n    {\n      \/\/ intancing\n      vec3 m1 =  pos - mushroomPos1;\n      vec3 m2 = (pos - mushroomPos2).zyx;\n      if( dot2(m2.xz) < dot2(m1.xz) ) m1 = m2;\n    \n      \/\/ bounding volume\n      float bb = sdLine( m1, vec3(0.2,0.0,0.0), vec3(0.36,2.0,0.0) ).x-0.8;\n      if( bb<res.x ) \n      {\n\t  vec3 tmp = mapMushroom(m1);\n      if( tmp.x<res.x ) res = tmp;\n      }\n    }\n    \n    \/\/ ladybug\n    {\n      vec3 q = worldToLadyBug(pos);\n      if( (length(q)-1.5)\/4.0<res.x ) \/\/ bounding volume\n      {\n      vec3 tmp = mapLadyBug(q); tmp.x\/=4.0;\n      if( tmp.x<res.x ) res = tmp;\n      }\n    }\n    \n    \/\/ grass\n    {\n      if( pos.y-2.5<res.x ) \/\/ bounding volume\n      {\n      vec3 tmp = mapGrass(pos,h);\n      if( tmp.x<res.x ) res=tmp;\n      }\n    }\n    \n    \/\/ moss\n    {\n      if( pos.y-1.9<res.x ) \/\/ bounding volume\n      {\n      vec3 tmp = mapMoss(pos,h);\n      if( tmp.x<res.x ) res=tmp;\n      }\n    }\n    \n    return res;\n}\n\nvec3 map( in vec3 pos )\n{\n    vec3 res = mapShadow(pos);\n        \n    vec3 tmp = mapCrapInTheAir(pos);\n    if( tmp.x<res.x ) res=tmp;\n\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n#if 0    \n    vec2 e = vec2(0.002,0.0); \n    return normalize( vec3( map(pos+e.xyy).x - map(pos-e.xyy).x,\n                            map(pos+e.yxy).x - map(pos-e.yxy).x,\n                            map(pos+e.yyx).x - map(pos-e.yyx).x ) );\n#else\n    \/\/ inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+e*0.002).x;\n    }\n    return normalize(n);\n#endif    \n}\n    \nfloat calcShadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.01;\n    for( int i=ZERO; i<100; i++ )\n    {\n        vec3 pos = ro + rd*t;\n        float h = mapShadow( pos ).x;\n        res = min( res, 16.0*max(h,0.0)\/t );\n        if( h<0.0001 || pos.y>3.0 ) break;\n        \n        t += clamp(h,0.01,0.1);\n    }\n    \n    return clamp(res,0.0,1.0);\n}\n\nvec3 raycast( in vec3 ro, in vec3 rd )\n{\n    const float tmax = 12.0;\n    \n\tvec3 res = vec3(1.0,-1.0, 0.0);\n\n    for( int i=ZERO; i<256; i++ )\n    {\n        vec3 h = map( ro + rd*res.x );\n        if( h.x<(0.00015*res.x) || res.x>tmax )\n            break;\n        res.x += h.x;\n        res.y = h.y;\n        res.z = h.z;\n    }\n    \n    if( res.x>=tmax ) res.y = -1.0;\n    \n    return res;\n}\n\nvoid materials( in float matID, in float matID2, in vec3 pos, in vec3 nor,\n                out vec3 matColor, out float matRough,\n                out vec3 matNor, out float matOcc, out float matSSS, out float matRefOcc, out vec3 matGamma )\n{\n    matNor = nor;\n    matOcc = 1.0;\n    matSSS = 0.0;\n    matRough = 1.0;\n    matRefOcc = 1.0;\n    matGamma = vec3(1.0);\n    \n    if( matID<MAT_MUSH_HEAD+0.5 )\n    {\n        vec3 m1 =  pos - mushroomPos1;\n    \tvec3 m2 = (pos - mushroomPos2).zyx;\n    \tif( dot2(m2.xz) < dot2(m1.xz) ) m1 = m2;\n\n        vec3 qos = worldToMushrom( m1 );\n\n        matColor = vec3(0.26,0.21,0.15);\n        matColor -= 0.2*smoothstep(0.4,0.9,texture( iChannel1, 0.8*qos.xz ).x);\n        matColor = mix( vec3(0.35,0.35,0.35 ), matColor, smoothstep(1.5,2.4,qos.y) );\n        matColor = mix( vec3(0.05,0.02,0.01 ), matColor, smoothstep(1.5,1.65,qos.y) );\n        matColor -= 0.2*texture( iChannel1, 0.1*qos.xz ).zyx;\n        matColor *= 0.4*0.45;\n        matColor = max( matColor, 0.0 );\n        \n        matColor += matColor*vec3(0.3,0.6,0.0)*(1.0-smoothstep( 0.8, 1.4, length(m1-vec3(0.5,1.1,-0.3)) ));\n        \n        matRough = 0.6;\n        matSSS = 1.0;\n        matOcc = smoothstep( 0.4,1.5,length(worldToLadyBug( pos ).xz) );\n        matRefOcc = matOcc;\n        matGamma = vec3(0.75,0.87,1.0);\n    }\n    else if( matID<MAT_MUSH_NECK+0.5 )\n    {\n        vec2 uv = vec2( pos.y*0.5, atan(pos.x,pos.z)*(3.0\/3.14159) );\n\n        matColor = vec3(0.42,0.35,0.15);\n        \n        float pa = smoothstep(0.3,0.8,pos.y);\n\n        matColor -= pa*0.2*texture( iChannel1, 0.5*uv ).xxx;\n        matColor = max(vec3(0.0),matColor);\n        \n        matColor *= 0.22;\n        matColor = clamp( matColor, 0.0, 1.0 );\n        \n        matRough = 0.7;\n        matSSS = 1.0;\n        \n        matOcc = clamp( (pos.y-0.5)\/1.3,0.0,1.0);\n        matOcc = matOcc*matOcc;\n        matOcc *= clamp( 1.0-(pos.y-1.2)\/1.2,0.0,1.0);\n        matOcc = matOcc*0.5 + 0.5*matOcc*matOcc;\n        matRefOcc = matOcc;\n        matGamma = vec3(0.75,0.95,1.0);\n    }\n    else if( matID<MAT_LADY_BODY+.5 )\n    {\n        vec3 qos = worldToLadyBug( pos );\n            \n        \/\/ red\n        matColor = vec3(0.16,0.008,0.0);\n\n        float f = texture( iChannel1, 0.1*qos.xz ).x;\n        matColor = mix( matColor, vec3(0.15,0.07,0.0), f*f );\n        \n        qos.x = abs(qos.x);\n        vec2 uv = vec2( atan(qos.x,qos.y), 1.57*qos.z )*0.1;\n\n        \/\/ white\n        float p = length( (qos.xz-vec2(0.0,0.9))*vec2(0.5,1.0));\n        matColor = mix( matColor, vec3(1.0,0.8,0.6)*0.6, 1.0-smoothstep(0.09,0.14,p) );\n\n        \/\/ black\n        p = cos(uv.x*40.0)*cos(uv.y*40.0+1.57);\n        matColor *= 1.0-smoothstep( 0.35, 0.45, p );\n        \n        f = texture( iChannel1, qos.xz*vec2(0.8,0.1) ).x;\n        matColor *= 1.0 - 0.5*f;\n        f = texture( iChannel1, 4.0*qos.xz ).x;\n        matColor *= 1.0 - 0.99*f*f;\n        \n        matColor *= 1.3;\n        matRough = 0.15;\n        matOcc = 0.6 + 0.4*smoothstep( 0.0,0.3,qos.y );\n        matRefOcc = 0.2 + 0.8*smoothstep( 0.0,0.35,qos.y );\n    }\n    else if( matID<MAT_LADY_HEAD+.5 )\n    {\n        vec3 qos = worldToLadyBug( pos );\n\n        matColor = vec3(0.001);\n\n        qos.z += -0.22;\n        qos.y += -0.7;\n        float p = cos(12.0*qos.z)*cos(5.0*qos.y);\n        p += .1*cos(48.0*qos.z)*cos(20.0*qos.y);\n        matColor = mix( matColor, vec3(1.0,0.9,0.8)*0.8, smoothstep(0.8,1.0,p) );\n        matRough = 0.2;\n        matRefOcc = matOcc;\n    }\n    else if( matID<MAT_LADY_LEGS+.5 )\n    {\n        matColor = vec3(0.0,0.0,0.0);\n        matRough = 0.8;\n        matRefOcc = matOcc;\n    }\n    else if( matID<MAT_GRASS+0.5 )\n    {\n    \tmatColor = vec3(0.1,0.15,0.03);\n        \n        float h = terrain( pos.xz );\n        float e = clamp(pos.y-h,0.0,1.0);\n        matOcc = 0.01 + 0.99*e*e;\n        \n        matColor *= 1.0 - 0.3*cos(matID2*23.0);\n        matColor += 0.04*sin(matID2*41.0);\n        \n        matSSS = 0.2;\n        matColor *= 0.75;\n        matRough = 0.5;\n        matOcc *= 0.1+0.9*smoothstep( 0.0, 2.0, length(pos.xz-mushroomPos1.xz-vec2(0.3,0.3)) );\n        matRefOcc = matOcc;\n        matGamma = vec3(0.9,0.9,1.0);\n    }\n    else if( matID<MAT_GROUND+0.5 )\n    {\n        matColor = vec3(0.2,0.2,0.0);\n        matRough = 1.0;\n        matOcc = 0.02;\n        matRefOcc = matOcc;\n    }\n    else if( matID<MAT_MOSS+0.5 )\n    {\n        matColor = (matID2>0.0) ? vec3(0.18,0.15,0.02) : vec3(0.1,0.05,0.005);\n        \n        float f = texture( iChannel1, pos.xy*8.0 ).x;\n        matColor *= 0.55 + f;\n            \n        matOcc = abs(matID2);\n        matOcc *= 0.2+0.8*smoothstep( 0.0, 1.5, length(pos.xz-mushroomPos1.xz-vec2(0.3,0.3)) );\n        matOcc *= 0.2+0.8*smoothstep( 0.0, 1.5, length(pos.xz-mushroomPos2.xz-vec2(0.0,0.0)) );\n        matRough = 0.25;\n        matSSS = 0.5;\n        matRefOcc = matOcc;\n        matGamma = vec3(0.7,0.7,1.0);\n        \n        if( matID2<0.0 ) { matGamma = vec3(0.7,0.9,1.0); matRough = 0.75;}\n    }\n    else \/\/if( matID<MAT_CITA+0.5 )\n    {\n        matColor = vec3(1.0);\n        matSSS = 1.0;\n        matRough = 1.0;\n        matGamma = vec3(0.5);\n    }\n}\n\nvec3 lighting( in float dis, in vec3 rd, in vec3 pos, in vec3 nor,\n               in float occ,\n               in vec3 matColor, in float matRough, in float matSSS, in float matRefOcc,\n               in vec3 matGamma )\n{\n    vec3 col = vec3(0.0);\n\n    float fre = clamp( 1.0+dot(nor,rd), 0.0, 1.0 );\n    float sfre = 0.04 + 0.96*pow( fre, 5.0 );\n    float pn = exp2( 10.0*(1.0-matRough) );\n\n    \/\/ sun light\n    {\n        vec3 sunColor = vec3(7.0,4.0,3.0)*1.4;\n        vec3 sun = normalize(vec3(-0.8,0.35,-0.3));\n        float dif = clamp( dot(sun,nor), 0.0, 1.0 );\n        float sha = 0.0; if( dif>0.001 ) sha = calcShadow( pos, sun );\n        vec3 hal = normalize( sun - rd );\n        float spe = pow( clamp(dot(hal,nor), 0.0, 1.0 ), pn );\n        col += matColor * sunColor * dif * vec3(sha,0.5*sha*(1.0+sha),sha*sha);\n        col += (1.0-matRough)*sunColor * spe * pn * dif * sha * sfre \/ 4.0;\n    }\n\n    \/\/ sky light\n    {\n        vec3 skyColor = vec3(0.3,0.4,0.7)*1.0;\n        float dif = 0.5 + 0.5*nor.y;\n        col += matColor * skyColor * dif * occ;\n        col += skyColor * (1.0-matRough) * smoothstep( 0.0,0.2,reflect(rd,nor).y ) * sfre * 2.5 * matRefOcc;\n    }\n\n    \/\/ bounce light\n    {\n        vec3 bouColor = vec3(0.2,0.4,0.0)*1.2;\n        float dif = clamp(0.5 - 0.5*nor.y,0.0,1.0);\n        col += matColor * bouColor * dif * occ;\n    }\n\n    col += fre*matColor*occ*matSSS;\n    col = pow( max(col,0.0), matGamma );\n\n    return col;\n}\n\nvec3 background(in vec3 d)\n{\n    \/\/ cheap cubemap\n    vec3 n = abs(d);\n    vec2 uv = (n.x>n.y && n.x>n.z) ? d.yz\/d.x: \n              (n.y>n.x && n.y>n.z) ? d.zx\/d.y:\n                                     d.xy\/d.z;\n    return vec3(0.02,0.01,0.00) + vec3(2.5)*pow(texture( iChannel1, 0.1*uv, 1.0 ).yxz,vec3(2.6,4.0,4.2));\n}\n\nmat3 calcCamera( in vec3 ro, in vec3 ta )\n{\n    vec3 w = normalize( ro-ta );\n    vec3 u = normalize( cross( vec3(0.0,1.0,0.0), w ) );\n    vec3 v =          ( cross( w, u ) );\n    \n    return mat3( u, v, w );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy+2.0*fragCoord) \/ iResolution.y;\n    \n    \/\/ camera\n    vec3 ro = vec3(0.0,2.7,-3.0);\n    vec3 ta = vec3(0.0,1.9,0.0);\n    ro.x += 0.3*sin(0.03*iTime);    \n    mat3 camRot = calcCamera( ro, ta );\n    \n    \/\/ ray\n    vec3 rd = normalize( camRot * vec3(p,-2.0) );\n    \n    \/\/ background\n    vec3 col = background(rd);\n \n    \/\/ scene\n    vec3 tm = raycast(ro,rd);\n    float t = tm.x;\n    float matID = tm.y;\n    if( matID>0.5 )\n    {\n        vec3 pos = ro + t*rd;\n    \tvec3 nor = calcNormal( pos ); \n        \n        vec3 matNormal, matColor, matGamma;\n        float matRough, matOcc, matSSS, matRefOcc;\n        \n        materials( matID, tm.z, pos, nor, matColor, matRough, matNormal, matOcc, matSSS, matRefOcc, matGamma );\n        col = lighting( t, rd, pos, matNormal, matOcc, matColor, matRough, matSSS, matRefOcc, matGamma );\n    }\n    else\n    {\n        t = 30.0;\n    }\n    \n\tfragColor = vec4( col, t*dot(rd,normalize(ta-ro)) );\n}","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"ldtGWj","date":"1452349689","viewed":22098,"name":"Precalculated Voronoi Heightmap","username":"Shane","description":"Generating a simple, abstract stone texture in a single loop pass, then using it as a heightmap for raymarching purposes.","likes":223,"published":3,"flags":32,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/*\n\n\tPrecalculated Voronoi Heightmap\n\t-------------------------------\n\n\tGenerating a simple, abstract stone texture in a single offscreen loop pass, then using \n\tit as a heightmap for raymarching purposes. The example itself is nothing exciting, but it \n\tshows that you can now calculate things like multiple terrain layers - or anything you can \n\tdream up - in a single pass. In fact, if you put together a simple resizing system, you \n\tcould get it done in a single frame.\n\n\tYou can find the texture creation behind the \"Buf A\" tab. For the record, I haven't\tproperly \n\tinvestigated correct procedures yet, so there's probably a better way to preload a heightmap. \n\tIdeally, it'd be nice to render to a fixed sized buffer, like 512 by 512 for instance, which\n    would be especially helpful when moving to fullscreen, but I don't think that's possible at \n\tpresent? Either way, the framerate is much, much better in a sub-1000-px sized canvas than \n\tit would be if you had to do the same without multipass.\n\n\tBy the way, thanks to \"poljere,\" \"iq\" -- and whoever else was involved -- for providing \n\tmultiple-pass functionality. Putting that together would have been a backend nightmare, but \n\tit opens up so many possibilities.\n\n*\/\n\n\/\/ If you want to see what the generated heightmap looks like by itself, uncomment the following.\n\/\/#define SHOW_HEIGHMAP \n\n\/\/ Tri-Planar blending function. Based on an old Nvidia writeup:\n\/\/ GPU Gems 3 - Ryan Geiss: http:\/\/http.developer.nvidia.com\/GPUGems3\/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n   \n    p = fract(p);\n    \n    n = max(n*n, 0.001);\n    n \/= (n.x + n.y + n.z ); \n    \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\n\/\/ Reducing the heightmap function to a single texel lookup - via the stone texture which was \n\/\/ generated outside the distance function in the onscreen buffer, of course.\n\/\/\n\/\/ Using the single pass system, there would have been no other option than to generate the stone \n\/\/ texture several times a frame... or beg someone behind the scenes to provide a 2D multilayered \n\/\/ Voronoi heightmap. :)\nfloat heightMap( in vec2 p ) { \n\n    \/\/ The stone texture is tileable, or repeatable, which means the pattern is slightly\n    \/\/ repetitive, but not too bad, all things considered. Note that the offscreen buffer \n    \/\/ doesn't wrap, so you have to do that yourself. Ie: fract(p) - Range [0, 1].\n    return texture(iChannel0, fract(p\/2.), -100.).w;\n\n}\n\n\n\/\/ Raymarching a textured XY-plane, with a bit of distortion thrown in.\nfloat map(vec3 p){\n\n    \/\/ The height value.\n    float c = heightMap(p.xy);\n    \n    \/\/ Back plane, placed at vec3(0., 0., 1.), with plane normal vec3(0., 0., -1).\n    \/\/ Adding some height to the plane from the texture. Not much else to it.\n    return 1. - p.z - c*.1;\/\/texture(texChannel0, p.xy).x*.1;\n\n    \n    \/\/ Smoothed out.\n    \/\/float t =  heightMap(p.xy);\n    \/\/return 1. - p.z - smoothstep(0.1, .8, t)*.06 - t*t*.03;\n    \n}\n\n\n\/\/ Tetrahedral normal, courtesy of IQ.\nvec3 getNormal( in vec3 pos )\n{\n    vec2 e = vec2(0.001, -0.001);\n    return normalize(\n        e.xyy * map(pos + e.xyy) + \n        e.yyx * map(pos + e.yyx) + \n        e.yxy * map(pos + e.yxy) + \n        e.xxx * map(pos + e.xxx));\n}\n\n\n\n\/\/ Ambient occlusion, for that self shadowed look.\n\/\/ Based on the original by IQ.\nfloat calculateAO(vec3 p, vec3 n)\n{\n   const float AO_SAMPLES = 5.0;\n   float r = 1.0, w = 1.0;\n   for (float i=1.0; i<=AO_SAMPLES; i++)\n   {\n      float d0 = i\/AO_SAMPLES;\n      r += w * (map(p + n * d0) - d0);\n      w *= 0.5;\n   }\n   return clamp(r, 0.0, 1.0);\n}\n\n\/\/ Cool curve function, by Shadertoy user, Nimitz.\n\/\/\n\/\/ It gives you a scalar curvature value for an object's signed distance function, which \n\/\/ is pretty handy for all kinds of things. Here's it's used to darken the crevices.\n\/\/\n\/\/ From an intuitive sense, the function returns a weighted difference between a surface \n\/\/ value and some surrounding values - arranged in a simplex tetrahedral fashion for minimal\n\/\/ calculations, I'm assuming. Almost common sense... almost. :)\n\/\/\n\/\/ Original usage (I think?) - Cheap curvature: https:\/\/www.shadertoy.com\/view\/Xts3WM\n\/\/ Other usage: Xyptonjtroz: https:\/\/www.shadertoy.com\/view\/4ts3z2\nfloat curve(in vec3 p){\n\n    const float eps = 0.0225, amp = 7.5, ampInit = 0.525;\n\n    vec2 e = vec2(-1., 1.)*eps; \/\/0.05->3.5 - 0.04->5.5 - 0.03->10.->0.1->1.\n    \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    \n    return clamp((t1 + t2 + t3 + t4 - 4.*map(p))*amp + ampInit, 0., 1.);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    \n    \/\/ Unit direction ray. Divisionless one liner, courtesy of user, Coyote.\n    vec3 rd = normalize(vec3(fragCoord - iResolution.xy*.5, min(iResolution.y*.75, 600.)));\n    \n    float tm = iTime\/2.;\n    \/\/ Rotating the XY-plane back and forth, for a bit of variance.\n    \/\/ Elegant angle vector, courtesy of user, Fabrice.\n    vec2 th = sin(vec2(1.57, 0) + sin(tm\/4.)*.3);\n    rd.xy = mat2(th, -th.y, th.x)*rd.xy;\n    \n    \/\/ Tilting the camera in another direction.\n    \/\/th = sin(vec2(1.57, 0) + sin(iTime\/8.)*.1);\n    \/\/mat2(th, -th.y, th.x)*rd.yz;\n    \n    \n    \/\/ Ray origin. Moving in the X-direction to the right.\n    vec3 ro = vec3(tm, cos(tm\/4.), 0.);\n    \n    \n    \/\/ Light position, hovering around behind the camera.\n    vec3 lp = ro + vec3(cos(tm\/4.)*.5, sin(tm\/4.)*.5, -.5);\n    \n    \/\/ Standard raymarching segment. Because of the straight forward setup, very few \n    \/\/ iterations are needed.\n    float d, t=0.;\n    for(int j=0; j<32; j++){\n      \n        d = map(ro + rd*t); \/\/ Distance to the function.\n        \n        \/\/ The plane \"is\" the far plane, so no far plane break is needed.\n        if(d<0.001) break; \n        \n        t += d*.7; \/\/ Total distance from the camera to the surface.\n    \n    }\n    \n   \n    \/\/ Surface postion, surface normal and light direction.\n    vec3 sp = ro + rd*t;\n    vec3 sn = getNormal(sp);\n    vec3 ld = lp - sp;\n    \n    \n    \/\/ Texture scale factor.\n    const float tSize0 = 1.\/1.;\n    \n    \n    \/\/ Retrieving the texel at the surface postion. A tri-planar mapping method is used to\n    \/\/ give a little extra dimension. The time component is responsible for the texture movement.\n    float c = heightMap(sp.xy);\n   \n    \n    vec3 oC = tex3D(iChannel0, sp*tSize0, sn);\n    \/\/vec3 oC = texture(iChannel0, sp.xz*tSize0).xyz*(vec3(c)*.5+.5); \/\/ 2D texel lookup.\n    \/\/vec3 oC = vec3(.55)*(vec3(c)*.9+.1); \/\/ Textureless.\n    \n    \/\/ Mixing in the normal to give the color a bit of a pearlescent quality. These rocks probably\n    \/\/ wouldn't have a pearlecent quality... Um... space rocks. :)\n    oC *= pow(max(c*c*sn*.7 + 1., 0.), vec3(2))*c;\n   \n    \n    \n    float lDist = max(length(ld), 0.001); \/\/ Light distance.\n    float atten = 1.\/(1. + lDist*.125); \/\/ Light attenuation.\n    \n    ld \/= lDist; \/\/ Normalizing the light direction vector.\n    \n    float diff = max(dot(ld, sn), 0.); \/\/ Diffuse.\n    diff = pow(diff, 4.)*2.;\n    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 16.); \/\/ Specular.\n    float fre = pow(clamp(dot(sn, rd) + 1., .0, 1.), 2.); \/\/ Fake Fresnel, for the glow.\n \n    \/\/ Schlick Fresnel approximation, to tone down the specular component a bit.\n\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\tfloat fre2 = mix(.5, 1., Schlick);  \/\/F0 = .5;  \/\/ Hard granite.  \n    \n    \/\/ Shading. Note, there are no actual shadows. The camera is front on, so the following\n    \/\/ two functions are enough to give a shadowy appearance.\n    float crv = curve(sp); \/\/ Curve value, to darken the crevices.\n    crv = smoothstep(0., 1., crv)*.5 + crv*.25 + .25; \/\/ Tweaking the curve value a bit.\n    \n    float ao = calculateAO(sp, sn); \/\/ Ambient occlusion, for self shadowing.\n\n\n    \n    \/\/ Combining the terms above to light the texel.\n    vec3 col = (oC*(diff + .25 + vec3(.5, .7, 1)*spec*fre2*4. + vec3(1, .1, .2)*fre*8.));\n    \n    \n    \/\/ Another variation, without the Fresnel glow.\n    \/\/vec3 col = (oC*(diff + 1.) + vec3(1., .9, .7)*spec*fre2*2.);\n \n    \n    \/\/ Applying the shades.\n    col *= atten*crv*ao;\n    \n    \/\/col = vec3(crv);\n    \n    #ifdef SHOW_HEIGHMAP\n    vec2 uv = fragCoord.xy\/iResolution.y;\n    uv = mat2(th, -th.y, th.x)*uv;\n    uv += vec2(iTime, cos(iTime\/4.))\/2.;\n    vec4 tex = texture(iChannel0, fract(uv\/1.));\n    col = sqrt(tex.xyz)*tex.w;\n\t#endif\n\n    \/\/ Presenting to the screen.\n\tfragColor = vec4(sqrt(clamp(col, 0., 1.)), 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGRn","filepath":"\/media\/a\/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"\/media\/ap\/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ 2x2 hash algorithm.\nvec2 hash22(vec2 p) { \n    \n    \/\/ This line makes the pattern repeatable. \n    p = mod(p, 5.); \n\n    \/\/ More concise, but wouldn't disperse things as nicely as other versions.\n    float n = sin(dot(p, vec2(41, 289))); \n    return fract(vec2(8, 1)*262144.*n);\n\n    \/\/p = fract(vec2(8, 1)*262144.*n);\n    \/\/return sin(p*6.283 + iTime)*0.5 + 0.5;\n\n}\n\n\n\/\/ 2D 2nd-order Voronoi: Obviously, this is just a rehash of IQ's original. I've tidied\n\/\/ up those if-statements. Since there's less writing, it should go faster. That's how \n\/\/ it works, right? :)\n\/\/\nfloat voronoi(in vec2 p){\n    \n\tvec2 g = floor(p), o; p -= g;\n\t\n\tvec3 d = vec3(1); \/\/ 1.4, etc. \"d.z\" holds the distance comparison value.\n    \n\tfor(int y = -1; y <= 1; y++){\n\t\tfor(int x = -1; x <= 1; x++){\n            \n\t\t\to = vec2(x, y);\n            o += hash22(g + o) - p;\n            \n\t\t\td.z = dot(o, o);            \n            d.y = max(d.x, min(d.y, d.z));\n            d.x = min(d.x, d.z); \n                       \n\t\t}\n\t}\n\t\n\t\n    return d.y - d.x;\n    \/\/ return d.x;\n    \/\/ return max(d.y*.91 - d.x*1.1, 0.)\/.91;\n    \/\/ return sqrt(d.y) - sqrt(d.x); \/\/ etc.\n}\n\n\/\/ Prerendering a simple stone texture to one of the offscreen buffers. The process is simple, but\n\/\/ definitely not simple enough to calculate it on the fly inside a distance function.\n\/\/\n\/\/ There is one minor complication, and that is the texture needs to be repeatable. That's its own\n\/\/ discussion, but if you're not sure how it's achieved, the key to repeatable Voronoi are the lines \n\/\/ \"p = mod(p, 5)\" and \"float c = voronoi(p*5.)... .\" I'm sure you'll figure it out from there. :)\n\/\/\n\/\/ The random pixelization business is just a hacky way to redraw the texture when the canvas is resized.\n\/\/ Definitely not the best way to go about it, that's for sure.\n\/\/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \/\/ Offscreen buffer coordinates.\n    vec2 p = fragCoord.xy\/iResolution.xy;\n\n    \/\/ On the first frame, render the entire texture. Otherwise, randomly render every 8 pixels,\n    \/\/ which, in theory, should lessen the workload. I'm continuously rendering parts of the texture\n    \/\/ to account for resizing events. If you resize, the new heighmap will quickly pixel fade in.\n    \n    \/\/ Obviously, a better solution would be to detect a resize and render the texture just once, or \n    \/\/ better yet, have a fixed size offscreen buffer option... Although, that sounds like a backend \n    \/\/ nightmare. :)\n    \/\/if(hash22(p + iTime).x< 1.\/8. || iFrame==0){\n    if(floor(hash22(p + iTime).x*8.)< 1. || iFrame==0){    \n        \n        \/\/ The stone texture. I made this up on the spot. Basically add three second order Voronoi\n        \/\/ layers of varying amplitudes and frequency. Also, perturb the initial UV coordinates\n        \/\/ to give it more of a natural look. Finally, add some fine detailing via one of Shadertoy's\n        \/\/ in-house textures. By the way, you could generate that also, but I didn't want to \n        \/\/ overcomplicate a simple example.\n        \n        \/\/ Texture value. Reversing the channels for a different color variation.\n        vec3 tx = texture(iChannel1, p).xyz; tx *= tx;\n        tx = smoothstep(0., .5, tx);\n        \n        \/\/ Perturbing the UV coordinates just slightly to give the stones a slightly more natural feel.\n        \/\/ Note the PI frequencies. That's for texture wrapping purposes.\n        p += sin(p*6.283*2. - cos(p.yx*6.283*4.))*.01;\n        \n        \/\/ Three Voronoi layers. Pretty standard. I could have put a lot more effort into this\n        \/\/ part, but it's just a simple proof of concept, so just three lazy layers.\n        \n        \/\/ More stone looking.\n        \/\/float c = voronoi(p*5.)*.8 + voronoi(p*15.)*.15 + voronoi(p*45.)*.05;\n        \n        \/\/ Less detail.\n        \/\/float c = voronoi(p*5.) - (1.-voronoi(p*15.))*.08 + voronoi(p*45.)*.04;\n        \n       \n        \/\/float c = voronoi(p*5.)*.6 + voronoi(p.yx*5. + vec2(2.666, 1.666))*.4 - (1.-voronoi(p*15.))*.08 + voronoi(p*45.)*.04;\n        float c = voronoi(p*5. - .35)*.6 + voronoi((p.yx + .5)*10.)*.3 + (1.-voronoi(p*25.))*.075 + voronoi(p*60.)*.025;\n \n        \n\n        \/\/ Finally, using the greyscale texture value to add some fine detailing.\n        c += dot(tx, vec3(.299, .587, .114))*.1;\n        \n        \n        \/\/ Storing away the values for use in the main part of the application.\n        fragColor.xyz = tx; \/\/ Put the texture color in the XYZ channels.\n        fragColor.w = min(c\/1.1, 1.); \/\/ Store the heightmap value in the \"W\" channel.\n\n\n    }\n    \/\/ Copy the rest of the pixels over to the new frame. Obvious, but it'd been a while, so I had to \n    \/\/ figure that one out. :)\n    else fragColor = texture(iChannel0, p); \n    \n}","name":"Buffer A","description":"","type":"buffer"}]}];    var gUseScreenshots = piIsMobile();
    var gThemeName = "classic";



    </script>
</head>

<!-- <body onload="resultsInit(12,null,null)"> -->
<body onload="resultsInitStatic(12,null,null)">

<!-- header =================================================================================== -->


<div id="header">

    <div id="headerBlock1">
        <a href="/" id="headerTitle">Shadertoy</a>
        <form name="formSearch" action="/results" method="get" style="display:inline-block;">
        <div  id="headerSearch">
            <input type="search" id="mySearch" name="query" placeholder="Search..." value="raymarch"/>
        </div>
        </form>
    </div>

    <div id="headerBlock2">
            <a class="headerLinks" href="/browse">Browse</a>
        <a class="headerLinks" href="/new">New</a>
        <a class="headerLinks" href="/signin">Sign In</a>
        </div>
</div>
<!-- content ================================================================================== -->

<div id="content">

  <div id="controls">
    <div>
      <div style="text-align: center; vertical-align: middle; display: inline-block; padding-bottom:5px; padding-top:4px; margin-right:8px; margin-bottom:8px; margin-top:8px;">
      Sort:      </div>
      <div class="controlOptions"><a class="pageButtons" href="/results?query=raymarch&sort=popular&filter=&filter=multipass">Popular</a><a class="pageButtons" href="/results?query=raymarch&sort=newest&filter=&filter=multipass">Newest</a><div class="pageButtonsCurrent" href="/results?query=raymarch&sort=love&filter=&filter=multipass">Love</div><a class="pageButtons" href="/results?query=raymarch&sort=hot&filter=&filter=multipass">Hot</a></div>
    </div>

    <div id="controlFilter">
      <div style="display:flex;margin-right:8px;align-items:center;">Filter:</div>
      <div class="controlOptions"> <a class="pageButtonsCurrent" href="/results?query=raymarch&sort=love">Multipass</a><a class="pageButtons" href="/results?query=raymarch&sort=love&filter=soundoutput&filter=multipass">GPU Sound</a><a class="pageButtons" href="/results?query=raymarch&sort=love&filter=vr&filter=multipass">VR</a><a class="pageButtons" href="/results?query=raymarch&sort=love&filter=soundinput&filter=multipass">Microphone</a><a class="pageButtons" href="/results?query=raymarch&sort=love&filter=multipass&filter=musicstream">Soundcloud</a><a class="pageButtons" href="/results?query=raymarch&sort=love&filter=webcam&filter=multipass">Webcam</a></div>
    </div>

    <div>
        <div style="text-align: center; vertical-align: middle; display: inline-block; padding-bottom:5px; padding-top:4px; margin-right:8px; margin-bottom:8px; margin-top:8px;">
        View:</div>
        <div><a class="pageButtons" href="/slideshow?query=raymarch&sort=love">Slideshow</a></div>
    </div>

    <div class="navigation" id="navTop" ><span style="padding-right:8px;">Results (36):</span><div class="controlOptions"><div id="pageButton"0 class="pageButtonsCurrent" href="results?query=raymarch&sort=love&filter=multipass&from=0&num=12">1</div><a id="pageButton"1 class="pageButtons" href="results?query=raymarch&sort=love&filter=multipass&from=12&num=12">2</a><a id="pageButton"2 class="pageButtons" href="results?query=raymarch&sort=love&filter=multipass&from=24&num=12">3</a><span>...</span><a id="pageButtonLast" class="pageButtons" href="results?query=raymarch&sort=love&filter=multipass&from=1044&num=12">88</a></div>
</div>
  </div>


  <div id="shaderGrid">
    <div class='searchResult'><div class='searchResultContainer' id='Preview_0_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_0_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_0_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_0_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_0_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_0_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_0_Thumnail'>        <img class='previewThumbnailImage' id='Preview_0_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_0_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_0_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_0_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_0_Info'>  <span class='previewText'  id='Preview_0_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_0_TextUser'></span>  <span class='previewStats' id='Preview_0_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_1_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_1_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_1_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_1_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_1_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_1_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_1_Thumnail'>        <img class='previewThumbnailImage' id='Preview_1_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_1_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_1_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_1_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_1_Info'>  <span class='previewText'  id='Preview_1_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_1_TextUser'></span>  <span class='previewStats' id='Preview_1_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_2_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_2_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_2_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_2_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_2_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_2_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_2_Thumnail'>        <img class='previewThumbnailImage' id='Preview_2_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_2_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_2_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_2_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_2_Info'>  <span class='previewText'  id='Preview_2_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_2_TextUser'></span>  <span class='previewStats' id='Preview_2_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_3_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_3_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_3_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_3_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_3_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_3_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_3_Thumnail'>        <img class='previewThumbnailImage' id='Preview_3_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_3_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_3_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_3_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_3_Info'>  <span class='previewText'  id='Preview_3_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_3_TextUser'></span>  <span class='previewStats' id='Preview_3_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_4_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_4_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_4_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_4_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_4_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_4_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_4_Thumnail'>        <img class='previewThumbnailImage' id='Preview_4_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_4_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_4_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_4_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_4_Info'>  <span class='previewText'  id='Preview_4_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_4_TextUser'></span>  <span class='previewStats' id='Preview_4_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_5_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_5_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_5_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_5_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_5_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_5_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_5_Thumnail'>        <img class='previewThumbnailImage' id='Preview_5_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_5_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_5_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_5_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_5_Info'>  <span class='previewText'  id='Preview_5_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_5_TextUser'></span>  <span class='previewStats' id='Preview_5_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_6_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_6_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_6_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_6_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_6_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_6_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_6_Thumnail'>        <img class='previewThumbnailImage' id='Preview_6_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_6_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_6_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_6_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_6_Info'>  <span class='previewText'  id='Preview_6_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_6_TextUser'></span>  <span class='previewStats' id='Preview_6_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_7_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_7_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_7_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_7_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_7_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_7_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_7_Thumnail'>        <img class='previewThumbnailImage' id='Preview_7_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_7_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_7_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_7_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_7_Info'>  <span class='previewText'  id='Preview_7_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_7_TextUser'></span>  <span class='previewStats' id='Preview_7_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_8_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_8_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_8_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_8_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_8_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_8_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_8_Thumnail'>        <img class='previewThumbnailImage' id='Preview_8_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_8_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_8_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_8_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_8_Info'>  <span class='previewText'  id='Preview_8_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_8_TextUser'></span>  <span class='previewStats' id='Preview_8_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_9_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_9_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_9_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_9_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_9_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_9_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_9_Thumnail'>        <img class='previewThumbnailImage' id='Preview_9_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_9_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_9_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_9_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_9_Info'>  <span class='previewText'  id='Preview_9_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_9_TextUser'></span>  <span class='previewStats' id='Preview_9_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_10_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_10_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_10_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_10_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_10_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_10_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_10_Thumnail'>        <img class='previewThumbnailImage' id='Preview_10_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_10_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_10_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_10_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_10_Info'>  <span class='previewText'  id='Preview_10_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_10_TextUser'></span>  <span class='previewStats' id='Preview_10_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_11_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_11_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_11_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_11_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_11_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_11_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_11_Thumnail'>        <img class='previewThumbnailImage' id='Preview_11_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_11_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_11_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_11_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_11_Info'>  <span class='previewText'  id='Preview_11_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_11_TextUser'></span>  <span class='previewStats' id='Preview_11_Stats'></span></div></div>  </div>
  <br>
  <div class="navigation" id="navBottom" ><span style="padding-right:8px;">Results (36):</span><div class="controlOptions"><div id="pageButton"0 class="pageButtonsCurrent" href="results?query=raymarch&sort=love&filter=multipass&from=0&num=12">1</div><a id="pageButton"1 class="pageButtons" href="results?query=raymarch&sort=love&filter=multipass&from=12&num=12">2</a><a id="pageButton"2 class="pageButtons" href="results?query=raymarch&sort=love&filter=multipass&from=24&num=12">3</a><span>...</span><a id="pageButtonLast" class="pageButtons" href="results?query=raymarch&sort=love&filter=multipass&from=1044&num=12">88</a></div>
</div>  <br>      
</div>

<!-- footer ================================================================================== -->

<div id="footer">
    
    <div><span style="color:#ffffff;">Community Forums</span>
      <ul>
      <li><a class="regular" href="/events">Official Events</a></li>
      <li><a class="regular" href="https://www.facebook.com/groups/147749602472741">In Facebook (english)</a></li>
      <li><a class="regular" href="https://www.facebook.com/groups/1339783682699494">In Facebook (korean)</a></li>
      <li><a class="regular" href="https://discord.gg/XtmMN6E">In Discord</a> (<a class="regular" href="https://discordapp.com/channels/578696555612209173/579531723348639754">direct link</a>)</li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Feedback and Support</span>
      <ul>
      <li><a class="regular" href="https://www.facebook.com/Shadertoy">Facebook</a></li>
      <li><a class="regular" href="https://twitter.com/shadertoy">Twitter</a></li>
      <li><a class="regular" href="https://www.patreon.com/shadertoy">Patreon</a></li>
      <li><a class="regular" href="https://trello.com/b/5hM0CjId">Roadmap</a></li>

      
      </ul>
    </div>

    <div><span style="color:#ffffff;">Shadertoy</span>
      <ul>
      <li><a class="regular" href="/store">Store</a></li>
      <li><a class="regular" href="/howto">Documentation</a></li>
      <li><a class="regular" href="/terms">Terms & Privacy</a></li>
      <li><a class="regular" href="/about">About</a></li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Apps and Plugins</span>
      <ul>
      <li><a class="regular" href="https://itunes.apple.com/us/app/shadertoy/id717961814">Official iPhone App</a> by <a class="user" href="/user/reinder">Reinder</a></li>
      <li><a class="regular" href="https://steamcommunity.com/sharedfiles/filedetails/?id=1726697188">Screensaver</a> by <a class="user" href="/user/kosro">Kosro</a></li>
      <li><a class="regular" href="https://chrome.google.com/webstore/detail/shadertoy-unofficial-plug/ohicbclhdmkhoabobgppffepcopomhgl">Shadertoy plugin</a> by <a class="user" href="/user/patu">Patu</a></li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Tutorials</span>
      <ul>
      <li><a class="regular" href="https://www.youtube.com/watch?v=0ifChJ0nJfM">Shader coding intro</a> by <a class="user" href="/user/iq">iq</a></li>
      <li><a class="regular" href="https://shadertoyunofficial.wordpress.com/">Shadertoy Unofficial</a> by <a class="user" href="/user/FabriceNeyret2">FabriceNeyret2</a></li>
      </ul>
    </div>

</div>

<div id="compliance" style="padding-bottom:6px;visibility:hidden;left:0;top:0px;width:100%;background-color:rgb(200,120,20,0.93);position:absolute;color:#FFFFFF">
    <div style="text-align: center; margin-top:8px">
        We use cookies to give you the best experience on our website. If you continue using Shadertoy, we'll assume that you are happy to receive all cookies on this website. 
        For more information, please review our <a class="regular" href="/terms">Terms & Privacy</a>.
    </div> 
    <div style="text-align: center;margin-top:6px">
        <button type="button" style="width:100px;font-size:inherit" onclick="acceptCompliance()">Accept</button>
    </div>
</div>

<script>
(function runCompliance() 
{
    let showCompliance = 1;
    let allcookies = document.cookie;
    let cookiearray = allcookies.split(';');
    for (var i=0; i<cookiearray.length; i++)
    {
        let name  = cookiearray[i].split('=')[0];
        let value = cookiearray[i].split('=')[1];
        if (name.trim() == "scmp") 
        {
            showCompliance = value;
            break;
        }
    }

    if (showCompliance === 1) 
    {
        var ve = document.getElementById("compliance");
        ve.style.visibility="visible";
    }
})();

function acceptCompliance()
{
    let now = new Date();
    now.setTime( now.getTime() + (5*365*24*60*60*1000) );
    document.cookie="scmp=0;expires=" + now.toUTCString() + ";";

    var ve = document.getElementById("compliance");
    ve.style.visibility="hidden";
}
</script>

<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-44068895-1', 'shadertoy.com');
    ga('send', 'pageview');
</script></body>
</html>
