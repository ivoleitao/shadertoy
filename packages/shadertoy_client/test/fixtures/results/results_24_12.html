<!DOCTYPE HTML>
<html lang="en">
<head>

    
<title>Browse (3) - Shadertoy BETA</title>
<meta charset="utf-8" />
<meta name="Keywords" content="shadertoy, shader toy, quilez, inigo, jeremias, pol, fractals, demoscene, computer graphics, mathematics, rendering, demo, 3D, realtime, shader, raytracing, raymarching, webgl, glsl" />
<meta name="Description" content="Build shaders, share them, and learn from the best community." />
<meta name="Author" content="Beautypi" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<link rel="image_src" href="https://www.shadertoy.com/img/logo.png" />
<link rel="apple-touch-icon" href="/img/launch_icon_57.png"/>
<link rel="apple-touch-icon" sizes="72x72" href="/img/launch_icon_72.png"/>
<link rel="apple-touch-icon" sizes="114x114" href="/img/launch_icon_114.png"/>
<link rel="shortcut icon" href="/img/favicon.ico"/>

<style>::-webkit-scrollbar {
    height: 8px;
    width: 8px;
    background: #404040;
}

::-webkit-scrollbar-thumb
{
    background: #909090;
    border-radius: 0ex;
}

::-webkit-scrollbar-corner
{
    background: #000;
}

::-webkit-input-placeholder
{
	font-style:italic;
}
input:-moz-placeholder, textarea:-moz-placeholder
{
	font-style:italic;
}
input.placeholder-text, textarea.placeholder-text
{
	font-style:italic;
}

pre 
{
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
    white-space: -pre-wrap;
    white-space: -o-pre-wrap;
    word-wrap: break-word;
}

@font-face
{
    font-family: Lobster;
    src: url("/img/lobster.otf") format("opentype");
}

div#centerScreen
{
    left: 50%;
    top: 50%;
    position: absolute;
}

a.headerLinks:hover
{
    background-color:#505050;
    color : #ff8020;
}

body
{
    color: #000000;
    font-size:12px;
    font-style:normal;
    font-family:Tahoma,Arial;
    background-repeat: no-repeat;
    //background-attachment: fixed;
    padding:0px;
    margin:0px;
    text-align: left;
    background-color: #d0d0d0;
    background-repeat: repeat;
    user-select: text;
}

a,
a:hover,
a:visited
{
  color : inherit;
}

div#content {
    width: 95%;
    overflow: hidden;
    margin: auto;
    padding: 0px;
    min-height: calc(100vh - 80px);
    //box-sizing: border-box;
}


.notificationCount
{
 background-color:#ff0000;
 padding-left:3px;
 padding-right:1px;
 padding-top:1px;
 padding-bottom:1px;
}

div#header
{
    background-color: #404040;
    top: 0px;
    left: 0px;
    width: 100%;
    padding: 0;
    margin: 0;
    color: #ffffff;
    display: flex;
    flex-direction:row;
}

#headerBlock1
{
    width: 50%;
    display:flex;
    align-items:center;
}

a#headerTitle
{
    font-size: 2.25em;
    font-family: Lobster,Tahoma,Arial;
    text-decoration: none;
    padding-left:32px;
    padding-right:32px;
}

#headerSearch
{
    display: inline-block;
    color: #000000;
    width: 300px;
}

input[type=search]#mySearch
{
    width: 100%;
    border-radius: 6px;
    border: 1px solid black;
    padding:12px;
}

#headerBlock2
{
    width: 50%;
    margin-left: auto;
    display: flex;
    justify-content: flex-end;
}


a#headerTitle:hover
{
    color : #ff8020;
}

a.headerLinks
{
    font-weight: bold;
    padding-top: 14px;
    padding-bottom: 14px;
    padding-left: 14px;
    padding-right: 14px;
    margin:0px;
    text-decoration: none;
    transition: background-color 0.15s linear, color 0.15s linear;
}

#footer
{
    background-color: rgba(64,64,64,0.25);
    color: #000000;
    padding: 0px;
    margin: 0px;
    width: 100%;
    display: flex;
    justify-content: space-between;
    flex-wrap: wrap;
}

#footer div
{
    padding-top:10px;
    padding-bottom:0px;
    padding-left:16px;
    padding-right:16px;
}

#footer div ul
{
    margin-left:0px;
    padding-left:16px;
}

#footer div ul li
{
    padding-top:6px;
}

a.regular
{
    font-weight:bold;
    text-decoration:none
}

a.regular:hover
{
  color : #ff8020;
}

a.user
{
    font-weight:bold;
    text-decoration:none;
}

a.user:hover
{
  color : #ff8020;
  text-decoration: underline;
}

.uiButton
{
    border: none;
    outline: none;
    margin: 0px;
    padding: 0px;
    width: 22px;
    height: 22px;
    position: absolute;
    cursor: pointer;
    border-radius: 4px;
}

.uiButton:hover
{
    box-shadow: inset 0px 0px 1px 1px #808080, 0px 0px 1px 1px #808080;
}

.uiDivBUtton
{
    cursor:pointer;
}

.uiDivBUtton:hover
{
    color: #ffffff;
}


.dialog
{
    display: block;
    background-color: #e0e0e0;
    color: #000000;
    border:1px solid #000;
    padding:0px;
    margin:0px;
    text-align:left;
    border-radius: 4px;
    box-shadow:4px 4px 6px 0px rgba(0,0,0,0.5);
    overflow: hidden;
    z-index:1000;
    visibility: hidden;
    opacity:0;
    -moz-transition: opacity 0.25s linear,visibility 0.25s linear;
    -webkit-transition: opacity 0.25s linear,visibility 0.25s linear;
    transition: opacity 0.25s linear,visibility 0.25s linear;
}

.dialogHeader
{
    left:0px;
    top: 0px;
    width:100%;
    height:32px;
    position: absolute;
    background-color: #808080;
    cursor:move;
}

.dialogTitle
{
    left: 12px;
    top: 4px;
    position: absolute;
    padding: 0px;
    margin: 0px;
    color:#000000;
    font-size:1.5em;
    text-align: left;
    user-select: none;
    -moz-user-select: -moz-none;
    -webkit-user-select: none;
}

.dialogOverlay
{
    z-index:1000;

    visibility: hidden;
    opacity:0;
    -moz-transition: opacity 0.25s linear,visibility 0.25s linear;
    -webkit-transition: opacity 0.25s linear,visibility 0.25s linear;
    transition: opacity 0.25s linear,visibility 0.25s linear;

    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    width:100%;
    height:100%;
    position:absolute;

    background-color:rgba(0,0,0,.4);
}

.viewsIcon, .likesIcon
{
    border: none;
    outline: none;
    display:inline-block;
    background-repeat:no-repeat;
    top:0px;
    left:0px;
    padding:0px;
    padding-right: 2px;
    margin:0px;
    position:relative;
}

.userPictureSmall
{
    background-color:#808080;
    border: 1px solid #000000;
    width:32px;
    height:32px;
}

.dialogCloseButton
{
    right:8px;
    top: 4px;
    width:22px;
    height:22px;
    position: absolute;
    background-image: url("/img/close.png");
    cursor: pointer;
    border-radius: 4px;
}

.dialogCloseButton:hover
{
    box-shadow: inset 0px 0px 4px 2px #ffffff, 0px 0px 4px 2px #ffffff;
}

.dialogContentButtons
{
     padding:0;
     border:0;
     text-align: justify;
     left: 24px;
     bottom:40px;
     position:absolute;
}

.dialogButton
{
    text-align: center;
    vertical-align: middle;
    display: inline-block;
    border-radius: 4px;
    font-weight: bold;
    cursor: pointer;
    padding-bottom:5px;
    padding-top:4px;
    padding-left: 8px;
    padding-right: 8px;
    margin-left:4px;
    margin-right:4px;
    text-decoration: none;
    color:#000000;
    width: 80px;
    -moz-transition:    background-color 0.15s linear, color 0.15s linear;
    -webkit-transition: background-color 0.15s linear, color 0.15s linear;
    transition:         background-color 0.15s linear, color 0.15s linear;
}

.dialogButton:hover
{
  background-color:#808080;
  color : #ff8020;
}

.dialogCloseButton:hover
{
    box-shadow: inset 0px 0px 4px 2px #ffffff, 0px 0px 4px 2px #ffffff;
}

.dialogContent
{
    color: inherit;
    overflow: auto;
    width:100%;
    height:100%;
    left: 0px;
    top: 32px;
    position:absolute
}

.dialogContentBody
{
    color: inherit;
    width:100%;
    height:auto;
    padding-top:24px;
    padding-bottom:24px;
    padding-left:24px;
    padding-right:24px;
    text-align: left;
}

.formButton
{
    font-weight:bold;
	color:#ffffff;
	border:none;
    text-align:center;
	background-color:#808080;
    border-radius: 4px;
	padding-left:8px;
	padding-right:8px;
	padding-top:4px;
	padding-bottom:4px;
    cursor:pointer;
    min-width:80px;
    box-sizing: border-box;
}
.formInput {
    border-radius: 6px;
    border: 1px solid black;
    padding: 4px;
    border: none;
}
.formButton:hover {
    background-color: #e0e0e0;
}
.formButton:disabled
{
	color:#b0b0b0;
	background-color:#808080;
}

.formButtonSmall
{
    color:#ffffff;
    border:none;
    text-align:center;
    background-color:#808080;
    border-radius: 4px;
    padding-left:2px;
    padding-right:2px;
    padding-top:2px;
    padding-bottom:2px;
    cursor:pointer;
    min-width:40px;
}

.formButtonSmall:hover
{
    background-color: #e0e0e0;
}

.formButtonSmall:disabled
{
    color:#b0b0b0;
    background-color:#808080;
}

.formButtonSmall.disabled2,
.formButton.disabled2 { color:#b0b0b0; background-color:#808080; pointer-events: none; }

.inputForm
{
    padding-left:2%;
    padding-right:2%;
    resize: none;
    text-align: left;
    background-color:#e0e0e0;
    outline: none;
    border-radius: 4px;
    border: 1px solid #808080;
    color:inherit;
    box-sizing: border-box;
}

.inputForm:focus
{
    border: 1px solid #AFCDD8;
    background-color: #EBF2F4;
}

.transparentPannel
{
    background-color:rgba(64,64,64,0.1);
    padding:16px;
}

.comment, .commentSelf, .commentNew
{
    border-radius: 4px;
    width: 100%;
    margin-left: 0px;
    margin-right: 0px;
    margin-top: 0px;
    margin-bottom: 6px;

    padding: 14px;
    box-sizing: border-box;
    display: grid;
    grid-template-columns: 32px auto 8px;
    grid-template-rows: 1fr;
    grid-gap:8px;
}

.comment:nth-child(even)
{
    background-color: rgba(64,64,64,0.1);
}

.comment:nth-child(odd)
{
    background-color: rgba(128,128,128,0.1);
}

.commentSelf
{
    background-color: rgba(240,160,64,0.1);
}

.commentNew
{
    padding-right: 0px;
    grid-template-columns: 40px auto;
}

.commentContent
{
    vertical-align: top;
    text-align: left;
    word-break: break-all;
    word-break: break-word;
    white-space: pre-wrap;
    white-space: -moz-pre-wrap;
}


/* ----------------------- media resolutions ------------------------ */

@media screen and (max-width:799px)
{
    div#header {flex-direction:column; }
    #headerBlock1 { width:100%; }
    #headerBlock2 { width:100%; justify-content: space-around;}
    div#headerSearch {width:200px;}
    input#mySearch { width:200px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .previewText { width:130px; }
    .transparentPannel { padding:10px; }
}

@media screen and (min-width:800px) and (max-width:1279px)
{
    body { font-size: 9px; }
    div#headerSearch {width: 250px;}
    input#mySearch { width:250px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .previewText { width:130px; }
    .transparentPannel { padding:11px; }
}

@media screen and (min-width:1280px) and (max-width:1439px)
{
    body { font-size: 10px; }
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:28px; }
    .previewText { width:180px; }
    .transparentPannel { padding:12px; }
}

@media screen and (min-width:1440px) and (max-width:1919px)
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:28px; }
    .previewText { width:180px; }
    .transparentPannel { padding:12px; }
}

@media screen and (min-width:1920px) and (max-width:2559px)
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:32px; }
    .previewText { width:220px; }
    .transparentPannel { padding:16px; }
}

@media screen and (min-width:2560px) 
{
    div#headerSearch {width: 300px;}
    input#mySearch { width:300px; left:21px; height:22px; border-radius:6px; padding-left:8px; padding-right:8px; }
    .dialogHeader { height:32px; }
    .previewText { width:220px; }
    .transparentPannel { padding:16px; }
}
body
{
    background-image: url("/img/themes/classic/background.jpg");
}
</style>



    <script>"use strict"

//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piCamera
//
//==============================================================================

function piCamera()
{
    var mMatrix = setIdentity();
    var mMatrixInv = setIdentity();

    var mPosition = [0.0,0.0,0.0];
    var mXRotation = 0.0;
    var mYRotation = 0.0;

    var mPositionTarget = [0.0,0.0,0.0];
    var mXRotationTarget = 0.0;
    var mYRotationTarget = 0.0;

    var me = {};
/*
    me.Set = function( pos, dir, roll) 
             {
                 mMatrix    = setLookat( pos, add(pos,dir), [Math.sin(roll),Math.cos(roll),Math.sin(roll)] );
                 mMatrixInv = invertFast( mMatrix );
             };
*/
    me.SetPos = function(pos)
                {
                    mPosition = pos;
                    //mMatrix[ 3] = -(mMatrix[0] * pos[0] + mMatrix[1] * pos[1] + mMatrix[ 2] * pos[2]);
                    //mMatrix[ 7] = -(mMatrix[4] * pos[0] + mMatrix[5] * pos[1] + mMatrix[ 6] * pos[2]);
                    //mMatrix[11] = -(mMatrix[8] * pos[0] + mMatrix[9] * pos[1] + mMatrix[10] * pos[2]);
                };
/*
    me.GlobalMove = function(pos)
                    {
                        mMatrix[ 3] -= (mMatrix[0] * pos[0] + mMatrix[1] * pos[1] + mMatrix[ 2] * pos[2]);
                        mMatrix[ 7] -= (mMatrix[4] * pos[0] + mMatrix[5] * pos[1] + mMatrix[ 6] * pos[2]);
                        mMatrix[11] -= (mMatrix[8] * pos[0] + mMatrix[9] * pos[1] + mMatrix[10] * pos[2]);
                        mMatrixInv = invertFast(mMatrix);
                    };
*/
    me.LocalMove = function( dis )
                    {
                        dis = matMulvec( setRotationY(-mYRotation), dis);
                        mPositionTarget = sub(mPositionTarget,dis)
                    };

    me.RotateXY = function( x, y)
                  {
                    mXRotationTarget -= x;
                    mYRotationTarget -= y;
                    mXRotationTarget = Math.min( Math.max( mXRotationTarget, -Math.PI/2), Math.PI/2 );
                  };


    me.CameraExectue = function( dt )
    {
        // smooth position
        mXRotation += (mXRotationTarget-mXRotation) * 12.0*dt;
        mYRotation += (mYRotationTarget-mYRotation) * 12.0*dt;
        mPosition = add(mPosition, mul( sub(mPositionTarget, mPosition), 12.0*dt));

        // Make Camera matrix
        mMatrix = matMul( matMul(setRotationX(mXRotation), 
                                 setRotationY(mYRotation)),  
                                 setTranslation(mPosition));
        mMatrixInv = invertFast(mMatrix);

    }

    me.GetMatrix = function() { return mMatrix; };
    me.GetMatrixInverse = function() { return mMatrixInv; };
    me.SetMatrix = function( mat ) 
                    {
                        mMatrix = mat;
                        mMatrixInv = invertFast(mMatrix);

                        mPosition = getXYZ(matMulpoint(mat, [0.0,0.0,0.0]));
                        mPositionTarget = mPosition;
                    };

    me.GetPos = function() { return getXYZ(matMulpoint(mMatrixInv, [0.0,0.0,0.0])); }
    me.GetDir = function() { return getXYZ(normalize(matMulvec(mMatrixInv, [0.0,0.0,-1.0]))); }

    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piFile
//
//==============================================================================

function piFile( binaryDataArrayBuffer )
{
    // private
    //var mDataView = new DataView( binaryDataArrayBuffer, 0 );
    var mDataView = binaryDataArrayBuffer;
    var mOffset = 0;

    // public members
    var me = {};
    me.mDummy = 0;
/*
    // public functions
    me.Seek = function( off ) { mOffset = off - 3; };
    me.ReadUInt16 = function()  { var res = mDataView.getUint16( mOffset ); mOffset+=2; return res; };
    me.ReadUInt32 = function()  { var res = mDataView.getUint32( mOffset ); mOffset+=4; return res; };
    me.ReadUInt64 = function()  { return me.ReadUInt32() + (me.ReadUInt32()<<32); };
    me.ReadFloat32 = function() { var res = mDataView.getFloat32( mOffset ); mOffset+=4; return res; };
*/

    me.Seek = function( off ) { mOffset = off; };
    me.ReadUInt8  = function()  { var res = (new Uint8Array(mDataView,mOffset))[0]; mOffset+=1; return res; };
    me.ReadUInt16 = function()  { var res = (new Uint16Array(mDataView,mOffset))[0]; mOffset+=2; return res; };
    me.ReadUInt32 = function()  { var res = (new Uint32Array(mDataView,mOffset))[0]; mOffset+=4; return res; };
    me.ReadUInt64 = function()  { return me.ReadUInt32() + (me.ReadUInt32()<<32); };
    me.ReadFloat32 = function() { var res = (new Float32Array(mDataView,mOffset))[0]; mOffset+=4; return res; };
    me.ReadFloat32Array = function(n) 
                          { 
                              var src = new Float32Array(mDataView, mOffset);
                              var res = [];  for( var i=0; i<n; i++ ) { res[i] = src[i]; }
                              mOffset += 4*n;
                              return res;
                          };
    me.ReadFloat32ArrayNative = function(n) { var src = new Float32Array(mDataView, mOffset); mOffset += 4*n; return src; };
    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piMesh
//
//==============================================================================

function piMesh()
{
    this.mChunks = [];
    this.mPrimitiveType = 0;
    this.mVertexFormat = null;
}

/*
piMesh.prototype.normalize = function( ppos, npos )
{
    var numv = this.mVertexData.length;
    var numt = this.mIndices.length;

    for( var i=0; i<numv; i++ )
    {
        //float *v = (float*)piMesh_GetVertexData( me, i, npos );
        //v[0] = 0.0f;
        //v[1] = 0.0f;
        //v[2] = 0.0f;
        this.mVerts[8 * i + 3] = 0.0;
        this.mVerts[8 * i + 4] = 0.0;
        this.mVerts[8 * i + 5] = 0.0;
    }

    for( var i=0; i<numt; i++ )
    {
        piMeshFace *face = me->mFaceData.mIndexArray[0].mBuffer + i;

        const int ft = face->mNum;
        
        vec3 nor = vec3( 0.0f, 0.0f, 0.0f );
        for( int j=0; j<ft; j++ )
        {
            const vec3 va = *((vec3*)piMesh_GetVertexData( me, face->mIndex[ j      ], ppos ));
            const vec3 vb = *((vec3*)piMesh_GetVertexData( me, face->mIndex[(j+1)%ft], ppos ));

            nor += cross( va, vb );
        }

        for( int j=0; j<ft; j++ )
        {
            vec3 *n = (vec3*)piMesh_GetVertexData( me, face->mIndex[j], npos );
            n->x += nor.x;
            n->y += nor.y;
            n->z += nor.z;
        }
    }

    for( var i=0; i<numv; i++ )
    {
        vec3 *v = (vec3*)piMesh_GetVertexData( me, i, npos );
        *v = normalize( *v );
    }
}
*/

piMesh.prototype.createCube = function(renderer)
{
    this.mPrimitiveType = 0;

    this.mChunks[0] = { mVerts : new Float32Array([ -1.0, -1.0, -1.0,
                                       1.0, -1.0, -1.0,
                                      -1.0,  1.0, -1.0,
                                       1.0,  1.0, -1.0,
                                      -1.0, -1.0,  1.0,
                                       1.0, -1.0,  1.0,
                                      -1.0,  1.0,  1.0,
                                       1.0,  1.0,  1.0 ]),

                        mIndices : new Uint16Array([ 0, 2, 1,   1, 2, 3,   5, 1, 3,   5, 3, 7,   4, 5, 7,   4, 7, 6,   4, 6, 2,   4, 2, 0,   6, 7, 3,   6, 3, 2,   4, 0, 1,   4, 1, 5 ]),
                        mNumVertices : 8,
                        mNumFaces : 12, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };

    this.mVertexFormat = { mStride:12, mChannels:[ { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false } ] };

    return true;
}

piMesh.prototype.createCubeSharp = function (renderer)
{
    this.mPrimitiveType = 0;

    this.mChunks[0] = { mVerts : new Float32Array([-1.0, 1.0,-1.0,   0.0, 1.0, 0.0,   0.0, 0.0,
                                    -1.0, 1.0, 1.0,   0.0, 1.0, 0.0,   0.0, 1.0,
                                     1.0, 1.0, 1.0,   0.0, 1.0, 0.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   0.0, 1.0, 0.0,   1.0, 0.0,

                                    -1.0,-1.0, 1.0,   0.0, 0.0, 1.0,   0.0, 0.0,
                                     1.0,-1.0, 1.0,   0.0, 0.0, 1.0,   0.0, 1.0,
                                     1.0, 1.0, 1.0,   0.0, 0.0, 1.0,   1.0, 1.0,
                                    -1.0, 1.0, 1.0,   0.0, 0.0, 1.0,   1.0, 0.0,

                                     1.0, 1.0, 1.0,   1.0, 0.0, 0.0,   0.0, 0.0,
                                     1.0,-1.0, 1.0,   1.0, 0.0, 0.0,   0.0, 1.0,
                                     1.0,-1.0,-1.0,   1.0, 0.0, 0.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   1.0, 0.0, 0.0,   1.0, 0.0,

                                     1.0,-1.0,-1.0,   0.0, 0.0,-1.0,   0.0, 0.0,
                                    -1.0,-1.0,-1.0,   0.0, 0.0,-1.0,   0.0, 1.0,
                                    -1.0, 1.0,-1.0,   0.0, 0.0,-1.0,   1.0, 1.0,
                                     1.0, 1.0,-1.0,   0.0, 0.0,-1.0,   1.0, 0.0,

                                    -1.0,-1.0, 1.0,   0.0,-1.0, 0.0,   0.0, 0.0,
                                    -1.0,-1.0,-1.0,   0.0,-1.0, 0.0,   0.0, 1.0,
                                     1.0,-1.0,-1.0,   0.0,-1.0, 0.0,   1.0, 1.0,
                                     1.0,-1.0, 1.0,   0.0,-1.0, 0.0,   1.0, 0.0,

                                    -1.0, 1.0, 1.0,  -1.0, 0.0, 0.0,   0.0, 0.0,
                                    -1.0, 1.0,-1.0,  -1.0, 0.0, 0.0,   0.0, 1.0,
                                    -1.0,-1.0,-1.0,  -1.0, 0.0, 0.0,   1.0, 1.0,
                                    -1.0,-1.0, 1.0,  -1.0, 0.0, 0.0,   1.0, 0.0 ]),

                        mIndices : new Uint16Array([0,1,2, 0,2,3,   4,5,6, 4,6,7,    8,9,10,8,10,11,   12,13,14,12,14,15,   16,17,18,16,18,19,   20,21,22,20,22,23]),
                        mNumVertices : 24,
                        mNumFaces : 12, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };


    this.mVertexFormat = { mStride:32, mChannels:[ { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false },
                                                   { mNumComponents:3, mType: renderer.TYPE.FLOAT32, mNormalize: false },
                                                   { mNumComponents:2, mType: renderer.TYPE.FLOAT32, mNormalize: false } ] };

    return true;
}


piMesh.prototype.createUnitQuad = function (renderer)
{
    this.mPrimitiveType = 0;
    this.mVertexFormat = { mStride:8, mChannels: [ {mNumComponents:2, mType: renderer.TYPE.FLOAT32, mNormalize: false} ] };

    this.mChunks[0] = { mVerts : new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0,  1.0, 1.0,  1.0]),
                        mIndices : new Uint16Array([0, 2, 1, 1, 2, 3]),
                        mNumVertices : 4,
                        mNumFaces : 2, 
                        mTransform : setIdentity(),
                        mVBO : null, 
                        mIBO : null };
 
    return true;
}




piMesh.prototype.destroy = function()
{
    //delete this.mVerts;   this.mVerts = null;
    //delete this.mIndices; this.mIndices = null;
}

piMesh.prototype.scale = function (x, y, z)
{
    var stride = this.mVertexFormat.mStride/4;
    for( var j=0; j<this.mChunks.length; j++ )
    {
        var nv = this.mChunks[j].mNumVertices;
        for (var i = 0; i < nv; i++) 
        {
            this.mChunks[j].mVerts[stride * i + 0] *= x;
            this.mChunks[j].mVerts[stride * i + 1] *= y;
            this.mChunks[j].mVerts[stride * i + 2] *= z;
        }
    }
}

piMesh.prototype.translate = function (x, y, z) 
{
    var stride = this.mVertexFormat.mStride/4;
    for( var j=0; j<this.mChunks.length; j++ )
    {
        var nv = this.mChunks[j].mNumVertices;
        for (var i = 0; i < nv; i++) 
        {
            this.mChunks[j].mVerts[stride * i + 0] += x;
            this.mChunks[j].mVerts[stride * i + 1] += y;
            this.mChunks[j].mVerts[stride * i + 2] += z;
        }
    }
}

piMesh.prototype.GPULoad = function (renderer)
{
    for( var i=0; i<this.mChunks.length; i++ )
    {
        var vbo = renderer.CreateVertexArray(this.mChunks[i].mVerts, renderer.BUFTYPE.STATIC );
        if (vbo == null)
            return false;

        var ibo = renderer.CreateIndexArray(this.mChunks[i].mIndices, renderer.BUFTYPE.STATIC);
        if (ibo == null)
            return false;

        this.mChunks[i].mVBO = vbo;
        this.mChunks[i].mIBO = ibo;
    }
    return true;
}

piMesh.prototype.GPURender = function (renderer, positions )//, matPrj, matCam )
{
    //renderer.SetShaderConstantMat4F("unMPrj", matPrj, false );

    var num = this.mChunks.length;
    for( var i=0; i<num; i++ )
    {
        //var mat =  matMul( matCam, this.mChunks[i].mTransform );
        //renderer.SetShaderConstantMat4F("unMMod", mat, false);

        renderer.AttachVertexArray(this.mChunks[i].mVBO, this.mVertexFormat, positions );
        renderer.AttachIndexArray(this.mChunks[i].mIBO );
        renderer.DrawPrimitive(renderer.PRIMTYPE.TRIANGLES, this.mChunks[i].mNumFaces * 3, true, 1);
        renderer.DetachIndexArray(this.mChunks[i].mIBO);
        renderer.DetachVertexArray(this.mChunks[i].mVBO, this.mVertexFormat );
    }
}
//==============================================================================
//
// piLibs 2014-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piRenderer
//
//==============================================================================

function piRenderer()
{
    // private members

    var mGL = null;
    var mBindedShader = null;
    var mIs20 = false;
    var mFloat32Textures;
    var mFloat32Filter;
    var mFloat16Textures;
    var mDrawBuffers;
    var mDepthTextures;
    var mDerivatives;
    var mFloat16Filter;
    var mShaderTextureLOD;
    var mAnisotropic;
    var mRenderToFloat32F;
    var mDebugShader;
    var mAsynchCompile;

    var mVBO_Quad = null;
    var mVBO_Tri = null;
    var mVBO_CubePosNor = null;
    var mVBO_CubePos = null;
    var mShaderHeader = ["",""];
    var mShaderHeaderLines = [0,0];

    // public members
    var me = {};

    me.CLEAR      = { Color: 1, Zbuffer : 2, Stencil : 4 };
    me.TEXFMT     = { C4I8 : 0, C1I8 : 1, C1F16 : 2, C4F16 : 3, C1F32 : 4, C4F32 : 5, Z16 : 6, Z24 : 7, Z32 : 8, C3F32:9 };
    me.TEXWRP     = { CLAMP : 0, REPEAT : 1 };
    me.BUFTYPE    = { STATIC : 0, DYNAMIC : 1 };
    me.PRIMTYPE   = { POINTS : 0, LINES : 1, LINE_LOOP : 2, LINE_STRIP : 3, TRIANGLES : 4, TRIANGLE_STRIP : 5 };
    me.RENDSTGATE = { WIREFRAME : 0, FRONT_FACE : 1, CULL_FACE : 2, DEPTH_TEST : 3, ALPHA_TO_COVERAGE : 4 };
    me.TEXTYPE    = { T2D : 0, T3D : 1, CUBEMAP : 2 };
    me.FILTER     = { NONE : 0, LINEAR : 1, MIPMAP : 2, NONE_MIPMAP : 3 };
    me.TYPE       = { UINT8 : 0, UINT16 : 1, UINT32 : 2, FLOAT16: 3, FLOAT32 : 4, FLOAT64: 5 };

    // private functions

    var iFormatPI2GL = function( format )
    {
        if( mIs20 )
        {
             if (format === me.TEXFMT.C4I8)  return { mGLFormat: mGL.RGBA8,           mGLExternal: mGL.RGBA,             mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1I8)  return { mGLFormat: mGL.R8,              mGLExternal: mGL.RED,              mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1F16) return { mGLFormat: mGL.R16F,            mGLExternal: mGL.RED,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F16) return { mGLFormat: mGL.RGBA16F,         mGLExternal: mGL.RGBA,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C1F32) return { mGLFormat: mGL.R32F,            mGLExternal: mGL.RED,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F32) return { mGLFormat: mGL.RGBA32F,         mGLExternal: mGL.RGBA,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C3F32) return { mGLFormat: mGL.RGB32F,          mGLExternal: mGL.RGB,              mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.Z16)   return { mGLFormat: mGL.DEPTH_COMPONENT16, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        else if (format === me.TEXFMT.Z24)   return { mGLFormat: mGL.DEPTH_COMPONENT24, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        else if (format === me.TEXFMT.Z32)   return { mGLFormat: mGL.DEPTH_COMPONENT32F, mGLExternal: mGL.DEPTH_COMPONENT,  mGLType: mGL.UNSIGNED_SHORT }
        }
        else
        {
             if (format === me.TEXFMT.C4I8)  return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1I8)  return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.LUMINANCE,       mGLType: mGL.UNSIGNED_BYTE }
        else if (format === me.TEXFMT.C1F16) return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.LUMINANCE,       mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F16) return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C1F32) return { mGLFormat: mGL.LUMINANCE,       mGLExternal: mGL.RED,             mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.C4F32) return { mGLFormat: mGL.RGBA,            mGLExternal: mGL.RGBA,            mGLType: mGL.FLOAT }
        else if (format === me.TEXFMT.Z16)   return { mGLFormat: mGL.DEPTH_COMPONENT, mGLExternal: mGL.DEPTH_COMPONENT, mGLType: mGL.UNSIGNED_SHORT }
        }

        return null;
     }

    // public functions

    me.Initialize = function( gl )
                    {
                        mGL = gl;

                        mIs20 = !(gl instanceof WebGLRenderingContext);

                        if( mIs20 )
                        {
                            mFloat32Textures  = true;
                            mFloat32Filter    = mGL.getExtension( 'OES_texture_float_linear');
                            mFloat16Textures  = true;
                            mFloat16Filter    = mGL.getExtension( 'OES_texture_half_float_linear' );
                            mDerivatives      = true;
                            mDrawBuffers      = true;
                            mDepthTextures    = true;
                            mShaderTextureLOD = true;
                            mAnisotropic = mGL.getExtension( 'EXT_texture_filter_anisotropic' );
                            mRenderToFloat32F = mGL.getExtension( 'EXT_color_buffer_float');
                            mDebugShader = mGL.getExtension('WEBGL_debug_shaders');
                            mAsynchCompile = mGL.getExtension('KHR_parallel_shader_compile');

							mGL.hint( mGL.FRAGMENT_SHADER_DERIVATIVE_HINT, mGL.NICEST);
                        }
                        else
                        {
                            mFloat32Textures  = mGL.getExtension( 'OES_texture_float' );
                            mFloat32Filter    = mGL.getExtension( 'OES_texture_float_linear');
                            mFloat16Textures  = mGL.getExtension( 'OES_texture_half_float' );
                            mFloat16Filter    = mGL.getExtension( 'OES_texture_half_float_linear' );
                            mDerivatives      = mGL.getExtension( 'OES_standard_derivatives' );
                            mDrawBuffers      = mGL.getExtension( 'WEBGL_draw_buffers' );
                            mDepthTextures    = mGL.getExtension( 'WEBGL_depth_texture' );
                            mShaderTextureLOD = mGL.getExtension( 'EXT_shader_texture_lod' );
                            mAnisotropic      = mGL.getExtension( 'EXT_texture_filter_anisotropic' );
                            mRenderToFloat32F = mFloat32Textures;
                            mDebugShader      = null;
                            mAsynchCompile    = null;
							
							if( mDerivatives !== null) mGL.hint( mDerivatives.FRAGMENT_SHADER_DERIVATIVE_HINT_OES, mGL.NICEST);
                        }
                        
                        
                        var maxTexSize = mGL.getParameter( mGL.MAX_TEXTURE_SIZE );
                        var maxCubeSize = mGL.getParameter( mGL.MAX_CUBE_MAP_TEXTURE_SIZE );
                        var maxRenderbufferSize = mGL.getParameter( mGL.MAX_RENDERBUFFER_SIZE );
                        var extensions = mGL.getSupportedExtensions();
                        var textureUnits = mGL.getParameter( mGL.MAX_TEXTURE_IMAGE_UNITS );
                        console.log("WebGL (2.0=" + mIs20 + "):" +
                                    " Asynch Compile: "  + ((mAsynchCompile !==null) ? "yes" : "no") +
                                    ", Textures: F32 ["   + ((mFloat32Textures !==null) ? "yes" : "no") +
                                    "], F16 ["   + ((mFloat16Textures !==null) ? "yes" : "no") +
                                    "], Depth [" + ((mDepthTextures   !==null) ? "yes" : "no") +
                                    "], LOD ["    + ((mShaderTextureLOD!==null) ? "yes" : "no") +
                                    "], Aniso ["   + ((mAnisotropic     !==null) ? "yes" : "no") +
                                    "], Units [" + textureUnits +
                                    "], Max Size [" + maxTexSize +
                                    "], Cube Max Size [" + maxCubeSize +
                                    "], Targets: MRT ["            + ((mDrawBuffers     !==null) ? "yes" : "no") +
                                    "], F32 ["     + ((mRenderToFloat32F!==null) ? "yes" : "no") +
                                    "], Max Size [" + maxRenderbufferSize + "]");

                        // create a 2D quad Vertex Buffer
                        var vertices = new Float32Array( [ -1.0, -1.0,   1.0, -1.0,    -1.0,  1.0,     1.0, -1.0,    1.0,  1.0,    -1.0,  1.0] );
                        mVBO_Quad = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Quad );
                        mGL.bufferData( mGL.ARRAY_BUFFER, vertices, mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 2D triangle Vertex Buffer
                        mVBO_Tri = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Tri );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0,   3.0, -1.0,    -1.0,  3.0] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 3D cube Vertex Buffer
                        mVBO_CubePosNor = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePosNor );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0, -1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0, -1.0,  1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0,  1.0, -1.0,  -1.0,  0.0,  0.0,
                                                                              -1.0,  1.0,  1.0,  -1.0,  0.0,  0.0,
                                                                               1.0,  1.0, -1.0,   1.0,  0.0,  0.0,
                                                                               1.0,  1.0,  1.0,   1.0,  0.0,  0.0,
                                                                               1.0, -1.0, -1.0,   1.0,  0.0,  0.0,
                                                                               1.0, -1.0,  1.0,   1.0,  0.0,  0.0,
                                                                               1.0,  1.0,  1.0,   0.0,  1.0,  0.0,
                                                                               1.0,  1.0, -1.0,   0.0,  1.0,  0.0,
                                                                              -1.0,  1.0,  1.0,   0.0,  1.0,  0.0,
                                                                              -1.0,  1.0, -1.0,   0.0,  1.0,  0.0,
                                                                               1.0, -1.0, -1.0,   0.0, -1.0,  0.0,
                                                                               1.0, -1.0,  1.0,   0.0, -1.0,  0.0,
                                                                              -1.0, -1.0, -1.0,   0.0, -1.0,  0.0,
                                                                              -1.0, -1.0,  1.0,   0.0, -1.0,  0.0,
                                                                              -1.0,  1.0,  1.0,   0.0,  0.0,  1.0,
                                                                              -1.0, -1.0,  1.0,   0.0,  0.0,  1.0,
                                                                               1.0,  1.0,  1.0,   0.0,  0.0,  1.0,
                                                                               1.0, -1.0,  1.0,   0.0,  0.0,  1.0,
                                                                              -1.0, -1.0, -1.0,   0.0,  0.0, -1.0,
                                                                              -1.0,  1.0, -1.0,   0.0,  0.0, -1.0,
                                                                               1.0, -1.0, -1.0,   0.0,  0.0, -1.0,
                                                                               1.0,  1.0, -1.0,   0.0,  0.0, -1.0 ] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        // create a 3D cube Vertex Buffer
                        mVBO_CubePos = mGL.createBuffer();
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePos );
                        mGL.bufferData( mGL.ARRAY_BUFFER, new Float32Array( [ -1.0, -1.0, -1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                               1.0,  1.0, -1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0, -1.0,  1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0,  1.0, -1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0, -1.0,  1.0,
                                                                              -1.0, -1.0, -1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                              -1.0,  1.0,  1.0,
                                                                              -1.0, -1.0,  1.0,
                                                                               1.0,  1.0,  1.0,
                                                                               1.0, -1.0,  1.0,
                                                                              -1.0, -1.0, -1.0,
                                                                              -1.0,  1.0, -1.0,
                                                                               1.0, -1.0, -1.0,
                                                                               1.0,  1.0, -1.0 ] ), mGL.STATIC_DRAW );
                        mGL.bindBuffer( mGL.ARRAY_BUFFER, null );

                        //-------------------------------------------------------------------

                        mShaderHeader[0] = "";
                        mShaderHeaderLines[0] = 0;
                        if( mIs20 ) 
                        { 
                            mShaderHeader[0] += "#version 300 es\n" +
                                                "#ifdef GL_ES\n"+
                                                "precision highp float;\n" +
                                                "precision highp int;\n"+
                                                "precision mediump sampler3D;\n"+
                                                "#endif\n"; 
                            mShaderHeaderLines[0] += 6;
                        }
                        else
                        {
                            mShaderHeader[0] += "#ifdef GL_ES\n"+
                                                "precision highp float;\n" +
                                                "precision highp int;\n"+
                                                "#endif\n"+
                                                "float round( float x ) { return floor(x+0.5); }\n"+
                                                "vec2 round(vec2 x) { return floor(x + 0.5); }\n"+
                                                "vec3 round(vec3 x) { return floor(x + 0.5); }\n"+
                                                "vec4 round(vec4 x) { return floor(x + 0.5); }\n"+
                                                "float trunc( float x, float n ) { return floor(x*n)/n; }\n"+
                                                "mat3 transpose(mat3 m) { return mat3(m[0].x, m[1].x, m[2].x, m[0].y, m[1].y, m[2].y, m[0].z, m[1].z, m[2].z); }\n"+
                                                "float determinant( in mat2 m ) { return m[0][0]*m[1][1] - m[0][1]*m[1][0]; }\n"+
                                                "float determinant( mat4 m ) { float b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0], b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0], b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0], b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1], b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1], b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2], b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0], b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0], b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0], b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1], b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1], b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;}\n"+
                                                "mat2 inverse(mat2 m) { float det = determinant(m); return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / det; }\n"+
                                                "mat4 inverse(mat4 m ) { float inv0 = m[1].y*m[2].z*m[3].w - m[1].y*m[2].w*m[3].z - m[2].y*m[1].z*m[3].w + m[2].y*m[1].w*m[3].z + m[3].y*m[1].z*m[2].w - m[3].y*m[1].w*m[2].z; float inv4 = -m[1].x*m[2].z*m[3].w + m[1].x*m[2].w*m[3].z + m[2].x*m[1].z*m[3].w - m[2].x*m[1].w*m[3].z - m[3].x*m[1].z*m[2].w + m[3].x*m[1].w*m[2].z; float inv8 = m[1].x*m[2].y*m[3].w - m[1].x*m[2].w*m[3].y - m[2].x  * m[1].y * m[3].w + m[2].x  * m[1].w * m[3].y + m[3].x * m[1].y * m[2].w - m[3].x * m[1].w * m[2].y; float inv12 = -m[1].x  * m[2].y * m[3].z + m[1].x  * m[2].z * m[3].y +m[2].x  * m[1].y * m[3].z - m[2].x  * m[1].z * m[3].y - m[3].x * m[1].y * m[2].z + m[3].x * m[1].z * m[2].y; float inv1 = -m[0].y*m[2].z * m[3].w + m[0].y*m[2].w * m[3].z + m[2].y  * m[0].z * m[3].w - m[2].y  * m[0].w * m[3].z - m[3].y * m[0].z * m[2].w + m[3].y * m[0].w * m[2].z; float inv5 = m[0].x  * m[2].z * m[3].w - m[0].x  * m[2].w * m[3].z - m[2].x  * m[0].z * m[3].w + m[2].x  * m[0].w * m[3].z + m[3].x * m[0].z * m[2].w - m[3].x * m[0].w * m[2].z; float inv9 = -m[0].x  * m[2].y * m[3].w +  m[0].x  * m[2].w * m[3].y + m[2].x  * m[0].y * m[3].w - m[2].x  * m[0].w * m[3].y - m[3].x * m[0].y * m[2].w + m[3].x * m[0].w * m[2].y; float inv13 = m[0].x  * m[2].y * m[3].z - m[0].x  * m[2].z * m[3].y - m[2].x  * m[0].y * m[3].z + m[2].x  * m[0].z * m[3].y + m[3].x * m[0].y * m[2].z - m[3].x * m[0].z * m[2].y; float inv2 = m[0].y  * m[1].z * m[3].w - m[0].y  * m[1].w * m[3].z - m[1].y  * m[0].z * m[3].w + m[1].y  * m[0].w * m[3].z + m[3].y * m[0].z * m[1].w - m[3].y * m[0].w * m[1].z; float inv6 = -m[0].x  * m[1].z * m[3].w + m[0].x  * m[1].w * m[3].z + m[1].x  * m[0].z * m[3].w - m[1].x  * m[0].w * m[3].z - m[3].x * m[0].z * m[1].w + m[3].x * m[0].w * m[1].z; float inv10 = m[0].x  * m[1].y * m[3].w - m[0].x  * m[1].w * m[3].y - m[1].x  * m[0].y * m[3].w + m[1].x  * m[0].w * m[3].y + m[3].x * m[0].y * m[1].w - m[3].x * m[0].w * m[1].y; float inv14 = -m[0].x  * m[1].y * m[3].z + m[0].x  * m[1].z * m[3].y + m[1].x  * m[0].y * m[3].z - m[1].x  * m[0].z * m[3].y - m[3].x * m[0].y * m[1].z + m[3].x * m[0].z * m[1].y; float inv3 = -m[0].y * m[1].z * m[2].w + m[0].y * m[1].w * m[2].z + m[1].y * m[0].z * m[2].w - m[1].y * m[0].w * m[2].z - m[2].y * m[0].z * m[1].w + m[2].y * m[0].w * m[1].z; float inv7 = m[0].x * m[1].z * m[2].w - m[0].x * m[1].w * m[2].z - m[1].x * m[0].z * m[2].w + m[1].x * m[0].w * m[2].z + m[2].x * m[0].z * m[1].w - m[2].x * m[0].w * m[1].z; float inv11 = -m[0].x * m[1].y * m[2].w + m[0].x * m[1].w * m[2].y + m[1].x * m[0].y * m[2].w - m[1].x * m[0].w * m[2].y - m[2].x * m[0].y * m[1].w + m[2].x * m[0].w * m[1].y; float inv15 = m[0].x * m[1].y * m[2].z - m[0].x * m[1].z * m[2].y - m[1].x * m[0].y * m[2].z + m[1].x * m[0].z * m[2].y + m[2].x * m[0].y * m[1].z - m[2].x * m[0].z * m[1].y; float det = m[0].x * inv0 + m[0].y * inv4 + m[0].z * inv8 + m[0].w * inv12; det = 1.0 / det; return det*mat4( inv0, inv1, inv2, inv3,inv4, inv5, inv6, inv7,inv8, inv9, inv10, inv11,inv12, inv13, inv14, inv15);}\n"+                                                
                                                "float sinh(float x)  { return (exp(x)-exp(-x))/2.; }\n"+
                                                "float cosh(float x)  { return (exp(x)+exp(-x))/2.; }\n"+
                                                "float tanh(float x)  { return sinh(x)/cosh(x); }\n"+
                                                "float coth(float x)  { return cosh(x)/sinh(x); }\n"+
                                                "float sech(float x)  { return 1./cosh(x); }\n"+
                                                "float csch(float x)  { return 1./sinh(x); }\n"+
                                                "float asinh(float x) { return    log(x+sqrt(x*x+1.)); }\n"+
                                                "float acosh(float x) { return    log(x+sqrt(x*x-1.)); }\n"+
                                                "float atanh(float x) { return .5*log((1.+x)/(1.-x)); }\n"+
                                                "float acoth(float x) { return .5*log((x+1.)/(x-1.)); }\n"+
                                                "float asech(float x) { return    log((1.+sqrt(1.-x*x))/x); }\n"+
                                                "float acsch(float x) { return    log((1.+sqrt(1.+x*x))/x); }\n";
                            mShaderHeaderLines[0] += 26;
                        }

                        //-------------------------------------------------------

                        mShaderHeader[1] = "";
                        mShaderHeaderLines[1] = 0;
                        if( mIs20 ) 
                        { 
                            mShaderHeader[1] += "#version 300 es\n"+
                                                "#ifdef GL_ES\n"+
                                                "precision highp float;\n"+
                                                "precision highp int;\n"+
                                                "precision mediump sampler3D;\n"+
                                                "#endif\n"; 
                            mShaderHeaderLines[1] += 6;
                        }
                        else
                        {
                            if( mDerivatives ) { mShaderHeader[1] += "#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n"; mShaderHeaderLines[1]+=3; }
                            if( mShaderTextureLOD  ) { mShaderHeader[1] += "#extension GL_EXT_shader_texture_lod : enable\n"; mShaderHeaderLines[1]++; }
                            mShaderHeader[1] += "#ifdef GL_ES\n"+
                                                "precision highp float;\n"+
                                                "precision highp int;\n"+
                                                "#endif\n"+ 
                                                "vec4 texture(     sampler2D   s, vec2 c)                   { return texture2D(s,c); }\n"+
                                                "vec4 texture(     sampler2D   s, vec2 c, float b)          { return texture2D(s,c,b); }\n"+
                                                "vec4 texture(     samplerCube s, vec3 c )                  { return textureCube(s,c); }\n"+
                                                "vec4 texture(     samplerCube s, vec3 c, float b)          { return textureCube(s,c,b); }\n"+
                                                "float round( float x ) { return floor(x+0.5); }\n"+
                                                "vec2 round(vec2 x) { return floor(x + 0.5); }\n"+
                                                "vec3 round(vec3 x) { return floor(x + 0.5); }\n"+
                                                "vec4 round(vec4 x) { return floor(x + 0.5); }\n"+
                                                "float trunc( float x, float n ) { return floor(x*n)/n; }\n"+
                                                "mat3 transpose(mat3 m) { return mat3(m[0].x, m[1].x, m[2].x, m[0].y, m[1].y, m[2].y, m[0].z, m[1].z, m[2].z); }\n"+
                                                "float determinant( in mat2 m ) { return m[0][0]*m[1][1] - m[0][1]*m[1][0]; }\n"+
                                                "float determinant( mat4 m ) { float b00 = m[0][0] * m[1][1] - m[0][1] * m[1][0], b01 = m[0][0] * m[1][2] - m[0][2] * m[1][0], b02 = m[0][0] * m[1][3] - m[0][3] * m[1][0], b03 = m[0][1] * m[1][2] - m[0][2] * m[1][1], b04 = m[0][1] * m[1][3] - m[0][3] * m[1][1], b05 = m[0][2] * m[1][3] - m[0][3] * m[1][2], b06 = m[2][0] * m[3][1] - m[2][1] * m[3][0], b07 = m[2][0] * m[3][2] - m[2][2] * m[3][0], b08 = m[2][0] * m[3][3] - m[2][3] * m[3][0], b09 = m[2][1] * m[3][2] - m[2][2] * m[3][1], b10 = m[2][1] * m[3][3] - m[2][3] * m[3][1], b11 = m[2][2] * m[3][3] - m[2][3] * m[3][2];  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;}\n"+
                                                "mat2 inverse(mat2 m) { float det = determinant(m); return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / det; }\n"+
                                                "mat4 inverse(mat4 m ) { float inv0 = m[1].y*m[2].z*m[3].w - m[1].y*m[2].w*m[3].z - m[2].y*m[1].z*m[3].w + m[2].y*m[1].w*m[3].z + m[3].y*m[1].z*m[2].w - m[3].y*m[1].w*m[2].z; float inv4 = -m[1].x*m[2].z*m[3].w + m[1].x*m[2].w*m[3].z + m[2].x*m[1].z*m[3].w - m[2].x*m[1].w*m[3].z - m[3].x*m[1].z*m[2].w + m[3].x*m[1].w*m[2].z; float inv8 = m[1].x*m[2].y*m[3].w - m[1].x*m[2].w*m[3].y - m[2].x  * m[1].y * m[3].w + m[2].x  * m[1].w * m[3].y + m[3].x * m[1].y * m[2].w - m[3].x * m[1].w * m[2].y; float inv12 = -m[1].x  * m[2].y * m[3].z + m[1].x  * m[2].z * m[3].y +m[2].x  * m[1].y * m[3].z - m[2].x  * m[1].z * m[3].y - m[3].x * m[1].y * m[2].z + m[3].x * m[1].z * m[2].y; float inv1 = -m[0].y*m[2].z * m[3].w + m[0].y*m[2].w * m[3].z + m[2].y  * m[0].z * m[3].w - m[2].y  * m[0].w * m[3].z - m[3].y * m[0].z * m[2].w + m[3].y * m[0].w * m[2].z; float inv5 = m[0].x  * m[2].z * m[3].w - m[0].x  * m[2].w * m[3].z - m[2].x  * m[0].z * m[3].w + m[2].x  * m[0].w * m[3].z + m[3].x * m[0].z * m[2].w - m[3].x * m[0].w * m[2].z; float inv9 = -m[0].x  * m[2].y * m[3].w +  m[0].x  * m[2].w * m[3].y + m[2].x  * m[0].y * m[3].w - m[2].x  * m[0].w * m[3].y - m[3].x * m[0].y * m[2].w + m[3].x * m[0].w * m[2].y; float inv13 = m[0].x  * m[2].y * m[3].z - m[0].x  * m[2].z * m[3].y - m[2].x  * m[0].y * m[3].z + m[2].x  * m[0].z * m[3].y + m[3].x * m[0].y * m[2].z - m[3].x * m[0].z * m[2].y; float inv2 = m[0].y  * m[1].z * m[3].w - m[0].y  * m[1].w * m[3].z - m[1].y  * m[0].z * m[3].w + m[1].y  * m[0].w * m[3].z + m[3].y * m[0].z * m[1].w - m[3].y * m[0].w * m[1].z; float inv6 = -m[0].x  * m[1].z * m[3].w + m[0].x  * m[1].w * m[3].z + m[1].x  * m[0].z * m[3].w - m[1].x  * m[0].w * m[3].z - m[3].x * m[0].z * m[1].w + m[3].x * m[0].w * m[1].z; float inv10 = m[0].x  * m[1].y * m[3].w - m[0].x  * m[1].w * m[3].y - m[1].x  * m[0].y * m[3].w + m[1].x  * m[0].w * m[3].y + m[3].x * m[0].y * m[1].w - m[3].x * m[0].w * m[1].y; float inv14 = -m[0].x  * m[1].y * m[3].z + m[0].x  * m[1].z * m[3].y + m[1].x  * m[0].y * m[3].z - m[1].x  * m[0].z * m[3].y - m[3].x * m[0].y * m[1].z + m[3].x * m[0].z * m[1].y; float inv3 = -m[0].y * m[1].z * m[2].w + m[0].y * m[1].w * m[2].z + m[1].y * m[0].z * m[2].w - m[1].y * m[0].w * m[2].z - m[2].y * m[0].z * m[1].w + m[2].y * m[0].w * m[1].z; float inv7 = m[0].x * m[1].z * m[2].w - m[0].x * m[1].w * m[2].z - m[1].x * m[0].z * m[2].w + m[1].x * m[0].w * m[2].z + m[2].x * m[0].z * m[1].w - m[2].x * m[0].w * m[1].z; float inv11 = -m[0].x * m[1].y * m[2].w + m[0].x * m[1].w * m[2].y + m[1].x * m[0].y * m[2].w - m[1].x * m[0].w * m[2].y - m[2].x * m[0].y * m[1].w + m[2].x * m[0].w * m[1].y; float inv15 = m[0].x * m[1].y * m[2].z - m[0].x * m[1].z * m[2].y - m[1].x * m[0].y * m[2].z + m[1].x * m[0].z * m[2].y + m[2].x * m[0].y * m[1].z - m[2].x * m[0].z * m[1].y; float det = m[0].x * inv0 + m[0].y * inv4 + m[0].z * inv8 + m[0].w * inv12; det = 1.0 / det; return det*mat4( inv0, inv1, inv2, inv3,inv4, inv5, inv6, inv7,inv8, inv9, inv10, inv11,inv12, inv13, inv14, inv15);}\n"+
                                                "float sinh(float x)  { return (exp(x)-exp(-x))/2.; }\n"+
                                                "float cosh(float x)  { return (exp(x)+exp(-x))/2.; }\n"+
                                                "float tanh(float x)  { return sinh(x)/cosh(x); }\n"+
                                                "float coth(float x)  { return cosh(x)/sinh(x); }\n"+
                                                "float sech(float x)  { return 1./cosh(x); }\n"+
                                                "float csch(float x)  { return 1./sinh(x); }\n"+
                                                "float asinh(float x) { return    log(x+sqrt(x*x+1.)); }\n"+
                                                "float acosh(float x) { return    log(x+sqrt(x*x-1.)); }\n"+
                                                "float atanh(float x) { return .5*log((1.+x)/(1.-x)); }\n"+
                                                "float acoth(float x) { return .5*log((x+1.)/(x-1.)); }\n"+
                                                "float asech(float x) { return    log((1.+sqrt(1.-x*x))/x); }\n"+
                                                "float acsch(float x) { return    log((1.+sqrt(1.+x*x))/x); }\n";
                            mShaderHeaderLines[1] += 30;
                            if( mShaderTextureLOD )
                            {
                            mShaderHeader[1] += "vec4 textureLod(  sampler2D   s, vec2 c, float b)          { return texture2DLodEXT(s,c,b); }\n";
                            mShaderHeader[1] += "vec4 textureGrad( sampler2D   s, vec2 c, vec2 dx, vec2 dy) { return texture2DGradEXT(s,c,dx,dy); }\n";
                            mShaderHeaderLines[1] += 2;

                            //mShaderHeader[1] += "vec4 texelFetch( sampler2D s, ivec2 c, int l) { return texture2DLodEXT(s,(vec2(c)+0.5)/vec2(800,450),float(l)); }\n";
                            //mShaderHeaderLines[1] += 1;
                            }
                        }

                        return true;
                    };

        me.GetCaps =    function ()
                        {   
                            return { mIsGL20 : mIs20,
                                     mFloat32Textures: mFloat32Textures != null,
                                     mFloat16Textures: mFloat16Textures != null,
                                     mDrawBuffers: mDrawBuffers != null,
                                     mDepthTextures: mDepthTextures != null,
                                     mDerivatives: mDerivatives != null,
                                     mShaderTextureLOD: mShaderTextureLOD != null };
                        };

        me.GetShaderHeaderLines = function (shaderType)
                        {   
                            return mShaderHeaderLines[shaderType];
                        };

        me.CheckErrors = function()
                         {
                                var error = mGL.getError();
                                if( error != mGL.NO_ERROR ) 
                                { 
                                    for( var prop in mGL ) 
                                    {
                                        if( typeof mGL[prop] == 'number' ) 
                                        {
                                            if( mGL[prop] == error )
                                            {
                                                console.log( "GL Error " + error + ": " + prop );
                                                break;
                                            }
                                        }
                                    }
                                }
                         };

        me.Clear =  function( flags, ccolor, cdepth, cstencil )
                    {
                        var mode = 0;
                        if( flags & 1 ) { mode |= mGL.COLOR_BUFFER_BIT;   mGL.clearColor( ccolor[0], ccolor[1], ccolor[2], ccolor[3] ); }
                        if( flags & 2 ) { mode |= mGL.DEPTH_BUFFER_BIT;   mGL.clearDepth( cdepth ); }
                        if( flags & 4 ) { mode |= mGL.STENCIL_BUFFER_BIT; mGL.clearStencil( cstencil ); }
                        mGL.clear( mode );
                    };


        me.CreateTexture = function ( type, xres, yres, format, filter, wrap, buffer)
                           {
                                if( mGL===null ) return null;

                                var id = mGL.createTexture();

                                var glFoTy = iFormatPI2GL( format );
                                var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                if( type===me.TEXTYPE.T2D )
                                {
                                    mGL.bindTexture( mGL.TEXTURE_2D, id );
//if( buffer==null )
    //mGL.texStorage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, xres, yres);
//else
                                    mGL.texImage2D( mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texParameteri( mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap );
                                    mGL.texParameteri( mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap );

                                    if (filter === me.FILTER.NONE)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }

                                    mGL.bindTexture( mGL.TEXTURE_2D, null );
                                }
                                else if( type===me.TEXTYPE.T3D )
                                {
                                    if( mIs20 )
                                    {
                                        mGL.bindTexture( mGL.TEXTURE_3D, id );
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_BASE_LEVEL, 0);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAX_LEVEL, Math.log2(xres));
                                        if (filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                        }
                                        else if (filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        }
                                        else
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_3D);
                                        }
                                        mGL.texImage3D( mGL.TEXTURE_3D, 0, glFoTy.mGLFormat, xres, yres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );

                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_R, glWrap );
                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_S, glWrap );
                                        mGL.texParameteri( mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_T, glWrap );

                                        if (filter === me.FILTER.MIPMAP)
                                            mGL.generateMipmap( mGL.TEXTURE_3D );
                                        mGL.bindTexture( mGL.TEXTURE_3D, null );
                                    }
                                    else 
                                    {
                                        return null;
                                    }
                                }
                                else 
                                {
                                    mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );

                                    // this works great if we know the number of required mipmaps in advance (1, or other)
                                   //mGL.texStorage2D( mGL.TEXTURE_CUBE_MAP, 1, glFoTy.mGLFormat, xres, yres );

                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.texImage2D( mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, xres, yres, 0, glFoTy.mGLExternal, glFoTy.mGLType, buffer );

                                    if( filter === me.FILTER.NONE)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR)
                                    {
                                        mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR );
                                        mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR );
                                    }
                                    else if (filter === me.FILTER.MIPMAP)
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                    }

                                    if (filter === me.FILTER.MIPMAP)
                                        mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );

                                    mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                }
                        return { mObjectID: id, mXres: xres, mYres: yres, mFormat: format, mType: type, mFilter: filter, mWrap: wrap, mVFlip:false };
                        };

        me.CreateTextureFromImage = function ( type, image, format, filter, wrap, flipY) 
                                {
                                    if( mGL===null ) return null;

                                    var id = mGL.createTexture();

                                    var glFoTy = iFormatPI2GL( format );

                                    var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                    if( type===me.TEXTYPE.T2D )
                                    {
                                        mGL.bindTexture(mGL.TEXTURE_2D, id);

                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, flipY);
                                        mGL.pixelStorei(mGL.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                                        if( mIs20 ) mGL.pixelStorei(mGL.UNPACK_COLORSPACE_CONVERSION_WEBGL, mGL.NONE );

                                        mGL.texImage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image);

                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap);

                                        if (filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                        }
                                        else if( filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_2D);
                                        }
                                        else
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                            mGL.generateMipmap(mGL.TEXTURE_2D);
                                        }
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                        mGL.bindTexture(mGL.TEXTURE_2D, null);
                                    }
                                    else if( type===me.TEXTYPE.T3D )
                                    {
                                        return null;
                                    }
                                    else 
                                    {
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, flipY);
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[0] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[1] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (flipY ? image[3] : image[2]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (flipY ? image[2] : image[3]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[4] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[5] );

                                        if( filter === me.FILTER.NONE)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                        }
                                        else if (filter === me.FILTER.LINEAR)
                                        {
                                            mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR );
                                            mGL.texParameteri( mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR );
                                        }
                                        else if (filter === me.FILTER.MIPMAP)
                                        {
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                            mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                            mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );
                                        }
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                    }
                                    return { mObjectID: id, mXres: image.width, mYres: image.height, mFormat: format, mType: type, mFilter: filter, mWrap:wrap, mVFlip:flipY };
                                };

        me.SetSamplerFilter = function (te, filter, doGenerateMipsIfNeeded) 
                            {
                                if (te.mFilter === filter) return;

                                if (te.mType === me.TEXTYPE.T2D) 
                                {
                                    mGL.bindTexture(mGL.TEXTURE_2D, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_2D);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_2D, null);

                                }
                                else if (te.mType === me.TEXTYPE.T3D) 
                                {
                                    mGL.bindTexture(mGL.TEXTURE_3D, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_3D);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_3D);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_3D, null);

                                }
                                else
                                {
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, te.mObjectID);

                                    if (filter === me.FILTER.NONE) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST);
                                    }
                                    else if (filter === me.FILTER.LINEAR) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR);
                                    }
                                    else if (filter === me.FILTER.MIPMAP) 
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.LINEAR);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.LINEAR_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_CUBE_MAP);
                                    }
                                    else
                                    {
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MAG_FILTER, mGL.NEAREST);
                                        mGL.texParameteri(mGL.TEXTURE_CUBE_MAP, mGL.TEXTURE_MIN_FILTER, mGL.NEAREST_MIPMAP_LINEAR);
                                        if( doGenerateMipsIfNeeded ) mGL.generateMipmap(mGL.TEXTURE_CUBE_MAP);
                                    }

                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                                }


                                te.mFilter = filter;
                            };

        me.SetSamplerWrap = function (te, wrap)
                            {
                                if (te.mWrap === wrap) return;

                                var glWrap = mGL.REPEAT; if (wrap === me.TEXWRP.CLAMP) glWrap = mGL.CLAMP_TO_EDGE;

                                var id = te.mObjectID;

                                if (te.mType === me.TEXTYPE.T2D)
                                {
                                    mGL.bindTexture(mGL.TEXTURE_2D, id);
                                    mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_S, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_2D, mGL.TEXTURE_WRAP_T, glWrap);
                                    mGL.bindTexture(mGL.TEXTURE_2D, null);

                                }
                                else if (te.mType === me.TEXTYPE.T3D)
                                {
                                    mGL.bindTexture(mGL.TEXTURE_3D, id);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_R, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_S, glWrap);
                                    mGL.texParameteri(mGL.TEXTURE_3D, mGL.TEXTURE_WRAP_T, glWrap);
                                    mGL.bindTexture(mGL.TEXTURE_3D, null);
                                }

                                te.mWrap = wrap;
                            };

        me.SetSamplerVFlip = function (te, vflip, image)
                            {
                                if (te.mVFlip === vflip) return;

                                var id = te.mObjectID;

                                if (te.mType === me.TEXTYPE.T2D)
                                {
                                    if( image != null)
                                    {
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture(mGL.TEXTURE_2D, id);
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, vflip);
                                        var glFoTy = iFormatPI2GL( te.mFormat );
                                        mGL.texImage2D(mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image);
                                        mGL.bindTexture(mGL.TEXTURE_2D, null);
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
                                }
                                else if (te.mType === me.TEXTYPE.CUBEMAP)
                                {
                                    if( image != null)
                                    {
                                        var glFoTy = iFormatPI2GL( te.mFormat );
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, id );
                                        mGL.pixelStorei( mGL.UNPACK_FLIP_Y_WEBGL, vflip);
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[0] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[1] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (vflip ? image[3] : image[2]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, (vflip ? image[2] : image[3]) );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[4] );
                                        mGL.texImage2D(  mGL.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image[5] );
                                        mGL.bindTexture( mGL.TEXTURE_CUBE_MAP, null );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
        
                                }

                                te.mVFlip = vflip;
                            };

        me.CreateMipmaps =  function (te)
                            {
                                if( te.mType===me.TEXTYPE.T2D )
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                    mGL.bindTexture(mGL.TEXTURE_2D, te.mObjectID);
                                    mGL.generateMipmap(mGL.TEXTURE_2D);
                                    mGL.bindTexture(mGL.TEXTURE_2D, null);
                                }
                                else if( te.mType===me.TEXTYPE.CUBEMAP )
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, te.mObjectID);
                                    mGL.generateMipmap( mGL.TEXTURE_CUBE_MAP );
                                    mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                                }
                            };

        me.UpdateTexture =  function( tex, x0, y0, xres, yres, buffer )
                            {
                                var glFoTy = iFormatPI2GL( tex.mFormat );
                                if( tex.mType===me.TEXTYPE.T2D )
                                {
                                    mGL.activeTexture( mGL.TEXTURE0);
                                    mGL.bindTexture( mGL.TEXTURE_2D, tex.mObjectID );
                                    mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, tex.mVFlip );
                                    mGL.texSubImage2D( mGL.TEXTURE_2D, 0, x0, y0, xres, yres, glFoTy.mGLExternal, glFoTy.mGLType, buffer );
                                    mGL.bindTexture( mGL.TEXTURE_2D, null );
                                    mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                }
                            };

        me.UpdateTextureFromImage = function( tex, image )
                                {
                                    var glFoTy = iFormatPI2GL( tex.mFormat );
                                    if( tex.mType===me.TEXTYPE.T2D )
                                    {
                                        mGL.activeTexture( mGL.TEXTURE0 );
                                        mGL.bindTexture( mGL.TEXTURE_2D, tex.mObjectID );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, tex.mVFlip );
                                        mGL.texImage2D(  mGL.TEXTURE_2D, 0, glFoTy.mGLFormat, glFoTy.mGLExternal, glFoTy.mGLType, image );
                                        mGL.bindTexture( mGL.TEXTURE_2D, null );
                                        mGL.pixelStorei(mGL.UNPACK_FLIP_Y_WEBGL, false);
                                    }
                                };

        me.DestroyTexture = function( te )
                            {
                                 mGL.deleteTexture( te.mObjectID );
                            };

        me.AttachTextures = function (num, t0, t1, t2, t3) 
                            {
                                if (num > 0 && t0 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE0);
                                         if (t0.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t0.mObjectID);
                                    else if (t0.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t0.mObjectID);
                                    else if (t0.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t0.mObjectID);
                                }

                                if (num > 1 && t1 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE1);
                                         if (t1.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t1.mObjectID);
                                    else if (t1.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t1.mObjectID);
                                    else if (t1.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t1.mObjectID);
                                }

                                if (num > 2 && t2 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE2);
                                         if (t2.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t2.mObjectID);
                                    else if (t2.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t2.mObjectID);
                                    else if (t2.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t2.mObjectID);
                                }

                                if (num > 3 && t3 != null) 
                                {
                                    mGL.activeTexture(mGL.TEXTURE3);
                                         if (t3.mType === me.TEXTYPE.T2D) mGL.bindTexture(mGL.TEXTURE_2D, t3.mObjectID);
                                    else if (t3.mType === me.TEXTYPE.T3D) mGL.bindTexture(mGL.TEXTURE_3D, t3.mObjectID);
                                    else if (t3.mType === me.TEXTYPE.CUBEMAP) mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, t3.mObjectID);
                                }
                            };

        me.DettachTextures = function()
                             {
                                mGL.activeTexture(mGL.TEXTURE0);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE1);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE2);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);

                                mGL.activeTexture(mGL.TEXTURE3);
                                mGL.bindTexture(mGL.TEXTURE_2D, null);
                                mGL.bindTexture(mGL.TEXTURE_CUBE_MAP, null);
                             };

        me.CreateRenderTarget = function ( color0, color1, color2, color3, depth, wantZbuffer )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if (depth === null)
                                    {
                                        if( wantZbuffer===true )
                                        {
                                            var zb = mGL.createRenderbuffer();
                                            mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);
                                            mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, color0.mXres, color0.mYres);

                                            mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                        }
                                    }
                                    else
                                    {
                                        mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.TEXTURE_2D, depth.mObjectID, 0);
                                    }

                                    if( color0 !=null ) mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_2D, color0.mObjectID, 0);

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                        return null;

                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mTex0: color0 };
                                };

        me.DestroyRenderTarget = function ( tex )
                                 {
                                     mGL.deleteFramebuffer(tex.mObjectID);
                                 };

        me.SetRenderTarget = function (tex)
                             {
                                if( tex===null )
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                else
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, tex.mObjectID);

                                //mGL.drawBuffers([mGL.COLOR_ATTACHMENT0, mGL.COLOR_ATTACHMENT1]);
                             };

        me.CreateRenderTargetNew = function ( wantColor0, wantZbuffer, xres, yres, samples )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if( wantZbuffer===true )
                                    {
                                        var zb = mGL.createRenderbuffer();
                                        mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);

                                        if( samples==1 )
                                        mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, xres, yres);
                                        else
                                        mGL.renderbufferStorageMultisample(mGL.RENDERBUFFER, samples, mGL.DEPTH_COMPONENT16, xres, yres);
                                        mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                    }

                                    if( wantColor0 )
                                    {
                                        var cb = mGL.createRenderbuffer();
                                        mGL.bindRenderbuffer(mGL.RENDERBUFFER, cb);
                                        if( samples==1 )
                                        mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.RGBA8, xres, yres);
                                        else
                                        mGL.renderbufferStorageMultisample(mGL.RENDERBUFFER, samples, mGL.RGBA8, xres, yres);
                                        mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.RENDERBUFFER, cb);
                                    }

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                    {
                                        return null;
                                    }
                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mXres: xres, mYres:yres, mTex0: color0 };
                                };

        me.CreateRenderTargetCubeMap = function ( color0, depth, wantZbuffer )
                                {
                                    var id =  mGL.createFramebuffer();
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, id);

                                    if (depth === null)
                                    {
                                        if( wantZbuffer===true )
                                        {
                                            var zb = mGL.createRenderbuffer();
                                            mGL.bindRenderbuffer(mGL.RENDERBUFFER, zb);
                                            mGL.renderbufferStorage(mGL.RENDERBUFFER, mGL.DEPTH_COMPONENT16, color0.mXres, color0.mYres);
                                            mGL.framebufferRenderbuffer(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.RENDERBUFFER, zb);
                                        }
                                    }
                                    else
                                    {
                                        mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.DEPTH_ATTACHMENT, mGL.TEXTURE_2D, depth.mObjectID, 0);
                                    }

                                    if( color0 !=null ) mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_CUBE_MAP_POSITIVE_X, color0.mObjectID, 0);

                                    if (mGL.checkFramebufferStatus(mGL.FRAMEBUFFER) != mGL.FRAMEBUFFER_COMPLETE)
                                        return null;

                                    mGL.bindRenderbuffer(mGL.RENDERBUFFER, null);
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                    return { mObjectID: id, mTex0: color0 };
                                };

        me.SetRenderTargetCubeMap = function (fbo, face)
                             {
                                if( fbo===null )
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                                else
                                {
                                    mGL.bindFramebuffer(mGL.FRAMEBUFFER, fbo.mObjectID);
                                    mGL.framebufferTexture2D(mGL.FRAMEBUFFER, mGL.COLOR_ATTACHMENT0, mGL.TEXTURE_CUBE_MAP_POSITIVE_X+face, fbo.mTex0.mObjectID, 0);
                                }
                             };


        me.BlitRenderTarget = function( dst, src )
                                {
                                    mGL.bindFramebuffer(mGL.READ_FRAMEBUFFER, src.mObjectID);
                                    mGL.bindFramebuffer(mGL.DRAW_FRAMEBUFFER, dst.mObjectID);
                                    mGL.clearBufferfv(mGL.COLOR, 0, [0.0, 0.0, 0.0, 1.0]);
                                    mGL.blitFramebuffer( 0, 0, src.mXres, src.mYres,
                                                         0, 0, src.mXres, src.mYres,
                                                         mGL.COLOR_BUFFER_BIT, mGL.LINEAR
                                    );
                                };

        me.SetViewport = function( vp )
                         {
                              mGL.viewport( vp[0], vp[1], vp[2], vp[3] );
                         };

        me.SetWriteMask = function( c0, c1, c2, c3, z )
                          {
                              mGL.depthMask(z);
                              mGL.colorMask(c0,c0,c0,c0);
                          };

        me.SetState = function( stateName, stateValue )
                      {
                            if (stateName === me.RENDSTGATE.WIREFRAME)
                            {
                                if( stateValue ) mGL.polygonMode( mGL.FRONT_AND_BACK, mGL.LINE );
                                else             mGL.polygonMode( mGL.FRONT_AND_BACK, mGL.FILL );
                            }
                            else if (stateName === me.RENDSTGATE.FRONT_FACE)
                            {
                                if( stateValue ) mGL.cullFace( mGL.BACK );
                                else             mGL.cullFace( mGL.FRONT );
                            }
                            else if (stateName === me.RENDSTGATE.CULL_FACE)
                            {
                                if( stateValue ) mGL.enable( mGL.CULL_FACE );
                                else             mGL.disable( mGL.CULL_FACE );
                            }
                            else if (stateName === me.RENDSTGATE.DEPTH_TEST)
                            {
                                if( stateValue ) mGL.enable( mGL.DEPTH_TEST );
                                else             mGL.disable( mGL.DEPTH_TEST );
                            }
                            else if (stateName === me.RENDSTGATE.ALPHA_TO_COVERAGE)
                            {
                                if( stateValue ) { mGL.enable(  mGL.SAMPLE_ALPHA_TO_COVERAGE ); }
                                else             { mGL.disable( mGL.SAMPLE_ALPHA_TO_COVERAGE ); }
                            }
                      };

        me.SetMultisample = function( v)
                    {
                        if( v===true )
                        {
                            mGL.enable(mGL.SAMPLE_COVERAGE);
                            mGL.sampleCoverage(1.0, false);
                        }
                        else
                        {
                            mGL.disable(mGL.SAMPLE_COVERAGE);
                        }
                    };

        me.GetTranslatedShaderSource = function (shader) 
                          {
                            if( mGL===null ) return null;
                            if( mDebugShader===null ) return null;
                            let vfs = mGL.getAttachedShaders(shader.mProgram);
                            let str = mDebugShader.getTranslatedShaderSource(vfs[1]);
                            let parts = str.split("GLSL END"); str = (parts.length<2) ? str : parts[1];
                            return str;
                          };

        me.CreateShader = function (vsSource, fsSource, preventCache, forceSynch, onResolve) 
                          {
                            if( mGL===null ) return;

                            var vs = mGL.createShader( mGL.VERTEX_SHADER   );
                            var fs = mGL.createShader( mGL.FRAGMENT_SHADER );

                            vsSource = mShaderHeader[0] + vsSource;
                            fsSource = mShaderHeader[1] + fsSource;

                            if( preventCache )
                            {
                                let vran = Math.random().toString(36).substring(7);
                                let fran = Math.random().toString(36).substring(7);
                                vsSource += "\n#define K" + vran + "\n";
                                fsSource += "\n#define K" + fran + "\n";
                            }

                            var timeStart = getRealTime();

                            mGL.shaderSource(vs, vsSource);
                            mGL.shaderSource(fs, fsSource);
                            mGL.compileShader(vs);
                            mGL.compileShader(fs);

                            var pr = mGL.createProgram();
                            mGL.attachShader(pr, vs);
                            mGL.attachShader(pr, fs);
                            mGL.linkProgram(pr);

                            //-------------
                            let checkErrors = function()
                            {
                                if (!mGL.getProgramParameter(pr, mGL.LINK_STATUS))
                                {
                                    // vs error
                                    if (!mGL.getShaderParameter(vs, mGL.COMPILE_STATUS))
                                    {
                                        let vsLog = mGL.getShaderInfoLog(vs);
                                        onResolve(false, { mErrorType: 0, mErrorStr: vsLog });
                                        mGL.deleteProgram(pr);
                                    }
                                    // fs error
                                    else if (!mGL.getShaderParameter(fs, mGL.COMPILE_STATUS))
                                    {
                                        let fsLog = mGL.getShaderInfoLog(fs);
                                        onResolve(false, { mErrorType: 1, mErrorStr: fsLog });
                                        mGL.deleteProgram(pr);
                                    }
                                    // link error
                                    else
                                    {
                                        let infoLog = mGL.getProgramInfoLog(pr);
                                        onResolve(false, { mErrorType: 2, mErrorStr: infoLog });
                                        mGL.deleteProgram(pr);
                                    }
                                }
                                // no errors
                                else
                                {
                                    let compilationTime = getRealTime() - timeStart;
                                    onResolve(true, { mProgram: pr, mTime: compilationTime });
                                }
                            };

                            // check compilation
                            if (mAsynchCompile === null || forceSynch===true )
                            {
                                checkErrors();
                            }
                            else
                            {
                                let loopCheckCompletion = function ()
                                {
                                    if( mGL.getProgramParameter(pr, mAsynchCompile.COMPLETION_STATUS_KHR) === true )
                                        checkErrors();
                                    else
                                        setTimeout(loopCheckCompletion, 10);
                                };
                                setTimeout(loopCheckCompletion, 10);
                            }
                        };

        me.AttachShader = function( shader )
                          {
                                if( shader===null )
                                {
                                    mBindedShader = null;
                                    mGL.useProgram( null );
                                }
                                else
                                {
                                    mBindedShader = shader;
                                    mGL.useProgram(shader.mProgram);
                                }
                          };

        me.DetachShader = function ()
                        {
                            mGL.useProgram(null);
                        };

        me.DestroyShader = function( tex )
                        {
                            mGL.deleteProgram(tex.mProgram);
                        };

        me.GetAttribLocation = function (shader, name)
                        {
                            return mGL.getAttribLocation(shader.mProgram, name);
                        };

        me.SetShaderConstantLocation = function (shader, name)
                        {
                            return mGL.getUniformLocation(shader.mProgram, name);
                        };

        me.SetShaderConstantMat4F = function( uname, params, istranspose )
                        {
                            var program = mBindedShader;

                            let pos = mGL.getUniformLocation( program.mProgram, uname );
                            if( pos===null )
                                return false;

                            if( istranspose===false )
                            {
                                var tmp = new Float32Array( [ params[0], params[4], params[ 8], params[12],
                                                              params[1], params[5], params[ 9], params[13],
                                                              params[2], params[6], params[10], params[14],
                                                              params[3], params[7], params[11], params[15] ] );
	                            mGL.uniformMatrix4fv(pos,false,tmp);
                            }
                            else
                                mGL.uniformMatrix4fv(pos,false,new Float32Array(params) );
                            return true;
                        };

        me.SetShaderConstant1F_Pos = function(pos, x)
                        {
                            mGL.uniform1f(pos, x);
                            return true;
                        };

        me.SetShaderConstant1FV_Pos = function(pos, x)
                        {
                            mGL.uniform1fv(pos, x);
                            return true;
                        };

        me.SetShaderConstant1F = function( uname, x )
                        {
                            var pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1f(pos, x);
                            return true;
                        };

        me.SetShaderConstant1I = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1i(pos, x);
                            return true;
                        };
        me.SetShaderConstant1I_Pos = function(pos, x)
                        {
                            mGL.uniform1i(pos, x);
                            return true;
                        };


        me.SetShaderConstant2F = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform2fv(pos, x);
                            return true;
                        };

        me.SetShaderConstant3F = function(uname, x, y, z)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform3f(pos, x, y, z);
                            return true;
                        };

        me.SetShaderConstant1FV = function(uname, x)
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null)
                                return false;
                            mGL.uniform1fv(pos, new Float32Array(x));
                            return true;
                        };

        me.SetShaderConstant3FV = function(uname, x) 
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform3fv(pos, new Float32Array(x) );
                            return true;
                        };

        me.SetShaderConstant4FV = function(uname, x) 
                        {
                            let pos = mGL.getUniformLocation(mBindedShader.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform4fv(pos, new Float32Array(x) );
                            return true;
                        };

        me.SetShaderTextureUnit = function( uname, unit )
                        {
                            var program = mBindedShader;
                            let pos = mGL.getUniformLocation(program.mProgram, uname);
                            if (pos === null) return false;
                            mGL.uniform1i(pos, unit);
                            return true;
                        };

        me.CreateVertexArray = function( data, mode )
                        {
                            let id = mGL.createBuffer();
                            mGL.bindBuffer(mGL.ARRAY_BUFFER, id);
                            if (mode === me.BUFTYPE.STATIC)
                                mGL.bufferData(mGL.ARRAY_BUFFER, data, mGL.STATIC_DRAW);
                            else
                                mGL.bufferData(mGL.ARRAY_BUFFER, data, mGL.DYNAMIC_DRAW);
                            return { mObject: id };
                        };

        me.CreateIndexArray = function( data, mode )
                        {
                            let id = mGL.createBuffer();
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, id );
                            if (mode === me.BUFTYPE.STATIC)
                                mGL.bufferData(mGL.ELEMENT_ARRAY_BUFFER, data, mGL.STATIC_DRAW);
                            else
                                mGL.bufferData(mGL.ELEMENT_ARRAY_BUFFER, data, mGL.DYNAMIC_DRAW);
                            return { mObject: id };
                        };

        me.DestroyArray = function( tex )
                        {
                            mGL.destroyBuffer(tex.mObject);
                        };

        me.AttachVertexArray = function( tex, attribs, pos )
                        {
                            let shader = mBindedShader;

                            mGL.bindBuffer( mGL.ARRAY_BUFFER, tex.mObject);

                            var num = attribs.mChannels.length;
                            var stride = attribs.mStride;

                            var offset = 0;
                            for (var i = 0; i < num; i++)
                            {
                                var id = pos[i];
                                mGL.enableVertexAttribArray(id);
                                var dtype = mGL.FLOAT;
                                var dsize = 4;
                                     if( attribs.mChannels[i].mType === me.TYPE.UINT8   ) { dtype = mGL.UNSIGNED_BYTE;  dsize = 1; }
                                else if( attribs.mChannels[i].mType === me.TYPE.UINT16  ) { dtype = mGL.UNSIGNED_SHORT; dsize = 2; }
                                else if( attribs.mChannels[i].mType === me.TYPE.FLOAT32 ) { dtype = mGL.FLOAT;          dsize = 4; }
                                mGL.vertexAttribPointer(id, attribs.mChannels[i].mNumComponents, dtype, attribs.mChannels[i].mNormalize, stride, offset);
                                offset += attribs.mChannels[i].mNumComponents * dsize;
                            }
                        };

        me.AttachIndexArray = function( tex )
                        {
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, tex.mObject);
                        };

        me.DetachVertexArray = function (tex, attribs)
                        {
                            let num = attribs.mChannels.length;
                            for (let i = 0; i < num; i++)
                                mGL.disableVertexAttribArray(i);
                            mGL.bindBuffer(mGL.ARRAY_BUFFER, null);
                        };

        me.DetachIndexArray = function( tex )
                        {
                            mGL.bindBuffer(mGL.ELEMENT_ARRAY_BUFFER, null);
                        };

        me.DrawPrimitive = function( typeOfPrimitive, num, useIndexArray, numInstances )
                        {
                            let glType = mGL.POINTS;
                            if( typeOfPrimitive===me.PRIMTYPE.POINTS ) glType = mGL.POINTS;
                            if( typeOfPrimitive===me.PRIMTYPE.LINES ) glType = mGL.LINES;
                            if( typeOfPrimitive===me.PRIMTYPE.LINE_LOOP ) glType = mGL.LINE_LOOP;
                            if( typeOfPrimitive===me.PRIMTYPE.LINE_STRIP ) glType = mGL.LINE_STRIP;
                            if( typeOfPrimitive===me.PRIMTYPE.TRIANGLES ) glType = mGL.TRIANGLES;
                            if( typeOfPrimitive===me.PRIMTYPE.TRIANGLE_STRIP ) glType = mGL.TRIANGLE_STRIP;

                            if( numInstances<=1 )
                            {
  	                            if( useIndexArray ) mGL.drawElements( glType, num, mGL.UNSIGNED_SHORT, 0 );
	                            else                mGL.drawArrays( glType, 0, num );
                            }
                            else
                            {
                                mGL.drawArraysInstanced(glType, 0, num, numInstances);
                                mGL.drawElementsInstanced( glType, num, mGL.UNSIGNED_SHORT, 0, numInstances);
                            }
                        };


        me.DrawFullScreenTriangle_XY = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Tri );
                            mGL.vertexAttribPointer( vpos, 2, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays( mGL.TRIANGLES, 0, 3 );
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        };


        me.DrawUnitQuad_XY = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_Quad );
                            mGL.vertexAttribPointer( vpos, 2, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays( mGL.TRIANGLES, 0, 6 );
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        };

        me.DrawUnitCube_XYZ_NOR = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePosNor );
                            mGL.vertexAttribPointer( vpos[0], 3, mGL.FLOAT, false, 0, 0 );
                            mGL.vertexAttribPointer( vpos[1], 3, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos[0] );
                            mGL.enableVertexAttribArray( vpos[1] );
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 0, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 4, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 8, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 12, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 16, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 20, 4);
                            mGL.disableVertexAttribArray( vpos[0] );
                            mGL.disableVertexAttribArray( vpos[1] );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        }

        me.DrawUnitCube_XYZ = function( vpos )
                        {
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, mVBO_CubePos );
                            mGL.vertexAttribPointer( vpos, 3, mGL.FLOAT, false, 0, 0 );
                            mGL.enableVertexAttribArray( vpos );
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 0, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 4, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 8, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 12, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 16, 4);
                            mGL.drawArrays(mGL.TRIANGLE_STRIP, 20, 4);
                            mGL.disableVertexAttribArray( vpos );
                            mGL.bindBuffer( mGL.ARRAY_BUFFER, null );
                        }

        me.SetBlend = function( enabled )
                    {
                        if( enabled )
                        {
                            mGL.enable( mGL.BLEND );
                            mGL.blendEquationSeparate( mGL.FUNC_ADD, mGL.FUNC_ADD );
                            mGL.blendFuncSeparate( mGL.SRC_ALPHA, mGL.ONE_MINUS_SRC_ALPHA, mGL.ONE, mGL.ONE_MINUS_SRC_ALPHA );
                        }
                        else
                        {
                            mGL.disable( mGL.BLEND );
                        }
                    };

        me.GetPixelData = function( data, offset, xres, yres )
                        {
                            mGL.readPixels(0, 0, xres, yres, mGL.RGBA, mGL.UNSIGNED_BYTE, data, offset);
                        };

        me.GetPixelDataRenderTarget = function( obj, data, xres, yres )
                        {
                            mGL.bindFramebuffer(mGL.FRAMEBUFFER, obj.mObjectID);
                            mGL.readBuffer(mGL.COLOR_ATTACHMENT0);
                            mGL.readPixels(0, 0, xres, yres, mGL.RGBA, mGL.FLOAT, data, 0);
                            mGL.bindFramebuffer(mGL.FRAMEBUFFER, null);
                        };
    return me;
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piShading
//
//==============================================================================

function smoothstep(a, b, x)
{
    x = (x - a) / (b - a);
    if (x < 0) x = 0; else if (x > 1) x = 1;
    return x * x * (3.0 - 2.0 * x);
}

function clamp01(x)
{
    if( x < 0.0 ) x = 0.0;
    if( x > 1.0 ) x = 1.0;
    return x;
}

function clamp(x, a, b)
{
    if( x < a ) x = a;
    if( x > b ) x = b;
    return x;
}

function screen(a, b)
{
    return 1.0 - (1.0 - a) * (1.0 - b);
}

function parabola(x)
{
    return 4.0 * x * (1.0 - x);
}

function min(a, b)
{
    return (a < b) ? a : b;
}

function max(a, b)
{
    return (a > b) ? a : b;
}

function noise( x )
{
    function grad(i, j, x, y)
    {
        var h = 7 * i + 131 * j;
        h = (h << 13) ^ h;
        h = (h * (h * h * 15731 + 789221) + 1376312589);

        var rx = (h & 0x20000000) ? x : -x;
        var ry = (h & 0x10000000) ? y : -y;

        return rx + ry;
    }

    var i = [ Math.floor(x[0]), Math.floor(x[1]) ];
    var f = [ x[0] - i[0], x[1] - i[1] ];
    var w = [ f[0]*f[0]*(3.0-2.0*f[0]), f[1]*f[1]*(3.0-2.0*f[1]) ];

    var a = grad( i[0]+0, i[1]+0, f[0]+0.0, f[1]+0.0 );
    var b = grad( i[0]+1, i[1]+0, f[0]-1.0, f[1]+0.0 );
    var c = grad( i[0]+0, i[1]+1, f[0]+0.0, f[1]-1.0 );
    var d = grad( i[0]+1, i[1]+1, f[0]-1.0, f[1]-1.0 );

    return a + (b-a)*w[0] + (c-a)*w[1] + (a-b-c+d)*w[0]*w[1];
}//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piVecTypes
//
//==============================================================================


function vec3( a, b, c )
{
    return [ a, b, c ];
}

function add( a, b )
{
    return [ a[0]+b[0], a[1]+b[1], a[2]+b[2] ];
}

function sub( a, b )
{
    return [ a[0]-b[0], a[1]-b[1], a[2]-b[2] ];
}

function mul( a, s ) 
{
    return [ a[0]*s, a[1]*s, a[2]*s ];
}

function cross( a, b )
{
    return [ a[1]*b[2] - a[2]*b[1],
             a[2]*b[0] - a[0]*b[2],
             a[0]*b[1] - a[1]*b[0] ];
}

function dot( a, b ) 
{
    return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
}

function normalize( v ) 
{
    var is = 1.0 / Math.sqrt( v[0]*v[0] + v[1]*v[1] + v[2]*v[2] );
    return [ v[0]*is, v[1]*is, v[2]*is ];
}

function createCirclePoint( cen, uuu, vvv, rad, s, t )
{
    return [ cen[0] + rad*(uuu[0]*s + vvv[0]*t),
             cen[1] + rad*(uuu[1]*s + vvv[1]*t),
             cen[2] + rad*(uuu[2]*s + vvv[2]*t) ];
}

function createTangent( a, b, c )
{
    var cb = normalize( [ c[0]-b[0], c[1]-b[1], c[2]-b[2] ] );
    var ba = normalize( [ b[0]-a[0], b[1]-a[1], b[2]-a[2] ] );
    return normalize( [ ba[0]+cb[0], ba[1]+cb[1], ba[2]+cb[2] ] );

}

//===================================

function vec4( a, b, c, d )
{
    return [ a, b, c, d ];
}

function getXYZ( v )
{
    return [ v[0], v[1], v[2] ];
}

//===================================

function setIdentity()
{
    return [ 1.0, 0.0, 0.0, 0.0,
             0.0, 1.0, 0.0, 0.0,
             0.0, 0.0, 1.0, 0.0,
             0.0, 0.0, 0.0, 1.0 ];
}

function setRotationX( t )
{
    var sint = Math.sin(t);
    var cost = Math.cos(t);

    return [ 1.0,   0.0,   0.0, 0.0,
             0.0,  cost, -sint, 0.0, 
             0.0,  sint,  cost, 0.0,
             0.0,   0.0,   0.0, 1.0 ];
}

function setRotationY( t )
{
    var sint = Math.sin(t);
    var cost = Math.cos(t);

    return [ cost, 0.0, -sint, 0.0,
              0.0, 1.0,   0.0, 0.0, 
             sint, 0.0,  cost, 0.0,
              0.0, 0.0,   0.0, 1.0 ];
}

function extractRotationEuler( m)
{
    var res = [];
    if (m[0] == 1.0)
    {
        res[0] = Math.atan2(m[2], m[11]);
        res[1] = 0.0;
        res[2] = 0.0;

    }
    else if (m[0] == -1.0)
    {
        res[0] = Math.atan2( m[2], m[11]);
        res[1] = 0.0;
        res[2] = 0.0;
    }
    else
    {
        res[0] = Math.atan2( -m[9], m[10]);
        res[1] = Math.atan2( m[8], Math.sqrt(m[9]*m[9] + m[10]*m[10]));
        res[2] = Math.atan2( m[4], m[0]);
    }
    return res;
}

function setFromQuaternion( q )
{
    var ww = q[3]*q[3];
    var xx = q[0]*q[0];
    var yy = q[1]*q[1];
    var zz = q[2]*q[2];

    return [ ww+xx-yy-zz,                   2.0*(q[0]*q[1] - q[3]*q[2]), 2.0*(q[0]*q[2] + q[3]*q[1]), 0.0,
               2.0*(q[0]*q[1] + q[3]*q[2]),   ww-xx+yy-zz,                 2.0*(q[1]*q[2] - q[3]*q[0]), 0.0,
               2.0*(q[0]*q[2] - q[3]*q[1]),   2.0*(q[1]*q[2] + q[3]*q[0]), ww-xx-yy+zz,                 0.0,
               0.0,                           0.0,                         0.0,                         1.0 ];
}

function setPerspective( fovy, aspect, znear, zfar )
{
    var tan = Math.tan(fovy * Math.PI/180.0);
    var x = 1.0 / (tan*aspect);
    var y = 1.0 / (tan);
    var c = -(zfar + znear) / ( zfar - znear);
    var d = -(2.0 * zfar * znear) / (zfar - znear);

    return [ x,    0.0,  0.0,  0.0,
             0.0,  y,    0.0,  0.0,
             0.0,  0.0,  c,     d,
             0.0,  0.0, -1.0,  0.0 ];
}

function setLookAt( eye, tar, up )
{
    var dir = [ -tar[0]+eye[0], -tar[1]+eye[1], -tar[2]+eye[2] ];

	var m00 = dir[2]*up[1] - dir[1]*up[2]; 
    var m01 = dir[0]*up[2] - dir[2]*up[0];
    var m02 = dir[1]*up[0] - dir[0]*up[1];
    var im = 1.0/Math.sqrt( m00*m00 + m01*m01 + m02*m02 );
    m00 *= im;
    m01 *= im;
    m02 *= im;

	var m04 = m02*dir[1] - m01*dir[2]; 
    var m05 = m00*dir[2] - m02*dir[0];
    var m06 = m01*dir[0] - m00*dir[1];
    im = 1.0/Math.sqrt( m04*m04 + m05*m05 + m06*m06 );
    m04 *= im;
    m05 *= im;
    m06 *= im;

	var m08 = dir[0];
	var m09 = dir[1];
	var m10 = dir[2];
    im = 1.0/Math.sqrt( m08*m08 + m09*m09 + m10*m10 );
    m08 *= im;
    m09 *= im;
    m10 *= im;

	var m03 = -(m00*eye[0] + m01*eye[1] + m02*eye[2] );
	var m07 = -(m04*eye[0] + m05*eye[1] + m06*eye[2] );
	var m11 = -(m08*eye[0] + m09*eye[1] + m10*eye[2] );

    return [ m00, m01, m02, m03,
             m04, m05, m06, m07,
             m08, m09, m10, m11,
             0.0, 0.0, 0.0, 1.0 ];
}


function setOrtho( left, right, bottom, top, znear, zfar )
{
   var x = 2.0 / (right - left);
   var y = 2.0 / (top - bottom);
   var a = (right + left) / (right - left);
   var b = (top + bottom) / (top - bottom);
   var c = -2.0 / (zfar - znear);
   var d = -(zfar + znear) / ( zfar - znear);

   return [  x, 0.0, 0.0,   a,
           0.0,   y, 0.0,   b,
           0.0, 0.0,   c,   d,
           0.0, 0.0, 0.0, 1.0 ];
}

function setTranslation( p )
{
    return [ 1.0, 0.0, 0.0, p[0],
             0.0, 1.0, 0.0, p[1],
             0.0, 0.0, 1.0, p[2],
             0.0, 0.0, 0.0, 1.0 ];
}

function setScale( s )
{
    return [ s[0], 0.0,  0.0,  0.0,
             0.0,  s[1], 0.0,  0.0,
             0.0,  0.0,  s[2], 0.0,
             0.0,  0.0,  0.0,  1.0];
}

function setProjection( fov, znear, zfar )
{
    var x = 2.0 / (fov[3]+fov[2]);
    var y = 2.0 / (fov[0]+fov[1]);
    var a = (fov[3]-fov[2]) / (fov[3]+fov[2]);
    var b = (fov[0]-fov[1]) / (fov[0]+fov[1]);
    var c = -(zfar + znear) / ( zfar - znear);
    var d = -(2.0*zfar*znear) / (zfar - znear);
    return [   x, 0.0,    a, 0.0,
             0.0,   y,    b, 0.0,
             0.0, 0.0,    c,   d,
             0.0, 0.0, -1.0, 0.0 ];
   // inverse is:
   //return mat4x4( 1.0/x, 0.0f,  0.0f,   a/x,
   //               0.0f,  1.0/y, 0.0f,   b/x,
   //               0.0f,  0.0f,  0.0f,   -1.0,
   //               0.0f,  0.0f,  1.0f/d, c/d );
}


function invertFast( m )
{
    var inv = [
   
             m[5]  * m[10] * m[15] - 
             m[5]  * m[11] * m[14] - 
             m[9]  * m[6]  * m[15] + 
             m[9]  * m[7]  * m[14] +
             m[13] * m[6]  * m[11] - 
             m[13] * m[7]  * m[10],

             -m[1]  * m[10] * m[15] + 
              m[1]  * m[11] * m[14] + 
              m[9]  * m[2] * m[15] - 
              m[9]  * m[3] * m[14] - 
              m[13] * m[2] * m[11] + 
              m[13] * m[3] * m[10],

             m[1]  * m[6] * m[15] - 
             m[1]  * m[7] * m[14] - 
             m[5]  * m[2] * m[15] + 
             m[5]  * m[3] * m[14] + 
             m[13] * m[2] * m[7] - 
             m[13] * m[3] * m[6],

             -m[1] * m[6] * m[11] + 
              m[1] * m[7] * m[10] + 
              m[5] * m[2] * m[11] - 
              m[5] * m[3] * m[10] - 
              m[9] * m[2] * m[7] + 
              m[9] * m[3] * m[6],

             -m[4]  * m[10] * m[15] + 
              m[4]  * m[11] * m[14] + 
              m[8]  * m[6]  * m[15] - 
              m[8]  * m[7]  * m[14] - 
              m[12] * m[6]  * m[11] + 
              m[12] * m[7]  * m[10],

             m[0]  * m[10] * m[15] - 
             m[0]  * m[11] * m[14] - 
             m[8]  * m[2] * m[15] + 
             m[8]  * m[3] * m[14] + 
             m[12] * m[2] * m[11] - 
             m[12] * m[3] * m[10],

             -m[0]  * m[6] * m[15] + 
              m[0]  * m[7] * m[14] + 
              m[4]  * m[2] * m[15] - 
              m[4]  * m[3] * m[14] - 
              m[12] * m[2] * m[7] + 
              m[12] * m[3] * m[6],


             m[0] * m[6] * m[11] - 
             m[0] * m[7] * m[10] - 
             m[4] * m[2] * m[11] + 
             m[4] * m[3] * m[10] + 
             m[8] * m[2] * m[7] - 
             m[8] * m[3] * m[6],


             m[4]  * m[9] * m[15] - 
             m[4]  * m[11] * m[13] - 
             m[8]  * m[5] * m[15] + 
             m[8]  * m[7] * m[13] + 
             m[12] * m[5] * m[11] - 
             m[12] * m[7] * m[9],



             -m[0]  * m[9] * m[15] + 
              m[0]  * m[11] * m[13] + 
              m[8]  * m[1] * m[15] - 
              m[8]  * m[3] * m[13] - 
              m[12] * m[1] * m[11] + 
              m[12] * m[3] * m[9],

              m[0]  * m[5] * m[15] - 
              m[0]  * m[7] * m[13] - 
              m[4]  * m[1] * m[15] + 
              m[4]  * m[3] * m[13] + 
              m[12] * m[1] * m[7] - 
              m[12] * m[3] * m[5],

              -m[0] * m[5] * m[11] + 
               m[0] * m[7] * m[9] + 
               m[4] * m[1] * m[11] - 
               m[4] * m[3] * m[9] - 
               m[8] * m[1] * m[7] + 
               m[8] * m[3] * m[5],

              -m[4]  * m[9] * m[14] + 
               m[4]  * m[10] * m[13] +
               m[8]  * m[5] * m[14] - 
               m[8]  * m[6] * m[13] - 
               m[12] * m[5] * m[10] + 
               m[12] * m[6] * m[9],

              m[0]  * m[9] * m[14] - 
              m[0]  * m[10] * m[13] - 
              m[8]  * m[1] * m[14] + 
              m[8]  * m[2] * m[13] + 
              m[12] * m[1] * m[10] - 
              m[12] * m[2] * m[9],

              -m[0]  * m[5] * m[14] + 
               m[0]  * m[6] * m[13] + 
               m[4]  * m[1] * m[14] - 
               m[4]  * m[2] * m[13] - 
               m[12] * m[1] * m[6] + 
               m[12] * m[2] * m[5],

              m[0] * m[5] * m[10] - 
              m[0] * m[6] * m[9] - 
              m[4] * m[1] * m[10] + 
              m[4] * m[2] * m[9] + 
              m[8] * m[1] * m[6] - 
              m[8] * m[2] * m[5] ];

    var det = m[0] * inv[0] + m[1] * inv[4] + m[2] * inv[8] + m[3] * inv[12];

    det = 1.0/det;

    for( var i = 0; i<16; i++ ) inv[i] = inv[i] * det;

    return inv;
}

function matMul( a, b )
{
    var res = [];
    for( var i=0; i<4; i++ )
    {
        var x = a[4*i+0];
        var y = a[4*i+1];
        var z = a[4*i+2];
        var w = a[4*i+3];

        res[4*i+0] = x * b[ 0] + y * b[ 4] + z * b[ 8] + w * b[12];
        res[4*i+1] = x * b[ 1] + y * b[ 5] + z * b[ 9] + w * b[13];
        res[4*i+2] = x * b[ 2] + y * b[ 6] + z * b[10] + w * b[14];
        res[4*i+3] = x * b[ 3] + y * b[ 7] + z * b[11] + w * b[15];
    }

    return res;
}

function matMulpoint( m, v )
{
    return [ m[0]*v[0] + m[1]*v[1] + m[ 2]*v[2] + m[ 3],
             m[4]*v[0] + m[5]*v[1] + m[ 6]*v[2] + m[ 7],
             m[8]*v[0] + m[9]*v[1] + m[10]*v[2] + m[11] ];
}

function matMulvec( m, v )
{
    return [ m[0]*v[0] + m[1]*v[1] + m[ 2]*v[2],
             m[4]*v[0] + m[5]*v[1] + m[ 6]*v[2],
             m[8]*v[0] + m[9]*v[1] + m[10]*v[2] ];
}


function bound3( infi )
{
    return [ infi, -infi, infi, -infi, infi, -infi ];
}

function bound3_include( a, p )
{
    return [
        (p[0]<a[0]) ? p[0] : a[0],
        (p[0]>a[1]) ? p[0] : a[1],
        (p[1]<a[2]) ? p[1] : a[2],
        (p[1]>a[3]) ? p[1] : a[3],
        (p[2]<a[4]) ? p[2] : a[4],
        (p[2]>a[5]) ? p[2] : a[5] ];
}

function bound3_center( b )
{
    return [ 0.5*(b[0]+b[1]),
             0.5*(b[2]+b[3]),
             0.5*(b[4]+b[5]) ];
}

function bound3_radius( b )
{
    return [ 0.5*(b[1]-b[0]),
             0.5*(b[3]-b[2]),
             0.5*(b[5]-b[4]) ];
}
//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piWebVR
//
//==============================================================================

function WebVR( isVREnabledCallback, canvasElement )
{
    isVREnabledCallback(false);
    /*


    this.mSupportVR = false;
    this.mHMD = null;

    var me = this;
    var listVRDisplays = function (vrdevs) {
        for (var i = 0; i < vrdevs.length; i++)
        {
            if (vrdevs[i] instanceof VRDisplay)
            {
                me.mHMD = vrdevs[i];
                console.log("WebVR is available.");
                console.log(me.mHMD);
                break;
            }
        }

        isVREnabledCallback(true);
        me.mSupportVR = true;
    }

    if (navigator.getVRDisplays)
    {
        navigator.getVRDisplays().then(listVRDisplays);
    }

    isVREnabledCallback(false);
    this.mCanvas = canvasElement;
    */
}

WebVR.prototype.IsSupported = function()
{
    return false;
    //return this.mSupportVR;
}

WebVR.prototype.GetData = function( id )
{
    return {};
    /*
    var frameData = new VRFrameData();
    var s = this.mHMD.getFrameData(frameData);
    var ss = frameData.pose;
    
    var fovL = this.mHMD.getEyeParameters("left");
    var fovR = this.mHMD.getEyeParameters( "right" );

    // camera info
    var cPos = vec3(0.0, 0.0, 0.0);
    if (ss.position)
        cPos = vec3(-ss.position[0], -ss.position[1], -ss.position[2]);
    var rot = vec4(0.0, 0.0, 0.0, 0.0);
    if (ss.orientation)
        rot = vec4(ss.orientation[0], ss.orientation[1], ss.orientation[2], ss.orientation[3]);
    var cRot = setFromQuaternion(rot);
    var cTra = setTranslation(cPos);
    var cMat = matMul(invertFast(cRot), cTra);
    
    // per eye info
    var lTra = setTranslation( vec3(-fovL.offset[0], -fovL.offset[1], -fovL.offset[2]) );
    var lMat = matMul(lTra, cMat);
    var lPrj = [ Math.tan( fovL.fieldOfView.upDegrees * Math.PI/180.0),
                 Math.tan(fovL.fieldOfView.downDegrees * Math.PI / 180.0),
                 Math.tan(fovL.fieldOfView.leftDegrees * Math.PI / 180.0),
                 Math.tan(fovL.fieldOfView.rightDegrees * Math.PI / 180.0)];

    var rTra = setTranslation(vec3(-fovR.offset[0], -fovR.offset[1], -fovR.offset[2]));
    var rMat = matMul(rTra, cMat);
    var rPrj = [Math.tan(fovR.fieldOfView.upDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.downDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.leftDegrees * Math.PI / 180.0),
                 Math.tan(fovR.fieldOfView.rightDegrees * Math.PI / 180.0)];

    return {
        mCamera   : { mCamera: cMat },
        mLeftEye  : { mVP:[0,0,fovL.renderWidth,fovL.renderHeight], mProjection:lPrj, mCamera:lMat },
        mRightEye : { mVP:[fovR.renderWidth/2,0,fovR.renderWidth,fovR.renderHeight], mProjection:rPrj, mCamera:rMat }
           };
    */
}

WebVR.prototype.Enable = function( id )
{
    /*
    this.mHMD.requestPresent([{ source: this.mCanvas }]).then(
        function ()
        {
        },
        function (err)
        {
            console.log("webVR : requestPresent failed.");
        }
    );
    */
}

WebVR.prototype.Disable = function( id )
{
    /*
    if (!this.mHMD.isPresenting)
    {
        return;
    }

    this.mHMD.exitPresent().then(
        function ()
        {
        },
        function (err)
        {
            console.log("webVR : exitPresent failed.");
        }
    );
    */
}

WebVR.prototype.RequestAnimationFrame = function (id)
{
    //this.mHMD.requestAnimationFrame(id);
}

WebVR.prototype.IsPresenting = function (id)
{
    /*
    if (this.mHMD.isPresenting)
    {
        return true;
    }
    */
    return false;
}

WebVR.prototype.Finish = function (id)
{
    /*
    if (this.mHMD.isPresenting)
    {
        this.mHMD.submitFrame();
    }
    */
}

//==============================================================================
//
// piLibs 2015-2017 - http://www.iquilezles.org/www/material/piLibs/piLibs.htm
//
// piWebUtils
//
//==============================================================================


// RequestAnimationFrame
window.requestAnimFrame = ( function () { return window.requestAnimationFrame    || window.webkitRequestAnimationFrame ||
                                                 window.mozRequestAnimationFrame || window.oRequestAnimationFrame ||
                                                 window.msRequestAnimationFrame  || function( cb ) { window.setTimeout(cb,1000/60); };
                                        } )();

// performance.now
window.getRealTime = ( function() { if ("performance" in window ) return function() { return window.performance.now(); }
                                                                  return function() { return (new Date()).getTime(); }
                                  } )();

window.URL = window.URL || window.webkitURL;

navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;

function htmlEntities(str) 
{
    return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g,'&apos;');
}

function piDisableTouch()
{
    document.body.addEventListener('touchstart', function(e){ e.preventDefault(); });
}

var piGetTime = function ( timestamp )
{
    if (timestamp == 0)
        return "";
    return new Date(timestamp * 1000).toISOString().substr(0, 10);
}

function piGetCoords( obj )
{
    var x = 0;
    var y = 0; 
    do
    {
         x += obj.offsetLeft;
         y += obj.offsetTop;
    }while( obj = obj.offsetParent );

    return { mX:x, mY:y };
}

function piGetMouseCoords( ev, canvasElement )
{
    var pos = piGetCoords(canvasElement );
    var mcx =                        (ev.pageX - pos.mX) * canvasElement.width / canvasElement.offsetWidth;
    var mcy = canvasElement.height - (ev.pageY - pos.mY) * canvasElement.height / canvasElement.offsetHeight;

    return { mX: mcx, mY: mcy };

}

function piGetSourceElement( e )
{
    var ele = null;
    if( e.target )     ele = e.target;
    if( e.srcElement ) ele = e.srcElement;
    return ele;
}

function piRequestFullScreen( ele )
{
    if( ele==null ) ele =   document.documentElement;
         if( ele.requestFullscreen       ) ele.requestFullscreen();
    else if( ele.msRequestFullscreen     ) ele.msRequestFullscreen();
    else if( ele.mozRequestFullScreen    ) ele.mozRequestFullScreen();
    else if( ele.webkitRequestFullscreen ) ele.webkitRequestFullscreen( Element.ALLOW_KEYBOARD_INPUT );
}

function piIsFullScreen()
{
    return document.fullscreen || document.mozFullScreen || document.webkitIsFullScreen || document.msFullscreenElement || false;
}

function piExitFullScreen()
{
       if( document.exitFullscreen       ) document.exitFullscreen();
  else if( document.msExitFullscreen     ) document.msExitFullscreen();
  else if( document.mozCancelFullScreen  ) document.mozCancelFullScreen();
  else if( document.webkitExitFullscreen ) document.webkitExitFullscreen();
}

function piIsMobile()
{
    return (navigator.userAgent.match(/Android/i) ||
            navigator.userAgent.match(/webOS/i) ||
            navigator.userAgent.match(/iPhone/i) ||
            navigator.userAgent.match(/iPad/i) ||
            navigator.userAgent.match(/iPod/i) ||
            navigator.userAgent.match(/BlackBerry/i) ||
            navigator.userAgent.match(/Windows Phone/i)) ? true : false;
}

function piCreateGlContext( cv, useAlpha, useDepth, usePreserveBuffer, useSupersampling )
{
    var opts = { alpha: useAlpha, 
                 depth: useDepth, 
                 stencil: false, 
                 premultipliedAlpha: false, 
                 antialias: useSupersampling, 
                 preserveDrawingBuffer: usePreserveBuffer, 
                 powerPreference: "high-performance" }; // "low_power", "high_performance", "default"

    var gl = null;
    if( gl === null) gl = cv.getContext( "webgl2", opts );
    if( gl === null) gl = cv.getContext( "experimental-webgl2", opts );
    if( gl === null) gl = cv.getContext( "webgl", opts );
    if( gl === null) gl = cv.getContext( "experimental-webgl", opts );

    return gl;
}

function piCreateAudioContext()
{
    var res = null;
    try
    {
        if( window.AudioContext ) res = new AudioContext();
        if( res==null && window.webkitAudioContext ) res = new webkitAudioContext();
    }
    catch( e )
    {
        res = null;
    }
    return res;
}

function piHexColorToRGB(str) // "#ff3041"
{
    var rgb = parseInt(str.slice(1), 16);
    var r = (rgb >> 16) & 255;
    var g = (rgb >> 8) & 255;
    var b = (rgb >> 0) & 255;
    return [r, g, b];
}

function piCreateFPSCounter()
{
    var mFrame;
    var mTo;
    var mFPS;

    var iReset = function( time )
    {
        mFrame = 0;
        mTo = time;
        mFPS = 60.0;
    }

    var iCount = function( time )
    {
        mFrame++;

        if( (time-mTo)>500.0 )
        {
            mFPS = 1000.0*mFrame/(time-mTo);
            mFrame = 0;
            mTo = time;
            return true;
        }
        return false;
    }

    var iGetFPS = function()
    {
        return mFPS;
    }
    
    return { Reset : iReset, Count : iCount, GetFPS : iGetFPS };
}

function piCanMediaRecorded(canvas)
{
    if (typeof window.MediaRecorder !== 'function' || typeof canvas.captureStream !== 'function') {
        return false;
    }
    return true;
}

function piCreateMediaRecorder(isRecordingCallback, canvas) 
{
    if (piCanMediaRecorded(canvas) == false)
    {
        return null;
    }
    
    var options = { audioBitsPerSecond : 0, videoBitsPerSecond : 8000000 }; 
	     if (MediaRecorder.isTypeSupported('video/webm;codecs=h264')) options.mimeType = 'video/webm;codecs=h264';
    else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9' )) options.mimeType = 'video/webm;codecs=vp9';
    else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8' )) options.mimeType = 'video/webm;codecs=vp8';
    else                                                              options.mimeType = 'video/webm;';

    var mediaRecorder = new MediaRecorder(canvas.captureStream(), options);
    var chunks = [];
    
    mediaRecorder.ondataavailable = function(e) 
    {
        if (e.data.size > 0) 
        {
            chunks.push(e.data);
        }
    };
 
    mediaRecorder.onstart = function(){ 
        isRecordingCallback( true );
    };
    
    mediaRecorder.onstop = function()
    {
         isRecordingCallback( false );
         let blob     = new Blob(chunks, {type: "video/webm"});
         chunks       = [];
         let videoURL = window.URL.createObjectURL(blob);
         let url      = window.URL.createObjectURL(blob);
         let a        = document.createElement("a");
         document.body.appendChild(a);
         a.style      = "display: none";
         a.href       = url;
         a.download   = "capture.webm";
         a.click();
         window.URL.revokeObjectURL(url);
     };
    
    return mediaRecorder;
}

function piExportToEXR(width, height, numComponents, type, bytes)
{
    var bytesPerComponent = 0;
    if      (type=="Uint")   bytesPerComponent = 4; 
    else if (type=="Half")   bytesPerComponent = 2;
    else if (type=="Float")  bytesPerComponent = 4;

    var tHeader = 258 + (18 * numComponents + 1);
    var tTable = 8 * height;
    var tScanlines = height * (4 + 4 + (numComponents * bytesPerComponent * width));
    var tTotal = tHeader + tTable + tScanlines;

    //console.log("    header size = " + tHeader);
    //console.log("    table size = " + tTable);
    //console.log("    scanlines size = " + tScanlines);
    //console.log("    total = " + tTotal);

    var buffer = new ArrayBuffer(tTotal); 
    var data = new DataView(buffer);

    // Header
    {
        // Header : 4 bytes -> 0x76, 0x2f, 0x31, 0x01
        var c = 0;
        data.setUint8 (c++, 0x76);
        data.setUint8 (c++, 0x2f);
        data.setUint8 (c++, 0x31);
        data.setUint8 (c++, 0x01);

        // Version : 4 bytes -> 2, 0, 0, 0
        data.setUint8 (c++, 0x02);
        data.setUint8 (c++, 0x0);
        data.setUint8 (c++, 0x0);
        data.setUint8 (c++, 0x0);
        
        // Write channel info
        // Write attribute name : "channels"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x73);
            data.setUint8 (c++, 0x0);

            // Write attribute type : "chlist"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00);

            // Write attribute size : 18 x 3 + 1 = 55
            var attribSize = 18 * numComponents + 1;
            data.setUint8 (c++, attribSize); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            var i;
            for (i = 0; i < numComponents; i++)
            {
                // Attribute : "B" (42) "G" (47) "R" (52)
                if (i==0)       data.setUint8 (c++, 0x42);
                else if (i==1)  data.setUint8 (c++, 0x47);
                else if (i==2)  data.setUint8 (c++, 0x52);
                data.setUint8 (c++, 0x00);
                
                // Value : Float (2), Half (1), Uint (0)
                if      (type=="Uint")   data.setUint8 (c++, 0x00); 
                else if (type=="Half")   data.setUint8 (c++, 0x01);
                else if (type=="Float")  data.setUint8 (c++, 0x02);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);

                // Plinear
                data.setUint8 (c++, 0x01);

                // Reserved
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 

                // X sampling
                data.setUint8 (c++, 0x01); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                data.setUint8 (c++, 0x00); 
                
                // Y sampling
                data.setUint8 (c++, 0x01);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
                data.setUint8 (c++, 0x00);
            }
            // End attribute
            data.setUint8 (c++, 0x00);
    
        // Write attribute name : "compression"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6d); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x00);

            // Write attribute type : "compression"
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6d); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x00);

            // Write attribute size : "1"
            data.setUint8 (c++, 0x01); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // Write attribute value : "0" (None)
            data.setUint8 (c++, 0x00);

        // datawindow
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x00); 

            // box2i
            data.setUint8 (c++, 0x62); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x00);

            // size 16
            data.setUint8 (c++, 0x10); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0 3 2
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 

            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint32 (c, width-1, true);
            c += 4;
            
            data.setUint32 (c, height-1, true); 
            c += 4;

        // displayWindow
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x79); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x00);

            // box2i
            data.setUint8 (c++, 0x62); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x00); 

            // size 16
            data.setUint8 (c++, 0x10); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0 3 2
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint32 (c, width-1, true);
            c += 4;
            
            data.setUint32 (c, height-1, true); 
            c += 4;

        // lineOrder
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x4f); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00); 
            
            // lineOrder
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x4f); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00); 
            
            // size
            data.setUint8 (c++, 0x01);
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);
            
            // value 
            data.setUint8 (c++, 0x00);

        // PixelAspectRatio
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x78); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x41); 
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x70); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x52); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x00); 

            // float
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00);
        
            // size 4
            data.setUint8 (c++, 0x04); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 1.0
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x80); 
            data.setUint8 (c++, 0x3f);
        
        // screenWindowCenter
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x63);
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x43); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e);
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x00);

            // v2f
            data.setUint8 (c++, 0x76); 
            data.setUint8 (c++, 0x32); 
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x00);

            // size 8
            data.setUint8 (c++, 0x08); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

            // value 0 0
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00);

        // screenWindowWidth
            data.setUint8 (c++, 0x73); 
            data.setUint8 (c++, 0x63); 
            data.setUint8 (c++, 0x72); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x65); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x6e); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x77); 
            data.setUint8 (c++, 0x57); 
            data.setUint8 (c++, 0x69); 
            data.setUint8 (c++, 0x64); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x68); 
            data.setUint8 (c++, 0x00); 
            
            // float
            data.setUint8 (c++, 0x66); 
            data.setUint8 (c++, 0x6c); 
            data.setUint8 (c++, 0x6f); 
            data.setUint8 (c++, 0x61); 
            data.setUint8 (c++, 0x74); 
            data.setUint8 (c++, 0x00); 

            // size
            data.setUint8 (c++, 0x04); 
            data.setUint8 (c++, 0x00);
            data.setUint8 (c++, 0x00);
            data.setUint8 (c++, 0x00);

            // value
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x00); 
            data.setUint8 (c++, 0x80); 
            data.setUint8 (c++, 0x3f);

        // End of header
        data.setUint8 (c++, 0x00);
    }
    //console.log("header size = " + c);

    // Scanline table
    var initc = c + height * 8;
    for (var scanline = 0 ; scanline < height ; scanline ++)
    {
        var jump = initc + scanline * (8 + width * bytesPerComponent * numComponents); 
        data.setUint32 (c, jump, true);
        c += 4; 

        data.setUint32 (c, 0x00, true);
        c += 4;
    }
    //console.log("header + scanlines table size = " + c);

    // Scanlines
    for (var scanline = 0 ; scanline < height ; scanline ++)
    {
        // Scanline
        data.setUint32(c, scanline, true);
        c += 4;

        // size 24
        var size = width * numComponents * bytesPerComponent; 
        data.setUint32(c, size, true);
        c += 4;

        var numComponentsSource = 4; // number of components in the SOURCE image
        for (var component = 0; component < numComponents ; component ++) 
        {
            for (var pixel = 0 ; pixel < width ; pixel ++) 
            {
                // flip vertical, so we read OpenGL buffers without JS image flipping
                var v = bytes[(height-1-scanline) * width *numComponentsSource + pixel * numComponentsSource + (2-component)];
                if      (type=="Float") data.setFloat32(c, v, true);
                else if (type=="Half")  data.setUint16(c, v, true);

                c += bytesPerComponent;
            }
        }
    }
    //console.log("total size = " + c);
    return new Blob([buffer], {type: 'application/octet-stream'});
}


function piExportToWAV(numSamples, rate, bits, numChannels, words)
{
    let numBytes = numSamples * numChannels * bits/8;

    let buffer = new ArrayBuffer(44 + numBytes); 
    let data = new DataView(buffer);

    {
        data.setUint32( 0, 0x46464952, true );  // RIFF
        data.setUint32( 4, numBytes + 36, true);
        {
            data.setUint32( 8, 0x45564157, true );  // WAV_WAVE
            data.setUint32( 12, 0x20746D66, true );  // WAV_FMT
            {
                data.setUint32( 16, 16, true);
                data.setUint16( 20, 1, true ); // WAV_FORMAT_PCM
                data.setUint16( 22, numChannels, true);
                data.setUint32( 24, rate, true);
                data.setUint32( 28, rate*numChannels*bits / 8, true);
                data.setUint16( 32, numChannels*bits / 8, true);
                data.setUint16( 34, bits, true);
            }

            data.setUint32( 36, 0x61746164, true);  // WAV_DATA
            {
                data.setUint32( 40, numBytes, true);
                let numWords = numSamples * numChannels;
                for(let i=0; i<numWords; i++ )
                {
                    data.setInt16( 44 + i*2, words[i], true );
                }
            }
        }
    }


    //console.log("total size = " + c);
    return new Blob([buffer], {type: 'application/octet-stream'});
}

function piTriggerDownload(name, blob)
{
    let url = URL.createObjectURL(blob);
    let aElement = document.createElement("a");
    aElement.href     = url;
    aElement.target   = "_self";
    aElement.download = name;
    document.body.appendChild(aElement);
    aElement.click();
    document.body.removeChild(aElement);
}</script>
    <script>"use strict"

function bufferID_to_assetID( id )
{
    if( id===0 ) return '4dXGR8';
    if( id===1 ) return 'XsXGR8';
    if( id===2 ) return '4sXGR8';
    if( id===3 ) return 'XdfGR8';
    return 'none';
}
function assetID_to_bufferID( id )
{
    if( id==='4dXGR8' ) return 0;
    if( id==='XsXGR8' ) return 1;
    if( id==='4sXGR8' ) return 2;
    if( id==='XdfGR8' ) return 3;
    return -1;
}

function assetID_to_cubemapBuferID( id )
{
    if( id==='4dX3Rr' ) return 0;
    return -1;
}
function cubamepBufferID_to_assetID( id )
{
    if( id===0 ) return '4dX3Rr';
    return 'none';
}

function EffectPass( renderer, is20, isLowEnd, hasShaderTextureLOD, callback, obj, forceMuted, forcePaused, outputGainNode, copyProgram, id, effect  )
{
    this.mID = id;
    this.mInputs  = [null, null, null, null ];
    this.mOutputs = [null, null, null, null ];
    this.mSource = null;

    this.mGainNode = outputGainNode;
    this.mSoundShaderCompiled = false;

    this.mEffect = effect;
    this.mRenderer = renderer;
    this.mProgramCopy = copyProgram; 
    this.mCompilationTime = 0;

    this.mType = "none";
    this.mName = "none";
    this.mFrame = 0;

    this.mShaderTextureLOD = hasShaderTextureLOD;
    this.mIs20 = is20;
    this.mIsLowEnd = isLowEnd;
    this.mTextureCallbackFun = callback;
    this.mTextureCallbackObj = obj;
    this.mForceMuted = forceMuted;
    this.mForcePaused = forcePaused;
}

EffectPass.prototype.MakeHeader_Image = function()
{
    let header = "";

    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for( let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        // old API
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                  header += "uniform sampler2D iChannel" + i + ";\n";

        // new API (see shadertoy.com/view/wtdGW8)
        header += "uniform struct {\n";
             if( inp===null )                  header += "  sampler2D";
        else if( inp.mInfo.mType==="cubemap" ) header += "  samplerCube";
        else if( inp.mInfo.mType==="volume"  ) header += "  sampler3D";
        else                                  header += "  sampler2D";
        header +=        " sampler;\n";
        header += "  vec3  size;\n";
        header += "  float time;\n";
        header += "  int   loaded;\n";
        header += "}iCh" + i + ";\n";
    }
	header += "void mainImage( out vec4 c, in vec2 f );\n";
    header += "void st_assert( bool cond );\n";
    header += "void st_assert( bool cond, int v );\n";

    if( this.mIs20 ) 
    {
        header += "\nout vec4 shadertoy_out_color;\n" +
        "void st_assert( bool cond, int v ) {if(!cond){if(v==0)shadertoy_out_color.x=-1.0;else if(v==1)shadertoy_out_color.y=-1.0;else if(v==2)shadertoy_out_color.z=-1.0;else shadertoy_out_color.w=-1.0;}}\n" +
        "void st_assert( bool cond        ) {if(!cond)shadertoy_out_color.x=-1.0;}\n" +
        "void main( void )" +
        "{" +
            "shadertoy_out_color = vec4(1.0,1.0,1.0,1.0);" + 
            "vec4 color = vec4(0.0,0.0,0.0,1.0);" +
            "mainImage( color, gl_FragCoord.xy );" +
            "if(shadertoy_out_color.x<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(shadertoy_out_color.y<0.0) color=vec4(0.0,1.0,0.0,1.0);" +
            "if(shadertoy_out_color.z<0.0) color=vec4(0.0,0.0,1.0,1.0);" +
            "if(shadertoy_out_color.w<0.0) color=vec4(1.0,1.0,0.0,1.0);" +
            "shadertoy_out_color = vec4(color.xyz,1.0);" +
        "}";
    }
    else
    {
        header += "" +
        "void st_assert( bool cond, int v ) {if(!cond){if(v==0)gl_FragColor.x=-1.0;else if(v==1)gl_FragColor.y=-1.0;else if(v==2)gl_FragColor.z=-1.0;else gl_FragColor.w=-1.0;}}\n" +
        "void st_assert( bool cond        ) {if(!cond)gl_FragColor.x=-1.0;}\n" +
        "void main( void )" +
        "{" +
            "gl_FragColor = vec4(0.0,0.0,0.0,1.0);" + 
            "vec4 color = vec4(0.0,0.0,0.0,1.0);" +
            "mainImage( color, gl_FragCoord.xy );" +
            "color.w = 1.0;" +
            "if(gl_FragColor.w<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(gl_FragColor.x<0.0) color=vec4(1.0,0.0,0.0,1.0);" +
            "if(gl_FragColor.y<0.0) color=vec4(0.0,1.0,0.0,1.0);" +
            "if(gl_FragColor.z<0.0) color=vec4(0.0,0.0,1.0,1.0);" +
            "if(gl_FragColor.w<0.0) color=vec4(1.0,1.0,0.0,1.0);" +
            "gl_FragColor = vec4(color.xyz,1.0);"+
        "}";
    }
    header += "\n";

    /*
    this.mImagePassFooterVR = "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 ) 
        this.mImagePassFooterVR += "\nout vec4 outColor;\n";
    this.mImagePassFooterVR += "void main( void )" +
    "{" +
        "vec4 color = vec4(0.0,0.0,0.0,1.0);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainVR( color, gl_FragCoord.xy-unViewport.xy, ro, rd );" +
        "color.w = 1.0;"
    if( this.mIs20 ) 
        this.mImagePassFooterVR +=  "outColor = color;}";
    else
        this.mImagePassFooterVR +=  "gl_FragColor = color;}";
    */
    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Buffer = function()
{
    let header = "";
    
    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                  header += "uniform sampler2D iChannel" + i + ";\n";
    }

	header += "void mainImage( out vec4 c,  in vec2 f );\n"

    if( this.mIs20 )
        header += "\nout vec4 outColor;\n";
    header += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(0.0,0.0,0.0,1.0);" +
        "mainImage( color, gl_FragCoord.xy );";
    if( this.mIs20 )
        header +="outColor = color; }";
    else
        header +="gl_FragColor = color; }";
    header += "\n";

    /*
    this.mImagePassFooterVR = "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 )
    this.mImagePassFooterVR += "\nout vec4 outColor;\n";
    this.mImagePassFooterVR += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(0.0,0.0,0.0,1.0);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainVR( color, gl_FragCoord.xy-unViewport.xy, ro, rd );";
    if( this.mIs20 )
        this.mImagePassFooterVR +="outColor = color; }";
    else
        this.mImagePassFooterVR +="gl_FragColor = color; }";
    */
    this.mHeader = header;
    this.mHeaderLength = 0;
}


EffectPass.prototype.MakeHeader_Cubemap = function()
{
    let header = "";
    
    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform vec3      iResolution;\n" +
              "uniform float     iTime;\n" +
              "uniform float     iChannelTime[4];\n" +
              "uniform vec4      iMouse;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n" +
              "uniform int       iFrame;\n" +
              "uniform float     iTimeDelta;\n" +
              "uniform float     iFrameRate;\n";

    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];
             if( inp===null )                  header += "uniform sampler2D iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="cubemap" ) header += "uniform samplerCube iChannel" + i + ";\n";
        else if( inp.mInfo.mType==="volume"  ) header += "uniform sampler3D iChannel" + i + ";\n";
        else                                   header += "uniform sampler2D iChannel" + i + ";\n";
    }

	header += "void mainCubemap( out vec4 c, in vec2 f, in vec3 ro, in vec3 rd );\n"

    header += "\n" +
    "uniform vec4 unViewport;\n" +
    "uniform vec3 unCorners[5];\n";
    if( this.mIs20 )
        header += "\nout vec4 outColor;\n";
    header += "\nvoid main( void )\n" +
    "{" +
        "vec4 color = vec4(0.0,0.0,0.0,1.0);" +

        "vec3 ro = unCorners[4];" +
        "vec2 uv = (gl_FragCoord.xy - unViewport.xy)/unViewport.zw;" + 
        "vec3 rd = normalize( mix( mix( unCorners[0], unCorners[1], uv.x )," +
                                  "mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - ro);" + 

        "mainCubemap( color, gl_FragCoord.xy-unViewport.xy, ro, rd );";
    if( this.mIs20 )
        header +="outColor = color; }";
    else
        header +="gl_FragColor = color; }";
    header += "\n";

    this.mHeader = header;
    this.mHeaderLength = 0;
}

EffectPass.prototype.MakeHeader_Sound = function()
{
    let header = "";

    header += "#define HW_PERFORMANCE " + ((this.mIsLowEnd===true)?"0":"1") + "\n";

    header += "uniform float     iChannelTime[4];\n" +
              "uniform float     iTimeOffset;\n" +
              "uniform int       iSampleOffset;\n" +
              "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n" +
              "uniform vec3      iChannelResolution[4];\n";

    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp!==null && inp.mInfo.mType==="cubemap" )
            header += "uniform samplerCube iChannel" + i + ";\n";
        else
            header += "uniform sampler2D iChannel" + i + ";\n";
    }
    header += "\n";
    header += "vec2 mainSound( in int samp, float time );\n";

    if( this.mIs20 )
    {
        header += "out vec4 outColor; void main()" +
            "{" +
            "float t = iTimeOffset + ((gl_FragCoord.x-0.5) + (gl_FragCoord.y-0.5)*512.0)/iSampleRate;" +
            "int   s = iSampleOffset + int(gl_FragCoord.y-0.2)*512 + int(gl_FragCoord.x-0.2);" +
            "vec2 y = mainSound( s, t );" +
            "vec2 v  = floor((0.5+0.5*y)*65536.0);" +
            "vec2 vl =   mod(v,256.0)/255.0;" +
            "vec2 vh = floor(v/256.0)/255.0;" +
            "outColor = vec4(vl.x,vh.x,vl.y,vh.y);" +
            "}";
    }
    else
    {
        header += "void main()" +
            "{" +
            "float t = iTimeOffset + ((gl_FragCoord.x-0.5) + (gl_FragCoord.y-0.5)*512.0)/iSampleRate;" +
            "vec2 y = mainSound( 0, t );" +
            "vec2 v  = floor((0.5+0.5*y)*65536.0);" +
            "vec2 vl =   mod(v,256.0)/255.0;" +
            "vec2 vh = floor(v/256.0)/255.0;" +
            "gl_FragColor = vec4(vl.x,vh.x,vl.y,vh.y);" +
            "}";
    }
    header += "\n";
    this.mHeader = header;
    this.mHeaderLength = 0;
}


EffectPass.prototype.MakeHeader_Common = function ()
{
    let header = "";
    let headerlength = 0;

    header += "uniform vec4      iDate;\n" +
              "uniform float     iSampleRate;\n";
    headerlength += 2;

    if (this.mIs20)
    {
        header += "out vec4 outColor;\n";
        headerlength += 1;
    }
    header += "void main( void )\n";
    headerlength += 1;

    if (this.mIs20)
        header += "{ outColor = vec4(0.0); }";
    else
        header += "{ gl_FragColor = vec4(0.0); }";
    headerlength += 1;
    header += "\n";
    headerlength += 1;

    this.mHeader = header;
    this.mHeaderLength = headerlength;
}

EffectPass.prototype.MakeHeader = function()
{
         if( this.mType==="image" ) this.MakeHeader_Image();
    else if( this.mType==="sound" ) this.MakeHeader_Sound();
    else if( this.mType==="buffer") this.MakeHeader_Buffer();
    else if( this.mType==="common") this.MakeHeader_Common();
    else if( this.mType==="cubemap") this.MakeHeader_Cubemap();
    else console.log("ERROR 4");
}

EffectPass.prototype.Create_Image = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mSupportsVR = false;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    //this.mProgramVR = null;
}
EffectPass.prototype.Destroy_Image = function( wa )
{
}

EffectPass.prototype.Create_Buffer = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mSupportsVR = false;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    //this.mProgramVR = null;
}

EffectPass.prototype.Destroy_Buffer = function( wa )
{
}

EffectPass.prototype.Create_Cubemap = function( wa )
{
    this.MakeHeader();
    this.mSampleRate = 44100;
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
}

EffectPass.prototype.Destroy_Cubemap = function( wa )
{
}

EffectPass.prototype.Create_Common = function( wa )
{
    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.MakeHeader();
}
EffectPass.prototype.Destroy_Common = function( wa )
{
}

EffectPass.prototype.Create_Sound = function (wa)
{
    this.MakeHeader();


    this.mProgram = null;
    this.mError = false;
    this.mErrorStr = "";
    this.mTranslatedSource = null;
    this.mSampleRate = 44100;
    this.mPlayTime = 60*3;
    this.mPlaySamples = this.mPlayTime*this.mSampleRate;
    this.mBuffer = wa.createBuffer( 2, this.mPlaySamples, this.mSampleRate );

    //-------------------
    this.mTextureDimensions = 512;
    this.mRenderTexture = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D, 
                                                       this.mTextureDimensions, this.mTextureDimensions,
                                                       this.mRenderer.TEXFMT.C4I8,
                                                       this.mRenderer.FILTER.NONE,
                                                       this.mRenderer.TEXWRP.CLAMP, null);
    this.mRenderFBO = this.mRenderer.CreateRenderTarget(this.mRenderTexture, null, null, null, null, false);

    //-----------------------------

    // ArrayBufferView pixels;
    this.mTmpBufferSamples = this.mTextureDimensions*this.mTextureDimensions;
    this.mData = new Uint8Array( this.mTmpBufferSamples*4 );

    this.mPlaying = false;
}

EffectPass.prototype.Destroy_Sound = function( wa )
{
    if( this.mPlayNode!==null ) this.mPlayNode.stop();
    this.mPlayNode = null;
    this.mBuffer = null;
    this.mData = null;

    this.mRenderer.DestroyRenderTarget(this.mRenderFBO);
    this.mRenderer.DestroyTexture(this.mRenderTexture);
}

EffectPass.prototype.Create = function( passType, wa )
{
    this.mType = passType;
    this.mSource = null;

         if( passType==="image" ) this.Create_Image( wa );
    else if( passType==="sound" ) this.Create_Sound( wa );
    else if( passType==="buffer") this.Create_Buffer( wa );
    else if( passType==="common") this.Create_Common( wa );
    else if( passType==="cubemap") this.Create_Cubemap( wa );
    else alert("ERROR 1");
}

EffectPass.prototype.SetName = function (passName)
{
    this.mName = passName;
}

EffectPass.prototype.SetCode = function (src)
{
    this.mSource = src;
}

EffectPass.prototype.Destroy = function( wa )
{
    this.mSource = null;
         if( this.mType==="image" ) this.Destroy_Image( wa );
    else if( this.mType==="sound" ) this.Destroy_Sound( wa );
    else if( this.mType==="buffer") this.Destroy_Buffer( wa );
    else if( this.mType==="common") this.Destroy_Common( wa );
    else if( this.mType==="cubemap") this.Destroy_Cubemap( wa );
    else alert("ERROR 2");
}

EffectPass.prototype.NewShader_Sound = function( shaderCode, commonShaderCodes)
{
    let vsSource = null;

    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for( let i=0; i<commonShaderCodes.length; i++ )
    {
        fsSource += commonShaderCodes[i]+'\n';
    }
    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;
    fsSource += shaderCode;

    this.mSoundShaderCompiled = false;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader_Image = function ( shaderCode, commonShaderCodes )
{
    this.mSupportsVR = false;


    let vsSource = null;
    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for (let i = 0; i < commonShaderCodes.length; i++)
    {
        fsSource += commonShaderCodes[i]+'\n';
    }
    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;
    fsSource += shaderCode;

    return [vsSource, fsSource];


    /*
    let n1 = shaderCode.indexOf("mainVR(");
    let n2 = shaderCode.indexOf("mainVR (");
    let n3 = shaderCode.indexOf("mainVR  (");
    if( n1>0 || n2>0 || n3>0 )
    {
        let vsSourceVR;
        if( this.mIs20 )
            vsSourceVR = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        else
            vsSourceVR = "attribute in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

        let fsSourceVR = this.mHeader;
        for (let i = 0; i < commonShaderCodes.length; i++) {
            fsSourceVR += commonShaderCodes[i];
        }
        fsSourceVR += shaderCode;
        fsSourceVR += this.mImagePassFooterVR;

        let res = this.mRenderer.CreateShader(vsSource, fsSourceVR, preventCache);
        if( res.mResult == false )
        {
            return res.mInfo;
        }
        if( this.mProgramVR != null )
            this.mRenderer.DestroyShader( this.mProgramVR );

        this.mSupportsVR = true;
        this.mProgramVR = res;
    }
    */
}

EffectPass.prototype.NewShader_Cubemap = function( shaderCode, commonShaderCodes )
{
    let vsSource = null;
    if( this.mIs20 )
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader;
    for (let i = 0; i < commonShaderCodes.length; i++)
    {
        fsSource += commonShaderCodes[i]+'\n';
    }

    this.mHeaderLength = fsSource.split(/\r\n|\r|\n/).length;

    fsSource += shaderCode;

    return [vsSource, fsSource];
}


EffectPass.prototype.NewShader_Common = function (shaderCode )
{
    let vsSource = null;
    if (this.mIs20)
        vsSource = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
    else
        vsSource = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";

    let fsSource = this.mHeader + shaderCode;

    return [vsSource, fsSource];
}

EffectPass.prototype.NewShader = function ( commonSourceCodes, preventCache, onResolve)
{
    if( this.mRenderer===null ) return;

    let vs_fs = null;

         if( this.mType==="sound"  ) vs_fs = this.NewShader_Sound(   this.mSource, commonSourceCodes );
    else if( this.mType==="image"  ) vs_fs = this.NewShader_Image(   this.mSource, commonSourceCodes );
    else if( this.mType==="buffer" ) vs_fs = this.NewShader_Image(   this.mSource, commonSourceCodes );
    else if( this.mType==="common" ) vs_fs = this.NewShader_Common(  this.mSource,                   );
    else if( this.mType==="cubemap") vs_fs = this.NewShader_Cubemap( this.mSource, commonSourceCodes );
    else { console.log("ERROR 3: \"" + this.mType + "\""); return; }

    let me = this;
    this.mRenderer.CreateShader(vs_fs[0], vs_fs[1], preventCache, false,
        function (worked, info)
        {
            if (worked === true)
            {
                if (me.mType === "sound")
                {
                    me.mSoundShaderCompiled = true;
                }

                me.mCompilationTime = info.mTime;
                me.mError = false;
                me.mErrorStr = "No Errors";
                if (me.mProgram !== null)
                    me.mRenderer.DestroyShader(me.mProgram);
                me.mTranslatedSource = me.mRenderer.GetTranslatedShaderSource(info);
                me.mProgram = info;
            }
            else
            {
                me.mError = true;
                me.mErrorStr = info.mErrorStr;
            }
            onResolve();
        });
}

EffectPass.prototype.DestroyInput = function( id )
{
    if( this.mInputs[id]===null ) return;

    if( this.mInputs[id].mInfo.mType==="texture" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    if( this.mInputs[id].mInfo.mType==="volume" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="webcam" )
    {
        this.mInputs[id].video.pause();
        this.mInputs[id].video.src = "";

        if( this.mInputs[id].video.srcObject!==null )
        {
        let tracks = this.mInputs[id].video.srcObject.getVideoTracks();
        if( tracks ) tracks[0].stop();
        }
        this.mInputs[id].video = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="video" )
    {
        this.mInputs[id].video.pause();
        this.mInputs[id].video = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="music" || this.mInputs[id].mInfo.mType==="musicstream")
    {
        this.mInputs[id].audio.pause();
        this.mInputs[id].audio.mSound.mFreqData = null;
        this.mInputs[id].audio.mSound.mWaveData = null;
        this.mInputs[id].audio = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="cubemap" )
    {
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="keyboard" )
    {
        //if( this.mInputs[id].globject != null )
          //  this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }
    else if( this.mInputs[id].mInfo.mType==="mic" )
    {
        this.mInputs[id].mic = null;
        if( this.mInputs[id].globject !== null )
            this.mRenderer.DestroyTexture(this.mInputs[id].globject);
    }

    this.mInputs[id] = null;
}

EffectPass.prototype.TooglePauseInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused )
        {
            inp.video.play();
            inp.video.mPaused = false;
        }
        else
        {
            inp.video.pause();
            inp.video.mPaused = true;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        wa.resume()
        if( inp.audio.mPaused )
        {
            if( inp.loaded )
            {
                inp.audio.play();
            }
            inp.audio.mPaused = false;
        }
        else
        {
            inp.audio.pause();
            inp.audio.mPaused = true;
        }
        return inp.audio.mPaused;
    }

    return null;
}

EffectPass.prototype.StopInput = function( id )
{
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused === false )
        {
            inp.video.pause();
            inp.video.mPaused = true;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
    {
        if( inp.audio.mPaused === false )
        {
            inp.audio.pause();
            inp.audio.mPaused = true;
        }
        return inp.audio.mPaused;
    }
    return null;
}

EffectPass.prototype.ResumeInput = function( id )
{
    let inp = this.mInputs[id];

    if( inp===null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mPaused )
        {
            inp.video.play();
            inp.video.mPaused = false;
        }
        return inp.video.mPaused;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
    {
        if( inp.audio.mPaused )
        {
            inp.audio.play();
            inp.audio.mPaused = false;
        }
        return inp.audio.mPaused;
    }
    return null;
}

EffectPass.prototype.RewindInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];

    if( inp==null )
    {
    }
    else if( inp.mInfo.mType==="texture" )
    {
    }
    else if( inp.mInfo.mType==="volume" )
    {
    }
    else if( inp.mInfo.mType==="video" )
    {
        if( inp.loaded )
        {
            inp.video.currentTime = 0;
        }
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        wa.resume()
        if( inp.loaded )
        {
            inp.audio.currentTime = 0;
        }
    }
}

EffectPass.prototype.MuteInput = function( wa, id )
{
    let inp = this.mInputs[id];
    if( inp===null ) return;

    if( inp.mInfo.mType==="video" )
    {
        inp.video.muted = true;
        inp.video.mMuted = true;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if (wa !== null) inp.audio.mSound.mGain.gain.value = 0.0;
        inp.audio.mMuted = true;
    }
}

EffectPass.prototype.UnMuteInput = function( wa, id )
{
    let inp = this.mInputs[id];
    if( inp===null ) return;

    if( inp.mInfo.mType==="video" )
    {
        inp.video.muted = false;
        inp.video.mMuted = false;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if (wa !== null) inp.audio.mSound.mGain.gain.value = 1.0;
        inp.audio.mMuted = false;
    }
}

EffectPass.prototype.ToggleMuteInput = function( wa, id )
{
    var me = this;
    let inp = this.mInputs[id];
    if( inp===null ) return null;

    if( inp.mInfo.mType==="video" )
    {
        if( inp.video.mMuted ) this.UnMuteInput(wa,id);
        else                   this.MuteInput(wa,id);
        return inp.video.mMuted;
    }
    else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream")
    {
        if( inp.audio.mMuted ) this.UnMuteInput(wa,id);
        else                   this.MuteInput(wa,id);
        return inp.audio.mMuted;
    }

    return null;
}

EffectPass.prototype.UpdateInputs = function( wa, forceUpdate, keyboard )
{
   for (let i=0; i<this.mInputs.length; i++ )
   {
        let inp = this.mInputs[i];

        if( inp===null )
        {
            if( forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, null, false, 0, 0, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.image, true, 1, 1, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mPreview, true, 1, 1, -1.0, this.mID );
            }
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
            if( inp.loaded && forceUpdate )
            {
                if( this.mTextureCallbackFun!==null )
                {
                    let img = (assetID_to_cubemapBuferID(inp.mInfo.mID)===-1) ? inp.image[0] : inp.mImage;
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, img, true, 2, 1, -1.0, this.mID );
                }
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:keyboard.mIcon,mData:keyboard.mData}, false, 6, 0, -1.0, this.mID );
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, -1, this.mID );
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
              if( inp.loaded && inp.audio.mPaused === false && inp.audio.mForceMuted === false )
              {
                  if( wa !== null )
                  {
                      inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                      inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                  }

                  if (this.mTextureCallbackFun!==null)
                  {
                           if (inp.mInfo.mType === "music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:(wa==null)?null:inp.audio.mSound.mFreqData}, false, 4, 1, inp.audio.currentTime, this.mID);
                      else if (inp.mInfo.mType === "musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:(wa==null)?null:inp.audio.mSound.mFreqData, info: inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                  }
              }
              else if( inp.loaded===false )
              {
                  if (this.mTextureCallbackFun!==null)
                      this.mTextureCallbackFun(this.mTextureCallbackObj, i, {wave:null}, false, 4, 0, -1.0, this.mID);
              }
        }
        else if( inp.mInfo.mType==="mic" )
        {
              if( inp.loaded && inp.mForceMuted === false )
              {
                  if( wa !== null )
                  {
                      inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                      inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
                  }
                  if( this.mTextureCallbackFun!==null )
                      this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave: ((wa==null)?null:inp.mFreqData) }, false, 5, 1, 0, this.mID );
              }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded && forceUpdate )
            {
              if( this.mTextureCallbackFun!==null )
                  this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:null}, true, 9, 1, -1.0, this.mID );
            }
        }
    }
}

EffectPass.prototype.Sampler2Renderer = function (sampler)
{
    let filter = this.mRenderer.FILTER.NONE;
    if (sampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
    if (sampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
    let wrap = this.mRenderer.TEXWRP.REPEAT;
    if (sampler.wrap === "clamp") wrap = this.mRenderer.TEXWRP.CLAMP;
    let vflip = false;
    if (sampler.vflip === "true") vflip = true;

    return { mFilter: filter, mWrap: wrap, mVFlip: vflip };
}

EffectPass.prototype.GetSamplerVFlip = function (id)
{
    let inp = this.mInputs[id];
    return inp.mInfo.mSampler.vflip;
}

EffectPass.prototype.GetTranslatedShaderSource = function ()
{
    return this.mTranslatedSource;
}


EffectPass.prototype.SetSamplerVFlip = function (id, str) 
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let filter = false;
    if (str === "true") filter = true;

    if (inp === null)
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
    }
    else if (inp.mInfo.mType === "video")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, inp.image);
            inp.mInfo.mSampler.vflip = str;
        }
    }
    else if (inp.mInfo.mType === "webcam")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerVFlip(inp.globject, filter, null);
            inp.mInfo.mSampler.vflip = str;
        }
    }
}

EffectPass.prototype.GetAcceptsVFlip = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return false;
    if (inp.mInfo.mType === "video")  return true;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return true;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return false;
    return true;
}

EffectPass.prototype.GetSamplerFilter = function (id)
{
    let inp = this.mInputs[id];
    if( inp===null) return;
    return inp.mInfo.mSampler.filter;
}

EffectPass.prototype.SetSamplerFilter = function (id, str, buffers, cubeBuffers) 
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let filter = renderer.FILTER.NONE;
    if (str === "linear") filter = renderer.FILTER.LINEAR;
    if (str === "mipmap") filter = renderer.FILTER.MIPMAP;

    if (inp === null)
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
        if (inp.loaded)
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "video")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap")
    {
        if (inp.loaded) 
        {
            if( assetID_to_cubemapBuferID(inp.mInfo.mID)===0)
            {
                renderer.SetSamplerFilter(cubeBuffers[0].mTexture[0], filter, true);
                renderer.SetSamplerFilter(cubeBuffers[0].mTexture[1], filter, true);
                inp.mInfo.mSampler.filter = str;
            }
            else
            {
                renderer.SetSamplerFilter(inp.globject, filter, true);
                inp.mInfo.mSampler.filter = str;
            }
        }
    }
    else if (inp.mInfo.mType === "webcam")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerFilter(inp.globject, filter, true);
            inp.mInfo.mSampler.filter = str;
        }
    }
    else if (inp.mInfo.mType === "buffer")
    {
        renderer.SetSamplerFilter(buffers[inp.id].mTexture[0], filter, true);
        renderer.SetSamplerFilter(buffers[inp.id].mTexture[1], filter, true);
        inp.mInfo.mSampler.filter = str;
    }
    else if (inp.mInfo.mType === "keyboard")
    {
        inp.mInfo.mSampler.filter = str;
    }
}



EffectPass.prototype.GetAcceptsMipmapping = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return this.mIs20;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return this.mIs20;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return this.mIs20;
    return false;
}

EffectPass.prototype.GetAcceptsLinear = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return true;
    if (inp.mInfo.mType === "cubemap") return true;
    if (inp.mInfo.mType === "webcam")  return true;
    if (inp.mInfo.mType === "music")  return true;
    if (inp.mInfo.mType === "musicstream") return true;
    if (inp.mInfo.mType === "mic")  return true;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return true;
    return false;
}


EffectPass.prototype.GetAcceptsWrapRepeat = function (id)
{
    let inp = this.mInputs[id];

    if (inp === null) return false;
    if (inp.mInfo.mType === "texture") return true;
    if (inp.mInfo.mType === "volume") return true;
    if (inp.mInfo.mType === "video")  return this.mIs20;
    if (inp.mInfo.mType === "cubemap") return false;
    if (inp.mInfo.mType === "webcam")  return this.mIs20;
    if (inp.mInfo.mType === "music")  return false;
    if (inp.mInfo.mType === "musicstream") return false;
    if (inp.mInfo.mType === "mic")  return false;
    if (inp.mInfo.mType === "keyboard")  return false;
    if (inp.mInfo.mType === "buffer") return this.mIs20;
    return false;
}

EffectPass.prototype.GetSamplerWrap = function (id)
{
    let inp = this.mInputs[id];
    return inp.mInfo.mSampler.wrap;
}
EffectPass.prototype.SetSamplerWrap = function (id, str, buffers)
{
    var me = this;
    var renderer = this.mRenderer;
    let inp = this.mInputs[id];

    let restr = renderer.TEXWRP.REPEAT;
    if (str === "clamp") restr = renderer.TEXWRP.CLAMP;

    if (inp === null) 
    {
    }
    else if (inp.mInfo.mType === "texture")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "volume")
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "video") 
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "cubemap") 
    {
        if (inp.loaded)
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "webcam") 
    {
        if (inp.loaded) 
        {
            renderer.SetSamplerWrap(inp.globject, restr);
            inp.mInfo.mSampler.wrap = str;
        }
    }
    else if (inp.mInfo.mType === "buffer")
    {
        renderer.SetSamplerWrap(buffers[inp.id].mTexture[0], restr);
        renderer.SetSamplerWrap(buffers[inp.id].mTexture[1], restr);
        inp.mInfo.mSampler.wrap = str;
    }
}


EffectPass.prototype.GetTexture = function( slot )
{
    let inp = this.mInputs[slot];
    if( inp===null ) return null;
    return inp.mInfo;

}

EffectPass.prototype.SetOutputs = function( slot, id )
{
    this.mOutputs[slot] = id;
}

EffectPass.prototype.SetOutputsByBufferID = function( slot, id )
{
    if( this.mType==="buffer" )
    {
        this.mOutputs[slot] = bufferID_to_assetID( id );

        this.mEffect.ResizeBuffer( id, this.mEffect.mXres, this.mEffect.mYres, false );
    }
    else if( this.mType==="cubemap" )
    {
        this.mOutputs[slot] = cubamepBufferID_to_assetID( id );
        this.mEffect.ResizeCubemapBuffer(id, 1024, 1024 );
    }
}

EffectPass.prototype.NewTexture = function( wa, slot, url, buffers, cubeBuffers, keyboard )
{
    var me = this;
    var renderer = this.mRenderer;

    if( renderer===null ) return;

    let texture = null;

    if( url===null || url.mType===null )
    {
        if( me.mTextureCallbackFun!==null )
            me.mTextureCallbackFun( this.mTextureCallbackObj, slot, null, true, 0, 0, -1.0, me.mID );
        me.DestroyInput( slot );
        me.mInputs[slot] = null;
        me.MakeHeader();
        return { mFailed:false, mNeedsShaderCompile:false };
    }
    else if( url.mType==="texture" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.image = new Image();
        texture.image.crossOrigin = '';
        texture.image.onload = function()
        {
            let rti = me.Sampler2Renderer(url.mSampler);

            // O.M.G. FIX THIS
            let channels = renderer.TEXFMT.C4I8;
            if (url.mID === "Xdf3zn" || url.mID === "4sf3Rn" || url.mID === "4dXGzn" || url.mID === "4sf3Rr")
                channels = renderer.TEXFMT.C1I8;
            
            texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.image, channels, rti.mFilter, rti.mWrap, rti.mVFlip);

            texture.loaded = true;
            if( me.mTextureCallbackFun!==null )
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.image, true, 1, 1, -1.0, me.mID );
        }
        texture.image.src = url.mSrc;


        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="volume" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.mImage = { mData:null, mXres:1, mYres:0, mZres:0 };
        texture.mPreview = new Image();
        texture.mPreview.crossOrigin = '';

	    var xmlHttp = new XMLHttpRequest();
        if( xmlHttp===null ) return { mFailed:true };

        xmlHttp.open('GET', url.mSrc, true);
        xmlHttp.responseType = "arraybuffer";
        xmlHttp.onerror = function()
        {
            console.log( "Error 1 loading Volume" );
        }
        xmlHttp.onload = function()
        {
            let data = xmlHttp.response;
            if (!data ) { console.log( "Error 2 loading Volume" ); return; }

            let file = piFile(data);

            let signature = file.ReadUInt32();
            texture.mImage.mXres = file.ReadUInt32();
            texture.mImage.mYres = file.ReadUInt32();
            texture.mImage.mZres = file.ReadUInt32();
            let binNumChannels = file.ReadUInt8();
            let binLayout = file.ReadUInt8();
            let binFormat = file.ReadUInt16();
            let format = renderer.TEXFMT.C1I8;
                 if( binNumChannels===1 && binFormat===0 )  format = renderer.TEXFMT.C1I8;
            else if( binNumChannels===2 && binFormat===0 )  format = renderer.TEXFMT.C2I8;
            else if( binNumChannels===3 && binFormat===0 )  format = renderer.TEXFMT.C3I8;
            else if( binNumChannels===4 && binFormat===0 )  format = renderer.TEXFMT.C4I8;
            else if( binNumChannels===1 && binFormat===10 ) format = renderer.TEXFMT.C1F32;
            else if( binNumChannels===2 && binFormat===10 ) format = renderer.TEXFMT.C2F32;
            else if( binNumChannels===3 && binFormat===10 ) format = renderer.TEXFMT.C3F32;
            else if( binNumChannels===4 && binFormat===10 ) format = renderer.TEXFMT.C4F32;
            else return;

            let buffer = new Uint8Array(data, 20); // skip 16 bytes (header of .bin)

            let rti = me.Sampler2Renderer(url.mSampler);

            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T3D, texture.mImage.mXres, texture.mImage.mYres, format, rti.mFilter, rti.mWrap, buffer);

            if( texture.globject===null )
            {
                console.log( "Error 4: loading Volume" ); 
                return { mFailed:true };
            }

            if (me.mTextureCallbackFun !== null)
            {
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mPreview, true, 1, 1, -1.0, me.mID );
            }

            texture.loaded = true;

            // load icon for it
            texture.mPreview.onload = function()
            {
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mPreview, true, 1, 1, -1.0, me.mID );
            }
            texture.mPreview.src = url.mPreviewSrc;
        }
        xmlHttp.send("");


        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]==null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="volume")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="cubemap" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;

        let rti = me.Sampler2Renderer(url.mSampler);

        if( assetID_to_cubemapBuferID(url.mID)!==-1 )
        {
            texture.mImage = new Image();
            texture.mImage.onload = function()
            {
                texture.loaded = true;
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mImage, true, 2, 1, -1.0, me.mID );
            }
            texture.mImage.src = "/media/previz/cubemap00.png";

            this.mEffect.ResizeCubemapBuffer(0, 1024, 1024 );

        }
        else
        {
            texture.image = [ new Image(), new Image(), new Image(), new Image(), new Image(), new Image() ];

            let numLoaded = 0;
            for (var i=0; i<6; i++ )
            {
                texture.image[i].mId = i;
                texture.image[i].crossOrigin = '';
                texture.image[i].onload = function()
                {
                    var id = this.mId;
                    numLoaded++;
                    if( numLoaded===6 )
                    {
                        texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.CUBEMAP, texture.image, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                        texture.loaded = true;
                        if (me.mTextureCallbackFun !== null)
                            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, texture.image[0], true, 2, 1, -1.0, me.mID);
                    }
                }

                if( i === 0) 
                {
                    texture.image[i].src = url.mSrc;
                } 
                else 
                {
                    let n = url.mSrc.lastIndexOf(".");
                    texture.image[i].src = url.mSrc.substring(0, n) + "_" + i + url.mSrc.substring(n, url.mSrc.length);
                }
            }
        }

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]==null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="cubemap")) };

        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="webcam" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;

        texture.video = document.createElement('video');
    	texture.video.width = 320;
    	texture.video.height = 240;
    	texture.video.autoplay = true;
    	texture.video.loop = true;
        texture.mForceMuted = this.mForceMuted;
        texture.mImage = null;

        let rti = me.Sampler2Renderer(url.mSampler);

        var loadImageInsteadOfWebCam = function()
        {
            texture.mImage = new Image();
            texture.mImage.onload = function()
            {
                texture.loaded = true;
                texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.mImage, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                if( me.mTextureCallbackFun!==null )
                    me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.mImage, true, 7, 1, -1.0, me.mID );
            }
            texture.mImage.src = "/media/previz/webcam.png";
        }
        
        loadImageInsteadOfWebCam();

        if( typeof navigator.getUserMedia !== "undefined"  && texture.mForceMuted===false )
        {
            texture.video.addEventListener("canplay", function (e)
            {
				try
				{
                    texture.mImage = null;
                    if( texture.globject != null )
                        renderer.DestroyTexture( texture.globject );
					texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.video, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
					texture.loaded = true;
                }
                catch(e)
                {
                    loadImageInsteadOfWebCam();
	                alert( 'Your browser can not transfer webcam data to the GPU.');
                }
            } );

            navigator.mediaDevices.getUserMedia( 
                                { "video": { width: 1280, height: 720 }, "audio": false } )
                                .then( function(stream)
                                       {
                                            texture.video.srcObject = stream;
    	                               } )
                                .catch( function(error)
                                        {
                                            loadImageInsteadOfWebCam();
    		                                alert( 'Unable to capture WebCam. Please reload the page.' );
    	                                } );
        }
        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]==null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!="music") && 
                                                                (this.mInputs[slot].mInfo.mType!="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="mic" )
    {
        texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.mForceMuted = this.mForceMuted;
        texture.mAnalyser = null;
        let num = 512;
        texture.mFreqData = new Uint8Array( num );
        texture.mWaveData = new Uint8Array( num );

        if( wa === null || typeof navigator.getUserMedia === "undefined" )
        {
            if( !texture.mForceMuted ) alert( "Shadertoy: Web Audio not implement in this browser" );
            texture.mForceMuted = true; 
        }

        if( texture.mForceMuted )
        {
            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, num, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null)
            texture.loaded = true;
        }
        else
        {
        navigator.getUserMedia( { "audio": true },
                                function(stream)
                                {
                                  texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, null)
                                  texture.mic = wa.createMediaStreamSource(stream);
                                  texture.mAnalyser = wa.createAnalyser();
                                  texture.mic.connect( texture.mAnalyser );
                                  texture.loaded = true;
    	                        },
                                function(error)
                                {
    		                        alert( 'Unable open Mic. Please reload the page.' );
    	                        } );
        }
        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="video" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.video = document.createElement('video');
    	texture.video.loop = true;
        texture.video.preload = "auto";
        texture.video.mPaused = this.mForcePaused;
        texture.video.mMuted = true;//this.mForceMuted;
    	texture.video.muted  = true;//this.mForceMuted;
        if( this.mForceMuted===true )
            texture.video.volume = 0;
    	texture.video.autoplay = false;
        texture.video.hasFalled = false;
        
        let rti = me.Sampler2Renderer(url.mSampler);

        texture.video.addEventListener("canplay", function (e)
        {
            texture.video.play().then( function()
                                       {
                                           texture.video.mPaused = false;

                                           texture.globject = renderer.CreateTextureFromImage(renderer.TEXTYPE.T2D, texture.video, renderer.TEXFMT.C4I8, rti.mFilter, rti.mWrap, rti.mVFlip);
                                           texture.loaded = true;
            
                                           if( me.mTextureCallbackFun!=null )
                                               me.mTextureCallbackFun( me.mTextureCallbackObj, slot, texture.video, true, 3, 1, -1.0, me.mID );
                                        } )
                               .catch( function(error)
                                       {
                                           console.log( error );
                                       }
                                );
        } );

        texture.video.addEventListener( "error", function(e)
        {
               if( texture.video.hasFalled===true ) { alert("Error: cannot load video" ); return; }
               let str = texture.video.src;
               str = str.substr(0,str.lastIndexOf('.') ) + ".mp4";
               texture.video.src = str;
               texture.video.hasFalled = true;
        } );

        texture.video.src = url.mSrc;

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]==null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!="music") && 
                                                                (this.mInputs[slot].mInfo.mType!="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="music" || url.mType==="musicstream" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = false;
        texture.audio = document.createElement('audio');
    	texture.audio.loop = true;
        texture.audio.mMuted = this.mForceMuted;
        texture.audio.mForceMuted = this.mForceMuted;
        texture.audio.muted = this.mForceMuted;
        if( this.mForceMuted===true )
            texture.audio.volume = 0;
        texture.audio.autoplay = false;
        texture.audio.hasFalled = false;
        texture.audio.mPaused = false;
        texture.audio.mSound = {};

        if( this.mForceMuted===false )
        {
            if(url.mType==="musicstream" && SC === null)
            {
                alert( "Shadertoy: Soundcloud could not be reached" );
                texture.audio.mForceMuted = true;
            }
            }

        if( wa === null && this.mForceMuted===false )
        {
            alert( "Shadertoy: Web Audio not implement in this browser" );
            texture.audio.mForceMuted = true;
        }

        if( texture.audio.mForceMuted )
        {
            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null);
            let num = 512;
            texture.audio.mSound.mFreqData = new Uint8Array( num );
            texture.audio.mSound.mWaveData = new Uint8Array( num );
            texture.loaded = true;
        }

        texture.audio.addEventListener( "canplay", function()
        {
            if( texture===null || texture.audio===null ) return;
            if( this.mForceMuted  ) return;
            if( texture.loaded === true ) return;

            texture.globject = renderer.CreateTexture(renderer.TEXTYPE.T2D, 512, 2, renderer.TEXFMT.C1I8, renderer.FILTER.LINEAR, renderer.TEXWRP.CLAMP, null)

            texture.audio.mSound.mSource   = wa.createMediaElementSource( texture.audio );
            texture.audio.mSound.mAnalyser = wa.createAnalyser();
            texture.audio.mSound.mGain     = wa.createGain();

            texture.audio.mSound.mSource.connect(   texture.audio.mSound.mAnalyser );
            texture.audio.mSound.mAnalyser.connect( texture.audio.mSound.mGain );
            texture.audio.mSound.mGain.connect(me.mGainNode);

            texture.audio.mSound.mFreqData = new Uint8Array( texture.audio.mSound.mAnalyser.frequencyBinCount );
            texture.audio.mSound.mWaveData = new Uint8Array( texture.audio.mSound.mAnalyser.frequencyBinCount );

            if( texture.audio.mPaused )
            {
                texture.audio.pause();
            }
            else
            {
                texture.audio.play().then( function() {/*console.log("ok");*/} ).catch( function(e){console.log("error " + e);} );
            }
            texture.loaded = true;
        } );

        texture.audio.addEventListener( "error", function(e)
        {
               if( this.mForceMuted  ) return;

               if( texture.audio.hasFalled===true ) { return; }
               let str = texture.audio.src;
               str = str.substr(0,str.lastIndexOf('.') ) + ".ogg";
               texture.audio.src = str;
               texture.audio.hasFalled = true;
        } );

        if( !texture.audio.mForceMuted )
        {
            if(url.mType==="musicstream")
            {
                SC.resolve(url.mSrc, 
                    function(song) 
                    {
                        if( song.streamable===true )
                        {
                            texture.audio.crossOrigin = 'anonymous';
                            texture.audio.src = song.stream_url;
                            texture.audio.soundcloudInfo = song;
                        }
                        else
                        {
                            alert('Shadertoy: Soundcloud 3 - This track cannot be streamed' );
                        }
                    },
                    function(error)
                    {
                        if (me.mTextureCallbackFun!==null)
                        {
                            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null}, false, 4, 0, -1.0, me.mID);
                        }
                    } );
            } 
            else
            {
                texture.audio.src = url.mSrc;
            }
        }

        if (me.mTextureCallbackFun!==null)
        {
            if (url.mType === "music")            me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null}, false, 4, 0, -1.0, me.mID);
            else if (url.mType === "musicstream") me.mTextureCallbackFun(me.mTextureCallbackObj, slot, {wave:null, info: texture.audio.soundcloudInfo}, false, 8, 0, -1.0, me.mID);
        }

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!=="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!=="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!=="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!=="music") && 
                                                                (this.mInputs[slot].mInfo.mType!=="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!=="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!=="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="keyboard" )
    {
    	texture = {};
        texture.mInfo = url;
        texture.globject = null;
        texture.loaded = true;

        texture.keyboard = {};

        if( me.mTextureCallbackFun!==null )
            me.mTextureCallbackFun( me.mTextureCallbackObj, slot, {mImage: keyboard.mIcon, mData: keyboard.mData}, false, 6, 1, -1.0, me.mID );

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!="music") && 
                                                                (this.mInputs[slot].mInfo.mType!="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!="video")) };
        this.DestroyInput( slot );
        this.mInputs[slot] = texture;
        this.MakeHeader();
        return returnValue;
    }
    else if( url.mType==="buffer" )
    {
        texture = {};
        texture.mInfo = url;

        texture.image = new Image();
        texture.image.onload = function()
        {
            if( me.mTextureCallbackFun!=null )
                me.mTextureCallbackFun( me.mTextureCallbackObj, slot, {texture: texture.image, data:null}, true, 9, 1, -1.0, me.mID );
        }
        texture.image.src = url.mSrc;
        texture.id = assetID_to_bufferID( url.mID );
        texture.loaded = true;

        let returnValue = { mFailed:false, mNeedsShaderCompile: (this.mInputs[slot]===null ) || (
                                                                (this.mInputs[slot].mInfo.mType!="texture") && 
                                                                (this.mInputs[slot].mInfo.mType!="webcam") && 
                                                                (this.mInputs[slot].mInfo.mType!="mic") && 
                                                                (this.mInputs[slot].mInfo.mType!="music") && 
                                                                (this.mInputs[slot].mInfo.mType!="musicstream") && 
                                                                (this.mInputs[slot].mInfo.mType!="keyboard") && 
                                                                (this.mInputs[slot].mInfo.mType!="video")) };

        this.DestroyInput( slot );
        this.mInputs[slot] = texture;

        this.mEffect.ResizeBuffer(texture.id, this.mEffect.mXres, this.mEffect.mYres, false );

        this.SetSamplerFilter(slot, url.mSampler.filter, buffers, cubeBuffers, true);
        this.SetSamplerVFlip(slot, url.mSampler.vflip);
        this.SetSamplerWrap(slot, url.mSampler.wrap, buffers);

        this.MakeHeader();
        return returnValue;
    }
    else
    {
        alert( "input type error" );
        return { mFailed: true };
    }

    return { mFailed: true };
}

EffectPass.prototype.Paint_Image = function( vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    let times = [ 0.0, 0.0, 0.0, 0.0 ];

    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds()  + d.getMilliseconds()/1000.0 ];

    let mouse = [  mousePosX, mousePosY, mouseOriX, mouseOriY ];


    //------------------------
    
    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];
    let texIsLoaded = [0, 0, 0, 0 ];
    let texID = [ null, null, null, null];

    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            texID[i] = keyboard.mTexture;
            texIsLoaded[i] = 1;
            resos[3*i+0] = 256;
            resos[3*i+1] = 3;
            resos[3*i+2] = 1;
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
            if (inp.loaded === true)
            {
                let id = assetID_to_cubemapBuferID(inp.mInfo.mID);
                if( id!==-1 )
                {
                    texID[i] = cubeBuffers[id].mTexture[ cubeBuffers[id].mLastRenderDone ];
                    resos[3*i+0] = cubeBuffers[id].mResolution[0];
                    resos[3*i+1] = cubeBuffers[id].mResolution[1];
                    resos[3*i+2] = 1;
                    texIsLoaded[i] = 1;

                    // hack. in webgl2.0 we have samplers, so we don't need this crap here
                    let filter = this.mRenderer.FILTER.NONE;
                         if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                    else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                    this.mRenderer.SetSamplerFilter( texID[i], filter, false);
                }
                else
                {
                    texID[i] = inp.globject;
                    texIsLoaded[i] = 1;
                }
            }
        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mImage, false, 7, 1, -1, this.mID );

                    texID[i] = inp.globject;
                    texIsLoaded[i] = 1;
                    resos[3*i+0] = inp.mImage.width;
                    resos[3*i+1] = inp.mImage.height;
                    resos[3*i+2] = 1;
                }
                else  if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {

                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 7, 1, -1, this.mID );

                    texID[i] = inp.globject;
                    this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                    resos[3*i+0] = inp.video.videoWidth;
                    resos[3*i+1] = inp.video.videoHeight;
                    resos[3*i+2] = 1;
                    texIsLoaded[i] = 1;
                }
            }
            else 
            {
                texID[i] = null;
                texIsLoaded[i] = 0;
                resos[3*i+0] = inp.video.width;
                resos[3*i+1] = inp.video.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.mPaused === false )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, inp.video.currentTime, this.mID );
            }

            if( inp.loaded===true )
            { 
                times[i] = inp.video.currentTime;
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;

      	        if( inp.video.mPaused === false )
      	        {
      	            this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
                resos[3*i+0] = inp.video.videoWidth;
                resos[3*i+1] = inp.video.videoHeight;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.audio.mPaused === false && inp.audio.mForceMuted === false && inp.loaded===true )
            {
                if( wa !== null )
                {
                    inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                    inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                }

                if( this.mTextureCallbackFun!==null )
                {
                         if( inp.mInfo.mType==="music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa === null) ? null : { wave : inp.audio.mSound.mFreqData }, false, 4, 1, inp.audio.currentTime, this.mID);
                    else if( inp.mInfo.mType==="musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa === null) ? null : { wave : inp.audio.mSound.mFreqData, info : inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                }
            }

            if( inp.loaded===true )
            {
                times[i] = inp.audio.currentTime;
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;

                if( inp.audio.mForceMuted === true )
                {
                    times[i] = 10.0 + time;
                    let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.audio.mSound.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                  //let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.audio.mSound.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }

                }

      	        if( inp.audio.mPaused === false )
                {
      	            let waveLen = Math.min(inp.audio.mSound.mWaveData.length, 512);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512, 1, inp.audio.mSound.mFreqData);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 1, 512, 1, inp.audio.mSound.mWaveData);
                }

                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                    times[i] = 10.0 + time;
                    let num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                    //var num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }
            }
            else
            {
                inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
            }

            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave:inp.mFreqData}, false, 5, 1, -1, this.mID );

            if( inp.loaded===true )
            {
                texID[i] = inp.globject;
                texIsLoaded[i] = 1;
                let waveLen = Math.min( inp.mWaveData.length, 512 );
                this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512,     1, inp.mFreqData);
                this.mRenderer.UpdateTexture(inp.globject, 0, 1, waveLen, 1, inp.mWaveData);
                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            let id = inp.id;
            if( inp.loaded===true  )
            {
                texID[i] = buffers[id].mTexture[ buffers[id].mLastRenderDone ];
                texIsLoaded[i] = 1;
                resos[3*i+0] = xres;
                resos[3*i+1] = yres;
                resos[3*i+2] = 1;
                // hack. in webgl2.0 we have samplers, so we don't need this crap here
                let filter = this.mRenderer.FILTER.NONE;
                     if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                this.mRenderer.SetSamplerFilter( texID[i], filter, false);
            }

            if( this.mTextureCallbackFun!==null )
            {
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:buffers[id].mThumbnailBuffer}, false, 9, 1, -1, this.mID );
            }
        }
    }

    this.mRenderer.AttachTextures( 4, texID[0], texID[1], texID[2], texID[3] );

    //-----------------------------------

    let prog = this.mProgram;

    //if( vrData!=null && this.mSupportsVR ) prog = this.mProgramVR;



    this.mRenderer.AttachShader(prog);

    this.mRenderer.SetShaderConstant1F(  "iTime", time);
    this.mRenderer.SetShaderConstant3F(  "iResolution", xres, yres, 1.0);
    this.mRenderer.SetShaderConstant4FV( "iMouse", mouse);
    this.mRenderer.SetShaderConstant1FV( "iChannelTime", times );              // OBSOLETE
    this.mRenderer.SetShaderConstant4FV( "iDate", dates );
    this.mRenderer.SetShaderConstant3FV( "iChannelResolution", resos );        // OBSOLETE
    this.mRenderer.SetShaderConstant1F(  "iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit( "iChannel0", 0 );
    this.mRenderer.SetShaderTextureUnit( "iChannel1", 1 );
    this.mRenderer.SetShaderTextureUnit( "iChannel2", 2 );
    this.mRenderer.SetShaderTextureUnit( "iChannel3", 3 );
    this.mRenderer.SetShaderConstant1I(  "iFrame", this.mFrame );
    this.mRenderer.SetShaderConstant1F(  "iTimeDelta", dtime);
    this.mRenderer.SetShaderConstant1F(  "iFrameRate", fps );

    this.mRenderer.SetShaderConstant1F(  "iCh0.time", times[0] );
    this.mRenderer.SetShaderConstant1F(  "iCh1.time", times[1] );
    this.mRenderer.SetShaderConstant1F(  "iCh2.time", times[2] );
    this.mRenderer.SetShaderConstant1F(  "iCh3.time", times[3] );
    this.mRenderer.SetShaderConstant3F(  "iCh0.size", resos[0], resos[ 1], resos[ 2] );
    this.mRenderer.SetShaderConstant3F(  "iCh1.size", resos[3], resos[ 4], resos[ 5] );
    this.mRenderer.SetShaderConstant3F(  "iCh2.size", resos[6], resos[ 7], resos[ 8] );
    this.mRenderer.SetShaderConstant3F(  "iCh3.size", resos[9], resos[10], resos[11] );
    this.mRenderer.SetShaderConstant1I(  "iCh0.loaded",       texIsLoaded[0] );
    this.mRenderer.SetShaderConstant1I(  "iCh1.loaded",       texIsLoaded[1] );
    this.mRenderer.SetShaderConstant1I(  "iCh2.loaded",       texIsLoaded[2] );
    this.mRenderer.SetShaderConstant1I(  "iCh3.loaded",       texIsLoaded[3] );

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");


    if( (vrData !== null) && this.mSupportsVR )
    {
        for (let i=0; i<2; i++ )
        {
            let ei = (i===0) ? vrData.mLeftEye : vrData.mRightEye;

            let vp = [i * xres / 2, 0, xres / 2, yres];

            this.mRenderer.SetViewport(vp);

            let fov = ei.mProjection;
            let corA = [ -fov[2], -fov[1], -1.0 ];
            let corB = [  fov[3], -fov[1], -1.0 ];
            let corC = [  fov[3],  fov[0], -1.0 ];
            let corD = [ -fov[2],  fov[0], -1.0 ];
            let apex = [ 0.0, 0.0, 0.0 ];

            let ma = invertFast( ei.mCamera );
            corA = matMulpoint( ma, corA ); 
            corB = matMulpoint( ma, corB ); 
            corC = matMulpoint( ma, corC ); 
            corD = matMulpoint( ma, corD ); 
            apex = matMulpoint( ma, apex ); 

            let corners = [ corA[0], corA[1], corA[2], 
                            corB[0], corB[1], corB[2], 
                            corC[0], corC[1], corC[2], 
                            corD[0], corD[1], corD[2],
                            apex[0], apex[1], apex[2]];

            this.mRenderer.SetShaderConstant3FV("unCorners", corners);
            this.mRenderer.SetShaderConstant4FV("unViewport", vp);

            this.mRenderer.DrawUnitQuad_XY(l1);
        }
    }
    else 
    {
        this.mRenderer.SetViewport([0, 0, xres, yres]);
        this.mRenderer.DrawFullScreenTriangle_XY( l1 );
    }

    this.mRenderer.DettachTextures();
}

EffectPass.prototype.iRenderSound = function(d, callback )
{
    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds() ];

    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];

    this.mRenderer.SetRenderTarget(this.mRenderFBO);

    this.mRenderer.SetViewport([0, 0, this.mTextureDimensions, this.mTextureDimensions]);
    this.mRenderer.AttachShader(this.mProgram);
    this.mRenderer.SetBlend( false );

    let texID = [null, null, null, null];
    for (let i = 0; i < this.mInputs.length; i++)
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
    }

    this.mRenderer.AttachTextures(4, texID[0], texID[1], texID[2], texID[3]);

    let l2 = this.mRenderer.SetShaderConstantLocation(this.mProgram, "iTimeOffset");
    let l3 = this.mRenderer.SetShaderConstantLocation(this.mProgram, "iSampleOffset");
    this.mRenderer.SetShaderConstant4FV("iDate", dates);
    this.mRenderer.SetShaderConstant3FV("iChannelResolution", resos);
    this.mRenderer.SetShaderConstant1F("iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit("iChannel0", 0);
    this.mRenderer.SetShaderTextureUnit("iChannel1", 1);
    this.mRenderer.SetShaderTextureUnit("iChannel2", 2);
    this.mRenderer.SetShaderTextureUnit("iChannel3", 3);

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    //--------------------------------
    let numSamples = this.mTmpBufferSamples;
    let numBlocks = this.mPlaySamples / numSamples;
    for (let j=0; j<numBlocks; j++ )
    {
        let off = j*numSamples;
        
        this.mRenderer.SetShaderConstant1F_Pos(l2, off / this.mSampleRate);
        this.mRenderer.SetShaderConstant1I_Pos(l3, off );
        this.mRenderer.DrawUnitQuad_XY(l1);

        this.mRenderer.GetPixelData(this.mData, 0, this.mTextureDimensions, this.mTextureDimensions);

        callback( off, this.mData, numSamples );
    }

    this.mRenderer.DetachShader();
    this.mRenderer.DettachTextures();
    this.mRenderer.SetRenderTarget(null);
}

EffectPass.prototype.Paint_Sound = function( wa, d )
{
    let bufL = this.mBuffer.getChannelData(0); // Float32Array
    let bufR = this.mBuffer.getChannelData(1); // Float32Array

    this.iRenderSound( d, function(off, data, numSamples)
                         {
                            for( let i=0; i<numSamples; i++ )
                            {
                                bufL[off+i] = -1.0 + 2.0*(data[4*i+0]+256.0*data[4*i+1])/65535.0;
                                bufR[off+i] = -1.0 + 2.0*(data[4*i+2]+256.0*data[4*i+3])/65535.0;
                            }
                         }
                     );
}

EffectPass.prototype.SetUniforms = function(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    let times = [ 0.0, 0.0, 0.0, 0.0 ];

    let dates = [ d.getFullYear(), // the year (four digits)
                  d.getMonth(),	   // the month (from 0-11)
                  d.getDate(),     // the day of the month (from 1-31)
                  d.getHours()*60.0*60 + d.getMinutes()*60 + d.getSeconds()  + d.getMilliseconds()/1000.0 ];

    let mouse = [  mousePosX, mousePosY, mouseOriX, mouseOriY ];

    let resos = [ 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0 ];

    //------------------------
    
    let texID = [ null, null, null, null];

    for( let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.image.width;
                resos[3*i+1] = inp.image.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="volume" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = inp.mImage.mXres;
                resos[3*i+1] = inp.mImage.mYres;
                resos[3*i+2] = inp.mImage.mZres;
            }
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
            texID[i] = keyboard.mTexture;
        }
        else if( inp.mInfo.mType=="cubemap" )
        {
            if (inp.loaded === true)
            {
                let id = assetID_to_cubemapBuferID(inp.mInfo.mID);
                if( id!==-1 )
                {
                    texID[i] = cubeBuffers[id].mTexture[ cubeBuffers[id].mLastRenderDone ];
                    resos[3*i+0] = cubeBuffers[id].mResolution[0];
                    resos[3*i+1] = cubeBuffers[id].mResolution[1];
                    resos[3*i+2] = 1;
    
                    // hack. in webgl2.0 we have samplers, so we don't need this crap here
                    let filter = this.mRenderer.FILTER.NONE;
                         if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                    else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                    this.mRenderer.SetSamplerFilter( texID[i], filter, false);
                }
                else
                {
                    texID[i] = inp.globject;
                }
            }

        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    texID[i] = inp.globject;
                    resos[3*i+0] = inp.mImage.width;
                    resos[3*i+1] = inp.mImage.height;
                    resos[3*i+2] = 1;
                }
                else  if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {
                    texID[i] = inp.globject;
                    resos[3*i+0] = inp.video.videoWidth;
                    resos[3*i+1] = inp.video.videoHeight;
                    resos[3*i+2] = 1;
                }
            }
            else 
            {
                texID[i] = null;
                resos[3*i+0] = inp.video.width;
                resos[3*i+1] = inp.video.height;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
           if( inp.loaded===true )
           { 
                times[i] = inp.video.currentTime;
                texID[i] = inp.globject;
                resos[3*i+0] = inp.video.videoWidth;
                resos[3*i+1] = inp.video.videoHeight;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.loaded===true )
            {
                times[i] = inp.audio.currentTime;
                texID[i] = inp.globject;

                if( inp.audio.mForceMuted === true )
                {
                    times[i] = 10.0 + time;
                }

                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                times[i] = 10.0 + time;
            }

            if( inp.loaded===true )
            {
                texID[i] = inp.globject;
                resos[3*i+0] = 512;
                resos[3*i+1] = 2;
                resos[3*i+2] = 1;
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded===true  )
            {
                texID[i] = buffers[inp.id].mTexture[ buffers[inp.id].mLastRenderDone ];
                resos[3*i+0] = buffers[inp.id].mResolution[0];
                resos[3*i+1] = buffers[inp.id].mResolution[1];
                resos[3*i+2] = 1;
            }
        }
    }

    this.mRenderer.AttachTextures( 4, texID[0], texID[1], texID[2], texID[3] );

    //-----------------------------------

    this.mRenderer.AttachShader(this.mProgram);

    this.mRenderer.SetShaderConstant1F(  "iTime", time);
    this.mRenderer.SetShaderConstant3F(  "iResolution", xres, yres, 1.0);
    this.mRenderer.SetShaderConstant4FV( "iMouse", mouse);
    this.mRenderer.SetShaderConstant1FV( "iChannelTime", times );              // OBSOLETE
    this.mRenderer.SetShaderConstant4FV( "iDate", dates );
    this.mRenderer.SetShaderConstant3FV( "iChannelResolution", resos );        // OBSOLETE
    this.mRenderer.SetShaderConstant1F(  "iSampleRate", this.mSampleRate);
    this.mRenderer.SetShaderTextureUnit( "iChannel0", 0 );
    this.mRenderer.SetShaderTextureUnit( "iChannel1", 1 );
    this.mRenderer.SetShaderTextureUnit( "iChannel2", 2 );
    this.mRenderer.SetShaderTextureUnit( "iChannel3", 3 );
    this.mRenderer.SetShaderConstant1I(  "iFrame", this.mFrame );
    this.mRenderer.SetShaderConstant1F(  "iTimeDelta", dtime);
    this.mRenderer.SetShaderConstant1F(  "iFrameRate", fps );

    this.mRenderer.SetShaderConstant1F(  "iChannel[0].time",       times[0] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[1].time",       times[1] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[2].time",       times[2] );
    this.mRenderer.SetShaderConstant1F(  "iChannel[3].time",       times[3] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[0].resolution", resos[0], resos[ 1], resos[ 2] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[1].resolution", resos[3], resos[ 4], resos[ 5] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[2].resolution", resos[6], resos[ 7], resos[ 8] );
    this.mRenderer.SetShaderConstant3F(  "iChannel[3].resolution", resos[9], resos[10], resos[11] );
}

EffectPass.prototype.ProcessInputs = function(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard )
{
    for (let i=0; i<this.mInputs.length; i++ )
    {
        let inp = this.mInputs[i];

        if( inp===null )
        {
        }
        else if( inp.mInfo.mType==="texture" )
        {
        }
        else if( inp.mInfo.mType==="volume" )
        {
        }
        else if( inp.mInfo.mType==="keyboard" )
        {
        }
        else if( inp.mInfo.mType==="cubemap" )
        {
        }
        else if( inp.mInfo.mType==="webcam" )
        {
            if( inp.loaded===true )
            {
                if( inp.mImage !== null )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.mImage, false, 7, 1, -1, this.mID );
                }
                else if( inp.video.readyState === inp.video.HAVE_ENOUGH_DATA )
                {
                    if( this.mTextureCallbackFun!==null )
                        this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 7, 1, -1, this.mID );

                    this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
            }
        }
        else if( inp.mInfo.mType==="video" )
        {
            if( inp.video.mPaused === false )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, inp.video, false, 3, 1, inp.video.currentTime, this.mID );
            }

            if( inp.loaded===true )
            { 
      	        if( inp.video.mPaused === false )
      	        {
      	            this.mRenderer.UpdateTextureFromImage(inp.globject, inp.video);
                    if( inp.mInfo.mSampler.filter === "mipmap" )
                        this.mRenderer.CreateMipmaps(inp.globject);
                }
            }
        }
        else if( inp.mInfo.mType==="music" || inp.mInfo.mType==="musicstream" )
        {
            if( inp.audio.mPaused === false && inp.audio.mForceMuted === false && inp.loaded===true )
            {
                if( wa !== null )
                {
                    inp.audio.mSound.mAnalyser.getByteFrequencyData(  inp.audio.mSound.mFreqData );
                    inp.audio.mSound.mAnalyser.getByteTimeDomainData( inp.audio.mSound.mWaveData );
                }

                if( this.mTextureCallbackFun!==null )
                {
                         if( inp.mInfo.mType==="music")       this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa == null) ? null : { wave : inp.audio.mSound.mFreqData }, false, 4, 1, inp.audio.currentTime, this.mID);
                    else if( inp.mInfo.mType==="musicstream") this.mTextureCallbackFun(this.mTextureCallbackObj, i, (wa == null) ? null : { wave : inp.audio.mSound.mFreqData, info : inp.audio.soundcloudInfo}, false, 8, 1, inp.audio.currentTime, this.mID);
                }
            }

            if( inp.loaded===true )
            {
                if( inp.audio.mForceMuted === true )
                {
                    let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.audio.mSound.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                  //let num = inp.audio.mSound.mFreqData.length;
                    for (let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.audio.mSound.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }

                }

      	        if( inp.audio.mPaused === false )
                {
      	            let waveLen = Math.min(inp.audio.mSound.mWaveData.length, 512);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512, 1, inp.audio.mSound.mFreqData);
      	            this.mRenderer.UpdateTexture(inp.globject, 0, 1, 512, 1, inp.audio.mSound.mWaveData);
                }
            }
        }
        else if( inp.mInfo.mType==="mic" )
        {
            if( inp.loaded===false || inp.mForceMuted || wa === null || inp.mAnalyser == null )
            {
                    let num = inp.mFreqData.length;
                    for( let j=0; j<num; j++ )
                    {
                        let x = j / num;
                        let f =  (0.75 + 0.25*Math.sin( 10.0*j + 13.0*time )) * Math.exp( -3.0*x );

                        if( j<3 )
                            f =  Math.pow( 0.50 + 0.5*Math.sin( 6.2831*time ), 4.0 ) * (1.0-j/3.0);

                        inp.mFreqData[j] = Math.floor(255.0*f) | 0;
                    }

                    for( let j=0; j<num; j++ )
                    {
                        let f = 0.5 + 0.15*Math.sin( 17.0*time + 10.0*6.2831*j/num ) * Math.sin( 23.0*time + 1.9*j/num );
                        inp.mWaveData[j] = Math.floor(255.0*f) | 0;
                    }
            }
            else
            {
                inp.mAnalyser.getByteFrequencyData(  inp.mFreqData );
                inp.mAnalyser.getByteTimeDomainData( inp.mWaveData );
            }

            if( this.mTextureCallbackFun!==null )
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {wave:inp.mFreqData}, false, 5, 1, -1, this.mID );

            if( inp.loaded===true )
            {
                let waveLen = Math.min( inp.mWaveData.length, 512 );
                this.mRenderer.UpdateTexture(inp.globject, 0, 0, 512,     1, inp.mFreqData);
                this.mRenderer.UpdateTexture(inp.globject, 0, 1, waveLen, 1, inp.mWaveData);
            }
        }
        else if( inp.mInfo.mType==="buffer" )
        {
            if( inp.loaded===true  )
            {
                let id = inp.id;
                let texID = buffers[id].mTexture[ buffers[id].mLastRenderDone ];

                // hack. in webgl2.0 we have samplers, so we don't need this crap here
                let filter = this.mRenderer.FILTER.NONE;
                     if (inp.mInfo.mSampler.filter === "linear") filter = this.mRenderer.FILTER.LINEAR;
                else if (inp.mInfo.mSampler.filter === "mipmap") filter = this.mRenderer.FILTER.MIPMAP;
                this.mRenderer.SetSamplerFilter( texID, filter, false);
            }

            if( this.mTextureCallbackFun!==null )
            {
				let id = inp.id;
                this.mTextureCallbackFun( this.mTextureCallbackObj, i, {texture:inp.image, data:buffers[id].mThumbnailBuffer}, false, 9, 1, -1, this.mID );
            }
        }
    }
}

EffectPass.prototype.Paint_Cubemap = function( vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face )
{
    this.ProcessInputs(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face );
    this.SetUniforms(vrData, wa, d, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );

    let l1 = this.mRenderer.GetAttribLocation(this.mProgram, "pos");

    let vp = [0, 0, xres, yres];

    this.mRenderer.SetViewport(vp);

    let corA = [ -1.0, -1.0, -1.0 ];
    let corB = [  1.0, -1.0, -1.0 ];
    let corC = [  1.0,  1.0, -1.0 ];
    let corD = [ -1.0,  1.0, -1.0 ];
    let apex = [  0.0,  0.0,  0.0 ];

    if( face===0 )
    {
        corA = [  1.0,  1.0,  1.0 ];
        corB = [  1.0,  1.0, -1.0 ];
        corC = [  1.0, -1.0, -1.0 ];
        corD = [  1.0, -1.0,  1.0 ];
    }
    else if( face===1 ) // -X
    {
        corA = [ -1.0,  1.0, -1.0 ];
        corB = [ -1.0,  1.0,  1.0 ];
        corC = [ -1.0, -1.0,  1.0 ];
        corD = [ -1.0, -1.0, -1.0 ];
    }
    else if( face===2 ) // +Y
    {
        corA = [ -1.0,  1.0, -1.0 ];
        corB = [  1.0,  1.0, -1.0 ];
        corC = [  1.0,  1.0,  1.0 ];
        corD = [ -1.0,  1.0,  1.0 ];
    }
    else if( face===3 ) // -Y
    {
        corA = [ -1.0, -1.0,  1.0 ];
        corB = [  1.0, -1.0,  1.0 ];
        corC = [  1.0, -1.0, -1.0 ];
        corD = [ -1.0, -1.0, -1.0 ];
    }
    else if( face===4 ) // +Z
    {
        corA = [ -1.0,  1.0,  1.0 ];
        corB = [  1.0,  1.0,  1.0 ];
        corC = [  1.0, -1.0,  1.0 ];
        corD = [ -1.0, -1.0,  1.0 ];
    }
    else //if( face===5 ) // -Z
    {
        corA = [  1.0,  1.0, -1.0 ];
        corB = [ -1.0,  1.0, -1.0 ];
        corC = [ -1.0, -1.0, -1.0 ];
        corD = [  1.0, -1.0, -1.0 ];
    }

    let corners = [ corA[0], corA[1], corA[2], 
                    corB[0], corB[1], corB[2], 
                    corC[0], corC[1], corC[2], 
                    corD[0], corD[1], corD[2],
                    apex[0], apex[1], apex[2]];

    this.mRenderer.SetShaderConstant3FV("unCorners", corners);
    this.mRenderer.SetShaderConstant4FV("unViewport", vp);

    this.mRenderer.DrawUnitQuad_XY(l1);

    this.mRenderer.DettachTextures();
}


EffectPass.prototype.Paint = function( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, bufferNeedsMimaps, buffers, cubeBuffers, keyboard, effect )
{
    if( this.mType==="sound" )
    {
        if (this.mSoundShaderCompiled === true)
        {
            // make sure all textures are loaded
            for (let i=0; i<this.mInputs.length; i++ )
            {
                let inp = this.mInputs[i];
                if (inp === null) continue;

                if (inp.mInfo.mType === "texture" && !inp.loaded) return;
                if (inp.mInfo.mType === "cubemap" && !inp.loaded) return;
            }

            this.Paint_Sound(wa, da);
            this.mSoundShaderCompiled = false;
        }
        if (this.mFrame === 0)
        {
            if (this.mPlaying===true)
            {
                this.mPlayNode.disconnect();
                this.mPlayNode.stop();
                this.mPlayNode = null;
            }
            this.mPlaying = true;

            this.mPlayNode = wa.createBufferSource();
            this.mPlayNode.buffer = this.mBuffer;
            this.mPlayNode.connect(this.mGainNode);
            this.mPlayNode.start(0);
        }
        this.mFrame++;
    }
    else if( this.mType==="image" )
    {
        this.mRenderer.SetRenderTarget( null );
        this.Paint_Image( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );
        this.mFrame++;
    }
    else if( this.mType==="common" )
    {
        //console.log("rendering common");
    }
    else if( this.mType==="buffer" )
    {
        this.mEffect.ResizeBuffer(bufferID, this.mEffect.mXres, this.mEffect.mYres, false );

        let buffer = buffers[bufferID];

        let dstID = 1 - buffer.mLastRenderDone;

        this.mRenderer.SetRenderTarget( buffer.mTarget[dstID] );
        this.Paint_Image( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard );

        // compute mipmaps if needd
        if( bufferNeedsMimaps )
        {
            this.mRenderer.CreateMipmaps( buffer.mTexture[dstID]);
        }

        // make thumbnail
        //if( this.mTextureCallbackFun != null )
        /*
        {
            this.mRenderer.SetRenderTarget( buffer.mThumbnailRenderTarget );
            let v = [0, 0, buffer.mThumbnailRes[0], buffer.mThumbnailRes[1]];
            this.mRenderer.SetBlend(false);
            this.mRenderer.SetViewport(v);
            this.mRenderer.AttachShader(this.mProgramCopy);
            let l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, "pos");
            this.mRenderer.SetShaderConstant4FV("v", v);
            this.mRenderer.AttachTextures(1, buffer.mTexture[dstID], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);
            this.mRenderer.DettachTextures();
            this.mRenderer.DetachShader();
            this.mRenderer.GetPixelData( new Uint8Array(buffer.mThumbnailBuffer.data.buffer), buffer.mThumbnailRes[0], buffer.mThumbnailRes[1] );
            this.mRenderer.SetRenderTarget(null);
        }
        */
        buffers[bufferID].mLastRenderDone = 1 - buffers[bufferID].mLastRenderDone;
        this.mFrame++;
    }
    else if( this.mType==="cubemap" )
    {
        this.mEffect.ResizeCubemapBuffer(bufferID, 1024, 1024, false );

        let buffer = cubeBuffers[bufferID];

        xres = buffer.mResolution[0];
        yres = buffer.mResolution[1];
        let dstID = 1 - buffer.mLastRenderDone;
        for( let face=0; face<6; face++ )
        {
            this.mRenderer.SetRenderTargetCubeMap( buffer.mTarget[dstID], face );
            this.Paint_Cubemap( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, buffers, cubeBuffers, keyboard, face );
        }
        this.mRenderer.SetRenderTargetCubeMap( null, 0 );

        // compute mipmaps if needd
        if( bufferNeedsMimaps )
        {
            this.mRenderer.CreateMipmaps( buffer.mTexture[dstID]);
        }
        cubeBuffers[bufferID].mLastRenderDone = 1 - cubeBuffers[bufferID].mLastRenderDone;

        this.mFrame++;
    }

}

EffectPass.prototype.StopOutput_Sound = function( wa )
{
    if( this.mPlayNode===null ) return;
    this.mPlayNode.disconnect();

};

EffectPass.prototype.ResumeOutput_Sound = function( wa )
{
    if( this.mPlayNode===null ) return;

    wa.resume()
    this.mPlayNode.connect( this.mGainNode );
};

EffectPass.prototype.StopOutput_Image = function( wa )
{
};

EffectPass.prototype.ResumeOutput_Image = function( wa )
{
};

EffectPass.prototype.StopOutput = function( wa )
{
    for (let j=0; j<this.mInputs.length; j++ )
        this.StopInput(j);

    if( this.mType==="sound" )
         this.StopOutput_Sound( wa );
    else
         this.StopOutput_Image( wa );
}

EffectPass.prototype.ResumeOutput = function( wa )
{
    for (let j=0; j<this.mInputs.length; j++ )
        this.ResumeInput(j);

    if( this.mType==="sound" )
         this.ResumeOutput_Sound( wa );
    else
         this.ResumeOutput_Image( wa );
}

EffectPass.prototype.GetCompilationTime = function()
{
    return this.mCompilationTime;
}

//============================================================================================================
function Screenshots()
{
    // private
    let mTexture = null;
    let mTarget = null;
    let mXres = 0;
    let mYres = 0;
    let mCubemapToEquirectProgram;
    let mRenderer = null;

    // public
    var me = {};

    me.Initialize = function(renderer)
    {
        mRenderer = renderer;
        let caps = mRenderer.GetCaps();
        let is20 = caps.mIsGL20;


        let vsSourceC, fsSourceC;
        if( is20 )
        {
            vsSourceC = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
            fsSourceC = "uniform samplerCube t; out vec4 outColor; void main() { vec2 px = gl_FragCoord.xy/vec2(4096.0,2048.0); vec2 an = 3.1415926535898 * (px*vec2(2.0, 1.0) - vec2(0.0,0.5)); vec3 rd = vec3(-cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x)); outColor = texture(t, rd); }";
        }
        else
        {
            vsSourceC = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
            fsSourceC = "uniform samplerCube t; void main() { vec2 px = gl_FragCoord.xy/vec2(4096.0,2048.0); vec2 an = 3.1415926535898 * (px*vec2(2.0, 1.0) - vec2(0.0,0.5)); vec3 rd = vec3(-cos(an.y) * sin(an.x), sin(an.y), cos(an.y) * cos(an.x)); gl_FragColor = texture(t, rd); }";
        }

        let compileShader = function (worked, info)
        {
            if (worked === false)
            {
                console.log("Failed to compile cubemap resample shader (" + errorType + "): " + log);
            }
            else
            {
                mCubemapToEquirectProgram = info;
            }
        }
        mRenderer.CreateShader(vsSourceC, fsSourceC, false, true, compileShader);

        return true;
    };

    me.Allocate = function( xres, yres )
    {
        if( xres>mXres || yres>mYres )
        {
            let texture = mRenderer.CreateTexture(mRenderer.TEXTYPE.T2D, xres, yres, mRenderer.TEXFMT.C4F32, mRenderer.FILTER.NONE, mRenderer.TEXWRP.CLAMP, null);
            let target = mRenderer.CreateRenderTarget( texture, null, null, null, null, false);

            if( mXres!==0 )
            {
                mRenderer.DestroyTexture(mTexture);
                mRenderer.DestroyRenderTarget(mTarget);
            }

            mTexture = texture;
            mTarget = target;
            mXres = xres;
            mYres = yres;
        }
    };

    me.GetProgram = function()
    {
        return mCubemapToEquirectProgram;
    };
    me.GetTarget = function()
    {
        return mTarget;
    };

    return me;
};

//============================================================================================================

function Effect(vr, ac, canvas, callback, obj, forceMuted, forcePaused, resizeCallback, crashCallback )
{
    let xres = canvas.width;
    let yres = canvas.height;

    let me = this;
    this.mCanvas = canvas;
    this.mCreated = false;
    this.mRenderer = null;
    this.mAudioContext = ac;
    this.mGLContext = null;
    this.mWebVR = vr;
    this.mRenderingStereo = false;
    this.mXres = xres;
    this.mYres = yres;
    this.mForceMuted = forceMuted;
    if( ac===null ) this.mForceMuted = true;
    this.mForcePaused = forcePaused;
    this.mGainNode = null;
    this.mPasses = [];
    this.mFrame = 0;
    this.mTextureCallbackFun = callback;
    this.mTextureCallbackObj = obj;
    this.mMaxBuffers = 4;
    this.mMaxCubeBuffers = 1;
    this.mMaxPasses = this.mMaxBuffers + 1 + 1 + 1 + 1; // some day decouple passes from buffers (4 buffers + common + Imagen + sound + cubemap)
    this.mBuffers = [];
    this.mCubeBuffers = [];
    this.mScreenshotSytem = null;
    this.mCompilationTime = 0;
    this.mIsLowEnd = piIsMobile();

    this.mGLContext = piCreateGlContext(canvas, false, false, true, false); // need preserve-buffe to true in order to capture screenshots
    if (this.mGLContext === null)
    {
        return;
    }

    canvas.addEventListener("webglcontextlost", function (event)
        {
            event.preventDefault();
            crashCallback();
        }, false);

    this.mRenderer = piRenderer();
    if (!this.mRenderer.Initialize(this.mGLContext))
        return;

    this.mScreenshotSytem = Screenshots();
    if (!this.mScreenshotSytem.Initialize(this.mRenderer))
        return;

    var caps = this.mRenderer.GetCaps();
    this.mIs20 = caps.mIsGL20;
    this.mShaderTextureLOD = caps.mShaderTextureLOD;
    //-------------
    if( ac!==null )
    {   
        this.mGainNode = ac.createGain();
        if( !forceMuted )
        {
            this.mGainNode.connect( ac.destination);
        }
        if (this.mForceMuted )
            this.mGainNode.gain.value = 0.0;
        else
            this.mGainNode.gain.value = 1.0;
    }

    //-------------
    let vsSourceC, fsSourceC;
    if( this.mIs20 )
    {
        vsSourceC = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceC = "uniform vec4 v; uniform sampler2D t; out vec4 outColor; void main() { outColor = textureLod(t, gl_FragCoord.xy / v.zw, 0.0); }";
    }
    else
    {
        vsSourceC = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceC = "uniform vec4 v; uniform sampler2D t; void main() { gl_FragColor = texture2D(t, gl_FragCoord.xy / v.zw, -100.0); }";
    }

    this.mRenderer.CreateShader(vsSourceC, fsSourceC, false, true, function(worked, info)
        {
            if (worked === false) console.log("Failed to compile shader to copy buffers : " + info.mErrorStr);
            else me.mProgramCopy = info;
        });

    let vsSourceD, fsSourceD;
    if( this.mIs20 )
    {
        vsSourceD = "layout(location = 0) in vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceD = "uniform vec4 v; uniform sampler2D t; out vec4 outColor; void main() { vec2 uv = gl_FragCoord.xy / v.zw; outColor = texture(t, vec2(uv.x,1.0-uv.y)); }";
    }
    else
    {
        vsSourceD = "attribute vec2 pos; void main() { gl_Position = vec4(pos.xy,0.0,1.0); }";
        fsSourceD = "uniform vec4 v; uniform sampler2D t; void main() { vec2 uv = gl_FragCoord.xy / v.zw; gl_FragColor = texture2D(t, vec2(uv.x,1.0-uv.y)); }";
    }

    this.mRenderer.CreateShader(vsSourceD, fsSourceD, false, true, function (worked, info)
        {
            if (worked === false) console.log("Failed to compile shader to downscale buffers : " + info.mErrorStr);
            else me.mProgramDownscale = info;
        });


    // set all buffers and cubemaps to null
    for( let i=0; i<this.mMaxBuffers; i++ )
    {
        this.mBuffers[i] = { mTexture: [null, null], 
                             mTarget:  [null, null], 
                             mResolution: [0, 0],
                             mLastRenderDone: 0,
                             mThumbnailRenderTarget: null,
                             mThumbnailTexture: null,
                             mThumbnailBuffer:  null,
                             mThumbnailRes: [0, 0] };
    }

    for( let i=0; i<this.mMaxCubeBuffers; i++ )
    {
        this.mCubeBuffers[i] = { mTexture: [null, null], 
                                mTarget:  [null, null], 
                                mResolution: [0, 0],
                                mLastRenderDone: 0,
                                mThumbnailRenderTarget: null,
                                mThumbnailTexture: null,
                                mThumbnailBuffer:  null,
                                mThumbnailRes: [0, 0] };
    }

    //-------

    let keyboardData = new Uint8Array( 256*3 );
    for (let j=0; j<(256*3); j++ ) { keyboardData[j] = 0; }
    let kayboardTexture = this.mRenderer.CreateTexture( this.mRenderer.TEXTYPE.T2D, 256, 3, this.mRenderer.TEXFMT.C1I8, this.mRenderer.FILTER.NONE, this.mRenderer.TEXWRP.CLAMP, null);
    let keyboardImage = new Image();
    if( callback!==null )
        keyboardImage.src = "/img/keyboard.png"; // don't load PNG if no UI 
    this.mKeyboard = { mData: keyboardData, mTexture: kayboardTexture, mIcon: keyboardImage };

    let iResize = function( xres, yres )
    {
        me.mCanvas.width = xres;
        me.mCanvas.height = yres;
        me.mXres = xres;
        me.mYres = yres;
        me.ResizeBuffers(xres, yres);
        resizeCallback(xres, yres);
    };

    let bestAttemptFallback = function()
    {
        let devicePixelRatio = window.devicePixelRatio || 1;
        let xres = Math.round(me.mCanvas.offsetWidth  * devicePixelRatio) | 0;
        let yres = Math.round(me.mCanvas.offsetHeight * devicePixelRatio) | 0;
        iResize(xres, yres);
    };

    if(!window.ResizeObserver)
    {
        console.log("WARNING: This browser doesn't support ResizeObserver.");
        bestAttemptFallback();
        window.addEventListener("resize", bestAttemptFallback);
    }
    else
    {
        this.mRO = new ResizeObserver( function(entries, observer)
        {
            var entry = entries[0];
            if (!entry['devicePixelContentBoxSize'])
            {
                observer.unobserve(me.mCanvas);
                console.log("WARNING: This browser doesn't support ResizeObserver + device-pixel-content-box (2)");
                bestAttemptFallback();
                window.addEventListener("resize", bestAttemptFallback);
            }
            else
            {
                let box = entry.devicePixelContentBoxSize[0];
                let xres = box.inlineSize;
                let yres = box.blockSize;
                iResize(xres, yres);
            }
        });
        try
        {
            this.mRO.observe(this.mCanvas, { box: ["device-pixel-content-box"] });
            //this.mRO.observe(this.mCanvas);
        }
        catch (e)
        {
            console.log("WARNING: This browser doesn't support ResizeObserver + device-pixel-content-box (1)");
            bestAttemptFallback();
            window.addEventListener("resize", bestAttemptFallback);
        }
    }

    this.mCreated = true;
}


Effect.prototype.ResizeCubemapBuffer = function(i, xres, yres )
{
    let oldXres = this.mCubeBuffers[i].mResolution[0];
    let oldYres = this.mCubeBuffers[i].mResolution[1];

    if( this.mCubeBuffers[i].mTexture[0]===null || oldXres !== xres || oldYres !== yres )
    {
        let texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.CUBEMAP,
            xres, yres,
            this.mRenderer.TEXFMT.C4F16,
            this.mRenderer.FILTER.LINEAR,
            this.mRenderer.TEXWRP.CLAMP, 
            null);
        let target1 = this.mRenderer.CreateRenderTargetCubeMap( texture1, null, false);

        let texture2 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.CUBEMAP,
            xres, yres,
            this.mRenderer.TEXFMT.C4F16,
            this.mRenderer.FILTER.LINEAR,
            this.mRenderer.TEXWRP.CLAMP, 
            null);

        let target2 = this.mRenderer.CreateRenderTargetCubeMap( texture2, null, false);

        // Store new buffers
        this.mCubeBuffers[i].mTexture = [texture1,texture2], 
        this.mCubeBuffers[i].mTarget =  [target1, target2 ], 
        this.mCubeBuffers[i].mLastRenderDone = 0;
        this.mCubeBuffers[i].mResolution[0] = xres;
        this.mCubeBuffers[i].mResolution[1] = yres;
    }
}


Effect.prototype.ResizeBuffer = function( i, xres, yres, skipIfNotExists )
{
    if( skipIfNotExists && this.mBuffers[i].mTexture[0]===null ) return;

    let oldXres = this.mBuffers[i].mResolution[0];
    let oldYres = this.mBuffers[i].mResolution[1];

    if( oldXres !== xres || oldYres !== yres )
    {
        let needCopy = (this.mBuffers[i].mTexture[0]!==null);

        let texture1 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,
            xres, yres,
            this.mRenderer.TEXFMT.C4F32,
            (needCopy) ? this.mBuffers[i].mTexture[0].mFilter : this.mRenderer.FILTER.NONE,
            (needCopy) ? this.mBuffers[i].mTexture[0].mWrap   : this.mRenderer.TEXWRP.CLAMP, 
            null);

        let texture2 = this.mRenderer.CreateTexture(this.mRenderer.TEXTYPE.T2D,
            xres, yres,
            this.mRenderer.TEXFMT.C4F32,
            (needCopy) ? this.mBuffers[i].mTexture[1].mFilter : this.mRenderer.FILTER.NONE,
            (needCopy) ? this.mBuffers[i].mTexture[1].mWrap   : this.mRenderer.TEXWRP.CLAMP, 
            null);

        let target1 = this.mRenderer.CreateRenderTarget( texture1, null, null, null, null, false);
        let target2 = this.mRenderer.CreateRenderTarget( texture2, null, null, null, null, false);

        if( needCopy )
        {
            let v = [0, 0, Math.min(xres, oldXres), Math.min(yres, oldYres)];
            this.mRenderer.SetBlend(false);
            this.mRenderer.SetViewport(v);
            this.mRenderer.AttachShader(this.mProgramCopy);
            let l1 = this.mRenderer.GetAttribLocation(this.mProgramCopy, "pos");
            let vOld = [0, 0, oldXres, oldYres];
            this.mRenderer.SetShaderConstant4FV("v", vOld);

            // Copy old buffers 1 to new buffer
            this.mRenderer.SetRenderTarget(target1);
            this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[0], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);

            // Copy old buffers 2 to new buffer
            this.mRenderer.SetRenderTarget(target2);
            this.mRenderer.AttachTextures(1, this.mBuffers[i].mTexture[1], null, null, null);
            this.mRenderer.DrawUnitQuad_XY(l1);

            // Deallocate old memory
            this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[0]);
            this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[0]);
            this.mRenderer.DestroyTexture(this.mBuffers[i].mTexture[1]);
            this.mRenderer.DestroyRenderTarget(this.mBuffers[i].mTarget[1]);
            //this.mRenderer.DestroyTexture(this.mBuffers[i].thumbnailTexture);
        }

        // Store new buffers
        this.mBuffers[i].mTexture = [texture1,texture2], 
        this.mBuffers[i].mTarget =  [target1, target2 ], 
        this.mBuffers[i].mLastRenderDone = 0;
        this.mBuffers[i].mResolution[0] = xres;
        this.mBuffers[i].mResolution[1] = yres;
    }
}

Effect.prototype.saveScreenshot = function(passid)
{
    let pass = this.mPasses[passid];

    if( pass.mType === "buffer" )
    {
        let bufferID = assetID_to_bufferID( this.mPasses[passid].mOutputs[0] );

        let texture = this.mBuffers[bufferID].mTarget[ this.mBuffers[bufferID].mLastRenderDone ];

        let numComponents = 3;
        let width = texture.mTex0.mXres;
        let height = texture.mTex0.mYres;
        let type = "Float"; // Other options Float, Half, Uint
        let bytes = new Float32Array(width * height * 4 );//numComponents);
        this.mRenderer.GetPixelDataRenderTarget( texture, bytes, width, height );
        let blob = piExportToEXR(width, height, numComponents, type, bytes);

        // Offer download automatically to the user
        piTriggerDownload("image.exr", blob);
    }
    else if( pass.mType === "cubemap" )
    {
        let xres = 4096;
        let yres = 2048;
        this.mScreenshotSytem.Allocate( xres, yres );

        let cubeBuffer = this.mCubeBuffers[0];

        let target = this.mScreenshotSytem.GetTarget();
        this.mRenderer.SetRenderTarget( target );

        let program = this.mScreenshotSytem.GetProgram();

        this.mRenderer.AttachShader(program);
        let l1 = this.mRenderer.GetAttribLocation(program, "pos");
        this.mRenderer.SetViewport( [0, 0, xres, yres] );
        this.mRenderer.AttachTextures(1, cubeBuffer.mTexture[ cubeBuffer.mLastRenderDone ], null, null, null);
        this.mRenderer.DrawUnitQuad_XY(l1);
        this.mRenderer.DettachTextures();
        this.mRenderer.SetRenderTarget( null );

        let data = new Float32Array(xres*yres*4);
        this.mRenderer.GetPixelDataRenderTarget( target, data, xres, yres );

        let blob = piExportToEXR(xres, yres, 3, "Float", data );
        piTriggerDownload("image.exr", blob);
    }
    else if( pass.mType === "sound" )
    {
        let offset = 0;
        const bits = 16;
        const numChannels = 2;
        let words = new Int16Array(60*pass.mSampleRate*numChannels );

        pass.iRenderSound( new Date(), function(off, data, numSamples)
                                         {
                                            for( let i=0; i<numSamples; i++ )
                                            {
                                                words[offset++] = (data[4*i+0]+256.0*data[4*i+1]) - 32767;
                                                words[offset++] = (data[4*i+2]+256.0*data[4*i+3]) - 32767;
                                            }
                                         }
                                     );

        let blob = piExportToWAV( 60*pass.mSampleRate, pass.mSampleRate, bits, numChannels, words);

        piTriggerDownload("sound.wav", blob);
    }    
}

Effect.prototype.ResizeBuffers = function(xres, yres)
{
    for (let i=0; i<this.mMaxBuffers; i++ )
    {
        this.ResizeBuffer(i, xres, yres, true);
    }
}

Effect.prototype.IsEnabledVR = function ()
{
    if (this.mRenderingStereo) return true;
    return false;
}

Effect.prototype.EnableVR = function()
{
    if( !this.mWebVR.IsSupported() ) return;
    if( this.mRenderingStereo ) return;

    this.mRenderingStereo = true;
    this.mWebVR.Enable();
}

Effect.prototype.DisableVR = function()
{
    if( !this.mWebVR.IsSupported() ) return;
    if( !this.mRenderingStereo ) return;

    this.mRenderingStereo = false;
    this.mWebVR.Disable();
}

Effect.prototype.GetTexture = function( passid, slot )
{
    return this.mPasses[passid].GetTexture( slot );
}

Effect.prototype.NewTexture = function( passid, slot, url )
{
    return this.mPasses[passid].NewTexture( this.mAudioContext, slot, url, this.mBuffers, this.mCubeBuffers, this.mKeyboard );
}

Effect.prototype.SetOutputs = function( passid, slot, url )
{
    this.mPasses[passid].SetOutputs( slot, url );
}

Effect.prototype.SetOutputsByBufferID = function( passid, slot, id )
{
    this.mPasses[passid].SetOutputsByBufferID( slot, id );
}

Effect.prototype.GetAcceptsLinear = function (passid, slot) 
{
    return this.mPasses[passid].GetAcceptsLinear(slot);
}

Effect.prototype.GetAcceptsMipmapping = function (passid, slot) 
{
    return this.mPasses[passid].GetAcceptsMipmapping(slot);
}

Effect.prototype.GetAcceptsWrapRepeat = function (passid, slot) 
{
    return this.mPasses[passid].GetAcceptsWrapRepeat(slot);
}

Effect.prototype.GetAcceptsVFlip = function (passid, slot)
{
    return this.mPasses[passid].GetAcceptsVFlip(slot);
}

Effect.prototype.SetSamplerFilter = function (passid, slot, str) 
{
    this.mPasses[passid].SetSamplerFilter(slot, str, this.mBuffers, this.mCubeBuffers);
}

Effect.prototype.GetTranslatedShaderSource = function (passid)
{
    return this.mPasses[passid].GetTranslatedShaderSource();
}

Effect.prototype.GetSamplerFilter = function (passid, slot) {
    return this.mPasses[passid].GetSamplerFilter(slot);
}

Effect.prototype.SetSamplerWrap = function (passid, slot, str) {
    this.mPasses[passid].SetSamplerWrap(slot, str, this.mBuffers);
}

Effect.prototype.GetSamplerWrap = function (passid, slot) {
    return this.mPasses[passid].GetSamplerWrap(slot);
}

Effect.prototype.SetSamplerVFlip = function (passid, slot, str) {
    this.mPasses[passid].SetSamplerVFlip(slot, str);
}

Effect.prototype.GetSamplerVFlip = function (passid, slot) {
    return this.mPasses[passid].GetSamplerVFlip(slot);
}

Effect.prototype.GetHeaderSize = function (passid)
{
    return this.mPasses[passid].mHeaderLength + 
           this.mRenderer.GetShaderHeaderLines(1);
 
}

Effect.prototype.ToggleVolume = function()
{
    this.mForceMuted = !this.mForceMuted;

    // outp
    if (this.mForceMuted)
        this.mGainNode.gain.value = 0.0;
    else
        this.mGainNode.gain.value = 1.0;

    // inp
    let num = this.mPasses.length;
    for( let j=0; j<num; j++ )
    {
        for( let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            if( this.mForceMuted )
                this.mPasses[j].MuteInput( this.mAudioContext, i );
            else
                this.mPasses[j].UnMuteInput( this.mAudioContext, i );
        }
    }

    return this.mForceMuted;
}

Effect.prototype.SetKeyDown = function( passid, k )
{
    if( this.mKeyboard.mData[ k + 0*256 ] == 255 ) return;

    this.mKeyboard.mData[ k + 0*256 ] = 255;
    this.mKeyboard.mData[ k + 1*256 ] = 255;
    this.mKeyboard.mData[ k + 2*256 ] = 255 - this.mKeyboard.mData[ k + 2*256 ];
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    let num = this.mPasses.length;
    for (let j=0; j<num; j++ )
    {
        for (let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            let inp = this.mPasses[j].mInputs[i];
            if( inp!==null && inp.mInfo.mType==="keyboard" )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:this.mKeyboard.mIcon, mData: this.mKeyboard.mData}, false, 6, 1, -1.0, this.mPasses[j].mID );
            }
        }
    }
}

Effect.prototype.SetKeyUp = function( passid, k )
{
    this.mKeyboard.mData[ k + 0*256 ] = 0;
    this.mKeyboard.mData[ k + 1*256 ] = 0;
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    let num = this.mPasses.length;
    for (let j=0; j<num; j++ )
    {
        for (let i=0; i<this.mPasses[j].mInputs.length; i++ )
        {
            let inp = this.mPasses[j].mInputs[i];
            if( inp!==null && inp.mInfo.mType==="keyboard" )
            {
                if( this.mTextureCallbackFun!==null )
                    this.mTextureCallbackFun( this.mTextureCallbackObj, i, {mImage:this.mKeyboard.mIcon, mData: this.mKeyboard.mData}, false, 6, 1, -1.0, this.mPasses[j].mID );
            }
        }
    }

}

Effect.prototype.StopOutputs = function()
{
    let wa = this.mAudioContext;

    let num = this.mPasses.length;
    for (let i=0; i<num; i++ )
    {
        this.mPasses[i].StopOutput( wa );
    }
}

Effect.prototype.ResumeOutputs = function()
{
    let wa = this.mAudioContext;

    let num = this.mPasses.length;
    for (let i=0; i<num; i++ )
    {
        this.mPasses[i].ResumeOutput( wa );
    }
}

Effect.prototype.PauseInput = function( passid, id )
{
    return this.mPasses[passid].TooglePauseInput( this.mAudioContext, id );
}

Effect.prototype.ToggleMuteInput = function( passid, id )
{
    return this.mPasses[passid].ToggleMuteInput( this.mAudioContext, id );
}

Effect.prototype.RewindInput = function( passid, id )
{
    this.mPasses[passid].RewindInput( this.mAudioContext, id );
}

Effect.prototype.UpdateInputs = function( passid, forceUpdate )
{
   this.mPasses[passid].UpdateInputs( this.mAudioContext, forceUpdate, this.mKeyboard );
}

Effect.prototype.ResetTime = function()
{
    this.mFrame = 0;
    this.mAudioContext.resume()

    let num = this.mPasses.length;
    for( let i=0; i<num; i++ )
    {
        this.mPasses[i].mFrame = 0;
        for( let j=0; j<this.mPasses[i].mInputs.length; j++ )
            this.mPasses[i].RewindInput(this.mAudioContext, j)
    }
}

Effect.prototype.RequestAnimationFrame = function (id)
{
    if (this.mRenderingStereo && this.mWebVR.IsPresenting())
    {
        this.mWebVR.RequestAnimationFrame(id);
    }
    else
    {
        requestAnimFrame(id);
    }
}

Effect.prototype.Paint = function(time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, isPaused)
{
    let wa = this.mAudioContext;
    let da = new Date();
    let vrData = null; if (this.mRenderingStereo) vrData = this.mWebVR.GetData();
    let xres = this.mXres / 1;
    let yres = this.mYres / 1;

    if( this.mFrame===0 )
    {
        for( let i=0; i<this.mMaxBuffers; i++ )
        {
            if( this.mBuffers[i].mTexture[0]!==null )
            {
                this.mRenderer.SetRenderTarget( this.mBuffers[i].mTarget[0] );
                this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
                this.mRenderer.SetRenderTarget( this.mBuffers[i].mTarget[1] );
                this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
				
				this.mRenderer.CreateMipmaps( this.mBuffers[i].mTexture[0] );
				this.mRenderer.CreateMipmaps( this.mBuffers[i].mTexture[1] );
            }
        }
        for( let i=0; i<this.mMaxCubeBuffers; i++ )
        {
            if( this.mCubeBuffers[i].mTexture[0]!==null )
            {
                for( let face=0; face<6; face++ )
                {
                    this.mRenderer.SetRenderTargetCubeMap( this.mCubeBuffers[i].mTarget[0], face );
                    this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
                    this.mRenderer.SetRenderTargetCubeMap( this.mCubeBuffers[i].mTarget[1], face );
                    this.mRenderer.Clear( this.mRenderer.CLEAR.Color, [0.0,0.0,0.0,0.0], 1.0, 0   );
					this.mRenderer.CreateMipmaps( this.mCubeBuffers[i].mTexture[0] );
				    this.mRenderer.CreateMipmaps( this.mCubeBuffers[i].mTexture[1] );
                }
            }
        }
    }

    let num = this.mPasses.length;

    // render sound first
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "sound" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, null, false, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render buffers second
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "buffer" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        let bufferID = assetID_to_bufferID( this.mPasses[i].mOutputs[0] );

        // check if any downstream pass needs mipmaps when reading from this buffer
        let needMipMaps = false;
        for (let j=0; j<num; j++ )
        {
            for (let k=0; k<this.mPasses[j].mInputs.length; k++ )
            {
                let inp = this.mPasses[j].mInputs[k];
                if( inp!==null && inp.mInfo.mType==="buffer" && inp.id === bufferID && inp.mInfo.mSampler.filter === "mipmap")
                {
                    needMipMaps = true;
                    break;
                }
            }
        }

        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, needMipMaps, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }


    // render cubemap buffers second
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "cubemap" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        let bufferID = 0;//assetID_to_bufferID( this.mPasses[i].mOutputs[0] );

        // check if any downstream pass needs mipmaps when reading from this buffer
        let needMipMaps = false;

        for (let j=0; j<num; j++ )
        {
            for (let k=0; k<this.mPasses[j].mInputs.length; k++ )
            {
                let inp = this.mPasses[j].mInputs[k];
                if( inp!==null && inp.mInfo.mType==="cubemap" )
                {
                    if( assetID_to_cubemapBuferID(inp.mInfo.mID)===0 && inp.mInfo.mSampler.filter === "mipmap" )
                    {
                        needMipMaps = true;
                        break;
                    }
                }
            }
        }

        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, bufferID, needMipMaps, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }

    // render image last
    for( let i=0; i<num; i++ )
    {
        if( this.mPasses[i].mType !== "image" ) continue;
        if( this.mPasses[i].mProgram===null ) continue;
        this.mPasses[i].Paint( vrData, wa, da, time, dtime, fps, mouseOriX, mouseOriY, mousePosX, mousePosY, xres, yres, isPaused, null, false, this.mBuffers, this.mCubeBuffers, this.mKeyboard, this );
    }   

    // erase keypresses
    for (let k=0; k<256; k++ )
    {
       this.mKeyboard.mData[ k + 1*256 ] = 0;
    }
    this.mRenderer.UpdateTexture( this.mKeyboard.mTexture, 0, 0, 256, 3, this.mKeyboard.mData );

    if( this.mRenderingStereo ) this.mWebVR.Finish();

    this.mFrame++;
}

Effect.prototype.NewShader = function( passid, preventCache, onResolve )
{
    let commonSourceCodes = [];
    for (let i=0; i<this.mPasses.length; i++ )
    {
        if( this.mPasses[i].mType==="common")
        {
            commonSourceCodes.push(this.mPasses[i].mSource);
        }
    }

    this.mPasses[passid].NewShader(commonSourceCodes, preventCache, onResolve );
}

Effect.prototype.GetNumPasses = function()
{
    return this.mPasses.length;
}

Effect.prototype.GetNumOfType = function(passtype)
{
    let id = 0;
    for (let j=0; j<this.mPasses.length; j++ )
    {
        if( this.mPasses[j].mType===passtype )
        {
            id++;
        }
    }
    return id;
}

Effect.prototype.GetPassType = function( id )
{
    return this.mPasses[id].mType;
}
Effect.prototype.GetPassName = function( id )
{
    return this.mPasses[id].mName;
}
Effect.prototype.GetCode = function( id )
{
    return this.mPasses[id].mSource;
}
Effect.prototype.SetCode = function( id, source )
{
    this.mPasses[id].SetCode(source);
}
Effect.prototype.GetError = function (id)
{
    return this.mPasses[id].mError;
}
Effect.prototype.GetErrorStr = function (id)
{
    return this.mPasses[id].mErrorStr;
}
Effect.prototype.GetErrorGlobal = function()
{
    for (let i = 0; i < this.mPasses.length; i++)
    {
        if (this.mPasses[i].mError)
        {
            return true;
        }
    }
    return false;
}

Effect.prototype.Load = function (jobj )
{
    if (jobj.ver !== "0.1")
    {
        console.log("Wrong Format");
        return false;
    }

    let numPasses = jobj.renderpass.length;

    if( numPasses<1 || numPasses>this.mMaxPasses )
    {
        console.log("Corrupted Shader - " + numPasses);
        return false;
    }

    this.mPasses = [];
    for (let j = 0; j < numPasses; j++)
    {
        let rpass = jobj.renderpass[j];

        // skip sound passes if in thumbnail mode
        if( this.mForceMuted && rpass.type === "sound" ) continue;

        let wpass = new EffectPass(this.mRenderer, this.mIs20, this.mIsLowEnd, this.mShaderTextureLOD,
                                   this.mTextureCallbackFun, this.mTextureCallbackObj, this.mForceMuted, this.mForcePaused, this.mGainNode,
                                   this.mProgramDownscale, j, this);

        wpass.Create(rpass.type, this.mAudioContext);

        let numInputs = rpass.inputs.length;

        for (let i = 0; i < 4; i++)
        {
            wpass.NewTexture(this.mAudioContext, i, null, null, null);
        }
        for (let i = 0; i < numInputs; i++)
        {
            let lid  = rpass.inputs[i].channel;
            let styp = rpass.inputs[i].type;
            let sid  = rpass.inputs[i].id;
            let ssrc = rpass.inputs[i].filepath;
            let psrc = rpass.inputs[i].previewfilepath;
            let samp = rpass.inputs[i].sampler;

            wpass.NewTexture(this.mAudioContext, lid, { mType: styp, mID: sid, mSrc: ssrc, mSampler: samp, mPreviewSrc: psrc }, this.mBuffers, this.mCubeBuffers, this.mKeyboard);
        }

        for (let i = 0; i < 4; i++)
        {
            wpass.SetOutputs(i, null);
        }

        let numOutputs = rpass.outputs.length;
        for (let i = 0; i < numOutputs; i++)
        {
            let outputID = rpass.outputs[i].id;
            let outputCH = rpass.outputs[i].channel;
            wpass.SetOutputs(outputCH, outputID);
        }

        // create some hardcoded names. This should come from the DB
        let rpassName = "";
        if (rpass.type === "common" ) rpassName = "Common";
        if (rpass.type === "sound"  ) rpassName = "Sound";
        if (rpass.type === "image"  ) rpassName = "Image";
        if (rpass.type === "buffer") rpassName = "Buffer " + String.fromCharCode(65 + assetID_to_bufferID(wpass.mOutputs[0]));
        if (rpass.type === "cubemap") rpassName = "Cube A";// " + String.fromCharCode(65 + assetID_to_bufferID(this.mPasses[j].mOutputs[0]));
        wpass.SetName(rpassName);
        wpass.SetCode(rpass.code);

        this.mPasses.push(wpass);
    }
    return true;
}

Effect.prototype.CompileSome = function ( passes, preventCache, onResolve )
{
    let me = this;

    let to = getRealTime();
    let allPromisses = [];
    for (let j = 0; j < passes.length; j++)
    {
        allPromisses.push(new Promise(function (resolve, reject)
        {
            me.NewShader(passes[j], preventCache, function () { resolve(1); });
        }));
    }

    // aggregated callback when all passes have been compiled
    Promise.all(allPromisses).then(function (values)
    {
        let totalError = false;
        for (let j = 0; j < me.mPasses.length; j++)
        {
            if (me.mPasses[j].mError)
            {
                totalError = true;
                break;
            }
        }
        me.mCompilationTime = getRealTime() - to;
        onResolve(!totalError);
    }).catch(console.log);
}

Effect.prototype.Compile = function (preventCache, onResolve )
{
    let me = this;

    let to = getRealTime();
    let allPromisses = [];
    let numPasses = this.mPasses.length;
    for (let j = 0; j < numPasses; j++)
    {
        allPromisses.push(new Promise(function (resolve, reject)
        {
            me.NewShader(j, preventCache, function () { resolve(1); });
        }));
    }

    // aggregated callback when all passes have been compiled
    Promise.all(allPromisses).then(function (values)
    {
        let totalError = false;
        for (let j = 0; j < numPasses; j++)
        {
            if (me.mPasses[j].mError)
            {
                totalError = true;
                break;
            }
        }
        me.mCompilationTime = getRealTime() - to;
        onResolve(!totalError);
    }).catch(console.log);
}

Effect.prototype.GetCompilationTime = function( id )
{
    return this.mPasses[id].GetCompilationTime()/1000.0;
}
Effect.prototype.GetTotalCompilationTime = function()
{
    return this.mCompilationTime/1000.0;
}

Effect.prototype.DestroyPass = function( id )
{
   this.mPasses[id].Destroy( this.mAudioContext );
   this.mPasses.splice(id, 1);
}

Effect.prototype.AddPass = function( passType, passName, onResolve )
{
    let shaderStr = null;

    if( passType==="sound"   ) shaderStr = "vec2 mainSound( int samp, float time )\n{\n    // A 440 Hz wave that attenuates quickly overt time\n    return vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );\n}";
    if( passType==="buffer"  ) shaderStr = "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}";
    if( passType==="common"  ) shaderStr = "vec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}";
    if( passType==="cubemap" ) shaderStr = "void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Ray direction as color\n    vec3 col = 0.5 + 0.5*rayDir;\n\n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}";

    let id = this.GetNumPasses();
    this.mPasses[id] = new EffectPass( this.mRenderer, this.mIs20, this.mIsLowEnd, this.mShaderTextureLOD,
                                       this.mTextureCallbackFun, this.mTextureCallbackObj, this.mForceMuted, this.mForcePaused, this.mGainNode, 
                                       this.mProgramDownscale, id, this );

    this.mPasses[id].Create( passType, this.mAudioContext );
    this.mPasses[id].SetName( passName );
    this.mPasses[id].SetCode( shaderStr );
    this.NewShader(id, false, function ()
    {
        onResolve();
    });

    return { mId : id, mShader : shaderStr };
}

// this should be removed once we have MultiPass 2.0 and passes render to arbitrary buffers
Effect.prototype.IsBufferPassUsed = function( bufferID )
{
    for (let j=0; j<this.mPasses.length; j++ )
    {
        if( this.mPasses[j].mType !== "buffer" ) continue;
        if( this.mPasses[j].mOutputs[0] === bufferID_to_assetID(bufferID) ) return true;
    }
    return false;
}

Effect.prototype.Save = function()
{
    var result = {};

    result.ver = "0.1";

    result.renderpass = [];

    let numPasses = this.mPasses.length;
    for (let j=0; j<numPasses; j++ )
    {
        result.renderpass[j] = {};

        result.renderpass[j].outputs = new Array();
        for (let i = 0; i<4; i++ )
        {
            let outputID = this.mPasses[j].mOutputs[i];
            if( outputID===null ) continue;
            result.renderpass[j].outputs.push( { channel: i, id: outputID } );
        }
        result.renderpass[j].inputs = new Array();
        for (let i = 0; i<4; i++ )
        {
            if( this.mPasses[j].mInputs[i]===null ) continue;
            result.renderpass[j].inputs.push( {channel: i,
                                               type    : this.mPasses[j].mInputs[i].mInfo.mType,
                                               id      : this.mPasses[j].mInputs[i].mInfo.mID,
                                               filepath: this.mPasses[j].mInputs[i].mInfo.mSrc,
                                               sampler : this.mPasses[j].mInputs[i].mInfo.mSampler });
        }

        result.renderpass[j].code = this.mPasses[j].mSource;
        result.renderpass[j].name = this.mPasses[j].mName
        result.renderpass[j].description = "";
        result.renderpass[j].type = this.mPasses[j].mType;
    }

    result.flags = this.calcFlags();

    return result;
}

Effect.prototype.calcFlags = function ()
{
    let flagVR = false;
    let flagWebcam = false;
    let flagSoundInput = false;
    let flagSoundOutput = false;
    let flagKeyboard = false;
    let flagMultipass = false;
    let flagMusicStream = false;

    let numPasses = this.mPasses.length;
    for (let j = 0; j < numPasses; j++)
    {
        let pass = this.mPasses[j];

        if (pass.mType === "sound") flagSoundOutput = true;
        if (pass.mType === "buffer") flagMultipass = true;

        for (let i = 0; i < 4; i++)
        {
            if (pass.mInputs[i] === null) continue;

            if (pass.mInputs[i].mInfo.mType === "webcam") flagWebcam = true;
            else if (pass.mInputs[i].mInfo.mType === "keyboard") flagKeyboard = true;
            else if (pass.mInputs[i].mInfo.mType === "mic") flagSoundInput = true;
            else if (pass.mInputs[i].mInfo.mType === "musicstream") flagMusicStream = true;
        }

        let n1 = pass.mSource.indexOf("mainVR(");
        let n2 = pass.mSource.indexOf("mainVR (");
        if (n1 > 0 || n2 > 0) flagVR = true;
    }

    return {
        mFlagVR: flagVR,
        mFlagWebcam: flagWebcam,
        mFlagSoundInput: flagSoundInput,
        mFlagSoundOutput: flagSoundOutput,
        mFlagKeyboard: flagKeyboard,
        mFlagMultipass: flagMultipass,
        mFlagMusicStream: flagMusicStream
    };
}</script>
    <script>"use strict"

const kMaxCompileTime = 10.0;

function iReportCrash(shaderID)
{
    let req = new XMLHttpRequest();
    req.onload = function ()
    {
        let jsn = req.response;
        if (jsn === null) return;
        if (jsn.result === 0)
        {
            // yep
        }
    };
    req.open("POST", "/shadertoy", true);
    req.responseType = "json";
    req.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    req.send( "s=" + shaderID + "&r=2" );
}
</script>
    <script>"use strict"

var gActive = -1;
var mShaders = [];
var gNumCanvases = 0;

function myrefresh( id, slot, img, forceFrame, gui, guiID, renderID, time )
{
    if( mShaders[id].mReady===false ) return;
    if( forceFrame )
    {
        if (mShaders[id].mScreenshot === false)
        {
            mShaders[id].gEffect.Paint(mShaders[id].mTime / 1000.0, 1.0 / 60.0, 60.0, 0, 0, 0, 0, false);
        }
    }
}

function startRendering()
{
    if( gActive<0 ) return;
    if( mShaders[gActive].mReady===false ) return;
    if( mShaders[gActive].mScreenshot===true ) return;

    let time = getRealTime();

    mShaders[gActive].mFPS.Count( time );
    mShaders[gActive].mTime = mShaders[gActive].mTime0 + (time - mShaders[gActive].mTo);
    let dtime = 1000.0/60.0;
    mShaders[gActive].gEffect.Paint( mShaders[gActive].mTime/1000.0, dtime/1000.0, mShaders[gActive].mFPS.GetFPS(), 0,0,0,0, false);

    requestAnimFrame( startRendering );
}

function iLoadAndCompile(jsn, i )
{
    var shaderObj = jsn[i];
    if (shaderObj === null) return;

    var resizeCB = function (xres, yres) { myrefresh(i, 0, null, true, false, 0, -1.0) };
    var crashCB = function () { alert('crash');/*iReportCrash(gShaderIDs[i])*/ };
    mShaders[i].gEffect = new Effect(null, null, mShaders[i].mPreview.mCanvas, myrefresh, i, true, true, resizeCB, crashCB);

    if (!mShaders[i].gEffect.Load(shaderObj)) return;

    mShaders[i].gEffect.Compile(false, function (worked)
    {
        if (worked === true)
        {
            previewShowRender(mShaders[i].mPreview);

            mShaders[i].mScreenshot = false;
            mShaders[i].mReady = true;
            mShaders[i].mTime = 10.0 * 1000.0;
            mShaders[i].mTime0 = 0.0;
            mShaders[i].mTo = 0.0;
            mShaders[i].mFPS = piCreateFPSCounter();
            mShaders[i].mPreview.mCanvas.addEventListener("mouseout", function (ev) { gActive = -1; }, true);
            mShaders[i].mPreview.mBase.addEventListener("mouseover", function (ev) { if (mShaders[i].mPreview.mUI !== null) mShaders[i].mPreview.mUI.classList.add('isVisible'); }, true);
            mShaders[i].mPreview.mBase.addEventListener("mouseout", function (ev) { if (mShaders[i].mPreview.mUI !== null) mShaders[i].mPreview.mUI.classList.remove('isVisible'); }, true);
            mShaders[i].mPreview.mCanvas.addEventListener("mouseover", function (ev)
            {
                let ele = piGetSourceElement(ev);
                if (ele.mId === undefined) return;

                gActive = ele.mId;
                if (!mShaders[gActive].mReady) return;
                let time = getRealTime();
                mShaders[gActive].mTo = time;
                mShaders[gActive].mTime0 = mShaders[gActive].mTime;
                mShaders[gActive].mFPS.Reset(time);

                startRendering();
            }, true);


            /*
            let compilationTime = mShaders[i].gEffect.GetTotalCompilationTime();
            if (compilationTime > kMaxCompileTime)
            {
                iReportCrash(mShaders[i].mShaderID);
            }*/

            myrefresh(i, null, null, true, false, 0, -1.0);
        }
        else
        {
            mShaders[i].mReady = false;
            previewShowError(mShaders[i].mPreview);
        }
    });
};


function iProcessShader( jsn, i )
{
    var shaderObj = jsn[i];
    if( shaderObj===null ) return;

    if ((shaderObj.info.usePreview === 0 && !gUseScreenshots) || (mShaders[i].mPreviewReady !== 1))
    {
        iLoadAndCompile(jsn, i);
    }
    else
    {
        mShaders[i].mScreenshot = true;
        if( shaderObj.info.usePreview === 1 )
            previewShowScreenshot(mShaders[i].mPreview, 1); // comp
        else if (gUseScreenshots)
            previewShowScreenshot(mShaders[i].mPreview, 2); // sett
    }

    if( i<(jsn.length-1) ) setTimeout( function(){iProcessShader(jsn,i+1);}, 10 );
}

function iInitUI(numCanvases, uiCallback, windowTitle)
{
    gNumCanvases = numCanvases;
    document.getElementById("mySearch").focus();

    //-----------------------------------------------------------------
    // window
    //-----------------------------------------------------------------
    if (windowTitle !== null) {
        document.title = windowTitle;
    }

    //-----------------------------------------------------------------
    // ui
    //-----------------------------------------------------------------
    var num = Math.min(gShaders.length, gNumCanvases);

    //var base = document.getElementsByClassName( "searchResult" );

    for (let i = 0; i < gNumCanvases; i++)
    {
        let pv = createPreview(i);

        if (i >= num) {
            previewHide(pv);
            continue;
        }

        let shaderID = gShaders[i].info.id;
        
        if (pv.mUI !== null && uiCallback !== null) {
            pv.mUI.addEventListener('click', function (ev) {
                uiCallback(shaderID);
                ev.preventDefault();
            }, false);
        }
        
        previewShowLoading(pv);
        
        mShaders[i] = {};
        mShaders[i].mShaderID = shaderID;
        mShaders[i].mPreview = pv;
        mShaders[i].mScreenshot = false;
        mShaders[i].mPreview.mLink.href = "/view/" + shaderID;
        mShaders[i].mPreviewReady = 0;
        mShaders[i].mReady = false;
        mShaders[i].gEffect = null;

        previewLoadScreenshot(mShaders[i].mPreview,
            function () { mShaders[i].mPreviewReady = 1; if (mShaders[i].mReady === false) previewShowScreenshot(mShaders[i].mPreview, 0); },
            function () { mShaders[i].mPreviewReady = 2; },
            shaderID);
    }

    if (num <= 0) {
        return;
    }
}

function iInitShaders(jsn)
{
    for (let i = 0; i < jsn.length; i++)
    {
        let shaderObj = jsn[i];
        if (shaderObj === null) continue;
        let inf = shaderObj.info;
        mShaders[i].mPreview.mTextA.textContent = inf.name;
        mShaders[i].mPreview.mTextB.innerHTML = "<a class='user' href='/user/" + htmlEntities(inf.username) + "'>" + htmlEntities(inf.username) + "</a>";
        mShaders[i].mPreview.mTextC.innerHTML = "<img src='/img/themes/" + gThemeName + "/views.png' class='viewsIcon'></img>" + inf.viewed + "    &nbsp;&nbsp;  <img src='/img/themes/" + gThemeName + "/likes.png' class='likesIcon'></img>" + inf.likes;
    }

    setTimeout(function () { iProcessShader(jsn, 0); }, 10);
}

function resultsInitStatic(numCanvases, uiCallback, windowTitle)
{
    iInitUI(numCanvases, uiCallback, windowTitle);

    iInitShaders(gShaders);
}

function resultsInit(numCanvases, uiCallback, windowTitle)
{	
    iInitUI(numCanvases, uiCallback, windowTitle);

    var num = Math.min(gShaderIDs.length, gNumCanvases);

    var mHttpReq = new XMLHttpRequest();

    mHttpReq.abort();

    var str = "{ \"shaders\" : [";
    for( let i=0; i<num; i++ )
    {
         str += "\"" + gShaderIDs[i] + "\"";
         if( i!==(num-1) ) str += ", ";
    }
    str += "] }";

    str = "s=" + encodeURIComponent( str ) + "&nt=0&nl=0&np=0";

    mHttpReq.open( "POST", "/shadertoy", true );
    mHttpReq.responseType = "json";
    mHttpReq.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    mHttpReq.onload = function ()
    {
        let jsn = this.response;
        if( jsn===null )
        {
            console.log( "Could not load shaders" );
            return;
        }

        iInitShaders(jsn);
    }
    mHttpReq.send( str );
}</script>
    <style>
    .shaderPreview
    {
    display: block;
    background-color: #000000;
    background-image: url("/img/loading.gif");
    background-repeat: no-repeat;
    background-position: center;
    padding: 0px;
    margin: 0px;
    border: 0px solid #000000;
    border-radius: 8px;
    width:100%;
    height:100%;
    position: absolute;
    overflow:hidden;
    }

    .previewInfo
    {
    width: 100%;
    left: 0px;
    top: 2px;
    position: relative;
    visibility: hidden;
    }

    .previewCanvas
    {
    left: 0px;
    top: 0px;
    padding: 0px;
    margin: 0px;
    position: absolute;
    cursor: pointer;
    width:100%;
    height:100%;
    border-radius: 8px;
    border: 0px solid #000000;
    backgroundColor: transparent;
visibility: hidden;
opacity:0;
transition: opacity 1.0s ease;
    }

    .previewText
    {
        text-overflow: ellipsis;
    white-space: nowrap;
    padding-right: 1px;
    }

    .previewTextUser
    {
    text-overflow: ellipsis;
    white-space: nowrap;
    padding-left: 3px;
    }

    .previewStats
    {
    padding-right: 1px;
    right: 0px;
    top: 0px;
    position: absolute;
    }

    .previewErrorContainer
    {
    left:0px;
    top:0px;
    width:100%;
    height:100%;
    padding:0px;
    margin:0px;
    background-color:#000000;
    border-radius:8px;
    cursor:pointer;
    visibility:hidden;
    }

    .previewErrorMessage
    {
    top:50%;
    position:absolute;
    width:100%;
    text-align:center;
    padding:0;
    margin:auto;
    color:#ff0000;
    font-size:2em;
    font-style:italic;
    }

    .previewNoGLContainter
    {
    left:0px;
    top:0px;
    width:100%;
    height:100%;
    padding:0px;
    margin:0px;
    position:absolute;
    background-color:#000000;
    border-radius:8px;
    cursor:pointer;
    pointer-events:none;
    visibility:hidden;
    font-size:2em;
    }

    .previewNoGLMessage
    {
    width:86%;
    height:90%;
    padding-left:7%;
    padding-right:7%;
    padding-top:10%;
    padding-bottom:0px;
    color:#ff0000;
    position:absolute;
    visibility:hidden;
    }

    .previewThumbnailContainer
    {
    width:100%;
    height:100%;
    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    cursor:pointer;
    visibility:hidden;
    border-radius:8px;
    border:0px solid #000000;
    }

    .previewThumbnailImage
    {
    width:100%;
    height:100%;
    left:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    cursor:pointer;
    border-radius:8px;
    border:0px solid #000000;
opacity: 0.0;
transition: opacity 1.0s ease;
    }

    .previewThumbnailIcon
    {
    width:64px;
    height:32px;
    left:0px;
    top:0px;
    padding:0px;
    padding-top:12px;
    margin:0px;
    position:absolute;
    color:#ffffff;
    background-color:#ff8020;
    font-weight:bold;
    border-radius:0px 0px 8px 0px;
    text-align:center;
    //visibility:hidden;
    }


    .previewUIContainter
    {
    display: block;
    right:0px;
    top:0px;
    padding:0px;
    margin:0px;
    position:absolute;
    //cursor:pointer;
    //pointer-events:none;
    //visibility:hidden;
    }
</style>

<script>
    function previewHide(me)
    {
    me.mBase.style.visibility = "hidden";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "hidden";
    }

    function previewShowRender(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "visible";
me.mCanvas.style.opacity = 1.0;
    me.mCanvas.style.borderRadius ="8px;";
//  me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "visible";
    }

    function previewShowScreenshot(me, message)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "visible";
me.mThumbnailImg.style.opacity = 1.0;
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "visible";
    me.mThumbnailWar1.style.visibility = (message===1)?"visible":"hidden";
    me.mThumbnailWar2.style.visibility = (message===2)?"visible":"hidden";
    }

    function previewShowLoading(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "hidden";
    me.mCont.style.visibility = "hidden";

    me.mLink.style.visibility = "visible";
    me.mBase.style.backgroundColor = "#ff0000;"
    me.mCont.style.visibility = "visible";
    }

    function previewShowNoWebGL(me, shaderID)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "visible";
    me.mError.style.visibility = "visible";
    me.mThumbnailImgNoWebGL.onerror = function(ev) 
                                      { 
                                            me.mThumbnailImgNoWebGL.style.visibility="hidden"; 
                                            me.mMessageNoWebGL.style.visibility="visible"; 
                                      };
    me.mThumbnailImgNoWebGL.src = "/media/shaders/" + shaderID + ".jpg";
    }

    function previewShowError(me)
    {
    me.mBase.style.visibility = "visible";
    me.mCanvas.style.visibility = "hidden";
    me.mCanvas2D.style.visibility = "hidden";
    me.mNoWebGL.style.visibility = "hidden";
    me.mError.style.visibility = "visible";
    me.mCont.style.visibility = "visible";
    }

    function previewLoadScreenshot( me, cbSuccess, cbError, shaderID )
    {
    var url = "/media/shaders/" + shaderID + ".jpg";
    me.mThumbnailImg.onload = cbSuccess;
    me.mThumbnailImg.onerror = function(ev) { cbError(); };
    me.mThumbnailImg.src = url;
    }
        
    function createPreview(id)
    {
        var bar = document.getElementById( "Preview_"+id+"_Canvas" );
        bar.width = bar.offsetWidth;
        bar.height = bar.offsetHeight;
        bar.mId = id;

        return { mBase: document.getElementById( "Preview_"+id+"_Container" ),
        mLink: document.getElementById( "Preview_"+id+"_Link" ),
        mCanvas: bar,
        mCont: document.getElementById( "Preview_"+id+"_Info" ),
        mTextA: document.getElementById( "Preview_"+id+"_Text" ),
        mTextB: document.getElementById( "Preview_"+id+"_TextUser" ),
        mTextC: document.getElementById( "Preview_"+id+"_Stats" ),
        mNoWebGL: document.getElementById( "Preview_"+id+"_NoWebGL" ),
        mError: document.getElementById( "Preview_"+id+"_Error" ),
        mCanvas2D: document.getElementById( "Preview_"+id+"_Thumnail" ),
        mThumbnailImg: document.getElementById( "Preview_"+id+"_ThumnailImage" ),
        mThumbnailWar1: document.getElementById( "Preview_"+id+"_ThumnailWarning1" ),
        mThumbnailWar2: document.getElementById( "Preview_"+id+"_ThumnailWarning2" ),
        mThumbnailImgNoWebGL: document.getElementById( "Preview_"+id+"_ThumnailImageNoWebGL" ),
        mMessageNoWebGL: document.getElementById( "Preview_"+id+"_MessageNoWebGL"),
        mUI: document.getElementById( "Preview_"+id+"_UI" )
        };
    }
</script>

    <style>

    div#shaderGrid
    {
        width:100%;
        padding:0px;
        margin:0px;
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        grid-template-rows: repeat(3, 1fr);
        grid-column-gap: 64px;
        grid-row-gap: 24px;
    }
    .searchResult
    {
        margin: 0px;
        padding: 0px;
        width: 100%;
    }
    .searchResultContainer
    {
        width: 100%;
        padding-bottom:56.25%;
        height: 0;
        position: relative;
    }
    .navigation
    {
        display:flex;
        align-items:center;
    }
    div#navBottom
    {
        display:none;
        justify-content:center;
    }
    a.pageButtons, .pageButtonsCurrent
    {
        border-style: solid;
        border-width: 1px;
        border-color: #808080;
        text-align: center;
        vertical-align: middle;
        margin-left: 12px;
        display: inline-block;
        border-radius: 4px;
		font-weight:bold;
        cursor: pointer;
        padding-bottom:5px;
        padding-top:4px;
        padding-left: 8px;
        padding-right: 8px;
        margin:8px;
    }
    a.pageButtons
    {
        text-decoration: none;
        -moz-transition:    background-color 0.15s linear, color 0.15s linear;
        -webkit-transition: background-color 0.15s linear, color 0.15s linear;
        transition:         background-color 0.15s linear, color 0.15s linear;
    }
    a.pageButtons:hover
    {
      background-color:#808080;
      color : #ff8020;
    }
    .pageButtonsCurrent
    {
        background-color: #808080;
        color:#000000;
    }
    div#controls
    {
        width:100%;
        padding-top:16px;
        padding-bottom:16px;
        display:flex;
        justify-content:space-between; 
        flex-wrap:wrap;
    }
    div#controls > div
    {
        display:inline-flex;
    }
    .controlOptions
    {
        display:inline-block;
    }

    /* ----------------------- media resolutions ------------------------ */

    @media screen and (max-width:799px) 
    {
        div#shaderGrid  { grid-template-columns: 1fr; grid-template-rows: repeat(12, 1fr); grid-column-gap: 0px; grid-row-gap: 16px; }
        div#controls
        {
            width:100%;
            display:flex;
            justify-content:flex-start; 
            flex-wrap:wrap;
        }
        div#controls > div
        {
            display:inline-flex;
            width:100%;
            margin-left: 0px;
            margin-right: 0px;
            padding-bottom:16px;
        }
        div#navBottom
        {
            display: flex;
        }
    }
    
    </style>
    <script>
    var gShaders=[{"ver":"0.1","info":{"id":"wtS3W3","date":"1561330954","viewed":4883,"name":"Sunset Drive Unlimited","username":"spolsh","description":"Retro futuristic game and animation. Started at jam and polished during couple of spare evening. Details in shader code headers.\nPlease post your high scores :) Enjoy!","likes":154,"published":3,"flags":112,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"\/media\/previz\/buffer03.png","previewfilepath":"\/media\/previz\/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Mll3z2","filepath":"https:\/\/soundcloud.com\/rombo_rama\/lifelike-so-electric","previewfilepath":"https:\/\/soundcloud.com\/rombo_rama\/lifelike-so-electric","type":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Copyright \u00a9 2019 Michal Klos\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ Sunset Drive Unlimited\n\/\/  Endless runner with synthwave stylization\n\/\/\t\"Brick Driver\" sequel, because it missed fluent turning and coins:\n\/\/\thttps:\/\/www.shadertoy.com\/view\/wssSD4\n\n\/\/ #define options in Common tab\n\/\/  Some effects can be disabled on low end gpus\n\n\/\/ Gameplay is based on Brick Game Racing,\n\/\/  https:\/\/youtu.be\/EdMyKRC8qyU\n\n\/\/ First draft created in 24h on Game Jam Square 26-28.04.2019\n\/\/\tFinished after couple of spare evenings on 24.06.2019\n\n\/\/ Based on:\n\/\/ - \"80's raymarching\" by villedieumorgan. https:\/\/shadertoy.com\/view\/lsVSRt\n\/\/ - \"[SH16B] Speed Drive 80\" by knarkowicz. https:\/\/shadertoy.com\/view\/4ldGz4\n\/\/ Other snippets credits in comments next to the code\n\/\/ Thank you guys for sharing it, hope you like it :)\n\n\/\/ Music: Lifelike - So Electric\n\/\/  https:\/\/soundcloud.com\/rombo_rama\/lifelike-so-electric\n\n\nvec3 fxaa( vec3 color )\n{\n\t\/\/ FXAA implementation by mudlord (I think?)\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n\tvec2 pp = 1.0 \/ R.xy;\n    float lumaNW = dot(texture(iChannel0, (F.xy + vec2(-1.0, -1.0)) * pp).xyz, luma);\n    float lumaNE = dot(texture(iChannel0, (F.xy + vec2(1.0, -1.0)) * pp).xyz, luma);\n    float lumaSW = dot(texture(iChannel0, (F.xy + vec2(-1.0, 1.0)) * pp).xyz, luma);\n    float lumaSE = dot(texture(iChannel0, (F.xy + vec2(1.0, 1.0)) * pp).xyz, luma);\n    float lumaM  = dot(color.xyz,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir = vec2(-((lumaNW + lumaNE) - (lumaSW + lumaSE)), ((lumaNW + lumaSW) - (lumaNE + lumaSE)));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * (1.0\/8.0)), (1.0\/128.0));\n\n    float rcpDirMin = 2.5 \/ (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(8.0, 8.0),\n              max(vec2(-8.0, -8.0),\n              dir * rcpDirMin)) * pp;\n\n    vec3 rgbA = 0.5 * (\n        texture(iChannel0, F.xy * pp + dir * (1.0 \/ 3.0 - 0.5)).xyz +\n        texture(iChannel0, F.xy * pp + dir * (2.0 \/ 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n        texture(iChannel0, F.xy * pp + dir * -0.5).xyz +\n        texture(iChannel0, F.xy * pp + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax)){\n        return rgbA;\n    } else {\n        return rgbB;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4( 0.0 );\n\t\n\tvec2 uv = F.xy \/ R.xy;\n    vec2 q = 1.0 - 2.0 * uv;\n    q.x *= R.x \/ R.y;\n\n#ifdef FORCED_RATIO\n    float bars = step( abs( q.y ) * g_forceRatio, R.x \/ R.y );\n    if ( bars < 0.5 ) return;\t\n#endif \/\/ FORCED_RATIO\n       \n    fragColor = texture( iChannel0, vec2( uv ) );\n\n#ifdef FXAA\t\n\tfragColor.rgb = fxaa( fragColor.rgb );\n#endif\n\n#ifdef NOISE\n    fragColor.rgb *= 0.8 + 0.2 * hash22( 1000.0 * ( F.xy \/ R.xy + fract( iTime ) ) ).x;\n#endif\n\n#ifdef FPS_COUNTER    \n    vec2 h = F.xy \/ R.xy;\n    h.x *= R.x \/ R.y;\n    fragColor.rgb += printInt( ( h -vec2( 0.0, 0.21 ) ) * 30.0, iFrameRate );\n#endif \n\n    \/\/ gamma\n\tfragColor.rgb = pow( fragColor.rgb, vec3( 0.4545 ) );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"\/presets\/tex00.jpg","previewfilepath":"\/presets\/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ Copyright \u00a9 2019 Michal Klos\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ Sunset Drive Unlimited\n\/\/  Endless runner with synthwave stylization\n\/\/\t\"Brick Driver\" sequel, because it missed fluent turning and coins:\n\/\/\thttps:\/\/www.shadertoy.com\/view\/wssSD4\n\n\/\/ #define options in Common tab\n\/\/  Some effects can be disabled on low end gpus\n\n\/\/ Gameplay is based on Brick Game Racing,\n\/\/  https:\/\/youtu.be\/EdMyKRC8qyU\n\n\/\/ First draft created in 24h on Game Jam Square 26-28.04.2019\n\/\/\tFinished after couple of spare evenings on 24.06.2019\n\n\/\/ Based on:\n\/\/ - \"80's raymarching\" by villedieumorgan. https:\/\/shadertoy.com\/view\/lsVSRt\n\/\/ - \"[SH16B] Speed Drive 80\" by knarkowicz. https:\/\/shadertoy.com\/view\/4ldGz4\n\/\/ Other snippets credits in comments next to the code\n\/\/ Thank you guys for sharing it, hope you like it :)\n\n\/\/ Music: Lifelike - So Electric\n\/\/  https:\/\/soundcloud.com\/rombo_rama\/lifelike-so-electric\n\n\n\nAppState updateGame( AppState s, float isDemo )\n{\n    if ( isDemo > 0.0 )\n    {\n        s.timeAccumulated += 1.0 * iTimeDelta;\n    \ts.playerPos.y = 5.0 * s.timeAccumulated;\n    }\n    else\n    {\n        float playerCellID = floor( s.playerPos.y );\n        s.paceScale = saturate( ( playerCellID - 50.0) \/ 500.0);\n        float timeMultiplier = mix( 0.75, 2.0, pow( s.paceScale, 1.0 ) );\n\n        s.timeAccumulated += timeMultiplier * iTimeDelta;\n        s.playerPos.y = 5.0 * s.timeAccumulated;\n    }    \n    \n    float playerCellID = floor( s.playerPos.y );\n\n    if ( isDemo > 0.0 )\n    {           \n        float cellOffset = 1.0;\n        float nextPlayerCellID = playerCellID + cellOffset;\n\n        float nextCellCoinRND = hash11( nextPlayerCellID + s.seed ); \/\/ skip rnd obstacle every second cell to make room for driving\n        nextCellCoinRND *= mix( 1.0, -1.0, step( mod( nextPlayerCellID, 4.0 ), 1.5 ) ); \/\/ gaps in coin placing: 2 gaps, 2 coins\n        nextCellCoinRND = mix( nextCellCoinRND, -1.0, step( nextPlayerCellID, 5.0 ) ); \/\/ head start\n        float nextCellCoinCol = floor( 3.0 * nextCellCoinRND );\n\n        \/\/ OBSTACLE\n        float nextCellObsRND = hash11( 100.0 * nextPlayerCellID + s.seed );\n        nextCellObsRND *= mix( 1.0, -1.0, step( mod( nextPlayerCellID, 3.0 ), 1.5 ) );\n        nextCellObsRND = mix( nextCellObsRND, -1.0, step( nextPlayerCellID, 7.0 ) ); \/\/ head start\n        float nextCellObsCol = floor( 3.0 * nextCellObsRND );\n        \n        float inputObs = 0.0;                \n        if ( nextCellObsCol > -0.5 )\n        {\n            nextCellCoinCol -= 0.5; \/\/ pos fix\n        \tfloat toObs = nextCellObsCol - s.playerPos.x;\n        \n            if ( nextCellObsCol == 1.0 )\n                inputObs = hash11( nextPlayerCellID + s.seed );\n            \n            if ( nextCellObsCol < 1.0 )\n                inputObs = 1.0;\n\n            if ( nextCellObsCol > 1.0 )\n                inputObs = -1.0;\n        }\n        \n        \n        float inputCoin = 0.0;\n        if ( nextCellCoinCol > -0.5 )\n        {               \n            nextCellCoinCol -= 0.5; \/\/ pos fix\n            float toCoin = nextCellCoinCol - s.playerPos.x;\n            \n\t\t\tinputCoin = sign(toCoin) * saturate( abs( toCoin ) );\n        }\n\n        float inputDir = inputCoin + 5.0 * inputObs;\n        inputDir = sign( inputDir ) * 4.0 * saturate( abs( inputDir ) );\n        \n        s.isPressedLeft  = step( 0.5, -inputDir );\n        s.isPressedRight = step( 0.5,  inputDir );\n    }\n\n    float speed = mix( 0.1, 0.15, isDemo );\n    s.playerPos.x -= speed * s.isPressedLeft; \n    s.playerPos.x += speed * s.isPressedRight; \n\n    s.playerPos.x = clamp( s.playerPos.x, -0.5, 1.5 );\n\n    if ( playerCellID != s.coin0Pos ) \n    {\n        s.coin3Pos \t = s.coin2Pos;\n        s.coin3Taken = s.coin2Taken;\n\n        s.coin2Pos \t = s.coin1Pos;\n        s.coin2Taken = s.coin1Taken;\n\n        s.coin1Pos \t = s.coin0Pos;\n        s.coin1Taken = s.coin0Taken;\n\n        s.coin0Pos = playerCellID;\n        s.coin0Taken = 0.0;\n    }\n \n    \/\/ COIN start\n    float cellCoinRND = hash11( playerCellID + s.seed ); \/\/ skip rnd obstacle every second cell to make room for driving\n    cellCoinRND *= mix( 1.0, -1.0, step( mod( playerCellID, 4.0 ), 1.5 ) ); \/\/ gaps in coin placing: 2 gaps, 2 coins\n    cellCoinRND = mix( cellCoinRND, -1.0, step( playerCellID, 5.0 ) ); \/\/ head start\n    float cellCoinCol = floor( 3.0 * cellCoinRND );\n\n    vec2 coinPos = -vec2( 0.0, playerCellID )\t\/\/ cell pos\n        +vec2( 0.5, -0.5 )\t\/\/ move to cell center\n        -vec2( cellCoinCol, 0.0 ); \/\/ move to column\n\n    if ( cellCoinRND >= 0.0 )\n    {        \n        float distCoinPlayer = length( coinPos + s.playerPos );\n\n        if ( distCoinPlayer < 0.5 && s.coin0Taken < 0.5 )\n        {\n            if ( isDemo < 1.0 )\n            \ts.score++;\n            \n            s.coin0Taken = 1.0;\n            s.timeCollected = iTime;\n        }\n    }\n    \/\/ COIN end\n\n    \/\/ OBSTACLE start\n    float cellObsRND = hash11( 100.0 * playerCellID + s.seed );\n    cellObsRND *= mix( 1.0, -1.0, step( mod( playerCellID, 3.0 ), 1.5 ) );\n    cellObsRND = mix( cellObsRND, -1.0, step( playerCellID, 7.0 ) ); \/\/ head start\n    float cellObsCol = floor( 3.0 * cellObsRND );\n\n    if ( cellObsRND >= 0.0 && cellObsCol != cellCoinCol )\n    {   \n        vec2 obstaclePos = -vec2( 0.0, playerCellID )\t\/\/ cell pos\n            +vec2( 0.5, -0.25 )\t\/\/ move to cell center\n            -vec2(cellObsCol, 0.0 ); \/\/ move to column\n\n        float distObstaclePlayer = length( obstaclePos + s.playerPos );\n\n        if ( distObstaclePlayer < 0.5 && isDemo < 1.0 )\n        {\n            s.timeFailed = iTime;\n            s.timeCollected = -1.0;\n            s.highscore = max( s.highscore, s.score );\n        }\n    }\n    \/\/ OBSTACLE end        \n    return s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    if ( fragCoord.x >= 8. || fragCoord.y >= 8. ) \n    {        \n        discard;    \n    }\n    \n    AppState s;\n    loadState( iChannel0, s );\n        \n    s.showUI = mod( s.showUI + texelFetch( iChannel1, ivec2( ASCII_U, 1 ), 0 ).x, 2.0 );\n    float isSpacePressed = texelFetch( iChannel1, ivec2( ASCII_SPACE, 1 ), 0 ).x;\n   \n  \t\/\/ read keys that people usually press\n    \/\/ https:\/\/www.shadertoy.com\/view\/lsXGzf\n    float keyLeft = 0.0;\n    for ( int i = 0; i < keysLeft.length(); ++i )\n        keyLeft = max( keyLeft, texelFetch( iChannel1, ivec2( keysLeft[i], 0 ), 0 ).x );\n    \n\ts.isPressedLeft = keyLeft;    \n            \n    float keyRight = 0.0;\n    for ( int i = 0; i < keysRight.length(); ++i )\n        keyRight = max( keyRight, texelFetch( iChannel1, ivec2( keysRight[i], 0 ), 0 ).x );\n    \n    s.isPressedRight = keyRight;    \n       \n    if ( s.stateID == GS_SPLASH ) \/\/ splash\n    {                             \n        if ( isSpacePressed > 0.5 || s.isPressedLeft > 0.5 || s.isPressedRight > 0.5 )\n        {\n            s = setStateStartGame( s, iTime );\n            s.stateID = GS_GAME;            \n            s.timeStarted = iTime;\n            s.timeAccumulated = 0.0;\n            s.seed += iTime;\n        }\n        else\n        {\n            s = updateGame( s, 1.0 );\n        }        \n    }\n    else if ( s.stateID == GS_GAME ) \/\/ game\n    {\n        if ( s.timeFailed > s.timeStarted )\n        {   \n            if ( iTime > s.timeFailed + 1.0 \n                && ( s.isPressedLeft > 0.5 || s.isPressedRight > 0.5 ) )\n            {            \n            \ts.timeStarted = iTime;\n                s.timeFailed = -1.0;\n            }\n                        \n            if ( iTime > s.timeFailed + 5.0 )\n            {                \n                s = setStateStartGame( s, iTime );\n                s.stateID = GS_SPLASH;\n            }\n            \n            s.isPressedLeft = 0.0;\n            s.isPressedRight = 0.0;\n        }\n        else\n        {\n            s = updateGame( s, 0.0 );\n        }\n    }\n  \n    fragColor = saveState( s, fragCoord, iFrame, iTime );\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\/\/ Copyright \u00a9 2019 Michal Klos\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ Sunset Drive Unlimited\n\/\/  Endless runner with synthwave stylization\n\/\/\t\"Brick Driver\" sequel, because it missed fluent turning and coins:\n\/\/\thttps:\/\/www.shadertoy.com\/view\/wssSD4\n\n\/\/ #define options in Common tab\n\/\/  Some effects can be disabled on low end gpus\n\n\/\/ Gameplay is based on Brick Game Racing,\n\/\/  https:\/\/youtu.be\/EdMyKRC8qyU\n\n\/\/ First draft created in 24h on Game Jam Square 26-28.04.2019\n\/\/\tFinished after couple of spare evenings on 24.06.2019\n\n\/\/ Based on:\n\/\/ - \"80's raymarching\" by villedieumorgan. https:\/\/shadertoy.com\/view\/lsVSRt\n\/\/ - \"[SH16B] Speed Drive 80\" by knarkowicz. https:\/\/shadertoy.com\/view\/4ldGz4\n\/\/ Other snippets credits in comments next to the code\n\/\/ Thank you guys for sharing it, hope you like it :)\n\n\/\/ Music: Lifelike - So Electric\n\/\/  https:\/\/soundcloud.com\/rombo_rama\/lifelike-so-electric\n\n\n\n\/\/ switches, enable\/disable effects:\n#define REFLECTIONS \/\/ needs good gpu\n#define VOLUMETRICS \/\/ needs good gpu\n#define FXAA\n#define GRADE\n#define NOISE\n#define FORCED_RATIO\n\/\/ debug:\n#define SHOW_UI\n\/\/ #define FPS_COUNTER\n\/\/ #define DEBUG_2D\n\/\/ #define DEBUG_CAMERA\n\/\/ #define CAM_STICKED\n\n\n#define ZERO (min(iFrame,0))\n#define R iResolution\n#define F gl_FragCoord\n\/\/ fix by adx\n#define texture(s,u) textureLod(s,u,0.)\n\nconst float g_forceRatio = 2.39;\nconst float PI = float(3.14159);\n\n\/\/ control loop\nconst float keysLeft[] = float[] ( \n\t 37.0,  \/\/ Arrow left\n\t 65.0,  \/\/ A\n\t 197.0  \/\/ a \n);\n\nconst float keysRight[] = float[] ( \n\t 39.0, \/\/ Arrow right\n\t 68.0, \/\/ D\n     100.0 \/\/ d\n);\n\nconst int ASCII_U\t\t= 85;\nconst int ASCII_SPACE\t= 32;\n\n\/\/ Game State\nconst float GS_SPLASH = 0.0;\nconst float GS_GAME   = 1.0;\n\n\/\/ Cell State\nstruct AppState\n{\n\tfloat stateID;\n    float isPressedLeft;\n    float isPressedRight;\n    float timeStarted;\n    \n    vec2 playerPos;\n    float score;\n    float timeFailed;\n    \n    float highscore;\n    float timeCollected;\n    float timeAccumulated;\n    float showUI;\n    \n    float paceScale;\n    float seed;\n    \n    float coin0Pos;\n    float coin0Taken;\n    float coin1Pos;\n    float coin1Taken;\n    float coin2Pos;\n    float coin2Taken;\n    float coin3Pos;\n    float coin3Taken;\n};\n\n   \n\/\/ https:\/\/www.shadertoy.com\/view\/4djSRW\nfloat hash11( float p )\n{\n\tvec3 p3  = fract( vec3( p ) * .1031 );\n    p3 += dot( p3, p3.yzx + 19.19 );\n    return fract( ( p3.x + p3.y) * p3.z );\n}\n\nvec2 hash21( float p )\n{\n\tvec3 p3 = fract( vec3( p ) * vec3( .1031, .1030, .0973 ) );\n\tp3 += dot( p3, p3.yzx + 19.19 );\n    return fract( ( p3.xx + p3.yz ) * p3.zy );\n}\n\nvec2 hash22( vec2 p )\n{\n\tvec3 p3 = fract( vec3( p.xyx ) * vec3( .1031, .1030, .0973 ) );\n    p3 += dot( p3, p3.yzx + 19.19 );\n    return fract( ( p3.xx + p3.yz ) * p3.zy );\n}\n\n\/\/ from Tiny Planet: Earth by morgan3d https:\/\/www.shadertoy.com\/view\/lt3XDM\nfloat hash( float n ) { return fract( sin( n ) * 1e4 ); }\nfloat noise( vec3 x ) { const vec3 step = vec3( 110, 241, 171 ); vec3 i = floor( x ); vec3 f = fract( x ); float n = dot( i, step ); vec3 u = f * f * ( 3.0 - 2.0 * f ); return mix( mix( mix( hash( n + dot( step, vec3( 0, 0, 0 ) ) ), hash( n + dot( step, vec3( 1, 0, 0 ) ) ), u.x ), mix( hash( n + dot( step, vec3( 0, 1, 0 ) ) ), hash( n + dot( step, vec3( 1, 1, 0 ) ) ), u.x ), u.y ), mix( mix( hash( n + dot( step, vec3( 0, 0, 1 ) ) ), hash( n + dot( step, vec3( 1, 0, 1 ) ) ), u.x ), mix( hash( n + dot( step, vec3( 0, 1, 1) ) ), hash( n + dot( step, vec3( 1, 1, 1 ) ) ), u.x ), u.y ), u.z ); }\n\n#define DEFINE_FBM(name, OCTAVES) float name( vec3 x ) { float v = 0.0; float a = 0.5; vec3 shift = vec3( 100 ); for ( int i = 0; i < OCTAVES; ++i ) { v += a * noise( x ); x = x * 2.0 + shift; a *= 0.5; } return v; }\nDEFINE_FBM(fbm3, 3)\n\n\nvec4 loadValue( sampler2D tex, int x, int y )\n{\n    return texelFetch( tex, ivec2( x, y ), 0 );\n}\n\nvoid loadState( sampler2D tex, out AppState s )\n{\n    vec4 data;\n\n\tdata = loadValue( tex, 0, 0 );\n    s.isPressedLeft\t\t= data.x;\n    s.isPressedRight\t= data.y;\n    s.stateID      \t\t= data.z;\n\ts.timeStarted \t\t= data.w;    \n    \n    data = loadValue( tex, 1, 0 );\n    s.playerPos\t\t\t= data.xy;\n    s.score\t\t\t\t= data.z;\n    s.timeFailed \t\t= data.w;\n    \n    data = loadValue( tex, 2, 0 );\n    s.highscore \t\t= data.x;\n    s.timeCollected\t\t= data.y;\n    s.timeAccumulated\t= data.z;\n    s.showUI\t\t\t= data.w;\n    \n    data = loadValue( tex, 3, 0 );\n    s.paceScale\t\t\t= data.x;\n    s.seed\t\t\t\t= data.y;\n   \n    data = loadValue( tex, 0, 1 );\n    s.coin0Pos = data.x;\n    s.coin0Taken = data.y;\n    s.coin1Pos = data.z;\n    s.coin1Taken = data.w;\n    data = loadValue( tex, 1, 1 );\n    s.coin2Pos = data.x;\n    s.coin2Taken = data.y;\n    s.coin3Pos = data.z;\n    s.coin3Taken = data.w;\n}\n\nvoid storeValue( vec2 re, vec4 va, inout vec4 fragColor, vec2 fragCoord )\n{\n    fragCoord = floor( fragCoord );\n    fragColor = ( fragCoord.x == re.x && fragCoord.y == re.y ) ? va : fragColor;\n}\n\nAppState setStateStartGame( in AppState s, float iTime )\n{    \n    s.stateID \t\t\t=  GS_SPLASH;\n    s.timeStarted\t\t=  iTime;\n    s.playerPos\t\t\t=  vec2( 0.5, 0.0 );\n    s.score\t\t\t\t=  0.0;\n    s.timeFailed\t\t= -1.0;\n    s.timeCollected\t\t= -1.0;\n    s.timeAccumulated\t=  0.0;\n    s.showUI\t\t\t=  1.0;\n\n    s.coin0Pos\t\t= 0.0;\n    s.coin0Taken\t= 0.0;\n    s.coin1Pos\t\t= 0.0;        \n    s.coin1Taken\t= 0.0;\n    s.coin2Pos\t\t= 0.0;        \n    s.coin2Taken\t= 0.0;\n    s.coin3Pos\t\t= 0.0;        \n    s.coin3Taken\t= 0.0;    \n    \n    return s;\n}\n\nvec4 saveState( in AppState s, in vec2 fragCoord, int iFrame, float iTime )\n{\n    if (iFrame <= 0)\n    {\n        s.seed = fbm3( iDate.yzw );\n \t\ts = setStateStartGame( s, iTime );\n\t}\n    \n    vec4 ret = vec4( 0.);\n\tstoreValue( vec2( 0., 0. ), vec4( s.isPressedLeft,\t\ts.isPressedRight,\ts.stateID,\t\t\ts.timeStarted),\tret, fragCoord );    \n\tstoreValue( vec2( 1., 0. ), vec4( s.playerPos,\t\t\t\t\t\t\t\ts.score,\t\t\ts.timeFailed),\tret, fragCoord );\n\tstoreValue( vec2( 2., 0. ), vec4( s.highscore,\t\t\ts.timeCollected,\ts.timeAccumulated,\ts.showUI),\t\tret, fragCoord );\n    storeValue( vec2( 3., 0. ), vec4( s.paceScale,\t\t\ts.seed,\t\t\t\t0.0,\t\t\t\t0.0),\t\t\tret, fragCoord );\n    \n    storeValue( vec2( 0., 1. ), vec4( s.coin0Pos, s.coin0Taken, s.coin1Pos, s.coin1Taken ), ret, fragCoord );\n    storeValue( vec2( 1., 1. ), vec4( s.coin2Pos, s.coin2Taken, s.coin3Pos, s.coin3Taken ), ret, fragCoord );\n    return ret;\n}\n\n\/\/ math\n\nfloat saturate( float x ) { return clamp( x, 0., 1. ); }\n\nvec3 saturate( vec3 x ) { return clamp( x, vec3( 0. ), vec3( 1. ) ); }\n\nmat2 rot( float a ) { float s = sin( a ); float c = cos( a ); return mat2( c, -s, s, c ); }\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize( ta - ro );\n\tvec3 cp = vec3( sin( cr ), cos( cr ), 0.0 );\n\tvec3 cu = normalize( cross( cw, cp ) );\n\tvec3 cv =          ( cross( cu, cw ) );\n    return mat3( cu, cv, cw );\n}\n\nfloat impulse( float k, float x ) {\n    float h = k * x;\n    return h * exp( 1.0 - h );\n}\n\n\/\/-----------------------------------------------------------------\n\/\/ Digit drawing function by P_Malin (https:\/\/www.shadertoy.com\/view\/4sf3RN)\n\nfloat sampleDigit( const in float n, const in vec2 vUV )\n{\t\t\n\tif ( vUV.x  < 0.0 ) return 0.0;\n\tif ( vUV.y  < 0.0 ) return 0.0;\n\tif ( vUV.x >= 1.0 ) return 0.0;\n\tif ( vUV.y >= 1.0 ) return 0.0;\n\t\n\tfloat data = 0.0;\n\t\n\t     if( n < 0.5 ) data = 7.0 + 5.0 * 16.0 + 5.0 * 256.0 + 5.0 * 4096.0 + 7.0 * 65536.0;\n\telse if( n < 1.5 ) data = 2.0 + 2.0 * 16.0 + 2.0 * 256.0 + 2.0 * 4096.0 + 2.0 * 65536.0;\n\telse if( n < 2.5 ) data = 7.0 + 1.0 * 16.0 + 7.0 * 256.0 + 4.0 * 4096.0 + 7.0 * 65536.0;\n\telse if( n < 3.5 ) data = 7.0 + 4.0 * 16.0 + 7.0 * 256.0 + 4.0 * 4096.0 + 7.0 * 65536.0;\n\telse if( n < 4.5 ) data = 4.0 + 7.0 * 16.0 + 5.0 * 256.0 + 1.0 * 4096.0 + 1.0 * 65536.0;\n\telse if( n < 5.5 ) data = 7.0 + 4.0 * 16.0 + 7.0 * 256.0 + 1.0 * 4096.0 + 7.0 * 65536.0;\n\telse if( n < 6.5 ) data = 7.0 + 5.0 * 16.0 + 7.0 * 256.0 + 1.0 * 4096.0 + 7.0 * 65536.0;\n\telse if( n < 7.5 ) data = 4.0 + 4.0 * 16.0 + 4.0 * 256.0 + 4.0 * 4096.0 + 7.0 * 65536.0;\n\telse if( n < 8.5 ) data = 7.0 + 5.0 * 16.0 + 7.0 * 256.0 + 5.0 * 4096.0 + 7.0 * 65536.0;\n\telse if( n < 9.5 ) data = 7.0 + 4.0 * 16.0 + 7.0 * 256.0 + 5.0 * 4096.0 + 7.0 * 65536.0;\n\t\n\tvec2 vPixel = floor( vUV * vec2( 4.0, 5.0 ) );\n\tfloat fIndex = vPixel.x + ( vPixel.y * 4.0 );\n\t\n\treturn mod( floor( data \/ pow( 2.0, fIndex ) ), 2.0 );\n}\n\nfloat printInt( const in vec2 uv, const in float value )\n{\n\tfloat res = 0.0;\n\tfloat maxDigits = 1.0 + ceil( log2( value ) \/ log2( 10.0 ) );\n\tfloat digitID = floor( uv.x );\n\tif( digitID > 0.0 && digitID < maxDigits )\n\t{\n        float digitVa = mod( floor( value \/ pow( 10.0, maxDigits - 1.0 - digitID ) ), 10.0 );\n        res = sampleDigit( digitVa, vec2( fract( uv.x ), uv.y ) );\n\t}\n\n\treturn res;\t\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdXGzn","filepath":"\/media\/a\/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"\/media\/ap\/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"\/media\/a\/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"\/media\/ap\/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\/\/ Copyright \u00a9 2019 Michal Klos\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ Sunset Drive Unlimited\n\/\/  Endless runner with synthwave stylization\n\/\/\t\"Brick Driver\" sequel, because it missed fluent turning and coins:\n\/\/\thttps:\/\/www.shadertoy.com\/view\/wssSD4\n\n\/\/ #define options in Common tab\n\/\/  Some effects can be disabled on low end gpus\n\n\/\/ Gameplay is based on Brick Game Racing,\n\/\/  https:\/\/youtu.be\/EdMyKRC8qyU\n\n\/\/ First draft created in 24h on Game Jam Square 26-28.04.2019\n\/\/\tFinished after couple of spare evenings on 24.06.2019\n\n\/\/ Based on:\n\/\/ - \"80's raymarching\" by villedieumorgan. https:\/\/shadertoy.com\/view\/lsVSRt\n\/\/ - \"[SH16B] Speed Drive 80\" by knarkowicz. https:\/\/shadertoy.com\/view\/4ldGz4\n\/\/ Other snippets credits in comments next to the code\n\/\/ Thank you guys for sharing it, hope you like it :)\n\n\/\/ Music: Lifelike - So Electric\n\/\/  https:\/\/soundcloud.com\/rombo_rama\/lifelike-so-electric\n\n\n\nAppState g_S;\n\nfloat g_glowCoin = 1e10;\nfloat g_glowCoinRefl = 1e10;\nfloat g_glowEnemy = 1e10;\nfloat g_glowEnemyRefl = 1e10;\nfloat g_glowPlayer = 1e10;\nfloat g_glowPlayerRefl = 1e10;\nfloat g_glowPlayerFront = 1e10;\nfloat g_glowPlayerLights = 1e10;\nfloat g_cameraMode = 0.0;\n\nconst float GRID_SIZE = 0.5;\nconst float GRID_LINE_SIZE = 1.25;\n\nconst float GRID_CAR_SIZE = 0.5;\nconst float GRID_CAR_LINE_SIZE = 1.5;\n\nconst vec3 GRID_COLOR_1 = vec3(0.00, 0.02, 0.20);\nconst vec3 GRID_COLOR_2 = vec3(26.00, 14.0, 122.0)\/255.;\n\nconst vec3 SUN_DIRECTION = vec3(0.0, 0.025, 0.5);\nconst vec3 SKY_COLOR_1 = vec3(49., 33., 66.)\/255.;\nconst vec3 SKY_COLOR_2 = vec3(0.00,0.02,0.20);\n\nconst vec3 SUN_COLOR_1 = vec3(1.0, 0.3, 0.1) * 0.5;\nconst vec3 SUN_COLOR_2 = vec3(1.0, 1.0, 0.1) * 0.5;\n\nconst vec3 CAR_COLOR_1 = vec3(1.0, 0.5, 0.1) * 0.0;\nconst vec3 CAR_COLOR_2 = vec3(1.0, 0.0, 0.0) * 1.5;\n\nconst vec3 CAR_PLAYER_COLOR_1 = vec3(0.1, 1.0, 0.5) * 0.1;\nconst vec3 CAR_PLAYER_COLOR_2 = vec3(0.1, 1.0, 0.5) * 1.5;\n\nconst vec3 FOG_COLOR = vec3(193.00, 24.0, 123.0)\/255.;\n\n\nstruct sHit {\n    float t;\n    float m;\n    vec3 lPos;\n};\n    \nsHit createHit( float t, float m, vec3 lPos )\n{\n    sHit h;\n    h.t = t;\n    h.m = m;\n    h.lPos = lPos;\n    return h;\n}\n\nvoid drawCoin( inout vec3 color, vec2 p, vec2 coinPos )\n{  \n    float sCoin = length(\n        p\n        -vec2( 0.0, coinPos.y )\t\/\/ cell pos\n        +vec2( 0.5, -0.5 )\t\t\/\/ move to cell center\n        -vec2( coinPos.x, 0.0 ) \/\/ move to column\n    ) - 0.25; \t\t\t\t\t\/\/ radius of coin\n\n    color.rgb = mix( vec3( 1.0, 1.0, 0.0 ), color.rgb, smoothstep( 0.0, 0.1, sCoin ) );\n}\n\nvoid drawGameFlat( inout vec4 color, vec2 p, AppState s )\n{\n    \/\/ game\n\tvec2 p0 = p;    \n    \/\/ float cameraAnim = smoothstep(-0.5, 0.5, sin(iTime) );\n    float cameraAnim = 0.0;\n\tp0 *= mix( 5.0, 10.0, cameraAnim );\t\t\/\/ scale field of view\n    p0.x += 0.25;\t\t\t\t\t\t\t\/\/ fix track centering\n    p0.y += mix( 2.0, 8.0, cameraAnim );\t\/\/ move camera pos\n    p0.y += s.playerPos.y;\n    \n    float playerCellID = floor( s.playerPos.y );\n    float sPlayer = length( p0 - s.playerPos ) - 0.25;\n           \n    vec2 p1 = p0;\n    p1.y += 2.0 * s.playerPos.y;\n    color.rgb = mix( vec3( 1.0 ), color.rgb, smoothstep( 1.5, 1.75, abs( p1.x - 0.5 ) ) );\n    color.rgb = mix( texture( iChannel2, fract( p1 ) ).rgb, color.rgb, 0.5 );\n       \n\t\/\/ COIN start\n    float cellID = floor( p0.y );\n    float cellCoinRND = hash11( cellID + g_S.seed );\t\t\t\t\t\/\/ skip rnd obstacle every second cell to make room for driving    \n    cellCoinRND *= mix( 1.0, -1.0, step( mod( cellID, 4.0 ), 1.5 ) );\t\/\/ gaps in coin placing: 2 gaps, 2 coins\n    cellCoinRND = mix( cellCoinRND, -1.0, step (cellID, 5.0 ) );\t\t\/\/ head start\n    float cellCoinCol = floor( 3.0 * cellCoinRND );\n       \n    if ( cellCoinRND >= 0.0 )\n    {\n        if ( cellID > playerCellID )\n           \tdrawCoin( color.rgb, p0, vec2( cellCoinCol, cellID ) );\n        \n        if ( cellID == playerCellID && s.coin0Taken < 0.5 )\n            drawCoin( color.rgb, p0, vec2( cellCoinCol, cellID ) );\n        \n        if ( cellID == playerCellID - 1.0 && s.coin1Taken < 0.5 )\n            drawCoin( color.rgb, p0, vec2( cellCoinCol, cellID ) );\n        \n        if ( cellID == playerCellID - 2.0 && s.coin2Taken < 0.5 )\n            drawCoin( color.rgb, p0, vec2( cellCoinCol, cellID ) );\n       \n        if ( cellID == playerCellID - 3.0 && s.coin3Taken < 0.5 )\n            drawCoin( color.rgb, p0, vec2( cellCoinCol, cellID ) );\n    }    \n\/\/ COIN end\n\n\/\/ OBSTACLE start\n    float cellObsRND = hash11( 100.0 * cellID + g_S.seed );\t\t\/\/ skip rnd obstacle every second cell to make room for driving\n    cellObsRND *= mix( 1.0, -1.0, step( mod( cellID, 3.0 ), 1.5 ) );\n    cellObsRND = mix( cellObsRND, -1.0, step( cellID, 7.0) );\t\/\/ head start\n    float cellObsCol = floor( 3.0 * cellObsRND );\n    \n\tif ( cellObsRND >= 0.0 && cellObsCol != cellCoinCol )\n    {        \n    \tfloat sObstacle = length(\n            p0\n            -vec2( 0.0, cellID )\t\t\/\/ cell pos\n            +vec2( 0.5, -0.5 )\t\t\t\/\/ move to cell center\n            -vec2( cellObsCol, 0.0 )\t\/\/ move to column\n        ) - 0.25;\t\t\t\t\t\t\/\/ radius of coin\n        \n    \tcolor.rgb = mix( vec3( 1.0, 0.0, 0.0 ), color.rgb, smoothstep( 0.0, 0.1, sObstacle ) );\n        \n        vec2 obstaclePos = -vec2( 0.0, cellID )\t\t\t\/\/ cell pos\n            \t\t\t\t+vec2( 0.5, -0.5 )\t\t\t\/\/ move to cell center\n            \t\t\t\t-vec2( cellObsCol, 0.0 );\t\/\/ move to column\n\n        float distObstaclePlayer = length( obstaclePos + s.playerPos );\n        \n        if ( distObstaclePlayer < 0.5 ) \n        {\n            color.rgb += vec3( 0.5 );\n        }\n    }\n    \n    color.rgb = mix( vec3( 0.0, 1.0, 0.0 ), color.rgb, smoothstep( 0.0, 0.1, sPlayer ) );\n\n\/\/ OBSTACLE end        \n\n}\n\nfloat circle( vec2 p, float r )\n{\n    return ( length( p \/ r ) - 1. ) * r;\n}\n\nvoid opRotate( inout vec2 p, float a ) \n{\n    p = cos( a ) * p + sin( a ) * vec2( p.y, -p.x );\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn ( d1.x < d2.x ) ? d1 : d2;\n}\n\nsHit opUS( sHit d1, sHit d2 )\n{\n    if ( d1.t < d2.t )\n        return d1;\n    else \n        return d2;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n   \tp = vec3( p.z, p.x, -p.y ); \/\/ Coord fix\n    \/\/ n must be normalized\n          \n    vec3 p0 = vec3(p.x, p.y, p.z);\n\n    float fgProf = 0.2 * smoothstep( 1.5, 2.0, abs( p0.y ) );\n    float bgProf = 1.0 * smoothstep( 3.5, 4.5, abs( p0.y ) );\n    float fg = 0.15 * p.y * p.y * fgProf + fgProf * clamp( texture( iChannel2, p0.xy \/ 10. ).r, 0.0, 1.0 );\n    float bg = 0.1 * fgProf + bgProf * clamp( texture( iChannel2, p0.xy \/ 40.).r, 0.0, 1.0 );\n    float displace = 1.5 * fg + 2.5 * bg;\n    \n    float sGround = dot(\n        vec3( p.x, p.y, max( p.z + displace, p.z ) ),\n        n.xyz )\n        + n.w;\n    \n    sGround *= 0.5;\n    \n  \treturn sGround;\n}\n\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length( p ) - s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs( p ) - b;\n    return min( max( d.x, max( d.y, d.z ) ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot( pa, ba ) \/ dot( ba, ba ), 0.0, 1.0 );\n\treturn length( pa - ba * h ) - r;\n}\n\nfloat opUnion( float a, float b )\n{\n    return min( a, b );\n}\n\nfloat opIntersect( float a, float b )\n{\n    return max( a, b );\n}\n\nfloat opSubstract( float a, float b )\n{\n    return max( a, -b );\n}\n\nfloat opSubstractChamfer( float a, float b, float r ) \n{\n    return max( max( a, -b ), ( a + r - b ) * 0.70711 );\n}\n\nfloat plane( vec3 p, vec4 plane ) \n{\n    return dot( p, plane.xyz ) + plane.w;\n}\n\nfloat box( vec3 p, vec3 b )\n{\n    vec3 d = abs( p ) - b;\n    return min( max( d.x, max( d.y, d.z ) ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\nfloat cylinder( vec3 p, float r, float height ) \n{\n    float d = length( p.xz ) - r;\n    d = max( d, abs( p.y ) - height );\n    return d;\n}\n\nfloat sphere( vec3 p, float s )\n{\n    return length( p ) - s;\n}\n\nvec2 sdColumn( vec3 p, float r, float id )\n{\n    return vec2( ( ( abs( p.x ) + abs( p.y ) ) - r ) \/ sqrt( 2.0 ), id );\n}\n\nfloat sdCoin( vec3 p, float id )\n{       \n    float sCyl = cylinder( p.yzx, 0.1, 0.02 );    \n\n    if ( id == 2.0 )\n        g_glowCoin = min( g_glowCoin, sCyl );\n    \n    if ( id == 12.0 )\n    \tg_glowCoinRefl = min( g_glowCoin, sCyl );\n    \n    return sCyl;\n}\n\n\/\/ From \"[SH16B] Speed Drive 80\" by knarkowicz. https:\/\/shadertoy.com\/view\/4ldGz4\nfloat car( vec3 p, float id )\n{        \n    p *= 5.5;\n    \n    p.x = -p.x;     \n    p.y -= 0.3;\n    \n    float a = box( p, vec3( 4.2, 0.9, 1.8 ) );   \n    \n    vec3 t = p + vec3( -6.0, 0.0, 0.0 );\n    opRotate( t.yx, 0.2 );\n    float b = plane( t, vec4( 0.0, -1.0, 0.0, 0.0 ) );\n    \n    t = p + vec3( -5.0, 0.0, 0.0 );\n    opRotate( t.yx, -0.4 );\n    float c = plane( t, vec4( 0.0, 1.0, 0.0, 0.0 ) );    \n    \n    t = p + vec3( 2.0, -0.2, 0.0 );\n    opRotate( t.yx, -0.4 );\n    float d = plane( t, vec4( 0.0, -1.0, 0.0, 0.0 ) );   \n    \n    t = p + vec3( 2.0, -0.3, 0.0 );\n    opRotate( t.yx, -0.05 );\n    float e = plane( t, vec4( 0.0, -1.0, 0.0, 0.0 ) );       \n    \n    t = p + vec3( 2.0, 1.0, 0.0 );\n    opRotate( t.yx, 0.2 );\n    float f = plane( t, vec4( 0.0, 1.0, 0.0, 0.0 ) );     \n        \n    if ( id == 1.0 )\n    {\n        float bloomF = box( t + vec3( -0.5, 0.7, 0.0 ), vec3( 0.1, 0.3, 1.5 ) );\n        t.z = abs( t.z );\n        t.z -= 1.5;       \n        float bloomB = box( t + vec3( -4.4, -0.2, 0.0 ), vec3( 0.2, 0.4, 0.2 ) );\n    \tg_glowPlayer = min( g_glowPlayer, 1.0 \/ 5.5 * min( bloomF, bloomB ) );\n    }\n    \n    if ( id == 3.0 )\n        g_glowEnemy = min( g_glowEnemy, 1.0 \/ 5.5 * box( t + vec3( -2.0, 0.7, 0.0 ), vec3( 3.0, 1.0, 1.0 ) ) );\n\n    t = p + vec3( 1.0, -0.6, 0.0 );\n    opRotate( t.yx, -0.4 );\n    float frontWindow = box( t, vec3( 0.6, 0.05, 1.6 ) );\n    \n    t = p + vec3( -2.5, -0.7, 0.0 );\n    opRotate( t.yx, 0.2 );\n    float backWindow = box( t, vec3( 1.0, 0.05, 1.6 ) );\n    \n    float body = opSubstract( a, opUnion( opUnion( opUnion( b, c ), opIntersect( d, e ) ), f ) );\n    \n    t = p;\n    t.z = -abs( t.z );\n    t += vec3( 0.0, -0.8, 1.2 );\n    opRotate( t.yz, -0.9 );\n    float sideCutPlanes = plane( t, vec4( 0.0, -1.0, 0.0, 0.0 ) );      \n    \n    body = opSubstractChamfer( body, opUnion( backWindow, frontWindow ), 0.1 );\n    body = opSubstractChamfer( body, sideCutPlanes, 0.05 );\n    \n    p.x += 0.1;\n    p.xz = abs( p.xz );\n    t = p.xzy - vec3( 2.4, 1.5, -0.65 );\n    float wheel = cylinder( t, 0.7, 1.0 );\n    body = opSubstract( body, wheel );\n    t.y -= .1;\n    wheel = opSubstract( cylinder( t, 0.6, 0.3 ), sphere( t + vec3( 0.0, -0.45, 0.0 ), 0.45 ) );\n    \n    body = opUnion( body, wheel );\n    \n    body \/= 5.5;\n    \n    return body;\n}\n\nfloat carFront( vec3 p, float id )\n{        \n    \/\/ front lights\n    p.z = abs( p.z );\n    p.z -= 0.2;\n    float front = cylinder( p.zxy + vec3( -0.06, -0.77, -0.02 ), 0.05, 0.01 );\n    \n    if ( id == 1.5 )\n        g_glowPlayerFront = min( g_glowPlayerFront, front );\n       \n    return front;\n}\n\nfloat carLights( vec3 p, float id )\n{        \n    \/\/ back lights\n    p.z = abs( p.z );\n    p.z -= 0.2;\n    float back = box( p + vec3( 0.75, -0.09, 0.0 ), vec3( 0.02, 0.02, 0.075 ) );\n    \n    if ( id == 1.5 )\n    \tg_glowPlayerLights = min( g_glowPlayerLights, back );\n       \n    return back;\n}\n\n\nfloat carRefl( vec3 p, float id )\n{        \n    float body = box( p + vec3( 0.0, -0.07, 0.0 ), vec3( 0.6, 0.02, 0.2) );\n    body = min( body, box( p + vec3( 0.2, -0.1, 0.0 ), vec3( 0.4, 0.02, 0.2 ) ) );\n    \n    \/\/ back lights\n    p.z = abs( p.z );\n    p.z -= 0.2;\n    float bloom = box( p + vec3( 0.75, -0.09, 0.0 ), vec3( 0.02, 0.02, 0.075 ) );    \n    \n    bloom = min( bloom, body );\n    \n    if ( id == 1.5 )\n    \tg_glowPlayerRefl = min( g_glowPlayerRefl, bloom );\n    \n    if ( id == 3.5 )\n        g_glowEnemyRefl = min( g_glowEnemyRefl, bloom );\n       \n    return body;\n}\n\nvec2 getBent()\n{\n    float bentSide\t= sin( g_S.timeAccumulated \/ PI );\n    float bentUp\t= ( ( cos( 0.25 * g_S.timeAccumulated \/ PI ) * 0.5 ) + 0.5 ) * 1.5;\n    return vec2( bentSide, bentUp );\n}\n\nsHit map( in vec3 pos )\n{\n    sHit sRes = createHit( 1e10, 0.0, pos );\n\n\t\/\/ player, in place in fact\n    vec2 bent = getBent();\n    \n    \/\/ game\n    vec3 p0 = pos;    \n    \/\/ bending    \n    p0.x -= 1.5 * sin( 0.05 * p0.z * PI ) * bent.x;\n    p0.y += 1.5 * sin( 0.05 * p0.z * PI ) * bent.y;\n   \n    vec3 pPlayer = pos -vec3( g_S.playerPos.x, 0.25, 0.0 );\n    \n    pPlayer.xz *= rot(  0.2 * bent.x );\n    pPlayer.yz *= rot( -0.2 * bent.y );\n    \/\/ sRes = opUS( sRes, CreateHit( sdBox( pPlayer, vec3(0.5, 0.2, 0.5) ) - 0.01, 1.0, pPlayer) ); \/\/ debug collider\n    \n\tfloat rotY = -.2 * g_S.isPressedLeft + .2 * g_S.isPressedRight;\n    float rotX = -.1 * g_S.isPressedLeft + .1 * g_S.isPressedRight;    \n    pPlayer.xz *= rot( -0.01 * PI * bent.y + rotY -0.5 * PI );\n    pPlayer.yz *= rot( -0.01 * PI * bent.x + rotX );\n    \/\/ pPlayer.yz *= rot( -10.0*iTime ); \/\/ mothman\n    pPlayer.y += 0.05;    \n    sRes = opUS( sRes, createHit( car( pPlayer, 1.0 ), 1.0, pPlayer ) );\n\tsRes = opUS( sRes, createHit( carLights( pPlayer, 1.5 ), 1.5, pPlayer ) );\n    sRes = opUS( sRes, createHit( carFront( pPlayer, 1.6 ), 1.6, pPlayer ) );\n    \n    vec3 pEnv = p0;\n    pEnv.z += 2.0 * g_S.playerPos.y;\n    pEnv.x -= 0.5;\n    sRes = opUS( sRes, createHit( sdPlane( pEnv, vec4( 0, 0, -1, 0 ) ), 0.0, vec3( pEnv.x, 0.0, pEnv.z ) ) );\n    \n    p0.z *= 0.5;\n    p0.z += g_S.playerPos.y;\n    \n    vec3 p0Mod = p0;\n    p0Mod.z = mod( p0.z + 0.5, 1.0 ) - 0.5;\n                \n    float playerCellID = floor( g_S.playerPos.y );\n   \n    \/\/ COIN start\n    float cellID = floor( p0.z + 0.5 );\n    \n    float cellCoinRND = hash11( cellID + g_S.seed ); \/\/ skip rnd obstacle every second cell to make room for driving    \n    cellCoinRND *= mix( 1.0, -1.0, step( mod( cellID, 4.0 ), 1.5 ) ); \/\/ gaps in coin placing: 2 gaps, 2 coins\n    cellCoinRND = mix( cellCoinRND, -1.0, step( cellID, 5.0 ) ); \/\/ head start\n    float cellCoinCol = floor( 3.0 * cellCoinRND );\n    \n    if (cellCoinRND >= 0.0)\n    {\n        vec3 pCoin = p0Mod; \n        float bounce = 0.3 * abs( sin( 5.0 * iTime + cellID ) );\n        vec3 coinOffset = vec3( -0.5  + cellCoinCol, 0.4 + bounce, 0.0 );\n        pCoin -= coinOffset;\n        pCoin.z *= 2.0;\n        pCoin.xz *= rot( 10.0 * iTime );\n                \n        if ( cellID > playerCellID )\n            sRes = opUS( sRes, createHit( sdCoin( pCoin, 2.0 ) - 0.01, 2.0, pCoin ) );\n        \n        if ( cellID == playerCellID && g_S.coin0Taken < 0.5 )\n        \tsRes = opUS( sRes, createHit( sdCoin( pCoin, 2.0 ) - 0.01, 2.0, pCoin ) );\n        \n        if ( cellID == playerCellID - 1.0 && g_S.coin1Taken < 0.5 )\n        \tsRes = opUS( sRes, createHit( sdCoin( pCoin, 2.0 ) - 0.01, 2.0, pCoin ) );\n        \n        if ( cellID == playerCellID - 2.0 && g_S.coin2Taken < 0.5 )\n        \tsRes = opUS( sRes, createHit( sdCoin( pCoin, 2.0 ) - 0.01, 2.0, pCoin ) );\n        \n        if ( cellID == playerCellID - 3.0 && g_S.coin3Taken < 0.5 )\n        \tsRes = opUS( sRes, createHit( sdCoin( pCoin, 2.0 ) - 0.01, 2.0, pCoin ) );\n    }    \n       \n    float cellObsRND = hash11( 100.0 * cellID + g_S.seed ); \/\/ skip rnd obstacle every second cell to make room for driving\n    cellObsRND *= mix( 1.0, -1.0, step( mod( cellID, 3.0 ), 1.5 ) );\n    cellObsRND = mix( cellObsRND, -1.0, step( cellID, 7.0 ) ); \/\/ head start\n    float cellObsCol = floor( 3.0 * cellObsRND );\n\n    if ( cellObsRND >= 0.0 && cellObsCol != cellCoinCol )\n    {            \n        vec3 obstacleOffset = vec3(\n            -0.5 + cellObsCol,  \n             0.2,\n             0.0\n        );\n\n        \/\/ sRes = opUS( sRes, CreateHit( sdBox( p0Mod -obstacleOffset, vec3(0.5, 0.1, 0.5) ) - 0.01, 3.0, p0Mod ) ); \/\/ debug colider\n        p0Mod -= obstacleOffset;\n        p0Mod.z *= 2.0;\n        p0Mod.xz *= rot( -0.5 * PI );\n        sRes = opUS( sRes, createHit( car( p0Mod, 3.0 ), 3.0, p0Mod ) );\n        sRes = opUS( sRes, createHit( carLights( p0Mod, 3.5 ), 3.5, p0Mod ) );\n        sRes = opUS( sRes, createHit( carFront( p0Mod, 3.6 ), 3.6, p0Mod) );\n    }\n\n    return sRes;\n}\n\nsHit mapRefl( in vec3 pos )\n{\n    sHit sRes = createHit( 1e10, -1.0, pos );\n\n    vec2 bent = getBent();\n    vec3 p0 = pos;    \n    p0.x -= 1.5 * sin( 0.05 * p0.z * PI) * bent.x;\n    p0.y += 1.5 * sin( 0.05 * p0.z * PI) * bent.y;\n   \n    float rotY = -.2 * g_S.isPressedLeft + .2 * g_S.isPressedRight;\n    float rotX = -.1 * g_S.isPressedLeft + .1 * g_S.isPressedRight;    \n    vec3 pPlayer = pos - vec3( g_S.playerPos.x, 0.25, 0.0 );\n    pPlayer.xz *= rot(  0.2 * bent.x );\n    pPlayer.yz *= rot( -0.2 * bent.y );\n    pPlayer.xz *= rot( -0.01 * PI * bent.y + rotY -0.5 * PI);\n    pPlayer.yz *= rot( -0.01 * PI * bent.x + rotX);\n    pPlayer.y += 0.05;\n\tsRes = opUS( sRes, createHit( carRefl( pPlayer, 1.5 ), 1.5, pPlayer) );\n\n    p0.z *= 0.5;\n    p0.z += g_S.playerPos.y;      \n    \n    vec3 p0Mod = p0;\n    p0Mod.z = mod( p0.z + 0.5, 1.0 ) -0.5;\n                \n    float playerCellID = floor( g_S.playerPos.y );\n   \n    \/\/ COIN start\n    float cellID = floor( p0.z + 0.5 );\n    \n    float cellCoinRND = hash11( cellID + g_S.seed ); \/\/ skip rnd obstacle every second cell to make room for driving    \n    cellCoinRND *= mix( 1.0, -1.0, step( mod( cellID, 4.0 ), 1.5 ) ); \/\/ gaps in coin placing: 2 gaps, 2 coins\n    cellCoinRND = mix( cellCoinRND, -1.0, step( cellID, 5.0 ) ); \/\/ head start\n    float cellCoinCol = floor( 3.0 * cellCoinRND );\n    \n    if ( cellCoinRND >= 0.0 )\n    {\n        vec3 pCoin = p0Mod; \n        float bounce = 0.3 * abs( sin( 5.0 * iTime + cellID ) );\n        vec3 coinOffset = vec3( -0.5 + cellCoinCol, 0.4 + bounce, 0.0 );\n        pCoin -= coinOffset;\n        pCoin.z *= 2.0;\n        pCoin.xz *= rot( 10.0 * iTime );\n                \n        if ( cellID > playerCellID )\n            sRes = opUS( sRes, createHit( sdCoin( pCoin, 12.0 ) - 0.01, 2.0, pCoin ) );\n        \n        if ( cellID == playerCellID && g_S.coin0Taken < 0.5 )\n        \tsRes = opUS( sRes, createHit( sdCoin( pCoin, 12.0 ) - 0.01, 2.0, pCoin ) );\n        \n        if ( cellID == playerCellID - 1.0 && g_S.coin1Taken < 0.5 )\n        \tsRes = opUS( sRes, createHit( sdCoin( pCoin, 12.0 ) - 0.01, 2.0, pCoin ) );\n        \n        if ( cellID == playerCellID - 2.0 && g_S.coin2Taken < 0.5 )\n        \tsRes = opUS( sRes, createHit( sdCoin( pCoin, 12.0 ) - 0.01, 2.0, pCoin ) );\n        \n        if ( cellID == playerCellID - 3.0 && g_S.coin3Taken < 0.5 )\n        \tsRes = opUS( sRes, createHit( sdCoin( pCoin, 12.0 ) - 0.01, 2.0, pCoin ) );\n    }    \n       \n    float cellObsRND = hash11( 100.0 * cellID + g_S.seed ); \/\/ skip rnd obstacle every second cell to make room for driving\n    cellObsRND *= mix( 1.0, -1.0, step( mod( cellID, 3.0 ), 1.5 ) );\n    cellObsRND = mix( cellObsRND, -1.0, step( cellID, 7.0 ) ); \/\/ head start\n    float cellObsCol = floor( 3.0 * cellObsRND );\n\n    if ( cellObsRND >= 0.0 && cellObsCol != cellCoinCol )\n    {            \n        vec3 obstacleOffset = vec3(\n            -0.5 + cellObsCol,  \n             0.2,\n             0.0\n        );\n\n        p0Mod -= obstacleOffset;\n        p0Mod.z *= 2.0;\n        p0Mod.xz *= rot( -0.5 * PI );\n        sRes = opUS( sRes, createHit( carRefl( p0Mod, 3.5), 3.5, p0Mod ) );\n    }\n\n    return sRes;\n}\n\n\n\/\/ https:\/\/iquilezles.org\/articles\/boxfunctions\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0 \/ rd;\n    vec3 n = m * ro;\n    vec3 k = abs( m ) * rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nsHit castRay( in vec3 ro, in vec3 rd, float tmin, float tmax )\n{\n    sHit sRes = createHit( -1.0, -1.0, rd );\n\n    \/\/ raymarch primitives   \n    vec2 tb = iBox( ro - vec3( 0.0, 0.0, 15.0 ), rd, vec3( 7.0, 4.0, 45.0 ) );\n    \n    if( tb.x < tb.y && tb.y > 0.0 && tb.x < tmax )\n    {\n        tmin = max( tb.x, tmin );\n        tmax = min( tb.y, tmax );       \n\n        float t = tmin;\n        for( int i = ZERO; i < 128 && t < tmax; i++ )\n        {\n            sHit h = map( ro + rd * t );\n            if( abs( h.t ) < ( 0.001 * t ) )\n            { \n                \/\/ res = vec2(t,h.y); \n                sRes = createHit( t, h.m, h.lPos ); \n                break;\n            }\n            t += h.t;\n        }\n    }\n    \n    return sRes;\n}\n\nsHit castRayRefl( in vec3 ro, in vec3 rd, float tmin, float tmax )\n{\n    sHit sRes = createHit( -1.0, -1.0, rd );\n\n    \/\/ raymarch primitives   \n    vec2 tb = iBox( ro - vec3( 0.0, 0.0, 5.0 ), rd, vec3( 4.0, 4.0, 25.0 ) );\n    \n    if( tb.x < tb.y && tb.y > 0.0 && tb.x < tmax )\n    {\n        tmin = max( tb.x, tmin );\n        tmax = min( tb.y, tmax );       \n\n        float t = tmin;\n        for( int i = ZERO; i < 32 && t < tmax; i++ )\n        {\n            sHit h = mapRefl( ro + rd * t );\n            if( abs( h.t ) < ( 0.001 * t ) )\n            { \n                sRes = createHit( t, h.m, h.lPos ); \n                break;\n            }\n            t += h.t;\n        }\n    }\n\n    return sRes;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n#if 1\n    \/\/ vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    vec2 e = vec2( 1.0, -1.0 ) * 0.5773 * 0.01;\n    return normalize( e.xyy*map( pos + e.xyy ).t + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).t + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).t + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).t );\n#else\n    \/\/ inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3( 0.0 );\n    for( int i = ZERO; i < 4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e * map( pos + 0.0005 * e ).x;\n    }\n    return normalize( n );\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i = ZERO; i < 5; i++ )\n    {\n        float hr = 0.01 + 0.12 * float( i ) \/ 4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).t;\n        occ += -( dd - hr ) * sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0 * occ, 0.0, 1.0 ) * (0.5 + 0.5 * nor.y );\n}\n\nvec3 getSkyColor( vec3 rd )\n{\n    vec3 color = mix( SKY_COLOR_1 * 1.4, SKY_COLOR_2, rd.y \/ 9.0 );\n\t\n    float fogFalloff = clamp( 8.0 * rd.y, 0.0, 1.0 );\n    color = mix( FOG_COLOR, color, fogFalloff );\n    color = mix( color, GRID_COLOR_1, smoothstep( -0.1, -0.2, rd.y ) );\n\n    vec3 sunDir = normalize( SUN_DIRECTION );\n    float sunGlow = smoothstep( 0.9, 1.0, dot( rd, sunDir ) );\n        \n    rd = mix( rd, sunDir, -1.0 ); \/\/ easier to bend vectors than fiddle with falloff :P\n    float sun = smoothstep( 0.987, 0.99, dot(rd, sunDir ) );\n    sun -= smoothstep( 0.1, 0.9, 0.5 );\t\t\t        \n    \n    float stripes = mod( 50.0 * ( pow( rd.y + 0.15, 1.5 ) ) + 0.5, 1.0 ) -0.5;\n    stripes = smoothstep( 0.2, 0.21, abs( stripes ) );\n        \n    \n    \/\/ based on https:\/\/www.shadertoy.com\/view\/tssSz7\n    vec2 starTile   = floor( rd.xy * 40.0 );\n    vec2 starPos    = fract( rd.xy * 40.0 ) * 2.0 - 1.0;\n    vec2 starRand = hash22( starTile );\n    starPos += starRand * 2.0 - 1.0;\n    float stars = saturate( 1.0 - ( ( sin( iTime * 1.0 + 50.0 * rd.y ) ) * 0.5 + 6.0 ) * length( starPos ) );\n    stars *= step( 0.0, -sun );\n    stars *= step( 0.9, starRand.x );\n    stars *= 5.0;\n           \n    sun = 2.0 * clamp( sun * stripes, 0.0, 1.0 );\n    \n    vec3 sunCol = 4.0 * mix( SUN_COLOR_1, SUN_COLOR_2, -( rd.y - 0.1 ) \/ 0.3 );\n    color = mix( color, sunCol, sun );\n\n\tcolor = mix( FOG_COLOR, color, 0.8 + 0.2 * fogFalloff );\n    color = mix( color, sunCol, 0.25 * sunGlow );\n    \n    color += stars;\n\n    \/\/ return vec3(stripes);\n    \/\/ return vec3(sun);\n    \/\/ return vec3(sunGlow);\n    return color;\n}\n\nvec4 shade( vec3 wPos, vec3 lPos, vec3 nor, vec3 rd, float m )\n{       \n    vec2 bent = getBent();\n    \/\/ repeat car rotation with fixes\n    float rotY = -.2 * g_S.isPressedLeft + .2 * g_S.isPressedRight;\n    float rotX = -.1 * g_S.isPressedLeft + .1 * g_S.isPressedRight;\n\n    vec3 albedo = vec3( 0.5 );\n    float met = 1.0;\n    vec4 color = vec4( albedo, met );\n    vec3 emissive = vec3( 0.0 );\n        \n    if ( m == 0.0 )\n    {\n        vec2 p0 = lPos.xz;\n        p0.x -= 1.5 * sin( 0.05 * p0.y * PI ) * smoothstep( -0.5, 0.5, sin( iTime ) );\n        vec2 uv = abs( mod( lPos.xz + GRID_SIZE \/ 2.0, GRID_SIZE ) - GRID_SIZE \/ 2.0 );\n        uv \/= fwidth( lPos.xz );\n        float gln = min( min( uv.x, uv.y ), 1.) \/ GRID_SIZE;\n        \n    \talbedo = mix( GRID_COLOR_1, GRID_COLOR_2, 0.7 - smoothstep( 0.0, GRID_LINE_SIZE \/ GRID_SIZE, gln ) );\n        \n        float pSideLine = lPos.x;\n\t\tpSideLine = abs( pSideLine );\n        pSideLine -= 1.45;\n        pSideLine = abs( pSideLine );\n        float sideLine = 1.0 - smoothstep( 0.03, 0.04, pSideLine );\n        \n        float pCenterLine = lPos.x;\n\t\tpCenterLine = abs( pCenterLine );\n        pCenterLine -= 0.55;\n        pCenterLine = abs( pCenterLine );\n        float centerLine = 1.0 - smoothstep( 0.03, 0.04, pCenterLine );\n        \n        float pCenterLineBreak = mod( lPos.z + 0.5, 1.0) - 0.5;\n        float centerLineBreak = smoothstep( 0.15, 0.16, abs( pCenterLineBreak ) );\n        float damage = pow( texture( iChannel1, 0.03 * lPos.xz ).r, 1.5 );\n        albedo = mix( albedo, vec3( 1.0, 1.0, 0.5 ), ( sideLine + centerLine * centerLineBreak ) * damage );\n               \n        vec2 pTrail = vec2( lPos.x - g_S.playerPos.x + 0.5, lPos.z - 2.0 * g_S.playerPos.y );\n        pTrail.x += 4.0 * rotY; \/\/ move the cos\n        pTrail.x -= 4.0 * rotY * ( cos( 0.75 * pTrail.y - 0.1 * PI ) * 0.5 + 0.5 ); \/\/ fake car turns\n        pTrail.x = abs( pTrail.x );\n        pTrail.x -= 0.28;\n        pTrail.x = abs( pTrail.x );\n               \n        float trailMask = exp( -30.0 * pTrail.x );\n        trailMask += 0.2 * saturate( exp( -4.0 * pTrail.x ) );\n        trailMask *= saturate( -pTrail.y + 0.5 );\t\t\/\/ clamp on Y\n        trailMask *= saturate(  pTrail.y * 0.5 + 1.5 );\t\/\/ clamp on Y\n        emissive += vec3( 1.5, 0.2, 0.0 ) * trailMask;       \n    }\n    \n    if ( m == 1.0 )\n    {\n        vec2 p0 = 2.6 * lPos.xz;\n        p0.x -= 1.5 * sin( 0.05 * p0.y * PI ) * smoothstep( -0.5, 0.5, sin( iTime ) );\n        vec2 uv = abs( mod( 3.0 * lPos.xz + GRID_SIZE \/ 2.0, GRID_SIZE ) - GRID_SIZE \/ 2.0 );\n        uv \/= fwidth( lPos.xz );\n        float gln = min( min( uv.x, uv.y ), 1. ) \/ GRID_SIZE;\n        vec3 carCol = mix( CAR_PLAYER_COLOR_1, CAR_PLAYER_COLOR_2, 0.7 - smoothstep( 0.0, GRID_CAR_LINE_SIZE \/ GRID_CAR_SIZE, gln ) );\n        \n        float coinImp = step( 0.0, g_S.timeCollected ) * impulse( 2.0, max( 0.0, iTime - g_S.timeCollected ) * 6.0 );\n        albedo = mix( carCol, vec3( 1.0, 1.0, 0.5 ), sin( 100.0 * iTime ) * coinImp );\n        \n        float obsImp = step( 0.0, g_S.timeFailed ) * max( 0.0, iTime - g_S.timeFailed );\n        albedo = mix( albedo, vec3( 1.0, 0.0, 0.0) , sin( 100.0 * iTime ) * obsImp );\n    }\n    \n    if ( m == 1.5 )\n    {\n        emissive = albedo = vec3( 1.5, 0.5, 0.5 );\n    }\n    \n    if ( m == 1.6 )\n    {\n        emissive = albedo = vec3( 0.5, 0.5, 1.5 );\n    }\n    \n    if ( m == 2.0 )\n    {\n        albedo = vec3( 1.0, 1.0, 0.5 );\n        emissive = 10.0 * albedo;\n    }\n    \n    if ( m == 3.0 )\n    {\n       vec2 p0 = 2.6 * lPos.xz;\n        p0.x -= 1.5 * sin( 0.05 * p0.y * PI) * smoothstep( -0.5, 0.5, sin( iTime ) );\n        vec2 uv = abs( mod( 3.0 * lPos.xz + GRID_SIZE \/ 2.0, GRID_SIZE ) - GRID_SIZE \/ 2.0 );         \n        uv \/= fwidth( lPos.xz );\n        float gln = min( min( uv.x, uv.y ), 1. ) \/ GRID_SIZE;\n        \n        albedo = mix( CAR_COLOR_1, CAR_COLOR_2, 0.7 - smoothstep( 0.0, GRID_CAR_LINE_SIZE \/ GRID_CAR_SIZE, gln ) );\n    }\n    \n    if ( m == 3.5 )\n    {\n        emissive = albedo = vec3( 1.0, 0.5, 0.5 );\n    }\n    \n    if ( m == 3.6 )\n    {\n        emissive = albedo = vec3( 0.5, 0.5, 1.0 );\n    }\n\n    if ( m == 4.0 )\n    {\n        albedo = 0.2 * vec3( 1.0, 0.0, 1.0 );\n    }\n            \n\t\/\/ spotlight, paramteres-\n    vec3 perSpotOffset = vec3( 0.0, 0.05, 0.8 );\n    vec3 pSpot = vec3( wPos.x - g_S.playerPos.x, 0.0, wPos.z );\n    pSpot -= perSpotOffset;\n    vec3 spotDir = normalize( vec3( 0.0, -0.1, 1.0 ) );\n    vec3 spotColor  = 100.0 * vec3( 1.0 );\n    \n    pSpot.yz *= rot( -0.2  * bent.y );\n    pSpot.xz *= rot( -0.01 * bent.y * PI + rotY );\n    pSpot.yz *= rot( -0.01 * bent.x * PI + rotX );\n    spotDir.yz *= rot( 0.2 * bent.y );\n    spotDir.xz *= rot(-0.2 * rotY );\n    spotDir.yz *= rot(-0.2 * rotX );\n    \n    \/\/ spotlight, color\n    float maskDist = fract( ( length( pSpot ) - 1.0 ) );\n    float spotAtt = 1.0 \/ pow( 1.0 * length( pSpot ), 2.0 );\n    spotAtt *= smoothstep( 0.1, 1.1, dot( normalize( pSpot ), spotDir ) );\n    spotAtt *= saturate( dot( -nor, spotDir ) );\n    emissive += albedo * spotColor * spotAtt;    \n        \n    float fre = pow( 0.5 * ( 1.0 + dot( nor, rd ) ), 2.0 );\n    float amb = clamp( 0.5 + 0.5 * nor.y, 0.0, 1.0 );\n    float occ = calcAO( wPos, nor );    \n    vec3  lig = normalize( SUN_DIRECTION + vec3( 0.0, 0.2, 0.0 ) );\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n\tvec3  hal = normalize( lig - rd );\n    float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ), 64.0 )\n        * dif\n        * ( 0.04 + 0.96 * pow( clamp( 1.0 + dot( hal, rd ), 0.0, 1.0 ), 5.0 ) );\n   \n    color.rgb = albedo * ( 0.5 + 0.5 * occ ) * ( 0.7 + 0.3 * dif ) + spe * vec3( 1.0, 0.5, 0.1 );\n\tcolor.rgb += emissive;\n\tcolor.a = fre;\n    \n    return color;\n    \/\/ return vec4(vec3(0.4) * m, 0.5); \/\/ debug material ID\n    \/\/ return vec4(vec3(fre), 0.0);\n}\n\nfloat densityNoise( vec3 pos )\n{\n    vec2 bent = getBent();\n    \n    float noise = 1.0;\n    float noiseDetail = textureLod( iChannel1, vec2( 1.0, 1.0 ) * pos.xz \/ 64.0, 0.0 ).x;        \n    pos.x -= pos.y;\n    vec2 uv1 = vec2( 0.2, 1.5 ) * pos.xz \/ 64.0 + iTime * vec2( 0.01, 0.1 );\n    float noiseBase = textureLod( iChannel1, uv1, 0.0 ).y;\n    noise = step( 0.6, noiseBase );\n    noise *= noiseDetail * 0.5 + 0.5;\n    noise *= smoothstep( 1.5, 0.0, pos.y ); \/\/ height falloff    \n    noise *= ( 1.0 - bent.y ); \/\/ disable on hills    \n\treturn noise;\n}\n\nvoid volumetricFog( inout vec3 color, vec3 rayOrigin, vec3 rayDir, float sceneT )\n{ \/\/ From \"[SH16B] Speed Drive 80\" by knarkowicz. https:\/\/shadertoy.com\/view\/4ldGz4\n    float gFogDensity\t\t= 0.1;\n    rayOrigin.z += 2.0 * g_S.playerPos.y;\n    \n    sceneT = sceneT <= 0.0 ? 100.0 : sceneT;\n    \n    vec3 seed = vec3( 0.06711056, 0.00583715, 52.9829189 );\n    float dither = fract( seed.z * fract( dot( gl_FragCoord.xy, seed.xy ) ) );\n    \n    float fogAlpha = 0.0;\n    for ( int i = ZERO; i < 32; ++i )\n    {\n        float t = ( float( i ) + 0.5 + dither ) * 5.0;\n        if ( t <= sceneT )\n        {\n        \tvec3 p = rayOrigin + t * rayDir;\n            float s = densityNoise( p );\n            fogAlpha += gFogDensity * t * exp( -gFogDensity * t ) * s;\n        }\n    }\n    fogAlpha = 1.0 - saturate( fogAlpha );\n    vec3 fogColor = FOG_COLOR + vec3( 1.0 );\n    color = mix( fogColor, color, fogAlpha );\n    \/\/ color = vec3(0.01)*sceneT;\n}\n\nvec3 Bloom()\n{\n    vec3 bloom = vec3( 0.0 );\n    bloom += vec3( 1.0, 0.2, 0.1 )  * 0.5 * vec3( exp( -g_glowCoin * 10.0 ) );\n    bloom += vec3( 1.0, 0.2, 0.1 )  * 0.3 * vec3( exp( -g_glowCoinRefl * 10.0 ) );\n    bloom += vec3( 1.0, 0.2, 0.0 )  * 1.0 * vec3( exp( -saturate(g_glowPlayer) * 10.0 ) );\n    bloom += vec3( 1.0, 0.2, 0.0 )  * 0.5 * vec3( exp( -saturate(g_glowPlayerRefl) * 10.0 ) );\n    bloom += vec3( 1.0, 0.05, 0.0 ) * 0.3 * vec3( exp( -saturate(g_glowPlayerLights) * 15.0 ) );\n    bloom += vec3( 0.0, 0.05, 1.0 ) * 0.3 * vec3( exp( -saturate(g_glowPlayerFront) * 15.0 ) );\n    bloom += vec3( 1.0, 0.2, 0.0 )  * 0.5 * vec3( exp( -saturate(g_glowEnemy) * 5.0 ) );\n    bloom += vec3( 1.0, 0.2, 0.0 )  * 0.0 * vec3( exp( -saturate(g_glowEnemyRefl) * 5.0 ) );\n    return bloom;\n}\n\nvec4 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 sky = getSkyColor( rd );\n    vec4 col = vec4( sky, 1.0 );\n    sHit sRes = castRay( ro, rd, 1.0, 40.0 );\n    float t = sRes.t;\n\tfloat m = sRes.m;\n    if( m > -0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n\t\t\n        col = shade( pos, sRes.lPos, nor, rd, m );\n\n#ifdef REFLECTIONS\n        vec3 seed = vec3( 0.06711056, 0.00583715, 52.9829189 );\n\t    float dither = fract( seed.z * fract( dot( gl_FragCoord.yx + fract( iTime ), seed.xy ) ) );\n\n        vec4 bounceCol = vec4( getSkyColor( ref ), 0.0 );\n        ref = normalize( mix( ref, vec3(0.0, 1.0, 0.0 ), dither * 0.1 ) );\n        sHit bounceRes = castRayRefl( pos, ref, 0.1, 20.0 ); \/\/ only trace for bloom, do not shade\n        float bounceT = bounceRes.t;\n        if ( bounceRes.m < 0.0 )\n        \tbounceCol = vec4( getSkyColor( ref ), 0.0 );\n\n        col = vec4( mix( col.xyz, bounceCol.xyz, col.w ), 0.0 );\n            \n#endif \/\/ REFLECTIONS\n        \n        col.rgb += Bloom();\n        col.rgb *= 1.5;        \n    }\n        \n    col.rgb = mix( col.rgb, FOG_COLOR, 1.0 - exp( -0.00005 * t * t * t ) );\n\n#ifdef VOLUMETRICS\n    volumetricFog( col.rgb, ro, rd, t );\n#endif \/\/ VOLUMETRICS\n    \n    \/\/ blur mask\n    col.a = 1.0 - ( dot( rd, normalize( SUN_DIRECTION + vec3( 0.0, 0.05, 0.0 ) ) ) * 0.5 + 0.5 );\n    \n\treturn col;\n}\n\nvoid drawGame3D( inout vec4 color, vec2 uv, AppState s )\n{   \n    vec2 mo = iMouse.xy \/ iResolution.xy;\n   \n    vec2 bent = getBent();\n\n    float fbm = fbm3( vec3( 1000.0 * iTime ) );\n    float crash = step( 0.0, g_S.timeFailed ) * impulse( 2.0, max( 0.0, iTime - g_S.timeFailed ) * 6.0 );\n    \/\/ camera\t    \n    float roll = -0.1 * bent.x;\n    float arm = 3.5 + 0.2 * s.paceScale;\n    float angleH = -0.5 * PI + 0.1 * bent.x;\n    float height = 1.2 + bent.y + crash * fbm + 0.05 * g_S.paceScale * fbm;\n    float fov = 2.0 - 0.5 * s.paceScale;\n    \n    vec3 ro = vec3( 0.0 );\n    \n    if ( s.timeFailed > 0.0 )\n    {\n        roll = mix( roll, 0.0, saturate( iTime - s.timeFailed ) );\n        arm = mix( arm, 3.5, saturate( iTime - s.timeFailed ) );\n        angleH += iTime - s.timeFailed;\n    }\n    \n    if ( s.stateID == GS_SPLASH )\n    {\n        arm += 0.5 * sin( iTime ) * 0.5 + 0.5;\n        roll = -0.1 * ( mo.x - 0.5 );\n        angleH += 0.5 * ( mo.x - 0.5 );\n        height += 0.5 * (mo.y - 0.5 );                \n    }\n    \n    ro = vec3( arm * cos( angleH ), height, arm * sin( angleH ) );\n    \n#ifdef DEBUG_CAMERA    \n    roll = 0.0;\n    ro = vec3( 0.5 + 3.5 * cos( 12.0 * mo.x ), 0.5 + 4.0 * mo.y, -0.5 + 3.5 * sin( 12.0 * mo.x ) );\n#endif        \n    \n    vec3 ta = vec3(\n        0.0, \n        mix( 1.0, 0.5, step( 0.0, s.timeFailed ) * saturate( iTime - s.timeFailed ) ),\n        0.0\n    );\n\n#ifdef CAM_STICKED    \n    ro.x += s.playerPos.x;\n    ta.x += s.playerPos.x;\n#endif    \n    \n    \/\/ camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, roll );\n   \n    \/\/ ray direction\n    vec3 rd = ca * normalize( vec3( uv.xy, fov ) );\n    \n    \/\/ render\t\n    vec4 col = render( ro, rd );\n       \n    color = col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4(0.0);\n    \n\tvec2 q = F.xy \/ R.xy;\n    vec2 p = -1. + 2. * q;\n\tp.x *= R.x \/ R.y;\n\n#ifdef FORCED_RATIO\n\tfloat bars = step( abs( p.y ) * g_forceRatio, R.x \/ R.y );\n    if ( bars < 0.5 ) return;\n#endif \/\/ FORCED_RATIO    \n    \n    AppState s;\n    loadState( iChannel0, s );\n    g_S = s;\n\n    vec4 color = vec4( 0.0, 0.0, 0.0, 1.0 );\n       \n    vec2 pGame = p;\n    pGame.x *= -1.0; \/\/ flip axis to match Flat version\n    drawGame3D( color, pGame, s );\n   \n#ifdef DEBUG_2D\n    vec2 p0 = p;    \n    p0 *= 2.0;\n    p0 -= vec2( -3.0, 0.0 );\n    if ( p0.x < 0.7 && p0.y > -1.0 )\n    {\n        \/\/ drawGameFlat( color, p0, s );\n    \t\/\/ drawUI(color, p0, s);\n    }\n#endif    \n    \n\tfragColor = color;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGzr","filepath":"\/media\/a\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"\/media\/ap\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\/\/ Copyright \u00a9 2019 Michal Klos\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ Sunset Drive Unlimited\n\/\/  Endless runner with synthwave stylization\n\/\/\t\"Brick Driver\" sequel, because it missed fluent turning and coins:\n\/\/\thttps:\/\/www.shadertoy.com\/view\/wssSD4\n\n\/\/ #define options in Common tab\n\/\/  Some effects can be disabled on low end gpus\n\n\/\/ Gameplay is based on Brick Game Racing,\n\/\/  https:\/\/youtu.be\/EdMyKRC8qyU\n\n\/\/ First draft created in 24h on Game Jam Square 26-28.04.2019\n\/\/\tFinished after couple of spare evenings on 24.06.2019\n\n\/\/ Based on:\n\/\/ - \"80's raymarching\" by villedieumorgan. https:\/\/shadertoy.com\/view\/lsVSRt\n\/\/ - \"[SH16B] Speed Drive 80\" by knarkowicz. https:\/\/shadertoy.com\/view\/4ldGz4\n\/\/ Other snippets credits in comments next to the code\n\/\/ Thank you guys for sharing it, hope you like it :)\n\n\/\/ Music: Lifelike - So Electric\n\/\/  https:\/\/soundcloud.com\/rombo_rama\/lifelike-so-electric\n\n\n\nfloat textSDF( vec2 p, float glyph )\n{\n    p = abs( p.x - .5 ) > .5 || abs( p.y - .5 ) > .5 ? vec2( 0. ) : p;\n    return 2. * ( texture( iChannel3, p \/ 16. + fract( vec2( glyph, 15. - floor( glyph \/ 16. ) ) \/ 16. ) ).w - 127. \/ 255. );\n}\n\nvoid menuText( inout vec3 color, vec2 p, in AppState s )\n{        \n    vec2 scale = vec2( 4., 8. );\n    vec2 t = floor( p \/ scale );   \n    \n    uint v = 0u;\n\tv = t.y == 2. ? ( t.x < 4. ? 1768452929u : ( t.x < 8. ? 1768777835u : ( t.x < 12. ? 5653614u : 0u ) ) ) : v;\n\tv = t.y == 1. ? ( t.x < 4. ? 1918986307u : ( t.x < 8. ? 1147496812u : ( t.x < 12. ? 1752383839u : ( t.x < 16. ? 1835559785u : 5664361u ) ) ) ) : v;\n\tv = t.y == 0. ? ( t.x < 4. ? 1918986307u : ( t.x < 8. ? 1147496812u : ( t.x < 12. ? 86u : 0u ) ) ) : v;\n\tv = t.x >= 0. && t.x < 20. ? v : 0u;\n    \n\tfloat c = float( ( v >> uint( 8. * t.x ) ) & 255u );\n    \n\tvec3 textColor = vec3( 1.0 );\n\n    p = ( p - t * scale ) \/ scale;\n    p.x = ( p.x - .5 ) * .5 + .5;\n    float sdf = textSDF( p, c );\n    if ( c != 0. )\n    {\n    \tcolor = mix( textColor, color, smoothstep( -.05, +.05, sdf ) );\n    }\n}\n\nfloat titleText( vec2 p )\n{        \n    vec2 scale = vec2( 4., 8. );\n    vec2 t = floor( p \/ scale );   \n    \n    uint v = 0u;\n\tv = t.y == 0. ? ( t.x < 4. ? 1397642579u : ( t.x < 8. ? 1142969413u : ( t.x < 12. ? 1163282770u : ( t.x < 16. ? 1280202016u : ( t.x < 20. ? 1414090057u : 17477u ) ) ) ) ) : v;\n\tv = t.x >= 0. && t.x < 24. ? v : 0u;\n    \n\tfloat c = float( ( v >> uint( 8. * t.x ) ) & 255u );\n    \n    p = ( p - t * scale ) \/ scale;\n    p.x = ( p.x - .5 ) * .5 + .5;\n    float sdf = textSDF( p, c );\n    return ( c != 0. ) ? smoothstep( -.05, +.05, sdf ) : 1.0;\n}\n\nfloat spaceText(vec2 p)\n{        \n    vec2 scale = vec2( 4., 8. );\n    vec2 t = floor( p \/ scale );   \n    \n    uint v = 0u;    \n    v = t.y == 0. ? ( t.x < 4. ? 1936028240u : ( t.x < 8. ? 1935351923u : ( t.x < 12. ? 1701011824u : ( t.x < 16. ? 1869881437u : ( t.x < 20. ? 1635021600u : 29810u ) ) ) ) ) : v;\n\tv = t.x >= 0. && t.x < 24. ? v : 0u;\n    \n\tfloat c = float( ( v >> uint( 8. * t.x ) ) & 255u );\n    \n    p = ( p - t * scale ) \/ scale;\n    p.x = (p.x - .5 ) * .5 + .5;\n    float sdf = textSDF( p, c );\n    return ( c != 0. ) ? smoothstep( -.05, +.05, sdf ) : 1.0;\n}\n\nfloat highscoreText( vec2 p )\n{        \n    vec2 scale = vec2( 4., 8. );\n    vec2 t = floor( p \/ scale );\n    \n    uint v = 0u;    \n\tv = t.y == 0. ? ( t.x < 4. ? 1751607624u : ( t.x < 8. ? 1919902579u : 14949u ) ) : v;\n\tv = t.x >= 0. && t.x < 12. ? v : 0u;\n    \n\tfloat c = float( ( v >> uint( 8. * t.x ) ) & 255u );\n    \n    p = ( p - t * scale ) \/ scale;\n    p.x = ( p.x - .5 ) * .5 + .5;\n    float sdf = textSDF( p, c );\n    return ( c != 0. ) ? smoothstep( -.05, +.05, sdf ) : 1.0;\n}\n\nvoid drawUI(inout vec3 color, vec2 p, AppState s)\n{\n    p *= R.y \/ R.x; \/\/ ratio and resolution indepenent scaling\n    p *= 1.75;\n    \n    \/\/ splash screen   \n    if ( s.stateID == GS_SPLASH )\n    {\n        color.rgb *= 0.1 + 0.9 * smoothstep( 0.75, 0.0, p.y ); \/\/ dark text bg\n\t\tvec2 p2 = p;\n\t\tp2 *= 50.;\n\t\tp2 -= vec2( -45, 27. );\n        \/\/ color.rgb = mix(color.rgb, vec3(0.0), 1.0-smoothstep(0.0, 0.5, abs(p2.y)) ); \/\/ horiz guide\n        \n        float maskTitle = titleText( p2 ); \/\/ Sunset Drive Unlimited\n        color.rgb = mix( vec3( 1.0 ), color.rgb, maskTitle );\n        \n\t\tvec2 p1 = p;\n\t\tp1 *= 60. + 5. * abs( sin( 2.0 * iTime ) );\n\t\tp1 -= vec2( -47., -42. );\n        float maskSpace = spaceText( p1 ); \/\/ press [space] to start\n        color.rgb = mix( vec3( 1.0 ), color.rgb, maskSpace );\n\n\t\tvec2 p3 = p;\n\t\tp3 *= 60.;\n\t\tp3 -= vec2( -30, 25. );\n        float maskHs = highscoreText( p3 ); \/\/ Highscore\n        color.rgb = mix( vec3( 1.0 ), color.rgb, maskHs );\n\n\t\tvec2 pScore = p;\n        pScore *= 12.0;\n        pScore -= vec2( 1.3, 5.3 );\n        float sScore = printInt( pScore, s.highscore );\n        color.rgb = mix( color.rgb, vec3( 1.0 ), sScore );\n    }\n    else\n    {\n        vec2 pScore = p;\n        pScore *= 6.0;\n        pScore -= vec2( -0.9, 3.4 );\n        float maxDigits = ceil( log2( s.score ) \/ log2( 10.0 ) );\n        pScore.x += 0.5 * maxDigits;\n        float sScore = printInt( pScore, s.score );\n        color.rgb = mix( color.rgb, vec3( 1.0 ), sScore );\n    }\n\n\t\/\/ color.rgb = mix(color.rgb, vec3(0.0), 1.0-smoothstep(0.0, 0.01, abs(p.x)) ); \/\/ center guide\n    \/\/ color.rgb = mix(color.rgb, vec3(0.0), 1.0-smoothstep(0.0, 0.01, abs(p.y)) ); \/\/ horiz guide\n}\n\nconst float gaussianWeights[6] = float[] (\n\t0.12801,\n\t0.12299,\n\t0.10908,\n\t0.08931,\n\t0.06750,\n\t0.04709 \n);\n\nvec3 rbg( sampler2D t, vec2 UV, vec2 dir )\n{\n\tvec3 c = vec3( 0 );\n\tvec2 uv = 1.0 - 2.0 * UV;\t\n    vec2 rRcp = 1.0 \/ vec2( 1920.0, 1080.0 );\n\tfor( int i = -5; i < 6; ++i )\n    {\n\t\tc += gaussianWeights[abs( i )] * textureLod( t, 0.5 - 0.5 * ( uv + rRcp * dir * float( i ) ), 0.0 ).rgb;\n\t}\n\treturn c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n \tvec2 uv = F.xy \/ R.xy;\n    vec2 p = -1. + 2. * uv;\n\tp.x *= R.x \/ R.y;\n\n#ifdef FORCED_RATIO\n\tfloat bars = step( abs( p.y ) * g_forceRatio, R.x \/ R.y );\n    if ( bars < 0.5 ) return;\t\n#endif\n    \n    AppState s;\n    loadState( iChannel1, s );\n    \n    float scale = 5.0 * s.paceScale;\n    \n    if ( s.timeFailed > 0.0 )\n    {\n        scale = 1.0;\n    }\n    \n    if ( s.stateID == GS_SPLASH )\n    {\n        scale = 4.0;\n    }\n    \n    scale += 0.1;\n\n\tvec4 beauty = texture( iChannel0, uv );\n    vec2 dir = normalize( vec2( dFdx( beauty.a ), dFdy( beauty.a ) ) );\n    vec3 blurred = rbg( iChannel0, uv, dir * scale );    \n    float blurMask = 0.1 + smoothstep( 0.0, 0.2, beauty.a ); \/\/ 0.1 bias to blur a bit dithered volumetrics at center\n    vec3 color = mix( beauty.rgb, blurred, blurMask ); \n\n#ifdef SHOW_UI\n        drawUI( color, p, s );\n#endif\n        \n    fragColor = vec4( color, 1.0 );\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\/\/ Copyright \u00a9 2019 Michal Klos\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ Sunset Drive Unlimited\n\/\/  Endless runner with synthwave stylization\n\/\/\t\"Brick Driver\" sequel, because it missed fluent turning and coins:\n\/\/\thttps:\/\/www.shadertoy.com\/view\/wssSD4\n\n\/\/ #define options in Common tab\n\/\/  Some effects can be disabled on low end gpus\n\n\/\/ Gameplay is based on Brick Game Racing,\n\/\/  https:\/\/youtu.be\/EdMyKRC8qyU\n\n\/\/ First draft created in 24h on Game Jam Square 26-28.04.2019\n\/\/\tFinished after couple of spare evenings on 24.06.2019\n\n\/\/ Based on:\n\/\/ - \"80's raymarching\" by villedieumorgan. https:\/\/shadertoy.com\/view\/lsVSRt\n\/\/ - \"[SH16B] Speed Drive 80\" by knarkowicz. https:\/\/shadertoy.com\/view\/4ldGz4\n\/\/ Other snippets credits in comments next to the code\n\/\/ Thank you guys for sharing it, hope you like it :)\n\n\/\/ Music: Lifelike - So Electric\n\/\/  https:\/\/soundcloud.com\/rombo_rama\/lifelike-so-electric\n\n\n\nvec2 barrelDistortion( vec2 coord, float amt, float zoom )\n{ \/\/ based on gtoledo3 (XslGz8)\n  \/\/ added zoomimg\n\tvec2 cc = coord - 0.5;\n    vec2 p = cc * zoom;\n    coord = p + 0.5;\n\tfloat dist = dot( cc, cc );\n\treturn coord + cc * dist * amt;\n}\n\nvec3 tonemapACES( vec3 x )\n{\n    \/\/ Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\t        \n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return ( x * ( a * x + b ) ) \/ ( x * ( c * x + d ) + e );\n}\n\nvec3 ca( sampler2D t, vec2 UV )\n{\t\n\tconst int N = 8;\t\n    float scale = 1.0;\n\tvec2 uv = 1.0 - 2.0 * UV;\n\tvec3 c = vec3( 0 );\n\tfloat rf = 1.0;\n\tfloat gf = 1.0;\n    float bf = 1.0;\n\tfloat f = 1.0 \/ float( N );\n\tfor( int i = 0; i < N; ++i )\n    {\n\t\tc.r += f * texture( t, 0.5 - 0.5 * ( ( uv ) * rf ) ).r;\n\t\tc.g += f * texture( t, 0.5 - 0.5 * ( ( uv ) * gf ) ).g;\n\t\tc.b += f * texture( t, 0.5 - 0.5 * ( ( uv ) * bf ) ).b;\n\t\trf *= mix( 1.0, 0.9972, scale );\n\t\tgf *= mix( 1.0, 0.998,  scale );\n        bf \/= mix( 1.0, 0.9988, scale );\n\t}\n\treturn c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    fragColor = vec4(0.0);\n\t\n\tvec2 uv = F.xy \/ R.xy;\n    vec2 q = 1.0 - 2.0 * uv;\n    q.x *= R.x \/ R.y;\n\n#ifdef FORCED_RATIO        \n\tfloat bars = step( abs( q.y ) * g_forceRatio, R.x \/ R.y );\n    if ( bars < 0.5 ) return;\t\n#endif\n\n    \/\/ barrel distortion\n\tvec2 uvb = barrelDistortion( uv, 0.1, 0.97 );\n    \n    \/\/ chromatic aberration\t\n    vec3 color;\n\tcolor.rgb = ca( iChannel0, uv );\n    \/\/ color = texture( iChannel0, uv ).rgb;\n    \n    \/\/ vignette\n\tcolor.rgb *= 0.7 + 0.3 * clamp( pow( 28.0 * uv.x * uv.y * ( 1.0 - uv.x ) * ( 1.0 - uv.y ), 2.0 ), 0.0, 1.0 );\n\t\n\t\/\/ grade\n#ifdef GRADE\n    color.rgb = smoothstep( vec3( -0.05 ), vec3( 0.8 ), color.rgb );\n#endif\n          \n    color.rgb = tonemapACES( color.rgb );\n     \n\tfragColor.rgb = color;\n}","name":"Buffer D","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"MsG3Dz","date":"1453999525","viewed":9248,"name":"Three Pass DOF Example","username":"mu6k","description":"Use mouse to rotate! My attempt at writing a decent depth of field effect. Well all I can say is that I'm satisfied with it.","likes":141,"published":3,"flags":32,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"\/media\/previz\/buffer03.png","previewfilepath":"\/media\/previz\/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/*by musk License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n  email: muuuusk at gmail dot com\n\n2016-02-02:\n\n  My attempt at writing a decent depth of field effect.\n  Well all I can say is that I'm satisfied with it.\n\n  My attempt was to get a hexagonal bokeh. Well it's sort of like that.\n  But maybe using it on a scene with a lot of reflection wasnt the best idea...\n\n  So you might ask how come this is three pass when four buffers are used?\n  Well only the depth of field effect uses 3 passes. \n  The rest of the passes handle rendering and post processing.\n  \n  This part here is the post processing.\n*\/\n\n#define DISPLAY_GAMMA 1.8\n#define USE_CHROMATIC_ABBERATION\n\nvec2 uvsToUv(vec2 uvs){\n    return (uvs)*vec2(iResolution.y\/iResolution.x,1.0)+vec2(.5,.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    vec2 uvs = (fragCoord.xy-iResolution.xy*.5)\/iResolution.yy;\n    \n    \/\/chromatic abberation\n    #ifdef USE_CHROMATIC_ABBERATION\n    vec3 color = vec3(0,0,0);\n    color.x += texture(iChannel0, uvsToUv(uvs)).x*.66;\n    color.xy += texture(iChannel0, uvsToUv(uvs*.995)).xy*.33;\n    color.y += texture(iChannel0, uvsToUv(uvs*.990)).y*.33;\n    color.yz += texture(iChannel0, uvsToUv(uvs*.985)).yz*.33;\n    color.z += texture(iChannel0, uvsToUv(uvs*.980)).z*.66;\n    #else\n    vec3 color = texture(iChannel0, uvsToUv(uvs)).xyz;\n    #endif\n    \n    \/\/tone mapping\n    color = vec3(1.7,1.8,1.9)*color\/(1.0+color);\n    \n    \/\/inverse gamma correction\n\tfragColor = vec4(pow(color,vec3((1.0)\/(DISPLAY_GAMMA))),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/by musk License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/rendering pass\n\n#define SPHERE 1.0 \n\/\/#define SPHERE 0.0 \n\n#define FOCUS_DISTANCE 7.5\n#define DEFOCUS_PER_UNIT 0.0925\n#define BLUR_LIMIT 1.0\n\n#define RAY_STEPS_PRIMARY 80\n#define RAY_STEPS_SECOND 20\n#define RAY_STEPS_THIRD 10\n#define RAY_STEPS_FOURTH 5\n\nfloat df2obj(vec3 p){\/\/repeated spheres\n    p.x+=iTime-2.0;\n    vec3 op=p;\n    vec3 p2 = p;\n    p.xz=mod(p.xz+vec2(2.0),4.0)-vec2(2.0);\n    float box=max(abs(p.x),max(abs(p.y),abs(p.z)));\n    float sphere = length(p);\n    return (mix(box,sphere,SPHERE)-1.0);\n}\n\nfloat df2floor(vec3 p){\/\/the floor\n\treturn p.y+1.0;\n}\n\nfloat df2(vec3 p){\/\/union(spheres, floor)\n\treturn min(df2obj(p), df2floor(p));\n}\n\n#define nvec3(A,B,C) normalize(vec3(A,B,C))\n#define nvec3a2(A,B) normalize(vec3(A,B))\n\nmat2 matr(float a){\/\/build a 2d rotation matrix\n    float c=cos(a),s=sin(a);\n    return mat2(c,s,-s,c);\n}\n\n#define NF(R,P,F) {vec2 e=vec2(0,0.01);R=nvec3(F(P-e.yxx),F(P-e.xyx),F(P-e.xxy));}\n#define RM(R,P,D,F,S) {R=P+D*.1; for(int i=0; i<S; i++){float t=F(R);R+=t*D;}}\n\n\nvec3 shading(vec3 p, vec3 d, vec3 n){\/\/compute the shade at given position direction surface normal\n    vec3 c = vec3(.0); \/\/object color\n    vec3 bg; \/\/background color\n    bg = (d*.5+.5)*.5;\n    bg+=sin(d.y*4.0)*.5+.5;\n    bg*=max(cos(iTime*0.2-10.0)*.7+.5,.0);\n    if (df2(p)<.1){ \/\/if near surface\n        float lt=iTime-14.0;\n        vec3 l = vec3(sin(lt*.1)*14.0,4.0+cos(lt*.23)*2.0,cos(lt*.13)*14.0);\n        vec3 ldir = normalize(vec3(p-l));\n        float oa = (df2(p-n)+df2(p-n*.5)*2.0+df2(p-n*.25)*4.0)*.5*.3333+.5;\/\/ambient occlusion\n        float od = max(min(min(df2(p-ldir*.3)\/0.3,df2(p-ldir)),df2(p-ldir*0.6)\/.6),.0);\/\/shadow\n        float dist = distance(p,l);\n        c = vec3(.8,.7,.6)*max(.0,dot(n,ldir)*.5)\/(1.0+dist*0.1)*(od*.8+.2)*2.0;\/\/diffuse component\n        float spec = pow(max(.0,dot(normalize(reflect(d,n)),-ldir)*.5+.5),1000.0)*56.0;\/\/specular component\n        c+=vec3(spec*od);\n        c*=oa;\n        c=mix(bg,c,1.0\/(1.0+length(p)*0.01));\/\/fogging\n    } else {\n        c =bg;\n    }\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    vec2 uvs = (fragCoord.xy-iResolution.xy*.5)\/iResolution.yy*2.0;\n    float ar= iResolution.x \/ iResolution.y;\n    \n    vec3 dir = nvec3a2(uvs, 2.0);\/\/primary ray direction\n    \n    vec3 pos = vec3(.0,.0,-8.0);\/\/primary ray position\n    vec2 muvs = (iMouse.xy-iResolution.xy*.5)\/iResolution.yy;\/\/mouse position\n    \n    \/\/rotate the direction and position based on mouse\n\tmat2 rx = matr(muvs.y*4.0-4.7);\n    mat2 ry = matr(muvs.x*4.0+4.5);\n    vec3 p;\n    dir.yz*=rx;\n    dir.xz*=ry;\n    pos.yz*=rx;\n    pos.xz*=ry;\n    \n    \/\/first ray\n    RM(p,pos,dir,df2,RAY_STEPS_PRIMARY);\n    vec3 norm;\n    NF(norm, p, df2);\n    \n    \/\/fresnel shading\n    float fres = 1.0-dot(dir,norm)*.9;\n    vec3 color = shading(p,dir, norm);\n    \n    if (df2(p)<.1){\/\/did we hit surface?\n        \n        \/\/then shoot the second ray\n        vec3 p2,n2,d2=reflect(dir,norm);\n        RM(p2,p,d2,df2,RAY_STEPS_SECOND);\n        NF(n2,p2,df2);\n        \n        color += shading(p2,d2,n2)*fres;\n        \n        if (df2(p2)<.1){\/\/did we hit surface again?\n\t\t\t\n            \/\/then shoot the third ray\n            float fres2 = 1.0-dot(d2,n2)*.9;\n            vec3 p3,n3,d3=reflect(d2,n2);\n            RM(p3,p2,d3,df2,RAY_STEPS_THIRD);\n            NF(n3,p3,df2);\n\n            color += shading(p3,d3,n3)*fres2*fres;\n\n            if (df2(p3)<.1){\/\/again?\n                \n            \t\/\/then shoot the fourth ray\n                float fres3 = 1.0-dot(d3,n3)*.9;\n                vec3 p4,n4,d4=reflect(d3,n3);\n                RM(p4,p3,d4,df2,RAY_STEPS_FOURTH);\n                NF(n4,p4,df2);\n\n                color += shading(p4,d4,n4)*fres3*fres2*fres;\n            }\n        }\n    }\n    \n    \/\/compute how much this pixel is focused (this math could be improved)\n    float focus = abs(distance(p,pos)-FOCUS_DISTANCE)*DEFOCUS_PER_UNIT;\n    focus = min(BLUR_LIMIT,focus);\n    \n    \/\/store color and focus amount\n\tfragColor = vec4(color,focus);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\/\/by musk License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/first blur pass\n\nconst vec2 dir = vec2(0.02,0.02);\/\/blur direction\nconst float thresh = .5;\/\/depth threshold\n\nfloat weight(float x){\n\treturn 1.0-x*x*x*x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    vec2 uvs = (fragCoord.xy-iResolution.xy*.5)\/iResolution.yy*2.0;\n    \n    float dist = texture(iChannel0,uv).a;\n    float totalw = .0;\n    \n    vec3 color = vec3(0,0,0);\n    for (int i=0; i<=20; i++){\n        vec2 p = uv;\n        float fi = float(i-10)\/10.0;\n        p.xy+=dir*fi*dist;\n        \n        float w = weight(fi);\n        \n    \tvec4 c = texture(iChannel0,p);\n        if (dist>=c.a){\n            w*=max(.0,1.0-(dist-c.a)\/thresh);\n        }\n        color += c.xyz*w;\n        totalw+=w;\n    }\n    color\/=totalw;\n\tfragColor = vec4(color,dist);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\/\/by musk License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/second blur pass\n\nconst vec2 dir = vec2(0.02,-0.02);\/\/blur direction\nconst float thresh = .5;\/\/depth threshold\n\nfloat weight(float x){\n\treturn 1.0-x*x*x*x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    vec2 uvs = (fragCoord.xy-iResolution.xy*.5)\/iResolution.yy;\n\n    float dist = texture(iChannel0,uv).a;\n    float totalw = .0;\n    \n    vec3 color = vec3(0,0,0);\n    for (int i=0; i<=20; i++){\n        vec2 p = uv;\n        float fi = float(i-10)\/10.0;\n        p.xy+=dir*fi*dist;\n        \n        float w = weight(fi);\n        \n    \tvec4 c = texture(iChannel0,p);\n        if (dist>=c.a){\n            w*=max(.0,1.0-(dist-c.a)\/thresh);\n        }\n        color += c.xyz*w;\n        totalw+=w;\n    }\n    color\/=totalw;\n\tfragColor = vec4(color,dist);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\/\/by musk License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\/\/third blur pass\n\nconst vec2 dir = vec2(0.00,0.04);\/\/blur direction\nconst float thresh = .5;\/\/depth threshold\n\nfloat weight(float x){\n\treturn 1.0-x*x*x*x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    vec2 uvs = (fragCoord.xy-iResolution.xy*.5)\/iResolution.yy;\n    \n    float dist = texture(iChannel0,uv).a;\n    float totalw = .0;\n    \n    vec3 color = vec3(0,0,0);\n    for (int i=0; i<=20; i++){\n        vec2 p = uv;\n        float fi = float(i-10)\/10.0;\n        p.xy+=dir*fi*dist;\n        \n        float w = weight(fi);\n        \n    \tvec4 c = texture(iChannel0,p);\n        if (dist>=c.a){\n            w*=max(.0,1.0-(dist-c.a)\/thresh);\n        }\n        color += c.xyz*w;\n        totalw+=w;\n    }\n    color\/=totalw;\n\tfragColor = vec4(color,dist);\n}","name":"Buffer D","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"XtyGWD","date":"1474559035","viewed":8589,"name":"Multiple Transparency","username":"P_Malin","description":"Transparency experiment - manually using a stack to handle ray recursion.\n(works in VR mode)\n","likes":139,"published":3,"flags":33,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Multiple Transparency - @P_Malin\n\/\/ @P_Malin\n\n\nvec3 Tonemap( vec3 x )\n{\n    float a = 0.010;\n    float b = 0.132;\n    float c = 0.010;\n    float d = 0.163;\n    float e = 0.101;\n\n    return ( x * ( a * x + b ) ) \/ ( x * ( c * x + d ) + e );\n}\n\nvec3 ColorGrade( vec3 vColor )\n{\n    vec3 vHue = vec3(1.0, .7, .2);\n    \n    vec3 vGamma = 1.0 + vHue * 0.6;\n    vec3 vGain = vec3(.9) + vHue * vHue * 8.0;\n    \n    vColor *= 2.0;\n    \n    float fMaxLum = 100.0;\n    vColor \/= fMaxLum;\n    vColor = pow( vColor, vGamma );\n    vColor *= vGain;\n    vColor *= fMaxLum;  \n    return vColor;\n}\n\n\/\/ Depth of field pass\n\n#define BLUR_TAPS 32\n\nfloat fGolden = 3.141592 * (3.0 - sqrt(5.0));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vUV = fragCoord.xy \/ iResolution.xy;\n\n    vec4 vSample = textureLod( iChannel0, vUV, 0.0 ).rgba;\n\tfloat fCoC = vSample.w;\n    \t\n\tvec3 vResult = vSample.rgb;\n    float fTot = 0.0;\n        \n    vec2 vangle = vec2(0.0, fCoC); \/\/ Start angle\n    \n    if ( abs(fCoC) > 0.0 )\n    {\n        vResult.rgb  *= fCoC;\n        fTot += fCoC;\n\n        float fBlurTaps = float(BLUR_TAPS);\n\n        for(int i=1; i<BLUR_TAPS; i++)\n        {\n            \/\/ http:\/\/blog.marmakoide.org\/?p=1\n            float t = float(i) \/ fBlurTaps;\n            float fTheta = t * fBlurTaps * fGolden;\n            float fRadius = fCoC * sqrt( t * fBlurTaps ) \/ sqrt( fBlurTaps );        \n\n            vec2 vTapUV = vUV + vec2( sin(fTheta), cos(fTheta) ) * fRadius;\n\n            vec4 vTapSample = textureLod( iChannel0, vTapUV, 0.0 ).rgba;\n            {\n                float fCoC2 = vTapSample.w;\n                float fWeight = max( 0.001, fCoC2 );\n\n                vResult += vTapSample.rgb * fWeight;\n                fTot += fWeight;\n            }\n        }\n        vResult \/= fTot;\n    }\n        \n\tfragColor = vec4(vResult, 1.0);    \n    \n    float fExposure = 3.0;    \n    \n    fragColor.rgb = fragColor.rgb * fExposure;\n    \n    fragColor.rgb = ColorGrade( fragColor.rgb );\n        \n    fragColor.rgb = Tonemap( fragColor.rgb );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sfGRn","filepath":"\/media\/a\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"\/media\/ap\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"\/media\/a\/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"\/media\/ap\/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"\/media\/a\/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"\/media\/ap\/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ Multiple Transparency - @P_Malin\n\n\/\/ Transparency experiment - manually using a stack to handle ray recursion.\n\n\n\/\/ Scene Render\n\n#define kMaxTraceDist 1000.0\n#define kFarDist 1100.0\n\n#define MAT_FG_BEGIN \t10\n\n#define PI 3.141592654\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Data Storage\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec4 LoadVec4( sampler2D sampler, in vec2 vAddr )\n{\n    return texelFetch( sampler, ivec2(vAddr), 0 );\n}\n\nvec3 LoadVec3( sampler2D sampler, in vec2 vAddr )\n{\n    return LoadVec4( sampler, vAddr ).xyz;\n}\n\nbool AtAddress( vec2 p, vec2 c ) { return all( equal( floor(p), floor(c) ) ); }\n\nvoid StoreVec4( in vec2 vAddr, in vec4 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = AtAddress( fragCoord, vAddr ) ? vValue : fragColor;\n}\n\nvoid StoreVec3( in vec2 vAddr, in vec3 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec4( vAddr, vec4( vValue, 0.0 ), fragColor, fragCoord);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Camera\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nstruct CameraState\n{\n    vec3 vPos;\n    vec3 vTarget;\n    float fFov;\n};\n    \nvoid Cam_LoadState( out CameraState cam, sampler2D sampler, vec2 addr )\n{\n    vec4 vPos = LoadVec4( sampler, addr + vec2(0,0) );\n    cam.vPos = vPos.xyz;\n    vec4 targetFov = LoadVec4( sampler, addr + vec2(1,0) );\n    cam.vTarget = targetFov.xyz;\n    cam.fFov = targetFov.w;\n}\n\nvoid Cam_StoreState( vec2 addr, const in CameraState cam, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec4( addr + vec2(0,0), vec4( cam.vPos, 0 ), fragColor, fragCoord );\n    StoreVec4( addr + vec2(1,0), vec4( cam.vTarget, cam.fFov ), fragColor, fragCoord );    \n}\n\nmat3 Cam_GetWorldToCameraRotMatrix( const CameraState cameraState )\n{\n    vec3 vForward = normalize( cameraState.vTarget - cameraState.vPos );\n\tvec3 vRight = normalize( cross(vec3(0, 1, 0), vForward) );\n\tvec3 vUp = normalize( cross(vForward, vRight) );\n    \n    return mat3( vRight, vUp, vForward );\n}\n\nvec2 Cam_GetViewCoordFromUV( const in vec2 vUV )\n{\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= iResolution.x \/ iResolution.y;\n\n\treturn vWindow;\t\n}\n\nvoid Cam_GetCameraRay( const vec2 vUV, const CameraState cam, out vec3 vRayOrigin, out vec3 vRayDir )\n{\n    vec2 vView = Cam_GetViewCoordFromUV( vUV );\n    vRayOrigin = cam.vPos;\n    float fPerspDist = 1.0 \/ tan( radians( cam.fFov ) );\n    vRayDir = normalize( Cam_GetWorldToCameraRotMatrix( cam ) * vec3( vView, fPerspDist ) );\n}\n\nvec2 Cam_GetUVFromWindowCoord( const in vec2 vWindow )\n{\n    vec2 vScaledWindow = vWindow;\n    vScaledWindow.x *= iResolution.y \/ iResolution.x;\n\n    return vScaledWindow * 0.5 + 0.5;\n}\n\nvec2 Cam_WorldToWindowCoord(const in vec3 vWorldPos, const in CameraState cameraState )\n{\n    vec3 vOffset = vWorldPos - cameraState.vPos;\n    vec3 vCameraLocal;\n\n    vCameraLocal = vOffset * Cam_GetWorldToCameraRotMatrix( cameraState );\n\t\n    vec2 vWindowPos = vCameraLocal.xy \/ (vCameraLocal.z * tan( radians( cameraState.fFov ) ));\n    \n    return vWindowPos;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Scene\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nstruct SceneResult\n{\n\tfloat fDist;\n\tint iObjectId;\n    vec3 vUVW;\n};\n    \nvoid Scene_Union( inout SceneResult a, const in SceneResult b )\n{\n    if ( b.fDist < a.fDist )\n    {\n        a = b;\n    }\n}\n\n    \nvoid Scene_Trim( inout SceneResult a, const in SceneResult b )\n{\n    if ( a.fDist < -b.fDist )\n    {\n        a.fDist = -b.fDist;\n    }\n}\n\nSceneResult Scene_GetDistance( const vec3 vPos, const int iInsideObject );    \n\nvec3 Scene_GetNormal(const in vec3 vPos, const int iInsideObject)\n{\n    const float fDelta = 0.001;\n    vec2 e = vec2( -1, 1 );\n    \n    vec3 vNormal = \n        Scene_GetDistance( vPos + e.yxx * fDelta, iInsideObject ).fDist * e.yxx + \n        Scene_GetDistance( vPos + e.xxy * fDelta, iInsideObject ).fDist * e.xxy + \n        Scene_GetDistance( vPos + e.xyx * fDelta, iInsideObject ).fDist * e.xyx + \n        Scene_GetDistance( vPos + e.yyy * fDelta, iInsideObject ).fDist * e.yyy;\n    \n    if ( dot( vNormal, vNormal ) < 0.00001 )\n    {\n        return vec3(0, 1, 0);\n    }\n    \n    return normalize( vNormal );\n}    \n    \nSceneResult Scene_Trace( const in vec3 vRayOrigin, const in vec3 vRayDir, float minDist, float maxDist, int iInsideObject )\n{\t\n    SceneResult result;\n    result.fDist = 0.0;\n    result.vUVW = vec3(0.0);\n    result.iObjectId = -1;\n    \n\tfloat t = minDist;\n\tconst int kRaymarchMaxIter = 96;\n\tfor(int i=0; i<kRaymarchMaxIter; i++)\n\t{\t\t\n\t\tresult = Scene_GetDistance( vRayOrigin + vRayDir * t, iInsideObject );\n        t += result.fDist;\n\n        if ( abs(result.fDist) < 0.001 )\n\t\t{\n\t\t\tbreak;\n\t\t}\t\t\n\n        if ( ( iInsideObject == -1 ) && (abs(result.fDist) > 0.1) )\n        {\n            result.iObjectId = -1;\n        }\n        \n        if ( t > maxDist )\n        {\n            result.iObjectId = -1;\n\t        t = maxDist;\n            break;\n        }        \n\t}\n    \n    result.fDist = t;\n\n\n    return result;\n}    \n\nfloat Scene_TraceShadow( const in vec3 vRayOrigin, const in vec3 vRayDir, const in float fMinDist, const in float fLightDist )\n{\n    \/\/return 1.0;\n    \/\/return ( Scene_Trace( vRayOrigin, vRayDir, 0.1, fLightDist ).fDist < fLightDist ? 0.0 : 1.0;\n    \n\tfloat res = 1.0;\n    float t = fMinDist;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = Scene_GetDistance( vRayOrigin + vRayDir * t, -1 ).fDist;\n        res = min( res, 8.0*h\/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.0001 || t>fLightDist ) break;\n    }\n    return clamp( res, 0.0, 1.0 );    \n}\n\nfloat Scene_GetAmbientOcclusion( const in vec3 vPos, const in vec3 vDir )\n{\n    float fOcclusion = 0.0;\n    float fScale = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float fOffsetDist = 0.01 + 1.0*float(i)\/4.0;\n        vec3 vAOPos = vDir * fOffsetDist + vPos;\n        float fDist = Scene_GetDistance( vAOPos, -1 ).fDist;\n        fOcclusion += (fOffsetDist - fDist) * fScale;\n        fScale *= 0.4;\n    }\n    \n    return clamp( 1.0 - 2.0*fOcclusion, 0.0, 1.0 );\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Lighting\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \nstruct SurfaceInfo\n{\n    vec3 vPos;\n    vec3 vNormal;\n    vec3 vBumpNormal;    \n    vec3 vAlbedo;\n    vec3 vR0;\n    float fSmoothness;\n    vec3 vEmissive;\n   \tfloat fTransparency;\n    float fRefractiveIndex;\n};\n    \nSurfaceInfo Scene_GetSurfaceInfo( const in vec3 vRayOrigin,  const in vec3 vRayDir, SceneResult traceResult, int iInsideObject );\n\nstruct SurfaceLighting\n{\n    vec3 vDiffuse;\n    vec3 vSpecular;\n};\n    \nSurfaceLighting Scene_GetSurfaceLighting( const in vec3 vRayDir, in SurfaceInfo surfaceInfo );\n\nfloat Light_GIV( float dotNV, float k)\n{\n\treturn 1.0 \/ ((dotNV + 0.0001) * (1.0 - k)+k);\n}\n\nvoid Light_Add(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\n\tfloat fNDotL = clamp(dot(vLightDir, surface.vBumpNormal), 0.0, 1.0);\n\t\n\tlighting.vDiffuse += vLightColour * fNDotL;\n    \n\tvec3 vH = normalize( -vViewDir + vLightDir );\n\tfloat fNdotV = clamp(dot(-vViewDir, surface.vBumpNormal), 0.0, 1.0);\n\tfloat fNdotH = clamp(dot(surface.vBumpNormal, vH), 0.0, 1.0);\n    \n\tfloat alpha = 1.0 - surface.fSmoothness;\n\t\/\/ D\n\n\tfloat alphaSqr = alpha * alpha;\n\tfloat denom = fNdotH * fNdotH * (alphaSqr - 1.0) + 1.0;\n\tfloat d = alphaSqr \/ (PI * denom * denom);\n\n\tfloat k = alpha \/ 2.0;\n\tfloat vis = Light_GIV(fNDotL, k) * Light_GIV(fNdotV, k);\n\n\tfloat fSpecularIntensity = d * vis * fNDotL;    \n\tlighting.vSpecular += vLightColour * fSpecularIntensity;    \n}\n\nvoid Light_AddPoint(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightPos, const in vec3 vLightColour)\n{    \n    vec3 vPos = surface.vPos;\n\tvec3 vToLight = vLightPos - vPos;\t\n    \n\tvec3 vLightDir = normalize(vToLight);\n\tfloat fDistance2 = dot(vToLight, vToLight);\n\tfloat fAttenuation = 100.0 \/ (fDistance2);\n\t\n\tfloat fShadowFactor = Scene_TraceShadow( surface.vPos, vLightDir, 0.1, length(vToLight) );\n\t\n\tLight_Add( lighting, surface, vViewDir, vLightDir, vLightColour * fShadowFactor * fAttenuation);\n}\n\nvoid Light_AddDirectional(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\t\n\tfloat fAttenuation = 1.0;\n\tfloat fShadowFactor = Scene_TraceShadow( surface.vPos, vLightDir, 0.1, 10.0 );\n\t\n\tLight_Add( lighting, surface, vViewDir, vLightDir, vLightColour * fShadowFactor * fAttenuation);\n}\n\nvec3 Light_GetFresnel( vec3 vView, vec3 vNormal, vec3 vR0, float fGloss )\n{\n    float NdotV = max( 0.0, dot( vView, vNormal ) );\n\n    return vR0 + (vec3(1.0) - vR0) * pow( 1.0 - NdotV, 5.0 ) * pow( fGloss, 20.0 );\n}\n\nvoid Env_AddPointLightFlare(inout vec3 vEmissiveGlow, const in vec3 vRayOrigin, const in vec3 vRayDir, const in float fIntersectDistance, const in vec3 vLightPos, const in vec3 vLightColour)\n{\n    vec3 vToLight = vLightPos - vRayOrigin;\n    float fPointDot = dot(vToLight, vRayDir);\n    fPointDot = clamp(fPointDot, 0.0, fIntersectDistance);\n\n    vec3 vClosestPoint = vRayOrigin + vRayDir * fPointDot;\n    float fDist = length(vClosestPoint - vLightPos);\n\tvEmissiveGlow += sqrt(vLightColour * 0.05 \/ (fDist * fDist));\n}\n\nvoid Env_AddDirectionalLightFlareToFog(inout vec3 vFogColour, const in vec3 vRayDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\n\tfloat fDirDot = clamp(dot(vLightDir, vRayDir) * 0.5 + 0.5, 0.0, 1.0);\n\tfloat kSpreadPower = 2.0;\n\tvFogColour += vLightColour * pow(fDirDot, kSpreadPower) * 0.25;\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Rendering\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec4 Env_GetSkyColor( const vec3 vViewPos, const vec3 vViewDir );\nvec3 Env_ApplyAtmosphere( const in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist, const int iInsideObject );\nvec3 FX_Apply( in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist);\n\nstruct RayInfo\n{\n    vec3 vRayOrigin;\n    vec3 vRayDir;\n    float fStartDist;\n    float fLengthRemaining;\n    \n    float fRefractiveIndex;\n    \n    int iObjectId;\n    float fDist;\n    vec3 vColor;\n    vec3 vAmount;\n    \n    int iChild0;\n    int iChild1;\n};\n    \n#define RAY_STACK_SIZE 12\n\nRayInfo rayStack[RAY_STACK_SIZE];\n\nvoid RayInfo_Clear( inout RayInfo rayInfo )\n{\n    rayInfo = RayInfo( vec3(0), vec3(0), 0., -1., 1.0, -1, 0., vec3(0), vec3(1), -1, -1 );\n}\n\nvoid RayStack_Reset()\n{\n    for ( int i=0; i<RAY_STACK_SIZE; i++)\n    {\n\t    RayInfo_Clear( rayStack[i] );\n    }\n}\n\nRayInfo RayStack_Get( int index )\n{\n\treturn rayStack[index];\n    \/\/if ( index < RAY_STACK_SIZE )\n    \/\/{\n\t\/\/\treturn rayStack[index];\n    \/\/}\n    \/\/\n    \/\/RayInfo result;\n    \/\/RayInfo_Clear( result );\n    \/\/return result;\n}\n\nvoid RayStack_Set( int index, RayInfo rayInfo )\n{\n    rayStack[index] = rayInfo;\n}\n\nvec4 Scene_GetColorAndDepth( const in vec3 vInRayOrigin, const in vec3 vInRayDir )\n{\n\tvec3 vResultColor = vec3(0.0);\n            \n\tSceneResult firstTraceResult;\n    \n    int stackCurrent = 0;\n    int stackEnd = 1;\n    \n    RayStack_Reset();\n        \n    rayStack[0].vRayOrigin = vInRayOrigin;\n    rayStack[0].vRayDir = vInRayDir;\n    rayStack[0].fStartDist = 0.0;\n    rayStack[0].fLengthRemaining = kMaxTraceDist;\n    rayStack[0].fRefractiveIndex = 1.0;\n    rayStack[0].vAmount = vec3(1.0);\n    rayStack[0].iChild0 = -1;\n    rayStack[0].iChild1 = -1;       \n           \n\tfor( int iPassIndex=0; iPassIndex < RAY_STACK_SIZE; iPassIndex++ )\n\t{\t                \n        if ( stackCurrent >= RAY_STACK_SIZE )\n            break;\n        \n        RayInfo rayInfo = RayStack_Get( stackCurrent );\n        \n        if ( rayInfo.fLengthRemaining <= 0.0 )\n            continue;\n        \n        rayInfo.iChild0 = -1;\n        rayInfo.iChild1 = -1;\n        \n    \tSceneResult traceResult = Scene_Trace( rayInfo.vRayOrigin, rayInfo.vRayDir, rayInfo.fStartDist, rayInfo.fLengthRemaining, rayInfo.iObjectId );\n        \n        rayInfo.fDist = traceResult.fDist;\n        \n        \/\/if ( iPassIndex == 0 )\n        \/\/{\n          \/\/  firstTraceResult = traceResult;\n        \/\/}\n        \n\t\trayInfo.vColor = vec3(0.0);\n\t\tvec3 vReflectance = vec3(1.0);\n\n\t\tif( traceResult.iObjectId < 0 )\n\t\t{\n            rayInfo.vColor = Env_GetSkyColor( rayInfo.vRayOrigin, rayInfo.vRayDir ).rgb;\n        }\n        else\n        {\n            SurfaceInfo surfaceInfo = Scene_GetSurfaceInfo( rayInfo.vRayOrigin, rayInfo.vRayDir, traceResult, rayInfo.iObjectId );\n            SurfaceLighting surfaceLighting = Scene_GetSurfaceLighting( rayInfo.vRayDir, surfaceInfo );\n                \n            \/\/ calculate reflectance (Fresnel)\n            float NdotV = clamp( dot(surfaceInfo.vBumpNormal, -rayInfo.vRayDir ), 0.0, 1.0);\n\t\t\tvReflectance = Light_GetFresnel( -rayInfo.vRayDir, surfaceInfo.vBumpNormal, surfaceInfo.vR0, surfaceInfo.fSmoothness );\n\t\t\t\n\t\t\trayInfo.vColor = (surfaceInfo.vAlbedo * surfaceLighting.vDiffuse + surfaceInfo.vEmissive) * (vec3(1.0) - vReflectance); \n            \n\t\t\tvec3 vReflectAmount = vReflectance;                \n            vec3 vTranmitAmount = vec3(1.0) - vReflectance;\n            vTranmitAmount *= surfaceInfo.fTransparency;\n            \n            bool doReflection = true;\n            \n            \/\/ superhack\n            \/\/if ( false )\n            if ( surfaceInfo.fTransparency > 0.0 )\n            {                \n                vec3 vTestAmount = vTranmitAmount * rayInfo.vAmount;\n                \n                if ( (vTestAmount.x + vTestAmount.y + vTestAmount.z) > 0.01 )\n                {\n                    RayInfo refractRayInfo;\n\n                    refractRayInfo.vAmount = vTranmitAmount;\n                    refractRayInfo.vRayOrigin = surfaceInfo.vPos;\n                    refractRayInfo.iObjectId = traceResult.iObjectId;\n                                        \n\t\t\t\t\trefractRayInfo.vRayDir = refract( rayInfo.vRayDir, surfaceInfo.vBumpNormal, rayInfo.fRefractiveIndex \/ surfaceInfo.fRefractiveIndex );\n                    if ( traceResult.iObjectId == rayInfo.iObjectId )\n                    {\n                        refractRayInfo.iObjectId = -1;\n                    }                    \n                    \/*\n                    if ( (rayInfo.fObjectId != -1.) && (traceResult.fObjectId == rayInfo.fObjectId) )\n                    {\n                        refractRayInfo.fObjectId = -1.;\n                        refractRayInfo.vRayDir = refract( rayInfo.vRayDir, surfaceInfo.vBumpNormal, surfaceInfo.fRefractiveIndex );\n                    }\n                    else\n                    {\n                        refractRayInfo.vRayDir = refract( rayInfo.vRayDir, surfaceInfo.vBumpNormal, 1.0 \/ surfaceInfo.fRefractiveIndex );\n                    }*\/\n                    \n                    if ( length( refractRayInfo.vRayDir ) > 0.0 )\n                    {\n                        refractRayInfo.vRayDir = normalize(refractRayInfo.vRayDir);\n                        \/\/refractRayInfo.vRayDir.xz *= -1.0;\n                        refractRayInfo.fStartDist = abs(0.1 \/ dot( refractRayInfo.vRayDir, surfaceInfo.vNormal ));            \n                        refractRayInfo.fLengthRemaining = rayInfo.fLengthRemaining - traceResult.fDist;                \n                        refractRayInfo.fDist = 1.0 - rayInfo.fDist;\n                        refractRayInfo.fRefractiveIndex = surfaceInfo.fRefractiveIndex;\n\n                        rayInfo.iChild1 = stackEnd;\n\n                        \/\/if ( stackEnd < RAY_STACK_SIZE )\n                        {\n                            rayInfo.vColor *= 1.0 - surfaceInfo.fTransparency;        \n                            refractRayInfo.vAmount *= surfaceInfo.fTransparency;\n                        }\n                        RayStack_Set( stackEnd, refractRayInfo );                        \n                        stackEnd++;\n                        \n                        doReflection = false;\n                    }\n                    else\n                    {\n                        vReflectAmount += vTranmitAmount;\n                    }\n                }\n            }\n                        \n            \/\/ Reflect Ray\n            if ( doReflection )\n            {\n                vec3 vTestAmount = vReflectAmount * rayInfo.vAmount;\n                \n                if ( (vTestAmount.x + vTestAmount.y + vTestAmount.z) > 0.01 )\n                {                \n                    RayInfo reflectRayInfo;\n\n                    reflectRayInfo.vAmount = vReflectAmount;\n                    reflectRayInfo.vRayOrigin = surfaceInfo.vPos;\n                    reflectRayInfo.vRayDir = normalize( reflect( rayInfo.vRayDir, surfaceInfo.vBumpNormal ) );\n                    reflectRayInfo.iObjectId = rayInfo.iObjectId;\n                    reflectRayInfo.fStartDist = abs(0.01 \/ dot( reflectRayInfo.vRayDir, surfaceInfo.vNormal ));            \n                    reflectRayInfo.fLengthRemaining = rayInfo.fLengthRemaining - traceResult.fDist;                \n                    reflectRayInfo.fRefractiveIndex = rayInfo.fRefractiveIndex;\n\n                    rayInfo.iChild0 = stackEnd;\n\n                    RayStack_Set( stackEnd, reflectRayInfo );\n                    stackEnd++;\n                }\n            }\n            \n            rayInfo.vColor += surfaceLighting.vSpecular * vReflectance;            \n        }\n        \n\t\tRayStack_Set( stackCurrent, rayInfo );\n                \n        stackCurrent++;\n    }\n        \n\tfor( int iStackPos=(RAY_STACK_SIZE-1); iStackPos >= 0; iStackPos-- )\n\t{\t    \n        RayInfo rayInfo = RayStack_Get( iStackPos );\n\n        if ( rayInfo.fLengthRemaining <= 0.0 )\n            continue;\n\n        \/\/ Accumulate colors from child rays\n        \n        if ( rayInfo.iChild0 >= 0 )\n        {\n\t        RayInfo childRayInfo = RayStack_Get( rayInfo.iChild0 );\n            if ( childRayInfo.fDist > 0.0 )\n            {\n            \trayInfo.vColor += childRayInfo.vAmount * childRayInfo.vColor;\n            }\n        }\n\n        if ( rayInfo.iChild1 >= 0 )\n        {\n\t        RayInfo childRayInfo = RayStack_Get( rayInfo.iChild1 );\n            if ( childRayInfo.fDist > 0.0 )\n            {\n\t            rayInfo.vColor += childRayInfo.vAmount * childRayInfo.vColor;\n            }\n        }\n        \n\t\trayInfo.vColor = Env_ApplyAtmosphere( rayInfo.vColor, rayInfo.vRayOrigin, rayInfo.vRayDir, rayInfo.fDist, rayInfo.iObjectId );\n\t\trayInfo.vColor = FX_Apply( rayInfo.vColor, rayInfo.vRayOrigin, rayInfo.vRayDir, rayInfo.fDist );\n            \n\t\tRayStack_Set( iStackPos, rayInfo );        \n    }    \n    \n    if ( firstTraceResult.iObjectId >= MAT_FG_BEGIN )\n    {\n        firstTraceResult.fDist = -firstTraceResult.fDist;\n    }\n        \n    return vec4( rayStack[0].vColor, rayStack[0].fDist );\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Utility Functions\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Scene Description\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ Materials\n\n#define MAT_SKY\t\t \t-1\n#define MAT_DEFAULT \t0\n#define MAT_GLASS\t \t1\n#define MAT_WINE\t \t2\n#define MAT_STEEL\t \t3\n#define MAT_GLOSS_PAINT\t 4\n\n\nSurfaceInfo Scene_GetSurfaceInfo( const in vec3 vRayOrigin,  const in vec3 vRayDir, SceneResult traceResult, int iInsideObject )\n{\n    SurfaceInfo surfaceInfo;\n    \n    surfaceInfo.vPos = vRayOrigin + vRayDir * (traceResult.fDist);\n    \n    surfaceInfo.vNormal = Scene_GetNormal( surfaceInfo.vPos, iInsideObject ); \n    surfaceInfo.vBumpNormal = surfaceInfo.vNormal;\n    surfaceInfo.vAlbedo = vec3(1.0);\n    surfaceInfo.vR0 = vec3( 0.01 );\n    surfaceInfo.fSmoothness = 1.0;\n    surfaceInfo.vEmissive = vec3( 0.0 );\n    \n    surfaceInfo.fTransparency = 0.0;\n    surfaceInfo.fRefractiveIndex = 1.0;\n        \n    if ( traceResult.iObjectId == MAT_DEFAULT )\n    {\n    \tsurfaceInfo.vR0 = vec3( 0.02 );\n\t    surfaceInfo.vAlbedo = textureLod( iChannel2, traceResult.vUVW.xz * 0.5, 0.0 ).rgb;\n        surfaceInfo.vAlbedo = surfaceInfo.vAlbedo * surfaceInfo.vAlbedo;\n                        \n    \tsurfaceInfo.fSmoothness = clamp( 1.0 - surfaceInfo.vAlbedo.r * surfaceInfo.vAlbedo.r * 2.0, 0.0, 1.0);\n        \n        surfaceInfo.vAlbedo *= 0.25;\n        \n        \/*surfaceInfo.vBumpNormal.x += surfaceInfo.vAlbedo.r;\n        surfaceInfo.vBumpNormal.z += surfaceInfo.vAlbedo.g;\n        surfaceInfo.vAlbedo = mix( vec3(0,.1,0), vec3(0.1, 0.8, 0.2), surfaceInfo.vAlbedo);\n        surfaceInfo.fSmoothness = 0.0;*\/\n        \n        \/\/surfaceInfo.vR0 = vec3(clamp(surfaceInfo.vAlbedo.r - surfaceInfo.vPos.x, 0.0, 1.0));\n        \n        float fDist = length( surfaceInfo.vPos.xz );\n        \n        float fCheckerAmount = clamp( 1.0 - fDist * 0.1 + surfaceInfo.vAlbedo.r * 0.5, 0.0, 1.0);\n        \n        vec3 vChecker;\n        float fChecker = step(fract((floor(traceResult.vUVW.x) + floor(traceResult.vUVW.z)) * 0.5), 0.25);\n        if ( fChecker > 0.0 )\n        {\n            vChecker = vec3(1.0);\n        }\n        else\n        {\n            vChecker = vec3(0.1);\n        }\n                \n        surfaceInfo.vAlbedo = mix(surfaceInfo.vAlbedo, vChecker, fCheckerAmount);\n        surfaceInfo.vR0 = mix(surfaceInfo.vR0, vec3(0.1), fCheckerAmount);\n        surfaceInfo.fSmoothness =  mix(surfaceInfo.fSmoothness, 1.0, fCheckerAmount);\n        \n    }\n\n  \/*  if ( traceResult.fObjectId == MAT_STEEL )\n    {\n\t    surfaceInfo.vAlbedo = texture( iChannel2, traceResult.vUVW.xz ).rgb;\n        surfaceInfo.vAlbedo = surfaceInfo.vAlbedo * surfaceInfo.vAlbedo;\n        \n    \tsurfaceInfo.fSmoothness = surfaceInfo.vAlbedo.r;\/\/clamp( surfaceInfo.vAlbedo.r, 0.0, 1.0);                \n        \n        surfaceInfo.vAlbedo = surfaceInfo.vAlbedo * 0.5;\n                        \n    \tsurfaceInfo.vR0 = vec3( surfaceInfo.vAlbedo.r * surfaceInfo.vAlbedo.r * 0.8 );\n\n        vec3 vDirt = texture( iChannel3, traceResult.vUVW.xz ).rgb;\n        vDirt = vDirt * vDirt;\n        surfaceInfo.vAlbedo = vDirt * ( 1.0 - surfaceInfo.vAlbedo.r) * 0.1;\/\/mix( surfaceInfo.vAlbedo, vDirt, 1.0 - surfaceInfo.vAlbedo.r );\n        \n    }*\/\n    \n    if ( traceResult.iObjectId == MAT_GLOSS_PAINT )\n    {\n        \/\/float fChecker = step(fract((floor(traceResult.vUVW.x) + floor(traceResult.vUVW.z)) * 0.5), 0.25);\n        float fStripe = step( fract( dot( traceResult.vUVW * 5.0, vec3(1.0, 0.2, 0.4) ) ), 0.5 );\n        if ( fStripe > 0.0 )\n        {\n\t        surfaceInfo.vAlbedo = vec3(0.1, 0.05, 1.0);\n        }\n        else\n        {\n\t        surfaceInfo.vAlbedo = vec3(1.0, 0.05, 0.1);\n        }        \n    }\n    \n    \n    if ( traceResult.iObjectId == MAT_GLASS )\n    {\n    \tsurfaceInfo.vR0 = vec3( 0.02 );\n\n        vec3 vAlbedo;\n        vAlbedo = textureLod( iChannel3, traceResult.vUVW.xy * 2.0, 0.0 ).rgb;\n        vAlbedo = vAlbedo * vAlbedo;\n        vAlbedo *= vec3(1.0, 0.1, 0.5);\n                \n        surfaceInfo.vAlbedo = vAlbedo;\n        \n    \t\/\/surfaceInfo.fSmoothness = 0.9;\/\/clamp( 1.0 - surfaceInfo.vAlbedo.r * surfaceInfo.vAlbedo.r * 2.0, 0.0, 1.0);\n    \tsurfaceInfo.fSmoothness = clamp( 1.0 - surfaceInfo.vAlbedo.r * 2.0, 0.0, 0.9);\n\n        surfaceInfo.fTransparency = clamp( surfaceInfo.vPos.y * 5.0 + surfaceInfo.vAlbedo.g * 3.0, 0.0, 1.0);\n\n        if ( surfaceInfo.vPos.x < 0.0 || surfaceInfo.vPos.z < 0.0 )\n        {\n        \tsurfaceInfo.vAlbedo = vec3(0.0);                \n    \t\tsurfaceInfo.fSmoothness = 0.9;\n            surfaceInfo.fTransparency = 1.0 - vAlbedo.g * 0.2;\n        }\n        \n        surfaceInfo.fRefractiveIndex = 1.5;\n        \n        \n        float fLipStickDist = length(surfaceInfo.vPos - vec3(0.3, 3.1, -2.9)) - 1.0;\n        if ( fLipStickDist < 0.0 )\n        {            \n            surfaceInfo.fTransparency = clamp(1.0 +fLipStickDist * 2.0- vAlbedo.r, 0.0, 1.0);\n            surfaceInfo.vAlbedo = vec3(0.5,0,0) * (1.0 - surfaceInfo.fTransparency);\n        }\n        \n        \/*surfaceInfo.vBumpNormal.x += surfaceInfo.vAlbedo.r;\n        surfaceInfo.vBumpNormal.z += surfaceInfo.vAlbedo.g;\n        surfaceInfo.vAlbedo = mix( vec3(0,.1,0), vec3(0.1, 0.8, 0.2), surfaceInfo.vAlbedo);\n        surfaceInfo.fSmoothness = 0.0;*\/\n    }\n\n    if ( traceResult.iObjectId == MAT_WINE )\n    {\n    \tsurfaceInfo.vR0 = vec3( 0.02 );\n        surfaceInfo.vAlbedo = vec3(0.0);\n                \n    \tsurfaceInfo.fSmoothness = 0.9;\n        \n        surfaceInfo.fTransparency = 1.0;\n        surfaceInfo.fRefractiveIndex = 1.3;        \n        \n        \/*surfaceInfo.vBumpNormal.x += surfaceInfo.vAlbedo.r;\n        surfaceInfo.vBumpNormal.z += surfaceInfo.vAlbedo.g;\n        surfaceInfo.vAlbedo = mix( vec3(0,.1,0), vec3(0.1, 0.8, 0.2), surfaceInfo.vAlbedo);\n        surfaceInfo.fSmoothness = 0.0;*\/\n    }\n    \n    if ( traceResult.iObjectId == iInsideObject )\n    {\n\t\tsurfaceInfo.fRefractiveIndex = 1.0;            \n    }\n    \n    return surfaceInfo;\n}\n\n\/\/ Scene Description\nfloat GetDistanceMug( const in vec3 vPos )\n{\n\tfloat fDistCylinderOutside = length(vPos.xz) - 1.0;\n\tfloat fDistCylinderInterior = length(vPos.xz) - 0.9;\n\tfloat fTop = vPos.y - 1.0;\n       \n\tfloat r1 = 0.6;\n\tfloat r2 = 0.15;\n\tvec2 q = vec2(length(vPos.xy + vec2(1.2, -0.1))-r1,vPos.z);\n\tfloat fDistHandle = length(q)-r2;\n       \n\tfloat fDistMug = max(max(min(fDistCylinderOutside, fDistHandle), fTop), -fDistCylinderInterior);\n\treturn fDistMug;\n}\n\nfloat SmoothMin( float a, float b, float k )\n{\n\t\/\/return min(a,b);\n\t\n\t\n    \/\/float k = 0.06;\n\tfloat h = clamp( 0.5 + 0.5*(b-a)\/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat GetDistanceWine( vec3 vPos )\n{\n    vec3 vLocalPos = vPos;\n    vLocalPos.y -= 2.0;\n    \n    vec2 vPos2 = vec2(length(vLocalPos.xz), vLocalPos.y);\n    \n    vec2 vSphOrigin = vec2(0);\n    vec2 vSphPos = vPos2 - vSphOrigin;   \n    \n    float fBowlDistance = length( vSphPos ) -  0.6 + 0.01;\n    \n    vec3 vWaterNormal = vec3(0,1,0);\n    \n    vWaterNormal.x = sin( iTime * 5.0) * 0.01;\n    vWaterNormal.z = cos( iTime * 5.0) * 0.01;\n    \n    vWaterNormal = normalize( vWaterNormal );\n    float fWaterLevel = dot(vLocalPos, vWaterNormal) - 0.1;\n        \n    return max( fBowlDistance, fWaterLevel );\n}\n\nfloat GetDistanceWineGlass( vec3 vPos )\n{\n    vec2 vPos2 = vec2(length(vPos.xz), vPos.y);\n    \n    vec2 vSphOrigin = vec2(0,2.0);\n    vec2 vSphPos = vPos2 - vSphOrigin;\n    \n    vec2 vClosest = vSphPos;\n    \n    if ( vClosest.y > 0.3 ) vClosest.y = 0.3;\n    vClosest = normalize(vClosest) * 0.6;\n    \n    float fBowlDistance = distance( vClosest, vSphPos ) - 0.015;\n    \n    vec2 vStemClosest = vPos2;\n    vStemClosest.x = 0.0;    \n    vStemClosest.y = clamp(vStemClosest.y, 0.0, 1.35);\n    \n    float fStemRadius = vStemClosest.y - 0.5;\n    fStemRadius = fStemRadius * fStemRadius * 0.02 + 0.03;\n    \n    float fStemDistance = distance( vPos2, vStemClosest ) - fStemRadius;\n    \n    \n    vec2 norm = normalize( vec2( 0.4, 1.0 ) );\n    vec2 vBaseClosest = vPos2;\n    float fBaseDistance = dot( vPos2 - vec2(0.0, 0.1), norm ) - 0.2;\n    fBaseDistance = max( fBaseDistance, vPos2.x - 0.5 ); \n\n    float fDistance = SmoothMin(fBowlDistance, fStemDistance, 0.2);\n    fDistance = SmoothMin(fDistance, fBaseDistance, 0.2);\n    \n    fDistance = max( fDistance, vSphPos.y - 0.5 );\n        \n    return fDistance;\n}\n\nfloat GetDistanceBowl( vec3 vPos )\n{    \n    vec2 vPos2 = vec2(length(vPos.xz), vPos.y);\n    \n    vec2 vSphOrigin = vec2(0,1.0 - 0.3 + 0.03);\n    vec2 vSphPos = vPos2 - vSphOrigin;\n    \n    vec2 vClosest = vSphPos;\n    \n    if ( vClosest.y > 0.1 ) vClosest.y = 0.1;\n    if ( vClosest.y < -0.7 ) vClosest.y = -0.7;\n    \n    float r = sqrt( 1.0 - vClosest.y * vClosest.y);    \n    vClosest.x = r;        \n    \n    float fBowlDistance = distance( vClosest, vSphPos );   \n    \n    vClosest = vSphPos;\n    vClosest.y = -0.7;    \n    r = sqrt( 1.0 - vClosest.y * vClosest.y);    \n    vClosest.x = min( vClosest.x, r ); \n    \n    float fBaseDistance = distance( vClosest, vSphPos );\n    \n    fBowlDistance = min( fBowlDistance, fBaseDistance );   \n    \n    return fBowlDistance- 0.03;\n}\n\n\nSceneResult Scene_GetDistance( const vec3 vPos, const int iInsideObject )\n{\n    SceneResult result;\n    \n    vec3 vWineGlassPos = vec3(0.0, 0.0, -2.0);\n    vec3 vBowlPos = vec3(1.0, 0.0, 1.0 );\n\n\tresult.fDist = vPos.y;\n    result.vUVW = vPos;\n\tresult.iObjectId = MAT_DEFAULT;\n\n        \n    SceneResult sphereResult1;\n    \n    \n    vec3 vSphere1Pos = vBowlPos + vec3(0.4, 0.5, 0.2);\n    sphereResult1.vUVW = vPos - vSphere1Pos;\n    sphereResult1.fDist = min( result.fDist, length(vPos - vSphere1Pos) - 0.4);\n\tsphereResult1.iObjectId = MAT_GLOSS_PAINT;\n    Scene_Union( result, sphereResult1 );    \n    \n\n    vec3 vSphere2Pos = vec3(2.2, 0.5, -0.9);\n    SceneResult sphereResult2;\n    sphereResult2.vUVW = (vPos - vSphere2Pos).zyx;\n\tsphereResult2.fDist = length(vPos - vSphere2Pos) - 0.5;\n\tsphereResult2.iObjectId = MAT_GLOSS_PAINT;\n    Scene_Union( result, sphereResult2 );\n    \n    if ( result.fDist > 10.0 )\n    {\n        result.iObjectId = MAT_SKY;\n    }\n    \n    SceneResult wineResult;\n    wineResult.vUVW = vPos;\n\twineResult.iObjectId = MAT_WINE;    \n    wineResult.fDist = GetDistanceWine( vPos - vWineGlassPos );\n    \n    \n    float fRadius = 1.0;\n    float fHeight = 1.0;\n    \n    SceneResult glassResult;\n    glassResult.iObjectId = MAT_GLASS;\n    glassResult.fDist = length(vPos - vec3(-2.0,fHeight,1.0)) - fRadius;\n    \n    glassResult.fDist = min(glassResult.fDist, GetDistanceBowl( vPos - vBowlPos));\n        \n    glassResult.vUVW = vPos.xzy;\n    glassResult.fDist = min( glassResult.fDist, GetDistanceWineGlass(vPos - vWineGlassPos ) );    \n\n    \/\/glassResult.fDist = min( glassResult.fDist, GetDistanceMug(vPos - vec3(-2.0, 1.0, -2.0) ) );    \n\n    Scene_Trim( wineResult, glassResult );\n    wineResult.fDist -= 0.0001;\n    \n    if ( iInsideObject == MAT_GLASS )\n    {\n        glassResult.fDist = -glassResult.fDist;\n    }\n\n    if ( iInsideObject == MAT_WINE )\n    {\n        wineResult.fDist = -wineResult.fDist;\n    }\n        \n    Scene_Union( result, glassResult );\n    Scene_Union( result, wineResult );\n    \n    return result;\n}\n\n\n\n\/\/ Scene Lighting\n\nvec3 g_vSunDir = normalize(vec3(1.0, 0.4, 0.5));\nvec3 g_vSunColor = vec3(1, 0.7, 0.5) * 5.0;\nvec3 g_vAmbientColor = vec3(0.8, 0.2, 0.1);\n\nSurfaceLighting Scene_GetSurfaceLighting( const in vec3 vViewDir, in SurfaceInfo surfaceInfo )\n{\n    SurfaceLighting surfaceLighting;\n    \n    surfaceLighting.vDiffuse = vec3(0.0);\n    surfaceLighting.vSpecular = vec3(0.0);    \n    \n    Light_AddDirectional( surfaceLighting, surfaceInfo, vViewDir, g_vSunDir, g_vSunColor );\n    \n    \/\/Light_AddPoint( surfaceLighting, surfaceInfo, vViewDir, vec3(1.4, 1.0, 5.8), vec3(1,1,1) );\n    \n    float fAO = Scene_GetAmbientOcclusion( surfaceInfo.vPos, surfaceInfo.vNormal );\n    \/\/ AO\n    surfaceLighting.vDiffuse += fAO * (surfaceInfo.vBumpNormal.y * 0.5 + 0.5) * g_vAmbientColor;\n    \n    return surfaceLighting;\n}\n\n\/\/ Environment\n\nvec4 Env_GetSkyColor( const vec3 vViewPos, const vec3 vViewDir )\n{\n\tvec4 vResult = vec4( 0.0, 0.0, 1.0, kFarDist );\n    \n    vec3 vEnvMap = textureLod( iChannel1, vViewDir, 0.0 ).rgb;\n    vEnvMap = vEnvMap * vEnvMap;\n    float kEnvmapExposure = 0.999;\n    vResult.rgb = -log2(1.0 - vEnvMap * kEnvmapExposure);\n        \n    \/*\n\tvec4 vResult = vec4( 0.0, 0.0, 0.0, kFarDist );\n\t\n    float fElevation = atan( vViewDir.y, length(vViewDir.xz) );\n    float fHeading = atan( vViewDir.x, vViewDir.z );\n    \n    float fSkyElevationMin = -PI * 0.125;\n    float fSkyElevationMax = PI * 0.5;\n\n    float fScaledElevation = 0.5 * ((fElevation - fSkyElevationMin) \/ (fSkyElevationMax - fSkyElevationMin));\n    if (fHeading < 0.0) fScaledElevation = 1.0 - fScaledElevation;\n    vec2 vUV = vec2( fract(fHeading \/ PI), fScaledElevation );\n    \n    vResult = texture( iChannel3, vUV );\n    \n    \/\/vResult = mix( vec3(0.02, 0.04, 0.06), vec3(0.1, 0.3, 0.8) * 3.0, vViewDir.y * 0.5 + 0.5 );\n\t\n    \/\/ Sun\n    float NdotV = dot( g_vSunDir, vViewDir );\n    vResult.rgb += smoothstep( cos(radians(.7)), cos(radians(.5)), NdotV ) * g_vSunColor * 5000.0;\n    \n\t*\/\n\n    return vResult;\t\n}\n\nfloat Env_GetFogFactor(const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist, const float fInsideObject)\n{    \n\tfloat kFogDensity = 0.00001;\n\treturn exp(fDist * -kFogDensity);\t\n}\n\nvec3 Env_GetFogColor(const in vec3 vDir, const float fInsideObject)\n{    \n\treturn vec3(0.2, 0.5, 0.6) * 2.0;\t\t\n}\n\nvec3 Env_ApplyAtmosphere( const in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist, const int iInsideObject )\n{\n    \/\/return vColor;\n    vec3 vResult = vColor;\n    \n    \/*\n\tfloat fFogFactor = Env_GetFogFactor( vRayOrigin, vRayDir, fDist, fInsideObject );\n\tvec3 vFogColor = Env_GetFogColor( vRayDir, fInsideObject );\t\n\tEnv_AddDirectionalLightFlareToFog( vFogColor, vRayDir, g_vSunDir, g_vSunColor * 3.0);    \n    vResult = mix( vFogColor, vResult, fFogFactor );\n\t*\/\n    \n    \/\/ Glass extinction\n    if ( iInsideObject == MAT_GLASS || iInsideObject == MAT_WINE )\n    {\n        vec3 vExtCol = vec3(0);\n\n        if ( iInsideObject == MAT_WINE )\n        {\n            vExtCol = vec3(1.0) - vec3(1.0, 0.5, 0.01);\n        }\n        else\n        {\n            if ( vRayOrigin.z > 0.0 )\n            {\n                if ( vRayOrigin.x < 0.0 )\n                {\n                    vExtCol = vec3(1.0) - vec3(0.01, 0.01, 1.0);\n                }\n                else\n                {\n                    vExtCol = vec3(1.0) - vec3(1.0, 0.2, 0.8);\n                    vExtCol *= 20.0;\n                }\n            }\n        }\n        \n\t\tvResult *= exp(fDist * -vExtCol);\t\n    }\n    \n\n    return vResult;\t    \n}\n\n\nvec3 FX_Apply( in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist)\n{    \n    return vColor;\n}\n\nfloat fPlaneInFocus = 5.0;\n\nfloat GetCoC( float fDistance, float fPlaneInFocus )\n{\n\t\/\/ http:\/\/http.developer.nvidia.com\/GPUGems\/gpugems_ch23.html\n\n    float fAperture = 0.05;\n    float fFocalLength = 0.8;\n  \n\treturn abs(fAperture * (fFocalLength * (fDistance - fPlaneInFocus)) \/\n          (fDistance * (fPlaneInFocus - fFocalLength)));  \n}\n\nvec4 MainCommon( vec3 vRayOrigin, vec3 vRayDir, float fShade )\n{\n\tvec4 vColorLinAmdDepth = Scene_GetColorAndDepth( vRayOrigin, vRayDir );    \n    vColorLinAmdDepth.rgb = max( vColorLinAmdDepth.rgb, vec3(0.0) );\n        \n    vec4 vFragColor = vColorLinAmdDepth;\n    \n    vFragColor.rgb *= fShade;\n    \n    vFragColor.a = GetCoC( vColorLinAmdDepth.w, fPlaneInFocus );    \n    \n    return vFragColor;\n}\n\nfloat GetVignetting( const in vec2 vUV, float fScale, float fPower, float fStrength )\n{\n\tvec2 vOffset = (vUV - 0.5) * sqrt(2.0) * fScale;\n\t\n\tfloat fDist = max( 0.0, 1.0 - length( vOffset ) );\n    \n\tfloat fShade = 1.0 - pow( fDist, fPower );\n    \n    fShade = 1.0 - fShade * fStrength;\n\n\treturn fShade;\n}\n\nvoid mainImage( out vec4 vFragColor, in vec2 vFragCoord )\n{\n    vec2 vUV = vFragCoord.xy \/ iResolution.xy; \n\n    CameraState cam;\n    \n    float fAngle = (iMouse.x \/ iResolution.x) * radians(360.0);\n    float fElevation = (iMouse.y \/ iResolution.y) * radians(90.0);\n\n    if ( iMouse.x <= 0.0 )\n    {\n        fAngle = -2.3;\n        fElevation = 0.5;\n    }\n    \n    float fDist = 6.0;\n    \n    cam.vPos = vec3(sin(fAngle) * fDist * cos(fElevation),sin(fElevation) * fDist,cos(fAngle) * fDist * cos(fElevation));\n    cam.vTarget = vec3(0,0.5,0);\n    cam.fFov = 20.0;\n    \n    vec3 vRayOrigin, vRayDir;\n    Cam_GetCameraRay( vUV, cam, vRayOrigin, vRayDir );\n \n    float fShade = GetVignetting( vUV, 0.7, 2.0, 1.0 );\n    \n    vFragColor= MainCommon( vRayOrigin, vRayDir, fShade );\n}\n\nvoid mainVR( out vec4 vFragColor, in vec2 vFragCoord, in vec3 vRayOrigin, in vec3 vRayDir )\n{   \n    {\n        vec3 vOrigin = vRayOrigin;\n        \n        vOrigin *= 15.0;\n        \n    \tvOrigin.y += 3.0;\n    \tvOrigin.z += 3.0;\n    \n    \tvFragColor = MainCommon( vOrigin, vRayDir, 1.0 );\n    }\n    \n    vFragColor.a = 0.0;\n    \n    \n    \/\/ read prev camera pos for both eyes\n    vec2 vLeftPosAddress = vec2(0.0, 0.0) + 0.5;\n    vec4 vLeftPos = texture( iChannel0, vLeftPosAddress \/ iChannelResolution[0].xy );\n    vec2 vLeftDirAddress = vec2(0.0, 1.0) + 0.5;\n    vec4 vLeftDir = texture( iChannel0, vLeftDirAddress \/ iChannelResolution[0].xy );\n    vec2 vRightPosAddress = vec2(floor(iChannelResolution[0].x\/2.0), 0.0) + 0.5;\n    vec4 vRightPos = texture( iChannel0, vRightPosAddress \/ iChannelResolution[0].xy );\n    vec2 vRightDirAddress = vec2(floor(iChannelResolution[0].x\/2.0), 1.0) + 0.5;\n    vec4 vRightDir = texture( iChannel0, vRightDirAddress \/ iChannelResolution[0].xy );\n    \n    \/\/ Write camera pos for current eye\n    vec2 vAddress = floor( vFragCoord.xy );\n    if ( vAddress.x == 0.0 && vAddress.y == 0.0 )\n    {\n        vFragColor.rgb = vRayOrigin;\n    }\n    if ( vAddress.x == 0.0 && vAddress.y == 1.0 )\n    {\n        vFragColor.rgb = vRayDir;\n    }\n    \n\t\/\/ store prev left and right eye info\n    if ( vAddress.x == 1.0 && vAddress.y == 0.0)\n    {\n        vFragColor = vLeftPos;\n    }\n    if ( vAddress.x == 1.0 && vAddress.y == 1.0)\n    {\n        vFragColor = vLeftDir;\n    }\n    if ( vAddress.x == 2.0 && vAddress.y == 0.0)\n    {\n        vFragColor = vRightPos;\n    }\n    if ( vAddress.x == 2.0 && vAddress.y == 1.0)\n    {\n        vFragColor = vRightDir;\n    }\n\n    if ( vAddress.x == 2.0 && vAddress.y == 0.0)\n    {\n        vFragColor = vRightPos;\n    }\n    \n}\n\n","name":"Buf A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"3tsyzl","date":"1593154586","viewed":8609,"name":"Julia - Quaternion 3","username":"iq","description":"The cubic Julia set used in the introduction of my video \"Geodes\" ([url]https:\/\/www.shadertoy.com\/view\/3llyzl[\/url]). It has 3 bounces of super simple GI (no specular) and some temporal reprojection to remove noise.","likes":135,"published":3,"flags":32,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Copyright Inigo Quilez, 2020 - https:\/\/iquilezles.org\/\n\/\/ I am the sole copyright owner of this Work.\n\/\/ You cannot host, display, distribute or share this Work in any form,\n\/\/ including physical and digital. You cannot use this Work in any\n\/\/ commercial or non-commercial product, website or project. You cannot\n\/\/ sell this Work and you cannot mint an NFTs of it.\n\/\/ I share this Work for educational purposes, and you can link to it,\n\/\/ through an URL, proper attribution and unmodified screenshot, as part\n\/\/ of your educational material. If these conditions are too restrictive\n\/\/ please contact me and we'll definitely work it out.\n\/\/ The Julia set of f(z) = z\u00b3 + c, as rendered for the Youtube\n\/\/ video called \"Geodes\": https:\/\/www.youtube.com\/watch?v=rQ2bnU4dkso\n\/\/\n\/\/ I simplified a few things, reduced the number of GI bounces\n\/\/ and did some temporal reprojection to keep it more or less\n\/\/ real-time while looking similar to the one in the video.\n\/\/\n\/\/ Explanations:\n\/\/  https:\/\/iquilezles.org\/articles\/distancefractals\n\/\/  https:\/\/iquilezles.org\/articles\/orbittraps3d\n\/\/\n\/\/ Related shaders:\n\/\/\n\/\/ Julia - Quaternion 1 : https:\/\/www.shadertoy.com\/view\/MsfGRr\n\/\/ Julia - Quaternion 2 : https:\/\/www.shadertoy.com\/view\/lsl3W2\n\/\/ Julia - Quaternion 3 : https:\/\/www.shadertoy.com\/view\/3tsyzl\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord \/ iResolution.xy;\n\n    vec3 col = texture( iChannel0, p ).xyz;\n\n    \/\/ color grade\n    col = col*2.0\/(1.0+col);\n    col = pow( col, vec3(0.4545) );\n    col = pow(col,vec3(0.85,0.97,1.0));\n    col = col*0.5 + 0.5*col*col*(3.0-2.0*col);\n\n    \/\/ vignette\n    col *= 0.5 + 0.5*pow( 16.0*p.x*p.y*(1.0-p.x)*(1.0-p.y), 0.1 );\n    \n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ Created by inigo quilez - iq\/2020\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ The Julia set of f(z) = z\u00b3 + c, as rendered for the Youtube\n\/\/ video called \"Geodes\": https:\/\/www.shadertoy.com\/view\/3llyzl\n\/\/\n\/\/ I simplified a few things, reduced the number of GI bounces\n\/\/ and did some temporal reprojection to keep it more or less\n\/\/ real-time while looking similar to the one in the video.\n\/\/\n\/\/ Explanations:\n\/\/  https:\/\/iquilezles.org\/articles\/distancefractals\n\/\/  https:\/\/iquilezles.org\/articles\/orbittraps3d\n\/\/\n\/\/ Related shaders:\n\/\/\n\/\/ Julia - Quaternion 1 : https:\/\/www.shadertoy.com\/view\/MsfGRr\n\/\/ Julia - Quaternion 2 : https:\/\/www.shadertoy.com\/view\/lsl3W2\n\/\/ Julia - Quaternion 3 : https:\/\/www.shadertoy.com\/view\/3tsyzl\n\n\n\/\/ disable TRAPs to see just the set\n#define TRAPS\n\n\/\/ disable CUT to see the whole set\n#define CUT\n\nconst int   kNumIte = 200;\nconst float kPrecis = 0.00025;\nconst vec4  kC = vec4(-2,6,15,-6)\/22.0;\nconst float kFocLen = 3.0;\n#ifdef TRAPS\nconst float kBSRad = 2.0;\n#else\nconst float kBSRad = 1.2;\n#endif\n#define     kNumBounces 3\n\n\/\/ --------------------------------------\n\/\/ oldschool rand() from Visual Studio\n\/\/ --------------------------------------\nint   seed = 1;\nint   rand(void) { seed = seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())\/32767.0; }\nvoid  srand( ivec2 p, int frame )\n{\n    int n = frame;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589; \/\/ by Hugo Elias\n    n += p.y;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589;\n    n += p.x;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589;\n    seed = n;\n}\n\n\/\/--------------------------------------------------------------------------------\n\/\/ http:\/\/amietia.com\/lambertnotangent.html\n\/\/--------------------------------------------------------------------------------\nvec3 cosineDirection( in vec3 nor)\n{\n    float u = frand()*2.0-1.0;\n    float a = frand()*6.28318531;\n    return normalize(nor+vec3(sqrt(1.0-u*u)*vec2(cos(a),sin(a)), u) );\n}\n\/\/--------------------------------------------------------------------------------\n\/\/ quaternion manipulation\n\/\/--------------------------------------------------------------------------------\nvec4 qSquare( in vec4 q )\n{\n    return vec4(q.x*q.x - q.y*q.y - q.z*q.z - q.w*q.w, 2.0*q.x*q.yzw);\n}\nvec4 qCube( in vec4 q )\n{\n    vec4  q2 = q*q;\n    return vec4(q.x  *(    q2.x - 3.0*q2.y - 3.0*q2.z - 3.0*q2.w), \n                q.yzw*(3.0*q2.x -     q2.y -     q2.z -     q2.w));\n}\nfloat qLength2( in vec4 q ) { return dot(q,q); }\n\/\/--------------------------------------------------------------------------------\n\/\/ ray-sphere intersection\n\/\/ https:\/\/iquilezles.org\/articles\/intersectors\n\/\/--------------------------------------------------------------------------------\nvec2 iSphere( in vec3 ro, in vec3 rd, in float rad )\n{\n\tfloat b = dot( ro, rd );\n\tfloat c = dot( ro, ro ) - rad*rad;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n    h = sqrt(h);\n\treturn vec2(-b-h, -b+h );\n}\n\/\/--------------------------------------------------------------------------------\n\/\/ build camera rotation matrix\n\/\/--------------------------------------------------------------------------------\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\/\/--------------------------------------------------------------------------------\n\/\/ SDF of the Julia set z\u00b3+c\n\/\/ https:\/\/iquilezles.org\/articles\/distancefractals\n\/\/--------------------------------------------------------------------------------\nvec2 map( in vec3 p )\n{\n    vec4 z = vec4( p, 0.0 );\n    float dz2 = 1.0;\n\tfloat m2  = 0.0;\n    float n   = 0.0;\n    #ifdef TRAPS\n    float o   = 1e10;\n    #endif\n    \n    for( int i=0; i<kNumIte; i++ ) \n\t{\n        \/\/ z' = 3z\u00b2 -> |z'|\u00b2 = 9|z\u00b2|\u00b2\n\t\tdz2 *= 9.0*qLength2(qSquare(z));\n        \n        \/\/ z = z\u00b3 + c\t\t\n\t\tz = qCube( z ) + kC;\n        \n        \/\/ stop under divergence\t\t\n        m2 = qLength2(z);\t\t\n\n        \/\/ orbit trapping : https:\/\/iquilezles.org\/articles\/orbittraps3d\n        #ifdef TRAPS\n        o = min( o, length(z.xz-vec2(0.45,0.55))-0.1 );\n        #endif\n        \n        \/\/ exit condition\n        if( m2>256.0 ) break;\t\t\t\t \n\t\tn += 1.0;\n\t}\n   \n\t\/\/ sdf(z) = log|z|\u00b7|z|\/|dz| : https:\/\/iquilezles.org\/articles\/distancefractals\n\tfloat d = 0.25*log(m2)*sqrt(m2\/dz2);\n    \n    #ifdef TRAPS\n    d = min(o,d);\n    #endif\n    #ifdef CUT\n    d = max(d, p.y);\n    #endif\n    \n\treturn vec2(d,n);        \n}\n\n\/\/--------------------------------------------------------------------------------\n\/\/ Compute Normal to SDF\n\/\/--------------------------------------------------------------------------------\n\n#if 1\n\/\/ https:\/\/iquilezles.org\/articles\/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    const vec2 e = vec2(1.0,-1.0)*0.5773*kPrecis;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n#else\n\/\/ https:\/\/iquilezles.org\/articles\/juliasets3d\nvec3 calcNormal( in vec3 p )\n{\n    #ifdef TRAPS\n    the code below only works for the actual Julia set, not the traps\n    #endif\n        \n    vec4 z = vec4(p,0.0);\n\n    \/\/ identity derivative\n    mat4x4 J = mat4x4(1,0,0,0,  \n                      0,1,0,0,  \n                      0,0,1,0,  \n                      0,0,0,1 );\n\n  \tfor(int i=0; i<kNumIte; i++)\n    {\n        \/\/ f(q) = q\u00b3 + c = \n        \/\/   x =  x\u00b2x - 3y\u00b2x - 3z\u00b2x - 3w\u00b2x + c.x\n        \/\/   y = 3x\u00b2y -  y\u00b2y -  z\u00b2y -  w\u00b2y + c.y\n        \/\/   z = 3x\u00b2z -  y\u00b2z -  z\u00b2z -  w\u00b2z + c.z\n        \/\/   w = 3x\u00b2w -  y\u00b2w -  z\u00b2w -  w\u00b2w + c.w\n\t\t\/\/\n        \/\/ Jacobian, J(f(q)) =\n        \/\/   3(x\u00b2-y\u00b2-z\u00b2-w\u00b2)  6xy            6xz            6xw\n        \/\/    -6xy           3x\u00b2-3y\u00b2-z\u00b2-w\u00b2 -2yz           -2yw\n        \/\/    -6xz          -2yz            3x2-y\u00b2-3z\u00b2-w\u00b2 -2zw\n        \/\/    -6xw          -2yw           -2zw            3x\u00b2-y\u00b2-z\u00b2-3w\u00b2\n        \n        float k1 = 6.0*z.x*z.y, k2 = 6.0*z.x*z.z;\n        float k3 = 6.0*z.x*z.w, k4 = 2.0*z.y*z.z;\n        float k5 = 2.0*z.y*z.w, k6 = 2.0*z.z*z.w;\n        float sx = z.x*z.x, sy = z.y*z.y;\n        float sz = z.z*z.z, sw = z.w*z.w;\n        float mx = 3.0*sx-3.0*sy-3.0*sz-3.0*sw;\n        float my = 3.0*sx-3.0*sy-    sz-    sw;\n        float mz = 3.0*sx-    sy-3.0*sz-    sw;\n        float mw = 3.0*sx-    sy-    sz-3.0*sw;\n        \n        \/\/ chain rule of jacobians\n        J = J*mat4x4( mx, -k1, -k2, -k3,\n                      k1,  my, -k4, -k5,\n                      k2, -k4,  mz, -k6,\n                      k3, -k5, -k6,  mw );\n        \/\/ q = q\u00b3 + c\n        z = qCube(z) + kC; \n        \n        \/\/ exit condition\n        if(dot2(z)>256.0) break;\n    }\n\n    return (p.y>0.0 ) ? vec3(0.0,1.0,0.0) : normalize( (J*z).xyz );\n}\n#endif\n\n\/\/--------------------------------------------------------------------------------\n\/\/ ray-scene intersection\n\/\/--------------------------------------------------------------------------------\nvec2 raycast( in vec3 ro, in vec3 rd )\n{\n    float tmax = 7.0;\n\tfloat tmin = kPrecis;    \n\n    \/\/ intersect clipping plane\n    #ifdef CUT\n    const float kSplit = 0.01;\n    float tpS = (kSplit-ro.y)\/rd.y;\n    if( tpS>0.0 )\n    {\n        if( ro.y>kSplit ) tmin = max(tmin,tpS);\n        else              tmax = min(tmax,tpS);\n    }\n\t#endif\n    \n    \/\/ intersect lower clipping plane\n    #if 1\n    {\n    float tpF = (-0.8-ro.y)\/rd.y;\n    if( tpF>0.0 ) tmax = min(tmax,tpF);\n    }\n    #endif\n\n    \/\/ intersect bounding sphere\n    #if 1\n    vec2 bv = iSphere( ro, rd, kBSRad );\n    if( bv.y<0.0 ) return vec2(-2.0,0.0);\n    tmin = max(tmin,bv.x);\n    tmax = min(tmax,bv.y);\n\t#endif\n    \n    \/\/ raymarch\n    vec2  res = vec2(-1.0);\n    float t = tmin;\n\tfloat lt = 0.0;\n\tfloat lh = 0.0;\n    for(int i=0; i<1024; i++ )\n    {\n        res = map(ro+rd*t);\n        if( res.x<kPrecis ) break;\n\t\tlt = t;\n\t\tlh = res.x;\n        #ifndef TRAPS\n        t += min(res.x,0.2);\n        #else\n        t += min(res.x,0.01)*(0.5+0.5*frand());\n        #endif\n        if( t>tmax ) break;\n    }\n    \/\/ linear interpolation for better isosurface\n\tif( lt>0.0001 && res.x<0.0 ) t = lt - lh*(t-lt)\/(res.x-lh);\n\t\n    res.x = (t<tmax)?t:-1.0;\n\n    return res;\n}\n\n\/\/--------------------------------------------------------------------------------\n\/\/ color of the surface\n\/\/--------------------------------------------------------------------------------\nvec3 colorSurface( in vec3 pos, in vec3 nor, in vec2 tn )\n{\n    vec3 col = 0.5+0.5*cos(log2(tn.y)*0.9+3.5+vec3(0.0,0.6,1.0));\n    if( pos.y>0.0 ) col = mix(col,vec3(1.0),0.2);\n    float inside = smoothstep(14.0,15.0,tn.y);\n    col *= vec3(0.45,0.42,0.40) + vec3(0.55,0.58,0.60)*inside;\n    col = mix(col*col*(3.0-2.0*col),col,inside);\n    col = mix( mix(col,vec3(dot(col,vec3(0.3333))),-0.4),\n                        col, inside);\n    return clamp(col*0.65,0.0,1.0);\n}\n\n\/\/--------------------------------------------------------------------------------\n\/\/ Render the scene through super simplified path-tracing\n\/\/--------------------------------------------------------------------------------\nvec3 render( in  vec2 fragCoord, in vec3 ro, in vec3 rd,\n             out vec3 resPos, out float resT)\n{\n    vec3 colorMask = vec3(1.0);\n \tresT = 1e20;\n    \n    \/\/ path-tracing\n    for( int bounce=0; bounce<kNumBounces; bounce++ )\n    {\n        vec2 tn = raycast( ro, rd );\n        float t = tn.x;\n        if( t < 0.0 )\n        {\n            return (bounce>0) ? colorMask*1.65*step(0.0,rd.y) \n                              : vec3(clamp(0.02+0.021*rd.y,0.0,1.0));\n        }\n        else\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal( pos );\n\n            if( bounce==0 ) { resT = t; resPos = pos; }\n\n\t\t\tcolorMask *= colorSurface( pos, nor, tn );\n            rd = cosineDirection(nor);\n        \tro = pos+nor*kPrecis;\n        }\n   }\n   \n   return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/-----------------------------------------------\n\t\/\/ init random seed\n    \/\/-----------------------------------------------\n    ivec2 q = ivec2(fragCoord);\n    srand( q, iFrame );\n    \n    \/\/-----------------------------------------------\n    \/\/ camera\n    \/\/-----------------------------------------------\n    float an = 0.5+iTime*0.03;\n    vec3  ro = 2.0*vec3(sin(an),0.8,cos(an));\n    #ifdef CUT\n    vec3  ta = vec3( 0.0, -0.3, 0.0 );\n    #else\n    vec3  ta = vec3( 0.0, -0.1, 0.0 );\n\t#endif\n    mat3x3 cam = setCamera(ro,ta,0.0);\n    \n    \/\/-----------------------------------------------\n    \/\/ ray direction\n    \/\/-----------------------------------------------\n    vec2 p = (2.0*fragCoord-iResolution.xy)\/iResolution.y;\n    vec3 rd = normalize( cam*vec3(p.xy,kFocLen) );\n    \n    \/\/-----------------------------------------------\n    \/\/ render fractal\n    \/\/-----------------------------------------------\n    vec3 pos; float resT;\n    vec3 col = render(fragCoord,ro,rd,pos,resT);\n\n    \/\/-----------------------------------------------\n\t\/\/ reproject to previous frame and pull history\n    \/\/-----------------------------------------------\n\n    \/\/ fetch previous camera matrix from the bottom left three pixels\n    mat3x4 oldCam = mat3x4( texelFetch(iChannel0,ivec2(0,0), 0),\n                            texelFetch(iChannel0,ivec2(1,0), 0),\n                            texelFetch(iChannel0,ivec2(2,0), 0) );\n    \/\/ world space point\n    vec4 wpos = vec4(pos,1.0);\n    \/\/ convert to camera space (note inverse multiply)\n    vec3 cpos = wpos*oldCam;\n    \/\/ convert to NDC space (project)\n    vec2 npos = kFocLen*cpos.xy\/cpos.z;\n    \/\/ convert to screen space\n    vec2 spos = 0.5 + 0.5*npos*vec2(iResolution.y\/iResolution.x,1.0);\n\t\/\/ convert to raster space\n    vec2 rpos = spos * iResolution.xy;\n\n    \/\/ read color+depth from this point's previous screen location\n    vec4 ocolt = textureLod( iChannel0, spos, 0.0 );\n    \/\/ if we consider the data contains the history for this point\n    if( iFrame>0 && resT<100.0 && (rpos.y>1.5||rpos.x>3.5) )\n    {\n        \/\/ blend with history (it's a IIR low pas filter really)\n        col = mix( ocolt.xyz, col, 0.06 );\n    }\n    \/\/ output\n\tif( q.y==0 && q.x<3 )\n    {\n    \t\/\/ camera matrix in lower left three pixels, for next frame\n             if( q.x==0 ) fragColor = vec4( cam[0], -dot(cam[0],ro) );\n        else if( q.x==1 ) fragColor = vec4( cam[1], -dot(cam[1],ro) );\n        else              fragColor = vec4( cam[2], -dot(cam[2],ro) );\n    }\n    else\n    {\n        \/\/ color and depth\n        fragColor = vec4( col, resT );\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"MstXWS","date":"1461313640","viewed":7559,"name":"Raymarched reaction-diffusion","username":"emh","description":"Ray-marched sphere with reaction diffusion as displacement. Based on https:\/\/www.shadertoy.com\/view\/XsG3z1, original at https:\/\/www.shadertoy.com\/view\/4dcGW2 . Mouse to rotate ball.","likes":129,"published":3,"flags":32,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Created by Eivind Magnus Hvidevold emnh\/2016.\n\/\/ Reaction-diffusion by Flexi.\n\/\/ Raymarching by inigo quilez - iq\/2013.\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n\/\/----------------------------------------------------------------------\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 \/ 3.0, 1.0 \/ 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nvec2 map(in vec3 pos) {    \n    vec3 o = pos;\n    \n    pos = pos - vec3(0.0, -1.5, 0.0);\n    vec2 mo = iMouse.xy\/iResolution.xy;\n    float ms = 3.14 * 2.0;\n    mat4 mrx = rotationMatrix(vec3(1.0, 0.0, 0.0), mo.y * ms);\n    mat4 mry = rotationMatrix(vec3(0.0, 1.0, 0.0), mo.x * ms);\n    mat4 mrt = rotationMatrix(vec3(0.0, 1.0, 0.0), sin(iTime \/ 10.0));\n    \n    pos = (vec4(pos, 1.0) * mrx * mry * mrt).xyz;\n    \n    \/\/ uv mapping\n    vec3 p = normalize(pos);\n    vec2 uv = vec2(0.0);\n    uv.x = 0.5 + atan(p.z, p.x) \/ (2.*3.14159);\n    uv.y = 0.5 - asin(p.y) \/ 3.14159;\n    \n    float y = texture(iChannel0, uv).y;\n    float y2 = 0.1 * y;\n    \n    float ss = 5.0;\n    vec3 sphereO = pos; \/\/ - vec3(0.0, 0.25, 1.0);\n    \n    float sd = 0.0;\n\tsd = sdSphere(sphereO \/ ss, 0.4 + y2) * ss;\n    \n    return vec2(sd, iTime \/ 10.0 + y); \/\/sd + iTime \/ 10.0);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n#if 0\n    float tp1 = (0.0-ro.y)\/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)\/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n\tfloat precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h\/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)\/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        \/\/ material        \n\t\t\/* col = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        \n\t\t\n        if( m<1.5 )\n        {\n            \n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            col = 0.4 + 0.1*f*vec3(1.0);\n        }*\/\n\t\tcol = hsv2rgb(vec3(m, 1.0, 1.0));\n\n        \/\/ lighting        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.20*dif*vec3(1.00,0.85,0.55);\n\t\tlin += 1.20*spe*vec3(1.00,0.85,0.55)*dif;\n        lin += 0.20*amb*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*dom*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.002*t*t ) );\n\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy\/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x\/iResolution.y;\n    vec2 mo = iMouse.xy\/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n\n\t\/\/ camera\t\n\t\/\/ vec3 ro = vec3( -0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 3.5*sin(0.1*time + 6.0*mo.x) );\n    \/\/vec3 ro = vec3( -0.5+3.5*cos(6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 3.5*sin(6.0*mo.x) );\n    vec3 ro = vec3( 3.5, 1.0, 3.5 );\n\tvec3 ta = vec3( -0.5, -2.0, -1.0 );\n\t\n\t\/\/ camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    \/\/ ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    \/\/ render\t\n    vec3 col = render( ro, rd );\n\n\tcol = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ Reaction-diffusion pass.\n\/\/\n\/\/ Here's a really short, non technical explanation:\n\/\/\n\/\/ To begin, sprinkle the buffer with some initial noise on the first few frames (Sometimes, the \n\/\/ first frame gets skipped, so you do a few more).\n\/\/\n\/\/ During the buffer loop pass, determine the reaction diffusion value using a combination of the \n\/\/ value stored in the buffer's \"X\" channel, and a the blurred value - stored in the \"Y\" channel \n\/\/ (You can see how that's done in the code below). Blur the value from the \"X\" channel (the old \n\/\/ reaction diffusion value) and store it in \"Y\", then store the new (reaction diffusion) value \n\/\/ in \"X.\" Display either the \"X\" value  or \"Y\" buffer value in the \"Image\" tab, add some window \n\/\/ dressing, then repeat the process. Simple... Slightly confusing when I try to explain it, but \n\/\/ trust me, it's simple. :)\n\/\/\n\/\/ Anyway, for a more sophisticated explanation, here are a couple of references below:\n\/\/\n\/\/ Reaction-Diffusion by the Gray-Scott Model - http:\/\/www.karlsims.com\/rd.html\n\/\/ Reaction-Diffusion Tutorial - http:\/\/www.karlsims.com\/rd.html\n\n\/\/ Cheap vec3 to vec3 hash. Works well enough, but there are other ways.\nvec3 hash33(in vec2 p){ \n    float n = sin(dot(p, vec2(41, 289)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\n\/\/ Serves no other purpose than to save having to write this out all the time. I could write a \n\/\/ \"define,\" but I'm pretty sure this'll be inlined.\nvec4 tx(in vec2 p){ return texture(iChannel0, p); }\n\n\/\/ Weighted blur function. Pretty standard.\nfloat blur(in vec2 p){\n    \n    \/\/ Used to move to adjoining pixels. - uv + vec2(-1, 1)*px, uv + vec2(1, 0)*px, etc.\n    vec3 e = vec3(1, 0, -1);\n    vec2 px = 1.\/iResolution.xy;\n    \n    \/\/ Weighted 3x3 blur, or a cheap and nasty Gaussian blur approximation.\n\tfloat res = 0.0;\n    \/\/ Four corners. Those receive the least weight.\n\tres += tx(p + e.xx*px ).x + tx(p + e.xz*px ).x + tx(p + e.zx*px ).x + tx(p + e.zz*px ).x;\n    \/\/ Four sides, which are given a little more weight.\n    res += (tx(p + e.xy*px ).x + tx(p + e.yx*px ).x + tx(p + e.yz*px ).x + tx(p + e.zy*px ).x)*2.;\n\t\/\/ The center pixel, which we're giving the most weight to, as you'd expect.\n\tres += tx(p + e.yy*px ).x*4.;\n    \/\/ Normalizing.\n    return res\/16.;     \n    \n}\n\n\/\/ The reaction diffusion loop.\n\/\/ \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n\tvec2 uv = fragCoord\/iResolution.xy; \/\/ Screen coordinates. Range: [0, 1]\n    vec2 pw = 1.\/iResolution.xy; \/\/ Relative pixel width. Used for neighboring pixels, etc.\n    \n    \n    \/\/ The blurred pixel. This is the result that's used in the \"Image\" tab. It's also reused\n    \/\/ in the next frame in the reaction diffusion process (see below).\n\tfloat avgReactDiff = blur(uv);\n\n    \n\t\/\/ The noise value. Because the result is blurred, we can get away with plain old static noise.\n    \/\/ However, smooth noise, and various kinds of noise textures will work, too.\n    vec3 noise = hash33(uv + vec2(53, 43)*iTime)*.6 + .2;\n\n    \/\/ Used to move to adjoining pixels. - uv + vec2(-1, 1)*px, uv + vec2(1, 0)*px, etc.\n    vec3 e = vec3(1, 0, -1);\n    \n    \/\/ Gradient epsilon value. The \"1.5\" figure was trial and error, but was based on the 3x3 blur radius.\n    vec2 pwr = pw*1.5; \n    \n    \/\/ Use the blurred pixels (stored in the Y-Channel) to obtain the gradient. I haven't put too much \n    \/\/ thought into this, but the gradient of a pixel on a blurred pixel grid (average neighbors), would \n    \/\/ be analogous to a Laplacian operator on a 2D discreet grid. Laplacians tend to be used to describe \n    \/\/ chemical flow, so... Sounds good, anyway. :)\n    \/\/\n    \/\/ Seriously, though, take a look at the formula for the reacion-diffusion process, and you'll see\n    \/\/ that the following few lines are simply putting it into effect.\n    \n    \/\/ Gradient of the blurred pixels from the previous frame.\n\tvec2 lap = vec2(tx(uv + e.xy*pwr).y - tx(uv - e.xy*pwr).y, tx(uv + e.yx*pwr).y - tx(uv - e.yx*pwr).y);\/\/\n    \n    \/\/ Add some diffusive expansion, scaled down to the order of a pixel width.\n    uv = uv + lap*pw*3.0; \n    \n    \/\/ Stochastic decay. Ie: A differention equation, influenced by noise.\n    \/\/ You need the decay, otherwise things would keep increasing, which in this case means a white screen.\n    float newReactDiff = tx(uv).x + (noise.z - 0.5)*0.0025 - 0.002; \n    \n    \/\/ Reaction-diffusion.\n\tnewReactDiff += dot(tx(uv + (noise.xy-0.5)*pw).xy, vec2(1, -1))*0.145; \n\n    \n    \/\/ Storing the reaction diffusion value in the X channel, and avgReactDiff (the blurred pixel value) \n    \/\/ in the Y channel. However, for the first few frames, we add some noise. Normally, one frame would \n    \/\/ be enough, but for some weird reason, it doesn't always get stored on the very first frame.\n    if(iFrame>9) fragColor.xy = clamp(vec2(newReactDiff, avgReactDiff\/.98), 0., 1.);\n    else fragColor = vec4(noise, 1.);\n    \n}","name":"Buf A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"lsVSRt","date":"1488834249","viewed":4318,"name":"80's raymarching","username":"villedieumorgan","description":"First iteration, wanted to learn some more about raymarching.\nA car and some obstacle could be added in the future.\n\n","likes":128,"published":1,"flags":32,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define RGBSHIFT true\n#define OLDSCREENLINES\n#define NUMBER_LINES 269.\n\n\/* \nMADE BY MORGAN VILLEDIEU\nTW : https:\/\/twitter.com\/VilledieuMorgan\nClick and drag to rotate the camera\n*\/\n\nvec4 rgbShift( in vec2 p , in vec4 shift) {\n    shift *= 1.02*shift.w - 1.0;\n    vec2 rs = vec2(shift.x,-shift.y);\n    vec2 gs = vec2(shift.y,-shift.z);\n    vec2 bs = vec2(shift.z,-shift.x);\n    \n    float r = texture(iChannel0, p+rs\/2., 0.0).x;\n    float g = texture(iChannel0, p+gs\/2., 0.0).y;\n    float b = texture(iChannel0, p+bs\/2., 0.0).z;\n    \n    return vec4(r,g,b,1.0);\n}\n\nfloat rand(vec2 co) { \n    return fract(sin(dot(co.xy ,vec2(12.98,78.23))) * 43758.54);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float numberLines = 269.;\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    vec3 oldScreenLines = vec3(sin(uv.y*NUMBER_LINES+sin(iTime)*20.));\n    \n    #ifdef RGBSHIFT\n\t\tvec3 col = mix(rgbShift(uv, vec4(0.015, 0.0, 0.015, 0.0)).xyz, oldScreenLines, 0.01) ;\n    #else\n    \tvec3 col = texture(iChannel0, uv).rgb;\n    #endif\n    \n    col -= .028*rand( uv.xy * iTime);\n    fragColor = vec4(col*2.5, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGzn","filepath":"\/media\/a\/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"\/media\/ap\/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"\/media\/a\/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"\/media\/ap\/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"\/media\/a\/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"\/media\/ap\/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/* \nMADE BY MORGAN VILLEDIEU\nTW : https:\/\/twitter.com\/VilledieuMorgan\nClick and drag to rotate the camera\n*\/\n\n\/\/Raymarch settings\n\n#define MAX_MOVEMENT_SPEED 0.9\n#define MIN_RADIUS 0.01\n#define MAX_RADIUS 0.3\n#define STAR_COUNT 30\n#define PI 3.14159265358979323\n#define TWOPI 6.283185307\n\n#define EPSILON 0.1\n\n#define RADIUS_SEED 1337.0\n#define START_POS_SEED 2468.0\n#define THETA_SEED 1675.0\n\n#define MIN_DIST 0.001\n#define MAX_DIST 32.0\n#define MAX_STEPS 96\n#define STEP_MULT 0.9\n#define NORMAL_OFFS 0.01\n#define FOCAL_LENGTH 0.9\n\n\/\/Scene settings\n\n\/\/#define SHOW_RAY_COST\n\n\/\/Colors\n#define SKY_COLOR_1 vec3(49., 33., 66.)\/255.\n#define SKY_COLOR_2 vec3(0.00,0.05,0.20)\n\n#define SUN_COLOR_2 vec3(87., 33., 73.)\/255.\n#define SUN_COLOR_1 vec3(1.00, 0.20, 0.60)\/2.\n\n#define GRID_COLOR_1 vec3(0.00, 0.05, 0.20)\n#define GRID_COLOR_2 vec3(26.00, 14.0, 122.0)\/255.\n#define FOG_COLOR vec3(193.00, 24.0, 123.0)\/255.\n\n\/\/Parameters\n#define GRID_SIZE 0.50\n#define GRID_LINE_SIZE 1.25\n\n#define SUN_DIRECTION vec3( 0.10,0.0,0.)\n\n#define CLOUD_SCROLL vec2(0.002, 0.001)\n#define CLOUD_BLUR 2.0\n#define CLOUD_SCALE vec2(0.04, 0.10)\n\n#define MOUNTAIN_SCALE 6.0\n#define MOUNTAIN_SHIFT 5.3\n\n#define SPEED 11.\n\nconst vec3 starColor = vec3(1.0, 1.0, 1.0);\n\n\/\/Color modes\n\/\/vec3(#,#,#) Number of bits per channel\n\n\/\/24 bit color\n#define RGB888 vec3(8,8,8)\n\/\/16 bit color\n#define RGB565 vec3(5,6,5)\n#define RGB664 vec3(6,6,4)\n\/\/8 bit color\n#define RGB332 vec3(3,3,2)\n#define RGB242 vec3(2,4,2)\n#define RGB222 vec3(2,2,2) \/\/+2 unused\n\n\/\/#define DITHER_ENABLE\n#define COLOR_MODE RGB242\n\n\/\/Object IDs\n#define SKYDOME 0.\n#define FLOOR 1.\n#define OCTAGON 3.\n\nfloat pi = atan(1.0) * 4.0;\nfloat tau = atan(1.0) * 8.0;\n\nfloat normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x\/(sigma*sigma))\/sigma;\n}\n\nvec3 dither(vec3 color, vec3 bits, vec2 pixel)\n{\n    vec3 cmax = exp2(bits)-1.0;\n    \n    vec3 dithfactor = mod(color, 1.0 \/ cmax) * cmax;\n    float dithlevel = texture(iChannel0,pixel \/ iChannelResolution[2].xy).r;\n    \n    vec3 cl = floor(color * cmax)\/cmax;\n    vec3 ch = ceil(color * cmax)\/cmax;\n    \n    return mix(cl, ch, step(dithlevel, dithfactor));\n}\n\nstruct MC\n{\n    vec3 position;\n    vec3 normal;\n    float dist;\n    float steps;\n    float id;\n};\n\n\/\/Returns a rotation matrix for the given angles around the X,Y,Z axes.\nmat3 Rotate(vec3 angles)\n{\n    vec3 c = cos(angles);\n    vec3 s = sin(angles);\n    \n    mat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0,c.x,s.x, 0.0,-s.x, c.x);\n    mat3 rotY = mat3( c.y, 0.0,-s.y, 0.0,1.0,0.0, s.y, 0.0, c.y);\n    mat3 rotZ = mat3( c.z, s.z, 0.0,-s.z,c.z,0.0, 0.0, 0.0, 1.0);\n\n    return rotX * rotY * rotZ;\n}\n\n\/\/==== Distance field operators\/functions by iq. ====\nvec2 opU(vec2 d1, vec2 d2)\n{\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\nvec2 opS(vec2 d1, vec2 d2)\n{\n    return (-d1.x > d2.x) ? d1*vec2(-1,1) : d2;\n}\n\n\nvec2 sdBox(vec3 pos, vec3 size, float id)\n{\n    return vec2(length(max(abs(pos) - size, 0.0)), id);\n}\n\nvec2 sdOct( vec3 p, float r, float id )\n{\n\tvec2 s = vec2(1,-1)\/sqrt(1.0);\n\treturn vec2(max(max(max(\n\t\t\tabs(dot(p,s.xxx)),abs(dot(p,s.yyx))),\n\t\t\tabs(dot(p,s.yxy))),abs(dot(p,s.xyy))) - r*mix(1.0,1.0\/sqrt(3.0),.5), id);\n}\n\nvec2 sdSphere(vec3 p, float s, float id)\n{\n  return vec2(length(p) - s, id);\n}\n\n\nfloat displace(vec3 p) {\n\tfloat height = 10.;\n\treturn ((cos(1.*p.y+0.5)*clamp(sin(1.1*p.x), 0.5, 1.)*sin(0.+2.4)*height*clamp(texture(iChannel0, p.xy\/10.).r*0.4, 0.0, 0.5)));\n}\n\n\/\/float displace(vec3 p) {\n\/\/return ((cos(1.*p.x)*sin(1.1*p.y)\/2.*sin(4.*p.z+1.)))*texture(iChannel2, p.xy\/10.).r+0.1;\n\/\/}\n\n\n\nvec2 sdPlane(vec3 p, vec4 n, float id)\n{\n  \/\/ n must be normalized\n  return vec2(dot(vec3(p.x,p.y, max(p.z + displace(vec3(p.x, p.y-10., p.z)), p.z)), vec3(n.x, n.y, n.z)) + n.y, id);\n}\n\nvec2 sdColumn(vec3 p, float r, float id)\n{\n    return vec2(((abs(p.x)+abs(p.y))-r)\/sqrt(2.0), id);\n}\n\n\/\/Distance to the scene\nvec2 Scene(vec3 p)\n{\n    vec2 d = vec2(MAX_DIST, SKYDOME);\n    \/\/d = opU(opU(sdPlane(p, vec4(0, 0,-1, 0), FLOOR), d), \n    \/\/        opU(sdPlane(p, vec4(0, 0.5,-1, 0), FLOOR), d)) ;\n    \n    d = opU(sdPlane(p, vec4(0, 0,-1, 0), FLOOR), d);\n    \/\/d = opU(sdBox(vec3(p.x-25.1, p.y, p.z-15.4), vec3(5.5, 0.5,15.5), OCTAGON), d);\n\t\/\/d = opU(sdBox(vec3(p.x-10.1, p.y-2., p.z-10.4), vec3(5.5, 0.5,15.5), OCTAGON), d);    \n    \/\/d = opU(sdOct(vec3(p.x-30.1, p.y, p.z+0.2*2.), 0.5, OCTAGON), d);    \n    \n\treturn d;\n}\n\n\/\/Surface normal at the current position\nvec3 Normal(vec3 p)\n{\n    vec3 off = vec3(NORMAL_OFFS, 0, 0);\n    return normalize\n    ( \n        vec3\n        (\n            Scene(p + off.xyz).x - Scene(p - off.xyz).x,\n            Scene(p + off.zxy).x - Scene(p - off.zxy).x,\n            Scene(p + off.yzx).x - Scene(p - off.yzx).x\n        )\n    );\n}\n\n\/\/Raymarch the scene with the given ray\nMC MR(vec3 orig,vec3 dir)\n{\n    float steps = 0.0;\n    float dist = 0.0;\n    float id = 0.0;\n    \n    for(int i = 0;i < MAX_STEPS;i++)\n    {\n        vec2 object = Scene(orig + dir * dist);\n        \n        \/\/Add the sky dome and have it follow the camera.\n        object = opU(object, -sdSphere(dir * dist, MAX_DIST, SKYDOME));\n        \n        dist += object.x * STEP_MULT;\n        \n        id = object.y;\n        \n        steps++;\n        \n        if(abs(object.x) < MIN_DIST * dist)\n        {\n            break;\n        }\n    }\n    \n    MC result;\n    \n    result.position = orig + dir * dist;\n    result.normal = Normal(result.position);\n    result.dist = dist;\n    result.steps = steps;\n    result.id = id;\n    \n    return result;\n}\n\n\/\/Scene texturing\/shading\nvec3 Shade(MC hit, vec3 direction, vec3 camera)\n{\n    vec3 color = vec3(0.0);\n    vec3 rd = color;\n    vec3 skydomeColor = color;\n    \n    if(hit.id == SKYDOME)\n    {\n \n        \/\/vec2 v = fwidth(hit.position.xy);\n        \/\/vec4 soundNoise = texture(iChannel3, v);\n        \n        \/\/Sky gradient\n    \tcolor = mix(SKY_COLOR_1*1.4, SKY_COLOR_2, -hit.position.z\/7.0);\n        \/\/nice\n        \/\/color = mix(SKY_COLOR_1, SKY_COLOR_2, hit.position.z\/9.0);\n        \n        \/\/Sun\n        vec3 sunDir = normalize(SUN_DIRECTION);\n        \n        float sun = smoothstep(0.9430, 0.975, dot(direction, sunDir));\n        sun -= smoothstep(0.1, 0.9, 0.5);\n        vec3 sunCol = mix(SUN_COLOR_1, SUN_COLOR_2*1.2, hit.position.z\/2.5);\n        \n        color = mix(color, sunCol, sun) + texture(iChannel2, vec2(2.) * 0.1).rgb * 0.07;\n    }\n    \n    \/\/if(hit.id == OCTAGON)\n    \/\/{\n    \/\/    color = texture(iChannel1, hit.position.xy).rgb *0.5;\n    \/\/}\n    \n\n    if(hit.id == FLOOR)\n    {\n        vec2 uv = abs(mod(hit.position.xy + GRID_SIZE\/2.0, GRID_SIZE) - GRID_SIZE\/2.0); \n        \n        uv \/= fwidth(hit.position.xy);\n                                                       \n        float gln = min(min(uv.x, uv.y), 1.) \/ GRID_SIZE;\n    \tcolor = mix(GRID_COLOR_1, GRID_COLOR_2, 0.7 - smoothstep(0.0, GRID_LINE_SIZE \/ GRID_SIZE, gln));\n        \n        \/\/ darker on the sides\n        vec3 normal = vec3(0.,-0.5,0.);\n        vec3 rfld = reflect( direction, normal );\n        float reflectstrength = 1.-abs(dot( direction, normal ));\n        color *= reflectstrength;\n\n    } \n    \n    \/\/Distance fog\n    color += mix(GRID_COLOR_2, FOG_COLOR, pow(hit.dist, 1.01) )\/70.;\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy \/ iResolution.y;\n    float aspect = iResolution.x \/ iResolution.y;\n\tvec2 uv = fragCoord.xy \/ iResolution.y;\n    \n    \/\/Camera stuff   \n    vec3 angles = vec3(0);\n    \n    \/\/Auto mode\n    if(iMouse.xy == vec2(0,0))\n    {\n        angles.y = tau * (1.8 \/ 8.0);\n        angles.x = tau * (1.8 \/ 8.0) * 1.1;\n    }\n    else\n    {    \n    \tangles = vec3((iMouse.xy \/ iResolution.xy) * pi, 0);\n        angles.xy *= vec2(1.0, 1.0);\n    }\n    \n    angles.y = clamp(angles.y, 0.0, 15.5 * tau \/ 64.0);\n    \n    mat3 rotate = Rotate(angles.yzx);\n    \n    vec3 orig = vec3(0, 1., 0.) * rotate;\n    \n    vec3 dir = normalize(vec3(uv - res \/ 2.0, FOCAL_LENGTH)) * rotate;\n    \n    orig.z += 0.25;\n    \/\/orig.y = sin(iTime)*10.5;\n    orig.x += iTime*SPEED;\n   \n    \/\/Ray marching\n    MC hit = MR(orig, dir);\n    \n    \/\/Shading\n    vec3 color = Shade(hit, dir, orig );\n     \n    #ifdef SHOW_RAY_COST\n    color = mix(vec3(0,1,0), vec3(1,0,0), hit.steps \/ float(MAX_STEPS));\n    #endif\n\n    #ifdef DITHER_ENABLE\n    color = dither(color, COLOR_MODE, fragCoord);\n    #endif\n    \n    \/\/particles\n \n    vec2 position = ( fragCoord.xy - iResolution.xy * 0.5  ) \/ iResolution.x;\n    float angle = atan(dir.y,dir.z)\/(atan(iTime)-1.*1.*PI);\n    angle -= floor(angle);\n    float rad = length(vec2(dir.x * 0.02, dir.z));\n\n    float angleFract = fract(angle*10.5);\n    float angleRnd = floor(angle*180.);\n    float angleRnd1 = fract(angleRnd*fract(angleRnd*.72035)*1.1);\n    float angleRnd2 = fract(angleRnd*fract(angleRnd*.82657)*1.724);\n    float t = iTime*20.+angleRnd1*1000.;\n    float radDist = sqrt(angleRnd2+float(1));\n    float adist = radDist\/rad*.1;\n    float dist = (t*.2+adist);\n    dist = abs(fract(dist\/20.)-.5);\n    \n    \/\/draw only the particles at the top \n    if(dir.z < 0.0 ){ \n    \tcolor += 0.6 * max(0.0,.7-dist*100.\/adist)*(0.5-abs(angleFract-.5))*1.\/adist\/radDist;\n    }else{\n        color += vec3(0.0,0.,0.2)* vec3(max(0.0,.7-dist*100.\/adist)*(0.5-abs(angleFract-.5))*1.\/adist\/radDist);\n    }\n   \n\tfragColor = vec4(color, 1.0);\n    \n}","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"lsV3zV","date":"1460529301","viewed":5022,"name":"Veach 1997 Fig 9.4","username":"mplanck","description":"A playpen for understanding Veach's ground breaking paper on multiple importance sampling: https:\/\/graphics.stanford.edu\/papers\/veach_thesis\/ with PBRT second edition as my bible. Use Keys 1,2,3,4 and Space","likes":122,"published":1,"flags":48,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Final gather \n\n\/\/ INPUTS\n\n\/\/ 1 := select brdf importance sampling only\n\/\/ 2 := select light importance sampling only\n\/\/ 3 := select multiple importance sampling\n\/\/ 4 := turn on green coloring of brdf importance samples, red coloring of light importance samples\n\/\/ SPACE := reset to no coloring and multiple importance sampling\n\n\/\/ **************************************************************************\n\/\/ GLOBALS\n\nfloat g_frame = 0.;\n\nvoid setup_globals()\n{\n    g_frame = float(iFrame) - texture(iChannel1, vec2(0., 0.), -100.).r ;\n}\n\n\/\/ **************************************************************************\n\/\/ MAIN COLOR\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    setup_globals();\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n        \n    vec3 scol = vec3(0.);\n    if (g_frame > .5)\n    {\n\t\tscol = texture( iChannel0, uv ).xyz;\n        scol \/= g_frame;\n        scol = pow( scol, vec3(0.4545) );\n    }\n    \n    fragColor = vec4(scol, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"\/presets\/tex00.jpg","previewfilepath":"\/presets\/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ Buffer A is used to store persistent state in one pixel\n\n\/\/ r = start frame\n\/\/ g = sampling type (brdf, light, multiple)\n\/\/ b = color samples? (green for brdf importance samples, red for light importance samples)\n\n\/\/ INPUTS\n\n\/\/ 1 := select brdf importance sampling only\n\/\/ 2 := select light importance sampling only\n\/\/ 3 := select multiple importance sampling\n\/\/ 4 := turn on green coloring of brdf importance samples, red coloring of light importance samples\n\/\/ SPACE := reset to no coloring and multiple importance sampling\n\n\/\/ **************************************************************************\n\/\/ CONSTANTS\n\nconst float KEY_SPACE = 32.5\/256.0;\nconst float KEY_ONE = 49.5\/256.0;\nconst float KEY_TWO = 50.5\/256.0;\nconst float KEY_THREE = 51.5\/256.0;\nconst float KEY_FOUR = 52.5\/256.0;\n\nconst float BRDF_IMPORTANCE_SAMPLING = 2.;\nconst float LIGHT_IMPORTANCE_SAMPLING = 1.;\nconst float MULTIPLE_IMPORTANCE_SAMPLING = 0.;\n\nbool this_pixel_is_being_rendered(vec2 fragCoord, vec2 r)\n{\n    return (step(r.y-.2, fragCoord.y) * step(fragCoord.y, r.y+1.2) * \n            step(r.x-.2, fragCoord.x) * step(fragCoord.x, r.x+1.2)) > .5;\n}\n\nbool this_pixel_is_in_the_range(vec2 fragCoord, vec2 r0, vec2 r1)\n{\n    return (step(r0.y-.2, fragCoord.y) * step(fragCoord.y, r1.y+1.2) * \n            step(r0.x-.2, fragCoord.x) * step(fragCoord.x, r1.x+1.2)) > .5;\n}\n\n\/\/ **************************************************************************\n\/\/ MAIN COLOR\n\nvec3 process_inputs(vec2 fragCoord)\n{\n    \n\tvec3 resultingColor = vec3(0.);\n    \n    vec3 storedState = texture(iChannel0, vec2(0., 0.), -100.).rgb;\n\n    float initialFrame = storedState.r;\n    float samplingType = storedState.g;\n    float colorSamples = storedState.b;\n\n    \/\/ space bar resets coloring and sampling to default\n    float pressSpace = texture( iChannel1, vec2(KEY_SPACE,0.25) ).x;\n    if (pressSpace > .5 || iFrame == 0) \n    { \n        initialFrame = float(iFrame);         \n        samplingType = MULTIPLE_IMPORTANCE_SAMPLING; \n        colorSamples = 0.;\n    }\t\n\n    \/\/ one enables brdf sampling only\n    float pressOne = texture( iChannel1, vec2(KEY_ONE,0.25) ).x;\n    if (pressOne > .5) { \n        initialFrame = float(iFrame); \n        samplingType = BRDF_IMPORTANCE_SAMPLING; \n    }\t\n\n    \/\/ two enables lighting sampling only\n    float pressTwo = texture( iChannel1, vec2(KEY_TWO,0.25) ).x;\n    if (pressTwo > .5) { \n        initialFrame = float(iFrame); \n        samplingType = LIGHT_IMPORTANCE_SAMPLING; \n    }\t\n\n    \/\/ three enables multiple importance sampling\n    float pressThree = texture( iChannel1, vec2(KEY_THREE,0.25) ).x;\n    if (pressThree > .5) { \n        initialFrame = float(iFrame); \n        samplingType = MULTIPLE_IMPORTANCE_SAMPLING; \n    }\t\n\n    \/\/ four enables color sampling - green for brdf, red for light\n    float pressFour = texture( iChannel1, vec2(KEY_FOUR,0.25) ).x;\n    if (pressFour > .5) { \n        initialFrame = float(iFrame); \n        colorSamples = 1.;\n    }\n    \n    \n    if (this_pixel_is_being_rendered(fragCoord, vec2(0., 0.)))\n    {        \n\t\tresultingColor = vec3(initialFrame, samplingType, colorSamples);\n    }\n                \n    return resultingColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\n    if (!this_pixel_is_in_the_range(fragCoord, vec2(0., 0.), vec2(1., 0.)))\n    {\n        discard;\n    }\n    \n    vec3 finalColor = process_inputs(fragCoord);\n    \n    fragColor = vec4(finalColor,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\/\/ Buffer B does the sampling and accumulation work \n\n\/\/ **************************************************************************\n\/\/ DEFINES\n\n#define PI 3.14159\n#define TWO_PI 6.28318\n#define INV_TWO_PI .159155\n#define PI_OVER_TWO 1.570796\n\n#define REALLY_SMALL_NUMBER 0.0001\n#define REALLY_BIG_NUMBER 1000000.\n\n#define MIRROR_ID 1.\n#define SEMI_MIRROR_ID 2.\n#define SEMI_ROUGH_ID 3.\n#define ROUGH_ID 4.\n#define LIGHT_ID 5.\n\n#define BACKDROP_ID 6.\n#define ENVIRONMENT_ID 7.\n\n\/\/ **************************************************************************\n\/\/ CONSTANTS\n\nconst int BRDF_IMPORTANCE_SAMPLING = 2;\nconst int LIGHT_IMPORTANCE_SAMPLING = 1;\nconst int MULTIPLE_IMPORTANCE_SAMPLING = 0;\n\n\/\/ **************************************************************************\n\/\/ INLINE MACROS\n\n#define MATCHES_ID(id1, id2) (id1 > (id2 - .5)) && (id1 < (id2 + .5))\n\n\n\/\/ **************************************************************************\n\/\/ GLOBALS\n\nfloat g_frame        = 0.;\nint g_samplingType = MULTIPLE_IMPORTANCE_SAMPLING;\nfloat g_colorSamples = 0.;\n\n\nvec4 g_light0 = vec4(-2.,1.8, -3., .1);\nvec4 g_light1 = vec4(-.666,1.8, -3., .2);\nvec4 g_light2 = vec4(.666,1.8, -3., .3);\nvec4 g_light3 = vec4(2.,1.8, -3., .4);\n\n\/\/ **************************************************************************\n\/\/ MATH UTILITIES\n\n\/\/ Rotate the input point around the y-axis by the angle given as a cos(angle)\n\/\/ and sin(angle) argument.  There are many times where I want to reuse the\n\/\/ same angle on different points, so why do the heavy trig twice. Range of\n\/\/ outputs := ([-1.,-1.,-1.] -> [1.,1.,1.])\nvec3 rotate_yaxis( vec3 point, float cosa, float sina )\n{\n    return vec3(point.x * cosa  + point.z * sina,\n                point.y,\n                point.x * -sina + point.z * cosa);\n}\n\n\/\/ Rotate the input point around the x-axis by the angle given as a cos(angle)\n\/\/ and sin(angle) argument.  There are many times where  I want to reuse the\n\/\/ same angle on different points, so why do the  heavy trig twice. Range of\n\/\/ outputs := ([-1.,-1.,-1.] -> [1.,1.,1.])\nvec3 rotate_xaxis( vec3 point, float cosa, float sina )\n{\n    return vec3(point.x,\n                point.y * cosa - point.z * sina,\n                point.y * sina + point.z * cosa);\n}\n\n\n\/\/ --------------------------------------\n\/\/ from dave hoskins: https:\/\/www.shadertoy.com\/view\/4djSRW\n\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\nvec2 hash21(float p)\n{\n    vec3 p3 = fract(vec3(p) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n#define HASHSCALE1 .1031\nfloat hash12(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\/\/ --------------------------------------\n\nfloat dist_squared(vec3 v1, vec3 v2)\n{\n    return (v1.x - v2.x) * (v1.x - v2.x) + \n        (v1.y - v2.y) * (v1.y - v2.y) + \n        (v1.z - v2.z) * (v1.z - v2.z);\n}\n\nvec4 intersect_sphere(vec3 ro, vec3 rd, vec3 sphc, float sphr)\n{\n    if (dist_squared(ro,sphc) < sphr * sphr) \n    { \n        return vec4(-1., vec3(0.)); \n    }\n    \n    vec3 sphro = ro - sphc; \n    float a = dot(rd, rd);\n    float b = dot(sphro, rd);\n    float c = dot(sphro, sphro) - sphr * sphr;\n    float sign = mix(-1., 1., step(0., a));\n    float t = (-b + sign * sqrt(b*b - a*c))\/a; \n    \n    vec3 n = normalize(ro + t * rd - sphc);\n    return vec4(step(0., t), n);    \n    \n}\n\nvec3 polar_to_cartesian(float sinTheta, \n                        float cosTheta, \n                        float sinPhi,\n                        float cosPhi)\n{\n    return vec3(sinTheta * cosPhi,\n                sinTheta * sinPhi,\n                cosTheta);\n}\n\n\n\/\/ **************************************************************************\n\/\/ DISTANCE FIELDS\n\nfloat sphere_df( vec3 p, float r) \n{ \n    return length(p) - r; \n}\n\nfloat envsphere_df ( vec3 p, float r) \n{ \n    return r - length(p); \n}\n\nfloat roundbox_df ( vec3 p, vec3 b, float r ) \n{\n    return length(max(abs(p-vec3(0., .5*b.y, 0.))-.5*b,0.))-r; \n}\n\n\/\/ **************************************************************************\n\/\/ INFORMATION HOLDERS (aka DATA STRUCTURES)\n\nstruct RaySampleInfo\n{\n    vec3 origin;\n    vec3 direction;\n    vec2 imagePlaneUV;\n};\n\n#define INIT_RAY_INFO() RaySampleInfo(vec3(0.) \/* origin *\/, vec3(0.) \/* direction *\/, vec2(0.) \/* imagePlaneUV *\/)\n\nstruct SurfaceInfo\n{\n    float id;\n    vec3 incomingRayDir;\n    vec3 point;\n    vec3 normal;\n    float incomingRayLength;\n    float rayDepth;\n    \n};\n#define INIT_SURFACE_INFO(incomingRayDir) SurfaceInfo(-1. \/* id *\/, incomingRayDir \/* incomingRayDir *\/, vec3(0.) \/* point *\/, vec3(0.) \/* normal *\/, 0. \/* incomingRayLength *\/, 0. \/* rayDepth *\/)\n\nstruct MaterialInfo\n{\n    float seed;\n    float specExponent;\n    float specIntensity;\n    vec3  baseColor;\n};\n#define INIT_MATERIAL_INFO(seed) MaterialInfo(seed, 1. \/* specExponent *\/, 1. \/* specIntensity *\/, vec3(.8) \/* baseColor *\/)\n\n\/\/ **************************************************************************\n\/\/ SETUP WORLD\n\nvoid setup_globals()\n{\n    \n    vec3 storedState = texture(iChannel1, vec2(0., 0.), -100.).rgb;\n    g_frame = float(iFrame) - storedState.r ;\n    g_samplingType = int(storedState.g + .5);\n    g_colorSamples = storedState.b;\n}\n\nvec4 get_light(int i)\n{\n    if (i == 0) { return g_light0; }\n    if (i == 1) { return g_light1; }\n    if (i == 2) { return g_light2; }\n    else { return g_light3; }\n}\n\nRaySampleInfo setup_cameraRay(vec2 aaoffset)\n{\n    \n    vec3 origin = vec3(0.0, 2., 6.0);\n    vec3 cameraPointsAt = vec3(0., .5, 0.);\n\n    float invAspectRatio = iResolution.y \/ iResolution.x;\n    vec2 imagePlaneUV = (gl_FragCoord.xy + aaoffset) \/ iResolution.xy - .5;\n    imagePlaneUV.y *= invAspectRatio;\n\n    vec3 iu = vec3(0., 1., 0.);\n\n    vec3 iz = normalize( cameraPointsAt - origin );\n    vec3 ix = normalize( cross(iz, iu) );\n    vec3 iy = cross(ix, iz);\n\n    vec3 direction = normalize( imagePlaneUV.x * ix + imagePlaneUV.y * iy + .8 * iz );\n\n    return RaySampleInfo(origin, direction, imagePlaneUV);\n\n}\n\n\/\/ **************************************************************************\n\/\/ MARCH\n\nvec2 union_obj(vec2 o1, vec2 o2)\n{\n    return (o1.x < o2.x) ? o1 : o2;\n}\n\nvec2 map(float depth, vec3 p)\n{\n    vec2 roughObj =       vec2(roundbox_df(rotate_xaxis(p - vec3(0., -.4,  1.2), cos( 0.0), sin( 0.0)), vec3(5., .02, 1.), .01), ROUGH_ID);\n    vec2 semiroughObj =   vec2(roundbox_df(rotate_xaxis(p - vec3(0., -.38,  0.), cos(-0.12), sin(-0.12)) , vec3(5., .02, 1.), .01), SEMI_ROUGH_ID);\n    vec2 semimirrorObj =  vec2(roundbox_df(rotate_xaxis(p - vec3(0., -.2, -1.2), cos(-0.26), sin(-0.26)) , vec3(5., .02, 1.), .01), SEMI_MIRROR_ID);\n    vec2 mirrorObj =      vec2(roundbox_df(rotate_xaxis(p - vec3(0., .2, -2.4), cos(-0.5), sin(-0.5)) , vec3(5., .02, 1.), .01), MIRROR_ID);    \n    \n    \n    vec2 resultObj = union_obj(mirrorObj, semimirrorObj);\n    resultObj = union_obj(resultObj, semiroughObj);\n    resultObj = union_obj(resultObj, roughObj);    \n    \n    float backdropDF = roundbox_df(p + vec3(0., 1., 0.), vec3(20.,.2,10.), 0.);\n    backdropDF = min(backdropDF, roundbox_df(rotate_xaxis(p - vec3(0., -3.8, -3.2), cos(.5), sin(.5)), vec3(20., 10., .2), 0.));\n    vec2 backdropObjs = vec2(backdropDF, BACKDROP_ID);    \n    resultObj = union_obj(resultObj, backdropObjs);\n    \n    if (depth < .5)\n    {\n        vec4 l = get_light(0);\n        float lightDF = sphere_df(p - l.xyz, l.w);\n        l = get_light(1);\n        lightDF = min(lightDF, sphere_df(p - l.xyz, l.w));\n        l = get_light(2);\n        lightDF = min(lightDF, sphere_df(p - l.xyz, l.w));\n        l = get_light(3);\n        lightDF = min(lightDF, sphere_df(p - l.xyz, l.w));\n        \n        vec2 lightObjs =       vec2(lightDF, LIGHT_ID);\n        resultObj = union_obj(resultObj, lightObjs);\n    }\n    \n    resultObj = union_obj(resultObj, vec2( envsphere_df(p, 11.), ENVIRONMENT_ID) );\n        \n    return resultObj;\n}\n\nvec3 calc_normal(vec3 p)\n{\n \n    vec3 epsilon = vec3(0.001, 0., 0.);\n    \n    vec3 n = vec3(map(1., p + epsilon.xyy).x - map(1., p - epsilon.xyy).x,\n                  map(1., p + epsilon.yxy).x - map(1., p - epsilon.yxy).x,\n                  map(1., p + epsilon.yyx).x - map(1., p - epsilon.yyx).x);\n    \n    return normalize(n);\n}\n\nSurfaceInfo dist_march(float depth, vec3 ro, vec3 rd)\n{\n    SurfaceInfo surface = INIT_SURFACE_INFO(rd); \n    \n    float t = 0.;\n    vec3 p = ro;    \n    vec2 obj = vec2(0.);\n    float d = REALLY_BIG_NUMBER;\n    \n    for (int i = 0; i < 64; i++)\n    {\n        obj = map(depth, p);\n        d = obj.x;\n        \n        t += d;\n        p += rd * d;\n        \n        if (d < .001) { break; }\n        obj.y = 0.;\n        \n    }\n\n    surface.id = obj.y;        \n    surface.point = p;\n    surface.normal = calc_normal(surface.point);\n    surface.incomingRayLength = t;\n    surface.rayDepth = depth;\n    \n    return surface;\n}\n\nvoid calc_binormals(vec3 normal,\n                    out vec3 tangent,\n                    out vec3 binormal)\n{\n    if (abs(normal.x) > abs(normal.y))\n    {\n        tangent = normalize(vec3(-normal.z, 0., normal.x));\n    }\n    else\n    {\n        tangent = normalize(vec3(0., normal.z, -normal.y));\n    }\n    \n    binormal = cross(normal, tangent);\n}\n \nvec3 uniform_sample_cone(vec2 u12, \n                         float cosThetaMax, \n                         vec3 xbasis, vec3 ybasis, vec3 zbasis)\n{\n    float cosTheta = (1. - u12.x) + u12.x * cosThetaMax;\n    float sinTheta = sqrt(1. - cosTheta * cosTheta);\n    float phi = u12.y * TWO_PI;\n    vec3 samplev = polar_to_cartesian(sinTheta, cosTheta, sin(phi), cos(phi));\n    return samplev.x * xbasis + samplev.y * ybasis + samplev.z * zbasis;\n}\n             \nvec3 brdf(vec3 wi, \n          vec3 wo, \n          vec3 n,\n          MaterialInfo material)\n{\n    \n    float cosThetaN_Wi = abs(dot(n, wi));\n    float cosThetaN_Wo = abs(dot(n, wo));\n    vec3 wh = normalize(wi + wo);\n    float cosThetaN_Wh = abs(dot(n, wh));   \n    \n    \/\/ Compute geometric term of blinn microfacet      \n    float cosThetaWo_Wh = abs(dot(wo, wh));\n    float G = min(1., min((2. * cosThetaN_Wh * cosThetaN_Wo \/ cosThetaWo_Wh),\n                           (2. * cosThetaN_Wh * cosThetaN_Wi \/ cosThetaWo_Wh)));\n    \n    \/\/ Compute distribution term\n    float D = (material.specExponent+2.) * INV_TWO_PI * pow(max(0., cosThetaN_Wh), material.specExponent);\n    \n    \/\/ assume no fresnel\n    float F = 1.;\n    \n    return material.baseColor * D * G * F \/ (4. * cosThetaN_Wi * cosThetaN_Wo);\n}\n \n\nvec3 light_emission(vec3 p, vec3 lp, vec3 ln)\n{\n    return 20. * vec3(1., .98, .95) \/ dist_squared(p, lp);\n}\n\nfloat calc_visibility( vec3 ro, vec3 rd, float ray_extent )\n{\n    \n    SurfaceInfo surface = dist_march(1., ro, rd);\n    return step(ray_extent, surface.incomingRayLength);\n    \n}\n\nfloat light_pdf( vec4 light,\n                SurfaceInfo surface )\n{\n    \n    float sinThetaMax2 = light.w * light.w \/ dist_squared(light.xyz, surface.point);\n    float cosThetaMax = sqrt(max(0., 1. - sinThetaMax2));\n    return 1. \/ (TWO_PI * (1. - cosThetaMax));\n    \n}\n\nvec3 sample_light( SurfaceInfo surface,\n                   MaterialInfo material,\n                   vec4 light,\n                 out float pdf )\n{\n    vec2 u12 = hash21(material.seed);\n    \n    vec3 tangent = vec3(0.), binormal = vec3(0.);\n    vec3 ldir = normalize(light.xyz - surface.point);\n    calc_binormals(ldir, tangent, binormal);\n    \n    float sinThetaMax2 = light.w * light.w \/ dist_squared(light.xyz, surface.point);\n    float cosThetaMax = sqrt(max(0., 1. - sinThetaMax2));\n    vec3 light_sample = uniform_sample_cone(u12, cosThetaMax, tangent, binormal, ldir);\n    \n    pdf = -1.;\n    if (dot(light_sample, surface.normal) > 0.)\n    {\n        pdf = 1. \/ (TWO_PI * (1. - cosThetaMax));\n    }\n    \n    return light_sample;\n    \n}\n \nfloat brdf_pdf( vec3 wi, vec3 wo, \n                SurfaceInfo surface, \n                MaterialInfo material )\n{\n    vec3 wh = normalize(wi + wo);    \n    float cosTheta = abs(dot(wh, surface.normal));\n        \n    float pdf = -1.;\n    if (dot(wo, wh) > 0.)\n    {\n        pdf = ((material.specExponent + 1.) * pow(max(0., cosTheta), material.specExponent))\/(TWO_PI * 4. * dot(wo, wh));\n    }\n    \n    return pdf;\n}\n\n\nvec3 sample_brdf( SurfaceInfo surface,\n                 MaterialInfo material,\n                out float pdf)\n{\n           \n    vec2 u12 = hash21(material.seed);\n    \n    float cosTheta = pow(max(0., u12.x), 1.\/(material.specExponent+1.));\n    float sinTheta = sqrt(max(0., 1. - cosTheta * cosTheta));\n    float phi = u12.y * TWO_PI;\n    \n    vec3 whLocal = polar_to_cartesian(sinTheta, cosTheta, sin(phi), cos(phi));\n\n    vec3 tangent = vec3(0.), binormal = vec3(0.);\n    calc_binormals(surface.normal, tangent, binormal);\n    \n    vec3 wh = whLocal.x * tangent + whLocal.y * binormal + whLocal.z * surface.normal;\n    \n    vec3 wo = -surface.incomingRayDir;    \n    if (dot(wo, wh) < 0.)\n    {\n       wh *= -1.;\n    }\n            \n    vec3 wi = reflect(surface.incomingRayDir, wh);\n    \n    pdf = ((material.specExponent + 1.) * pow(clamp(abs(dot(wh, surface.normal)),0.,1.), material.specExponent))\/(TWO_PI * 4. * dot(wo, wh));\n    return wi;\n}    \n\nfloat power_heuristic(float nf, \n                      float fPdf, \n                      float ng, \n                      float gPdf)\n{\n    float f = nf * fPdf;\n    float g = ng * gPdf;\n    return (f*f)\/(f*f + g*g);\n}\n\nvec3 integrate_lighting( SurfaceInfo surface,\n                       MaterialInfo material,\n                       vec3 wi)\n{\n    vec3 lcol = vec3(0.);\n    for (int i = 0; i < 4; i += 1)\n    {\n        \n        vec4 light = get_light(i); \n                \n        if (g_samplingType == LIGHT_IMPORTANCE_SAMPLING ||\n            g_samplingType == MULTIPLE_IMPORTANCE_SAMPLING)\n        {\n            \/\/ sample light        \n            float lpdf = -1.;\n            vec3 lightSample = sample_light(surface, material, light, lpdf);\n\n            \n            if (lpdf > 0.)\n            {\n                vec4 r = intersect_sphere(surface.point, lightSample, light.xyz, light.w);\n                if (r.x > .0)\n                {\n                    vec3 colorSamples = mix(vec3(1.), vec3(1., .4, .4), g_colorSamples);\n                    float bpdf = brdf_pdf(wi, lightSample, surface, material);\n                    float misWeight = power_heuristic(1., lpdf, 1., bpdf);\n                    if (g_samplingType == LIGHT_IMPORTANCE_SAMPLING)\n                    {\n                        misWeight = 1.;\n                    }\n\n                    float visibility = calc_visibility( surface.point + lightSample * .01, lightSample, r.x);\n                    vec3 le = light_emission(surface.point, surface.point + lightSample * r.x, r.yzw);\n                    \/\/ specular\n                    lcol += material.specIntensity * colorSamples * visibility * brdf(wi, lightSample, surface.normal, material) * \n                                le * abs(dot(lightSample, surface.normal)) *\n                                (misWeight\/lpdf);\n\n                    \/\/ diffuse - cheated lambertian\n                    \/\/ reuse visibility\n                    lcol += material.baseColor * visibility * abs(dot(surface.normal, lightSample)) * le * INV_TWO_PI*\n                        (misWeight\/lpdf);\n\n\n                }\n            }\n        }\n\n            \n        \n        if (g_samplingType == BRDF_IMPORTANCE_SAMPLING ||\n            g_samplingType == MULTIPLE_IMPORTANCE_SAMPLING)\n        {\n            \/\/ sample brdf        \n            float bpdf = -1.;\n            vec3 brdfSample = sample_brdf(surface, material, bpdf);\n            if (bpdf > 0.)\n            {              \n                vec4 r = intersect_sphere(surface.point, brdfSample, light.xyz, light.w);\n                if (r.x > 0.)\n                {               \n                    vec3 colorSamples = mix(vec3(1.), vec3(.4, 1., .4), g_colorSamples);\n\n                    float lpdf = light_pdf(light, surface);\n                    float misWeight = power_heuristic(1., bpdf, 1., lpdf);\n                    if (g_samplingType == BRDF_IMPORTANCE_SAMPLING)\n                    {\n                        misWeight = 1.;\n                    }\n\n                    float visibility = calc_visibility( surface.point + brdfSample * .01, brdfSample, r.x);\n\n                    vec3 le = light_emission(surface.point, surface.point + brdfSample * r.x, r.yzw);\n                    \/\/ specular\n                    lcol += material.specIntensity * colorSamples * visibility * brdf(wi, brdfSample, surface.normal, material) *\n                        le *\n                        abs(dot(brdfSample, surface.normal)) *\n                        (misWeight\/bpdf);\n\n                    \/\/ diffuse - cheated lambertian\n                    \/\/ reuse visibility\n                    lcol += material.baseColor * visibility * abs(dot(surface.normal, brdfSample)) * le * INV_TWO_PI *\n                        (misWeight\/bpdf);\n\n                }\n            }\n        }\n\n        \n    }\n    \n    return lcol;\n}\n\nvec3 calc_pixelColor( float seed )\n{\n        \n    vec3 pcol = vec3(0.);    \n\n    RaySampleInfo currSample = setup_cameraRay( sin(.712 * seed) * vec2(.6 * cos(.231 * seed), .6 * sin(.231 * seed)) );\n    \n    \n    for (float depth = 0.; depth < 1.; depth+=1.)\n    {\n        SurfaceInfo surface = dist_march(depth,\n                                         currSample.origin, \n                                         currSample.direction);\n        \n        MaterialInfo material = INIT_MATERIAL_INFO(seed);\n        float roughness = 1.;\n\n        if (surface.id < .5)\n        {\n            break;\n        }        \n        else if (MATCHES_ID(surface.id, LIGHT_ID))\n        {\n            pcol = 1. * vec3(1., 1., 1.);\n            break;\n        }\n        else if (MATCHES_ID(surface.id, MIRROR_ID))\n        {\n            roughness = 0.;\n            material.baseColor = vec3(.005);\n        }\n        else if (MATCHES_ID(surface.id, SEMI_MIRROR_ID))\n        {\n            roughness = .4;\n            material.baseColor = vec3(.005);\n        }\n        else if (MATCHES_ID(surface.id, SEMI_ROUGH_ID))\n        {\n            roughness = .8;\n            material.baseColor = vec3(.005);\n        }\n        else if (MATCHES_ID(surface.id, ROUGH_ID))\n        {\n            roughness = .95;\n            material.baseColor = vec3(.005);\n        }\n                   \n        \n        else if (MATCHES_ID(surface.id, BACKDROP_ID))\n        {\n            roughness = 1.;\n            material.baseColor = vec3(.015, .012, .012);\n        }\n         \n        else\n        {\n            break;\n        }\n        \n        material.specExponent = floor(max(1., (1. - pow(roughness, .15)) * 40000.));    \n        material.specIntensity = 15.;\n        \n        pcol += integrate_lighting(surface, material, -surface.incomingRayDir);\n        \n        currSample.direction = reflect(surface.incomingRayDir, surface.normal);\n        currSample.origin = surface.point + .01 * currSample.direction;\n        \n    }\n    \n    return pcol;   \n}\n\n\/\/ **************************************************************************\n\/\/ MAIN COLOR\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    setup_globals();\n    vec2 uv = fragCoord.xy \/ iResolution.xy;        \n        \n    \/\/ ----------------------------------\n    \/\/ SAMPLING \n    \n    float seed = g_frame + hash12( uv );\n    \/\/float seed = float(floor(float(g_frame)\/10.));\n    \n    vec3 currPixelColor = calc_pixelColor( seed );    \n\n    \/\/ ----------------------------------\n    \/\/ FINAL GATHER \n\n    vec3 finalColor = vec3(0.);\n    \n    if (g_frame > .5)\n    {\n        finalColor = texture(iChannel0, uv).rgb;\n    }\n    \n    finalColor += currPixelColor;\n    \n    fragColor = vec4(finalColor,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"MdBfRK","date":"1501498448","viewed":5257,"name":"[SH17C] Let's Make A Ray Marcher","username":"TekF","description":"A guide to writing a ray marcher. Aimed at people who have done a little programming, and want to learn how to draw 3D scenes in Shadertoy. You interact with the tutorial by writing code in ShaderToy's editor.","likes":118,"published":3,"flags":32,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void _mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\/\/-------- Don't edit the next line! It will break the tutorial. --------\nvoid mainImage(out vec4 o,vec2 u){vec4 s=texelFetch(iChannel3,ivec2(0),0);_mainImage(o,u*s.zw-s.xy);vec4 t=texelFetch(iChannel3,ivec2(u),0);o=mix(o,t,t.a);}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzr","filepath":"\/media\/a\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"\/media\/ap\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/*\n\nYour final shader should look like this:\n\n\/\/1) Signed Distance Field\n\/\/========================\nfloat Sphere( vec3 centre, float radius, vec3 pos )\n{\n    return length(centre-pos)-radius;\n}\n\nfloat Scene( vec3 pos )\n{\n    float f = Sphere(vec3(-1,-1,0),1.,pos);\n    f = min(f,Sphere(vec3(1,-1,0),1.,pos));\n    f = min(f,Sphere(vec3(0,1,0),1.,pos));\n    return f;\n}\n\n\/\/2) Ray Marching\n\/\/===============\nvoid Rotate( inout vec3 vector, vec2 angle )\n{\n\tvector.yz = cos(angle.y)*vector.yz\n\t\t\t\t+sin(angle.y)*vec2(-1,1)*vector.zy;\n\tvector.xz = cos(angle.x)*vector.xz\n\t\t\t\t+sin(angle.x)*vec2(-1,1)*vector.zx;\n}\n\nvoid _mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 ray = normalize( vec3(\n\t\t\t\t(fragCoord-iResolution.xy*.5)\/iResolution.x, \/\/ pixel pos on screen\n\t\t\t\t1 ) ); \/\/ place screen 1 unit in front of eye\n    vec3 pos = vec3(0,0,-8); \/\/ move eye 8 units back from scene\n\tvec2 angle = vec2(iTime,.3);\n\t\/\/if ( iMouse.z >= .0 ) angle = (iMouse.xy\/iResolution.xy-.5)*3.14;\n\tRotate(pos,angle);\n\tRotate(ray,angle);\n\n    fragColor = vec4(1);\n    for ( int i=0; i < 100; i++ )\n    {\n        float h = Scene(pos);\n        if ( h < .01 )\n        {\n            fragColor = vec4(0);\n            break;\n        }\n        pos += ray*h;\n    }\n\n\/\/3) Lighting\n\/\/===========\n    if ( Scene(pos) < .01 )\n    {\n        vec3 normal;\n        normal.x = Scene(pos+vec3(.01,0,0)) - Scene(pos-vec3(.01,0,0));\n        normal.y = Scene(pos+vec3(0,.01,0)) - Scene(pos-vec3(0,.01,0));\n        normal.z = Scene(pos+vec3(0,0,.01)) - Scene(pos-vec3(0,0,.01));\n        normal = normalize(normal);\n\n        vec3 lightSource = vec3(4,4,-4);\n\t\tfloat light = max(.0,dot(normal,normalize(lightSource-pos)));\n\n        vec3 ambient = vec3(.05,.1,.15);\n        vec3 lightCol = vec3(1.,.9,.8);\n        fragColor.rgb = light*lightCol + ambient;\n    }\n    \n    fragColor.rgb = pow( fragColor.rgb, vec3(1.0\/2.2) );\n}\n\n*\/\n\n\n\/*\n\nSome extensions to try:\n\n\/\/ A more interesting SDF:\nfloat Superellipsoid( vec3 centre, float radius, float power, vec3 pos )\n{\n    pos = abs(pos-centre)\/radius; \/\/ scale and sign-flip pos into a [0,1] range\n    pos = pow(pos,vec3(power)); \/\/ apply power before summing components\n    float d = dot(pos,vec3(1)); \/\/ add the components together\n\td = pow(d,1.\/power); \/\/ apply inverse power so SDF is well behaved\n    float fix = min(1.,.5+.5*(power-1.)); \/\/ corrective factor for lower powers, ensure gradient of SDF doesn't exceed 1.\n    return fix*(d-1.)*radius; \/\/ undo the scaling, to hit the desired radius\n}\n\nfloat Scene( vec3 pos )\n{\n    float f = Sphere(vec3(0,1,-1),1.,pos);\n    \n    \/\/ ripply sphere (*.8 to keep SDF gradient <= 1.0)\n    f = min(f,Sphere(vec3(1,-1,-1),1.,pos)*.8 + sin(pos.y*20.+iTime*3.)*.03);\n\n    f = min(f,Superellipsoid(vec3(0,0,1),.7,1.\/(.5+.48*sin(iTime*1.3)),pos));\n    \n    \/\/ cut a circular chunk out of the scene\n    f = max(f,-Sphere(vec3(0,0,-.5),1.,pos));\n    \n    \/\/ this sphere is combined after the cut-out sphere, so it doesn't get cut\n    f = min(f,Sphere(vec3(-1,-1,-1),.8,pos));\n\n\t\/\/ floor\n    f = min(f,Sphere(vec3(0,-20,0),18.,pos));\n    \n    return f;\n}\n\n\n\/\/ shadows:\nfloat ShadowMarch( vec3 pos, vec3 light )\n{\n    vec3 ray = normalize(light-pos);\n    float e = length(light-pos);\n    float t = .02; \/\/ step away from the surface\n    for ( int i=0; i < 200; i++ )\n    {\n        float h = Scene(pos+ray*t);\n        if ( h < .001 )\n        {\n            return 0.; \/\/ hit something\n        }\n        if ( t >= e )\n        {\n            break;\n        }\n        t += h;\n    }\n    return 1.; \/\/ didn't hit anything\n}\n\n\/\/ and add this to the light calculation:\n        light *= ShadowMarch( pos, lightSource );\n\n\nFor further extensions, see this shader: https:\/\/www.shadertoy.com\/view\/4dSfzt\nIt includes reflection mapping and different materials per shape.\n\n\n*\/\n\n\nuint text[] = uint[]( 0x2774654cU, 0x614d2073U, 0x4120656bU, 0x79615220U, 0x72614d20U, 0x72656863U, 0x20202021U, \n0x3d3d3d3dU, 0x3d3d3d3dU, 0x3d3d3d3dU, 0x3d3d3d3dU, 0x3d3d3d3dU, 0x3d3d3d3dU, 0x2020203dU, \n\n0x73696854U, 0x74757420U, 0x6169726fU, 0x6977206cU, 0x73206c6cU, 0x20776f68U, 0x20756f79U, 0x20776f68U, 0x67206f74U, 0x7266206fU, 0x53206d6fU, 0x65646168U, 0x796f7472U, 0x20207327U, \n0x61666564U, 0x20746c75U, 0x77656e22U, 0x68732022U, 0x72656461U, 0x6f74202cU, 0x73206120U, 0x65646168U, 0x68742072U, 0x63207461U, 0x72206e61U, 0x65646e65U, 0x20612072U, 0x20204433U, \n0x6e656373U, 0x69772065U, 0x6c206874U, 0x74686769U, 0x2e676e69U, \n\n0x6976614eU, 0x65746167U, 0x65687420U, 0x74757420U, 0x6169726fU, 0x7962206cU, 0x696c6320U, 0x6e696b63U, 0x68742067U, 0x20112065U, 0x20646e61U, 0x75622013U, 0x6e6f7474U, 0x20202e73U, \n0x61707845U, 0x7420646eU, 0x76206568U, 0x20776569U, 0x7920666fU, 0x2072756fU, 0x64616873U, 0x62207265U, 0x72702079U, 0x69737365U, 0xab20676eU, 0x2020202eU, \n\n0x74696445U, 0x65687420U, 0x646f6320U, 0x6e692065U, 0x61685320U, 0x74726564U, 0x7327796fU, 0x756f7320U, 0x20656372U, 0x656e6170U, 0x6854202eU, 0x6d492065U, 0x20656761U, 0x20626174U, 0x746e6f63U, 0x736e6961U, 0x756f7920U, 0x68732072U, 0x72656461U, 0x6e61202cU, 0x20202064U, \n0x20656874U, 0x20667542U, 0x61742041U, 0x6f632062U, 0x6961746eU, 0x6320736eU, 0x2065646fU, 0x64206f74U, 0x6c707369U, 0x74207961U, 0x20736968U, 0x6f747574U, 0x6c616972U, 0x6e61202cU, 0x20612064U, 0x74736574U, 0x65206465U, 0x706d6178U, 0x6f20656cU, 0x68742066U, 0x20202065U, \n0x616e6966U, 0x6873206cU, 0x72656461U, 0x206e6920U, 0x6f632061U, 0x6e656d6dU, 0x74612074U, 0x65687420U, 0x61747320U, 0x202c7472U, 0x63696877U, 0x6f792068U, 0x61632075U, 0x6572206eU, 0x20726566U, 0x69206f74U, 0x6f792066U, 0x65672075U, 0x74732074U, 0x2e6b6375U, \n\n0x65646f43U, 0x67657320U, 0x746e656dU, 0x69682073U, 0x696c6867U, 0x65746867U, 0x6e692064U, 0x65726720U, 0x61206e65U, 0x6e206572U, 0x6c207765U, 0x73656e69U, 0x20666f20U, 0x65646f63U, 0x726f6620U, 0x756f7920U, 0x206f7420U, 0x2e646461U, \n0x6c6c6559U, 0x6c20776fU, 0x73656e69U, 0x65726120U, 0x6e696c20U, 0x74207365U, 0x20746168U, 0x65766168U, 0x61686320U, 0x6465676eU, 0x2020202eU, \n\n0x72206f54U, 0x79206e75U, 0x2072756fU, 0x65646f63U, 0x7270202cU, 0x20737365U, 0x2b746c41U, 0x746e453cU, 0x2c3e7265U, 0x20726f20U, 0x63696c63U, 0x2005206bU, 0x74207461U, 0x62206568U, 0x6f74746fU, 0x666f206dU, 0x65687420U, 0x756f7320U, 0x20656372U, 0x656e6170U, 0x2020202eU, \n0x53202931U, 0x656e6769U, 0x69442064U, 0x6e617473U, 0x46206563U, 0x646c6569U, \n0x3d3d3d3dU, 0x3d3d3d3dU, 0x3d3d3d3dU, 0x3d3d3d3dU, 0x3d3d3d3dU, 0x3d3d3d3dU, \n0x20202020U, \n0x73726946U, 0x6c202c74U, 0x73277465U, 0x65726320U, 0x20657461U, 0x75662061U, 0x6974636eU, 0x74206e6fU, 0x6574206fU, 0x75206c6cU, 0x6f682073U, 0x6c632077U, 0x2065736fU, 0x20206577U, \n0x20657261U, 0x74206f74U, 0x73206568U, 0x61667275U, 0x6f206563U, 0x20612066U, 0x65687073U, 0x61206572U, 0x6e612074U, 0x6f702079U, 0x20746e69U, 0x33206e69U, 0x70732044U, 0x2e656361U, \n\n0x63206557U, 0x6a206e61U, 0x20747375U, 0x7361656dU, 0x20657275U, 0x20656874U, 0x74736964U, 0x65636e61U, 0x6f726620U, 0x6874206dU, 0x70732065U, 0x65726568U, 0x20207327U, \n0x746e6563U, 0x74206572U, 0x6874206fU, 0x6f702065U, 0x20746e69U, 0x77206577U, 0x20746e61U, 0x74206f74U, 0x2c747365U, 0x646e6120U, 0x62757320U, 0x63617274U, 0x68742074U, 0x20202065U, \n0x69646172U, 0x202e7375U, 0x20646441U, 0x73696874U, 0x646f6320U, 0x74612065U, 0x65687420U, 0x706f7420U, 0x20666f20U, 0x72756f79U, 0x756f7320U, 0x20656372U, 0x656c6966U, 0x2020203aU, \n0x616f6c66U, 0x70532074U, 0x65726568U, 0x65762028U, 0x63203363U, 0x72746e65U, 0x66202c65U, 0x74616f6cU, 0x64617220U, 0x2c737569U, 0x63657620U, 0x6f702033U, 0x20746e69U, 0x20202029U, \n0x2020207bU, \n0x75746572U, 0x6c206e72U, 0x74676e65U, 0x65632868U, 0x6572746eU, 0x696f702dU, 0x2d29746eU, 0x69646172U, 0x203b7375U, \n0x2020207dU, \n\n0x20646e41U, 0x6c276577U, 0x6574206cU, 0x69207473U, 0x79622074U, 0x70657220U, 0x6963616cU, 0x7420676eU, 0x63206568U, 0x2065646fU, 0x74616874U, 0x6f686320U, 0x7365736fU, 0x65687420U, 0x61726620U, 0x6c6f4367U, 0x6920726fU, 0x6d5f206eU, 0x496e6961U, 0x6567616dU, 0x2020203aU, \n0x67617266U, 0x6f6c6f43U, 0x203d2072U, 0x34636576U, 0x70532028U, 0x65726568U, 0x63657628U, 0x29302833U, 0x2e30202cU, 0x76202c35U, 0x28336365U, 0x2c767520U, 0x29203020U, 0x3b292029U, \n\n0x72276557U, 0x73752065U, 0x20676e69U, 0x20656874U, 0x74207675U, 0x6970206fU, 0x61206b63U, 0x696f7020U, 0x7420746eU, 0x6574206fU, 0x6f207473U, 0x6874206eU, 0x6c702065U, 0x20656e61U, 0x7a207461U, 0x202c303dU, 0x20646e61U, 0x70732061U, 0x65726568U, 0x20666f20U, \n0x69646172U, 0x30207375U, 0x6120352eU, 0x6f702074U, 0x69746973U, 0x76206e6fU, 0x28336365U, 0x2d202930U, 0x69687720U, 0x69206863U, 0x20612073U, 0x726f6873U, 0x6e616874U, 0x6f662064U, 0x65762072U, 0x30283363U, 0x302c302cU, 0x20202029U, \n0x65687053U, 0x29286572U, 0x74756f20U, 0x73747570U, 0x22206120U, 0x6e676973U, 0x64206465U, 0x61747369U, 0x2065636eU, 0x6c656966U, 0x28202264U, 0x29464453U, 0x6977202cU, 0x20206874U, \n0x6167656eU, 0x65766974U, 0x6c617620U, 0x20736575U, 0x20726f66U, 0x6e696f70U, 0x69207374U, 0x6469736eU, 0x68742065U, 0x70732065U, 0x65726568U, 0x6e61202cU, 0x20202064U, \n0x69736f70U, 0x65766974U, 0x726f6620U, 0x74756f20U, 0x65646973U, 0x696f7020U, 0x2e73746eU, \n\n0x2774654cU, 0x61702073U, 0x20746e69U, 0x69736e69U, 0x70206564U, 0x746e696fU, 0x6c622073U, 0x2c6b6361U, 0x646e6120U, 0x74756f20U, 0x65646973U, 0x656e6f20U, 0x68772073U, 0x3a657469U, \n0x616f6c66U, 0x64732074U, 0x203d2066U, 0x65687053U, 0x76286572U, 0x28336365U, 0x202c2930U, 0x2c352e30U, 0x63657620U, 0x75202833U, 0x30202c76U, 0x3b292920U, \n0x67617266U, 0x6f6c6f43U, 0x203d2072U, 0x34636576U, 0x74732028U, 0x20287065U, 0x202c302eU, 0x20666473U, 0x3b292029U, \n\n0x2774654cU, 0x65632073U, 0x6572746eU, 0x65687420U, 0x69726f20U, 0x206e6967U, 0x74207461U, 0x63206568U, 0x72746e65U, 0x666f2065U, 0x65687420U, 0x72637320U, 0x2e6e6565U, 0x61684320U, 0x2065676eU, 0x20656874U, 0x63207675U, 0x75636c61U, 0x6974616cU, 0x74206e6fU, 0x20203a6fU, \n0x32636576U, 0x20767520U, 0x2e38203dU, 0x7266282aU, 0x6f436761U, 0x2d64726fU, 0x73655269U, 0x74756c6fU, 0x2e6e6f69U, 0x2e2a7978U, 0x692f2935U, 0x6f736552U, 0x6974756cU, 0x782e6e6fU, 0x2020203bU, \n\n0x20776f4eU, 0x6c276577U, 0x7263206cU, 0x65746165U, 0x73206120U, 0x656e6563U, 0x74697720U, 0x20332068U, 0x65687073U, 0x3a736572U, \n0x616f6c66U, 0x63532074U, 0x28656e65U, 0x63657620U, 0x6f702033U, 0x20292073U, \n0x2020207bU, \n0x616f6c66U, 0x20662074U, 0x7053203dU, 0x65726568U, 0x63657628U, 0x312d2833U, 0x2c312d2cU, 0x312c2930U, 0x6f702c2eU, 0x203b2973U, \n0x203d2066U, 0x286e696dU, 0x70532c66U, 0x65726568U, 0x63657628U, 0x2c312833U, 0x302c312dU, 0x2e312c29U, 0x736f702cU, 0x203b2929U, \n0x203d2066U, 0x286e696dU, 0x70532c66U, 0x65726568U, 0x63657628U, 0x2c302833U, 0x29302c31U, 0x2c2e312cU, 0x29736f70U, 0x20203b29U, \n0x75746572U, 0x66206e72U, 0x2020203bU, \n0x2020207dU, \n\n0x20646e41U, 0x6c276577U, 0x6163206cU, 0x53206c6cU, 0x656e6563U, 0x736e6920U, 0x64616574U, 0x20666f20U, 0x65687053U, 0x69206572U, 0x6d5f206eU, 0x496e6961U, 0x6567616dU, 0x2020203aU, \n0x616f6c66U, 0x64732074U, 0x203d2066U, 0x6e656353U, 0x65762865U, 0x20283363U, 0x202c7675U, 0x29292030U, 0x2020203bU, \n\n0x20776f4eU, 0x20756f79U, 0x756f6873U, 0x7320646cU, 0x33206565U, 0x72696320U, 0x73656c63U, 0x2020202eU, \n0x52202932U, 0x4d207961U, 0x68637261U, 0x20676e69U, 0x6f6e202dU, 0x68742077U, 0x73676e69U, 0x74656720U, 0x72657320U, 0x73756f69U, 0x20202021U, \n0x3d3d3d3dU, 0x3d3d3d3dU, 0x3d3d3d3dU, 0x3d3d3d3dU, 0x3d3d3d3dU, 0x3d3d3d3dU, 0x3d3d3d3dU, 0x3d3d3d3dU, 0x3d3d3d3dU, 0x3d3d3d3dU, 0x2020203dU, \n\n\n\n\n\n\n\n\n\n0x67616d49U, 0x20656e69U, 0x74616874U, 0x65687420U, 0x72637320U, 0x206e6565U, 0x61207369U, 0x6e697720U, 0x20776f64U, 0x6f746e69U, 0x33206120U, 0x6f772044U, 0x2e646c72U, 0x20655720U, 0x746e6177U, 0x206f7420U, 0x6b726f77U, 0x74756f20U, 0x69687720U, 0x20206863U, \n0x65786970U, 0x7220736cU, 0x65727065U, 0x746e6573U, 0x69687720U, 0x6f206863U, 0x63656a62U, 0x53202e74U, 0x6577206fU, 0x206c6c27U, 0x65726966U, 0x72206120U, 0x66207961U, 0x206d6f72U, 0x72756f79U, 0x65796520U, 0x72687420U, 0x6867756fU, 0x63616520U, 0x69702068U, 0x2c6c6578U, \n0x20646e61U, 0x6b726f77U, 0x74756f20U, 0x20666920U, 0x74616874U, 0x79617220U, 0x6d756220U, 0x69207370U, 0x206f746eU, 0x74796e61U, 0x676e6968U, 0x2020203aU, \n0x64696f76U, 0x616d5f20U, 0x6d496e69U, 0x28656761U, 0x74756f20U, 0x63657620U, 0x72662034U, 0x6f436761U, 0x2c726f6cU, 0x206e6920U, 0x32636576U, 0x61726620U, 0x6f6f4367U, 0x29206472U, \n0x2020207bU, \n0x33636576U, 0x79617220U, 0x6e203d20U, 0x616d726fU, 0x657a696cU, 0x65762028U, 0x20283363U, \n0x61726628U, 0x6f6f4367U, 0x692d6472U, 0x6f736552U, 0x6974756cU, 0x782e6e6fU, 0x352e2a79U, 0x52692f29U, 0x6c6f7365U, 0x6f697475U, 0x2c782e6eU, 0x202f2f20U, 0x65786970U, 0x6f70206cU, 0x6e6f2073U, 0x72637320U, 0x206e6565U, \n0x29202e31U, 0x203b2920U, 0x70202f2fU, 0x6563616cU, 0x65687420U, 0x72637320U, 0x206e6565U, 0x6e752031U, 0x69207469U, 0x7266206eU, 0x20746e6fU, 0x6520666fU, 0x20206579U, \n0x33636576U, 0x736f7020U, 0x76203d20U, 0x28336365U, 0x2c302c30U, 0x3b29382dU, 0x202f2f20U, 0x65766f6dU, 0x65796520U, 0x75203820U, 0x7374696eU, 0x63616220U, 0x7266206bU, 0x73206d6fU, 0x656e6563U, \n0x67617266U, 0x6f6c6f43U, 0x203d2072U, 0x34636576U, 0x65747328U, 0x302e2870U, 0x6353202cU, 0x28656e65U, 0x2a796172U, 0x702b2e38U, 0x2029736fU, 0x203b2929U, \n0x2020207dU, \n\n0x20776f4eU, 0x27756f79U, 0x73206572U, 0x6e696565U, 0x20612067U, 0x63696c73U, 0x68742065U, 0x67756f72U, 0x68742068U, 0x63732065U, 0x20656e65U, 0x61207461U, 0x78696620U, 0x64206465U, 0x61747369U, 0x2065636eU, 0x6e6f6c61U, 0x68742067U, 0x61722065U, 0x20202e79U, \n0x20776f4eU, 0x74616874U, 0x27657720U, 0x77206572U, 0x696b726fU, 0x6920676eU, 0x4433206eU, 0x656c202cU, 0x20732774U, 0x20646461U, 0x656d6f73U, 0x6d616320U, 0x20617265U, \n0x61746f72U, 0x6e6f6974U, 0x6f74202cU, 0x6c656820U, 0x73752070U, 0x646e7520U, 0x74737265U, 0x20646e61U, 0x74616877U, 0x27657720U, 0x6c206572U, 0x696b6f6fU, 0x6120676eU, 0x20203a74U, \n0x64696f76U, 0x746f5220U, 0x28657461U, 0x6f6e6920U, 0x76207475U, 0x20336365U, 0x74636576U, 0x202c726fU, 0x32636576U, 0x676e6120U, 0x2920656cU, \n0x2020207bU, \n0x74636576U, 0x792e726fU, 0x203d207aU, 0x28736f63U, 0x6c676e61U, 0x29792e65U, 0x6365762aU, 0x2e726f74U, 0x20207a79U, \n0x6e69732bU, 0x676e6128U, 0x792e656cU, 0x65762a29U, 0x2d283263U, 0x29312c31U, 0x6365762aU, 0x2e726f74U, 0x203b797aU, \n0x74636576U, 0x782e726fU, 0x203d207aU, 0x28736f63U, 0x6c676e61U, 0x29782e65U, 0x6365762aU, 0x2e726f74U, 0x20207a78U, \n0x6e69732bU, 0x676e6128U, 0x782e656cU, 0x65762a29U, 0x2d283263U, 0x29312c31U, 0x6365762aU, 0x2e726f74U, 0x203b787aU, \n0x2020207dU, \n\n0x6c276557U, 0x7061206cU, 0x20796c70U, 0x73696874U, 0x746f7220U, 0x6f697461U, 0x6f74206eU, 0x746f6220U, 0x6f702068U, 0x6e612073U, 0x61722064U, 0x6f732079U, 0x65687420U, 0x65697620U, 0x6f722077U, 0x65746174U, 0x72612073U, 0x646e756fU, 0x65687420U, 0x69726f20U, 0x2e6e6967U, \n0x20646441U, 0x73696874U, 0x74666120U, 0x77207265U, 0x65642065U, 0x72616c63U, 0x61722065U, 0x6e612079U, 0x6f702064U, 0x74202c73U, 0x6f72206fU, 0x65746174U, 0x65687420U, 0x6562206dU, 0x65726f66U, 0x20657720U, 0x6c6c6163U, 0x65635320U, 0x2928656eU, 0x2020203aU, \n0x32636576U, 0x676e6120U, 0x3d20656cU, 0x63657620U, 0x54692832U, 0x2c656d69U, 0x3b29332eU, \n0x61746f52U, 0x70286574U, 0x612c736fU, 0x656c676eU, 0x20203b29U, \n0x61746f52U, 0x72286574U, 0x612c7961U, 0x656c676eU, 0x20203b29U, \n\n0x20656854U, 0x63726963U, 0x2073656cU, 0x20657261U, 0x20776f6eU, 0x74746567U, 0x20676e69U, 0x67676962U, 0x61207265U, 0x7320646eU, 0x6c6c616dU, 0x2d207265U, 0x61687420U, 0x20732774U, 0x61636562U, 0x20657375U, 0x72276577U, 0x6f722065U, 0x69746174U, 0x7420676eU, 0x20206568U, \n0x63696c73U, 0x68742065U, 0x67756f72U, 0x68742068U, 0x63732065U, 0x2c656e65U, 0x73757020U, 0x676e6968U, 0x20746920U, 0x61206e69U, 0x6f20646eU, 0x6f207475U, 0x6f732066U, 0x6f20656dU, 0x68742066U, 0x70732065U, 0x65726568U, 0x20202e73U, \n\n0x79206649U, 0x7720756fU, 0x20746e61U, 0x63206f74U, 0x72746e6fU, 0x74206c6fU, 0x72206568U, 0x7461746fU, 0x206e6f69U, 0x68746977U, 0x65687420U, 0x756f6d20U, 0x202c6573U, 0x20756f79U, 0x206e6163U, 0x20646461U, 0x73696874U, 0x6e696c20U, 0x20203a65U, \n0x28206669U, 0x6f4d6920U, 0x2e657375U, 0x3d3e207aU, 0x20302e20U, 0x6e612029U, 0x20656c67U, 0x6928203dU, 0x73756f4dU, 0x79782e65U, 0x6552692fU, 0x756c6f73U, 0x6e6f6974U, 0x2d79782eU, 0x2a29352eU, 0x34312e33U, 0x2020203bU, \n\n\n\n\n\n\n\n\n\n0x20656854U, 0x20464453U, 0x6c6c6574U, 0x73752073U, 0x776f6820U, 0x72616620U, 0x20657720U, 0x20657261U, 0x6d6f7266U, 0x65687420U, 0x6f6c6320U, 0x74736573U, 0x72757320U, 0x65636166U, 0x20746120U, 0x20796e61U, 0x6e696f70U, 0x6e692074U, 0x61707320U, 0x202e6563U, 0x20206f53U, \n0x63206577U, 0x73206e61U, 0x6c656661U, 0x6f6d2079U, 0x74206576U, 0x20746168U, 0x20726166U, 0x74206e69U, 0x64206568U, 0x63657269U, 0x6e6f6974U, 0x20666f20U, 0x20656874U, 0x20796172U, 0x68746977U, 0x2074756fU, 0x74746968U, 0x20676e69U, 0x74796e61U, 0x676e6968U, 0x2020202eU, \n0x77206649U, 0x65722065U, 0x74616570U, 0x69687420U, 0x72702073U, 0x7365636fU, 0x6e652073U, 0x6867756fU, 0x6d697420U, 0x202c7365U, 0x20656874U, 0x20796172U, 0x6c6c6977U, 0x646e6520U, 0x20707520U, 0x6f6d6c61U, 0x65207473U, 0x74636178U, 0x7420796cU, 0x6863756fU, 0x20676e69U, \n0x20656874U, 0x66727573U, 0x20656361U, 0x7420666fU, 0x6f206568U, 0x63656a62U, 0x202c7374U, 0x6c206f73U, 0x73277465U, 0x64646120U, 0x6c206120U, 0x20706f6fU, 0x74207461U, 0x65206568U, 0x6f20646eU, 0x6d5f2066U, 0x496e6961U, 0x6567616dU, 0x2020203aU, \n0x67617266U, 0x6f6c6f43U, 0x203d2072U, 0x34636576U, 0x3b293128U, \n0x20726f66U, 0x6e692028U, 0x3d692074U, 0x69203b30U, 0x31203c20U, 0x203b3030U, 0x202b2b69U, 0x20202029U, \n0x2020207bU, \n0x616f6c66U, 0x20682074U, 0x6353203dU, 0x28656e65U, 0x29736f70U, 0x2f2f203bU, 0x61657220U, 0x68742064U, 0x44532065U, 0x202d2046U, 0x20656874U, 0x74736964U, 0x65636e61U, 0x206f7420U, 0x20656874U, 0x736f6c63U, 0x20747365U, 0x66727573U, 0x20656361U, \n0x28206669U, 0x3c206820U, 0x31302e20U, 0x2f202920U, 0x6669202fU, 0x27657720U, 0x6e206572U, 0x6c726165U, 0x6f742079U, 0x69686375U, 0x6120676eU, 0x72757320U, 0x65636166U, 0x6170202cU, 0x20746e69U, 0x20656874U, 0x65786970U, 0x6c62206cU, 0x206b6361U, \n0x2020207bU, \n0x67617266U, 0x6f6c6f43U, 0x203d2072U, 0x34636576U, 0x3b293028U, \n0x61657262U, 0x20203b6bU, \n0x2020207dU, \n0x20736f70U, 0x72203d2bU, 0x682a7961U, 0x2f2f203bU, 0x65747320U, 0x6c612070U, 0x20676e6fU, 0x20656874U, 0x20796172U, 0x74207962U, 0x64206568U, 0x61747369U, 0x2065636eU, 0x74206f74U, 0x63206568U, 0x65736f6cU, 0x73207473U, 0x61667275U, 0x20206563U, \n0x2020207dU, \n0x694c2033U, 0x69746867U, 0x2020676eU, \n0x3d3d3d3dU, 0x3d3d3d3dU, 0x20203d3dU, \n0x20776f4eU, 0x76276577U, 0x69682065U, 0x68742074U, 0x75732065U, 0x63616672U, 0x666f2065U, 0x206e6120U, 0x656a626fU, 0x202c7463U, 0x2774656cU, 0x6f772073U, 0x6f206b72U, 0x20207475U, \n0x74616877U, 0x676e6120U, 0x7420656cU, 0x20746168U, 0x66727573U, 0x20656361U, 0x61207369U, 0x54202e74U, 0x67206568U, 0x69646172U, 0x20746e65U, 0x7420666fU, 0x53206568U, 0x20204644U, \n0x70207369U, 0x65707265U, 0x6369646eU, 0x72616c75U, 0x206f7420U, 0x20656874U, 0x66727573U, 0x2c656361U, 0x646e6120U, 0x20657720U, 0x206e6163U, 0x646e6966U, 0x65687420U, \n0x64617267U, 0x746e6569U, 0x20796220U, 0x706d6173U, 0x676e696cU, 0x65687420U, 0x46445320U, 0x6f6c6120U, 0x6520676eU, 0x20686361U, 0x73697861U, 0x2020202eU, \n\n0x20646441U, 0x73696874U, 0x646f6320U, 0x66612065U, 0x20726574U, 0x20656874U, 0x2d796172U, 0x6372616dU, 0x6f6c2068U, 0x203a706fU, \n0x28206669U, 0x65635320U, 0x7028656eU, 0x2029736fU, 0x302e203cU, 0x20292031U, 0x64202f2fU, 0x74206469U, 0x72206568U, 0x68207961U, 0x61207469U, 0x6874796eU, 0x3f676e69U, \n0x2020207bU, \n0x33636576U, 0x726f6e20U, 0x3b6c616dU, \n0x6d726f6eU, 0x782e6c61U, 0x53203d20U, 0x656e6563U, 0x736f7028U, 0x6365762bU, 0x302e2833U, 0x2c302c31U, 0x20292930U, 0x6353202dU, 0x28656e65U, 0x2d736f70U, 0x33636576U, 0x31302e28U, 0x302c302cU, 0x203b2929U, \n0x6d726f6eU, 0x792e6c61U, 0x53203d20U, 0x656e6563U, 0x736f7028U, 0x6365762bU, 0x2c302833U, 0x2c31302eU, 0x20292930U, 0x6353202dU, 0x28656e65U, 0x2d736f70U, 0x33636576U, 0x2e2c3028U, 0x302c3130U, 0x203b2929U, \n0x6d726f6eU, 0x7a2e6c61U, 0x53203d20U, 0x656e6563U, 0x736f7028U, 0x6365762bU, 0x2c302833U, 0x302e2c30U, 0x20292931U, 0x6353202dU, 0x28656e65U, 0x2d736f70U, 0x33636576U, 0x302c3028U, 0x31302e2cU, 0x203b2929U, \n0x6d726f6eU, 0x3d206c61U, 0x726f6e20U, 0x696c616dU, 0x6e28657aU, 0x616d726fU, 0x203b296cU, \n0x67617266U, 0x6f6c6f43U, 0x67722e72U, 0x203d2062U, 0x2e2b352eU, 0x6f6e2a35U, 0x6c616d72U, 0x2f2f203bU, 0x73657420U, 0x68742074U, 0x61762065U, 0x2065756cU, \n0x2020207dU, \n\n0x2774654cU, 0x70612073U, 0x20796c70U, 0x696c2061U, 0x69746867U, 0x6320676eU, 0x75636c61U, 0x6974616cU, 0x74206e6fU, 0x6874206fU, 0x203a7461U, \n0x33636576U, 0x67696c20U, 0x6f537468U, 0x65637275U, 0x76203d20U, 0x28336365U, 0x2c342c34U, 0x3b29342dU, 0x202f2f20U, 0x69736f70U, 0x6e6f6974U, 0x20666f20U, 0x20656874U, 0x6867696cU, 0x20202074U, \n0x616f6c66U, 0x696c2074U, 0x20746867U, 0x616d203dU, 0x302e2878U, 0x746f642cU, 0x726f6e28U, 0x2c6c616dU, 0x6d726f6eU, 0x7a696c61U, 0x696c2865U, 0x53746867U, 0x6372756fU, 0x6f702d65U, 0x29292973U, 0x2020203bU, \n0x67617266U, 0x6f6c6f43U, 0x67722e72U, 0x203d2062U, 0x33636576U, 0x67696c28U, 0x3b297468U, \n0x6c276557U, 0x6974206cU, 0x6120746eU, 0x6569626dU, 0x6c20746eU, 0x74686769U, 0x696c7320U, 0x6c746867U, 0x6c622079U, 0x202c6575U, 0x20646e61U, 0x65726964U, 0x6c207463U, 0x74686769U, \n0x67696c73U, 0x796c7468U, 0x61726f20U, 0x2c65676eU, 0x206f7420U, 0x65766967U, 0x6d206120U, 0x2065726fU, 0x7574616eU, 0x206c6172U, 0x6c656566U, 0x2020202eU, \n0x33636576U, 0x626d6120U, 0x746e6569U, 0x76203d20U, 0x28336365U, 0x2c35302eU, 0x2e2c312eU, 0x3b293531U, \n0x33636576U, 0x67696c20U, 0x6f437468U, 0x203d206cU, 0x33636576U, 0x2c2e3128U, 0x2e2c392eU, 0x203b2938U, \n0x67617266U, 0x6f6c6f43U, 0x67722e72U, 0x203d2062U, 0x6867696cU, 0x696c2a74U, 0x43746867U, 0x2b206c6fU, 0x626d6120U, 0x746e6569U, 0x2020203bU, \n\n0x20776f4eU, 0x74616874U, 0x27657720U, 0x63206572U, 0x75706d6fU, 0x676e6974U, 0x67696c20U, 0x76207468U, 0x65756c61U, 0x77202c73U, 0x68732065U, 0x646c756fU, \n0x756a6461U, 0x6f207473U, 0x63207275U, 0x756f6c6fU, 0x66207372U, 0x7920726fU, 0x2072756fU, 0x65726373U, 0x73276e65U, 0x6d616720U, 0x202e616dU, \n\n0x6f632041U, 0x72756f6cU, 0x6c617620U, 0x6f206575U, 0x20312066U, 0x6e207369U, 0x7420746fU, 0x65636977U, 0x65687420U, 0x69726220U, 0x6e746867U, 0x20737365U, 0x3020666fU, 0x202c352eU, 0x61636562U, 0x20657375U, 0x65726373U, 0x20736e65U, 0x20657261U, \n0x696c6163U, 0x74617262U, 0x74206465U, 0x7375206fU, 0x6f6d2065U, 0x63206572U, 0x756f6c6fU, 0x61762072U, 0x7365756cU, 0x206e6920U, 0x20656874U, 0x6b726164U, 0x6c6f6320U, 0x7372756fU, 0x6877202cU, 0x20657265U, 0x72756f79U, 0x65796520U, 0x72612073U, 0x6f6d2065U, 0x20206572U, \n0x736e6573U, 0x76697469U, 0x57202e65U, 0x65722765U, 0x6d6f6320U, 0x69747570U, 0x6120676eU, 0x61757463U, 0x696c206cU, 0x20746867U, 0x756c6176U, 0x202c7365U, 0x77206f73U, 0x656e2065U, 0x74206465U, 0x6f63206fU, 0x7265766eU, 0x68742074U, 0x2065736fU, 0x6f746e69U, \n0x65726373U, 0x63206e65U, 0x756f6c6fU, 0x202e7372U, 0x74736f4dU, 0x6e6f6d20U, 0x726f7469U, 0x61682073U, 0x61206576U, 0x6d616720U, 0x6120616dU, 0x6e756f72U, 0x2e322064U, 0x73202c32U, 0x6577206fU, 0x206c6c27U, 0x6c707061U, 0x68742079U, 0x6e692065U, 0x73726576U, 0x20202065U, \n0x7420666fU, 0x2e746168U, \n\n0x20646441U, 0x73696874U, 0x646f6320U, 0x74612065U, 0x65687420U, 0x646e6520U, 0x20666f20U, 0x69616d5fU, 0x616d496eU, 0x203a6567U, \n0x67617266U, 0x6f6c6f43U, 0x67722e72U, 0x203d2062U, 0x28776f70U, 0x61726620U, 0x6c6f4367U, 0x722e726fU, 0x202c6267U, 0x33636576U, 0x302e3128U, 0x322e322fU, 0x3b292029U, \n\n0x656d6f53U, 0x656d6974U, 0x6f792073U, 0x6c6c2775U, 0x6e696620U, 0x63732064U, 0x73656e65U, 0x6f6f6c20U, 0x6562206bU, 0x72657474U, 0x74697720U, 0x69642068U, 0x72656666U, 0x20746e65U, 0x6d6d6167U, 0x61762061U, 0x7365756cU, 0x7562202cU, 0x6f662074U, 0x20202072U, \n0x6c616572U, 0x69747369U, 0x6d692063U, 0x73656761U, 0x756f7920U, 0x6f687320U, 0x20646c75U, 0x61776c61U, 0x6d207379U, 0x68637461U, 0x756f7920U, 0x6f6d2072U, 0x6f74696eU, 0x20732772U, 0x6d6d6167U, 0x6e612061U, 0x64612064U, 0x7473756aU, 0x6c6f6320U, 0x7372756fU, 0x2020202eU, \n0x636e6f43U, 0x6973756cU, 0x20206e6fU, \n0x3d3d3d3dU, 0x3d3d3d3dU, 0x20203d3dU, \n\n0x72726f53U, 0x74202c79U, 0x27746168U, 0x68742073U, 0x6e652065U, 0x28202e64U, 0x20726f46U, 0x21776f6eU, 0x20202029U, \n\n0x79206649U, 0x6c20756fU, 0x206b6f6fU, 0x74206e69U, 0x42206568U, 0x41206675U, 0x756f7320U, 0x2c656372U, 0x68204920U, 0x20657661U, 0x656d6f73U, 0x61786520U, 0x656c706dU, 0x666f2073U, \n0x656d6f73U, 0x726f6d20U, 0x78652065U, 0x736e6574U, 0x736e6f69U, 0x6c202d20U, 0x20656b69U, 0x63617274U, 0x20676e69U, 0x64616873U, 0x7220776fU, 0x2c737961U, 0x646e6120U, \n0x656d6f73U, 0x46445320U, 0x69727420U, 0x2e736b63U, \n\n0x6f682049U, 0x79206570U, 0x6620756fU, 0x646e756fU, 0x69687420U, 0x75742073U, 0x69726f74U, 0x75206c61U, 0x75666573U, 0x49202e6cU, 0x6f792066U, 0x61772075U, 0x7420746eU, 0x6173206fU, 0x79206576U, 0x2072756fU, 0x64616873U, 0x6a207265U, 0x20747375U, 0x79706f63U, \n0x72657665U, 0x69687479U, 0x7920676eU, 0x7627756fU, 0x72772065U, 0x65747469U, 0x6e69206eU, 0x61206f74U, 0x77656e20U, 0x61687320U, 0x2c726564U, 0x646e6120U, 0x6e657220U, 0x20656d61U, 0x69616d5fU, 0x616d496eU, 0x74206567U, 0x616d206fU, 0x6d496e69U, 0x2e656761U, \n\n0x48202020U, 0x79707061U, 0x61685320U, 0x69726564U, 0x2021676eU, \n0x542d2020U, 0x20466b65U, \n\n0x00000000U );\nuint lines[] = uint[]( \n0x0f0U, 0x7f0U, 0xef0U, 0xef0U, 0x1cf0U, 0x2af0U, 0x2ff0U, 0x2ff0U, 0x3df0U, 0x49f0U, 0x49f0U, 0x5ef0U, 0x73f0U, 0x87f0U, 0x8720U, 0x9930U, 0xa4f0U, 0xa4f0U, \n0xb9f0U, 0xbff0U, 0xc5f0U, 0xc6f0U, 0xd4f0U, 0xe2f0U, 0xe2f0U, 0xeff0U, 0xfdf0U, 0x10b20U, 0x11920U, 0x11a21U, 0x12320U, 0x124f0U, 0x124f0U, 0x13931U, 0x147f0U, 0x147f0U, 0x15bf0U, \n0x16df0U, 0x17bf0U, 0x188f0U, 0x18ff0U, 0x18ff0U, 0x19d31U, 0x1a931U, 0x1b2f0U, 0x1b2f0U, 0x1c731U, 0x1d6f0U, 0x1d6f0U, 0x1e020U, 0x1e620U, 0x1e721U, 0x1f121U, 0x1fb21U, 0x20521U, 0x20820U, 0x209f0U, 0x209f0U, 0x21731U, 0x220f0U, 0x220f0U, \n0x228f0U, 0x233f0U, 0x23ef0U, 0x23ef0U, 0x23ef0U, 0x23ef0U, 0x23ef0U, 0x23ef0U, 0x23ef0U, 0x23ef0U, 0x23ef0U, 0x23ef0U, 0x252f0U, 0x267f0U, 0x27330U, 0x28130U, 0x28231U, 0x28934U, 0x29a34U, 0x2a731U, 0x2b631U, 0x2c230U, 0x2c3f0U, 0x2c3f0U, \n0x2d7f0U, 0x2e4f0U, 0x2f220U, 0x2fd20U, 0x2fe21U, 0x30724U, 0x31021U, 0x31924U, 0x32220U, 0x323f0U, 0x323f0U, 0x338f0U, 0x34c21U, 0x35321U, 0x35821U, 0x35df1U, 0x35df0U, 0x372f0U, 0x384f1U, 0x384f0U, 0x39721U, 0x3a8f0U, \n0x3a8f0U, 0x3a8f0U, 0x3a8f0U, 0x3a8f0U, 0x3a8f0U, 0x3a8f0U, 0x3a8f0U, 0x3a8f0U, 0x3a8f0U, 0x3bdf0U, 0x3d2f0U, 0x3e7f0U, 0x3fa31U, 0x3ff21U, 0x40721U, 0x40822U, 0x41b22U, 0x42e22U, 0x42f23U, 0x43423U, 0x43622U, 0x43722U, 0x44a21U, \n0x44bf0U, 0x44ef0U, 0x451f0U, 0x45ff0U, 0x46df0U, 0x47af0U, 0x486f0U, 0x486f0U, 0x49021U, 0x49d21U, 0x49e22U, 0x4a122U, 0x4b122U, 0x4c122U, 0x4d122U, 0x4d822U, 0x4e421U, 0x4e5f0U, 0x4e5f0U, 0x4f022U, 0x4ff22U, 0x50f32U, \n0x516f0U, 0x524f0U, 0x53022U, 0x53822U, 0x54032U, 0x54bf0U, 0x54bf0U, 0x557f0U, 0x562f0U, 0x562f0U, 0x575f0U, 0x58af0U, 0x59ef0U, 0x5b3f0U, 0x5b5f0U, 0x5b5f0U, 0x5bf21U, 0x5ccf0U, 0x5ccf0U, 0x5e0f0U, \n0x5f5f0U, 0x5f8f0U, 0x5fbf0U, 0x5fbf0U, 0x604f0U, 0x604f0U, 0x612f0U, 0x61ff0U, 0x623f0U, 0x623f0U, 0x637f0U, 0x64bf0U, 0x64b67U, 0x6504aU, 0x652f0U, 0x65200U );\nuint pages[] = uint[]( 0x0U, 0x12U, 0x25U, 0x3dU, 0x55U, 0x6bU, 0x82U, 0x98U, 0xacU, 0xbbU );\n\nconst float screenHeightInLines = 24.; \/\/ text looks best if this is an integer fraction of height\nconst float textSoftness = .3;\nconst float tabWidth = 4.;\nconst float charWidth = .5; \/\/ as a factor of height\n\nvec4 WallOfText( float startLine, uint endLine, vec2 uv )\n{\n    uv.y -= iResolution.y; \/\/ we'll index negative y's from the top of the screen\n    \n    \/\/ convert to line-height scale\n    float pixelToLineScale = screenHeightInLines\/iResolution.y;\n    uv *= pixelToLineScale;\n    \n    \/\/ maybe add pages here, pointing into the lines\n    \n    \/\/ find out which line we're on\n    int line = int(-uv.y+startLine);\n    if ( line >= int(endLine) )\n    {\n       \treturn vec4(0);\n    }\n    \n    int lineIndex = int(lines[line]>>8U);\n    int lineIndent = int(lines[line]&0xFU); \/\/Oh ex, eff you!\n    int lineColour = int((lines[line]>>4U)&0xFU);\n    vec3 textColour = vec3(lineColour&1,(lineColour>>1)&1,(lineColour>>2)&1);\n    \n    \/\/ and which character within the line\n    int charIndex = int(floor(uv.x\/charWidth-float(lineIndent)*tabWidth));\n    charIndex += lineIndex*4;\n    \n    if ( charIndex >= lineIndex*4 && charIndex < int(lines[line+1]>>8U)*4 )\n    {\n        uint char = text[charIndex\/4];\n        char = (char>>(8*(charIndex&3)))&0xffU;\n        vec2 charuv = vec2( char&0xFU, 0xFU-(char>>4) );\n        \n        uv.x = fract(uv.x\/charWidth)*charWidth;\n        uv.y = fract(uv.y-startLine);\n        \n        vec4 t = textureLod(iChannel1,(uv+charuv)\/16.+vec2(1.\/64.,0), 0.);\n        \n\t    float s = textSoftness * pixelToLineScale;\n        \n        return vec4( textColour, smoothstep(.5+s,.5-s,t.w) );\n    }\n    \n    return vec4(0);\n}\n\n\n\/\/ Prints character in the range uv = (0,0) to (.5,1)\n\/\/ Doesn't handle the range outside of that\nfloat PrintCharacterInternal( in uint char, in vec2 uv )\n{\n    vec2 charp = vec2( char&0xFU, 0xFU-(char>>4U) );\n\n\/*    if ( min(uv.x,uv.y) < .0 || max(uv.x-.5,uv.y-1.) > .0 )\n        return 0.;*\/\n    uv.x += .25;\n\n    float s = 10.\/iResolution.x;\n    return smoothstep(.5+s,.5-s,textureLod(iChannel1, (uv+charp)\/16., .0).w);\n}\n\n\nint numButtons = 0;\nfloat clickTimes[4];\n\n\/\/ p = corner position - sign indicates which corner!\n\/\/ string rendering worked, but the shader performance nosedived if I also had a lot of text in the tutorial.\nfloat Button( inout vec4 o, uint char,\/*uint string[16], int strlen,*\/ vec2 p, vec2 uv, bool click )\n{\n    int strlen = 1;\n\tfloat buttonFontScale = iResolution.y \/ screenHeightInLines;\n    vec2 margin = vec2(.3,.0);\n    vec2 buttonDim = (vec2(.5*float(strlen),1)+margin)*buttonFontScale*.5;\n    \n    vec2 buttonMid = abs(p)-sign(p)*buttonDim;\n    \n    float clickTime = texelFetch(iChannel0,ivec2(3+numButtons\/4,0),0)[numButtons%4];\n    if ( clickTime > 15. )\n    {\n        vec2 duv = abs(iMouse.xy-buttonMid)-buttonDim;\n        if ( click && max(duv.x,duv.y) < .0 )\n            clickTime = 0.;\n    }\n    clickTimes[numButtons] = clickTime; \/\/ for data output\n    numButtons++;\n\n    vec2 euv = abs(uv-buttonMid)-buttonDim;\n    if ( max(euv.x,euv.y) <= .0 )\n    {\n        float pushed = clickTime < 5. ? -1. : 1.;\n        float l = .8 + .2*pushed*sign(dot(uv-buttonMid,vec2(-1,1)\/buttonDim))*step(-2.,max(euv.x,euv.y));\n        o.rgb = vec3(l);\n        \n        vec2 stringUV = (uv-buttonMid+buttonDim-margin*buttonFontScale*.5)\/buttonFontScale;\n        if ( stringUV.x > .0 && stringUV.x < .5*float(strlen) && stringUV.y > .0 && stringUV.y < 1. )\n        {\n            o.rgb = mix( o.rgb, vec3(0),\n                        PrintCharacterInternal( char\/*string[int(stringUV.x\/.5)]*\/, vec2(fract(stringUV.x\/.5)*.5,stringUV.y) )\n                        );\n        }\n        \n\t\to.a = 1.;\n    }\n\n    return clickTime;\n}\n\n\n\/\/ diagrams\nvoid Circle( inout vec3 o, vec2 c, float r, vec3 i, vec2 uv )\n{\n    o = mix( i, o, smoothstep( r-1.4, r, length(uv-c) ) );\n}\n\nvoid Line( inout vec3 o, vec2 a, vec2 b, float h, vec3 i, vec2 uv )\n{\n    if ( length(a-b) <= .0001 ) return;\n    \n    float t = dot(uv-a,b-a)\/dot(b-a,b-a);\n    t = clamp( t, .0, 1. );\n    vec2 p = mix( a, b, t ); \/\/ this should be the closest point on the line\n    o = mix( i, o, smoothstep( h-.7, h+.7, length(uv-p) ) );\n}\n\nvoid SphereMarchDiagram( inout vec3 o, vec2 uv )\n{\n    float size = iResolution.y*.55; \/\/ don't scale uv, it will break the anti aliasing\n    \n    if ( abs(uv.x) > .8*size || abs(uv.y) > .27*size )\n        return;\n    \n\tvec2 a = size*vec2(-.3,.1);\n    vec2 b = size*vec2(.5,.0 );\n    float l = length(b-a);\n    \n    float tt = fract(iTime\/10.)*10.;\n    float t[10];\n    for( int i=0; i < t.length(); i++ )\n    {\n        t[i] = smoothstep(.0,1.,tt-float(i));\n    }\n    \n    vec2 p0 = a;\n    vec2 p1 = mix(a,b,.5);\n    vec2 p2 = mix(a,b,.74);\n    vec2 p3 = mix(a,b,.92);\n    vec2 p4 = mix(a,b,.98);\n    \n    Circle( o, p4, l*.025*t[8], vec3(1,.5,.5), uv );\n    Circle( o, p4, l*.015*t[8], vec3(1,0,0), uv );\n    Circle( o, p3, l*.065*t[6], vec3(1,.5,.5), uv );\n    Circle( o, p3, l*.055*t[6], vec3(1,0,0), uv );\n    Circle( o, p2, l*.185*t[4], vec3(1,.5,.5), uv );\n    Circle( o, p2, l*.175*t[4], vec3(1,0,0), uv );\n    Circle( o, p1, l*.245*t[2], vec3(1,.5,.5), uv );\n    Circle( o, p1, l*.235*t[2], vec3(1,0,0), uv );\n    Circle( o, p0, l*.505*t[0], vec3(1,.5,.5), uv );\n    Circle( o, p0, l*.495*t[0], vec3(1,0,0), uv );\n    \n    vec2 arrowhead = normalize(b-a)*.3*size+a;\n    Line( o, a, arrowhead, size*.01, vec3(0), uv );\n    Line( o, arrowhead+vec2(-.04,.06)*size, arrowhead, size*.01, vec3(0), uv );\n    Line( o, arrowhead+vec2(-.06,-.05)*size, arrowhead, size*.01, vec3(0), uv );\n         \n    Line( o, p0, mix(p0,p1,t[1]), size*.005, vec3(1), uv );\n    Line( o, p1, mix(p1,p2,t[3]), size*.005, vec3(1), uv );\n    Line( o, p2, mix(p2,p3,t[5]), size*.005, vec3(1), uv );\n    Line( o, p3, mix(p3,p4,t[7]), size*.005, vec3(1), uv );\n    Line( o, p4, mix(p4,b,t[7]), size*.005, vec3(1), uv );\n    Circle( o, p0, size*.017, vec3(1), uv );\n    Circle( o, p1, size*.017*t[1], vec3(1), uv );\n    Circle( o, p2, size*.017*t[3], vec3(1), uv );\n    Circle( o, p3, size*.017*t[5], vec3(1), uv );\n    Circle( o, p4, size*.017*t[7], vec3(1), uv );\n    Circle( o, b, size*.017*t[9], vec3(1), uv );\n\n    Line( o, size*vec2(.7,.1), size*vec2(.43,-.08), size*.02, vec3(0), uv );\n    Line( o, size*vec2(.29,-.18), size*vec2(.43,-.08), size*.02, vec3(0), uv );\n    Line( o, size*vec2(.29,-.18), size*vec2(.04,-.165), size*.02, vec3(0), uv );\n    Line( o, size*vec2(-.1,-.3), size*vec2(.04,-.165), size*.02, vec3(0), uv );\n}\n\n\n\/\/ the same function from the tutorial!\nvoid Rotate( inout vec3 vector, vec2 angle )\n{\n\tvector.yz = cos(angle.y)*vector.yz\n\t\t\t\t+sin(angle.y)*vec2(-1,1)*vector.zy;\n\tvector.xz = cos(angle.x)*vector.xz\n\t\t\t\t+sin(angle.x)*vec2(-1,1)*vector.zx;\n}\n\n\nvec2 Hash( uint index )\n{\n    \/\/ integer hash copied from Hugo Elias\n\tindex = (index << 13U) ^ index;\n    index = index * (index * index * 15731U + 789221U) + 1376312589U;\n    uvec2 k = index * uvec2(index,index*16807U);\n    return 1.0 - vec2( k & uvec2(0x7fffffffU))\/float(0x7fffffff);\n}\n\n\nvoid RayLaunchDiagram( inout vec3 o, vec2 uv )\n{\n    float size = iResolution.y*.2; \/\/ don't scale uv, it will break the anti aliasing\n    \n    if ( abs(uv.x) > 2.*size || abs(uv.y) > .9*size ) return;\n    \n    vec3 eye = vec3(0,0,-2);\n    vec3 frame = vec3(1,.6,0);\n    \n    \/\/ isometric projection to 2D\n    vec3 i = vec3(1,0,0)*size;\n    vec3 j = vec3(0,1,0)*size;\n    vec2 a = vec2(.125,1.\/12.)*6.28*smoothstep(vec2(-.5),vec2(.5,.2),vec2(sin(iTime\/2.)));\n    Rotate( i, a );\n    Rotate( j, a );\n    \n    vec2 pe = vec2(dot(i,eye),dot(j,eye));\n    vec2 pf0 = vec2(dot(i,frame),dot(j,frame));\n    vec2 pf1 = vec2(dot(i,frame*vec3(-1,1,0)),dot(j,frame*vec3(-1,1,0)));\n    vec2 pf2 = vec2(dot(i,frame*vec3(1,-1,0)),dot(j,frame*vec3(1,-1,0)));\n    vec2 pf3 = vec2(dot(i,frame*vec3(-1,-1,0)),dot(j,frame*vec3(-1,-1,0)));\n    \n    \/\/ screen edges\n    Line( o, pf0, pf1, size*.02, vec3(.8), uv );\n    Line( o, pf3, pf1, size*.02, vec3(.8), uv );\n    Line( o, pf3, pf2, size*.02, vec3(.8), uv );\n    Line( o, pf0, pf2, size*.02, vec3(.8), uv );\n    \n    \/\/ rays firing through screen\n    vec3 ray = vec3(Hash(uint(iTime\/1.)),2.*fract(iTime\/1.));\n    vec2 p = mix(mix(pf3,pf2,ray.x),mix(pf1,pf0,ray.x),ray.y);\n    Circle( o, p, size*.02, vec3(1), uv );\n    Line( o, mix(pe,p,ray.z), mix(pe,p,ray.z+.1), size*.01, vec3(1), uv );\n    \n    \/\/ frustum\n    Line( o, pe, pf0, size*.01, vec3(.8), uv );\n    Line( o, pe, pf1, size*.01, vec3(.8), uv );\n    Line( o, pe, pf2, size*.01, vec3(.8), uv );\n    Line( o, pe, pf3, size*.01, vec3(.8), uv );\n    \n    \n    \/\/ [would be nice to show rays hitting something and colour appearing on screen\n}\n\n\nvoid mainImage( out vec4 o, vec2 uv )\n{\n    vec4 lastMouse = texelFetch(iChannel0,ivec2(1,0),0);\n    float page = texelFetch(iChannel0,ivec2(2,0),0).x;\n    \n    if ( iFrame == 0 )\n    {\n        page = .0;\n    }\n    \n    float isSmall = smoothstep(0.,30.,lastMouse.z);\n    if ( lastMouse.w < .0 ) isSmall = 1.-isSmall;\n    vec4 frame = mix( vec4(0,0,1,1), vec4(iResolution.x*2.,iResolution.y*2.,3,3), isSmall );\n    \n    \n    \/\/ buttons\n    bool click = ( lastMouse.x > .0\n         \t\t&& lastMouse.y > .0 && iMouse.w <= .0 );\n\n    vec2 sizeButtonPos = (vec2(0,0)+frame.xy)\/frame.zw+vec2(1,1);\n    \n    vec4 frameButtons = vec4(0);\n    float resizeClickTime = Button( frameButtons,\n                                   isSmall < .5 ? 0xBBU : 0xABU,\n                                   \/\/uint[16]( isSmall < .5 ? 0xBBU : 0xABU,0U,0U,0U, 0U,0U,0U,0U, 0U,0U,0U,0U, 0U,0U,0U,0U), 1,\n                                   sizeButtonPos*vec2(-1,-1), uv, click );\n    bool resizeClick = (resizeClickTime == 0.);\n    \n    vec4 pageButtons = vec4(0);\n    float pageUpClickTime = Button( pageButtons,\n                                     0x11U, \/\/uint[16]( 0x50U, 0x72U, 0x65U, 0x76U,  0U,0U,0U,0U, 0U,0U,0U,0U, 0U,0U,0U,0U ), 4, \/\/Next\n                                     vec2(iResolution.x-1.,-iResolution.y*.045-2.), uv, click );\n    float pageDownClickTime = Button( pageButtons,\n                                   0x13U, \/\/uint[16]( 0x4eU, 0x65U, 0x78U, 0x74U,  0U,0U,0U,0U, 0U,0U,0U,0U, 0U,0U,0U,0U ), 4, \/\/Next\n                                   vec2(iResolution.x-1.,-1), uv, click );\n    \n    page += pageUpClickTime == 0. ? -1. : pageDownClickTime == 0. ? 1. : 0.;\n    page = clamp(page,0.,float(pages.length()-2));\n\n    o = vec4(vec3(.5),1);\n    \n    \/\/ text goes here!\n\/\/\tfloat startLine = (float(lines.length())-24.)*(.5-.5*cos(float(iFrame)*6.283\/1000.));\n    float startLine = float(pages[int(page)]);\/\/25.*floor(6.999*fract(iTime\/(7.*2.)));\n    uint endLine = pages[int(page)+1];\/\/25.*floor(6.999*fract(iTime\/(7.*2.)));\n\tvec4 t = WallOfText( startLine, endLine, uv );\n    \n    o.rgb = mix( o.rgb, t.rgb, t.a );\n    o.rgb = mix( o.rgb, pageButtons.rgb, pageButtons.a );\n    o.a = max(max( o.a, t.a ), pageButtons.a );\n    \n    if ( int(page) == 3 )\n    {\n    \tRayLaunchDiagram( o.rgb, uv-vec2(.3,.75)*iResolution.xy );\n    }\n    \n    if ( int(page) == 5 )\n    {\n    \tSphereMarchDiagram( o.rgb, uv-vec2(.3,.83)*iResolution.xy );\n    }\n    \n    \/\/ frame\n    vec2 uvf = uv*frame.zw-frame.xy;\n    uvf = (abs(uvf-iResolution.xy*.5)-iResolution.xy*.5)\/frame.zw;\n    float f = max(uvf.x,uvf.y);\n    o = f < 0. ? vec4(0) : \/\/ transparent so we can see the user's shader\n    \tf < 2. ? vec4(0,0,0,1) : \/\/ border\n        o;\n    \n    o.rgb = mix( o.rgb, frameButtons.rgb, frameButtons.a );\n    o.a = max( o.a, frameButtons.a );\n    \n    \/\/ data output\n    ivec2 iuv = ivec2(uv);\n    if ( iuv.y == 0 && iuv.x < 2 + numButtons )\n    {\n        o = texelFetch(iChannel0,ivec2(uv),0);\n        \n        if ( iuv.x == 0 )\n        {\n            o = frame;\n        }\n        else if ( iuv.x == 1 )\n        {\n            \/\/ last frame's mouse position, frames since last click\n            o.xy = iMouse.zw;\n            if ( resizeClick )\n            {\n                o.z = .0;\n            \to.w = -sign(lastMouse.w);\n            }\n            else\n            {\n\t            o.z++;\n            \to.w = sign(lastMouse.w);\n            }\n            if ( o.w == 0. ) o.w = 1.;\n        }\n        else if ( iuv.x == 2 )\n        {\n            \/\/ page number\n            o.x = page;\n        }\n        else\n        {\n            \/\/ button data\n            for ( int i=0; i < numButtons; i+=4 )\n            {\n            \to = vec4(clickTimes[i],clickTimes[i+1],clickTimes[i+2],clickTimes[i+3])+1.;\n            }\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"wt3XDj","date":"1585951890","viewed":3316,"name":"Castaway","username":"P_Malin","description":"SPACE = Toggle Flycam\nWASD \/ click + mouse to move\nShift = Move faster","likes":113,"published":3,"flags":112,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"\/media\/previz\/buffer02.png","previewfilepath":"\/media\/previz\/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XtB3Wh","filepath":"https:\/\/soundcloud.com\/soundsofnaturewhitenoisesoundeffects\/waves-tropical-ocean-waves","previewfilepath":"https:\/\/soundcloud.com\/soundsofnaturewhitenoisesoundeffects\/waves-tropical-ocean-waves","type":"musicstream","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/     _____             _                                \n\/\/    \/ ____|           | |                               \n\/\/   | |      __ _  ___ | |_  __ _ __      __ __ _  _   _ \n\/\/   | |     \/ _` |\/ __|| __|\/ _` |\\ \\ \/\\ \/ \/\/ _` || | | |\n\/\/   | |____| (_| |\\__ \\| |_| (_| | \\ V  V \/| (_| || |_| |\n\/\/    \\_____|\\__,_||___\/ \\__|\\__,_|  \\_\/\\_\/  \\__,_| \\__, |\n\/\/                                                   __\/ |\n\/\/                                                  |___\/ \n\n\/\/ Castaway by @P_Malin\n\n\/\/ https:\/\/www.shadertoy.com\/view\/wt3XDj\n\n\/\/ Controls:\n\/\/ SPACE = Toggle Flycam\n\/\/ WASD \/ click + mouse to move\n\/\/ Shift = Move faster\n\n\/\/ YouTube Video Here: https:\/\/youtu.be\/bSg5nb_UTVM\n\n\/\/ ASCII Comments: http:\/\/patorjk.com\/software\/taag\/#p=display&h=2&c=c%2B%2B&f=Big&t=My%20Comment\n\n\/\/    _____                               _____ _               _                      _____          _   ______    \n\/\/   |_   _|                             \/ ____| |             | |                    |  __ \\        | | |  ____|   \n\/\/     | |  _ __ ___   __ _  __ _  ___  | (___ | |__   __ _  __| | ___ _ __   ______  | |__) |__  ___| |_| |____  __\n\/\/     | | | '_ ` _ \\ \/ _` |\/ _` |\/ _ \\  \\___ \\| '_ \\ \/ _` |\/ _` |\/ _ \\ '__| |______| |  ___\/ _ \\\/ __| __|  __\\ \\\/ \/\n\/\/    _| |_| | | | | | (_| | (_| |  __\/  ____) | | | | (_| | (_| |  __\/ |             | |  | (_) \\__ \\ |_| |   >  < \n\/\/   |_____|_| |_| |_|\\__,_|\\__, |\\___| |_____\/|_| |_|\\__,_|\\__,_|\\___|_|             |_|   \\___\/|___\/\\__|_|  \/_\/\\_\\\n\/\/                           __\/ |                                                                                  \n\/\/                          |___\/                                                                                   \n\nfloat Vignette( vec2 uv, float size )\n{\n    float d = length( (uv - 0.5f) * 2.0f ) \/ length(vec2(1.0));\n    \n    d \/= size;\n    \n    float s = d * d * ( 3.0f - 2.0f * d );\n    \n    float v = mix ( d, s, 0.6f );\n    \n    return max(0.0, 1.0f - v);\n}\n\n\nvec3 PostProcessColour( vec3 color )\n{\n#if EQUIRECTANGULAR_PROJECTION\n    float exposure = 0.5f;    \n    color = color * exposure;\n    \n    float gamma = 2.2f;    \n    color = pow( color, vec3( 1.0f \/ gamma ) );    \n#else\n    float exposure = 1.0f;    \n    color = color * exposure;\n    \n    color = 1.0f - exp( -color );    \n    float gamma = 2.2f;    \n    color = pow( color, vec3( 1.0f \/ gamma ) );\n            \n#endif\n    return color;\n}\n\n\n#define ENABLE_DOF\n\nfloat GetCoC( float fDistance, float fPlaneInFocus )\n{\n#ifdef ENABLE_DOF    \n\t\/\/ http:\/\/http.developer.nvidia.com\/GPUGems\/gpugems_ch23.html\n\n    float fAperture = min(1.0, fPlaneInFocus * fPlaneInFocus * 0.5);\n    float fFocalLength = 0.05;\n    \n\treturn abs(fAperture * (fFocalLength * (fDistance - fPlaneInFocus)) \/\n          (fDistance * (fPlaneInFocus - fFocalLength)));  \n#else\n    return 0.0f;\n#endif    \n}\n\nvec3 SampleWithDOF( ivec2 pos, float planeInFocus )\n{\n\tvec4 vCenterSample = texelFetch( iChannel0, pos, 0 );    \n    \n    \/\/return vec3(1) \/vCenterSample.w;\n    \n    float CoC = GetCoC( vCenterSample.w, planeInFocus );\n        \n\t#define DOF_SIZE 6\n    #define DOF_SIZE_F float( DOF_SIZE )\n    \n    #define DOF_BLOOM_STRENGTH 2.0\n    \n    CoC = CoC * 500.0;\n        \n    float testRadius = CoC * CoC;\n    \n    bool bloom = false;\n    if ( CoC <= 1.0f )\n    {\n        testRadius = DOF_SIZE_F;\n        bloom = true;\n    }\n    \n\tvec3 vResult = vec3(0.0);    \n    float fTot = 0.0;\n    \n    {\n        float fY = -DOF_SIZE_F;\n        for( int y=-DOF_SIZE; y<=DOF_SIZE; y++ )\n        {\n            float fX = -DOF_SIZE_F;\n            for( int x=-DOF_SIZE; x<=DOF_SIZE; x++ )\n            {            \n                vec2 vOffset = vec2( fX, fY );\n                float r2 = dot( vOffset, vOffset );\n                if ( r2 < testRadius )\n                {                \n                    ivec2 iOffset = ivec2( x,y );\n                    vec4 vTapSample = texelFetch( iChannel0, pos + iOffset, 0 );\n                    \n                    float fWeight = 1.0f;\n                    \n                    if ( bloom )\n                    {\n\t\t            \tfWeight = exp2( -r2 * DOF_BLOOM_STRENGTH );                        \n                    }\n                    \n                    vResult += vTapSample.rgb * fWeight;\n                    fTot += fWeight;\n                }\n                fX+=1.0f;\n            }\n            fY+=1.0f;\n        }\n    }\n    \n    vResult = vResult \/ fTot;\n    \n    return vResult;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n\n\tvec4 vCenterScreenSample = texelFetch( iChannel0, ivec2(iResolution.xy \/ 2.), 0 );\n    float planeInFocus = vCenterScreenSample.w;\n    \n#if EQUIRECTANGULAR_PROJECTION\n    vec3 sceneColour = texelFetch( iChannel0, ivec2( fragCoord ), 0 ).rgb;\n    \/\/vec3 sceneColour = SampleWithDOF( ivec2( fragCoord ), planeInFocus );\n    sceneColour*= 0.5;\n#else\n    vec3 sceneColour = SampleWithDOF( ivec2( fragCoord ), planeInFocus );\n    sceneColour.rgb *= 0.2 + 0.8 * Vignette( uv, 1.0 );\n#endif\n    \n    \n    vec3 outputColour = PostProcessColour( sceneColour.rgb );    \n\n#if 0\n    CameraState cam;\n    Cam_LoadState( cam, iChannel3, ivec2(0,0) );\n    \n    Cam_DebugOverlay( outputColour, cam, uv, planeInFocus );\n#endif\n        \n    fragColor = vec4(outputColour, 1.0);    \n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\/\/     _____                                           \n\/\/    \/ ____|                                          \n\/\/   | |      ___   _ __ ___   _ __ ___    ___   _ __  \n\/\/   | |     \/ _ \\ | '_ ` _ \\ | '_ ` _ \\  \/ _ \\ | '_ \\ \n\/\/   | |____| (_) || | | | | || | | | | || (_) || | | |\n\/\/    \\_____|\\___\/ |_| |_| |_||_| |_| |_| \\___\/ |_| |_|\n\/\/                                                     \n\/\/                                                     \n\n#define PI\t3.141592654\n#define TAU 6.283185308\n\n#define ZERO (min(0,iFrame))\n\n\n#define IOR_AIR \t1.0f\n#define IOR_WATER \t1.33f\n\n#define EQUIRECTANGULAR_PROJECTION 0\n\nfloat RadianceChange( float IA, float IB )\n{\n    float x = IB \/ IA;\n    return x * x;\n}\n\n\n\/\/  ____        _          ____  _                             \n\/\/ |  _ \\  __ _| |_ __ _  \/ ___|| |_ ___  _ __ __ _  __ _  ___ \n\/\/ | | | |\/ _` | __\/ _` | \\___ \\| __\/ _ \\| '__\/ _` |\/ _` |\/ _ \\\n\/\/ | |_| | (_| | || (_| |  ___) | || (_) | | | (_| | (_| |  __\/\n\/\/ |____\/ \\__,_|\\__\\__,_| |____\/ \\__\\___\/|_|  \\__,_|\\__, |\\___|\n\/\/                                                  |___\/      \n\/\/\n\nvec4 LoadVec4( sampler2D sampler, in ivec2 addr )\n{\n    return texelFetch( sampler, addr, 0 );\n}\n\nvec3 LoadVec3( sampler2D sampler, in ivec2 addr )\n{\n    return LoadVec4( sampler, addr ).xyz;\n}\n\nbool AtAddress( ivec2 p, ivec2 c ) { return all( equal( p, c ) ); }\n\nvoid StoreVec4( in ivec2 addr, in vec4 value, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    fragColor = AtAddress( fragCoord, addr ) ? value : fragColor;\n}\n\nvoid StoreVec3( in ivec2 addr, in vec3 value, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    StoreVec4( addr, vec4( value, 0.0 ), fragColor, fragCoord );\n}\n\n\/\/\n\/\/  ____       _        _   _             \n\/\/ |  _ \\ ___ | |_ __ _| |_(_) ___  _ __  \n\/\/ | |_) \/ _ \\| __\/ _` | __| |\/ _ \\| '_ \\ \n\/\/ |  _ < (_) | || (_| | |_| | (_) | | | |\n\/\/ |_| \\_\\___\/ \\__\\__,_|\\__|_|\\___\/|_| |_|\n\/\/                                        \n\/\/\n\nvec3 RotateX( const in vec3 pos, const in float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    \n    vec3 result = vec3( pos.x, c * pos.y + s * pos.z, -s * pos.y + c * pos.z );\n    \n    return result;\n}\n\nvec3 RotateY( const in vec3 pos, const in float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    \n    vec3 result = vec3( c * pos.x + s * pos.z, pos.y, -s * pos.x + c * pos.z );\n    \n    return result;\n}\n\nvec3 RotateZ( const in vec3 pos, const in float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    \n    vec3 result = vec3( c * pos.x + s * pos.y, -s * pos.x + c * pos.y, pos.z );\n    \n    return result;\n}\n\n\nmat3 MatFromAngles( vec3 angles )\n{\n    mat3 rotX = mat3(1.0, 0.0, 0.0, \n                     0.0, cos(angles.x), sin(angles.x), \n                     0.0, -sin(angles.x), cos(angles.x));\n    \n    mat3 rotY = mat3(cos(angles.y), 0.0, -sin(angles.y), \n                     0.0, 1.0, 0.0, \n                     sin(angles.y), 0.0, cos(angles.y));    \n\n    mat3 rotZ = mat3(cos(angles.z), sin(angles.z), 0.0,\n                     -sin(angles.z), cos(angles.z), 0.0,\n                     0.0, 0.0, 1.0 );\n    \n    \n    mat3 m = rotY * rotX * rotZ;\n    \n    return m;\n}\n\n\n\/\/   ___              _                  _             \n\/\/  \/ _ \\ _   _  __ _| |_ ___ _ __ _ __ (_) ___  _ __  \n\/\/ | | | | | | |\/ _` | __\/ _ \\ '__| '_ \\| |\/ _ \\| '_ \\ \n\/\/ | |_| | |_| | (_| | ||  __\/ |  | | | | | (_) | | | |\n\/\/  \\__\\_\\\\__,_|\\__,_|\\__\\___|_|  |_| |_|_|\\___\/|_| |_|\n\/\/                                                     \n\/\/\n\nvec4 QuatMul( vec4 lhs, vec4 rhs ) \n{\n      return vec4( lhs.y * rhs.z - lhs.z * rhs.y + lhs.x * rhs.w + lhs.w *rhs.x,\n                   lhs.z * rhs.x - lhs.x * rhs.z + lhs.y * rhs.w + lhs.w *rhs.y,\n                   lhs.x * rhs.y - lhs.y * rhs.x + lhs.z * rhs.w + lhs.w *rhs.z,\n                   lhs.w * rhs.w - lhs.x * rhs.x - lhs.y * rhs.y - lhs.z *rhs.z );\n}\n\nvec4 QuatFromAxisAngle( vec3 axis, float angle )\n{\n\treturn vec4( normalize(axis) * sin( angle ), cos( angle ) );    \n}\n\nvec4 QuatFromVec3( vec3 rot )\n{\n    float l = length( rot );\n    if ( l <= 0.0 )\n    {\n        return vec4( 0.0, 0.0, 0.0, 1.0 );\n    }\n    return QuatFromAxisAngle( rot, l );\n}\n\nmat3 QuatToMat3( const in vec4 q )\n{\n\tvec4 qSq = q * q;\n\tfloat xy2 = q.x * q.y * 2.0;\n\tfloat xz2 = q.x * q.z * 2.0;\n\tfloat yz2 = q.y * q.z * 2.0;\n\tfloat wx2 = q.w * q.x * 2.0;\n\tfloat wy2 = q.w * q.y * 2.0;\n\tfloat wz2 = q.w * q.z * 2.0;\n \n\treturn mat3 (\t\n     qSq.w + qSq.x - qSq.y - qSq.z, xy2 - wz2, xz2 + wy2,\n     xy2 + wz2, qSq.w - qSq.x + qSq.y - qSq.z, yz2 - wx2,\n     xz2 - wy2, yz2 + wx2, qSq.w - qSq.x - qSq.y + qSq.z );\n}\n\nvec3 QuatMul( vec3 v, vec4 q )\n{\n    \/\/ TODO Validate vs other quat code\n    vec3 t = 2.0 * cross(q.xyz, v);\n\treturn v + q.w * t + cross(q.xyz, t);\n}\n\n\/\/\n\/\/  _  __          _                         _ \n\/\/ | |\/ \/___ _   _| |__   ___   __ _ _ __ __| |\n\/\/ | ' \/\/ _ \\ | | | '_ \\ \/ _ \\ \/ _` | '__\/ _` |\n\/\/ | . \\  __\/ |_| | |_) | (_) | (_| | | | (_| |\n\/\/ |_|\\_\\___|\\__, |_.__\/ \\___\/ \\__,_|_|  \\__,_|\n\/\/           |___\/                             \n\/\/\n\nconst int KEY_SPACE = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\nconst int KEY_COMMA = 188;\nconst int KEY_PER   = 190;\n\nconst int KEY_1 = \t49;\nconst int KEY_2 = \t50;\nconst int KEY_3 = \t51;\nconst int KEY_ENTER = 13;\nconst int KEY_SHIFT = 16;\nconst int KEY_CTRL  = 17;\nconst int KEY_ALT   = 18;\nconst int KEY_TAB\t= 9;\n\nbool Key_IsPressed( sampler2D samp, int key )\n{\n    return texelFetch( samp, ivec2(key, 0), 0 ).x > 0.0;    \n}\n\nbool Key_IsToggled(sampler2D samp, int key )\n{\n    return texelFetch( samp, ivec2(key, 2), 0 ).x > 0.0;    \n}\n\n\/\/ ---- 8< ---- GLSL Number Printing - @P_Malin ---- 8< ----\n\/\/ Creative Commons CC0 1.0 Universal (CC-0) \n\/\/ https:\/\/www.shadertoy.com\/view\/4sBSWW\n\nfloat DigitBin( const int x )\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue( vec2 vStringCoords, float fValue, float fMaxDigits, float fDecimalPlaces )\n{       \n    if ((vStringCoords.y < 0.0) || (vStringCoords.y >= 1.0)) return 0.0;\n    \n    bool bNeg = ( fValue < 0.0 );\n\tfValue = abs(fValue);\n    \n\tfloat fLog10Value = log2(abs(fValue)) \/ log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n\t\t\tif((bNeg) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} else {\n                float fReducedRangeValue = fValue;\n                if(fDigitIndex < 0.0) { fReducedRangeValue = fract( fValue ); fDigitIndex += 1.0; }\n\t\t\t\tfloat fDigitValue = (abs(fReducedRangeValue \/ (pow(10.0, fDigitIndex))));\n                fCharBin = DigitBin(int(floor(mod(fDigitValue, 10.0))));\n\t\t\t}\n        }\n\t}\n    return floor(mod((fCharBin \/ pow(2.0, floor(fract(vStringCoords.x) * 4.0) + (floor(vStringCoords.y * 5.0) * 4.0))), 2.0));\n}\n\nvec3 CylinderProjectionToDir( vec2 uv )\n{\n    float theta = uv.x * TAU + 2.0;\n    float sy = sin(uv.y * PI);\n    float cy = -cos(uv.y * PI);\n    \n    vec2 mapDir = vec2( sin(theta), cos(theta) );\n    vec3 dir = vec3(mapDir.x * sy, cy, mapDir.y * sy);\n    return dir;\n}\n\n\/\/ ---- 8< -------- 8< -------- 8< -------- 8< ----\n\n\n\/\/\n\/\/   ____                               \n\/\/  \/ ___|__ _ _ __ ___   ___ _ __ __ _ \n\/\/ | |   \/ _` | '_ ` _ \\ \/ _ \\ '__\/ _` |\n\/\/ | |__| (_| | | | | | |  __\/ | | (_| |\n\/\/  \\____\\__,_|_| |_| |_|\\___|_|  \\__,_|\n\/\/                                      \n\n\nstruct CameraState\n{\n    vec3 vPos;\n    vec3 vTarget;\n    vec3 vUp;\n    float fFov;\n    vec2 vJitter;\n    float fPlaneInFocus;\n};\n    \nvoid Cam_LoadState( out CameraState cam, sampler2D sampler, ivec2 addr )\n{\n    vec4 vPos = LoadVec4( sampler, addr + ivec2(0,0) );\n    cam.vPos = vPos.xyz;\n    vec4 targetFov = LoadVec4( sampler, addr + ivec2(1,0) );\n    cam.vTarget = targetFov.xyz;\n    cam.fFov = targetFov.w;\n    vec4 vUp = LoadVec4( sampler, addr + ivec2(2,0) );\n    cam.vUp = vUp.xyz;\n    \n    vec4 jitterDof = LoadVec4( sampler, addr + ivec2(3,0) );\n    cam.vJitter = jitterDof.xy;\n    cam.fPlaneInFocus = jitterDof.z;\n}\n\nvoid Cam_StoreState( ivec2 addr, const in CameraState cam, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    StoreVec4( addr + ivec2(0,0), vec4( cam.vPos, 0 ), fragColor, fragCoord );\n    StoreVec4( addr + ivec2(1,0), vec4( cam.vTarget, cam.fFov ), fragColor, fragCoord );    \n    StoreVec4( addr + ivec2(2,0), vec4( cam.vUp, 0 ), fragColor, fragCoord );    \n    StoreVec4( addr + ivec2(3,0), vec4( cam.vJitter, cam.fPlaneInFocus, 0 ), fragColor, fragCoord );    \n}\n\nmat3 Cam_GetWorldToCameraRotMatrix( const CameraState cameraState )\n{\n    vec3 vForward = normalize( cameraState.vTarget - cameraState.vPos );\n\tvec3 vRight = normalize( cross( cameraState.vUp, vForward) );\n\tvec3 vUp = normalize( cross(vForward, vRight) );\n    \n    return mat3( vRight, vUp, vForward );\n}\n\nvec2 Cam_GetViewCoordFromUV( vec2 vUV, float fAspectRatio )\n{\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= fAspectRatio;\n\n\treturn vWindow;\t\n}\n\nvoid Cam_GetCameraRay( const vec2 vUV, const float fAspectRatio, const CameraState cam, out vec3 vRayOrigin, out vec3 vRayDir )\n{\n    vec2 vView = Cam_GetViewCoordFromUV( vUV, fAspectRatio );\n    vRayOrigin = cam.vPos;\n    float fPerspDist = 1.0 \/ tan( radians( cam.fFov ) );\n    vRayDir = normalize( Cam_GetWorldToCameraRotMatrix( cam ) * vec3( vView, fPerspDist ) );\n    #if EQUIRECTANGULAR_PROJECTION\n    vRayDir = CylinderProjectionToDir(vUV);\n    #endif\n}\n\n\/\/ fAspectRatio = iResolution.x \/ iResolution.y;\nvec2 Cam_GetUVFromWindowCoord( const in vec2 vWindow, float fAspectRatio )\n{\n    vec2 vScaledWindow = vWindow;\n    vScaledWindow.x \/= fAspectRatio;\n\n    return (vScaledWindow * 0.5 + 0.5);\n}\n\nvec2 Cam_WorldToWindowCoord(const in vec3 vWorldPos, const in CameraState cameraState )\n{\n    vec3 vOffset = vWorldPos - cameraState.vPos;\n    vec3 vCameraLocal;\n\n    vCameraLocal = vOffset * Cam_GetWorldToCameraRotMatrix( cameraState );\n\t\n    vec2 vWindowPos = vCameraLocal.xy \/ (vCameraLocal.z * tan( radians( cameraState.fFov ) ));\n    \n    return vWindowPos;\n}\n\nvoid Cam_DebugOverlay( inout vec3 colour, CameraState cam, vec2 uv, float depth )\n{\n    vec2 pos = uv * vec2(80,30);\n    pos.x -= 2.0;\n    pos.y -= 28.0;\n    \n    if ( pos.x > -0.5 && pos.y < 1.5 && pos.x < 40.5 && pos.y > -4.5 )\n    {\n        colour = vec3(0);\n    }\n    \n    vec2 hpos = pos;\n    colour = mix( colour, vec3(0,0,1), PrintValue( hpos, cam.vPos.x, 3.0, 3.0 ) );\n    hpos.x -= 10.0;\n    colour = mix( colour, vec3(0,0,1), PrintValue( hpos, cam.vPos.y, 3.0, 3.0 ) );\n    hpos.x -= 10.0;\n    colour = mix( colour, vec3(0,0,1), PrintValue( hpos, cam.vPos.z, 3.0, 3.0 ) );\n    hpos.x -= 10.0;\n    \n    pos.y += 1.3;\n    \n\thpos = pos;\n    colour = mix( colour, vec3(1,0,1), PrintValue( hpos, cam.vTarget.x, 3.0, 3.0 ) );\n    hpos.x -= 10.0;\n    colour = mix( colour, vec3(1,0,1), PrintValue( hpos, cam.vTarget.y, 3.0, 3.0 ) );\n    hpos.x -= 10.0;\n    colour = mix( colour, vec3(1,0,1), PrintValue( hpos, cam.vTarget.z, 3.0, 3.0 ) );\n    hpos.x -= 10.0;\n    \n    pos.y += 1.3;\n    \n\thpos = pos;\n    colour = mix( colour, vec3(0,1,0), PrintValue( hpos, cam.fFov, 3.0, 3.0 ) );\n    hpos.x -= 10.0;\n    colour = mix( colour, vec3(0,1,0), PrintValue( hpos, depth, 3.0, 3.0 ) );\n    \n    \n    vec3 vDir = normalize(cam.vTarget - cam.vPos);\n    vec3 vTarget2 = cam.vPos + vDir * depth;\n    \n    pos.y += 1.3;\n    \n\thpos = pos;\n    colour = mix( colour, vec3(0,1,1), PrintValue( hpos, vTarget2.x, 3.0, 3.0 ) );\n    hpos.x -= 10.0;\n    colour = mix( colour, vec3(0,1,1), PrintValue( hpos, vTarget2.y, 3.0, 3.0 ) );\n    hpos.x -= 10.0;\n    colour = mix( colour, vec3(0,1,1), PrintValue( hpos, vTarget2.z, 3.0, 3.0 ) );\n    hpos.x -= 10.0;    \n}\n\n\/\/  _   _           _       _____                 _   _                 \n\/\/ | | | | __ _ ___| |__   |  ___|   _ _ __   ___| |_(_) ___  _ __  ___ \n\/\/ | |_| |\/ _` \/ __| '_ \\  | |_ | | | | '_ \\ \/ __| __| |\/ _ \\| '_ \\\/ __|\n\/\/ |  _  | (_| \\__ \\ | | | |  _|| |_| | | | | (__| |_| | (_) | | | \\__ \\\n\/\/ |_| |_|\\__,_|___\/_| |_| |_|   \\__,_|_| |_|\\___|\\__|_|\\___\/|_| |_|___\/\n\/\/                                                                      \n\n\/\/ From: Hash without Sine by Dave Hoskins\n\/\/ https:\/\/www.shadertoy.com\/view\/4djSRW\n\n\/\/ *** Use this for integer stepped ranges, ie Value-Noise\/Perlin noise functions.\n\/\/#define HASHSCALE1 .1031\n\/\/#define HASHSCALE3 vec3(.1031, .1030, .0973)\n\/\/#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\n\/\/ For smaller input rangers like audio tick or 0-1 UVs use these...\n#define HASHSCALE1 443.8975\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n#define HASHSCALE4 vec3(443.897, 441.423, 437.195, 444.129)\n\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ Hash without Sine\n\/\/ MIT License...\n\/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and\/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*\/\n\n\/\/----------------------------------------------------------------------------------------\n\/\/  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/\/  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/\/  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n\/\/----------------------------------------------------------------------------------------\n\/\/\/  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/\/  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n\n\/\/ https:\/\/iquilezles.org\/articles\/intersectors\n\/\/ sphere of size ra centered at point ce\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); \/\/ no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/smin\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)\/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/smin\nfloat smax( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)\/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Smoothnoise\n\nvec2 SmoothNoise22( vec2 o ) \n{\n\tvec2 p = floor(o);\n\tvec2 f = fract(o);\n\t\t\n\tfloat n = p.x + p.y*57.0;\n\n\tvec2 a = hash21(n+  0.0);\n\tvec2 b = hash21(n+  1.0);\n\tvec2 c = hash21(n+ 57.0);\n\tvec2 d = hash21(n+ 58.0);\n\t\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\t\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\t\n\tfloat u = t.x;\n\tfloat v = t.y;\n\n\tvec2 res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n    \n    return res;\n}\n\n\nvec3 SmoothNoise32( vec2 o ) \n{\n\tvec2 p = floor(o);\n\tvec2 f = fract(o);\n\t\t\n\tfloat n = p.x + p.y*57.0;\n\n\tvec3 a = hash31(n+  0.0);\n\tvec3 b = hash31(n+  1.0);\n\tvec3 c = hash31(n+ 57.0);\n\tvec3 d = hash31(n+ 58.0);\n\t\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\t\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\t\n\tfloat u = t.x;\n\tfloat v = t.y;\n\n\tvec3 res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n    \n    return res;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Sky \/ Environment sampling\n\t   \nstruct EnvironmentSettings\n{\n    float time;\n    \n    vec3 skyZenithCol;\n    vec3 skyHorizonCol;\n    \n    vec3 sunDiscCol;\n    vec3 sunLightCol;\n    \n    vec3 ambientCol;\n    \n    float sunElevation;\n    float sunHeading;\n    vec3 sunDir;\n    \n    vec3 fogCol;\n    float fogDensity;\n    float skyFogDensity;\n};\n\nfloat CloudSample( sampler2D iChannel, vec2 uv, float time, float spread )\n{\n    vec2 cloudUV0 = uv;\n    cloudUV0 += time * 0.0005;\n    vec2 cloudUV1 = cloudUV0 * 2.0f; \n    cloudUV1 += time * 0.0005;\n    float cloudSampleA0 = texture( iChannel, cloudUV0, spread ).r;    \n    float cloudSampleA1 = texture( iChannel, cloudUV1, spread ).b;\n\tfloat cloudDensityA = cloudSampleA0 * 0.7 + cloudSampleA1 * 0.3;\n    \n    return cloudDensityA;\n}\n\nvec4 TraceSky( EnvironmentSettings env, sampler2D iChannel, vec3 dir, float time, float spread, bool sunDisc )\n{       \n    \/\/ sky gradient\n    float f = clamp( 1.0 - dir.y, 0.0f, 1.0f );    \n    f = f * f * f * f;\n    vec3 col = mix( env.skyZenithCol, env.skyHorizonCol, f );    \n    \n    \/\/ sun disc\n    float VdotL = dot( dir, env.sunDir );        \n    \n    if ( sunDisc )\n    {\n        const float a0 = cos( radians( 1.0 ) );\n        const float a1 = cos( radians( 0.8 ) );\n\n        float sunBlend = smoothstep( a0, a1, VdotL );\n        col = mix( col, env.sunDiscCol, sunBlend );    \n    }\n    \n    float dist = 100000.0;\n    \n    \/\/ cloud layer \n    if ( dir.y > 0.0 )\n    {\n        float earthRadius = 6371000.0f;\n        vec3 earthOrigin = vec3(0.0f, -earthRadius, 0.0f );\n        float cloudHeight = 6000.0f;\n        float cloudRadius = earthRadius + cloudHeight;\n\n        vec2 cloudInt = sphIntersect( vec3(0), dir, earthOrigin, cloudRadius );\n        float cloudT = cloudInt.y;\n        \n        dist = cloudT;\n\n\n        vec3 cloudPos = dir * cloudT;\n\n        vec3 cloudN = normalize( cloudPos - earthOrigin );\n\n        vec2 cloudUV = cloudPos.xz * 0.00001f;\n        float cloudDensityA = CloudSample( iChannel, cloudUV, time, spread );\n        float bumpOffset = 0.0003f;\n        float cloudDensityB = CloudSample( iChannel, cloudUV - env.sunDir.xz * bumpOffset, time, spread );\n\n        float cloudDensity = (cloudDensityA + cloudDensityB) * 0.5;\n\n        \/\/ bumpmap towards sun\n        float cloudBumpLight = max( 0.0f, (cloudDensityB - cloudDensityA) * 1.5 + 0.5);\n\n        float sunThicknessFactor = 1.0 \/ dot( cloudN, env.sunDir );\n        \n        sunThicknessFactor = abs( sunThicknessFactor );\n\n\n        float toSunFactor = 1.0 - max( 0.0, dot(dir, env.sunDir));\n        float toSunAmount = exp( toSunFactor * -20.0 );\n        \n        float cloudSunLight = cloudBumpLight * (1.0 + toSunAmount * 2.5);\n\n        float viewThicknessFactor = 1.0 \/ dot( cloudN, dir );\n\n        float cover = 0.2;\n        float density = 0.1;\n\n        float thickness = max( 0.0, (cloudDensity - cover) \/ (1.0 - cover) );\n\n        float cloudOpticalDepth = thickness * viewThicknessFactor;\n        float sunCloudOpticalDepth = thickness * sunThicknessFactor;\n        \n        vec3 litCloudCol = env.sunLightCol * cloudSunLight * ( exp( sunCloudOpticalDepth * -density ) ) * 10.0; \n        vec3 cloudCol = litCloudCol + env.ambientCol;\n\n\n        float cloudBlend = 1.0 - exp( cloudOpticalDepth * -density );\n        col = mix( col, cloudCol, cloudBlend );       \n    }\n    \n    return vec4( col, dist );   \n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Terrain Height\n\n\nfloat Terrain_GetShape( vec2 mapPos )\n{\n    float d = length(mapPos);\n        \n    float h = SmoothNoise22( mapPos * 0.02 ).x * 100.0 + 50.0;\n\n   \treturn min( h, d );\n}\n\nfloat Terrain_GetBaseHeight( vec2 mapPos )\n{\n    float dist = Terrain_GetShape( mapPos );\n    float hIsland = 2.0 - dist * dist * 0.0005;\n\n\treturn hIsland;\n}\n\nvec3 GetRockSample( sampler2D rockSampler, vec2 mapPos, float mipLod )\n{\n    vec2 uv = mapPos * 0.1;\n    vec3 textureSample = textureLod( rockSampler, uv.yx, mipLod ).rgb;\n    \/\/textureSample.r = (textureSample.r - textureSample.g) \/ (1.0f - textureSample.g);\n    return textureSample = textureSample * textureSample;\n}\n\n\n\nvec2 Terrain_GetHeights( sampler2D rockSampler,vec2 mapPos, bool detail )\n{\n    \/\/h = 1.0 - exp( h * -1. );\n    \/\/float dist = length( mapPos );\n    \n    vec2 smoothNoise = SmoothNoise22( mapPos * 20.0 );\n        \n    float h0 = Terrain_GetBaseHeight( mapPos );\n    \n    float rockRelief = 0.05;\n    \n    \/\/ + smoothNoise.y\n    float rockScale = smoothstep( 2.0, -2.5, h0 );\n    \/\/rockScale -= (smoothNoise.y - 0.5) * 0.25;\n    vec3 rockSample = GetRockSample( rockSampler, mapPos, 0.0 );\n    float rockh = h0 + ((rockSample.g * rockSample.b) - 1.0 + rockScale * 1.5 ) * rockRelief ;\/\/ + rockScale - 2.0 * (1.0 - rockScale);\n    \n    \/\/h += hIsland + 10.0;\n    \/\/h = smax( h, hIsland, 0.5 );\n\n    \/\/h= hIsland - h;\n    \n    \/\/h = 1.0 - exp( h * -0.5 );\n    float h = h0 + smoothNoise.x * 0.001;\n    \n    if ( detail )\n    {\n        float sandWaveBlend = smoothstep( 0.5, 1.5, h );\n        float f = mapPos.y * 20.0 + sin( mapPos.x * 0.3) * 10.0+ cos( mapPos.x * 0.5) * 10.0;\n        \n    \tfloat w = sin(f) * 0.5 + 0.5;\n    \n    \tw = pow ( 1.0 - w, 1.5 );        \n        \n        float wave = w * 0.005 * sandWaveBlend;\n        \n        float rough = SmoothNoise22( mapPos * 2.0 ).x * 0.03;\n        \n        h += mix( wave, rough, smoothstep( 1.3, 1.5, h ) );\n        \n        h += SmoothNoise22( mapPos * 1.0 ).x * 0.02;\n\t    h += SmoothNoise22( mapPos * 1000.0 ).x * 0.001;\t\n    \n        \/\/ todo: footsteps?\n        \/\/h += (0.5 - textureLod( iChannel2, mapPos * 0.1, 0.0 ).r) * 0.1;\n    \n#if 1\n        if ( h > rockh )\n        {\n\t        float delta = h - rockh;\n            float amount = exp2( -delta * 50.0 );\n            h -= amount * 0.01;\n        }\n#endif     \n            \n    }\n    \n    return vec2(h,rockh);\n}\n\n\nfloat Terrain_GetHeight( sampler2D rockSampler, vec2 mapPos, bool detail, bool onlySand )\n{\n    vec2 heights = Terrain_GetHeights( rockSampler, mapPos, detail );   \n\n    if ( onlySand )\n        return heights.x;\n    \n    return max( heights.x, heights.y );\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sfGRn","filepath":"\/media\/a\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"\/media\/ap\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"\/presets\/tex00.jpg","previewfilepath":"\/presets\/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/     _____                                       _____  _          _        \n\/\/    \/ ____|                                     \/ ____|| |        | |       \n\/\/   | |      __ _  _ __ ___    ___  _ __  __ _  | (___  | |_  __ _ | |_  ___ \n\/\/   | |     \/ _` || '_ ` _ \\  \/ _ \\| '__|\/ _` |  \\___ \\ | __|\/ _` || __|\/ _ \\\n\/\/   | |____| (_| || | | | | ||  __\/| |  | (_| |  ____) || |_| (_| || |_|  __\/\n\/\/    \\_____|\\__,_||_| |_| |_| \\___||_|   \\__,_| |_____\/  \\__|\\__,_| \\__|\\___|\n\/\/                                                                            \n\/\/                                                                            \n\n#define iChannelState\t\t\tiChannel0\n#define iChannelRockTexture\t\tiChannel1\n#define iChannelKeyboard \t\tiChannel3\n\n#define FLY_CAM_INVERT_Y 1\n\n\/\/   __          __             _           _                _____                               \n\/\/   \\ \\        \/ \/            | |         (_)              \/ ____|                              \n\/\/    \\ \\  \/\\  \/ \/_ _ _ __   __| | ___ _ __ _ _ __   __ _  | |     __ _ _ __ ___   ___ _ __ __ _ \n\/\/     \\ \\\/  \\\/ \/ _` | '_ \\ \/ _` |\/ _ \\ '__| | '_ \\ \/ _` | | |    \/ _` | '_ ` _ \\ \/ _ \\ '__\/ _` |\n\/\/      \\  \/\\  \/ (_| | | | | (_| |  __\/ |  | | | | | (_| | | |___| (_| | | | | | |  __\/ | | (_| |\n\/\/       \\\/  \\\/ \\__,_|_| |_|\\__,_|\\___|_|  |_|_| |_|\\__, |  \\_____\\__,_|_| |_| |_|\\___|_|  \\__,_|\n\/\/                                                   __\/ |                                       \n\/\/                                                  |___\/                                        \n\nstruct WanderCamState\n{\n    vec3 pos;\n    vec3 lookAt;\n    \n    float targetAngle;\n    float lookAtAngle;\n    \n    float eyeHeight;\n\n    float timer;\n    \n    float shoreDistance;\n    \n    int iSitting;\n    \n    float lookAtElevation;\n};\n\nvoid WanderCam_LoadState( out WanderCamState wanderCam, sampler2D sampler, ivec2 addr )\n{\n    vec4 vPos = LoadVec4( sampler, addr + ivec2(0,0) );\n    wanderCam.pos = vPos.xyz;\n    vec4 vLookAt = LoadVec4( sampler, addr + ivec2(1,0) );\n    wanderCam.lookAt = vLookAt.xyz;\n    vec4 vMisc = LoadVec4( sampler, addr + ivec2(2,0) );    \n    wanderCam.targetAngle = vMisc.x;\n    wanderCam.lookAtAngle = vMisc.y;\n    wanderCam.eyeHeight = vMisc.z;\n    wanderCam.timer = vMisc.w;\n    \n    vec4 vMisc2 = LoadVec4( sampler, addr + ivec2(3,0) );    \n    wanderCam.iSitting = int( vMisc2.y );\n    wanderCam.shoreDistance = vMisc2.z;\n    wanderCam.lookAtElevation = vMisc2.w;\n}\n\nvoid WanderCam_StoreState( ivec2 addr, const WanderCamState wanderCam, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    StoreVec4( addr + ivec2(0,0), vec4( wanderCam.pos, 0 ), fragColor, fragCoord );\n    StoreVec4( addr + ivec2(1,0), vec4( wanderCam.lookAt, 0 ), fragColor, fragCoord );\n    StoreVec4( addr + ivec2(2,0), vec4( wanderCam.targetAngle, wanderCam.lookAtAngle, wanderCam.eyeHeight, wanderCam.timer ), fragColor, fragCoord );\n    StoreVec4( addr + ivec2(3,0), vec4( 0, wanderCam.iSitting, wanderCam.shoreDistance, wanderCam.lookAtElevation ), fragColor, fragCoord );\n}\n\nvoid WanderCam_Init( inout WanderCamState wanderCam )\n{\n    if ( iFrame == 0 )\n    {\n        wanderCam.pos = vec3(0, 2, 40);\n        wanderCam.lookAt = vec3(0,2,10);\n        wanderCam.targetAngle = 0.;\n        wanderCam.lookAtAngle = 0.3;\n        wanderCam.lookAtElevation = -0.3;\n        wanderCam.eyeHeight = 1.5;\n\t\twanderCam.timer = 5.0;\n        wanderCam.iSitting = 0;\n        wanderCam.shoreDistance = 5.;\n    }\n}\n\nvec2 WanderCam_GetTarget( WanderCamState wanderCam )\n{\n    float theta = wanderCam.targetAngle;\n    return vec2( sin( theta ), cos( theta ) ) * (60.0 - wanderCam.shoreDistance);\n}\n\nvec3 WanderCam_GetLookAt( WanderCamState wanderCam )\n{\n    float theta = wanderCam.lookAtAngle;\n    float phi = wanderCam.lookAtElevation;\n    return vec3( sin( theta ) * cos(phi), sin(phi), cos( theta ) * cos(phi) );\n}\n\nvoid WanderCam_Update( inout WanderCamState wanderCam )\n{\n    vec2 target = WanderCam_GetTarget( wanderCam );\n    vec2 toTarget = target - wanderCam.pos.xz;\n    \n    float len = length( toTarget );\n    \n    if ( len > 0.0 )\n    {\n        float moveRate = min( len * 0.5, 1.0 );\n\t    float currSpeed = 0.04f * moveRate;\n        \n        float speed = min( len, currSpeed );\n        vec2 delta = normalize( toTarget ) * speed;\n\n        wanderCam.pos.xz += delta;\n    }\n    \n    if ( len < 0.1 )\n    {\n        wanderCam.timer -= iTimeDelta;\n        if ( wanderCam.timer < 0.0 )\n        {\n            \/\/ do something different\n            float rnd = hash11(iTime + 31.);\n\n            if ( rnd < 0.1 )                \n            {\n                \/\/ extend timer\n                wanderCam.timer = 2.0;\n            }\n\t\t\telse\n            if ( rnd < 0.4 )\n            {\n                \/\/ change lookat target\n                wanderCam.lookAtAngle = hash11(iTime+7.) * 2. - 1.;\n                wanderCam.lookAtElevation = hash11(iTime+29.) * -0.6 + 0.1;\n                wanderCam.timer = 2.0;\n            }\n            else\n            {\n                \/\/ random chance to sit here if we haven't\n                float rndSit = hash11(iTime + 45.);\n                if ( wanderCam.iSitting == 0 && rndSit < 0.25 )\n                {\n                    wanderCam.iSitting = 1;\n                    wanderCam.timer = 1.5;\n                }\n                else\n                {\n                    if ( wanderCam.iSitting == 1 )\n                    {\n\t                    \/\/ stand up\n                        wanderCam.iSitting = -1; \/\/ don't sit again\n                        wanderCam.timer = 1.5;\n                    }\n                    else\n                    {\n                        \/\/ Move to a different location\n                        wanderCam.targetAngle += (hash11(iTime) - 0.5) * 0.5;\n                        wanderCam.targetAngle = clamp( wanderCam.targetAngle, -1.5, 1.5);\n                        wanderCam.shoreDistance = hash11(iTime+27.) * 5.0;\n                        wanderCam.timer = 5.0;\n                    }                    \n                }                \n            }           \n        }        \n    }\n    else\n    {\n        wanderCam.iSitting = 0;\n    }\n\n    float targeth = 1.5;\n    if ( wanderCam.iSitting != 0 )\n    {\n    \ttargeth = 0.9;\n    }\n    \n    wanderCam.eyeHeight = wanderCam.eyeHeight + (targeth - wanderCam.eyeHeight) * 0.03;\n    \n    wanderCam.pos.y = Terrain_GetHeight( iChannelRockTexture, wanderCam.pos.xz, false, true );\n    wanderCam.pos.y += wanderCam.eyeHeight;\n\n    vec3 lookAt = WanderCam_GetLookAt( wanderCam );\n    \n    vec3 idealLookAt = lookAt;\n    wanderCam.lookAt = wanderCam.lookAt + (idealLookAt - wanderCam.lookAt) * 0.01;\n}\n\n\/\/    _____ _          ____                \n\/\/   |  ___| |_   _   \/ ___|__ _ _ __ ___  \n\/\/   | |_  | | | | | | |   \/ _` | '_ ` _ \\ \n\/\/   |  _| | | |_| | | |__| (_| | | | | | |\n\/\/   |_|   |_|\\__, |  \\____\\__,_|_| |_| |_|\n\/\/            |___\/                        \n\/\/\n\nstruct FlyCamState\n{\n    vec3 vPos;\n    vec3 vAngles;\n    vec4 vPrevMouse;\n};\n\nvoid FlyCam_LoadState( out FlyCamState flyCam, sampler2D sampler, ivec2 addr )\n{\n    vec4 vPos = LoadVec4( sampler, addr + ivec2(0,0) );\n    flyCam.vPos = vPos.xyz;\n    vec4 vAngles = LoadVec4( sampler, addr + ivec2(1,0) );\n    flyCam.vAngles = vAngles.xyz;\n    vec4 vPrevMouse = LoadVec4( sampler, addr + ivec2(2,0) );    \n    flyCam.vPrevMouse = vPrevMouse;\n}\n\nvoid FlyCam_StoreState( ivec2 addr, const in FlyCamState flyCam, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    StoreVec4( addr + ivec2(0,0), vec4( flyCam.vPos, 0 ), fragColor, fragCoord );\n    StoreVec4( addr + ivec2(1,0), vec4( flyCam.vAngles, 0 ), fragColor, fragCoord );\n    StoreVec4( addr + ivec2(2,0), vec4( iMouse ), fragColor, fragCoord );\n}\n\nmat3 Mat_FromAngles( vec3 vAngles )\n{\n    mat3 rotX = mat3(1.0, 0.0, 0.0, \n                     0.0, cos(vAngles.x), sin(vAngles.x), \n                     0.0, -sin(vAngles.x), cos(vAngles.x));\n    \n    mat3 rotY = mat3(cos(vAngles.y), 0.0, -sin(vAngles.y), \n                     0.0, 1.0, 0.0, \n                     sin(vAngles.y), 0.0, cos(vAngles.y));    \n\n    mat3 rotZ = mat3(cos(vAngles.z), sin(vAngles.z), 0.0,\n                     -sin(vAngles.z), cos(vAngles.z), 0.0,\n                     0.0, 0.0, 1.0 );\n    \n    \n    return rotY * rotX * rotZ;    \n}\n\nvoid FlyCam_GetAxes( FlyCamState flyCam, out vec3 vRight, out vec3 vUp, out vec3 vForwards )\n{\n    vec3 vAngles = flyCam.vAngles;\n    \n    mat3 m = Mat_FromAngles( vAngles );\n    \n    vRight = m[0];\n    vUp = m[1];\n    vForwards = m[2];\n}\n\nvoid FlyCam_Init( inout FlyCamState flyCam, vec3 vStartPos, vec3 vStartAngles )\n{\n    if ( iFrame == 0 )\n    {\n        flyCam.vPos = vStartPos;\n        flyCam.vAngles = vStartAngles;\n        flyCam.vPrevMouse = iMouse;    \n    }\n}\n\nvoid FlyCam_Update( inout FlyCamState flyCam )\n{    \n    \/\/float fMoveSpeed = 0.01;\n    float fMoveSpeed = iTimeDelta * 4.0;\n    float fRotateSpeed = 3.0;\n    \n    if ( Key_IsPressed( iChannelKeyboard, KEY_SHIFT ) )\n    {\n        fMoveSpeed *= 4.0;\n    }\n          \n    vec3 vMove = vec3(0.0);\n        \n    if ( Key_IsPressed( iChannelKeyboard, KEY_W ) )\n    {\n        vMove.z += fMoveSpeed;\n    }\n    if ( Key_IsPressed( iChannelKeyboard, KEY_S ) )\n    {\n        vMove.z -= fMoveSpeed;\n    }\n\n    if ( Key_IsPressed( iChannelKeyboard, KEY_A ) )\n    {\n        vMove.x -= fMoveSpeed;\n    }\n    if ( Key_IsPressed( iChannelKeyboard, KEY_D ) )\n    {\n        vMove.x += fMoveSpeed;\n    }\n    \n    vec3 vForwards, vRight, vUp;\n    FlyCam_GetAxes( flyCam, vRight, vUp, vForwards );\n        \n    flyCam.vPos += vRight * vMove.x + vForwards * vMove.z;\n    \n    vec3 vRotate = vec3(0);\n    \n    bool bMouseDown = iMouse.z > 0.0;\n    bool bMouseWasDown = flyCam.vPrevMouse.z > 0.0;\n    \n    if ( bMouseDown && bMouseWasDown )\n    {\n    \tvRotate.yx += ((iMouse.xy - flyCam.vPrevMouse.xy) \/ iResolution.xy) * fRotateSpeed;\n    }\n    \n#if FLY_CAM_INVERT_Y    \n    vRotate.x *= -1.0;\n#endif    \n    \n    if ( Key_IsPressed( iChannelKeyboard, KEY_E ) )\n    {\n        vRotate.z -= fRotateSpeed * 0.01;\n    }\n    if ( Key_IsPressed( iChannelKeyboard, KEY_Q ) )\n    {\n        vRotate.z += fRotateSpeed * 0.01;\n    }\n        \n\tflyCam.vAngles += vRotate;\n    \n    flyCam.vAngles.x = clamp( flyCam.vAngles.x, -PI * .5, PI * .5 );\n}\n\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iAddr = ivec2(fragCoord.xy);\n    if ( iAddr.y != 0 || iAddr.x > 16 ) \n    {\n        discard; \n        return;\n    }\n    \n\tfragColor = vec4(0.0f, 0.0f, 0.0f, 1.0f);\n    \n   \/\/ Setup Cam\n    CameraState cam;\n    \n    \/\/ Set defaults\n    \n    vec3 vCameraInitialPos = vec3(-0.1, 5.0, 3.5);\n    \n    cam.vPos = vCameraInitialPos;\n    cam.vTarget =  vCameraInitialPos + vec3(0,0, 3.0);\n    cam.vUp = vec3(0,1,0);\n    cam.fFov = 25.0;\n    cam.fPlaneInFocus = length(cam.vTarget - cam.vPos);\n    cam.vJitter = vec2(0.0);        \n        \n    WanderCamState wanderCam;\n    WanderCam_LoadState( wanderCam, iChannelState, ivec2(11,0) );\n    \n    WanderCam_Init( wanderCam );\n \n    \n    \/\/ Update FlyCam\n    FlyCamState flyCam;\n    FlyCam_LoadState( flyCam, iChannelState, ivec2(8,0) );\n    \n    float pitch = 0.1;\n    \n\tFlyCam_Init( flyCam, vCameraInitialPos, vec3(pitch, 0.0, 0) );    \n\n    if ( Key_IsToggled( iChannelKeyboard, KEY_SPACE ) )\n    {    \n        FlyCam_Update( flyCam );\n\n        vec3 vForwards, vRight, vUp;\n        FlyCam_GetAxes( flyCam, vRight, vUp, vForwards );\n\n        cam.vPos = flyCam.vPos;\n        cam.vTarget = flyCam.vPos + vForwards;\n        cam.vUp = vUp;\n        cam.fPlaneInFocus = length(flyCam.vPos);        \n\n        cam.fPlaneInFocus = -1.0; \/\/ auto focus\n    }\n    else\n    {\n\t\tWanderCam_Update( wanderCam );\n        \n        \/\/ set cam from wander cam\n        cam.vPos = wanderCam.pos;\n        cam.vTarget = wanderCam.pos + wanderCam.lookAt;\n        \n        vec3 vNoise = SmoothNoise32( cam.vPos.xz + iTime * 0.5 );\n        \n        vec3 vShakyCamAngles = (vNoise - 0.5) * vec3( 0.05, 0.03, 0.01 );\n        mat3 m = Mat_FromAngles( vShakyCamAngles );\n        \n        vec3 vToTarget = cam.vTarget - cam.vPos;\n        cam.vTarget = cam.vPos + vToTarget * m;\n        \n        cam.vUp = vec3(0,1,0) * m;\n        \n        \/\/ update flycam position from wander cam\n        flyCam.vPos = cam.vPos;\n        vec3 vDir = cam.vTarget - cam.vPos;\n        flyCam.vAngles = vec3( 0, atan(vDir.x, vDir.z), 0);\n    }\n\n    \n#ifdef ENABLE_TAA_JITTER\n    cam.vJitter = hash21( fract( iTime ) ) - 0.5f;\n#endif    \n\n\tCam_StoreState( ivec2(0), cam, fragColor, iAddr );    \n    FlyCam_StoreState( ivec2(8,0), flyCam, fragColor, iAddr );\n    WanderCam_StoreState( ivec2(11,0), wanderCam, fragColor, iAddr );\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4sfGRn","filepath":"\/media\/a\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"\/media\/ap\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\/\/    __  __         _           _____                           _____                   _             \n\/\/   |  \\\/  |       (_)         \/ ____|                         |  __ \\                 | |            \n\/\/   | \\  \/ |  __ _  _  _ __   | (___    ___  ___  _ __    ___  | |__) | ___  _ __    __| |  ___  _ __ \n\/\/   | |\\\/| | \/ _` || || '_ \\   \\___ \\  \/ __|\/ _ \\| '_ \\  \/ _ \\ |  _  \/ \/ _ \\| '_ \\  \/ _` | \/ _ \\| '__|\n\/\/   | |  | || (_| || || | | |  ____) || (__|  __\/| | | ||  __\/ | | \\ \\|  __\/| | | || (_| ||  __\/| |   \n\/\/   |_|  |_| \\__,_||_||_| |_| |_____\/  \\___|\\___||_| |_| \\___| |_|  \\_\\\\___||_| |_| \\__,_| \\___||_|   \n\/\/                                                                                                     \n\/\/                                                                                                     \n\n#define iChannelState\t\t\tiChannel0\n#define iChannelRockTexture\t\tiChannel1\n\n\nEnvironmentSettings GetEnvironmentSettings()\n{\n    EnvironmentSettings env;\n    \n    env.time = iTime;\n\n    env.sunElevation = (0.2f * PI * 0.5);\n    env.sunHeading = (PI * 0.15);\n    \n#if 1\n    \/\/ day\n    env.skyZenithCol = vec3( 0.005f, 0.1f, 1.0f ) * 0.3;\n    env.skyHorizonCol = vec3( 0.1f, 0.4f, 1.0f ) * 1.0;\n    \n\tvec3 sunCol = vec3(1.0f, 0.95f, 0.65f);\n    \n    env.fogCol =  vec3( 0.6, 0.85, 0.9 ) * 2.0;\n    \n    env.sunDiscCol = sunCol * 4096.0;\n    env.sunLightCol = sunCol * 2.0;\n    \n#endif\n    \n#if 0\n    \/\/ sunset-ish\n    env.sunElevation = (0.05f * PI * 0.5);\n    \n    env.skyZenithCol = vec3(1,0.2,0) * 0.25;\n    env.skyHorizonCol = vec3( 1,0,0);\n    \n\tvec3 sunCol = vec3(1.0f, 0.25f, 0.001f);\n    \n    env.fogCol =  vec3( 1.0, 0.5, 0.0 );\n    \n    env.sunDiscCol = sunCol * 64.0;\n    env.sunLightCol = sunCol * 2.0;\n    \n#endif\n    \n#if 0\n    \/\/ night-ish\n    env.skyZenithCol = vec3(0,0,0.001);\n    env.skyHorizonCol = vec3( 0,0.01,0.05);\n    \n\tvec3 sunCol = vec3(0.2f);\n    env.sunElevation = (0.1f * PI * 0.5);\n    \n    env.fogCol =  env.skyHorizonCol;\n    \n    env.sunDiscCol = sunCol * 32.0;\n    env.sunLightCol = sunCol;\/\/ * 2.0;\n    \n#endif\n    \n#if 0\n    \/\/ Hello darkness my old friend. I've found some bugs with you again.\n    env.skyZenithCol = vec3(0);\n    env.skyHorizonCol = vec3( 0);\n    \n\tvec3 sunCol = vec3(0.0f);\n    env.sunElevation = (0.1f * PI * 0.5);\n    \n    env.fogCol =  env.skyHorizonCol;\n    \n    env.sunDiscCol = sunCol * 32.0;\n    env.sunLightCol = sunCol;\/\/ * 2.0;\n    \n#endif    \n    \n    env.ambientCol = (env.skyZenithCol + env.skyHorizonCol) * 0.5 * 0.25;\n        \n    env.ambientCol =env.fogCol;\n    env.fogDensity = 0.001f;\n    env.skyFogDensity = 0.00001f;\n        \n    \/\/env.sunElevation = iMouse.y * PI * 0.5 \/ iResolution.y;\n    \/\/env.sunHeading = iMouse.x * TAU \/ iResolution.x;\n\n    float se = sin( env.sunElevation );\n    float ce = cos( env.sunElevation );\n    float sh = sin( env.sunHeading );\n    float ch = cos( env.sunHeading );\n    \n    env.sunDir = normalize( vec3( ce * sh, se, ce * ch ) );\n    \n    return env;\n}\n\n\nvec3 GetExtinction( vec2 mapPos )\n{\n\/\/ https:\/\/aslopubs.onlinelibrary.wiley.com\/doi\/pdf\/10.4319\/lo.1997.42.2.0379\n\/\/ green seawater\n    vec3 extA = vec3( 0.29, 0.10, 0.43 );\n    \n    vec3 extB = vec3( 0.3, 0.11, 0.11 );    \n    float blend = SmoothNoise22( mapPos * 0.01 ).x;    \n    return mix( extA, extB, blend );\n}\n\nvec3 GetSunGlow( EnvironmentSettings env, vec3 dir )\n{\n\tfloat VdotL = dot( dir, env.sunDir );\n    \n    VdotL = VdotL * 0.5 + 0.5;\n        \n    float gf = 1.0 - VdotL;\n    \n    float scale = (1.0 \/ (gf * 150.0 + 0.45));\n    \n    \/\/float scale = (1.0 \/ (gf * 1000.0 + 1.0));\n\n    return env.sunLightCol * scale;    \n}\n\n\nvec2 GetShorelineWaves( vec2 pos, float water_terrain_dh )\n{\n    \/\/return vec2(0);\n    water_terrain_dh = max( 0.0f, water_terrain_dh );\n    float p = water_terrain_dh * 8.0 + iTime * 1.5;\n    \/\/float p = pos.y;\n    \/\/p *= water_terrain_dh * 0.05 + 1.0;\n    \/\/p += iTime * 2.0;\n    \n    vec2 noise = SmoothNoise22( pos * 0.1 );\n    \n    p = p + noise.x * 4.0;\n    \n    float waveMag = exp( -water_terrain_dh * 0.7);\n    \n    \n    float sw = sin( p + cos(p) * (1.0 - waveMag) ) * -0.5 + 0.5;    \n    \n    \/\/float chop = 3.0 - waveMag * 3.0;\n    \/\/sw = pow ( 1.0 - sw, chop );    \n    \n    float fm = (sin( p - PI * 0.85 ) * 0.5 + 0.5);\n        \n    return vec2( sw * sqrt( waveMag ), fm * waveMag ) * noise.y ;\n}\n\n\nfloat Water_WaveShape( vec2 uv, float chop )\n{\n\tuv += SmoothNoise22( uv * 0.6) * 2.0;\n    \n    vec2 w = sin(uv * 2.0) * 0.5 + 0.5;\n    \n    w = 1.0 - pow ( 1.0 - w, vec2(chop) );\n    \n    float h = (w.x + w.y) * 0.5;\n    \n    return h;\/\/pow( h, 0.1 );\n}\n\nfloat Water_GetWaves( vec2 mapPos, int waterOctaves, float time )\n{\n    float a = 1.0f;\n    \n    float h = 0.0f;\n    \n    float tot = 0.0;\n    \n    float r = 2.5f;\n    mat2 rm = mat2( cos(r), -sin(r), sin(r), cos(r) ) * 2.1f;\n    \n    vec2 aPos = mapPos;\n    \n    float waveTime = time;\n    \n    float chopA = 0.7;\n    float chopB = 0.9;\n    \n    int maxOctaveCount = 8;\n        \n    for ( int octave = 0; octave < maxOctaveCount; octave++ )\n    {            \n        if ( octave > waterOctaves )\n            break;\n\n        float chop = mix(chopA, chopB, float(octave) \/ float(waterOctaves-1));\n        \n        h += Water_WaveShape( aPos + waveTime , chop ) * a;\n        tot += a;\n                \n        aPos = aPos * rm;\n                \n        a *= .3;\n        \n        waveTime *= 1.6;\n        \n    }\n    \n    return h \/ tot;    \n}\n\nfloat Water_GetHeight( vec2 origMapPos, int waterOctaves, float time )\n{\n    \n#if EQUIRECTANGULAR_PROJECTION    \n    return -1000.0;\n#endif    \n    vec2 mapPos = origMapPos \/ 4.0;\n            \n\tfloat h = Water_GetWaves( mapPos, waterOctaves, time );\n    \n    bool detail = false;\n    float terrainHeight = Terrain_GetHeight( iChannelRockTexture, origMapPos, false, true );\n    float waveScale = smoothstep( 0.0, -2.0, terrainHeight ) * 0.8 + 0.2;\n    \/\/waveScale = 0.0f;\n    \n    \/\/waveScale *= 1.0 - smoothstep( 1.8f, 1.9f, terrainHeight );\n    \n    \/\/waveScale = 1.0f;\n    \n    float result = h * waveScale;\n\n    float shorelineWaves = GetShorelineWaves(origMapPos, -terrainHeight).x * waveScale * 1.5;\n    \n    float water_terrain_dh = result - terrainHeight;\n#if 0\n    float foamFactor = smoothstep( 0.3, 0.0f, water_terrain_dh );\n    \n    float t= ( foamFactor * foamFactor *  foamFactor ) *  1.5;\n    float bump = 3.0 * t * t - 2.0f * t * t * t;\n    result += bump * 0.1;\n#endif  \n    \n#if 1\n    float edge = (water_terrain_dh+shorelineWaves*0.5+0.02)*5.;\n    edge = clamp(1.0-edge, 0.0, 1.0);    \n    edge = sqrt( 1.0 - edge * edge );\n    \/\/edge = smoothstep( 0.0, 1.0, edge );\n    result += edge * 0.1;\n#endif\n    \n    \/\/result = 0.0f;\n    \n    result += shorelineWaves;\n    \n    return result;\n}\n\nstruct MapHeight\n{\n    float height;\n    int objectId;\n};\n\nMapHeight Map_GetHeight( vec2 mapPos, int waterOctaves, bool detail )\n{\n    float groudHeight = Terrain_GetHeight( iChannelRockTexture, mapPos, detail, false );\n    MapHeight result = MapHeight( groudHeight, 0 );\n    \n    if ( waterOctaves > 0 )\n    {\n        float waterHeight = Water_GetHeight(mapPos, waterOctaves, iTime );\n        if (waterHeight > result.height )\n        {\n            result.height = waterHeight;\n            result.objectId = 1;\n        }\n    }\n    \n    return result;\n}\n\nMapHeight Map_GetAltitude( vec3 pos, int waterOctaves, bool detail )\n{\n    MapHeight mapHeight = Map_GetHeight( pos.xz, waterOctaves, detail );\n    return MapHeight( pos.y - mapHeight.height, mapHeight.objectId );    \n}\n\nvec3 Map_GetNormal( vec3 pos )\n{\n    const float delta = 0.01;\n    \n    const int normalOctaves = 8;\n    vec3 normal = vec3(1.0f, 0.0f, 1.0f) * Map_GetHeight( pos.xz, normalOctaves, true ).height\n           + Map_GetHeight( pos.xz + vec2(delta, 0.0f), normalOctaves, true ).height * vec3(-1.0f, 0.0, 0.0)\n        + Map_GetHeight( pos.xz + vec2(0.0f, delta), normalOctaves, true ).height * vec3(0.0f, 0.0, -1.0) + vec3(0.0, delta, 0.0);\n    \n    return normalize( normal );\n} \n\nstruct MapTraceResult\n{\n    float dist;\n    int objectId;\n};\n\nMapTraceResult Map_Trace( vec3 rayOrigin, vec3 rayDir, int waterOctaves, bool detail )\n{\n    MapTraceResult result = MapTraceResult( -1., -1 );\n    \/\/if ( rayDir.y > 0.0f )\n    \/\/{\n        \/\/return -1.0f;\n    \/\/}\n        \n    float minT;\n    vec3 minPos;\n    float minH;\n    \n    float maxT = 0.0f;\n    vec3 maxPos = rayOrigin + rayDir * maxT;\n\tMapHeight mapHeight = Map_GetAltitude( maxPos, waterOctaves, detail );\n    float maxH = mapHeight.height;    \n    result.dist = maxT;    \n    result.objectId = mapHeight.objectId;  \n\n    float yMax = 2.0f;\n    float yMin = -8.0f;\n    \n    yMax = min( yMax, rayOrigin.y );\n    \n    int maxIterA = 16;\n    \n    \/\/float traceStep = 1.0;\n    \n    for( int iter = 1; iter <= maxIterA; iter++ )\n    {\n        minT = maxT;\n        minH = maxH;\n\n        float fr = float(iter) \/ float(maxIterA);\n        float y = yMax + (yMin - yMax) * fr;\n        \n        maxT = (y - rayOrigin.y) \/ rayDir.y;               \n        \n        maxPos = rayOrigin + rayDir * maxT;\n\t\tMapHeight mapHeight = Map_GetAltitude( maxPos, waterOctaves, detail );\n        maxH = mapHeight.height;\n        \n        result.dist = maxT;\n\t    result.objectId = mapHeight.objectId;  \n                \n        if ( maxH < 0.0 )\n        {\n            break;\n        }        \n    }    \n    \n    \n    int maxIterB = 11;\n    \n    for( int iter = 0; iter < maxIterB; iter++ )\n    {\n        float midT = (minT + maxT) * 0.5f;        \n        \/\/float midT = mix( minT, maxT, ( (maxH + minH) * 0.5 - minH ) \/ (maxH-minH) );\n        \n        vec3 midPos = rayOrigin + rayDir * midT;\n\t\tMapHeight mapHeight = Map_GetAltitude( midPos, waterOctaves, detail );\n        float midH = mapHeight.height;\n        \n        if ( midH < 0.0f )\n        {\n            maxT = midT;\n            maxH = midH;\n            result.dist = maxT;\n\t\t    result.objectId = mapHeight.objectId;  \n        }\n        else\n        {\n            minT = midT;\n            minH = midH;\n        }      \n        \n        if ( abs( minH - maxH ) < 0.001)\n        {\n            break;\n        }\n    }\n    \n    return result;\n}\n\nvec3 GetSkyColour( EnvironmentSettings env, vec3 rayOrigin, vec3 rayDir, float mipLod, bool sunDisc )\n{\n    vec4 skyResult = TraceSky( env, iChannel1, rayDir, iTime * 3.0, mipLod, sunDisc );\n    \n    \n    vec3 result = skyResult.rgb;\n\n    float dist = skyResult.w;\n    \n    float fogFactor = 1.0 - exp( dist * -env.skyFogDensity );\n    result = mix ( result, env.fogCol, fogFactor );\n    return result; \n}\n\nvec3 GetInscatter( EnvironmentSettings env, float heading, float cosRefract, vec3 extinction )\n{\n    \/\/ hardcode LUT\n    vec3 result = vec3(0.0, 0.0, 0.0);\n\n    \/\/ some average sky color\n    vec3 skyCol = (env.skyHorizonCol * 3.0f + env.skyZenithCol * 1.0f) \/ 4.0f;       \n\n    \/\/ Parameters:\n    float lightIntensity = 0.07f; \/\/ overall intensity of result - don't just rely on extinction to darken color\n    float scatteringScale = 40.0f;\n    float scatteringOffset = 4.0f;\n    \/\/\/\/\/\/\/\n\n\n    float cosSunHeading = cos( heading - env.sunHeading );\n\n    float spread = -0.5 -cosRefract * 1.5; \/\/ wrap sunlight more with \"depth\"\n\n    float sunIntensityX = cosSunHeading * ( 1.0f - spread ) + spread;\n    sunIntensityX = max( 0.0f, sunIntensityX );\n\n    float sunIntensityY = max( 0.0f, -cosRefract );\n\n\n    float sunIntensity = sunIntensityX * sunIntensityX + sunIntensityY * sunIntensityY;\n    sunIntensity *= (1.0 + cosRefract) * 8.0; \/\/ decrease sun intensity with \"spread\"\n\n    vec3 light = env.sunLightCol * sunIntensity + skyCol;\n\n    light *= lightIntensity;        \n\n    float dist = (cosRefract * cosRefract) * scatteringScale + scatteringOffset;\n\n    result.rgb = light * (exp( dist * -extinction)); \/\/ could be exp2 if we change scatteringScale and scatteringOffset values\n\n    return result;\n}\n\nfloat GIV( float dotNV, float k)\n{\n\treturn 1.0 \/ ((dotNV + 0.0001) * (1.0 - k)+k);\n}\n\n\nvec4 GetSandCol( vec3 pos, float mipLod )\n{\n    vec3 textureSample = textureLod( iChannel1, pos.zx * 2.0, mipLod ).rgb;\n    textureSample = textureSample * textureSample;\n\n    \/\/ darker, browner sand\n    vec3 sandColA = vec3( 0.9f, 0.63f, 0.4f );\n    sandColA = sandColA * sandColA;\n    \n    \/\/ ligher, whiter sand\n    vec3 sandColB = vec3( 1.0f, 0.8f, 0.6f );\n    sandColB = sandColB * sandColB;    \n    \n    \/\/ todo - pass in sand type factor - define regions somewhere\n    \n    float blendFactor = smoothstep(1.2, 2.0, pos.y);\n        \n\tvec3 sandCol = mix( sandColA, sandColB, blendFactor );\n    \n    \/\/float rockFactor = clamp(-pos.y +textureSample.g * 0.75 + 0.25 + 0.0, 0.0, 1.0);\n    \n    vec2 heights = Terrain_GetHeights( iChannelRockTexture, pos.xz, true );\n        \n    float rockFactor = clamp( (heights.y - heights.x + 0.01) * 500.0, 0.0f, 1.0 );\n    \n#if EQUIRECTANGULAR_PROJECTION    \n    rockFactor = 0.0;\n#endif       \n    \n    sandCol = mix( sandCol, textureSample, rockFactor );\n    \n    \/\/vec3 textureSampleB = textureLod( iChannel1, uv * 10.0, mipLod ).rgb;\n    \/\/sandCol *= (textureSample.g * 0.5 + textureSampleB.r * 0.5);\n    \n    return vec4( sandCol, rockFactor );\n    \/*\n    col = col * col;            \n    \n    float rawCol = col.r;\n    \n    float fade = clamp( 0.5 + pos.y, 0.0f, 1.0);\n\tfade = 0.3 + fade * 0.6f;\n    \n    col = col * (1.0f - fade) + fade;\n    col *= vec3( 1.0f, 0.85f, 0.5f );\n    \n    return vec4( col, rawCol );\n    *\/\n}\n\nvec3 WaterCaustics( EnvironmentSettings env, vec3 pos )\n{    \n    \/\/return sunLightCol; \/\/ no caustics\n    \n    float h = Water_GetWaves( pos.xz, 3, iTime * 3.0 );\n    float i = 0.5f + 0.7f * h * h;\n    return env.sunLightCol * i;\n}\n\nvec3 GetSceneColour( EnvironmentSettings env, vec3 rayOrigin, vec3 rayDir, out float sceneDist )\n{\n    vec3 result = vec3(0);\n\n    float wetDiffuseFactor = 0.5;\n    \n    int waterOctaves = 3;\n    MapTraceResult mapTrace = Map_Trace( rayOrigin, rayDir, waterOctaves, false );\n    \n    if ( mapTrace.dist < 0.0 )\n    {        \n        result.rgb = GetSkyColour( env, rayOrigin, rayDir, 0.0f, true );\n        sceneDist = 10000.0;\n    }\n    else\n    if ( mapTrace.dist >= 0.0 )\n    {        \n        sceneDist = mapTrace.dist;\n        \n        vec3 hitPos = rayOrigin + rayDir * mapTrace.dist;\n        vec3 normal = Map_GetNormal( hitPos );\n                \n\n        float vR0 = 0.02f;\n        \n        float roughness = 0.0002f;\n\n        vec3 albedo = vec3(1);\n        float transparency = 1.0f;\n        vec3 colTransmitted = vec3(0);\n        \n        if ( mapTrace.objectId == 1 )\n        {\n            vec3 waterExtinction = GetExtinction( hitPos.xz );\n            {\n                \n                float terrainHeight = Terrain_GetHeight( iChannelRockTexture, hitPos.xz, false, true );\n                \n                float water_terrain_dh = hitPos.y - terrainHeight;\n                \n                float foamAmount = clamp( 1.0 - water_terrain_dh * (1.0f \/ 0.5f), 0.0f, 1.0f );\n                foamAmount = foamAmount * foamAmount;\n                \n\t\t\t\tfloat waveFactor = GetShorelineWaves( hitPos.xz, water_terrain_dh ).y;\n                \n                foamAmount = max( foamAmount, waveFactor );\n\n                vec2 foamMapUV = hitPos.xz; \/\/mix(hitPos.xz, refractHitPos.xz, 0.25);\n                foamMapUV = foamMapUV * 20.0 + water_terrain_dh * 100.0;\n                \n                \n\t            \/\/normal.xz += (SmoothNoise2( foamMapUV * 2.0) * 2.0f - 1.0f) * foamAmount * 0.2;\n                \/\/normal = normalize( normal );\n                \n\t            vec3 rayRefracted = refract( rayDir, normal, 1.0f \/ 1.3333f );\n                \n                \n                \n                MapTraceResult refractTrace = Map_Trace( hitPos, rayRefracted, 0, false );\n                vec3 refractHitPos = hitPos + rayRefracted * refractTrace.dist;\n                \n                float dh = refractHitPos.y - hitPos.y;\n\n                vec3 diffuseCol = GetSandCol( refractHitPos, (log( refractTrace.dist )+1.) * 4.0).rgb;\n                \n                diffuseCol *= wetDiffuseFactor;\n\n                vec3 seabedLighting = WaterCaustics( env, refractHitPos );\n                \n                float seabedNdotL = env.sunDir.y;\n                vec3 diffuseLight  = seabedNdotL * seabedLighting * exp( (-dh \/ -env.sunDir.y) * waterExtinction );\n                \n                diffuseLight += env.ambientCol * exp( dh * waterExtinction );\n                                \n                colTransmitted = diffuseLight * diffuseCol;\n                \n                vec3 extinction = exp( (-refractTrace.dist ) * waterExtinction );\n\n                \n                colTransmitted *= extinction;  \n\n                {\n                    float inscatterFactor = clamp( 1.0 - rayRefracted.y, 0.0f, 1.0f );\n\n                    \/\/vec3 inscatterScale =  exp( -inscatterFactor * waterExtinction * inscatterScaleFactor );\n\n                    float lookupU = atan(rayRefracted.x, rayRefracted.z);\n                             \n\n                    float lookupV = clamp( -rayRefracted.y, 0.0f, 1.0f);\n                    vec3 inscatterScale = GetInscatter( env, lookupU, lookupV, waterExtinction );\n\t\t\t\t\tcolTransmitted += inscatterScale;\n                }\n            \/\/}\n            \n\t\t\t\t\/\/colTransmitted *= RadianceChange( IOR_AIR, IOR_WATER );                \n\t            \/\/colTransmitted *= RadianceChange( IOR_WATER, IOR_AIR );\n                \n            \/\/{\n\n                \n                \/\/float foam = SmoothNoise2( foamMapUV ).x;\n                vec2 foamSampleUV = foamMapUV * 0.005 + iTime * 0.1;\n                vec4 foamSample = texture( iChannel1, foamSampleUV, 0.0 );\n                float foam = foamSample.x;\n                \n                \n                foam = 1.f - foam;\n                foam = 1.f - foam* foam;\n                \n                float foamFactor = foamAmount * 0.8f;\n                \n                foamFactor = max( 0.0, foamFactor - foam * (1.0f - foamFactor));\n                \n                \/\/foamFactor *= 0.25 + 0.75 * SmoothNoise2( hitPos.xz * 10000.0 ).x;\n                                \n                float foamThicknessFactor = 1.0;\n                \/\/if ( abs( dh ) < 0.02 ) { foamThicknessFactor = 0.5; }\n                \n                \/\/ foam shadow\n                colTransmitted *= 1.0 - foamFactor * foamThicknessFactor;\n                \n                \/\/ foam bubbles\n                \/\/colTransmitted += diffuseLight * exp( -foamAmount * waterExtinction * 10.0 ) * foamSample.b * 0.2;\n                \n                \/\/albedo = vec3( SmoothNoise2( hitPos.xz * 10000.0 ).x * 0.5 + 0.5 );\n                albedo = vec3( 1.0f );\n                \n                normal.x += (foamSample.x - texture( iChannel1, foamSampleUV - vec2(0.2, 0), 0.0 ).x) * foamFactor * 0.4;\n                normal.z += (foamSample.x - texture( iChannel1, foamSampleUV - vec2(0, 0.2), 0.0 ).x) * foamFactor * 0.4;\n                normal = normalize( normal );\n                \n                \n                transparency = 1.0 - foamFactor * foamThicknessFactor;                                \n                roughness = mix( roughness, 0.3f, foamFactor * foamFactor );                \n            }            \n        }\n        else\n        {\n            vec3 mapPos = rayOrigin + rayDir * mapTrace.dist;\n            \n            vec4 sandColSample = GetSandCol( mapPos, 0.0f );\n            albedo = sandColSample.rgb;\n            transparency = 0.0f;\n            \n            float wetness = 0.0f;\n            \n            vec2 noiseLow = SmoothNoise22(mapPos.xz * 0.2);\n\n            roughness = 1.0f - sandColSample.a * (0.5 + sandColSample.r * 0.5);\n            \n            \/\/float roughnessHeight = smoothstep( 2.0, 1.2, mapPos.y );            \n            \/\/roughness = mix( roughness, noiseLow.y * 0.08, roughnessHeight );\n            \n#if 1\n            \n            \n            \/\/float wetRoughness = mix( 2.0f, 1.2f, noiseLow.x );\n            float wetnessHeightFactor = smoothstep( 1.5, 0.6, mapPos.y );\n            float wetnessHeight = mix( wetness, 0.8+noiseLow.x * 0.2, wetnessHeightFactor);\n            \n            wetness = max( wetness, wetnessHeight );\n                        \n                        \n                                                \n#endif      \n            \n\t        float waterOldHeight = Water_GetHeight(mapPos.xz, 2, iTime - 0.05 );                        \n            float wetnessShorline = smoothstep( 0.4, 0.0, mapPos.y - waterOldHeight);\n            \n            wetnessShorline *= 1.0;\n                \n            wetness = max( wetness, wetnessShorline );\n            \n            \n            roughness = mix ( roughness, 0.001, wetness );            \n            albedo *= (1.0 - wetness ) * (1.0f - wetDiffuseFactor) + wetDiffuseFactor;\n            \n            \/\/albedo = clamp( albedo + max(0.0f, wetnessShorline - 0.9), 0.0, 1.0); \/\/ attempt to hack persistent foam\n        }\n\n        vec3 h = normalize( -rayDir + env.sunDir );\n        float NdotL = max( 0.0f, dot( normal, env.sunDir ) );\n        float NdotH = dot( h, normal );\n        float NdotV = dot( rayDir, normal );\n               \n        vec3 diffuseIntensity = (NdotL * env.sunLightCol + env.ambientCol) * albedo;\n\n        colTransmitted = mix( diffuseIntensity, colTransmitted, transparency );\n        \n        roughness = roughness * 0.995 + 0.005;\n        \n        float gloss = (1.0f - roughness);\n        float glossFactor = pow( gloss, 20.0 );\n        \n        vec3 rayReflected = reflect( rayDir, normal );\n        \n        vec3 colReflected = GetSkyColour( env, hitPos, rayReflected, glossFactor * 16.0, false );\n        \n        {\n\t\t\tfloat alpha = roughness;\n            float alphaSqr = alpha * alpha;\n            float denom = NdotH * NdotH * (alphaSqr - 1.0) + 1.0f;\n            float k = alpha \/ 2.0;\n            float vis = GIV(NdotL, k) * GIV(NdotV, k);\n            float f = alphaSqr \/ (PI * denom * denom);\n            colReflected += f * NdotL * env.sunLightCol;\n        }\n        \n        \n        {\n            float NdotV = max( 0.0, dot( rayDir, -normal ) );\n\n            vec3 fresnel = vR0 + (vec3(1.0) - vR0) * pow( 1.0 - NdotV, 5.0 ) * glossFactor;\n\n            result.rgb = mix( colTransmitted, colReflected, fresnel );\n        }            \n        \n    \n        float dist = mapTrace.dist;\n        float fogFactor = 1.0 - exp( dist * -env.fogDensity );\n        result.rgb = mix ( result.rgb, env.fogCol, fogFactor );\n\t}\n\n    vec3 sunGlow = GetSunGlow( env, rayDir );\n    result.rgb += sunGlow;\n\n    return result;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{       \n    vec2 uv = fragCoord.xy \/ iResolution.xy;;\n\n    CameraState cam;\n\tCam_LoadState( cam, iChannelState, ivec2(0,0) );\n    \n    \/\/ Trace Scene\n    float fAspectRatio = iResolution.x \/ iResolution.y;            \n    \n    vec3 rayOrigin, rayDir;\n    vec2 vJitterUV = uv + cam.vJitter \/ iResolution.xy;\n    Cam_GetCameraRay( vJitterUV, fAspectRatio, cam, rayOrigin, rayDir );    \n\n\tEnvironmentSettings env = GetEnvironmentSettings();\n    \n    float dist;\n    vec3 sceneColor = GetSceneColour( env, rayOrigin, rayDir, dist );\n    \n    fragColor = vec4(sceneColor,dist);\n}\n","name":"Buffer C","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"XdcyDM","date":"1519073508","viewed":2346,"name":"Creation Stone","username":"mmerchante","description":"Reference: a jewelry piece I found online. Pretty hard to get right, unfortunately :(","likes":108,"published":3,"flags":32,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4sX3zn","filepath":"\/media\/a\/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"\/media\/ap\/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"\/media\/a\/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"\/media\/ap\/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define FIXED_STEP_SIZE .0175\n#define FIXED_STEPS 100\n\n#define MAX_DISTANCE 50.0\n#define MIN_DISTANCE 4.0\n#define EPSILON .025\n#define EPSILON_MEDIUM .75\n\n#define MEDIUM_ETA .5757575\n\n\/\/ https:\/\/www.shadertoy.com\/view\/4djSRW\n\/\/  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\/\/  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat dot2(vec3 p)\n{\n    return dot(p, p);\n}\n\nfloat worley(vec3 p)\n{\n    float d = 10.0;\n    \n    vec3 n = floor(p);\n    \n    for(int z = -1; z <= 1; z++)\n    for(int y = -1; y <= 1; y++)\n    for(int x = -1; x <= 1; x++)\n    {\n        vec3 neighbor = n + vec3(x,y,z);\n        vec3 centerPosition = neighbor + hash33(neighbor);\n        \n        d = min(d, dot2(centerPosition - p) + .7);\n        \n        if(d < 0.0)\n            break;\n\t}\n\n\treturn d;\n}\n\nfloat density(vec3 p)\n{\n   \tp.xz -= worley(p * 2.342) * .2;\n    p.y += .45;\n    p *= .15;\n    p.xz *= .75;\n    float d = p.y * 1.5;\n    p.y += sin(p.x * 12.0) * .05 - .05;\n    p.xz += sin(p.y * 12.0) * .01 + .01;\n    p.y *= .35;\n    \n    float edge0 = p.y * 8.0 + (sin(p.y * 1.0)  * .5 + .5) * .3;    \n   \tfloat terrain = smoothstep(edge0 + .2, edge0, texture(iChannel1, p.xz * 2.0).r) * 1.25;\n    \n    d += terrain;\n    \n    \/\/ This adds a nice rim over the terrain\n    d += sin(terrain * 3.14 - .5) * 1.5; \n    d += p.y + .4;\n    d -= smoothstep(.1, -.05, p.y - d * .005);    \n    \n\treturn d;\n}\n\nfloat terrain(vec3 p)\n{\n\tp.xz -= worley(p * 2.342) * .2;\n    p.y += .45;\n    p *= .15;\n    p.xz *= .75;\n    p.y += sin(p.x * 12.0) * .05 - .05;\n    p.xz += sin(p.y * 12.0) * .01 + .01;\n    p.y *= .35;\n    \n    float tx = texture(iChannel1, p.xz).r + .05;    \n\n   \tfloat terrain = smoothstep(.3, .0, tx * .2 + texture(iChannel1, p.xz * 2.0).r * .5) * 1.5;\n    return terrain;\n}\n\n\/\/ ---------------------------------------------------------\n\nstruct Intersection\n{\n    float totalDistance;\n    float mediumDistance;\n    float sdf;\n    float density;\n    int materialID;\n};\n    \nstruct Camera\n{\n\tvec3 origin;\n    vec3 direction;\n    vec3 left;\n    vec3 up;\n};\n    \n\/\/ ---------------------------------------------------------\n    \nIntersection FinalizeRaymarch(Camera camera, vec4 bufA)\n{    \n    Intersection outData;\n    outData.sdf = 0.0;\n    outData.density = 0.0;\n    outData.totalDistance = bufA.w;\n\n    \/\/ INNER MEDIUM\n    if(outData.totalDistance < MAX_DISTANCE)\n    {\n        float t = FIXED_STEP_SIZE;\n        float d = 0.0;\n        \n        vec3 hitPosition = camera.origin + camera.direction * (outData.totalDistance + EPSILON);\n        vec3 normal = bufA.xyz;\n        \n        float roughETA = MEDIUM_ETA + hash13(hitPosition * 44.) *.02;\n        vec3 refr = refract(camera.direction, normal, roughETA);\n        \n        for(int i = 0; i < FIXED_STEPS; ++i)\n        {            \n            vec3 p = hitPosition + refr * t;\n            \n            \/\/ We know the size of the rock\n            if(length(p) > length(hitPosition))\n                break;\n            \n            float dd = density(p);\n            d += dd;\n            t += FIXED_STEP_SIZE * dd * (.9 + hash13(p * 22.2) * .3);\n            \n            if(dd < EPSILON_MEDIUM || t > 4.5)\n                break;\n        }\n        \n        outData.density = d;\n        outData.mediumDistance = t;\n    }\n    \n    return outData;\n}\n\nvec3 Render(Camera camera, Intersection isect, vec4 bufA, vec2 uv)\n{\n    vec3 p = camera.origin + camera.direction * isect.totalDistance;\n    \n    if(isect.totalDistance < MAX_DISTANCE)\n    {        \n        vec3 lPos = camera.origin - camera.left * 6.0 - camera.up * 15.0;\n        vec3 normal = bufA.xyz;\n        \n        vec3 refl = reflect(camera.direction, normal);\n        vec3 env = texture(iChannel0, refl).rgb;\n        \n        float fresnel = smoothstep(.65, .2, -dot(normal, camera.direction));\n        \n        vec3 innerColor = vec3(.25, .75, 1.0);\n        \n        float den = max(0.0001, isect.density) * .0075;\n        vec3 refr = refract(camera.direction, normal, MEDIUM_ETA);\n        vec3 innerP = p + refr * isect.mediumDistance;\n                \n        float deposit = terrain(innerP);\n        vec3 toLight = normalize(lPos - innerP);\n        vec3 volumetric = innerColor * vec3(den + deposit * .375) + vec3(deposit * .2);\n        \n        \/\/ Smooth the interface\n        volumetric *= volumetric * smoothstep(-.0, .65, isect.mediumDistance);\n        \n        return env * fresnel * .75 * smoothstep(-.05, .2, normal.y) + volumetric;        \n    }\n    \n    float vignette = 1.0 - pow(length(uv) \/ 2., 2.0);\n    return vec3(.15, .175, .25) * vignette * vignette * .5;\n}\n\n\nCamera GetCamera(vec2 uv, float zoom)\n{\n    float dist = 4.0 \/ zoom;\n    float time = 2.9 + iTime * .2;\n    \n    vec3 target = vec3(0.0, 1.0, 0.0);\n    vec3 p = vec3(0.0, 3.5, 0.0) + vec3(cos(time), 0.0, sin(time)) * dist;\n        \n    vec3 forward = normalize(target - p);\n    vec3 left = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(forward, left));\n\n    Camera cam;   \n    cam.origin = p;\n    cam.direction = normalize(forward - left * uv.x * zoom - up * uv.y * zoom);\n    cam.up = up;\n    cam.left = left;\n        \n    return cam;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (-iResolution.xy + (fragCoord*2.0)) \/ iResolution.y;    \n    \n    \/\/ Cheating here...\n    if(abs(uv.y) > .75)\n    {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    vec2 rawUV = fragCoord \/ iResolution.xy;\n    vec4 bufA = texture(iChannel2, rawUV);\n    \n    Camera camera = GetCamera(uv, .5);\n    Intersection isect = FinalizeRaymarch(camera, bufA);\n    \n    vec3 color = Render(camera, isect, bufA, uv);\n    \n    \n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sfGRn","filepath":"\/media\/a\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"\/media\/ap\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ Buf A: Container raymarching\n\n#define MAX_STEPS 50\n#define MAX_STEPS_F float(MAX_STEPS)\n\n#define FIXED_STEP_SIZE .025\n\n#define MAX_DISTANCE 50.0\n#define MIN_DISTANCE 4.0\n#define EPSILON .025\n#define EPSILON_MEDIUM .75\n#define EPSILON_NORMAL .05\n\n\/\/ hg_sdf\nconst vec3 GDFVectors[19] = vec3[19](\n\tvec3(1.0,.0,.0),\n\tvec3(.0,1.0,.0),\n\tvec3(.0,.0,1.0),\n\tvec3(.577,.577,.577),\n\tvec3(-.577,.577,.577),\n\tvec3(.577,-.577,.577),\n\tvec3(.577,.577,-.577),\n\tvec3(.0,.357,.934),\n\tvec3(.0,-.357,.934),\n\tvec3(.934,.0,.357),\n\tvec3(-.934,.0,.357),\n\tvec3(.357,.934,.0),\n\tvec3(-.357,.934,.0),\n\tvec3(.0,.851,.526),\n\tvec3(.0,-.851,.526),\n\tvec3(.526,.0,.851),\n\tvec3(-.526,.0,.851),\n\tvec3(.851,.526,.0),\n\tvec3(-.851,.526,.0)\n);\n\n\nfloat sdf(vec3 p)\n{\n\tfloat d = 0.0;\n    \n    p = abs(p);\n    \n    d = max(d, dot(p, GDFVectors[2]));\n    d = max(d, dot(p, GDFVectors[3]));\n    d = max(d, dot(p, GDFVectors[4]));\n    d = max(d, dot(p, GDFVectors[5]));\n    d = max(d, dot(p, GDFVectors[6]));\n    d = max(d, dot(p, GDFVectors[7]));\n    d = max(d, dot(p, GDFVectors[8]));\n    d = max(d, dot(p, GDFVectors[9]));\n    d = max(d, dot(p, GDFVectors[10]));    \n    d = max(d, dot(p, GDFVectors[11]));\n    d = max(d, dot(p, GDFVectors[12]));\n    d = max(d, dot(p, GDFVectors[13]));\n    d = max(d, dot(p, GDFVectors[14]));\n    d = max(d, dot(p, GDFVectors[15]));\n    d = max(d, dot(p, GDFVectors[16]));    \n    d = max(d, dot(p, GDFVectors[17]));\n    d = max(d, dot(p, GDFVectors[18]));\n    \n    return (d - 3.0) * 1.25;\n}\n\n\/\/ ---------------------------------------------------------\n\nstruct Intersection\n{\n    float totalDistance;\n    float mediumDistance;\n    float sdf;\n    float density;\n    int materialID;\n};\n    \nstruct Camera\n{\n\tvec3 origin;\n    vec3 direction;\n    vec3 left;\n    vec3 up;\n};\n    \n\/\/ ---------------------------------------------------------\n\nIntersection Raymarch(Camera camera)\n{    \n    Intersection outData;\n    outData.sdf = 0.0;\n    outData.density = 0.0;\n    outData.totalDistance = MIN_DISTANCE;\n        \n\tfor(int j = 0; j < MAX_STEPS; ++j)\n\t{\n        vec3 p = camera.origin + camera.direction * outData.totalDistance;\n\t\toutData.sdf = sdf(p);\n\n\t\toutData.totalDistance += outData.sdf;\n                \n\t\tif(outData.sdf < EPSILON || outData.totalDistance > MAX_DISTANCE)\n            break;\n\t}\n    \n    return outData;\n}\n\nCamera GetCamera(vec2 uv, float zoom)\n{\n    float dist = 4.0 \/ zoom;\n    float time = 2.9 + iTime * .2;\n    \n    vec3 target = vec3(0.0, 1.0, 0.0);\n    vec3 p = vec3(0.0, 3.5, 0.0) + vec3(cos(time), 0.0, sin(time)) * dist;\n        \n    vec3 forward = normalize(target - p);\n    vec3 left = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(forward, left));\n\n    Camera cam;   \n    cam.origin = p;\n    cam.direction = normalize(forward - left * uv.x * zoom - up * uv.y * zoom);\n    cam.up = up;\n    cam.left = left;\n        \n    return cam;\n}\n\nvec3 sdfNormal(vec3 p, float epsilon)\n{\n    vec3 eps = vec3(epsilon, -epsilon, 0.0);\n    \n\tfloat dX = sdf(p + eps.xzz) - sdf(p + eps.yzz);\n\tfloat dY = sdf(p + eps.zxz) - sdf(p + eps.zyz);\n\tfloat dZ = sdf(p + eps.zzx) - sdf(p + eps.zzy); \n\n\treturn normalize(vec3(dX,dY,dZ));\n}\n\n\/\/ https:\/\/www.shadertoy.com\/view\/Xts3WM\nfloat curv(in vec3 p, in float w)\n{\n    vec2 e = vec2(-1., 1.) * w;\n    \n    float t1 = sdf(p + e.yxx), t2 = sdf(p + e.xxy);\n    float t3 = sdf(p + e.xyx), t4 = sdf(p + e.yyy);\n    \n    return .25\/e.y*(t1 + t2 + t3 + t4 - 4.0 * sdf(p));\n}\n\nvec3 triplanar(vec3 P, vec3 N)\n{   \n    vec3 Nb = abs(N);\n    \n    float b = (Nb.x + Nb.y + Nb.z);\n    Nb \/= vec3(b);\n    \n    vec3 c0 = textureLod(iChannel0, P.xy, 3.0).rgb * Nb.z;\n    vec3 c1 = textureLod(iChannel0, P.yz, 3.0).rgb * Nb.x;\n    vec3 c2 = textureLod(iChannel0, P.xz, 3.0).rgb * Nb.y;\n    \n    return c0 + c1 + c2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (-iResolution.xy + (fragCoord*2.0)) \/ iResolution.y;    \n    \n    \/\/ Cheating here...\n    if(abs(uv.y) > .75)\n    {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    Camera camera = GetCamera(uv, .5);\n    Intersection isect = Raymarch(camera);\n    \n    vec3 p = camera.origin + camera.direction * isect.totalDistance;\n    \n    float c = curv(p, .15);\n    float longC = curv(p, .45);\n    vec3 normal = sdfNormal(p, EPSILON_NORMAL);\n    \n    vec3 tx = triplanar(p * .75, normal) + triplanar(p * 1.5, normal) * .2;\n    tx = tx * 2.0 - 1.0;\n    tx *= .025 + longC * .075;\n        \n    \n    \/\/ By feeding the curvature into the normal and distance, we ad enough weirdness to make it plausible\n    if(isect.sdf < EPSILON)\n        isect.totalDistance -= c * 1.5;\n    \n    fragColor =vec4(normalize(normal + tx - c * .25), isect.totalDistance);\n}","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"4dtSzX","date":"1460598776","viewed":2549,"name":"Aurora Explorer [re]","username":"KylBlz","description":"Must watch for at least 1 minute! Controls: WASD\/Arrows, Shift, Space, Mouse!","likes":102,"published":1,"flags":48,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"\/media\/a\/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"\/media\/ap\/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"\/media\/a\/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"\/media\/ap\/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define view_dist 20.\n\/\/low:64\tmedium:128\tultra:255\n#define vol_steps 128\n\n#define PI       3.1415926\n#define HPI      1.5707963\n#define tex(a,b) textureLod(a,b,0.)\n\n\/\/ storage register\/texel addresses\nconst vec2 txVel = vec2(0.5,0.5);\nconst vec2 txLoc = vec2(1.5,0.5);\nconst vec2 txRot = vec2(2.5,0.5);\nconst vec2 txMou = vec2(3.5,0.5);\n\nconst float mtSphere = 1.,\n            mtGround = 2.,\n            mtLight = 3.,\n    \t\tzfar = 100.;\n\n\/\/the reflective sphere\nvec4 sphere = vec4(vec3(0.1, 0.0, 0.1), 0.2);\n\/\/the light\nvec4 light = vec4(vec3(0.,0.5,0.), 0.05);\n\/\/plane location, plane normal, plane width\nmat3 plane = mat3(vec3(0., -0.7, 0.), vec3(0., 1., 0.), vec3(0.5, 0., 0.));\n\/\/just need this public\nvec3 camVel = vec3(0.);\n\n\/\/properties\nfloat modifier = 0.7,\t\/\/plasma\n\t  contrast = 20.0,\n      clump = 1.0,\n      size = 0.075,\n\t  ambient = 0.1,\t\/\/light\n      brightness = 3.;\n\nvec3 rotateXY(vec3 p, vec2 angle) {\n    vec2 c = cos(angle), s = sin(angle);\n    p.yz *= mat2 (c.x,s.x,-s.x,c.x);\n    p.xz *= mat2 (c.y,s.y,-s.y,c.y);\n    return p;\n}\n\nfloat linearAngle(float d, float r) {\n    return min(HPI, abs(asin(r\/d)));\n}\n\nfloat ROSA(in vec3 l) {\n    vec3 lv = light.xyz - l,\n         ov = sphere.xyz - l;\n    float ld = sqrt(dot(lv, lv)),\n          od = sqrt(dot(ov, ov)),\n          sal = linearAngle(ld, light.w),\n          sao = linearAngle(od, sphere.w),\n          fsa = sal;\n    if (od < ld) {\n        float theta = acos(dot(lv \/ ld, ov \/ od));\n\t    fsa *= 1. - clamp((sao - theta) \/ sal, 0., 1.);\n    }\n    fsa \/= sal;\n    return fsa * fsa;\n}\n\nvec2 csqr( vec2 a )  { return vec2( a.x*a.x - a.y*a.y, 2.*a.x*a.y  ); }\n\n\/\/plasma noise function\nfloat map(in vec3 p) {\n\tfloat res = 0.;\n    vec3 c = p;\n\tfor (int i = 0; i < 3; ++i) {\n        p = modifier*abs(p)\/dot(p,p) -modifier*clump;\n        p.yz= csqr(p.yz);\n        res += exp(-contrast * abs(dot(p,c)));\n\t}\n\treturn res;\n}\n\n\/\/marches air space between objects and camera\nvec3 raymarch( in vec3 ro, vec3 rd, vec2 tminmax ) {\n    \/\/start at starting loc\n    float t = tminmax.x;\n    \/\/small delta\n    float dt = (tminmax.y - tminmax.x) \/ float(vol_steps);\n    \/\/output color\n    vec3 col= vec3(0.);\n    vec3 pos = ro;\n    \/\/current sample\n    float c = 0.;\n    for( int i=0; i<vol_steps; i++ ) {\n        \/\/this steps through empty space faster\n        t += (.6 + t*t * 0.01) * dt*exp(-c*c);\n        pos = ro+t*rd;\n        \/\/get plasma density\n        c = map(pos*size);\n\t\t\/\/adjusted sumation\n        col += c*c*normalize(abs(pos.zyx));\n    }\n    return col * 0.007;\n}\n\n\/\/returns { location, normal, vec3(dist, volume, material) }\nmat3 traceScene( vec3 ro, vec3 rd) {\n    \/\/sphere intersection\n    vec3 oc = ro - sphere.xyz;\n    float c = dot( oc, oc ) - sphere.w*sphere.w;\n    float bs = dot( oc, rd );\n    float hs = sqrt(bs*bs - c);\n    float sphereDepth = zfar;\n    if (hs > 0.) {\n        if (bs < 0.) sphereDepth = -bs - hs;\n    }\n    \/\/now the light\n    oc = ro - light.xyz;\n    c = dot( oc, oc ) - light.w*light.w;\n    float bl = dot( oc, rd );\n    float hl = sqrt(bl*bl - c);\n    float lightDepth = zfar;\n    if (hl > 0.) {\n        if (bl < 0.) lightDepth = -bl - hl;\n    }\n    \/\/plane intersection\n    float planeAng = dot(plane[1], rd);\n    float planeDepth = dot(plane[1], plane[0] - ro) \/ planeAng;\n    if (planeDepth < 0. || planeDepth > zfar) planeDepth = zfar;\n    \n    \/\/depth test\n    if (sphereDepth < planeDepth && sphereDepth < lightDepth) {\n        vec3 sloc = ro+rd*sphereDepth;\n        return mat3(sloc,\n                   (sloc-sphere.xyz) \/ sphere.w,\n                   vec3(max(0., sphereDepth), hs\/sphere.w, mtSphere));\n    } else if (planeDepth < sphereDepth && planeDepth < lightDepth) {\n\t\treturn mat3(ro+rd*planeDepth,\n                    plane[1],\n                    vec3(max(0., planeDepth), planeAng+1.+plane[2].x, mtGround));\n    } else if (lightDepth < planeDepth && lightDepth < sphereDepth) {\n        vec3 sloc = ro+rd*lightDepth;\n        return mat3(sloc,\n                    sloc \/ light.w,\n                    vec3(max(0., lightDepth), light.w, mtLight));\n    } else {\n        return mat3(vec3(map(rd * (0.3+0.1*sin(iTime*0.1)))), vec3(rd), vec3(zfar, zfar, 0.));\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \/\/place 0,0 in center from -1 to 1 ndc\n    vec2 uv = fragCoord.xy * 2.\/iResolution.xx - vec2(1., 0.5);\n    \/\/mostly for post process\n    float radial = pow(max(length(uv)-0.2, 0.), 2.);\n    \n    \/\/get input, update camera\n    vec3 camLoc = tex( iChannel0, txLoc\/iChannelResolution[0].xy ).xyz;\n    camVel = tex(iChannel0, txVel\/iChannelResolution[0].xy ).xyz;\n\tvec3 camRot = tex(iChannel0, txRot\/iChannelResolution[0].xy ).xyz;\n    \/\/camRot is angle vec in rad\n    vec3 camDir = normalize(vec3(uv, 1.0));\n    vec3 rayDir = normalize(rotateXY(camDir, camRot.xy));\n    \n    \/\/update scene\n    float time = iTime + 25.0;\n    light.xz = vec2(sin(time)*1.,cos(time)*1.);\n    \/\/update fractal\n    clump = 1.+0.2*sin(time*0.1);\n    size = 0.075-0.01*sin(time*0.1);\n    \n    \/\/contains location xyz, normal xyz, distance, material, 0.\n    mat3 collision = traceScene(camLoc,  rayDir);\n\n    \/\/calculate light properties\n    vec3 lightDir = normalize(light.xyz - collision[0]);\n    float light2surface = distance(light.xyz, collision[0]),\n    \t  lightMoment = max(pow(0.25+dot(rayDir, reflect(lightDir, collision[1])), 3.), 0.),\n          lightPow = brightness \/ (light2surface*light2surface+1.);\n    \n    \/\/volume\n    fragColor = vec4(clamp(raymarch(camLoc, rayDir, vec2(0., min(view_dist, collision[2].x))),0., 1.), 1.);\n        \n    \/\/if ray collided with sphere\n    if (collision[2].z == mtSphere) {\n   \n        \/\/get plasma density\n        float c = map(collision[0]*size*7.0);\n\t\t\/\/adjusted sumation\n        fragColor.rgb += 0.5*c*normalize(abs(collision[0].zyx))*(lightMoment+0.5)*(lightPow+0.5);\n        \n    }\n    \/\/if ray collided with ground\n    else if (collision[2].z == mtGround) {\n        float fresnel = 1.2+dot(rayDir,collision[1]);\n        \/\/sample texture with distance fade and energy conservation\n        vec3 groundCol = tex(iChannel1, collision[0].xz * 0.5).rrr \/ (collision[2].x*collision[2].x*0.001+1.) * fresnel;\n        \/\/make floor patterned\n        vec3 offset = vec3(0., (groundCol.r + .5*tex(iChannel2, collision[0].xz).r)*(0.1-fresnel*0.07), 0.);\n        vec3 newrd = normalize(rayDir + offset);\n        lightMoment = max(pow(0.5+dot(newrd, reflect(lightDir, collision[1])), 3.)*1.2, 0.);\n        \/\/yep\n        vec3 reflectdir = reflect(newrd, collision[1]);\n        \/\/reflect off ground\n        vec3 skyCol = vec3(map(reflectdir * (0.3+0.1*sin(iTime*0.1))))*abs(reflectdir);\n        \/\/reflect off ground\n        mat3 collision3 = traceScene(collision[0] + collision[1]*0.001, reflect(newrd, collision[1]));\n        float rosa = ROSA(collision[0]);\n        \/\/skycolor * fresnel + ground color * light properties\n        fragColor.rgb += skyCol * max(fresnel - 0.5, 0.) + float(int(collision3[2].z == mtLight)) +\n            \t\t\t groundCol * (ambient + lightMoment * rosa * lightPow);\n    \n    }\n    \/\/ray collided with light source\n    else if (collision[2].z == mtLight) {\n        fragColor.rgb = vec3(2.);\n        \n    }\n    \/\/ray did not collide (sky)\n    else {\n        \/\/nothing much going on up here yet\n        fragColor.rgb += collision[0]*abs(collision[1]);\n\n    }\n    \n    \/\/apply retina adjustment before clamp\n    fragColor.rgb = clamp(fragColor.rgb, 0., 1.);\n    \/\/darken for now, eventually blur\n    fragColor.rgb *= (1. - radial*0.2);\n    \/\/gamma correction\n    fragColor.rgb = pow(fragColor.rgb, vec3(1. + radial));\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"\/presets\/tex00.jpg","previewfilepath":"\/presets\/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define MAX_ACCELERATION      16.\n#define MAX_VELOCITY          4.\n#define FRICTION              8.\n\n#define VALUE_VELOCITY        0\n#define VALUE_POSITION        1\n#define VALUE_ROTATION        2\n#define VALUE_MOUSE           3\n\n\/\/half pi\nconst float pi = 3.1415926,\n    \t\tpi_5 = 1.5707963;\n\nconst vec2 KEY_W \t = vec2(87.5 \/ 256., 0.),\n    \t   KEY_S \t = vec2(83.5 \/ 256., 0.),\n    \t   KEY_A \t = vec2(65.5 \/ 256., 0.),\n    \t   KEY_D \t = vec2(68.5 \/ 256., 0.),\n\t\t   KEY_LEFT  = vec2(37.5 \/ 256., 0.),\n\t\t   KEY_UP    = vec2(38.5 \/ 256., 0.),\n\t\t   KEY_RIGHT = vec2(39.5 \/ 256., 0.),\n\t\t   KEY_DOWN  = vec2(40.5 \/ 256., 0.),\n    \t   KEY_SHIFT = vec2(16.0 \/ 256., 0.),\n    \t   KEY_SPACE = vec2(32.0 \/ 256., 0.);\n\nconst vec4 INIT_POS = vec4(6.5, 1.0, -7., 1.),\n    \t   INIT_VEL = vec4(0., 0., 0., 1.),\n    \t   INIT_ROT = vec4(0.15, -0.65, 0., 1.),\n    \t   INIT_MOU = vec4(0., 0., 0., 1.);\n\nvec3 vRotateY(vec3 p, float angle) {\n    float c = cos(angle), s = sin(angle);\n    return vec3(c*p.x + s*p.z, p.y, -s*p.x + c*p.z);\n}\n\nvec3 getAcceleration() {\n    return vec3(\n        texture(iChannel1, KEY_D).x - texture(iChannel1, KEY_A).x + texture(iChannel1, KEY_RIGHT).x - texture(iChannel1, KEY_LEFT).x,\n        texture(iChannel1, KEY_SPACE).x - texture(iChannel1, KEY_SHIFT).x,\n        texture(iChannel1, KEY_W).x - texture(iChannel1, KEY_S).x + texture(iChannel1, KEY_UP).x - texture(iChannel1, KEY_DOWN).x\n    );\n}\n\nvec4 getValue(int a) {\n    vec2 q = vec2(float(a) + 0.5, 0.0) \/ iResolution.x;\n    return texture(iChannel0, q);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if (fragCoord.y > 1.) discard;\n    \n    int a = int(fragCoord.x);\n    float q = fragCoord.x \/ iResolution.x;\n    vec4 value = texture(iChannel0, vec2(q, 0.));\n    \n    \/\/set initial values\n    if (iFrame == 0) {\n        if (a == VALUE_ROTATION) {\n            value = INIT_ROT;\n        } else if (a == VALUE_MOUSE) {\n            value = INIT_MOU;\n        } else if (a == VALUE_VELOCITY) {\n            value = INIT_VEL;\n        } else if (a == VALUE_POSITION) {\n            value = INIT_POS;\n        }    \n    }\n    \n    if (a == VALUE_ROTATION && iMouse.z > 0.) {\n        vec4 mouse = 2.0 * abs(iMouse) \/ iResolution.y;\n        vec4 rot = getValue(VALUE_MOUSE);\n        value.y = mouse.x - mouse.z + rot.y;\n        value.x = clamp(mouse.y - mouse.w + rot.x, -pi_5, pi_5);\n        \n    } else if (a == VALUE_MOUSE && iMouse.z < 0.) {\n        value = getValue(VALUE_ROTATION);\n        \n    } else if (a == VALUE_VELOCITY) {\n        float rot = getValue(VALUE_ROTATION).y;\n        vec3 acc = vRotateY(getAcceleration(), rot);\n        value.xyz += acc * MAX_ACCELERATION * iTimeDelta;\n        float speed = length(value.xyz);\n        \/\/limit speed\n        if (speed > MAX_VELOCITY) {\n            value.xyz *= MAX_VELOCITY \/ speed;\n        } else if (speed > FRICTION * iTimeDelta) {\n            value.xyz *= (speed - FRICTION * iTimeDelta) \/ speed;\n        } else {\n            value.xyz = vec3(0.0, 0.0, 0.0);\n        }\n    } else if (a == VALUE_POSITION) {\n        vec3 velocity = getValue(VALUE_VELOCITY).xyz;\n        value.xyz += velocity * iTimeDelta;\n        \/\/collision detection?\n        if (value.y < -10.99) value.y = -10.99;\n    }\n    \n    fragColor = vec4(value);\n    return;\n}\n","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"XlSBRW","date":"1514685239","viewed":4883,"name":"Crystal Drops","username":"spolsh","description":"Inspired by UE4 Protostar demo and Liquid Carbon by Virgill.\nMouse enabled.\nTested on GTX970 at 1920x1200 on Chrome, Firefox and Opera.\n\nFeel free to feedback how to improve performance and code :)","likes":96,"published":3,"flags":96,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"\/media\/previz\/buffer01.png","previewfilepath":"\/media\/previz\/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xd2SRD","filepath":"https:\/\/soundcloud.com\/hybridminds\/hybrid-minds-meant-to-be?in=shaniithebunny\/sets\/liqud","previewfilepath":"https:\/\/soundcloud.com\/hybridminds\/hybrid-minds-meant-to-be?in=shaniithebunny\/sets\/liqud","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Crystal Drops\n\/\/ by Michal 'spolsh' Klos 2017\n\n\/\/ Works well with Pulfrich Effect:\n\/\/ https:\/\/en.wikipedia.org\/wiki\/Pulfrich_effect\n\/\/ https:\/\/www.youtube.com\/watch?v=Q-v4LsbFc5c\n\n\/\/ comment line 5 in Buf A to animate camera endlessly\n\n#define R iResolution\n#define T iTime\n#define F gl_FragCoord\n#define M iMouse\n\n\/\/ uncomment to enable FPS counter \n\/\/ #define FPS_COUNTER\n\n\/\/-----------------------------------------------------------------\n\/\/ Digit drawing function by P_Malin (https:\/\/www.shadertoy.com\/view\/4sf3RN)\n\nfloat SampleDigit(const in float n, const in vec2 vUV)\n{\t\t\n\tif(vUV.x  < 0.0) return 0.0;\n\tif(vUV.y  < 0.0) return 0.0;\n\tif(vUV.x >= 1.0) return 0.0;\n\tif(vUV.y >= 1.0) return 0.0;\n\t\n\tfloat data = 0.0;\n\t\n\t     if(n < 0.5) data = 7.0 + 5.0*16.0 + 5.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\telse if(n < 1.5) data = 2.0 + 2.0*16.0 + 2.0*256.0 + 2.0*4096.0 + 2.0*65536.0;\n\telse if(n < 2.5) data = 7.0 + 1.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 3.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 4.5) data = 4.0 + 7.0*16.0 + 5.0*256.0 + 1.0*4096.0 + 1.0*65536.0;\n\telse if(n < 5.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n\telse if(n < 6.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n\telse if(n < 7.5) data = 4.0 + 4.0*16.0 + 4.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 8.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\telse if(n < 9.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\t\n\tvec2 vPixel = floor(vUV * vec2(4.0, 5.0));\n\tfloat fIndex = vPixel.x + (vPixel.y * 4.0);\n\t\n\treturn mod(floor(data \/ pow(2.0, fIndex)), 2.0);\n}\n\nfloat PrintInt(const in vec2 uv, const in float value )\n{\n\tfloat res = 0.0;\n\tfloat maxDigits = 1.0+ceil(log2(value)\/log2(10.0));\n\tfloat digitID = floor(uv.x);\n\tif( digitID>0.0 && digitID<maxDigits )\n\t{\n        float digitVa = mod( floor( value\/pow(10.0,maxDigits-1.0-digitID) ), 10.0 );\n        res = SampleDigit( digitVa, vec2(fract(uv.x), uv.y) );\n\t}\n\n\treturn res;\t\n}\n\nfloat nrand(vec2 n)\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nvec3 filmGrainColor(vec2 uv, float offset)\n{ \/\/ by ma (lstGWn)\n    vec4 uvs;\n    uvs.xy = uv + vec2(offset, offset);\n    uvs.zw = uvs.xy + 0.5*vec2(1.0 \/ iResolution.x, 1.0 \/ iResolution.y);\n\n    uvs = fract(uvs * vec2(21.5932, 21.77156).xyxy);\n\n    vec2 shift = vec2(21.5351, 14.3137);\n    vec2 temp0 = uvs.xy + dot(uvs.yx, uvs.xy + shift);\n    vec2 temp1 = uvs.xw + dot(uvs.wx, uvs.xw + shift);\n    vec2 temp2 = uvs.zy + dot(uvs.yz, uvs.zy + shift);\n    vec2 temp3 = uvs.zw + dot(uvs.wz, uvs.zw + shift);\n\n    vec3 r = vec3(0.0, 0.0, 0.0);\n    r += fract(temp0.x * temp0.y * vec3(95.4337, 96.4337, 97.4337));\n    r += fract(temp1.x * temp1.y * vec3(95.4337, 96.4337, 97.4337));\n    r += fract(temp2.x * temp2.y * vec3(95.4337, 96.4337, 97.4337));\n    r += fract(temp3.x * temp3.y * vec3(95.4337, 96.4337, 97.4337));\n\n    return r * 0.25;\n}\n\nvec2 barrelDistortion(vec2 coord, float amt, float zoom)\n{ \/\/ based on gtoledo3 (XslGz8)\n  \/\/ added zoomimg\n\tvec2 cc = coord-0.5;\n    vec2 p = cc*zoom;\n    coord = p+0.5;\n\tfloat dist = dot(cc, cc);\n\treturn coord +cc*dist*amt;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    fragColor = vec4(0.0);\n    vec2 uv = F.xy\/R.xy;\n    vec2 vv = 2.0*(uv-0.5);\n    vv.x *= R.x\/R.y;\n \n    float cas = step(abs(vv.y)*2.39,R.x\/R.y);\n    if (cas<0.1) return;\n \n    vec3 c = texture(iChannel0, uv).rgb;   \n        \n    uv = barrelDistortion(uv, 0.1, 0.96);\n           \n    \/\/ chromatic abberation inspired by knifa (lsKSDz)\n    vec2 d = abs((uv-0.5)*2.0);    \n    d = pow(d, vec2(1.5, 1.0));\n    d.y *= 0.1;\n    \n    float dScale = 0.01;\n    const int maxSamples = 4;\n    vec4 r, g, b;\n    r = g = b = vec4(0.0);\n    for (int i=0; i<maxSamples; ++i)\n    {\n        float rnd = nrand(uv+vec2(i)+0.001*T);\n    \tr += texture(iChannel0, uv +d*rnd*dScale);\n    \tg += texture(iChannel0, uv);\n    \tb += texture(iChannel0, uv -d*rnd*dScale);\n\t}\n    \n    c = vec3(r.r, g.g, b.b)\/vec3(maxSamples);\n    \n    c *= 1.0 -0.25*filmGrainColor(0.5*uv, T).rgb;\n    \n    c = pow(c, vec3(0.4545));\n    \n    vec2 v = 2.*(uv-.5);\n    v.y *= 2.39 * R.y\/R.x;\n    v = clamp((v*.5)+.5, 0., 1.);\n    \/\/ c.rgb = vec3(1.0); \/\/ uncomment to see only vignette\n    c *= 0.25 + 0.75*pow( 16.0*v.x*v.y*(1.0-v.x)*(1.0-v.y), 0.25);\n    \n#ifdef FPS_COUNTER    \n    vec2 h = F.xy\/R.xy; \n    h.x *= R.x \/ R.y;\n    c += PrintInt( (h -vec2(0.0,0.21))*30.0, iFrameRate );\n#endif \n    \n    fragColor = vec4(c, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3zn","filepath":"\/media\/a\/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"\/media\/ap\/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ Crystal Drops\n\/\/ by Michal 'spolsh' Klos 2017\n\n\/\/ comment to animate camera endlessly\n\/\/ #define SLOMO_LOOP\n\n#define R iResolution\n#define F gl_FragCoord\n#define M iMouse\n\n#define HASHSCALE4 vec4(.1031, .1030, .0973, .1099)\n\nfloat T = 0.0;\n\nvec4 hash41(float p)\n{ \/\/ by Dave_Hoskins\n\tvec4 p4 = fract(vec4(p) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);    \n}\n\n\/\/ polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{ \/\/ by iq\n    float h = clamp( 0.5+0.5*(b-a)\/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat map(vec3 p)\n{\n    float s = length(p -vec3(0.0, .01*sin(8.0*T), 0.0)) - 0.5;\n\ts += 0.005*sin(45.0*p.x+10.0*T);\n    \n    for (int i=0; i<12; ++i) {\n        vec4 rnd = hash41(100.0+float(i));        \n        vec3 rndPos = 2.0*(normalize(rnd.xyz) -vec3(0.5));\n        rndPos.y *= 0.2;\n        float timeOffset = rnd.w;\n        float phase = fract(timeOffset -0.25*T);\n\t\tvec3 offset = mix( 0.1*rndPos, 15.0*rndPos, phase);\n        float rnd2 = fract(rnd.x +rnd.y);\n        float s0 = length(p +offset) -0.25*mix(0.8 +0.2*rnd2, 0.2 +0.8*rnd2, phase);\n        s = smin(s, s0, 0.4);\n    }\n\n    s += 0.002*sin(20.0*p.x +10.0*T);\n        \n    return s;    \n}\n\nvec3 env(vec3 dir) \n{\n    vec3 cubemap = texture(iChannel0, dir).rgb;\n    float ex = mix(6.0, 12.0, 0.5*(sin(0.5*T) +1.0));\n    float t0 = 0.05*pow(1.0 -dot(vec3(0.0, -1.0, 0.0), dir), ex);\n    float t1 = mix(0.2, 2.5, 1.0 -abs(sin(2.0*3.14*dir.y)));    \n    vec3 c = cubemap *t0 *t1;\n    return c * vec3(0.35, 1.2, 2.5);\n}\n\nvec3 calcNormal(vec3 p)\n{ \/\/ by iq\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n\treturn normalize(\te.xyy *map(p + e.xyy) + \n\t\t\t\t\t\te.yxy *map(p + e.yxy) + \t\t\t\t\t  \n\t\t\t\t\t\te.yyx *map(p + e.yyx) + \t\t\t\t\t  \n\t\t\t\t  \t  \te.xxx *map(p + e.xxx) );\n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr)\n{ \/\/ by iq\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = normalize(cross(cu,cw));\n    return mat3(cu, cv, cw);\n}\n\nvec3 tonemapping(vec3 color)\n{ \/\/ by Zavie (lslGzl)\n\tcolor = max(vec3(0.), color-vec3(0.004));\n\tcolor = (color * (6.2*color+.5))\/(color*(6.2*color+1.7)+0.06);\n\treturn color;\n}\n\nfloat spline(float x, float x1, float x2, float y1, float dy1, float y2, float dy2)\n{\n\tfloat t = (x -x1) \/ (x2 -x1);\t\n    float a = 2.0*y1 -2.0*y2 +dy1 +dy2;\n\tfloat b = -3.0*y1 +3.0*y2 -2.0*dy1 -dy2;\n\tfloat c = dy1;\n\tfloat d = y1;\n\tfloat t2 = t*t;\n\tfloat t3 = t2*t;\n\treturn a * t3 +b*t2 +c*t +d;\n}\n\nvoid calcTime()\n{\n    T = iTime;\n#ifdef SLOMO_LOOP\n    \/\/ slomo by Dave (4s23RW)\n    T = mod(iTime, 20.0);\n\tconst float slomoMin = 2.3;\n\tconst float slomoMax = 2.6;\n\tconst float slomoK = 0.2;\n\tconst float slomoDuration = (slomoMax-slomoMin)\/slomoK;\n\tif (T >= slomoMin && T<slomoMin+slomoDuration)\n\t\tT = spline(T, slomoMin, slomoMin+slomoDuration, slomoMin, slomoDuration*0.3, slomoMax, slomoDuration*0.15);\n\telse if ( T >= slomoMin+slomoDuration)\n\t\tT = T -slomoDuration +(slomoMax-slomoMin);\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    calcTime();\n        \n    vec2 u = F.xy\/R.xy;\n    vec2 v = 2.0*(u -0.5);\n    v.x *= R.x\/R.y;\n    vec2 m = M.xy\/R.xy;\n    float cas = step(abs(v.y)*2.39,R.x\/R.y);\n    if (cas<0.1) return;\n        \n\tvec3 ro = vec3(\n        8.0*cos(0.2*T +6.0*m.x),\n        2.0*mix(-1.0,1.0, m.y),\n        8.0*sin(0.2*T +6.0*m.x)\n    );\n    float taAnim = 2.0*(smoothstep(-0.1, 0.1, sin(0.1*T)) -0.5);\n\tvec3 ta = vec3(taAnim, -0.05, 0.0);\n\t\t\n    mat3 ca = setCamera(ro, ta, 0.0);\n    vec3 rd = ca * normalize(vec3(v, mix(4.5, 5.0, taAnim)));    \n    vec3 p, c;\n    vec3 n, rl, rr;\n    p = vec3(0.0);\n    c = env(rd);\n    \n    float t, d, a;\n    t = d = a = 0.0;\n    for(int i=0; i<50; ++i) {\n        t+=(d=map(p=ro+rd*t));\n        if (d<0.01) {\n            break;\n        }                \n    }\n    \n    float depth = length(p-ro);\n    \n    if (t<25.0) { \/\/ if hit scene\n        \n    \tn = calcNormal(p);\n\t    rl = reflect(rd, n);\n\t    rr = refract(rd, n, .19);\n    \n        for(int i=0; i<25; ++i) {\n            d = map(p=ro+rd*t);\n            a += step(d, 0.008) *0.005;\n            t += 0.02;\n    \t}\n        \n        a = exp(-a*25.0);\n        c = env(mix(rr, rl, a));\n\t\t\/\/ c = vec3(a); \/\/ uncomment to see absorbtion mask\n        c *= mix(vec3(1.4, 1.0, 0.9), vec3(1.0), clamp(0.2*length(p), 0.0, 1.0)); \/\/ value        \n        c *= mix(vec3(1.5), vec3(.3), clamp(pow(0.1*depth, 2.0), 0.0, 1.0)); \/\/ fogging\n    }\n              \n    c = tonemapping(c);\n    \n    depth = 0.01*dot(rd, p-ro); \/\/ depth paraller to camera\n\tfragColor = vec4(c, depth);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\/\/ Crystal Drops\n\/\/ by Michal 'spolsh' Klos 2017\n\n#define R iResolution\n#define T iTime\n#define F gl_FragCoord\n\nvec3 sharpen()\n{ \/\/ by NickWest (lslGRr)\n    vec2 uv = F.xy\/R.xy;\n  \tvec2 step = 1.0\/iResolution.xy;\n    float scale = 1.5;\n\tvec3 texA = texture(iChannel0, uv + vec2(-step.x, -step.y) * scale).rgb;\n\tvec3 texB = texture(iChannel0, uv + vec2( step.x, -step.y) * scale).rgb;\n\tvec3 texC = texture(iChannel0, uv + vec2(-step.x,  step.y) * scale).rgb;\n\tvec3 texD = texture(iChannel0, uv + vec2( step.x,  step.y) * scale).rgb;   \n    vec3 around = 0.25 *(texA+texB+texC+texD);\n\tvec3 center = texture(iChannel0, uv).rgb;\n\tvec3 col = center +(center-around)*1.0;\n    return col;\n}\n\nfloat depthToMask(float d)\n{\n\td *= 100.0;\n    d = abs(d -8.5);\n    d = pow(d, 6.0);\n    d = clamp(d, 0.0, 1.0);    \n    return d;\n}\n\nvec2 Hash22(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\n\nvec4 bokeh(vec2 uv, float rad)\n{ \/\/ based on dof by Jochen \"Virgill\" Feldk\u00f6tter, Alcatraz \/ Rhodium 4k Intro liquid carbon\n  \/\/ simplyfied version of Dave Hoskins blur\n  \/\/ now bokeh is not cut within dof mask, added alpha blending based on difference of dof mask samples\n    const float GA =2.399; \n\tconst mat2 rot = mat2(cos(GA),sin(GA),-sin(GA),cos(GA));\n\tvec4 acc = vec4(texture(iChannel0,uv).rgb, rad);\n    float d = rad;\n    vec2 pixel=0.0002*vec2(5.*R.y\/R.x,7.);\n\tvec2 angle=vec2(0,rad);\n\tfor (int j=0;j<80;j++)\n    {  \n        rad += 1.\/rad;\n\t    angle*=rot;\n        vec4 col=texture(iChannel0, uv+pixel*(rad-1.)*angle);\n      \tacc.rgb = max(acc.rgb,col.rgb);\n        acc.a = max(acc.a, abs(d-depthToMask(col.w)));\n\t}\n\treturn acc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{      \n    vec2 uv = F.xy\/R.xy;    \n    vec2 v = 2.0*(uv-0.5);\n    v.x *= R.x\/R.y;\n    \n    float cas = step(abs(v.y)*2.39,R.x\/R.y);\n    if (cas<0.1) return;\n         \n    float d = depthToMask(texture(iChannel0, uv).w);\n    \/\/ fragColor = vec4(d); return; \/\/ uncomment to see dof mask\n    \n    vec3 sharp = sharpen();   \n\tvec4 dof = bokeh(uv, d);\n    fragColor = vec4(mix(sharp, dof.rgb, dof.a), 1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}];    var gUseScreenshots = piIsMobile();
    var gThemeName = "classic";



    </script>
</head>

<!-- <body onload="resultsInit(12,null,null)"> -->
<body onload="resultsInitStatic(12,null,null)">

<!-- header =================================================================================== -->


<div id="header">

    <div id="headerBlock1">
        <a href="/" id="headerTitle">Shadertoy</a>
        <form name="formSearch" action="/results" method="get" style="display:inline-block;">
        <div  id="headerSearch">
            <input type="search" id="mySearch" name="query" placeholder="Search..." value="raymarch"/>
        </div>
        </form>
    </div>

    <div id="headerBlock2">
            <a class="headerLinks" href="/browse">Browse</a>
        <a class="headerLinks" href="/new">New</a>
        <a class="headerLinks" href="/signin">Sign In</a>
        </div>
</div>
<!-- content ================================================================================== -->

<div id="content">

  <div id="controls">
    <div>
      <div style="text-align: center; vertical-align: middle; display: inline-block; padding-bottom:5px; padding-top:4px; margin-right:8px; margin-bottom:8px; margin-top:8px;">
      Sort:      </div>
      <div class="controlOptions"><a class="pageButtons" href="/results?query=raymarch&sort=popular&filter=&filter=multipass">Popular</a><a class="pageButtons" href="/results?query=raymarch&sort=newest&filter=&filter=multipass">Newest</a><div class="pageButtonsCurrent" href="/results?query=raymarch&sort=love&filter=&filter=multipass">Love</div><a class="pageButtons" href="/results?query=raymarch&sort=hot&filter=&filter=multipass">Hot</a></div>
    </div>

    <div id="controlFilter">
      <div style="display:flex;margin-right:8px;align-items:center;">Filter:</div>
      <div class="controlOptions"> <a class="pageButtonsCurrent" href="/results?query=raymarch&sort=love">Multipass</a><a class="pageButtons" href="/results?query=raymarch&sort=love&filter=soundoutput&filter=multipass">GPU Sound</a><a class="pageButtons" href="/results?query=raymarch&sort=love&filter=vr&filter=multipass">VR</a><a class="pageButtons" href="/results?query=raymarch&sort=love&filter=soundinput&filter=multipass">Microphone</a><a class="pageButtons" href="/results?query=raymarch&sort=love&filter=multipass&filter=musicstream">Soundcloud</a><a class="pageButtons" href="/results?query=raymarch&sort=love&filter=webcam&filter=multipass">Webcam</a></div>
    </div>

    <div>
        <div style="text-align: center; vertical-align: middle; display: inline-block; padding-bottom:5px; padding-top:4px; margin-right:8px; margin-bottom:8px; margin-top:8px;">
        View:</div>
        <div><a class="pageButtons" href="/slideshow?query=raymarch&sort=love">Slideshow</a></div>
    </div>

    <div class="navigation" id="navTop" ><span style="padding-right:8px;">Results (36):</span><div class="controlOptions"><a id="pageButton"0 class="pageButtons" href="results?query=raymarch&sort=love&filter=multipass&from=0&num=12">1</a><a id="pageButton"1 class="pageButtons" href="results?query=raymarch&sort=love&filter=multipass&from=12&num=12">2</a><div id="pageButton"2 class="pageButtonsCurrent" href="results?query=raymarch&sort=love&filter=multipass&from=24&num=12">3</div><a id="pageButton"3 class="pageButtons" href="results?query=raymarch&sort=love&filter=multipass&from=36&num=12">4</a><a id="pageButton"4 class="pageButtons" href="results?query=raymarch&sort=love&filter=multipass&from=48&num=12">5</a><span>...</span><a id="pageButtonLast" class="pageButtons" href="results?query=raymarch&sort=love&filter=multipass&from=1044&num=12">88</a></div>
</div>
  </div>


  <div id="shaderGrid">
    <div class='searchResult'><div class='searchResultContainer' id='Preview_0_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_0_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_0_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_0_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_0_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_0_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_0_Thumnail'>        <img class='previewThumbnailImage' id='Preview_0_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_0_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_0_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_0_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_0_Info'>  <span class='previewText'  id='Preview_0_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_0_TextUser'></span>  <span class='previewStats' id='Preview_0_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_1_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_1_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_1_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_1_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_1_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_1_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_1_Thumnail'>        <img class='previewThumbnailImage' id='Preview_1_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_1_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_1_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_1_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_1_Info'>  <span class='previewText'  id='Preview_1_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_1_TextUser'></span>  <span class='previewStats' id='Preview_1_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_2_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_2_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_2_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_2_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_2_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_2_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_2_Thumnail'>        <img class='previewThumbnailImage' id='Preview_2_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_2_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_2_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_2_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_2_Info'>  <span class='previewText'  id='Preview_2_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_2_TextUser'></span>  <span class='previewStats' id='Preview_2_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_3_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_3_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_3_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_3_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_3_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_3_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_3_Thumnail'>        <img class='previewThumbnailImage' id='Preview_3_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_3_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_3_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_3_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_3_Info'>  <span class='previewText'  id='Preview_3_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_3_TextUser'></span>  <span class='previewStats' id='Preview_3_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_4_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_4_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_4_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_4_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_4_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_4_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_4_Thumnail'>        <img class='previewThumbnailImage' id='Preview_4_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_4_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_4_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_4_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_4_Info'>  <span class='previewText'  id='Preview_4_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_4_TextUser'></span>  <span class='previewStats' id='Preview_4_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_5_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_5_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_5_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_5_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_5_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_5_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_5_Thumnail'>        <img class='previewThumbnailImage' id='Preview_5_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_5_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_5_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_5_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_5_Info'>  <span class='previewText'  id='Preview_5_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_5_TextUser'></span>  <span class='previewStats' id='Preview_5_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_6_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_6_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_6_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_6_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_6_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_6_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_6_Thumnail'>        <img class='previewThumbnailImage' id='Preview_6_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_6_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_6_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_6_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_6_Info'>  <span class='previewText'  id='Preview_6_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_6_TextUser'></span>  <span class='previewStats' id='Preview_6_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_7_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_7_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_7_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_7_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_7_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_7_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_7_Thumnail'>        <img class='previewThumbnailImage' id='Preview_7_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_7_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_7_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_7_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_7_Info'>  <span class='previewText'  id='Preview_7_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_7_TextUser'></span>  <span class='previewStats' id='Preview_7_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_8_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_8_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_8_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_8_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_8_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_8_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_8_Thumnail'>        <img class='previewThumbnailImage' id='Preview_8_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_8_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_8_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_8_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_8_Info'>  <span class='previewText'  id='Preview_8_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_8_TextUser'></span>  <span class='previewStats' id='Preview_8_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_9_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_9_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_9_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_9_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_9_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_9_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_9_Thumnail'>        <img class='previewThumbnailImage' id='Preview_9_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_9_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_9_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_9_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_9_Info'>  <span class='previewText'  id='Preview_9_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_9_TextUser'></span>  <span class='previewStats' id='Preview_9_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_10_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_10_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_10_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_10_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_10_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_10_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_10_Thumnail'>        <img class='previewThumbnailImage' id='Preview_10_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_10_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_10_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_10_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_10_Info'>  <span class='previewText'  id='Preview_10_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_10_TextUser'></span>  <span class='previewStats' id='Preview_10_Stats'></span></div></div><div class='searchResult'><div class='searchResultContainer' id='Preview_11_Container'>  <a class='shaderPreview searchResultCanvas' id='Preview_11_Link'>    <div class='previewNoGLContainter searchResultCanvas' id='Preview_11_NoWebGL'>        <img class='previewThumbnailImage' id='Preview_11_ThumnailImageNoWebGL'></img>        <div class='previewNoGLMessage' id='Preview_11_MessageNoWebGL'>No Screenshot Availabe</div>    </div>    <div class='previewErrorContainer searchResultCanvas' id='Preview_11_Error'>        <div class='previewErrorMessage'>Shader Error</div>    </div>    <div class='previewThumbnailContainer searchResultCanvas' id='Preview_11_Thumnail'>        <img class='previewThumbnailImage' id='Preview_11_ThumnailImage'></img>        <div class='previewThumbnailIcon' id='Preview_11_ThumnailWarning1' title='This shader takes too long to compile, a preview image is shown instead to improve browsing.
Click on the shader to see it in real-time.'>Warning</div>        <div class='previewThumbnailIcon' id='Preview_11_ThumnailWarning2' title='You are using static shader previews.
Click on the shader to see it in real-time.'>Preview</div>    </div>    <canvas class='previewCanvas searchResultCanvas' id='Preview_11_Canvas'></canvas>  </a></div><div class='previewInfo' id='Preview_11_Info'>  <span class='previewText'  id='Preview_11_Text'></span>  <span>by</span>  <span class='previewTextUser'  id='Preview_11_TextUser'></span>  <span class='previewStats' id='Preview_11_Stats'></span></div></div>  </div>
  <br>
  <div class="navigation" id="navBottom" ><span style="padding-right:8px;">Results (36):</span><div class="controlOptions"><a id="pageButton"0 class="pageButtons" href="results?query=raymarch&sort=love&filter=multipass&from=0&num=12">1</a><a id="pageButton"1 class="pageButtons" href="results?query=raymarch&sort=love&filter=multipass&from=12&num=12">2</a><div id="pageButton"2 class="pageButtonsCurrent" href="results?query=raymarch&sort=love&filter=multipass&from=24&num=12">3</div><a id="pageButton"3 class="pageButtons" href="results?query=raymarch&sort=love&filter=multipass&from=36&num=12">4</a><a id="pageButton"4 class="pageButtons" href="results?query=raymarch&sort=love&filter=multipass&from=48&num=12">5</a><span>...</span><a id="pageButtonLast" class="pageButtons" href="results?query=raymarch&sort=love&filter=multipass&from=1044&num=12">88</a></div>
</div>  <br>      
</div>

<!-- footer ================================================================================== -->

<div id="footer">
    
    <div><span style="color:#ffffff;">Community Forums</span>
      <ul>
      <li><a class="regular" href="/events">Official Events</a></li>
      <li><a class="regular" href="https://www.facebook.com/groups/147749602472741">In Facebook (english)</a></li>
      <li><a class="regular" href="https://www.facebook.com/groups/1339783682699494">In Facebook (korean)</a></li>
      <li><a class="regular" href="https://discord.gg/XtmMN6E">In Discord</a> (<a class="regular" href="https://discordapp.com/channels/578696555612209173/579531723348639754">direct link</a>)</li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Feedback and Support</span>
      <ul>
      <li><a class="regular" href="https://www.facebook.com/Shadertoy">Facebook</a></li>
      <li><a class="regular" href="https://twitter.com/shadertoy">Twitter</a></li>
      <li><a class="regular" href="https://www.patreon.com/shadertoy">Patreon</a></li>
      <li><a class="regular" href="https://trello.com/b/5hM0CjId">Roadmap</a></li>

      
      </ul>
    </div>

    <div><span style="color:#ffffff;">Shadertoy</span>
      <ul>
      <li><a class="regular" href="/store">Store</a></li>
      <li><a class="regular" href="/howto">Documentation</a></li>
      <li><a class="regular" href="/terms">Terms & Privacy</a></li>
      <li><a class="regular" href="/about">About</a></li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Apps and Plugins</span>
      <ul>
      <li><a class="regular" href="https://itunes.apple.com/us/app/shadertoy/id717961814">Official iPhone App</a> by <a class="user" href="/user/reinder">Reinder</a></li>
      <li><a class="regular" href="https://steamcommunity.com/sharedfiles/filedetails/?id=1726697188">Screensaver</a> by <a class="user" href="/user/kosro">Kosro</a></li>
      <li><a class="regular" href="https://chrome.google.com/webstore/detail/shadertoy-unofficial-plug/ohicbclhdmkhoabobgppffepcopomhgl">Shadertoy plugin</a> by <a class="user" href="/user/patu">Patu</a></li>
      </ul>
    </div>

    <div><span style="color:#ffffff;">Tutorials</span>
      <ul>
      <li><a class="regular" href="https://www.youtube.com/watch?v=0ifChJ0nJfM">Shader coding intro</a> by <a class="user" href="/user/iq">iq</a></li>
      <li><a class="regular" href="https://shadertoyunofficial.wordpress.com/">Shadertoy Unofficial</a> by <a class="user" href="/user/FabriceNeyret2">FabriceNeyret2</a></li>
      </ul>
    </div>

</div>

<div id="compliance" style="padding-bottom:6px;visibility:hidden;left:0;top:0px;width:100%;background-color:rgb(200,120,20,0.93);position:absolute;color:#FFFFFF">
    <div style="text-align: center; margin-top:8px">
        We use cookies to give you the best experience on our website. If you continue using Shadertoy, we'll assume that you are happy to receive all cookies on this website. 
        For more information, please review our <a class="regular" href="/terms">Terms & Privacy</a>.
    </div> 
    <div style="text-align: center;margin-top:6px">
        <button type="button" style="width:100px;font-size:inherit" onclick="acceptCompliance()">Accept</button>
    </div>
</div>

<script>
(function runCompliance() 
{
    let showCompliance = 1;
    let allcookies = document.cookie;
    let cookiearray = allcookies.split(';');
    for (var i=0; i<cookiearray.length; i++)
    {
        let name  = cookiearray[i].split('=')[0];
        let value = cookiearray[i].split('=')[1];
        if (name.trim() == "scmp") 
        {
            showCompliance = value;
            break;
        }
    }

    if (showCompliance === 1) 
    {
        var ve = document.getElementById("compliance");
        ve.style.visibility="visible";
    }
})();

function acceptCompliance()
{
    let now = new Date();
    now.setTime( now.getTime() + (5*365*24*60*60*1000) );
    document.cookie="scmp=0;expires=" + now.toUTCString() + ";";

    var ve = document.getElementById("compliance");
    ve.style.visibility="hidden";
}
</script>

<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-44068895-1', 'shadertoy.com');
    ga('send', 'pageview');
</script></body>
</html>
