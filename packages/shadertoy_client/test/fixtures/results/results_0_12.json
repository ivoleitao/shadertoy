[
    {
        "ver": "0.1",
        "info": {
            "id": "4ttSWf",
            "date": "1482384986",
            "viewed": 225427,
            "name": "Rainforest",
            "username": "iq",
            "description": "Another terrain, with cheap trees made of ellipsoids and noise. It computes analytic normals for the terrain and clouds. The art composed to camera as usual. Making-of Tutorial: [url]https:\/\/www.youtube.com\/watch?v=BFld4EBO2RE[\/url]",
            "likes": 1029,
            "published": 3,
            "flags": 32,
            "usePreview": 0,
            "tags": []
        },
        "renderpass": [
            {
                "inputs": [
                    {
                        "id": "4dXGR8",
                        "filepath": "\/media\/previz\/buffer00.png",
                        "previewfilepath": "\/media\/previz\/buffer00.png",
                        "type": "buffer",
                        "channel": 0,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "4dfGRr",
                        "channel": 0
                    }
                ],
                "code": "\/\/ Copyright Inigo Quilez, 2016 - https:\/\/iquilezles.org\/\n\/\/ I am the sole copyright owner of this Work.\n\/\/ You cannot host, display, distribute or share this Work in any form,\n\/\/ including physical and digital. You cannot use this Work in any\n\/\/ commercial or non-commercial product, website or project. You cannot\n\/\/ sell this Work and you cannot mint an NFTs of it.\n\/\/ I share this Work for educational purposes, and you can link to it,\n\/\/ through an URL, proper attribution and unmodified screenshot, as part\n\/\/ of your educational material. If these conditions are too restrictive\n\/\/ please contact me and we'll definitely work it out.\n\n\/\/ A rainforest landscape.\n\/\/\n\/\/ Making of Tutorial: https:\/\/www.youtube.com\/watch?v=BFld4EBO2RE\n\/\/ Buy a metal or paper print: https:\/\/www.redbubble.com\/shop\/ap\/39843511\n\/\/\n\/\/ Normals are analytical (true derivatives) for the terrain and for the\n\/\/ clouds, including the noise, the fbm and the smoothsteps.\n\/\/\n\/\/ Lighting and art composed for this shot\/camera. The trees are really\n\/\/ ellipsoids with noise, but they kind of do the job in distance and low\n\/\/ image resolutions Also I used some basic reprojection technique to \n\/\/ smooth out the render.\n\/\/\n\/\/ See here for more info: \n\/\/  https:\/\/iquilezles.org\/articles\/fbm\n\/\/  https:\/\/iquilezles.org\/articles\/morenoise\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord\/iResolution.xy;\n\n    vec3 col = texture( iChannel0, p ).xyz;\n  \/\/vec3 col = texelFetch( iChannel0, ivec2(fragCoord-0.5), 0 ).xyz;\n\n    col *= 0.5 + 0.5*pow( 16.0*p.x*p.y*(1.0-p.x)*(1.0-p.y), 0.05 );\n         \n    fragColor = vec4( col, 1.0 );\n}\n",
                "name": "Image",
                "description": "",
                "type": "image"
            },
            {
                "inputs": [
                    {
                        "id": "4dXGR8",
                        "filepath": "\/media\/previz\/buffer00.png",
                        "previewfilepath": "\/media\/previz\/buffer00.png",
                        "type": "buffer",
                        "channel": 0,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "4dXGR8",
                        "channel": 0
                    }
                ],
                "code": "#define LOWQUALITY\n\n\/\/==========================================================================================\n\/\/ general utilities\n\/\/==========================================================================================\n#define ZERO (min(iFrame,0))\n\nfloat sdEllipsoidY( in vec3 p, in vec2 r )\n{\n    float k0 = length(p\/r.xyx);\n    float k1 = length(p\/(r.xyx*r.xyx));\n    return k0*(k0-1.0)\/k1;\n}\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p\/r);\n    float k1 = length(p\/(r*r));\n    return k0*(k0-1.0)\/k1;\n}\n\n\/\/ return smoothstep and its derivative\nvec2 smoothstepd( float a, float b, float x)\n{\n\tif( x<a ) return vec2( 0.0, 0.0 );\n\tif( x>b ) return vec2( 1.0, 0.0 );\n    float ir = 1.0\/(b-a);\n    x = (x-a)*ir;\n    return vec2( x*x*(3.0-2.0*x), 6.0*x*(1.0-x)*ir );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\/\/==========================================================================================\n\/\/ hashes (low quality, do NOT use in production)\n\/\/==========================================================================================\n\nfloat hash1( vec2 p )\n{\n    p  = 50.0*fract( p*0.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat hash1( float n )\n{\n    return fract( n*17.0*fract( n*0.3183099 ) );\n}\n\nvec2 hash2( vec2 p ) \n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    float n = 111.0*p.x + 113.0*p.y;\n    return fract(n*fract(k*n));\n}\n\n\/\/==========================================================================================\n\/\/ noises\n\/\/==========================================================================================\n\n\/\/ value noise, and its analytical derivatives\nvec4 noised( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    #if 1\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n    #else\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    #endif\n\n    float n = p.x + 317.0*p.y + 157.0*p.z;\n    \n    float a = hash1(n+0.0);\n    float b = hash1(n+1.0);\n    float c = hash1(n+317.0);\n    float d = hash1(n+318.0);\n    float e = hash1(n+157.0);\n\tfloat f = hash1(n+158.0);\n    float g = hash1(n+474.0);\n    float h = hash1(n+475.0);\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z), \n                      2.0* du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\n                                      k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\n                                      k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    #if 1\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    #else\n    vec3 u = w*w*(3.0-2.0*w);\n    #endif\n    \n\n\n    float n = p.x + 317.0*p.y + 157.0*p.z;\n    \n    float a = hash1(n+0.0);\n    float b = hash1(n+1.0);\n    float c = hash1(n+317.0);\n    float d = hash1(n+318.0);\n    float e = hash1(n+157.0);\n\tfloat f = hash1(n+158.0);\n    float g = hash1(n+474.0);\n    float h = hash1(n+475.0);\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z);\n}\n\nvec3 noised( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    #if 1\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec2 du = 30.0*w*w*(w*(w-2.0)+1.0);\n    #else\n    vec2 u = w*w*(3.0-2.0*w);\n    vec2 du = 6.0*w*(1.0-w);\n    #endif\n    \n    float a = hash1(p+vec2(0,0));\n    float b = hash1(p+vec2(1,0));\n    float c = hash1(p+vec2(0,1));\n    float d = hash1(p+vec2(1,1));\n\n    float k0 = a;\n    float k1 = b - a;\n    float k2 = c - a;\n    float k4 = a - b - c + d;\n\n    return vec3( -1.0+2.0*(k0 + k1*u.x + k2*u.y + k4*u.x*u.y), \n                 2.0*du * vec2( k1 + k4*u.y,\n                            k2 + k4*u.x ) );\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    #if 1\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    #else\n    vec2 u = w*w*(3.0-2.0*w);\n    #endif\n\n    float a = hash1(p+vec2(0,0));\n    float b = hash1(p+vec2(1,0));\n    float c = hash1(p+vec2(0,1));\n    float d = hash1(p+vec2(1,1));\n    \n    return -1.0+2.0*(a + (b-a)*u.x + (c-a)*u.y + (a - b - c + d)*u.x*u.y);\n}\n\n\/\/==========================================================================================\n\/\/ fbm constructions\n\/\/==========================================================================================\n\nconst mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                      -0.80,  0.36, -0.48,\n                      -0.60, -0.48,  0.64 );\nconst mat3 m3i = mat3( 0.00, -0.80, -0.60,\n                       0.80,  0.36, -0.48,\n                       0.60, -0.48,  0.64 );\nconst mat2 m2 = mat2(  0.80,  0.60,\n                      -0.60,  0.80 );\nconst mat2 m2i = mat2( 0.80, -0.60,\n                       0.60,  0.80 );\n\n\/\/------------------------------------------------------------------------------------------\n\nfloat fbm_4( in vec2 x )\n{\n    float f = 1.9;\n    float s = 0.55;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=ZERO; i<4; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*m2*x;\n    }\n\treturn a;\n}\n\nfloat fbm_4( in vec3 x )\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=ZERO; i<4; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*m3*x;\n    }\n\treturn a;\n}\n\nvec4 fbmd_7( in vec3 x )\n{\n    float f = 1.92;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    vec3  d = vec3(0.0);\n    mat3  m = mat3(1.0,0.0,0.0,\n                   0.0,1.0,0.0,\n                   0.0,0.0,1.0);\n    for( int i=ZERO; i<7; i++ )\n    {\n        vec4 n = noised(x);\n        a += b*n.x;          \/\/ accumulate values\t\t\n        d += b*m*n.yzw;      \/\/ accumulate derivatives\n        b *= s;\n        x = f*m3*x;\n        m = f*m3i*m;\n    }\n\treturn vec4( a, d );\n}\n\nvec4 fbmd_8( in vec3 x )\n{\n    float f = 2.0;\n    float s = 0.65;\n    float a = 0.0;\n    float b = 0.5;\n    vec3  d = vec3(0.0);\n    mat3  m = mat3(1.0,0.0,0.0,\n                   0.0,1.0,0.0,\n                   0.0,0.0,1.0);\n    for( int i=ZERO; i<8; i++ )\n    {\n        vec4 n = noised(x);\n        a += b*n.x;          \/\/ accumulate values\t\t\n        if( i<4 )\n        d += b*m*n.yzw;      \/\/ accumulate derivatives\n        b *= s;\n        x = f*m3*x;\n        m = f*m3i*m;\n    }\n\treturn vec4( a, d );\n}\n\nfloat fbm_9( in vec2 x )\n{\n    float f = 1.9;\n    float s = 0.55;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=ZERO; i<9; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*m2*x;\n    }\n    \n\treturn a;\n}\n\nvec3 fbmd_9( in vec2 x )\n{\n    float f = 1.9;\n    float s = 0.55;\n    float a = 0.0;\n    float b = 0.5;\n    vec2  d = vec2(0.0);\n    mat2  m = mat2(1.0,0.0,0.0,1.0);\n    for( int i=ZERO; i<9; i++ )\n    {\n        vec3 n = noised(x);\n        n.x = n.x;\n        \n        a += b*n.x;          \/\/ accumulate values\t\t\n        d += b*m*n.yz;       \/\/ accumulate derivatives\n        b *= s;\n        x = f*m2*x;\n        m = f*m2i*m;\n    }\n\n\treturn vec3( a, d );\n}\n\n\/\/==========================================================================================\n\/\/ specifics to the actual painting\n\/\/==========================================================================================\n\n\n\/\/------------------------------------------------------------------------------------------\n\/\/ global\n\/\/------------------------------------------------------------------------------------------\n\nconst vec3  kSunDir = vec3(-0.624695,0.468521,-0.624695);\nconst float kMaxTreeHeight = 4.8;\nconst float kMaxHeight = 840.0;\n\nvec3 fog( in vec3 col, float t )\n{\n    vec3 ext = exp2(-t*0.00025*vec3(1,1.5,4)); \n    return col*ext + (1.0-ext)*vec3(0.55,0.55,0.58); \/\/ 0.55\n}\n\n\/\/------------------------------------------------------------------------------------------\n\/\/ clouds\n\/\/------------------------------------------------------------------------------------------\n\nvec4 cloudsFbm( in vec3 pos )\n{\n    return fbmd_8(pos*0.0015+vec3(2.0,1.1,1.0)+0.07*vec3(iTime,0.5*iTime,-0.15*iTime));\n}\n\nvec4 cloudsMap( in vec3 pos, out float nnd )\n{\n    float d = abs(pos.y-900.0)-40.0;\n    vec3 gra = vec3(0.0,sign(pos.y-900.0),0.0);\n    \n    vec4 n = cloudsFbm(pos);\n    d += 400.0*n.x * (0.7+0.3*gra.y);\n    \n    if( d>0.0 ) return vec4(-d,0.0,0.0,0.0);\n    \n    nnd = -d;\n    d = min(-d\/100.0,0.25);\n    \n    \/\/gra += 0.1*n.yzw *  (0.7+0.3*gra.y);\n    \n    return vec4( d, gra );\n}\n\nfloat cloudsShadowFlat( in vec3 ro, in vec3 rd )\n{\n    float t = (900.0-ro.y)\/rd.y;\n    if( t<0.0 ) return 1.0;\n    vec3 pos = ro + rd*t;\n    return cloudsFbm(pos).x;\n}\n\nfloat terrainShadow( in vec3 ro, in vec3 rd, in float mint );\n\nvec4 renderClouds( in vec3 ro, in vec3 rd, float tmin, float tmax, inout float resT, in vec2 px )\n{\n    vec4 sum = vec4(0.0);\n\n    \/\/ bounding volume!!\n    float tl = ( 600.0-ro.y)\/rd.y;\n    float th = (1200.0-ro.y)\/rd.y;\n    if( tl>0.0 ) tmin = max( tmin, tl ); else return sum;\n    if( th>0.0 ) tmax = min( tmax, th );\n\n    float t = tmin;\n    \/\/t += 1.0*hash1(gl_FragCoord.xy);\n    float lastT = -1.0;\n    float thickness = 0.0;\n    for(int i=ZERO; i<128; i++)\n    { \n        vec3  pos = ro + t*rd; \n        float nnd;\n        vec4  denGra = cloudsMap( pos, nnd ); \n        float den = denGra.x;\n        float dt = max(0.2,0.011*t);\n        \/\/dt *= hash1(px+float(i));\n        if( den>0.001 ) \n        { \n            float kk;\n            cloudsMap( pos+kSunDir*70.0, kk );\n            float sha = 1.0-smoothstep(-200.0,200.0,kk); sha *= 1.5;\n            \n            vec3 nor = normalize(denGra.yzw);\n            float dif = clamp( 0.4+0.6*dot(nor,kSunDir), 0.0, 1.0 )*sha; \n            float fre = clamp( 1.0+dot(nor,rd), 0.0, 1.0 )*sha;\n            float occ = 0.2+0.7*max(1.0-kk\/200.0,0.0) + 0.1*(1.0-den);\n            \/\/ lighting\n            vec3 lin  = vec3(0.0);\n                 lin += vec3(0.70,0.80,1.00)*1.0*(0.5+0.5*nor.y)*occ;\n                 lin += vec3(0.10,0.40,0.20)*1.0*(0.5-0.5*nor.y)*occ;\n                 lin += vec3(1.00,0.95,0.85)*3.0*dif*occ + 0.1;\n\n            \/\/ color\n            vec3 col = vec3(0.8,0.8,0.8)*0.45;\n\n            col *= lin;\n\n            col = fog( col, t );\n\n            \/\/ front to back blending    \n            float alp = clamp(den*0.5*0.125*dt,0.0,1.0);\n            col.rgb *= alp;\n            sum = sum + vec4(col,alp)*(1.0-sum.a);\n\n            thickness += dt*den;\n            if( lastT<0.0 ) lastT = t;            \n        }\n        else \n        {\n            dt = abs(den)+0.2;\n\n        }\n        t += dt;\n        if( sum.a>0.995 || t>tmax ) break;\n    }\n    \n    \/\/resT = min(resT, (150.0-ro.y)\/rd.y );\n    if( lastT>0.0 ) resT = min(resT,lastT);\n    \/\/if( lastT>0.0 ) resT = mix( resT, lastT, sum.w );\n    \n    \n    sum.xyz += max(0.0,1.0-0.0125*thickness)*vec3(1.00,0.60,0.40)*0.3*pow(clamp(dot(kSunDir,rd),0.0,1.0),32.0);\n\n    return clamp( sum, 0.0, 1.0 );\n}\n\n\n\/\/------------------------------------------------------------------------------------------\n\/\/ terrain\n\/\/------------------------------------------------------------------------------------------\n\nvec2 terrainMap( in vec2 p )\n{\n    float e = fbm_9( p\/2000.0 + vec2(1.0,-2.0) );\n    float a = 1.0-smoothstep( 0.12, 0.13, abs(e+0.12) ); \/\/ flag high-slope areas (-0.25, 0.0)\n    e = 600.0*e + 600.0;\n    \n    \/\/ cliff\n    e += 90.0*smoothstep( 552.0, 594.0, e );\n    \/\/e += 90.0*smoothstep( 550.0, 600.0, e );\n    \n    return vec2(e,a);\n}\n\nvec4 terrainMapD( in vec2 p )\n{\n    vec3 e = fbmd_9( p\/2000.0 + vec2(1.0,-2.0) );\n    e.x  = 600.0*e.x + 600.0;\n    e.yz = 600.0*e.yz;\n\n    \/\/ cliff\n    vec2 c = smoothstepd( 550.0, 600.0, e.x );\n\te.x  = e.x  + 90.0*c.x;\n\te.yz = e.yz + 90.0*c.y*e.yz;     \/\/ chain rule\n    \n    e.yz \/= 2000.0;\n    return vec4( e.x, normalize( vec3(-e.y,1.0,-e.z) ) );\n}\n\nvec3 terrainNormal( in vec2 pos )\n{\n#if 1\n    return terrainMapD(pos).yzw;\n#else    \n    vec2 e = vec2(0.03,0.0);\n\treturn normalize( vec3(terrainMap(pos-e.xy).x - terrainMap(pos+e.xy).x,\n                           2.0*e.x,\n                           terrainMap(pos-e.yx).x - terrainMap(pos+e.yx).x ) );\n#endif    \n}\n\nfloat terrainShadow( in vec3 ro, in vec3 rd, in float mint )\n{\n    float res = 1.0;\n    float t = mint;\n#ifdef LOWQUALITY\n    for( int i=ZERO; i<32; i++ )\n    {\n        vec3  pos = ro + t*rd;\n        vec2  env = terrainMap( pos.xz );\n        float hei = pos.y - env.x;\n        res = min( res, 32.0*hei\/t );\n        if( res<0.0001 || pos.y>kMaxHeight ) break;\n        t += clamp( hei, 2.0+t*0.1, 100.0 );\n    }\n#else\n    for( int i=ZERO; i<128; i++ )\n    {\n        vec3  pos = ro + t*rd;\n        vec2  env = terrainMap( pos.xz );\n        float hei = pos.y - env.x;\n        res = min( res, 32.0*hei\/t );\n        if( res<0.0001 || pos.y>kMaxHeight  ) break;\n        t += clamp( hei, 0.5+t*0.05, 25.0 );\n    }\n#endif\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec2 raymarchTerrain( in vec3 ro, in vec3 rd, float tmin, float tmax )\n{\n    \/\/ bounding plane\n    float tp = (kMaxHeight+kMaxTreeHeight-ro.y)\/rd.y;\n    if( tp>0.0 ) tmax = min( tmax, tp );\n    \n    \/\/ raymarch\n    float dis, th;\n    float t2 = -1.0;\n    float t = tmin; \n    float ot = t;\n    float odis = 0.0;\n    float odis2 = 0.0;\n    for( int i=ZERO; i<400; i++ )\n    {\n        th = 0.001*t;\n\n        vec3  pos = ro + t*rd;\n        vec2  env = terrainMap( pos.xz );\n        float hei = env.x;\n\n        \/\/ tree envelope\n        float dis2 = pos.y - (hei+kMaxTreeHeight*1.1);\n        if( dis2<th ) \n        {\n            if( t2<0.0 )\n            {\n                t2 = ot + (th-odis2)*(t-ot)\/(dis2-odis2); \/\/ linear interpolation for better accuracy\n            }\n        }\n        odis2 = dis2;\n        \n        \/\/ terrain\n        dis = pos.y - hei;\n        if( dis<th ) break;\n        \n        ot = t;\n        odis = dis;\n        t += dis*0.8*(1.0-0.75*env.y); \/\/ slow down in step areas\n        if( t>tmax ) break;\n    }\n\n    if( t>tmax ) t = -1.0;\n    else t = ot + (th-odis)*(t-ot)\/(dis-odis); \/\/ linear interpolation for better accuracy\n    \n    return vec2(t,t2);\n}\n\n\/\/------------------------------------------------------------------------------------------\n\/\/ trees\n\/\/------------------------------------------------------------------------------------------\n\nfloat treesMap( in vec3 p, in float rt, out float oHei, out float oMat, out float oDis )\n{\n    oHei = 1.0;\n    oDis = 0.0;\n    oMat = 0.0;\n        \n    float base = terrainMap(p.xz).x; \n    \n    float bb = fbm_4(p.xz*0.075);\n\n    float d = 20.0;\n    vec2 n = floor( p.xz\/2.0 );\n    vec2 f = fract( p.xz\/2.0 );\n    for( int j=0; j<=1; j++ )\n    for( int i=0; i<=1; i++ )\n    {\n        vec2  g = vec2( float(i), float(j) ) - step(f,vec2(0.5));\n        vec2  o = hash2( n + g );\n        vec2  v = hash2( n + g + vec2(13.1,71.7) );\n        vec2  r = g - f + o;\n\n        float height = kMaxTreeHeight * (0.4+0.8*v.x);\n        float width = 0.5 + 0.2*v.x + 0.3*v.y;\n\n        if( bb<0.0 ) width *= 0.5; else height *= 0.7;\n        \n        vec3  q = vec3(r.x,p.y-base-height*0.5,r.y);\n        \n        float k = sdEllipsoidY( q, vec2(width,0.5*height) );\n\n        if( k<d )\n        { \n            d = k;\n            oMat = 0.5*hash1(n+g+111.0);\n            if( bb>0.0 ) oMat += 0.5;\n            oHei = (p.y - base)\/height;\n            oHei *= 0.5 + 0.5*length(q) \/ width;\n        }\n    }\n\n    \/\/ distort ellipsoids to make them look like trees (works only in the distance really)\n    if( rt<1200.0 )\n    {\n        p.y -= 600.0;\n        float s = fbm_4( p*3.0 );\n        s = s*s;\n        float att = 1.0-smoothstep(100.0,1200.0,rt);\n        d += 4.0*s*att;\n        oDis = s*att;\n    }\n    \n    return d;\n}\n\nfloat treesShadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.02;\n#ifdef LOWQUALITY\n    for( int i=ZERO; i<64; i++ )\n    {\n        float kk1, kk2, kk3;\n        vec3 pos = ro + rd*t;\n        float h = treesMap( pos, t, kk1, kk2, kk3 );\n        res = min( res, 32.0*h\/t );\n        t += h;\n        if( res<0.001 || t>50.0 || pos.y>kMaxHeight+kMaxTreeHeight ) break;\n    }\n#else\n    for( int i=ZERO; i<150; i++ )\n    {\n        float kk1, kk2, kk3;\n        float h = treesMap( ro + rd*t, t, kk1, kk2, kk3 );\n        res = min( res, 32.0*h\/t );\n        t += h;\n        if( res<0.001 || t>120.0 ) break;\n    }\n#endif\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 treesNormal( in vec3 pos, in float t )\n{\n    float kk1, kk2, kk3;\n#if 0    \n    const float eps = 0.005;\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*treesMap( pos + e.xyy, t, kk1, kk2, kk3 ) + \n                      e.yyx*treesMap( pos + e.yyx, t, kk1, kk2, kk3 ) + \n                      e.yxy*treesMap( pos + e.yxy, t, kk1, kk2, kk3 ) + \n                      e.xxx*treesMap( pos + e.xxx, t, kk1, kk2, kk3 ) );            \n#else\n    \/\/ inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*treesMap(pos+0.005*e, t, kk1, kk2, kk3);\n    }\n    return normalize(n);\n#endif    \n}\n\n\/\/------------------------------------------------------------------------------------------\n\/\/ sky\n\/\/------------------------------------------------------------------------------------------\n\nvec3 renderSky( in vec3 ro, in vec3 rd )\n{\n    \/\/ background sky     \n    \/\/vec3 col = vec3(0.45,0.6,0.85)\/0.85 - rd.y*vec3(0.4,0.36,0.4);\n    \/\/vec3 col = vec3(0.4,0.6,1.1) - rd.y*0.4;\n    vec3 col = vec3(0.42,0.62,1.1) - rd.y*0.4;\n\n    \/\/ clouds\n    float t = (2500.0-ro.y)\/rd.y;\n    if( t>0.0 )\n    {\n        vec2 uv = (ro+t*rd).xz;\n        float cl = fbm_9( uv*0.00104 );\n        float dl = smoothstep(-0.2,0.6,cl);\n        col = mix( col, vec3(1.0), 0.12*dl );\n    }\n    \n\t\/\/ sun glare    \n    float sun = clamp( dot(kSunDir,rd), 0.0, 1.0 );\n    col += 0.2*vec3(1.0,0.6,0.3)*pow( sun, 32.0 );\n    \n\treturn col;\n}\n\n\/\/------------------------------------------------------------------------------------------\n\/\/ main image making function\n\/\/------------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o = hash2( vec2(iFrame,1) ) - 0.5;\n    \n    vec2 p = (2.0*(fragCoord+o)-iResolution.xy)\/ iResolution.y;\n    \n    \/\/----------------------------------\n    \/\/ setup\n    \/\/----------------------------------\n\n    \/\/ camera\n    float time = iTime;\n    vec3 ro = vec3(0.0, 401.5, 6.0);\n    vec3 ta = vec3(0.0, 403.5, -90.0 + ro.z );\n    \n    \/\/ro += vec3(10.0*sin(0.02*time),0.0,-10.0*sin(0.2+0.031*time))\n    \n    ro.x -= 80.0*sin(0.01*time);\n    ta.x -= 86.0*sin(0.01*time);\n\n    \/\/ ray\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    vec3 rd = ca * normalize( vec3(p,1.5));\n\n\tfloat resT = 2000.0;\n\n    \/\/----------------------------------\n    \/\/ sky\n    \/\/----------------------------------\n\n    vec3 col = renderSky( ro, rd );\n\n\n    \/\/----------------------------------\n    \/\/ raycast terrain and tree envelope\n    \/\/----------------------------------\n    {\n    const float tmax = 2000.0;\n    int   obj = 0;\n    vec2 t = raymarchTerrain( ro, rd, 15.0, tmax );\n    if( t.x>0.0 )\n    {\n        resT = t.x;\n        obj = 1;\n    }\n\n    \/\/----------------------------------\n    \/\/ raycast trees, if needed\n    \/\/----------------------------------\n    float hei, mid, displa;\n    \n    if( t.y>0.0 )\n    {\n        float tf = t.y;\n        float tfMax = (t.x>0.0)?t.x:tmax;\n        for(int i=ZERO; i<64; i++) \n        { \n            vec3  pos = ro + tf*rd; \n            float dis = treesMap( pos, tf, hei, mid, displa); \n            if( dis<(0.000125*tf) ) break;\n            tf += dis;\n            if( tf>tfMax ) break;\n        }\n        if( tf<tfMax )\n        {\n            resT = tf;\n            obj = 2;\n        }\n    }\n\n    \/\/----------------------------------\n    \/\/ shade\n    \/\/----------------------------------\n    if( obj>0 )\n    {\n        vec3 pos  = ro + resT*rd;\n        vec3 epos = pos + vec3(0.0,4.8,0.0);\n\n        float sha1  = terrainShadow( pos+vec3(0,0.02,0), kSunDir, 0.02 );\n        \/\/sha1 *= smoothstep(-0.3,0.0,cloudsShadowFlat(epos, kSunDir));\n        sha1 *= smoothstep(-0.325,-0.075,cloudsShadowFlat(epos, kSunDir));\n        \n        #ifndef LOWQUALITY\n        float sha2  = treesShadow( pos+vec3(0,0.02,0), kSunDir );\n        #endif\n\n        vec3 tnor = terrainNormal( pos.xz );\n        vec3 nor;\n        \n        vec3 speC = vec3(1.0);\n        \/\/----------------------------------\n        \/\/ terrain\n        \/\/----------------------------------\n        if( obj==1 )\n        {\n            \/\/ bump map\n            nor = normalize( tnor + 0.8*(1.0-abs(tnor.y))*0.8*fbmd_7( (pos-vec3(0,600,0))*0.15*vec3(1.0,0.2,1.0) ).yzw );\n\n            col = vec3(0.18,0.12,0.10)*.85;\n\n            col = 1.0*mix( col, vec3(0.1,0.1,0.0)*0.2, smoothstep(0.7,0.9,nor.y) );      \n            float dif = clamp( dot( nor, kSunDir), 0.0, 1.0 ); \n            dif *= sha1;\n            #ifndef LOWQUALITY\n            dif *= sha2;\n            #endif\n\n            float bac = clamp( dot(normalize(vec3(-kSunDir.x,0.0,-kSunDir.z)),nor), 0.0, 1.0 );\n            float foc = clamp( (pos.y\/2.0-180.0)\/130.0, 0.0,1.0);\n            float dom = clamp( 0.5 + 0.5*nor.y, 0.0, 1.0 );\n            vec3  lin  = 1.0*0.2*mix(0.1*vec3(0.1,0.2,0.1),vec3(0.7,0.9,1.5)*3.0,dom)*foc;\n                  lin += 1.0*8.5*vec3(1.0,0.9,0.8)*dif;        \n                  lin += 1.0*0.27*vec3(1.1,1.0,0.9)*bac*foc;\n            speC = vec3(4.0)*dif*smoothstep(20.0,0.0,abs(pos.y\/2.0-310.0)-20.0);\n\n            col *= lin;\n        }\n        \/\/----------------------------------\n        \/\/ trees\n        \/\/----------------------------------\n        else \/\/if( obj==2 )\n        {\n            vec3 gnor = treesNormal( pos, resT );\n            \n            nor = normalize( gnor + 2.0*tnor );\n\n            \/\/ --- lighting ---\n            vec3  ref = reflect(rd,nor);\n            float occ = clamp(hei,0.0,1.0) * pow(1.0-2.0*displa,3.0);\n            float dif = clamp( 0.1 + 0.9*dot( nor, kSunDir), 0.0, 1.0 ); \n            dif *= sha1;\n            if( dif>0.0001 )\n            {\n                float a = clamp( 0.5+0.5*dot(tnor,kSunDir), 0.0, 1.0);\n                a = a*a;\n                a *= occ;\n                a *= 0.6;\n                a *= smoothstep(60.0,200.0,resT);\n                \/\/ tree shadows with fake transmission\n                #ifdef LOWQUALITY\n                float sha2  = treesShadow( pos+kSunDir*0.1, kSunDir );\n                #endif\n                dif *= a+(1.0-a)*sha2;\n            }\n            float dom = clamp( 0.5 + 0.5*nor.y, 0.0, 1.0 );\n            float bac = clamp( 0.5+0.5*dot(normalize(vec3(-kSunDir.x,0.0,-kSunDir.z)),nor), 0.0, 1.0 );                 \n            float fre = clamp(1.0+dot(nor,rd),0.0,1.0);\n            \/\/float spe = pow( clamp(dot(ref,kSunDir),0.0, 1.0), 9.0 )*dif*(0.2+0.8*pow(fre,5.0))*occ;\n\n            \/\/ --- lights ---\n            vec3 lin  = 12.0*vec3(1.2,1.0,0.7)*dif*occ*(2.5-1.5*smoothstep(0.0,120.0,resT));\n                 lin += 0.55*mix(0.1*vec3(0.1,0.2,0.0),vec3(0.6,1.0,1.0),dom*occ);\n                 lin += 0.07*vec3(1.0,1.0,0.9)*bac*occ;\n                 lin += 1.10*vec3(0.9,1.0,0.8)*pow(fre,5.0)*occ*(1.0-smoothstep(100.0,200.0,resT));\n            speC = dif*vec3(1.0,1.1,1.5)*1.2;\n\n            \/\/ --- material ---\n            float brownAreas = fbm_4( pos.zx*0.015 );\n            col = vec3(0.2,0.2,0.05);\n            col = mix( col, vec3(0.32,0.2,0.05), smoothstep(0.2,0.9,fract(2.0*mid)) );\n            col *= (mid<0.5)?0.65+0.35*smoothstep(300.0,600.0,resT)*smoothstep(700.0,500.0,pos.y):1.0;\n            col = mix( col, vec3(0.25,0.16,0.01)*0.825, 0.7*smoothstep(0.1,0.3,brownAreas)*smoothstep(0.5,0.8,tnor.y) );\n            col *= 1.0-0.5*smoothstep(400.0,700.0,pos.y);\n            col *= lin;\n        }\n\n        \/\/ spec\n        vec3  ref = reflect(rd,nor);            \n        float fre = clamp(1.0+dot(nor,rd),0.0,1.0);\n        float spe = 3.0*pow( clamp(dot(ref,kSunDir),0.0, 1.0), 9.0 )*(0.05+0.95*pow(fre,5.0));\n        col += spe*speC;\n\n        col = fog(col,resT);\n    }\n    }\n\n\n\n    float isCloud = 0.0;\n    \/\/----------------------------------\n    \/\/ clouds\n    \/\/----------------------------------\n    {\n        vec4 res = renderClouds( ro, rd, 0.0, resT, resT, fragCoord );\n        col = col*(1.0-res.w) + res.xyz;\n        isCloud = res.w;\n    }\n\n    \/\/----------------------------------\n    \/\/ final\n    \/\/----------------------------------\n    \n    \/\/ sun glare    \n    float sun = clamp( dot(kSunDir,rd), 0.0, 1.0 );\n    col += 0.25*vec3(0.8,0.4,0.2)*pow( sun, 4.0 );\n \n\n    \/\/ gamma\n    \/\/col = sqrt( clamp(col,0.0,1.0) );\n    col = pow( clamp(col*1.1-0.02,0.0,1.0), vec3(0.4545) );\n\n    \/\/ contrast\n    col = col*col*(3.0-2.0*col);            \n    \n    \/\/ color grade    \n    col = pow( col, vec3(1.0,0.92,1.0) );   \/\/ soft green\n    col *= vec3(1.02,0.99,0.9 );            \/\/ tint red\n    col.z = col.z+0.1;                      \/\/ bias blue\n    \n    \/\/------------------------------------------\n\t\/\/ reproject from previous frame and average\n    \/\/------------------------------------------\n\n    mat4 oldCam = mat4( textureLod(iChannel0,vec2(0.5,0.5)\/iResolution.xy, 0.0),\n                        textureLod(iChannel0,vec2(1.5,0.5)\/iResolution.xy, 0.0),\n                        textureLod(iChannel0,vec2(2.5,0.5)\/iResolution.xy, 0.0),\n                        0.0, 0.0, 0.0, 1.0 );\n    \n    \/\/ world space\n    vec4 wpos = vec4(ro + rd*resT,1.0);\n    \/\/ camera space\n    vec3 cpos = (wpos*oldCam).xyz; \/\/ note inverse multiply\n    \/\/ ndc space\n    vec2 npos = 1.5 * cpos.xy \/ cpos.z;\n    \/\/ screen space\n    vec2 spos = 0.5 + 0.5*npos*vec2(iResolution.y\/iResolution.x,1.0);\n    \/\/ undo dither\n    spos -= o\/iResolution.xy;\n\t\/\/ raster space\n    vec2 rpos = spos * iResolution.xy;\n    \n    if( rpos.y<1.0 && rpos.x<3.0 )\n    {\n    }\n\telse\n    {\n        vec3 ocol = textureLod( iChannel0, spos, 0.0 ).xyz;\n    \tif( iFrame==0 ) ocol = col;\n        col = mix( ocol, col, 0.1+0.8*isCloud );\n    }\n\n    \/\/----------------------------------\n                           \n\tif( fragCoord.y<1.0 && fragCoord.x<3.0 )\n    {\n        if( abs(fragCoord.x-2.5)<0.5 ) fragColor = vec4( ca[2], -dot(ca[2],ro) );\n        if( abs(fragCoord.x-1.5)<0.5 ) fragColor = vec4( ca[1], -dot(ca[1],ro) );\n        if( abs(fragCoord.x-0.5)<0.5 ) fragColor = vec4( ca[0], -dot(ca[0],ro) );\n    }\n    else\n    {\n        fragColor = vec4( col, 1.0 );\n    }\n}",
                "name": "Buffer A",
                "description": "",
                "type": "buffer"
            }
        ]
    },
    {
        "ver": "0.1",
        "info": {
            "id": "MdX3Rr",
            "date": "1360495251",
            "viewed": 193104,
            "name": "Elevated",
            "username": "iq",
            "description": "A raymarched version of the demo Elevated from 2009.",
            "likes": 854,
            "published": 3,
            "flags": 32,
            "usePreview": 0,
            "tags": []
        },
        "renderpass": [
            {
                "inputs": [
                    {
                        "id": "4dXGR8",
                        "filepath": "\/media\/previz\/buffer00.png",
                        "previewfilepath": "\/media\/previz\/buffer00.png",
                        "type": "buffer",
                        "channel": 0,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "4dfGRr",
                        "channel": 0
                    }
                ],
                "code": "\/\/ Copyright Inigo Quilez, 2013 - https:\/\/iquilezles.org\/\n\/\/ I am the sole copyright owner of this Work.\n\/\/ You cannot host, display, distribute or share this Work in any form,\n\/\/ including physical and digital. You cannot use this Work in any\n\/\/ commercial or non-commercial product, website or project. You cannot\n\/\/ sell this Work and you cannot mint an NFTs of it.\n\/\/ I share this Work for educational purposes, and you can link to it,\n\/\/ through an URL, proper attribution and unmodified screenshot, as part\n\/\/ of your educational material. If these conditions are too restrictive\n\/\/ please contact me and we'll definitely work it out.\n\n\n\/\/ on the derivatives based noise: https:\/\/iquilezles.org\/articles\/morenoise\n\/\/ on the soft shadow technique: https:\/\/iquilezles.org\/articles\/rmshadows\n\/\/ on the fog calculations: https:\/\/iquilezles.org\/articles\/fog\n\/\/ on the lighting: https:\/\/iquilezles.org\/articles\/outdoorslighting\n\/\/ on the raymarching: https:\/\/iquilezles.org\/articles\/terrainmarching\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord\/iResolution.xy;\n    vec4 data = texture( iChannel0, uv );\n\n    vec3 col = vec3(0.0);\n    if( data.w < 0.0 )\n    {\n        col = data.xyz;\n    }\n    else\n    {\n        \/\/ decompress velocity vector\n        float ss = mod(data.w,1024.0)\/1023.0;\n        float st = floor(data.w\/1024.0)\/1023.0;\n\n        \/\/ motion blur (linear blur across velocity vectors\n        vec2 dir = (-1.0 + 2.0*vec2( ss, st ))*0.25;\n        col = vec3(0.0);\n        for( int i=0; i<32; i++ )\n        {\n            float h = float(i)\/31.0;\n            vec2 pos = uv + dir*h;\n            col += texture( iChannel0, pos ).xyz;\n        }\n        col \/= 32.0;\n    }\n    \n    \/\/ vignetting\t\n\tcol *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 );\n\n    col = clamp(col,0.0,1.0);\n    col = col*0.6 + 0.4*col*col*(3.0-2.0*col) + vec3(0.0,0.0,0.04);\n    \n\n    \n    fragColor = vec4( col, 1.0 );\n}",
                "name": "Image",
                "description": "",
                "type": "image"
            },
            {
                "inputs": [
                    {
                        "id": "4dXGzn",
                        "filepath": "\/media\/a\/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png",
                        "previewfilepath": "\/media\/ap\/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png",
                        "type": "texture",
                        "channel": 0,
                        "sampler": {
                            "filter": "mipmap",
                            "wrap": "repeat",
                            "vflip": "false",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "4dXGR8",
                        "channel": 0
                    }
                ],
                "code": "\/\/ Copyright Inigo Quilez, 2016 - https:\/\/iquilezles.org\/\n\/\/ I am the sole copyright owner of this Work.\n\/\/ You cannot host, display, distribute or share this Work in any form,\n\/\/ including physical and digital. You cannot use this Work in any\n\/\/ commercial or non-commercial product, website or project. You cannot\n\/\/ sell this Work and you cannot mint an NFTs of it.\n\/\/ I share this Work for educational purposes, and you can link to it,\n\/\/ through an URL, proper attribution and unmodified screenshot, as part\n\/\/ of your educational material. If these conditions are too restrictive\n\/\/ please contact me and we'll definitely work it out.\n\n\/\/ on the derivatives based noise: https:\/\/iquilezles.org\/articles\/morenoise\n\/\/ on the soft shadow technique: https:\/\/iquilezles.org\/articles\/rmshadows\n\/\/ on the fog calculations: https:\/\/iquilezles.org\/articles\/fog\n\/\/ on the lighting: https:\/\/iquilezles.org\/articles\/outdoorslighting\n\/\/ on the raymarching: https:\/\/iquilezles.org\/articles\/terrainmarching\n\n\n#define AA 1   \/\/ make this 2 or even 3 if you have a really powerful GPU\n\n#define USE_SMOOTH_NOISE 0   \/\/ enable to prevent discontinuities\n\n#define SC (250.0)\n\n\/\/ value noise, and its analytical derivatives\nvec3 noised( in vec2 x )\n{\n    vec2 f = fract(x);\n    #if USE_SMOOTH_NOISE==0\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n    #else\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n    #endif\n\n#if 1\n    \/\/ texel fetch version\n    ivec2 p = ivec2(floor(x));\n    float a = texelFetch( iChannel0, (p+ivec2(0,0))&255, 0 ).x;\n\tfloat b = texelFetch( iChannel0, (p+ivec2(1,0))&255, 0 ).x;\n\tfloat c = texelFetch( iChannel0, (p+ivec2(0,1))&255, 0 ).x;\n\tfloat d = texelFetch( iChannel0, (p+ivec2(1,1))&255, 0 ).x;\n#else    \n    \/\/ texture version    \n    vec2 p = floor(x);\n\tfloat a = textureLod( iChannel0, (p+vec2(0.5,0.5))\/256.0, 0.0 ).x;\n\tfloat b = textureLod( iChannel0, (p+vec2(1.5,0.5))\/256.0, 0.0 ).x;\n\tfloat c = textureLod( iChannel0, (p+vec2(0.5,1.5))\/256.0, 0.0 ).x;\n\tfloat d = textureLod( iChannel0, (p+vec2(1.5,1.5))\/256.0, 0.0 ).x;\n#endif\n    \n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\tdu*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\nconst mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\n\n\nfloat terrainH( in vec2 x )\n{\n\tvec2  p = x*0.003\/SC;\n    float a = 0.0;\n    float b = 1.0;\n\tvec2  d = vec2(0.0);\n    for( int i=0; i<16; i++ )\n    {\n        vec3 n = noised(p);\n        d += n.yz;\n        a += b*n.x\/(1.0+dot(d,d));\n\t\tb *= 0.5;\n        p = m2*p*2.0;\n    }\n\n    #if USE_SMOOTH_NOISE==1\n    a *= 0.9;\n    #endif\n\treturn SC*120.0*a;\n}\n\nfloat terrainM( in vec2 x )\n{\n\tvec2  p = x*0.003\/SC;\n    float a = 0.0;\n    float b = 1.0;\n\tvec2  d = vec2(0.0);\n    for( int i=0; i<9; i++ )\n    {\n        vec3 n = noised(p);\n        d += n.yz;\n        a += b*n.x\/(1.0+dot(d,d));\n\t\tb *= 0.5;\n        p = m2*p*2.0;\n    }\n    #if USE_SMOOTH_NOISE==1\n    a *= 0.9;\n    #endif\n\treturn SC*120.0*a;\n}\n\nfloat terrainL( in vec2 x )\n{\n\tvec2  p = x*0.003\/SC;\n    float a = 0.0;\n    float b = 1.0;\n\tvec2  d = vec2(0.0);\n    for( int i=0; i<3; i++ )\n    {\n        vec3 n = noised(p);\n        d += n.yz;\n        a += b*n.x\/(1.0+dot(d,d));\n\t\tb *= 0.5;\n        p = m2*p*2.0;\n    }\n    #if USE_SMOOTH_NOISE==1\n    a *= 0.9;\n    #endif\n\treturn SC*120.0*a;\n}\n\nfloat raycast( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\n{\n    float t = tmin;\n\tfor( int i=0; i<300; i++ )\n\t{\n        vec3 pos = ro + t*rd;\n\t\tfloat h = pos.y - terrainM( pos.xz );\n\t\tif( abs(h)<(0.0015*t) || t>tmax ) break;\n\t\tt += 0.4*h;\n\t}\n\n\treturn t;\n}\n\nfloat softShadow(in vec3 ro, in vec3 rd, float dis )\n{\n    float minStep = clamp(dis*0.01,SC*0.5,SC*50.0);\n\n    float res = 1.0;\n    float t = 0.001;\n\tfor( int i=0; i<80; i++ )\n\t{\n\t    vec3  p = ro + t*rd;\n        float h = p.y - terrainM( p.xz );\n\t\tres = min( res, 16.0*h\/t );\n\t\tt += max(minStep,h);\n\t\tif( res<0.001 ||p.y>(SC*200.0) ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos, float t )\n{\n    vec2  eps = vec2( 0.001*t, 0.0 );\n    return normalize( vec3( terrainH(pos.xz-eps.xy) - terrainH(pos.xz+eps.xy),\n                            2.0*eps.x,\n                            terrainH(pos.xz-eps.yx) - terrainH(pos.xz+eps.yx) ) );\n}\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*texture( iChannel0, p\/256.0 ).x; p = m2*p*2.02;\n    f += 0.2500*texture( iChannel0, p\/256.0 ).x; p = m2*p*2.03;\n    f += 0.1250*texture( iChannel0, p\/256.0 ).x; p = m2*p*2.01;\n    f += 0.0625*texture( iChannel0, p\/256.0 ).x;\n    return f\/0.9375;\n}\n\nconst float kMaxT = 5000.0*SC;\n\nvec4 render( in vec3 ro, in vec3 rd )\n{\n    vec3 light1 = normalize( vec3(-0.8,0.4,-0.3) );\n    \/\/ bounding plane\n    float tmin = 1.0;\n    float tmax = kMaxT;\n#if 1\n    float maxh = 250.0*SC;\n    float tp = (maxh-ro.y)\/rd.y;\n    if( tp>0.0 )\n    {\n        if( ro.y>maxh ) tmin = max( tmin, tp );\n        else            tmax = min( tmax, tp );\n    }\n#endif\n\tfloat sundot = clamp(dot(rd,light1),0.0,1.0);\n\tvec3 col;\n    float t = raycast( ro, rd, tmin, tmax );\n    if( t>tmax)\n    {\n        \/\/ sky\t\t\n        col = vec3(0.3,0.5,0.85) - rd.y*rd.y*0.5;\n        col = mix( col, 0.85*vec3(0.7,0.75,0.85), pow( 1.0-max(rd.y,0.0), 4.0 ) );\n        \/\/ sun\n\t\tcol += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );\n\t\tcol += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );\n\t\tcol += 0.2*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );\n        \/\/ clouds\n\t\tvec2 sc = ro.xz + rd.xz*(SC*1000.0-ro.y)\/rd.y;\n\t\tcol = mix( col, vec3(1.0,0.95,1.0), 0.5*smoothstep(0.5,0.8,fbm(0.0005*sc\/SC)) );\n        \/\/ horizon\n        col = mix( col, 0.68*vec3(0.4,0.65,1.0), pow( 1.0-max(rd.y,0.0), 16.0 ) );\n        t = -1.0;\n\t}\n\telse\n\t{\n        \/\/ mountains\t\t\n\t\tvec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, t );\n        \/\/nor = normalize( nor + 0.5*( vec3(-1.0,0.0,-1.0) + vec3(2.0,1.0,2.0)*texture(iChannel1,0.01*pos.xz).xyz) );\n        vec3 ref = reflect( rd, nor );\n        float fre = clamp( 1.0+dot(rd,nor), 0.0, 1.0 );\n        vec3 hal = normalize(light1-rd);\n        \n        \/\/ rock\n\t\tfloat r = texture( iChannel0, (7.0\/SC)*pos.xz\/256.0 ).x;\n        col = (r*0.25+0.75)*0.9*mix( vec3(0.08,0.05,0.03), vec3(0.10,0.09,0.08), \n                                     texture(iChannel0,0.00007*vec2(pos.x,pos.y*48.0)\/SC).x );\n\t\tcol = mix( col, 0.20*vec3(0.45,.30,0.15)*(0.50+0.50*r),smoothstep(0.70,0.9,nor.y) );\n        \n        \n        col = mix( col, 0.15*vec3(0.30,.30,0.10)*(0.25+0.75*r),smoothstep(0.95,1.0,nor.y) );\n\t\tcol *= 0.1+1.8*sqrt(fbm(pos.xz*0.04)*fbm(pos.xz*0.005));\n\n\t\t\/\/ snow\n\t\tfloat h = smoothstep(55.0,80.0,pos.y\/SC + 25.0*fbm(0.01*pos.xz\/SC) );\n        float e = smoothstep(1.0-0.5*h,1.0-0.1*h,nor.y);\n        float o = 0.3 + 0.7*smoothstep(0.0,0.1,nor.x+h*h);\n        float s = h*e*o;\n        col = mix( col, 0.29*vec3(0.62,0.65,0.7), smoothstep( 0.1, 0.9, s ) );\n\t\t\n         \/\/ lighting\t\t\n        float amb = clamp(0.5+0.5*nor.y,0.0,1.0);\n\t\tfloat dif = clamp( dot( light1, nor ), 0.0, 1.0 );\n\t\tfloat bac = clamp( 0.2 + 0.8*dot( normalize( vec3(-light1.x, 0.0, light1.z ) ), nor ), 0.0, 1.0 );\n\t\tfloat sh = 1.0; if( dif>=0.0001 ) sh = softShadow(pos+light1*SC*0.05,light1,t);\n\t\t\n\t\tvec3 lin  = vec3(0.0);\n\t\tlin += dif*vec3(8.00,5.00,3.00)*1.3*vec3( sh, sh*sh*0.5+0.5*sh, sh*sh*0.8+0.2*sh );\n\t\tlin += amb*vec3(0.40,0.60,1.00)*1.2;\n        lin += bac*vec3(0.40,0.50,0.60);\n\t\tcol *= lin;\n        \n        col += (0.7+0.3*s)*(0.04+0.96*pow(clamp(1.0+dot(hal,rd),0.0,1.0),5.0))*\n               vec3(7.0,5.0,3.0)*dif*sh*\n               pow( clamp(dot(nor,hal), 0.0, 1.0),16.0);\n        \n        col += s*0.65*pow(fre,4.0)*vec3(0.3,0.5,0.6)*smoothstep(0.0,0.6,ref.y);\n\n        \/\/col = col*3.0\/(1.5+col);\n        \n\t\t\/\/ fog\n        float fo = 1.0-exp(-pow(0.001*t\/SC,1.5) );\n        vec3 fco = 0.65*vec3(0.4,0.65,1.0);\/\/ + 0.1*vec3(1.0,0.8,0.5)*pow( sundot, 4.0 );\n        col = mix( col, fco, fo );\n\n\t}\n    \/\/ sun scatter\n    col += 0.3*vec3(1.0,0.7,0.3)*pow( sundot, 8.0 );\n\n    \/\/ gamma\n\tcol = sqrt(col);\n    \n\treturn vec4( col, t );\n}\n\nvec3 camPath( float time )\n{\n\treturn SC*1100.0*vec3( cos(0.0+0.23*time), 0.0, cos(1.5+0.21*time) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, in float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid moveCamera( float time, out vec3 oRo, out vec3 oTa, out float oCr, out float oFl )\n{\n\tvec3 ro = camPath( time );\n\tvec3 ta = camPath( time + 3.0 );\n\tro.y = terrainL( ro.xz ) + 22.0*SC;\n\tta.y = ro.y - 20.0*SC;\n\tfloat cr = 0.2*cos(0.1*time);\n    oRo = ro;\n    oTa = ta;\n    oCr = cr;\n    oFl = 3.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*0.1 - 0.1 + 0.3 + 4.0*iMouse.x\/iResolution.x;\n\n    \/\/ camera position\n    vec3 ro, ta; float cr, fl;\n    moveCamera( time, ro, ta, cr, fl );\n\n    \/\/ camera2world transform    \n    mat3 cam = setCamera( ro, ta, cr );\n\n    \/\/ pixel\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)\/iResolution.y;\n\n    float t = kMaxT;\n    vec3 tot = vec3(0.0);\n\t#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        \/\/ pixel coordinates\n        vec2 o = vec2(float(m),float(n)) \/ float(AA) - 0.5;\n        vec2 s = (-iResolution.xy + 2.0*(fragCoord+o))\/iResolution.y;\n\t#else    \n        vec2 s = p;\n\t#endif\n\n        \/\/ camera ray    \n        vec3 rd = cam * normalize(vec3(s,fl));\n\n        vec4 res = render( ro, rd );\n        t = min( t, res.w );\n \n        tot += res.xyz;\n\t#if AA>1\n    }\n    tot \/= float(AA*AA);\n\t#endif\n\n\n    \/\/-------------------------------------\n\t\/\/ velocity vectors (through depth reprojection)\n    \/\/-------------------------------------\n    float vel = 0.0;\n    if( t<0.0 )\n    {\n        vel = -1.0;\n    }\n    else\n    {\n\n        \/\/ old camera position\n        float oldTime = time - 0.1 * 1.0\/24.0; \/\/ 1\/24 of a second blur\n        vec3 oldRo, oldTa; float oldCr, oldFl;\n        moveCamera( oldTime, oldRo, oldTa, oldCr, oldFl );\n        mat3 oldCam = setCamera( oldRo, oldTa, oldCr );\n\n        \/\/ world space\n        #if AA>1\n        vec3 rd = cam * normalize(vec3(p,fl));\n        #endif\n        vec3 wpos = ro + rd*t;\n        \/\/ camera space\n        vec3 cpos = vec3( dot( wpos - oldRo, oldCam[0] ),\n                          dot( wpos - oldRo, oldCam[1] ),\n                          dot( wpos - oldRo, oldCam[2] ) );\n        \/\/ ndc space\n        vec2 npos = oldFl * cpos.xy \/ cpos.z;\n        \/\/ screen space\n        vec2 spos = 0.5 + 0.5*npos*vec2(iResolution.y\/iResolution.x,1.0);\n\n\n        \/\/ compress velocity vector in a single float\n        vec2 uv = fragCoord\/iResolution.xy;\n        spos = clamp( 0.5 + 0.5*(spos - uv)\/0.25, 0.0, 1.0 );\n        vel = floor(spos.x*1023.0) + floor(spos.y*1023.0)*1024.0;\n    }\n    \n    fragColor = vec4( tot, vel );\n}",
                "name": "Buffer A",
                "description": "",
                "type": "buffer"
            }
        ]
    },
    {
        "ver": "0.1",
        "info": {
            "id": "XsX3RB",
            "date": "1372830991",
            "viewed": 172786,
            "name": "Volcanic",
            "username": "iq",
            "description": "An alien volcanic landscape. It started as an experiment on 2d-texture based 3d noise. But then I played with the noise shape, the added some shading, put lighting in it, etc..., until I got this.",
            "likes": 672,
            "published": 3,
            "flags": 32,
            "usePreview": 0,
            "tags": []
        },
        "renderpass": [
            {
                "inputs": [
                    {
                        "id": "4dXGR8",
                        "filepath": "\/media\/previz\/buffer00.png",
                        "previewfilepath": "\/media\/previz\/buffer00.png",
                        "type": "buffer",
                        "channel": 0,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "4dfGRr",
                        "channel": 0
                    }
                ],
                "code": "\/\/ Copyright Inigo Quilez, 2013 - https:\/\/iquilezles.org\/\n\/\/ I am the sole copyright owner of this Work.\n\/\/ You cannot host, display, distribute or share this Work in any form,\n\/\/ including physical and digital. You cannot use this Work in any\n\/\/ commercial or non-commercial product, website or project. You cannot\n\/\/ sell this Work and you cannot mint an NFTs of it.\n\/\/ I share this Work for educational purposes, and you can link to it,\n\/\/ through an URL, proper attribution and unmodified screenshot, as part\n\/\/ of your educational material. If these conditions are too restrictive\n\/\/ please contact me and we'll definitely work it out.\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord\/iResolution.xy;\n    vec4 data = textureLod( iChannel0, uv, 0.0 );\n\n    vec3 col = vec3(0.0);\n    \n    if( data.w < 0.0 )\n    {\n        col = textureLod( iChannel0, uv, 0.0 ).xyz;\n    }\n    else\n    {\n        \/\/ decompress velocity vector\n        float ss =   mod(data.w,1024.0)\/1023.0;\n        float st = floor(data.w\/1024.0)\/1023.0;\n\n        \/\/ motion blur (linear blur across velocity vectors)\n        vec2 dir = (2.0*vec2(ss,st)-1.0)*0.25;\n        float tot = 0.0;\n        for( int i=0; i<32; i++ )\n        {\n            float h = float(i)\/31.0;\n            vec2  p = uv + dir*h;\n            float w = 1.0-h;\n            col += w*textureLod( iChannel0, p, 0.0 ).xyz;\n            tot += w;\n        }\n        col \/= tot;\n    }\n\n    \/\/ vignetting\t\n\tcol *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 );\n\n    fragColor = vec4( col, 1.0 );\n}",
                "name": "Image",
                "description": "",
                "type": "image"
            },
            {
                "inputs": [
                    {
                        "id": "4sfGRn",
                        "filepath": "\/media\/a\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg",
                        "previewfilepath": "\/media\/ap\/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg",
                        "type": "texture",
                        "channel": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "wrap": "repeat",
                            "vflip": "false",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    },
                    {
                        "id": "XsX3Rn",
                        "filepath": "\/media\/a\/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg",
                        "previewfilepath": "\/media\/ap\/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg",
                        "type": "texture",
                        "channel": 2,
                        "sampler": {
                            "filter": "mipmap",
                            "wrap": "repeat",
                            "vflip": "false",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    },
                    {
                        "id": "Xsf3zn",
                        "filepath": "\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
                        "previewfilepath": "\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
                        "type": "texture",
                        "channel": 0,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "repeat",
                            "vflip": "false",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "4dXGR8",
                        "channel": 0
                    }
                ],
                "code": "\/\/#define HIGH_QUALITY_NOISE\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n#ifndef HIGH_QUALITY_NOISE\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)\/256.0, 0.0 ).yx;\n#else\n\tvec2 uv  = (p.xy+vec2(37.0,17.0)*p.z);\n\tvec2 rg1 = textureLod( iChannel0, (uv+ vec2(0.5,0.5))\/256.0, 0.0 ).yx;\n\tvec2 rg2 = textureLod( iChannel0, (uv+ vec2(1.5,0.5))\/256.0, 0.0 ).yx;\n\tvec2 rg3 = textureLod( iChannel0, (uv+ vec2(0.5,1.5))\/256.0, 0.0 ).yx;\n\tvec2 rg4 = textureLod( iChannel0, (uv+ vec2(1.5,1.5))\/256.0, 0.0 ).yx;\n\tvec2 rg  = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\n#endif\t\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\n\treturn textureLod( iChannel0, (uv+118.4)\/256.0, 0.0 ).x;\n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nfloat fbm4( in vec3 q )\n{\n    float f  = 0.5000*noise( q ); q = m*q*2.02;\n          f += 0.2500*noise( q ); q = m*q*2.03;\n          f += 0.1250*noise( q ); q = m*q*2.01;\n          f += 0.0625*noise( q );\n    return f;\n}\n    \nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n )\n{\n\treturn texture( sam, p.yz )*abs(n.x) +\n           texture( sam, p.zx )*abs(n.y) +\n           texture( sam, p.xy )*abs(n.z);\n}\n\n\/\/=====================================================================\n\nfloat lava( in vec2 p )\n{\n\tp += vec2(2.0,4.0);\n    float f  = 0.5000*noise( p ); p = p*2.02;\n          f += 0.2500*noise( p ); p = p*2.03;\n          f += 0.1250*noise( p ); p = p*2.01;\n          f += 0.0625*noise( p );\n    return f;\n}\n\nfloat displacement( in vec3 p )\n{\n    float dis = textureLod( iChannel2, p.xz, 0.0 ).x;\n    return fbm4(p+vec3(1.0,0.0,0.8)) - dis*0.01;\n}\n\nfloat mapTerrain( in vec3 pos )\n{\n\treturn pos.y*0.1 + (displacement(pos*vec3(0.8,1.0,0.8)) - 0.4)*(1.0-smoothstep(1.0,3.0,pos.y));\n}\n\nfloat raymarchTerrain( in vec3 ro, in vec3 rd )\n{\n    \/\/ bounding plane\n    const float hmax = 1.9;\n    float tp = (hmax-ro.y)\/rd.y;\n    float tmax = (tp<0.0)?30.0:tp;\n\n    \/\/ raymarch\n    float t = 0.1;\n    for( int i=0; i<350; i++ )\n    {\n\t    float h = mapTerrain( ro+rd*t );\n        if( abs(h)<(0.00025*t) || t>tmax ) break;\n        t += h*0.8;\n    }\n    return (t>tmax) ? -1.0 : t;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/rmshadows\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    \/\/ bounding plane\n    const float hmax = 1.9;\n    float tp = (hmax-ro.y)\/rd.y;\n    float tmax = (tp<0.0)?30.0:tp;\n\n    \/\/ raymarch\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<100; i++ )\n    {\n        float h = mapTerrain(ro + rd*t);\n        res = min( res, k*max(h,0.0)\/t );\n        t += clamp( h, 0.01, 0.4 );\n\t\tif( res<0.001 || t>tmax ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/normalsSDF\nvec3 calcNormal( in vec3 pos, in float t )\n{\n    float eps = max(0.02,0.001*t);\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*mapTerrain(pos+e.xyy) + \n\t\t\t\t\t  e.yyx*mapTerrain(pos+e.yyx) + \n\t\t\t\t\t  e.yxy*mapTerrain(pos+e.yxy) + \n\t\t\t\t\t  e.xxx*mapTerrain(pos+e.xxx) );\n}\n\nconst vec3 lig = normalize( vec3(-0.3,0.4,0.7) );\n\nvec4 mapClouds( in vec3 pos )\n{\n\tvec3 q = pos*0.5 + vec3(0.0,-iTime,0.0);\n\t\n\tfloat d = clamp( fbm4(q)-0.55, 0.0, 1.0 );\n\td *= smoothstep( 0.5, 0.55, lava(0.1*pos.xz)+0.01 );\n\t\n\tvec4 res = vec4( d );\n\tres.xyz  = 0.25*mix( vec3(1.0,0.8,0.7), 0.2*vec3(0.4,0.4,0.4), d );\n\tres.xyz *= 0.5 + 0.5*smoothstep(-2.0, 1.0, pos.y);\n\treturn res;\n}\n\nvec4 raymarchClouds( in vec3 ro, in vec3 rd, in vec3 bcol, float tmax, in vec2 px )\n{\n\tvec4 sum = vec4( 0.0 );\n\tfloat sun = pow( clamp( dot(rd,lig), 0.0, 1.0 ), 6.0 );\n\tfloat t = texture(iChannel0,px\/256.0).x*0.1;\n\tfor( int i=0; i<60; i++ )\n\t{\n\t\tvec4 col = mapClouds( ro + t*rd );\n\t\t\n        col.xyz += vec3(1.0,0.7,0.4)*0.4*sun*(1.0-col.w);\n\t\tcol.xyz = mix( col.xyz, bcol, 1.0-exp(-0.00006*t*t*t) );\n        col.a *= 2.0;\n\t\tcol.rgb *= col.a;\n\t\tsum = sum + col*(1.0 - sum.a);\t\n\n\t\tt += max(0.1,0.05*t);\n\t\tif( t>tmax || sum.w>0.95 ) break;\n\t}\n\tsum.xyz \/= (0.001+sum.w);\n\treturn clamp( sum, 0.0, 1.0 );\n}\n\nvec3 path( float time )\n{\n\treturn vec3( 16.0*cos(0.2+0.075*time), 1.5, 16.0*sin(0.1+0.0825*time) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid moveCamera( in float time, out vec3 oRo, out vec3 oTa, out float oCr, out float oFl )\n{\n    oFl = 2.1;\n    oCr = 0.3*sin(1.0+0.07*time);\n    oRo = path( time+0.0 );\n    oTa = path( time+1.6 );\n\toTa.y *= 0.35 + 0.25*sin(0.09*time);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)\/iResolution.y;\n\t\n    \/\/ camera\t\n\tfloat off = step( 0.001, iMouse.z )*6.0*iMouse.x\/iResolution.x;\n    float time = 3.4 + iTime + off;\n    vec3 ro, ta; float cr, fl;\n    moveCamera( time, ro, ta, cr, fl );\n    \n\t\/\/ camera2world transform\n    mat3 cam = setCamera( ro, ta, cr );\n\n    \/\/ ray    \n    vec3 rd = cam * normalize(vec3(p.xy,fl));\n\n    \/\/ sky\t \n    vec3  col = vec3(0.36,0.43,0.54) - rd.y*0.5;\n    float sun = clamp( dot(rd,lig), 0.0, 1.0 );\n\tcol += vec3(1.0,0.8,0.4)*0.24*pow( sun, 6.0 );\n\n\tvec3 bcol = col;\n    \n    \/\/ terrain\t\n\tfloat t = raymarchTerrain(ro, rd);\n    float st = t;\n    if( t>0.0 )\n\t{\n\t\tvec3 pos = ro + t*rd;\n\t\tvec3 nor = calcNormal( pos, t );\n\t\tvec3 ref = reflect( rd, nor );\n\t\t\n        \/\/ lighting\n\t\tfloat hhh = 1.0 - smoothstep(-2.0, 1.0, pos.y);\n\t\tfloat sun = clamp( dot( nor, lig ), 0.0, 1.0 );\n\t\tfloat sha = 0.0; if( sun>0.01) sha=softshadow(pos,lig,0.001,32.0);\n\t\tfloat bac = clamp( dot( nor, normalize(lig*vec3(-1.0,0.0,-1.0)) ), 0.0, 1.0 );\n\t\tfloat sky = 0.5 + 0.5*nor.y;\n        float lav = smoothstep( 0.5, 0.55, lava(0.1*pos.xz) )*hhh*clamp(0.5-0.5*nor.y,0.0,1.0);\n\t\tfloat occ = pow( (1.0-displacement(pos*vec3(0.8,1.0,0.8)))*1.6-0.5, 2.0 );\n\t\tfloat amb = 1.0;\n        float fre = 1.0+dot(nor,rd); fre = fre*fre;\n\n\t\tvec3 lin = vec3(0.0);\n\t\tlin += 1.3*sun*vec3(1.80,1.27,0.99)*pow(vec3(sha),vec3(1.0,1.2,1.5));\n\t\tlin += 1.0*sky*vec3(0.16,0.20,0.40)*occ;\n\t\tlin += 1.0*bac*vec3(0.40,0.28,0.20)*occ;\n\t\tlin += 1.0*amb*vec3(0.15,0.17,0.20)*occ;\n\t\tlin += lav*vec3(3.00,0.61,0.00);\n\n        \/\/ surface shading\/material\t\t\n        vec3 te = texcube( iChannel1, 0.5*pos, nor ).xyz;\n\t\tcol = te;\n\t\tcol = col*(0.2+0.8*texcube( iChannel2, 4.0*vec3(2.0,8.0,2.0)*pos, nor ).x);\n\n\t\tvec3 lava = vec3(1.0,0.9,0.2);\n\t\tlava *= texture( iChannel2, pos.xz ).xyz;\n\t\tcol = mix( col, 0.8*lava, hhh );\n\t\t\n\t\tvec3 verde = vec3(0.2,0.2,0.05);\n\t\tverde *= 0.2+1.6*texture( iChannel1, 7.1*pos.xz ).xyz;\n\t\tverde += 0.1*texture( iChannel1, 1.0*pos.xz ).xyz;\n        verde *= 1.0+fre*fre;\n\t\tcol = mix( col, verde, smoothstep(0.0, 0.8, nor.y)*smoothstep(0.0, 0.1, pos.y-0.8 ) );\n\t\t\n\t\tcol = lin * col;\n\n        \/\/ sun spec\n        vec3 hal = normalize(lig-rd);\n        col += (te.x*te.x)*vec3(11.0,8.0,5.0)*sun*sha*\n               pow( clamp(dot(nor,hal),0.0,1.0), 8.0 ) *\n               (0.04+0.96*pow(clamp(1.0+dot(hal,rd),0.0,1.0),5.0));\n            \n\t\t\/\/ atmospheric\n        vec3 ext = exp2(-t*t*0.001*vec3(0.5,1.0,2.0) );\n        col = col*ext + 0.6*(1.0-ext)*(1.0-0.7*hhh);\n    }\n\n    \/\/ sun glow\n    col += vec3(1.0,0.6,0.2)*0.2*sun*sun*clamp( (rd.y+0.4)\/(0.0+0.4),0.0,1.0);\n\t\n    \/\/ smoke\t\n    vec4 res = raymarchClouds( ro, rd, bcol, (t<0.0)?600.0:t, fragCoord );\n\tcol = mix( col, res.xyz, res.w );\n\n    \/\/ gain\n    col *= 1.6\/(1.0+col);\n    col *= vec3(1.02,1.04,1.0);\n\n    \/\/ gamma\t\n\tcol = pow( clamp( col, 0.0, 1.0 ), vec3(0.45) );\n\n    \/\/ contrast, desat, tint and vignetting\t\n\tcol = col*col*(3.0-2.0*col);\n\tcol = mix( col, vec3(col.x+col.y+col.z)*0.33, 0.2 );\n      \n    \/\/-------------------------------------\n\t\/\/ velocity vectors\n    \/\/-------------------------------------\n    float vel = -1.0;\n    if( st>0.0 )\n    {\n        \/\/ old camera position\n        float oldTime = time - 1.0\/30.0; \/\/ 1\/30 of a second blur\n        vec3 oldRo, oldTa; float oldCr, oldFl;\n        moveCamera( oldTime, oldRo, oldTa, oldCr, oldFl );\n        mat3 oldCam = setCamera( oldRo, oldTa, oldCr );\n        \/\/ world space\n        vec3 wpos = ro + rd*st;\n        \/\/ camera space\n        vec3 cpos = vec3( dot( wpos - oldRo, oldCam[0] ),\n                          dot( wpos - oldRo, oldCam[1] ),\n                          dot( wpos - oldRo, oldCam[2] ) );\n        \/\/ ndc space\n        vec2 npos = oldFl * cpos.xy \/ cpos.z;\n        \/\/ screen space\n        vec2 spos = 0.5 + 0.5*npos*vec2(iResolution.y\/iResolution.x,1.0);\n        \/\/ compress velocity vector in a single float\n        vec2 uv = fragCoord\/iResolution.xy;\n        spos = clamp( 0.5 + 0.5*(spos - uv)\/0.25, 0.0, 1.0 );\n        vel = floor(spos.x*1023.0) + floor(spos.y*1023.0)*1024.0;\n    }\n\n    fragColor = vec4( col, vel );\n}",
                "name": "Buffer A",
                "description": "",
                "type": "buffer"
            }
        ]
    },
    {
        "ver": "0.1",
        "info": {
            "id": "XsyGWV",
            "date": "1458155905",
            "viewed": 37309,
            "name": "Sirenian Dawn",
            "username": "nimitz",
            "description": "Experiments in raymarched terrain rendering.",
            "likes": 629,
            "published": 1,
            "flags": 32,
            "usePreview": 0,
            "tags": []
        },
        "renderpass": [
            {
                "inputs": [
                    {
                        "id": "4dXGR8",
                        "filepath": "\/media\/previz\/buffer00.png",
                        "previewfilepath": "\/media\/previz\/buffer00.png",
                        "type": "buffer",
                        "channel": 0,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "4dfGRr",
                        "channel": 0
                    }
                ],
                "code": "\/\/ Sirenian Dawn by nimitz (twitter: @stormoid)\n\/\/ https:\/\/www.shadertoy.com\/view\/XsyGWV\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\/\/ Contact the author for other licensing options\n\n\/*\n\tSee: https:\/\/en.wikipedia.org\/wiki\/Terra_Sirenum\n\n\tThings of interest in this shader:\n\t\t-A technique I call \"relaxation marching\", see march() function\n\t\t-A buffer based technique for anti-alisaing\n\t\t-Cheap and smooth procedural starfield\n\t\t-Non-constant fog from iq\n\t\t-Completely faked atmosphere :)\n\t\t-Terrain based on noise derivatives\n*\/\n\n\/*\n\tMore about the antialiasing:\n\t\tThe fragments with high enough iteration count\/distance ratio \n\t\tget blended with the past frame, I tried a few different \n\t\tinput for the blend trigger: distance delta, color delta, \n\t\tnormal delta, scene curvature.  But none of them provides \n\t\tgood enough info about the problem areas to allow for proper\n\t\tantialiasing without making the whole scene blurry.\n\t\t\n\t\tOn the other hand iteration count (modulated by a power\n\t\tof distance) does a pretty good job without requiring to\n\t\tstore past frame info in the alpha channel (which can then\n\t\tbe used for something else, nothing in this case)\n\n*\/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4(texture(iChannel0, fragCoord.xy\/iResolution.xy).rgb, 1.0);\n}",
                "name": "Image",
                "description": "",
                "type": "image"
            },
            {
                "inputs": [
                    {
                        "id": "4dXGzn",
                        "filepath": "\/media\/a\/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png",
                        "previewfilepath": "\/media\/ap\/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png",
                        "type": "texture",
                        "channel": 0,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "repeat",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    },
                    {
                        "id": "4dXGR8",
                        "filepath": "\/media\/previz\/buffer00.png",
                        "previewfilepath": "\/media\/previz\/buffer00.png",
                        "type": "buffer",
                        "channel": 1,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "4dXGR8",
                        "channel": 0
                    }
                ],
                "code": "\/\/Sirenian Dawn by nimitz (twitter: @stormoid)\n\/\/ https:\/\/www.shadertoy.com\/view\/XsyGWV\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define ITR 90\n#define FAR 400.\n#define time iTime\n\nconst vec3 lgt = vec3(-.523, .41, -.747);\nmat2 m2 = mat2( 0.80,  0.60, -0.60,  0.80 );\n\n\/\/form iq, see: https:\/\/iquilezles.org\/articles\/morenoise\nvec3 noised( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    vec2 u = f*f*(3.0-2.0*f);\n\tfloat a = textureLod(iChannel0,(p+vec2(0.5,0.5))\/256.0,0.0).x;\n\tfloat b = textureLod(iChannel0,(p+vec2(1.5,0.5))\/256.0,0.0).x;\n\tfloat c = textureLod(iChannel0,(p+vec2(0.5,1.5))\/256.0,0.0).x;\n\tfloat d = textureLod(iChannel0,(p+vec2(1.5,1.5))\/256.0,0.0).x;\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\t6.0*f*(1.0-f)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\nfloat terrain( in vec2 p)\n{\n    float rz = 0.;\n    float z = 1.;\n\tvec2  d = vec2(0.0);\n    float scl = 2.95;\n    float zscl = -.4;\n    float zz = 5.;\n    for( int i=0; i<5; i++ )\n    {\n        vec3 n = noised(p);\n        d += pow(abs(n.yz),vec2(zz));\n        d -= smoothstep(-.5,1.5,n.yz);\n        zz -= 1.;\n        rz += z*n.x\/(dot(d,d)+.85);\n        z *= zscl;\n        zscl *= .8;\n        p = m2*p*scl;\n    }\n    \n    rz \/= smoothstep(1.5,-.5,rz)+.75;\n    return rz;\n}\n\nfloat map(vec3 p)\n{\n    return p.y-(terrain(p.zx*0.07))*2.7-1.;\n}\n\n\/*\tThe idea is simple, as the ray gets further from the eye, I increase \n\tthe step size of the raymarching and lower the target precision, \n\tthis allows for better performance with virtually no loss in visual quality. *\/\nfloat march(in vec3 ro, in vec3 rd, out float itrc)\n{\n    float t = 0.;\n    float d = map(rd*t+ro);\n    float precis = 0.0001;\n    for (int i=0;i<=ITR;i++)\n    {\n        if (abs(d) < precis || t > FAR) break;\n        precis = t*0.0001;\n        float rl = max(t*0.02,1.);\n        t += d*rl;\n        d = map(rd*t+ro)*0.7;\n        itrc++;\n    }\n\n    return t;\n}\n\nvec3 rotx(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n\nvec3 roty(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(c*p.x + s*p.z, p.y, -s*p.x + c*p.z);\n}\n\nvec3 rotz(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nvec3 normal(in vec3 p, in float ds)\n{  \n    vec2 e = vec2(-1., 1.)*0.0005*pow(ds,1.);\n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\nfloat noise(in vec2 x){return texture(iChannel0, x*.01).x;}\nfloat fbm(in vec2 p)\n{\t\n\tfloat z=.5;\n\tfloat rz = 0.;\n\tfor (float i= 0.;i<3.;i++ )\n\t{\n        rz+= (sin(noise(p)*5.)*0.5+0.5) *z;\n\t\tz *= 0.5;\n\t\tp = p*2.;\n\t}\n\treturn rz;\n}\n\nfloat bnoise(in vec2 p){ return fbm(p*3.); }\nvec3 bump(in vec3 p, in vec3 n, in float ds)\n{\n    vec2 e = vec2(0.005*ds,0);\n    float n0 = bnoise(p.zx);\n    vec3 d = vec3(bnoise(p.zx+e.xy)-n0, 1., bnoise(p.zx+e.yx)-n0)\/e.x*0.025;\n    d -= n*dot(n,d);\n    n = normalize(n-d);\n    return n;\n}\n\nfloat curv(in vec3 p, in float w)\n{\n    vec2 e = vec2(-1., 1.)*w;   \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    return .15\/e.y *(t1 + t2 + t3 + t4 - 4. * map(p));\n}\n\n\/\/Based on: https:\/\/iquilezles.org\/articles\/fog\nvec3 fog(vec3 ro, vec3 rd, vec3 col, float ds)\n{\n    vec3 pos = ro + rd*ds;\n    float mx = (fbm(pos.zx*0.1-time*0.05)-0.5)*.2;\n    \n    const float b= 1.;\n    float den = 0.3*exp(-ro.y*b)*(1.0-exp( -ds*rd.y*b ))\/rd.y;\n    float sdt = max(dot(rd, lgt), 0.);\n    vec3  fogColor  = mix(vec3(0.5,0.2,0.15)*1.2, vec3(1.1,0.6,0.45)*1.3, pow(sdt,2.0)+mx*0.5);\n    return mix( col, fogColor, clamp(den + mx,0.,1.) );\n}\n\nfloat linstep(in float mn, in float mx, in float x){\n\treturn clamp((x - mn)\/(mx - mn), 0., 1.);\n}\n\n\/\/Complete hack, but looks good enough :)\nvec3 scatter(vec3 ro, vec3 rd)\n{   \n    float sd= max(dot(lgt, rd)*0.5+0.5,0.);\n    float dtp = 13.-(ro + rd*(FAR)).y*3.5;\n    float hori = (linstep(-1500., 0.0, dtp) - linstep(11., 500., dtp))*1.;\n    hori *= pow(sd,.04);\n    \n    vec3 col = vec3(0);\n    col += pow(hori, 200.)*vec3(1.0, 0.7,  0.5)*3.;\n    col += pow(hori, 25.)* vec3(1.0, 0.5,  0.25)*.3;\n    col += pow(hori, 7.)* vec3(1.0, 0.4, 0.25)*.8;\n    \n    return col;\n}\n\nvec3 nmzHash33(vec3 q)\n{\n    uvec3 p = uvec3(ivec3(q));\n    p = p*uvec3(374761393U, 1103515245U, 668265263U) + p.zxy + p.yzx;\n    p = p.yzx*(p.zxy^(p >> 3U));\n    return vec3(p^(p >> 16U))*(1.0\/vec3(0xffffffffU));\n}\n\n\/\/Very happy with this star function, cheap and smooth\nvec3 stars(in vec3 p)\n{\n    vec3 c = vec3(0.);\n    float res = iResolution.x*0.8;\n    \n\tfor (float i=0.;i<3.;i++)\n    {\n        vec3 q = fract(p*(.15*res))-0.5;\n        vec3 id = floor(p*(.15*res));\n        vec2 rn = nmzHash33(id).xy;\n        float c2 = 1.-smoothstep(0.,.6,length(q));\n        c2 *= step(rn.x,.0005+i*i*0.001);\n        c += c2*(mix(vec3(1.0,0.49,0.1),vec3(0.75,0.9,1.),rn.y)*0.25+0.75);\n        p *= 1.4;\n    }\n    return c*c*.7;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 q = fragCoord.xy \/ iResolution.xy;\n    vec2 p = q - 0.5;\n\tp.x*=iResolution.x\/iResolution.y;\n\tvec2 mo = iMouse.xy \/ iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(-.2,0.3):mo;\n    mo.x *= 1.2;\n    mo -= vec2(1.2,-0.1);\n\tmo.x *= iResolution.x\/iResolution.y;\n    mo.x += sin(time*0.15)*0.2;\n\t\n    vec3 ro = vec3(650., sin(time*0.2)*0.25+10.,-time);\n    vec3 eye = normalize(vec3(cos(mo.x),-0.5+mo.y,sin(mo.x)));\n    vec3 right = normalize(vec3(cos(mo.x+1.5708),0.,sin(mo.x+1.5708)));\n    vec3 up = normalize(cross(right, eye));\n\tvec3 rd = normalize((p.x*right + p.y*up)*1.05 + eye);\n    rd.y += abs(p.x*p.x*0.015);\n    rd = normalize(rd);\n\t\n    float count = 0.;\n\tfloat rz = march(ro,rd, count);\n    \n    vec3 scatt = scatter(ro, rd);\n    \n    vec3 bg = stars(rd)*(1.0-clamp(dot(scatt, vec3(1.3)),0.,1.));\n    vec3 col = bg;\n    \n    vec3 pos = ro+rz*rd;\n    vec3 nor= normal( pos, rz );\n    if ( rz < FAR )\n    {\n        nor = bump(pos,nor,rz);\n        float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lgt ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lgt.x,0.0,-lgt.z))), 0.0, 1.0 );\n        float spe = pow(clamp( dot( reflect(rd,nor), lgt ), 0.0, 1.0 ),500.);\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        vec3 brdf = 1.*amb*vec3(0.10,0.11,0.12);\n        brdf += bac*vec3(0.15,0.05,0.04);\n        brdf += 2.3*dif*vec3(.9,0.4,0.25);\n        col = vec3(0.25,0.25,0.3);\n        float crv = curv(pos, 2.)*1.;\n        float crv2 = curv(pos, .4)*2.5;\n        \n        col += clamp(crv*0.9,-1.,1.)*vec3(0.25,.6,.5);\n        col = col*brdf + col*spe*.1 +.1*fre*col;\n        col *= crv*1.+1.;\n        col *= crv2*1.+1.;\n    }\n\t\n    col = fog(ro, rd, col, rz);\n    col = mix(col,bg,smoothstep(FAR-150., FAR, rz));\n    col += scatt;\n    \n    col = pow( col, vec3(0.93,1.0,1.0) );\n    col = mix(col, smoothstep(0.,1.,col), 0.2);\n    col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1)*0.9+0.1;\n    \n    vec4 past = texture(iChannel1, q);\n    float tOver = clamp(iTimeDelta-(1.\/60.),0.,1.);\n    \n    \/\/if (count\/pow(rz, 0.65) > 3.3) col = mix(col, past.rgb, clamp(1.0-iResolution.x*0.0003,0.,1.));\n    if (count\/pow(rz, 0.65) > 3.3) col = mix(col, past.rgb, clamp(0.85-iTimeDelta*7.,0.,1.));\n    \n\tfragColor = vec4(col, 1.0);\n}",
                "name": "Buffer A",
                "description": "",
                "type": "buffer"
            }
        ]
    },
    {
        "ver": "0.1",
        "info": {
            "id": "WsSBzh",
            "date": "1606524984",
            "viewed": 124578,
            "name": "Selfie Girl",
            "username": "iq",
            "description": "A raymarched procedural SDF - a girl taking a selfie, this time. Making of video here: [url]https:\/\/www.youtube.com\/watch?v=8--5LwHRhjk[\/url]",
            "likes": 495,
            "published": 3,
            "flags": 32,
            "usePreview": 1,
            "tags": []
        },
        "renderpass": [
            {
                "inputs": [
                    {
                        "id": "4sf3Rn",
                        "filepath": "\/media\/a\/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png",
                        "previewfilepath": "\/media\/ap\/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png",
                        "type": "texture",
                        "channel": 2,
                        "sampler": {
                            "filter": "mipmap",
                            "wrap": "repeat",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    },
                    {
                        "id": "Xsf3zn",
                        "filepath": "\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
                        "previewfilepath": "\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
                        "type": "texture",
                        "channel": 3,
                        "sampler": {
                            "filter": "mipmap",
                            "wrap": "repeat",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    },
                    {
                        "id": "4sfGRr",
                        "filepath": "\/media\/a\/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin",
                        "previewfilepath": "\/media\/ap\/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin",
                        "type": "volume",
                        "channel": 0,
                        "sampler": {
                            "filter": "mipmap",
                            "wrap": "repeat",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    },
                    {
                        "id": "XsXGR8",
                        "filepath": "\/media\/previz\/buffer01.png",
                        "previewfilepath": "\/media\/previz\/buffer01.png",
                        "type": "buffer",
                        "channel": 1,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "4dfGRr",
                        "channel": 0
                    }
                ],
                "code": "\/\/ Copyright Inigo Quilez, 2020 - https:\/\/iquilezles.org\/\n\/\/ I am the sole copyright owner of this Work.\n\/\/ You cannot host, display, distribute or share this Work in any form,\n\/\/ including physical and digital. You cannot use this Work in any\n\/\/ commercial or non-commercial product, website or project. You cannot\n\/\/ sell this Work and you cannot mint an NFTs of it.\n\/\/ I share this Work for educational purposes, and you can link to it,\n\/\/ through an URL, proper attribution and unmodified screenshot, as part\n\/\/ of your educational material. If these conditions are too restrictive\n\/\/ please contact me and we'll definitely work it out.\n\n\n\/\/ Source code of the mathematical painting \"Selfie Girl\".\n\/\/ Making-of video on Youtube:\n\/\/\n\/\/ https:\/\/www.youtube.com\/watch?v=8--5LwHRhjk\n\n\/\/ The image is a single formula, but I had to split it\n\/\/ down into 3 passes here so it could be shared without\n\/\/ breaking the WebGL implementation of the web browsers\n\/\/ (which is what Shadertoy uses to run the code below\n\/\/ that implements the formula).\n\n\/\/ This \"Image\" tab in particular renders the girl through\n\/\/ raymarching and then performs the final composition with\n\/\/ the background, which is computed in \"Buffer B\" (open\n\/\/ the rest of the tabs to see explanations of what each\n\/\/ one does). For the rendering\/computer graphics people - \n\/\/ there's no TAA in this pass because I didn't want to\n\/\/ compute velocity vectors for the animation, so things\n\/\/ alias a bit (feel free to change the AA define below to\n\/\/ 2 if you have a fast GPU)\n\n#define AA 1\n\n\n\/\/ This SDF is really 6 braids at once (through domain\n\/\/ repetition) with three strands each (brute forced)\nvec4 sdHair( vec3 p, vec3 pa, vec3 pb, vec3 pc, float an, out vec2 occ_id) \n{\n    vec4 b = sdBezier(p, pa,pb,pc );\n    vec2 q = rot(b.zw,an);\n  \t\n    vec2 id2 = round(q\/0.1);\n    id2 = clamp(id2,vec2(0),vec2(2,1));\n    q -= 0.1*id2;\n\n    float id = 11.0*id2.x + id2.y*13.0;\n\n    q += smoothstep(0.5,0.8,b.y)*0.02*vec2(0.4,1.5)*cos( 23.0*b.y + id*vec2(13,17));\n\n    occ_id.x = clamp(length(q)*8.0-0.2,0.0,1.0);\n    vec4 res = vec4(99,q,b.y);\n    for( int i=0; i<3; i++ )\n    {\n        vec2 tmp = q + 0.01*cos( id + 180.0*b.y + vec2(2*i,6-2*i));\n        float lt = length(tmp)-0.02;\n        if( lt<res.x )\n        { \n            occ_id.y = id+float(i); \n            res.x = lt; \n            res.yz = tmp;\n        }\n    }\n    return res;\n}\n\n\/\/ The SDF for the hoodie and jacket. It's a very distorted\n\/\/ ellipsoid, torus section, a segment and a sphere.\nvec4 sdHoodie( in vec3 pos )\n{\n    vec3 opos = pos;\n\n    pos.x   += 0.09*sin(3.5*pos.y-0.5)*sin(    pos.z) + 0.015;\n    pos.xyz += 0.03*sin(2.0*pos.y)*sin(7.0*pos.zyx);\n    \n    \/\/ hoodie\n    vec3 hos = pos-vec3(0.0,-0.33,0.15);\n    hos.x -= 0.031*smoothstep(0.0,1.0,opos.y+0.33);\n    hos.yz = rot(hos.yz,0.9);\n    float d1 = sdEllipsoid(hos,vec3(0.96-pos.y*0.1,1.23,1.5));\n\tfloat d2 = 0.95*pos.z-0.312*pos.y-0.9;\n    float d = max(opOnion(d1,0.01), d2 );\n    \n    \/\/ shoulders\n    vec3 sos = vec3( abs(pos.x), pos.yz );    \n    vec2 se = sdSegment(sos, vec3(0.18,-1.6,-0.3), vec3(1.1,-1.9,0.0) );\n    d = smin(d,se.x-mix(0.25,0.43,se.y),0.4);\n    d = smin(d,sdSphere(sos-vec3(0.3,-2.2,0.4), 0.5 ),0.2);\n\n    \/\/ neck\n    opos.x -= 0.02*sin(9.0*opos.y);\n    vec4 w = opElongate( opos-vec3(0.0,-1.2,0.3), vec3(0.0,0.3,0.0) );\n    d = smin(d,\n             w.w+sdCappedTorus(vec3(w.xy,-w.z),vec2(0.6,-0.8),0.6,0.02),\n             0.1);\n    \n    \/\/ bumps\n    d += 0.004*sin(pos.x*90.0)*sin(pos.y*90.0)*sin(pos.z*90.0);\n    d -= 0.002*sin(pos.x*300.0);\n    d -= 0.02*(1.0-smoothstep(0.0,0.04,abs(opOnion(pos.x,1.1))));\n    \n    \/\/ border\n    d = min(d,length(vec2(d1,d2))-0.015);\n    \n    return vec4(d,pos);\n}\n\n\/\/ moves the head (and hair and hoodie). This could be done\n\/\/ more efficiently (with a single matrix or quaternion),\n\/\/ but this code was optimized for editing, not for runtime\nvec3 moveHead( in vec3 pos, in vec3 an, in float amount)\n{\n    pos.y -= -1.0;\n    pos.xz = rot(pos.xz,amount*an.x);\n    pos.xy = rot(pos.xy,amount*an.y);\n    pos.yz = rot(pos.yz,amount*an.z);\n    pos.y += -1.0;\n    return pos;\n}\n\n\/\/ the animation state\nvec3 animData; \/\/ { blink, nose follow up, mouth } \nvec3 animHead; \/\/ { head rotation angles }\n\n\/\/ SDF of the girl. It is not as efficient as it should, \n\/\/ both in terms of performance and euclideanness of the\n\/\/ returned distance. Among other things I tweaked the\n\/\/ overal shape of the head though scaling right in the\n\/\/ middle of the design process (see 1.02 and 1.04 numbers\n\/\/ below). I should have backpropagated those adjustements\n\/\/ to the  primitives themselves, but I didn't and now it's\n\/\/ too late. So, I am paying some cost there.\n\/\/\n\/\/ She is modeled to camera (her face's shape looks bad\n\/\/ from other perspectives. She's made of five ellipsoids\n\/\/ blended together for the face, a cone and three spheres\n\/\/ for the nose, a torus for the teeh and two quadratic \n\/\/ curves for the lips. The neck is a cylinder, the hair\n\/\/ is made of three quadratic curves that are repeated\n\/\/ multiple times through domain repetition and each of\n\/\/ them contains three more curves in order to make the\n\/\/ braids. The hoodie is an ellipsoid deformed with\n\/\/ two sine waves and cut in half, the neck is an elongated\n\/\/ torus section and the shoulders are capsules.\n\/\/\nvec4 map( in vec3 pos, in float time, out float outMat, out vec3 uvw )\n{\n    outMat = 1.0;\n\n    vec3 oriPos = pos;\n    \n    \/\/ head deformation and transformation\n    pos.y \/= 1.04;\n    vec3 opos;\n    opos = moveHead( pos, animHead, smoothstep(-1.2, 0.2,pos.y) );\n    pos  = moveHead( pos, animHead, smoothstep(-1.4,-1.0,pos.y) );\n    pos.x *= 1.04;\n    pos.y \/= 1.02;\n    uvw = pos;\n\n    \/\/ symmetric coord systems (sharp, and smooth)\n    vec3 qos = vec3(abs(pos.x),pos.yz);\n    vec3 sos = vec3(sqrt(qos.x*qos.x+0.0005),pos.yz);\n    \n    \/\/ head\n    float d = sdEllipsoid( pos-vec3(0.0,0.05,0.07), vec3(0.8,0.75,0.85) );\n    \n    \/\/ jaw\n    vec3 mos = pos-vec3(0.0,-0.38,0.35); mos.yz = rot(mos.yz,0.4);\n\tmos.yz = rot(mos.yz,0.1*animData.z);\n\tfloat d2 = sdEllipsoid(mos-vec3(0,-0.17,0.16),\n                 vec3(0.66+sclamp(mos.y*0.9-0.1*mos.z,-0.3,0.4),\n                 \t  0.43+sclamp(mos.y*0.5,-0.5,0.2),\n                      0.50+sclamp(mos.y*0.3,-0.45,0.5)));\n        \n    \/\/ mouth hole\n    d2 = smax(d2,-sdEllipsoid(mos-vec3(0,0.06,0.6+0.05*animData.z), vec3(0.16,0.035+0.05*animData.z,0.1)),0.01);\n    \n    \/\/ lower lip    \n    vec4 b = sdBezier(vec3(abs(mos.x),mos.yz), \n                      vec3(0,0.01,0.61),\n                      vec3(0.094+0.01*animData.z,0.015,0.61),\n                      vec3(0.18-0.02*animData.z,0.06+animData.z*0.05,0.57-0.006*animData.z));\n    float isLip = smoothstep(0.045,0.04,b.x+b.y*0.03);\n    d2 = smin(d2,b.x - 0.027*(1.0-b.y*b.y)*smoothstep(1.0,0.4,b.y),0.02);\n    d = smin(d,d2,0.19);\n\n    \/\/ chicks\n    d = smin(d,sdSphere(qos-vec3(0.2,-0.33,0.62),0.28 ),0.04);\n    \n    \/\/ who needs ears\n    \n    \/\/ eye sockets\n    vec3 eos = sos-vec3(0.3,-0.04,0.7);\n    eos.xz = rot(eos.xz,-0.2);\n    eos.xy = rot(eos.xy,0.3);\n    eos.yz = rot(eos.yz,-0.2);\n    d2 = sdEllipsoid( eos-vec3(-0.05,-0.05,0.2), vec3(0.20,0.14-0.06*animData.x,0.1) );\n\td = smax( d, -d2, 0.15 );\n\n    eos = sos-vec3(0.32,-0.08,0.8);\n    eos.xz = rot(eos.xz,-0.4);\n    d2 = sdEllipsoid( eos, vec3(0.154,0.11,0.1) );\n    d = smax( d, -d2, 0.05 );\n\n    vec3 oos = qos - vec3(0.25,-0.06,0.42);\n    \n    \/\/ eyelid\n    d2 = sdSphere( oos, 0.4 );\n    oos.xz = rot(oos.xz, -0.2);\n    oos.xy = rot(oos.xy, 0.2);\n    vec3 tos = oos;        \n    oos.yz = rot(oos.yz,-0.6+0.58*animData.x);\n\n    \/\/eyebags\n    tos = tos-vec3(-0.02,0.06,0.2+0.02*animData.x);\n    tos.yz = rot(tos.yz,0.8);\n    tos.xy = rot(tos.xy,-0.2);\n\td = smin( d, sdTorus(tos,0.29,0.01), 0.03 );\n    \n    \/\/ eyelids\n    eos = qos - vec3(0.33,-0.07,0.53);\n    eos.xy = rot(eos.xy, 0.2);\n    eos.yz = rot(eos.yz,0.35-0.25*animData.x);\n    d2 = smax(d2-0.005, -max(oos.y+0.098,-eos.y-0.025), 0.02 );\n    d = smin( d, d2, 0.012 );\n\n\t\/\/ eyelashes\n\toos.x -= 0.01;\n    float xx = clamp( oos.x+0.17,0.0,1.0);\n    float ra = 0.35 + 0.1*sqrt(xx\/0.2)*(1.0-smoothstep(0.3,0.4,xx))*(0.6+0.4*sin(xx*256.0));\n    float rc = 0.18\/(1.0-0.7*smoothstep(0.15,0.5,animData.x));\n    oos.y -= -0.18 - (rc-0.18)\/1.8;\n    d2 = (1.0\/1.8)*sdArc( oos.xy*vec2(1.0,1.8), vec2(0.9,sqrt(1.0-0.9*0.9)), rc )-0.001;\n    float deyelashes = max(d2,length(oos.xz)-ra)-0.003;\n    \n    \/\/ nose\n    eos = pos-vec3(0.0,-0.079+animData.y*0.005,0.86);\n    eos.yz = rot(eos.yz,-0.23);\n    float h = smoothstep(0.0,0.26,-eos.y);\n    d2 = sdCone( eos-vec3(0.0,-0.02,0.0), vec2(0.03,-0.25) )-0.04*h-0.01;\n    eos.x = sqrt(eos.x*eos.x + 0.001);\n    d2 = smin( d2, sdSphere(eos-vec3(0.0, -0.25,0.037),0.06 ), 0.07 );\n    d2 = smin( d2, sdSphere(eos-vec3(0.1, -0.27,0.03 ),0.04 ), 0.07 );\n    d2 = smin( d2, sdSphere(eos-vec3(0.0, -0.32,0.05 ),0.025), 0.04 );        \n    d2 = smax( d2,-sdSphere(eos-vec3(0.07,-0.31,0.038),0.02 ), 0.035 );\n    d = smin(d,d2,0.05-0.03*h);\n    \n    \/\/ mouth\n    eos = pos-vec3(0.0,-0.38+animData.y*0.003+0.01*animData.z,0.71);\n    tos = eos-vec3(0.0,-0.13,0.06);\n    tos.yz = rot(tos.yz,0.2);\n    float dTeeth = sdTorus(tos,0.15,0.015);\n    eos.yz = rot(eos.yz,-0.5);\n    eos.x \/= 1.04;\n\n    \/\/ nose-to-upperlip connection\n    d2 = sdCone( eos-vec3(0,0,0.03), vec2(0.14,-0.2) )-0.03;\n    d2 = max(d2,-(eos.z-0.03));\n    d = smin(d,d2,0.05);\n\n    \/\/ upper lip\n    eos.x = abs(eos.x);\n    b = sdBezier(eos, vec3(0.00,-0.22,0.17),\n                      vec3(0.08,-0.22,0.17),\n                      vec3(0.17-0.02*animData.z,-0.24-0.01*animData.z,0.08));\n    d2 = length(b.zw\/vec2(0.5,1.0)) - 0.03*clamp(1.0-b.y*b.y,0.0,1.0);\n    d = smin(d,d2,0.02);\n    isLip = max(isLip,(smoothstep(0.03,0.005,abs(b.z+0.015+abs(eos.x)*0.04))\n                 -smoothstep(0.45,0.47,eos.x-eos.y*1.15)));\n\n    \/\/ valley under nose\n    vec2 se = sdSegment(pos, vec3(0.0,-0.45,1.01),  vec3(0.0,-0.47,1.09) );\n    d2 = se.x-0.03-0.06*se.y;\n    d = smax(d,-d2,0.04);\n    isLip *= smoothstep(0.01,0.03,d2);\n\n    \/\/ neck\n    se = sdSegment(pos, vec3(0.0,-0.65,0.0), vec3(0.0,-1.7,-0.1) );\n    d2 = se.x - 0.38;\n\n    \/\/ shoulders\n    se = sdSegment(sos, vec3(0.0,-1.55,0.0), vec3(0.6,-1.65,0.0) );\n    d2 = smin(d2,se.x-0.21,0.1);\n    d = smin(d,d2,0.4);\n        \n    \/\/ register eyelases now\n    vec4 res = vec4( d, isLip, 0, 0 );\n    if( deyelashes<res.x )\n    {\n        res.x = deyelashes*0.8;\n        res.yzw = vec3(0.0,1.0,0.0);\n    }\n    \/\/ register teeth now\n    if( dTeeth<res.x )\n    {\n        res.x = dTeeth;\n        outMat = 5.0;\n    }\n \n    \/\/ eyes\n\tpos.x \/=1.05;        \n    eos = qos-vec3(0.25,-0.06,0.42);\n    d2 = sdSphere(eos,0.4);\n    if( d2<res.x ) \n    { \n        res.x = d2;\n     \toutMat = 2.0;\n        uvw = pos;\n    }\n        \n    \/\/ hair\n    {\n        vec2 occ_id, tmp;\n\t\tqos = pos; qos.x=abs(pos.x);\n\n        vec4 pres = sdHair(pos,vec3(-0.3, 0.55,0.8), \n                               vec3( 0.95, 0.7,0.85), \n                               vec3( 0.4,-1.45,0.95),\n                               -0.9,occ_id);\n\n        vec4 pres2 = sdHair(pos,vec3(-0.4, 0.6,0.55), \n                                vec3(-1.0, 0.4,0.2), \n                                vec3(-0.6,-1.4,0.7),\n                                0.6,tmp);\n        if( pres2.x<pres.x ) { pres=pres2; occ_id=tmp;  occ_id.y+=40.0;}\n\n        pres2 = sdHair(qos,vec3( 0.4, 0.7,0.4), \n                           vec3( 1.0, 0.5,0.45), \n                           vec3( 0.4,-1.45,0.55),\n                           -0.2,tmp);\n        if( pres2.x<pres.x ) { pres=pres2; occ_id=tmp;  occ_id.y+=80.0;}\n    \n\n        pres.x *= 0.8;\n        if( pres.x<res.x )\n        {\n            res = vec4( pres.x, occ_id.y, 0.0, occ_id.x );\n            uvw = pres.yzw;\n            outMat = 4.0;\n        }\n    }\n\n    \/\/ hoodie\n    vec4 tmp = sdHoodie( opos );\n    if( tmp.x<res.x )\n    {\n        res.x = tmp.x;\n        outMat = 3.0;\n        uvw  = tmp.yzw;\n    }\n\n    return res;\n}\n\n\/\/ SDF of the girl again, but with extra high frequency\n\/\/ modeling detail. While the previous one is used for\n\/\/ raymarching and shadowing, this one is used for normal\n\/\/ computation. This separation is conceptually equivalent\n\/\/ to decoupling detail from base geometry with \"normal\n\/\/ maps\", but done in 3D and with SDFs, which is way\n\/\/ simpler and can be done corretly (something rarely seen\n\/\/ in 3D engines) without any complexity.\nvec4 mapD( in vec3 pos, in float time )\n{\n    float matID;\n    vec3 uvw;\n    vec4 h = map(pos, time, matID, uvw);\n    \n    if( matID<1.5 ) \/\/ skin\n    {\n        \/\/ pores\n        float d = fbm1(iChannel0,120.0*uvw);\n        h.x += 0.0015*d*d;\n    }\n    else if( matID>3.5 && matID<4.5 ) \/\/ hair\n    {\n        \/\/ some random displacement to evoke hairs\n        float te = texture( iChannel2,vec2( 0.25*atan(uvw.x,uvw.y),8.0*uvw.z) ).x;\n    \th.x -= 0.02*te;\n    }    \n    return h;\n}\n\n\/\/ Computes the normal of the girl's surface (the gradient\n\/\/ of the SDF). The implementation is weird because of the\n\/\/ technicalities of the WebGL API that forces us to do\n\/\/ some trick to prevent code unrolling. More info here:\n\/\/\n\/\/ https:\/\/iquilezles.org\/articles\/normalsSDF\n\/\/\nvec3 calcNormal( in vec3 pos, in float time )\n{\n    const float eps = 0.001;\n#if 0    \n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*eps,time,kk ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps,time,kk ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps,time,kk ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps,time,kk ).x );\n#else\n    vec4 n = vec4(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec4 s = vec4(pos, 0.0);\n        float kk; vec3 kk2;\n        s[i] += eps;\n        n[i] = mapD(s.xyz, time).x;\n      \/\/if( n.x+n.y+n.z+n.w>100.0 ) break;\n    }\n    return normalize(n.xyz-n.w);\n#endif   \n}\n\n\/\/ Compute soft shadows for a given light, with a single\n\/\/ ray insead of using montecarlo integration or shadowmap\n\/\/ blurring. More info here:\n\/\/\n\/\/ https:\/\/iquilezles.org\/articles\/rmshadows\n\/\/\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, in float time, float k )\n{\n    \/\/ first things first - let's do a bounding volume test\n    vec2 sph = iCylinderY( ro, rd, 1.5 );\n  \/\/vec2 sph = iConeY(ro-vec3(-0.05,3.7,0.35),rd,0.08);\n    tmax = min(tmax,sph.y);\n\n    \/\/ raymarch and track penumbra    \n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<128; i++ )\n    {\n        float kk; vec3 kk2;\n\t\tfloat h = map( ro + rd*t, time, kk, kk2 ).x;\n        res = min( res, k*h\/t );\n        t += clamp( h, 0.005, 0.1 );\n        if( res<0.002 || t>tmax ) break;\n    }\n    return max( res, 0.0 );\n}\n\n\/\/ Computes convexity for our girl SDF, which can be used\n\/\/ to approximate ambient occlusion. More info here:\n\/\/\n\/\/ https:\/\/iquilezles.org\/www\/material\/nvscene2008\/rwwtt.pdf\n\/\/\nfloat calcOcclusion( in vec3 pos, in vec3 nor, in float time )\n{\n    float kk; vec3 kk2;\n\tfloat ao = 0.0;\n    float off = textureLod(iChannel3,gl_FragCoord.xy\/256.0,0.0).x;\n    vec4 k = vec4(0.7012912,0.3941462,0.8294585,0.109841)+off;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tk = fract(k + H4);\n        vec3 ap = normalize(-1.0+2.0*k.xyz);\n        float h = k.w*0.1;\n        ap = (nor+ap)*h;\n        float d = map( pos+ap, time, kk, kk2 ).x;\n        ao += max(0.0,h-d);\n        if( ao>16.0 ) break;\n    }\n\tao \/= 16.0;\n    return clamp( 1.0-ao*24.0, 0.0, 1.0 );\n}\n\n\/\/ Computes the intersection point between our girl SDF and\n\/\/ a ray (coming form the camera in this case). It's a\n\/\/ traditional and basic\/uncomplicated SDF raymarcher. More\n\/\/ info here:\n\/\/\n\/\/ https:\/\/iquilezles.org\/www\/material\/nvscene2008\/rwwtt.pdf\n\/\/\nvec2 intersect( in vec3 ro, in vec3 rd, in float tmax, in float time, out vec3 cma, out vec3 uvw )\n{\n    cma = vec3(0.0);\n    uvw = vec3(0.0);\n    float matID = -1.0;\n\n    float t = 1.0;\n    \n    \/\/ bounding volume test first\n    vec2 sph = iCylinderY( ro, rd, 1.5 );\n  \/\/vec2 sph = iConeY(ro-vec3(-0.05,3.7,0.35),rd,0.08);\n    if( sph.y<0.0 ) return vec2(-1.0);\n    \n    \/\/ clip raymarch space to bonding volume\n    tmax = min(tmax,sph.y);\n    t    = max(1.0, sph.x);\n    \n    \/\/ raymarch\n    for( int i=0; i<256; i++ )\n    {\n        vec3 pos = ro + t*rd;\n\n        float tmp;\n        vec4 h = map(pos,time,tmp,uvw);\n        if( h.x<0.001 )\n        {\n            cma = h.yzw;\n            matID = tmp;\n            break;\n        }\n        t += h.x*0.95;\n        if( t>tmax ) break;\n    }\n\n    return vec2(t,matID);\n}\n\n\/\/ This is a replacement for a traditional dot(N,L) diffuse\n\/\/ lobe (called N.L in the code) that fakes some subsurface\n\/\/ scattering (transmision of light thorugh the skin that\n\/\/ surfaces as a red glow)\n\/\/\nvec3 sdif( float ndl, float ir )\n{\n    float pndl = clamp( ndl, 0.0, 1.0 );\n    float nndl = clamp(-ndl, 0.0, 1.0 );\n    return vec3(pndl) + vec3(1.0,0.1,0.01)*0.7*pow(clamp(ir*0.75-nndl,0.0,1.0),2.0);\n}\n\n\/\/ Animates the eye central position (not the actual random\n\/\/ darts). It's carefuly synched with the head motion, to\n\/\/ make the eyes anticipate the head turn (without this\n\/\/ anticipation, the eyes and the head are disconnected and\n\/\/ it all looks like a zombie\/animatronic)\n\/\/\nfloat animEye( in float time )\n{\n    const float w = 6.1;\n    float t = mod(time-0.31,w*1.0);\n    \n    float q = fract((time-0.31)\/(2.0*w));\n    float s = (q > 0.5) ? 1.0 : 0.0;\n    return (t<0.15)?1.0-s:s;\n}\n\n\/\/ Renders the girl. It finds the ray-girl intersection\n\/\/ point, computes the normal at the intersection point,\n\/\/ computes the ambient occlusion approximation, does per\n\/\/ material setup (color, specularity, subsurface\n\/\/ coefficient and paints some fake occlusion), and finally\n\/\/ does the lighting computations.\n\/\/\n\/\/ Lighting is not based on pathtracing. Instead the bounce\n\/\/ light occlusion signals are created manually (placed\n\/\/ and sized by hand). The subsurface scattering in the\n\/\/ nose area is also painted by hand. There's not much\n\/\/ attention to the physicall correctness of the light\n\/\/ response and materials, but generally all signal do\n\/\/ follow physically based rendering practices.\n\/\/\nvec3 renderGirl( in vec2 p, in vec3 ro, in vec3 rd, in float tmax, in vec3 col, in float time )\n{\n    \/\/ --------------------------\n    \/\/ find ray-girl intersection\n    \/\/ --------------------------\n    vec3 cma, uvw;\n    vec2 tm = intersect( ro, rd, tmax, time, cma, uvw );\n\n    \/\/ --------------------------\n    \/\/ shading\/lighting\t\n    \/\/ --------------------------\n    if( tm.y>0.0 )\n    {\n        vec3 pos = ro + tm.x*rd;\n        vec3 nor = calcNormal(pos, time);\n\n        float ks = 1.0;\n        float se = 16.0;\n        float tinterShadow = 0.0;\n        float sss = 0.0;\n        float focc = 1.0;\n        \/\/float frsha = 1.0;\n\n        \/\/ --------------------------\n        \/\/ material\n        \/\/ --------------------------\n        if( tm.y<1.5 ) \/\/ skin\n        {\n            vec3 qos = vec3(abs(uvw.x),uvw.yz);\n\n            \/\/ base skin color\n            col = mix(vec3(0.225,0.15,0.12),\n                      vec3(0.24,0.1,0.066),\n                      smoothstep(0.4 ,0.0,length( qos.xy-vec2(0.42,-0.3)))+\n                      smoothstep(0.15,0.0,length((qos.xy-vec2(0,-0.29))\/vec2(1.4,1))));\n            \n            \/\/ fix that ugly highlight\n            col -= 0.03*smoothstep(0.13,0.0,length((qos.xy-vec2(0,-0.49))\/vec2(2,1)));\n                \n            \/\/ lips\n            col = mix(col,vec3(0.14,0.06,0.1),cma.x*step(-0.7,qos.y));\n            \n            \/\/ eyelashes\n            col = mix(col,vec3(0.04,0.02,0.02)*0.6,0.9*cma.y);\n\n            \/\/ fake skin drag\n            uvw.y += 0.025*animData.x*smoothstep(0.3,0.1,length(uvw-vec3(0.0,0.1,1.0)));\n\t\t\tuvw.y -= 0.005*animData.y*smoothstep(0.09,0.0,abs(length((uvw.xy-vec2(0.0,-0.38))\/vec2(2.5,1.0))-0.12));\n            \n            \/\/ freckles\n            vec2 ti = floor(9.0+uvw.xy\/0.04);\n            vec2 uv = fract(uvw.xy\/0.04)-0.5;\n            float te = fract(111.0*sin(1111.0*ti.x+1331.0*ti.y));\n            te = smoothstep(0.9,1.0,te)*exp(-dot(uv,uv)*24.0); \n            col *= mix(vec3(1.1),vec3(0.8,0.6,0.4), te);\n\n            \/\/ texture for specular\n            ks = 0.5 + 4.0*texture(iChannel3,uvw.xy*1.1).x;\n            se = 12.0;\n            ks *= 0.5;\n            tinterShadow = 1.0;\n            sss = 1.0;\n            ks *= 1.0 + cma.x;\n            \n            \/\/ black top\n            col *= 1.0-smoothstep(0.48,0.51,uvw.y);\n            \n            \/\/ makeup\n            float d2 = sdEllipsoid(qos-vec3(0.25,-0.03,0.43),vec3(0.37,0.42,0.4));\n            col = mix(col,vec3(0.06,0.024,0.06),1.0 - smoothstep(0.0,0.03,d2));\n\n            \/\/ eyebrows\n    \t\t{\n            #if 0\n            \/\/ youtube video version\n        \tvec4 be = sdBezier( qos, vec3(0.165+0.01*animData.x,0.105-0.02*animData.x,0.89),\n                                     vec3(0.37,0.18-0.005*animData.x,0.82+0.005*animData.x), \n                                     vec3(0.53,0.15,0.69) );\n            float ra = 0.005 + 0.015*sqrt(be.y);\n            #else\n            \/\/ fixed version\n        \tvec4 be = sdBezier( qos, vec3(0.16+0.01*animData.x,0.11-0.02*animData.x,0.89),\n                                     vec3(0.37,0.18-0.005*animData.x,0.82+0.005*animData.x), \n                                     vec3(0.53,0.15,0.69) );\n            float ra = 0.005 + 0.01*sqrt(1.0-be.y);\n            #endif\n            float dd = 1.0+0.05*(0.7*sin((sin(qos.x*3.0)\/3.0-0.5*qos.y)*350.0)+\n                                 0.3*sin((qos.x-0.8*qos.y)*250.0+1.0));\n    \t\tfloat d = be.x - ra*dd;\n        \tfloat mask = 1.0-smoothstep(-0.005,0.01,d);\n        \tcol = mix(col,vec3(0.04,0.02,0.02),mask*dd );\n        \t}\n\n            \/\/ fake occlusion\n            focc = 0.2+0.8*pow(1.0-smoothstep(-0.4,1.0,uvw.y),2.0);\n            focc *= 0.5+0.5*smoothstep(-1.5,-0.75,uvw.y);\n            focc *= 1.0-smoothstep(0.4,0.75,abs(uvw.x));\n            focc *= 1.0-0.4*smoothstep(0.2,0.5,uvw.y);\n            \n            focc *= 1.0-smoothstep(1.0,1.3,1.7*uvw.y-uvw.x);\n            \n            \/\/frsha = 0.0;\n        }\n        else if( tm.y<2.5 ) \/\/ eye\n        {\n            \/\/ The eyes are fake in that they aren't 3D. Instead I simply\n\t\t\t\/\/ stamp a 2D mathematical drawing of an iris and pupil. That\n\t\t\t\/\/ includes the highlight and occlusion in the eyesballs.\n            \n            sss = 1.0;\n\n            vec3 qos = vec3(abs(uvw.x),uvw.yz);\n\t\t\tfloat ss = sign(uvw.x);\n            \n            \/\/ iris animation\n            float dt = floor(time*1.1);\n            float ft = fract(time*1.1);\n            vec2 da0 = sin(1.7*(dt+0.0)) + sin(2.3*(dt+0.0)+vec2(1.0,2.0));\n            vec2 da1 = sin(1.7*(dt+1.0)) + sin(2.3*(dt+1.0)+vec2(1.0,2.0));\n            vec2 da = mix(da0,da1,smoothstep(0.9,1.0,ft));\n\n            float gg = animEye(time);\n            da *= 1.0+0.5*gg;\n            qos.yz = rot(qos.yz,da.y*0.004-0.01);\n            qos.xz = rot(qos.xz,da.x*0.004*ss-gg*ss*(0.03-step(0.0,ss)*0.014)+0.02);\n\n            vec3 eos = qos-vec3(0.31,-0.055 - 0.03*animData.x,0.45);\n            \n            \/\/ iris\n            float r = length(eos.xy)+0.005;\n            float a = atan(eos.y,ss*eos.x);\n            vec3 iris = vec3(0.09,0.0315,0.0135);\n            iris += iris*3.0*(1.0-smoothstep(0.0,1.0, abs((a+3.14159)-2.5) ));\n            iris *= 0.35+0.7*texture(iChannel2,vec2(r,a\/6.2831)).x;\n            \/\/ base color\n            col = vec3(0.42);\n            col *= 0.1+0.9*smoothstep(0.10,0.114,r);\n            col = mix( col, iris, 1.0-smoothstep(0.095,0.10,r) );\n            col *= smoothstep(0.05,0.07,r);\n\t\t\t\n            \/\/ fake occlusion backed in\n            float edis = length((vec2(abs(uvw.x),uvw.y)-vec2(0.31,-0.07))\/vec2(1.3,1.0));\n            col *= mix( vec3(1.0), vec3(0.4,0.2,0.1), linearstep(0.07,0.16,edis) );\n\n            \/\/ fake highlight\n            qos = vec3(abs(uvw.x),uvw.yz);\n            col += (0.5-gg*0.3)*(1.0-smoothstep(0.0,0.02,length(qos.xy-vec2(0.29-0.05*ss,0.0))));\n            \n            se = 128.0;\n\n            \/\/ fake occlusion\n            focc = 0.2+0.8*pow(1.0-smoothstep(-0.4,1.0,uvw.y),2.0);\n            focc *= 1.0-linearstep(0.10,0.17,edis);\n            \/\/frsha = 0.0;\n        }\n        else if( tm.y<3.5 )\/\/ hoodie\n        {\n            sss = 0.0;\n            col = vec3(0.81*texture(iChannel0,uvw*6.0).x);\n            ks *= 2.0;\n            \n            \/\/ logo\n            if( abs(uvw.x)<0.66 )\n            {\n                float par = length(uvw.yz-vec2(-1.05,0.65));\n                col *= mix(vec3(1.0),vec3(0.6,0.2,0.8)*0.7,1.0-smoothstep(0.1,0.11,par));\n                col *= smoothstep(0.005,0.010,abs(par-0.105));\n            }                \n\n            \/\/ fake occlusion\n            focc = mix(1.0,\n                \t   0.03+0.97*smoothstep(-0.15,1.7,uvw.z),\n                       smoothstep(-1.6,-1.3,uvw.y)*(1.0-clamp(dot(nor.xz,normalize(uvw.xz)),0.0,1.0))\n                      );\n            \n            \/\/frsha = mix(1.0,\n            \/\/            clamp(dot(nor.xz,normalize(uvw.xz)),0.0,1.0),\n            \/\/            smoothstep(-1.6,-1.3,uvw.y)\n            \/\/           );\n            \/\/frsha *= smoothstep(0.85,1.0,length(uvw-vec3(0.0,-1.0,0.0)));\n        }\n        else if( tm.y<4.5 )\/\/ hair\n        {\n            sss = 0.0;\n            col = (sin(cma.x)>0.7) ? vec3(0.03,0.01,0.05)*1.5 :\n                                     vec3(0.04,0.02,0.01)*0.4;\n            ks *= 0.75 + cma.z*18.0;\n            float te = texture( iChannel2,vec2( 0.25*atan(uvw.x,uvw.y),8.0*uvw.z) ).x;\n            col *= 2.0*te;\n            ks *= 1.5*te;\n            \n\t\t\t\/\/ fake occlusion\n            focc  = 1.0-smoothstep(-0.40, 0.8, uvw.y);\n            focc *= 1.0-0.95*smoothstep(-1.20,-0.2,-uvw.z);\n            focc *= 0.5+cma.z*12.0;\n            \/\/frsha = 1.0-smoothstep(-1.3,-0.8,uvw.y);\n            \/\/frsha *= 1.0-smoothstep(-1.20,-0.2,-uvw.z);\n        }\n        else if( tm.y<5.5 )\/\/ teeth\n        {\n            sss = 1.0;\n            col = vec3(0.3);\n            ks *= 1.5;\n            \/\/frsha = 0.0;\n        }\n\n        float fre = clamp(1.0+dot(nor,rd),0.0,1.0);\n        float occ = focc*calcOcclusion( pos, nor, time );\n\n        \/\/ --------------------------\n        \/\/ lighting. just four lights\n        \/\/ --------------------------\n        vec3 lin = vec3(0.0);\n\n        \/\/ fake sss\n        float nma = 0.0;\n        if( tm.y<1.5 )\n        {\n        nma = 1.0-smoothstep(0.0,0.12,length((uvw.xy-vec2(0.0,-0.37))\/vec2(2.4,0.7)));\n        }\n\n        \/\/vec3 lig = normalize(vec3(0.5,0.4,0.6));\n        vec3 lig = vec3(0.57,0.46,0.68);\n        vec3 hal = normalize(lig-rd);\n        float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n        \/\/float sha = 0.0; if( dif>0.001 ) sha=calcSoftshadow( pos+nor*0.002, lig, 0.0001, 2.0, time, 5.0 );\n        float sha = calcSoftshadow( pos+nor*0.002, lig, 0.0001, 2.0, time, 5.0 );\n        float spe = 2.0*ks*pow(clamp(dot(nor,hal),0.0,1.0),se)*dif*sha*(0.04+0.96*pow(clamp(1.0-dot(hal,-rd),0.0,1.0),5.0));\n\n        \/\/ fake sss for key light\n        vec3 cocc = mix(vec3(occ),\n                        vec3(0.1+0.9*occ,0.9*occ+0.1*occ*occ,0.8*occ+0.2*occ*occ),\n                        tinterShadow);\n        cocc = mix( cocc, vec3(1,0.3,0.0), nma);\n        sha = mix(sha,max(sha,0.3),nma);\n\n        vec3  amb = cocc*(0.55 + 0.45*nor.y);\n        float bou = clamp(0.3-0.7*nor.x, 0.0, 1.0 );\n\n        lin +=      vec3(0.65,1.05,2.0)*amb*1.15;\n        lin += 1.50*vec3(1.60,1.40,1.2)*sdif(dot(nor,lig),0.5+0.3*nma+0.2*(1.0-occ)*tinterShadow) * mix(vec3(sha),vec3(sha,0.2*sha+0.7*sha*sha,0.2*sha+0.7*sha*sha),tinterShadow);\n        lin +=      vec3(1.00,0.30,0.1)*sss*fre*0.6*(0.5+0.5*dif*sha*amb)*(0.1+0.9*focc);\n        lin += 0.35*vec3(4.00,2.00,1.0)*bou*occ*col;\n\n        col = lin*col + spe + fre*fre*fre*0.1*occ;\n\n        \/\/ overall\n\t\tcol *= 1.1;\n    }\n        \n    return col;\n}\n\n\/\/ Animates the head turn. This is my first time animating\n\/\/ and I am aware I'm in uncanny\/animatronic land. But I\n\/\/ have to start somwhere!\n\/\/\nfloat animTurn( in float time )\n{\t\n    const float w = 6.1;\n    float t = mod(time,w*2.0);\n    \n    vec3 p = (t<w) ? vec3(0.0,0.0,1.0) : vec3(w,1.0,-1.0);\n    return p.y + p.z*expSustainedImpulse(t-p.x,1.0,10.0);\n}\n\n\/\/ Animates the eye blinks. Blinks are motivated by head\n\/\/ turns (again, in an attempt tp avoid animatronic and\n\/\/ zoombie feel), but also there are random blinks. This\n\/\/ same funcion is called with some delay and extra\n\/\/ smmoothness to get the blink of the eyes be followed by\n\/\/ the face muscles around the face.\n\/\/\nfloat animBlink( in float time, in float smo )\n{\n    \/\/ head-turn motivated blink\n    const float w = 6.1;\n    float t = mod(time-0.31,w*1.0);\n    float blink = smoothstep(0.0,0.1,t) - smoothstep(0.18,0.4,t);\n\n    \/\/ regular blink\n    float tt = mod(1.0+time,3.0);\n    blink = max(blink,smoothstep(0.0,0.07+0.07*smo,tt)-smoothstep(0.1+0.04*smo,0.35+0.3*smo,tt));\n    \n    \/\/ keep that eye alive always\n    float blinkBase = 0.04*(0.5+0.5*sin(time));\n    blink = mix( blinkBase, 1.0, blink );\n\n    \/\/ base pose is a bit down\n    float down = 0.15;\n    return down+(1.0-down)*blink;\n}\n\n\/\/ The main rendering entry point. Basically it does some\n\/\/ setup, creating the ray that will explore the 3D scene\n\/\/ in search of the girl for each pixel, computes the\n\/\/ animation variables (blink, mouth and head movements),\n\/\/ does the rendering of the girl if it finds her under\n\/\/ the current pixel, and finally does gamme correction\n\/\/ and some minimal color processing and vignetting to the\n\/\/ image.\n\/\/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ render\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        \/\/ pixel coordinates\n        vec2 o = vec2(float(m),float(n)) \/ float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))\/iResolution.y;\n        float d = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n        float time = iTime - 0.5*(1.0\/24.0)*(float(m*AA+n)+d)\/float(AA*AA-1);\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)\/iResolution.y;\n        float time = iTime;\n        #endif\n        \n        time += 2.0;\n        \n        \/\/ camera movement\t\n        vec3 ro; float fl;\n        mat3 ca = calcCamera( time, ro, fl );\n    \tvec3 rd = ca * normalize( vec3((p-vec2(-0.52,0.12))\/1.1,fl));\n\n        \/\/ animation (blink, face follow up, mouth)\n        float turn = animTurn( time );\n        animData.x = animBlink(time,0.0);\n        animData.y = animBlink(time-0.02,1.0);\n        animData.z = -0.25 + 0.2*(1.0-turn)*smoothstep(-0.3,0.9,sin(time*1.1)) + 0.05*cos(time*2.7);\n\n        \/\/ animation (head orientation)\n        animHead = vec3( sin(time*0.5), sin(time*0.3), -cos(time*0.2) );\n        animHead = animHead*animHead*animHead;\n        animHead.x = -0.025*animHead.x + 0.2*(0.7+0.3*turn);\n        animHead.y =  0.1 + 0.02*animHead.y*animHead.y*animHead.y;\n        animHead.z = -0.03*(0.5 + 0.5*animHead.z) - (1.0-turn)*0.05;\n        \n        \/\/ rendering\n        vec4 tmp = texelFetch(iChannel1,ivec2(fragCoord),0);\n        vec3 col = tmp.xyz;\n        float tmin = tmp.w;\n        \n        if( p.x*1.4+p.y<0.8 && -p.x*4.5+p.y<6.5 && p.x<0.48)\n        col = renderGirl(p,ro,rd,tmin,col,time);\n        \/\/else col=vec3(0,1,0);\n        \n        \/\/ gamma        \n        col = pow( col, vec3(0.4545) );\n\t    tot += col;\n    #if AA>1\n    }\n    tot \/= float(AA*AA);\n    #endif\n \n    \/\/ compress\n    tot = 3.8*tot\/(3.0+dot(tot,vec3(0.333)));\n  \n    \/\/ vignette\n    vec2 q = fragCoord\/iResolution.xy;\n    tot *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.15);\n\n    \/\/ grade\n    tot = tot*vec3(1.02,1.00,0.99)+vec3(0.0,0.0,0.045);\n       \n    fragColor = vec4( tot, 1.0 );\n}",
                "name": "Image",
                "description": "",
                "type": "image"
            },
            {
                "inputs": [],
                "outputs": [],
                "code": "\/\/ Basic utility functions (SDFs, noises, shaping functions)\n\/\/ and also the camera setup which is shared between the\n\/\/ background rendering code (\"Buffer A\" tab) and the character\n\/\/ rendering code (\"Image\" tab)\n\n\n\n\/\/ https:\/\/iquilezles.org\/articles\/smin\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25\/k;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/smin\nfloat smax( float a, float b, float k )\n{\n    k *= 1.4;\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*h\/(6.0*k*k);\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/smin\nfloat smin3( float a, float b, float k )\n{\n    k *= 1.4;\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*h\/(6.0*k*k);\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/smin\nfloat sclamp(in float x, in float a, in float b )\n{\n    float k = 0.1;\n\treturn smax(smin(x,b,k),a,k);\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nfloat opOnion( in float sdf, in float thickness )\n{\n    return abs(sdf)-thickness;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nfloat opRepLim( in float p, in float s, in float lima, in float limb )\n{\n    return p-s*clamp(round(p\/s),lima,limb);\n}\n\nfloat det( vec2 a, vec2 b ) { return a.x*b.y-b.x*a.y; }\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x-a.y*b.y; }\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nfloat sdTorus( in vec3 p, in float ra, in float rb )\n{\n    return length( vec2(length(p.xz)-ra,p.y) )-rb;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.z) ? dot(p.xz,sc) : length(p.xz);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nfloat sdSphere( in vec3 p, in float r ) \n{\n    return length(p)-r;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    float k0 = length(p\/r);\n    float k1 = length(p\/(r*r));\n    return k0*(k0-1.0)\/k1;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nfloat sdBox( in vec3 p, in vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min( max(max(d.x,d.y),d.z),0.0) + length(max(d,0.0));\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nfloat sdArc( in vec2 p, in vec2 scb, in float ra )\n{\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k );\n}\n\n#if 1\n\/\/ http:\/\/research.microsoft.com\/en-us\/um\/people\/hoppe\/ravg.pdf\n\/\/ { dist, t, y (above the plane of the curve, x (away from curve in the plane of the curve))\nvec4 sdBezier( vec3 p, vec3 va, vec3 vb, vec3 vc )\n{\n  vec3 w = normalize( cross( vc-vb, va-vb ) );\n  vec3 u = normalize( vc-vb );\n  vec3 v =          ( cross( w, u ) );\n  \/\/----  \n  vec2 m = vec2( dot(va-vb,u), dot(va-vb,v) );\n  vec2 n = vec2( dot(vc-vb,u), dot(vc-vb,v) );\n  vec3 q = vec3( dot( p-vb,u), dot( p-vb,v), dot(p-vb,w) );\n  \/\/----  \n  float mn = det(m,n);\n  float mq = det(m,q.xy);\n  float nq = det(n,q.xy);\n  \/\/----  \n  vec2  g = (nq+mq+mn)*n + (nq+mq-mn)*m;\n  float f = (nq-mq+mn)*(nq-mq+mn) + 4.0*mq*nq;\n  vec2  z = 0.5*f*vec2(-g.y,g.x)\/dot(g,g);\n\/\/float t = clamp(0.5+0.5*(det(z,m+n)+mq+nq)\/mn, 0.0 ,1.0 );\n  float t = clamp(0.5+0.5*(det(z-q.xy,m+n))\/mn, 0.0 ,1.0 );\n  vec2 cp = m*(1.0-t)*(1.0-t) + n*t*t - q.xy;\n  \/\/----  \n  float d2 = dot(cp,cp);\n  return vec4(sqrt(d2+q.z*q.z), t, q.z, -sign(f)*sqrt(d2) );\n}\n#else\nfloat det( vec3 a, vec3 b, in vec3 v ) { return dot(v,cross(a,b)); }\n\n\/\/ my adaptation to 3d of http:\/\/research.microsoft.com\/en-us\/um\/people\/hoppe\/ravg.pdf\n\/\/ { dist, t, y (above the plane of the curve, x (away from curve in the plane of the curve))\nvec4 sdBezier( vec3 p, vec3 b0, vec3 b1, vec3 b2 )\n{\n    b0 -= p;\n    b1 -= p;\n    b2 -= p;\n    \n    vec3  d21 = b2-b1;\n    vec3  d10 = b1-b0;\n    vec3  d20 = (b2-b0)*0.5;\n\n    vec3  n = normalize(cross(d10,d21));\n\n    float a = det(b0,b2,n);\n    float b = det(b1,b0,n);\n    float d = det(b2,b1,n);\n    vec3  g = b*d21 + d*d10 + a*d20;\n\tfloat f = a*a*0.25-b*d;\n\n    vec3  z = cross(b0,n) + f*g\/dot(g,g);\n    float t = clamp( dot(z,d10-d20)\/(a+b+d), 0.0 ,1.0 );\n    vec3 q = mix(mix(b0,b1,t), mix(b1,b2,t),t);\n    \n    float k = dot(q,n);\n    return vec4(length(q),t,-k,-sign(f)*length(q-n*k));\n}\n#endif\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nvec2 sdSegment(vec3 p, vec3 a, vec3 b)\n{\n    vec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ), h );\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nvec2 sdSegmentOri(vec2 p, vec2 b)\n{\n\tfloat h = clamp( dot(p,b)\/dot(b,b), 0.0, 1.0 );\n\treturn vec2( length( p - b*h ), h );\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nfloat sdFakeRoundCone(vec3 p, float b, float r1, float r2)\n{\n    float h = clamp( p.y\/b, 0.0, 1.0 );\n    p.y -= b*h;\n\treturn length(p) - mix(r1,r2,h);\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nfloat sdCone( in vec3 p, in vec2 c )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n\n  vec2 a = q - c*clamp( (q.x*c.x+q.y*c.y)\/dot(c,c), 0.0, 1.0 );\n  vec2 b = q - c*vec2( clamp( q.x\/c.x, 0.0, 1.0 ), 1.0 );\n  \n  float s = -sign( c.y );\n  vec2 d = min( vec2( dot( a, a ), s*(q.x*c.y-q.y*c.x) ),\n\t\t\t    vec2( dot( b, b ), s*(q.y-c.y)  ));\n  return -sqrt(d.x)*sign(d.y);\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n    p = abs(p);\n    vec2 b = vec2(la,lb);\n    float f = clamp( (ndot(b,b-2.0*p.xz))\/dot(b,b), -1.0, 1.0 );\n\tvec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/distfunctions\nvec4 opElongate( in vec3 p, in vec3 h )\n{\n    vec3 q = abs(p)-h;\n    return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n\n\/\/-----------------------------------------------\n\n\/\/ ray-infinite-cylinder intersection\nvec2 iCylinderY( in vec3 ro, in vec3 rd, in float rad )\n{\n\tvec3 oc = ro;\n    float a = dot( rd.xz, rd.xz );\n\tfloat b = dot( oc.xz, rd.xz );\n\tfloat c = dot( oc.xz, oc.xz ) - rad*rad;\n\tfloat h = b*b - a*c;\n\tif( h<0.0 ) return vec2(-1.0);\n    h = sqrt(h);\n\treturn vec2(-b-h,-b+h)\/a;\n}\n\n\/\/ ray-infinite-cone intersection\nvec2 iConeY(in vec3 ro, in vec3 rd, in float k )\n{\n\tfloat a = dot(rd.xz,rd.xz) - k*rd.y*rd.y;\n    float b = dot(ro.xz,rd.xz) - k*ro.y*rd.y;\n    float c = dot(ro.xz,ro.xz) - k*ro.y*ro.y; \n        \n    float h = b*b-a*c;\n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b-h,-b+h)\/a;\n}\n\n\/\/-----------------------------------------------\n\nfloat linearstep(float a, float b, in float x )\n{\n    return clamp( (x-a)\/(b-a), 0.0, 1.0 );\n}\n\nvec2 rot( in vec2 p, in float an )\n{\n    float cc = cos(an);\n    float ss = sin(an);\n    return mat2(cc,-ss,ss,cc)*p;\n}\n\nfloat expSustainedImpulse( float t, float f, float k )\n{\n    return smoothstep(0.0,f,t)*1.1 - 0.1*exp2(-k*max(t-f,0.0));\n}\n\n\/\/-----------------------------------------------\n\nvec3 hash3( uint n ) \n{\n    \/\/ integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    uvec3 k = n * uvec3(n,n*16807U,n*48271U);\n    return vec3( k & uvec3(0x7fffffffU))\/float(0x7fffffff);\n}\n\n\/\/---------------------------------------\n\nfloat noise1( sampler3D tex, in vec3 x )\n{\n    return textureLod(tex,(x+0.5)\/32.0,0.0).x;\n}\nfloat noise1( sampler2D tex, in vec2 x )\n{\n    return textureLod(tex,(x+0.5)\/64.0,0.0).x;\n}\nfloat noise1f( sampler2D tex, in vec2 x )\n{\n    return texture(tex,(x+0.5)\/64.0).x;\n}\nfloat fbm1( sampler3D tex, in vec3 x )\n{\n    float f = 0.0;\n    f += 0.5000*noise1(tex,x); x*=2.01;\n    f += 0.2500*noise1(tex,x); x*=2.01;\n    f += 0.1250*noise1(tex,x); x*=2.01;\n    f += 0.0625*noise1(tex,x);\n    f = 2.0*f-0.9375;\n    return f;\n}\n\nfloat fbm1( sampler2D tex, in vec2 x )\n{\n    float f = 0.0;\n    f += 0.5000*noise1(tex,x); x*=2.01;\n    f += 0.2500*noise1(tex,x); x*=2.01;\n    f += 0.1250*noise1(tex,x); x*=2.01;\n    f += 0.0625*noise1(tex,x);\n    f = 2.0*f-0.9375;\n    return f;\n}\nfloat fbm1f( sampler2D tex, in vec2 x )\n{\n    float f = 0.0;\n    f += 0.5000*noise1f(tex,x); x*=2.01;\n    f += 0.2500*noise1f(tex,x); x*=2.01;\n    f += 0.1250*noise1f(tex,x); x*=2.01;\n    f += 0.0625*noise1f(tex,x);\n    f = 2.0*f-0.9375;\n    return f;\n}\nfloat bnoise( in float x )\n{\n    float i = floor(x);\n    float f = fract(x);\n    float s = sign(fract(x\/2.0)-0.5);\n    float k = 0.5+0.5*sin(i);\n    return s*f*(f-1.0)*((16.0*k-4.0)*f*(f-1.0)-1.0);\n}\nvec3 fbm13( in float x, in float g )\n{    \n    vec3 n = vec3(0.0);\n    float s = 1.0;\n    for( int i=0; i<6; i++ )\n    {\n        n += s*vec3(bnoise(x),bnoise(x+13.314),bnoise(x+31.7211));\n        s *= g;\n        x *= 2.01;\n        x += 0.131;\n    }\n    return n;\n}\n\n\/\/--------------------------------------------------\n\/\/const float X1 = 1.6180339887498948; const float H1 = float( 1.0\/X1 );\n\/\/const float X2 = 1.3247179572447460; const vec2  H2 = vec2(  1.0\/X2, 1.0\/(X2*X2) );\n\/\/const float X3 = 1.2207440846057595; const vec3  H3 = vec3(  1.0\/X3, 1.0\/(X3*X3), 1.0\/(X3*X3*X3) );\n  const float X4 = 1.1673039782614187; const vec4  H4 = vec4(  1.0\/X4, 1.0\/(X4*X4), 1.0\/(X4*X4*X4), 1.0\/(X4*X4*X4*X4) );\n\n\/\/--------------------------------------\nmat3 calcCamera( in float time, out vec3 oRo, out float oFl )\n{\n    vec3 ta = vec3( 0.0, -0.3, 0.0 );\n    vec3 ro = vec3( -0.5563, -0.2, 2.7442 );\n    float fl = 1.7;\n#if 0\n    vec3 fb = fbm13( 0.2*time, 0.5 );\n    ta += 0.025*fb;\n    float cr = -0.01 + 0.006*fb.z;\n#else\n    vec3 fb1 = fbm13( 0.15*time, 0.50 );\n    ro.xyz += 0.010*fb1.xyz;\n    vec3 fb2 = fbm13( 0.33*time, 0.65 );\n    fb2 = fb2*fb2*sign(fb2);\n    ta.xy += 0.005*fb2.xy;\n    float cr = -0.01 + 0.002*fb2.z;\n#endif\n    \n    \/\/ camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(cr),cos(cr),0.0) ) );\n    vec3 vv =          ( cross(uu,ww));\n    \n    oRo = ro;\n    oFl = fl;\n\n    return mat3(uu,vv,ww);\n}\n\n#define ZERO min(iFrame,0)\n#define ZEROU min(uint(iFrame),0u)\n",
                "name": "Common",
                "description": "",
                "type": "common"
            },
            {
                "inputs": [
                    {
                        "id": "4sf3Rn",
                        "filepath": "\/media\/a\/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png",
                        "previewfilepath": "\/media\/ap\/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png",
                        "type": "texture",
                        "channel": 2,
                        "sampler": {
                            "filter": "mipmap",
                            "wrap": "repeat",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    },
                    {
                        "id": "Xsf3zn",
                        "filepath": "\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
                        "previewfilepath": "\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
                        "type": "texture",
                        "channel": 3,
                        "sampler": {
                            "filter": "mipmap",
                            "wrap": "repeat",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    },
                    {
                        "id": "4sfGRr",
                        "filepath": "\/media\/a\/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin",
                        "previewfilepath": "\/media\/ap\/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin",
                        "type": "volume",
                        "channel": 0,
                        "sampler": {
                            "filter": "mipmap",
                            "wrap": "repeat",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    },
                    {
                        "id": "4dXGR8",
                        "filepath": "\/media\/previz\/buffer00.png",
                        "previewfilepath": "\/media\/previz\/buffer00.png",
                        "type": "buffer",
                        "channel": 1,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "4dXGR8",
                        "channel": 0
                    }
                ],
                "code": "\/\/ Renders the background (trees, ground, river and bridge).\n\/\/ The render uses a super basic implementation of Temporal\n\/\/ Antialiasing (TAA) without color clipping or anything,\n\/\/ but it's enough to stabilize aliasing. It also outputs\n\/\/ the deph buffer into the alpha channel for the next pass\n\/\/ (\"Buffer B\") to consume and do proper Depth Of Field.\n\n\n\/\/ The ground - it's a simple box deformed by a few sine waves\n\/\/\nfloat sdGround( in vec3 pos )\n{\n    pos -= vec3(120.0,-35.0,-700.0);\n    pos.x += -150.0;\n    pos.z += 30.0*sin(1.00*pos.x*0.016+0.0);\n    pos.z += 10.0*sin(2.20*pos.x*0.016+1.0);\n    pos.y += 20.0*sin(0.01*pos.x+2.0)*sin(0.01*pos.z+2.0);\n    \n    return sdBox(pos,vec3(1000.0,2.0,400.0))-10.0;\n}\n\n\/\/ The bridge. It's made of five boxes repeated forever\n\/\/ with some mod() call, which are distorted with gentle\n\/\/ sine waves so they don't look like perfectly geometrical. \n\/\/\nvec2 sdBridge( in vec3 pos )\n{\n    float issnow = 0.0;\n    vec3 opos = pos;\n    pos.x  += 50.0*sin(pos.z*0.01)+10.0;\n    pos.xz += 0.05*sin(pos.yx+vec2(0,2));                \n    vec3 sos = vec3(abs(pos.x),pos.yz);\n    float h = -16.0;\n    \n    \/\/ floor\n    vec3 ros = vec3(sos.xy,mod(sos.z+2.0,4.0)-2.0 )-vec3(0.0,h,0.0);\n    float d = sdBox(ros,vec3(20.0,1.0,1.85));\n\n    \/\/ thick bars\n    ros = vec3(sos.xy,mod(sos.z+5.0,10.0)-5.0 )-vec3(20.0,h+5.0-0.4,0.0);\n    float d2 = sdBox(ros,vec3(1.2,5.0,0.7)+0.1)-0.1;\n    d = min(d,d2);\n    \n    #if 0\n    {\n    float id = floor((sos.z+5.0)\/10.0);\n    ros = vec3(sos.xy,mod(sos.z+5.0,10.0)-5.0 )-vec3(20.0,h-0.4,0.0);\n\tros-=vec3(-1.5,1,0);\n    ros.x -= ros.y;\n    float ra = 0.5 + 0.5*sin(float(id)+4.0);\n    float d2 = sdEllipsoid(ros,vec3(2.0,2.0,1.3)*ra);\n    issnow = clamp( 0.5+0.5*(d-d2)\/0.7, 0.0, 1.0 );\n    d = smin(d,d2,0.7);\n    }\n    #endif\n\n    \/\/ small bars\n    ros = vec3(sos.xy,mod(sos.z+1.25,2.5)-1.25 )-vec3(20.0,h+5.0,0.0);\n    d2 = sdBox(ros,vec3(0.2,5.0,0.2))-0.05;\n    d = min(d,d2);\n    \n    \/\/ handle\n    d2 = sdBox(sos-vec3(20.0,h+10.0,0.0),vec3(0.5,0.1,300.0))-0.4;\n    d = min(d,d2);\n    \n    \/\/ foot bar\n    d2 = sdBox(sos-vec3(20.0,h+2.4,0.0),vec3(0.7,0.1,300.0))-0.2;\n    d = min(d,d2);\n    \n\treturn vec2(d,issnow);\n}\n\n\/\/ The trees are ultra basic and look really bad without\n\/\/ defocus, but all I needed was something that looked like\n\/\/ pine trees so the viewers would complete the picture in\n\/\/ their heads. Only four trees are evaluated at any time,\n\/\/ even though  there are inifinte many of them. Yet these\n\/\/ four trees consume most of the rendering budget for the\n\/\/ painting.\n\/\/\nvec3 sdForest( in vec3 pos, float tmin )\n{\n    float shid = 0.0;\n    \n    const float per = 200.0;\n    \n    pos -= vec3(120.0,-16.0,-600.0);\n        \n    vec3 vos = pos\/per;\n    vec3 ip = floor(vos);\n    vec3 fp = fract(vos);\n    \n    bool hit = false;\n    float d = tmin;\n    float occ = 1.0;\n    \n    for( int j=0; j<=1; j++ )\n    for( int i=0; i<=1; i++ )\n    {\n        vec2 of = vec2(i,j);\n        ivec2 tid = ivec2(ip.xz + of );\n        tid.y = min(tid.y,-0);\n        \n        uint treeId = uint(tid.y)*17u+uint(tid.x)*1231u;\n        \n        vec3 rf =  hash3( uint(treeId) )-0.5;\n        \n        vec3 ros = vec3( (float(tid.x)+rf.x)*per,\n                         0.0,\n                         (float(tid.y)+rf.y)*per );\n\n\n        float hei = 1.0 + 0.2*sin( float(tid.x*115+tid.y*221) );\n        hei *= (tid.y==0) ? 1.0 : 1.5;\n          \n        hei *= 275.0;\n\n        float d2 = sdFakeRoundCone( pos-ros,hei,7.0,1.0);\n        if( d2<d)\n        {\n            d = d2;\n            hit = false;\n        }\n        \n        if( d2-150.0>d ) continue;\n        \n        vec2 qos = pos.xz - ros.xz;\n        float an = atan(qos.x,qos.y);\n        float ra = length(qos);\n        float vv = 0.3*sin(11.0*an) + 0.2*sin(28.0*an)+ 0.10*sin(53.0*an+4.0);\n\n        \n        \/\/ trick - only evalute 4 closest of the 10 cones\n        int segid = int(floor(16.0*(pos.y-ros.y)\/hei));\n        for( uint k=ZEROU; k<4u; k++ )\n        {\n            uint rk = uint( min(max(segid+int(k),5),15) );\n            \n            float h = float(rk)\/15.0;\n            \n            vec3 ran = hash3( treeId*24u+rk );\n            \n            h += 0.1*(1.0-h)*(ran.z-0.5) + 0.05*sin(1.0*an);\n\n            ros.y = h*hei;\n            \n            float hh = 0.5 + 0.5*(1.0-h);\n            float ww = 0.1 + 0.9*(1.0-h);\n            hh *= 0.7+0.2*ran.x;\n            ww *= 0.9+0.2*ran.y;\n            hh *= 1.0+0.2*vv;\n            \n            vec2 rrr = vec2( ra, pos.y-ros.y );\n            vec2 tmp = sdSegmentOri( rrr,vec2(120.0*ww,-100.0*hh));\n            float d2 = tmp.x-mix(1.0,vv,tmp.y);\n            if( d2<d )\n            {\n                hit = true;\n                d = d2;\n                shid = rf.z;\n                occ = tmp.y * clamp(ra\/100.0+h,0.0,1.0);\n            }\n        }\n    }\n    \n    if( hit )\n    {\n        float dis = 0.5+0.5*fbm1(iChannel0,0.1*pos*vec3(1,0.3,1));\n        d -= 8.0*dis-4.0;\n        \/\/occ = dis;\n    }\n    \n\treturn vec3(d,shid,occ);\n}\n\n\n\/\/ The SDF of the landscape is made by combining ground, \n\/\/ bridge, river and trees. \n\/\/\nvec4 map( in vec3 pos, in float time, out float outMat, out vec3 uvw )\n{\n    pos.xz = rot(pos.xz,0.2);\n\n    vec4 res = vec4(pos.y+36.0,0,0,0);    \n    \n    outMat = 1.0;\n    uvw = pos;\n    \n    \/\/-------\n    {\n    vec2 d2 = sdBridge(pos);\n    if( d2.x<res.x )\n    {\n        res.xy = d2;\n        outMat = 2.0;\n    }\n    }\n    \/\/-------\n    float d = sdGround(pos);\n    if( d<res.x )\n    {\n        res.x = d;\n        outMat = 4.0;\n    }\n    \/\/-------\n    float bb = pos.z+450.0;\n    if( bb<d )\n    {\n    vec3 d2 = sdForest(pos,d);\n    if( d2.x<res.x )\n    {\n        res.x = d2.x;\n        res.y = d2.y;\n        res.z = d2.z;\n        outMat = 3.0;\n    }\n    }\n    \n    return res;\n}\n\n\/\/ The landscape SDF again, but with extra high frequency\n\/\/ modeling detail. While the previous one is used for\n\/\/ raymarching and shadowing, this one is used for normal\n\/\/ computation. This separation is conceptually equivalent\n\/\/ to decoupling detail from base geometry with \"normal\n\/\/ maps\", but done in 3D and with SDFs, which is way simpler\n\/\/ and can be done correctly (something rarely seen in 3D\n\/\/ engines) without any complexity.\n\/\/\nfloat mapD( in vec3 pos, in float time )\n{\n    float matID; vec3 kk2;\n    float d = map(pos,time,matID,kk2).x;\n    \n    if( matID<1.5 ) \/\/ water\n    {\n        float g = 0.5 + 0.5*fbm1f(iChannel2,0.02*pos.xz);\n        g = g*g;\n    \tfloat f = 0.5 + 0.5*fbm1f(iChannel2,pos.xz);\n        d -= g*12.0*(0.5+0.5*f*g*2.0);\n    }\n    else if( matID<2.5 ) \/\/ bridge\n    {\n    \td -= 0.07*(0.5+0.5*fbm1(iChannel0, pos*vec3(8,1,8) ));\n    }\n    else if( matID<4.5 ) \/\/ ground\n    {\n    \tfloat dis = fbm1(iChannel0,0.1*pos);\n    \td -= 3.0*dis;\n    }\n    \n    return d;\n}\n\n\/\/ Computes the normal of the girl's surface (the gradient\n\/\/ of the SDF). The implementation is weird because of the\n\/\/ technicalities of the WebGL API that forces us to do\n\/\/ some trick to prevent code unrolling. More info here:\n\/\/\n\/\/ https:\/\/iquilezles.org\/articles\/normalsSDF\n\/\/\nvec3 calcNormal( in vec3 pos, in float time, in float t )\n{\n    float eps = 0.001*t;\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*mapD( pos + e.xyy*eps,time ) + \n\t\t\t\t\t  e.yyx*mapD( pos + e.yyx*eps,time ) + \n\t\t\t\t\t  e.yxy*mapD( pos + e.yxy*eps,time ) + \n\t\t\t\t\t  e.xxx*mapD( pos + e.xxx*eps,time ) );\n#else\n    vec4 n = vec4(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec4 s = vec4(pos, 0.0);\n        s[i] += eps;\n        n[i] = mapD(s.xyz, time);\n        \/\/if( n.x+n.y+n.z+n.w>100.0 ) break;\n    }\n    return normalize(n.xyz-n.w);\n#endif    \n}\n\n\/\/ Compute soft shadows for a given light, with a single ray\n\/\/ insead of using montecarlo integration or shadowmap\n\/\/ blurring. More info here:\n\/\/\n\/\/ https:\/\/iquilezles.org\/articles\/rmshadows\n\/\/\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, in float time, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    \n    \/\/ first things first - let's do a bounding volume test\n    float tm = (480.0-ro.y)\/rd.y; if( tm>0.0 ) tmax=min(tmax,tm);\n    \n    \/\/ raymarch and track penumbra\n    for( int i=ZERO; i<128; i++ )\n    {\n        float kk; vec3 kk2;\n\t\tfloat h = map( ro + rd*t, time, kk, kk2 ).x;\n        res = min( res, k*h\/t );\n        t += clamp( h, 0.05, 25.0 );\n        if( res<0.002 || t>tmax ) break;\n    }\n    return max( res, 0.0 );\n}\n\n\/\/ Computes convexity for our landscape SDF, which can be\n\/\/ used to approximate ambient occlusion. More info here:\n\/\/\n\/\/ https:\/\/iquilezles.org\/www\/material\/nvscene2008\/rwwtt.pdf\n\/\/\nfloat calcOcclusion( in vec3 pos, in vec3 nor, in float time, float sca, in vec2 px )\n{\n    float kk; vec3 kk2;\n\tfloat ao = 0.0;\n    float off = textureLod(iChannel3,px\/256.0,0.0).x;\n    vec4 k = vec4(0.7012912,0.3941462,0.8294585,0.109841)+off;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tk = fract(k + H4);\n        vec3 ap = normalize(-1.0+2.0*k.xyz);\n        float h = k.w*1.0*sca;\n        ap = (nor+ap)*h;\n        float d = map( pos+ap, time, kk, kk2 ).x;\n        ao += max(0.0,h-d);\n        if( ao>10000.0 ) break;\n    }\n\tao \/= 16.0;\n    return clamp( 1.0-ao*2.0\/sca, 0.0, 1.0 );\n}\n\n\/\/ Computes the intersection point between our landscape SDF\n\/\/ and a ray (coming form the camera in this case). It's a\n\/\/ traditional and uncomplicated SDF raymarcher. More info:\n\/\/\n\/\/ https:\/\/iquilezles.org\/www\/material\/nvscene2008\/rwwtt.pdf\n\/\/\nvec2 intersect( in vec3 ro, in vec3 rd, in float time, out vec3 cma, out vec3 uvw )\n{\n    cma = vec3(0.0);\n    uvw = vec3(0.0);\n    float matID = -1.0;\n\n    float tmax = 2500.0;\n    float t = 15.0;\n\t\/\/ bounding volume test first    \n    float tm = (480.0-ro.y)\/rd.y; if( tm>0.0 ) tmax=min(tmax,tm);\n    \n    \/\/ raymarch\n    for( int i=ZERO; i<1024; i++ )\n    {\n        vec3 pos = ro + t*rd;\n\n        float tmp;\n        vec4 h = map(pos,time,tmp,uvw);\n        if( (h.x)<0.0002*t )\n        {\n            cma = h.yzw;\n            matID = tmp;\n            break;\n        }\n        t += h.x*0.8;\n        if( t>tmax ) break;\n    }\n\n    return vec2(t,matID);\n}\n\n\/\/ Renders the landscape. It finds the ray-landscape\n\/\/ intersection point, computes the normal at the\n\/\/ intersection point, computes the ambient occlusion\n\/\/ approximation, does per material setup (color,\n\/\/ specularity, and paints some fake occlusion), and\n\/\/ finally does the lighting computation.\n\/\/\nvec4 renderBackground( in vec2 p, in vec3 ro, in vec3 rd, in float time, in vec2 px )\n{\n    \/\/ sky color\n    vec3 col = vec3(0.45,0.75,1.1) + rd.y*0.5;\n    vec3 fogcol = vec3(0.3,0.5,1.0)*0.25;\n    col = mix( col, fogcol, exp2(-8.0*max(rd.y,0.0)) );\n    \n    \/\/ -------------------------------\n    \/\/ find ray-landscape intersection\n    \/\/ -------------------------------\n    float tmin = 1e20;\n    vec3 cma, uvw;\n    vec2 tm = intersect( ro, rd, time, cma, uvw);\n\n    \/\/ --------------------------\n    \/\/ shading\/lighting\t\n    \/\/ --------------------------\n    if( tm.y>0.0 )\n    {\n        tmin = tm.x;\n        \n        vec3 pos = ro + tmin*rd;\n        vec3 nor = calcNormal(pos, time, tmin);\n\n        col = cma;\n\n        float ks = 1.0;\n        float se = 16.0;\n        float focc = 1.0;\n        float occs = 1.0;\n        float snow = 1.0;\n        \n    \t\/\/ --------------------------\n        \/\/ materials\n    \t\/\/ --------------------------\n\n        \/\/ water\n        if( tm.y<1.5 )\n        {\n            col = vec3(0.1,0.2,0.3);\n            occs = 20.0;\n        }\n        \/\/ bridge\n        else if( tm.y<2.5 )\n        {\n            float f = 0.5 + 0.5*fbm1(iChannel0,pos*vec3(8,1,8));\n            ks = f*8.0;\n            se = 12.0;\n            col = mix(vec3(0.40,0.22,0.15)*0.63,\n                      vec3(0.35,0.07,0.02)*0.2,f);\n            f = fbm1(iChannel0,pos*0.5);\n            col *= 1.0 + 1.1*f*vec3(0.5,1.0,1.5);\n          \tcol *= 1.0 + 0.2*cos(cma.y*23.0+vec3(0,0.2,0.5));\n            \n            float g = 0.5 + 0.5*fbm1(iChannel0,0.21*pos);\n            g -= 0.8*nor.x*nor.x;\n            snow *= smoothstep(0.2,0.6,g);\n        }\n        \/\/ forest\n        else if( tm.y<3.5 )\n        {\n            col = vec3(0.2,0.1,0.02)*0.7;\n            focc = cma.y*(0.7+0.3*nor.y);\n            occs = 100.0;\n        }\n        \/\/ ground\n        else if( tm.y<4.5 )\n        {\n            col = vec3(0.7,0.3,0.1)*0.12;\n            float d = smoothstep(1.0,6.0,pos.y-(-36.0));\n            col *= 0.2+0.8*d;\n            occs = 100.0;\n            snow = 1.0;\n        }\n\n        float fre = clamp(1.0+dot(nor,rd),0.0,1.0);\n        float occ = focc*calcOcclusion( pos, nor, time, occs, px );\n\n        snow *= smoothstep(0.25,0.3,nor.y);\n        if( abs(tm.y-2.0)<0.5 )\n        {\n            snow = max(snow,clamp(1.0-occ*occ*3.5,0.0,1.0));\n            snow = max(snow,cma.x);\n        }\n\n        col = mix( col, vec3(0.7,0.75,0.8)*0.6, snow);\n\t\t\n\t\t\n    \t\/\/ --------------------------\n        \/\/ lighting\n    \t\/\/ --------------------------\n        vec3 lin = vec3(0.0);\n\n        vec3  lig = normalize(vec3(0.5,0.4,0.6));\n        vec3  hal = normalize(lig-rd);\n        float dif = clamp(dot(nor,lig), 0.0, 1.0 );\n        \/\/float sha = 0.0; if( dif>0.001 ) sha=calcSoftshadow( pos, lig, 0.001, 500.0, time, 8.0 );\n        float sha = calcSoftshadow( pos, lig, 0.001, 500.0, time, 8.0 );\n        dif *= sha;\n        float spe = ks*pow(clamp(dot(nor,hal),0.0,1.0),se)*dif*(0.04+0.96*pow(clamp(1.0+dot(hal,rd),0.0,1.0),5.0));\n        vec3  amb = occ*vec3(0.55+0.45*nor.y);\n\n        lin += col*vec3(0.4,0.7,1.1)*amb;\n        lin += col*1.4*vec3(2.3,1.5,1.1)*dif;\n        lin += spe*2.0;\n        lin += snow*vec3(0.21,0.35,0.7)*fre*fre*fre*(0.5+0.5*dif*amb)*focc;\n\n        #if 1\n        if( abs(tm.y-2.0)<0.5 )\n        {\n\t\t\tfloat dif = max(0.2+0.8*dot(nor,vec3(-1,-0.3,0)),0.0);\n\t\t\tlin += col*vec3(0.58,0.29,0.14)*dif;\n        }\n\t\t#endif\n\t\tcol = lin;\n\n        col = mix( col, vec3(0.3,0.5,1.0)*0.25, 1.0-exp2(-0.0003*tmin) );\n    }\n\n    \/\/ sun flow\n    float glow = max(dot(rd,vec3(0.5,0.4,0.2)),0.0);\n    glow *= glow;\n    col += vec3(6.0,4.0,3.6)*glow*glow;\n\n    return vec4(col,tmin);\n}\n    \n\/\/ The main rendering entry point. Basically it does some\n\/\/ setup or creating the ray that will explore the 3D\n\/\/ scene in search of the landscape for each pixel, does\n\/\/ the rendering of the landscape, and performs the\n\/\/ Temporal Antialiasing before spiting out the color (in\n\/\/ linear space, not gama) and the deph of the scene.\n\/\/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ render\n    vec2 o = hash3( uint(iFrame) ).xy - 0.5;\n    vec2 p = (2.0*(fragCoord+o)-iResolution.xy)\/iResolution.y;\n        \n    float time = 2.0 + iTime;\n    \n    \/\/ skip pixels behind girl\n    #if 1\n    if( length((p-vec2(-0.56, 0.2))\/vec2(0.78,1.0))<0.85 ||\n        length((p-vec2(-0.56,-0.4))\/vec2(1.00,1.0))<0.73)\n    {\n        fragColor = vec4( 0.55,0.55,0.65,1e20 ); return;\n    }\n    #endif\n\n    \/\/ camera movement\t\n    vec3 ro; float fl;\n    mat3 ca = calcCamera( time, ro, fl );\n    vec3 rd = ca * normalize( vec3((p-vec2(-0.52,0.12))\/1.1,fl));\n\n    vec4 tmp = renderBackground(p,ro,rd,time,fragCoord);\n    vec3 col = tmp.xyz;\n\n    \/\/---------------------------------------------------------------\n\t\/\/ reproject from previous frame and average (cheap TAA, kind of)\n    \/\/---------------------------------------------------------------\n    \n    mat4 oldCam = mat4( textureLod(iChannel1,vec2(0.5,0.5)\/iResolution.xy, 0.0),\n                        textureLod(iChannel1,vec2(1.5,0.5)\/iResolution.xy, 0.0),\n                        textureLod(iChannel1,vec2(2.5,0.5)\/iResolution.xy, 0.0),\n                        0.0, 0.0, 0.0, 1.0 );\n    bool oldStarted = textureLod(iChannel1,vec2(3.5,0.5)\/iResolution.xy, 0.0).x>0.5;\n    \n    \/\/ world space\n    vec4 wpos = vec4(ro + rd*tmp.w,1.0);\n    \/\/ camera space\n    vec3 cpos = (wpos*oldCam).xyz; \/\/ note inverse multiply\n    \/\/ ndc space\n    vec2 npos = fl * cpos.xy \/ cpos.z;\n    \/\/ undo composition hack\n    npos = npos*1.1+vec2(-0.52,0.12); \n    \/\/ screen space\n    vec2 spos = 0.5 + 0.5*npos*vec2(iResolution.y\/iResolution.x,1.0);\n    \/\/ undo dither\n    spos -= o\/iResolution.xy;\n\t\/\/ raster space\n    vec2 rpos = spos * iResolution.xy;\n    \n    if( rpos.y<1.0 && rpos.x<4.0 )\n    {\n    }\n\telse\n    {\n        vec3 ocol = textureLod( iChannel1, spos, 0.0 ).xyz;\n    \tif( !oldStarted ) ocol = col;\n        col = mix( ocol, col, 0.1 );\n    }\n\n    \/\/----------------------------------\n    bool started = textureSize(iChannel0,0).x>=2 &&\n                   textureSize(iChannel2,0).x>=2 &&\n                   textureSize(iChannel3,0).x>=2;\n                           \n\tif( fragCoord.y<1.0 && fragCoord.x<4.0 )\n    {\n        if( abs(fragCoord.x-3.5)<0.5 ) fragColor = vec4( started?1.0:0.0, 0.0, 0.0, 0.0 );\n        if( abs(fragCoord.x-2.5)<0.5 ) fragColor = vec4( ca[2], -dot(ca[2],ro) );\n        if( abs(fragCoord.x-1.5)<0.5 ) fragColor = vec4( ca[1], -dot(ca[1],ro) );\n        if( abs(fragCoord.x-0.5)<0.5 ) fragColor = vec4( ca[0], -dot(ca[0],ro) );\n    }\n    else\n    {\n        fragColor = vec4( col, tmp.w );\n    }\n    \n    if( !started ) fragColor = vec4(0.0);\n}",
                "name": "Buffer A",
                "description": "",
                "type": "buffer"
            },
            {
                "inputs": [
                    {
                        "id": "4dXGR8",
                        "filepath": "\/media\/previz\/buffer00.png",
                        "previewfilepath": "\/media\/previz\/buffer00.png",
                        "type": "buffer",
                        "channel": 0,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "XsXGR8",
                        "channel": 0
                    }
                ],
                "code": "\/\/ Depth of Field (depth defocus) on the background. It's a basic\n\/\/ gather approach, where each pixel's neighborhood gets scanned\n\/\/ and the Circle of Confusion computed for each one of those\n\/\/ neighbor pixels. If the distance to the pixel is smaller than\n\/\/ the Circle of Confusion, the current pixel gets a contribution\n\/\/ from it with a weight that is inversely proportional to the\n\/\/ area of the Circle of Confusion, to conserve energy.\n\/\/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec4 ref = texelFetch( iChannel0, ivec2(fragCoord),0);\n    \n    vec2 q = fragCoord\/iResolution.xy;\n\n    vec4 acc = vec4(0.0);\n    const int N = 9;\n\tfor( int j=-N; j<=N; j++ )\n    for( int i=-N; i<=N; i++ )\n    {\n        vec2 off = vec2(float(i),float(j));\n        \n        vec4 tmp = texture( iChannel0, q + off\/vec2(1280.0,720.0) ); \n\n        float coc = 0.01 + 9.0*(1.0-1.0\/(1.0+0.01*abs(tmp.w)));\n        \n        if( dot(off,off) < coc*coc )\n        {\n            float w = 1.0\/(coc*coc); \n            acc += vec4(tmp.xyz*w,w);\n        }\n    }\n    vec3 col = acc.xyz \/ acc.w;\n\n    fragColor = vec4(col,ref.w);\n}\n",
                "name": "Buffer B",
                "description": "",
                "type": "buffer"
            }
        ]
    },
    {
        "ver": "0.1",
        "info": {
            "id": "MdlGW7",
            "date": "1372661086",
            "viewed": 85252,
            "name": "Cloudy Terrain",
            "username": "iq",
            "description": "A terrain full of trees or something (up to your interpretation). Distance field raymarching for the terrain. Linearly volumetric raymarching for the foliage. Linearly volumetric raymarching for clouds. Plain plane Raytraced for lakes.",
            "likes": 486,
            "published": 3,
            "flags": 32,
            "usePreview": 0,
            "tags": []
        },
        "renderpass": [
            {
                "inputs": [
                    {
                        "id": "4dXGR8",
                        "filepath": "\/media\/previz\/buffer00.png",
                        "previewfilepath": "\/media\/previz\/buffer00.png",
                        "type": "buffer",
                        "channel": 0,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "4dfGRr",
                        "channel": 0
                    }
                ],
                "code": "\/\/ Copyright Inigo Quilez, 2013 - https:\/\/iquilezles.org\/\n\/\/ I am the sole copyright owner of this Work.\n\/\/ You cannot host, display, distribute or share this Work in any form,\n\/\/ including physical and digital. You cannot use this Work in any\n\/\/ commercial or non-commercial product, website or project. You cannot\n\/\/ sell this Work and you cannot mint an NFTs of it.\n\/\/ I share this Work for educational purposes, and you can link to it,\n\/\/ through an URL, proper attribution and unmodified screenshot, as part\n\/\/ of your educational material. If these conditions are too restrictive\n\/\/ please contact me and we'll definitely work it out.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord\/iResolution.xy;\n    vec4 data = texture( iChannel0, uv );\n\n    vec3 col = vec3(0.0);\n    if( data.w < 0.0 )\n    {\n        col = texture( iChannel0, uv ).xyz;\n    }\n    else\n    {\n        \/\/ decompress velocity vector\n        float ss = mod(data.w,256.0)\/255.0;\n        float st = floor(data.w\/256.0)\/255.0;\n\n        \/\/ motion blur (linear blur across velocity vectors\n        vec2 dir = (-1.0 + 2.0*vec2( ss, st ))*0.25;\n        col = vec3(0.0);\n        for( int i=0; i<32; i++ )\n        {\n            float h = float(i)\/31.0;\n            vec2 pos = uv + dir*h;\n            col += texture( iChannel0, pos ).xyz;\n        }\n        col \/= 32.0;\n    }\n    \n    \/\/ vignetting\t\n\tcol *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 );\n\n    fragColor = vec4( col, 1.0 );\n}",
                "name": "Image",
                "description": "",
                "type": "image"
            },
            {
                "inputs": [
                    {
                        "id": "XdX3Rn",
                        "filepath": "\/media\/a\/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg",
                        "previewfilepath": "\/media\/ap\/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg",
                        "type": "texture",
                        "channel": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "wrap": "repeat",
                            "vflip": "false",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    },
                    {
                        "id": "XdXGzn",
                        "filepath": "\/media\/a\/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png",
                        "previewfilepath": "\/media\/ap\/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png",
                        "type": "texture",
                        "channel": 3,
                        "sampler": {
                            "filter": "mipmap",
                            "wrap": "repeat",
                            "vflip": "false",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    },
                    {
                        "id": "4dXGzn",
                        "filepath": "\/media\/a\/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png",
                        "previewfilepath": "\/media\/ap\/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png",
                        "type": "texture",
                        "channel": 0,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "repeat",
                            "vflip": "false",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    },
                    {
                        "id": "4dXGR8",
                        "filepath": "\/media\/previz\/buffer00.png",
                        "previewfilepath": "\/media\/previz\/buffer00.png",
                        "type": "buffer",
                        "channel": 2,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "4dXGR8",
                        "channel": 0
                    }
                ],
                "code": "\/\/ Created by inigo quilez - iq\/2013\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    float a = textureLod( iChannel0, x.xy\/256.0 + (p.z+0.0)*120.7123, 0.0 ).x;\n    float b = textureLod( iChannel0, x.xy\/256.0 + (p.z+1.0)*120.7123, 0.0 ).x;\n\treturn mix( a, b, f.z );\n}\n\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n\nfloat envelope( vec3 p )\n{\n\tfloat isLake = 1.0-smoothstep( 0.62, 0.72, textureLod( iChannel0, 0.001*p.zx, 0.0).x );\n\treturn 0.1 + isLake*0.9*textureLod( iChannel1, 0.01*p.xz, 0.0 ).x;\n}\n\nfloat mapTerrain( in vec3 pos )\n{\n\treturn pos.y - envelope(pos);\n}\n\nfloat raymarchTerrain( in vec3 ro, in vec3 rd )\n{\n\tfloat maxd = 50.0;\n\tfloat precis = 0.001;\n    float h = 1.0;\n    float t = 0.0;\n    for( int i=0; i<80; i++ )\n    {\n        if( abs(h)<precis||t>maxd ) break;\n        t += h;\n\t    h = mapTerrain( ro+rd*t );\n    }\n\n    if( t>maxd ) t=-1.0;\n    return t;\n}\n\nvec3 lig = normalize( vec3(0.7,0.4,0.2) );\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.02,0.0,0.0);\n\treturn normalize( vec3(\n           mapTerrain(pos+eps.xyy) - mapTerrain(pos-eps.xyy),\n           0.5*2.0*eps.x,\n           mapTerrain(pos+eps.yyx) - mapTerrain(pos-eps.yyx) ) );\n\n}\n\nvec4 mapTrees( in vec3 pos, in vec3 rd )\n{\n    vec3  col = vec3(0.0);\t\n\tfloat den = 1.0;\n\n\tfloat kklake = textureLod( iChannel0, 0.001*pos.zx, 0.0).x;\n\tfloat isLake = smoothstep( 0.7, 0.71, kklake );\n\t\n\tif( pos.y>1.0 || pos.y<0.0 ) \n\t{\n\t\tden = 0.0;\n\t}\n\telse\n\t{\n\t\t\n\t\tfloat h = pos.y;\n\t\tfloat e = envelope( pos );\n\t\tfloat r = clamp(h\/e,0.0,1.0);\n\t\t\n        den = smoothstep( r, 1.0, textureLod(iChannel0, pos.xz*0.15, 0.0).x );\n        \n\t\tden *= 1.0-0.95*clamp( (r-0.75)\/(1.0-0.75) ,0.0,1.0);\n\t\t\n        float id = textureLod( iChannel0, pos.xz, 0.0).x;\n        float oc = pow( r, 2.0 );\n\n\t\tvec3  nor = calcNormal( pos );\n\t\tvec3  dif = vec3(1.0)*clamp( dot( nor, lig ), 0.0, 1.0 );\n\t\tfloat amb = 0.5 + 0.5*nor.y;\n\t\t\n\t\tfloat w = (2.8-pos.y)\/lig.y;\n\t\tfloat c = fbm( (pos+w*lig)*0.35 );\n\t\tc = smoothstep( 0.38, 0.6, c );\n\t\tdif *= pow( vec3(c), vec3(0.8, 1.0, 1.5 ) );\n\t\t\t\n\t\tvec3  brdf = 1.7*vec3(1.5,1.0,0.8)*dif*(0.1+0.9*oc) + 1.3*amb*vec3(0.1,0.15,0.2)*oc;\n\n\t\tvec3 mate = 0.6*vec3(0.5,0.5,0.1);\n\t\tmate += 0.3*textureLod( iChannel1, 0.1*pos.xz, 0.0 ).zyx;\n\t\t\n\t\tcol = brdf * mate;\n\n\t\tden *= 1.0-isLake;\n\t}\n\n\treturn vec4( col, den );\n}\n\n\nvec4 raymarchTrees( in vec3 ro, in vec3 rd, float tmax, vec3 bgcol, out float resT )\n{\n\tvec4 sum = vec4(0.0);\n    float t = tmax;\n\tfor( int i=0; i<512; i++ )\n\t{\n\t\tvec3 pos = ro + t*rd;\n\t\tif( sum.a>0.99 || pos.y<0.0  || t>20.0 ) break;\n\t\t\n\t\tvec4 col = mapTrees( pos, rd );\n\n\t\tcol.xyz = mix( col.xyz, bgcol, 1.0-exp(-0.0018*t*t) );\n        \n\t\tcol.rgb *= col.a;\n\n\t\tsum = sum + col*(1.0 - sum.a);\t\n\t\t\n\t\tt += 0.0035*t;\n\t}\n    \n    resT = t;\n\n\treturn clamp( sum, 0.0, 1.0 );\n}\n\nvec4 mapClouds( in vec3 p )\n{\n\tfloat d = 1.0-0.3*abs(2.8 - p.y);\n\td -= 1.6 * fbm( p*0.35 );\n\n\td = clamp( d, 0.0, 1.0 );\n\t\n\tvec4 res = vec4( d );\n\n\tres.xyz = mix( 0.8*vec3(1.0,0.95,0.8), 0.2*vec3(0.6,0.6,0.6), res.x );\n\tres.xyz *= 0.65;\n\t\n\treturn res;\n}\n\n\nvec4 raymarchClouds( in vec3 ro, in vec3 rd, in vec3 bcol, float tmax, out float rays, ivec2 px )\n{\n\tvec4 sum = vec4(0, 0, 0, 0);\n\trays = 0.0;\n    \n\tfloat sun = clamp( dot(rd,lig), 0.0, 1.0 );\n\tfloat t = 0.1*texelFetch( iChannel0, px&ivec2(255), 0 ).x;\n\tfor(int i=0; i<64; i++)\n\t{\n\t\tif( sum.w>0.99 || t>tmax ) break;\n\t\tvec3 pos = ro + t*rd;\n\t\tvec4 col = mapClouds( pos );\n\n\t\tfloat dt = max(0.1,0.05*t);\n\t\tfloat h = (2.8-pos.y)\/lig.y;\n\t\tfloat c = fbm( (pos + lig*h)*0.35 );\n\t\t\/\/kk += 0.05*dt*(smoothstep( 0.38, 0.6, c ))*(1.0-col.a);\n\t\trays += 0.02*(smoothstep( 0.38, 0.6, c ))*(1.0-col.a)*(1.0-smoothstep(2.75,2.8,pos.y));\n\t\n\t\t\n\t\tcol.xyz *= vec3(0.4,0.52,0.6);\n\t\t\n        col.xyz += vec3(1.0,0.7,0.4)*0.4*pow( sun, 6.0 )*(1.0-col.w);\n\t\t\n\t\tcol.xyz = mix( col.xyz, bcol, 1.0-exp(-0.0018*t*t) );\n\t\t\n\t\tcol.a *= 0.5;\n\t\tcol.rgb *= col.a;\n\n\t\tsum = sum + col*(1.0 - sum.a);\t\n\n\t\tt += dt;\/\/max(0.1,0.05*t);\n\t}\n    rays = clamp( rays, 0.0, 1.0 );\n\n\treturn clamp( sum, 0.0, 1.0 );\n}\n\nvec3 path( float time )\n{\n\treturn vec3( 32.0*cos(0.2+0.75*.1*time*1.5), 1.2, 32.0*sin(0.1+0.75*0.11*time*1.5) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid moveCamera( float time, out vec3 oRo, out vec3 oTa, out float oCr, out float oFl )\n{\n    \/\/ camera\t\n\toRo = path( time );\n\toTa = path( time+1.0 );\n\toTa.y *= 0.2;\n\toCr = 0.3*cos(0.07*time);\n    oFl = 1.75;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy \/ iResolution.xy;\n\tvec2 p = -1.0 + 2.0*q;\n\tp.x *= iResolution.x \/ iResolution.y;\n\t\n\tfloat time = 23.5+iTime;\n\t\n    \/\/ camera\t\n\tvec3 ro, ta;\n    float roll, fl;\n    moveCamera( time, ro, ta, roll, fl );\n        \n\t\/\/ camera tx\n    mat3 cam = setCamera( ro, ta, roll );\n\n    \/\/ ray direction\n    vec3 rd = normalize( cam * vec3(p.xy,fl) );\n\n    \/\/ sky\t \n\tvec3 col = vec3(0.84,0.95,1.0)*0.77 - rd.y*0.6;\n\tcol *= 0.75;\n\tfloat sun = clamp( dot(rd,lig), 0.0, 1.0 );\n    col += vec3(1.0,0.7,0.3)*0.3*pow( sun, 6.0 );\n\tvec3 bcol = col;\n\n    \/\/ lakes\n    float gt = (0.0-ro.y)\/rd.y;\n    if( gt>0.0 )\n    {\n        vec3 pos = ro + rd*gt;\n\n\t\tvec3 nor = vec3(0.0,1.0,0.0);\n\t    nor.xz  = 0.10*(-1.0 + 2.0*texture( iChannel3, 1.5*pos.xz ).xz);\n\t    nor.xz += 0.15*(-1.0 + 2.0*texture( iChannel3, 3.2*pos.xz ).xz);\n\t    nor.xz += 0.20*(-1.0 + 2.0*texture( iChannel3, 6.0*pos.xz ).xz);\n\tnor = normalize(nor);\n\n\t\tvec3 ref = reflect( rd, nor );\n\t    vec3 sref = reflect( rd, vec3(0.0,1.0,0.0) );\n\t\tfloat sunr = clamp( dot(ref,lig), 0.0, 1.0 );\n\n\t    float kklake = texture( iChannel0, 0.001*pos.zx).x;\n\t\tcol = vec3(0.1,0.1,0.0);\n        vec3 lcol = vec3(0.2,0.5,0.7);\n\t\tcol = mix( lcol, 1.1*vec3(0.2,0.6,0.7), 1.0-smoothstep(0.7,0.81,kklake) );\n\t\t\n\t\tcol *= 0.12;\n\n\t    float fre = 1.0 - max(sref.y,0.0);\n\t\tcol += 0.8*vec3(1.0,0.9,0.8)*pow( sunr, 64.0 )*pow(fre,1.0);\n\t\tcol += 0.5*vec3(1.0,0.9,0.8)*pow( fre, 10.0 );\n\n\t\tfloat h = (2.8-pos.y)\/lig.y;\n        float c = fbm( (pos+h*lig)*0.35 );\n\t\tcol *= 0.4 + 0.6*smoothstep( 0.38, 0.6, c );\n\n\t    col *= smoothstep(0.7,0.701,kklake);\n\n\t    col.xyz = mix( col.xyz, bcol, 1.0-exp(-0.0018*gt*gt) );\n    }\n\n\n    \/\/ terrain\t\n\tfloat t = raymarchTerrain(ro, rd);\n    if( t>0.0 )\n\t{\n        \/\/ trees\t\t\n        float ot;\n        vec4 res = raymarchTrees( ro, rd, t, bcol, ot );\n        t = ot;\n\t    col = col*(1.0-res.w) + res.xyz;\n\t}\n\n\t\/\/ sun glow\n    col += vec3(1.0,0.5,0.2)*0.35*pow( sun, 3.0 );\n\n    float rays = 0.0;\n    \/\/ clouds\t\n    {\n\tif( t<0.0 ) t=600.0;\n    vec4 res = raymarchClouds( ro, rd, bcol, t, rays, ivec2(fragCoord) );\n\tcol = col*(1.0-res.w) + res.xyz;\n\t}\n\n\tcol += (1.0-0.8*col)*rays*rays*rays*0.4*vec3(1.0,0.8,0.7);\n\tcol = clamp( col, 0.0, 1.0 );\n\n\t\n    \/\/ gamma\t\n\tcol = pow( col, vec3(0.45) );\n\n    \/\/ contrast, desat, tint and vignetting\t\n\tcol = col*0.1 + 0.9*col*col*(3.0-2.0*col);\n\tcol = mix( col, vec3(col.x+col.y+col.z)*0.33, 0.2 );\n\tcol *= vec3(1.06,1.05,1.0);\n\n    \/\/-------------------------------------\n\t\/\/ velocity vectors (through depth reprojection)\n    \/\/-------------------------------------\n    float vel = 0.0;\n    if( t<0.0 )\n    {\n        vel = -1.0;\n    }\n    else\n    {\n\n        \/\/ old camera position\n        float oldTime = time - 1.0\/30.0; \/\/ 1\/30 of a second blur\n        vec3 oldRo, oldTa; float oldCr, oldFl;\n        moveCamera( oldTime, oldRo, oldTa, oldCr, oldFl );\n        mat3 oldCam = setCamera( oldRo, oldTa, oldCr );\n\n        \/\/ world space\n        vec3 wpos = ro + rd*t;\n        \/\/ camera space\n        vec3 cpos = vec3( dot( wpos - oldRo, oldCam[0] ),\n                          dot( wpos - oldRo, oldCam[1] ),\n                          dot( wpos - oldRo, oldCam[2] ) );\n        \/\/ ndc space\n        vec2 npos = oldFl * cpos.xy \/ cpos.z;\n        \/\/ screen space\n        vec2 spos = 0.5 + 0.5*npos*vec2(iResolution.y\/iResolution.x,1.0);\n\n\n        \/\/ compress velocity vector in a single float\n        vec2 uv = fragCoord\/iResolution.xy;\n        spos = clamp( 0.5 + 0.5*(spos - uv)\/0.25, 0.0, 1.0 );\n        vel = floor(spos.x*255.0) + floor(spos.y*255.0)*256.0;\n    }\n    \n    fragColor = vec4( col, vel );\n}",
                "name": "Buffer A",
                "description": "",
                "type": "buffer"
            }
        ]
    },
    {
        "ver": "0.1",
        "info": {
            "id": "lllBDM",
            "date": "1512136004",
            "viewed": 21656,
            "name": "Goo",
            "username": "noby",
            "description": "A quick one evening doodle with semi-translucent material shading.",
            "likes": 486,
            "published": 1,
            "flags": 32,
            "usePreview": 0,
            "tags": []
        },
        "renderpass": [
            {
                "inputs": [
                    {
                        "id": "XsXGR8",
                        "filepath": "\/media\/previz\/buffer01.png",
                        "previewfilepath": "\/media\/previz\/buffer01.png",
                        "type": "buffer",
                        "channel": 0,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "4dfGRr",
                        "channel": 0
                    }
                ],
                "code": "\/\/ Tone mapping and post processing\nfloat hash(float c){return fract(sin(dot(c,12.9898))*43758.5453);}\n\n\/\/ linear white point\nconst float W = 1.2;\nconst float T2 = 7.5;\n\nfloat filmic_reinhard_curve (float x) {\n    float q = (T2*T2 + 1.0)*x*x;    \n\treturn q \/ (q + x + T2*T2);\n}\n\nvec3 filmic_reinhard(vec3 x) {\n    float w = filmic_reinhard_curve(W);\n    return vec3(\n        filmic_reinhard_curve(x.r),\n        filmic_reinhard_curve(x.g),\n        filmic_reinhard_curve(x.b)) \/ w;\n}\n\nconst int N = 8;\nvec3 ca(sampler2D t, vec2 UV, vec4 sampl){\n\tvec2 uv = 1.0 - 2.0 * UV;\n\tvec3 c = vec3(0);\n\tfloat rf = 1.0;\n\tfloat gf = 1.0;\n    float bf = 1.0;\n\tfloat f = 1.0\/float(N);\n\tfor(int i = 0; i < N; ++i){\n\t\tc.r += f*texture(t, 0.5-0.5*(uv*rf) ).r;\n\t\tc.g += f*texture(t, 0.5-0.5*(uv*gf) ).g;\n\t\tc.b += f*texture(t, 0.5-0.5*(uv*bf) ).b;\n\t\trf *= 0.9972;\n\t\tgf *= 0.998;\n        bf \/= 0.9988;\n\t\tc = clamp(c,0.0, 1.0);\n\t}\n\treturn c;\n}\n\nvoid mainImage(out vec4 fragColor,vec2 fragCoord){\n    const float brightness = 1.0;\n    vec2 pp = fragCoord.xy\/iResolution.xy;\n    vec2 r = iResolution.xy;\n    vec2 p = 1.-2.*fragCoord.xy\/r.xy;\n    p.y *= r.y\/r.x;\n   \n    \/\/ a little chromatic aberration\n    vec4 sampl = texture(iChannel0, pp);\n    vec3 color = ca(iChannel0, pp, sampl).rgb;\n    \n    \/\/ final output\n    float vignette = 1.25 \/ (1.1 + 1.1*dot(p, p));\n    vignette *= vignette;\n    vignette = mix(1.0, smoothstep(0.1, 1.1, vignette), 0.25);\n    float noise = .012*vec3(hash(length(p)*iTime)).x;\n    color = color*vignette+noise;\n    color = filmic_reinhard(brightness*color);\n    \n    color = smoothstep(-0.025, 1.0,color);\n    \n    color = pow(color, vec3(1.0\/2.2));\n    fragColor = vec4(color, 1.0);\n}",
                "name": "Image",
                "description": "",
                "type": "image"
            },
            {
                "inputs": [],
                "outputs": [
                    {
                        "id": "4dXGR8",
                        "channel": 0
                    }
                ],
                "code": "\/\/ MIT License: https:\/\/opensource.org\/licenses\/MIT\nconst float pi = 3.14159;\nmat3 rotate( in vec3 v, in float angle){\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\treturn mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n\t\t(1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n\t\t(1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\n\t\t);\n}\n\nvec3 hash(vec3 p){\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n\/\/ Gradient noise from iq\n\/\/ return value noise (in x) and its derivatives (in yzw)\nvec4 noised(vec3 x){\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n    \n    vec3 ga = hash( p+vec3(0.0,0.0,0.0) );\n    vec3 gb = hash( p+vec3(1.0,0.0,0.0) );\n    vec3 gc = hash( p+vec3(0.0,1.0,0.0) );\n    vec3 gd = hash( p+vec3(1.0,1.0,0.0) );\n    vec3 ge = hash( p+vec3(0.0,0.0,1.0) );\n\tvec3 gf = hash( p+vec3(1.0,0.0,1.0) );\n    vec3 gg = hash( p+vec3(0.0,1.0,1.0) );\n    vec3 gh = hash( p+vec3(1.0,1.0,1.0) );\n    \n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    \/\/ value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   \/\/ derivatives\n                 du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\n}\n\nfloat map(vec3 p){\n    \/\/ ugly hacky slow distance field with bad gradients\n    float d = p.y;\n    float c = max(0.0, pow(distance(p.xz, vec2(0,16)), 1.0));\n    float cc = pow(smoothstep(20.0, 5.0, c), 2.0);\n    \/\/p.xz *= cc;\n    vec4 n = noised(vec3(p.xz*0.07, iTime*0.5));\n    float nn = n.x * (length((n.yzw)));\n    n = noised(vec3(p.xz*0.173, iTime*0.639));\n    nn += 0.25*n.x * (length((n.yzw)));\n    nn = smoothstep(-0.5, 0.5, nn);\n    d = d-6.0*nn*(cc);\n    return d;\n}\n\nfloat err(float dist){\n    dist = dist\/100.0;\n    return min(0.01, dist*dist);\n}\n\nvec3 dr(vec3 origin, vec3 direction, vec3 position){\n    const int iterations = 3;\n    for(int i = 0; i < iterations; i++){\n        position = position + direction * (map(position) - err(distance(origin, position)));\n    }\n    return position;\n}\n\nvec3 intersect(vec3 ro, vec3 rd){\n\tvec3 p = ro+rd;\n\tfloat t = 0.;\n\tfor(int i = 0; i < 150; i++){\n        float d = 0.5*map(p);\n        t += d;\n        p += rd*d;\n\t\tif(d < 0.01 || t > 60.0) break;\n\t}\n    \n    \/\/ discontinuity reduction as described (somewhat) in\n    \/\/ their 2014 sphere tracing paper\n    p = dr(ro, rd, p);\n    return p;\n}\n\nvec3 normal(vec3 p){\n\tfloat e=0.01;\n\treturn normalize(vec3(map(p+vec3(e,0,0))-map(p-vec3(e,0,0)),\n\t                      map(p+vec3(0,e,0))-map(p-vec3(0,e,0)),\n\t                      map(p+vec3(0,0,e))-map(p-vec3(0,0,e))));\n}\n\nfloat G1V(float dnv, float k){\n    return 1.0\/(dnv*(1.0-k)+k);\n}\n\nfloat ggx(vec3 n, vec3 v, vec3 l, float rough, float f0){\n    float alpha = rough*rough;\n    vec3 h = normalize(v+l);\n    float dnl = clamp(dot(n,l), 0.0, 1.0);\n    float dnv = clamp(dot(n,v), 0.0, 1.0);\n    float dnh = clamp(dot(n,h), 0.0, 1.0);\n    float dlh = clamp(dot(l,h), 0.0, 1.0);\n    float f, d, vis;\n    float asqr = alpha*alpha;\n    const float pi = 3.14159;\n    float den = dnh*dnh*(asqr-1.0)+1.0;\n    d = asqr\/(pi * den * den);\n    dlh = pow(1.0-dlh, 5.0);\n    f = f0 + (1.0-f0)*dlh;\n    float k = alpha\/1.0;\n    vis = G1V(dnl, k)*G1V(dnv, k);\n    float spec = dnl * d * f * vis;\n    return spec;\n}\n\nfloat subsurface(vec3 p, vec3 v, vec3 n){\n    \/\/vec3 d = normalize(mix(v, -n, 0.5));\n    \/\/ suggested by Shane\n    vec3 d = refract(v, n, 1.0\/1.5);\n    vec3 o = p;\n    float a = 0.0;\n    \n    const float max_scatter = 2.5;\n    for(float i = 0.1; i < max_scatter; i += 0.2)\n    {\n        o += i*d;\n        float t = map(o);\n        a += t;\n    }\n    float thickness = max(0.0, -a);\n    const float scatter_strength = 16.0;\n\treturn scatter_strength*pow(max_scatter*0.5, 3.0)\/thickness;\n}\n\nvec3 shade(vec3 p, vec3 v){\n    vec3 lp = vec3(50,20,10);\n    vec3 ld = normalize(p+lp);\n    \n    vec3 n = normal(p);\n    float fresnel = pow( max(0.0, 1.0+dot(n, v)), 5.0 );\n    \n    vec3 final = vec3(0);\n    vec3 ambient = vec3(0.1, 0.06, 0.035);\n    vec3 albedo = vec3(0.75, 0.9, 0.35);\n    vec3 sky = vec3(0.5,0.65,0.8)*2.0;\n    \n    float lamb = max(0.0, dot(n, ld));\n    float spec = ggx(n, v, ld, 3.0, fresnel);\n    float ss = max(0.0, subsurface(p, v, n));\n    \n    \/\/ artistic license\n    lamb = mix(lamb, 3.5*smoothstep(0.0, 2.0, pow(ss, 0.6)), 0.7);\n    final = ambient + albedo*lamb+ 25.0*spec + fresnel*sky;\n    return vec3(final*0.5);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord \/ iResolution.xy;\n    vec3 a = vec3(0);\n    \n    \/\/ leftover stuff from something else, too lazy to remove\n    \/\/ don't ask\n    const float campos = 5.1;\n    float lerp = 0.5+0.5*cos(campos*0.4-pi);\n    lerp = smoothstep(0.13, 1.0, lerp);\n    vec3 c = mix(vec3(-0,217,0), vec3(0,4.4,-190), pow(lerp,1.0));\n    mat3 rot = rotate(vec3(1,0,0), pi\/2.0);\n    mat3 ro2 = rotate(vec3(1,0,0), -0.008*pi\/2.0);\n    \n    vec2 u2 = -1.0+2.0*uv;\n    u2.x *= iResolution.x\/iResolution.y;\n\n    vec3 d = mix(normalize(vec3(u2, 20)*rot), normalize(vec3(u2, 20))*ro2, pow(lerp,1.11));\n    d = normalize(d);\n\n    vec3 ii = intersect(c+145.0*d, d);\n    vec3 ss = shade(ii, d);\n    a += ss;\n    \n    fragColor.rgb = a*(0.99+0.02*hash(vec3(uv,0.001*iTime)));\n}",
                "name": "Buf A",
                "description": "",
                "type": "buffer"
            },
            {
                "inputs": [
                    {
                        "id": "4dXGR8",
                        "filepath": "\/media\/previz\/buffer00.png",
                        "previewfilepath": "\/media\/previz\/buffer00.png",
                        "type": "buffer",
                        "channel": 0,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "XsXGR8",
                        "channel": 0
                    }
                ],
                "code": "\/\/ FXAA implementation by mudlord (I think?)\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n    vec2 p = fragCoord.xy\/iResolution.xy;\n    vec2 pp = 1.0 \/ iResolution.xy;\n    vec4 color = texture(iChannel0, vec2(fragCoord.xy * pp));\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(texture(iChannel0, (fragCoord.xy + vec2(-1.0, -1.0)) * pp).xyz, luma);\n    float lumaNE = dot(texture(iChannel0, (fragCoord.xy + vec2(1.0, -1.0)) * pp).xyz, luma);\n    float lumaSW = dot(texture(iChannel0, (fragCoord.xy + vec2(-1.0, 1.0)) * pp).xyz, luma);\n    float lumaSE = dot(texture(iChannel0, (fragCoord.xy + vec2(1.0, 1.0)) * pp).xyz, luma);\n    float lumaM  = dot(color.xyz,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir = vec2(-((lumaNW + lumaNE) - (lumaSW + lumaSE)), ((lumaNW + lumaSW) - (lumaNE + lumaSE)));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * (1.0\/8.0)), (1.0\/128.0));\n\n    float rcpDirMin = 2.5 \/ (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(8.0, 8.0),\n              max(vec2(-8.0, -8.0),\n              dir * rcpDirMin)) * pp;\n\n    vec3 rgbA = 0.5 * (\n        texture(iChannel0, fragCoord.xy * pp + dir * (1.0 \/ 3.0 - 0.5)).xyz +\n        texture(iChannel0, fragCoord.xy * pp + dir * (2.0 \/ 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n        texture(iChannel0, fragCoord.xy * pp + dir * -0.5).xyz +\n        texture(iChannel0, fragCoord.xy * pp + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax)){\n        fragColor = vec4(rgbA, color.w);\n    } else {\n        fragColor = vec4(rgbB, color.w);\n    }\n\n}",
                "name": "Buf B",
                "description": "",
                "type": "buffer"
            }
        ]
    },
    {
        "ver": "0.1",
        "info": {
            "id": "4dSfRc",
            "date": "1501424188",
            "viewed": 27004,
            "name": "[SH17C] Raymarching tutorial",
            "username": "reinder",
            "description": "The shader used as example in this tutorial can be found [url=https:\/\/www.shadertoy.com\/view\/4dSBz3]here[\/url].\n\nYou can navigate the slides using your arrow keys.",
            "likes": 333,
            "published": 3,
            "flags": 48,
            "usePreview": 1,
            "tags": []
        },
        "renderpass": [
            {
                "inputs": [
                    {
                        "id": "4dXGR8",
                        "filepath": "\/media\/previz\/buffer00.png",
                        "previewfilepath": "\/media\/previz\/buffer00.png",
                        "type": "buffer",
                        "channel": 0,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    },
                    {
                        "id": "XsXGR8",
                        "filepath": "\/media\/previz\/buffer01.png",
                        "previewfilepath": "\/media\/previz\/buffer01.png",
                        "type": "buffer",
                        "channel": 1,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    },
                    {
                        "id": "4sXGR8",
                        "filepath": "\/media\/previz\/buffer02.png",
                        "previewfilepath": "\/media\/previz\/buffer02.png",
                        "type": "buffer",
                        "channel": 2,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    },
                    {
                        "id": "XdfGR8",
                        "filepath": "\/media\/previz\/buffer03.png",
                        "previewfilepath": "\/media\/previz\/buffer03.png",
                        "type": "buffer",
                        "channel": 3,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "4dfGRr",
                        "channel": 0
                    }
                ],
                "code": "\/\/ [SH17C] Raymarching tutorial. Created by Reinder Nijhoff 2017\n\/\/ Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n\/\/ @reindernijhoff\n\/\/ \n\/\/ https:\/\/www.shadertoy.com\/view\/4dSfRc\n\/\/\n\/\/ In this tutorial you will learn how to render a 3d-scene in Shadertoy\n\/\/ using distance fields.\n\/\/\n\/\/ The tutorial itself is created in Shadertoy, and is rendered\n\/\/ using ray marching a distance field.\n\/\/\n\/\/ The shader studied in the tutorial can be found here: \n\/\/     https:\/\/www.shadertoy.com\/view\/4dSBz3\n\/\/\n\/\/ Created for the Shadertoy Competition 2017 \n\/\/\n\/\/ Most of the render code is taken from: 'Raymarching - Primitives' by Inigo Quilez.\n\/\/\n\/\/ You can find this shader here:\n\/\/     https:\/\/www.shadertoy.com\/view\/Xds3zN\n\/\/\n\n\/\/ COMPOSITE IMAGE\n\n#define SLIDE_FADE_STEPS 60\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    int SLIDE_STEPS_VISIBLE = int(texelFetch( iChannel0, ivec2(0,0), 0 ).y);\n    \n    vec4 current = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    vec4 prev    = texelFetch(iChannel2, ivec2(fragCoord), 0);\n    vec4 font    = texelFetch(iChannel3, ivec2(fragCoord), 0);\n\n\tfragColor = mix( prev, current, clamp( float(SLIDE_STEPS_VISIBLE)\/float(SLIDE_FADE_STEPS), 0., 1.) );\n    fragColor = mix( fragColor * .75, font, font.a );\n}",
                "name": "Image",
                "description": "",
                "type": "image"
            },
            {
                "inputs": [
                    {
                        "id": "4dXGRr",
                        "filepath": "\/presets\/tex00.jpg",
                        "previewfilepath": "\/presets\/tex00.jpg",
                        "type": "keyboard",
                        "channel": 1,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    },
                    {
                        "id": "4dXGzr",
                        "filepath": "\/media\/a\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png",
                        "previewfilepath": "\/media\/ap\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png",
                        "type": "texture",
                        "channel": 2,
                        "sampler": {
                            "filter": "mipmap",
                            "wrap": "repeat",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    },
                    {
                        "id": "4dXGR8",
                        "filepath": "\/media\/previz\/buffer00.png",
                        "previewfilepath": "\/media\/previz\/buffer00.png",
                        "type": "buffer",
                        "channel": 0,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "4dXGR8",
                        "channel": 0
                    }
                ],
                "code": "\/\/ [SH17C] Raymarching tutorial. Created by Reinder Nijhoff 2017\n\/\/ @reindernijhoff\n\/\/ \n\/\/ https:\/\/www.shadertoy.com\/view\/4dSfRc\n\/\/\n\/\/ In this tutorial you will learn how to render a 3d-scene in Shadertoy\n\/\/ using distance fields.\n\/\/\n\/\/ The tutorial itself is created in Shadertoy, and is rendered\n\/\/ using ray marching a distance field.\n\/\/\n\/\/ The shader studied in the tutorial can be found here: \n\/\/     https:\/\/www.shadertoy.com\/view\/4dSBz3\n\/\/\n\/\/ Created for the Shadertoy Competition 2017 \n\/\/\n\/\/ Most of the render code is taken from: 'Raymarching - Primitives' by Inigo Quilez.\n\/\/\n\/\/ You can find this shader here:\n\/\/     https:\/\/www.shadertoy.com\/view\/Xds3zN\n\/\/\n\n\/\/ SLIDE NAVIGATION FUNCTIONS\n\n\/\/ Load & store functions\n\n#define SLIDE_FADE_STEPS 45\n\n#define TITLE_DELAY   45\n#define BODY_DELAY   90\n#define CODE_DELAY   135\n#define FOOTER_DELAY 180\n\n#define NUM_SLIDES 25\n\nint SLIDE = 0;\nint SLIDE_STEPS_VISIBLE = 0;\n\nivec4 LoadVec4( in ivec2 vAddr ) {\n    return ivec4( texelFetch( iChannel0, vAddr, 0 ) );\n}\n\nbool AtAddress( ivec2 p, ivec2 c ) { return all( equal( floor(vec2(p)), vec2(c) ) ); }\n\nvoid StoreVec4( in ivec2 vAddr, in ivec4 vValue, inout vec4 fragColor, in ivec2 fragCoord ) {\n    fragColor = AtAddress( fragCoord, vAddr ) ? vec4(vValue) : fragColor;\n}\n\nvec4 LoadFVec4( in ivec2 vAddr ) {\n    return texelFetch( iChannel0, vAddr, 0 );\n}\n\nvoid StoreFVec4( in ivec2 vAddr, in vec4 vValue, inout vec4 fragColor, in ivec2 fragCoord ) {\n    fragColor = AtAddress( fragCoord, vAddr ) ? vValue : fragColor;\n}\n\n\/\/ key functions\n\n\/\/ Keyboard constants definition\nconst int KEY_SPACE = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_D     = 68;\nconst int KEY_S     = 83;\nconst int KEY_W     = 87;\n\n\nbool KP(int key) {\n\treturn texelFetch( iChannel1, ivec2(key, 0), 0 ).x > 0.0;\n}\n\nbool KT(int key) {\n\treturn texelFetch( iChannel1, ivec2(key, 2), 0 ).x > 0.0;\n}\n\n\/\/ slide logic\n\nstruct SlideDataStruct {\n    int title;\n    int titleDelay;\n    int body;\n    int bodyDelay;\n    int code;\n    int codeDelay;\n    vec3 ro;\n    vec3 ta;\n    int sceneMode;\n    int codeS;\n    int codeE;\n    int distMode;\n};\n\nSlideDataStruct temp;\nint tempCounter;\n\nbool createSlideData( \n    const int title,\n    const int titleDelay,\n    const int body,\n    const int bodyDelay,\n    const int code,\n    const int codeDelay,\n    const vec3 ro,\n    const vec3 ta,\n    const int sceneMode,\n    const int codeS,\n    const int codeE,\n\tconst int distMode ) {\n        \n    if(tempCounter == SLIDE) {\n        temp.title = title;\n  \t  \ttemp.titleDelay = titleDelay;\n   \t \ttemp.body = body;\n   \t \ttemp.bodyDelay =bodyDelay;\n   \t \ttemp.code = code;\n   \t\ttemp.codeDelay =codeDelay;\n   \t\ttemp.ro = ro;\n   \t\ttemp.ta = ta;\n   \t \ttemp.sceneMode = sceneMode;\n  \t \ttemp.codeS = codeS;\n  \t  \ttemp.codeE = codeE;\n\t\ttemp.distMode = distMode;\n        return true;\n    } else {\n    \ttempCounter++;\n        return false;\n    }\n}\n\nSlideDataStruct getSlideData() {\n    tempCounter = 0;\n    \n    \/\/ intro\n   if( createSlideData(1,TITLE_DELAY,1,BODY_DELAY,0,0, vec3(.0,0.,1.),vec3(0.,0.,-.5), 0, 0, 0, 0) ) return temp;\n\n    \/\/ intro - show bw scene\n   if( createSlideData(1,0,2,0,0,0, vec3(.0,0.,1.), vec3(0.,0.,-5.), -1, 0, 0, 0)) return temp;\n    \n    \/\/ create a ray - origin\n   if( createSlideData(2,TITLE_DELAY,3,BODY_DELAY,0,0, vec3(2.,1.,2.),vec3(0.,0.2,-1.3), 1, 0, 0, 0)) return temp;\n        \n    \/\/ create a ray - origin \/ code    \n   if( createSlideData(2,0,4,0,1,TITLE_DELAY, vec3(2.,1.,2.),vec3(0.,0.2,-1.3), 1, 1, 3, 0)) return temp;\n    \n    \/\/ place screen\n   if( createSlideData(2,0,5,TITLE_DELAY,0,0, vec3(2.,1.,2.),vec3(0.,0.2,-1.3), 2, 0, 0, 0)) return temp;\n    \n    \/\/ create rd\n   if( createSlideData(2,0,6,TITLE_DELAY,0,0, vec3(2.5,3.,2.5),vec3(0.,0.2,-1.3), 3, 0, 0, 0)) return temp;\n\n\t\/\/ create rd \/ code\n   if( createSlideData(2,0,7,0,1,TITLE_DELAY, vec3(2.5,3.,2.5),vec3(0.,0.2,-1.3), 3, 3, 0, 0)) return temp;\n   \n    \/\/ interact with scene\n   if( createSlideData(2,0,8,0,0,0, vec3(2.5,3.,2.5),vec3(0.,0.2,-1.3), 3, 3, 0, 0)) return temp;\n    \n    \/\/ distance fields intro\n   if( createSlideData(3,TITLE_DELAY,9,BODY_DELAY,0,0, vec3(1.,6.,2.),vec3(0.,0.2,-1.3), 3, 0, 0, 0)) return temp;\n    \n    \/\/ distance fields def\n   if( createSlideData(3,0,10,TITLE_DELAY,0,0, vec3(1.,6.,2.),vec3(0.,0.2,-1.3), 3, 0, 0, 0)) return temp;\n        \n    \/\/ distance fields one sphere\n   if( createSlideData(3,TITLE_DELAY,11,BODY_DELAY,0,0, vec3(1.,6.,-2.),vec3(-1.,-0.5,-2.), 4, 0, 0, 0)) return temp;\n    \n     \/\/ distance fields one sphere\n   if( createSlideData(3,0,11,0,0,0, vec3(1.,6.,-2.),vec3(-1.,-0.5,-2.), 4, 0, 0, 1)) return temp;\n      \n    \/\/ distance fields one sphere - code\n   if( createSlideData(3,0,12,0,2,TITLE_DELAY, vec3(1.,6.,-2.),vec3(-1.,-0.5,-2.), 4, 0, 3, 1)) return temp;\n    \n    \/\/ distance fields one three spheres\n   if( createSlideData(3,0,13,TITLE_DELAY,0,0, vec3(1.,6.,-2.),vec3(-1.,-0.5,-2.), 2, 0, 5, 2)) return temp;\n    \n    \/\/ distance fields one three spheres - in code\n   if( createSlideData(3,0,14,0,2,TITLE_DELAY, vec3(1.,6.,-2.),vec3(-1.,-0.5,-2.), 2, 0, 5, 2)) return temp;\n    \n    \/\/ distance fields one three spheres - full code\n   if( createSlideData(3,0,15,TITLE_DELAY,2,BODY_DELAY, vec3(1.,6.,-2.),vec3(-1.,-0.5,-2.), 2, 0, 0, 3)) return temp;\n        \n    \/\/ distance fields one three spheres - march\n   if( createSlideData(3,0,16,TITLE_DELAY,0,0, vec3(2.5,3.,1.5),vec3(0.,0.2,-1.3), 5, 0, 0, 4)) return temp;\n    \n    \/\/ distance fields one three spheres - march code\n   if( createSlideData(3,0,17,0,3,TITLE_DELAY, vec3(2.5,3.,1.5),vec3(0.,0.2,-1.3), 5, 0, 0, 4)) return temp;\n        \n    \/\/ distance fields one three spheres - interact\n   if( createSlideData(3,0,8,TITLE_DELAY,0,0, vec3(.5,2.,2.5),vec3(0.,0.2,-.3), 5, 0, 0, 4)) return temp;\n\n    \/\/ lighting - normal intro\n   if( createSlideData(4,TITLE_DELAY,18,BODY_DELAY,0,0, vec3(2.5,3.,1.5),vec3(0.,0.2,-1.3), 6, 0, 0, 0)) return temp;\n\n   \/\/ lighting - normal full\n   if( createSlideData(4,0,19,TITLE_DELAY,4,BODY_DELAY, vec3(4.5,3.,-1.5),vec3(0.,0.2,-1.3), 6, 0, 0, 0)) return temp;\n\n   \/\/ lighting - interact\n   if( createSlideData(4,0,8,TITLE_DELAY,0,0, vec3(4.5,3.,-1.5),vec3(0.,0.2,-1.3), 6, 0, 0, 0)) return temp;\n\n   \/\/ lighting - diffuse\n   if( createSlideData(4,0,20,TITLE_DELAY,0,0, vec3(.0,0.,1.),vec3(0.,0.,-.5), 0, 0, 0, 0)) return temp;\n\n   \/\/ lighting - diffuse\n   if( createSlideData(4,0,21,0,5,TITLE_DELAY, vec3(.0,0.,1.),vec3(0.,0.,-.5), -1, 0, 0, 0)) return temp;\n \n   \/\/ done\n   if( createSlideData(1,TITLE_DELAY,22,BODY_DELAY,0,0, vec3(.0,0.,1.),vec3(0.,0.,-.5), -1, 0, 0, 0)) return temp;\n \n    \n    return temp;\n}\n    \nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nfloat sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph ) {\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return 10000.0;\n\treturn -b - sqrt( h );\n}\n\nfloat iPlane(in vec3 ro, in vec3 rd, in float d) {\n\t\/\/ equation of a plane, y=0 = ro.y + t*rd.y\n    return -(ro.y+d)\/rd.y;\n}\n\nvec3 intersectScene( vec3 ro, vec3 ta, vec2 p,  bool intersectPlane ) {    \n    mat3 ca = setCamera( ro, ta, 0.0 );\n    vec3 rd = ca * normalize( vec3(p.xy,1.0) );\n    \n    float d = 1000.;\n    \/\/ sphere intersections ..\n    if( intersectPlane ) {\n\t    if( rd.y < 0. ) d = min(d, iPlane(ro, rd, 0.));\n    } else {\n    \td = min( d, sphIntersect( ro, rd, vec4(-1,0,-5,1) ));\n   \t\td = min( d, sphIntersect( ro, rd, vec4(2,0,-3,1) ));\n  \t  \td = min( d, sphIntersect( ro, rd, vec4(-2,0,-2,1) ));\n\n\t    if( rd.y < 0. ) d = min(d, iPlane(ro, rd, 1.));\n    }\n    \n    if( d < 100. ) {\n        return ro + d*rd;\n    } else {\n        return vec3(-1,0,-4);\n    }\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tivec2 uv = ivec2(fragCoord.xy);\n    \n    \/\/ wait for font-texture to load\n    if( iFrame == 0 || texelFetch(iChannel2, ivec2(0,0), 0).b < .1) {\n        vec4 ro = vec4(0,0,1,0);\n\t\tvec4 ta = vec4(0);\n        \n\t\tStoreFVec4( ivec2(0,3), ro, fragColor, uv);\n\t\tStoreFVec4( ivec2(0,4), ta, fragColor, uv);\n    } else if( uv.x < 2 && uv.y < 6) {\n        ivec4 slideData = LoadVec4( ivec2(0,0) );\n        SLIDE = slideData.x;\n        SLIDE_STEPS_VISIBLE = slideData.y;\n        SLIDE_STEPS_VISIBLE++;\n\n        if( SLIDE_STEPS_VISIBLE > 16 ) {\n            if( KP(KEY_SPACE) || KP(KEY_RIGHT) || KP(KEY_D) ) {\n                SLIDE++;\n                SLIDE_STEPS_VISIBLE=0;\n            }\n            if( KP(KEY_LEFT) || KP(KEY_W) ) {\n                SLIDE = (SLIDE + NUM_SLIDES - 1);\n                SLIDE_STEPS_VISIBLE=0;\n            }\n            \n            SLIDE = SLIDE % NUM_SLIDES; \n        }\n        \n        SlideDataStruct slide = getSlideData();\n        \n        \/\/ screen resolution\n        ivec4 res = LoadVec4( ivec2(1,0) );\n        if( res.x != int(iResolution.x) || res.y != int(iResolution.y) ) {\n            SLIDE_STEPS_VISIBLE = 0;\n        }\n        StoreVec4( ivec2(1,0), ivec4(iResolution.xy, 0,0), fragColor, uv );\n        \n\t\t\/\/ slide navigation               \n\t\tStoreVec4( ivec2(0,0), ivec4(SLIDE, SLIDE_STEPS_VISIBLE, slide.sceneMode, slide.distMode), fragColor, uv);\n        \n        \/\/ text \n        ivec4 showText1 = ivec4(0);\n        ivec4 showText2 = ivec4(0);\n        \n        if( SLIDE_STEPS_VISIBLE == 0) showText1.x = 1;\n        \n        if( slide.titleDelay == SLIDE_STEPS_VISIBLE) showText2.x = slide.title;\n        if( slide.bodyDelay == SLIDE_STEPS_VISIBLE) showText2.y = slide.body;\n        if( slide.codeDelay == SLIDE_STEPS_VISIBLE) showText2.z = slide.code;\n\n        showText1.y = slide.codeS;\n        showText1.z = slide.codeE;\n        \n\t\tStoreVec4( ivec2(0,1), showText1, fragColor, uv);\n\t\tStoreVec4( ivec2(0,2), showText2, fragColor, uv);\n        \n        \/\/ camera\n        \n        vec4 ro = LoadFVec4( ivec2(0,3) );\n        vec4 ta = LoadFVec4( ivec2(0,4) );\n        \n\t\tif(SLIDE_STEPS_VISIBLE > SLIDE_FADE_STEPS) {\n            ro.xyz = mix( ro.xyz, slide.ro, 0.055 );\n            ta.xyz = mix( ta.xyz, slide.ta, 0.055 );\n        }\n        \n\t\tStoreFVec4( ivec2(0,3), ro, fragColor, uv);\n\t\tStoreFVec4( ivec2(0,4), ta, fragColor, uv);\n                \n        if(iMouse.z > 0.) {\n            vec2 q = (iMouse.xy - .5 * iResolution.xy ) \/ iResolution.y;\n\t\t\tStoreFVec4( ivec2(0,5), vec4(intersectScene(ro.xyz, ta.xyz, q, slide.sceneMode == 5),1), fragColor, uv);\n        } else {\n\t\t\tStoreFVec4( ivec2(0,5), vec4(intersectScene(vec3(0,0,1), vec3(1,0,0), vec2(0), slide.sceneMode == 5),1), fragColor, uv);\n        }\n    } else {  \n\t    fragColor = vec4(0);\n    }\n}",
                "name": "Buffer A",
                "description": "",
                "type": "buffer"
            },
            {
                "inputs": [
                    {
                        "id": "4dXGR8",
                        "filepath": "\/media\/previz\/buffer00.png",
                        "previewfilepath": "\/media\/previz\/buffer00.png",
                        "type": "buffer",
                        "channel": 0,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "XsXGR8",
                        "channel": 0
                    }
                ],
                "code": "\/\/ [SH17C] Raymarching tutorial. Created by Reinder Nijhoff 2017\n\/\/ @reindernijhoff\n\/\/ \n\/\/ https:\/\/www.shadertoy.com\/view\/4dSfRc\n\/\/\n\/\/ In this tutorial you will learn how to render a 3d-scene in Shadertoy\n\/\/ using distance fields.\n\/\/\n\/\/ The tutorial itself is created in Shadertoy, and is rendered\n\/\/ using ray marching a distance field.\n\/\/\n\/\/ The shader studied in the tutorial can be found here: \n\/\/     https:\/\/www.shadertoy.com\/view\/4dSBz3\n\/\/\n\/\/ Created for the Shadertoy Competition 2017 \n\/\/\n\/\/ Most of the render code is taken from: 'Raymarching - Primitives' by Inigo Quilez.\n\/\/\n\/\/ You can find this shader here:\n\/\/     https:\/\/www.shadertoy.com\/view\/Xds3zN\n\/\/\n\n\/\/ RENDER SCENE\n\n\n\/\/ Load & store functions\n\n#define SLIDE_FADE_STEPS 60\n\nint SLIDE = 0;\nint SLIDE_STEPS_VISIBLE = 0;\nint SCENE_MODE = 0;\nint DIST_MODE = 0;\nint MAX_MARCH_STEPS;\n\nvec3 intersections[7];\nvec3 intersectionNormal;\n\nfloat aspect;\nvec3 USER_INTERSECT;\n\nivec4 LoadVec4( in ivec2 vAddr ) {\n    return ivec4( texelFetch( iChannel0, vAddr, 0 ) );\n}\n\nvec4 LoadFVec4( in ivec2 vAddr ) {\n    return texelFetch( iChannel0, vAddr, 0 );\n}\n\nbool AtAddress( ivec2 p, ivec2 c ) { return all( equal( floor(vec2(p)), vec2(c) ) ); }\n\nvoid StoreVec4( in ivec2 vAddr, in ivec4 vValue, inout vec4 fragColor, in ivec2 fragCoord ) {\n    fragColor = AtAddress( fragCoord, vAddr ) ? vec4(vValue) : fragColor;\n}\n\nvoid loadData() {\n    ivec4 slideData = LoadVec4( ivec2(0,0) );\n    SLIDE = slideData.x;\n    SLIDE_STEPS_VISIBLE = slideData.y;\n    SCENE_MODE = slideData.z;\n\tDIST_MODE = slideData.w;\n}\n\n\n\/\/ tutorial Scene\nfloat tut_map(vec3 p) {\n    float d = distance(p, vec3(-1, 0, -5)) - 1.;\n    d = min(d, distance(p, vec3(2, 0, -3)) - 1.);\n    d = min(d, distance(p, vec3(-2, 0, -2)) - 1.);\n    d = min(d, p.y + 1.);\n    return d;\n}\n\nvec3 tut_calcNormal(in vec3 pos) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\n    return normalize(\n        e.xyy * tut_map(pos + e.xyy) +\n        e.yyx * tut_map(pos + e.yyx) +\n        e.yxy * tut_map(pos + e.yxy) +\n        e.xxx * tut_map(pos + e.xxx));\n}\n\nvec4 tut_render(in vec2 uv, const int steps) {\n    vec3 ro = vec3(0, 0, 1);\n    vec3 rd = normalize(vec3(uv, 0.) - ro);\n\n    float h, t = 1.;\n    for (int i = 0; i < steps; i++) {\n        h = tut_map((ro + rd * t));\n        t += h;\n        if (h < 0.01) break;\n    }\n\n    if (h < 0.01) {\n        vec3 p = ro + rd * t;\n        vec3 normal = tut_calcNormal(p);\n        vec3 light = vec3(0, 2, 0);\n\n        float dif = clamp(dot(normal, normalize(light - p)), 0., 1.);\n        dif *= 5. \/ dot(light - p, light - p);\n        return vec4(pow(vec3(dif), vec3(1. \/ 2.2)), 1);\n    } else {\n        return vec4(0, 0, 0, 1);\n    }\n}\n\n\/\/\n\/\/ render full scene\n\/\/\n\/\/ Most of this is taken from: 'Raymarching - Primitives' by Inigo Quilez.\n\/\/\n\/\/ You can find this shader here:\n\/\/     https:\/\/www.shadertoy.com\/view\/Xds3zN\n\/\/\n\n\/\/------------------------------------------------------------------\n\nfloat sdPlane( vec3 p, float d ) {\n\treturn p.y - d;\n}\n\nfloat sdSphere( vec3 p, float s ) {\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n\/\/------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 ) {\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n\/\/------------------------------------------------------------------\n\nvec2 map_0( in vec3 pos ) { \/\/ basic scene\n    vec2 res = opU( vec2( sdPlane(     pos, -1.), 1.0 ),\n\t                vec2( sdSphere(    pos-vec3(-1,0,-5),1.), 50. ) );\n    res = opU( res, vec2( sdSphere(    pos-vec3(2,0,-3),1.), 65. ) );\n    res = opU( res, vec2( sdSphere(    pos-vec3(-2,0,-2),1.),41. ) );\n        \n    return res;\n}\n\nvec2 map_1( in vec3 pos ) { \/\/ scene + ro\n    vec2 res = map_0(pos);\n    res = opU( res, vec2( sdSphere(    pos-vec3(0,0,1),.1),2. ) );\n    return res;\n}\n\nvec2 map_2( in vec3 pos ) { \/\/ scene + ro + screen\n    vec2 res = map_0(pos);\n            \n    res = opU( res, vec2( sdSphere(    pos-vec3(0,0,1),.1),3. ) );\n    res = opU( res, vec2( sdBox( pos,  vec3(.5*aspect, .5,.025)), 4.));\n    return res;\n}\n\nvec2 map_3( in vec3 pos ) { \/\/ scene + ro + rd + intersection\n    vec2 res = map_2(pos);\n    \n    res = opU( res, vec2( sdSphere(     pos-USER_INTERSECT,.1),2. ) );\n    res = opU( res, vec2( sdCapsule(    pos, vec3(0,0,1.), USER_INTERSECT,.025),2. ) );\n    \n    return res;\n}\n\nvec2 map_4( in vec3 pos ) { \/\/ scene + ro + one sphere\n    vec2 res = opU( vec2( sdPlane(     pos, -1.), 1.0 ),\n\t                vec2( sdSphere(    pos-vec3(-1,0,-5),1.), 50. ) );\n    \n    res = opU( res, vec2( sdSphere(    pos-vec3(0,0,1),.1),3. ) );\n    res = opU( res, vec2( sdBox( pos,  vec3(.5*aspect, .5,.025)), 4.));\n    \n    return res;\n}\n\nvec2 map_5( in vec3 pos ) { \/\/ scene + ro + screen + march steps\n    vec2 res = map_2(pos);\n    \n    res = opU( res, vec2( sdCapsule(    pos, vec3(0,0,1.), USER_INTERSECT,.025),3. ) );\n    for( int i=0; i<intersections.length(); i++ ){\n        if (i <= MAX_MARCH_STEPS) {\n\t    \tres = opU( res, vec2( sdSphere( pos-intersections[i],.1), (i==MAX_MARCH_STEPS)?2.:3. ) );\n        }\n    }\n    \n    return res;\n}\n\nvec2 map_6( in vec3 pos ) { \/\/ scene + ro + rd + intersection + normal\n    vec2 res = map_2(pos);\n    \n    res = opU( res, vec2( sdSphere(     pos-USER_INTERSECT,.1),3. ) );\n    res = opU( res, vec2( sdCapsule(    pos, USER_INTERSECT + intersectionNormal, USER_INTERSECT,.025),2. ) );\n    \n    res = opU( res, vec2( sdCapsule(    pos, vec3(0,0,1.), USER_INTERSECT,.025),3. ) );\n    return res;\n}\n\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = .5;\n    float tmax = 20.0;\n       \n    float t = tmin;\n    float m = -1.0;\n\n    if( SCENE_MODE == 0 ) {\n        for( int i=0; i<64; i++ )\n        {\n            float precis = 0.00005*t;\n            vec2 res = map_0( ro+rd*t );\n            if( res.x<precis || t>tmax ) break;\n            t += res.x;\n            m = res.y;\n        }\n    } else if( SCENE_MODE == 1 ) {\n        for( int i=0; i<64; i++ )\n        {\n            float precis = 0.00005*t;\n            vec2 res = map_1( ro+rd*t );\n            if( res.x<precis || t>tmax ) break;\n            t += res.x;\n            m = res.y;\n        }\n    } else if( SCENE_MODE == 2 ) {\n        for( int i=0; i<64; i++ )\n        {\n            float precis = 0.00005*t;\n            vec2 res = map_2( ro+rd*t );\n            if( res.x<precis || t>tmax ) break;\n            t += res.x;\n            m = res.y;\n        }\n    } else if( SCENE_MODE == 3 ) {\n        for( int i=0; i<64; i++ )\n        {\n            float precis = 0.00005*t;\n            vec2 res = map_3( ro+rd*t );\n            if( res.x<precis || t>tmax ) break;\n            t += res.x;\n            m = res.y;\n        }\n    } else if( SCENE_MODE == 4 ) {\n        for( int i=0; i<64; i++ )\n        {\n            float precis = 0.00005*t;\n            vec2 res = map_4( ro+rd*t );\n            if( res.x<precis || t>tmax ) break;\n            t += res.x;\n            m = res.y;\n        }\n    } else if( SCENE_MODE == 5 ) {\n        for( int i=0; i<64; i++ )\n        {\n            float precis = 0.00005*t;\n            vec2 res = map_5( ro+rd*t );\n            if( res.x<precis || t>tmax ) break;\n            t += res.x;\n            m = res.y;\n        }\n    }  else if( SCENE_MODE == 6 ) {\n        for( int i=0; i<64; i++ )\n        {\n            float precis = 0.00005*t;\n            vec2 res = map_6( ro+rd*t );\n            if( res.x<precis || t>tmax ) break;\n            t += res.x;\n            m = res.y;\n        }\n    } \n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint, h;\n    for( int i=0; i<16; i++ )\n    {\n        \n\t    if( SCENE_MODE == 0 ) {\n\t\t\th = map_0( ro + rd*t ).x;\n    \t} else if( SCENE_MODE == 1 ) {\n\t\t\th = map_1( ro + rd*t ).x;\n    \t} else if( SCENE_MODE == 2 ) {\n\t\t\th = map_2( ro + rd*t ).x;\n   \t\t} else if( SCENE_MODE == 3 ) {\n\t\t\th = map_3( ro + rd*t ).x;\n   \t\t} else if( SCENE_MODE == 4 ) {\n\t\t\th = map_4( ro + rd*t ).x;\n   \t\t} else if( SCENE_MODE == 5 ) {\n\t\t\th = map_5( ro + rd*t ).x;\n   \t\t} else if( SCENE_MODE == 6 ) {\n\t\t\th = map_6( ro + rd*t ).x;\n   \t\t}\n        \n        res = min( res, 8.0*h\/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    \n    if( SCENE_MODE == 0 ) {\n \t   return normalize( e.xyy*map_0( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map_0( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map_0( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map_0( pos + e.xxx ).x );\n    } else if( SCENE_MODE == 1 ) {\n            return normalize( e.xyy*map_1( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map_1( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map_1( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map_1( pos + e.xxx ).x );\n    } else if( SCENE_MODE == 2 ) {\n            return normalize( e.xyy*map_2( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map_2( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map_2( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map_2( pos + e.xxx ).x );\n    } else if( SCENE_MODE == 3 ) {\n            return normalize( e.xyy*map_3( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map_3( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map_3( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map_3( pos + e.xxx ).x );\n    } else if( SCENE_MODE == 4 ) {\n            return normalize( e.xyy*map_4( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map_4( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map_4( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map_4( pos + e.xxx ).x );\n    } else if( SCENE_MODE == 5 ) {\n            return normalize( e.xyy*map_5( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map_5( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map_5( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map_5( pos + e.xxx ).x );\n    } else if( SCENE_MODE == 6 ) {\n            return normalize( e.xyy*map_6( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map_6( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map_6( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map_6( pos + e.xxx ).x );\n    }\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0, dd;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)\/4.0;\n        vec3 aopos =  nor * hr + pos;\n\t    if( SCENE_MODE == 0 ) {\n\t\t\tdd = map_0( aopos ).x;\n    \t} else if( SCENE_MODE == 1 ) {\n\t\t\tdd = map_1( aopos ).x;\n    \t} else if( SCENE_MODE == 2 ) {\n\t\t\tdd = map_2( aopos ).x;\n   \t\t} else if( SCENE_MODE == 3 ) {\n\t\t\tdd = map_3( aopos ).x;\n   \t\t} else if( SCENE_MODE == 4 ) {\n\t\t\tdd = map_4( aopos ).x;\n   \t\t} else if( SCENE_MODE == 5 ) {\n\t\t\tdd = map_5( aopos ).x;\n   \t\t} else if( SCENE_MODE == 6 ) {\n\t\t\tdd = map_6( aopos ).x;\n   \t\t}\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.75,0.9,1.0) + max(rd.y*.8,0.);\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        \/\/ material        \n\t\tcol = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        if( m<1.5 ) {            \n            float f = mod( floor(1.0*pos.z) + floor(1.0*pos.x), 2.0);\n            col = 0.35 + 0.05*f*vec3(1.0);\n        } else if (m < 2.5 ) {\n            col = vec3(.5 + .3*sin(iTime*6.28318530718 ),0,0);\n        } else if (m < 3.5 ) {\n            col = vec3(.8,0,0);\n        } else if (m < 4.5 ) {\n            col = tut_render(pos.xy, 64).rgb;\n        }\n\n        \/\/ lighitng        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(0.4, 0.7, 0.6) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.30*dif*vec3(1.00,0.80,0.55);\n\t\tlin += 2.00*spe*vec3(1.00,0.90,0.70)*dif;\n        lin += 0.40*amb*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\n        \n        if( DIST_MODE > 0 ) {\n            \/\/ intersect with plane;\n            float d = -(ro.y)\/rd.y;\n            vec3 dint = ro + d*rd;\n            \n            float m = sdSphere(dint-vec3(-1,0,-5),1.);\n            \n            if( DIST_MODE > 1 ) { \n                m = min( m, sdSphere(dint-vec3(2,0,-3),1.));\n                m = min( m, sdSphere(dint-vec3(-2,0,-2),1.));\n            }\n            if( DIST_MODE > 2 ) { \n                m = min( m, dint.y + 1.);\n            }\n            vec3 dcol = vec3(abs(mod(m, 0.1)\/0.1 - 0.5));\n            dcol = mix( dcol, pal( m*.115+.6, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) ), .7);\n            \n            if( SCENE_MODE == 5) {\n                for( int i=0; i<intersections.length(); i++ ){\n                    if (i<MAX_MARCH_STEPS) {\n                        float dti = distance(intersections[i], dint);\n                        float mai = map_0(intersections[i]).x;\n                        float outer = smoothstep( mai-0.15, mai, dti);\n                        dcol = mix( dcol, vec3(1,0,0), .3*smoothstep( mai+0.01, mai, dti)*(outer+1.) );\n                    }\n                }            \n            }\n            if( d < t ) {\n                col = mix(col, dcol, .6);\n            }\n        }\n        \n    \tcol = mix( col, vec3(0.75,0.9,1.0), .05+.95* smoothstep(10.,20.,t) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nvec3 calcNormal_0( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    \n    return normalize( e.xyy*map_0( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map_0( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map_0( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map_0( pos + e.xxx ).x );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvec3 renderScene( vec2 p, vec3 ro, vec3 ta ) {\n    \/\/ camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \/\/ ray direction\n    vec3 rd = ca * normalize( vec3(p.xy,1.0) );\n    \/\/ render\t\n    vec3 col = render( ro, rd );\n    \n    return col;\n}\n\n\nvoid initIntersecions( in vec3 ro, in vec3 rd ) {\n    float t = 1.;\n    \n    for( int i=0; i<intersections.length(); i++ ){\n        vec2 res = map_0( ro+rd*t );\n        t += res.x;\n        intersections[i] = ro + rd*t;\n    }\n}\n\n\/\/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 q = (fragCoord.xy - .5 * iResolution.xy ) \/ iResolution.y;\n    \n    aspect = iResolution.x\/iResolution.y;\n    \n    loadData();\n    \n    if(SCENE_MODE == -1) {\n        fragColor = tut_render(q, 96);\n    } else {\n        vec3 ro = LoadFVec4( ivec2(0,3) ).xyz;\n        vec3 ta = LoadFVec4( ivec2(0,4) ).xyz;\n        USER_INTERSECT = LoadFVec4( ivec2(0,5) ).xyz;\n        \n        if( SCENE_MODE == 5 ) {\n            MAX_MARCH_STEPS = min(max(int( SLIDE_STEPS_VISIBLE\/40-1),0), intersections.length()-1);\n            \n            initIntersecions(vec3(0,0,1), normalize(USER_INTERSECT - vec3(0,0,1)) );\n            for (int i=0; i<intersections.length(); i++) {\n                if (i<MAX_MARCH_STEPS+1) {\n            \t\tUSER_INTERSECT = intersections[i];\n                }\n            }\n        }\n        if( SCENE_MODE == 6 ) {\n            intersectionNormal = calcNormal_0(USER_INTERSECT) * .5;\n        }\n        \n        fragColor = vec4(renderScene(q, ro, ta),1);\n    }\n}",
                "name": "Buffer B",
                "description": "",
                "type": "buffer"
            },
            {
                "inputs": [
                    {
                        "id": "4dXGR8",
                        "filepath": "\/media\/previz\/buffer00.png",
                        "previewfilepath": "\/media\/previz\/buffer00.png",
                        "type": "buffer",
                        "channel": 0,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    },
                    {
                        "id": "XsXGR8",
                        "filepath": "\/media\/previz\/buffer01.png",
                        "previewfilepath": "\/media\/previz\/buffer01.png",
                        "type": "buffer",
                        "channel": 1,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    },
                    {
                        "id": "4sXGR8",
                        "filepath": "\/media\/previz\/buffer02.png",
                        "previewfilepath": "\/media\/previz\/buffer02.png",
                        "type": "buffer",
                        "channel": 2,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "4sXGR8",
                        "channel": 0
                    }
                ],
                "code": "\/\/ [SH17C] Raymarching tutorial. Created by Reinder Nijhoff 2017\n\/\/ @reindernijhoff\n\/\/ \n\/\/ https:\/\/www.shadertoy.com\/view\/4dSfRc\n\/\/\n\/\/ In this tutorial you will learn how to render a 3d-scene in Shadertoy\n\/\/ using distance fields.\n\/\/\n\/\/ The tutorial itself is created in Shadertoy, and is rendered\n\/\/ using ray marching a distance field.\n\/\/\n\/\/ The shader studied in the tutorial can be found here: \n\/\/     https:\/\/www.shadertoy.com\/view\/4dSBz3\n\/\/\n\/\/ Created for the Shadertoy Competition 2017 \n\/\/\n\/\/ Most of the render code is taken from: 'Raymarching - Primitives' by Inigo Quilez.\n\/\/\n\/\/ You can find this shader here:\n\/\/     https:\/\/www.shadertoy.com\/view\/Xds3zN\n\/\/\n\n\/\/ COPY LAST FRAME FOR FADES\n\n#define SLIDE_FADE_STEPS 60 \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    int SLIDE_STEPS_VISIBLE = int(texelFetch( iChannel0, ivec2(0,0), 0 ).y);\n    \n    if(iFrame == 0) {\n  \t\tfragColor = vec4(0,0,0,1);\n    } else if(SLIDE_STEPS_VISIBLE > SLIDE_FADE_STEPS) {\n  \t\tfragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    } else {\n    \tfragColor = texelFetch(iChannel2, ivec2(fragCoord), 0);\n    }\n}",
                "name": "Buffer C",
                "description": "",
                "type": "buffer"
            },
            {
                "inputs": [
                    {
                        "id": "4dXGzr",
                        "filepath": "\/media\/a\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png",
                        "previewfilepath": "\/media\/ap\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png",
                        "type": "texture",
                        "channel": 2,
                        "sampler": {
                            "filter": "mipmap",
                            "wrap": "repeat",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    },
                    {
                        "id": "4dXGR8",
                        "filepath": "\/media\/previz\/buffer00.png",
                        "previewfilepath": "\/media\/previz\/buffer00.png",
                        "type": "buffer",
                        "channel": 0,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    },
                    {
                        "id": "XdfGR8",
                        "filepath": "\/media\/previz\/buffer03.png",
                        "previewfilepath": "\/media\/previz\/buffer03.png",
                        "type": "buffer",
                        "channel": 1,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "XdfGR8",
                        "channel": 0
                    }
                ],
                "code": "\/\/ [SH17C] Raymarching tutorial. Created by Reinder Nijhoff 2017\n\/\/ @reindernijhoff\n\/\/ \n\/\/ https:\/\/www.shadertoy.com\/view\/4dSfRc\n\/\/\n\/\/ In this tutorial you will learn how to render a 3d-scene in Shadertoy\n\/\/ using distance fields.\n\/\/\n\/\/ The tutorial itself is created in Shadertoy, and is rendered\n\/\/ using ray marching a distance field.\n\/\/\n\/\/ The shader studied in the tutorial can be found here: \n\/\/     https:\/\/www.shadertoy.com\/view\/4dSBz3\n\/\/\n\/\/ Created for the Shadertoy Competition 2017 \n\/\/\n\/\/ Most of the render code is taken from: 'Raymarching - Primitives' by Inigo Quilez.\n\/\/\n\/\/ You can find this shader here:\n\/\/     https:\/\/www.shadertoy.com\/view\/Xds3zN\n\/\/\n\n\/\/ FONT RENDERING\n\n#define FONT_UV_WIDTH 160.\n\nivec4 LoadVec4( in ivec2 vAddr ) {\n    return ivec4( texelFetch( iChannel0, vAddr, 0 ) );\n}\n\nvoid drawStr(const uint str, const ivec2 c, const vec2 uv, const vec2 caret, const float size, const vec3 fontCol, inout vec4 outCol) {    \n    if( !(str == 0x0U || c.y < 0 || c.x < 0) ) {\n        int x = c.x % 4;\n        uint xy = (str >> ((3 - x) * 8)) % 256U;\n\n        if( xy > 0x0aU ) {\n            vec2 K = fract((uv - caret) \/ vec2(size * .45, size));\n            K.x = K.x * .6 + .2;\n            K.y = K.y * .95 - .05;\n            float d = textureLod(iChannel2, (K + vec2( xy & 0xFU, 0xFU - (xy >> 4))) \/ 16.,0.).a;\n\n            outCol.rgb = mix( fontCol, vec3(0) , smoothstep(.0,1.,smoothstep(.47,.53,d)) * .9 );\n            outCol.a = smoothstep(1.,0., smoothstep(.53,.59,d));\n        } \n    }\n}\n\nvoid mainImage( out vec4 outCol, in vec2 fragCoord ) {\n    ivec4 slideData = LoadVec4( ivec2(0,0) );\n    ivec4 text1 = LoadVec4(ivec2(0,1));\n    ivec4 text2 = LoadVec4(ivec2(0,2));\n\n    if( text1.x == 1 ) {\n        outCol = vec4(0);\n    } else {\n        outCol = texelFetch(iChannel1, ivec2(fragCoord), 0);    \n    }\n\n    vec2 uv = ((fragCoord-iResolution.xy*.5)\/iResolution.y) * FONT_UV_WIDTH;\n\n    if(text2.x > 0) { \/\/ title\n        int i = text2.x;\n\t\tuint f = 0x0U;\n\t\tif( i == 1 ) {\n\t\t\tivec2 c = ivec2( (uv - vec2(-79, 60)) * (1.\/vec2(5.85, -13)) + vec2(1,2)) - 1;\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x5261796dU : c.x < 8 ? 0x61726368U : c.x < 12 ? 0x696e6720U : c.x < 16 ? 0x64697374U : c.x < 20 ? 0x616e6365U : c.x < 24 ? 0x20666965U : c.x < 28 ? 0x6c647320U : f;\n\t\t\tdrawStr( f, c, uv, vec2(-79, 60), 13., vec3(255.\/255., 208.\/255., 128.\/255.), outCol );\t\t}\n\t\telse if( i == 2 ) {\n\t\t\tivec2 c = ivec2( (uv - vec2(-35.1, 60)) * (1.\/vec2(5.85, -13)) + vec2(1,2)) - 1;\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x43726561U : c.x < 8 ? 0x74652061U : c.x < 12 ? 0x20726179U : f;\n\t\t\tdrawStr( f, c, uv, vec2(-35.1, 60), 13., vec3(255.\/255., 208.\/255., 128.\/255.), outCol );\t\t}\n\t\telse if( i == 3 ) {\n\t\t\tivec2 c = ivec2( (uv - vec2(-43.9, 60)) * (1.\/vec2(5.85, -13)) + vec2(1,2)) - 1;\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x44697374U : c.x < 8 ? 0x616e6365U : c.x < 12 ? 0x20666965U : c.x < 16 ? 0x6c647320U : f;\n\t\t\tdrawStr( f, c, uv, vec2(-43.9, 60), 13., vec3(255.\/255., 208.\/255., 128.\/255.), outCol );\t\t}\n\t\telse if( i == 4 ) {\n\t\t\tivec2 c = ivec2( (uv - vec2(-23.4, 60)) * (1.\/vec2(5.85, -13)) + vec2(1,2)) - 1;\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x4c696768U : c.x < 8 ? 0x74696e67U : f;\n\t\t\tdrawStr( f, c, uv, vec2(-23.4, 60), 13., vec3(255.\/255., 208.\/255., 128.\/255.), outCol );\t\t}\n\n    }\n    if(text2.y > 0) { \/\/ body\n        int i = text2.y;\n\t\tivec2 c = ivec2( (uv - vec2(-120, 40)) * (1.\/vec2(3.6, -8)) + vec2(1,2)) - 1;\n\t\tuint f = 0x0U;\n\t\tif( i == 1 || i == 2 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x496e2074U : c.x < 8 ? 0x68697320U : c.x < 12 ? 0x7475746fU : c.x < 16 ? 0x7269616cU : c.x < 20 ? 0x20796f75U : c.x < 24 ? 0x2077696cU : c.x < 28 ? 0x6c206c65U : c.x < 32 ? 0x61726e20U : c.x < 36 ? 0x686f7720U : c.x < 40 ? 0x746f2072U : c.x < 44 ? 0x656e6465U : c.x < 48 ? 0x7220200aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x61203364U : c.x < 8 ? 0x2d736365U : c.x < 12 ? 0x6e652069U : c.x < 16 ? 0x6e205368U : c.x < 20 ? 0x61646572U : c.x < 24 ? 0x746f7920U : c.x < 28 ? 0x7573696eU : c.x < 32 ? 0x67206469U : c.x < 36 ? 0x7374616eU : c.x < 40 ? 0x63652066U : c.x < 44 ? 0x69656c64U : c.x < 48 ? 0x732e2020U : f;\n\t\t}\n\t\tif( i == 2 ) {\n\t\t\tif(c.y == 3) f = c.x < 4 ? 0x41732061U : c.x < 8 ? 0x6e206578U : c.x < 12 ? 0x616d706cU : c.x < 16 ? 0x652c2077U : c.x < 20 ? 0x65207769U : c.x < 24 ? 0x6c6c2063U : c.x < 28 ? 0x72656174U : c.x < 32 ? 0x65207468U : c.x < 36 ? 0x69732062U : c.x < 40 ? 0x6c61636bU : c.x < 44 ? 0x20616e64U : c.x < 48 ? 0x2020200aU : f;\n\t\t\tif(c.y == 4) f = c.x < 4 ? 0x77686974U : c.x < 8 ? 0x65207363U : c.x < 12 ? 0x656e6520U : c.x < 16 ? 0x6f662074U : c.x < 20 ? 0x68726565U : c.x < 24 ? 0x20737068U : c.x < 28 ? 0x65726573U : c.x < 32 ? 0x206f6e20U : c.x < 36 ? 0x6120706cU : c.x < 40 ? 0x616e652eU : f;\n\t\t}\n\t\telse if( i == 3 || i == 4 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x46697273U : c.x < 8 ? 0x74207765U : c.x < 12 ? 0x20637265U : c.x < 16 ? 0x61746520U : c.x < 20 ? 0x61207261U : c.x < 24 ? 0x792e200aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x54686520U : c.x < 8 ? 0x72617920U : c.x < 12 ? 0x6f726967U : c.x < 16 ? 0x696e2028U : c.x < 20 ? 0x726f2920U : c.x < 24 ? 0x77696c6cU : c.x < 28 ? 0x20626520U : c.x < 32 ? 0x61742028U : c.x < 36 ? 0x302c302cU : c.x < 40 ? 0x31292e20U : f;\n\t\t}\n\t\tif( i == 4 ) {\n\t\t\tif(c.y == 3) f = c.x < 4 ? 0x496e2063U : c.x < 8 ? 0x6f64653aU : f;\n\t\t}\n\t\telse if( i == 5 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x4e6f7720U : c.x < 8 ? 0x77652070U : c.x < 12 ? 0x6c616365U : c.x < 16 ? 0x20612076U : c.x < 20 ? 0x69727475U : c.x < 24 ? 0x616c2073U : c.x < 28 ? 0x63726565U : c.x < 32 ? 0x6e20696eU : c.x < 36 ? 0x20746865U : c.x < 40 ? 0x20736365U : c.x < 44 ? 0x6e652e0aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x49742069U : c.x < 8 ? 0x73206c6fU : c.x < 12 ? 0x63617465U : c.x < 16 ? 0x64206174U : c.x < 20 ? 0x20746865U : c.x < 24 ? 0x206f7269U : c.x < 28 ? 0x67696e20U : c.x < 32 ? 0x616e6420U : c.x < 36 ? 0x6861730aU : f;\n\t\t\tif(c.y == 2) f = c.x < 4 ? 0x64696d65U : c.x < 8 ? 0x6e73696fU : c.x < 12 ? 0x6e73206fU : c.x < 16 ? 0x66206173U : c.x < 20 ? 0x70656374U : c.x < 24 ? 0x5f726174U : c.x < 28 ? 0x696f2078U : c.x < 32 ? 0x20312e20U : f;\n\t\t}\n\t\telse if( i == 6 || i == 7 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x57652063U : c.x < 8 ? 0x6f6d7075U : c.x < 12 ? 0x74652074U : c.x < 16 ? 0x68652072U : c.x < 20 ? 0x61792064U : c.x < 24 ? 0x69726563U : c.x < 28 ? 0x74696f6eU : c.x < 32 ? 0x20287264U : c.x < 36 ? 0x2920666fU : c.x < 40 ? 0x72206561U : c.x < 44 ? 0x6368200aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x70697865U : c.x < 8 ? 0x6c202866U : c.x < 12 ? 0x72616743U : c.x < 16 ? 0x6f6f7264U : c.x < 20 ? 0x2e787929U : c.x < 24 ? 0x206f6620U : c.x < 28 ? 0x6f757220U : c.x < 32 ? 0x76697274U : c.x < 36 ? 0x75616c20U : c.x < 40 ? 0x73637265U : c.x < 44 ? 0x656e2e20U : f;\n\t\t}\n\t\tif( i == 7 ) {\n\t\t\tif(c.y == 3) f = c.x < 4 ? 0x496e2063U : c.x < 8 ? 0x6f64653aU : f;\n\t\t}\n\t\telse if( i == 8 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x55736520U : c.x < 8 ? 0x796f7572U : c.x < 12 ? 0x206d6f75U : c.x < 16 ? 0x73652074U : c.x < 20 ? 0x6f20696eU : c.x < 24 ? 0x74657261U : c.x < 28 ? 0x63742077U : c.x < 32 ? 0x69746820U : c.x < 36 ? 0x74686520U : c.x < 40 ? 0x7363656eU : c.x < 44 ? 0x652e2020U : f;\n\t\t}\n\t\telse if( i == 9 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x41206469U : c.x < 8 ? 0x7374616eU : c.x < 12 ? 0x63652066U : c.x < 16 ? 0x69656c64U : c.x < 20 ? 0x20697320U : c.x < 24 ? 0x75736564U : c.x < 28 ? 0x20746f20U : c.x < 32 ? 0x66696e64U : c.x < 36 ? 0x20746865U : c.x < 40 ? 0x2020200aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x696e7465U : c.x < 8 ? 0x72736563U : c.x < 12 ? 0x74696f6eU : c.x < 16 ? 0x206f6620U : c.x < 20 ? 0x6f757220U : c.x < 24 ? 0x72617920U : c.x < 28 ? 0x28726f2cU : c.x < 32 ? 0x20726429U : c.x < 36 ? 0x20616e64U : c.x < 40 ? 0x20746865U : c.x < 44 ? 0x20737068U : c.x < 48 ? 0x65726573U : c.x < 52 ? 0x2020200aU : f;\n\t\t\tif(c.y == 2) f = c.x < 4 ? 0x616e6420U : c.x < 8 ? 0x706c616eU : c.x < 12 ? 0x65206f66U : c.x < 16 ? 0x20746865U : c.x < 20 ? 0x20736365U : c.x < 24 ? 0x6e652e20U : f;\n\t\t}\n\t\telse if( i == 10 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x41206469U : c.x < 8 ? 0x7374616eU : c.x < 12 ? 0x63652066U : c.x < 16 ? 0x69656c64U : c.x < 20 ? 0x20697320U : c.x < 24 ? 0x61206675U : c.x < 28 ? 0x6e637469U : c.x < 32 ? 0x6f6e2074U : c.x < 36 ? 0x68617420U : c.x < 40 ? 0x67697665U : c.x < 44 ? 0x7320616eU : c.x < 48 ? 0x2020200aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x65737469U : c.x < 8 ? 0x6d617465U : c.x < 12 ? 0x20286120U : c.x < 16 ? 0x6c6f7765U : c.x < 20 ? 0x7220626fU : c.x < 24 ? 0x756e6420U : c.x < 28 ? 0x6f662920U : c.x < 32 ? 0x74686520U : c.x < 36 ? 0x64697374U : c.x < 40 ? 0x616e6365U : c.x < 44 ? 0x20746f20U : c.x < 48 ? 0x7468650aU : f;\n\t\t\tif(c.y == 2) f = c.x < 4 ? 0x636c6f73U : c.x < 8 ? 0x65737420U : c.x < 12 ? 0x73757266U : c.x < 16 ? 0x61636520U : c.x < 20 ? 0x61742061U : c.x < 24 ? 0x6e792070U : c.x < 28 ? 0x6f696e74U : c.x < 32 ? 0x20696e20U : c.x < 36 ? 0x73706163U : c.x < 40 ? 0x652e2020U : f;\n\t\t}\n\t\telse if( i == 11 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x54686520U : c.x < 8 ? 0x64697374U : c.x < 12 ? 0x616e6365U : c.x < 16 ? 0x2066756eU : c.x < 20 ? 0x6374696fU : c.x < 24 ? 0x6e20666fU : c.x < 28 ? 0x72206120U : c.x < 32 ? 0x73706865U : c.x < 36 ? 0x72652069U : c.x < 40 ? 0x73207468U : c.x < 44 ? 0x65206469U : c.x < 48 ? 0x7374616eU : c.x < 52 ? 0x63652074U : c.x < 56 ? 0x6f20200aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x74686520U : c.x < 8 ? 0x63656e74U : c.x < 12 ? 0x6572206fU : c.x < 16 ? 0x66207468U : c.x < 20 ? 0x65207370U : c.x < 24 ? 0x68657265U : c.x < 28 ? 0x206d696eU : c.x < 32 ? 0x75732074U : c.x < 36 ? 0x68652072U : c.x < 40 ? 0x61646975U : c.x < 44 ? 0x73206f66U : c.x < 48 ? 0x20746865U : c.x < 52 ? 0x20737068U : c.x < 56 ? 0x6572652eU : f;\n\t\t}\n\t\telse if( i == 12 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x54686520U : c.x < 8 ? 0x636f6465U : c.x < 12 ? 0x20666f72U : c.x < 16 ? 0x20612073U : c.x < 20 ? 0x70686572U : c.x < 24 ? 0x65206c6fU : c.x < 28 ? 0x63617465U : c.x < 32 ? 0x64206174U : c.x < 36 ? 0x20282d31U : c.x < 40 ? 0x2c302c2dU : c.x < 44 ? 0x35293a20U : f;\n\t\t}\n\t\telse if( i == 13 || i == 14 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x57652063U : c.x < 8 ? 0x6f6d6269U : c.x < 12 ? 0x6e652064U : c.x < 16 ? 0x69666665U : c.x < 20 ? 0x72656e74U : c.x < 24 ? 0x20646973U : c.x < 28 ? 0x74616e63U : c.x < 32 ? 0x65206675U : c.x < 36 ? 0x6e637469U : c.x < 40 ? 0x6f6e7320U : c.x < 44 ? 0x62792074U : c.x < 48 ? 0x616b696eU : c.x < 52 ? 0x6720200aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x74686520U : c.x < 8 ? 0x6d696e69U : c.x < 12 ? 0x6d756d20U : c.x < 16 ? 0x76616c75U : c.x < 20 ? 0x65206f66U : c.x < 24 ? 0x20746865U : c.x < 28 ? 0x73652066U : c.x < 32 ? 0x756e6374U : c.x < 36 ? 0x696f6e73U : c.x < 40 ? 0x2e202020U : f;\n\t\t}\n\t\tif( i == 14 ) {\n\t\t\tif(c.y == 3) f = c.x < 4 ? 0x496e2063U : c.x < 8 ? 0x6f64653aU : f;\n\t\t}\n\t\telse if( i == 15 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x54686520U : c.x < 8 ? 0x746f7461U : c.x < 12 ? 0x6c206469U : c.x < 16 ? 0x7374616eU : c.x < 20 ? 0x63652066U : c.x < 24 ? 0x756e6374U : c.x < 28 ? 0x696f6e20U : c.x < 32 ? 0x666f7220U : c.x < 36 ? 0x74686973U : c.x < 40 ? 0x20736365U : c.x < 44 ? 0x6e65200aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x28696e63U : c.x < 8 ? 0x6c756469U : c.x < 12 ? 0x6e672074U : c.x < 16 ? 0x68652070U : c.x < 20 ? 0x6c616e65U : c.x < 24 ? 0x29206973U : c.x < 28 ? 0x20676976U : c.x < 32 ? 0x656e2062U : c.x < 36 ? 0x793a2020U : f;\n\t\t}\n\t\telse if( i == 16 || i == 17 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x4e6f7720U : c.x < 8 ? 0x77652063U : c.x < 12 ? 0x616e206dU : c.x < 16 ? 0x61726368U : c.x < 20 ? 0x20746865U : c.x < 24 ? 0x20736365U : c.x < 28 ? 0x6e652066U : c.x < 32 ? 0x726f6d20U : c.x < 36 ? 0x726f2069U : c.x < 40 ? 0x6e206469U : c.x < 44 ? 0x72656374U : c.x < 48 ? 0x696f6e20U : c.x < 52 ? 0x72642e0aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x45616368U : c.x < 8 ? 0x20737465U : c.x < 12 ? 0x70207369U : c.x < 16 ? 0x7a652069U : c.x < 20 ? 0x73206769U : c.x < 24 ? 0x76656e20U : c.x < 28 ? 0x62792074U : c.x < 32 ? 0x68652064U : c.x < 36 ? 0x69737461U : c.x < 40 ? 0x6e636520U : c.x < 44 ? 0x6669656cU : c.x < 48 ? 0x642e2020U : f;\n\t\t}\n\t\tif( i == 17 ) {\n\t\t\tif(c.y == 3) f = c.x < 4 ? 0x57652073U : c.x < 8 ? 0x746f7020U : c.x < 12 ? 0x74686520U : c.x < 16 ? 0x6d617263U : c.x < 20 ? 0x68207768U : c.x < 24 ? 0x656e2077U : c.x < 28 ? 0x65206669U : c.x < 32 ? 0x6e642061U : c.x < 36 ? 0x6e20696eU : c.x < 40 ? 0x74657273U : c.x < 44 ? 0x65637469U : c.x < 48 ? 0x6f6e3a20U : f;\n\t\t}\n\t\telse if( i == 18 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x4e6f7720U : c.x < 8 ? 0x74686174U : c.x < 12 ? 0x20776520U : c.x < 16 ? 0x68617665U : c.x < 20 ? 0x20666f75U : c.x < 24 ? 0x6e642074U : c.x < 28 ? 0x68652069U : c.x < 32 ? 0x6e746572U : c.x < 36 ? 0x73656374U : c.x < 40 ? 0x696f6e20U : c.x < 44 ? 0x2870203dU : c.x < 48 ? 0x20726f20U : c.x < 52 ? 0x2b207264U : c.x < 56 ? 0x202a2074U : c.x < 60 ? 0x2920200aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x666f7220U : c.x < 8 ? 0x6f757220U : c.x < 12 ? 0x7261792cU : c.x < 16 ? 0x20776520U : c.x < 20 ? 0x63616e20U : c.x < 24 ? 0x67697665U : c.x < 28 ? 0x20746865U : c.x < 32 ? 0x20736365U : c.x < 36 ? 0x6e652073U : c.x < 40 ? 0x6f6d6520U : c.x < 44 ? 0x6c696768U : c.x < 48 ? 0x74696e67U : c.x < 52 ? 0x2e20200aU : f;\n\t\t\tif(c.y == 2) f = c.x < 4 ? 0x2020200aU : f;\n\t\t\tif(c.y == 3) f = c.x < 4 ? 0x546f2061U : c.x < 8 ? 0x70706c79U : c.x < 12 ? 0x20646966U : c.x < 16 ? 0x66757365U : c.x < 20 ? 0x206c6967U : c.x < 24 ? 0x6874696eU : c.x < 28 ? 0x67207765U : c.x < 32 ? 0x20686176U : c.x < 36 ? 0x6520746fU : c.x < 40 ? 0x2063616cU : c.x < 44 ? 0x63756c61U : c.x < 48 ? 0x7465200aU : f;\n\t\t\tif(c.y == 4) f = c.x < 4 ? 0x74686520U : c.x < 8 ? 0x6e6f726dU : c.x < 12 ? 0x616c206fU : c.x < 16 ? 0x66207368U : c.x < 20 ? 0x6164696eU : c.x < 24 ? 0x6720706fU : c.x < 28 ? 0x696e7420U : c.x < 32 ? 0x702e2020U : f;\n\t\t}\n\t\telse if( i == 19 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x54686520U : c.x < 8 ? 0x6e6f726dU : c.x < 12 ? 0x616c2063U : c.x < 16 ? 0x616e2062U : c.x < 20 ? 0x65206361U : c.x < 24 ? 0x6c63756cU : c.x < 28 ? 0x61746564U : c.x < 32 ? 0x20627920U : c.x < 36 ? 0x74616b69U : c.x < 40 ? 0x6e672074U : c.x < 44 ? 0x68652063U : c.x < 48 ? 0x656e7472U : c.x < 52 ? 0x616c200aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x64696666U : c.x < 8 ? 0x6572656eU : c.x < 12 ? 0x63657320U : c.x < 16 ? 0x6f6e2074U : c.x < 20 ? 0x68652064U : c.x < 24 ? 0x69737461U : c.x < 28 ? 0x6e636520U : c.x < 32 ? 0x6669656cU : c.x < 36 ? 0x643a2020U : f;\n\t\t}\n\t\telse if( i == 20 || i == 21 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x57652063U : c.x < 8 ? 0x616c6375U : c.x < 12 ? 0x6c617465U : c.x < 16 ? 0x20746865U : c.x < 20 ? 0x20646966U : c.x < 24 ? 0x66757365U : c.x < 28 ? 0x206c6967U : c.x < 32 ? 0x6874696eU : c.x < 36 ? 0x6720666fU : c.x < 40 ? 0x7220610aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x706f696eU : c.x < 8 ? 0x74206c69U : c.x < 12 ? 0x67687420U : c.x < 16 ? 0x61742070U : c.x < 20 ? 0x6f736974U : c.x < 24 ? 0x696f6e20U : c.x < 28 ? 0x28302c32U : c.x < 32 ? 0x2c30292eU : f;\n\t\t}\n\t\tif( i == 21 ) {\n\t\t\tif(c.y == 3) f = c.x < 4 ? 0x496e2063U : c.x < 8 ? 0x6f64653aU : f;\n\t\t}\n\t\telse if( i == 22 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x416e6420U : c.x < 8 ? 0x77652061U : c.x < 12 ? 0x72652064U : c.x < 16 ? 0x6f6e6521U : c.x < 20 ? 0x2020200aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x2020200aU : f;\n\t\t\tif(c.y == 2) f = c.x < 4 ? 0x41646469U : c.x < 8 ? 0x6e672061U : c.x < 12 ? 0x6d626965U : c.x < 16 ? 0x6e74206fU : c.x < 20 ? 0x63636c75U : c.x < 24 ? 0x73696f6eU : c.x < 28 ? 0x2c202866U : c.x < 32 ? 0x616b6529U : c.x < 36 ? 0x20726566U : c.x < 40 ? 0x6c656374U : c.x < 44 ? 0x696f6e73U : c.x < 48 ? 0x2c20200aU : f;\n\t\t\tif(c.y == 3) f = c.x < 4 ? 0x736f6674U : c.x < 8 ? 0x20736861U : c.x < 12 ? 0x646f7773U : c.x < 16 ? 0x2c20666fU : c.x < 20 ? 0x672c2061U : c.x < 24 ? 0x6d626965U : c.x < 28 ? 0x6e74206cU : c.x < 32 ? 0x69676874U : c.x < 36 ? 0x696e6720U : c.x < 40 ? 0x616e6420U : c.x < 44 ? 0x73706563U : c.x < 48 ? 0x756c6172U : c.x < 52 ? 0x206c6967U : c.x < 56 ? 0x6874696eU : c.x < 60 ? 0x6720200aU : f;\n\t\t\tif(c.y == 4) f = c.x < 4 ? 0x6973206cU : c.x < 8 ? 0x65667420U : c.x < 12 ? 0x61732061U : c.x < 16 ? 0x6e206578U : c.x < 20 ? 0x65726369U : c.x < 24 ? 0x73652066U : c.x < 28 ? 0x6f722074U : c.x < 32 ? 0x68652072U : c.x < 36 ? 0x65616465U : c.x < 40 ? 0x722e2020U : f;\n\t\t}\n\t\tdrawStr( f, c, uv, vec2(-120, 40), 8., vec3(1), outCol );\n    }\n    if(text2.z > 0) { \/\/ code\n        int i = text2.z;\n\t\tivec2 c = ivec2( (uv - vec2(-120, 0)) * (1.\/vec2(3.6, -8)) + vec2(1,2)) - 1;\n\t\tuint f = 0x0U;\n\t\tif( i == 1 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x766f6964U : c.x < 8 ? 0x206d6169U : c.x < 12 ? 0x6e496d61U : c.x < 16 ? 0x6765286fU : c.x < 20 ? 0x75742076U : c.x < 24 ? 0x65633420U : c.x < 28 ? 0x66726167U : c.x < 32 ? 0x436f6c6fU : c.x < 36 ? 0x722c2069U : c.x < 40 ? 0x6e207665U : c.x < 44 ? 0x63322066U : c.x < 48 ? 0x72616743U : c.x < 52 ? 0x6f6f7264U : c.x < 56 ? 0x29207b0aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x76656333U : c.x < 12 ? 0x20726f20U : c.x < 16 ? 0x3d207665U : c.x < 20 ? 0x63332830U : c.x < 24 ? 0x2c20302cU : c.x < 28 ? 0x2031293bU : c.x < 32 ? 0x2020200aU : f;\n\t\t\tif(c.y == 2) f = c.x < 4 ? 0x2020200aU : f;\n\t\t\tif(c.y == 3) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x76656332U : c.x < 12 ? 0x2071203dU : c.x < 16 ? 0x20286672U : c.x < 20 ? 0x6167436fU : c.x < 24 ? 0x6f72642eU : c.x < 28 ? 0x7879202dU : c.x < 32 ? 0x202e3520U : c.x < 36 ? 0x2a206952U : c.x < 40 ? 0x65736f6cU : c.x < 44 ? 0x7574696fU : c.x < 48 ? 0x6e2e7879U : c.x < 52 ? 0x2029202fU : c.x < 56 ? 0x20695265U : c.x < 60 ? 0x736f6c75U : c.x < 64 ? 0x74696f6eU : c.x < 68 ? 0x2e793b0aU : f;\n\t\t\tif(c.y == 4) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x76656333U : c.x < 12 ? 0x20726420U : c.x < 16 ? 0x3d206e6fU : c.x < 20 ? 0x726d616cU : c.x < 24 ? 0x697a6528U : c.x < 28 ? 0x76656333U : c.x < 32 ? 0x28712c20U : c.x < 36 ? 0x302e2920U : c.x < 40 ? 0x2d20726fU : c.x < 44 ? 0x293b200aU : f;\n\t\t}\n\t\telse if( i == 2 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x666c6f61U : c.x < 8 ? 0x74206d61U : c.x < 12 ? 0x70287665U : c.x < 16 ? 0x63332070U : c.x < 20 ? 0x29207b0aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x666c6f61U : c.x < 12 ? 0x74206420U : c.x < 16 ? 0x3d206469U : c.x < 20 ? 0x7374616eU : c.x < 24 ? 0x63652870U : c.x < 28 ? 0x2c207665U : c.x < 32 ? 0x6333282dU : c.x < 36 ? 0x312c2030U : c.x < 40 ? 0x2c202d35U : c.x < 44 ? 0x2929202dU : c.x < 48 ? 0x20312e3bU : c.x < 52 ? 0x2020200aU : f;\n\t\t\tif(c.y == 2) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x64203d20U : c.x < 12 ? 0x6d696e28U : c.x < 16 ? 0x642c2064U : c.x < 20 ? 0x69737461U : c.x < 24 ? 0x6e636528U : c.x < 28 ? 0x702c2076U : c.x < 32 ? 0x65633328U : c.x < 36 ? 0x322c2030U : c.x < 40 ? 0x2c202d33U : c.x < 44 ? 0x2929202dU : c.x < 48 ? 0x20312e29U : c.x < 52 ? 0x3b20200aU : f;\n\t\t\tif(c.y == 3) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x64203d20U : c.x < 12 ? 0x6d696e28U : c.x < 16 ? 0x642c2064U : c.x < 20 ? 0x69737461U : c.x < 24 ? 0x6e636528U : c.x < 28 ? 0x702c2076U : c.x < 32 ? 0x65633328U : c.x < 36 ? 0x2d322c20U : c.x < 40 ? 0x302c202dU : c.x < 44 ? 0x32292920U : c.x < 48 ? 0x2d20312eU : c.x < 52 ? 0x293b200aU : f;\n\t\t\tif(c.y == 4) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x64203d20U : c.x < 12 ? 0x6d696e28U : c.x < 16 ? 0x642c2070U : c.x < 20 ? 0x2e79202bU : c.x < 24 ? 0x20312e29U : c.x < 28 ? 0x3b20200aU : f;\n\t\t\tif(c.y == 5) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x72657475U : c.x < 12 ? 0x726e2064U : c.x < 16 ? 0x3b20200aU : f;\n\t\t\tif(c.y == 6) f = c.x < 4 ? 0x7d202020U : f;\n\t\t}\n\t\telse if( i == 3 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x666c6f61U : c.x < 8 ? 0x7420682cU : c.x < 12 ? 0x2074203dU : c.x < 16 ? 0x20312e3bU : c.x < 20 ? 0x2020200aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x666f7220U : c.x < 8 ? 0x28696e74U : c.x < 12 ? 0x2069203dU : c.x < 16 ? 0x20303b20U : c.x < 20 ? 0x69203c20U : c.x < 24 ? 0x3235363bU : c.x < 28 ? 0x20692b2bU : c.x < 32 ? 0x29207b0aU : f;\n\t\t\tif(c.y == 2) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x68203d20U : c.x < 12 ? 0x6d617028U : c.x < 16 ? 0x726f202bU : c.x < 20 ? 0x20726420U : c.x < 24 ? 0x2a207429U : c.x < 28 ? 0x3b20200aU : f;\n\t\t\tif(c.y == 3) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x74202b3dU : c.x < 12 ? 0x20683b0aU : f;\n\t\t\tif(c.y == 4) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x69662028U : c.x < 12 ? 0x68203c20U : c.x < 16 ? 0x302e3031U : c.x < 20 ? 0x29206272U : c.x < 24 ? 0x65616b3bU : c.x < 28 ? 0x2020200aU : f;\n\t\t\tif(c.y == 5) f = c.x < 4 ? 0x7d202020U : f;\n\t\t}\n\t\telse if( i == 4 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x76656333U : c.x < 8 ? 0x2063616cU : c.x < 12 ? 0x634e6f72U : c.x < 16 ? 0x6d616c28U : c.x < 20 ? 0x696e2076U : c.x < 24 ? 0x65633320U : c.x < 28 ? 0x7029207bU : c.x < 32 ? 0x2020200aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x76656332U : c.x < 12 ? 0x2065203dU : c.x < 16 ? 0x20766563U : c.x < 20 ? 0x3228312eU : c.x < 24 ? 0x302c202dU : c.x < 28 ? 0x312e3029U : c.x < 32 ? 0x202a2030U : c.x < 36 ? 0x2e303030U : c.x < 40 ? 0x353b200aU : f;\n\t\t\tif(c.y == 2) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x72657475U : c.x < 12 ? 0x726e206eU : c.x < 16 ? 0x6f726d61U : c.x < 20 ? 0x6c697a65U : c.x < 24 ? 0x2820200aU : f;\n\t\t\tif(c.y == 3) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x20202020U : c.x < 12 ? 0x652e7879U : c.x < 16 ? 0x79202a20U : c.x < 20 ? 0x6d617028U : c.x < 24 ? 0x70202b20U : c.x < 28 ? 0x652e7879U : c.x < 32 ? 0x7929202bU : c.x < 36 ? 0x2020200aU : f;\n\t\t\tif(c.y == 4) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x20202020U : c.x < 12 ? 0x652e7979U : c.x < 16 ? 0x78202a20U : c.x < 20 ? 0x6d617028U : c.x < 24 ? 0x70202b20U : c.x < 28 ? 0x652e7979U : c.x < 32 ? 0x7829202bU : c.x < 36 ? 0x2020200aU : f;\n\t\t\tif(c.y == 5) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x20202020U : c.x < 12 ? 0x652e7978U : c.x < 16 ? 0x79202a20U : c.x < 20 ? 0x6d617028U : c.x < 24 ? 0x70202b20U : c.x < 28 ? 0x652e7978U : c.x < 32 ? 0x7929202bU : c.x < 36 ? 0x2020200aU : f;\n\t\t\tif(c.y == 6) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x20202020U : c.x < 12 ? 0x652e7878U : c.x < 16 ? 0x78202a20U : c.x < 20 ? 0x6d617028U : c.x < 24 ? 0x70202b20U : c.x < 28 ? 0x652e7878U : c.x < 32 ? 0x7829293bU : c.x < 36 ? 0x2020200aU : f;\n\t\t\tif(c.y == 7) f = c.x < 4 ? 0x7d202020U : f;\n\t\t}\n\t\telse if( i == 5 ) {\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x69662028U : c.x < 8 ? 0x68203c20U : c.x < 12 ? 0x302e3031U : c.x < 16 ? 0x29207b0aU : f;\n\t\t\tif(c.y == 1) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x76656333U : c.x < 12 ? 0x2070203dU : c.x < 16 ? 0x20726f20U : c.x < 20 ? 0x2b207264U : c.x < 24 ? 0x202a2074U : c.x < 28 ? 0x3b20200aU : f;\n\t\t\tif(c.y == 2) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x76656333U : c.x < 12 ? 0x206e6f72U : c.x < 16 ? 0x6d616c20U : c.x < 20 ? 0x3d206361U : c.x < 24 ? 0x6c634e6fU : c.x < 28 ? 0x726d616cU : c.x < 32 ? 0x2870293bU : c.x < 36 ? 0x2020200aU : f;\n\t\t\tif(c.y == 3) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x76656333U : c.x < 12 ? 0x206c6967U : c.x < 16 ? 0x6874203dU : c.x < 20 ? 0x20766563U : c.x < 24 ? 0x3328302cU : c.x < 28 ? 0x20322c20U : c.x < 32 ? 0x30293b0aU : f;\n\t\t\tif(c.y == 4) f = c.x < 4 ? 0x2020200aU : f;\n\t\t\tif(c.y == 5) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x666c6f61U : c.x < 12 ? 0x74206469U : c.x < 16 ? 0x66203d20U : c.x < 20 ? 0x636c616dU : c.x < 24 ? 0x7028646fU : c.x < 28 ? 0x74286e6fU : c.x < 32 ? 0x726d616cU : c.x < 36 ? 0x2c206e6fU : c.x < 40 ? 0x726d616cU : c.x < 44 ? 0x697a6528U : c.x < 48 ? 0x6c696768U : c.x < 52 ? 0x74202d20U : c.x < 56 ? 0x7029292cU : c.x < 60 ? 0x20302e2cU : c.x < 64 ? 0x20312e29U : c.x < 68 ? 0x3b20200aU : f;\n\t\t\tif(c.y == 6) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x64696620U : c.x < 12 ? 0x2a3d2035U : c.x < 16 ? 0x2e202f20U : c.x < 20 ? 0x646f7428U : c.x < 24 ? 0x6c696768U : c.x < 28 ? 0x74202d20U : c.x < 32 ? 0x702c206cU : c.x < 36 ? 0x69676874U : c.x < 40 ? 0x202d2070U : c.x < 44 ? 0x293b200aU : f;\n\t\t\tif(c.y == 7) f = c.x < 4 ? 0x20202020U : c.x < 8 ? 0x66726167U : c.x < 12 ? 0x436f6c6fU : c.x < 16 ? 0x72203d20U : c.x < 20 ? 0x76656334U : c.x < 24 ? 0x28766563U : c.x < 28 ? 0x3328706fU : c.x < 32 ? 0x77286469U : c.x < 36 ? 0x662c2030U : c.x < 40 ? 0x2e343534U : c.x < 44 ? 0x3529292cU : c.x < 48 ? 0x2031293bU : c.x < 52 ? 0x2020200aU : f;\n\t\t\tif(c.y == 8) f = c.x < 4 ? 0x7d202020U : f;\n\t\t}\n\t\tdrawStr( f, c, uv, vec2(-120, 0), 8., vec3(.8,.95,1.), outCol );\n        if( text1.y > 0 ) {\n           if(uv.y >  - (-1.+float(text1.y))*8. && c.y >= 0 ) {\n                outCol *= vec4(.5,.2,.6,.8);\n            }\n        }\n        if( text1.z > 0 ) {\n            if(uv.y <  - (-2.+float(text1.z))*8. && c.y >= 0 ) {\n                outCol *= vec4(.5,.2,.6,.8);\n            }\n        }\n    }\n    if(slideData.y == 120) { \/\/ footer\n        int i = 1;\n\t\tuint f = 0x0U;\n\t\tif( i == 1 ) {\n\t\t\tivec2 c = ivec2( (uv - vec2(-38.8, -78)) * (1.\/vec2(3.38, -7.5)) + vec2(1,2)) - 1;\n\t\t\tif(c.y == 0) f = c.x < 4 ? 0x50726573U : c.x < 8 ? 0x73207370U : c.x < 12 ? 0x61636520U : c.x < 16 ? 0x746f2063U : c.x < 20 ? 0x6f6e7469U : c.x < 24 ? 0x6e756520U : f;\n\t\t\tdrawStr( f, c, uv, vec2(-38.8, -78), 7.5, vec3(.9), outCol );\t\t}\n\n    }\n}",
                "name": "Buffer D",
                "description": "",
                "type": "buffer"
            }
        ]
    },
    {
        "ver": "0.1",
        "info": {
            "id": "lstSRS",
            "date": "1460054893",
            "viewed": 24386,
            "name": "Gargantua With HDR Bloom",
            "username": "sonicether",
            "description": "My attempt at recreating the black hole Gargantua from the movie Interstellar. High-quality bloom was essential for the right look, so I did what I could with only four passes. No background stars\/nebulae, maybe I'll do that in the future.",
            "likes": 294,
            "published": 3,
            "flags": 32,
            "usePreview": 1,
            "tags": []
        },
        "renderpass": [
            {
                "inputs": [
                    {
                        "id": "4dXGR8",
                        "filepath": "\/media\/previz\/buffer00.png",
                        "previewfilepath": "\/media\/previz\/buffer00.png",
                        "type": "buffer",
                        "channel": 0,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    },
                    {
                        "id": "XsXGR8",
                        "filepath": "\/media\/previz\/buffer01.png",
                        "previewfilepath": "\/media\/previz\/buffer01.png",
                        "type": "buffer",
                        "channel": 1,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    },
                    {
                        "id": "4sXGR8",
                        "filepath": "\/media\/previz\/buffer02.png",
                        "previewfilepath": "\/media\/previz\/buffer02.png",
                        "type": "buffer",
                        "channel": 2,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    },
                    {
                        "id": "XdfGR8",
                        "filepath": "\/media\/previz\/buffer03.png",
                        "previewfilepath": "\/media\/previz\/buffer03.png",
                        "type": "buffer",
                        "channel": 3,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "4dfGRr",
                        "channel": 0
                    }
                ],
                "code": "vec3 saturate(vec3 x)\n{\n    return clamp(x, vec3(0.0), vec3(1.0));\n}\n\nvec4 cubic(float x)\n{\n    float x2 = x * x;\n    float x3 = x2 * x;\n    vec4 w;\n    w.x =   -x3 + 3.0*x2 - 3.0*x + 1.0;\n    w.y =  3.0*x3 - 6.0*x2       + 4.0;\n    w.z = -3.0*x3 + 3.0*x2 + 3.0*x + 1.0;\n    w.w =  x3;\n    return w \/ 6.0;\n}\n\nvec4 BicubicTexture(in sampler2D tex, in vec2 coord)\n{\n\tvec2 resolution = iResolution.xy;\n\n\tcoord *= resolution;\n\n\tfloat fx = fract(coord.x);\n    float fy = fract(coord.y);\n    coord.x -= fx;\n    coord.y -= fy;\n\n    fx -= 0.5;\n    fy -= 0.5;\n\n    vec4 xcubic = cubic(fx);\n    vec4 ycubic = cubic(fy);\n\n    vec4 c = vec4(coord.x - 0.5, coord.x + 1.5, coord.y - 0.5, coord.y + 1.5);\n    vec4 s = vec4(xcubic.x + xcubic.y, xcubic.z + xcubic.w, ycubic.x + ycubic.y, ycubic.z + ycubic.w);\n    vec4 offset = c + vec4(xcubic.y, xcubic.w, ycubic.y, ycubic.w) \/ s;\n\n    vec4 sample0 = texture(tex, vec2(offset.x, offset.z) \/ resolution);\n    vec4 sample1 = texture(tex, vec2(offset.y, offset.z) \/ resolution);\n    vec4 sample2 = texture(tex, vec2(offset.x, offset.w) \/ resolution);\n    vec4 sample3 = texture(tex, vec2(offset.y, offset.w) \/ resolution);\n\n    float sx = s.x \/ (s.x + s.y);\n    float sy = s.z \/ (s.z + s.w);\n\n    return mix( mix(sample3, sample2, sx), mix(sample1, sample0, sx), sy);\n}\n\nvec3 ColorFetch(vec2 coord)\n{\n \treturn texture(iChannel0, coord).rgb;   \n}\n\nvec3 BloomFetch(vec2 coord)\n{\n \treturn BicubicTexture(iChannel3, coord).rgb;   \n}\n\nvec3 Grab(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord \/= scale;\n    coord -= offset;\n\n    return BloomFetch(coord);\n}\n\nvec2 CalcOffset(float octave)\n{\n    vec2 offset = vec2(0.0);\n    \n    vec2 padding = vec2(10.0) \/ iResolution.xy;\n    \n    offset.x = -min(1.0, floor(octave \/ 3.0)) * (0.25 + padding.x);\n    \n    offset.y = -(1.0 - (1.0 \/ exp2(octave))) - padding.y * octave;\n\n\toffset.y += min(1.0, floor(octave \/ 3.0)) * 0.35;\n    \n \treturn offset;   \n}\n\nvec3 GetBloom(vec2 coord)\n{\n \tvec3 bloom = vec3(0.0);\n    \n    \/\/Reconstruct bloom from multiple blurred images\n    bloom += Grab(coord, 1.0, vec2(CalcOffset(0.0))) * 1.0;\n    bloom += Grab(coord, 2.0, vec2(CalcOffset(1.0))) * 1.5;\n\tbloom += Grab(coord, 3.0, vec2(CalcOffset(2.0))) * 1.0;\n    bloom += Grab(coord, 4.0, vec2(CalcOffset(3.0))) * 1.5;\n    bloom += Grab(coord, 5.0, vec2(CalcOffset(4.0))) * 1.8;\n    bloom += Grab(coord, 6.0, vec2(CalcOffset(5.0))) * 1.0;\n    bloom += Grab(coord, 7.0, vec2(CalcOffset(6.0))) * 1.0;\n    bloom += Grab(coord, 8.0, vec2(CalcOffset(7.0))) * 1.0;\n\n\treturn bloom;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n    \n    vec3 color = ColorFetch(uv);\n    \n    \n    color += GetBloom(uv) * 0.08;\n    \n    color *= 200.0;\n    \n\n    \/\/Tonemapping and color grading\n    color = pow(color, vec3(1.5));\n    color = color \/ (1.0 + color);\n    color = pow(color, vec3(1.0 \/ 1.5));\n\n    \n    color = mix(color, color * color * (3.0 - 2.0 * color), vec3(1.0));\n    color = pow(color, vec3(1.3, 1.20, 1.0));    \n\n\tcolor = saturate(color * 1.01);\n    \n    color = pow(color, vec3(0.7 \/ 2.2));\n\n    fragColor = vec4(color, 1.0);\n\n}\n",
                "name": "Image",
                "description": "",
                "type": "image"
            },
            {
                "inputs": [
                    {
                        "id": "XsXGRn",
                        "filepath": "\/media\/a\/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg",
                        "previewfilepath": "\/media\/ap\/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg",
                        "type": "texture",
                        "channel": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "wrap": "repeat",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    },
                    {
                        "id": "Xsf3zn",
                        "filepath": "\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
                        "previewfilepath": "\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
                        "type": "texture",
                        "channel": 0,
                        "sampler": {
                            "filter": "mipmap",
                            "wrap": "repeat",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    },
                    {
                        "id": "4dXGR8",
                        "filepath": "\/media\/previz\/buffer00.png",
                        "previewfilepath": "\/media\/previz\/buffer00.png",
                        "type": "buffer",
                        "channel": 2,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "4dXGR8",
                        "channel": 0
                    }
                ],
                "code": "\/*  \nMain render. \n\nTemporal AA for a smooth image. Temporal accumulation is disabled while moving the view to prevent ghosting.\n*\/\n\n#define ITERATIONS 200          \/\/Increase for less grainy result\n#define TEMPORAL_AA\n\n\nconst vec3 MainColor = vec3(1.0);\n\n\/\/noise code by iq\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n    vec2 rg = textureLod( iChannel0, (uv+ 0.5)\/256.0, 0.0 ).yx;\n    return -1.0+2.0*mix( rg.x, rg.y, f.z );\n}\n\nfloat saturate(float x)\n{\n    return clamp(x, 0.0, 1.0);\n}\n\nvec3 saturate(vec3 x)\n{\n    return clamp(x, vec3(0.0), vec3(1.0));\n}\n\nfloat rand(vec2 coord)\n{\n    return saturate(fract(sin(dot(coord, vec2(12.9898, 78.223))) * 43758.5453));\n}\n\nfloat pcurve( float x, float a, float b )\n{\n    float k = pow(a+b,a+b) \/ (pow(a,a)*pow(b,b));\n    return k * pow( x, a ) * pow( 1.0-x, b );\n}\n\nconst float pi = 3.14159265;\n\nfloat atan2(float y, float x)\n{\n    if (x > 0.0)\n    {\n        return atan(y \/ x);\n    }\n    else if (x == 0.0)\n    {\n        if (y > 0.0)\n        {\n            return pi \/ 2.0;\n        }\n        else if (y < 0.0)\n        {\n            return -(pi \/ 2.0);\n        }\n        else\n        {\n            return 0.0;\n        }\n    }\n    else \/\/(x < 0.0)\n    {\n        if (y >= 0.0)\n        {\n            return atan(y \/ x) + pi;\n        }\n        else\n        {\n            return atan(y \/ x) - pi;\n        }\n    }\n}\n\nfloat sdTorus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q)-t.y;\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n  return length(p)-r;\n}\n\nvoid Haze(inout vec3 color, vec3 pos, float alpha)\n{\n    vec2 t = vec2(1.0, 0.01);\n\n    float torusDist = length(sdTorus(pos + vec3(0.0, -0.05, 0.0), t));\n\n    float bloomDisc = 1.0 \/ (pow(torusDist, 2.0) + 0.001);\n    vec3 col = MainColor;\n    bloomDisc *= length(pos) < 0.5 ? 0.0 : 1.0;\n\n    color += col * bloomDisc * (2.9 \/ float(ITERATIONS)) * (1.0 - alpha * 1.0);\n}\n\nvoid GasDisc(inout vec3 color, inout float alpha, vec3 pos)\n{\n    float discRadius = 3.2;\n    float discWidth = 5.3;\n    float discInner = discRadius - discWidth * 0.5;\n    float discOuter = discRadius + discWidth * 0.5;\n    \n    vec3 origin = vec3(0.0, 0.0, 0.0);\n    float mouseZ = iMouse.y \/ iResolution.y;\n    vec3 discNormal = normalize(vec3(0.0, 1.0, 0.0));\n    float discThickness = 0.1;\n\n    float distFromCenter = distance(pos, origin);\n    float distFromDisc = dot(discNormal, pos - origin);\n    \n    float radialGradient = 1.0 - saturate((distFromCenter - discInner) \/ discWidth * 0.5);\n\n    float coverage = pcurve(radialGradient, 4.0, 0.9);\n\n    discThickness *= radialGradient;\n    coverage *= saturate(1.0 - abs(distFromDisc) \/ discThickness);\n\n    vec3 dustColorLit = MainColor;\n    vec3 dustColorDark = vec3(0.0, 0.0, 0.0);\n\n    float dustGlow = 1.0 \/ (pow(1.0 - radialGradient, 2.0) * 290.0 + 0.002);\n    vec3 dustColor = dustColorLit * dustGlow * 8.2;\n\n    coverage = saturate(coverage * 0.7);\n\n\n    float fade = pow((abs(distFromCenter - discInner) + 0.4), 4.0) * 0.04;\n    float bloomFactor = 1.0 \/ (pow(distFromDisc, 2.0) * 40.0 + fade + 0.00002);\n    vec3 b = dustColorLit * pow(bloomFactor, 1.5);\n    \n    b *= mix(vec3(1.7, 1.1, 1.0), vec3(0.5, 0.6, 1.0), vec3(pow(radialGradient, 2.0)));\n    b *= mix(vec3(1.7, 0.5, 0.1), vec3(1.0), vec3(pow(radialGradient, 0.5)));\n\n    dustColor = mix(dustColor, b * 150.0, saturate(1.0 - coverage * 1.0));\n    coverage = saturate(coverage + bloomFactor * bloomFactor * 0.1);\n    \n    if (coverage < 0.01)\n    {\n        return;   \n    }\n    \n    \n    vec3 radialCoords;\n    radialCoords.x = distFromCenter * 1.5 + 0.55;\n    radialCoords.y = atan2(-pos.x, -pos.z) * 1.5;\n    radialCoords.z = distFromDisc * 1.5;\n\n    radialCoords *= 0.95;\n    \n    float speed = 0.06;\n    \n    float noise1 = 1.0;\n    vec3 rc = radialCoords + 0.0;               rc.y += iTime * speed;\n    noise1 *= noise(rc * 3.0) * 0.5 + 0.5;      rc.y -= iTime * speed;\n    noise1 *= noise(rc * 6.0) * 0.5 + 0.5;      rc.y += iTime * speed;\n    noise1 *= noise(rc * 12.0) * 0.5 + 0.5;     rc.y -= iTime * speed;\n    noise1 *= noise(rc * 24.0) * 0.5 + 0.5;     rc.y += iTime * speed;\n\n    float noise2 = 2.0;\n    rc = radialCoords + 30.0;\n    noise2 *= noise(rc * 3.0) * 0.5 + 0.5;      rc.y += iTime * speed;\n    noise2 *= noise(rc * 6.0) * 0.5 + 0.5;      rc.y -= iTime * speed;\n    noise2 *= noise(rc * 12.0) * 0.5 + 0.5;     rc.y += iTime * speed;\n    noise2 *= noise(rc * 24.0) * 0.5 + 0.5;     rc.y -= iTime * speed;\n    noise2 *= noise(rc * 48.0) * 0.5 + 0.5;     rc.y += iTime * speed;\n    noise2 *= noise(rc * 92.0) * 0.5 + 0.5;     rc.y -= iTime * speed;\n\n    dustColor *= noise1 * 0.998 + 0.002;\n    coverage *= noise2;\n    \n    radialCoords.y += iTime * speed * 0.5;\n    \n    dustColor *= pow(texture(iChannel1, radialCoords.yx * vec2(0.15, 0.27)).rgb, vec3(2.0)) * 4.0;\n\n    coverage = saturate(coverage * 1200.0 \/ float(ITERATIONS));\n    dustColor = max(vec3(0.0), dustColor);\n\n    coverage *= pcurve(radialGradient, 4.0, 0.9);\n\n    color = (1.0 - alpha) * dustColor * coverage + color;\n\n    alpha = (1.0 - alpha) * coverage + alpha;\n}\n\n\n\nvec3 rotate(vec3 p, float x, float y, float z)\n{\n    mat3 matx = mat3(1.0, 0.0, 0.0,\n                     0.0, cos(x), sin(x),\n                     0.0, -sin(x), cos(x));\n\n    mat3 maty = mat3(cos(y), 0.0, -sin(y),\n                     0.0, 1.0, 0.0,\n                     sin(y), 0.0, cos(y));\n\n    mat3 matz = mat3(cos(z), sin(z), 0.0,\n                     -sin(z), cos(z), 0.0,\n                     0.0, 0.0, 1.0);\n\n    p = matx * p;\n    p = matz * p;\n    p = maty * p;\n\n    return p;\n}\n\nvoid RotateCamera(inout vec3 eyevec, inout vec3 eyepos)\n{\n    float mousePosY = iMouse.y \/ iResolution.y;\n    float mousePosX = iMouse.x \/ iResolution.x;\n\n    vec3 angle = vec3(mousePosY * 0.05 + 0.05, 1.0 + mousePosX * 1.0, -0.45);\n\n    eyevec = rotate(eyevec, angle.x, angle.y, angle.z);\n    eyepos = rotate(eyepos, angle.x, angle.y, angle.z);\n}\n\nvoid WarpSpace(inout vec3 eyevec, inout vec3 raypos)\n{\n    vec3 origin = vec3(0.0, 0.0, 0.0);\n\n    float singularityDist = distance(raypos, origin);\n    float warpFactor = 1.0 \/ (pow(singularityDist, 2.0) + 0.000001);\n\n    vec3 singularityVector = normalize(origin - raypos);\n    \n    float warpAmount = 5.0;\n\n    eyevec = normalize(eyevec + singularityVector * warpFactor * warpAmount \/ float(ITERATIONS));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n    \n    float aspect = iResolution.x \/ iResolution.y;\n\n    vec2 uveye = uv;\n    \n    #ifdef TEMPORAL_AA\n    uveye.x += (rand(uv + sin(iTime * 1.0)) \/ iResolution.x) * (iMouse.z > 1.0 ? 0.0 : 1.0);\n    uveye.y += (rand(uv + 1.0 + sin(iTime * 1.0)) \/ iResolution.y) * (iMouse.z > 1.0 ? 0.0 : 1.0);\n    #endif\n    \n    vec3 eyevec = normalize(vec3((uveye * 2.0 - 1.0) * vec2(aspect, 1.0), 6.0));\n    vec3 eyepos = vec3(0.0, -0.0, -10.0);\n    \n    vec2 mousepos = iMouse.xy \/ iResolution.xy;\n    if (mousepos.x == 0.0)\n    {\n        mousepos.x = 0.35;\n    }\n    eyepos.x += mousepos.x * 3.0 - 1.5;\n    \n    const float far = 15.0;\n\n    RotateCamera(eyevec, eyepos);\n\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    \n    float dither = rand(uv \n                        #ifdef TEMPORAL_AA\n                        + sin(iTime * 1.0) * (iMouse.z > 1.0 ? 0.0 : 1.0)\n                        #endif\n                       ) * 2.0;\n\n\n    float alpha = 0.0;\n    vec3 raypos = eyepos + eyevec * dither * far \/ float(ITERATIONS);\n    for (int i = 0; i < ITERATIONS; i++)\n    {        \n        WarpSpace(eyevec, raypos);\n        raypos += eyevec * far \/ float(ITERATIONS);\n        GasDisc(color, alpha, raypos);\n        Haze(color, raypos, alpha);\n    }\n    \n    color *= 0.0001;\n\n    \n    #ifdef TEMPORAL_AA\n    const float p = 1.0;\n    vec3 previous = pow(texture(iChannel2, uv).rgb, vec3(1.0 \/ p));\n    \n    color = pow(color, vec3(1.0 \/ p));\n    \n    float blendWeight = 0.9 * (iMouse.z > 1.0 ? 0.0 : 1.0);\n    \n    color = mix(color, previous, blendWeight);\n    \n    color = pow(color, vec3(p));\n    #endif\n    \n    fragColor = vec4(saturate(color), 1.0);\n\n}",
                "name": "Buf A",
                "description": "",
                "type": "buffer"
            },
            {
                "inputs": [
                    {
                        "id": "4dXGR8",
                        "filepath": "\/media\/previz\/buffer00.png",
                        "previewfilepath": "\/media\/previz\/buffer00.png",
                        "type": "buffer",
                        "channel": 0,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "XsXGR8",
                        "channel": 0
                    }
                ],
                "code": "\/\/First bloom pass, mipmap tree thing\n\nvec3 ColorFetch(vec2 coord)\n{\n \treturn texture(iChannel0, coord).rgb;   \n}\n\nvec3 Grab1(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = ColorFetch(coord);\n\n    return color;\n}\n\nvec3 Grab4(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = vec3(0.0);\n    float weights = 0.0;\n    \n    const int oversampling = 4;\n    \n    for (int i = 0; i < oversampling; i++)\n    {    \t    \n        for (int j = 0; j < oversampling; j++)\n        {\n\t\t\tvec2 off = (vec2(i, j) \/ iResolution.xy + vec2(0.0) \/ iResolution.xy) * scale \/ float(oversampling);\n            color += ColorFetch(coord + off);\n            \n\n            weights += 1.0;\n        }\n    }\n    \n    color \/= weights;\n    \n    return color;\n}\n\nvec3 Grab8(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = vec3(0.0);\n    float weights = 0.0;\n    \n    const int oversampling = 8;\n    \n    for (int i = 0; i < oversampling; i++)\n    {    \t    \n        for (int j = 0; j < oversampling; j++)\n        {\n\t\t\tvec2 off = (vec2(i, j) \/ iResolution.xy + vec2(0.0) \/ iResolution.xy) * scale \/ float(oversampling);\n            color += ColorFetch(coord + off);\n            \n\n            weights += 1.0;\n        }\n    }\n    \n    color \/= weights;\n    \n    return color;\n}\n\nvec3 Grab16(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = vec3(0.0);\n    float weights = 0.0;\n    \n    const int oversampling = 16;\n    \n    for (int i = 0; i < oversampling; i++)\n    {    \t    \n        for (int j = 0; j < oversampling; j++)\n        {\n\t\t\tvec2 off = (vec2(i, j) \/ iResolution.xy + vec2(0.0) \/ iResolution.xy) * scale \/ float(oversampling);\n            color += ColorFetch(coord + off);\n            \n\n            weights += 1.0;\n        }\n    }\n    \n    color \/= weights;\n    \n    return color;\n}\n\nvec2 CalcOffset(float octave)\n{\n    vec2 offset = vec2(0.0);\n    \n    vec2 padding = vec2(10.0) \/ iResolution.xy;\n    \n    offset.x = -min(1.0, floor(octave \/ 3.0)) * (0.25 + padding.x);\n    \n    offset.y = -(1.0 - (1.0 \/ exp2(octave))) - padding.y * octave;\n\n\toffset.y += min(1.0, floor(octave \/ 3.0)) * 0.35;\n    \n \treturn offset;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n    \n    \n    vec3 color = vec3(0.0);\n    \n    \/*\n    Create a mipmap tree thingy with padding to prevent leaking bloom\n   \t\n\tSince there's no mipmaps for the previous buffer and the reduction process has to be done in one pass,\n    oversampling is required for a proper result\n\t*\/\n    color += Grab1(uv, 1.0, vec2(0.0,  0.0)   );\n    color += Grab4(uv, 2.0, vec2(CalcOffset(1.0))   );\n    color += Grab8(uv, 3.0, vec2(CalcOffset(2.0))   );\n    color += Grab16(uv, 4.0, vec2(CalcOffset(3.0))   );\n    color += Grab16(uv, 5.0, vec2(CalcOffset(4.0))   );\n    color += Grab16(uv, 6.0, vec2(CalcOffset(5.0))   );\n    color += Grab16(uv, 7.0, vec2(CalcOffset(6.0))   );\n    color += Grab16(uv, 8.0, vec2(CalcOffset(7.0))   );\n\n\n    fragColor = vec4(color, 1.0);\n}",
                "name": "Buf B",
                "description": "",
                "type": "buffer"
            },
            {
                "inputs": [
                    {
                        "id": "XsXGR8",
                        "filepath": "\/media\/previz\/buffer01.png",
                        "previewfilepath": "\/media\/previz\/buffer01.png",
                        "type": "buffer",
                        "channel": 0,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "4sXGR8",
                        "channel": 0
                    }
                ],
                "code": "\/\/Horizontal gaussian blur leveraging hardware filtering for fewer texture lookups.\n\nvec3 ColorFetch(vec2 coord)\n{\n \treturn texture(iChannel0, coord).rgb;   \n}\n\nfloat weights[5];\nfloat offsets[5];\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    \n    weights[0] = 0.19638062;\n    weights[1] = 0.29675293;\n    weights[2] = 0.09442139;\n    weights[3] = 0.01037598;\n    weights[4] = 0.00025940;\n    \n    offsets[0] = 0.00000000;\n    offsets[1] = 1.41176471;\n    offsets[2] = 3.29411765;\n    offsets[3] = 5.17647059;\n    offsets[4] = 7.05882353;\n    \n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n    \n    vec3 color = vec3(0.0);\n    float weightSum = 0.0;\n    \n    if (uv.x < 0.52)\n    {\n        color += ColorFetch(uv) * weights[0];\n        weightSum += weights[0];\n\n        for(int i = 1; i < 5; i++)\n        {\n            vec2 offset = vec2(offsets[i]) \/ iResolution.xy;\n            color += ColorFetch(uv + offset * vec2(0.5, 0.0)) * weights[i];\n            color += ColorFetch(uv - offset * vec2(0.5, 0.0)) * weights[i];\n            weightSum += weights[i] * 2.0;\n        }\n\n        color \/= weightSum;\n    }\n\n    fragColor = vec4(color,1.0);\n}",
                "name": "Buf C",
                "description": "",
                "type": "buffer"
            },
            {
                "inputs": [
                    {
                        "id": "4sXGR8",
                        "filepath": "\/media\/previz\/buffer02.png",
                        "previewfilepath": "\/media\/previz\/buffer02.png",
                        "type": "buffer",
                        "channel": 0,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "XdfGR8",
                        "channel": 0
                    }
                ],
                "code": "\/\/Vertical gaussian blur leveraging hardware filtering for fewer texture lookups.\n\nvec3 ColorFetch(vec2 coord)\n{\n \treturn texture(iChannel0, coord).rgb;   \n}\n\nfloat weights[5];\nfloat offsets[5];\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    \n    weights[0] = 0.19638062;\n    weights[1] = 0.29675293;\n    weights[2] = 0.09442139;\n    weights[3] = 0.01037598;\n    weights[4] = 0.00025940;\n    \n    offsets[0] = 0.00000000;\n    offsets[1] = 1.41176471;\n    offsets[2] = 3.29411765;\n    offsets[3] = 5.17647059;\n    offsets[4] = 7.05882353;\n    \n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n    \n    vec3 color = vec3(0.0);\n    float weightSum = 0.0;\n    \n    if (uv.x < 0.52)\n    {\n        color += ColorFetch(uv) * weights[0];\n        weightSum += weights[0];\n\n        for(int i = 1; i < 5; i++)\n        {\n            vec2 offset = vec2(offsets[i]) \/ iResolution.xy;\n            color += ColorFetch(uv + offset * vec2(0.0, 0.5)) * weights[i];\n            color += ColorFetch(uv - offset * vec2(0.0, 0.5)) * weights[i];\n            weightSum += weights[i] * 2.0;\n        }\n\n        color \/= weightSum;\n    }\n\n    fragColor = vec4(color,1.0);\n}",
                "name": "Buf D",
                "description": "",
                "type": "buffer"
            }
        ]
    },
    {
        "ver": "0.1",
        "info": {
            "id": "ldScDh",
            "date": "1492933322",
            "viewed": 43906,
            "name": "Greek Temple",
            "username": "iq",
            "description": "A basic temple model. Terrain is false perspective. No global illumination. Two sun directions. Ambient occlusion is mostly painted by hand. Bounce lighting is also painted by hand. Live coded: [url]https:\/\/www.youtube.com\/watch?v=-pdSjBPH3zM[\/url]",
            "likes": 287,
            "published": 3,
            "flags": 32,
            "usePreview": 0,
            "tags": []
        },
        "renderpass": [
            {
                "inputs": [
                    {
                        "id": "4dXGR8",
                        "filepath": "\/media\/previz\/buffer00.png",
                        "previewfilepath": "\/media\/previz\/buffer00.png",
                        "type": "buffer",
                        "channel": 0,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "4dfGRr",
                        "channel": 0
                    }
                ],
                "code": "\/\/ Copyright Inigo Quilez, 2017 - https:\/\/iquilezles.org\/\n\/\/ I am the sole copyright owner of this Work.\n\/\/ You cannot host, display, distribute or share this Work in any form,\n\/\/ including physical and digital. You cannot use this Work in any\n\/\/ commercial or non-commercial product, website or project. You cannot\n\/\/ sell this Work and you cannot mint an NFTs of it.\n\/\/ I share this Work for educational purposes, and you can link to it,\n\/\/ through an URL, proper attribution and unmodified screenshot, as part\n\/\/ of your educational material. If these conditions are too restrictive\n\/\/ please contact me and we'll definitely work it out.\n\n\/\/ You can buy a metal print of this shader here:\n\/\/ https:\/\/www.redbubble.com\/i\/metal-print\/Greek-Temple-by-InigoQuilez\/39845587.0JXQP\n\n\/\/ A basic temple model. No global illumination, all cheated and composed to camera:\n\/\/\n\/\/ - the terrain is false perspective\n\/\/ - there are two different sun directions for foreground and background. \n\/\/ - ambient occlusion is mostly painted by hand\n\/\/ - bounce lighting is also painted by hand\n\/\/\n\/\/ This shader was made as a continuation to a live coding session I did for the students\n\/\/ of UPENN. After the initial live coded session I decided to rework it and improve it,\n\/\/ and that turned out to be a bit of a pain because when looking for the final look I got\n\/\/ trapped in more local minima that I usually do and it took me a while to leave them. \n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tivec2 p = ivec2(fragCoord-0.5);\n    \n    vec3 col = texelFetch( iChannel0, p, 0 ).xyz;\n    \n    vec2 q = fragCoord \/ iResolution.xy;\n    col *= 0.8 + 0.2*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.2 );\n\n    \n\tfragColor = vec4(col,1.0);\n}",
                "name": "Image",
                "description": "",
                "type": "image"
            },
            {
                "inputs": [
                    {
                        "id": "XdX3Rn",
                        "filepath": "\/media\/a\/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg",
                        "previewfilepath": "\/media\/ap\/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg",
                        "type": "texture",
                        "channel": 2,
                        "sampler": {
                            "filter": "mipmap",
                            "wrap": "repeat",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    },
                    {
                        "id": "Xsf3zn",
                        "filepath": "\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
                        "previewfilepath": "\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
                        "type": "texture",
                        "channel": 1,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "repeat",
                            "vflip": "false",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    },
                    {
                        "id": "Xsf3Rr",
                        "filepath": "\/media\/a\/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg",
                        "previewfilepath": "\/media\/ap\/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg",
                        "type": "texture",
                        "channel": 0,
                        "sampler": {
                            "filter": "mipmap",
                            "wrap": "repeat",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    },
                    {
                        "id": "4dXGR8",
                        "filepath": "\/media\/previz\/buffer00.png",
                        "previewfilepath": "\/media\/previz\/buffer00.png",
                        "type": "buffer",
                        "channel": 3,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "4dXGR8",
                        "channel": 0
                    }
                ],
                "code": "\/\/ Created by inigo quilez - iq\/2017\n\/\/ I share this piece (art and code) here in Shadertoy and through its Public API, only for educational purposes. \n\/\/ You cannot use, sell, share or host this piece or modifications of it as part of your own commercial or non-commercial product, website or project.\n\/\/ You can share a link to it or an unmodified screenshot of it provided you attribute \"by Inigo Quilez, @iquilezles and iquilezles.org\". \n\/\/ If you are a teacher, lecturer, educator or similar and these conditions are too restrictive for your needs, please contact me and we'll work it out.\n\n\n\/\/ A basic temple model\n\/\/\n\/\/ - the terrain is false perspective\n\/\/ - there are two different sun directions for foreground and background. \n\/\/ - ambient occlusion is mostly painted by hand\n\/\/ - bounce lighting is also painted by hand\n\/\/\n\/\/ This shader was made as a continuation to a live coding session I\n\/\/ did for the students of UPENN. Check it here:\n\/\/\n\/\/ https:\/\/www.youtube.com\/watch?v=-pdSjBPH3zM\n\n\n\n\/\/#define STATICCAM\n\nfloat hash1( vec2 p )\n{\n    p  = 50.0*fract( p*0.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat hash( uint n ) \n{\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    \/\/ floating point conversion from https:\/\/iquilezles.org\/articles\/sfrand\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\nvec2 hash2( float n ) { return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123)); }\n\nfloat noise( in vec2 p )\n{\n    ivec2 i = ivec2(floor(p));\n    vec2  f = fract(p);\n\tf = f*f*(3.0-2.0*f);\n\tfloat a = texelFetch( iChannel1, (i+ivec2(0,0))&255, 0 ).x;\n    float b = texelFetch( iChannel1, (i+ivec2(1,0))&255, 0 ).x;\n    float c = texelFetch( iChannel1, (i+ivec2(0,1))&255, 0 ).x;\n    float d = texelFetch( iChannel1, (i+ivec2(1,1))&255, 0 ).x;\n    return mix( mix(a,b,f.x), mix(c,d,f.x), f.y );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel1, (uv+0.5)\/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat fbm4( in vec3 p )\n{\n    float n = 0.0;\n    n += 1.000*noise( p*1.0 );\n    n += 0.500*noise( p*2.0 );\n    n += 0.250*noise( p*4.0 );\n    n += 0.125*noise( p*8.0 );\n    return n;\n}\n\nfloat fbm6( in vec3 p )\n{\n    float n = 0.0;\n    n += 1.00000*noise( p*1.0 );\n    n += 0.50000*noise( p*2.0 );\n    n += 0.25000*noise( p*4.0 );\n    n += 0.12500*noise( p*8.0 );\n    n += 0.06250*noise( p*16.0 );\n    n += 0.03125*noise( p*32.0 );\n    return n;\n}\n\nfloat fbm6( in vec2 p )\n{\n    float n = 0.0;\n    n += 1.00000*noise( p*1.0 );\n    n += 0.50000*noise( p*2.0 );\n    n += 0.25000*noise( p*4.0 );\n    n += 0.12500*noise( p*8.0 );\n    n += 0.06250*noise( p*16.0 );\n    n += 0.03125*noise( p*32.0 );\n    return n;\n}\n\nfloat fbm4( in vec2 p )\n{\n    float n = 0.0;\n    n += 1.00000*noise( p*1.0 );\n    n += 0.50000*noise( p*2.0 );\n    n += 0.25000*noise( p*4.0 );\n    n += 0.12500*noise( p*8.0 );\n    return n;\n}\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdRhombus( in vec2 p, in vec2 b, in float r ) \n{\n    vec2 q = abs(p);\n    float h = clamp( (-2.0*ndot(q,b) + ndot(b,b) )\/dot(b,b), -1.0, 1.0 );\n    float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\n    d *= sign( q.x*b.y + q.y*b.x - b.x*b.y );\n\treturn d - r;\n}\n\nfloat usdBox( in vec3 p, in vec3 b )\n{\n    return length( max(abs(p)-b,0.0 ) );\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdBox( float p, float b )\n{\n  return abs(p) - b;\n}\n\nvec2 opRepLim( in vec2 p, in float s, in vec2 lim )\n{\n    return p-s*clamp(round(p\/s),-lim,lim);\n}\n\nvec2 opRepLim( in vec2 p, in float s, in vec2 limmin, in vec2 limmax )\n{\n    return p-s*clamp(round(p\/s),-limmin,limmax);\n}\n\nvec4 textureGood( in sampler2D sam, in vec2 uv )\n{\n    ivec2 res = textureSize(sam,0).xy;\n    uv = uv*vec2(res) - 0.5;\n    ivec2 i = ivec2(floor(uv));\n    vec2  f = fract(uv);\n    f = f*f*(3.0-2.0*f);\n    vec4 a = texelFetch( sam, (i+ivec2(0,0))&(res-1), 0 );\n    vec4 b = texelFetch( sam, (i+ivec2(1,0))&(res-1), 0 );\n    vec4 c = texelFetch( sam, (i+ivec2(0,1))&(res-1), 0 );\n    vec4 d = texelFetch( sam, (i+ivec2(1,1))&(res-1), 0 );\n    return mix( mix(a,b,f.x), mix(c,d,f.x), f.y );\n}\n\n#define ZERO (min(iFrame,0))\n\n\/\/------------\n\nfloat terrain( in vec2 p )\n{\n    float h = 90.0*textureGood( iChannel2, p.yx*0.0001 + 0.35 + vec2(0.02,0.05) ).x - 70.0 + 5.0;\n    h = mix( h, -7.2, 1.0-smoothstep(16.0,60.0,length(p)));\n    h -= 7.0*textureGood( iChannel2, p*0.002 ).x;\n    float d = textureLod( iChannel0, p*0.01, 0.0 ).x;\n    h -= 1.0*d*d*d;\n    return h;\n}\n\nconst float ocean = -25.0;\n\nvec3 temple( in vec3 p )\n{\n    vec3 op = p;    \n    vec3 res = vec3(-1.0,-1.0,0.5);\n\n    p.y += 2.0;\n\n    \/\/ columns\n    vec3 q = p; q.xz = opRepLim( q.xz, 4.0, vec2(4.0,2.0) );\n    vec2 id = floor((p.xz+2.0)\/4.0);\n    float d = length(q.xz) - 0.9 + 0.05*p.y;\n    d = max(d,p.y-6.0);\n    d = max(d,-p.y-5.0);\n    d -= 0.05*pow(0.5+0.5*sin(atan(q.x,q.z)*16.0),2.0);\n    d -= 0.15*pow(0.5+0.5*sin(q.y*3.0+0.6),0.12) - 0.15;\n    res.z = hash1( id + 11.0*floor(0.25 + (q.y*3.0+0.6)\/6.2831) );\n    d *= 0.85;\n    vec3 w = vec3(q.x,abs(q.y-0.3)-5.5, q.z );\n    d = min( d,  sdBox(w,vec3(1.4,0.2,1.4)+sign(q.y-0.3)*vec3(0.1,0.05,0.1))-0.1 ); \/\/ base\n    d = max( d, -sdBox(p,vec3(14.0,10.0,6.0)) ); \/\/ clip in\n\n    \/\/ floor upper bounding plane\n    float bb1 = op.y+7.0;\n    if( bb1<d )\n    {\n    float ra = 0.15 * hash1(id+vec2(1.0,3.0));\n\tq = p; q.xz = opRepLim( q.xz, 4.0, vec2(4.0,3.0) );\n    float b = sdBox( q-vec3(0.0,-6.0+0.1-ra,0.0), vec3(2.0,0.5,2.0)-0.15-ra )-0.15;\n    b *= 0.5;\n    if( b<d ) { d = b; res.z = hash1(id); }\n    \n    p.xz -= 2.0;\n    id = floor((p.xz+2.0)\/4.0);\n    ra = 0.15 * hash1(id+vec2(1.0,3.0)+23.1);\n    q = p; q.xz = opRepLim( q.xz, 4.0, vec2(5.0,4.0), vec2(5.0,3.0) );\n\tb = sdBox( q-vec3(0.0,-7.0-ra,0.0), vec3(2.0,0.6,2.0)-0.15-ra )-0.15;\n    b *= 0.8;\n    if( b<d ) { d = b; res.z = hash1( id + 13.5 ); }\n    p.xz += 2.0;\n    \n    id = floor((p.xz+2.0)\/4.0);\n    ra = 0.15 * hash1(id+vec2(1.0,3.0)+37.7);\n    q = p; q.xz = opRepLim( q.xz, 4.0, vec2(5.0,4.0) );\n\tb = sdBox( q-vec3(0.0,-8.0-ra-1.0,0.0), vec3(2.0,0.6+1.0,2.0)-0.15-ra )-0.15;\n    b *= 0.5;\n    if( b<d ) { d = b; res.z = hash1( id*7.0 + 31.1 ); }\n    }\n\n\n    \/\/ roof lower bounding plane\n    float bb2 = -(op.y-4.0);\n    if( bb2<d )\n    {\n    q = vec3( mod(p.x+2.0,4.0)-2.0, p.y, mod(p.z+0.0,4.0)-2.0 );\n    float b = sdBox( q-vec3(0.0,7.0,0.0), vec3(1.95,1.0,1.95)-0.15 )-0.15;\n    b = max( b, sdBox(p-vec3(0.0,7.0,0.0),vec3(18.0,1.0,10.0)) );\n    if( b<d ) { d = b; res.z = hash1( floor((p.xz+vec2(2.0,0.0))\/4.0) + 31.1 ); }\n    \n    q = vec3( mod(p.x+0.5,1.0)-0.5, p.y, mod(p.z+0.5,1.0)-0.5 );\n    b = sdBox( q-vec3(0.0,8.0,0.0), vec3(0.45,0.5,0.45)-0.02 )-0.02;\n    b = max( b, sdBox(p-vec3(0.0,8.0,0.0),vec3(19.0,0.2,11.0)) );\n    if( b<d ) { d = b; res.z = hash1( floor((p.xz+0.5)\/1.0) + 7.8 ); }\n    \n    b = sdRhombus( p.yz-vec2(8.2,0.0), vec2(3.0,11.0), 0.05 ) ;\n    q = vec3( mod(p.x+1.0,2.0)-1.0, p.y, mod(p.z+1.0,2.0)-1.0 );\n    b = max( b, -sdBox( vec3( abs(p.x)-20.0,p.y,q.z)-vec3(0.0,8.0,0.0), vec3(2.0,5.0,0.1) )-0.02 );\n    \n    b = max( b, -p.y+8.2 );\n    b = max( b, usdBox(p-vec3(0.0,8.0,0.0),vec3(19.0,12.0,11.0)) );\n    float c = sdRhombus( p.yz-vec2(8.3,0.0), vec2(2.25,8.5), 0.05 );\n    c = max( c, sdBox(abs(p.x)-19.0,2.0) );\n    b = max( b, -c );    \n\n    d = min( d, b );\n    d = max( d,-sdBox(p-vec3(0.0,9.5,0.0),vec3(15.0,4.0,9.0)) );\n    }\n\n    if( d<0.1 )\n    {\n    d -= 0.02*smoothstep(0.5,1.0,fbm4( p.zxy ));\n    d -= 0.01*smoothstep(0.4,0.8,fbm4( op*3.0 ));\n    d += 0.005;\n    }\n    \n    return vec3( d, 1.0, res.z );\n}\n\nvec3 map( in vec3 p )\n{\n    vec3 res = vec3( p.y+25.0, 3.0, 0.0 );\n\n    float bb = p.y+6.0; \/\/ bounding plane for terrain\n    if( bb<res.x )\n    {\n        float h = terrain( p.xz );\n        float m = (p.y-h)*0.35;\n        if( m<res.x ) res=vec3( m, 2.0, 0.0 );\n    }\n\n    bb = usdBox(p-vec3(0.0,-1.0,0.0),vec3(22.0,11.0,20.0) ); \/\/ bounding box for temple\n    if( bb<res.x )\n    {\n        vec3 tmp = temple(p);\n        if( tmp.x<res.x ) res=tmp;\n    }\n    \n    return res;\n}\n\n\/\/ https:\/\/iquilezles.org\/articles\/normalsSDF\nvec3 calcNormal( in vec3 p, in float t )\n{\n#if 0    \n    float e = 0.001*t;\n\n    vec2 h = vec2(1.0,-1.0)*0.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e ).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e ).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e ).x );\n#else    \n    \/\/ inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*0.001*t).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n    vec2 ma = vec2(0.0);\n\n    vec3 res = vec3(-1.0);\n    \n    float tmax = 1000.0;\n\n    \/\/ bottom bounding plane\n    {\n    float tp = (ocean-ro.y)\/rd.y;\n    if( tp>0.0 ) { tmax = tp; res = vec3( tp, 3.0, 0.0 ); }\n    }\n    \/\/ top bounding plane\n    {\n    float tp = (10.0-ro.y)\/rd.y;\n    if( tp>0.0 ) { tmax = tp;  }\n    }\n        \n    float t = 10.0;\n    for( int i=0; i<256; i++ )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 h = map( pos );\n        ma = h.yz;\n        if( h.x<(0.0001*t) || t>tmax ) break;\n        t += h.x;\n    }\n\n    if( t<tmax )\n    {\n    \tres = vec3(t, ma);\n    }\n\n    return res;\n}\n\nvec4 textureBox( in sampler2D tex, in vec3 pos, in vec3 nor )\n{\n    vec4 cx = texture( tex, pos.yz );\n    vec4 cy = texture( tex, pos.xz );\n    vec4 cz = texture( tex, pos.xy );\n    vec3 m = nor*nor;\n    return (cx*m.x + cy*m.y + cz*m.z)\/(m.x+m.y+m.z);\n}\n\nfloat calcShadow( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n\n    float t = 0.01;\n    for( int i=0; i<128; i++ )\n    {\n        vec3 pos = ro + t*rd;\n        float h = map( pos ).x;\n        res = min( res, k*max(h,0.0)\/t );\n        if( res<0.0001 || pos.y>10.0) break;\n        t += clamp(h,0.01,5.0);\n    }\n\n    return res;\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor, float ra )\n{\n    float occ = 0.0;\n    for( int i=ZERO; i<32; i++ )\n    {\n        float h = 0.01 + 4.0*pow(float(i)\/31.0,2.0);\n        vec2 an = hash2( ra + float(i)*13.1 )*vec2( 3.14159, 6.2831 );\n        vec3 dir = vec3( sin(an.x)*sin(an.y), sin(an.x)*cos(an.y), cos(an.x) );\n        dir *= sign( dot(dir,nor) );\n        occ += clamp( 5.0*map( pos + h*dir ).x\/h, -1.0, 1.0);\n    }\n    return clamp( occ\/32.0, 0.0, 1.0 );\n}\n\nconst vec3 sunLig = normalize(vec3(0.7,0.1,0.4));\n\nvec3 skyColor( in vec3 ro, in vec3 rd )\n{\n    vec3 col = vec3(0.3,0.4,0.5)*0.3 - 0.3*rd.y;\n\n    float t = (1000.0-ro.y)\/rd.y;\n    if( t>0.0 )\n    {\n        vec2 uv = (ro+t*rd).xz;\n        float cl = texture( iChannel0, .000003*uv.yx ).x;\n        cl = smoothstep(0.3,0.7,cl);\n        col = mix( col, vec3(0.3,0.2,0.1), 0.1*cl );\n    }\n    \n    col = mix( col, vec3(0.2,0.25,0.30)*0.5, exp(-30.0*rd.y) ) ;\n    \n    float sd = pow( clamp( 0.25 + 0.75*dot(sunLig,rd), 0.0, 1.0 ), 4.0 );\n    col = mix( col, vec3(1.2,0.30,0.05)\/1.2, sd*exp(-abs((60.0-50.0*sd)*rd.y)) ) ;\n    \n    return col;\n}\n\nvec3 doBumpMap( in vec3 pos, in vec3 nor )\n{\n    float e = 0.002;\n    float b = 0.015;\n    \n\tfloat ref = fbm6( 4.0*pos );\n    vec3 gra = -b*vec3( fbm6(4.0*vec3(pos.x+e, pos.y, pos.z))-ref,\n                        fbm6(4.0*vec3(pos.x, pos.y+e, pos.z))-ref,\n                        fbm6(4.0*vec3(pos.x, pos.y, pos.z+e))-ref )\/e;\n\t\n\tvec3 tgrad = gra - nor * dot ( nor , gra );\n    return normalize( nor - tgrad );\n}\n\nvec3 doBumpMapGrass( in vec2 pos, in vec3 nor, out float hei )\n{\n    const float e = 0.002;\n    const float b = 0.03;\n    \n\tfloat ref = fbm6( 4.0*pos );\n    hei = ref;\n    \n    vec3 gra = -b*vec3( fbm6(4.0*vec2(pos.x+e, pos.y))-ref,\n                        e,\n                        fbm6(4.0*vec2(pos.x, pos.y+e))-ref )\/e;\n\t\n\tvec3 tgrad = gra - nor*dot( nor, gra );\n    return normalize( nor - tgrad );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float isThumbnail = step(iResolution.x,499.0);\n    \n    vec2 o = (1.0-isThumbnail)*(hash2( float(iFrame) ) - 0.5);\n    \n\tvec2 p = (-iResolution.xy + 2.0*(fragCoord+o)) \/ iResolution.y;\n    \n    uvec2 px = uvec2(fragCoord);\n    float ran = hash( px.x + 1920U*px.y + (1920U*1080U)*uint(iFrame*0) );    \n    \n    #ifdef STATICCAM\n    float an = -0.96;\n    #else\n    float an = -0.96 + sin(iTime*0.05)*0.1;\n    #endif\n    float ra = 70.0;\n    float fl = 3.0;\n    vec3 ta = vec3(0.0,-3.0,-23.0);\n    vec3 ro = ta + vec3(ra*sin(an),10.0,ra*cos(an));\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    vec3 rd = ca * normalize( vec3(p.xy,fl));\n    \n    \n    vec3 col = skyColor( ro, rd );\n    \n    float resT = 10000.0;\n    vec3 res = intersect( ro, rd );\n    if( res.y>0.0 )\n    {\n        float t = res.x;\n        resT = t;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, t );\n        \n        float fre = pow( clamp( 1.0+dot(nor,rd), 0.0, 1.0), 5.0 );\n\t\tfloat foc = 1.0;\n        \n        vec3 mate = vec3(0.2);\n        vec2 mspe = vec2(0.0);\n        float mbou = 0.0;\n        float mter = 0.0;\n        if( res.y<1.5 )\n        {\n            vec3 te = textureBox( iChannel0, pos*0.05, nor ).xyz;\n            mate = vec3(0.14,0.10,0.07) + 0.1*te;\n            mate *= 0.8 + 0.4*res.z;\n            mate *= 1.15;            \n            mspe = vec2(1.0,8.0);\n            mbou = 1.0;\n\n            nor = doBumpMap( pos, nor );\n            \n            foc = 0.7 + 0.3*smoothstep(0.4,0.7,fbm4( 3.0*pos ));\n\n            float ho = 1.0;\n            if( pos.y>-7.5 ) ho *= smoothstep( 0.0, 5.0, (pos.y+7.5)  );\n            ho = mix( 0.1+ho*0.3, 1.0, clamp( 0.6 + 0.4*dot( normalize(nor.xz*vec2(0.5,1.0)), normalize(pos.xz*vec2(0.5,1.0)) ) + 1.0*nor.y*nor.y, 0.0, 1.0 ) );\n            foc *= ho;\n            foc *= 0.4 + 0.6*smoothstep( 2.0, 15.0, length(pos*vec3(0.5,0.25,1.0)) );\n            float rdis = clamp( -0.15*max(sdRhombus( pos.yz-vec2(8.3,0.0)+vec2(2.0,0.0), vec2(2.25,8.5), 0.05 ),-(pos.y-8.3+2.0)), 0.0, 1.0 );\n            if( rdis>0.0001 ) foc = 0.1 + sqrt(rdis);\n\t\t\tif( pos.y<5.8 ) foc *= 0.6 + 0.4*smoothstep( 0.0, 1.5, -(pos.y-5.8) );\n            if( pos.y<3.4 ) foc *= 0.6 + 0.4*smoothstep( 0.0, 2.5, -(pos.y-3.4)  );\n\n            foc *= 0.8;            \n        }\n        else if( res.y<2.5 )\n        {\n            mate = vec3(0.95,0.9,0.85) * 0.4*texture( iChannel0, pos.xz*0.015 ).xyz;\n            mate *= 0.25 + 0.75*smoothstep( -25.0, -24.0, pos.y );\n            mate *= 0.32;            \n\t\t\tfloat h;\n            vec3 mor = doBumpMapGrass( pos.xz, nor, h );\n            mspe = vec2(2.5,4.0);\n            float is_grass = smoothstep( 0.9,0.95,mor.y);\n            \n            mate = mix( mate, vec3(0.15,0.1,0.0)*0.8*0.7 + h*h*h*vec3(0.12,0.1,0.05)*0.15, is_grass );\n            mspe = mix( mspe, vec2(0.5,4.0), is_grass );\n            nor = mor;\n            mter = 1.0;\n        }\n\t\telse\n        {\n            mate = vec3(0.1,0.21,0.25)*0.45;\n            mate += 2.0*vec3(0.01,0.03,0.03)*(1.0-smoothstep(0.0,10.0,pos.y-terrain(pos.xz)));\n            mate *= 0.4;            \n            float foam = (1.0-smoothstep(0.0,1.0,pos.y-terrain(pos.xz)));\n            foam *= smoothstep( 0.35,0.5,texture(iChannel0,pos.xz*0.07).x );\n            mate += vec3(0.08)*foam;\n            mspe = vec2(0.5,8.0);\n\n            vec2 e = vec2(0.01,0.0);\n            float ho = fbm4( (pos.xz     )*vec2(2.0,0.5) );\n            float hx = fbm4( (pos.xz+e.xy)*vec2(2.0,0.5) );\n            float hy = fbm4( (pos.xz+e.yx)*vec2(2.0,0.5) );\n            float sm = (1.0-smoothstep(0.0,4.0,pos.y-terrain(pos.xz)));\n            sm *= 0.02 + 0.03*foam;\n            ho *= sm;\n            hx *= sm;\n            hy *= sm;\n                \n            nor = normalize( vec3(ho-hx,e.x,ho-hy) );\n        }\n\n        float occ = 0.33 + 0.5*nor.y;\n        occ = calcOcclusion(pos,nor,ran) * foc;\n        \n        float lf = 1.0 - smoothstep( 30.0,80.0,length(pos.z));\n        vec3 lig = normalize( vec3(sunLig.x,sunLig.y+0.245*lf,sunLig.z) );\n        vec3 ligbak = normalize(vec3(-lig.x,0.0,-lig.z));\n        float dif = dot( nor, lig );\n        float sha = 1.0; if( dif>0.0 ) sha=calcShadow( pos+nor*0.001, lig, 32.0 );\n              dif = clamp(dif*sha,0.0,1.0);\n        float amb = (0.8 + 0.2*nor.y);\n              amb = mix( amb, amb*(0.5+0.5*smoothstep( -8.0,-1.0,pos.y)), mbou );\n\n        vec3 qos = pos\/1.5 - vec3(0.0,1.0,0.0);\n\n        float bak = clamp( 0.4+0.6*dot( nor, ligbak ), 0.0, 1.0 );\n              bak *= 0.6 + 0.4*smoothstep( -8.0,-1.0,qos.y);\n        \n        float bou = 0.3*clamp( 0.7-0.3*nor.y, 0.0, 1.0 );\n              bou *= smoothstep( 8.0,0.0,qos.y+6.0)*smoothstep(-6.7,-6.4,qos.y);\n              bou *= (0.7*smoothstep( 3.0,1.0,length( (qos.xz-vec2(1.0,6.0))*vec2(0.2,1.0)) )+\n                          smoothstep( 5.0,1.0,length( (qos.xz-vec2(5.0,-3.0))*vec2(0.4,1.0)) ));\n              bou +=  0.1*smoothstep( 5.0,1.0,length( (qos-vec3(-5.0,0.0,-5.0))*vec3(0.7,0.8,1.5)) );\n        \n        vec3 hal = normalize( lig -rd );\n        float spe = pow( clamp( dot(nor,hal), 0.0, 1.0), mspe.y )*(0.1+0.9*fre)*sha*(0.5+0.5*occ);\n\n        col = vec3(0.0);\n        col += amb*1.0*vec3(0.15,0.25,0.35)*occ*(1.0+mter);\n        col += dif*5.0*vec3(0.90,0.55,0.35);\n        col += bak*1.7*vec3(0.10,0.11,0.12)*occ*mbou;\n        col += bou*3.0*vec3(1.00,0.50,0.15)*occ*mbou;\n        col += spe*6.0*mspe.x*occ;\n        \n        col *= mate;\n\n        vec3 fogcol = vec3(0.1,0.125,0.15);\n        float sd = pow( clamp( 0.25 + 0.75*dot(lig,rd), 0.0, 1.0 ), 4.0 );\n\t    fogcol = mix( fogcol, vec3(1.0,0.25,0.042), sd*exp(-abs((60.0-50.0*sd)*abs(rd.y))) ) ;\n\n        float fog = 1.0 - exp(-0.0013*t);\n        col *= 1.0-0.5*fog;\n        col = mix( col, fogcol, fog );\n    }\n\n    col = max( col, 0.0 );\n    \n    col += 0.15*vec3(1.0,0.8,0.7)*pow( clamp( dot(rd,sunLig), 0.0, 1.0 ), 6.0 );\n\n    col = 1.2*col\/(1.0+col);\n    \n    col = sqrt( col );\n\n    col = clamp( 1.9*col-0.1, 0.0, 1.0 );\n    col = col*0.1 + 0.9*col*col*(3.0-2.0*col);\n    col = pow( col, vec3(0.76,0.98,1.0) );    \n    \n    \/\/------------------------------------------\n\t\/\/ reproject from previous frame and average\n    \/\/------------------------------------------\n\t#ifdef STATICCAM\n        vec3 ocol = texelFetch( iChannel3, ivec2(fragCoord-0.5), 0 ).xyz;\n        if( iFrame==0 ) ocol = col;\n        col = mix( ocol, col, 0.05 );\n        fragColor = vec4( col, 1.0 );\n    #else\n        mat4 oldCam = mat4( texelFetch(iChannel3,ivec2(0,0),0),\n                            texelFetch(iChannel3,ivec2(1,0),0),\n                            texelFetch(iChannel3,ivec2(2,0),0),\n                            0.0, 0.0, 0.0, 1.0 );\n\n        \/\/ world space\n        vec4 wpos = vec4(ro + rd*resT,1.0);\n        \/\/ camera space\n        vec3 cpos = (wpos*oldCam).xyz; \/\/ note inverse multiply\n        \/\/ ndc space\n        vec2 npos = fl * cpos.xy \/ cpos.z;\n        \/\/ screen space\n        vec2 spos = 0.5 + 0.5*npos*vec2(iResolution.y\/iResolution.x,1.0);\n        \/\/ undo dither\n        spos -= o\/iResolution.xy;\n        \/\/ raster space\n        vec2 rpos = spos * iResolution.xy;\n\n        if( (rpos.y<1.0 && rpos.x<3.0) || (isThumbnail>0.5)  )\n        {\n        }\n        else\n        {\n            vec4 data = textureLod( iChannel3, spos, 0.0 );\n            vec3 ocol = data.xyz;\n            float dt = abs(data.w - resT)\/resT;\n            if( iFrame==0 ) ocol = col;\n            col = mix( ocol, col, 0.1 + 0.5*smoothstep(0.1,0.2,dt) );\n        }\n\n        if( fragCoord.y<1.0 && fragCoord.x<3.0 )\n        {\n            if( abs(fragCoord.x-2.5)<0.5 ) fragColor = vec4( ca[2], -dot(ca[2],ro) );\n            if( abs(fragCoord.x-1.5)<0.5 ) fragColor = vec4( ca[1], -dot(ca[1],ro) );\n            if( abs(fragCoord.x-0.5)<0.5 ) fragColor = vec4( ca[0], -dot(ca[0],ro) );\n        }\n        else\n        {\n            fragColor = vec4( col, resT );\n        }\n    #endif\n}",
                "name": "Buffer A",
                "description": "",
                "type": "buffer"
            }
        ]
    },
    {
        "ver": "0.1",
        "info": {
            "id": "4tByz3",
            "date": "1511132429",
            "viewed": 57020,
            "name": "Ladybug",
            "username": "iq",
            "description": "A ladybug on a mushroom. It renders really slowly. Sorry for that, this is not meant to be rendered with raymarching really, but well, here we are. I'll get a pass later",
            "likes": 263,
            "published": 3,
            "flags": 32,
            "usePreview": 0,
            "tags": []
        },
        "renderpass": [
            {
                "inputs": [
                    {
                        "id": "4dXGR8",
                        "filepath": "\/media\/previz\/buffer00.png",
                        "previewfilepath": "\/media\/previz\/buffer00.png",
                        "type": "buffer",
                        "channel": 0,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "4dfGRr",
                        "channel": 0
                    }
                ],
                "code": "\/\/ Copyright Inigo Quilez, 2017 - https:\/\/iquilezles.org\/\n\/\/ I am the sole copyright owner of this Work.\n\/\/ You cannot host, display, distribute or share this Work in any form,\n\/\/ including physical and digital. You cannot use this Work in any\n\/\/ commercial or non-commercial product, website or project. You cannot\n\/\/ sell this Work and you cannot mint an NFTs of it.\n\/\/ I share this Work for educational purposes, and you can link to it,\n\/\/ through an URL, proper attribution and unmodified screenshot, as part\n\/\/ of your educational material. If these conditions are too restrictive\n\/\/ please contact me and we'll definitely work it out.\n\n\/\/ You can buy a metal print of this shader here:\n\/\/ https:\/\/www.redbubble.com\/i\/metal-print\/Ladybug-by-InigoQuilez\/39845563.0JXQP\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord \/ iResolution.xy;\n    \n    \n    \/\/ dof\n    const float focus = 2.35;\n\n    vec4 acc = vec4(0.0);\n    const int N = 12;\n\tfor( int j=-N; j<=N; j++ )\n    for( int i=-N; i<=N; i++ )\n    {\n        vec2 off = vec2(float(i),float(j));\n        \n        vec4 tmp = texture( iChannel0, q + off\/vec2(800.0,450.0) ); \n        \n        float depth = tmp.w;\n        \n        vec3  color = tmp.xyz;\n        \n        float coc = 0.05 + 12.0*abs(depth-focus)\/depth;\n        \n        if( dot(off,off) < (coc*coc) )\n        {\n            float w = 1.0\/(coc*coc); \n            acc += vec4(color*w,w);\n        }\n    }\n    \n    vec3 col = acc.xyz \/ acc.w;\n\n    \n    \/\/ gamma\n    col = pow( col, vec3(0.4545) );\n    \n    \/\/ color correct - it seems my laptop has a fucked up contrast\/gamma seeting, so I need\n    \/\/                 to do this for the picture to look okey in all computers but mine...\n    col = col*1.1 - 0.06;\n    \n    \/\/ vignetting\n    col *= 0.8 + 0.3*sqrt( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y) );\n\n    fragColor = vec4(col,1.0);\n}",
                "name": "Image",
                "description": "",
                "type": "image"
            },
            {
                "inputs": [
                    {
                        "id": "XsX3Rn",
                        "filepath": "\/media\/a\/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg",
                        "previewfilepath": "\/media\/ap\/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg",
                        "type": "texture",
                        "channel": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "wrap": "repeat",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "4dXGR8",
                        "channel": 0
                    }
                ],
                "code": "\/\/ Created by inigo quilez - iq\/2017\n\/\/ I share this piece (art and code) here in Shadertoy and through its Public API, only for educational purposes. \n\/\/ You cannot use, sell, share or host this piece or modifications of it as part of your own commercial or non-commercial product, website or project.\n\/\/ You can share a link to it or an unmodified screenshot of it provided you attribute \"by Inigo Quilez, @iquilezles and iquilezles.org\". \n\/\/ If you are a teacher, lecturer, educator or similar and these conditions are too restrictive for your needs, please contact me and we'll work it out.\n\n\n#define MAT_MUSH_HEAD 1.0\n#define MAT_MUSH_NECK 2.0\n#define MAT_LADY_BODY 3.0\n#define MAT_LADY_HEAD 4.0\n#define MAT_LADY_LEGS 5.0\n#define MAT_GRASS     6.0\n#define MAT_GROUND    7.0\n#define MAT_MOSS      8.0\n#define MAT_CITA      9.0\n\nvec2  hash2( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*18.5453); }\nvec3  hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(338.5453123,278.1459123,191.1234)); }\nfloat dot2(in vec2 p ) { return dot(p,p); }\nfloat dot2(in vec3 p ) { return dot(p,p); }\n\nvec2 sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n    return vec2( length(pa-h*ba), h );\n}\nvec2 sdLine( in vec3 p, in vec3 a, in vec3 b )\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n    return vec2( length(pa-h*ba), h );\n}\nvec2 sdLineOri( in vec3 p, in vec3 b )\n{\n    float h = clamp( dot(p,b)\/dot(b,b), 0.0, 1.0 );\n    \n    return vec2( length(p-h*b), h );\n}\nvec2 sdLineOriY( in vec3 p, in float b )\n{\n    float h = clamp( p.y\/b, 0.0, 1.0 );\n    p.y -= b*h;\n    return vec2( length(p), h );\n}\nfloat sdEllipsoid( in vec3 pos, in vec3 cen, in vec3 rad )\n{\n    vec3 p = pos - cen;\n    float k0 = length(p\/rad);\n    float k1 = length(p\/(rad*rad));\n    return k0*(k0-1.0)\/k1;\n}\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25\/k;\n}\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25\/k;\n}\nvec3 rotateX( in vec3 p, float t )\n{\n    float co = cos(t);\n    float si = sin(t);\n    p.yz = mat2(co,-si,si,co)*p.yz;\n    return p;\n}\nvec3 rotateY( in vec3 p, float t )\n{\n    float co = cos(t);\n    float si = sin(t);\n    p.xz = mat2(co,-si,si,co)*p.xz;\n    return p;\n}\nvec3 rotateZ( in vec3 p, float t )\n{\n    float co = cos(t);\n    float si = sin(t);\n    p.xy = mat2(co,-si,si,co)*p.xy;\n    return p;\n}\n\n\/\/==================================================\n\n#define ZERO (min(iFrame,0))\n\n\/\/==================================================\n\nvec3 mapLadyBug( vec3 p )\n{\n    float dBody = sdEllipsoid( p, vec3(0.0), vec3(0.8, 0.75, 1.0) );\n    dBody = smax( dBody, -sdEllipsoid( p, vec3(0.0,-0.1,0.0), vec3(0.75, 0.7, 0.95) ), 0.05 );\n    dBody = smax( dBody, -sdEllipsoid( p, vec3(0.0,0.0,0.8), vec3(0.35, 0.35, 0.5) ), 0.05 );\n  \tdBody = smax( dBody, sdEllipsoid( p, vec3(0.0,1.7,-0.1), vec3(2.0, 2.0, 2.0) ), 0.05 );\n  \tdBody = smax( dBody, -abs(p.x)+0.005, 0.02 + 0.1*clamp(p.z*p.z*p.z*p.z,0.0,1.0) );\n\n    vec3 res = vec3( dBody, MAT_LADY_BODY, 0.0 );\n\n    \/\/ --------\n    vec3 hc = vec3(0.0,0.1,0.8);\n    vec3 ph = rotateX(p-hc,0.5);\n    float dHead = sdEllipsoid( ph, vec3(0.0,0.0,0.0), vec3(0.35, 0.25, 0.3) );\n    dHead = smax( dHead, -sdEllipsoid( ph, vec3(0.0,-0.95,0.0), vec3(1.0) ), 0.03 );\n    dHead = min( dHead, sdEllipsoid( ph, vec3(0.0,0.1,0.3), vec3(0.15,0.08,0.15) ) );\n\n    if( dHead < res.x ) res = vec3( dHead, MAT_LADY_HEAD, 0.0 );\n    \n    res.x += 0.0007*sin(150.0*p.x)*sin(150.0*p.z)*sin(150.0*p.y); \/\/ iqiq\n\n    \/\/ -------------\n    \n    vec3 k1 = vec3(0.42,-0.05,0.92);\n    vec3 k2 = vec3(0.49,-0.2,1.05);\n    float dLegs = 10.0;\n\n    float sx = sign(p.x);\n    p.x = abs(p.x);\n    for( int k=0; k<3; k++ )\n    {   \n        vec3 q = p;\n        q.y -= min(sx,0.0)*0.1;\n        if( k==0) q += vec3( 0.0,0.11,0.0);\n        if( k==1) q += vec3(-0.3,0.1,0.2);\n        if( k==2) q += vec3(-0.3,0.1,0.6);\n        \n        vec2 se = sdLine( q, vec3(0.3,0.1,0.8), k1 );\n        se.x -= 0.015 + 0.15*se.y*se.y*(1.0-se.y);\n        dLegs = min(dLegs,se.x);\n\n        se = sdLine( q, k1, k2 );\n        se.x -= 0.01 + 0.01*se.y;\n        dLegs = min(dLegs,se.x);\n\n        se = sdLine( q, k2, k2 + vec3(0.1,0.0,0.1) );\n        se.x -= 0.02 - 0.01*se.y;\n        dLegs = min(dLegs,se.x);\n    }\n    \n    if( dLegs<res.x ) res = vec3(dLegs,MAT_LADY_LEGS, 0.0);\n\n\n    return res;\n}\n\nvec3 worldToMushrom( in vec3 pos )\n{\n    vec3 qos = pos;\n    qos.xy = (mat2(60,11,-11,60)\/61.0) * qos.xy;\n    qos.y += 0.03*sin(3.0*qos.z - 2.0*sin(3.0*qos.x));\n    qos.y -= 0.4;\n    return qos;\n}\n\nvec3 mapMushroom( in vec3 pos )\n{\n    vec3 res;\n\n    vec3 qos = worldToMushrom(pos);\n\n    {\n        \/\/ head\n        float d1 = sdEllipsoid( qos, vec3(0.0, 1.4,0.0), vec3(0.8,1.0,0.8) );\n\n        \/\/ displacement\n        float f;\n        vec3 tos = qos*0.5;\n        f  = 1.00*(sin( 63.0*tos.x+sin( 23.0*tos.z)));\n        f += 0.50*(sin(113.0*tos.z+sin( 41.0*tos.x)));\n        f += 0.25*(sin(233.0*tos.x+sin(111.0*tos.z)));\n        f = 0.5*(f + f*f*f);\n        d1 -= 0.0005*f - 0.01;\n\n        \/\/ cut the lower half\n        float d2 = sdEllipsoid( qos, vec3(0.0, 0.5,0.0), vec3(1.3,1.2,1.3) );\n        float d = smax( d1, -d2, 0.1 );\n        res = vec3( d, MAT_MUSH_HEAD, 0.0 );\n    }\n\n\n    {\n        \/\/ stem\n        pos.x += 0.3*sin(pos.y) - 0.65;\n        float pa = sin( 20.0*atan(pos.z,pos.x) );\n        vec2 se = sdLine( pos, vec3(0.0,2.0,0.0), vec3(0.0,0.0,0.0) );\n        float tt = 0.25 - 0.1*4.0*se.y*(1.0-se.y);\n        float d3 = se.x - tt;\n        \n        \/\/ skirt\n        vec2 ros = vec2(length(pos.xz),pos.y);\n        se = sdLine( ros, vec2(0.0,1.9), vec2(0.31,1.5) );\n        float d4 = se.x - 0.02;\/\/*(1.0-se.y);\n        d3 = smin( d3, d4, 0.05);\n\n        d3 += 0.003*pa;\n        d3 *= 0.7;\n\n        if( d3<res.x )\n            res = vec3( d3, MAT_MUSH_NECK, 0.0 );\n    }\n\n    return res;\n}\n\nvec3 mapGrass( in vec3 pos, float h )\n{\n    vec3 res = vec3(1e20,0.0,0.0);\n    \n    const float gf = 4.0;\n\n    vec3 qos = pos * gf;\n\n    vec2 n = floor( qos.xz );\n    vec2 f = fract( qos.xz );\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2  g = vec2( float(i), float(j) );\n\n        vec2 ra2 = hash2( n + g + vec2(31.0,57.0) );\n\n        if( ra2.x<0.73 ) continue;\n\n        vec2  o = hash2( n + g );\n        vec2  r = g - f + o;\n        vec2 ra = hash2( n + g + vec2(11.0,37.0) );\n\n        float gh = 2.0*(0.3+0.7*ra.x);\n\n        float rosy = qos.y - h*gf;\n\n        r.xy = reflect( r.xy, normalize(-1.0+2.0*ra) );\n        r.x -= 0.03*rosy*rosy;\n        \n        r.x *= 4.0;\n        float mo = 0.1*sin( 2.0*iTime + 20.0*ra.y )*(0.2+0.8*ra.x);\n        vec2 se = sdLineOri( vec3(r.x,rosy,r.y), vec3(4.0 + mo,gh*gf,mo) );\n        float gr = 0.3*sqrt(1.0-0.99*se.y);\n        float d = se.x - gr;\n        d \/= 4.0;\n\n        d \/= gf;\n        if( d<res.x )\n        {\n            res.x = d;\n            res.y = MAT_GRASS;\n            res.z = r.y;\n        }\n    }\n    \n    return res;\n}\n\nvec3 mapCrapInTheAir( in vec3 pos)\n{\n    ivec2 id = ivec2(floor((pos.xz+2.0)\/4.0));\n    pos.xz = mod(pos.xz+2.0,4.0)-2.0;\n    float dm = 1e10;\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 o = vec3(0.0,3.2,0.0);\n        o += vec3(1.7,1.50,1.7)*(-1.0 + 2.0*hash3(float(i)));\n        o += vec3(0.3,0.15,0.3)*sin(0.3*iTime + vec3(float(i+id.y),float(i+3+id.x),float(i*2+1+2*id.x)));\n        float d = dot2(pos - o);\n        dm = min(d,dm);\n    }\n    dm = sqrt(dm)-0.02;\n    \n    return vec3( dm, MAT_CITA, 0.0);\n}\n\nvec3 mapMoss( in vec3 pos, float h)\n{\n    vec3 res = vec3(1e20,0.0,0.0);\n\n    const float gf = 2.0;\n    \n    vec3 qos = pos * gf;\n    vec2 n = floor( qos.xz );\n    vec2 f = fract( qos.xz );\n\n    for( int k=ZERO; k<2; k++ )\n    {\n        for( int j=-1; j<=1; j++ )\n        for( int i=-1; i<=1; i++ )\n        {\n            vec2  g = vec2( float(i), float(j) );\n            vec2  o = hash2( n + g + vec2(float(k),float(k*5)));\n            vec2  r = g - f + o;\n\n            vec2 ra  = hash2( n + g + vec2(11.0, 37.0) + float(2*k) );\n            vec2 ra2 = hash2( n + g + vec2(41.0,137.0) + float(3*k) );\n\n            float mh = 0.5 + 1.0*ra2.y;\n            vec3 ros = qos - vec3(0.0,h*gf,0.0);\n\n            vec3 rr = vec3(r.x,ros.y,r.y);\n\n            rr.xz = reflect( rr.xz, normalize(-1.0+2.0*ra) );\n\n            rr.xz += 0.5*(-1.0+2.0*ra2);\n            vec2 se  = sdLineOriY( rr, gf*mh );\n            float sey = se.y;\n            float d = se.x - 0.05*(2.0-smoothstep(0.0,0.1,abs(se.y-0.9)));\n\n            vec3 pp = vec3(rr.x,mod(rr.y+0.2*0.0,0.4)-0.2*0.0,rr.z);\n\n            float an = mod( 21.0*floor( (rr.y+0.2*0.0)\/0.4 ), 1.57 );\n            float cc = cos(an);\n            float ss = sin(an);\n            pp.xz = mat2(cc,ss,-ss,cc)*pp.xz;\n\n            pp.xz = abs(pp.xz);\n            vec3 ppp = (pp.z>pp.x) ? pp.zyx : pp; \n            vec2 se2 = sdLineOri( ppp, vec3( 0.4,0.3,0.0) );\n            vec2 se3 = sdLineOri( pp,  vec3( 0.2,0.3,0.2) ); if( se3.x<se2.x ) se2 = se3;\n            float d2 = se2.x - (0.02 + 0.03*se2.y);\n\n            d2 = max( d2, (rr.y-0.83*gf*mh) );\n            d = smin( d, d2, 0.05 );\n\n            d \/= gf;\n            d *= 0.9;\n            if( d<res.x )\n            {\n                res.x = d;\n                res.y = MAT_MOSS;\n                res.z = clamp(length(rr.xz)*4.0+rr.y*0.2,0.0,1.0);\n                float e = clamp((pos.y - h)\/1.0,0.0,1.0);\n                res.z *= 0.02 + 0.98*e*e;\n                \n                if( ra.y>0.85 && abs(se.y-0.95)<0.1 ) res.z = -res.z;\n            }\n        }\n    }\n    \n    return res;\n}\n\nvec3 worldToLadyBug( in vec3 p )\n{\n    \/\/ TODO: combine all of the above in a single 4x4 matrix\n    p = 4.0*(p - vec3(-0.0,3.2-0.6,-0.57));\n    p = rotateY( rotateZ( rotateX( p, -0.92 ), 0.49), 3.5 );\n    p.y += 0.2;\n    return p;\n}\n\nconst vec3 mushroomPos1 = vec3( 0.0,0.1,0.0);\nconst vec3 mushroomPos2 = vec3(-3.0,0.0,3.0);\n\nfloat terrain( in vec2 pos )\n{\n    return 0.3 - 0.3*sin(pos.x*0.5 - sin(pos.y*0.5));\n}\n\nvec3 mapShadow( in vec3 pos )\n{\n    \/\/ terrain\n    float h = terrain( pos.xz );\n    float d = pos.y - h;\n    vec3 res = vec3( d, MAT_GROUND, 0.0 );\n    \n    \/\/ mushrooms\n    {\n      \/\/ intancing\n      vec3 m1 =  pos - mushroomPos1;\n      vec3 m2 = (pos - mushroomPos2).zyx;\n      if( dot2(m2.xz) < dot2(m1.xz) ) m1 = m2;\n    \n      \/\/ bounding volume\n      float bb = sdLine( m1, vec3(0.2,0.0,0.0), vec3(0.36,2.0,0.0) ).x-0.8;\n      if( bb<res.x ) \n      {\n\t  vec3 tmp = mapMushroom(m1);\n      if( tmp.x<res.x ) res = tmp;\n      }\n    }\n    \n    \/\/ ladybug\n    {\n      vec3 q = worldToLadyBug(pos);\n      if( (length(q)-1.5)\/4.0<res.x ) \/\/ bounding volume\n      {\n      vec3 tmp = mapLadyBug(q); tmp.x\/=4.0;\n      if( tmp.x<res.x ) res = tmp;\n      }\n    }\n    \n    \/\/ grass\n    {\n      if( pos.y-2.5<res.x ) \/\/ bounding volume\n      {\n      vec3 tmp = mapGrass(pos,h);\n      if( tmp.x<res.x ) res=tmp;\n      }\n    }\n    \n    \/\/ moss\n    {\n      if( pos.y-1.9<res.x ) \/\/ bounding volume\n      {\n      vec3 tmp = mapMoss(pos,h);\n      if( tmp.x<res.x ) res=tmp;\n      }\n    }\n    \n    return res;\n}\n\nvec3 map( in vec3 pos )\n{\n    vec3 res = mapShadow(pos);\n        \n    vec3 tmp = mapCrapInTheAir(pos);\n    if( tmp.x<res.x ) res=tmp;\n\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n#if 0    \n    vec2 e = vec2(0.002,0.0); \n    return normalize( vec3( map(pos+e.xyy).x - map(pos-e.xyy).x,\n                            map(pos+e.yxy).x - map(pos-e.yxy).x,\n                            map(pos+e.yyx).x - map(pos-e.yyx).x ) );\n#else\n    \/\/ inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+e*0.002).x;\n    }\n    return normalize(n);\n#endif    \n}\n    \nfloat calcShadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.01;\n    for( int i=ZERO; i<100; i++ )\n    {\n        vec3 pos = ro + rd*t;\n        float h = mapShadow( pos ).x;\n        res = min( res, 16.0*max(h,0.0)\/t );\n        if( h<0.0001 || pos.y>3.0 ) break;\n        \n        t += clamp(h,0.01,0.1);\n    }\n    \n    return clamp(res,0.0,1.0);\n}\n\nvec3 raycast( in vec3 ro, in vec3 rd )\n{\n    const float tmax = 12.0;\n    \n\tvec3 res = vec3(1.0,-1.0, 0.0);\n\n    for( int i=ZERO; i<256; i++ )\n    {\n        vec3 h = map( ro + rd*res.x );\n        if( h.x<(0.00015*res.x) || res.x>tmax )\n            break;\n        res.x += h.x;\n        res.y = h.y;\n        res.z = h.z;\n    }\n    \n    if( res.x>=tmax ) res.y = -1.0;\n    \n    return res;\n}\n\nvoid materials( in float matID, in float matID2, in vec3 pos, in vec3 nor,\n                out vec3 matColor, out float matRough,\n                out vec3 matNor, out float matOcc, out float matSSS, out float matRefOcc, out vec3 matGamma )\n{\n    matNor = nor;\n    matOcc = 1.0;\n    matSSS = 0.0;\n    matRough = 1.0;\n    matRefOcc = 1.0;\n    matGamma = vec3(1.0);\n    \n    if( matID<MAT_MUSH_HEAD+0.5 )\n    {\n        vec3 m1 =  pos - mushroomPos1;\n    \tvec3 m2 = (pos - mushroomPos2).zyx;\n    \tif( dot2(m2.xz) < dot2(m1.xz) ) m1 = m2;\n\n        vec3 qos = worldToMushrom( m1 );\n\n        matColor = vec3(0.26,0.21,0.15);\n        matColor -= 0.2*smoothstep(0.4,0.9,texture( iChannel1, 0.8*qos.xz ).x);\n        matColor = mix( vec3(0.35,0.35,0.35 ), matColor, smoothstep(1.5,2.4,qos.y) );\n        matColor = mix( vec3(0.05,0.02,0.01 ), matColor, smoothstep(1.5,1.65,qos.y) );\n        matColor -= 0.2*texture( iChannel1, 0.1*qos.xz ).zyx;\n        matColor *= 0.4*0.45;\n        matColor = max( matColor, 0.0 );\n        \n        matColor += matColor*vec3(0.3,0.6,0.0)*(1.0-smoothstep( 0.8, 1.4, length(m1-vec3(0.5,1.1,-0.3)) ));\n        \n        matRough = 0.6;\n        matSSS = 1.0;\n        matOcc = smoothstep( 0.4,1.5,length(worldToLadyBug( pos ).xz) );\n        matRefOcc = matOcc;\n        matGamma = vec3(0.75,0.87,1.0);\n    }\n    else if( matID<MAT_MUSH_NECK+0.5 )\n    {\n        vec2 uv = vec2( pos.y*0.5, atan(pos.x,pos.z)*(3.0\/3.14159) );\n\n        matColor = vec3(0.42,0.35,0.15);\n        \n        float pa = smoothstep(0.3,0.8,pos.y);\n\n        matColor -= pa*0.2*texture( iChannel1, 0.5*uv ).xxx;\n        matColor = max(vec3(0.0),matColor);\n        \n        matColor *= 0.22;\n        matColor = clamp( matColor, 0.0, 1.0 );\n        \n        matRough = 0.7;\n        matSSS = 1.0;\n        \n        matOcc = clamp( (pos.y-0.5)\/1.3,0.0,1.0);\n        matOcc = matOcc*matOcc;\n        matOcc *= clamp( 1.0-(pos.y-1.2)\/1.2,0.0,1.0);\n        matOcc = matOcc*0.5 + 0.5*matOcc*matOcc;\n        matRefOcc = matOcc;\n        matGamma = vec3(0.75,0.95,1.0);\n    }\n    else if( matID<MAT_LADY_BODY+.5 )\n    {\n        vec3 qos = worldToLadyBug( pos );\n            \n        \/\/ red\n        matColor = vec3(0.16,0.008,0.0);\n\n        float f = texture( iChannel1, 0.1*qos.xz ).x;\n        matColor = mix( matColor, vec3(0.15,0.07,0.0), f*f );\n        \n        qos.x = abs(qos.x);\n        vec2 uv = vec2( atan(qos.x,qos.y), 1.57*qos.z )*0.1;\n\n        \/\/ white\n        float p = length( (qos.xz-vec2(0.0,0.9))*vec2(0.5,1.0));\n        matColor = mix( matColor, vec3(1.0,0.8,0.6)*0.6, 1.0-smoothstep(0.09,0.14,p) );\n\n        \/\/ black\n        p = cos(uv.x*40.0)*cos(uv.y*40.0+1.57);\n        matColor *= 1.0-smoothstep( 0.35, 0.45, p );\n        \n        f = texture( iChannel1, qos.xz*vec2(0.8,0.1) ).x;\n        matColor *= 1.0 - 0.5*f;\n        f = texture( iChannel1, 4.0*qos.xz ).x;\n        matColor *= 1.0 - 0.99*f*f;\n        \n        matColor *= 1.3;\n        matRough = 0.15;\n        matOcc = 0.6 + 0.4*smoothstep( 0.0,0.3,qos.y );\n        matRefOcc = 0.2 + 0.8*smoothstep( 0.0,0.35,qos.y );\n    }\n    else if( matID<MAT_LADY_HEAD+.5 )\n    {\n        vec3 qos = worldToLadyBug( pos );\n\n        matColor = vec3(0.001);\n\n        qos.z += -0.22;\n        qos.y += -0.7;\n        float p = cos(12.0*qos.z)*cos(5.0*qos.y);\n        p += .1*cos(48.0*qos.z)*cos(20.0*qos.y);\n        matColor = mix( matColor, vec3(1.0,0.9,0.8)*0.8, smoothstep(0.8,1.0,p) );\n        matRough = 0.2;\n        matRefOcc = matOcc;\n    }\n    else if( matID<MAT_LADY_LEGS+.5 )\n    {\n        matColor = vec3(0.0,0.0,0.0);\n        matRough = 0.8;\n        matRefOcc = matOcc;\n    }\n    else if( matID<MAT_GRASS+0.5 )\n    {\n    \tmatColor = vec3(0.1,0.15,0.03);\n        \n        float h = terrain( pos.xz );\n        float e = clamp(pos.y-h,0.0,1.0);\n        matOcc = 0.01 + 0.99*e*e;\n        \n        matColor *= 1.0 - 0.3*cos(matID2*23.0);\n        matColor += 0.04*sin(matID2*41.0);\n        \n        matSSS = 0.2;\n        matColor *= 0.75;\n        matRough = 0.5;\n        matOcc *= 0.1+0.9*smoothstep( 0.0, 2.0, length(pos.xz-mushroomPos1.xz-vec2(0.3,0.3)) );\n        matRefOcc = matOcc;\n        matGamma = vec3(0.9,0.9,1.0);\n    }\n    else if( matID<MAT_GROUND+0.5 )\n    {\n        matColor = vec3(0.2,0.2,0.0);\n        matRough = 1.0;\n        matOcc = 0.02;\n        matRefOcc = matOcc;\n    }\n    else if( matID<MAT_MOSS+0.5 )\n    {\n        matColor = (matID2>0.0) ? vec3(0.18,0.15,0.02) : vec3(0.1,0.05,0.005);\n        \n        float f = texture( iChannel1, pos.xy*8.0 ).x;\n        matColor *= 0.55 + f;\n            \n        matOcc = abs(matID2);\n        matOcc *= 0.2+0.8*smoothstep( 0.0, 1.5, length(pos.xz-mushroomPos1.xz-vec2(0.3,0.3)) );\n        matOcc *= 0.2+0.8*smoothstep( 0.0, 1.5, length(pos.xz-mushroomPos2.xz-vec2(0.0,0.0)) );\n        matRough = 0.25;\n        matSSS = 0.5;\n        matRefOcc = matOcc;\n        matGamma = vec3(0.7,0.7,1.0);\n        \n        if( matID2<0.0 ) { matGamma = vec3(0.7,0.9,1.0); matRough = 0.75;}\n    }\n    else \/\/if( matID<MAT_CITA+0.5 )\n    {\n        matColor = vec3(1.0);\n        matSSS = 1.0;\n        matRough = 1.0;\n        matGamma = vec3(0.5);\n    }\n}\n\nvec3 lighting( in float dis, in vec3 rd, in vec3 pos, in vec3 nor,\n               in float occ,\n               in vec3 matColor, in float matRough, in float matSSS, in float matRefOcc,\n               in vec3 matGamma )\n{\n    vec3 col = vec3(0.0);\n\n    float fre = clamp( 1.0+dot(nor,rd), 0.0, 1.0 );\n    float sfre = 0.04 + 0.96*pow( fre, 5.0 );\n    float pn = exp2( 10.0*(1.0-matRough) );\n\n    \/\/ sun light\n    {\n        vec3 sunColor = vec3(7.0,4.0,3.0)*1.4;\n        vec3 sun = normalize(vec3(-0.8,0.35,-0.3));\n        float dif = clamp( dot(sun,nor), 0.0, 1.0 );\n        float sha = 0.0; if( dif>0.001 ) sha = calcShadow( pos, sun );\n        vec3 hal = normalize( sun - rd );\n        float spe = pow( clamp(dot(hal,nor), 0.0, 1.0 ), pn );\n        col += matColor * sunColor * dif * vec3(sha,0.5*sha*(1.0+sha),sha*sha);\n        col += (1.0-matRough)*sunColor * spe * pn * dif * sha * sfre \/ 4.0;\n    }\n\n    \/\/ sky light\n    {\n        vec3 skyColor = vec3(0.3,0.4,0.7)*1.0;\n        float dif = 0.5 + 0.5*nor.y;\n        col += matColor * skyColor * dif * occ;\n        col += skyColor * (1.0-matRough) * smoothstep( 0.0,0.2,reflect(rd,nor).y ) * sfre * 2.5 * matRefOcc;\n    }\n\n    \/\/ bounce light\n    {\n        vec3 bouColor = vec3(0.2,0.4,0.0)*1.2;\n        float dif = clamp(0.5 - 0.5*nor.y,0.0,1.0);\n        col += matColor * bouColor * dif * occ;\n    }\n\n    col += fre*matColor*occ*matSSS;\n    col = pow( max(col,0.0), matGamma );\n\n    return col;\n}\n\nvec3 background(in vec3 d)\n{\n    \/\/ cheap cubemap\n    vec3 n = abs(d);\n    vec2 uv = (n.x>n.y && n.x>n.z) ? d.yz\/d.x: \n              (n.y>n.x && n.y>n.z) ? d.zx\/d.y:\n                                     d.xy\/d.z;\n    return vec3(0.02,0.01,0.00) + vec3(2.5)*pow(texture( iChannel1, 0.1*uv, 1.0 ).yxz,vec3(2.6,4.0,4.2));\n}\n\nmat3 calcCamera( in vec3 ro, in vec3 ta )\n{\n    vec3 w = normalize( ro-ta );\n    vec3 u = normalize( cross( vec3(0.0,1.0,0.0), w ) );\n    vec3 v =          ( cross( w, u ) );\n    \n    return mat3( u, v, w );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy+2.0*fragCoord) \/ iResolution.y;\n    \n    \/\/ camera\n    vec3 ro = vec3(0.0,2.7,-3.0);\n    vec3 ta = vec3(0.0,1.9,0.0);\n    ro.x += 0.3*sin(0.03*iTime);    \n    mat3 camRot = calcCamera( ro, ta );\n    \n    \/\/ ray\n    vec3 rd = normalize( camRot * vec3(p,-2.0) );\n    \n    \/\/ background\n    vec3 col = background(rd);\n \n    \/\/ scene\n    vec3 tm = raycast(ro,rd);\n    float t = tm.x;\n    float matID = tm.y;\n    if( matID>0.5 )\n    {\n        vec3 pos = ro + t*rd;\n    \tvec3 nor = calcNormal( pos ); \n        \n        vec3 matNormal, matColor, matGamma;\n        float matRough, matOcc, matSSS, matRefOcc;\n        \n        materials( matID, tm.z, pos, nor, matColor, matRough, matNormal, matOcc, matSSS, matRefOcc, matGamma );\n        col = lighting( t, rd, pos, matNormal, matOcc, matColor, matRough, matSSS, matRefOcc, matGamma );\n    }\n    else\n    {\n        t = 30.0;\n    }\n    \n\tfragColor = vec4( col, t*dot(rd,normalize(ta-ro)) );\n}",
                "name": "Buffer A",
                "description": "",
                "type": "buffer"
            }
        ]
    },
    {
        "ver": "0.1",
        "info": {
            "id": "ldtGWj",
            "date": "1452349689",
            "viewed": 22098,
            "name": "Precalculated Voronoi Heightmap",
            "username": "Shane",
            "description": "Generating a simple, abstract stone texture in a single loop pass, then using it as a heightmap for raymarching purposes.",
            "likes": 223,
            "published": 3,
            "flags": 32,
            "usePreview": 1,
            "tags": []
        },
        "renderpass": [
            {
                "inputs": [
                    {
                        "id": "4dXGR8",
                        "filepath": "\/media\/previz\/buffer00.png",
                        "previewfilepath": "\/media\/previz\/buffer00.png",
                        "type": "buffer",
                        "channel": 0,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "repeat",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "4dfGRr",
                        "channel": 0
                    }
                ],
                "code": "\/*\n\n\tPrecalculated Voronoi Heightmap\n\t-------------------------------\n\n\tGenerating a simple, abstract stone texture in a single offscreen loop pass, then using \n\tit as a heightmap for raymarching purposes. The example itself is nothing exciting, but it \n\tshows that you can now calculate things like multiple terrain layers - or anything you can \n\tdream up - in a single pass. In fact, if you put together a simple resizing system, you \n\tcould get it done in a single frame.\n\n\tYou can find the texture creation behind the \"Buf A\" tab. For the record, I haven't\tproperly \n\tinvestigated correct procedures yet, so there's probably a better way to preload a heightmap. \n\tIdeally, it'd be nice to render to a fixed sized buffer, like 512 by 512 for instance, which\n    would be especially helpful when moving to fullscreen, but I don't think that's possible at \n\tpresent? Either way, the framerate is much, much better in a sub-1000-px sized canvas than \n\tit would be if you had to do the same without multipass.\n\n\tBy the way, thanks to \"poljere,\" \"iq\" -- and whoever else was involved -- for providing \n\tmultiple-pass functionality. Putting that together would have been a backend nightmare, but \n\tit opens up so many possibilities.\n\n*\/\n\n\/\/ If you want to see what the generated heightmap looks like by itself, uncomment the following.\n\/\/#define SHOW_HEIGHMAP \n\n\/\/ Tri-Planar blending function. Based on an old Nvidia writeup:\n\/\/ GPU Gems 3 - Ryan Geiss: http:\/\/http.developer.nvidia.com\/GPUGems3\/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n   \n    p = fract(p);\n    \n    n = max(n*n, 0.001);\n    n \/= (n.x + n.y + n.z ); \n    \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\n\/\/ Reducing the heightmap function to a single texel lookup - via the stone texture which was \n\/\/ generated outside the distance function in the onscreen buffer, of course.\n\/\/\n\/\/ Using the single pass system, there would have been no other option than to generate the stone \n\/\/ texture several times a frame... or beg someone behind the scenes to provide a 2D multilayered \n\/\/ Voronoi heightmap. :)\nfloat heightMap( in vec2 p ) { \n\n    \/\/ The stone texture is tileable, or repeatable, which means the pattern is slightly\n    \/\/ repetitive, but not too bad, all things considered. Note that the offscreen buffer \n    \/\/ doesn't wrap, so you have to do that yourself. Ie: fract(p) - Range [0, 1].\n    return texture(iChannel0, fract(p\/2.), -100.).w;\n\n}\n\n\n\/\/ Raymarching a textured XY-plane, with a bit of distortion thrown in.\nfloat map(vec3 p){\n\n    \/\/ The height value.\n    float c = heightMap(p.xy);\n    \n    \/\/ Back plane, placed at vec3(0., 0., 1.), with plane normal vec3(0., 0., -1).\n    \/\/ Adding some height to the plane from the texture. Not much else to it.\n    return 1. - p.z - c*.1;\/\/texture(texChannel0, p.xy).x*.1;\n\n    \n    \/\/ Smoothed out.\n    \/\/float t =  heightMap(p.xy);\n    \/\/return 1. - p.z - smoothstep(0.1, .8, t)*.06 - t*t*.03;\n    \n}\n\n\n\/\/ Tetrahedral normal, courtesy of IQ.\nvec3 getNormal( in vec3 pos )\n{\n    vec2 e = vec2(0.001, -0.001);\n    return normalize(\n        e.xyy * map(pos + e.xyy) + \n        e.yyx * map(pos + e.yyx) + \n        e.yxy * map(pos + e.yxy) + \n        e.xxx * map(pos + e.xxx));\n}\n\n\n\n\/\/ Ambient occlusion, for that self shadowed look.\n\/\/ Based on the original by IQ.\nfloat calculateAO(vec3 p, vec3 n)\n{\n   const float AO_SAMPLES = 5.0;\n   float r = 1.0, w = 1.0;\n   for (float i=1.0; i<=AO_SAMPLES; i++)\n   {\n      float d0 = i\/AO_SAMPLES;\n      r += w * (map(p + n * d0) - d0);\n      w *= 0.5;\n   }\n   return clamp(r, 0.0, 1.0);\n}\n\n\/\/ Cool curve function, by Shadertoy user, Nimitz.\n\/\/\n\/\/ It gives you a scalar curvature value for an object's signed distance function, which \n\/\/ is pretty handy for all kinds of things. Here's it's used to darken the crevices.\n\/\/\n\/\/ From an intuitive sense, the function returns a weighted difference between a surface \n\/\/ value and some surrounding values - arranged in a simplex tetrahedral fashion for minimal\n\/\/ calculations, I'm assuming. Almost common sense... almost. :)\n\/\/\n\/\/ Original usage (I think?) - Cheap curvature: https:\/\/www.shadertoy.com\/view\/Xts3WM\n\/\/ Other usage: Xyptonjtroz: https:\/\/www.shadertoy.com\/view\/4ts3z2\nfloat curve(in vec3 p){\n\n    const float eps = 0.0225, amp = 7.5, ampInit = 0.525;\n\n    vec2 e = vec2(-1., 1.)*eps; \/\/0.05->3.5 - 0.04->5.5 - 0.03->10.->0.1->1.\n    \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    \n    return clamp((t1 + t2 + t3 + t4 - 4.*map(p))*amp + ampInit, 0., 1.);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    \n    \/\/ Unit direction ray. Divisionless one liner, courtesy of user, Coyote.\n    vec3 rd = normalize(vec3(fragCoord - iResolution.xy*.5, min(iResolution.y*.75, 600.)));\n    \n    float tm = iTime\/2.;\n    \/\/ Rotating the XY-plane back and forth, for a bit of variance.\n    \/\/ Elegant angle vector, courtesy of user, Fabrice.\n    vec2 th = sin(vec2(1.57, 0) + sin(tm\/4.)*.3);\n    rd.xy = mat2(th, -th.y, th.x)*rd.xy;\n    \n    \/\/ Tilting the camera in another direction.\n    \/\/th = sin(vec2(1.57, 0) + sin(iTime\/8.)*.1);\n    \/\/mat2(th, -th.y, th.x)*rd.yz;\n    \n    \n    \/\/ Ray origin. Moving in the X-direction to the right.\n    vec3 ro = vec3(tm, cos(tm\/4.), 0.);\n    \n    \n    \/\/ Light position, hovering around behind the camera.\n    vec3 lp = ro + vec3(cos(tm\/4.)*.5, sin(tm\/4.)*.5, -.5);\n    \n    \/\/ Standard raymarching segment. Because of the straight forward setup, very few \n    \/\/ iterations are needed.\n    float d, t=0.;\n    for(int j=0; j<32; j++){\n      \n        d = map(ro + rd*t); \/\/ Distance to the function.\n        \n        \/\/ The plane \"is\" the far plane, so no far plane break is needed.\n        if(d<0.001) break; \n        \n        t += d*.7; \/\/ Total distance from the camera to the surface.\n    \n    }\n    \n   \n    \/\/ Surface postion, surface normal and light direction.\n    vec3 sp = ro + rd*t;\n    vec3 sn = getNormal(sp);\n    vec3 ld = lp - sp;\n    \n    \n    \/\/ Texture scale factor.\n    const float tSize0 = 1.\/1.;\n    \n    \n    \/\/ Retrieving the texel at the surface postion. A tri-planar mapping method is used to\n    \/\/ give a little extra dimension. The time component is responsible for the texture movement.\n    float c = heightMap(sp.xy);\n   \n    \n    vec3 oC = tex3D(iChannel0, sp*tSize0, sn);\n    \/\/vec3 oC = texture(iChannel0, sp.xz*tSize0).xyz*(vec3(c)*.5+.5); \/\/ 2D texel lookup.\n    \/\/vec3 oC = vec3(.55)*(vec3(c)*.9+.1); \/\/ Textureless.\n    \n    \/\/ Mixing in the normal to give the color a bit of a pearlescent quality. These rocks probably\n    \/\/ wouldn't have a pearlecent quality... Um... space rocks. :)\n    oC *= pow(max(c*c*sn*.7 + 1., 0.), vec3(2))*c;\n   \n    \n    \n    float lDist = max(length(ld), 0.001); \/\/ Light distance.\n    float atten = 1.\/(1. + lDist*.125); \/\/ Light attenuation.\n    \n    ld \/= lDist; \/\/ Normalizing the light direction vector.\n    \n    float diff = max(dot(ld, sn), 0.); \/\/ Diffuse.\n    diff = pow(diff, 4.)*2.;\n    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 16.); \/\/ Specular.\n    float fre = pow(clamp(dot(sn, rd) + 1., .0, 1.), 2.); \/\/ Fake Fresnel, for the glow.\n \n    \/\/ Schlick Fresnel approximation, to tone down the specular component a bit.\n\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\tfloat fre2 = mix(.5, 1., Schlick);  \/\/F0 = .5;  \/\/ Hard granite.  \n    \n    \/\/ Shading. Note, there are no actual shadows. The camera is front on, so the following\n    \/\/ two functions are enough to give a shadowy appearance.\n    float crv = curve(sp); \/\/ Curve value, to darken the crevices.\n    crv = smoothstep(0., 1., crv)*.5 + crv*.25 + .25; \/\/ Tweaking the curve value a bit.\n    \n    float ao = calculateAO(sp, sn); \/\/ Ambient occlusion, for self shadowing.\n\n\n    \n    \/\/ Combining the terms above to light the texel.\n    vec3 col = (oC*(diff + .25 + vec3(.5, .7, 1)*spec*fre2*4. + vec3(1, .1, .2)*fre*8.));\n    \n    \n    \/\/ Another variation, without the Fresnel glow.\n    \/\/vec3 col = (oC*(diff + 1.) + vec3(1., .9, .7)*spec*fre2*2.);\n \n    \n    \/\/ Applying the shades.\n    col *= atten*crv*ao;\n    \n    \/\/col = vec3(crv);\n    \n    #ifdef SHOW_HEIGHMAP\n    vec2 uv = fragCoord.xy\/iResolution.y;\n    uv = mat2(th, -th.y, th.x)*uv;\n    uv += vec2(iTime, cos(iTime\/4.))\/2.;\n    vec4 tex = texture(iChannel0, fract(uv\/1.));\n    col = sqrt(tex.xyz)*tex.w;\n\t#endif\n\n    \/\/ Presenting to the screen.\n\tfragColor = vec4(sqrt(clamp(col, 0., 1.)), 1.);\n}",
                "name": "Image",
                "description": "",
                "type": "image"
            },
            {
                "inputs": [
                    {
                        "id": "4sXGRn",
                        "filepath": "\/media\/a\/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg",
                        "previewfilepath": "\/media\/ap\/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg",
                        "type": "texture",
                        "channel": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "wrap": "repeat",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    },
                    {
                        "id": "4dXGR8",
                        "filepath": "\/media\/previz\/buffer00.png",
                        "previewfilepath": "\/media\/previz\/buffer00.png",
                        "type": "buffer",
                        "channel": 0,
                        "sampler": {
                            "filter": "linear",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": "4dXGR8",
                        "channel": 0
                    }
                ],
                "code": "\/\/ 2x2 hash algorithm.\nvec2 hash22(vec2 p) { \n    \n    \/\/ This line makes the pattern repeatable. \n    p = mod(p, 5.); \n\n    \/\/ More concise, but wouldn't disperse things as nicely as other versions.\n    float n = sin(dot(p, vec2(41, 289))); \n    return fract(vec2(8, 1)*262144.*n);\n\n    \/\/p = fract(vec2(8, 1)*262144.*n);\n    \/\/return sin(p*6.283 + iTime)*0.5 + 0.5;\n\n}\n\n\n\/\/ 2D 2nd-order Voronoi: Obviously, this is just a rehash of IQ's original. I've tidied\n\/\/ up those if-statements. Since there's less writing, it should go faster. That's how \n\/\/ it works, right? :)\n\/\/\nfloat voronoi(in vec2 p){\n    \n\tvec2 g = floor(p), o; p -= g;\n\t\n\tvec3 d = vec3(1); \/\/ 1.4, etc. \"d.z\" holds the distance comparison value.\n    \n\tfor(int y = -1; y <= 1; y++){\n\t\tfor(int x = -1; x <= 1; x++){\n            \n\t\t\to = vec2(x, y);\n            o += hash22(g + o) - p;\n            \n\t\t\td.z = dot(o, o);            \n            d.y = max(d.x, min(d.y, d.z));\n            d.x = min(d.x, d.z); \n                       \n\t\t}\n\t}\n\t\n\t\n    return d.y - d.x;\n    \/\/ return d.x;\n    \/\/ return max(d.y*.91 - d.x*1.1, 0.)\/.91;\n    \/\/ return sqrt(d.y) - sqrt(d.x); \/\/ etc.\n}\n\n\/\/ Prerendering a simple stone texture to one of the offscreen buffers. The process is simple, but\n\/\/ definitely not simple enough to calculate it on the fly inside a distance function.\n\/\/\n\/\/ There is one minor complication, and that is the texture needs to be repeatable. That's its own\n\/\/ discussion, but if you're not sure how it's achieved, the key to repeatable Voronoi are the lines \n\/\/ \"p = mod(p, 5)\" and \"float c = voronoi(p*5.)... .\" I'm sure you'll figure it out from there. :)\n\/\/\n\/\/ The random pixelization business is just a hacky way to redraw the texture when the canvas is resized.\n\/\/ Definitely not the best way to go about it, that's for sure.\n\/\/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \/\/ Offscreen buffer coordinates.\n    vec2 p = fragCoord.xy\/iResolution.xy;\n\n    \/\/ On the first frame, render the entire texture. Otherwise, randomly render every 8 pixels,\n    \/\/ which, in theory, should lessen the workload. I'm continuously rendering parts of the texture\n    \/\/ to account for resizing events. If you resize, the new heighmap will quickly pixel fade in.\n    \n    \/\/ Obviously, a better solution would be to detect a resize and render the texture just once, or \n    \/\/ better yet, have a fixed size offscreen buffer option... Although, that sounds like a backend \n    \/\/ nightmare. :)\n    \/\/if(hash22(p + iTime).x< 1.\/8. || iFrame==0){\n    if(floor(hash22(p + iTime).x*8.)< 1. || iFrame==0){    \n        \n        \/\/ The stone texture. I made this up on the spot. Basically add three second order Voronoi\n        \/\/ layers of varying amplitudes and frequency. Also, perturb the initial UV coordinates\n        \/\/ to give it more of a natural look. Finally, add some fine detailing via one of Shadertoy's\n        \/\/ in-house textures. By the way, you could generate that also, but I didn't want to \n        \/\/ overcomplicate a simple example.\n        \n        \/\/ Texture value. Reversing the channels for a different color variation.\n        vec3 tx = texture(iChannel1, p).xyz; tx *= tx;\n        tx = smoothstep(0., .5, tx);\n        \n        \/\/ Perturbing the UV coordinates just slightly to give the stones a slightly more natural feel.\n        \/\/ Note the PI frequencies. That's for texture wrapping purposes.\n        p += sin(p*6.283*2. - cos(p.yx*6.283*4.))*.01;\n        \n        \/\/ Three Voronoi layers. Pretty standard. I could have put a lot more effort into this\n        \/\/ part, but it's just a simple proof of concept, so just three lazy layers.\n        \n        \/\/ More stone looking.\n        \/\/float c = voronoi(p*5.)*.8 + voronoi(p*15.)*.15 + voronoi(p*45.)*.05;\n        \n        \/\/ Less detail.\n        \/\/float c = voronoi(p*5.) - (1.-voronoi(p*15.))*.08 + voronoi(p*45.)*.04;\n        \n       \n        \/\/float c = voronoi(p*5.)*.6 + voronoi(p.yx*5. + vec2(2.666, 1.666))*.4 - (1.-voronoi(p*15.))*.08 + voronoi(p*45.)*.04;\n        float c = voronoi(p*5. - .35)*.6 + voronoi((p.yx + .5)*10.)*.3 + (1.-voronoi(p*25.))*.075 + voronoi(p*60.)*.025;\n \n        \n\n        \/\/ Finally, using the greyscale texture value to add some fine detailing.\n        c += dot(tx, vec3(.299, .587, .114))*.1;\n        \n        \n        \/\/ Storing away the values for use in the main part of the application.\n        fragColor.xyz = tx; \/\/ Put the texture color in the XYZ channels.\n        fragColor.w = min(c\/1.1, 1.); \/\/ Store the heightmap value in the \"W\" channel.\n\n\n    }\n    \/\/ Copy the rest of the pixels over to the new frame. Obvious, but it'd been a while, so I had to \n    \/\/ figure that one out. :)\n    else fragColor = texture(iChannel0, p); \n    \n}",
                "name": "Buffer A",
                "description": "",
                "type": "buffer"
            }
        ]
    }
]