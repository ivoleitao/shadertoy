{
  "text": [
    "Made it 1.3 times faster by adding bounding planes, so in 4k resolution now it runs at 7.5 fps on my old mobile gtx 1070 notebook. ",
    "rtx 3090 in full screen: stuttering . not possible to view in 4k",
    "Thanks for the link @iq, I sis not read this article yet. As you said there we normaly use a 2d noise on xz to displace along y a plane. So it's like using the noise result as a y offset on a plane using f(x,z) = y or consider that as g(x,y,z) = y- f(x,z) = 0. \nMy main problem is when I want to create some noise based bump on any object's surface, I want a 3d noise on a varying 2d surface. I came out with this formula that seems to work normalize(-e.xyz - (dot(-e.xyz,n)-1.0)*n), where n is the point's surface normal and e the partial derivatives vector. It works on any continuous surface object but not on a cube for example.\n\nBut in this example I really fail to understand what the 3d noise result is actually doing. Is it telling if after a certain level of noise the point is actually filled with matter or not, or is is displacing some surface point on a certain direction? From the normal calculation I would say it's the first solution, but I'm not so sure.",
    "Right, totally failed to save the shader for some reason",
    "Link? The function 'calcNormal' uses 6 samples on this shader.",
    "This is a 3D shape, not a 2D height-map, so the way the normal is computed is correct. You can follow the link I left in the function to learn if you are curious why the gradient computation can use 4 samples rather than 6.",
    "My bad, it's not an elevation but a level of minimum noise to tell if there is actually matter or void... so I guess this normal calculation is actually correct here.",
    "@iq: Is it me totally wrong or the normal calculation of a 3D noise used to elevate along Y axis should be \nvec3 calcNormal( in vec3 pos, in float t )\n{\n    vec3 eps = vec3( max(0.01,0.001*t),0.0,0.0);\n#if 1\n\treturn normalize(  vec3(\n                       mapTerrain(pos+eps.xyy) - mapTerrain(pos-eps.xyy),\n                       eps.x,\n                       mapTerrain(pos+eps.yyx) - mapTerrain(pos-eps.yyx)));\n#else \/\/ original code\n    return normalize( vec3(\n                       mapTerrain(pos+eps.xyy) - mapTerrain(pos-eps.xyy),\n                       mapTerrain(pos+eps.yxy) - mapTerrain(pos-eps.yxy),\n                       mapTerrain(pos+eps.yyx) - mapTerrain(pos-eps.yyx)) );\n#endif\n\n}\n\nbecause it's actually a 4d normal computed from vec4(-ddx, -ddy, -ddz, eps) in 4d space where you cancel the Y dimension and use the W dimension as the noise value along the Y axis. So you should end with Vec3(-ddx, eps, -ddz). Am I right?",
    "i also like it withhout blur! btw, your code is very readable and informative, thank you ! ",
    "Newbie question ! At line 323 (Buffer A), why don't you use :\nvec3 cpos = (wpos - oldRo) * oldCam ;\n\n",
    "I prefer it without motion blur.",
    "Featured in this video :) ! [video]http:\/\/youtu.be\/7BB8TkY4Aeg[\/video]",
    "It's awesome graphics!!!\n\nif you want to run in Inter Explorer\nfix texutreLod to texure function (textureLod is not supported in IE)\n",
    "tylerbata, currently your best be to work around [lipschitz constants >1](due to (twist) transformations of the distance field\/gradient, or due to fractals with insufficiently precise orbit traps) is [url=https:\/\/www.shadertoy.com\/results?query=dynamiceps]dynamiceps[\/url]. It adjusts epsilon for the \"close to surface\" break condition, based on last step distance and distance to camera, for more precision closer to the camera, and more distortion further away from the camera, for more convergence and longer render distance (and as many reflections as steps).",
    "Beautiful, in full screen it looks perfect.",
    "Thanks! Yeah I kind of figured it would be a precision error.  I tested it by marching only 0.75 of the estimated distance and it fixed the problem...only thing is that adds a lot of cost.  So I think I will likely have some sort of dynamic precision based off the distance.  I also think I might try some sort of newton like method over shooting then fixing back...This could cause issues with thin objects like grass.",
    "raymarching being iterative raytracing, you easily end up accumulating more precision errors than in an analytical approach.\n\nevery iteration it estimates the closest distance o a defined surface.\nsometimes it is easier to define an upper bound for a distance.\nsome transformations make it very hard to estimate even an upper bound.\noften a faster lower-bound is \"close enough\" but lads to overestimation of distances, and you march into or trough a \"solid\"",
    "Let's be sure we're on the same page:\n\nAre you referring to the \"shimmering\" effect that's pretty much everywhere, at the pixel-level?\n\nOr are you referring to the flip-flop from black to light here and there along the edges of shadows?",
    "Thanks, I'm trying to figure out why fractal terrain will always flicker in some places.  Is the distance field not correct?  I have tested the noise function by itself and several variants but it still flickers.  I've seen it occur on other distance fields as well.",
    "Ok, my guess is this relates to volumetric surfaces with normals ~perpendicular to the light source. Tricky. My thought is applying a CLAMP function to the shadow color would solve the issue, rather than a binary function going straight from opaque black to transparent. Thoughts, anyone?",
    "Ah, wait, sorry, at first I didn't notice the issue you speak of. You're talking about the splotches of black among the rocks? That's different than the issue I described below. This is definitely a question for Inigo.",
    "Tylerbata, my guess is this would disappear with oversampling. Without oversampling, fractal terrain will most always flicker, I should think. Feel free to correct me, anyone.",
    "Why does the flickering occur?  Is there anyway to create it without it?",
    "The texture is used for surface shading, and needs mipmapping, hence I cannot make it linear and need the -100. The true solution is to remove the -100 and use texture2DLodEXT() instead, with 0 as mip level.",
    "Figured this out ---- values in G channel are assumed to be (37,17) shifted values in R channel. Nice idea. This saves one texture read as I understand. BTW, I set texture filtering mode to GL_LINEAR and then LOD = -100 is not necessary. \n\nNow the shader completely works and shows me amazing picture.\n\nBTW, awesome math happening here (in this demo and on this site). \nI love it, sir. Good work.",
    "Should the noise function be just smooth gradient- or simplex- like ? If so I think can implement it on my own.\nAlso what is the point of 3rd argument (-100) in texture2D call ?\n\ntexture2D( iChannel0, (uv+ vec2(0.5,0.5))\/256.0, -100.0)\n\nThanks.",
    "Tried your shader in a simple glfw-based application. It works. Three textures are needed -- the last two (iChannel1 and iChannel2)  can be more or less arbitrary as I understand. But the first (noise texture) should satisfy some properties which I cannot guess looking at the code. With random (uniformly) generated rgb components the geometry is visually torn. How can I generate suitable texture image for it? \n\nThanks.\n",
    "i kinda want o steer a hot air baloon through it, being affected by its surrounding and my mouse position.",
    "added a constant factor to line 226, resulted in pseudorandom refraction, as if everything was made of glass\n\nvec3 pos = ro + t*rd*0.5;",
    "[This comment has been hidden by the shader author]",
    "show this to every 10 year old manchild who gets easily excited by the minecraft terrain generator.",
    "Inigo, again mindblowing work.... Also, thank you for all the tutorials, example code etc. You're freaking awesome  bro!!",
    "... very impressiv, great work and thanks!",
    "this shader alone is inspiration enough to use this site... awesome! great work :)",
    "Wow, if you swap the iChannel0 source for a different texture and it becomes a completely different landscape!  I must investigate to understand this mapping...",
    "I can feel the heat...hehe...nice details, massive effect.",
    "Just wow!",
    "Awesome!",
    "Simply outstanding! An inspiration to those of us who are just getting started with programmable pipelines.\n",
    "I rendered it with motion blur and depth of field (at about 3 seconds a frame in my laptop at 1920x1080 HD): [url=http:\/\/www.youtube.com\/watch?v=QfvzfWgW6H4&hd=1]http:\/\/www.youtube.com\/watch?v=QfvzfWgW6H4&hd=1[\/url]\r\n\r\n[video]http:\/\/www.youtube.com\/watch?v=QfvzfWgW6H4[\/video]",
    "Not really. I have made the epsilon in the gradient\/normal computations bigger than the quantification error of the textured noise, but small enough to capture the actual geometry. Basically, making your deltas a bit bigger in calcNormal() should fix it. Hopefully! (unless you get really close to the surface of the model, that is). If not, maybe I should add textures in float16 format as an option...",
    "Yeah I've tried it for height maps before, but it showed the stepping problems on the texel gradients, which I found quite interesting. I guess you've hidden the errors in the squiggles. :)",
    "Yep. It suffers from precision problems though, but it can be a good alternative in some cases. Not only is faster, but WebGLSL seems to be less sensitive to fail compilation with this one that with the procedural\/hash based one.",
    "I've just this 3D noise idea in one of my old shaders, and it's speed enabled much finer steps. Thank-you iq!",
    "Really cool :)",
    "Brilliant! And that smoke really makes it 2X so! :)",
    "OMG! WOW! Incredible! I love it! :)"
  ],
  "date": [
    "1658701726",
    "1647056247",
    "1611785550",
    "1611714864",
    "1611611594",
    "1611602839",
    "1611333597",
    "1611326673",
    "1556719739",
    "1542920933",
    "1535122141",
    "1532120586",
    "1521386788",
    "1510100155",
    "1504262882",
    "1494089182",
    "1494047802",
    "1491277916",
    "1491270794",
    "1491232540",
    "1491232322",
    "1491232199",
    "1491155638",
    "1483849538",
    "1472147934",
    "1472134518",
    "1472133928",
    "1460985211",
    "1460984770",
    "1460930291",
    "1460930017",
    "1453795294",
    "1435949046",
    "1414706705",
    "1408906622",
    "1374173508",
    "1373314147",
    "1373180188",
    "1373175825",
    "1373135522",
    "1372876460",
    "1372873204",
    "1372870579",
    "1372870476",
    "1372867312",
    "1372860147",
    "1372846348"
  ],
  "username": [
    "iq",
    "inc",
    "AlainBandon",
    "iq",
    "Dave_Hoskins",
    "iq",
    "AlainBandon",
    "AlainBandon",
    "jeyko",
    "denosya",
    "Redline",
    "ttoinou",
    "songinnight",
    "ollj",
    "Osgrot",
    "tylerbata",
    "ollj",
    "jpryne",
    "tylerbata",
    "jpryne",
    "jpryne",
    "jpryne",
    "tylerbata",
    "iq",
    "afoksha",
    "afoksha",
    "afoksha",
    "ollj",
    "ollj",
    "ollj",
    "ollj",
    "nenovrak",
    "fred41",
    "peet",
    "dantronic",
    "frankwer",
    "bekre",
    "gyabo",
    "jpryne",
    "iq",
    "iq",
    "Dave_Hoskins",
    "iq",
    "Dave_Hoskins",
    "vanburgler",
    "Dave_Hoskins",
    "CPU"
  ],
  "userpicture": [
    "\/media\/users\/iq\/profile.png",
    "\/media\/users\/inc\/profile.jpeg",
    "\/img\/profile.jpg",
    "\/media\/users\/iq\/profile.png",
    "\/media\/users\/Dave_Hoskins\/profile.jpeg",
    "\/media\/users\/iq\/profile.png",
    "\/img\/profile.jpg",
    "\/img\/profile.jpg",
    "\/media\/users\/jeyko\/profile.png",
    "\/media\/users\/denosya\/profile.jpeg",
    "\/img\/profile.jpg",
    "\/media\/users\/ttoinou\/profile.jpeg",
    "\/img\/profile.jpg",
    "\/media\/users\/ollj\/profile.jpeg",
    "\/media\/users\/Osgrot\/profile.jpeg",
    "\/media\/users\/tylerbata\/profile.png",
    "\/media\/users\/ollj\/profile.jpeg",
    "\/img\/profile.jpg",
    "\/media\/users\/tylerbata\/profile.png",
    "\/img\/profile.jpg",
    "\/img\/profile.jpg",
    "\/img\/profile.jpg",
    "\/media\/users\/tylerbata\/profile.png",
    "\/media\/users\/iq\/profile.png",
    "\/img\/profile.jpg",
    "\/img\/profile.jpg",
    "\/img\/profile.jpg",
    "\/media\/users\/ollj\/profile.jpeg",
    "\/media\/users\/ollj\/profile.jpeg",
    "\/media\/users\/ollj\/profile.jpeg",
    "\/media\/users\/ollj\/profile.jpeg",
    "\/media\/users\/nenovrak\/profile.jpeg",
    "\/img\/profile.jpg",
    "\/media\/users\/peet\/profile.png",
    "\/media\/users\/dantronic\/profile.jpeg",
    "\/img\/profile.jpg",
    "\/img\/profile.jpg",
    "\/media\/users\/gyabo\/profile.png",
    "\/img\/profile.jpg",
    "\/media\/users\/iq\/profile.png",
    "\/media\/users\/iq\/profile.png",
    "\/media\/users\/Dave_Hoskins\/profile.jpeg",
    "\/media\/users\/iq\/profile.png",
    "\/media\/users\/Dave_Hoskins\/profile.jpeg",
    "\/img\/profile.jpg",
    "\/media\/users\/Dave_Hoskins\/profile.jpeg",
    "\/media\/users\/CPU\/profile.jpeg"
  ],
  "id": [
    "td3Szr",
    "3dt3D4",
    "3s2GDz",
    "Ws2GWR",
    "WsB3Dz",
    "3dS3Dz",
    "wsBGzw",
    "tsB3Rw",
    "Xt2yDh",
    "MsjBzw",
    "lsXBWn",
    "ldjcDV",
    "XdXcW4",
    "4ltSR2",
    "Mty3Ww",
    "lsVXRc",
    "XsKXzc",
    "ldyXWz",
    "MdGXWz",
    "ldySDR",
    "MsGSDR",
    "lsGSDR",
    "XsyXDR",
    "lstSRM",
    "XdtGRX",
    "ld33zf",
    "MscGzf",
    "MlSSRR",
    "llSSRR",
    "lllXWs",
    "MtlXWs",
    "Xlj3Rd",
    "MdSXRy",
    "XsXXR4",
    "XdS3D3",
    "lsl3W7",
    "4dfGW7",
    "XdfGDM",
    "XsXGDM",
    "4sf3WM",
    "ldl3WN",
    "lssGWN",
    "MdsGWN",
    "ldsGWN",
    "MslGWN",
    "MdlGWN",
    "MssGD4"
  ],
  "hidden": [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ]
}
