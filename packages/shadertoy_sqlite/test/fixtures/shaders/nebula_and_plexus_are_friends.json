{
    "ver": "0.1",
    "info": {
        "id": "3tdyRB",
        "date": "1609370204",
        "viewed": 96,
        "name": "Nebula and Plexus are friends",
        "username": "Nabuki",
        "description": "Quik and dirty combination of these two shaders: https:\/\/www.shadertoy.com\/view\/MtcGDf and https:\/\/www.shadertoy.com\/view\/wtcXWr",
        "likes": 6,
        "published": 3,
        "flags": 32,
        "usePreview": 0,
        "tags": [
            "nebulaplexus"
        ],
        "hasliked": 0
    },
    "renderpass": [
        {
            "inputs": [
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dfGRr",
                    "channel": 0
                }
            ],
            "code": "const float FLIGHT_SPEED = 6.0;\n\nconst float FIELD_OF_VIEW = 1.05;\n\n\nvec3 getRayDirection(vec2 fragCoord, vec3 cameraDirection) {\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n  \n    const float screenWidth = 1.0;\n    float originToScreen = screenWidth \/ 2.0 \/ tan(FIELD_OF_VIEW \/ 2.0);\n    \n    vec3 screenCenter = originToScreen * cameraDirection;\n    vec3 baseX = normalize(cross(screenCenter, vec3(0, -1.0, 0)));\n    vec3 baseY = normalize(cross(screenCenter, baseX));\n    \n    return normalize(screenCenter + (uv.x - 0.5) * baseX + (uv.y - 0.5) * iResolution.y \/ iResolution.x * baseY);\n}\n\nvec4 getNebulaColor(vec3 globalPosition, vec3 rayDirection) {\n    vec3 color = vec3(0.0);\n    float spaceLeft = 1.0;\n    \n    const float layerDistance = 10.0;\n    float rayLayerStep = rayDirection.z \/ layerDistance;\n    \n    const int steps = 4;\n    for (int i = 0; i <= steps; i++) {\n      vec3 noiseeval = globalPosition + rayDirection * ((1.0 - fract(globalPosition.z \/ layerDistance) + float(i)) * layerDistance \/ rayDirection.z);\n      noiseeval.xy += noiseeval.z;\n        \n        \n        float value = 0.06 * texture(iChannel0, fract(noiseeval.xy \/ 60.0)).r;\n         \n        if (i == 0) {\n            value *= 1.0 - fract(globalPosition.z \/ layerDistance);\n        } else if (i == steps) {\n            value *= fract(globalPosition.z \/ layerDistance);\n        }\n                \n        color += spaceLeft * 2. * vec3(value, value, value) * vec3(.5, .3, 0.1);\n        spaceLeft = max(0.0, spaceLeft - value * 2.0);\n    }\n    return vec4(color, 1.0);\n}\n\n#define S(a, b, t) smoothstep(a, b, t)\n\nfloat distLine(vec2 p, vec2 a, vec2 b){\n  vec2 pa = p - a;\n    vec2 ba = b - a;\n    float t = clamp(dot(pa, ba) \/ dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba*t);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b){\n  float d = distLine(p, a, b);\n    float m = S(0.03, 0.01, d);\n    float d2 =  length(a - b);\n    m *= S(1.2, 0.8, d2) * 0.5 + S(0.05, 0.03, abs(d2 - 0.75));\n    return m;\n}\n\nfloat distTriangle(in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n  vec2 e0 = p1 - p0;\n  vec2 e1 = p2 - p1;\n  vec2 e2 = p0 - p2;\n\n  vec2 v0 = p - p0;\n  vec2 v1 = p - p1;\n  vec2 v2 = p - p2;\n\n  vec2 pq0 = v0 - e0*clamp( dot(v0,e0)\/dot(e0,e0), 0.0, 1.0 );\n  vec2 pq1 = v1 - e1*clamp( dot(v1,e1)\/dot(e1,e1), 0.0, 1.0 );\n  vec2 pq2 = v2 - e2*clamp( dot(v2,e2)\/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n  return -sqrt(d.x)*sign(d.y);\n}\n\nfloat triangle(vec2 p, vec2 a, vec2 b, vec2 c){\n  float d = distTriangle(p, a, b, c);\n    float m = S(0.03, 0.01, d);\n    float d2 =  length(a - b);\n    m *= S(1.2, 0.8, d2) * 0.5 + S(0.05, 0.03, abs(d2 - 0.75));\n    return m;\n}\n\nfloat N21(vec2 p){\n  p = fract(p * vec2(233.34, 851.73));\n    p += dot(p, p + 23.45);\n    return fract(p.x * p.y);\n}\n\nvec2 N22(vec2 p){\n  float n = N21(p);\n    return vec2(n, N21(p + n));\n}\n\nvec2 getPos(vec2 id, vec2 offset){\n    vec2 n = N22(id + offset) * iTime;\n    return offset + sin(n) * 0.4;\n}\n\nfloat layer(vec2 uv){\n  vec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n    vec2 p[9];\n    int i = 0;\n    for(float y = -1.0; y <= 1.0; y++){\n      for(float x = -1.0; x <= 1.0; x++){\n          p[i++] = getPos(id, vec2(x, y));\n      }    \n    }\n    \n    \n    float t = iTime * 10.0;\n    float m = 0.0;\n    for(int i = 0; i < 9; i++){\n      m += line(gv, p[4], p[i]);\n        \n        vec2 j = (p[i] - gv) * 20.0;\n        float sparkle = 1.0 \/ dot(j, j);\n        \n        m += sparkle * (sin(t + fract(p[i].x) * 10.0) * 0.5 + 0.5);\n        \n        for(int yi= i + 1; yi < 9; yi++){\n        for(int zi= yi + 1; zi < 9; zi++){\n                \n                float len1 = abs(length(p[i] - p[yi]));\n                float len2 = abs(length(p[yi] - p[zi]));\n                float len3 = abs(length(p[i] - p[zi]));\n                \n                if((len1 + len2 + len3) < 2.8){\n                  m += triangle(gv, p[i], p[yi], p[zi]) * 0.8;\n                }\n        }\n      }\n    }\n    m += line(gv, p[1], p[3]);\n    m += line(gv, p[1], p[5]);\n    m += line(gv, p[7], p[3]);\n    m += line(gv, p[7], p[5]);\n\n    return m;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \/\/nebula\n    vec3 movementDirection = normalize(vec3(0.01, 0.0, 1.0));\n    \n    vec3 rayDirection = getRayDirection(fragCoord, movementDirection);\n    \n    vec3 globalPosition = vec3(3.14159, 3.14159, 0.0) + (iTime + 1000.0) * FLIGHT_SPEED * movementDirection;\n    \n    fragColor = getNebulaColor(globalPosition, rayDirection);\n    \n    \/\/ plexus\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) \/ iResolution.y;\n    \n    float m = 0.0;\n    float t = iTime * 0.1;\n        \n    for(float i = 0.0; i < 1.0; i += 1.0 \/ 4.0){\n        float z = fract(i + t);\n        float size = mix(10.0, 0.5, z);\n        float fade = S(0.0, 0.1, z) * S(1.0, 0.8, z);\n        \n        m += layer(uv * size + i * 20.0) * fade;\n    }\n    \n    \n    vec3 base = vec3(0.5, 0.3, 0.1);\n    vec3 col = m * base * 0.1;\n    \n    col -= uv.y * 0.5 * base;\n        \n    fragColor += vec4(col,1.0);\n}",
            "name": "Image",
            "description": "",
            "type": "image"
        },
        {
            "inputs": [],
            "outputs": [
                {
                    "id": "4dXGR8",
                    "channel": 0
                }
            ],
            "code": "\/\/\n\/\/ Description : Array and textureless GLSL 2D\/3D\/4D simplex \n\/\/               noise functions.\n\/\/      Author : Ian McEwan, Ashima Arts.\n\/\/  Maintainer : stegu\n\/\/     Lastmod : 20110822 (ijm)\n\/\/     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n\/\/               Distributed under the MIT License. See LICENSE file.\n\/\/               https:\/\/github.com\/ashima\/webgl-noise\n\/\/               https:\/\/github.com\/stegu\/webgl-noise\n\/\/ \n    vec3 mod289(vec3 x) {\n      return x - floor(x * (1.0 \/ 289.0)) * 289.0;\n    }\n\n    vec4 mod289(vec4 x) {\n      return x - floor(x * (1.0 \/ 289.0)) * 289.0;\n    }\n\n    vec4 permute(vec4 x) {\n         return mod289(((x*34.0)+1.0)*x);\n    }\n\n    vec4 taylorInvSqrt(vec4 r)\n    {\n      return 1.79284291400159 - 0.85373472095314 * r;\n    }\n\n    float snoise(vec3 v)\n      { \n      const vec2  C = vec2(1.0\/6.0, 1.0\/3.0) ;\n      const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    \/\/ First corner\n      vec3 i  = floor(v + dot(v, C.yyy) );\n      vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n    \/\/ Other corners\n      vec3 g = step(x0.yzx, x0.xyz);\n      vec3 l = 1.0 - g;\n      vec3 i1 = min( g.xyz, l.zxy );\n      vec3 i2 = max( g.xyz, l.zxy );\n\n      \/\/   x0 = x0 - 0.0 + 0.0 * C.xxx;\n      \/\/   x1 = x0 - i1  + 1.0 * C.xxx;\n      \/\/   x2 = x0 - i2  + 2.0 * C.xxx;\n      \/\/   x3 = x0 - 1.0 + 3.0 * C.xxx;\n      vec3 x1 = x0 - i1 + C.xxx;\n      vec3 x2 = x0 - i2 + C.yyy; \/\/ 2.0*C.x = 1\/3 = C.y\n      vec3 x3 = x0 - D.yyy;      \/\/ -1.0+3.0*C.x = -0.5 = -D.y\n\n    \/\/ Permutations\n      i = mod289(i); \n      vec4 p = permute( permute( permute( \n                 i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n               + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n               + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n    \/\/ Gradients: 7x7 points over a square, mapped onto an octahedron.\n    \/\/ The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n      float n_ = 0.142857142857; \/\/ 1.0\/7.0\n      vec3  ns = n_ * D.wyz - D.xzx;\n\n      vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  \/\/  mod(p,7*7)\n\n      vec4 x_ = floor(j * ns.z);\n      vec4 y_ = floor(j - 7.0 * x_ );    \/\/ mod(j,N)\n\n      vec4 x = x_ *ns.x + ns.yyyy;\n      vec4 y = y_ *ns.x + ns.yyyy;\n      vec4 h = 1.0 - abs(x) - abs(y);\n\n      vec4 b0 = vec4( x.xy, y.xy );\n      vec4 b1 = vec4( x.zw, y.zw );\n\n      \/\/vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n      \/\/vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n      vec4 s0 = floor(b0)*2.0 + 1.0;\n      vec4 s1 = floor(b1)*2.0 + 1.0;\n      vec4 sh = -step(h, vec4(0.0));\n\n      vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n      vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n      vec3 p0 = vec3(a0.xy,h.x);\n      vec3 p1 = vec3(a0.zw,h.y);\n      vec3 p2 = vec3(a1.xy,h.z);\n      vec3 p3 = vec3(a1.zw,h.w);\n\n    \/\/Normalise gradients\n      vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n      p0 *= norm.x;\n      p1 *= norm.y;\n      p2 *= norm.z;\n      p3 *= norm.w;\n\n    \/\/ Mix final noise value\n      vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n      m = m * m;\n      return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                    dot(p2,x2), dot(p3,x3)));\n\t}\n\nfloat tilingNoise(vec2 position, float size) {\n    float value = snoise(vec3(position * size, 0.0));\n    \n    float wrapx = snoise(vec3(position * size - vec2(size, 0.0), 0.0));    \n    value = mix(value, wrapx, max(0.0, position.x * size - (size - 1.0)));\n\n    float wrapy = snoise(vec3(position * size - vec2(0.0, size), 0.0));\n    float wrapxy = snoise(vec3(position * size - vec2(size, size), 0.0)); \n    wrapy = mix(wrapy, wrapxy, max(0.0, position.x * size - (size - 1.0)));\n\treturn mix(value, wrapy, max(0.0, position.y * size - (size - 1.0)));\n}\n\nvoid initialize(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord \/ iResolution.xy;\n    \n    const int octaves = 6;\n    \n    float value = 0.0;\n  \tfloat maxValue = 0.0; \n    for (float octave = 0.0; octave < float(octaves); octave++) {\n    \tvalue += pow(2.0, -octave) * tilingNoise(uv, 8.0 * pow(2.0, octave));\n        maxValue += pow(2.0, -octave);\n    }\n    \n    maxValue *= 0.5;\n    \n    fragColor = vec4(0.5 * (1.0 + value \/ maxValue) * vec3(1.0), 1.0);\n    fragColor.g = iResolution.x;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, fragCoord \/ iResolution.xy);\n    if (fragColor.g != iResolution.x) {\n    \tinitialize(fragColor, fragCoord);\n    }\n}",
            "name": "Buffer A",
            "description": "",
            "type": "buffer"
        }
    ]
}