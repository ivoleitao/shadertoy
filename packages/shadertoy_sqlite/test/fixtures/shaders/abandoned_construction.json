{
    "ver": "0.1",
    "info": {
        "id": "wdVGD3",
        "date": "1572267912",
        "viewed": 4132,
        "name": "Abandoned Construction",
        "username": "Shane",
        "description": "Flying through an extruded structure produced via an underlying herringbone block pattern.",
        "likes": 112,
        "published": 3,
        "flags": 0,
        "usePreview": 0,
        "tags": [
            "raymarching",
            "grid",
            "pattern",
            "block",
            "sand",
            "herringbone"
        ],
        "hasliked": 0
    },
    "renderpass": [
        {
            "inputs": [
                {
                    "id": "Xsf3Rr",
                    "filepath": "\/media\/a\/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg",
                    "previewfilepath": "\/media\/ap\/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg",
                    "type": "texture",
                    "channel": 0,
                    "sampler": {
                        "filter": "mipmap",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dfGRr",
                    "channel": 0
                }
            ],
            "code": "\/*\n\n\tAbandoned Construction\n\t----------------------\n\n\tHave you ever wondered what a herringbone tiling of 3 by 2 rectangles would look like\n\tin extruded heightmap form? Neither have I, but I began coding a brick pattern on a \n\t2D plane, and this is where I ended up. :D\n\n    A lot of repetitive tiling examples utilize a square grid. I prefer them for the\n\tobvious reason that they're simpler to use. Of course, a lot of interesting scenes \n\trequire triangles and hexagons, so on occasion, I'll make use of those too. Like \n\teveryone else, these single regular polygons are the ones I stick to. However, there \n\tare countless other tiling arrangements that remain underutilized, like this one.\n\n\tAs previously mentioned, this is based on a herringbone arrangement and consists of a \n    single 3 by 2 rectangle. I like this particular arrangement and tile size because it \n\thas a kind of ordered randomness feel to it that more common sizes -- like 2 by 1 -- \n\tlack. The downside is the added complexity due to the fact that grid skewing and \n\tunskewing is required to minimize the number of taps (four, all up, which is pretty\n\tgood) needed to cover the plane. I can't speak for everyone else, but I get a little\n\tconfused with logic that doesn't stay in a straight line. :)\n\n\tIn regard to the code, it's all been patched together from my other examples. It's \n\treasonably efficient, but probably not organized as much as I'd like. I've employed\n\ta lot of standard prioritization techniques, like raymarching the main objects and\n\tadding smaller details via bump mapping, etc. I've also used cheaper functions where\n\tpossible. By the way, I have a 2D example featuring the same herringbone pattern that \n\tI'll put up later, which will be a little easier to decipher.\n\n\tWhenever putting something relatively simple, like this, together, I always appreciate \n\tthe amount of work that goes into virtually all of Dr2's examples. I have a couple of \n\tinteresting 3D examples coming up, but for now, I'm going back to simpler 2D stuff. :)\n    \n\t\n\n\n\tRelated examples:\n\n\t\/\/ This was the only herringbone pattern example I could find on Shadertoy, and from\n\t\/\/ what I can see, Fabrice has covered Nx1 (Whole integer multiples), which don't \n    \/\/ require skewing. I have an extruded example that cover this range and half integer\n    \/\/ multiples as well, but I need to think of an interesting scene first. Perhaps,\n\t\/\/ I'll leave that to Fabrice. :)\n\tHerringbone pattern - FabriceNeyret2 \n    https:\/\/www.shadertoy.com\/view\/4dVyDw\n\n\t\/\/ One of my favorite simple coloring jobs.\n    Skin Peeler - Dave Hoskins\n    https:\/\/www.shadertoy.com\/view\/XtfSWX\n    Based on one of my all time favorites:\n    Xyptonjtroz - Nimitz\n\thttps:\/\/www.shadertoy.com\/view\/4ts3z2\n\n*\/\n\n\/\/ Cheap, and very lazy, night time postprocessing. Kind of effective though. :)\n\/\/#define NIGHT\n\n\/\/ The far plane. I'd like this to be larger, but the extra iterations required to render the \n\/\/ additional scenery starts to slow things down on my slower machine.\n#define FAR 60.\n\n\n\/\/ Fabrice's concise, 2D rotation formula.\n\/\/mat2 rot2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\/\/ Standard 2D rotation formula - Nimitz says it's faster, so that's good enough for me. :)\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n\n\/\/ 3x1 hash function.\nfloat hash( vec3 p ){ return fract(sin(dot(p, vec3(21.71, 157.97, 113.43)))*45758.5453); }\n\n\n\/\/ Commutative smooth maximum function. Provided by Tomkh, and taken \n\/\/ from Alex Evans's (aka Statix) talk: \n\/\/ http:\/\/media.lolrus.mediamolecule.com\/AlexEvans_SIGGRAPH-2015.pdf\n\/\/ Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n    \n   float f = max(0., 1. - abs(b - a)\/k);\n   return max(a, b) + k*.25*f*f;\n}\n\n\n\/\/ Commutative smooth minimum function. Provided by Tomkh, and taken \n\/\/ from Alex Evans's (aka Statix) talk: \n\/\/ http:\/\/media.lolrus.mediamolecule.com\/AlexEvans_SIGGRAPH-2015.pdf\n\/\/ Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)\/k);\n   return min(a, b) - k*.25*f*f;\n}\n\n\n\/\/ Tri-Planar blending function. Based on an old Nvidia tutorial by Ryan Geiss.\nvec3 tex3D( sampler2D t, in vec3 p, in vec3 n ){ \n    \n    n = max(abs(n) - .2, 0.001); \/\/ max(abs(n), 0.001), etc.\n    n \/= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    \/\/ Textures are stored in sRGB (I think), so you have to convert them to linear space \n    \/\/ (squaring is a rough approximation) prior to working with them... or something like that. :)\n    \/\/ Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\n\n\n#define RIGID\n\/\/ Standard 2x2 hash algorithm.\nvec2 hash22(vec2 p) {\n    \n    \/\/ Faster, but probaly doesn't disperse things as nicely as other methods.\n    float n = sin(dot(p, vec2(113, 1)));\n    p = fract(vec2(2097152, 262144)*n)*2. - 1.;\n    #ifdef RIGID\n    return p;\n    #else\n    return cos(p*6.283 + iGlobalTime);\n    \/\/return abs(fract(p+ iGlobalTime*.25)-.5)*2. - .5; \/\/ Snooker.\n    \/\/return abs(cos(p*6.283 + iGlobalTime))*.5; \/\/ Bounce.\n    #endif\n\n}\n\n\n\/\/ Gradient noise. Ken Perlin came up with it, or a version of it. Either way, this is\n\/\/ based on IQ's implementation. It's a pretty simple process: Break space into squares, \n\/\/ attach random 2D vectors to each of the square's four vertices, then smoothly \n\/\/ interpolate the space between them.\nfloat gradN2D(in vec2 f){\n    \n    \/\/ Used as shorthand to write things like vec3(1, 0, 1) in the short form, e.yxy. \n   const vec2 e = vec2(0, 1);\n   \n    \/\/ Set up the cubic grid.\n    \/\/ Integer value - unique to each cube, and used as an ID to generate random vectors for the\n    \/\/ cube vertiies. Note that vertices shared among the cubes have the save random vectors attributed\n    \/\/ to them.\n    vec2 p = floor(f);\n    f -= p; \/\/ Fractional position within the cube.\n    \n\n    \/\/ Smoothing - for smooth interpolation. Use the last line see the difference.\n    \/\/vec2 w = f*f*f*(f*(f*6.-15.)+10.); \/\/ Quintic smoothing. Slower and more squarish, but derivatives are smooth too.\n    vec2 w = f*f*(3. - 2.*f); \/\/ Cubic smoothing. \n    \/\/vec2 w = f*f*f; w = ( 7. + (w - 7. ) * f ) * w; \/\/ Super smooth, but less practical.\n    \/\/vec2 w = .5 - .5*cos(f*3.14159); \/\/ Cosinusoidal smoothing.\n    \/\/vec2 w = f; \/\/ No smoothing. Gives a blocky appearance.\n    \n    \/\/ Smoothly interpolating between the four verticies of the square. Due to the shared vertices between\n    \/\/ grid squares, the result is blending of random values throughout the 2D space. By the way, the \"dot\" \n    \/\/ operation makes most sense visually, but isn't the only metric possible.\n    float c = mix(mix(dot(hash22(p + e.xx), f - e.xx), dot(hash22(p + e.yx), f - e.yx), w.x),\n                  mix(dot(hash22(p + e.xy), f - e.xy), dot(hash22(p + e.yy), f - e.yy), w.x), w.y);\n    \n    \/\/ Taking the final result, and converting it to the zero to one range.\n    return c*.5 + .5; \/\/ Range: [0, 1].\n}\n\n\/\/ Gradient noise fBm.\nfloat fBm(in vec2 p){\n    \n    return gradN2D(p)*.57 + gradN2D(p*2.)*.28 + gradN2D(p*4.)*.15;\n    \n}\n\n\n\/\/ Cheap and nasty 2D smooth noise function with inbuilt hash function - based on IQ's \n\/\/ original. Very trimmed down. In fact, I probably went a little overboard. I think it \n\/\/ might also degrade with large time values. I'll swap it for something more robust later.\nfloat n2D(vec2 p) {\n\n\tvec2 i = floor(p); p -= i; \n    \/\/p *= p*p*(p*(p*6. - 15.) + 10.);\n    p *= p*(3. - p*2.);  \n    \n\treturn dot(mat2(fract(sin(vec4(0, 1, 113, 114) + dot(i, vec2(1, 113)))*43758.5453))*\n                vec2(1. - p.y, p.y), vec2(1. - p.x, p.x) );\n\n}\n\n\n\/\/ Like above, but with no smoothing. Uses for the extruded brick height, so the smoothing\n\/\/ isn't noticeable, so we may as well cut the line out and save the GPU some work.\nfloat n2DS(vec2 p) {\n\n\tvec2 i = floor(p); p -= i; \n    \/\/p *= p*p*(p*(p*6. - 15.) + 10.);\n    \/\/p *= p*(3. - p*2.);  \n    \n\treturn dot(mat2(fract(sin(vec4(0, 1, 113, 114) + dot(i, vec2(1, 113)))*43758.5453))*\n                vec2(1. - p.y, p.y), vec2(1. - p.x, p.x) );\n\n}\n\n\/\/ The path is a 2D sinusoid that varies over time, which depends upon the frequencies and amplitudes.\nvec2 path(in float z){ \n    \n    return vec2(6.*sin(z * .1), 0);\n}\n\n\/\/ A very cheap surface function. Used for the underlying sand surface.\nfloat surfFunc( in vec3 p){\n    \n    \/\/ More expensive, but not noticeable enough to use.\n    \/\/p \/= 3.;\n    \/\/return n2D(p.xz)*.57 + n2D(p.xz*2.)*.28 + n2D(p.xz*4.)*.15;\n    \n    \/\/ Just two layers.\n    p \/= 2.5;\n    return n2D(p.xz)*.67 + n2D(p.xz*2.)*.33;\n    \n\n}\n\n\/\/ vec2 to vec2 hash.\nvec2 hash22B(vec2 p) { \n\n    \/\/ Faster, but doesn't disperse things quite as nicely. However, when framerate\n    \/\/ is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    \/\/ amalgamation I put together, based on a couple of other random algorithms I've \n    \/\/ seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(27, 57)));\n    return fract(vec2(262144, 32768)*n)*2. - 1.; \n    \n    \/\/ Animated.\n    \/\/p = fract(vec2(262144, 32768)*n);\n    \/\/return sin(p*6.2831853 + iTime); \n    \n}\n \n\/\/ Based on IQ's gradient noise formula.\nfloat n2D3G(in vec2 p){\n   \n    vec2 i = floor(p); p -= i;\n    \n    vec4 v;\n    v.x = dot(hash22(i), p);\n    v.y = dot(hash22(i + vec2(1, 0)), p - vec2(1, 0));\n    v.z = dot(hash22(i + vec2(0, 1)), p - vec2(0, 1));\n    v.w = dot(hash22(i + 1.), p - 1.);\n\n#if 1\n    \/\/ Quintic interpolation.\n    p = p*p*p*(p*(p*6. - 15.) + 10.);\n#else\n    \/\/ Cubic interpolation.\n    p = p*p*(3. - 2.*p);\n#endif\n\n    return mix(mix(v.x, v.y, p.x), mix(v.z, v.w, p.x), p.y);\n    \/\/return v.x + p.x*(v.y - v.x) + p.y*(v.z - v.x) + p.x*p.y*(v.x - v.y - v.z + v.w);\n}\n\n\n\/\/ Height map values. Just some noise, with a path cut out for the camera to go through.\nfloat hm(in vec2 p){\n    \n    \/\/ Camera path. \n    vec2 pth = p.xy - path(p.y);\n    float camPath = abs(pth.x);\n    \n    \/\/ Scaling.\n    p = p\/2.5;\/\/ + iTime\/4.;\n    \n    \/\/ Noise, for the terrain, or block heights\n    float n = n2DS(p.xy + 7.5);\/\/*.67 + n2D(p.xy*2.)*.33;\n    \n    \/\/ Cutting a camera path out of the noisy terrain.\n    n = smoothstep(.2, 1., n)*clamp(camPath - .6, 0., 1.);\n \n    \n    return n; \/\/ Range [0, 1]... hopefully. :)\n\n}\n\n\n\nfloat sBox(in vec3 p, in vec3 b){\n   \n\n  vec3 d = abs(p) - b;\n  return min(max(max(d.x, d.y), d.z), 0.) + length(max(d, 0.));\n}\n\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n   \n\n  vec2 d = abs(p) - b + sf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - sf;\n}\n\n\/*\nfloat sBoxS(in vec3 p, in vec3 b, in float sf){\n   \n\n  vec3 d = abs(p) - b + sf;\n  return min(max(max(d.x, d.y), d.z), 0.) + length(max(d, 0.)) - sf;\n}\n*\/\n\n\/\/ IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h){\n    \n    \n    vec2 w = vec2( sdf, abs(pz) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n\n    \/*\n    \/\/ Slight rounding. A little nicer, but I want to save every operation\n    \/\/ I can.\n    const float sf = .005;\n    vec2 w = vec2( sdf, abs(pz) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w + sf, 0.)) - sf;\n    *\/\n}\n\n \n\/\/ Skewing and unskewing.\nvec2 skewXY(vec2 p, vec2 v){ return mat2(1, -v.y, v.x, 1)*p; }\nvec2 unskewXY(vec2 p, vec2 v){ return inverse(mat2(1, -v.y, v.x, 1))*p; }\n\n \n\/\/ Extruded 3 by 2 bricks, laid out in a herringbone formation with heights\n\/\/ derived from a simple height function. It was a little fiddly to code,\n\/\/ but anyone could figure it out.\nvec4 herringbone3D(vec3 q3){\n    \n    \/\/ Scale.\n    const float scale = 1.\/3.;\n    \/\/ Skewing vector. Each brick staggers down by this amount... for some\n    \/\/ reason that made sense to me at the time... I should probably write \n    \/\/ these things down. :D\n\tconst vec2 sk = vec2(1, -1)\/5.; \/\/ 12 x .2\n    \/\/ Brick dimension: Length to height ratio with additional scaling.\n\tconst vec2 dim = vec2(1.5, 1)*scale;\n    \/\/ A helper vector, but basically, it's the size of the repeat cell.\n    \/\/ Again, the little correction factor made sence to me at the time.\n    \/\/ When the reasoning comes to me, I'll update the comments. :)\n\tvec2 s = (vec2(2.5, 2.5) - abs(sk)\/2.)*scale; \/\/ 12 x .2\n\n    \/\/ A hacky Z-scaling factor to help avoid artifacts. In case it isn't \n    \/\/ obvious, I didn't enjoy coding this. :D\n    q3.y *= scale\/2.;\n    \n    \n    \/\/ Distance.\n    float d = 1e5;\n    \/\/ Cell center, local coordinates and overall cell ID.\n    vec2 cntr, p, ip;\n    \n    \/\/ Individual brick ID.\n    vec2 id = vec2(0);\n    vec2 l = dim;\n    cntr = vec2(0);\n    float boxID = 0.; \/\/ Box ID. Not used in this example, but helpful.\n    \n    for(int i = 0; i<4; i++){\n         \n        if(i==2) {\n            cntr = vec2((dim.x + dim.y)\/2., -dim.y\/4.);\n            l = l.yx;\n        }\n\n        \/\/ Working with skewed grids can be a bit confusing, but it's not\n        \/\/ so bad. However, following someone elses logic is always confusing,\n        \/\/ so for now, just trust that this particular process works. If you're\n        \/\/ like me, and you need to do things for yourself, create a pattern\n        \/\/ that involves a skewed grid, and the following should make more sense.\n        \/\/ \n        \/\/ Local coordinates, based on a square grid.\n        p = q3.xz - cntr;\n        p = skewXY(p, sk); \/\/ Skewing by the X and Y skewing values.\n        ip = floor(p\/s) + .5; \/\/ Local tile ID.\n        p -= (ip)*s; \/\/ New local position.\n        p = unskewXY(p, sk); \/\/ Unskewing.\n\n\n        \/\/ At the this point, you render whatever object you wish to render, just\n        \/\/ like with any other grid. In this case it's an extruded pylon that \n        \/\/ takes its height from a height map function.\n        \n        \/\/ Rounded box.\n        float di2D = sBoxS(p, l\/2., .04);\n        \/\/ Correct positional individual tile ID.\n        vec2 idi = ip*s + cntr;\n        \/\/ Don't forget to unskew the ID... Yeah, skewing is confusing. :)\n        idi = unskewXY(idi, sk);\n        \/\/ The extruded block height. See the height map function, above. I've\n        \/\/ Also used to the floor function to snap the heights to specific\n        \/\/ quantized values.\n        float h = max(floor(hm(idi)*24.999)\/24., 0.)*.5 + .002;\n        \n        \/\/ The extruded distance function value.\n        float di = opExtrusion(di2D + .01, q3.y - h, h);\n\n        \/\/ For all tiles above a certain height, bore out the center to give it\n        \/\/ a Besser block feel.\n        if(h>.0025){\n\n            di = max(di, -(di2D + .1));\n        }\n\n\n        \/\/ If necessary, update the minimum tile value, position-based ID, and block ID.\n        if(di<d){\n            d = di;\n            id = idi;\n            boxID = float(i);\n\n        }\n\n        \/\/ Move the grid center to the new position. From the pattern, you can see that\n        \/\/ each tile is rendered down by factor equivalent to the longest length.\n        cntr -= -dim.y;\n        \n    }\n    \n    \/\/ Return the distance, unskewed position-base ID and box ID.\n    return vec4(d, id, boxID);\n}\n\n\/\/ Brick ID and scene object ID.\nvec2 bID;\nvec3 objID;\n\n\/\/ The flat shaded terrain and the mesh.\nfloat map(vec3 p){\n    \n    \n    \/\/ Terrain function. Essentially, the sand, in this case. \n    float ter = p.y + (.5 - surfFunc(p))*.8 - .05;\n\n    \/\/ The extruded herringbone heightmap.\n    vec4 her = herringbone3D(p); \n\n    \/\/ The individual brick pylon ID.\n    bID = her.yz;\n    \n \n    \/\/ Placing the individual object IDs in a container. This will\n    \/\/ be sorted outside the loop. It's also necessary to compare\n    \/\/ values, to mix materials. Like, for instance, where the sand\n    \/\/ meets the brick surface.\n    objID = vec3(ter, her.x, 1e5);\n    \n    \n    \/\/ Combining the blocks with the terrain. I've combined them with \n    \/\/ a touch of smoothing to make it look a little more organic.\n    return smin(ter, her.x, .005);\n \n}\n\n\n\/\/ Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    float t = 0., d;\n    \n    \/\/ Hack to force loop unrolling. I can't say I'm happy with it, but it is what it is. :)\n    \/\/ If someone has a better idea, feel free to let me know.\n    \/\/int zer = int(min(iTime, 0.)); \n    for(int i = 0; i<128; i++){\n    \n        d = map(ro + rd*t);\n        \/\/ Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        \/\/ \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001*(t*.05 + 1.) || t>FAR) break; \/\/ Alternative: 0.001*max(t*.25, 1.), etc.\n        \n        \/\/ I concocted this mess in a desperate attempt to get more mileage out of the ray, and \n        \/\/ amazingly, it worked. Having said that, you probably shouldn't try this at home. :D\n        t += i<32? d*.75 : d*(1. + t*.05); \n    }\n\n    return min(t, FAR);\n}\n\n\n\/*\n\/\/ Tetrahedral normal - courtesy of IQ. I'm in saving mode, so the two \"map\" calls saved make\n\/\/ a difference. Also because of the random nature of the scene, the tetrahedral normal has the \n\/\/ same aesthetic effect as the regular - but more expensive - one, so it's an easy decision.\nvec3 normal(in vec3 p, float ef)\n{  \n    vec2 e = vec2(-1, 1)*.001*ef;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n*\/\n\n \n\/\/ Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 normal(in vec3 p, float ef) {\n\tvec2 e = vec2(.001*ef, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n\/*\n\/\/ Tri-Planar blending function. Based on an old Nvidia writeup:\n\/\/ GPU Gems 3 - Ryan Geiss: https:\/\/developer.nvidia.com\/gpugems\/GPUGems3\/gpugems3_ch01.html\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n ){\n    \n    n = max(abs(n) - .2, 0.001);\n    n \/= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, fract(p.zx)).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n\n    \/\/ Textures are stored in sRGB (I think), so you have to convert them to linear space \n    \/\/ (squaring is a rough approximation) prior to working with them... or something like that. :)\n    \/\/ Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n    \n}\n\n\n\/\/ Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    \/\/ Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; \/\/ Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )\/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); \/\/ Bumped normal. \"bf\" - bump factor.\n\t\n}\n*\/\n\n\/\/ Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n\/\/ example that explains it, if you require it.\nfloat n3D(in vec3 p){\n    \n\tconst vec3 s = vec3(113, 157, 1);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); \/\/p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); \/\/ Range: [0, 1].\n}\n\n\n\n\n\n\/\/ A global value to record the distance from the camera to the hit point. It's used to tone\n\/\/ down the sand height values that are further away. If you don't do this, really bad\n\/\/ Moire artifacts will arise. By the way, you should always avoid globals, if you can, but\n\/\/ I didn't want to pass an extra variable through a bunch of different functions.\nfloat gT;\n\n\/\/ Surface bump function..\nfloat bumpSurf3D( in vec3 p){\n    \n    \n    \n    p *= vec3(1.65, 2.2, 3.85);\n    \/\/float ns = n2D(p.xz)*.57 + n2D(p.xz*2.)*.28 + n2D(p.xz*4.)*.15;\n    float ns = n3D(p)*.57 + n3D(p*2.)*.28 + n3D(p*4.)*.15;\n    \n    \/\/ vec2 q = rot2(-3.14159\/5.)*p.xz;\n    \/\/ float ns1 = grad(p.z*32., 0.);\/\/*clamp(p.y*5., 0., 1.);\/\/smoothstep(0., .1, p.y);\/\/\n    \/\/ float ns2 = grad(q.y*32., 0.);\/\/*clamp(p.y*5., 0., 1.);\/\/smoothstep(0., .1, p.y);\/\/\n    \/\/ ns = mix(ns1, ns2, ns);\n    \n    ns = (1. - abs(smoothstep(0., 1., ns) - .5)*2.);\n    ns = mix(ns, smoothstep(0., 1., ns), .65);\n    \n    \/\/ Use the height to taper off the sand edges, before returning.\n    ns = ns*smoothstep(0., .2, p.y - .075);\n    \n    \n    \/\/ A surprizingly simple and efficient hack to get rid of the super annoying Moire pattern \n    \/\/ formed in the distance. Simply lessen the value when it's further away. Most people would\n    \/\/ figure this out pretty quickly, but it took far too long before it hit me. :)\n    return ns\/(1. + gT*gT*.015);\n    \n\n}\n\n\/\/ Standard function-based bump mapping routine: This is the cheaper four tap version. There's\n\/\/ a six tap version (samples taken from either side of each axis), but this works well enough.\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    \/\/ Larger sample distances give a less defined bump, but can sometimes lessen the aliasing.\n    const vec2 e = vec2(0.001, 0); \n    \n    \/\/ Gradient vector: vec3(df\/dx, df\/dy, df\/dz);\n    float ref = bumpSurf3D(p);\n    vec3 grad = (vec3(bumpSurf3D(p - e.xyy),\n                      bumpSurf3D(p - e.yxy),\n                      bumpSurf3D(p - e.yyx)) - ref)\/e.x; \n    \n    \/*\n    \/\/ Six tap version, for comparisson. No discernible visual difference, in a lot of cases.\n    vec3 grad = vec3(bumpSurf3D(p - e.xyy) - bumpSurf3D(p + e.xyy),\n                     bumpSurf3D(p - e.yxy) - bumpSurf3D(p + e.yxy),\n                     bumpSurf3D(p - e.yyx) - bumpSurf3D(p + e.yyx))\/e.x*.5;\n    *\/\n       \n    \/\/ Adjusting the tangent vector so that it's perpendicular to the normal. It's some kind \n    \/\/ of orthogonal space fix using the Gram-Schmidt process, or something to that effect.\n    grad -= nor*dot(nor, grad);          \n         \n    \/\/ Applying the gradient vector to the normal. Larger bump factors make things more bumpy.\n    return normalize(nor + grad*bumpfactor);\n\t\n}\n\n\/\/ Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n\/\/ iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    \/\/ More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 32; \n    \n    ro += n*.0015;\n    vec3 rd = lp - ro; \/\/ Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.;\/\/.0015; \/\/ Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    \/\/float stepDist = end\/float(maxIterationsShad);\n    rd \/= end;\n\n    \/\/ Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    \/\/ number to give a decent shadow is the best one to choose. \n    \/\/int zer = int(min(iTime, 0.)); \/\/ Hack to force loop unrolling.\n    for (int i = 0; i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d\/t);\n        \/\/shade = min(shade, smoothstep(0., 1., k*h\/dist)); \/\/ Subtle difference. Thanks to IQ for this tidbit.\n        \/\/ So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d*.75, .05, .35); \n        \n        \n        \/\/ Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    \/\/ Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    \/\/ It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    \/\/ AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n\n\/\/ I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n\/\/ Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 3., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15\/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n    \n    \n}\n\n\n\/\/ Standard sky routine: Gradient with sun and overhead cloud plane. I debated over whether to put more \n\/\/ effort in, but the dust is there and I'm saving cycles. I originally included sun flares, but wasn't \n\/\/ feeling it, so took them out. I might tweak them later, and see if I can make them work with the scene.\nvec3 getSky(vec3 ro, vec3 rd, vec3 ld){ \n    \n    \/\/ Sky color gradients.\n    vec3 col = vec3(.8, .7, .5), col2 = vec3(.4, .6, .9);\n    \n    \/\/ Probably a little too simplistic. :)\n    \/\/return mix(col, col2, pow(max(rd.y*.5 + .9, 0.), 5.))*vec3(1.2, .95, .7); \n    \n    \/\/ Mix the gradients using the Y value of the unit direction ray. \n    vec3 sky = mix(col, col2, pow(max(rd.y + .15, 0.), .5));\n    \/\/sky *= vec3(.84, 1, 1.17); \/\/ Adding some extra vibrancy.\n    \n     \n    float sun = clamp(dot(ld, rd), 0., 1.);\n    sky += vec3(1, .7, .4)*vec3(pow(sun, 16.))*.2; \/\/ Sun flare, of sorts.\n    sun = pow(sun, 32.); \/\/ Not sure how well GPUs handle really high powers, so I'm doing it in two steps.\n    sky += vec3(1, .9, .7)*vec3(pow(sun, 32.))*.35\/vec3(1.2, 1, .8); \/\/ Sun.\n    \n     \/\/ Subtle, fake sky curvature.\n    rd.z *= 1. + length(rd.xy)*.15;\n    rd = normalize(rd);\n   \n    \/\/ A simple way to place some clouds on a distant plane above the terrain -- Based on something IQ uses.\n    const float SC = 1e5;\n    float t = (SC - ro.y - .15)\/(rd.y + .15); \/\/ Trace out to a distant XZ plane.\n    vec2 uv = (ro + t*rd).xz; \/\/ UV coordinates.\n    \n    \/\/ Mix the sky with the clouds, whilst fading out a little toward the horizon (The rd.y bit).\n\tif(t>0.) sky =  mix(sky, vec3(2), smoothstep(.45, 1., fBm(1.5*uv\/SC))*\n                        smoothstep(.45, .55, rd.y*.5 + .5)*.4);\n    \n    \/\/ Return the sky color.\n    return sky*vec3(1.2, 1, .8);\n     \n}\n\n\n\n\/\/ More concise, self contained version of IQ's original 3D noise function.\nfloat noise3D(in vec3 p){\n    \n    \/\/ Just some random figures, analogous to stride. You can change this, if you want.\n\tconst vec3 s = vec3(113, 157, 1);\n\t\n\tvec3 ip = floor(p); \/\/ Unique unit cell ID.\n    \n    \/\/ Setting up the stride vector for randomization and interpolation, kind of. \n    \/\/ All kinds of shortcuts are taken here. Refer to IQ's original formula.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    \n\tp -= ip; \/\/ Cell's fractional component.\n\t\n    \/\/ A bit of cubic smoothing, to give the noise that rounded look.\n    p = p*p*(3. - 2.*p);\n    \n    \/\/ Standard 3D noise stuff. Retrieving 8 random scalar values for each cube corner,\n    \/\/ then interpolating along X. There are countless ways to randomize, but this is\n    \/\/ the way most are familar with: fract(sin(x)*largeNumber).\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n\t\n    \/\/ Interpolating along Y.\n    h.xy = mix(h.xz, h.yw, p.y);\n    \n    \/\/ Interpolating along Z, and returning the 3D noise value.\n    return mix(h.x, h.y, p.z); \/\/ Range: [0, 1].\n\t\n}\n\n\/\/\/\/\/\n\/\/ Code block to produce some layers of smokey haze. Not sophisticated at all.\n\/\/ If you'd like to see a much more sophisticated version, refer to Nitmitz's\n\/\/ Xyptonjtroz example. Incidently, I wrote this off the top of my head, but\n\/\/ I did have that example in mind when writing this.\n\n\/\/ Hash to return a scalar value from a 3D vector.\nfloat hash31(vec3 p){ return fract(sin(dot(p, vec3(127.1, 311.7, 74.7)))*43758.5453); }\n\n\/\/ Several layers of cheap noise to produce some subtle smokey haze.\n\/\/ Start at the ray origin, then take some samples of noise between it\n\/\/ and the surface point. Apply some very simplistic lighting along the \n\/\/ way. It's not particularly well thought out, but it doesn't have to be.\nfloat getMist(in vec3 ro, in vec3 rd, in vec3 lp, in float t){\n\n    float mist = 0.;\n    \n    \/\/ro -= vec3(0, 0, iTime*3.);\n    \n    float t0 = 0.;\n    \n    for (int i = 0; i<24; i++){\n        \n        \/\/ If we reach the surface, don't accumulate any more values.\n        if (t0>t) break; \n        \n        \/\/ Lighting. Technically, a lot of these points would be\n        \/\/ shadowed, but we're ignoring that.\n        float sDi = length(lp-ro)\/FAR; \n\t    float sAtt = 1.\/(1. + sDi*.25);\n\t    \n        \/\/ Noise layer.\n        vec3 ro2 = (ro + rd*t0)*2.5;\n        float c = noise3D(ro2)*.65 + noise3D(ro2*3.)*.25 + noise3D(ro2*9.)*.1;\n        \/\/float c = noise3D(ro2)*.65 + noise3D(ro2*4.)*.35; \n\n        float n = c;\/\/max(.65-abs(c - .5)*2., 0.);\/\/smoothstep(0., 1., abs(c - .5)*2.);\n        mist += n*sAtt;\n        \n        \/\/ Advance the starting point towards the hit point. You can \n        \/\/ do this with constant jumps (FAR\/8., etc), but I'm using\n        \/\/ a variable jump here, because it gave me the aesthetic \n        \/\/ results I was after.\n        t0 += clamp(c*.25, .1, 1.);\n        \n    }\n    \n    \/\/ Add a little noise, then clamp, and we're done.\n    return max(mist\/48., 0.);\n    \n    \/\/ A different variation (float n = (c. + 0.);)\n    \/\/return smoothstep(.05, 1., mist\/32.);\n\n}\n\n\/\/\/\/\/\/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\t\n\n\n\t\n\t\/\/ Screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*.5)\/iResolution.y;\n\t\n\t\/\/ Camera Setup.     \n\tvec3 ro = vec3(0, 1.5, iTime*2.); \/\/ Camera position, doubling as the ray origin.\n    vec3 lk = ro + vec3(0, -.1, .5);  \/\/ \"Look At\" position.\n    \n\t\n\t\/\/ Using the Z-value to perturb the XY-plane.\n\t\/\/ Sending the camera and \"look at\" vectors down the tunnel. The \"path\" function is \n\t\/\/ synchronized with the distance function.\n\tro.xy += path(ro.z);\n\tlk.xy += path(lk.z);\n\n \n    \/\/ Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159265\/2.5; \/\/ FOV - Field of view.\n    vec3 fw = normalize(lk - ro);\n    vec3 rt = normalize(vec3(fw.z, 0, -fw.x )); \n    vec3 up = cross(fw, rt);\n\n    \/\/ rd - Ray direction.\n    vec3 rd = normalize(fw + (u.x*rt + u.y*up)*FOV);\n    \/\/ Warping the ray to give that curved lens effect.\n    rd = normalize(vec3(rd.xy, rd.z*(1. - length(rd.xy)*.25)));\n    \n    \/\/ Swiveling the camera about the XY-plane (from left to right) when turning corners.\n    \/\/ Naturally, it's synchronized with the path in some kind of way.\n\trd.xy = rot2( path(lk.z).x\/48.)*rd.xy;\n    \n\t\n    \/\/ Usually, you'd just make this a unit directional light, and be done with it, but I\n    \/\/ like some of the angular subtleties of point lights, so this is a point light a\n    \/\/ long distance away. Fake, and probably not advisable, but no one will notice.\n    vec3 lp = vec3(FAR*.25, FAR*.35, FAR) + vec3(0, 0, ro.z);\n \n\n\t\/\/ Raymarching.\n    float t = trace(ro, rd);\n    \n    \/\/ Saving objects.\n    vec2 svBID = bID;\n    vec3 oSvObjID = objID; \/\/ Saving the list of object IDs for blending purposes.\n    \/\/ Closest object ID.\n    float svObjID = objID.x < objID.y? 0. : 1.;\n\n    \/\/ Global distance. Used to mitigate Moire pattern effects.\n    gT = t;\n   \n    \/\/ Sky. Only retrieving a single color this time.\n    \/\/vec3 sky = getSky(rd);\n    \n    \/\/ The passage color.\n    vec3 col = vec3(0);\n    \n    \/\/ Surface point. \"t\" is clamped to the maximum distance, and I'm reusing it to render\n    \/\/ the mist, so that's why it's declared in an untidy position outside the block below...\n    \/\/ It seemed like a good idea at the time. :)\n    vec3 sp = ro + t*rd; \n    \n    float pathHeight = sp.y;\/\/surfFunc(sp);\/\/ - path(sp.z).y; \/\/ Path height line, of sorts.\n    \n    \/\/ If we've hit the ground, color it up.\n    if (t < FAR){\n    \n        \n        vec3 sn = normal(sp, 1.); \/\/ Surface normal. \/\/*(1. + t*.125)\n        \n        \/\/ Light direction vector. From the sun to the surface point. We're not performing\n        \/\/ light distance attenuation, since it'll probably have minimal effect.\n        vec3 ld = lp - sp;\n        float lDist = max(length(ld), 0.001);\n        ld \/= lDist; \/\/ Normalize the light direct vector.\n        \n        lDist \/= FAR; \/\/ Scaling down the distance to something workable for calculations.\n        float atten = 1.\/(1. + lDist*lDist*.05);\n\n        \n        \/\/ Texture scale factor.        \n        const float tSize = 1.\/8.;\n        \n        \n        \/\/ Function based bump mapping.\n        if(svObjID==0.) sn = doBumpMap(sp, sn, .1);\/\/\/(1. + t*t\/FAR\/FAR*.25)\n        \n        \/\/ Texture bump mapping.\n        float bf = .01;\/\/(pathHeight + 5. < 0.)?  .05: .025;\n        \/\/sn = doBumpMap(iChannel0, sp*tSize, sn, bf\/(1. + t\/FAR));\n        \n        \n        \/\/ Soft shadows and occlusion.\n        float sh = softShadow(sp, lp, sn, 8.);\n        float ao = calcAO(sp, sn); \/\/ Ambient occlusion.\n        \n        \/\/ Add AO to the shadow. No science, but adding AO to things sometimes gives a bounced light look.\n        sh = min(sh + .25, 1.); \n        \n        float dif = max( dot( ld, sn ), 0.); \/\/ Diffuse term.\n        float spe = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 5.); \/\/ Specular term.\n        float fre = clamp(1.0 + dot(rd, sn), 0., 1.); \/\/ Fresnel reflection term.\n \n        \/\/ Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        \/\/ so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        \/\/ used to give a sandstone consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.0);\n\t\tfloat fre2 = mix(.2, 1., Schlick);  \/\/F0 = .2 - Hard clay... or close enough.\n       \n        \/\/ Overal global ambience. It's made up, but I figured a little occlusion (less ambient light\n        \/\/ in the corners, etc) and reflectance would be in amongst it... Sounds good, anyway. :)\n        float amb = ao*.35;\/\/ + fre*fre2*.2;\n        \n\n        \n        \n        \n\t\t\/\/ Surface texel.\n        vec3 tx = tex3D(iChannel0, sp\/2., sn);\n \n        tx = smoothstep(-.2, .4, tx);\n    \t\/\/tx = mix(tx, vec3(1)*dot(tx, vec3(.299, .587, .114)), .5); \/\/ Toning down a little.\n        \n        vec3 sndTx = mix(vec3(1, .95, .7), vec3(.9, .6, .4), fBm(sp.xz*16.));\n        \n        vec3 col0 = col;\n        vec3 col1 = col;\n        \n        float bordCol0Col1 = oSvObjID.x - oSvObjID.y;\n        const float bordW = .1;\n        \n        \n        \/\/ Blocks.\n        if(svObjID==1. || abs(bordCol0Col1)<bordW){\n            col1 = tx*mix(vec3(1), sndTx*2., .6);\/\/\/vec3(1, .9, .8)*1.5; \n            \n            col1 *= 1.\/(1. + t*t*.005);\n            \n            vec3 bTx = texture(iChannel0, svBID).xyz; bTx *= bTx;\n            bTx =  smoothstep(0., .5, bTx);\n            \n            col1 = mix(col1, col1*bTx*2.4, .35);\n        }\n       \n        \/\/ Sand.\n        if(svObjID==0. || abs(bordCol0Col1)<bordW){\n        \n            \/\/ Give the sand a bit of a sandstone texture.\n        \tcol0 = sndTx;\/\/mix(vec3(1, .95, .7), vec3(.9, .6, .4), fBm(sp.xz*16.));\n        \tcol0 = mix(col0*1.4, col0*.6, fBm(sp.xz*32. - .5));\/\/\/(1. + t*t*.001)\n     \n             \/\/ Extra shading in the sand crevices.\n            float bSurf = bumpSurf3D(sp);\n            col0 *= bSurf*.75 + .5;\n            col0 *= vec3(1.5, 1.45, 1.3)\/2.;\n \n        }\n        \n        \n        \n        \n        \/\/ Return the color, which is either the sandy terrain color, the object color,\n    \t\/\/ or if we're in the vicinity of both, make it a mixture of the two.\n    \tcol = mix(col0, col1, smoothstep(-bordW, bordW, bordCol0Col1));\n       \n        \/\/ Lamest sand sprinkles ever. :)\n        col = mix(col*.7 + (hash(floor(sp*96.))*.7 + hash(floor(sp*192.))*.3)*.3, col, min(t*t\/FAR, 1.));\n        col *= vec3(1.2, 1, .9); \/\/ Extra color -- Part of last minute adjustments.\n    \n        \n        \/\/ Combining all the terms from above. Some diffuse, some specular - both of which are\n        \/\/ shadowed and occluded - plus some global ambience. Not entirely correct, but it's\n        \/\/ good enough for the purposes of this demonstation.        \n        col = col*(dif + amb + vec3(1, .97, .92)*fre2*spe*2.)*atten;\n        \n        \n        \/\/ A bit of sky reflection. Not really accurate, but I've been using fake physics since the 90s. :)\n        vec3 refSky = getSky(sp, reflect(rd, sn), ld);\n        col += col*refSky*.05 + refSky*fre*fre2*atten*.15; \n        \n \n        \/\/ Applying the shadows and ambient occlusion.\n        col *= sh*ao;\n\n        \n    }\n    \n  \n    \/\/ Combine the scene with the sky using some cheap volumetric substance.\n\tfloat dust = getMist(ro, rd, lp, t)*(1. - smoothstep(0., 1., pathHeight*.05));\/\/(-rd.y + 1.);\n    vec3 gLD = normalize(lp - vec3(0, 0, ro.z));\n    vec3 sky = getSky(ro, rd, gLD);\/\/*mix(1., .75, dust);\n    \/\/col = mix(col, sky, min(t*t*1.5\/FAR\/FAR, 1.)); \/\/ Quadratic fade off. More subtle.\n    col = mix(col, sky, smoothstep(0., .95, t\/FAR)); \/\/ Linear fade. Much dustier. I kind of like it.\n    \n    \n    \/\/ Mild dusty haze... Not really sure how it fits into the physical situation, but I thought it'd\n    \/\/ add an extra level of depth... or something. At this point I'm reminded of the \"dog in a tie \n    \/\/ sitting at the computer\" meme with the caption, \"I have no idea what I'm doing.\" :D\n    vec3 mistCol = vec3(1, .95, .9); \/\/ Probably, more realistic, but less interesting.\n    col += (mix(col, mistCol, .66)*.66 + col*mistCol*1.)*dust;\n    \n    \n    \/\/ Simulating sun scatter over the sky and terrain: IQ uses it in his Elevated example.\n    col += vec3(1., .7, .4)*pow( max(dot(rd, gLD), 0.), 16.)*.4;\n    \n    \n    \/\/ Applying the mild dusty haze.\n    col = col*.75 + (col + .25*vec3(1.2, 1, .9))*mistCol*dust*1.5;\n    \n    \n    \/\/ Really artificial. Kind of cool, but probably a little too much.    \n    \/\/col *= vec3(1.2, 1, .9);\n\n    #ifdef NIGHT\n    \/\/ Cheapest, laziest night time postprocessing ever. :D\n    col *= vec3(.4, .6, 1);\n    #endif\n    \n    \/\/ Standard way to do a square vignette. Note that the maxium value value occurs at \"pow(0.5, 4.) = 1.\/16,\" \n    \/\/ so you multiply by 16 to give it a zero to one range. This one has been toned down with a power\n    \/\/ term to give it more subtlety.\n    u = fragCoord\/iResolution.xy;\n    col = min(col, 1.)*pow( 16.*u.x*u.y*(1. - u.x)*(1. - u.y) , .0625);\n \n    \/\/ Rough gamma correction, and present to screen.\n\tfragColor = vec4(sqrt(clamp(col, 0., 1.)), 1);\n}",
            "name": "Image",
            "description": "",
            "type": "image"
        }
    ]
}