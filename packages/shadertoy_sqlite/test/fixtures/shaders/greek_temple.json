{
    "ver": "0.1",
    "info": {
        "id": "ldScDh",
        "date": "1492933322",
        "viewed": 27937,
        "name": "Greek Temple",
        "username": "iq",
        "description": "A basic temple model. Terrain is false perspective. No global illumination. Two sun directions. Ambient occlusion is mostly painted by hand. Bounce lighting is also painted by hand. Completed from a live coding session with the students of UPENN",
        "likes": 213,
        "published": 3,
        "flags": 32,
        "tags": [
            "procedural",
            "3d",
            "raymarching",
            "distancefield"
        ],
        "hasliked": 0
    },
    "renderpass": [
        {
            "inputs": [
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dfGRr",
                    "channel": 0
                }
            ],
            "code": "\/\/ Created by inigo quilez - iq\/2017\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ You can buy a metal print of this shader here:\n\/\/ https:\/\/www.redbubble.com\/i\/metal-print\/Greek-Temple-by-InigoQuilez\/39845587.0JXQP\n\n\/\/ A basic temple model. No global illumination, all cheated and composed to camera:\n\/\/\n\/\/ - the terrain is false perspective\n\/\/ - there are two different sun directions for foreground and background. \n\/\/ - ambient occlusion is mostly painted by hand\n\/\/ - bounce lighting is also painted by hand\n\/\/\n\/\/ This shader was made as a continuation to a live coding session I did for the students\n\/\/ of UPENN. After the initial live coded session I decided to rework it and improve it,\n\/\/ and that turned out to be a bit of a pain because when looking for the final look I got\n\/\/ trapped in more local minima that I usually do and it took me a while to leave them. \n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tivec2 p = ivec2(fragCoord-0.5);\n    \n    vec3 col = texelFetch( iChannel0, p, 0 ).xyz;\n    \n    vec2 q = fragCoord \/ iResolution.xy;\n    col *= 0.8 + 0.2*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.2 );\n\n    \n\tfragColor = vec4(col,1.0);\n}",
            "name": "Image",
            "description": "",
            "type": "image"
        },
        {
            "inputs": [
                {
                    "id": "XdX3Rn",
                    "filepath": "\/media\/a\/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg",
                    "previewfilepath": "\/media\/ap\/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg",
                    "type": "texture",
                    "channel": 2,
                    "sampler": {
                        "filter": "mipmap",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "Xsf3zn",
                    "filepath": "\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
                    "previewfilepath": "\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
                    "type": "texture",
                    "channel": 1,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "repeat",
                        "vflip": "false",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "Xsf3Rr",
                    "filepath": "\/media\/a\/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg",
                    "previewfilepath": "\/media\/ap\/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg",
                    "type": "texture",
                    "channel": 0,
                    "sampler": {
                        "filter": "mipmap",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 3,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dXGR8",
                    "channel": 0
                }
            ],
            "code": "\/\/ Created by inigo quilez - iq\/2017\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\/\/ A basic temple model. No global illumination, all cheated and composed to camera:\n\/\/\n\/\/ - the terrain is false perspective\n\/\/ - there are two different sun directions for foreground and background. \n\/\/ - ambient occlusion is mostly painted by hand\n\/\/ - bounce lighting is also painted by hand\n\/\/\n\/\/ This shader was made as a continuation to a live coding session I did for the students\n\/\/ of UPENN. After the initial live coded session I decided to rework it and improve it,\n\/\/ and that turned out to be a bit of a pain because when looking for the final look I got\n\/\/ trapped in more local m\u2642inima that I usually do and it took me a while to leave them. \n\n\/\/ TODO: fix black glitches\n\/\/       fix usdBox of rhombus with sdElogation operation\n\n\n\/\/#define STATICCAM\n\nfloat hash1( vec2 p )\n{\n    p  = 50.0*fract( p*0.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat hash( uint n ) \n{\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    \/\/ floating point conversion from http:\/\/iquilezles.org\/www\/articles\/sfrand\/sfrand.htm\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\nvec2 hash2( float n ) { return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123)); }\n\nfloat noise( in vec2 x )\n{\n    ivec2 p = ivec2(floor(x));\n    vec2 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tivec2 uv = p.xy;\n\tfloat rgA = texelFetch( iChannel1, (uv+ivec2(0,0))&255, 0 ).x;\n    float rgB = texelFetch( iChannel1, (uv+ivec2(1,0))&255, 0 ).x;\n    float rgC = texelFetch( iChannel1, (uv+ivec2(0,1))&255, 0 ).x;\n    float rgD = texelFetch( iChannel1, (uv+ivec2(1,1))&255, 0 ).x;\n    return mix( mix( rgA, rgB, f.x ),\n                mix( rgC, rgD, f.x ), f.y );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel1, (uv+0.5)\/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat fbm4( in vec3 p )\n{\n    float n = 0.0;\n    n += 1.000*noise( p*1.0 );\n    n += 0.500*noise( p*2.0 );\n    n += 0.250*noise( p*4.0 );\n    n += 0.125*noise( p*8.0 );\n    return n;\n}\n\nfloat fbm6( in vec3 p )\n{\n    float n = 0.0;\n    n += 1.00000*noise( p*1.0 );\n    n += 0.50000*noise( p*2.0 );\n    n += 0.25000*noise( p*4.0 );\n    n += 0.12500*noise( p*8.0 );\n    n += 0.06250*noise( p*16.0 );\n    n += 0.03125*noise( p*32.0 );\n    return n;\n}\n\nfloat fbm6( in vec2 p )\n{\n    float n = 0.0;\n    n += 1.00000*noise( p*1.0 );\n    n += 0.50000*noise( p*2.0 );\n    n += 0.25000*noise( p*4.0 );\n    n += 0.12500*noise( p*8.0 );\n    n += 0.06250*noise( p*16.0 );\n    n += 0.03125*noise( p*32.0 );\n    return n;\n}\n\nfloat fbm4( in vec2 p )\n{\n    float n = 0.0;\n    n += 1.00000*noise( p*1.0 );\n    n += 0.50000*noise( p*2.0 );\n    n += 0.25000*noise( p*4.0 );\n    n += 0.12500*noise( p*8.0 );\n    return n;\n}\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdRhombus( in vec2 p, in vec2 b, in float r ) \n{\n    vec2 q = abs(p);\n    float h = clamp( (-2.0*ndot(q,b) + ndot(b,b) )\/dot(b,b), -1.0, 1.0 );\n    float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\n    d *= sign( q.x*b.y + q.y*b.x - b.x*b.y );\n\treturn d - r;\n}\n\nfloat usdBox( in vec3 p, in vec3 b )\n{\n    return length( max(abs(p)-b,0.0 ) );\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdBox( float p, float b )\n{\n  return abs(p) - b;\n}\n\nvec2 opRepLim( in vec2 p, in float s, in vec2 lim )\n{\n    return p-s*clamp(round(p\/s),-lim,lim);\n}\n\nvec2 opRepLim( in vec2 p, in float s, in vec2 limmin, in vec2 limmax )\n{\n    return p-s*clamp(round(p\/s),-limmin,limmax);\n}\n\nvec4 textureGood( sampler2D sam, in vec2 uv )\n{\n    uv = uv*1024.0 - 0.5;\n    vec2 iuv = floor(uv);\n    vec2 f = fract(uv);\n    f = f*f*(3.0-2.0*f);\n\tvec4 rg1 = textureLod( sam, (iuv+ vec2(0.5,0.5))\/1024.0, 0.0 );\n\tvec4 rg2 = textureLod( sam, (iuv+ vec2(1.5,0.5))\/1024.0, 0.0 );\n\tvec4 rg3 = textureLod( sam, (iuv+ vec2(0.5,1.5))\/1024.0, 0.0 );\n\tvec4 rg4 = textureLod( sam, (iuv+ vec2(1.5,1.5))\/1024.0, 0.0 );\n\treturn mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\n}\n\n#define ZERO (min(iFrame,0))\n\n\/\/------------\n\nfloat terrain( in vec2 p )\n{\n    float h = 90.0*textureGood( iChannel2, p.yx*0.0001 + 0.35 + vec2(0.02,0.05) ).x - 70.0 + 5.0;\n    h = mix( h, -7.2, 1.0-smoothstep(16.0,60.0,length(p)));\n    h -= 7.0*textureGood( iChannel2, p*0.002 ).x;\n    float d = textureLod( iChannel0, p*0.01, 0.0 ).x;\n    h -= 1.0*d*d*d;\n    return h;\n}\n\nconst float ocean = -25.0;\n\nvec3 temple( in vec3 p )\n{\n    vec3 op = p;    \n    vec3 res = vec3(-1.0,-1.0,0.5);\n\n    p.y += 2.0;\n\n    \/\/ bounding box\n    float bbox = usdBox(p,vec3(15.0,12.0,15.0)*1.5 );\n    if( bbox>5.0 ) return vec3(bbox+1.0,-1.0,0.5);\n    vec3 q = p; q.xz = opRepLim( q.xz, 4.0, vec2(4.0,2.0) );\n    \n    \/\/ columns\n    vec2 id = floor((p.xz+2.0)\/4.0);\n\n    float d = length(q.xz) - 0.9 + 0.05*p.y;\n    d = max(d,p.y-6.0);\n    d = max(d,-p.y-5.0);\n    d -= 0.05*pow(0.5+0.5*sin(atan(q.x,q.z)*16.0),2.0);\n    d -= 0.15*pow(0.5+0.5*sin(q.y*3.0+0.6),0.12) - 0.15;\n    res.z = hash1( id + 11.0*floor(0.25 + (q.y*3.0+0.6)\/6.2831) );\n    d *= 0.85;\n    \n    {\n    vec3 qq = vec3(q.x,abs(q.y-0.3)-5.5, q.z );\n    d = min( d, sdBox( qq,vec3(1.4,0.2,1.4)+sign(q.y-0.3)*vec3(0.1,0.05,0.1))-0.1 ); \/\/ base\n    }    \n\n    d = max( d, -sdBox(p,vec3(14.0,10.0,6.0)) ); \/\/ clip in\n\n    \/\/ floor\n    float ra = 0.15 * hash1(id+vec2(1.0,3.0));\n\tq = p; q.xz = opRepLim( q.xz, 4.0, vec2(4.0,3.0) );\n    float b = sdBox( q-vec3(0.0,-6.0+0.1-ra,0.0), vec3(2.0,0.5,2.0)-0.15-ra )-0.15;\n    b *= 0.5;\n    if( b<d ) { d = b; res.z = hash1(id); }\n    \n    p.xz -= 2.0;\n    id = floor((p.xz+2.0)\/4.0);\n    ra = 0.15 * hash1(id+vec2(1.0,3.0)+23.1);\n    q = p; q.xz = opRepLim( q.xz, 4.0, vec2(5.0,4.0), vec2(5.0,3.0) );\n\tb = sdBox( q-vec3(0.0,-7.0-ra,0.0), vec3(2.0,0.6,2.0)-0.15-ra )-0.15;\n    b *= 0.8;\n    if( b<d ) { d = b; res.z = hash1( id + 13.5 ); }\n    p.xz += 2.0;\n    \n    id = floor((p.xz+2.0)\/4.0);\n    ra = 0.15 * hash1(id+vec2(1.0,3.0)+37.7);\n    q = p; q.xz = opRepLim( q.xz, 4.0, vec2(5.0,4.0) );\n\tb = sdBox( q-vec3(0.0,-8.0-ra-1.0,0.0), vec3(2.0,0.6+1.0,2.0)-0.15-ra )-0.15;\n    b *= 0.5;\n    if( b<d ) { d = b; res.z = hash1( id*7.0 + 31.1 ); }\n\n    \n    \/\/ roof\n    q = vec3( mod(p.x+2.0,4.0)-2.0, p.y, mod(p.z+0.0,4.0)-2.0 );\n    b = sdBox( q-vec3(0.0,7.0,0.0), vec3(1.95,1.0,1.95)-0.15 )-0.15;\n    b = max( b, sdBox(p-vec3(0.0,7.0,0.0),vec3(18.0,1.0,10.0)) );\n    if( b<d ) { d = b; res.z = hash1( floor((p.xz+vec2(2.0,0.0))\/4.0) + 31.1 ); }\n    \n    q = vec3( mod(p.x+0.5,1.0)-0.5, p.y, mod(p.z+0.5,1.0)-0.5 );\n    b = sdBox( q-vec3(0.0,8.0,0.0), vec3(0.45,0.5,0.45)-0.02 )-0.02;\n    b = max( b, sdBox(p-vec3(0.0,8.0,0.0),vec3(19.0,0.2,11.0)) );\n\t\/\/q = p+vec3(0.0,0.0,-0.5); q.xz = opRepLim( q.xz, 1.0, vec2(19.0,10.0) );\n    \/\/b = sdBox( q-vec3(0.0,8.0,0.0), vec3(0.45,0.2,0.45)-0.02 )-0.02;\n    if( b<d ) { d = b; res.z = hash1( floor((p.xz+0.5)\/1.0) + 7.8 ); }\n\n    \n    \n    b = sdRhombus( p.yz-vec2(8.2,0.0), vec2(3.0,11.0), 0.05 ) ;\n    q = vec3( mod(p.x+1.0,2.0)-1.0, p.y, mod(p.z+1.0,2.0)-1.0 );\n    b = max( b, -sdBox( vec3( abs(p.x)-20.0,p.y,q.z)-vec3(0.0,8.0,0.0), vec3(2.0,5.0,0.1) )-0.02 );\n    \n    b = max( b, -p.y+8.2 );\n    b = max( b, usdBox(p-vec3(0.0,8.0,0.0),vec3(19.0,12.0,11.0)) );\n    float c = sdRhombus( p.yz-vec2(8.3,0.0), vec2(2.25,8.5), 0.05 );\n    c = max( c, sdBox(abs(p.x)-19.0,2.0) );\n    b = max( b, -c );    \n    \n\n    d = min( d, b );\n\n    d = max( d,-sdBox(p-vec3(0.0,9.5,0.0),vec3(15.0,4.0,9.0)) );\n\n\n    d -= 0.02*smoothstep(0.5,1.0,fbm4( p.zxy ));\n    d -= 0.01*smoothstep(0.4,0.8,fbm4( op*3.0 ));\n    d += 0.005;\n    \n    res = vec3( d, 1.0, res.z );\n\n    return res;\n}\n\nvec3 map( in vec3 p )\n{\n    vec3 res = temple(p);\n    \n    {\n        float h = terrain( p.xz );\n        float m = p.y - h;\n        m *= 0.35;\n        if( m<res.x ) res = vec3( m, 2.0, 0.0 );\n    }\n    \n\n    {\n        float w = p.y + 25.0;\n        if( w<res.x ) res = vec3(w,3.0, 0.0 );\n    }\n\n    return res;\n}\n\n\/\/ http:\/\/iquilezles.org\/www\/articles\/normalsSDF\/normalsSDF.htm\nvec3 calcNormal( in vec3 p, in float t )\n{\n#if 0    \n    float e = 0.001*t;\n\n    vec2 h = vec2(1.0,-1.0)*0.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e ).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e ).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e ).x );\n#else    \n    \/\/ inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*0.001*t).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n    vec2 ma = vec2(0.0);\n\n    vec3 res = vec3(-1.0);\n    \n    float tmax = 1000.0;\n\n    float tp = (ocean-ro.y)\/rd.y;\n    if( tp>0.0 )\n    {\n        tmax = tp;\n        res = vec3( tp, 3.0, 0.0 );\n    }\n        \n    float t = 10.0;\n    for( int i=0; i<256; i++ )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 h = map( pos );\n        if( h.x<(0.0001*t) || t>tmax ) break;\n        t += h.x;\n\n        ma = h.yz;\n    }\n\n    if( t<tmax )\n    {\n    \tres = vec3(t, ma);\n    }\n\n    return res;\n}\n\nvec4 textureBox( in sampler2D tex, in vec3 pos, in vec3 nor )\n{\n    vec4 cx = texture( tex, pos.yz );\n    vec4 cy = texture( tex, pos.xz );\n    vec4 cz = texture( tex, pos.xy );\n    vec3 m = nor*nor;\n    return (cx*m.x + cy*m.y + cz*m.z)\/(m.x+m.y+m.z);\n}\n\nfloat calcShadow( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n    \n    float t = 0.01;\n    for( int i=0; i<128; i++ )\n    {\n        vec3 pos = ro + t*rd;\n        float h = map( pos ).x;\n        res = min( res, k*max(h,0.0)\/t );\n        if( res<0.0001 ) break;\n        t += clamp(h,0.01,0.5);\n    }\n\n    return res;\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor, float ra )\n{\n    float occ = 0.0;\n    for( int i=ZERO; i<32; i++ )\n    {\n        float h = 0.01 + 4.0*pow(float(i)\/31.0,2.0);\n        vec2 an = hash2( ra + float(i)*13.1 )*vec2( 3.14159, 6.2831 );\n        vec3 dir = vec3( sin(an.x)*sin(an.y), sin(an.x)*cos(an.y), cos(an.x) );\n        dir *= sign( dot(dir,nor) );\n        occ += clamp( 5.0*map( pos + h*dir ).x\/h, -1.0, 1.0);\n    }\n    return clamp( occ\/32.0, 0.0, 1.0 );\n}\n\n\nvec3 sunLig = normalize(vec3(0.7,0.1,0.4));\n\nvec3 skyColor( in vec3 ro, in vec3 rd )\n{\n    vec3 col = vec3(0.3,0.4,0.5)*0.3 - 0.3*rd.y;\n\n    float t = (1000.0-ro.y)\/rd.y;\n    if( t>0.0 )\n    {\n        vec2 uv = (ro+t*rd).xz;\n        float cl = texture( iChannel0, .000003*uv.yx ).x;\n        cl = smoothstep(0.3,0.7,cl);\n        col = mix( col, vec3(0.3,0.2,0.1), 0.1*cl );\n    }\n    \n    col = mix( col, vec3(0.2,0.25,0.30)*0.5, exp(-30.0*rd.y) ) ;\n    \n    float sd = pow( clamp( 0.25 + 0.75*dot(sunLig,rd), 0.0, 1.0 ), 4.0 );\n    col = mix( col, vec3(1.2,0.30,0.05)\/1.2, sd*exp(-abs((60.0-50.0*sd)*rd.y)) ) ;\n    \n    return col;\n}\n\nvec3 doBumpMap( in vec3 pos, in vec3 nor )\n{\n    float e = 0.002;\n    float b = 0.015;\n    \n\tfloat ref = fbm6( 4.0*pos );\n    vec3 gra = -b*vec3( fbm6(4.0*vec3(pos.x+e, pos.y, pos.z))-ref,\n                        fbm6(4.0*vec3(pos.x, pos.y+e, pos.z))-ref,\n                        fbm6(4.0*vec3(pos.x, pos.y, pos.z+e))-ref )\/e;\n\t\n\tvec3 tgrad = gra - nor * dot ( nor , gra );\n    return normalize( nor - tgrad );\n}\n\nvec3 doBumpMapGrass( in vec2 pos, in vec3 nor, out float hei )\n{\n    float e = 0.002;\n    float b = 0.03;\n    \n\tfloat ref = fbm6( 4.0*pos );\n    hei = ref;\n    \n    vec3 gra = -b*vec3( fbm6(4.0*vec2(pos.x+e, pos.y))-ref,\n                        e,\n                        fbm6(4.0*vec2(pos.x, pos.y+e))-ref )\/e;\n\t\n\tvec3 tgrad = gra - nor*dot( nor, gra );\n    return normalize( nor - tgrad );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float isThumbnail = step(iResolution.x,499.0);\n    \n    vec2 o = (1.0-isThumbnail)*(hash2( float(iFrame) ) - 0.5);\n    \n\tvec2 p = (-iResolution.xy + 2.0*(fragCoord+o)) \/ iResolution.y;\n    \n    uvec2 px = uvec2(fragCoord);\n    float ran = hash( px.x + 1920U*px.y + (1920U*1080U)*uint(iFrame*0) );    \n    \n    #ifdef STATICCAM\n    float an = -0.96;\n    #else\n    float an = -0.96 + sin(iTime*0.05)*0.1;\n    #endif\n    float ra = 70.0;\n    float fl = 3.0;\n    vec3 ta = vec3(0.0,-3.0,-23.0);\n    vec3 ro = ta + vec3(ra*sin(an),10.0,ra*cos(an));\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    vec3 rd = ca * normalize( vec3(p.xy,fl));\n    \n    \n    vec3 col = vec3(0.0);\n    \n    col = skyColor( ro, rd );\n    \n    float resT = 10000.0;\n    vec3 res = intersect( ro, rd );\n    if( res.y>0.0 )\n    {\n        float t = res.x;\n        resT = t;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, t );\n        \n        float fre = pow( clamp( 1.0+dot(nor,rd), 0.0, 1.0), 5.0 );\n\t\tfloat foc = 1.0;\n        \n        vec3 mate = vec3(0.2);\n        vec2 mspe = vec2(0.0);\n        float mbou = 0.0;\n        float mter = 0.0;\n        if( res.y<1.5 )\n        {\n            vec3 te = textureBox( iChannel0, pos*0.05, nor ).xyz;\n            \/\/mate = vec3(0.12,0.08,0.05) + 0.15*te;\n            mate = vec3(0.14,0.10,0.07) + 0.1*te;\n            mate *= 0.8 + 0.4*res.z;\n            mate *= 1.15;            \n            mspe = vec2(1.0,8.0);\n            mbou = 1.0;\n\n            nor = doBumpMap( pos, nor );\n            \n            foc = 0.7 + 0.3*smoothstep(0.4,0.7,fbm4( 3.0*pos ));\n\n            float ho = 1.0;\n            if( pos.y>-7.5 ) ho *= smoothstep( 0.0, 5.0, (pos.y+7.5)  );\n            ho = mix( 0.1+ho*0.3, 1.0, clamp( 0.6 + 0.4*dot( normalize(nor.xz*vec2(0.5,1.0)), normalize(pos.xz*vec2(0.5,1.0)) ) + 1.0*nor.y*nor.y, 0.0, 1.0 ) );\n            foc *= ho;\n            foc *= 0.4 + 0.6*smoothstep( 2.0, 15.0, length(pos*vec3(0.5,0.25,1.0)) );\n            float rdis = clamp( -0.15*max(sdRhombus( pos.yz-vec2(8.3,0.0)+vec2(2.0,0.0), vec2(2.25,8.5), 0.05 ),-(pos.y-8.3+2.0)), 0.0, 1.0 );\n            if( rdis>0.0001 ) foc = 0.1 + sqrt(rdis);\n\t\t\tif( pos.y<5.8 ) foc *= 0.6 + 0.4*smoothstep( 0.0, 1.5, -(pos.y-5.8) );\n            if( pos.y<3.4 ) foc *= 0.6 + 0.4*smoothstep( 0.0, 2.5, -(pos.y-3.4)  );\n\n            foc *= 0.8;            \n        }\n        else if( res.y<2.5 )\n        {\n            mate = vec3(0.95,0.9,0.85) * 0.4*texture( iChannel0, pos.xz*0.015 ).xyz;\n            mate *= 0.25 + 0.75*smoothstep( -25.0, -24.0, pos.y );\n            mate *= 0.32;            \n\t\t\tfloat h;\n            vec3 mor = doBumpMapGrass( pos.xz, nor, h );\n            mspe = vec2(2.5,4.0);\n            float is_grass = smoothstep( 0.9,0.95,mor.y);\n            \n            mate = mix( mate, vec3(0.15,0.1,0.0)*0.8*0.7 + h*h*h*vec3(0.12,0.1,0.05)*0.15, is_grass );\n            mspe = mix( mspe, vec2(0.5,4.0), is_grass );\n            nor = mor;\n            mter = 1.0;\n        }\n\t\telse\n        {\n            mate = vec3(0.1,0.21,0.25)*0.45;\n            mate += 2.0*vec3(0.01,0.03,0.03)*(1.0-smoothstep(0.0,10.0,pos.y-terrain(pos.xz)));\n            mate *= 0.4;            \n            float foam = (1.0-smoothstep(0.0,1.0,pos.y-terrain(pos.xz)));\n            foam *= smoothstep( 0.35,0.5,texture(iChannel0,pos.xz*0.07).x );\n            mate += vec3(0.08)*foam;\n            mspe = vec2(0.5,8.0);\n\n            vec2 e = vec2(0.01,0.0);\n            float ho = fbm4( (pos.xz     )*vec2(2.0,0.5) );\n            float hx = fbm4( (pos.xz+e.xy)*vec2(2.0,0.5) );\n            float hy = fbm4( (pos.xz+e.yx)*vec2(2.0,0.5) );\n            float sm = (1.0-smoothstep(0.0,4.0,pos.y-terrain(pos.xz)));\n            sm *= 0.02 + 0.03*foam;\n            ho *= sm;\n            hx *= sm;\n            hy *= sm;\n                \n            nor = normalize( vec3(ho-hx,e.x,ho-hy) );\n        }\n\n        float occ = 0.33 + 0.5*nor.y;\n        occ = calcOcclusion(pos,nor,ran) * foc;\n        \n        float lf = 1.0 - smoothstep( 30.0,80.0,length(pos.z));\n        vec3 lig = normalize( vec3(sunLig.x,sunLig.y+0.245*lf,sunLig.z) );\n        vec3 ligbak = normalize(vec3(-lig.x,0.0,-lig.z));\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float sha = calcShadow( pos+nor*0.001, lig, 32.0 );\n              dif *= sha;\n        float amb = (0.8 + 0.2*nor.y);\n              amb = mix( amb, amb*(0.5+0.5*smoothstep( -8.0,-1.0,pos.y)), mbou );\n\n        vec3 qos = pos\/1.5 - vec3(0.0,1.0,0.0);\n\n        float bak = clamp( 0.4+0.6*dot( nor, ligbak ), 0.0, 1.0 );\n              bak *= 0.6 + 0.4*smoothstep( -8.0,-1.0,qos.y);\n        \n        \n        float bou = 0.3*clamp( 0.7-0.3*nor.y, 0.0, 1.0 );\n              bou *= smoothstep( 8.0,0.0,qos.y+6.0)*smoothstep(-6.7,-6.4,qos.y);\n              bou *= (0.7*smoothstep( 3.0,1.0,length( (qos.xz-vec2(1.0,6.0))*vec2(0.2,1.0)) )+\n                      smoothstep( 5.0,1.0,length( (qos.xz-vec2(5.0,-3.0))*vec2(0.4,1.0)) ));\n        \n\n        bou += 0.1*smoothstep( 5.0,1.0,length( (qos-vec3(-5.0,0.0,-5.0))*vec3(0.7,0.8,1.5)) );\n        \n        vec3 hal = normalize( lig -rd );\n        float spe = pow( clamp( dot(nor,hal), 0.0, 1.0), mspe.y )*(0.1+0.9*fre)*sha*(0.5+0.5*occ);\n\n        col = vec3(0.0);\n        col += amb*1.0*vec3(0.15,0.25,0.35)*occ*(1.0+mter);\n        col += dif*5.0*vec3(0.90,0.55,0.35);\n        col += bak*1.7*vec3(0.10,0.11,0.12)*occ*mbou;\n        col += bou*3.0*vec3(1.00,0.50,0.15)*occ*mbou;\n        col += spe*6.0*mspe.x*occ;\n        \n        col *= mate;\n\n        vec3 fogcol = vec3(0.1,0.125,0.15);\n        float sd = pow( clamp( 0.25 + 0.75*dot(lig,rd), 0.0, 1.0 ), 4.0 );\n\t    fogcol = mix( fogcol, vec3(1.0,0.25,0.042), sd*exp(-abs((60.0-50.0*sd)*abs(rd.y))) ) ;\n\n        float fog = 1.0 - exp(-0.0013*t);\n        col *= 1.0-0.5*fog;\n        col = mix( col, fogcol, fog );\n    }\n\n    col = max( col, 0.0 );\n    \n    col += 0.15*vec3(1.0,0.8,0.7)*pow( clamp( dot(rd,sunLig), 0.0, 1.0 ), 6.0 );\n\n    col = 1.2*col\/(1.0+col);\n    \n    col = sqrt( col );\n\n    \n    col = clamp( 1.9*col-0.1, 0.0, 1.0 );\n    col = col*0.1 + 0.9*col*col*(3.0-2.0*col);\n    col = pow( col, vec3(0.76,0.98,1.0) );    \n\n    \n    \/\/------------------------------------------\n\t\/\/ reproject from previous frame and average\n    \/\/------------------------------------------\n\t#ifdef STATICCAM\n        vec3 ocol = texelFetch( iChannel3, ivec2(fragCoord-0.5), 0 ).xyz;\n        if( iFrame==0 ) ocol = col;\n        col = mix( ocol, col, 0.05 );\n        fragColor = vec4( col, 1.0 );\n    #else\n        mat4 oldCam = mat4( texelFetch(iChannel3,ivec2(0,0),0),\n                            texelFetch(iChannel3,ivec2(1,0),0),\n                            texelFetch(iChannel3,ivec2(2,0),0),\n                            0.0, 0.0, 0.0, 1.0 );\n\n        \/\/ world space\n        vec4 wpos = vec4(ro + rd*resT,1.0);\n        \/\/ camera space\n        vec3 cpos = (wpos*oldCam).xyz; \/\/ note inverse multiply\n        \/\/ ndc space\n        vec2 npos = fl * cpos.xy \/ cpos.z;\n        \/\/ screen space\n        vec2 spos = 0.5 + 0.5*npos*vec2(iResolution.y\/iResolution.x,1.0);\n        \/\/ undo dither\n        spos -= o\/iResolution.xy;\n        \/\/ raster space\n        vec2 rpos = spos * iResolution.xy;\n\n        if( (rpos.y<1.0 && rpos.x<3.0) || (isThumbnail>0.5)  )\n        {\n        }\n        else\n        {\n            vec4 data = textureLod( iChannel3, spos, 0.0 );\n            vec3 ocol = data.xyz;\n            float dt = abs(data.w - resT)\/resT;\n            if( iFrame==0 ) ocol = col;\n            col = mix( ocol, col, 0.1 + 0.5*smoothstep(0.1,0.2,dt) );\n        }\n\n        if( fragCoord.y<1.0 && fragCoord.x<3.0 )\n        {\n            if( abs(fragCoord.x-2.5)<0.5 ) fragColor = vec4( ca[2], -dot(ca[2],ro) );\n            if( abs(fragCoord.x-1.5)<0.5 ) fragColor = vec4( ca[1], -dot(ca[1],ro) );\n            if( abs(fragCoord.x-0.5)<0.5 ) fragColor = vec4( ca[0], -dot(ca[0],ro) );\n        }\n        else\n        {\n            fragColor = vec4( col, resT );\n        }\n    #endif\n}",
            "name": "Buffer A",
            "description": "",
            "type": "buffer"
        }
    ]
}