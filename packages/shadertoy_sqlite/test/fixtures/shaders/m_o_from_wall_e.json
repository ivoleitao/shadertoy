{
    "ver": "0.1",
    "info": {
        "id": "WdVfRc",
        "date": "1608151199",
        "viewed": 2870,
        "name": "M-O (from Wall-E)",
        "username": "dean_the_coder",
        "description": "Anyone remember 'M-O' from Pixar's 'Wall-E' movie?  Here's my tribute to that little chap.",
        "likes": 69,
        "published": 3,
        "flags": 0,
        "usePreview": 1,
        "tags": [
            "3d",
            "raymarching",
            "pixar",
            "movie",
            "cineshader",
            "walle"
        ],
        "hasliked": 0
    },
    "renderpass": [
        {
            "inputs": [],
            "outputs": [
                {
                    "id": "4dfGRr",
                    "channel": 0
                }
            ],
            "code": "\/\/ 'M-O'\n\/\/ by dean_the_coder (Twitter: @deanthecoder)\n\/\/\n\/\/ Anyone remember 'M-O' from Pixar's 'Wall-E' movie?\n\/\/ Here's my tribute to that little chap.\n\/\/\n\/\/ Technically I wanted to practice writing a shader that\n\/\/ performs well enough that I can enable anti-aliasing by\n\/\/ default, has quite a small codebase (my shaders usually\n\/\/ tend to be a bit on the large side), and doesn't require\n\/\/ any external textures.\n\/\/\n\/\/ With more GPU power I would have liked to make the red\n\/\/ light spin around within refracted glass. I might\n\/\/ come back to that if I ever get a more powerful laptop.\n\/\/\n\/\/ Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\n\/\/ and a bunch of others for sharing their knowledge!\n\nfloat arms, time, g = 0.;\n\n#define AA  \/\/ Enable this line if your GPU can take it!\n\nstruct Hit {\n\tfloat d; \/\/ SDF distance.\n\tint id; \/\/ Material ID.\n\tvec2 t; \/\/ uv texture coords.\n};\n\nfloat n21(vec2 p) {\n\tconst vec3 s = vec3(7, 157, 0);\n\tvec2 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\n\tvec2 h = s.zy + dot(ip, s.xy);\n\th = mix(fract(sin(h) * 43.5453), fract(sin(h + s.x) * 43.5453), p.x);\n\n\treturn mix(h.x, h.y, p.y);\n}\n\nvoid minH(inout Hit a, Hit b) {\n\tif (b.d < a.d) a = b;\n}\n\nmat2 rot(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat sdCyl(vec3 p, vec2 hr) {\n\tvec2 d = abs(vec2(length(p.zy), p.x)) - hr;\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat sdTaper(vec2 p, vec3 r) {\n\tp.x = abs(p.x);\n\tp.y = -p.y;\n\tfloat b = (r.x - r.y) \/ r.z, a = sqrt(1. - b * b), k = dot(p, vec2(-b, a));\n\tif (k > a * r.z) return length(p - vec2(0, r.z)) - r.y;\n\treturn (k < 0. ? length(p) : dot(p, vec2(a, b))) - r.x;\n}\n\nfloat sdArm(vec3 p, float c) {\n\treturn max(\n\t\tmax(sdTaper(p.yz, vec3(.5, .2, 2)), abs(abs(p.x) - 1.55)) - .1, \/\/ Main arm.\n\t\t(p.z + 1.5 + sin(p.y * 7.) * .1) * c); \/\/ Front\/back cut.\n}\n\n\/\/ The sine wave applied to the dirt track.\nfloat trk(float z) { return sin(z * .2 - time); }\n\n\/\/ Map the scene using SDF functions.\nHit map(vec3 p) {\n\t\/\/ Floor.\n\tHit h = Hit(length(p.y), 1, p.xz);\n\n\t\/\/ Walls.\n\tminH(h, Hit(min(dot(p, vec3(-.707, .707, 0)) + 9., dot(p, vec3(-1, 0, 0)) + 20.), 0, p.yz));\n\n\t\/\/ Wall lights.\n\tfloat d = sdBox(vec3(p.xy, mod(p.z - time * 8., 40.)) - vec3(20, 7.25, 20), vec3(.1, .1, 8));\n\tg += .01 \/ (.01 + d * d);\n\tminH(h, Hit(d - .7, 4, p.xy));\n\n\tp.x += trk(-.9);\n\tp.xz *= rot(trk(7.) * .2);\n\n\t\/\/ Ball.\n\tminH(h, Hit(length(p - vec3(0, 1, 0)) - 1., 2, p.xy));\n\tp.yz *= rot(-arms);\n\tp.y -= 1.7;\n\tminH(h, Hit(sdBox(p, vec3(1.2, .9, .8 + cos((p.y + 5.1) * 1.33) * .5)) - .2, 3, p.xy)); \/\/ Lower body.\n\tvec3 op = p;\n\n\t\/\/ Arms\/Hands.\n\tp.y -= .5;\n\tp.yz *= rot(-arms);\n\td = sdArm(p, -1.);\n\tp.z += arms + cos(time * 15.) * .1;\n\tminH(h, Hit(min(d, sdArm(p, 1.)), 0, op.xy));\n\n\t\/\/ Brush.\n\tfloat f, b = .2 + .8 * abs(sin(p.x * 18.)) * .1;\n\tminH(h, Hit(sdCyl(p + vec3(0, 0, 2), vec2(.1 + b, 1.4)), 2, p.xy));\n\n\t\/\/ Arm extenders.\n\tp.x = abs(p.x) - 1.55;\n\tp.z += 1.;\n\tminH(h, Hit(sdBox(p, vec3(.08, .22, .6)), 2, p.xz));\n\n\t\/\/ Head.\n\tp = op;\n\tp.yz *= rot(arms * -.7);\n\tp.xz *= rot(trk(0.) * .1);\n\tp.y -= 2.;\n\tp.z += .5;\n\tf = cos(p.y + .8);\n\n\tminH(h, Hit(max(sdBox(p, vec3(mix(1.2, 1.4, f), .8, mix(.9, 1.2, f))), \/\/ Head.\n\t\t\t2.5 - length(p.yz + vec2(2.5, -.8)) \/\/ Rear cut-out.\n\t\t\t) - .2, 6, p.xy));\n\n\t\/\/ Light - Top.\n\tp.y -= mix(.96, 2.5, arms);\n\tminH(h, Hit(sdBox(p, vec3(.5, .04, .5)), 3, p.xy));\n\tminH(h, Hit(sdBox(p + vec3(0, .3, 0), vec3(.45, .3, .45)), 5, p.xy));\n\n\treturn h;\n}\n\nvec3 calcN(vec3 p) {\n\tvec2 e = vec2(.024, -.024);\n\treturn normalize(e.xyy * map(p + e.xyy).d +\n\t\t\t\t\t e.yyx * map(p + e.yyx).d +\n\t\t\t\t\t e.yxy * map(p + e.yxy).d +\n\t\t\t\t\t e.xxx * map(p + e.xxx).d);\n}\n\nfloat calcShadow(vec3 p, vec3 ld) {\n\tfloat s = 1., t = .1, h;\n\tfor (int i = 0; i < 20; i++)\n\t{\n\t\th = map(p + ld * t).d;\n\t\ts = min(s, 15. * h \/ t);\n\t\tt += h;\n\t\tif (s < .001 || t > 2.7) break;\n\t}\n\n\treturn clamp(s, 0., 1.);\n}\n\n\/\/ Quick ambient occlusion.\nfloat ao(vec3 p, vec3 n, float h) {\n\treturn map(p + h * n).d \/ h;\n}\n\n\/**********************************************************************************\/\n\nvec3 vig(vec3 c, vec2 fc) {\n\tvec2 q = fc.xy \/ iResolution.xy;\n\tc *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\treturn c;\n}\n\n\/\/ Calculate the floor normal vector.\nvec2 flrN(vec2 t) {\n\treturn n21(vec2(t.x * 1.2, t.y)) * .3 + \/\/ Surface texture.\n\t\tsmoothstep(.0, .04, abs(sin(t * .5))); \/\/ Tile edges.\n}\n\nvec3 mat(Hit h, vec3 p, inout vec3 n) {\n\tif (h.id == 1) { \/\/ Floor\n\t\tvec2 t = h.t + vec2(trk(p.z), time * -5.);\n\n\t\tn.xz += flrN(vec2(h.t.x, t.y));\n\t\tn = normalize(n);\n\n\t\tfloat mm = n21(mod(t * 10., 20.));\n\t\tvec2 d = abs(vec2(abs(abs(t.x) - .8) - .3, mod(t.y, .4) - .1)) - vec2(.2, .1);\n\t\treturn vec3(.3, .4, .5)\n\t\t* mix(1., mm, (1. - step(0., min(max(d.x, d.y), 0.))) * step(p.z, -2.5)); \/\/ Tracks.\n\t}\n\n\tif (h.id == 2) return vec3(.1); \/\/ Ball, brush\n\n\tif (h.id == 3) \/\/ White body\n\t\treturn vec3(1. - step(abs(h.t.y + .7), .15) * .9);\n\n\tif (h.id == 4) \/\/ Wall light.\n\t\treturn vec3(25);\n\n\tif (h.id == 5) return vec3(1, 0, 0);\n\n\tif (h.id == 6) { \/\/ Face\n\t\tvec2 t = vec2(abs(h.t.x), h.t.y);\n\t\tif (t.y < -.3 && t.x < 1.) {\n\t\t\tt.x += arms * .4;\n\t\t\tfloat l = .3 + .7 * abs(sin(t.y * 50.));\n\t\t\tt *= rot(.6 * arms);\n\t\t\treturn .01 + vec3(1.5, 1.5, 0) * step(abs(t.x - .3), .25) * step(abs(t.y + .7), .1 - arms * .1) * l;\n\t\t}\n\t}\n\n\treturn vec3(1);\n}\n\nvec3 lights(vec3 p, vec3 rd, Hit h) {\n\tconst vec3 lp = vec3(6, 3, -10);\n\tvec3 n = calcN(p), ld = normalize(lp - p);\n\treturn mat(h, p, n) \/\/ Material color.\n\t\t   * (\n\t\t\t  (\n\t\t\t\t  max(0., .1 + .9 * dot(ld, n)) \/\/ Primary light.\n\t\t\t\t  + max(0., .1 + .9 * dot(ld * vec3(-1, 0, -1), n)) \/\/ Bounce light.\n\t\t\t  )\n\t\t\t  * mix(.3, .6, calcShadow(p, ld)) \/\/ Shadows.\n\t\t\t  * mix(ao(p, n, .3), ao(p, n, 2.), .7) \/\/ Ambient occlusion.\n\t\t\t  + pow(max(0., dot(rd, reflect(ld, n))), 30.) \/\/ Specular.\n\t\t\t ) * vec3(2, 1.8, 1.7); \/\/ Main light color.\n}\n\nvec3 march(vec3 ro, vec3 rd) {\n\t\/\/ Raymarch.\n\tvec3 p, n, c;\n\n\tfloat d = .01;\n\tHit h;\n\tfor (int i = 0; i < 110; i++) {\n\t\tp = ro + rd * d;\n\t\th = map(p);\n\n\t\tif (abs(h.d) < .0015)\n\t\t\tbreak;\n\n\t\td += h.d;\n\t}\n\n\t\/\/ Calculate pixel color.\n\tc = lights(p, rd, h) + g;\n\tif (h.id == 1) {\n\t\t\/\/ Ray hit the floor - Apply reflection.\n\t\tn = calcN(p);\n\t\tn.xz -= flrN(p.xz - vec2(0, time * 5.)) * .024;\n\t\trd = reflect(rd, normalize(n));\n\t\td = .5;\n\t\tro = p;\n\t\tfor (int i = 0; i < 90; i++) {\n\t\t\tp = ro + rd * d;\n\t\t\th = map(p);\n\n\t\t\tif (abs(h.d) < .0015)\n\t\t\t\tbreak;\n\t\t\td += h.d;\n\t\t}\n\n\t\tif (abs(h.d) < .0015)\n\t\t\tc = mix(c, mat(h, p, n), .01);\n\t}\n\n\treturn c;\n}\n\nvoid mainImage(out vec4 c, vec2 fc)\n{\n\ttime = mod(iTime, 30.) - 1.;\n\tarms = (time < 0. ? smoothstep(-1., 0., time) : abs(sin(time * 10.) * .1) + .9) * .38;\n\ttime = max(0., time);\n\n\tvec3 ro = vec3(-7, 4, -7. - sin(time * .3)),\n\t\t col = vec3(0);\n#ifdef AA\n\tfor (float dx = 0.; dx <= 1.; dx++)\n\t\tfor (float dy = 0.; dy <= 1.; dy++) {\n\t\t\tvec2 uv = (fc + vec2(dx, dy) * .5 - .5 * iResolution.xy) \/ iResolution.y;\n#else\n\t\t\tvec2 uv = (fc - .5 * iResolution.xy) \/ iResolution.y;\n#endif\n\n\t\t\tvec3 f = normalize(vec3(0, 3, -4) - ro),\n\t\t\t\t r = normalize(cross(vec3(0, 1, 0), f));\n\t\t\tcol += march(ro, normalize(f + r * uv.x + cross(f, r) * uv.y));\n#ifdef AA\n\t\t}\n\tcol \/= 4.;\n#endif\n\n\tc.rgb = vig(pow(col, vec3(.45)), fc);\n}\n",
            "name": "Image",
            "description": "",
            "type": "image"
        }
    ]
}