{
    "ver": "0.1",
    "info": {
        "id": "3lcyDN",
        "date": "1609390217",
        "viewed": 53,
        "name": "Gallery (Final Project)",
        "username": "ouyhlan",
        "description": "Final Project",
        "likes": 5,
        "published": 3,
        "flags": 40,
        "usePreview": 1,
        "tags": [
            "raymarching",
            "ibl",
            "pbr"
        ],
        "hasliked": 0
    },
    "renderpass": [
        {
            "inputs": [
                {
                    "id": "XsfGRn",
                    "filepath": "\/media\/a\/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg",
                    "previewfilepath": "\/media\/ap\/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg",
                    "type": "texture",
                    "channel": 1,
                    "sampler": {
                        "filter": "mipmap",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "XsfGzn",
                    "filepath": "\/media\/a\/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg",
                    "previewfilepath": "\/media\/ap\/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg",
                    "type": "cubemap",
                    "channel": 0,
                    "sampler": {
                        "filter": "mipmap",
                        "wrap": "clamp",
                        "vflip": "false",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 2,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "XsXGR8",
                    "filepath": "\/media\/previz\/buffer01.png",
                    "previewfilepath": "\/media\/previz\/buffer01.png",
                    "type": "buffer",
                    "channel": 3,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dfGRr",
                    "channel": 0
                }
            ],
            "code": "#define MAX_LOD 8.\n#define DIFFUSE_LOD 6.75\n#define AA 2\n\nvec3 getSpecularLightColor( vec3 N, float roughness ) {\n    \/\/ \u501f\u9274\u4ed6\u4eba\u4ee3\u7801\u7684\u4e00\u4e9b\u52a0\u4e86HDR\u6548\u679c\u7684\u955c\u9762\u53cd\u5c04\u73af\u5883\u5149\u7167\u8d34\u56fe\n    return pow(textureLod(iChannel0, N, roughness * MAX_LOD).rgb, vec3(4.5)) * 6.5;\n}\n\nvec3 getDiffuseLightColor( vec3 N ) {\n    \/\/ \u501f\u9274\u4ed6\u4eba\u4ee3\u7801\u7684\u4e00\u4e9b\u52a0\u4e86HDR\u6548\u679c\u7684\u955c\u9762\u6f2b\u53cd\u5c04\u5149\u7167\u8d34\u56fe\n    return .25 +pow(textureLod(iChannel0, N, DIFFUSE_LOD).rgb, vec3(3.)) * 1.;\n}\n\n\/\/\n\/\/ Modified FrenelSchlick: https:\/\/seblagarde.wordpress.com\/2011\/08\/17\/hello-world\/\n\/\/\nvec3 FresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n\/\/ IBL\n\/\/ \u53c2\u8003\u5b9e\u73b0https:\/\/learnopengl-cn.github.io\/07%20PBR\/02%20Lighting\/\nvec3 Lighting(in vec3 ro, in vec3 pos, in vec3 N, in vec3 albedo, in float ao, in float roughness, in float metallic ) {\n    \/\/ \u8ba1\u7b97\u4e00\u4e9b\u57fa\u672c\u7684\u5411\u91cf\u65b9\u5411\n    vec3 V = normalize(ro - pos); \n    vec3 R = reflect(-V, N);\n    float NdotV = max(0.0, dot(N, V));\n    \n    \/\/ \u5229\u7528\u83f2\u6d85\u5c14\u65b9\u7a0b\u8ba1\u7b97\u53cd\u7167\u7387\n    vec3 F0 = vec3(0.04); \n    F0 = mix(F0, albedo, metallic);\n    vec3 F = FresnelSchlickRoughness(NdotV, F0, roughness);\n    \n    \/\/ \u6f2b\u53cd\u5c04\u5149\u7167\n    vec3 kS = F;\n    vec3 kD = vec3(1.0) - kS;\n    \n    kD *= 1.0 - metallic;\n    vec3 irradiance = getDiffuseLightColor(N);\n    vec3 diffuse  = albedo * irradiance;\n    \n    \/\/ \u955c\u9762\u53cd\u5c04\u5149\u7167\n    vec3 prefilteredColor = getSpecularLightColor(R, roughness);\n    vec2 envBRDF = texture(iChannel3, vec2(NdotV, roughness)).rg;\n    vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\n    \n    \/\/ \u6700\u7ec8\u51fa\u5c04\u5149\u989c\u8272\n    vec3 color = (kD * diffuse + specular) * ao;\n\n    return color;\n}\n\n\/\/ \u6e32\u67d3\u4ee3\u7801\nvec3 Render( const in vec3 ro, const in vec3 rd ) {\n    vec3 col = vec3(0); \n    vec2 res = castRay( ro, rd );\n\n    if (res.x > 0.) {\n        vec3 pos = ro + rd * res.x;\n        vec3 N, albedo;\n        float roughness, metallic, ao;\n\n        getMaterialProperties(pos, rd, res.y, N, albedo, ao, roughness, metallic, iChannel1, iChannel2, iChannel3);\n\n        col = Lighting(ro, pos, N, albedo, ao, roughness, metallic);\n        col *= max(0.0, min(1.1, 10.\/dot(pos,pos)) - .15);\n    }\n\n    \/\/ \u73bb\u7483\u6548\u679c\n    \/\/ \u56e0\u4e3aBRDF\u65b9\u7a0b\u5b83\u53ea\u8bbe\u8ba1\u53cd\u5c04\uff0c\u800c\u6211\u4eec\u7684\u949f\u8868\u8981\u6620\u5c04\u5185\u90e8\u7684\u6837\u5b50\n    \/\/ \u8fd9\u91cc\u7684\u89e3\u51b3\u65b9\u6848\u662f\uff1a\u9996\u5148\u8ba1\u7b97\u91cc\u9762\u7684\u5149\u7167\n    \/\/ \u628a\u90a3\u4e2a\u5149\u7167\u5f53\u4f5c\u662f\u6f2b\u53cd\u5c04\u5149\uff0c\u518d\u6765\u8ba1\u7b97\u73bb\u7483\u7684\u5149\u7167\n    float glass = castRayGlass( ro, rd );\n    if (glass > 0. && (glass < res.x || res.x < 0.)) {\n        vec3 N = calcNormalGlass(ro+rd*glass);\n        vec3 pos = ro + rd * glass;\n\n        vec3 V = normalize(ro - pos); \n        vec3 R = reflect(-V, N);\n        float NdotV = max(0.0, dot(N, V));\n\n        float roughness = texture(iChannel2, pos.xz*.5 + .5).g;\n\n        vec3 F = FresnelSchlickRoughness(NdotV, vec3(.08), roughness);\n        vec3 prefilteredColor = getSpecularLightColor(R, roughness);\n        vec2 envBRDF = texture(iChannel3, vec2(NdotV, roughness)).rg;\n        vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\n        float ao = calcAO(pos, R);\n        ao = clamp(.1+.9*ao, 0., 1.);\n        col = col * (1.0 -  (F * envBRDF.x + envBRDF.y) ) * ao + specular * ao;\n    } \n\n    \/\/ Gamma\u6821\u6b63\n    col = max( vec3(0), col - 0.004);\n    col = (col*(6.2*col + .5)) \/ (col*(6.2*col+1.7) + 0.06);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord\/iResolution.xy;\n    vec2 mo = iMouse.xy\/iResolution.xy - .5;\n    if(iMouse.z <= 0.) {\n        mo = vec2(.2*sin(-iTime*.1+.3)+.045,.1-.2*sin(-iTime*.1+.3));\n    }\n    float a = 5.05;\n    vec3 ro = vec3( .55 + 2.*cos(6.0*mo.x+a), 4.3 + 2. * mo.y, .5+2.0*sin(6.0*mo.x+a) );\n    vec3 ta = vec3( .25, .5, .0 );\n    mat3 ca = setCamera( ro, ta );\n\n    vec3 colT = vec3(0);\n    float d = 181.0 * sin(iTime*.1+.3) + 181.0;\n    \n    \/\/ \u949f\u8868\u65cb\u8f6c\n    if (d <= 181.0) {\n        COVER_ROT_X = -0.28 - float(d) * 0.01;\n    }else{\n        COVER_ROT_X = -2.09 + (float(d)-181.) * 0.01;\n    }\n    \n    \/\/ \u770b\u522b\u4eba\u4f7f\u7528\u7684\u6297\u952f\u9f7f\u65b9\u6cd5\n    for (int x=0; x<AA; x++) {\n        for(int y=0; y<AA; y++) {\n\t\t    vec2 p = (-iResolution.xy + 2.0*(fragCoord + vec2(x,y)\/float(AA) - .5))\/iResolution.y;\n   \t\t\tvec3 rd = ca * normalize( vec3(p.xy,1.6) );  \n            colT += Render( ro, rd);           \n        }\n    }\n    \n    colT \/= float(AA*AA);\n    \n    fragColor = vec4(colT, 1.0);\n}",
            "name": "Image",
            "description": "",
            "type": "image"
        },
        {
            "inputs": [
                {
                    "id": "Xsf3Rr",
                    "filepath": "\/media\/a\/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg",
                    "previewfilepath": "\/media\/ap\/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg",
                    "type": "texture",
                    "channel": 2,
                    "sampler": {
                        "filter": "mipmap",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "4dXGzr",
                    "filepath": "\/media\/a\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png",
                    "previewfilepath": "\/media\/ap\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png",
                    "type": "texture",
                    "channel": 1,
                    "sampler": {
                        "filter": "mipmap",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dXGR8",
                    "channel": 0
                }
            ],
            "code": "\/\/ \u949f\u8868\u523b\u5ea6\u8d34\u56fe\u751f\u6210\u4ee3\u7801\uff0c\u4e0b\u9762\u4ee3\u7801\u5b8c\u5168\u4f7f\u7528\u4ed6\u4eba\u7684\nbool resolutionChanged() {\n    return floor(texelFetch(iChannel0, ivec2(0), 0).r) != floor(iResolution.x);\n}\n\nfloat printChar(vec2 uv, uint char) {\n    float d = textureLod(iChannel1, (uv + vec2( char & 0xFU, 0xFU - (char >> 4))) \/ 16.,0.).a;\n\treturn smoothstep(1.,0., smoothstep(.5,.51,d));\n}\n\nfloat dialSub( in vec2 uv, float wr ) {\n    float r = length( uv );\n    float a = atan( uv.y, uv.x )+3.1415926;\n\n    float f = abs(2.0*fract(0.5+a*60.0\/6.2831)-1.0);\n    float g = 1.0-smoothstep( 0.0, 0.1, abs(2.0*fract(0.5+a*12.0\/6.2831)-1.0) );\n    float w = fwidth(f);\n    f = 1.0 - smoothstep( 0.2*g+0.05-w, 0.2*g+0.05+w, f );\n    float s = abs(fwidth(r));\n    f *= smoothstep( 0.9 - wr -s, 0.9 - wr, r ) - smoothstep( 0.9, 0.9+s, r );\n    float hwr = wr * .5;\n    f -= 1.-smoothstep(hwr+s,hwr,abs(r-0.9+hwr)) - smoothstep(hwr-s,hwr,abs(r-0.9+hwr));\n\n    return .1 + .8 * clamp(1.-f,0.,1.);\n}\n\nfloat dial(vec2 uv) {\n    float d = dialSub(uv, 0.05);\n\n    vec2 uvs = uv;\n    \n    uvs.y += 0.6;\n    uvs *= 1.\/(0.85-0.6);\n\n    d = min(d, dialSub(uvs, 0.1));\n    \n    vec2 center = vec2(0.5);\n    vec2 radius = vec2(3.65, 0.);\n    \n    for (int i=0; i<9; i++) {\n        if(i!=5) {\n\t        float a = 6.28318530718 * float(i+4)\/12.;\n    \t    vec2 uvt = clamp(uv * 5. + center + rotate(radius, a), vec2(0), vec2(1));\n        \td = mix(d, 0.3, printChar(uvt, uint(49+i)));\n        }\n    }\n    for (int i=0; i<3; i++) {\n\t    float a = 6.28318530718 * float(i+13)\/12.;\n    \tvec2 uvt1 = clamp(uv * 5. + center + rotate(radius, a) + vec2(.25,0.), vec2(0), vec2(1));\n        d = mix(d, 0.3, printChar(uvt1, uint(49)));\n    \tvec2 uvt = clamp(uv * 5. + center + rotate(radius, a)+ vec2(-.15,0.), vec2(0), vec2(1));\n        d = mix(d, 0.3, printChar(uvt, uint(48+i)));\n    }\n    \n    d *= .9 + .25*texture(iChannel2, uv*.5+.5).r;\n    \n    return pow(clamp(d, 0., 1.), 2.2);\n}\n\nfloat roughnessGlass(vec2 uv) {\n    uv = uv * .5 + .5;\n    return smoothstep(0.2, 0.8, texture(iChannel2, uv * .3).r) * .4 + .2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {   \n    if(resolutionChanged() && iChannelResolution[1].x > 0.  && iChannelResolution[2].x > 0.) {\n        if (fragCoord.x < 1.5 && fragCoord.y < 1.5) {\n            fragColor = floor(iResolution.xyxy);\n        } else {\n            vec2 uv = (2.0*fragCoord.xy-iResolution.xy)\/iResolution.xy;\n\n            fragColor = vec4( dial(uv), roughnessGlass(uv), 0., 1.0 );      \n        }\n    } else {\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    }\n}",
            "name": "Buffer A",
            "description": "",
            "type": "buffer"
        },
        {
            "inputs": [
                {
                    "id": "XsXGR8",
                    "filepath": "\/media\/previz\/buffer01.png",
                    "previewfilepath": "\/media\/previz\/buffer01.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "XsXGR8",
                    "channel": 0
                }
            ],
            "code": "\/\/ EnvBRDF\u9884\u8ba1\u7b97\u8d34\u56fe\uff0c\u4e0b\u9762\u4ee3\u7801\u5b8c\u5168\u4f7f\u7528\u4ed6\u4eba\u7684\nconst float PI = 3.14159265359;\n\n\/\/ see: http:\/\/blog.selfshadow.com\/publications\/s2013-shading-course\/karis\/s2013_pbs_epic_notes_v2.pdf\nfloat PartialGeometryGGX(float NdotV, float a) {\n    float k = a \/ 2.0;\n\n    float nominator   = NdotV;\n    float denominator = NdotV * (1.0 - k) + k;\n\n    return nominator \/ denominator;\n}\n\nfloat GeometryGGX_Smith(float NdotV, float NdotL, float roughness) {\n    float a = roughness*roughness;\n    float G1 = PartialGeometryGGX(NdotV, a);\n    float G2 = PartialGeometryGGX(NdotL, a);\n    return G1 * G2;\n}\n\nfloat RadicalInverse_VdC(uint bits) {\n    bits = (bits << 16u) | (bits >> 16u);\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n    return float(bits) * 2.3283064365386963e-10; \/\/ \/ 0x100000000\n}\n\nvec2 Hammersley(int i, int N) {\n    return vec2(float(i)\/float(N), RadicalInverse_VdC(uint(i)));\n} \n\nvec3 ImportanceSampleGGX(vec2 Xi, float roughness) {\n    float a = roughness*roughness;\n    float phi      = 2.0 * PI * Xi.x;\n    float cosTheta = sqrt((1.0 - Xi.y) \/ (1.0 + (a*a - 1.0) * Xi.y));\n    float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n\n    vec3 HTangent;\n    HTangent.x = sinTheta*cos(phi);\n    HTangent.y = sinTheta*sin(phi);\n    HTangent.z = cosTheta;\n\n    return HTangent;\n}\n\nvec2 IntegrateBRDF(float roughness, float NdotV) {\n    vec3 V;\n    V.x = sqrt(1.0 - NdotV*NdotV);\n    V.y = 0.0;\n    V.z = NdotV;\n\n    float A = 0.0;\n    float B = 0.0;\n\n    const int SAMPLE_COUNT = 128;\n\n    vec3 N = vec3(0.0, 0.0, 1.0);\n    vec3 UpVector = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n    vec3 TangentX = normalize(cross(UpVector, N));\n    vec3 TangentY = cross(N, TangentX);\n\n    for(int i = 0; i < SAMPLE_COUNT; ++i)  {\n        vec2 Xi = Hammersley(i, SAMPLE_COUNT);\n        vec3 HTangent = ImportanceSampleGGX(Xi, roughness);\n        \n        vec3 H = normalize(HTangent.x * TangentX + HTangent.y * TangentY + HTangent.z * N);\n        vec3 L = normalize(2.0 * dot(V, H) * H - V);\n\n        float NdotL = max(L.z, 0.0);\n        float NdotH = max(H.z, 0.0);\n        float VdotH = max(dot(V, H), 0.0);\n\n        if(NdotL > 0.0) {\n            float G = GeometryGGX_Smith(NdotV, NdotL, roughness);\n            float G_Vis = (G * VdotH) \/ (NdotH * NdotV);\n            float Fc = pow(1.0 - VdotH, 5.0);\n\n            A += (1.0 - Fc) * G_Vis;\n            B += Fc * G_Vis;\n        }\n    }\n    A \/= float(SAMPLE_COUNT);\n    B \/= float(SAMPLE_COUNT);\n    return vec2(A, B);\n}\n\nbool resolutionChanged() {\n    return floor(texelFetch(iChannel0, ivec2(0), 0).r) != floor(iResolution.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if(resolutionChanged()) {\n        if (fragCoord.x < 1.5 && fragCoord.y < 1.5) {\n            fragColor = floor(iResolution.xyxy);\n        } else {\n\t   \t\tvec2 uv = fragCoord \/ iResolution.xy;\n    \t\tvec2 integratedBRDF = IntegrateBRDF(uv.y, uv.x);\n   \t \t\tfragColor = vec4(integratedBRDF, 0.0,1.0);\n        }\n    } else {\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    }\n}",
            "name": "Buffer B",
            "description": "",
            "type": "buffer"
        },
        {
            "inputs": [],
            "outputs": [],
            "code": "\/\/ \u6240\u6709\u7684SDF\u51fd\u6570\u6e90\u4ee3\u7801\u6765\u81ea\u4e8e Inigo Quilez: http:\/\/www.iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm\n#define MAT_TABLE    1.\n#define MAT_PEN_0 2.\n#define MAT_PEN_1 3.\n#define MAT_PEN_2 4.\n#define MAT_DIAL     5.\n#define MAT_HAND     6.\n#define MAT_METAL_0  7.\n#define MAT_METAL_1  8.\n\n#define CLOCK_ROT_X -0.26\n#define CLOCK_ROT_Y 0.\n#define CLOCK_OFFSET_Y 0.42\n\n#define COVER_ROT_Y 0.\n#define COVER_ROT_Z -0.\n#define rBOT vec3(0,0,1.14)\n\n#define COVER_OFFSET_Y 0.\n#define COVER_OFFSET_Z -1.04\n#define COVER_OFFSET_X 0.\n\n#define DEST vec3(0,-0.29,1.1)\n#define COVER_OFFSET_1 vec3(0,0,-1.04)\n#define COVER_OFFSET_2 vec3(0,0,0)\n\n#define PEN_POS vec3(-0.31,-0.2, -.725)\n\n#define CAP_POS vec3(-3.7, -0.2, -.725)\n\n#define CAP_ROTATE_Y 0.5\n\nfloat MAX_T = 10.;\nfloat COVER_ROT_X ;\n\n\/\/ \u6709\u5411\u8ddd\u79bb\u51fd\u6570\u7684\u6a21\u677f\u4ee3\u7801\n\/\/ \u51fa\u5904\uff1ahttp:\/\/www.iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm\nfloat sdPlane( const vec3 p ) {\n\treturn p.y;\n}\n\nfloat sdTorus( const vec3 p, const vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdTorusYZ( const vec3 p, const vec2 t ) {\n  vec2 q = vec2(length(p.yz)-t.x,p.x);\n  return length(q)-t.y;\n}\n\nfloat sdTorusYX( const vec3 p, const vec2 t ) {\n  vec2 q = vec2(length(p.yx)-t.x,p.z);\n  return length(q)-t.y;\n}\n\nfloat sdCylinder( const vec3 p, const vec2 h ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinderZY( const vec3 p, const vec2 h ) {\n  vec2 d = abs(vec2(length(p.zy),p.x)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinderXY( const vec3 p, const vec2 h ) {\n  vec2 d = abs(vec2(length(p.xy),p.z)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.yz), p.x );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)\/dot(k2,k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot(ca,ca),dot(cb,cb)) );\n}\n\nfloat sdHexPrism( const vec3 p, const vec2 h ) {\n    vec3 q = abs(p);\n#if 0\n    return max(q.x-h.y,max((q.z*0.866025+q.y*0.5),q.y)-h.x);\n#else\n    float d1 = q.x-h.y;\n    float d2 = max((q.z*0.866025+q.y*0.5),q.y)-h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p\/r);\n  float k1 = length(p\/(r*r));\n  return k0*(k0-1.0)\/k1;\n}\n\nfloat sdCapsule( const vec3 p, const vec3 a, const vec3 b, const float r ) {\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdSphere( const vec3 p, const float r ) {\n    return length(p) - r;\n}\n\nfloat sdCone( const vec3 p, const vec2 c ) {\n    float q = length(p.yz);\n    return dot(c,vec2(q,p.x));\n}\n\nfloat sdSegment2D( const vec2 p, const vec2 a, const vec2 b, const float w ) {\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - w;\n}\n\n\/\/ \u6a21\u578b\u7ec4\u5408\u65b9\u6cd5\n\/\/ \u51fa\u5904\uff1ahttp:\/\/www.iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm\nfloat opS( const float d1, const float d2 ) {\n    return max(-d1,d2);\n}\n\nfloat opU( const float d1, const float d2 ) {\n    return min(d1,d2);\n}\n\n\/\/ \u4e00\u4e9b\u65cb\u8f6c\u53d8\u6362\u7684\u51fd\u6570\nvec3 rotateX( in vec3 p, const float t ) {\n    float co = cos(t);\n    float si = sin(t);\n    p.yz = mat2(co,-si,si,co)*p.yz;\n    return p;\n}\n\nvec3 rotateY( in vec3 p, const float t ) {\n    float co = cos(t);\n    float si = sin(t);\n    p.xz = mat2(co,-si,si,co)*p.xz;\n    return p;\n}\n\nvec3 rotateZ( in vec3 p, const float t ) {\n    float co = cos(t);\n    float si = sin(t);\n    p.xy = mat2(co,-si,si,co)*p.xy;\n    return p;\n}\n\nvec2 rotate( in vec2 p, const float t ) {\n    float co = cos(t);\n    float si = sin(t);\n    p = mat2(co,-si,si,co) * p;\n    return p;\n}\n\nvec3 rotateCover(in vec3 p, const float t){\n    vec3 res = p - vec3(0,1.69,1.291);\n\trotateX(res,t);\n\tres = res + vec3(0,1.69,1.291);\n\treturn res;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\n\/\/ Hash\u51fd\u6570\nfloat hash11(float p) {\n\tvec3 p3  = fract(vec3(p) * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\/\/ \u573a\u666f\nfloat mapHand( const vec3 pos, const float w, const float l, const float r ) {\n    float d = sdSegment2D(pos.xz, vec2(0,-w*10.), vec2(0,l), w);\n    d = min(d, length(pos.xz) - (.03+r));\n    return max(d, abs(pos.y)-.005);\n}\n\nvec2 map( in vec3 pos, in vec3 p1, in vec3 p2, in vec3 p3, in vec3 ps, in vec3 pm, in vec3 ph, \n         const bool watchIntersect, const bool penIntersect,\n         const bool coverIntersect, const bool capIntersect) {\n    \/\/--- table\n    vec2 res = vec2(sdPlane(pos), MAT_TABLE);\n    \n    \/\/ \u622a\u65ad\u7684\u8868\u94fe\n    if (pos.z > 1. && pos.z < 5.) {\n        float h = smoothstep(3., -.4, pos.z)*.74 + .045;\n        float dChain0 = length(pos.xy+vec2(.3*sin(pos.z), -h))-.1;\n        if (dChain0 < 0.1) {\n            dChain0 = 10.;\n            float pth1z = floor(pos.z*5.);\n            if (pth1z > 5.) {\n\t            float pth1 = hash11(floor(pos.z*5.));\n    \t        vec3 pt1 = vec3(pos.x + .3*sin(pos.z)- pth1 *.02 + 0.02, pos.y-h - pth1 *.03, mod(pos.z, .2) - .1);\n        \t    pt1 = rotateZ(pt1, .6 * smoothstep(2.,3., pos.z));\n            \tdChain0 = sdTorus(pt1, vec2(.071, .02)); \n            }\n            \n            float pth2z = floor(pos.z*5. + .5);\n            float pth2 = hash11(pth2z); \n            vec3 pt2 = vec3(pos.x + .3*sin(pos.z)- pth2 *.02 + 0.02, pos.y-h - pth2 *.03, mod(pos.z + .1, .2) - .1);\n            pt2 = rotateZ(pt2, 1.1 * smoothstep(2.,3., pos.z));\n            dChain0 = opU(dChain0, sdTorusYZ(pt2, vec2(.071, .02)));          \n        }\n        if (dChain0 < res.x) res = vec2(dChain0, MAT_METAL_1);\n    }\n    \n    \/\/ \u94a2\u7b14\n    if (penIntersect){     \n        float dpen0 = sdCappedCone(pos + PEN_POS + vec3(1.8,0,0),1.2,0.15,.2);\n        if (dpen0 < res.x) res = vec2(dpen0,MAT_HAND);\n        \n        \/\/\u94a2\u7b14\u7b2c\u4e8c\u622a\n        float dpen1= sdCappedCone(pos + PEN_POS + vec3(-0.12,0,0),.7,.2,0.13);\n        if (dpen1 < res.x) res = vec2(dpen1,MAT_HAND);\n        \n        \/\/\u8fde\u63a5\u4e24\u622a\u7684\u91d1\u5b50\u505a\u7684\u73af\uff01\n        float dTorus0 = sdTorusYZ(pos + PEN_POS + vec3(0.60,0,0),vec2(0.2,0.01));\n        if (dTorus0 < res.x) res = vec2(dTorus0,MAT_METAL_0);\n        \n        float dTorus1 = sdTorusYZ(pos + PEN_POS + vec3(0.42,0,0),vec2(0.2,0.01));\n        if (dTorus1 < res.x) res = vec2(dTorus1,MAT_METAL_0);\n        \n        \/\/\u94a2\u7b14\u4e00\u7aef\u4e0a\u91d1\u5b50\u505a\u7684\u5c01\u76d6\n        float dCylinder1 = sdCylinderZY(pos + PEN_POS + vec3(3.02,0,0),vec2(0.15,0.025));\n        if (dCylinder1 < res.x) res = vec2(dCylinder1,MAT_METAL_0);\n        \/\/\u8fde\u63a5\u624b\u6307\u63e1\u7684\u548c\u94a2\u7b14\u7b2c\u4e8c\u622a\u7684\u91d1\u5b50\u505a\u7684\u73af\n             \n        float dTorus2 = sdTorusYZ(pos + PEN_POS + vec3(-0.83,0,0),vec2(0.13,0.01));\n        if (dTorus2 < res.x) res = vec2(dTorus2,MAT_METAL_0);\n        \n        \/\/\u624b\u6307\u63e1\u7684\u5730\u65b9\n        float dCylinder2 = sdCylinderZY(pos + PEN_POS + vec3(-1,0,0), vec2(.125,0.5));\n        for (int i = 0; i < 45; i++){\n            float dcld = sdTorusYZ( pos + PEN_POS + vec3(-.8-float(i)*0.02,0,0), vec2(.12,0.006));\n            dCylinder2 = opS(dcld,dCylinder2);\n        }\n        if (dCylinder2 < res.x) res = vec2(dCylinder2, MAT_HAND);\n        \n        \/\/\u7b14\u5934 \u91d1\u5b50\u505a\u7684\n        float dpen2 = sdCappedCone(pos + PEN_POS + vec3(-1.8,0,0),0.3,0.18,0.001);\n        \/\/\u9760\u8fd1\u7b14\u8eab\u90a3\u4e00\u8fb9\u7684\uff0c\u7528\u7403\u6765\u622a\u51fa\u68f1\u89d2\n        float r1 = 1.36; \/\/\u7403\u7684\u534a\u5f84\n        float x1 = -1.3; \/\/\u7403\u7684x\u5750\u6807\n        dpen2 = opS(sdSphere(pos + (PEN_POS + vec3(x1,1.,1.)), r1), dpen2);\n        dpen2 = opS(sdSphere(pos + (PEN_POS + vec3(x1,1.,-1.)), r1), dpen2);\n        dpen2 = opS(sdSphere(pos + (PEN_POS + vec3(x1,-1.,1.)), r1), dpen2);\n        dpen2 = opS(sdSphere(pos + (PEN_POS + vec3(x1,-1.,-1.)), r1), dpen2);\n        \/\/\u9760\u8fd1\u7b14\u8eab\u90a3\u4e00\u8fb9\u7684\uff0c\u7528\u7403\u6765\u622a\u51fa\u68f1\u89d2\n        float r2 = 0.98;\/\/\u7403\u7684\u534a\u5f84\n        float x2 = -2.12;\/\/\u7403\u7684x\u5750\u6807\n        dpen2 = opS(sdSphere(pos + (PEN_POS + vec3(x2,1.,0.)), r2), dpen2);\n        dpen2 = opS(sdSphere(pos + (PEN_POS + vec3(x2,-1.,0.)), r2), dpen2);\n        dpen2 = opS(sdSphere(pos + (PEN_POS + vec3(x2,0.,1.)), r2), dpen2);\n        dpen2 = opS(sdSphere(pos + (PEN_POS + vec3(x2,0.,-1.)), r2), dpen2);\n        \n        \n        if (dpen2 < res.x) res = vec2(dpen2,MAT_METAL_0);\n    }\n    \n    \/\/ \u949f\u8868\n    if (watchIntersect) {\n\t\t\/\/\u8868\u76d8\n        float dDial = sdCylinder(p1, vec2(1.05,.13));\n        if (dDial < res.x) res = vec2(dDial, MAT_DIAL);\n\t\t\/\/\u4e0e\u94fe\u6761\u8fde\u63a5\u7684\u90a3\u4e2a\u5927\u5708\u5708\n        float dC = sdTorusYX(vec3(max(abs(p1.x)-.5*p1.y-0.19,0.),p1.y+0.12,p1.z-1.18), vec2(0.11,0.02));\n        if (dC < res.x) res = vec2(dC, MAT_METAL_1);\n        \/\/\u8868\u5185\u5c42\u7684\u91d1\u5c5e\u73af\n        float dM = sdTorus(p1 + vec3(0,-.165,0), vec2(1.005,.026));   \n\t\t\/\/\u540e\u9762\u90a3\u4e2a\u9f7f\u8f6e\u4e00\u6837\u7684\u4e1c\u4e1c\n        float bb = sdCylinderXY(p1+vec3(0,0,-1.3), vec2(0.15,0.04));\n        if(bb < 0.5) {\n            float a = atan(p1.y, p1.x);\n            float c = abs(fract(a*3.1415)-.5);\n            float d = min(abs(p1.z-1.3), .02);\n            bb = sdCylinderXY(p1+vec3(0,0,-1.3), vec2(0.11 - 40.*d*d - .1*c*c,0.04));\n        } \n        dM = opU(dM, bb);\n\t\t\/\/\u9525\u5f62\u4e1c\u897f\u4e0a\u7684\u5706\u67f1\uff1f\n        if (watchIntersect) {\n        float dDial = sdCylinder(p1, vec2(1.05,.13));\n        if (dDial < res.x) res = vec2(dDial, MAT_DIAL);\n\n        float dC = sdTorusYX(vec3(max(abs(p1.x)-.5*p1.y-0.19,0.),p1.y+0.12,p1.z-1.18), vec2(0.11,0.02));\n        if (dC < res.x) res = vec2(dC, MAT_METAL_1);\n        \n        float dM = sdTorus(p1 + vec3(0,-.165,0), vec2(1.005,.026));   \n        float bb = sdCylinderXY(p1+vec3(0,0,-1.3), vec2(0.15,0.04));\n        \n        if(bb < 0.5) {\n            float a = atan(p1.y, p1.x);\n            float c = abs(fract(a*3.1415)-.5);\n            float d = min(abs(p1.z-1.3), .02);\n            bb = sdCylinderXY(p1+vec3(0,0,-1.3), vec2(0.15 - 40.*d*d - .1*c*c,0.04));\n        } \n        dM = opU(dM, bb);\n        dM = opU(dM, sdCylinderZY(p1+vec3(0,-0.2,1.1),vec2(0.04,0.08)));\n        dM = opU(dM, sdCylinderZY(p1+vec3(-0.165,-0.2,1.1),vec2(0.05,0.08)));\n        dM = opU(dM, sdCylinderZY(p1+vec3(0.165,-0.2,1.1),vec2(0.05,0.08)));\n        dM = opU(dM, sdCylinderZY(p1+vec3(0,-0.2,1.1),vec2(0.01,0.25)));\n        dM = opU(dM, sdCylinderZY(p1+vec3(0,0,-1.18), vec2(0.06,0.2)));\n        float rr = min(abs(p1.z-1.26), .2);\n\t\t\/\/\u8ddf\u94fe\u6761\u8fde\u63a5\u7684\u9525\u5f62\u7684\u4e1c\u897f\uff1f\n        dM = opU(dM, sdCylinderXY(p1+vec3(0,0,-1.2), vec2(0.025 + 0.35*rr,0.1)));\n       \n        p1.y = abs(p1.y);\n\t\t\/\/\u8868\u76d8\u5916\u9762\u4e00\u4e9b\u7684\u91d1\u5c5e\u73af\n        dM = opU(dM, sdTorus(p1 + vec3(0,-.1,0), vec2(1.025,.075)));\n\t\t\/\/\u5f62\u6210\u8868\u7684\u5916\u9762\u73af\u7ed5\u7684\u4e00\u5c42\u91d1\u5c5e\u73af\n        dM = opU(dM, sdCylinder(p1, vec2(1.1,.1)));\n\t\t\/\/\u53bb\u6389\u4e00\u5c42\u91d1\u5c5e\u73af\uff0c\u5f62\u6210\u6bd4\u8f83\u660e\u663e\u7684\u68f1\u89d2\n        dM = opS(sdTorus(p1 + vec3(0,-.1,0), vec2(1.11,.015)), dM);\n\t\t\/\/\u5206\u9488\u65f6\u9488\u7684\u87ba\u4e1d\u9489\n        dM = opU(dM, sdCylinder(p1, vec2(0.01,0.175)));\n\t\t\/\/\u79d2\u9488\u7684\u87ba\u4e1d\u9489\n        dM = opU(dM, sdCylinder(p1+vec3(0,0,.6), vec2(0.01,0.155)));\n        if (dM < res.x) res = vec2(dM, MAT_METAL_0);\n\n        \/\/ \u5206\u9488\n        float dMin = mapHand(pm + vec3(0,-.16,0), .02, 0.7, 0.015);\n        if (dMin < res.x) res = vec2(dMin, MAT_HAND);\n        \/\/ \u65f6\u9488\n        float dHour = mapHand(ph + vec3(0,-.15,0), .02, 0.4, 0.03);\n        if (dHour < res.x) res = vec2(dHour, MAT_HAND);\n        \/\/ \u79d2\u9488\n        float dSeconds = mapHand(ps + vec3(0,-.14,0), .01, 0.17, 0.006);\n        if (dSeconds < res.x) res = vec2(dSeconds, MAT_HAND);\n        }\n    }\n\tif(coverIntersect){\n        \/\/\u5916\u8868\u9762 \n        float dE = sdEllipsoid(p2+vec3(0,-0.015,0), vec3(1.,.2,1.));\n        \/\/if (dCover2 < res.x) res = vec2(dCover2,MAT_METAL_0);\n        \n\t\tfloat dC = sdCylinder(p2+vec3(0,0.13,0), vec2(1.02,0.15));\n        float dCover1 = opS( dC, dE);\n        \/\/\n        if (dCover1 < res.x) res = vec2(dCover1,MAT_METAL_0);\n        \n        \/\/\u5185\u8868\u9762 \u6539\u6210\u955c\u9762\uff1f\n        float dCover2 = sdCylinder(p2+vec3(0,0.,0),vec2(1.02,0.001));\n        if (dCover2 < res.x) res = vec2(dCover2, MAT_METAL_1);\n        \n        \/\/\u5916\u9762\u7684\u73af\u513f\n        float dTorus = sdTorus(p2+vec3(0,0.015,0), vec2(1.05,0.04));\n        if (dTorus < res.x) res = vec2(dTorus, MAT_METAL_0);\n\t}\n\tif(capIntersect){\n        \/\/\u7b14\u5e3d\u4e3b\u4f53\n\t\tfloat dcap1 = sdCappedCone(p3, 0.6, 0.16 ,0.14);\n\t\tif (dcap1 < res.x) res = vec2(dcap1,MAT_HAND);\n        \/\/\u7b14\u5e3d\u4e0a\u7684\u9ec4\u91d1\u7684\u5934\uff0c\u8fd8\u53bb\u6389\u4e86\u4e24\u5708\n        float dcap2 = sdCylinderZY(p3+vec3(-0.6,0,0),vec2(0.14,0.1));\n        dcap2 = opS(sdTorusYZ(p3+vec3(-0.63,0,0),vec2(0.14,0.0075)),dcap2);\n        dcap2 = opS(sdTorusYZ(p3+vec3(-0.66,0,0),vec2(0.14,0.0075)),dcap2);\n\n        if (dcap2 < res.x) res = vec2(dcap2,MAT_METAL_0);       \n        \n        \/\/\u7b14\u5e3d\u4e0a\u5939\u4e66\u7684\u90a3\u4e2a\u957f\u6761\n        float dcap3 = sdRoundBox(p3+vec3(0,0,0.18),vec3(0.7,0.05,0.015),0.);\n        \n        if (dcap3 < res.x) res = vec2(dcap3,MAT_METAL_0);\n        \/\/\u8fde\u63a5\u957f\u6761\u548c\u7b14\u5e3d\n        float dcap4 = sdRoundBox(p3+vec3(-0.65,0,0.17),vec3(0.05,0.05,0.03),0.);\n        if (dcap4 < res.x) res = vec2(dcap4,MAT_METAL_0);\n        \n        float dcap5 = sdTorusYZ(p3+vec3(0.6,0,0),vec2(0.142,0.015));\n        if (dcap5 < res.x) res = vec2(dcap5,MAT_METAL_0);       \n\t}\n\t\n    return res;\n}\n\nvec2 map( in vec3 pos ) {\n    \/\/ \u949f\u8868\n    vec3 p1 = rotateX( pos + vec3(0,-CLOCK_OFFSET_Y,0), CLOCK_ROT_X );\n    p1 = rotateY( p1, CLOCK_ROT_Y );\n    \n    \/\/ \u949f\u8868\u76d6\u5b50\uff0c\u8981\u8f6c\u5230\u5408\u9002\u7684\u4f4d\u7f6e\u4e0a\u53bb\n    vec3 p2 = rotateX( pos, COVER_ROT_X );\n    vec3 rBot = vec3(0, rBOT.z * -1. * sin(COVER_ROT_X), rBOT.z * cos(COVER_ROT_X));\n\n    vec3 ad = DEST - rBot;\n\tvec3 ab = rBot * -2.;\n\t\n\tfloat dz = -1.* dot(ad,ab)\/sqrt(dot(ab,ab));\n\t\n\tvec3 ob = vec3(0,0,-1);\n\tvec3 od = DEST;\n\t\n\tfloat cosine = dot(ob,od)\/(sqrt(dot(od,od)));\n\tfloat stdAngle = acos(cosine);\n\tfloat s = -1.;\n    \n\tif (cosine >cos(COVER_ROT_X)){\n\t\ts = 1.;\n\t}\n\tfloat dis = dot(ad,ad);\n\tfloat dy = s*sqrt(dis-dz*dz);\n\t\n    vec3 offset = vec3(0,dy,dz);\n    p2 = p2 + offset;\n    \n    \/\/ \u7b14\u5e3d\n\tvec3 p3 = rotateY(pos + CAP_POS, CAP_ROTATE_Y);\n\t\n\tfloat secs = mod( floor(iDate.w),        60.0 );\n\tfloat mins = mod( floor(iDate.w\/60.0),   60.0 );\n\tfloat hors = mod( floor(iDate.w\/3600.0), 24.0 ) + mins\/60.;\n    \n    vec3 ps = rotateY( p1+vec3(0,0,.6), 6.2831*secs\/60.0 );\n    vec3 pm = rotateY( p1, 6.2831*mins\/60.0 );\n    vec3 ph = rotateY( p1, 6.2831*hors\/12.0 );\n    \n    return map( pos, p1, p2, p3,ps, pm, ph, true, true,true,true);\n}\n\n\/\/ \u949f\u8868\u8868\u9762\u7684\u73bb\u7483\nfloat mapGlass( in vec3 pos ) {\n    return sdEllipsoid( pos - vec3(0,.10,0), vec3(1.,.2,1.) );\n}\n\n\/\/ \u5305\u56f4\u76d2\u7684\u4ee3\u7801\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in float r ) {\n\tvec3 oc = ro;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - r * r;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n\treturn vec2(-b - h, -b + h);\n}\n\nbool boxIntserct( in vec3 ro, in vec3 rd, in vec3 rad ) {\n    vec3 m = 1.0\/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return false;\n\n\treturn true;\n}\n\n\/\/ \u8ba1\u7b97\u8868\u9762\u70b9\u7684\u6cd5\u7ebf\nvec3 calcNormal( in vec3 pos ) {\n    const vec2 e = vec2(1.0,-1.0)*0.000075;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\n\n\/\/ \u8ba1\u7b97\u73bb\u7483\u7684\u6cd5\u7ebf\nvec3 calcNormalGlass( in vec3 pos ) {\n    const vec2 e = vec2(1.0,-1.0)*0.005;\n    return normalize( e.xyy*mapGlass( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*mapGlass( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*mapGlass( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*mapGlass( pos + e.xxx ) );\n}\n\n\/\/ Ray Marching\u7b97\u6cd5\u7684\u4ee3\u7801\nfloat castRayGlass( in vec3 ro, in vec3 rd ) {\n    \/\/CLOCK_OFFSET_Y\u662f\u5c06\u949f\u8868\u4e0a\u79fb\u4ee5\u6b63\u786e\u5730\u67b6\u5728\u94a2\u7b14\u4e0a\n    vec3 p1 = rotateX( ro + vec3(0,-CLOCK_OFFSET_Y,0), CLOCK_ROT_X );\n    p1 = rotateY( p1, CLOCK_ROT_Y );\n    vec3 rd1 = rotateX( rd, CLOCK_ROT_X );\n    rd1 = rotateY( rd1, CLOCK_ROT_Y );\n\n    float t = -1.;\n    vec2 bb = sphIntersect( p1- vec3(0,.10,0), rd1, 1.);\n    if (bb.y > 0.) {\n        t = max(bb.x, 0.);\n        float tmax = bb.y;\n        for( int i=0; i<24; i++ ) {\n            float precis = 0.00025*t;\n            float res = mapGlass( p1+rd1*t );\n            if( res<precis || t>tmax ) break; \n            t += res;\n        }\n\n        if( t>tmax ) t=-1.0;\n    }\n    return t;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd ) {\n    float tmin = 0.0;\n    float tmax = MAX_T;\n    \n    \/\/ \u5305\u56f4\u76d2\u7684\u8ba1\u7b97\n    const float top =5.;\n    float tp1 = (0.0-ro.y)\/rd.y; if( tp1>0.0 ) { if( ro.y>0.0 ) tmax = min( tmax, tp1 );\n                                                else            tmin = max( tmin, tp1 ); }\n    float tp2 = (top-ro.y)\/rd.y; if( tp2>0.0 ) { if( ro.y>top ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n    \n    float t = tmin;\n    float mat = -1.;\n    \n    vec3 p1 = rotateX( ro + vec3(0,-CLOCK_OFFSET_Y,0), CLOCK_ROT_X ); \/\/CLOCK_OFFSET_Y\u662f\u5c06\u949f\u8868\u4e0a\u79fb\u4ee5\u6b63\u786e\u5730\u67b6\u5728\u94a2\u7b14\u4e0a\n    p1 = rotateY( p1, CLOCK_ROT_Y );\n\t\n    vec3 rd1 = rotateX( rd, CLOCK_ROT_X );\n    rd1 = rotateY( rd1, CLOCK_ROT_Y );\n    \n\t\/\/ \u949f\u8868\u76d6\u5b50\uff0c\u8981\u8f6c\u5230\u5408\u9002\u7684\u4f4d\u7f6e\u4e0a\u53bb\n    vec3 p2 = rotateX( ro, COVER_ROT_X );\n    vec3 rBot = vec3(0, rBOT.z * -1. * sin(COVER_ROT_X), rBOT.z * cos(COVER_ROT_X));\n\n    vec3 ad = DEST - rBot;\n\tvec3 ab = rBot * -2.;\n    vec3 ob = vec3(0,0,-1);\n\tvec3 od = DEST;\n\t\n\tfloat dz = -1.* dot(ad,ab)\/sqrt(dot(ab,ab));\n    float dis = dot(ad,ad);\n\tfloat cosine = dot(ob,od)\/(sqrt(dot(od,od)));\n\tfloat stdAngle = acos(cosine);\n\tfloat s = -1.;\n    \n\tif (cosine > cos(COVER_ROT_X)){\n\t\ts = 1.;\n\t}\n\n\tfloat dy = s*sqrt(dis-dz*dz);\n    vec3 offset = vec3(0,dy,dz);\n\n    p2 = p2 + offset;\n    vec3 rd2 = rotateX(rd, COVER_ROT_X);\n    \n\t\/\/\u7b14\u5e3d\n\tvec3 p3 = rotateY(ro + CAP_POS, CAP_ROTATE_Y);\n\tvec3 rd3 = rotateY(rd, CAP_ROTATE_Y);\n\t\n\t\/\/ \u949f\u8868\u5185\u90e8\u6307\u9488\n\tfloat secs = mod( floor(iDate.w),        60.0 );\n\tfloat mins = mod( floor(iDate.w\/60.0),   60.0 );\n\tfloat hors = mod( floor(iDate.w\/3600.0), 24.0 ) + mins\/60.;\n    \n    vec3 ps = rotateY( p1+vec3(0,0,.6), 6.2831*secs\/60.0 );\n    vec3 rds = rotateY( rd1, 6.2831*secs\/60.0 );\n    \n    vec3 pm = rotateY( p1, 6.2831*mins\/60.0 );\n    vec3 rdm = rotateY( rd1, 6.2831*mins\/60.0 );\n    \n    vec3 ph = rotateY( p1, 6.2831*hors\/12.0 );\n    vec3 rdh = rotateY( rd1, 6.2831*hors\/12.0 );\n    \n    \/\/ \u6c42\u4e0e\u5305\u56f4\u76d2\u662f\u5426\u7531\u4ea4\u70b9\n    bool watchIntersect = boxIntserct(p1, rd1, vec3(1.1,.2,1.4));\n    bool penIntersect = boxIntserct(ro + PEN_POS, rd, vec3(3.,.23,.23));\n\tbool coverIntersect = boxIntserct(p2, rd2, vec3(1.1,1.,1.4));\n\tbool capIntersect = boxIntserct(p3, rd3, vec3(1.,0.23,0.23));\n   \n\t\n    for( int i=0; i<48; i++ ) {\n\t    float precis = 0.00025*t;\n\t    vec2 res = map( ro+rd*t, p1+rd1*t, p2+rd2*t, p3+rd3*t, ps+rds*t, pm+rdm*t, ph+rdh*t, \n                       watchIntersect, penIntersect,coverIntersect, capIntersect);\n        if( res.x<precis || t>tmax ) break; \/\/return vec2(t, mat);\n        t += res.x;\n        mat = res.y;\n    }\n\n    if( t>tmax ) t=-1.0;\n    return vec2(t, mat);\n}\n\n\/\/ \u8ba1\u7b97\u73af\u5883\u5149\u906e\u853d\n\/\/ \u8fd9\u91cc\u4f7f\u7528\u8f6f\u9634\u5f71\u7b97\u6cd5\u4ee3\u66ff\n\/\/ https:\/\/www.iquilezles.org\/www\/articles\/rmshadows\/rmshadows.htm\nfloat calcAO( in vec3 ro, in vec3 rd ) {    \n    vec3 p1 = rotateX( ro + vec3(0,-CLOCK_OFFSET_Y,0), CLOCK_ROT_X ); \/\/CLOCK_OFFSET_Y\u662f\u5c06\u949f\u8868\u4e0a\u79fb\u4ee5\u6b63\u786e\u5730\u67b6\u5728\u94c5\u7b14\u4e0a\n    p1 = rotateY( p1, CLOCK_ROT_Y );\n\t\n    vec3 rd1 = rotateX( rd, CLOCK_ROT_X );\n    rd1 = rotateY( rd1, CLOCK_ROT_Y );\n    \n\t\/\/ \u949f\u8868\u76d6\u5b50\uff0c\u8981\u8f6c\u5230\u5408\u9002\u7684\u4f4d\u7f6e\u4e0a\u53bb\n    vec3 p2 = rotateX( ro, COVER_ROT_X );\n    vec3 rBot = vec3(0, rBOT.z * -1. * sin(COVER_ROT_X), rBOT.z * cos(COVER_ROT_X));\n\n    vec3 ad = DEST - rBot;\n\tvec3 ab = rBot * -2.;\n    vec3 ob = vec3(0,0,-1);\n\tvec3 od = DEST;\n\t\n\tfloat dz = -1.* dot(ad,ab)\/sqrt(dot(ab,ab));\n    float dis = dot(ad,ad);\n\tfloat cosine = dot(ob,od)\/(sqrt(dot(od,od)));\n\tfloat stdAngle = acos(cosine);\n\tfloat s = -1.;\n    \n\tif (cosine > cos(COVER_ROT_X)){\n\t\ts = 1.;\n\t}\n\n\tfloat dy = s*sqrt(dis-dz*dz);\n    vec3 offset = vec3(0,dy,dz);\n\n    p2 = p2 + offset;\n    vec3 rd2 = rotateX(rd, COVER_ROT_X);\n    \n\t\/\/\u7b14\u5e3d\n\tvec3 p3 = rotateY(ro + CAP_POS, CAP_ROTATE_Y);\n\tvec3 rd3 = rotateY(rd, CAP_ROTATE_Y);\n\t\n\t\/\/ \u949f\u8868\u5185\u90e8\u6307\u9488\n\tfloat secs = mod( floor(iDate.w),        60.0 );\n\tfloat mins = mod( floor(iDate.w\/60.0),   60.0 );\n\tfloat hors = mod( floor(iDate.w\/3600.0), 24.0 ) + mins\/60.;\n    \n    vec3 ps = rotateY( p1+vec3(0,0,.6), 6.2831*secs\/60.0 );\n    vec3 rds = rotateY( rd1, 6.2831*secs\/60.0 );\n    \n    vec3 pm = rotateY( p1, 6.2831*mins\/60.0 );\n    vec3 rdm = rotateY( rd1, 6.2831*mins\/60.0 );\n    \n    vec3 ph = rotateY( p1, 6.2831*hors\/12.0 );\n    vec3 rdh = rotateY( rd1, 6.2831*hors\/12.0 );\n    \n    bool watchIntersect = true;\n    bool penIntersect = true;\n    bool coverIntersect = true;\n    bool capIntersect = true;\n    \n    \n    float tmin = 0.;\n    float tmax = MAX_T;\n    float t = tmin;\n    float res = 1.0;\n    for( int i=0; i<48; i++ ) {\n\t    float precis = 0.00025*t;\n\t    vec2 h = map( ro+rd*t, p1+rd1*t, p2+rd2*t, p3+rd3*t, ps+rds*t, pm+rdm*t, ph+rdh*t, \n                       watchIntersect, penIntersect,coverIntersect, capIntersect);\n        if( h.x<precis ) \n            return 0.0;\n        else if ( t>tmax )\n            break;\n        res = min( res, 4.0 * h.x\/t);\n\n        t += h.x;\n    }\n    res = clamp(res, 0., 1.);\n    return res;\n}\n\n\n\/\/ \u91d1\u5c5e\u7684\u5c5e\u6027\nvec4 texNoise( sampler2D sam, in vec3 p, in vec3 n ) {\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\nvoid getMaterialProperties(\n    in vec3 pos, in vec3 rd, in float mat,\n    inout vec3 normal, inout vec3 albedo, inout float ao, inout float roughness, inout float metallic,\n\tsampler2D tex1, sampler2D tex2, sampler2D tex3) {\n    \n    vec3 pinv = rotateX( pos + vec3(0,-CLOCK_OFFSET_Y,0), CLOCK_ROT_X );\n    pinv = rotateY( pinv, CLOCK_ROT_Y );\n    \n    \/\/ \u8ba1\u7b97\u73af\u5883\u5149\u906e\u853dAO\n    normal = calcNormal( pos );\n    \/\/vec3 refl = reflect(rd, normal);\n    \/\/vec3 half_ = normalize(normal+refl);\n    ao = calcAO(pos, normal);\n    \n    \/\/ \u91d1\u5c5e\u5ea6\n    metallic = 0.;\n    \n    \/\/ \u6839\u636e\u4e0d\u540c\u4f4d\u7f6e\u8bbe\u7f6e\u91d1\u5c5e\u7684\u566a\u58f0\n    vec4 noise = texNoise(tex1, pinv * .5, normal);\n    float metalnoise = 1.- noise.r;\n    metalnoise*=metalnoise;\n\n    mat -= .5;\n    \/\/ \u684c\u5b50\u7684\u6750\u8d28\n    if (mat < MAT_TABLE) {\n        albedo = .7 * pow(texture(tex1, rotate(pos.xz * .4 + .25, -.3)).rgb, 2.2*vec3(0.45,0.5,0.5));\n        roughness = 0.95 - albedo.r * .6;\n    }\n    \n    \/\/ \u94a2\u7b14\u4e0d\u540c\u90e8\u5206\u7684\u6750\u8d28\u989c\u8272\n    else if( mat < MAT_PEN_0 ) {\n        vec2 npos = pos.yz + PEN_POS.yz;\n        if (length(npos) < 0.055) {\n        \talbedo = vec3(0.02);\n        \troughness = .9;\n        } else if(sdHexPrism(pos + PEN_POS, vec2(.195, 3.)) < 0.) {\n        \talbedo = .8* texture(tex1, pos.xz).rgb;\n        \troughness = 0.99;\n        } else {\n        \talbedo = .5*pow(vec3(1.,.8,.15), vec3(2.2));\n        \troughness = .75 - noise.b * .4;\n        }\n        albedo *= noise.g * .75 + .7;\n    }\n    else if( mat < MAT_PEN_1 ) {\n       \talbedo = .4*pow(vec3(.85,.75,.55), vec3(2.2));\n       \troughness = 1.;\n    }\n    else if( mat < MAT_PEN_2 ) {\n        float ax = abs(-2.25 - pos.x - PEN_POS.x);\n        float r = 1. - abs(2.*fract(30.*pos.x)-1.)*smoothstep(.08,.09,ax)*smoothstep(.21,.2,ax);\n\n        r -= 4. * metalnoise;  \n        ao *= .5 + .5 * r;\n\t    albedo = mix(vec3(0.5, 0.3, 0.2),vec3(0.560, 0.570, 0.580), ao * ao); \/\/ Iron\n   \t\troughness = 1.-.25*r;\n   \t\tmetallic = 1.; \n    }\n    \/\/ \u949f\u8868\u7684\u6750\u8d28\n    else if( mat < MAT_DIAL ) {\n        float dial = texture(tex2, vec2(-.5 * pinv.x + .5, +.5 * pinv.z + .5)).r;\n        albedo = vec3(dial);\n        roughness = dial + .95;\n        ao = 1.;\n    }\n    else if( mat < MAT_HAND ) {\n        albedo = vec3(0.02);\n        roughness = .65;\n    }\n    \/\/ \u91d1\u8272\u548c\u94f6\u8272\n    else if( mat < MAT_METAL_0 ) {\n\t    albedo = vec3(1.000, 0.766, 0.336); \/\/ Gold\n   \t\troughness = .6;\n   \t\tmetallic = 1.; \n    } \n    else if( mat < MAT_METAL_1 ) {\n\t    albedo = vec3(0.972, 0.960, 0.915); \/\/ Silver\n   \t\troughness = .7 + max(.15 * length(pos.xz)-.3, 0.); \/\/ prevent aliasing\n   \t\tmetallic = 1.; \n    }\n    if (mat < MAT_PEN_2) {\n        ao = min(ao, smoothstep(.95, 1.5, length(pos.xz)));\n    }\n    \n    \/\/ \u91d1\u5c5e\u7684\u4e00\u4e9b\u5904\u7406\n    if (metallic > .5) {   \n        albedo *= 1.-metalnoise;\n        roughness += metalnoise*4.;\n    }\n    \n    ao = clamp(.1+.9*ao, 0., 1.);\n    roughness = clamp(roughness, 0., 1.);\n}\n\n\/\/ \u8bbe\u7f6e\u6444\u50cf\u673a\nmat3 setCamera( in vec3 ro, in vec3 ta ) {\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(0.0, 1.0,0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n",
            "name": "Common",
            "description": "",
            "type": "common"
        },
        {
            "inputs": [],
            "outputs": [],
            "code": "\/\/ \u949f\u8868\u6ef4\u6ef4\u7b54\u7b54\u7684\u58f0\u97f3\nfloat tick( float time )\n{\n    return pow(max(sin(6.2831 * (time + 0.25)) - 0.9999, 0.0), 1.0 \/ 16.0);\n}\n\nvec2 mainSound( int samp, float time )\n{\n    float volume = 0.0625;\n    float freq0 = sin(6.2831* 7896.0*time) * 0.25 * tick(time - 0.008);\n    float freq1 = sin(6.2831* 7743.0*time) * 1.00 * tick(time + 0.000);;\n    float freq2 = sin(6.2831* 8125.0*time) * 0.70 * tick(time + 0.008);;\n    \n    return vec2(volume * (freq0 + freq1 + freq2) );\n}",
            "name": "Sound",
            "description": "",
            "type": "sound"
        }
    ]
}