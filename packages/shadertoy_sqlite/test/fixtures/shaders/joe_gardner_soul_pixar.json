{
    "ver": "0.1",
    "info": {
        "id": "3ltyRB",
        "date": "1609385636",
        "viewed": 571,
        "name": "Joe Gardner (Soul Pixar)",
        "username": "leon",
        "description": "Joe Gardner from Soul (Pixar 2020)\nSpent the night building this little guy after watching the movie",
        "likes": 23,
        "published": 3,
        "flags": 0,
        "usePreview": 0,
        "tags": [
            "pixar",
            "soul"
        ],
        "hasliked": 0
    },
    "renderpass": [
        {
            "inputs": [],
            "outputs": [
                {
                    "id": "4dfGRr",
                    "channel": 0
                }
            ],
            "code": "\/\/ Joe Gardner from Soul (Pixar 2020)\n\/\/\n\/\/ by Leon Denise 2020.12.31\n\/\/ \n\/\/ thanks to Inigo Quilez, Dave Hoskins, Koltes, NuSan\n\/\/ for sharing useful lines of code\n\/\/\n\/\/ Licensed under hippie love conspiracy\n\nbool ao_pass = false;\n\n\/\/ volumes description\nVolume map(vec3 pos)\n{\n    float shape = 100.;\n\n    \/\/ global twist animation\n    pos.zy *= rot(sin(pos.y*.2 + time) * .1 + .2);\n    pos.yx *= rot(0.1 * sin(pos.y * .3 + time));\n    vec3 p = pos;\n\n    Volume ghost;\n    ghost.mat = 0;\n    ghost.density = 0.05;\n    ghost.space = 0.12;\n    \n    Volume opaque;\n    opaque.mat = 0;\n    opaque.density = 1.;\n    opaque.space = 0.;\n    \n    Volume hair;\n    hair.mat = mat_eyebrows;\n    hair.density = .2;\n    hair.space = 0.1;\n    \n    Volume glass;\n    glass.mat = mat_glass;\n    glass.density = .15;\n    glass.space = 0.1;\n\n    \/\/ head\n    ghost.dist = length(p*vec3(1,0.9,1))-1.0;\n    ghost.dist = opSmoothUnion(ghost.dist, length(p-vec3(0,1.2,0))-0.55, 0.35);\n    \n    \/\/ mouth\n    p.z += 1.3;\n    p.yz *= rot(p.z * .5 + 0.1*sin(time+p.z*4.));\n    shape = sdBox(p, vec3(1,0.01,1.));\n    shape = max(shape, -length(pos.xz)+.99);\n    ghost.dist = opSmoothSubtraction(shape, ghost.dist, 0.1);\n\n    \/\/ hat\n    p = pos-vec3(0,1.6,0);\n    shape = sdRoundedCylinder(p + sin(p.z*4.)*.03, .4, .01, .01);\n    shape = min(shape, sdCappedCone(p+.05*sin(p.z*8.), vec3(0,.5,0), vec3(0), .3, .445));\n    ghost.dist = min(ghost.dist, shape);\n\n    \/\/ eyes globes\n    p = pos-vec3(0,1.,-.55);\n    float s = sign(p.x);\n    p.xz *= rot(-pos.x*1.);\n    p.x = abs(p.x)-.15;\n    opaque.dist = max(length(p*vec3(1,1.,1.3))-0.18, -ghost.dist);\n    opaque.mat = mat_eye_globe;\n\n    \/\/ eyebrows\n    p -= vec3(0.05,.3,-.03);\n    p.y -= 0.01*sin(time*3.);\n    p.xy *= rot(0.2 + sin(pos.x * 2. + time)*.5);\n    shape = sdBox(p, vec3(.15,0.02-p.x*.1,.03));\n    hair.dist = shape;\n\n    \/\/ body\n    p = pos;\n    ghost.dist = opSmoothUnion(ghost.dist, length(p+vec3(0,1.8,0))-.5, 0.6);\n\n    \/\/ legs\n    p.x = abs(p.x)-.2;\n    p.z += 0.1*sin(p.x*4. + time);\n    ghost.dist = opSmoothUnion(ghost.dist, sdVerticalCapsule(p+vec3(0,2.8,0), 0.6, 0.01+max(0.,p.y+3.)*0.3), 0.2);\n\n    \/\/ arms\n    p = pos;\n    p.x = abs(p.x)-.4;\n    p.xy *= rot(3.14\/2.);\n    p.x += pos.x*0.2*sin(pos.x + time);\n    ghost.dist = opSmoothUnion(ghost.dist, sdVerticalCapsule(p+vec3(-1.5,0,0), 0.6, 0.2), 0.2);\n    \n    Volume volume = select(select(ghost, opaque), hair);\n\n    \/\/ glass\n    if (!ao_pass)\n    {\n        p = pos-vec3(0,1.,-.65);\n        p.x = abs(p.x)-.18;\n        glass.dist = sdRoundBox(p+vec3(-0.1,0,.1), vec3(0.2+p.y*0.1, 0.15+p.x*.05, 0.001), 0.05);\n        glass.dist = max(glass.dist, -sdRoundBox(p+vec3(-0.1,0,.1), vec3(0.18+p.y*0.1, 0.14+p.x*.05, 0.1), 0.05));\n        glass.dist = max(glass.dist, abs(p.z)-.1);\n        volume = select(volume, glass);\n    }\n\n    return volume;\n}\n\n\/\/ NuSan\n\/\/ https:\/\/www.shadertoy.com\/view\/3sBGzV\nvec3 getNormal(vec3 p) {\n\tvec2 off=vec2(0.001,0);\n\treturn normalize(map(p).dist-vec3(map(p-off.xyy).dist, map(p-off.yxy).dist, map(p-off.yyx).dist));\n}\n\n\/\/ Inigo Quilez\n\/\/ https:\/\/www.shadertoy.com\/view\/Xds3zN\nfloat getAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)\/4.0;\n        Volume volume = map( pos + h*nor );\n        float d = volume.dist;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\nvoid mainImage( out vec4 color, in vec2 coordinate )\n{\n    \/\/ coordinates\n    vec2 uv = coordinate \/ iResolution.xy;\n    vec2 p = 2.*(coordinate - 0.5 * iResolution.xy)\/iResolution.y;\n    \n    \/\/ camera\n    vec3 pos = vec3(-5,0,-8);\n    \n    \/\/ look at\n    vec3 z = normalize(vec3(0,-0.3,0)-pos);\n    vec3 x = normalize(cross(z, vec3(0,1,0)));\n    vec3 y = normalize(cross(x, z));\n    vec3 ray = normalize(z * 3. + x * p.x + y * p.y);\n    \n    \/\/ background gradient\n    color.rgb += vec3(0.2235, 0.3804, 0.5882) * uv.y;\n    \n    \/\/ render variables\n    float shade = 0.0;\n    vec3 normal = vec3(0,1,0);\n    float ao = 1.0;\n    float rng = hash12(coordinate + time);\n    const int count = 30;\n    \n    \/\/ raymarch iteration\n    for (int index = 0; index < count; ++index)\n    {\n        Volume volume = map(pos);\n        if (volume.dist < 0.01)\n        {\n            \/\/ sample ao when first hit\n            if (shade < 0.001)\n            {\n                ao_pass = true;\n                ao = getAO(pos, normal);\n                ao_pass = false;\n            }\n            \n            \/\/ accumulate fullness\n            shade += volume.density;\n            \n            \/\/ step further on edge of volume\n            normal = getNormal(pos);\n            float fresnel = pow(dot(ray, normal)*.5+.5, 1.2);\n            volume.dist = volume.space * fresnel;\n            \n            \/\/ coloring\n            vec3 col = vec3(0);\n            switch (volume.mat)\n            {\n                \/\/ eye globes color\n                case mat_eye_globe:\n                float globe = dot(normal, vec3(0,1,0))*0.5+0.5;\n                vec3 look = vec3(0,0,-1);\n                look.xz *= rot(sin(time)*0.2-.2);\n                look.yz *= rot(sin(time*2.)*0.1+.5);\n                float pupils = smoothstep(0.01, 0.0, dot(normal, look)-.95);\n                col += vec3(1)*globe*pupils;\n                break;\n\n                \/\/ eyebrows color\n                case mat_eyebrows:\n                col += vec3(0.3451, 0.2314, 0.5255);\n                break;\n\n                \/\/ glass color\n                case mat_glass:\n                col += vec3(.2);\n                break;\n\n                \/\/ ghost color\n                default:\n                vec3 leftlight = normalize(vec3(6,-5,1));\n                vec3 rightlight = normalize(vec3(-3,1,1));\n                vec3 frontlight = normalize(vec3(-1,1,-2));\n                vec3 blue = vec3(0,0,1) * pow(dot(normal, leftlight)*0.5+0.5, 0.2);\n                vec3 green = vec3(0,1,0) * pow(dot(normal, frontlight)*0.5+0.5, 2.);\n                vec3 red = vec3(0.8941, 0.2039, 0.0824) * pow(dot(normal, rightlight)*0.5+0.5, .5);\n                col += blue + green + red;\n                col *= ao*0.5+0.3;\n                break;\n            }\n            \n            \/\/ accumulate color\n            color.rgb += col * volume.density;\n        }\n        \n        \/\/ stop when fullness reached\n        if (shade >=  1.0)\n        {\n            break;\n        }\n        \n        \/\/ dithering trick inspired by Duke\n        volume.dist *= 0.9 + 0.1 * rng;\n        \n        \/\/ keep marching\n        pos += ray * volume.dist;\n    }\n}",
            "name": "Image",
            "description": "",
            "type": "image"
        },
        {
            "inputs": [],
            "outputs": [],
            "code": "\n#define time iTime\n#define repeat(p,r) (mod(p+r\/2.,r)-r\/2.)\n\n\/\/ details about sdf volumes\nstruct Volume\n{\n    float dist;\n    int mat;\n    float density;\n    float space;\n};\n\n\/\/ union operation between two volume\nVolume select(Volume a, Volume b)\n{\n    if (a.dist < b.dist) return a;\n    return b;\n}\n\n\/\/ materials\nconst int mat_eye_globe = 1;\nconst int mat_pupils = 2;\nconst int mat_eyebrows = 3;\nconst int mat_iris = 4;\nconst int mat_glass = 5;\n\n\/\/ Rotation 2D matrix\nmat2 rot(float a) { float c = cos(a), s = sin(a); return mat2(c,-s,s,c); }\n\n\/\/ Dave Hoskins\n\/\/ https:\/\/www.shadertoy.com\/view\/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\/\/ Inigo Quilez\n\/\/ https:\/\/www.iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)\/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)\/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)\/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\nfloat sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)\/baba;\n    float x = sqrt( papa - paba*paba*baba );\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)\/k, 0.0, 1.0 );\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n",
            "name": "Common",
            "description": "",
            "type": "common"
        }
    ]
}