{
    "ver": "0.1",
    "info": {
        "id": "4dKGWm",
        "date": "1454853751",
        "viewed": 24038,
        "name": "Elephant",
        "username": "iq",
        "description": "Signed distance field raymarching. Procedural elephants. Or a bunch of ellipsoids and few lines and a couple of quadratic curves. Split it in layers to prevent the compiler from crashing. The art is composed to camera. It runs very slow, but it loos good!",
        "likes": 122,
        "published": 3,
        "flags": 32,
        "tags": [
            "procedural",
            "3d",
            "raymarching",
            "distancefield"
        ],
        "hasliked": 0
    },
    "renderpass": [
        {
            "inputs": [
                {
                    "id": "XsXGRn",
                    "filepath": "\/media\/a\/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg",
                    "previewfilepath": "\/media\/ap\/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg",
                    "type": "texture",
                    "channel": 0,
                    "sampler": {
                        "filter": "mipmap",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "4df3Rr",
                    "filepath": "\/media\/a\/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg",
                    "previewfilepath": "\/media\/ap\/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg",
                    "type": "texture",
                    "channel": 1,
                    "sampler": {
                        "filter": "mipmap",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "4sf3Rr",
                    "filepath": "\/media\/a\/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png",
                    "previewfilepath": "\/media\/ap\/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png",
                    "type": "texture",
                    "channel": 2,
                    "sampler": {
                        "filter": "mipmap",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "XsXGR8",
                    "filepath": "\/media\/previz\/buffer01.png",
                    "previewfilepath": "\/media\/previz\/buffer01.png",
                    "type": "buffer",
                    "channel": 3,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dfGRr",
                    "channel": 0
                }
            ],
            "code": "\/\/ Created by inigo quilez - iq\/2016\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\/\/ Youtube video capture: https:\/\/www.youtube.com\/watch?v=vga8FZzv5GE\n\nfloat hash1( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)\/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 smin( vec2 a, vec2 b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b.x-a.x)\/k, 0.0, 1.0 );\n\treturn vec2( mix( b.x, a.x, h ) - k*h*(1.0-h), mix( b.y, a.y, h ) );\n}\n\nfloat smax( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)\/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\nfloat eliSoftShadow( in vec3 ro, in vec3 rd, in vec3 sphcen, in vec3 sphrad, in float k )\n{\n    vec3 oc = ro - sphcen;\n    \n    vec3 ocn = oc \/ sphrad;\n    vec3 rdn = rd \/ sphrad;\n    \n    float a = dot( rdn, rdn );\n\tfloat b = dot( ocn, rdn );\n\tfloat c = dot( ocn, ocn );\n\tfloat h = b*b - a*(c-1.0);\n\n    float t = (-b - sqrt( max(h,0.0) ))\/a;\n\n    return (h>0.0) ? step(t,0.0) : smoothstep(0.0, 1.0, -k*h\/max(t,0.0) );\n}\n\nvec2 sdSegment( in vec3 p, vec3 a, vec3 b )\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ), h );\n}\n\nfloat sdSphere( in vec3 p, in vec3 c, in float r )\n{\n    return length(p-c) - r;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 c, in vec3 r )\n{\n#if 1    \n    return (length( (p-c)\/r ) - 1.0) * min(min(r.x,r.y),r.z);\n#else\n    p -= c;\n    float k0 = length(p\/r);\n    float k1 = length(p\/(r*r));\n    return k0*(k0-1.0)\/k1;\n#endif    \n}\n\n\/\/ http:\/\/research.microsoft.com\/en-us\/um\/people\/hoppe\/ravg.pdf\nfloat det( vec2 a, vec2 b ) { return a.x*b.y-b.x*a.y; }\nvec3 getClosest( vec2 b0, vec2 b1, vec2 b2 ) \n{\n  float a =     det(b0,b2);\n  float b = 2.0*det(b1,b0);\n  float d = 2.0*det(b2,b1);\n  float f = b*d - a*a;\n  vec2  d21 = b2-b1;\n  vec2  d10 = b1-b0;\n  vec2  d20 = b2-b0;\n  vec2  gf = 2.0*(b*d21+d*d10+a*d20); gf = vec2(gf.y,-gf.x);\n  vec2  pp = -f*gf\/dot(gf,gf);\n  vec2  d0p = b0-pp;\n  float ap = det(d0p,d20);\n  float bp = 2.0*det(d10,d0p);\n  float t = clamp( (ap+bp)\/(2.0*a+b+d), 0.0 ,1.0 );\n  return vec3( mix(mix(b0,b1,t), mix(b1,b2,t),t), t );\n}\n\nvec2 sdBezier( vec3 a, vec3 b, vec3 c, vec3 p, out vec2 pos )\n{\n\tvec3 w = normalize( cross( c-b, a-b ) );\n\tvec3 u = normalize( c-b );\n\tvec3 v = normalize( cross( w, u ) );\n\n\tvec2 a2 = vec2( dot(a-b,u), dot(a-b,v) );\n\tvec2 b2 = vec2( 0.0 );\n\tvec2 c2 = vec2( dot(c-b,u), dot(c-b,v) );\n\tvec3 p3 = vec3( dot(p-b,u), dot(p-b,v), dot(p-b,w) );\n\n\tvec3 cp = getClosest( a2-p3.xy, b2-p3.xy, c2-p3.xy );\n\n    pos = cp.xy;\n    \n\treturn vec2( sqrt(dot(cp.xy,cp.xy)+p3.z*p3.z), cp.z );\n}\n\n#define ZERO (min(iFrame,0))\n\n\/\/---------------------------------------------------------------------------\n\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n, in float k, in vec3 g1, in vec3 g2 )\n{\n    vec3 m = pow( abs( n ), vec3(k) );\n\tvec4 x = textureGrad( sam, p.yz, g1.yz, g2.yz );\n\tvec4 y = textureGrad( sam, p.zx, g1.zx, g2.zx );\n\tvec4 z = textureGrad( sam, p.xy, g1.xy, g2.xy );\n\treturn (x*m.x + y*m.y + z*m.z) \/ (m.x + m.y + m.z);\n}\n\nmat3 base( in vec3 ww )\n{\n    vec3  vv = vec3(0.0,0.0,1.0);\n    vec3  uu = normalize( cross( vv, ww ) );\n    return mat3(uu.x,ww.x,vv.x,\n                uu.y,ww.y,vv.y,\n                uu.z,ww.z,vv.z);\n}\n\n\/\/---------------------------------------------------------------------------\n\nfloat leg( in vec3 p, in vec3 pa, in vec3 pb, in vec3 pc, float m, float h )\n{\n    float l = sign(pa.z);\n    \n    vec2 b = sdSegment( p, pa, pb );\n\n    float tr = 0.35 - 0.16*smoothstep(0.0,1.0,b.y);\n    float d3 = b.x - tr;\n\n    b = sdSegment( p, pb, pc );\n    tr = 0.18;\n    d3 = smin( d3, b.x - tr, 0.1 );\n\n    \/\/ paw        \n    vec3 ww = normalize( mix( normalize(pc-pb), vec3(0.0,1.0,0.0), h) );\n    mat3 pr = base( ww );\n    vec3 fc = pr*((p-pc))-vec3(0.02,0.0,0.0)*(-1.0+2.0*h);\n    float d4 = sdEllipsoid( fc, vec3(0.0), vec3(0.2,0.15,0.2) );\n\n    d3 = smin( d3, d4, 0.1 );\n\n    \/\/ nails\n    float d6 = sdEllipsoid( fc, vec3(0.14,-0.06,0.0)*(-1.0+2.0*h), vec3(0.1,0.16,0.1));\n    d6 = min( d6, sdEllipsoid( vec3(fc.xy,abs(fc.z)), vec3(0.13*(-1.0+2.0*h),-0.08*(-1.0+2.0*h),0.13), vec3(0.09,0.14,0.1)) );\n    d3 = smin( d3, d6, 0.001 );\n\treturn d3;\n}\n\nvec2 mapElephant( vec3 p, out vec3 matInfo )\n{\n    matInfo = vec3(0.0);\n    \n    p.x -= -0.5;\n\tp.y -= 2.4;\n    \n    vec3 ph = p;\n    float cc = 0.995;\n    float ss = 0.0998745;\n    ph.yz = mat2(cc,-ss,ss,cc)*ph.yz;\n    ph.xy = mat2(cc,-ss,ss,cc)*ph.xy;\n    \n    \/\/ head\n    float d1 = sdEllipsoid( ph, vec3(0.0,0.05,0.0), vec3(0.45,0.5,0.3) );\n    d1 = smin( d1, sdEllipsoid( ph, vec3(-0.3,0.15,0.0), vec3(0.2,0.2,0.2) ), 0.1 );\n\n    \/\/ nose\n    vec2 kk;\n    vec2 b1 = sdBezier( vec3(-0.15,-0.05,0.0), vec3(-0.7,0.0,0.0), vec3(-0.7,-0.8,0.0), ph, kk );\n    float tr1 = 0.30 - 0.17*smoothstep(0.0,1.0,b1.y);\n    vec2  b2 = sdBezier( vec3(-0.7,-0.8,0.0), vec3(-0.7,-1.5,0.0), vec3(-0.4,-1.6,0.2), ph, kk );\n    float tr2 = 0.30 - 0.17 - 0.05*smoothstep(0.0,1.0,b2.y);\n    float bd1 = b1.x-tr1;\n    float bd2 = b2.x-tr2;\n    float nl = b1.y*0.5;\n    float bd = bd1;\n    if( bd2<bd1 )\n    {\n        nl = 0.5 + 0.5*b2.y;\n        bd = bd2;\n    }\n    matInfo.x = clamp(nl * (1.0-smoothstep(0.0,0.2,bd)),0.0,1.0);\n    float d2 = bd;\n    float xx = nl*120.0;\n    float ff = sin(xx + sin(xx + sin(xx + sin(xx))));\n    \/\/ff *= smoothstep(0.0,0.01,kk.y);\n    d2 += 0.003*ff*(1.0-nl)*(1.0-nl)*smoothstep(0.0,0.1,nl);\n\n    d2 -= (0.05 - 0.05*(1.0-pow(textureLod( iChannel0, vec2(1.0*nl,p.z*0.12), 0.0 ).x,1.0)))*nl*(1.0-nl)*0.5;\n    \n    float d = smin(d1,d2,0.2);\n\n    \/\/ teeth\n    vec3 q = vec3( p.xy, abs(p.z) );\n    vec3 qh = vec3( ph.xy, abs(ph.z) );\n    {\n    vec2 s1 = sdSegment( qh, vec3(-0.4,-0.1,0.1), vec3(-0.5,-0.4,0.28) );\n    float d3 = s1.x - 0.18*(1.0 - 0.3*smoothstep(0.0,1.0,s1.y));\n    d = smin( d, d3, 0.1 );\n    }\n    \n    \/\/ eyes\n    {\n    vec2 s1 = sdSegment( qh, vec3(-0.2,0.2,0.11), vec3(-0.3,-0.0,0.26) );\n    float d3 = s1.x - 0.19*(1.0 - 0.3*smoothstep(0.0,1.0,s1.y));\n    d = smin( d, d3, 0.03 );\n\n    float st = length(qh.xy-vec2(-0.31,-0.02));\n    \/\/d += 0.005*sin(250.0*st)*exp(-110.0*st*st );\n    d += 0.0015*sin(250.0*st)*(1.0-smoothstep(0.0,0.2,st));\n\n        \n    mat3 rot = mat3(0.8,-0.6,0.0,\n                    0.6, 0.8,0.0,\n                    0.0, 0.0,1.0 );\n    float d4 = sdEllipsoid( rot*(qh-vec3(-0.31,-0.02,0.34)), vec3(0.0), vec3(0.1,0.08,0.07)*0.7 );\n\td = smax(d, -d4, 0.02 );\n    }\n   \n\n    \/\/ body\n    {\n    float co = cos(0.4);\n    float si = sin(0.4);\n    vec3 w = p;\n    w.xy = mat2(co,si,-si,co)*w.xy;\n\n    float d4 = sdEllipsoid( w, vec3(0.6,0.3,0.0), vec3(0.6,0.6,0.6) );\n\td = smin(d, d4, 0.1 );\n\n    d4 = sdEllipsoid( w, vec3(1.8,0.3,0.0), vec3(1.2,0.9,0.7) );\n\td = smin(d, d4, 0.2 );\n\n    d4 = sdEllipsoid( w, vec3(2.1,0.55,0.0), vec3(1.0,0.9,0.6) );\n\td = smin(d, d4, 0.1 );\n\n    d4 = sdEllipsoid( w, vec3(2.0,0.8,0.0), vec3(0.7,0.6,0.8) );\n\td = smin(d, d4, 0.1 );\n    }\n\n    \/\/ back-left leg\n    {\n    float d3 = leg( q, vec3(2.6,-0.5,0.3), vec3(2.65,-1.45,0.3), vec3(2.6,-2.1,0.25), 1.0, 0.0 );\n    d = smin(d,d3,0.1);\n    }\n    \n\t\/\/ tail\n    #if 0\n    {\n    vec2 b = sdBezier( vec3(2.8,0.2,0.0), vec3(3.4,-0.6,0.0), vec3(3.1,-1.6,0.0), p, kk );\n    float tr = 0.10 - 0.07*b.y;\n    float d2 = b.x - tr;\n    d = smin( d, d2, 0.05 );\n    }\n    #endif\n        \n    \/\/ front-left leg\n    #if 0\n    {\n    float d3 = leg( q, vec3(0.8,-0.4,0.3), vec3(0.5,-1.55,0.3), vec3(0.5,-2.1,0.3), 1.0, 0.0 );\n    d = smin(d,d3,0.15);\n    }\n    #else\n    {\n    float d3 = leg( p, vec3(0.8,-0.4,0.3), vec3(0.7,-1.55,0.3), vec3(0.8,-2.1,0.3), 1.0, 0.0 );\n    d = smin(d,d3,0.15);\n    d3 = leg( p, vec3(0.8,-0.4,-0.3), vec3(0.4,-1.55,-0.3), vec3(0.4,-2.1,-0.3), 1.0, 0.0 );\n    d = smin(d,d3,0.15);\n    }\n    #endif\n    \n#if 1\n    \/\/ ear\n    float co = cos(0.5);\n    float si = sin(0.5);\n    vec3 w = qh;\n    w.xz = mat2(co,si,-si,co)*w.xz;\n    \n    vec2 ep = w.zy - vec2(0.5,0.4);\n    float aa = atan(ep.x,ep.y);\n    float al = length(ep);\n    w.x += 0.003*sin(24.0*aa)*smoothstep(0.0,0.5,dot(ep,ep));\n    w.x += 0.02*textureLod( iChannel1, vec2(al*0.02,0.5+0.05*sin(aa)), 0.0 ).x * smoothstep(0.0,0.3,dot(ep,ep));\n                      \n    float r = 0.02*sin( 24.0*atan(ep.x,ep.y))*clamp(-w.y*1000.0,0.0,1.0);\n    r += 0.01*sin(15.0*w.z);\n    \/\/ section        \n    float d4 = length(w.zy-vec2( 0.5,-0.2+0.03)) - 0.8 + r;    \n    float d5 = length(w.zy-vec2(-0.1, 0.6+0.03)) - 1.5 + r;    \n    float d6 = length(w.zy-vec2( 1.8, 0.1+0.03)) - 1.6 + r;    \n    d4 = smax( d4, d5, 0.1 );\n    d4 = smax( d4, d6, 0.1 );\n\n    float wi = 0.02 + 0.1*pow(clamp(1.0-0.7*w.z+0.3*w.y,0.0,1.0),2.0);\n    w.x += 0.05*cos(6.0*w.y);\n    \n    \/\/ cut it!\n    d4 = smax( d4, -w.x, 0.03 ); \n    d4 = smax( d4, w.x-wi, 0.03 ); \n    \n\tmatInfo.y = clamp(length(ep),0.0,1.0) * (1.0-smoothstep( -0.1, 0.05, d4 ));\n    \n    d = smin( d, d4, 0.3*max(qh.y,0.0) ); \/\/ trick -> positional smooth\n    \n    \/\/ conection hear\/head\n    vec2 s1 = sdBezier( vec3(-0.15,0.3,0.0), vec3(0.1,0.6,0.2), vec3(0.35,0.6,0.5), qh, kk );\n    float d3 = s1.x - 0.08*(1.0-0.95*s1.y*s1.y);\n    d = smin( d, d3, 0.05 );\n    \n#endif\n\n    d -= 0.002*textureLod( iChannel1, 0.5*p.yz, 0.0 ).x;\n    d -= 0.002*textureLod( iChannel1, 0.5*p.yx, 0.0 ).x;\n    d += 0.003;\n    d -= 0.005*textureLod( iChannel0, 0.5*p.yx, 0.0 ).x*(0.2 + 0.8*smoothstep( 0.8, 1.3, length(p-vec3(-0.5,0.0,0.0)) ));\n\n    \n    vec2 res = vec2(d,0.0);\n\t\/\/=====================\n    \/\/ teeth\n    vec2 b = sdBezier( vec3(-0.5,-0.4,0.28), vec3(-0.5,-0.7,0.32), vec3(-1.0,-0.8,0.45), qh, kk );\n    float tr = 0.10 - 0.08*b.y;\n    d2 = b.x - tr;\n    if( d2<res.x ) \n    {\n        res = vec2( d2, 1.0 );\n        matInfo.x = b.y;\n    }\n\t\/\/------------------\n    \/\/eyeball\n    mat3 rot = mat3(0.8,-0.6,0.0,\n                    0.6, 0.8,0.0,\n                    0.0, 0.0,1.0 );\n    d4 = sdEllipsoid( rot*(qh-vec3(-0.31,-0.02,0.33)), vec3(0.0), vec3(0.1,0.08,0.07)*0.7 );\n    if( d4<res.x ) res = vec2( d4, 2.0 );\n\n    return res;\n}\n\nfloat sleg( in vec3 p, in vec3 pa, in vec3 pb, in vec3 pc, float m, float h, float sc )\n{\n    float l = sign(pa.z);\n    \n    vec2 b = sdSegment( p, pa, pb );\n\n    float tr = 0.35 - 0.15*smoothstep(0.0,1.0,b.y);\n    float d3 = b.x - tr*sc;\n\n    b = sdSegment( p, pb, pc );\n    tr = 0.18;\/\/ - 0.015*smoothstep(0.0,1.0,b.y);\n    d3 = smin( d3, b.x - tr*sc, 0.1 );\n\n    \/\/ paw        \n    vec3 ww = normalize( mix( normalize(pc-pb), vec3(0.0,1.0,0.0), h) );\n    mat3 pr = base( ww );\n    vec3 fc = pr*((p-pc))-vec3(0.02,0.0,0.0)*(-1.0+2.0*h);\n    float d4 = sdEllipsoid( fc, vec3(0.0), vec3(0.2,0.15,0.2) );\n\n    d3 = smin( d3, d4, 0.1 );\n\n    \/\/ nails\n    float d6 = sdEllipsoid( fc, vec3(0.14,-0.04,0.0)*(-1.0+2.0*h), vec3(0.1,0.16,0.1));\n    d6 = min( d6, sdEllipsoid( vec3(fc.xy,abs(fc.z)), vec3(0.13*(-1.0+2.0*h),0.04,0.13), vec3(0.09,0.14,0.1)) );\n    d3 = smin( d3, d6, 0.001 );\n\treturn d3;\n\n\treturn d3;\n}\n\nvec2 mapSmallElephant( vec3 p, out vec3 matInfo )\n{\n    matInfo = vec3(0.0);\n    vec3 oop = p;\n    const float sca = 2.0;\n    p.xz = mat2(0.8,0.6,-0.6,0.8)*p.xz;\n    p *= sca;\n    \n    p -= vec3(-1.1,2.4,-2.0);\n        \n    vec3 ph = p;\n    ph.yz = mat2(0.95,0.31225,-0.31225,0.95)*ph.yz;\n        \n    \/\/ head\n    float d1 = sdEllipsoid( ph, vec3(0.0,0.0,0.0), vec3(0.45,0.55,0.38) );\n\n    \/\/ nose\n    vec2 kk;\n    \n    vec2 b1 = sdBezier( vec3(-0.15,-0.05,0.0), vec3(-0.7,-0.2,-0.1), vec3(-0.7,-0.5,0.1), ph, kk );    \n    float tr1 = 0.30 - 0.17*smoothstep(0.0,1.0,b1.y);\n    vec2 b2 = sdBezier( vec3(-0.7,-0.5,0.1), vec3(-0.7,-0.8,0.3), vec3(-0.4,-0.8,0.8), ph, kk );\n    \n    float tr2 = 0.30 - 0.17 - 0.05*smoothstep(0.0,1.0,b2.y);\n    float bd1 = b1.x-tr1;\n    float bd2 = b2.x-tr2;\n    float nl = b1.y*0.5;\n    float bd = bd1;\n    if( bd2<bd1 )\n    {\n        nl = 0.5 + 0.5*b2.y;\n        bd = bd2;\n    }\n    \n    matInfo.x = clamp(nl * (1.0-smoothstep(0.0,0.2,bd)),0.0,1.0);\n            \n    float d2 = bd;\n    float xx = nl*120.0;\n    float ff = sin(xx + sin(xx + sin(xx + sin(xx))));\n    d2 += 0.005*ff*(1.0-nl)*(1.0-nl)*smoothstep(0.0,0.1,nl);\n\n    float d = smin(d1,d2,0.2);\n\n    vec3 qh = vec3( ph.xy, abs(ph.z) );\n\n    \/\/ eyes\n    {\n    vec2 s1 = sdSegment( qh, vec3(-0.2,0.2,0.11), vec3(-0.3,-0.0,0.23) );\n    float d3 = s1.x - 0.19*(1.0 - 0.3*smoothstep(0.0,1.0,s1.y));\n    d = smin( d, d3, 0.03 );\n    mat3 rot = mat3(0.8,-0.6,0.0,\n                    0.6, 0.8,0.0,\n                    0.0, 0.0,1.0 );\n    float d4 = sdEllipsoid( rot*(qh-vec3(-0.31,-0.02,0.34)), vec3(0.0), vec3(0.1,0.08,0.07)*0.7 );\n\td = smax(d, -d4, 0.04 );\n    }\n\n\n    vec3 q = vec3( p.xy, abs(p.z) );\n\n    \/\/ body\n    {\n    float co = cos(0.4);\n    float si = sin(0.4);\n    vec3 w = p;\n    w.xy = mat2(co,si,-si,co)*w.xy;\n        \n    float d4 = sdEllipsoid( w, vec3(0.6,0.3,0.0), vec3(0.6,0.6,0.6) );\n\td = smin(d, d4, 0.1 );\n\n    d4 = sdEllipsoid( w, vec3(1.8,0.3,0.0), vec3(1.2,0.9,0.7) );\n\td = smin(d, d4, 0.2 );\n    }\n\n    \/\/ back-left leg\n    {\n    float d3 = sleg( q, vec3(2.6,-0.6,0.3), vec3(2.65,-1.4,0.3), vec3(2.6,-2.0,0.25), 1.0, 0.0, 0.75 );\n    d = smin(d,d3,0.1);\n    }\n    \n\t\/\/ tail\n    #if 0\n    {\n    vec2 b = sdBezier( vec3(2.6,0.,0.0), vec3(3.4,-0.6,0.0), vec3(3.1,-1.6,0.0), p, kk );\n    float tr = 0.10 - 0.07*b.y;\n    float d2 = b.x - tr;\n    d = smin( d, d2, 0.05 );\n    }\n    #endif\n    \n    \/\/ front-left leg\n    {\n    float d3 = sleg( p, vec3(0.8,-0.4,0.2), vec3(0.6,-1.4,0.2), vec3(0.7,-1.9,0.2), 1.0, 0.0, 0.75 );\n    d = smin(d,d3,0.15);\n    d3 = sleg( p, vec3(0.8,-0.4,-0.2), vec3(0.3,-1.4,-0.2), vec3(0.2,-1.9,-0.2), 1.0, 0.0, 0.75 );\n    d = smin(d,d3,0.15);\n    }\n            \n#if 1\n    \/\/ ear\n    float co = cos(0.5);\n    float si = sin(0.5);\n    vec3 w = qh;\n    w.xz = mat2(co,si,-si,co)*w.xz;\n    \n    vec2 ep = w.zy - vec2(0.5,0.4);\n    float aa = atan(ep.x,ep.y);\n    float al = length(ep);\n    w.x += 0.003*sin( 24.0*aa)*smoothstep(0.0,0.5,dot(ep,ep));\n    w.x += 0.02*textureLod( iChannel1, vec2(al*0.02,0.15*aa\/3.1416), 0.0 ).x * smoothstep(0.0,0.3,dot(ep,ep));\n                      \n    float r = 0.02*sin( 24.0*atan(ep.x,ep.y))*clamp(-w.y*1000.0,0.0,1.0);\n    r += 0.01*sin(15.0*w.z);\n    \/\/ section        \n    float d4 = length(w.zy-vec2( 0.5,-0.2+0.03)) - 0.8 + r;    \n    float d5 = length(w.zy-vec2(-0.1, 0.6+0.03)) - 1.5 + r;    \n    float d6 = length(w.zy-vec2( 1.8, 0.1+0.03)) - 1.6 + r;    \n    d4 = smax( d4, d5, 0.1 );\n    d4 = smax( d4, d6, 0.1 );\n\n    float wi = 0.02 + 0.1*pow(clamp(1.0-0.7*w.z+0.3*w.y,0.0,1.0),2.0);\n    w.x += 0.05*cos(6.0*w.y);\n    \n    \/\/ cut it!\n    d4 = smax( d4, -w.x, 0.03 ); \n    d4 = smax( d4, w.x-wi, 0.03 ); \n    \n\tmatInfo.y = clamp(length(ep),0.0,1.0) * (1.0-smoothstep( -0.1, 0.05, d4 ));\n    \n    d = smin( d, d4, 0.3*max(qh.y+0.2,0.0) ); \/\/ trick -> positional smooth\n    \n    \/\/ conection hear\/head\n    vec2 s1 = sdBezier( vec3(-0.15,0.3,0.0), vec3(0.1,0.6,0.2), vec3(0.35,0.6,0.5), qh, kk );\n    float d3 = s1.x - 0.08*(1.0-0.95*s1.y*s1.y);\n    d = smin( d, d3, 0.05 );\n    \n#endif\n    \n    d -= 0.008*textureLod( iChannel1, 0.25*p.yz, 0.0 ).x;\n    d -= 0.008*textureLod( iChannel1, 0.25*p.yx, 0.0 ).x;\n    d += 0.010;\n    d -= 0.012*textureLod( iChannel0, 0.25*p.yx, 0.0 ).x*(0.3 + 0.7*smoothstep( 0.5, 1.0, length(p-vec3(-0.5,0.0,0.0)) ));\n    \n    vec2 res = vec2(d,0.0);\n\t\/\/=====================\n    \/\/eyeball\n    mat3 rot = mat3(0.8,-0.6,0.0,\n                    0.6, 0.8,0.0,\n                    0.0, 0.0,1.0 );\n    d4 = sdEllipsoid( rot*(qh-vec3(-0.31,-0.02,0.33)), vec3(0.0), vec3(0.1,0.08,0.07)*0.7 );\n    \n    if( d4<res.x ) res = vec2( d4, 2.0 );\n\n    res.x \/= sca;\n        \n    return res;\n}\n\nvec2 map( vec3 p, out vec3 matInfo )\n{\n    vec2 res = vec2(p.y+2.2-1.0);\n    \n    \/\/ bounding volume for big elephant\n    \/\/float b2 = length(p-vec3(0.5,1.7,0.0))-2.1;\n\t\/\/if( b2<res.x )    \n    {\n        res = mapElephant( p, matInfo );\n    }\n    \n    \/\/ bounding volume for small elephant\n    float bb = length(p-vec3(-0.4,0.5,-0.8))-1.3;\n    if( bb<res.x )\n    {\n        vec3 mi2;\n        vec2 tmp = mapSmallElephant( p, mi2 );\n        if( tmp.x<res.x ) { res=tmp; matInfo=mi2; }\n    }\n    \n    return res;\n}\n\nvec2 mapWithTerrain( vec3 p, out vec3 matInfo )\n{\n    vec2 res = map(p,matInfo);\n        \n    \/\/--------------------\n    \/\/ terrain\n    float h = 2.1+0.1;\n    float d2 = p.y + h;\n    if( d2<res.x ) res = vec2( d2, 3.0 );\n    \n    return res;\n}\n\n\/\/ http:\/\/iquilezles.org\/www\/articles\/normalsSDF\/normalsSDF.htm\nvec3 calcNormal( in vec3 pos, in float eps )\n{\n    vec3 kk;\n#if 0    \n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*map( pos + e.xyy, kk ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, kk ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, kk ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, kk ).x );\n#else\n    \/\/ inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+e*eps,kk).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nvec3 forwardSF( float i, float n) \n{\n    const float PI  = 3.141592653589793238;\n    const float PHI = 1.618033988749894848;\n    float phi = 2.0*PI*fract(i\/PHI);\n    float zi = 1.0 - (2.0*i+1.0)\/n;\n    float sinTheta = sqrt( 1.0 - zi*zi);\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\n}\n\nfloat calcSoftShadow( in vec3 ro, in vec3 rd, float k )\n{\n    vec3 kk;\n    float res = 1.0;\n    float t = 0.01;\n    for( int i=0; i<32; i++ )\n    {\n        float h = map(ro + rd*t, kk ).x;\n        res = min( res, smoothstep(0.0,1.0,k*h\/t) );\n        t += clamp( h, 0.05, 0.5 );\n\t\tif( res<0.01 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    vec3 kk;\n\tfloat ao = 0.0;\n    for( int i=ZERO; i<32; i++ )\n    {\n        vec3 ap = forwardSF( float(i), 32.0 );\n        ap *= sign( dot(ap,nor) );\n        float h = hash1(float(i));\n\t\tap *= h*0.3;\n        ao += clamp( mapWithTerrain( pos + nor*0.01 + ap, kk ).x*1.0\/h, 0.0, 1.0 );\n    }\n\tao \/= 32.0;\n\t\n    return clamp( ao*4.0*(1.0+0.25*nor.y), 0.0, 1.0 );\n}\n\nvec3 sunDir = normalize( vec3(0.15,0.7,0.65) );\n\nfloat dapples( in vec3 ro, in vec3 rd )\n{\n    float sha = eliSoftShadow( ro, rd, vec3(0.0,4.0,4.0), vec3(3.0,1.0,3.0), 70.0 );\n    \n    vec3 uu = normalize( cross( rd, vec3(0.0,0.0,1.0) ) );\n    vec3 vv = normalize( cross( uu, rd ) );\n\n    vec3 ce = vec3(0.0,4.0,5.0);\n    float t = -dot(ro-ce,rd);\n    vec3 po = ro + t*rd;\n    vec2 uv = vec2( dot(uu,po-ce), dot(vv,po-ce) );\n    \n    float dap = 1.0-smoothstep( 0.1, 0.5, texture(iChannel2,0.25+0.4*uv,-100.0).x );\n    return 1.0 - 0.9*(1.0-sha)*(1.0-dap);\n}\n\nvoid calcDpDxy( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy, in float t, in vec3 nor, out vec3 dpdx, out vec3 dpdy )\n{\n    dpdx = t*(rdx*dot(rd,nor)\/dot(rdx,nor) - rd);\n    dpdy = t*(rdy*dot(rd,nor)\/dot(rdy,nor) - rd);\n}\n\nvec3 shade( in vec3 ro, in vec3 rd, in float t, in float m, in vec3 matInfo, in vec3 rdx, in vec3 rdy )\n{\n    float eps = 0.001;\n    \n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormal( pos, eps*t );\n    vec3 dposdx, dposdy;\n    calcDpDxy( ro, rd, rdx, rdy, t, nor, dposdx, dposdy );\n\n    float kk;\n\n    vec3 mateD = vec3(0.2,0.16,0.11);\n    vec3 mateS = vec3(0.2,0.12,0.07);\n    vec3 mateK = vec3(0.0,1.0,0.0); \/\/ amount, power, metalic\n    float focc = 1.0;\n        \n    if( m<0.5 ) \/\/ body\n    {\n        mateD = vec3(0.27,0.26,0.25)*0.4;\n        mateS = vec3(0.27,0.26,0.25)*0.4;\n        mateK = vec3(0.12,20.0,0.0);\n        \n        float te = texcube( iChannel1, 0.25*pos, nor, 4.0, 0.25*dposdx, 0.25*dposdy ).x;\n        mateD *= 0.2+0.6*te;\n        mateK *= te;\n        \n        mateD *= 1.1 - 0.4*smoothstep( 0.3, 0.7, matInfo.x );\n        mateD = mix( mateD, mateD*vec3(1.1,0.8,0.7), smoothstep( 0.0, 0.15, matInfo.y ) );\n\n        focc *= 0.5 + 0.5*smoothstep(0.0,3.0,pos.y);\n                   \n        vec3 q = pos - vec3(-0.5,2.4,0.0);\n\n        \/\/---\n        vec2 est = q.xy-vec2(-0.31,-0.02);\n        mateD *= mix( vec3(1.0), vec3(0.2,0.15,0.1), exp(-20.0*dot(est,est)) );\n\n        mateD *= 1.2;\n        mateS *= 1.2;\n        mateK.x *= 1.2;\n        \n        mateK.xy *= vec2(3.0,2.0);\n    }\n    else if( m<1.5 ) \/\/ teeh\n    {\n        mateD = vec3(0.3,0.28,0.25)*0.9;\n        mateS = vec3(0.3,0.28,0.25)*0.9;\n        mateK = vec3(0.2,32.0,0.0);\n        mateD *= mix( vec3(0.45,0.4,0.35), vec3(1.0), sqrt(matInfo.x) );\n        focc = smoothstep(0.1,0.3,matInfo.x);\n        float te = texcube( iChannel1, 0.5*pos, nor, 4.0, 0.5*dposdx, 0.5*dposdy ).x;\n        mateD *= te;\n        mateK.x *= te;\n    }\n    else \/\/if( m<2.5 ) \/\/eyeball\n    {\n        mateD = vec3(0.0);\n        mateS = vec3(0.0);\n        mateK = vec3(0.4,32.0,0.0);\n    }\n    \n    vec3 hal = normalize( sunDir-rd );\n    float fre = clamp(1.0+dot(nor,rd), 0.0, 1.0 );\n    float occ = calcAO( pos, nor )*focc;\n        \n    float dif1 = clamp( dot(nor,sunDir), 0.0, 1.0 );\n    float bak = clamp( dot(nor,normalize(vec3(-sunDir.x,0.0,-sunDir.z))), 0.0, 1.0 );\n    float sha = calcSoftShadow( pos, sunDir, 16.0 );\n    sha = min( sha, dapples(pos,sunDir) );\n    dif1 *= sha;\n    float spe1 = clamp( dot(nor,hal), 0.0, 1.0 );\n    float bou = clamp( 0.3-0.7*nor.y, 0.0, 1.0 );\n    \n    float rod1 = 1.0 - (1.0-smoothstep( 0.15,0.2, length(pos.yz-vec2(1.8,0.3))))*(1.0-smoothstep(0.0,0.1,abs(pos.x+0.2)));\n\n    \n    \/\/ sun\n    vec3 col = 8.5*vec3(2.0,1.2,0.65)*dif1;\n    \/\/ sky\n    col += 4.5*vec3(0.35,0.7,1.0)*occ*clamp(0.2+0.8*nor.y,0.0,1.0);\n    \/\/ ground\n    col += 4.0*vec3(0.4,0.25,0.12)*bou*occ;\n    \/\/ back\n    col += 3.5*vec3(0.2,0.2,0.15)*bak*occ*rod1;\n    \/\/ sss\n    col += 25.0*fre*fre*(0.2+0.8*dif1*occ)*mateS*rod1;\n\n    \/\/ sun\n    vec3 hdir = normalize(sunDir - rd);\n    float costd = clamp( dot(sunDir, hdir), 0.0, 1.0 );\n    float spp = pow( spe1, mateK.y )*dif1*mateK.x * (0.04 + 0.96*pow(1. - costd,5.0));\n\n    \/\/ sky spec\n    float sksp = occ*occ*smoothstep(-0.2,0.2,reflect(rd,nor).y)*(0.5+0.5*nor.y)*mateK.x * (0.04 + 0.96*pow(fre,5.0));\n\n    col += mateK.z*15.0*5.0*spp; \n\n    col *= mateD;\n\n    col += (1.0-mateK.z)*75.0*spp; \n    col += (1.0-mateK.z)* 3.0*sksp*vec3(0.35,0.7,1.0); \n\n    return col;        \n}\n\nvec2 intersect( in vec3 ro, in vec3 rd, in float tmax, out vec3 matInfo )\n{\n    vec2 res = vec2(-1.0);\n\n    float maxdist = min(tmax,10.0);\n    float t = 4.0;\n\n    for( int i=0; i<128; i++ )\n    {\n        vec3 p = ro + t*rd;\n        vec2 h = map( p, matInfo );\n        res = vec2(t,h.y);\n        if( h.x<(0.0001*t) || t>maxdist ) break;\n        t += h.x;\/\/*0.75;\n    }\n\n    if( t>maxdist )\n    {\n        res = vec2(-1.0);\n    }\n\n    return res;\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec3 col, in float tmax, in vec3 rdx, in vec3 rdy )\n{\n    vec3 matInfo;\n    vec2 tm = intersect( ro, rd, tmax, matInfo );\n    if( tm.y>-0.5  )\n    {\n        col = shade( ro, rd, tm.x, tm.y, matInfo, rdx, rdy );\n        float fa = 1.0-exp(-0.0001*(tm.x*tm.x+tm.x));\n        col = mix( col, vec3(0.4,0.5,0.65), fa );\n    }\n\treturn col;    \n}\n\nmat3 setCamera( in vec3 ro, in vec3 rt, in float cr )\n{\n\tvec3 cw = normalize(rt-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    \/\/if( iFrame>1 ) discard;\n    \n    vec2 q = fragCoord\/iResolution.xy;\n    vec2 p = (-iResolution.xy+2.0*fragCoord)\/iResolution.y;\n\n    \/\/ camera\n    float an = 0.0 - 1.25- 1.0*iMouse.x\/iResolution.x;\n    vec3 ro = vec3(5.7*sin(an),1.6,5.7*cos(an));\n    vec3 ta = vec3(0.0,1.6,0.0);\n\n    \/\/ ray\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    vec3 rd = normalize( ca * vec3(p,-3.5) );\n\n    \/\/ ray differentials\n    vec2 px = (-iResolution.xy+2.0*(fragCoord+vec2(1.0,0.0)))\/iResolution.y;\n    vec2 py = (-iResolution.xy+2.0*(fragCoord+vec2(0.0,1.0)))\/iResolution.y;\n    vec3 rdx = normalize( ca * vec3(px,-3.5) );\n    vec3 rdy = normalize( ca * vec3(py,-3.5) );\n    \n    vec4 data = texture( iChannel3, q );\n    vec3 col = data.xyz;\n    float t = data.w;\n\n    \/\/ render\n    col = render( ro, rd, col, t, rdx, rdy);\n\n    float sun = clamp( 0.5 + 0.5*dot(rd,sunDir), 0.0, 1.0 );\n    col += 1.5*vec3(1.0,0.8,0.6)*pow(sun,16.0);\n\n    \/\/col = pow( col, vec3(0.4545) );\n    col = sqrt(col);\n\n    \/\/--------\n    \n    col.x += 0.010;\n    \n    col *= 0.3 + 0.7*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.1);\n    fragColor = vec4( col, 1.0 );\n}\n",
            "name": "Image",
            "description": "",
            "type": "image"
        },
        {
            "inputs": [
                {
                    "id": "XsX3Rn",
                    "filepath": "\/media\/a\/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg",
                    "previewfilepath": "\/media\/ap\/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg",
                    "type": "texture",
                    "channel": 2,
                    "sampler": {
                        "filter": "mipmap",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "4df3Rr",
                    "filepath": "\/media\/a\/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg",
                    "previewfilepath": "\/media\/ap\/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg",
                    "type": "texture",
                    "channel": 1,
                    "sampler": {
                        "filter": "mipmap",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "4sf3Rr",
                    "filepath": "\/media\/a\/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png",
                    "previewfilepath": "\/media\/ap\/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png",
                    "type": "texture",
                    "channel": 3,
                    "sampler": {
                        "filter": "mipmap",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dXGR8",
                    "channel": 0
                }
            ],
            "code": "\/\/ Created by inigo quilez - iq\/2016\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\nfloat hash1( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nvec3 hash3( float n )\n{\n    return fract(sin(n+vec3(0.0,13.1,31.3))*158.5453123);\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)\/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)\/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\nfloat eliSoftShadow( in vec3 ro, in vec3 rd, in vec3 sphcen, in vec3 sphrad, in float k )\n{\n    vec3 oc = ro - sphcen;\n    \n    vec3 ocn = oc \/ sphrad;\n    vec3 rdn = rd \/ sphrad;\n    \n    float a = dot( rdn, rdn );\n\tfloat b = dot( ocn, rdn );\n\tfloat c = dot( ocn, ocn );\n\tfloat h = b*b - a*(c-1.0);\n\n    float t = (-b - sqrt( max(h,0.0) ))\/a;\n\n    return (h>0.0) ? step(t,0.0) : smoothstep(0.0, 1.0, -k*h\/max(t,0.0) );\n}\n\nvec2 sdSegment( in vec3 p, vec3 a, vec3 b )\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ), h );\n}\n\nfloat sdSphere( in vec3 p, in vec3 c, in float r )\n{\n    return length(p-c) - r;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 c, in vec3 r )\n{\n    return (length( (p-c)\/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nmat3 base( in vec3 ww )\n{\n    vec3  vv  = vec3(0.0,0.0,1.0);\n    vec3  uu  = normalize( cross( vv, ww ) );\n    return mat3(uu.x,ww.x,vv.x,\n                uu.y,ww.y,vv.y,\n                uu.z,ww.z,vv.z);\n}\n\n#define ZERO (min(iFrame,0))\n\n\/\/---------------------------------------------------------------------------\n\nfloat leg( in vec3 p, in vec3 pa, in vec3 pb, in vec3 pc, float m, float h, float sc )\n{\n    float l = sign(pa.z);\n    \n    vec2 b = sdSegment( p, pa, pb );\n\n    float tr = 0.35 - 0.16*smoothstep(0.0,1.0,b.y);\n    float d3 = b.x - tr*sc;\n\n    b = sdSegment( p, pb, pc );\n    tr = 0.18;\n    d3 = smin( d3, b.x - tr*sc, 0.1 );\n\n    vec3 ww = normalize( mix( normalize(pc-pb), vec3(0.0,1.0,0.0), h) );\n    mat3 pr = base( ww );\n    vec3 fc = pr*((p-pc))-vec3(0.02,0.0,0.0)*(-1.0+2.0*h);\n    float d4 = sdEllipsoid( fc, vec3(0.0), vec3(0.2,0.15,0.2) );\n\n    d3 = smin( d3, d4, 0.1 );\n\n\treturn d3;\n}\n\nfloat mapElephantSimple( vec3 p )\n{\n    p.x -= -0.5;\n\tp.y -= 2.4;\n    \n    \/\/ head\n    float d = sdEllipsoid( p, vec3(0.0,0.0,0.0), vec3(0.55,0.55,0.35) );\n\n\n    \/\/ body\n    {\n    float co = cos(0.4);\n    float si = sin(0.4);\n    vec3 w = p;\n    w.xy = mat2(co,si,-si,co)*w.xy;\n\n    float d4 = sdEllipsoid( w, vec3(0.6,0.3,0.0), vec3(0.6,0.6,0.6) );\n\td = smin(d, d4, 0.1 );\n\n    d4 = sdEllipsoid( w, vec3(1.8,0.3,0.0), vec3(1.2,0.9,0.7) );\n\td = smin(d, d4, 0.2 );\n\n    d4 = sdEllipsoid( w, vec3(2.1,0.55,0.0), vec3(1.0,0.9,0.6) );\n\td = smin(d, d4, 0.1 );\n\n    d4 = sdEllipsoid( w, vec3(2.0,0.8,0.0), vec3(0.7,0.6,0.8) );\n\td = smin(d, d4, 0.1 );\n\n    }\n    vec3 q = vec3( p.xy, abs(p.z) );\n\n    \/\/ back-left leg\n    {\n    float d3 = leg( q, vec3(2.6,-0.6,0.3), vec3(2.65,-1.45,0.3), vec3(2.6,-2.1,0.25), 1.0, 0.0, 1.0 );\n    d = smin(d,d3,0.1);\n    }\n\n    \n    \/\/ front-left leg\n    float d3 = leg( p, vec3(0.8,-0.4,0.3), vec3(0.7,-1.55,0.3), vec3(0.8,-2.1,0.3), 1.0, 0.0, 1.0 );\n    d = smin(d,d3,0.15);\n    d3 = leg( p, vec3(0.8,-0.4,-0.3), vec3(0.4,-1.55,-0.3), vec3(0.4,-2.1,-0.3), 1.0, 0.0, 1.0 );\n    d = smin(d,d3,0.15);\n    \n    return d;\n}\n\nfloat mapTree( vec3 p )\n{\n    float f = length(p);\n    if( f>8.0 )\n        return f - 8.0 + 0.1;\n\n    vec3 q = p;   \n    \n    p.xz += 0.1*sin(4.0*p.y+vec2(0.0,1.0));\n    vec2 s1 = sdSegment( p, vec3(0.0,-2.0,0.0), vec3(-2.0,3.3,4.0) );\n    float d2 = s1.x - (0.25 - 0.12*s1.y);\n    s1 = sdSegment( p, vec3(0.0,-2.0,0.0), vec3(-3.0,3.3,0.0) );\n    float d4 = s1.x - (0.25 - 0.12*s1.y);\n    d2 = min( d2, d4 );\n    s1 = sdSegment( p, mix( vec3(0.0,-2.0,0.0), vec3(-3.0,3.3,-1.0), 0.35 ), vec3(-2.0,3.3,-4.0) );\n    d4 = s1.x - (0.25 - 0.12*s1.y);\n    d2 = min( d2, d4 );\n    \n    p.y += length(p.xz)*0.1;\n    p.y += 0.5*sin(p.x);\n    \n    float nn = textureLod(iChannel2,0.1*q.zy, 0.0).x;\n    d4 = sdEllipsoid( p, vec3( 0.0,3.3,0.0), vec3(4.5,0.9,4.5)*(1.0+nn) );\n    \n    d4 += max(0.0,3.0*sin(1.5*q.x)*sin(1.5*q.y)*sin(1.5*q.z)*clamp( 1.0 - d4\/3.0, 0.0, 1.0 ));\n\n    return min( d2, d4 );\n}\n\nmat3 rotationMat( in vec3 xyz )\n{\n    vec3 si = sin(xyz);\n    vec3 co = cos(xyz);\n\n\treturn mat3( co.y*co.z,                co.y*si.z,               -si.y,    \n                 si.x*si.y*co.z-co.x*si.z, si.x*si.y*si.z+co.x*co.z, si.x*co.y,\n                 co.x*si.y*co.z+si.x*si.z, co.x*si.y*si.z-si.x*co.z, co.x*co.y );\n}\n\n\nvec2 map( vec3 p, out vec3 matInfo )\n{\n    matInfo = vec3(0.0);\n    \n    p.x -= -0.5;\n\tp.y -= 2.4;\n    \n    \/\/--------------------\n\n    float h = 2.1 + 0.1*textureLod( iChannel2, 0.07*p.xz, 0.0 ).x;\n    \n    float d2 = p.y + h;\n    vec2 res = vec2( d2, 3.0 );\n\n    \n    \/\/--------------------\n#if 1\n    for( int j=ZERO; j<2; j++ )\n    {\n        float dleaves = 1000.0;\n\n        vec3         pl = p - vec3(-0.85,0.30,2.1);\n        vec3         pd = vec3(-0.2,-0.5,-0.3);\n        if( j==1 ) { pl = p - vec3(-0.00,0.45,2.2);\n                     pd = vec3( 0.2,-0.6, 0.1); };\n        \n        float pr = dot(pl,pl);\n        if( pr<1.5 )\n        {\n            float sim = 1.0;\n            vec2 uv = vec2(0.0);\n            for( int i=ZERO; i<9; i++ )\n            {\n                float h = float(i);\n                float hh = float(i+10*j);\n                vec3 sc = hash3(hh*13.92);\n                vec3 di = sin(vec3(0.0,1.0,2.0)+hh*vec3(10.0,15.0,20.0));\n                vec3 of = pd*h\/8.0;\n\n                vec3 q = pl - of;\n                q = rotationMat( 6.2831*di*vec3(0.1,-0.1,0.9) + 0.04*sin(20.0*hh + 0.7*iTime) ) * q;\n\n                q.z = q.z*sim - 0.22;\n\n                q.xz += q.y*q.y*2.0;\n\n                q *= 0.75 + 0.4*sc.x;\n\n                d2 =          sdSphere( q, vec3(0.0,-0.1,0.0), 0.25 );\n                d2 = max( d2, sdSphere( q, vec3(0.0, 0.1,0.0), 0.25 ) );\n                d2 = smax( d2, abs(q.x)-0.003, 0.01 );\n\n                d2 \/= 0.75 + 0.4*sc.x;\n\n                if( d2<dleaves )\n                {\n                    dleaves = d2;\n                    uv = q.yz;\n                }\n                sim *= -1.0;\n            }\n            vec2 s2 = sdSegment( pl, vec3(0.0), pd );\n            d2 = s2.x - 0.01;\n            dleaves = min(dleaves,d2); \n            if( dleaves<res.x ) \n            {\n                res = vec2( dleaves, 6.0 );\n                matInfo.x = 0.0;\n                matInfo.yz = uv;\n            }\n        }\n    }\n#endif\n\n    \/\/--------------------\n    \n#if 1\n    {\n    vec2 idb = floor(p.xz\/4.0);        \n    for( int j=ZERO; j<2; j++ )    \n    for( int i=ZERO; i<2; i++ )    \n    {\n        vec2 id = idb + vec2(float(i),float(j));\n        if( id.x>4.0 )\n        {\n            float h = id.x*7.7 + id.y*13.1;\n            float si = hash1(h*31.7);\n            float al = hash1(h*41.9);\n\n            if( si>0.5 )\n            {\n                vec3 bc = vec3(id.x*4.0+2.0,-2.0,id.y*4.0+2.0);\n                bc.xz -= 1.0*hash3( h*7.7 ).xy;\n                vec3 eli = vec3(1.6*(0.3 + 0.7*si),1.5*(0.5 + 0.5*al),1.6*(0.3 + 0.7*si));\n\n                #if 0\n                d2 = sdEllipsoid( p, bc, eli );\n                if( d2<res.x ) \n                {\n                    res = vec2( d2, 4.0 );\n                    matInfo.x = hash1(h*77.7);\n                }\n\n                #else\n                float d4 = 1000.0;\n                float d3 = 0.0;\n                for( int j=0; j<12; j++ )\n                {\n                    float h2 = float(j);\n                    vec3 of = normalize((-1.0+2.0*hash3(h*11.11+h2*9.13)));\n\n                    of.y = of.y*of.y - 0.1;\n                    of *= eli;\n\n                    vec3 bb = bc + of;\n                    d2 = sdEllipsoid( p, bb, 0.5*vec3(1.0,0.85,1.0));\n\n                    if( d2<d4)\n                    {\n                        d4 = d2;\n                        d3 = hash1(h*77.7);\n                    }\n                }\n\n                float di = textureLod(iChannel2,0.12*p.xz,0.0).x + \n                           textureLod(iChannel2,0.12*p.yz,0.0).x +\n                           textureLod(iChannel2,0.12*p.xy,0.0).x;\n                di \/= 3.0;\n                d4 -= 0.4*di*di;\n\n                if( d4<res.x ) \n                {\n                    res = vec2( d4, 4.0 );\n                    matInfo.x = d3;\n                    matInfo.y = di;\n                }\n                #endif\n            }\n        }\n    }\n    }\n#endif    \n     \n#if 1\n    {\n    vec3 tc1 = vec3(50.0,0.0,-40.0);\n    vec3 tc2 = vec3(85.0,0.0,5.0);\n    float td1 = dot(p.xz-tc1.xz,p.xz-tc1.xz);\n    float td2 = dot(p.xz-tc2.xz,p.xz-tc2.xz);\n    vec3 tc = (td1<td2) ? tc1 : tc2;\n    float d2 = mapTree( p - tc );\n    if( d2<res.x ) \n    {\n        res = vec2( d2, 5.0 );\n        matInfo.x = 0.0;\n    }\n    }\n#endif\n    \n    return res;\n}\n\nfloat  mapSmallElephantSimple( vec3 p )\n{\n    \n    const float sca = 2.0;\n    p.xz = mat2(0.8,0.6,-0.6,0.8)*p.xz;\n    p *= sca;\n    \n    p -= vec3(-1.1,2.4,-2.0);\n    \n    vec3 ph = p;\n    ph.yz = mat2(0.95,0.31225,-0.31225,0.95)*ph.yz;\n        \n    \/\/ head\n    float d = sdEllipsoid( ph, vec3(0.0,0.0,0.0), vec3(0.45,0.55,0.35) );\n\n    vec3 qh = vec3( ph.xy, abs(ph.z) );\n\n    vec3 q = vec3( p.xy, abs(p.z) );\n\n    \/\/ body\n    {\n    float co = cos(0.4);\n    float si = sin(0.4);\n    vec3 w = p;\n    w.xy = mat2(co,si,-si,co)*w.xy;\n        \n    float d4 = sdEllipsoid( w, vec3(1.8,0.3,0.0), vec3(1.2,0.9,0.7) );\n\td = smin(d, d4, 0.2 );\n\n    }\n\n    \/\/ back-left leg\n    {\n    float d3 = leg( q, vec3(2.6,-0.6,0.3), vec3(2.65,-1.4,0.3), vec3(2.6,-2.0,0.25), 1.0, 0.0, 0.75  );\n    d = smin(d,d3,0.1);\n    }\n    \n    \n    \/\/ front-left leg\n    {\n    float d3 = leg( p, vec3(0.8,-0.4,0.2), vec3(0.6,-1.4,0.2), vec3(0.7,-1.9,0.2), 1.0, 0.0, 0.75 );\n    d = smin(d,d3,0.15);\n    d3 = leg( p, vec3(0.8,-0.4,-0.2), vec3(0.3,-1.4,-0.2), vec3(0.2,-1.9,-0.2), 1.0, 0.0, 0.75 );\n    d = smin(d,d3,0.15);\n\n    }\n    \n    return d\/sca;\n}\n\nfloat mapWithElephants( vec3 p )\n{\n    vec3 kk;\n    float res = map( p, kk ).x;\n\n    res = min( res, mapElephantSimple(p) );\n    res = min( res, mapSmallElephantSimple(p) );\n\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos, in float eps )\n{\n    vec3 kk;\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*map( pos + e.xyy, kk ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, kk ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, kk ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, kk ).x );\n#else\n    \/\/ trick by klems, to prevent the compiler from inlining map() 4 times\n    vec4 n = vec4(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec4 s = vec4(pos, 0.0);\n        s[i] += eps*0.25;\n        n[i] = map(s.xyz,kk).x;\n    }\n    return normalize(n.xyz-n.w);\n#endif    \n}\n\nvec3 forwardSF( float i, float n) \n{\n    const float PI  = 3.141592653589793238;\n    const float PHI = 1.618033988749894848;\n    float phi = 2.0*PI*fract(i\/PHI);\n    float zi = 1.0 - (2.0*i+1.0)\/n;\n    float sinTheta = sqrt( 1.0 - zi*zi);\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\n}\n\nfloat calcSoftShadow( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n    float t = 0.01;\n    for( int i=0; i<24; i++ )\n    {\n        float h = mapWithElephants(ro + rd*t );\n        res = min( res, smoothstep(0.0,1.0,k*h\/t) );\n        t += clamp( h, 0.05, 0.5 );\n\t\tif( res<0.01 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat ao = 0.0;\n    for( int i=ZERO; i<8; i++ )\n    {\n        vec3 ap = forwardSF( float(i), 8.0 );\n        float h = hash1(float(i));\n        float dk = dot(ap,nor); if( dk<0.0 ) ap -= 2.0*nor*dk;\n        ap *= h*0.3;\n        ao += clamp( mapWithElephants( pos + nor*0.01 + ap )*2.4, 0.0, 1.0 );\n    }\n\tao \/= 8.0;\n\t\n    return clamp( ao*4.0*(1.0+0.25*nor.y), 0.0, 1.0 );\n}\n\n\nvec3 sunDir = normalize( vec3(0.15,0.7,0.65) );\n\nfloat dapples( in vec3 ro, in vec3 rd )\n{\n    float sha = eliSoftShadow( ro, rd, vec3(0.0,4.0,4.0), vec3(3.0,1.0,3.0), 10.0 );\n    \n    vec3 uu = normalize( cross( rd, vec3(0.0,0.0,1.0) ) );\n    vec3 vv = normalize( cross( uu, rd ) );\n\n    vec3 ce = vec3(0.0,4.0,5.0);\n    float t = -dot(ro-ce,rd);\n    vec3 po = ro + t*rd;\n    vec2 uv = vec2( dot(uu,po-ce), dot(vv,po-ce) );\n\n    float dap = 1.0-smoothstep( 0.1, 0.5, texture(iChannel3,0.25+0.4*uv).x );\n    return 1.0 - 0.95*(1.0-sha)*(1.0-dap);\n}\n\nvec3 shade( in vec3 ro, in vec3 rd, in float t, in float m, in vec3 matInfo )\n{\n    float eps = 0.001;\n    \n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormal( pos, eps*t );\n    float kk;\n\n    vec3 mateD = vec3(0.2,0.16,0.11);\n    vec3 mateS = vec3(0.2,0.12,0.07);\n    vec3 mateK = vec3(0.0,1.0,0.0); \/\/ amount, power, metalic\n    float focc = 1.0;\n    \n    if( m<3.5 ) \/\/ ground\n    {\n        mateD = vec3(0.1,0.09,0.07)*0.27;\n        mateS = vec3(0.0,0.0,0.0);\n        mateD *= 2.0*texture( iChannel1, 0.1*pos.xz ).xyz;\n        \n        float gr = smoothstep( 0.3,0.4,texture(iChannel2,0.01*pos.zx).x );\n        vec3 grcol = vec3(0.3,0.28,0.05)*0.07;\n        grcol *= 0.5 + texture( iChannel2, 4.0*pos.xz ).x;\n        mateD = mix( mateD, grcol, smoothstep( 0.9,1.0,nor.y)*gr );\n        mateD *= 1.2;\n        mateK = vec3(1.0,8.0,1.0);\n    }\n    else if( m<4.5) \/\/ bushes\n    {\n        mateD = vec3(0.2,0.32,0.07)*0.1;\n        mateD.x += matInfo.x*0.02;\n        mateS = vec3(0.8,0.9,0.1);\n        focc = 1.0-matInfo.y;\n        mateK = vec3(0.07,16.0,0.0);\n    }\n    else if( m<5.5 ) \/\/ trees\n    {\n        mateD = vec3(0.2,0.3,0.07)*0.07;\n        mateS = vec3(0.0,0.0,0.0);\n        mateK = vec3(0.2,16.0,0.0);\n    }\n    else \/\/ leaves\n    {\n        mateD = vec3(0.2,0.35,0.07)*0.2;\n        mateS = vec3(0.8,1.0,0.1)*0.25;\n        mateK = vec3(0.07,16.0,0.0);\n        float te = texture( iChannel2, 0.35*matInfo.yz ).x;\n        mateD *= 1.0 + 0.6*te;\n        mateS *= 1.0 + 0.6*te;\n        mateD += vec3(0.035) * (1.0-smoothstep(0.005,0.01,abs(matInfo.y)+matInfo.z*0.05) );\n    }\n    \n    vec3 hal = normalize( sunDir-rd );\n    float fre = clamp(1.0+dot(nor,rd), 0.0, 1.0 );\n    float occ = calcAO( pos, nor )*focc;\n        \n    float dif1 = clamp( dot(nor,sunDir), 0.0, 1.0 );\n    float bak = clamp( dot(nor,normalize(vec3(-sunDir.x,0.0,-sunDir.z))), 0.0, 1.0 );\n    float sha = calcSoftShadow( pos, sunDir, 16.0 );\n\tsha = min( sha, dapples(pos,sunDir) );\n              \n    dif1 *= sha;\n    float spe1 = clamp( dot(nor,hal), 0.0, 1.0 );\n    float bou = clamp( 0.3-0.7*nor.y, 0.0, 1.0 );\n\n    \/\/ sun\n    vec3 col = 8.5*vec3(2.0,1.2,0.65)*dif1;\n    \/\/ sky\n    col += 4.5*vec3(0.35,0.7,1.0)*occ*clamp(0.2+0.8*nor.y,0.0,1.0);\n    \/\/ ground\n    col += 4.0*vec3(0.4,0.25,0.12)*bou*occ;\n    \/\/ back\n    col += 3.5*vec3(0.2,0.2,0.15)*bak*occ;\n    \/\/ sss\n    col += 25.0*fre*fre*(0.2+0.8*dif1*occ)*mateS;\n\n    \/\/ sun\n    vec3 hdir = normalize(sunDir - rd);\n    float costd = clamp( dot(sunDir, hdir), 0.0, 1.0 );\n    float spp = pow( spe1, mateK.y )*dif1*mateK.x * (0.04 + 0.96*pow(1. - costd,5.0));\n    col += mateK.z*15.0*5.0*spp; \n\n    \n    col *= mateD;\n\n    col += (1.0-mateK.z)*15.0*5.0*spp; \n    \n    return col;        \n}\n\nvec2 intersect( in vec3 ro, in vec3 rd, out vec3 matInfo )\n{\n    vec2 res = vec2(-1.0);\n\n    float maxdist = 100.0;\n    float t = 1.0;\n\n    float tp = ( 8.0-ro.y)\/rd.y; if( tp>0.0 ) maxdist = min( maxdist, tp );\n          tp = (-2.2-ro.y)\/rd.y; if( tp>0.0 ) maxdist = min( maxdist, tp );\n    \n    for( int i=0; i<110; i++ )\n    {\n        vec3 p = ro + t*rd;\n        vec2 h = map( p, matInfo );\n        res = vec2(t,h.y);\n        if( h.x<(0.0001*t) ||  t>maxdist ) break;\n        t += h.x*0.75;\n    }\n\n    if( t>maxdist )\n    {\n        res = vec2(-1.0);\n    }\n\n    return res;\n}\n\nfloat mapBk( in vec3 pos )\n{\n    float l = length(pos.xz);\n    float f = smoothstep( 1000.0, 1500.0, l );\n\n    float h = 200.0*f*texture( iChannel2, 0.001 + 0.00003*pos.xz ).x;\n\n    return pos.y-h;\n}\n\nvec3 calcNormalBk( in vec3 pos, in float eps )\n{\n#if 0    \n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*mapBk( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*mapBk( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*mapBk( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*mapBk( pos + e.xxx ) );\n#else\n    \/\/ trick by klems, to prevent the compiler from inlining map() 4 times\n    vec4 n = vec4(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec4 s = vec4(pos, 0.0);\n        s[i] += eps;\n        n[i] = mapBk(s.xyz);\n    }\n    return normalize(n.xyz-n.w);\n#endif    \n}\n\nfloat calcSoftShadowBk( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n    float t = 0.01;\n    for( int i=0; i<16; i++ )\n    {\n        float h = mapBk(ro + rd*t );\n        res = min( res, smoothstep(0.0,1.0,k*h\/t) );\n        t += clamp( h, 10.0, 100.0 );\n\t\tif( res<0.01 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec3 shadeBk( in vec3 ro, in vec3 rd, in float t )\n{\n    float eps = 0.005;\n    \n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormalBk( pos, eps*t );\n    float kk;\n\n    vec3 mateD = vec3(0.14,0.14,0.12);\n    mateD = mix( mateD, vec3(0.03,0.03,0.0), smoothstep(0.85,0.95, nor.y ) );\n    mateD *= 0.3;\n  \n    mateD *= 0.1 + 2.0*texture( iChannel2, pos.xz*0.005 ).x;\n    \n    vec3 hal = normalize( sunDir-rd );\n        \n    float dif1 = clamp( dot(nor,sunDir), 0.0, 1.0 );\n    float sha = calcSoftShadowBk( pos, sunDir, 16.0 );\n    dif1 *= sha;\n\n    \/\/ sun\n    vec3 col = 8.0*vec3(1.8,1.2,0.8)*dif1;\n    \/\/ sky\n    col += 4.0*vec3(0.3,0.7,1.0)*clamp(0.2+0.8*nor.y,0.0,1.0);\n    \n    col *= mateD;\n\n    return col;        \n}\n\nfloat intersectBk( in vec3 ro, in vec3 rd )\n{\n    float res = -1.0;\n\n    float maxdist = 2000.0;\n    float t = 1000.0;\n\n    for( int i=0; i<100; i++ )\n    {\n        vec3 p = ro + t*rd;\n        float h = mapBk( p );\n        res = t;\n        if( h<(0.0001*t) ||  t>maxdist ) break;\n        t += h*0.75;\n    }\n\n    if( t>maxdist ) res = -1.0;\n\n    return res;\n}\n\nvec3 render( in vec3 ro, in vec3 rd, out float resT )\n{\n    resT = 10000.0;\n    \n    \/\/ sky\n    vec3 col = clamp(vec3(0.7,0.9,1.0) - rd.y,0.0,1.0);\n    \n    \/\/ clouds\n    float t = (1000.0-ro.y)\/rd.y;\n    if( t>0.0 )\n    {\n        vec2 uv = (ro+t*rd).xz;\n        float cl = texture( iChannel2, .000013*uv ).x;\n        cl = smoothstep(0.4,1.0,cl);\n        col = mix( col, vec3(1.0), 0.4*cl );\n    }\n\n    \/\/ distant mountains\n    {\n    float tm = intersectBk( ro, rd );\n    if( tm>-0.5  )\n    {\n        col = shadeBk( ro, rd, tm );\n        float fa = 1.0-exp(-0.001*tm);\n        vec3 pos = ro + rd*tm;\n        fa *= exp(-0.001*pos.y);\n        col = mix( col, vec3(0.4,0.5,0.65), fa );\n        resT = tm;\n    }\n    }\n    \n    \/\/ landscape\n    vec3 matInfo;\n    vec2 tm = intersect( ro, rd, matInfo );\n    if( tm.y>-0.5  )\n    {\n        col = shade( ro, rd, tm.x, tm.y, matInfo );\n        float fa = 1.0-exp(-0.0002*(tm.x*tm.x*0.4  + 0.6*tm.x));\n        col = mix( col, vec3(0.4,0.5,0.65), fa );\n        resT = tm.x;\n    }\n    \n    return col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 rt, in float cr )\n{\n\tvec3 cw = normalize(rt-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 q = fragCoord\/iResolution.xy;\n    vec2 p = (-iResolution.xy+2.0*fragCoord)\/iResolution.y;\n\n    \/\/ camera\n    float an = 0.0 - 1.25- 1.0*iMouse.x\/iResolution.x;\n    vec3 ro = vec3(5.7*sin(an),1.6,5.7*cos(an));\n    vec3 ta = vec3(0.0,1.6,0.0);\n\n    \/\/ ray\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    vec3 rd = normalize( ca * vec3(p,-3.5) );\n\n    \/\/ render\n    float t;\n    vec3 col = render( ro, rd, t);\n    \n    fragColor = vec4( col, t );\n}\n",
            "name": "Buffer A",
            "description": "",
            "type": "buffer"
        },
        {
            "inputs": [
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "XsXGR8",
                    "channel": 0
                }
            ],
            "code": "\/\/ Created by inigo quilez - iq\/2016\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\/\/ pretty decent DOF with a gather approach\n\nvec2 rand2( in vec2 f ) \n{ \n    float n = f.x+131.1*f.y;\n    return fract(sin(vec2(n,n+113.0))*43758.5453123); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 di = -0.5 + rand2( fragCoord );\n\n    vec2 uv = fragCoord\/iResolution.xy;\n    \n    vec4 ref = texture( iChannel0, uv );\n    \n    float focus = 7.0;\n\n    vec4 acc = vec4(0.0);\n\n    acc += vec4( texture( iChannel0, uv ).xyz, 1.0 );\n    \n    for( int j=0; j<11; j++ )\n    for( int i=0; i<11; i++ )\n    {\n        if( !((i==5) && (j==5)) )\n        {\n            vec2 of = 1.0 * (di+vec2(float(i-5),float(j-5)))\/800.0;\n            vec2 st = uv + of;\n\n            vec4 cold = texture( iChannel0, st );\n            float depth = cold.w;\n            float coc = 0.005*abs(depth-focus)\/depth;   \/\/ compute scatter radious\n\n            if( dot(of,of) < (coc*coc) )\n            {\n                acc += vec4(cold.xyz,1.0);\n            }\n        }\n    }\n    \n    vec3 col = acc.xyz \/ acc.w;\n    \n\tfragColor = vec4( col, ref.w );\n}    \n",
            "name": "Buffer B",
            "description": "",
            "type": "buffer"
        }
    ]
}