{
    "ver": "0.1",
    "info": {
        "id": "wlcyRB",
        "date": "1609361866",
        "viewed": 117,
        "name": "Day 379",
        "username": "jeyko",
        "description": "potato",
        "likes": 27,
        "published": 3,
        "flags": 32,
        "usePreview": 0,
        "tags": [
            "terrain",
            "fog",
            "trees",
            "fall",
            "leaves",
            "mdtmjvm",
            "evening"
        ],
        "hasliked": 0
    },
    "renderpass": [
        {
            "inputs": [
                {
                    "id": "XsXGR8",
                    "filepath": "\/media\/previz\/buffer01.png",
                    "previewfilepath": "\/media\/previz\/buffer01.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dfGRr",
                    "channel": 0
                }
            ],
            "code": "\/\/ Fork of \"Day 378\" by jeyko. https:\/\/shadertoy.com\/view\/WttyD7\n\/\/ 2020-12-30 10:41:15\n\n\n\/\/ Cyclic noise from nimitz\n\/\/ smooth ops & sdfs from IQ\n\/\/ pModPolar from hgSDF\n\/\/ FXAA maybe from mudlord\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)\/iResolution.y;\n\n    vec3 col = vec3(0);\n\n    col = texture(iChannel0,fragCoord\/iResolution.xy).xyz;\n    \n    col *= vec3(0.9,0.9,0.66);\n    col *= exposure;\n    \n    col = mix(col*1.5,smoothstep(0.,1.,col*vec3(1.,1.1,1.4 ))*1.8,0.6);\n    col = mix(acesFilm(col), col, 0.);\n    col *= 1. - dot(uv,uv*0.4)*2.;\n    \n    col = pow(col,vec3(0.454545));\n    \n    fragColor = vec4(col,1.0);\n}\n",
            "name": "Image",
            "description": "",
            "type": "image"
        },
        {
            "inputs": [],
            "outputs": [],
            "code": "bool hit = false;\n\n\/\/ General\n#define exposure 1.3\n#define groundOffs vec3(0,1.3,0)\n\n#define marchSteps 300\n#define marchEps  (mix(0.004,0.26,smoothstep(0.,1.,t*0.1 - 2.)))\n#define distScale 0.6\n\n\/\/ Path\n#define pathW 1.2\n\n\/\/ Trees\n#define treesSeperation 6.\n\n#define treeBranchSeperation 1.2\n\n#define trunkW 0.2\n\n\/\/ Clouds\n\n#define cloudsLowerLimit 7.\n#define cloudsHigherLimit 14.\n\n#define cloudSteps 60.\n#define volumetricDithAmt .05\n\n\/\/ Wind\n#define windSteps 40.\n#define maxWindD 30.\n\n\/\/ Atmosphere\n#define sunCol vec3(0.7,0.9,0.9)*1.\n#define sunPos (vec3(-0.01,1.22 ,2.)*2300.)\n\n#define planetSz 2984.\n#define atmoSz (planetSz\/63.)\n\n\n#define ambianceScale 0.4\n\n#define itersAtmo 3.\n#define itersOptic 3.\nconst float redLightLen = 640.;\nconst float greenLightLen = 550.;\nconst float blueLightLen = 450.;\n\nconst float transStrength = 0.02;\n\nfloat densFalloff = 1.9;\n\n\n#define sss(a) clamp(map(p + sunDir*a).x\/a,0., 1.)\n#define ao(a) clamp(map(p + mix(n, sunDir, 0.5)*a).x\/a,0., 1.)\n#define aoVol(p, a, dir) smoothstep(0.,1.,map(p + dir*a).x\/a*1.5)\n\n#define pi acos(-1.)\n\n#define pal(a,b,c,d,e) ((a + (b)*sin((c)*(d) + (e))))\n\n#define tau (2.*pi)\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pmod(p,a) mod(p - 0.*a,a) - 0.5*a\nfloat valueNoise(vec3 p, float pw);\nvec3 acesFilm(const vec3 x);\nvec2 dmin(vec2 a, float b, float cmp){return a.x < b ? a : vec2(b,cmp);}\nfloat turbulentNoise(vec3 p);\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra );\nfloat atmosphericDensity( vec3 p);\nfloat opticalDepth(vec3 p, vec3 rd, float len);\nvec3 getAtmosphere(vec3 ro, vec3 rd, float t, out float opticalDepthView);\nmat3 getRd(vec3 ro, vec3 lookAt);\nvec3 getRdSpherical(vec3 ro, inout vec2 uv);\nvec3 hash3(vec3 p);\nfloat r21(vec2 p);\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p );\n\nvec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) \/ (x * (c * x + d ) + e), 0.0, 1.0);\n}\n\n\/*\nfloat r24(vec2 p){\n    return texture(iChannel0,)[ int(mod(p.x))];\n}*\/\n\n \n\nmat3 getOrthogonalBasis(vec3 direction){\n    direction = normalize(direction);\n    vec3 right = normalize(cross(vec3(0,1,0),direction));\n    vec3 up = normalize(cross(direction, right));\n    return mat3(right,up,direction);\n}\n\nfloat cyclicNoiseWind(vec3 p, bool turbulent, float time){\n    float noise = 0.;\n    \n    float amp = 1.;\n    const float gain = 0.9;\n    const float lacunarity = 1.5;\n    const int octaves = 6;\n    \n    const float warp = 0.2;    \n    float warpTrk = 1.5 ;\n    const float warpTrkGain = .2;\n    \n    vec3 seed = vec3(-1,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy + vec3(0,time*0.3,0))))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\n\nfloat cyclicNoiseGround(vec3 p, bool turbulent){\n    float noise = 0.;\n    \n    float amp = 2.;\n    const float gain = 0.5;\n    const float lacunarity = 2.5;\n    const int octaves = 3;\n    \n    const float warp = 0.9;    \n    float warpTrk = 1. ;\n    const float warpTrkGain = 1.2;\n    \n    vec3 seed = vec3(-1,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy )))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\nfloat cyclicNoiseTrees(vec3 p, bool turbulent){\n    float noise = 0.;\n    \n    float amp = 1.;\n    const float gain = 0.4;\n    const float lacunarity = 2.5;\n    const int octaves = 3;\n    \n    const float warp = 0.5;    \n    float warpTrk = 1. ;\n    const float warpTrkGain = 1.2;\n    \n    vec3 seed = vec3(-1,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy )))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\nfloat cyclicNoiseAlley(vec3 p, bool turbulent){\n    float noise = 0.;\n    \n    float amp = 1.;\n    const float gain = 0.8;\n    const float lacunarity = 1.5;\n    const int octaves = 4;\n    \n    const float warp = 0.3;    \n    float warpTrk = 1.4 ;\n    const float warpTrkGain = 1.2;\n    \n    vec3 seed = vec3(-1,-2.,2.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy  + sin(p + 4.))))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\n\n\/*\nfloat valueNoiseCheap(in vec3 p,float pw)\n{\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n\tfp = fp*fp*(3.0-2.0*fp);\n\tvec2 tap = (ip.xy+vec2(37.0,17.0)*ip.z) + fp.xy;\n\tvec2 rz = textureLod( iChannel0, (tap+0.5)\/256.0, 0.0 ).yx;\n\treturn mix( rz.x, rz.y, fp.z );\n}*\/\n\n\nfloat valueNoise(vec3 p, float pw){\n    \n\tvec3 s = vec3(1., 25, 75);\n\t\n\tvec3 ip = floor(p); \/\/ Unique unit cell ID.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    \n\tp -= ip; \/\/ Cell's fractional component.\n\t\n    \/\/ A bit of cubic smoothing, to give the noise that rounded look.\n    if(pw == 1.){\n        p = p*p*(3. - 2.*p); \n    } else {\n    \n    \tp = p*p*(p*(p * 6. - 15.) + 10.);\n    }\n    \n    \/\/p = smoothstep(0.,1.,p);\n    \/\/ Smoother version of the above. Weirdly, the extra calculations can sometimes\n    \/\/ create a surface that's easier to hone in on, and can actually speed things up.\n    \/\/ Having said that, I'm sticking with the simpler version above.\n\t\/\/p = p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n\t\n    \/\/ Interpolating along Y.\n    h.xy = mix(h.xz, h.yw, p.y);\n    \n    \/\/ Interpolating along Z, and returning the 3D noise value.\n    return mix(h.x, h.y, p.z); \/\/ Range: [0, 1].\n\t\n}\n\nvec3 hash3(vec3 p) {\n\tp = vec3(dot(p, vec3(127.1, 311.7, 74.7)),\n\t\t\tdot(p, vec3(269.5, 183.3, 246.1)),\n\t\t\tdot(p, vec3(113.5, 271.9, 124.6)));\n\n\treturn -1.0 + 2.0 * fract(sin(p) * 43758.5453123);\n}\n\nfloat r21(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 r23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nfloat turbulentNoise(vec3 p, bool md) {\n\tp += 8.;\n    vec3 i = floor(p);\n\tvec3 f = fract(p);\n\n\tvec3 u = f * f * (3.0 - 2.0 * f);\n\n    \/\/f = u;\n\tfloat n0 = dot(hash3(i + vec3(0.0, 0.0, 0.0)), f - vec3(0.0, 0.0, 0.0));\n\tfloat n1 = dot(hash3(i + vec3(1.0, 0.0, 0.0)), f - vec3(1.0, 0.0, 0.0));\n\tfloat n2 = dot(hash3(i + vec3(0.0, 1.0, 0.0)), f - vec3(0.0, 1.0, 0.0));\n\tfloat n3 = dot(hash3(i + vec3(1.0, 1.0, 0.0)), f - vec3(1.0, 1.0, 0.0));\n\tfloat n4 = dot(hash3(i + vec3(0.0, 0.0, 1.0)), f - vec3(0.0, 0.0, 1.0));\n\tfloat n5 = dot(hash3(i + vec3(1.0, 0.0, 1.0)), f - vec3(1.0, 0.0, 1.0));\n\tfloat n6 = dot(hash3(i + vec3(0.0, 1.0, 1.0)), f - vec3(0.0, 1.0, 1.0));\n\tfloat n7 = dot(hash3(i + vec3(1.0, 1.0, 1.0)), f - vec3(1.0, 1.0, 1.0));\n\n\tfloat ix0 = mix(n0, n1, u.x);\n\tfloat ix1 = mix(n2, n3, u.x);\n\tfloat ix2 = mix(n4, n5, u.x);\n\tfloat ix3 = mix(n6, n7, u.x);\n\n\tfloat ret = mix(mix(ix0, ix1, u.y), mix(ix2, ix3, u.y), u.z) * 0.5 + 0.5;\n\tret = ret * 1.;\n    \n    \/\/ret = 1.- ret;\n    \/\/ret = abs(ret);\n    if (md)\n        ret = mix(ret,smoothstep(0.3,1.,ret*0.8),0.6);\n    return ret;\n}\n\n\n\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); \/\/ no intersection\n    h = sqrt( h );\n    \/\/return -b+h;\n    \/\/return max(max(-b-h,0.),max(-b+h,0.));\n    return vec2( -b-h, -b+h );\n}\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)+p.w)\/dot(rd,p.xyz);\n}\n\n\nfloat atmosphericDensity( vec3 p){\n    float fact = (p.y - planetSz )\/atmoSz;\n    fact = max(fact, 0.0001);\n    return exp(-fact*densFalloff)*pow(max(1. - fact,0.),0.04);\/\/*pow(smoothstep(0.95,0.84,fact),1.);\n}\n\nfloat opticalDepth(vec3 p, vec3 rd, float len){\n    float stSz = len \/ (itersOptic-1.);\n    float depth = 0.;\n    for(float opticIdx = 0.; opticIdx < itersOptic; opticIdx++ ){\n        depth += atmosphericDensity(p) * stSz;\n        p += rd*stSz;\n     }\n    return depth;\n}\n\n\nvec3 scatteringCoefficients = transStrength*vec3(\n    pow(400.\/redLightLen,4.),\n    pow(400.\/greenLightLen,4.),\n    pow(400.\/blueLightLen,4.)\n);\nvec3 getAtmosphere(vec3 ro, vec3 rd, float t, out float opticalDepthView){\n    vec3 accumAtmo = vec3(0);\n    float atmoMarchLen = 0.;\n    \n    vec3 offs = vec3(0,planetSz ,0);\n    vec3 p = ro;\n    vec3 sunPosAtmo = sunPos + offs;\n    \n    p += offs*1.;\n    \n    \n    float lenViewDirToEndOfAtmosphere = sphIntersect( p, rd, vec3(0), planetSz + atmoSz ).y;\n    \n    if(hit){\n        atmoMarchLen = mix(t,lenViewDirToEndOfAtmosphere,smoothstep(0.,1.,t\/50. - 1.));\n    } else {\n        atmoMarchLen = lenViewDirToEndOfAtmosphere;\n    }\n    float stepSz = atmoMarchLen\/(itersAtmo - 1.);\n    \n\n    for(float atmoIdx = 0.; atmoIdx < itersAtmo ; atmoIdx++ ){\n        vec3 dirToSun = normalize(sunPosAtmo - p);\n        float lenSunDirToEndOfAtmosphere = sphIntersect( p, dirToSun, vec3(0), planetSz + atmoSz ).y;\n        lenViewDirToEndOfAtmosphere = sphIntersect( p, -rd, vec3(0), planetSz + atmoSz ).y;\n        \n        float opticalDepthSun = opticalDepth(p, dirToSun, lenSunDirToEndOfAtmosphere);\n        opticalDepthView = opticalDepth(p, -rd, stepSz*atmoIdx);\n        \n        float localDens = atmosphericDensity(p);\n        \n\n        vec3 transmittance = exp(-(opticalDepthSun + opticalDepthView) * scatteringCoefficients);        \n        accumAtmo += transmittance * localDens * scatteringCoefficients * stepSz;\n        \n        p += rd * stepSz;\n    }\n    \n    return accumAtmo;\n}\n\nmat3 getRd(vec3 ro, vec3 lookAt){\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0),dir));\n    vec3 up = normalize(cross(dir,right));\n    \n    return mat3(right,up,dir); \n}\n\nvec3 getRdUV(vec3 ro, vec3 lookAt, vec2 uv){\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0),dir));\n    vec3 up = normalize(cross(dir,right));\n    \n    return normalize(dir + right*uv.x + up*uv.y); \n}\n\n\n\/\/ Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max((abs(n) - 0.2)*7., 0.001); \/\/ max(abs(n), 0.001), etc.\n    n \/= (n.x + n.y + n.z );  \n    \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\nvec3 getRdSpherical(inout vec2 uv){\n    \n    \/\/ polar coords\n    uv = vec2(atan(uv.y,uv.x),length(uv));\n    \n    vec2 ouv = uv;\n    uv += 0.5;\n    uv.y *= pi;\n    \n    \n    \/\/ parametrized sphere\n    vec3 offs = vec3(cos(uv.y)*cos(uv.x),sin(uv.y),cos(uv.y)*sin(uv.x));\n    \n    \/\/ insert camera rotations here\n    offs.yz *= rot(-(1.)*pi);\n    \n    \/\/vec3 lookAt = ro + offs;\n    \/\/vec3 v = normalize(lookAt - ro);\n    vec3 v = offs;\n    \/\/uv = ouv;\n    \/\/uv.x = v.x;\n    \/\/uv.y = v.y;\n    \n    return v;\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)\/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)\/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)\/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)\/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n\n#define opRepLim(p,c,l) (p-(c)*clamp(round((p)\/(c)),-(l),(l)))\n\nfloat pModPolar(inout vec2 p, out float id, float repetitions) {\n\tfloat angle = 2.*pi\/repetitions;\n\tfloat a = atan(p.y, p.x) + angle\/2.;\n    id = floor(a\/angle);\n\tfloat r = length(p);\n\tfloat c = floor(a\/angle);\n\ta = mod(a,angle) - angle\/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t\/\/ For an odd number of repetitions, fix cell index of the cell in -x direction\n\t\/\/ (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions\/2.)) c = abs(c);\n\treturn c;\n}",
            "name": "Common",
            "description": "",
            "type": "common"
        },
        {
            "inputs": [
                {
                    "id": "XdX3Rn",
                    "filepath": "\/media\/a\/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg",
                    "previewfilepath": "\/media\/ap\/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg",
                    "type": "texture",
                    "channel": 3,
                    "sampler": {
                        "filter": "mipmap",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "XsX3Rn",
                    "filepath": "\/media\/a\/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg",
                    "previewfilepath": "\/media\/ap\/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg",
                    "type": "texture",
                    "channel": 1,
                    "sampler": {
                        "filter": "mipmap",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "Xsf3zn",
                    "filepath": "\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
                    "previewfilepath": "\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
                    "type": "texture",
                    "channel": 0,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "repeat",
                        "vflip": "false",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 2,
                    "sampler": {
                        "filter": "mipmap",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dXGR8",
                    "channel": 0
                }
            ],
            "code": "\n#define TAA false\n\nvec3 getNormal(vec3 p);\nvec3 getSun(vec2 uv, vec2 sunPosU, vec3 ro, mat3 vp);\nfloat t = 0.;\nfloat invisibleWall = 10e4;\n\nfloat groundNoise = 0.;\nfloat alleyNoise = 0.;\nfloat treebarkNoise = 0.;\nvec3 alleyUv = vec3(0);\n\nfloat fp(float z){return sin(z*0.15 + cos(z*0.05 + sin(z*0.04)));}\n\nvec3 getPath(vec3 p){\n    return vec3(fp(p.z),0.,0.)*7.;\n    \/\/return vec3(sin(p.z*0.2),0.,0.)*3.;\n\n}\n\n\nvec2 getGround(vec3 p){\n    \n    float d = p.y;\n    float noise = groundNoise = cyclicNoiseGround(vec3(p)*0.2, false);\n    \n    d -= noise*0.2;\n    \n    return vec2(d,1.);\n}   \n\n\n\nvec2 getAlley(vec3 p){\n    p -= getPath(p);\n    \n    \n    p.y -= (alleyNoise = cyclicNoiseAlley(vec3(p)*62.2, true))*0.05*0.325;\n    p.y -= 0. + groundNoise*0.4 + 0.09;\n    p.y += smoothstep(0.0,0.9, abs(p.x) - pathW + sin(p.z*0.2)*0.2)*0.4;\n    \n    alleyUv = p;\n    \n    float d = p.y;\n    \n    \n    \n    return vec2(d,2.);\n}\nvec2 getTrees(vec3 po){\n    float d = 10e5;\n    float noise = cyclicNoiseTrees(vec3(po)*0.4, false);\n    float noiseb = cyclicNoiseTrees(vec3(po.x,po.y*0.2,po.z)*24.4, false);\n    treebarkNoise = noiseb;\n    \n    po.xz += noise*.5;\n    vec3 p = po;\n    \n    \n    vec3 id = floor((p)\/vec3(treesSeperation, treeBranchSeperation, treesSeperation));\n    \n    p -= getPath(vec3(0.,0.,id.z*treesSeperation + treesSeperation*0.5));\n    id = floor((p)\/vec3(treesSeperation, treeBranchSeperation, treesSeperation));\n    \n    \n    \n    p.z = pmod(p.z,treesSeperation);\n    \n    p.x = pmod(p.x,treesSeperation);\n    \n    invisibleWall = abs(abs(p.z) - treesSeperation*0.5) + 0.3;\n    \n    \n    float lpxz = length(p.xz);\n    \n    d = lpxz - trunkW  - noiseb*0.11*(1. + smoothstep(1.1,0.,p.y)*2.);\n    \n    \/\/p.y -= smoothstep(0.,0.2,(lpxz + 0.2))*0.5;\n    \n    \n    p.y = opRepLim( p.y - treeBranchSeperation*11.  + 0.75*treeBranchSeperation, treeBranchSeperation, 9. );\n    \/\/p.y = pmod( p.y, treeBranchSeperation);\n    \n    \n    \/\/p.y += 0.25*treeBranchSeperation;\n    \n    p.xz *= rot(sin(id.x*40.0 + id.z*1.4 + id.x*id.y*20. + id.y*229. + id.y * id.z*200.)*pi*222.);\n    \/\/p.xz *= rot(sin(id.z)*pi*2.);\n    \n    \n    float polarId;\n    \n    pModPolar(p.xz, polarId, 4.);\n    \n    invisibleWall = min(invisibleWall, abs(abs(p.y) - treeBranchSeperation*0.5) + 0.03);\n    \n    p.yx *= rot(0.5*pi);\n    float mdBranchLen = sin(id.x + id.y + 20.*id.y*id.z +20.*polarId);\n    mdBranchLen = mix(mdBranchLen*0.3, abs(mdBranchLen)*0.9,smoothstep(0.,1.,id.y*0.5 - 0.8));\n    float branchLen = (1.1  + mdBranchLen)*( 0.1 + smoothstep(0.4,1.,id.y*0.4 - 0.5)) ;\n    \n    float branchWidth = abs(sin(branchLen*200.  + polarId*10.));\n    \n    branchLen = max(branchLen, 0.);\n    \n    \n    \n    p.y += branchLen - 0.5;\n    p.x -= pow(smoothstep(0.,2.9,(lpxz - 0.)*1.)\/branchLen*1.6,1.)*0.9;\n    \n    \n    \/\/p.x -= noiseb*0.04 + noise*0.0;\n    \/\/branchWidth *= 0.5 + noiseb;\n    \n    \/\/d = opSmoothUnion( d,  sdRoundCone( p, 0.01 + branchWidth*0.02, 0.05 + branchWidth*0.04, branchLen ), 0.09 ) ;\n    \n    \/\/d = min( d,  sdRoundCone( p, 0.03 + branchWidth*0.04, 0.00 + branchWidth*0.0, branchLen )*1.) ;\n    \n    d = min( d,  max(length(p.xz) - 0.01 - 0.05*smoothstep(0.,1.,p.y\/branchLen*0.6), - p.y - branchLen*0.5)*0.7 ) ;\n    \n    \n    return vec2(d,3.);\n}\nfloat getLeaf(vec3 p, float sz, vec3 op, vec2 id){ \n    p.z -= sin(5.*abs(p.x)\/sz)*sz*.575;\n    \n    p.x *= 0.75;\n    p.xy *= rot(0. + sin(id.x*10. + id.y)*0.5);\n    \n    float d = length(p.xz) - sz ; \n    \n    d = max(d,abs(p.y) - 0.01);\n    return d;\/\/max(, - abs(p.y) + 0.03);\n\n}\nfloat getLeavesLayer(vec3 op, float md, float sz){\n    vec3 p = op; \n    vec2 id = floor(p.xz\/md);\n    p.xz = pmod(p.xz, md);\n    return getLeaf(p, sz, op, id);\n}\n\nvec2 getLeaves(vec3 p, float dTrees){\n    vec2 d = vec2(10e4);\n    p.y -= smoothstep(0.4,0.,dTrees)*0.1;\n    \n    p.y -= groundNoise*0.4;\n    p.xz *= rot(0.25);\n    \n    d = dmin(d, getLeavesLayer(p, 0.25, 0.05), 20.);\n    p.xz *= rot(0.25);\n    p.y -= 0.04;\n    d = dmin(d, getLeavesLayer(p, 0.5, 0.05), 21.);\n    \n    p.xz *= rot(0.25);\n    p.y -= 0.005;\n    d = dmin(d, getLeavesLayer(p, 0.45, 0.05), 22.);\n\n    p.xz *= rot(0.25);\n    p.y += 0.025;\n    d = dmin(d, getLeavesLayer(p, 0.35, 0.05), 23.);\n\n    p.xz *= rot(0.25);\n    p.y -= 0.002;\n    d = dmin(d, getLeavesLayer(p, 0.25, 0.05), 24.);\n    \n    p.xz *= rot(0.25);\n    p.y += 0.04;\n    d = dmin(d, getLeavesLayer(p, 0.25, 0.15), 24.);\n\n\n    return d;\n}\n\nvec2 map(vec3 p){\n    vec2 d = vec2(10e5);\n    \n    vec2 dGround = getGround(p);\n    vec2 dAlley = getAlley(p);\n    vec2 dTrees = getTrees(p);\n    vec2 dLeaves = getLeaves(p,dTrees.x);\n   \n   \n   \n    d = dmin(d, dAlley.x,dAlley.y);\n    \n    \n    dGround.x = opSmoothSubtraction( -dGround.x, -dAlley.x, 0.1 );\n    \n    \n    \n    \/\/dLeaves.x = opSmoothSubtraction( -dLeaves.x, -dAlley.x + 0.05, 0.01 );\n    \n    \/\/dLeaves.x = mix(dLeaves.x, max(dLeaves.x, -dGround.x + 0.03),smoothstep(0.05,0.,abs(dLeaves.x - dAlley.x) - 0.04 ));\n    \n    d = dmin(d, dGround.x,dGround.y);\n    dTrees.x = opSmoothUnion( dTrees.x, dGround.x, 0.4 );\n    \n    \n    d = dmin(d, dTrees.x,dTrees.y);\n    \n    d = dmin(d, dLeaves.x,dLeaves.y);\n    \n        \n    \n    \n    return d;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 prevFrame = texture(iChannel2,fragCoord\/iResolution.xy);\n    if(TAA){\n        vec2 taaidx = r23(vec3(fragCoord,float(iFrame)))*4.;\n        fragCoord += float(iMouse.z>0.)*.6*vec2(sin(float(taaidx.x)*pi\/4.),cos(float(taaidx.x)*pi\/4.))*taaidx.y\/4.;\n\n    }\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)\/iResolution.y;\n    vec2 muv = iMouse.xy\/iResolution.xy - 0.5;\n    vec3 col = vec3(0);\n    float T = iTime*1.4;\n    \n    vec3 sunDir = normalize(sunPos);\n    vec3 ro = vec3(0);\n    ro.z += T;\n    \n    \/\/ro.y -= getGround(ro).x;\n    ro += groundOffs;\n    ro += getPath(ro);\n    \n    vec3 lookAt = vec3(0,0,ro.z + 6.51);\n    \/\/lookAt.y -= getGround(lookAt).x;\n    lookAt += groundOffs;\n    lookAt += getPath(lookAt);\n    \n    \n    if(iMouse.z > 0.){\n        lookAt = vec3(\n            ro.x + sin(muv.x*tau - pi),\n            lookAt.y + muv.y*3. + 0.5,\n            ro.z + cos(muv.x*tau - pi)\n        );\n    \n    }\n\n    mat3 vp = getRd(ro,lookAt);    \n    \/\/vec3 rd = normalize(vec3(uv,1.))*vp;\n    vec3 rd = getRdUV(ro, lookAt, uv);\n    \n    \n    \/\/ Marching\n    \n    vec3 p = ro;\n    vec2 d;\n    for(int i = 0; i < marchSteps ; i++){\n        d = map(p);\n        \n        if(d.x < marchEps){\n            hit = true;\n            break;\n        } else if (t > 24.){\n            break;\n        }\n        \n        d = dmin(d,invisibleWall, 10.);\n        \n        p = ro + rd*(t += d.x * distScale);\n    }\n    \n    float depthView;\n    vec3 atmosphere = getAtmosphere(vec3(0,ro.y - 0.,0), rd, t, depthView);\n    \n\n    \n    \/\/ Wind\n    float volumetricDith = r21(fragCoord + sin(iTime*20.)*20.)*volumetricDithAmt;\n    \n    vec3 windP = ro + rd*volumetricDith*0.00 ;\n    float windStepSz = min(t,maxWindD)\/windSteps;\n    \n    vec3 windAccum = vec3(0);\n    float windDensTotal = 0.;\n    \/\/vec3 windAccum = vec3(0.);\n    \n    for(float i = 0.; i < windSteps ; i++){\n        vec3 wp = windP*0.51 - vec3(-iTime*0.5,smoothstep(0.,1.,windP.y*0.5 - 1.9),0.);\n        float dens = max(cyclicNoiseWind(wp,false,iTime),0.05)*0.461;\n        dens *= smoothstep(1.,0.,windP.y*0.01 + 0.4);\n        \n        vec3 c = mix(\n            vec3(1.4,1.1,0.67)*0.4,\n            vec3(0.2,0.44,0.47)*0.3,\n            \/\/smoothstep( 0., 1., abs(windP.x)*0.9 - 0.5)\n            smoothstep( 0., 1., length(rd.xy - sunDir.xy)*0.75 + 0.4)\n            \n            );\n        \n        c = mix( c*c*0.4, c, smoothstep(0.,1.,windP.y*0.15 + 0.1));\n        \n        \/\/dens *= aoVol(windP,1.,sunDir)*aoVol(windP,0.6,sunDir)*aoVol(windP,0.2,sunDir)*aoVol(windP,2.2,sunDir)*2.;\n        \/\/dens *= aoVol(windP,1.,sunDir)*aoVol(windP,0.6,sunDir)*aoVol(windP,0.2,sunDir)*aoVol(windP,2.2,sunDir)*2.;\n        \n        \n        dens = dens*(1.-windDensTotal);\n        windAccum += dens*windStepSz*c*1.;\n        windDensTotal += dens*windStepSz;\n        \n        \n        if( windDensTotal > 0.97){\n            break;\n        }\n        windP += rd*windStepSz;\n    }\n    \n\n    \/\/ Coloring\n    \n    vec3 hitCol = vec3(0);\n    vec3 ambientCol = atmosphere*1.;\n    if(hit){\n        vec3 n = getNormal(p);\n        if(d.y == 2.){\n            n = normalize(n + texture(iChannel3,p.xz).xyz)*0.7;\n            \n            n = normalize(n + texture(iChannel3,p.xz*0.2 + 3.).xyz);\n        }\n        \n        vec3 prevFrameMip = pow(max(texture(iChannel2,vec2(uv.x,-uv.y),7.).xyz, 0.),vec3(2.)) * float(iFrame > 0);\n        \n        vec3 hf = normalize(sunDir - rd);\n        float diff = max(dot(n,sunDir),0.);\n        float spec = pow(max(dot(n,hf),0.),29.);\n        float fres = pow( 1. - max(dot( n, -rd),0.001),5.);\n        fres = max(fres,0.);\n        \n        float AO = ao(2.9)*ao(0.2)*ao(1.)*ao(0.4)*2.;\n        float SSS = sss(.3)*sss(0.04)*sss(.1)*5.;\n        float shad = diff;\n        \n        vec3 albedo = vec3(0);\n        \n        vec3 treesCol = vec3(0);\n        {\n            albedo = 1.2*vec3(0.22,0.22,0.21)*(sunCol + atmosphere*0.4);\n            vec3 ambCol = albedo*(sunCol*0.2 + atmosphere*5.)*0.4;\n            vec3 aoCol = 0.4*albedo*albedo*(sunCol*0.3 + atmosphere*1.4);\n            \n            treesCol = mix(ambCol, albedo, shad);\n            treesCol = mix(aoCol, albedo, (AO - treebarkNoise*0.1));\n        }\n        vec3 groundCol = vec3(0.);\n        {\n            albedo = vec3(0.8,0.42,0.2)*0.1*(sunCol + prevFrameMip*224.4);\n            vec3 ambCol = albedo*(sunCol*0.2 + atmosphere*5.)*0.4;\n            vec3 aoCol = albedo*albedo*(sunCol*0.3 + atmosphere*1.4);\n            \n            groundCol = mix(ambCol, albedo, shad);\n            groundCol = mix(aoCol, albedo, AO);\n        }\n        vec3 leavesCol = vec3(0.);\n        {\n            \/\/albedo = vec3(0.8,0.42,0.2)*0.1;\n            \n            \/\/albedo = pal(0.5,0.5,vec3(1,2,1),1.,d.y);\n            \n            albedo = vec3(1.,0.1,0.2)*0.8;\n            \n            albedo += 1.;\n            \n            albedo.yz *= rot(-sin(d.y*20.)*0.1);\n            \n            albedo.xy *= rot(-sin(d.y)*0.1);\n            \n            albedo.xz *= rot(-sin(d.y*40.)*0.02);\n            \n            albedo -= 1.;\n            albedo *= sunCol + prevFrameMip;\n            albedo *= vec3(0.9,0.95,0.7);\n            \n            albedo *= 1. - smoothstep(0.5,0., abs(alleyUv.x) - pathW*1.1 )*vec3(1.,0.9,0.8)*0.76;\n            \n            vec3 ambCol = albedo*(sunCol*0.2 + prevFrameMip*2.)*0.4;\n            vec3 aoCol = albedo*albedo*albedo*(sunCol*0.1 + prevFrameMip*9.);\n            \n            leavesCol = mix(ambCol, albedo, shad);\n            leavesCol = mix(aoCol, albedo, AO);\n        }\n        \n        vec3 pathCol = vec3(0.);\n        {\n             \n            albedo = .6*vec3(0.11,0.1,0.1);\n            \n            float darkened = smoothstep(0.4,0., -abs(alleyUv.x) + pathW*0.5  + 0.05+ texture(iChannel1,alleyUv.xz).x*texture(iChannel1,alleyUv.xz*vec2(0.,0.05)).x*2.);\n            \n            albedo = mix(\n                albedo,\n                albedo*texture(iChannel1,alleyUv.xz).xyz + albedo*0.5,\n                darkened\n            );\n            \/\/albedo += ;\n            \n            vec3 ambCol = albedo*(sunCol*0.2  + prevFrameMip*24.4)*0.1;\n            vec3 aoCol = albedo*albedo*(sunCol*0.3 +  + prevFrameMip*24.4);\n            \n            \n            \n            pathCol = mix(ambCol, albedo, shad);\n            pathCol = mix(aoCol, albedo, AO*1.2);\n            pathCol += (smoothstep(0.4, 1.,alleyNoise) + 0.9)\n                *(spec*1.5 + fres*0.9)*3.9*(clamp(prevFrameMip,0.,.00) + vec3(0.,0.2,0.3)*0.008)*(1. - darkened*0.7);\n        }\n        \n        hitCol += groundCol*float(d.y == 1.);\n        hitCol += pathCol*float(d.y == 2.);\n        hitCol += treesCol*float(d.y == 3.);\n        hitCol += leavesCol*float(d.y >= 20.);\n        \n        \n        hitCol -= hitCol*float(d.y == 10.);\n        \n    }\n    \n\n    \/\/ Compositing\n    \n    col += hitCol;\n    \n    if(hit){\n       atmosphere *= 1.-pow(exp(-(t)*.04 ),2.);\n    }\n    \n    \/\/atmosphere += getSun(rd.xy, sunDir.xy, ro, vp);\n    \n    atmosphere*=0.04;\n    float depthViewFac = smoothstep(0.,1.,exp(-depthView*0.02) + exp(-t*0.4));\n    \n    col = col * depthViewFac + atmosphere; \n    \n    \/*\n    if (!hit  && lowerCloudLimitDist > 0.){\n        cloudAccum = mix(cloudAccum,col,clamp(1.-exp(-lowerCloudLimitDist*0.01 + 0.4),0.,1.));\n        col = mix(col,cloudAccum*1. , pow(clamp(cloudDensTotal*1. - 0.,0.,1.),4.));\n    }\n    *\/\n    \/\/windAccum *= smoothstep(0.,1.,t*0.2 - 1.);\n    col = mix(col, windAccum, pow(windDensTotal,1.));\n    \n    \/\/col = (col - windDensTotal) + 1.*windAccum;\n    \n    if(TAA && iFrame >1 && iMouse.z < 1.){\n        fragColor = mix(prevFrame, col.xyzz,0.4);\n    } else {\n        fragColor = col.xyzz;\n    }\n    \n    \n    \n    \n    \/\/fragColor.w = cloudDensTotal + float(hit)*1.;\n    fragColor.w = 1.;\n\n}\n\n\nvec3 getNormal(vec3 p){\n      vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*0.02).x;\n    }\n    return normalize(n);\n}\n\n\nvec3 getSun(vec2 uv, vec2 sunPosU, vec3 ro, mat3 vp){\n    \n    vec3 sunPosW = sunPos;\n    vec2 sunUVOriginal = uv;\n    vec2 sunUV = uv - sunPosU;\n    \/\/float cloudDensPrevFrame = texture(iChannel2, ((sunUV*iResolution.y + 0.5*iResolution.xy)\/iResolution.xy)).w;\n    \n    \/\/vec2 sunUvPrevFrame = (normalize(sunPosW - ro)*inverse(getRd(ro,sunPosW))).xy;\n    vec2 sunUvPrevFrame = (normalize(sunPosW - ro)*inverse(vp)).xy;\n    \n    sunUvPrevFrame = (sunUvPrevFrame*iResolution.y)\/iResolution.xy + 0.5;\n    \n    float deltaUV = 0.04;\n    float cloudDensPrevFrame = \n        texture(iChannel2, sunUvPrevFrame + deltaUV).w\n        + texture(iChannel2, sunUvPrevFrame - deltaUV).w\n        + texture(iChannel2, sunUvPrevFrame + vec2(-deltaUV,deltaUV)).w\n        + texture(iChannel2, sunUvPrevFrame + vec2(deltaUV,-deltaUV)).w\n        ; \n    \n    cloudDensPrevFrame \/= 4.;\n    \n    cloudDensPrevFrame = clamp(cloudDensPrevFrame,0.,1.);\n    \/\/ sun\n    vec3 sun = sunCol*smoothstep(0.07,0.,length(sunUV));\n    sun += sunCol*vec3(1.,0.4,0.6)*smoothstep(0.1,0.,length(sunUV));\n    sun += sunCol*vec3(0.7,0.4,0.6)*smoothstep(0.3,0.,length(sunUV))*0.5;\n    sun += sunCol*vec3(0.3,0.4,0.6)*smoothstep(0.6,0.,length(sunUV))*0.35;\n    \n    \n    \/\/ rays\n    \n    \n    vec3 sunRays = 0.4*sunCol * smoothstep(0.015*(1. + smoothstep(1.,0.,abs(sunUV.x)) ) ,0.,abs(sunUV.y))*smoothstep(0.5,0.,abs(sunUV.x));\n    \n    for(float i = 0.; i < 8.; i++){\n        sunUV *= rot(pi\/8.\/1.);\n        float mda = sin(i*pi\/4.);\n        float mdb = sin(i*pi\/2.);\n        float w = 0.03;\n        float l = 0.1;\n        sunRays += (sunCol) *\n            mix(.8,.1,smoothstep(0.,0.25 +  sin(i*pi\/ 4. + iTime)*0.1,length(sunUV))) *\n            smoothstep(w + mda*w\/4.,0.,abs(sunUV.y))*smoothstep((l + mdb*0.1)*1.5,0.,abs(sunUV.x));\n    }   \n    sunUV = sunUVOriginal - sunPosU;\n    vec3 flares = vec3(0);\n    vec2 toMid = sunPosU;\n    vec2 dirToMid = -normalize(toMid);\n    float lenToMid = length(toMid);\n\n    \/\/ flares\n    for(float i = 0.; i < 12.; i++){\n          sunUV -= 2.*lenToMid*dirToMid\/12.;\n          float dfl = length(sunUV) - (0.1 + 0.1*sin(i*5.))*0.5;\n          dfl *= 0.5;\n          vec3 flare = 0.01*(sunCol)*smoothstep(0.02,0.,dfl);\n          flare += 0.003*(sunCol*sunCol)*smoothstep(0.01,0.,abs(dfl - dFdx(uv.x)));\n          flares += flare*abs(sin(i*10.));\n    }   \n    \n    \n    return (sun + sunRays + flares*3.*sunCol) * (1. - cloudDensPrevFrame*1.);\n}\n\n",
            "name": "Buffer A",
            "description": "",
            "type": "buffer"
        },
        {
            "inputs": [
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "XsXGR8",
                    "channel": 0
                }
            ],
            "code": "\nfloat FXAAamt = 0.5;\n\n\n\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n    vec2 p = fragCoord.xy\/iResolution.xy;\n    vec2 pp = 1. \/ iResolution.xy;\n    vec4 color = texture(iChannel0, vec2(fragCoord.xy * pp));\n    vec3 luma = vec3(.299, 0.587, 0.114);\n    \n    float lumaNW = dot(texture(iChannel0, (fragCoord.xy + vec2(-1.0, -1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaNE = dot(texture(iChannel0, (fragCoord.xy + vec2(1.0, -1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaSW = dot(texture(iChannel0, (fragCoord.xy + vec2(-1.0, 1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaSE = dot(texture(iChannel0, (fragCoord.xy + vec2(1.0, 1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaM  = dot(color.xyz,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir = vec2(-((lumaNW + lumaNE) - (lumaSW + lumaSE)), ((lumaNW + lumaSW) - (lumaNE + lumaSE)));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * (1.0\/8.0)), (1.0\/128.0));\n\n    float rcpDirMin = 2.5 \/ (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(8.0, 8.0),\n              max(vec2(-8.0, -8.0),\n              dir * rcpDirMin)) * pp;\n\n    vec3 rgbA = 0.5 * (\n        texture(iChannel0, fragCoord.xy * pp + dir * (1.0 \/ 3.0 - 0.5)).xyz +\n        texture(iChannel0, fragCoord.xy * pp + dir * (2.0 \/ 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n        texture(iChannel0, fragCoord.xy * pp + dir * -0.5).xyz +\n        texture(iChannel0, fragCoord.xy * pp + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax)){\n        fragColor = vec4(rgbA, color.w);\n    } else {\n        fragColor = vec4(rgbB, color.w);\n    }\n\n}",
            "name": "Buffer B",
            "description": "",
            "type": "buffer"
        }
    ]
}