{
    "ver": "0.1",
    "info": {
        "id": "tdtyDs",
        "date": "1602165188",
        "viewed": 4116,
        "name": "Asymmetric Hexagon Landscape",
        "username": "Shane",
        "description": "A landscape of extruded asymmetric hexagonal blocks with offset vertices tailored to resemble randomly packed polygons.",
        "likes": 103,
        "published": 3,
        "flags": 0,
        "usePreview": 1,
        "tags": [
            "voronoi",
            "terrain",
            "hexagon",
            "city",
            "extrude"
        ],
        "hasliked": 0
    },
    "renderpass": [
        {
            "inputs": [
                {
                    "id": "4sXGRn",
                    "filepath": "\/media\/a\/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg",
                    "previewfilepath": "\/media\/ap\/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg",
                    "type": "texture",
                    "channel": 1,
                    "sampler": {
                        "filter": "mipmap",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "4dX3Rr",
                    "filepath": "\/media\/a\/\/media\/previz\/cubemap00.png",
                    "previewfilepath": "\/media\/ap\/\/media\/previz\/cubemap00.png",
                    "type": "cubemap",
                    "channel": 0,
                    "sampler": {
                        "filter": "nearest",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dfGRr",
                    "channel": 0
                }
            ],
            "code": "\/*\n\n    Asymmetric Hexagon Landscape\n    ----------------------------\n\n\tJust for fun, I coded up a landscape of extruded asymmetric hexagonal blocks \n    tailored to resemble randomly packed polygons. It's more of a proof of concept \n    than anything else. I think it runs well enough, and I've documented the code \n    to a certain degree, but I wouldn't take any of it too seriously. I had the \n    idea to do this when I was in Bavaria back in March, so that provided minor \n    inspiration for the design. It's rendered in an abstract low-poly cartoon style.\n\n\tThe code was hastily put together with old projects and makes use of something\n\tI constructed in 2D a long time ago when attempting to produce a fast random \n    Delaunay pattern. The idea is simple in concept, since it's nothing more than a \n    grid of hexagons with offset vertices. The Delaunay pattern I was after turned \n    out to be less interesting than I'd hoped for, due to the restricted offsets \n    involved. However, I always figured it'd look pretty cool in extruded form. The \n    thing holding me back was the usual speed constraints. In fact, speed was not \n    the primarily concern, but rather the painful buffer setup and wrapping \n    considerations required to make it fast. By the way, apologies in advance for\n\tthe longer compile time; I'll try to get that down later.\n\n\tMattz and IQ have already posted some pretty cool hexagon related traversals,\n\tand I'm pretty sure Abje -- who puts together a lot of clever stuff that slips\n\tunder the radar -- has already produced a Voronoi prism cell traverser, along \n    with a couple of other people. Fizzer's basically constructed every traversal \n    at one point or another, so I guess I'm saying that this isn't an entirely new \n    concept. Having said that, it is unique in the sense that it consists of \n    rounded asymmetric hexagons, plus it's a buffer-stored raymarched field that \n    can render pretty quickly... if you have a machine that works well reading \n    textures. I won't go as far as to say that it's an extruded straight edged \n    Voronoi grid, but it definitely has that kind of feel to it.\n\t\n    There are too many possible improvements and enhancements to name. There are \n    provisions within the code for neighboring hexagon checks, which allows for all \n    kinds of features like bridges, stairs, etc, but of course that would add to \n    the complexity. Either way, I'd like to do something along those lines at some \n    stage. For anyone interested, I'll put up a simple version featuring just the\n\toffset hexagons soon.\n\n    \n\n\tOther examples:\n\n\t\/\/ I've always been a fan of Tomkh's work.\n    Voronoi Column Tracing -  Tomkh \n\thttps:\/\/www.shadertoy.com\/view\/4lyGDV\n    Base on:\n    Reactive Voronoi - Glk7\n    https:\/\/www.shadertoy.com\/view\/Ml3GDX\n    \n\t\/\/ Here's a proper Voronoi traverser. Like all TekF's stuff, it's \n    \/\/ very stylish and confusingly fast. :)\n    TekF - Infinite City \n\thttps:\/\/www.shadertoy.com\/view\/4df3DS\n\n\n*\/\n\n\n\n\n\/\/ Max ray distance.\n#define FAR 20.\n\n\n\n\/\/ Scene object ID to separate the mesh object from the terrain.\nfloat objID;\n\n\n\/\/ The path is a 2D sinusoid that varies over time, which depends upon the frequencies and amplitudes.\nvec2 path(in float z){ \n    \n    \/\/return vec2(0);\n    return vec2(3.*sin(z*.1) + .5*cos(z*.4), .25*(sin(z*.875)*.5 + .5));\n}\n\n\n\n\/\/ Tri-Planar blending function: Based on an old Nvidia writeup:\n\/\/ GPU Gems 3 - Ryan Geiss: http:\/\/http.developer.nvidia.com\/GPUGems3\/gpugems3_ch01.html\nvec3 tex3D(sampler2D tex, in vec3 p, in vec3 n){    \n    \n    \/\/ Ryan Geiss effectively multiplies the first line by 7. It took me a while to realize that \n    \/\/ it's largely redundant, due to the division process that follows. I'd never noticed on \n    \/\/ account of the fact that I'm not in the habit of questioning stuff written by Ryan Geiss. :)\n    n = max(n*n - .2, .001); \/\/ max(abs(n), 0.001), etc.\n    n \/= dot(n, vec3(1)); \n    \/\/n \/= length(n); \n    \n    \/\/ Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    \/\/ Multiply each texture plane by its normal dominance factor.... or however you wish\n    \/\/ to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    \/\/ represnting the XZ plane, will be used, which makes sense.\n    \n    \/\/ Textures are stored in sRGB (I think), so you have to convert them to linear space \n    \/\/ (squaring is a rough approximation) prior to working with them... or something like that. :)\n    \/\/ Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; \/\/ Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n\n\n\/\/ The height map. It was orginally supposed to be a fast texture call, but then\n\/\/ I was insistent on creating a valley that followed the camera path, which would\n\/\/ be pretty difficult to encode into a repeat texture... Anyway, it's slower now,\n\/\/ but within acceptable ranges.\nfloat hmBlock(in vec2 p){ \n    \n    \/\/vec2 q = p; \n    \n    \/\/ Wrapping things around the camera path.\n    vec2 pth = path(p.y);\n    p -= pth; \/\/ Y is the Z coordinate here.\n    \n    float d = abs((p.x + .5) - .5)*2.;\n    \n    \/\/ Scaling by 1\/16 and snapping to repeat texture pixels. Alternatively, you \n    \/\/ can change the cube map filter to \"nearest\" and save a calculation, which\n    \/\/ is what I've done.\n    p \/= 16.;\n    \/\/ p = (floor(p*1024.\/16.) + .5)\/1024.;  \n    \n    \/\/ Retrieving the height value from the precalculated wrapped texture map.\n    float h = tx5(iChannel0, p).x; \n                    \n    \/\/ Carving out a path.\n    h = mix(h + pth.y,  h\/1.5 + pth.y\/2., 1. - smoothstep(0., .75, d - .15));\n    \n    \/\/ Quantizing the height levels. More expensive, but it looks a little neater.\n    #ifdef QUANTIZE_HEIGHT\n    h = floor(h*(LEVELS + .999))\/LEVELS; \n    #endif\n    h = max(h, WLEV\/LEVELS);\n\/*\n    if(h<= WLEV\/LEVELS + .001) {\n            \n            float sf = dot(sin(q*8. - cos(q.yx*16. + iTime*2.)), vec2(.012)) - .024;\n            \/\/h += sf;\n    }\n*\/\n    return h;  \n}\n\n\n\n\n\/\/ A regular extruded block grid.\n\/\/\n\/\/ The idea is very simple: Produce a normal grid full of packed square pylons.\n\/\/ That is, use the grid cell's center pixel to obtain a height value (read in\n\/\/ from a height map), then render a pylon at that height.\n \n\/\/ Global vertices, local coordinates of the offset hexagon cell, plus the extruded \n\/\/ face information. It's lazy putting them here, but I'll tidy them up later.\nvec4[3] gV;\nvec2 gP;\nfloat d2D;\n\n\nvec4 blocks(vec3 q){\n    \n    \n    \n    \/\/ Pulling in the 4 precalculated offset values from their respective\n    \/\/ cube map faces.\n    \/\/\n    \/\/ By the way, calculating the minimum 2D face distance, then using it to\n    \/\/ render the extruded block doesn't work... It'd be nice, but you have to\n    \/\/ compare all 4 extruded blocks... It's obvious, yet if I haven't done this\n    \/\/ for a while, it's the first thing I try. :D\n    vec2 uv = (floor(q.xy*1024.) + .5)\/1024.;\n    vec4 p40 = tx0(iChannel0, uv);  \/\/ The 2D distance fields.  \n    \/\/ Precalculated heights. These would have tripled the speed, but\n    \/\/ unforturnately weren't practical for this particular example.\n    \/\/vec4 p45 = tx5(iChannel0, uv); \n\n    #ifndef QUANTIZE_WATER\n    \/\/ Continuous water levels, meaning the water appears as a wavy coninuous plane.\n    float sf = dot(sin(q*8. - cos(q.zxy*16. + iTime*2.)), vec3(.006)) - .018;\n    #endif\n    \n    \/\/ Block dimension: Length to height ratio with additional scaling. By the way,\n    \/\/ I'm being sneaky here and not applying the vec2(.8660254, 1) stretch scaling\n    \/\/ that gives you proper scaled hexagons. One reason is that they're mutated by\n    \/\/ the offset vertices anyway, and the main one is that it makes wrapping more\n    \/\/ difficult. Not impossible, but more complicated.\n\tconst vec2 dim = GSCALE;\n    \/\/ A helper vector, but basically, it's the size of the repeat cell.\n\tconst vec2 s = dim*2.; \n \n    \n    \/\/ Distance.\n    float d = 1e5;\n    \/\/ Cell center, local coordinates and overall cell ID.\n    vec2 p, ip;\n    \n    \/\/ Individual brick ID.\n    vec2 id = vec2(0);\n    vec2 cntr = vec2(0);\n\n    \/\/ Four block corner postions.\n    const vec2 ll = vec2(.5);\n    \/\/vec2[4] ps4 = vec2[4](vec2(-ll.x, ll.y), ll, -ll, vec2(ll.x, -ll.y));\n    \/\/ Pointed top.\n    #ifdef FLAT_TOP\n    \/\/ Flat top.\n    vec2[4] ps4 = vec2[4](vec2(-ll.x, ll.y), ll + vec2(0., ll.y), -ll, vec2(ll.x, -ll.y) + vec2(0., ll.y));\n    #else\n    \/\/ Pointed top.\n    vec2[4] ps4 = vec2[4](vec2(-ll.x, ll.y), ll, -ll + vec2(ll.x, 0), vec2(ll.x, -ll.y) + vec2(ll.x, 0));\n    #endif   \n  \n\n    d2D = 1e5;\n    \n    float hexH = 0.; \/\/ Hexagon pylon height.\n    \n    \n\n    \/\/ Height scale.\n    const float hs = .6;\n\n\n    \/\/ Initializing the global vertices and local coordinates of the hexagon cell.\n    gV = vec4[3](vec4(0), vec4(0), vec4(0));\n    gP = p;\n    \n    for(int i = 0; i<4; i++){\n\n        \/\/ Block center.\n        cntr = ps4[i]\/2.; \n        \n        p = q.xy; \/\/ Local coordinates.\n        ip = floor(p\/s - cntr) + .5; \/\/ Local tile ID.\n        p -= (ip + cntr)*s; \/\/ New local position.\n        \n        \/\/ Correct positional individual tile ID.\n        vec2 idi = ip + cntr;\n \n        \/\/ Hexagon vertices. \n        vec4[3] vert = vID;\n\n        \n        #ifdef OFFSET_VERTICES\n        \/\/ Offsetting the vertices. Note that accuracy is important here. I had a bug for\n        \/\/ a while because I was premultiplying by \"s,\" to save some calculations, which meant\n        \/\/ points were not quite meeting at the joins... I won't bore you with the rest,\n        \/\/ except to say that it's necessary to keep these numbers simple.\n         \n        vec4 vrt0 = idi.xyxy + vert[0]\/2.;\n        vec4 vrt1 = idi.xyxy + vert[1]\/2.;\n        vec4 vrt2 = idi.xyxy + vert[2]\/2.;\n        vrt0 = hash42B(vrt0);\n        vrt1 = hash42B(vrt1);\n        vrt2 = hash42B(vrt2);\n         \n        const float vo = .15;\n        vert[0] += vrt0*vo;\n   \t\tvert[1] += vrt1*vo;\n        vert[2] += vrt2*vo;\n        \/\/vert[3] += vrt1.zw*vo;\n        \/\/vert[4] += vrt2.xy*vo;\n        \/\/vert[5] += vrt2.zw*vo;\n        #endif\n \n        \n        \/\/ Scaling to enable rendering back in normal space.\n        vert[0] *= dim.xyxy;\n        vert[1] *= dim.xyxy;\n        vert[2] *= dim.xyxy;\n\n        \n        \/\/ Scaling the ID.\n\t    idi *= s;\n         \n        \n        \/\/ Offset hexagon center.\n        \/\/vec2 inC = vec2(0);\n        \/\/ Preferred, but not necessary and it's a huge bottleneck, which surprises me.\n        \/\/vec2 inC = (vert[0].xy + vert[0].zw + vert[1].xy + vert[1].zw + vert[2].xy + vert[2].zw)\/6.;\n        \/\/vec2 idi1 = idi + inC;\n        \n        \/\/ Stored 2D rounded offset hexagon face distance information. Without this, \n        \/\/ the example would fry your GPU.\n        float face1 = p40[i];\n        \/\/ float face1 = sdPoly(p, vert); \n  \n        \n        float h1 = hmBlock(idi); \/\/p42[i] For future stored heights.\n      \n        \/\/ Animating the water levels. I added this at the last minute, so there'd\n        \/\/ be better ways to go about it.\n        if(h1<= WLEV\/LEVELS + .001) {\n            \n            #ifdef QUANTIZE_WATER\n            float sf = dot(sin(idi*8. - cos(idi.yx*16. + iTime*2.)), vec2(.012)) - .024;\n            #endif\n            h1 += sf;\n        }\n\n        h1 *= hs; \/\/ Height scaling.\n        \n        \/\/ Extruded offset hexagon.\n        float face1Ext = opExtrusion(face1, (q.z - h1), h1); \n        \n        face1Ext += max(face1, -.015)*.5;\n         \n        \/\/ Adding the top to the heigher pylons to act as roofs.\n        #ifdef ARID\n        if(h1>.4) face1Ext += face1*.35;\n        #else\n        if(h1>.4) face1Ext += face1*(h1*.6 + .25); \n        #endif\n\n        \n        \/\/ If applicable, update the overall minimum distance value,\n        \/\/ ID, and box ID. \n        if(face1Ext<d){\n            d = face1Ext;\n            id = idi;\n            hexH = h1;\n       \n            \n            \/\/ Setting the vertices and local coordinates.\n            gV = vert;\n            gP = p;\n            \n            d2D = face1;\n     \n        }\n        \n    }\n    \n    \/\/ Return the distance, position-based ID and triangle ID.\n    return vec4(d, id, hexH);\n}\n\n\n\n\/\/ Block ID -- It's a bit lazy putting it here, but it works. :)\nvec4 gID;\n\n\/\/ The extruded image.\nfloat map(vec3 p){\n    \n    \/\/ Floor.\n    float fl = p.y;\n\n    \/\/ The extruded blocks.\n    vec4 d4 = blocks(p.xzy);\n    gID = d4; \/\/ Individual block ID.\n \n \n    \/\/ Overall object ID.\n    objID = fl<d4.x? 1. : 0.;\n    \n    \/\/ Combining the floor with the extruded image\n    return min(fl, d4.x);\n \n}\n\n \n\/\/ Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    \/\/ Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    for(int i = 0; i<96; i++){\n    \n        d = map(ro + rd*t);\n        \/\/ Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        \/\/ \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001*(1. + t*.1) || t>FAR) break; \/\/ Alternative: 0.001*max(t*.25, 1.), etc.\n        \n        t += i<32? d*.5 : d*.75; \n        \/\/t += d*.8; \n    }\n\n    return min(t, FAR);\n}\n\n\n\/\/ Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\tconst vec2 e = vec2(.001, 0);\n    \n    \n    \/\/vec3 n = normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n    \/\/map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n    \n    float sgn = 1.;\n    vec3 n = vec3(0);\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp[i] = map(p + sgn*e6[i\/2]);\n        sgn = -sgn;\n        if(sgn>2.) break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\n\n\/\/ Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n\/\/ iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    \/\/ More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 32; \n    \n    ro += n*.0011;\n    vec3 rd = lp - ro; \/\/ Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.;\/\/.0015; \/\/ Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    \/\/float stepDist = end\/float(maxIterationsShad);\n    rd \/= end;\n\n    \/\/ Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    \/\/ number to give a decent shadow is the best one to choose. \n    for (int i = 0; i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d\/t);\n        \/\/shade = min(shade, smoothstep(0., 1., k*h\/dist)); \/\/ Subtle difference. Thanks to IQ for this tidbit.\n        \/\/ So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        \n        \/\/ Note the ray shortening hack here. It's not entirely accurate, but reduces\n        \/\/ shadow artifacts slightly for this particular stubborn distance field.\n        t += clamp(d*.8, .01, .25); \n        \n        \n        \/\/ Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    \/\/ Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    \/\/ It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    \/\/ AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n\/\/ I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n\/\/ Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 1.5, occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15\/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        if(sca>1e5) break; \/\/ Compiler related.\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n    \n    \n}\n\n\/\/ Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n\/\/ example that explains it, if you require it.\nfloat n3D(in vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); \/\/p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); \/\/ Range: [0, 1].\n}\n\n\/\/ Very basic pseudo environment mapping... and by that, I mean it's fake. :) However, it \n\/\/ does give the impression that the surface is reflecting the surrounds in some way.\n\/\/\n\/\/ More sophisticated environment mapping:\n\/\/ UI easy to integrate - XT95    \n\/\/ https:\/\/www.shadertoy.com\/view\/ldKSDm\nvec3 envMap(vec3 p){\n    \n    p *= 3.;\n    \/\/p.y += iTime;\n    \n    float n3D2 = n3D(p*2.);\n   \n    \/\/ A bit of fBm.\n    float c = n3D(p)*.57 + n3D2*.28 + n3D(p*4.)*.15;\n    c = smoothstep(.4, 1., c); \/\/ Putting in some dark space.\n    \n    p = vec3(c, c*c, c*c); \/\/ Redish tinge.\n    \n    return mix(p, p.xzy, n3D2*.4); \/\/ Mixing in a bit of purple.\n}\n\n\/\/ Window distance field.\nfloat distW(vec2 p, float sc){\n    \n    \/\/ Some hastily constructed arch windows consisting\n    \/\/ of A square with a semi circle on top.\n    p.y -= -sc*1.25\/3.;\n    float ci = length(p - vec2(0, sc*1.25)) - sc;\n    float sq = sBox(p, vec2(sc, sc*1.25));\n    return min(ci, sq);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    \/\/ Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)\/iResolution.y;\n\t\n\t\/\/ Camera Setup.\n\tvec3 ro = vec3(0, 1.15, iTime); \/\/ Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(0, -.2, .25);\/\/vec3(0, -.25, iTime);  \/\/ \"Look At\" position.\n    \n    \/\/ Light positioning. Near the camera.\n \tvec3 lp = ro + vec3(-.185, 0, -.625);\/\/ Put it a bit in front of the camera.\n    \n    \n    \/\/ Moving the camera along the path.\n\tro.xy += path(ro.z); \n    lk.xy += path(lk.z); \n    \/\/ Artificially moving the light with the camera to give it point light and distant \n    \/\/ light qualities... Not accurate, but good enough for the purpose of the example.\n    lp.xy += path(lp.z); \n\n    \/\/ Using the above to produce the unit ray-direction vector.\n    float FOV = 1.; \/\/ FOV - Field of view.\n    vec3 fwd = normalize(lk - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    \/\/ \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    \/\/ assuming no normalization is necessary? The only reason I ask is that lots of people do \n    \/\/ normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    \/\/ rd - Ray direction.\n    \/\/vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd\/FOV);\n    \n    \/\/ Swiveling the camera about the XY-plane.\n\trd.xy *= rot2(path(ro.z).x\/32.);\n\n    \/\/ Setting the global time variable so that the \"Common\" tab can recognize time.\n    setTime(iTime);\n\n\t \n    \n    \/\/ Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    \/\/ Save the block ID and object ID.\n    vec4 svGID = gID;\n    \n    float svObjID = objID;\n    \n    vec2 svP = gP;\n    vec2[6] svV = vec2[6](gV[0].xy, gV[0].zw, gV[1].xy, gV[1].zw, gV[2].xy, gV[2].zw);\n    \/\/float svH = gH;\n    \n    float svD2D = d2D;\n  \n\t\n    \/\/ Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t\/\/ The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t\/\/ Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    \/\/vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp, t);\n        \n          \n        \/\/ Obtaining the texel color. \n\t    vec3 texCol;   \n\n        \/\/ The extruded grid.\n        if(svObjID<.5){\n            \n            \n            \/\/ Colored block, for debug purposes.\n            \/\/vec3 rCol = .5 + .45*cos(6.2831*(svGID.w)\/2. + vec3(2, 1, 0) + 2.);\/\/hash21(svGID.yz)\n             \n            \/\/ Weighted center offset, so to speak.\n            \/\/vec2 dt = (svV[0] + svV[1] + svV[2] + svV[3] + svV[4] + svV[5])\/6.;\n       \n            \n            \/\/ Coloring, based on extruded hexagonal block height. \n            \/\/ It was a bit fiddly, but none of it was difficult...\n            \/\/ On second thoughts, I didn't enjoy painting the windows\n            \/\/ on the sides of the offset hexagons, but the rest was OK. :)\n            \n            \/\/ Hexagon pylon face ring.\n            vec3 tCol;\n            float hex = svD2D; \/\/sdPoly(svP, svV);\n            hex = max(abs(hex), abs(sp.y - svGID.w*2.)) - .001;\n             \n            \n            \n            \/\/ This looks like a bit of a mess, but it's pretty simple: Each \n            \/\/ pylon has a face top, and some sides. There are three different\n            \/\/ height levels, which have different top and side colors. The\n            \/\/ top level represents the buildings, the middle represents the\n            \/\/ the surrounding land, and the bottom represents water. The coloring\n            \/\/ is common sense.\n            \n            \n            \/\/ Building colors, depending on the Bavarian looking landscape \n            \/\/ or the arid one. By the way, the define can be found in the\n            \/\/ \"Common\" tab.\n            #ifdef ARID\n            float ra = hash21(svGID.yz + .53);\n            vec3 rnd2 = vec3(ra, ra*.8, ra*ra*.5);\n            \n            texCol = vec3(1, .98, .9);\n            tCol = vec3(1, .45, .4); \n            \/\/tCol = vec3(.85, .6, .45);\n            texCol = clamp(texCol*.9 + rnd2*.2, 0., 1.);\n            tCol = clamp(tCol*.9 + rnd2*.2, 0., 1.);\n            #else\n            float ra = hash21(svGID.yz + .53);\n            vec3 rnd2 = vec3(ra, ra*.9, ra*.8);\n            \n            texCol = vec3(1, .98, .95);\n            tCol = vec3(1, .2, .2);\n            texCol = clamp(texCol*.8 + rnd2*.4, 0., 1.);\n            tCol = clamp(tCol*.8 + rnd2*.4, 0., 1.);\n            #endif\n            \n           \n            \/\/ Grass colors.\n            if(svGID.w<.4) { \n                \n                \/\/ tCol = mix(tCol, vec3(1)*dot(tCol, vec3(.299, .587, .114)), 1.);\n                \n                #ifdef ARID\n                texCol = vec3(.8, .6, .45)*vec3(1, 1.05, .95);\n                tCol = vec3(.7, .5, .4)*vec3(1, 1.05, .95); \n                \/\/texCol = mix(texCol, vec3(1)*dot(tCol, vec3(.299, .587, .114)), .2);\n                tCol = mix(tCol, vec3(1)*dot(tCol, vec3(.299, .587, .114)), .2);\n                texCol = clamp(texCol*.9 + rnd2*.2, 0., 1.);\n                \n               \n                tCol = clamp(tCol*.9 + rnd2*.2, 0., 1.);\n                #else\n                texCol = vec3(.8, .5, .3);\n                tCol = vec3(.35, .65, .3);\/\/vec3(.8, .5, .3);\n                texCol = clamp(texCol*.8 + rnd2*.4, 0., 1.);\n                tCol = clamp(tCol*.8 + rnd2*.4, 0., 1.);\n                #endif\n                \n                \n                 \n            }\n            \n            \/\/tCol *= vec3(1.4, 1.3, 1.1);\n            \/\/texCol = mix(texCol*vec3(1.4, 1.3, 1.1), tCol, .5);\n            \n            \n            \/\/ Water colors.\n            if(svGID.w<= WLEV\/LEVELS*.6 + .001) { \n                texCol = vec3(.35, .65, 1);\n                tCol = vec3(.25, .5, 1);\n                \n                #ifdef ARID\n                texCol = clamp(texCol*.85 + rnd2.zyx*.3, 0., 1.)*vec3(.9, .95, 1);\n                tCol = clamp(tCol*.85 + rnd2.zyx*.3, 0., 1.)*vec3(.9, .95, 1);\n                #else\n                texCol = clamp(texCol*.9 + rnd2.zyx*.2, 0., 1.)*vec3(.8, .9, 1);\n                tCol = clamp(tCol*.9 + rnd2.zyx*.2, 0., 1.)*vec3(.8, .9, 1);\n                #endif\n            }\n            \n            \n            \/\/ Extra random colors, just to mix things up. It's a simple trick to\n            \/\/ to make colors just a little more interesting.\n            vec3 rnd3 = vec3(hash21(svGID.yz + .73), hash21(svGID.yz + .51), hash21(svGID.yz)) - .5;\n            texCol = clamp(texCol + rnd3*.1, 0., 1.);\n            tCol = clamp(tCol - rnd3*.1, 0., 1.);\n              \n            \/\/ Applying the top face color and the side color.\n            texCol = mix(texCol, tCol, (1. - smoothstep(0., .002, -(sp.y - svGID.w*2.)))*1.);\n            texCol = mix(texCol, vec3(0), (1. - smoothstep(0., .002, hex)));\n           \n            \n            \n            \/\/ Painting the window on the sides of the top level hexagons. My brain was \n            \/\/ fighting me on this every step of the way, so I'm glad it's over. :D\n            float win = 1e5;\n            \n            if(svGID.w>.4){ \n                \n                \n                \/\/vec2 ctr = (svV[0] + svV[1] + svV[2] + svV[3] + svV[4] + svV[5])\/6.;\n\n                for(int j = 0; j<6; j++){\n                    \n                    \n                    \/\/ Random window ID.\n                    float wRnd = hash21(svGID.yz + floor((sp.y - svGID.w*2.)\/(1.\/LEVELS*.6*2.)) + float(j));\n                    \n                    \/\/ Skip the occasional window.\n                    if(wRnd<.35) continue;\n\n                    \/\/ Current and next vertices.\n                    vec2 g = svV[j];\n                    vec2 g1 = svV[(j + 1)%6];\n                    \/\/vec2 g2 = svV[(j + 5)%6];\n                    \/\/ Tangent normal.\n                    vec2 nj = normalize(g1 - g).yx*vec2(1, -1);\n\n                    \/\/ 3D hexagon center position.\n                    vec3 cv = vec3(svP.x, \n                                   mod(sp.y - svGID.w*2., 1.\/LEVELS*.6*2.) - .5\/LEVELS*.6*2., \n                                   svP.y);\n               \n                    \/\/ Mid edge position and angle.\n                    vec2 gg = mix(g, g1, .5);\n                    float ang = atan(gg.y, gg.x);\n                    \n                    \/\/ Polar coordinates.\n                    vec2 spos = vec2(cos(ang), sin(ang))*length(gg);\n                    vec2 newP = rot2(-atan(nj.x, nj.y))*(svP - spos);\n                    \n                    \/\/ Window base and height.\n                    cv.xy = vec2(max(abs(newP.x), abs(newP.y)), cv.y);\n                     \n                    \/\/ Create the window for this particular hexagonal side.\n                    float wSize = hash21(svGID.yz + .71)*.075 + .2;\n                    win = min(win, distW(cv.xy, 1.\/LEVELS*.6*wSize*8.*GSCALE.x));\n\n                }\n                \n                \/\/ Render the windows.\n                win = max(win, sp.y - svGID.w*2.);\n                texCol = mix(texCol, vec3(.1, .05, .03), (1. - smoothstep(0., .003, win - .002))*.5);\n                texCol = mix(texCol, vec3(0), 1. - smoothstep(0., .003, win));\n                texCol = mix(texCol, vec3(.1, .05, .03), 1. - smoothstep(0., .003, win + .005));\n                 \n            }\n  \n  \n            \/\/ Adding a bit of texture.\n            vec3 tx = tex3D(iChannel1, sp*4., sn);\n            tx = smoothstep(.0, .5, tx);\n            texCol *= tx*.6 + .6;\n        }\n        else {\n            \n            \/\/ The dark floor in the background. Hiddent behind the pylons, but\n            \/\/ you still need it.\n            texCol = vec3(0);\n        } \n        \n       \n       \n    \t\n    \t\/\/ Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        \/\/ Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t\/\/ Normalize the light direction vector.\n\t    ld \/= lDist;\n\n        \n        \n        \/\/ Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 16.);\n    \tfloat ao = calcAO(sp, sn); \/\/ Ambient occlusion.\n        sh = min(sh + ao*.0, 1.);\n\t    \n\t    \/\/ Light attenuation, based on the distances above.\n\t    float atten = 1.\/(1. + lDist*.05);\n\n    \t\n    \t\/\/ Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        \/\/diff = pow(diff, 2.)*1.35; \/\/ Ramping up the diffuse.\n    \t\n    \t\/\/ Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 32.); \n\t    \n\t    \/\/ Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow(clamp(1. - abs(dot(sn, rd))*.5, 0., 1.), 2.);\n        \n\t\t\/\/ Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        \/\/ so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        \/\/ used to give a hard clay consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\tfloat freS = mix(.15, 1., Schlick);  \/\/F0 = .2 - Glass... or close enough.        \n        \n        \/\/ Combining the above terms to procude the final color. I'm applying more of a\n        \/\/ conventioning shadow shade, which usually entails multiplying it by the \n        \/\/ diffuse component. Sometimes, I'll apply it to everything.\n        col = texCol*(diff*sh + ao*.15 + .05 + vec3(1, .9, .7)*fre*.1);\n       \n        \n        \/\/ Cheap environmapping for the water.\n        if(svGID.w<= WLEV\/LEVELS*.6 + .001) {\n            vec3 cTex = envMap(reflect(rd, sn));\n            col *= (.85 + cTex*1.5);\n        }\n        \n        \n        \/\/ Applying the ambient occlusion and attenuated light.\n        col *= ao*atten;\n\t\n\t}\n    \n    \/\/ Applying some fog on the horizon.\n    vec3 fog = mix(vec3(1, .9, .5), vec3(.5, .7, 1), rd.y*.5 + .5);\n    col = mix(col, fog, smoothstep(0., .99, t\/FAR));\n    \n    \n    #ifdef GRAYSCALE\n    \/\/ Well, close to greyscale, but not quite. :)\n    col = vec3(1.05, 1, .95)*mix(col, vec3(1)*dot(col, vec3(.299, .587, .114)), .9);\n    #endif\n\n    \/\/ Rough gamma correction.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n\t\n}",
            "name": "Image",
            "description": "",
            "type": "image"
        },
        {
            "inputs": [],
            "outputs": [],
            "code": "\n\n\/\/ Producing hexagons with offset vertices can be a little painful, but it's \n\/\/ doable. Regular hexagon grids are almost trivial, but don't really suit this\n\/\/ example. Either way, comment this out to see.\n#define OFFSET_VERTICES\n\n\/\/ Changing the Bavarian look to a Mediterrainean one... Actually, with more of a \n\/\/ limestone sheen, it'd remind me slightly of the super crowded Maltese coastline.\n\/\/#define ARID\n\n\/\/ Quantizing the height levels. More expensive, if not precalated, but it looks \n\/\/ a little neater -- Windows line up with the terraced levels, etc.\n#define QUANTIZE_HEIGHT\n\n\/\/ Quantize the water level, meaning make each water block move independently... Or \n\/\/ is it discreetize, or perhaps noncontinuous... Either way, you know what I mean. :)\n#define QUANTIZE_WATER\n\n\/\/ Grayscale, for that artsy look. Well, it's close to greyscale, but not quite. :)\n\/\/#define GRAYSCALE\n\n\n\/\/ Quantization levels.\n#define LEVELS 19.\n#define WLEV 7.22 \/\/floor(LEVELS*.38)\n\n\n\n\/\/ Work around for the time variable.\nfloat gTime = 0.;\nvoid setTime(float tm){ gTime = tm; }\n    \n\n\n\n\/\/ Grid pattern repeat scale. Baking wrapped distance fields into textures can be \n\/\/ a little fiddly.\nfloat repSc = 1024.\/32.;\n\n\/\/ This sets the scale of the extruded shapes. Because of the way I've calculated\n\/\/ things, the scale needs to be even divisors and each term needs to be equal --\n\/\/ I use it in other applications where I can use two different numbers though. \n\/\/ As above, if you choose this option, a reset will be necessary. Ie. Hit the \n\/\/ back button.\n#define GSCALE vec2(1.\/8.)\n \n\/\/ Flat top hexagon.\n#define FLAT_TOP\n#ifdef FLAT_TOP\n\/\/ Vertices and mid edge points: Clockwise from the left.\nvec4[3] vID = vec4[3](vec4(-2.\/3., 0, -2.\/6., .5), vec4(2.\/6., .5, 2.\/3., 0), vec4(2.\/6., -.5, -2.\/6., -.5)); \nvec4[3] eID = vec4[3](vec4(-.5, .25, 0, .5), vec4(.5, .25, .5, -.25), vec4(0, -.5, -.5, -.25));\n#else\n\/\/ Vertices and mid edge points: Clockwise from the bottom left. -- Basically, the ones \n\/\/ above rotated anticlockwise. :)\nvec4[3] vID = vec4[3](vec4(-.5, -2.\/6., -.5, 2.\/6.), vec4(0, 2.\/3.,.5, 2.\/6.), vec4(.5, -2.\/6., 0, -2.\/3.));\nvec4[3] eID = vec4[3](vec4(-.5, 0, -.25, .5), vec4(.25, .5, .5, 0), vec4(.25, -.5, -.25, -.5));\n#endif\n\n\/\/\/\/\/\/\/\/\n\n\/\/ Reading from various cube map faces.\nvec4 tx0(samplerCube tx, vec2 p){    \n\n    return textureLod(tx, vec3(-.5, fract(p.yx) - .5), 0.);\n    \/\/return texture(tx, vec3(-.5, fract(p.yx) - .5));\n}\n\/*\nvec4 tx1(samplerCube tx, vec2 p){    \n\n    p = fract(p) - .5;\n    return textureLod(tx,  vec3(.5, p.y, -p.x), 0.);\n    \/\/return texture(tx, vec3(.5, p.y, -p.x));\n}\n\nvec4 tx2(samplerCube tx, vec2 p){    \n\n    p = fract(p) - .5;\n    return textureLod(tx,  vec3(p.x, -.5, p.y), 0.);\n    \/\/return texture(tx, vec3(p.x, -.5, p.y));\n}\n*\/\nvec4 tx5(samplerCube tx, vec2 p){    \n\n   \n    return textureLod(tx, vec3(fract(p) - .5, .5), 0.);\n    \/\/return texture(tx, vec3(fract(p) - .5, .5));\n}\n\n\/*\nvec4 tx1B(samplerCube tx, vec2 p){    \n\n    p = (floor(p*1024.) + .5)\/1024.;\n    p = fract(p) - .5;\n    \n    return textureLod(tx, vec3(.5, p.y, -p.x), 0.);\n    \/\/return texture(tx, vec3(.5, p.y, -p.x));\n}\n\nvec4 tx2B(samplerCube tx, vec2 p){    \n\n    p = (floor(p*1024.) + .5)\/1024.;\n    p = fract(p) - .5;\n    \n    return textureLod(tx, vec3(p.x, -.5, p.y), 0.);\n    \/\/return texture(tx, vec3(.5, p.y, -p.x));\n}\n*\/\n\n\n\/\/ Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n\/\/ IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n\/*\n\/\/ IQ's vec2 to float hash.\nvec2 hash22B(vec2 p){ \n   \n    p = (floor(p*1024.) + .5)\/1024.;\n    p = mod(p*repSc*GSCALE*2., repSc);\n    p = vec2(dot(p, vec2(27.619, 113.583)), dot(p, vec2(57.527, 85.491)));\n    p = fract(sin(p)*43758.5453)*2. - 1.; \n    return p;\n    \n    \n    \/\/return sin(p*6.2831853 + gTime);\/\/mix(p, sin(p*6.2831853 + iTime), .35);\n    \n}\n*\/\n\/\/ Based on IQ's hash formula.\nvec4 hash42B(vec4 p){ \n\n    p = (floor(p*1024.) + .5)\/1024.;\n  \n    p = mod(p*repSc*GSCALE.x*2., repSc);\n   \n    p = vec4(dot(p.xy, vec2(27.619, 113.583)), dot(p.xy, vec2(57.527, 85.491)),\n             dot(p.zw, vec2(27.619, 113.583)), dot(p.zw, vec2(57.527, 85.491)));\n                                                  \n    p = fract(sin(p)*43758.5453)*2. - 1.; \n    return p;\n    \n    \n    \/\/return sin(p*6.2831853 + gTime);\/\/mix(p, sin(p*6.2831853 + iTime), .35);\n    \n}\n\n\/*\n\/\/ IQ's vec2 to float texture hash.\nvec2 hash22T(sampler2D tx, vec2 p){ \n    \n    \/\/   p = (floor(p*1024.) + .5)\/1024.;\n    return textureLod(tx, p, 0.).xy;\n    \n}\n*\/ \n\n\/\/ vec2 to vec2 hash.\nvec2 hash22C(vec2 p) { \n\n    p = mod(p, repSc);\n    \/\/ Faster, but doesn't disperse things quite as nicely. However, when framerate\n    \/\/ is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    \/\/ amalgamation I put together, based on a couple of other random algorithms I've \n    \/\/ seen around... so use it with caution, because I make a tonne of mistakes. :)\n    vec2 n = sin(vec2(dot(p, vec2(27.29, 57.81)), dot(p, vec2(7.14, 113.43))));\n    return fract(vec2(262144.1397, 32768.8793)*n)*2. - 1.; \n    \n    \/\/ Animated.\n    \/\/p = fract(vec2(262144, 32768)*n);\n    \/\/return sin(p*6.2831853 + gTime); \n    \n}\n\n\/\/ Based on IQ's gradient noise formula.\nfloat n2D3G( in vec2 p ){\n   \n    vec2 i = floor(p); p -= i;\n    \n    vec4 v;\n    v.x = dot(hash22C(i), p);\n    v.y = dot(hash22C(i + vec2(1, 0)), p - vec2(1, 0));\n    v.z = dot(hash22C(i + vec2(0, 1)), p - vec2(0, 1));\n    v.w = dot(hash22C(i + 1.), p - 1.);\n\n#if 1\n    \/\/ Quintic interpolation.\n    p = p*p*p*(p*(p*6. - 15.) + 10.);\n#else\n    \/\/ Cubic interpolation.\n    p = p*p*(3. - 2.*p);\n#endif\n\n    return mix(mix(v.x, v.y, p.x), mix(v.z, v.w, p.x), p.y);\n    \n}\n\n\n\/\/ Height map. Just a couple of gradient noise layers. \n\/\/ By the way, because this is precalculated, you could\n\/\/ make this as extravagent as you wished.\nfloat hm(in vec2 p){ \n\n    p *= repSc;\n    \n    \/\/ p = (floor(p*1024.) + .5)\/1024.;\n    \/\/p \/= 24.;\n      \n    return n2D3G(p)*.5 + .5;\n \n    \/\/return (n2D3G(p)*.66 + n2D3G(p*2.)*.34)*.5 + .5;\n \n    \n}\n\n\/\/ Height map value, which is just the pixel's greyscale value.\n\/\/float hm(in vec2 p){ return dot(getTex(p), vec3(.299, .587, .114)); }\n\n\n\/\/ IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h){\n    \n    vec2 w = vec2(sdf, abs(pz) - h);\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n\n    \/*\n    \/\/ Slight rounding. A little nicer, but slower.\n    const float sf = .002;\n    vec2 w = vec2( sdf, abs(pz) - h - sf\/2.);\n  \treturn min(max(w.x, w.y), 0.) + length(max(w + sf, 0.)) - sf;\n    *\/\n}\n\n\/\/ IQ's distance to a regular pentagon, without trigonometric functions. \n\/\/ Other distances here:\n\/\/ http:\/\/www.iquilezles.org\/www\/articles\/distfunctions2d\/distfunctions2d.htm\n\/\/\n#define NV 6\n\/\/\nfloat sdPoly(in vec2 p, in vec2[NV] v){\n\n    const int num = v.length();\n    float d = dot(p - v[0],p - v[0]);\n    float s = 1.0;\n    for( int i = 0, j = num - 1; i < num; j = i, i++){\n    \n        \/\/ distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp(dot(w, e)\/dot(e, e), 0., 1. );\n        d = min( d, dot(b,b) );\n\n        \/\/ winding number from http:\/\/geomalgorithms.com\/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, p.y<v[j].y, e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n    }\n    \n    return s*sqrt(d);\n}\n\n\n\n\/\/ IQ's unsigned box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  return length(max(abs(p) - b + sf, 0.)) - sf;\n}\n\n\/\/ IQ's standard box function.\nfloat sBox(in vec2 p, in vec2 b){\n   \n    vec2 d = abs(p) - b;\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n\/\/ This will draw a box (no caps) of width \"ew\" from point \"a \"to \"b\". I hacked\n\/\/ it together pretty quickly. It seems to work, but I'm pretty sure it could be\n\/\/ improved on. In fact, if anyone would like to do that, I'd be grateful. :)\nfloat lBox(vec2 p, vec2 a, vec2 b, float ew){\n    \n    float ang = atan(b.y - a.y, b.x - a.x);\n    p = rot2(ang)*(p - mix(a, b, .5));\n\n    vec2 l = vec2(length(b - a), ew);\n    return sBox(p, (l + ew)\/2.) ;\n}\n\n\/*\n\/\/ This is a bound. Technically, it's not a proper distance field, but for\n\/\/ this example, no one will notice. :)\nfloat sHexS(in vec2 p, in vec2 b){\n    \n    p = abs(p);\n    return max(p.x*.8660254 + p.y*.5 - b.x, p.y - b.y);\n    \/\/return max(p.y*.8660254 + p.x*.5, p.x) - b.x;;\n}\n*\/\n\n \n\n\n\n",
            "name": "Common",
            "description": "",
            "type": "common"
        },
        {
            "inputs": [
                {
                    "id": "Xsf3zn",
                    "filepath": "\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
                    "previewfilepath": "\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
                    "type": "texture",
                    "channel": 2,
                    "sampler": {
                        "filter": "nearest",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "4dX3Rr",
                    "filepath": "\/media\/a\/\/media\/previz\/cubemap00.png",
                    "previewfilepath": "\/media\/ap\/\/media\/previz\/cubemap00.png",
                    "type": "cubemap",
                    "channel": 0,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dX3Rr",
                    "channel": 0
                }
            ],
            "code": "\n\n\n\/\/ A regular extruded block grid.\n\/\/\n\/\/ The idea is very simple: Produce a normal grid full of packed objects.\n\/\/ That is, use the grid cell's center pixel to obtain a height value (read in\n\/\/ from a height map), then render a pylon at that height.\n\n\/\/ For a 2D extruded block tiling four objects are needed. For the Cairo tiling,\n\/\/ each block needs to be subdivided into two seperate pentagonal pieces, so \n\/\/ that's eight pentagon distances all up. Since there are no vec8 containers in \n\/\/ WebGL, we need to make one. By the way, for regular 2D Cairo tiles, you only \n\/\/ need four or even two, depending what you're trying to do.\n\/\/\nstruct vect8{ vec4 distA; vec4 distB; vec4 distC; };\n\n\nvect8 df(vec2 q){\n    \n    \n    \/\/ Block dimension: Length to height ratio with additional scaling. By the way,\n    \/\/ I'm being sneaky here and not applying the vec2(.8660254, 1) stretch scaling\n    \/\/ that gives you proper scaled hexagons. One reason is that they're mutated by\n    \/\/ the offset vertices anyway, and the main one is that it makes wrapping more\n    \/\/ difficult. Not impossible, but more complicated.\n\tconst vec2 dim = GSCALE;\n    \/\/ A helper vector, but basically, it's the size of the repeat cell.\n\tconst vec2 s = dim*2.; \n   \n\n    \/\/ Cell center, local coordinates and overall cell ID.\n    vec2 p, ip;\n    \n    \/\/ Individual block ID.\n    vec2 cntr = vec2(0);\n\n    \n    \/\/ Four block corner postions.\n    const vec2 ll = vec2(.5);\n    \/\/vec2[4] ps4 = vec2[4](vec2(-ll.x, ll.y), ll, -ll, vec2(ll.x, -ll.y));\n    #ifdef FLAT_TOP\n    \/\/ Flat top.\n    vec2[4] ps4 = vec2[4](vec2(-ll.x, ll.y), ll + vec2(0., ll.y), -ll, vec2(ll.x, -ll.y) + vec2(0., ll.y));\n    #else\n    \/\/ Pointed top.\n    vec2[4] ps4 = vec2[4](vec2(-ll.x, ll.y), ll, -ll + vec2(ll.x, 0), vec2(ll.x, -ll.y) + vec2(ll.x, 0));\n    #endif\n    \n    \n    vect8 tile;\n\n    \/\/ Height scale. Not used here.\n    \/\/const float hs = .15;\n\n   \n    for(int i = 0; i<4; i++){\n\n        \/\/ Block center.\n        cntr = ps4[i]\/2.; \n        \n        p = q.xy; \/\/ Local coordinates.\n        ip = floor(p\/s - cntr) + .5; \/\/ Local tile ID.\n        p -= (ip + cntr)*s; \/\/ New local position.\n        \n        \/\/ Correct positional individual tile ID.\n        vec2 idi = ip + cntr;\n \n        \/\/ Hexagon vertices. \n        vec4[3] vert = vID; \n        \n        #ifdef OFFSET_VERTICES\n        \/\/ Offsetting the vertices. Note that accuracy is important here. I had a bug for\n        \/\/ a while because I was premultiplying by \"s,\" to save some calculations, which meant\n        \/\/ points were not quite meeting at the joins... I won't bore you with the rest,\n        \/\/ except to say that it's necessary to keep these numbers simple.\n        const float vo = .15;\n        vec4 vrt0 = idi.xyxy + vert[0]\/2.;\n        vec4 vrt1 = idi.xyxy + vert[1]\/2.;\n        vec4 vrt2 = idi.xyxy + vert[2]\/2.;\n        vrt0 = hash42B(vrt0);\n        vrt1 = hash42B(vrt1);\n        vrt2 = hash42B(vrt2);\n        vert[0] += vrt0*vo;\n   \t\tvert[1] += vrt1*vo;\n        vert[2] += vrt2*vo;\n        #endif \n        \n        \/\/ Scaling to enable rendering back in normal space.\n        vert[0] *= dim.xyxy;\n        vert[1] *= dim.xyxy;\n        vert[2] *= dim.xyxy; \n        \n        \/\/ Scaling the ID.\n\t    idi *= s;\n \n  \n          \n        \/\/ Hexagon vertices.\n        vec2[6] v1 = vec2[6](vert[0].xy, vert[0].zw, vert[1].xy, vert[1].zw, vert[2].xy, vert[2].zw);\n        \n\n        \/\/ Moving the vertices in to help create rounded hexagons. Rounded offset hexgons can\n        \/\/ be created by simply adding a factor to the distance field. Unfortunately, in a \n        \/\/ packed grid, that would create overlap, so it's necessary to move the points in\n        \/\/ first, then add the amount. This is less trivial, as you can see, but is just a\n        \/\/ bit of trigonometry. The following is robust, but was something I came up with on\n        \/\/ the spot, so if anyone knows of a more elegant way, feel free to let me know.\n        \/\/ Remember that this is just a one-off precalculation, so speed isn't a factor.\n        const float ndg = .0175*8.*GSCALE.x;\n        vec2[6] tmpV;\n        \n        for(int j = 0; j<6; j++){\n            \n            \/\/ Vertices and flanking neighbors.\n            vec2 g = v1[j];\n            vec2 g1 = v1[(j + 1)%6];\n            vec2 g2 = v1[(j + 5)%6];\n            vec2 nj = normalize(g1 - g); \/\/ Tangent vector.\n         \n            \/\/ Move the vertices in the direction of the tangent vector\n            \/\/ by the nudge factor.\n            vec2 v1 = g - g1;\n            vec2 v2 = g - g2;\n            \/\/ Angle between vectors.\n            float ang = acos(dot(v1, v2)\/length(v1)\/length(v2));\n            float sl = ndg\/tan(ang\/2.);\n            tmpV[j] = g + sl*nj + ndg*nj.yx*vec2(1, -1);\n        }\n                               \n        v1 = tmpV;                 \n\n        float face1 = sdPoly(p, v1);\n        \/\/ float face1 =  sHexS(p, scale\/2.);\n        face1 -= ndg*.9;\n        tile.distA[i] = face1;\n        \n        \/\/ No precalculated heights for this example, since we'll be reading\n        \/\/ from a precalculated texture in the \"Image\" tab.\n        \/*\n        \/\/ Using the original outer vertices for the offset factor.\n        vec2 inC = vec2(0);\/\/(vert[0].xy + vert[0].zw + vert[1].xy + vert[1].zw + vert[2].xy + vert[2].zw)\/6.;\n        vec2 idi1 = idi + inC.xy;\n        float h = hm(idi1);\n        tile.distB[i] = h;\n        *\/\n        \n        \n    }\n    \n    \/\/ Return the tile struct.\n    return tile;\n\n}\n\n\n\/\/ Cube mapping for face identification - Adapted from one of Fizzer's routines. \nint CubeFaceCoords(vec3 p){\n\n    \/\/ Elegant cubic space stepping trick, as seen in many voxel related examples.\n    vec3 f = abs(p); f = step(f.zxy, f)*step(f.yzx, f); \n    \n    ivec3 idF = ivec3(p.x<.0? 0 : 1, p.y<.0? 2 : 3, p.z<0.? 4 : 5);\n    \n    return f.x>.5? idF.x : f.y>.5? idF.y : idF.z; \n}\n\n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir){\n    \n    \n    \/\/ UV coordinates.\n    \/\/\n    \/\/ For whatever reason (which I'd love expained), the Y coordinates flip each\n    \/\/ frame if I don't negate the coordinates here -- I'm assuming this is internal, \n    \/\/ a VFlip thing, or there's something I'm missing. If there are experts out there, \n    \/\/ any feedback would be welcome. :)\n    vec2 uv = fract(fragCoord\/iResolution.y*vec2(1, -1));\n    \n    \/\/ Adapting one of Fizzer's old cube mapping routines to obtain the cube face ID \n    \/\/ from the ray direction vector.\n    int faceID = CubeFaceCoords(rayDir);\n    \n    \n    \/\/ Setting the global time variable so that the \"Common\" tab can recognize time.\n    setTime(iTime);\n  \n    \/\/ Pixel storage.\n    vec4 col;\n   \n    \/\/ Initial conditions -- Performed just the once upon initialization.\n    \/\/if(abs(tx(iChannel0, uv).w - iResolution.y)>.001){\n    \/\/\n    \/\/ IQ gave me the following tip, which saved me a heap of trouble and an extra channel. \n    \/\/ I'm not sure how he figured this out, but he pretty much knows everything. :D\n    \/\/\n    \/\/ If the texture hasn't loaded, or if we're on the first frame, initialize whatever \n    \/\/ you wish to initialize. In this case, I'm precalculating an expensive distance\n    \/\/ field and storing it in some of the cube map faces.\n    if(textureSize(iChannel0, 0).x<2 || iFrame<1){\n        \n        \/\/ INITIALIZING.\n        \n        \/\/ Construct a distance field, then store it.\n    \tvect8 d = df(uv);\n        \n        if(faceID == 0) col = d.distA; \/\/ Distance fields.\n        \/\/if(faceID == 1) col = d.distB; \/\/ Pylon heights.\n        if(faceID == 5) col = vec4(1)*hm(uv);\/\/d.distB; \/\/ Pylon heights.\n    \n        \n        \/\/repSc = 1024.;\n        \/\/if(faceID == 5) {\n            \/\/col = vec4(1)*hm(uv*repSc);\n        \/\/}\n     \n    }\n    else {\n        if(faceID == 0) col = tx0(iChannel0, uv);\n        \/\/if(faceID == 1) col = tx1(iChannel0, uv);\n        if(faceID == 5) col = tx5(iChannel0, uv);\n        \n    }\n\n\n    \/\/ Store in the cube map.\n    fragColor = col;\n    \n}",
            "name": "Cube A",
            "description": "",
            "type": "cubemap"
        }
    ]
}