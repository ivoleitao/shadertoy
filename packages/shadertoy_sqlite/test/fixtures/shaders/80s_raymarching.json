{
    "ver": "0.1",
    "info": {
        "id": "lsVSRt",
        "date": "1488834249",
        "viewed": 3686,
        "name": "80's raymarching",
        "username": "villedieumorgan",
        "description": "First iteration, wanted to learn some more about raymarching.\nA car and some obstacle could be added in the future.\n\n",
        "likes": 120,
        "published": 1,
        "flags": 32,
        "usePreview": 0,
        "tags": [
            "raymarching",
            "80s",
            "eighties"
        ],
        "hasliked": 0
    },
    "renderpass": [
        {
            "inputs": [
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dfGRr",
                    "channel": 0
                }
            ],
            "code": "#define RGBSHIFT\n#define OLDSCREENLINES\n#define NUMBER_LINES 269.\n\n\/* \nMADE BY MORGAN VILLEDIEU\nTW : https:\/\/twitter.com\/VilledieuMorgan\nClick and drag to rotate the camera\n*\/\n\nvec4 rgbShift( in vec2 p , in vec4 shift) {\n    shift *= 1.02*shift.w - 1.0;\n    vec2 rs = vec2(shift.x,-shift.y);\n    vec2 gs = vec2(shift.y,-shift.z);\n    vec2 bs = vec2(shift.z,-shift.x);\n    \n    float r = texture(iChannel0, p+rs\/2., 0.0).x;\n    float g = texture(iChannel0, p+gs\/2., 0.0).y;\n    float b = texture(iChannel0, p+bs\/2., 0.0).z;\n    \n    return vec4(r,g,b,1.0);\n}\n\nfloat rand(vec2 co) { \n    return fract(sin(dot(co.xy ,vec2(12.98,78.23))) * 43758.54);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float numberLines = 269.;\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n    vec3 oldScreenLines = vec3(sin(uv.y*NUMBER_LINES+sin(iTime)*20.));\n    \n    #ifdef RGBSHIFT\n\t\tvec3 col = mix(rgbShift(uv, vec4(0.015, 0.0, 0.015, 0.0)).xyz, oldScreenLines, 0.01) ;\n    #else\n    \tvec3 col = texture(iChannel0, uv);\n    #endif\n    \n    col -= .028*rand( uv.xy * iTime);\n    fragColor = vec4(col*2.5, 1.);\n}",
            "name": "Image",
            "description": "",
            "type": "image"
        },
        {
            "inputs": [
                {
                    "id": "4sXGzn",
                    "filepath": "\/media\/a\/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3",
                    "previewfilepath": "\/media\/ap\/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3",
                    "type": "music",
                    "channel": 2,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "false",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "Xdf3zn",
                    "filepath": "\/media\/a\/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png",
                    "previewfilepath": "\/media\/ap\/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png",
                    "type": "texture",
                    "channel": 1,
                    "sampler": {
                        "filter": "nearest",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "4sf3Rr",
                    "filepath": "\/media\/a\/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png",
                    "previewfilepath": "\/media\/ap\/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png",
                    "type": "texture",
                    "channel": 0,
                    "sampler": {
                        "filter": "mipmap",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dXGR8",
                    "channel": 0
                }
            ],
            "code": "\/* \nMADE BY MORGAN VILLEDIEU\nTW : https:\/\/twitter.com\/VilledieuMorgan\nClick and drag to rotate the camera\n*\/\n\n\/\/Raymarch settings\n\n#define MAX_MOVEMENT_SPEED 0.9\n#define MIN_RADIUS 0.01\n#define MAX_RADIUS 0.3\n#define STAR_COUNT 30\n#define PI 3.14159265358979323\n#define TWOPI 6.283185307\n\n#define EPSILON 0.1\n\n#define RADIUS_SEED 1337.0\n#define START_POS_SEED 2468.0\n#define THETA_SEED 1675.0\n\n#define MIN_DIST 0.001\n#define MAX_DIST 32.0\n#define MAX_STEPS 96\n#define STEP_MULT 0.9\n#define NORMAL_OFFS 0.01\n#define FOCAL_LENGTH 0.9\n\n\/\/Scene settings\n\n\/\/#define SHOW_RAY_COST\n\n\/\/Colors\n#define SKY_COLOR_1 vec3(49., 33., 66.)\/255.\n#define SKY_COLOR_2 vec3(0.00,0.05,0.20)\n\n#define SUN_COLOR_2 vec3(87., 33., 73.)\/255.\n#define SUN_COLOR_1 vec3(1.00, 0.20, 0.60)\/2.\n\n#define GRID_COLOR_1 vec3(0.00, 0.05, 0.20)\n#define GRID_COLOR_2 vec3(26.00, 14.0, 122.0)\/255.\n#define FOG_COLOR vec3(193.00, 24.0, 123.0)\/255.\n\n\/\/Parameters\n#define GRID_SIZE 0.50\n#define GRID_LINE_SIZE 1.25\n\n#define SUN_DIRECTION vec3( 0.10,0.0,0.)\n\n#define CLOUD_SCROLL vec2(0.002, 0.001)\n#define CLOUD_BLUR 2.0\n#define CLOUD_SCALE vec2(0.04, 0.10)\n\n#define MOUNTAIN_SCALE 6.0\n#define MOUNTAIN_SHIFT 5.3\n\n#define SPEED 11.\n\nconst vec3 starColor = vec3(1.0, 1.0, 1.0);\n\n\/\/Color modes\n\/\/vec3(#,#,#) Number of bits per channel\n\n\/\/24 bit color\n#define RGB888 vec3(8,8,8)\n\/\/16 bit color\n#define RGB565 vec3(5,6,5)\n#define RGB664 vec3(6,6,4)\n\/\/8 bit color\n#define RGB332 vec3(3,3,2)\n#define RGB242 vec3(2,4,2)\n#define RGB222 vec3(2,2,2) \/\/+2 unused\n\n\/\/#define DITHER_ENABLE\n#define COLOR_MODE RGB242\n\n\/\/Object IDs\n#define SKYDOME 0.\n#define FLOOR 1.\n#define OCTAGON 3.\n\nfloat pi = atan(1.0) * 4.0;\nfloat tau = atan(1.0) * 8.0;\n\nfloat normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x\/(sigma*sigma))\/sigma;\n}\n\nvec3 dither(vec3 color, vec3 bits, vec2 pixel)\n{\n    vec3 cmax = exp2(bits)-1.0;\n    \n    vec3 dithfactor = mod(color, 1.0 \/ cmax) * cmax;\n    float dithlevel = texture(iChannel0,pixel \/ iChannelResolution[2].xy).r;\n    \n    vec3 cl = floor(color * cmax)\/cmax;\n    vec3 ch = ceil(color * cmax)\/cmax;\n    \n    return mix(cl, ch, step(dithlevel, dithfactor));\n}\n\nstruct MC\n{\n    vec3 position;\n    vec3 normal;\n    float dist;\n    float steps;\n    float id;\n};\n\n\/\/Returns a rotation matrix for the given angles around the X,Y,Z axes.\nmat3 Rotate(vec3 angles)\n{\n    vec3 c = cos(angles);\n    vec3 s = sin(angles);\n    \n    mat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0,c.x,s.x, 0.0,-s.x, c.x);\n    mat3 rotY = mat3( c.y, 0.0,-s.y, 0.0,1.0,0.0, s.y, 0.0, c.y);\n    mat3 rotZ = mat3( c.z, s.z, 0.0,-s.z,c.z,0.0, 0.0, 0.0, 1.0);\n\n    return rotX * rotY * rotZ;\n}\n\n\/\/==== Distance field operators\/functions by iq. ====\nvec2 opU(vec2 d1, vec2 d2)\n{\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\nvec2 opS(vec2 d1, vec2 d2)\n{\n    return (-d1.x > d2.x) ? d1*vec2(-1,1) : d2;\n}\n\n\nvec2 sdBox(vec3 pos, vec3 size, float id)\n{\n    return vec2(length(max(abs(pos) - size, 0.0)), id);\n}\n\nvec2 sdOct( vec3 p, float r, float id )\n{\n\tvec2 s = vec2(1,-1)\/sqrt(1.0);\n\treturn vec2(max(max(max(\n\t\t\tabs(dot(p,s.xxx)),abs(dot(p,s.yyx))),\n\t\t\tabs(dot(p,s.yxy))),abs(dot(p,s.xyy))) - r*mix(1.0,1.0\/sqrt(3.0),.5), id);\n}\n\nvec2 sdSphere(vec3 p, float s, float id)\n{\n  return vec2(length(p) - s, id);\n}\n\n\nfloat displace(vec3 p) {\n\tfloat height = 10.;\n\treturn ((cos(1.*p.y+0.5)*clamp(sin(1.1*p.x), 0.5, 1.)*sin(0.+2.4)*height*clamp(texture(iChannel0, p.xy\/10.).r*0.4, 0.0, 0.5)));\n}\n\n\/\/float displace(vec3 p) {\n\/\/return ((cos(1.*p.x)*sin(1.1*p.y)\/2.*sin(4.*p.z+1.)))*texture(iChannel2, p.xy\/10.).r+0.1;\n\/\/}\n\n\n\nvec2 sdPlane(vec3 p, vec4 n, float id)\n{\n  \/\/ n must be normalized\n  return vec2(dot(vec3(p.x,p.y, max(p.z + displace(vec3(p.x, p.y-10., p.z)), p.z)), vec3(n.x, n.y, n.z)) + n.y, id);\n}\n\nvec2 sdColumn(vec3 p, float r, float id)\n{\n    return vec2(((abs(p.x)+abs(p.y))-r)\/sqrt(2.0), id);\n}\n\n\/\/Distance to the scene\nvec2 Scene(vec3 p)\n{\n    vec2 d = vec2(MAX_DIST, SKYDOME);\n    \/\/d = opU(opU(sdPlane(p, vec4(0, 0,-1, 0), FLOOR), d), \n    \/\/        opU(sdPlane(p, vec4(0, 0.5,-1, 0), FLOOR), d)) ;\n    \n    d = opU(sdPlane(p, vec4(0, 0,-1, 0), FLOOR), d);\n    \/\/d = opU(sdBox(vec3(p.x-25.1, p.y, p.z-15.4), vec3(5.5, 0.5,15.5), OCTAGON), d);\n\t\/\/d = opU(sdBox(vec3(p.x-10.1, p.y-2., p.z-10.4), vec3(5.5, 0.5,15.5), OCTAGON), d);    \n    \/\/d = opU(sdOct(vec3(p.x-30.1, p.y, p.z+0.2*2.), 0.5, OCTAGON), d);    \n    \n\treturn d;\n}\n\n\/\/Surface normal at the current position\nvec3 Normal(vec3 p)\n{\n    vec3 off = vec3(NORMAL_OFFS, 0, 0);\n    return normalize\n    ( \n        vec3\n        (\n            Scene(p + off.xyz).x - Scene(p - off.xyz).x,\n            Scene(p + off.zxy).x - Scene(p - off.zxy).x,\n            Scene(p + off.yzx).x - Scene(p - off.yzx).x\n        )\n    );\n}\n\n\/\/Raymarch the scene with the given ray\nMC MR(vec3 orig,vec3 dir)\n{\n    float steps = 0.0;\n    float dist = 0.0;\n    float id = 0.0;\n    \n    for(int i = 0;i < MAX_STEPS;i++)\n    {\n        vec2 object = Scene(orig + dir * dist);\n        \n        \/\/Add the sky dome and have it follow the camera.\n        object = opU(object, -sdSphere(dir * dist, MAX_DIST, SKYDOME));\n        \n        dist += object.x * STEP_MULT;\n        \n        id = object.y;\n        \n        steps++;\n        \n        if(abs(object.x) < MIN_DIST * dist)\n        {\n            break;\n        }\n    }\n    \n    MC result;\n    \n    result.position = orig + dir * dist;\n    result.normal = Normal(result.position);\n    result.dist = dist;\n    result.steps = steps;\n    result.id = id;\n    \n    return result;\n}\n\n\/\/Scene texturing\/shading\nvec3 Shade(MC hit, vec3 direction, vec3 camera)\n{\n    vec3 color = vec3(0.0);\n    vec3 rd = color;\n    vec3 skydomeColor = color;\n    \n    if(hit.id == SKYDOME)\n    {\n \n        \/\/vec2 v = fwidth(hit.position.xy);\n        \/\/vec4 soundNoise = texture(iChannel3, v);\n        \n        \/\/Sky gradient\n    \tcolor = mix(SKY_COLOR_1*1.4, SKY_COLOR_2, -hit.position.z\/7.0);\n        \/\/nice\n        \/\/color = mix(SKY_COLOR_1, SKY_COLOR_2, hit.position.z\/9.0);\n        \n        \/\/Sun\n        vec3 sunDir = normalize(SUN_DIRECTION);\n        \n        float sun = smoothstep(0.9430, 0.975, dot(direction, sunDir));\n        sun -= smoothstep(0.1, 0.9, 0.5);\n        vec3 sunCol = mix(SUN_COLOR_1, SUN_COLOR_2*1.2, hit.position.z\/2.5);\n        \n        color = mix(color, sunCol, sun) + texture(iChannel2, vec2(2.) * 0.1).rgb * 0.07;\n    }\n    \n    \/\/if(hit.id == OCTAGON)\n    \/\/{\n    \/\/    color = texture(iChannel1, hit.position.xy).rgb *0.5;\n    \/\/}\n    \n\n    if(hit.id == FLOOR)\n    {\n        vec2 uv = abs(mod(hit.position.xy + GRID_SIZE\/2.0, GRID_SIZE) - GRID_SIZE\/2.0); \n        \n        uv \/= fwidth(hit.position.xy);\n                                                       \n        float gln = min(min(uv.x, uv.y), 1.) \/ GRID_SIZE;\n    \tcolor = mix(GRID_COLOR_1, GRID_COLOR_2, 0.7 - smoothstep(0.0, GRID_LINE_SIZE \/ GRID_SIZE, gln));\n        \n        \/\/ darker on the sides\n        vec3 normal = vec3(0.,-0.5,0.);\n        vec3 rfld = reflect( direction, normal );\n        float reflectstrength = 1.-abs(dot( direction, normal ));\n        color *= reflectstrength;\n\n    } \n    \n    \/\/Distance fog\n    color += mix(GRID_COLOR_2, FOG_COLOR, pow(hit.dist, 1.01) )\/70.;\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy \/ iResolution.y;\n    float aspect = iResolution.x \/ iResolution.y;\n\tvec2 uv = fragCoord.xy \/ iResolution.y;\n    \n    \/\/Camera stuff   \n    vec3 angles = vec3(0);\n    \n    \/\/Auto mode\n    if(iMouse.xy == vec2(0,0))\n    {\n        angles.y = tau * (1.8 \/ 8.0);\n        angles.x = tau * (1.8 \/ 8.0) * 1.1;\n    }\n    else\n    {    \n    \tangles = vec3((iMouse.xy \/ iResolution.xy) * pi, 0);\n        angles.xy *= vec2(1.0, 1.0);\n    }\n    \n    angles.y = clamp(angles.y, 0.0, 15.5 * tau \/ 64.0);\n    \n    mat3 rotate = Rotate(angles.yzx);\n    \n    vec3 orig = vec3(0, 1., 0.) * rotate;\n    \n    vec3 dir = normalize(vec3(uv - res \/ 2.0, FOCAL_LENGTH)) * rotate;\n    \n    orig.z += 0.25;\n    \/\/orig.y = sin(iTime)*10.5;\n    orig.x += iTime*SPEED;\n   \n    \/\/Ray marching\n    MC hit = MR(orig, dir);\n    \n    \/\/Shading\n    vec3 color = Shade(hit, dir, orig );\n     \n    #ifdef SHOW_RAY_COST\n    color = mix(vec3(0,1,0), vec3(1,0,0), hit.steps \/ float(MAX_STEPS));\n    #endif\n\n    #ifdef DITHER_ENABLE\n    color = dither(color, COLOR_MODE, fragCoord);\n    #endif\n    \n    \/\/particles\n \n    vec2 position = ( fragCoord.xy - iResolution.xy * 0.5  ) \/ iResolution.x;\n    float angle = atan(dir.y,dir.z)\/(atan(iTime)-1.*1.*PI);\n    angle -= floor(angle);\n    float rad = length(vec2(dir.x * 0.02, dir.z));\n\n    float angleFract = fract(angle*10.5);\n    float angleRnd = floor(angle*180.);\n    float angleRnd1 = fract(angleRnd*fract(angleRnd*.72035)*1.1);\n    float angleRnd2 = fract(angleRnd*fract(angleRnd*.82657)*1.724);\n    float t = iTime*20.+angleRnd1*1000.;\n    float radDist = sqrt(angleRnd2+float(1));\n    float adist = radDist\/rad*.1;\n    float dist = (t*.2+adist);\n    dist = abs(fract(dist\/20.)-.5);\n    \n    \/\/draw only the particles at the top \n    if(dir.z < 0.0 ){ \n    \tcolor += 0.6 * max(0.0,.7-dist*100.\/adist)*(0.5-abs(angleFract-.5))*1.\/adist\/radDist;\n    }else{\n        color += vec3(0.0,0.,0.2)* vec3(max(0.0,.7-dist*100.\/adist)*(0.5-abs(angleFract-.5))*1.\/adist\/radDist);\n    }\n   \n\tfragColor = vec4(color, 1.0);\n    \n}",
            "name": "Buf A",
            "description": "",
            "type": "buffer"
        }
    ]
}