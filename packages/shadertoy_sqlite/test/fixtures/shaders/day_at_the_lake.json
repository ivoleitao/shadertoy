{
    "ver": "0.1",
    "info": {
        "id": "wl3czN",
        "date": "1609170991",
        "viewed": 780,
        "name": "Day at the Lake",
        "username": "nimitz",
        "description": "Terrain, volumetric clouds and lake with reflections without the use of textures or hash functions for noise.",
        "likes": 58,
        "published": 1,
        "flags": 32,
        "usePreview": 0,
        "tags": [
            "volumetric",
            "ao",
            "screenspace",
            "technique",
            "curvature",
            "cyclicnoise"
        ],
        "hasliked": 0
    },
    "renderpass": [
        {
            "inputs": [
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "XsXGR8",
                    "filepath": "\/media\/previz\/buffer01.png",
                    "previewfilepath": "\/media\/previz\/buffer01.png",
                    "type": "buffer",
                    "channel": 1,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dfGRr",
                    "channel": 0
                }
            ],
            "code": "\/\/ Day at the Lake by nimitz, 2020 (twitter: @stormoid)\n\/\/ https:\/\/www.shadertoy.com\/view\/wl3czN\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\/\/ Contact the author for other licensing options\n\n\/*\n    Originally a shader that was meant to show off a new rain algorithm, which will now get it's\n    own shader at some point in the future.\n    \n    Was also supposed to be a full 24h day, but the addition of the moon and stars would have made\n    the compilation times a bit too high for my taste (based on current average hardware capacities).\n    \n\n  Technical details:\n\n    Cyclic noise:\n        An evolution\/generalization of things like what I call \"triangle noise\" and that I've\n        used in multiple shaders before and more recently combinations of periodic circular \n        functions (sine, cosine, etc).\n        The basic idea goes like this:\n            -Deform the coordinate system uisng a continuous (C0 is enough) periodic\/cyclic function\n            -Generate an octave of noise using combinations of cyclic funtions\n            -Shape the generated octave with modulation functions (abs, pow, smoothstep, etc)\n            -Scale the deformation\/offset\/amplitude parameters for the next octave\n            -Scale and rotate (and offset if needed) the coordinate system before adding the next octave\n        \n        This shader demonstrates the versatility of the algorithm and some of the types of natural shapes\n        it can generate. Of note is how easily analityc derivatives can be computed and how easily the\n        deformation step can be modified to create more complex natural patterns (like erosion, advection,\n        circulation, etc)\n\n\n    Clouds:\n        Shaped with cyclic noise and using analytic derivative of said noise for both internal \n        reshaping and for shading. \n        Colored by sampling the atmosphere colors (at increased depths to mimic scattering of\n        light rays that are further away from the observer).\n        Drawn by excluding part of the volume from the render (on a smooth field like cyclic noisE)\n        to improve convergence speed. \n        \n    Terrain:\n        Shaped with cyclic noise and a pre-deformation step for increased large-scale divesity. Evaluated\n        at lowed detail level for water reflections.\n        Improved my method for multi-scale curvature mapping for terrain illumination by performing\n        single-axis (variable axis based on scale) laplacian-like (divergence of gradient) numerical\n        evaluations. The idea is that small scale curvature visuals can be computed along the normal\n        of the terrain and as the scale increase the axis is moved towards the up\/down axis to\n        better evaluate the large-scale depth of the terrain. This allows for both curvature, ao and\n        global illumination like results in a single function call of 9 terrain fetches, as opposed to\n        17 fetches (using tetrahedral curvature evaluations as per: https:\/\/www.shadertoy.com\/view\/Xts3WM)\n        \n    \n    Water:\n        Computing dynamically-spaced 3-tap averaged numerical derivative of a cyclic noise\n        function to disturb the water surface normal. With ggx distributed screenspace reflections\n        sampled on a blurred buffer to improve smoothness and reduce sample count.\n        \n        I tested using analitic derivative to improve performance but even when deriving from a\n        simplified cyclic function, the sensitivity of the analytic method did not result in\n        usable patterns. Perhaps some more investigation could lead to usable results.\n\n*\/\n\nfloat marchSimp(in vec3 ro, in vec3 rd)\n{\n\tfloat precis = 0.01;\n    float h=precis*2.0;\n    float d = 0.;\n    for( int i=0; i<14; i++ )\n    {\n        if( abs(h)<precis || d>FAR ) break;\n        d += h;\n\t    float res = mapSimp(ro+rd*d)*2.;\n        h = res;\n    }\n    \n\treturn d;\n}\n\nfloat radicalInverse_VdC(uint bits) \n{\n     bits = (bits << 16u) | (bits >> 16u);\n     bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n     bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n     bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n     bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n     return float(bits) * 2.3283064365386963e-10;\n }\n\n vec2 Hammersley(uint i, uint N) \n {\n     return vec2(float(i)\/float(N), radicalInverse_VdC(i));\n }\n\nvoid basis(in vec3 n, out vec3 f, out vec3 r)\n{\n    float sgn = sign(n.z);\n    float a = 1.\/(1. + sgn*n.z);\n    float b = -n.x*n.y*a;\n    f = vec3(1. - n.x*n.x*a, b, -n.x);\n    r = vec3(b, 1. - n.y*n.y*a , -n.y);\n}\n\nvec3 importanceSampleGGX(vec2 xi, float a, vec3 n, float mnl)\n{\n\tfloat phi = 6.2831853*xi.x;\n\tfloat cosTh = sqrt((1.0 - xi.y)\/(1.0 + (a*a - 1.0)*xi.y));\t\t\n\tfloat sinTh = sqrt(1.0 - cosTh*cosTh);\n    vec3 v = vec3(sinTh * cos(phi), sinTh * sin(phi), cosTh);\n    vec3 tx, ty;\n    basis(n, ty, tx);\n\treturn (tx*v.x + ty*v.y + n*v.z);\n}\n\nfloat waterMap(vec2 p)\n{\n    p *= 7.7;\n    return waterDsp(p, iTime)*4.;\n}\n\n\/\/7-taps version (3 blend, combined diff)\n\/\/from my older shader: https:\/\/www.shadertoy.com\/view\/4sfSzf\nvec3 water_normal (vec2 p, float h, float dst)\n{\n    const float wd = 0.5;\n    \n    float wx = fwidth(p.x)*wd;\n    float wy = fwidth(p.y)*wd;\n    \n    float t0 =  waterMap(p);\n    float tu =  waterMap(p + vec2(0., wy));\n    float td =  waterMap(p - vec2(0., wy));\n    float tl =  waterMap(p - vec2(wx, 0));\n    float tr =  waterMap(p + vec2(wx, 0));\n    float tdr = waterMap(p + vec2(wx, wy));\n    float tul = waterMap(p - vec2(wx, wy));\n    \n    vec2 t1 = vec2( t0 - tl, tul - tl );\n    vec2 t2 = vec2( tr - t0, tu - t0 );\n\t\n    vec2 rz = (t1 + t2)*0.5;\n    t1 = vec2( tdr - td, t0 - td );\n    rz = mix(rz, (t1 + t2)*0.5, 0.5);\n\n    h *= pow(dst, 2.75);\n    return normalize( vec3(rz.x, h*9., rz.y ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ttime = iTime;\n    vec2 q = fragCoord.xy \/ iResolution.xy;\n    vec2 p = q - 0.5;\n\tp.x*=iResolution.x\/iResolution.y;\n\tvec2 mo = iMouse.xy \/ iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(0.12,0.15):mo;\n\tmo.x *= iResolution.x\/iResolution.y;\n    mo*=3.14;\n\tmo.y = clamp(mo.y*0.6-.5,-4. ,.15 );\n    \n    vec3 rd, ro;\n    mat3 invCam = getRay(p, mo, ro, rd, iTime);\n\n    vec4 bufA = texture(iChannel0, q);\n    vec3 col = bufA.rgb;\n    vec3 pl = intcPlane(ro, rd, 1.8);\n    \n    if (pl.x < bufA.w)\n    {\n        vec3 nor = vec3(0,1,0);\n        nor = water_normal(pl.yz*4.3, 0.75, pl.x);\n        \n        \/\/compute fresnel (schlick)\n        float R0 = 0.020367; \/\/air to water\n    \tfloat nv = max(dot(-rd, nor), 0.0 );\n    \tfloat fr = R0 + (1.0 - R0) * pow( 1.0 - nv, 5.0 );\n        \n        vec3 attCol = mix(col*0.2, vec3(0.05,0.09,0.3)*dot(col,vec3(2.)), 0.5);\n        vec3 pos = ro + rd*pl.x;\n        \n        vec3 totCol = vec3(0.);\n        float totWeight = 0.;\n        \n        vec2 asp = vec2(iResolution.y\/iResolution.x,1.0);\n\t\tconst uint SAMPLES = 23u;\n\n        for (uint i = 0u; i<SAMPLES; i++)\n        {\n            vec2 xi = Hammersley(i, SAMPLES)*0.8;\n            float mnl = clamp(dot(nor, -rd),0.,1.);\n            \n            vec3 h = importanceSampleGGX(xi, 0.055, nor, mnl);\n            vec3 l = reflect(rd, h);\n            \n            float nl = max(dot(nor, l), .0);\n            \n            if (nl > 0.)\n            {\n                float rz2 = marchSimp(pos + l*0.05, l);\n                    \n                vec3 epos = (vec3((rz2*l + pos) - ro))*invCam;\n                vec2 npos = -fov*epos.xy\/epos.z;\n                vec2 spos = 0.5 + 1.*npos*asp;\n                vec4 rfTx = texture(iChannel1, spos);\n\n                totCol += rfTx.rgb*nl; \n                totWeight += nl;\n            }\n        }\n        \n        totCol \/= totWeight;\n        col = mix(attCol, totCol*0.7, clamp(fr,0.0, 0.85));\n    }\n    \n    float exposure = 2.1;\n    col = 1.0 - exp(-col * exposure);\n    \n    col = pow(clamp(col,0.,1.), vec3(0.416667))*1.055 - 0.055;\n    col.rgb *= pow( 32.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1)*0.35 + 0.65; \/\/Vign\n\n    fragColor = vec4(col, 1.0);\n}",
            "name": "Image",
            "description": "",
            "type": "image"
        },
        {
            "inputs": [],
            "outputs": [],
            "code": "\/\/ Day at the Lake by nimitz, 2020 (twitter: @stormoid)\n\/\/ https:\/\/www.shadertoy.com\/view\/wl3czN\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\/\/ Contact the author for other licensing options\n\n\/\/ Camera and cyclic noises (for clouds, water and terrain)\n\n#define FAR 30.\n\nconst float fov = 1.3;\nvec3 lgt = normalize( vec3(0.0, 0.27, -0.9) );\n\nvec3 lcol = vec3(0);\n\nmat3 rot_x(float a){float sa = sin(a); float ca = cos(a); return mat3(1.,.0,.0,    .0,ca,sa,   .0,-sa,ca);}\nmat3 rot_y(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,.0,sa,    .0,1.,.0,   -sa,.0,ca);}\nmat3 rot_z(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,sa,.0,    -sa,ca,.0,  .0,.0,1.);}\n\nmat3 getRay(vec2 p, vec2 mo, out vec3 ro, out vec3 rd, float time)\n{\n    mo.y = 0.15;\n    mo.x = mo.x*0.7 + 0.2;\n    mo.x += sin(time*0.1)*0.5;\n    \n\tro = vec3(-3.5, -1.71, -4.0);\n    rd = normalize(vec3(p, -fov));\n    \n    mat3 cam = rot_x(-mo.y)*rot_y(-mo.x);\n\trd *= cam;\n    \n    mat3 invCam = rot_y(mo.x)*rot_x(mo.y);\n    return invCam;\n}\n\n\/\/ For latitude 35, toD = time of day, toY = time of year, both 0..1\n\/\/ not 100% accurate, but cheap to evaluate and pretty close\nvec3 sunPos(float toD, float toY)\n{\n    toY = 1.0 - abs(fract(toY)-0.5)*2.0;\n    float mid = 1.0-abs(toY-0.5)*2.0;\n    float k = mix(0.68, 1.5, toY);\n    float xk = pow(toD, k);\n    toD = xk\/(xk + pow(1.0-toD, k));\n    toD = -toD*6.283853 - 1.5708 + 0.1;\n    return normalize(vec3(sin(toD)*mix(0.4,0.7, mid) + mix(0.1, -0.1, toY), sin(toD) + mix(-.7, 0.69, toY), cos(toD)));\n}\n\nvec3 intcPlane(vec3 ro, vec3 rd, float plH)\n{\n    ro.y += plH;\n    float t = -ro.y\/rd.y;\n    if (t < 0.)\n        return vec3(1e6);\n    float u =  ro.x + rd.x*t;\n    float v =  ro.z + rd.z*t;\n    return vec3(t,u,v);\n}\n\n\/\/ Clouds cyclic noise\nconst mat3 m3x = mat3(0.33338, 0.56034, -0.71817, -0.87887, 0.32651, -0.15323, 0.15162, 0.69596, 0.61339)*2.01;\nvec4 cloudMap(vec3 p, float time)\n{\n    p.xz += vec2(-time*1.0, time*0.25);\n    time *= 0.25;\n    p.y -= 9.0;\n    p *= vec3(0.19,0.3,0.19)*0.45;\n    vec3 bp = p;\n    float rz = 0.;\n    vec3 drv = vec3(0);\n    \n    float z = 0.5;\n    float trk= 0.9;\n    float dspAmp = 0.2;\n    \n    float att = clamp(1.31-abs(p.y - 5.5)*0.095,0.,1.);\n    float off = dot(sin(p*.52)*0.7+0.3, cos(p.yzx*0.6)*0.7+0.3)*0.75 - 0.2; \/\/large structures\n    float ofst = 12.1 - time*0.1;\n    \n    for (int i = 0; i<6; i++)\n    {\n        p += sin(p.yzx*trk - trk*2.0)*dspAmp;\n        \n        vec3 c = cos(p);\n        vec3 s = sin(p);\n        vec3 cs = cos(p.yzx + s.xyz + ofst);\n        vec3 ss = sin(p.yzx + s.xyz + ofst);\n        vec3 s2 = sin(p + s.zxy + ofst);\n        vec3 cdrv = (c*(cs - s*ss) - s*ss.yzx - s.zxy*s2)*z;\n        \n        rz += (dot(s, cs) + off - 0.1)*z; \/\/cloud density\n        rz *= att;\n        drv += cdrv;\n        \n        p += cdrv*0.05;\n        p.xz += time*0.1;\n        \n        dspAmp *= 0.7;\n        z *= 0.57;\n        trk *= 2.1;\n        p *= m3x;\n    }\n    \n    return vec4(rz, drv);\n}\n\n\/\/ Water surface cyclic noise\nmat2 m2w = mat2(0.90475, 0.42594, -0.42594, 0.90475)*2.12;\nfloat waterDsp(vec2 p, float time)\n{\n    float rz = 0.;\n    float z = 0.4;\n    float trk= 1.0;\n    float dspAmp = 0.5;\n    \n    for (int i = 0; i<5; i++)\n    {\n        p += sin(p.yx*0.5*trk + trk*2.5)*dspAmp;\n        rz += pow(abs(dot(cos(p*0.37), sin(p - time*0.5*trk))*z), 1.2);\n        \n        z *= 0.49;\n        trk *= 1.35;\n        dspAmp *= 0.8;\n        p *= m2w;\n    }\n    \n    return rz;\n}\n\n\/\/ Terrain cyclic noise\nfloat ttime = 0.;\nconst mat3 m3 = mat3(0.33338, 0.56034, -0.71817, -0.87887, 0.32651, -0.15323, 0.15162, 0.69596, 0.61339)*2.1;\n\nvoid cyclicOctave(inout vec3 p, inout float rz, inout float z, inout float trk, inout float dspAmp)\n{\n    p += sin(p.yzx*0.25*trk - trk*6.1 + cos(p*0.1 + 0.5)*1.0)*dspAmp;\n    float ofst = 4.6;\n    vec3 s = sin(p*1.3);\n    rz += smoothstep(-1.1, 0.5, dot(s, cos(p.yzx*0.95 + s.xyz + ofst)))*z;\n\n    dspAmp *= 0.65;\n    z *= 0.45;\n    trk *= 1.45;\n    p *= m3;\n}\n\nfloat cyclic3D(vec3 p )\n{\n    vec3 bp = p;\n    float rz = 0.;\n    vec3 drv = vec3(0);  \n    float z = 1.44;\n    float trk= 1.0;\n    float dspAmp = 1.;\n    \n    for (int i = 0; i<=10; i++)\n    {\n        cyclicOctave(p, rz, z, trk, dspAmp);\n    }\n    rz -= 1.1;\n    return rz;\n}\n\nfloat cyclic3DSimp(vec3 p )\n{\n    vec3 bp = p;\n    float rz = 0.;\n    float z = 1.44;\n    float trk= 1.0;\n    float dspAmp = 1.;\n    \n    for (int i = 0; i<=5; i++)\n    {\n      \tcyclicOctave(p, rz, z, trk, dspAmp);\n    }\n    rz -= 1.1;\n    return rz;\n}\n\nfloat map(vec3 p)\n{\n    float d = p.y;\n    d -= sin(p.z*0.2 + 1.0 - cos(p.x*0.25))*0.35;\n    float att = clamp(p.y*0.3 + 1.3, 0.,1.);\n    d += cyclic3D(p*0.3)*att*1. + 1.;  \n    return d;\n}\n\nfloat mapSimp(vec3 p)\n{\n    float d = p.y;\n    d -= sin(p.z*0.2 + 1.0 - cos(p.x*0.25))*0.35;\n    float att = clamp(p.y*0.3 + 1.3, 0.,1.);  \n    d += cyclic3DSimp(p*0.3)*att*1. + 1.;\n    return d;\n}\n",
            "name": "Common",
            "description": "",
            "type": "common"
        },
        {
            "inputs": [],
            "outputs": [
                {
                    "id": "4dXGR8",
                    "channel": 0
                }
            ],
            "code": "\/\/ Day at the Lake by nimitz, 2020 (twitter: @stormoid)\n\/\/ https:\/\/www.shadertoy.com\/view\/wl3czN\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\/\/ Contact the author for other licensing options\n\n\/\/ Main pass (sky and terrain)\n\n#define ITR 120\n#define time iTime\n\nfloat dfog = 0.;\nfloat matid = 0.;\n\n\/\/ Curvature mapping and multi-scale terrain ambient occlusion all in one\n\/\/ this version uses 9 fetches, but could be reduced to 7 with similar results\n\/\/ also using distance to modulate the smaller scale evaluation\nfloat curvM(in vec3 p, in float w, vec3 n, float d)\n{\n    vec3 haf = normalize(mix(vec3(0,1,0), n, .5));\n    float t1 = map(p + n*w*0.02*d), t2 = map(p - n*w*0.02*d);\n    float t3 = map(p + haf*w*.25), t4 = map(p - haf*w*.25);\n    float t5 = map(p + haf*w*1.3), t6 = map(p - haf*w*1.3);\n    float t7 = map(p + vec3(0.001,1,0.001)*w*20.), t8 = map(p - vec3(0.001,1,0.001)*w*20.);\n    float t0 = map(p);\n    float d2 = d*d;\n    \n    return smoothstep(-.55, .85, (800.*(t1 + t2)\/d2 + 100.*(t3 + t4)\/d2 + 2.5*(t5+t6) + 0.15*(t7+t8) - 40.*t0))*2.7 - 0.4;\n}\n\nvec3 normal(const in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*0.005;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tfloat precis = 0.0005;\n    float h=precis*2.0;\n    float d = 0.;\n    for( int i=0; i<ITR; i++ )\n    {\n        if( abs(h)<precis || d>FAR ) break;\n        d += h;\n\t    float res = map(ro+rd*d);\n        h = res;\n    }\n\treturn d;\n}\n\nfloat shadow(in vec3 ro, in vec3 rd, in float mint, in float maxt )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10;\n    \n    for( int i=0; i<18; i++ )\n    {\n\t\tfloat rz = map(ro + rd*t);\n        res = min(res, 4.5*rz\/t);\n        t += rz;\n        if( res<0.0001 || t>maxt ) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n\/\/ Based on: http:\/\/blog.selfshadow.com\/publications\/s2013-shading-course\/karis\/s2013_pbs_epic_notes_v2.pdf\nvec3 shade(in vec3 pos, in vec3 rd, float d)\n{\n    vec3 nor = normal(pos);\n    vec3 alb = vec3(0.2,0.65,0.01);\n    alb *= dot(cos(pos.xz*10. + sin(pos.zx*10.)*4.), sin(pos.zx*5.))*0.2 + 0.8;\n    float grass = clamp(pow(nor.y,4.) - (pos.y + 2.5)*0.2, 0., 1.);\n    alb = mix(vec3(0.32,0.31,0.3)*0.75, alb*0.55, grass);\n    float beach = pow(pow(max(nor.y, 0.0), 5.0),3.0)*smoothstep(0.03,.01,abs(pos.y + 1.805));\n    float dirt = smoothstep(0.03,.01, pos.y + 1.83);\n    alb = mix(alb, vec3(1,0.95,0.5)*0.75, beach);\n    alb = mix(alb, vec3(1,0.8,0.5)*0.2, dirt);\n    nor = mix(nor, vec3(0,1,0),beach*0.8);\n    \n    float rough = 0.75;\n    vec3 f0 = mix(vec3(0.1), vec3(0.004), grass);\n    \n\tfloat nl = clamp(dot(nor,lgt), 0., 1.);\n\tvec3 col = vec3(0.);\n    \n    if (nl > 0.)\n    {\n        nl *= clamp(shadow(pos, lgt, 0.1,8.),0.35,1.);\n        vec3 haf = normalize(lgt - rd);\n        float nh = clamp(dot(nor, haf), 0., 1.); \n        float nv = clamp(dot(nor, -rd), 0., 1.);\n        float lh = clamp(dot(lgt, haf), 0., 1.);\n        float a = rough*rough;\n        float a2 = a*a;\n        float dnm = nh*nh*(a2 - 1.) + 1.;\n        float D = a2\/(3.14159*dnm*dnm);\n        float k = pow(rough + 1., 2.)\/8.; \/\/hotness reducing\n\t\tfloat G = (1.\/(nl*(1. - k) + k))*(1.\/(nv*(1. - k) + k));\n        vec3 F = f0 + (1. - f0) * exp2((-5.55473*lh - 6.98316) * lh); \/\/\"optimization\"\n        vec3 spec = nl*D*F*G;\n        col = lcol*nl*(spec + alb*(1. - f0));\t\t\n    }\n    \n    float bnc3 = clamp(dot(nor, vec3(0,1,0))*.5 + 0.5, 0. , 1.);\n    col.rgb += vec3(0.4,0.5,0.8)*alb*bnc3*0.1*(1.- nl)*(lcol*0.9+0.1);\n    \n    col *= clamp(pos.y*0.6 + 1.9,0.,1.3);\n    \n    float crv0 = curvM(pos, 0.1, nor, d);\n    if (beach < 0.15)\n        col *= crv0 + 0.45;\n    \n    return col;\n}\n\n\/\/-----------------------------Sky rendering---------------------------\n\/\/ modified from an prototype public domain implementation by shadertoy user Jodie: https:\/\/www.shadertoy.com\/view\/ttSGzh\n\/\/ That version has some serious accuracy issues, I modified it to somewhat match the Hosek-Wilkie sky model visuals.\n\n#define atmoDepth 8228.\n#define earthRadius 6371000.\n#define mieDepth 1800\n#define sunColor vec3( .95, 0.96, 1.2 )\n#define ozoneHeight 30000.\n#define ozoneCoefficient (vec3(3.426, 8.298, .356) * 6e-5 \/ 100.)\n#define mieCoefficient 16e-6 \/\/ adjust for foggier look\n\n\/\/ custom\n#define rayleighCoefficient vec3(5.6e-6  , 1.25e-5 , 2.9e-5 )\n\nvec3 getThickness(vec3 rd)\n{\n    const vec4 cns = earthRadius + \n        \t\t\tvec4(atmoDepth, mieDepth, ozoneHeight, ozoneHeight + atmoDepth);\n    const float r2 = earthRadius * earthRadius;\n    float b = -rd.y*earthRadius;\n    vec4 z = sqrt( cns*cns + (b*b - r2) );\n    return vec3(b + z.xy, z.w - z.z);\n}\n\nvec4 getSky(vec3 rd, vec3 lgt, float addDepth)\n{\n    const vec3 addCol = vec3(1.,1.,1.);\n    const mat3 coeffs = mat3(rayleighCoefficient, vec3(mieCoefficient), ozoneCoefficient)\/0.693147;\n    vec3 thickness = getThickness(rd) + addDepth*addCol;\n    float rdl = max(dot(rd, lgt), 0.0);\n\n    vec3 rayleighScatter =(thickness.x * (0.4*rdl*rdl + 1.12))* rayleighCoefficient;\n    float g = 0.8 - lgt.y*0.15 - mieCoefficient*1500.;\n    float g2 = g*g;\n    float a = inversesqrt(g2 - (2.0*g*rdl - 1.0));\n    float phaseMie = (0.4 + lgt.y*0.1 + mieCoefficient*7000.)*(1.0 - g2)*a*a*a;\n    float mieScatter = thickness.y * phaseMie * mieCoefficient;\n\n    vec3 sunCoeff = coeffs*(getThickness(lgt) + addDepth*addCol);\n    vec3 viewCoeff = coeffs*thickness;\n    vec3 absorption = (exp2(-viewCoeff) - exp2(-sunCoeff))\/((sunCoeff - viewCoeff)*0.693147);\n\n    return vec4(clamp(sunColor*(rayleighScatter + mieScatter)*absorption*(0.6 + lgt.y*0.3), 0., 100.5), sunCoeff);\n}\n\n\n\/\/-------------------------End of sky rendering------------------------\n\/\/---------------------------------------------------------------------\n\nvec3 getSun(vec3 rd, float sunCoeff)\n{\n    float rdl = max(dot(rd, lgt), 0.0);\n    float dcy = smoothstep(-0.05,0.2,lgt.y);\n    vec3 sun = 50.0*vec3(1.,1.,.4)*pow(rdl, 10000.)*clamp(1.0 - dcy*.7, 0.,1.);\n    sun += 10.0*vec3(1.,0.7,.2)*pow(rdl, 3500.);\n    sun *= clamp(1.0 - dcy*.6, 0.,1.);\n    sun *= exp2(-sunCoeff*0.45);\n    return sun;\n}\n\nfloat linstep(in float mn, in float mx, in float x){ return clamp((x - mn)\/(mx - mn), 0., 1.); }\nmat2 rot2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\n\nvec4 getClouds( in vec3 ro, in vec3 rd, float scnD, vec3 skyCol )\n{\n\tvec4 rez = vec4(0.);\n\tfloat t = min(intcPlane(ro, rd, -12.).x, 175.);\n    \n    float updl = dot(lgt, vec3(0, 1, 0));\n    float sunUp = max(updl, 0.);\n    float sunUp3 = clamp(sunUp*sunUp*sunUp*6., 0.0, 1.0);\n    float sunDw = 1.0 - sunUp;\n    sunDw = pow(sunDw, 6.0);\n    \n    float bsd = dot(lgt.xz, rd.xz);\n    float sd = max(bsd, 0.0);\n    float sd2 = max(bsd*0.55 + 0.53,0.);\n    \n    vec3 topSky = clamp(getSky(vec3(0, 1, 0), lgt, 0.).xyz, 0.,1.);\n    vec3 baseCol = mix(topSky, vec3(0.05, 0.066, 0.09), clamp(sunUp3,0.0, 0.6))*0.2;\n    \n    float extraDepth = 14e4*((1.0-bsd)*0.2 + 0.9)*pow(1.0 - sunUp, 4.0);\n    vec3 hlitCol = clamp(getSky(normalize((lgt-vec3(0,0.001,0))*rot_y(0.15)), lgt, extraDepth).xyz ,0.0, 1.0);\n    hlitCol = hlitCol*sd2*mix(sunDw, sunDw*sunDw, sd)*8.;\n    \n    vec3 bSkyCol = getSky(rd, lgt, extraDepth*5.0*(sunUp*0.8 + 0.2)).xyz;\n    vec3 sunLCol = mix(vec3(1.0, 0.8, 0.75), vec3(.5), sunUp);\n    vec3 atmoCol = mix(bSkyCol*(sunUp*0.3+0.7), sunLCol*dot(bSkyCol, vec3(0.38)), sunUp3)*0.25;\n    \n\tfor(int i=0; i<85; i++)\n\t{\n\t\tvec3 pos = ro + t*rd;\n        if(rez.a > 0.99 || t > 300.  || pos.y > 150.)break;\n        vec4 cld = cloudMap(pos, iTime);\n\t\tfloat den = clamp(cld.x, 0., 1.)*1.02;\n\t\tfloat dn = clamp((cld.x + 1.9),0.0 , 3.0);\n        float fogT = 0.;\n        \n\t\tvec4 col = vec4(0);\n        \n        if (cld.x > 0.6)\n        {   \n            col = vec4(baseCol, 0.1);\n            float nl = max(dot(cld.yzw, -lgt), -1.2);\n            float dif = clamp((cld.x - cloudMap(pos + lgt*8., iTime).x)*0.4 + 0.2, 0.11, 2.0 )*2.5;\n            dif += clamp((cld.x - cloudMap(pos + lgt*15., iTime).x)*0.2 - 0.03, -0.02, 1. )*4.0;\n            \n            col.rgb += atmoCol*((nl*0.25 + 0.7)*dif*0.65); \/\/atmosphere lighting\n            \n            float den2 = den*den;\n            float den4 = den2*den2;\n            col *= den4*den4;\n            col.rgb += col.a*clamp((nl*0.8 + 0.1)*dif,0.,1.)*hlitCol; \/\/twi-lights\n            \/\/col *= smoothstep(t-0.0, t+.1, scnD); \/\/blend with scene\n        }\n        \n        float fogC = exp2(t*0.012\/(rd.y + 0.35) - 11.7);\n        col.rgba += vec4(skyCol, 1.0)*clamp(fogC, 0.0, 1.0);\n\t\trez = rez + col*(1.0 - rez.a);\n        t += clamp(7. - dn*dn*.85, 1.2, 7.);\n\t}    \n\treturn clamp(rez, 0.0, 1.0);\n}\n\nvec4 render(in vec3 ro, in vec3 rd)\n{\n    float rz = march(ro,rd);\n    float ldt = clamp(dot(lgt,rd),0.,1.);\n    \n    vec4 skyCol = getSky(rd, lgt, 0.);\n    vec3 col = skyCol.rgb;\n    vec3 bg= col;\n    \n    vec3 lgtOffs = normalize((lgt + vec3(0,0.03,0.)));\n    vec4 haloCol = getSky(lgtOffs, lgt, 0.);    \n    lcol = clamp(mix(haloCol.xyz, vec3(0.72, 0.71, 0.7), clamp(lgt.y*3.0, 0.04, 0.9)),0.,1.);\n    \n    if ( rz < FAR )\n    {\n        vec3 pos = ro +rd*rz;\n        vec3 nor = normal(pos);\n        col = shade(pos, rd, rz);\n        col = mix(col, bg, smoothstep(5., FAR + 35.,rz));\n    }\n    else\n    {\n        col += getSun(rd, skyCol.w);\n        vec4 cld = getClouds(ro, rd, 10000., bg);\n    \tcol = col*(1.0-cld.w) + cld.xyz;\n    }\n    return vec4(col, rz);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    ttime = iTime;\n\tvec2 q = fragCoord.xy \/ iResolution.xy;\n    vec2 p = q - 0.5;\n\tp.x*=iResolution.x\/iResolution.y;\n\tvec2 mo = iMouse.xy \/ iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(-0.1,-0.33):mo;\n\tmo.x *= iResolution.x\/iResolution.y;\n    mo*=3.14;\n\tmo.y = clamp(mo.y*0.6-.5,-4. ,.15 );\n    \n    lgt = sunPos(0.43 + mo.y*0.15, 0.5);\n    lgt *= rot_y(-0.2);\n    \n    vec3 rd, ro;\n    getRay(p, mo, ro, rd, iTime);\n    fragColor = render(ro, rd);\n}\n",
            "name": "Buffer A",
            "description": "",
            "type": "buffer"
        },
        {
            "inputs": [
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "XsXGR8",
                    "channel": 0
                }
            ],
            "code": "\/\/ Day at the Lake by nimitz, 2020 (twitter: @stormoid)\n\/\/ https:\/\/www.shadertoy.com\/view\/wl3czN\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\/\/ Contact the author for other licensing options\n\n\/\/ Naive Pre-Blur for water reflections\n\nconst int vTaps = 3;\nconst int hTaps = 1;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 q = fragCoord.xy \/ iResolution.xy;\n    vec4 col = vec4(0);\n    \n    for(int j = -hTaps; j <= hTaps; j++)\n    for(int i = -vTaps; i <= vTaps; i++)\n    {\n        vec2 tap = vec2(j,i);\n        tap *= vec2(2.\/iResolution.x, 4.\/iResolution.y);\n        col += texture(iChannel0, q+tap);\n    }\n    \n    float totTaps = (float(vTaps)*2.0 + 1.0) * (float(hTaps)*2.0 + 1.0);\n    col \/= totTaps;\n    \n\tfragColor = clamp(col, 0., 1.);\n}",
            "name": "Buffer B",
            "description": "",
            "type": "buffer"
        }
    ]
}