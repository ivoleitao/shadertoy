{
    "ver": "0.1",
    "info": {
        "id": "wsByWV",
        "date": "1587452922",
        "viewed": 14228,
        "name": "Voxel Game Evolution",
        "username": "kastorp",
        "description": "refactoring of  \"[SH16C] Voxel Game\" by Fb39ca4  \n\nkeys: ASWD move , SPACE jump, mouse rotate view and select, QERFGC  actions",
        "likes": 180,
        "published": 1,
        "flags": 48,
        "usePreview": 1,
        "tags": [
            "game",
            "voxel",
            "minecraft",
            "keyboard",
            "multipass",
            "memory"
        ],
        "hasliked": 0
    },
    "renderpass": [
        {
            "inputs": [
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "nearest",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "XsXGR8",
                    "filepath": "\/media\/previz\/buffer01.png",
                    "previewfilepath": "\/media\/previz\/buffer01.png",
                    "type": "buffer",
                    "channel": 1,
                    "sampler": {
                        "filter": "nearest",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "4sXGR8",
                    "filepath": "\/media\/previz\/buffer02.png",
                    "previewfilepath": "\/media\/previz\/buffer02.png",
                    "type": "buffer",
                    "channel": 2,
                    "sampler": {
                        "filter": "nearest",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "XdfGR8",
                    "filepath": "\/media\/previz\/buffer03.png",
                    "previewfilepath": "\/media\/previz\/buffer03.png",
                    "type": "buffer",
                    "channel": 3,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dfGRr",
                    "channel": 0
                }
            ],
            "code": "\/*---------------------------------------------------------\n\tTHIS SHADER IS BASED ON  \"[SH16C] Voxel Game\" by fb39ca4  \n  \t\n\twhen switching to full screen press L until you get better performance (K for higher resolution)\n\nCONTROLS:\n    drag mouse to move view and select blocks\n    WASD or arrows to move\n    Space to jump\n    Double-tap space to start flying, use space and shift to go up and down.\n\n    mouse double click to select\/unselect a block (doesn't work well with low framerate\n    Q + mouse button to place block \n    E + mouse button to destroy blocks \n\tR + mouse button to change shape of a block \n\tF + mouse button to rotate a shape on z axis \n\tG + mouse button to rotate a shape on y axis\n\tC + mouse button to select multiple blocks (hold on \"C\" to clear selection)\n\tdestroy,place, shape,rotate also work on selected blocks, without mouse button\n\n    mouse click on inventory to select a block type\n\tM to toggle map\n\tI to toggle inventory (hidden, simple, full)\n\n\tO,P to decrease\/increase speed of day\/night cycles   \n    k,L to decrease\/increase pixel sizes \n\tT to teleport to a random location\n    Page Up\/Down to increase or decrease zoom \n\tF7 enable\/disable torch light diffusion (flickering on some GPUs)\n\tF8 enable\/disable water flow\n\nBLOCK MECHANICS:\n\n\t TORCH= light\n\t TREE= grows if placed\n\t DIAMOND= illumninated if close to GOLD or other illuminated diamonds\n\t RED BLOCK= mirror \n\t WATER= semtrasparent, flows downwards\n\t SAND = falls if in empty space or with 4 horizontal steps\n\t PINK MARBLE= infinite water source\n\nCONFIGURATION:\n\tsee #define settings in \"Common\" file \n\nBUFFERS:\n    \"BUFFER A\": actions, collisions, settings, material textures\n    \"BUFFER B\": voxel cache, nearest blocks full height \n    \"BUFFER C\": surface voxel cache (just one block for every xy position)\n    \"BUFFER D\": rendering, map\n    \"IMAGE\"   : gui, stats\n\nCREDITS:\n\tVoxel game: @fb39ca4 https:\/\/shadertoy.com\/view\/MtcGDH\n\tVoxel traversal: @Iq https:\/\/www.shadertoy.com\/view\/4dfGzs\n\tGLSL Number Printing:  @P_Malin https:\/\/www.shadertoy.com\/view\/4sBSWW\n\tTextures: @Reinder https:\/\/www.shadertoy.com\/view\/4ds3WS\n\tencoding\/decoding: @Eiffie https:\/\/www.shadertoy.com\/view\/wsBfzW\n\tgrass: @W23 https:\/\/www.shadertoy.com\/view\/MdsGzS\n\tNoise: @Makio64 https:\/\/shadertoy.com\/view\/Xd3GRf\n\twater reflection:@Reinder https:\/\/www.shadertoy.com\/view\/MdXGW2\n\nCHANGELOG & TODO: \n\tsee bottom of the file\n\n\/\/-----------------------------------------------------*\/\n\n\n#ifdef STATS\n\n\/\/ ---- 8< ---- GLSL Number Printing - @P_Malin ---- 8< ----\n\/\/ Creative Commons CC0 1.0 Universal (CC-0) \n\/\/ https:\/\/www.shadertoy.com\/view\/4sBSWW\nfloat DigitBin(const in int x)\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue(const in vec2 fragCoord, const in vec2 vPixelCoords, const in vec2 vFontSize, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces)\n{\n    vec2 vStringCharCoords = (fragCoord.xy - vPixelCoords) \/ vFontSize;\n    if ((vStringCharCoords.y < 0.0) || (vStringCharCoords.y >= 1.0)) return 0.0;\n\tfloat fLog10Value = log2(abs(fValue)) \/ log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCharCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n\t\t\tif((fValue < 0.0) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} else {\n\t\t\t\tif(fDigitIndex < 0.0) fDigitIndex += 1.0;\n\t\t\t\tfloat fDigitValue = (abs(fValue \/ (pow(10.0, fDigitIndex))));\n                float kFix = 0.0001;\n                fCharBin = DigitBin(int(floor(mod(kFix+fDigitValue, 10.0))));\n\t\t\t}\t\t\n\t\t}\n\t}\n    return floor(mod((fCharBin \/ pow(2.0, floor(fract(vStringCharCoords.x) * 4.0) + (floor(vStringCharCoords.y * 5.0) * 4.0))), 2.0));\n}\n\n#endif\n\n\nvec4 drawSelectionBox(vec2 c) {\n\tvec4 o = vec4(0.);\n    float d = max(abs(c.x), abs(c.y));\n    if (d > 6. && d < 9.) {\n        o.a = 1.;\n        o.rgb = vec3(0.9);\n        if (d < 7.) o.rgb -= 0.3;\n        if (d > 8.) o.rgb -= 0.1;\n    }\n    return o;\n}\n\nmat2 inv2(mat2 m) {\n  return mat2(m[1][1],-m[0][1], -m[1][0], m[0][0]) \/ (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n}\n\nvec4 drawInventory(vec2 c) {\n    \n    float h= (load(_inventory).r>1.?NUM_ITEM_ROWS:1.);\n\tfloat scale = floor(iResolution.y \/ 128.);\n    c \/= scale;\n    vec2 r = iResolution.xy \/ scale;\n    vec4 o = vec4(0);\n    float xStart = (r.x - 16. * NUM_ITEMS) \/ 2.;\n    c.x -= xStart;\n    float selected = load(_selectedInventory).r;\n    vec2 p = (fract(c \/ 16.) - .5) * 3.;\n    vec2 u = vec2(sqrt(3.)\/2.,.5);\n    vec2 v = vec2(-sqrt(3.)\/2.,.5);\n    vec2 w = vec2(0,-1);\n    if (c.x < NUM_ITEMS * 16. && c.x >= 0. && c.y < 16.* h ) {\n        float slot = floor(c.x \/ 16.) + NUM_ITEMS*floor(c.y \/ 16.) ;\n    \to = getTexture(48., fract(c \/ 16.));\n        vec3 b = vec3(dot(p,u), dot(p,v), dot(p,w));\n        vec2 texCoord;\n        \/\/if (all(lessThan(b, vec3(1)))) o = vec4(dot(p,u), dot(p,v), dot(p,w),1.);\n        float top = 0.;\n        float right = 0.;\n        if (b.z < b.x && b.z < b.y) {\n        \ttexCoord = inv2(mat2(u,v)) * p.xy;\n            top = 1.;\n        }\n        else if(b.x < b.y) {\n        \ttexCoord = 1. - inv2(mat2(v,w)) * p.xy;\n            right = 1.;\n        }\n        else {\n        \ttexCoord = inv2(mat2(u,w)) * p.xy;\n            texCoord.y = 1. - texCoord.y;\n        }\n        if (all(lessThanEqual(abs(texCoord - .5), vec2(.5)))) {\n            float id = getInventory(slot);\n            if (id == 3.) id += top;\n            o.rgb = getTexture(id, texCoord).rgb * (0.5 + 0.25 * right + 0.5 * top);\n            o.a = 1.;\n        }\n    }\n    vec4 selection = drawSelectionBox(c - 8. - vec2(16. * mod(selected,NUM_ITEMS), 16.* floor(selected\/NUM_ITEMS)));\n    o = mix(o, selection, selection.a);\n    return o;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float pixelSize = load(_pixelSize).r;\n    vec2 renderResolution = ceil(iResolution.xy \/ pixelSize); \n    fragColor = texture(iChannel3, fragCoord * renderResolution \/ iResolution.xy \/ iResolution.xy);\n    \/\/fragColor = texture(iChannel3, fragCoord);\n    \n    if(load(_inventory).r>.0){   \n   \t     vec4 gui = drawInventory(fragCoord);\n   \t    fragColor = mix(fragColor, gui, gui.a);\n    }\n    \n#ifdef STATS    \n    \/\/DISPLAY STATS IF F3 IS TOGGGLED\n    float stats = load(_stats).r;    \n    if (stats >0.5) {\n        vec3 pos = load(_pos).xyz;\n        \n\n        \/\/POS\n        fragColor = mix( fragColor, vec2(1,.5).xyyx, PrintValue(fragCoord, vec2(0., iResolution.y - 20.), vec2(8,15), pos.x, 5.0, 5.0));\n        fragColor = mix( fragColor, vec2(1,.5).yxyx, PrintValue(fragCoord, vec2(0., iResolution.y - 40.), vec2(8,15), pos.y, 5.0, 5.0));\n        fragColor = mix( fragColor, vec2(1,.5).xxyx, PrintValue(fragCoord, vec2(0., iResolution.y - 60.), vec2(8,15), pos.z, 5.0, 5.0));\n\n        \/\/ANGLE\n        fragColor = mix( fragColor, vec2(1,.5).xyyx, PrintValue(fragCoord, vec2(0., iResolution.y -80.), vec2(8,15),  load(_angle).x, 5.0, 2.0));\n        fragColor = mix( fragColor, vec2(1,.5).xxxx, PrintValue(fragCoord, vec2(50., iResolution.y -80.), vec2(8,15),  load(_angle).y, 5.0, 2.0)); \n \n        \/\/TIME\n        fragColor = mix( fragColor, vec2(1,.5).xxxx , PrintValue(fragCoord, vec2(0., iResolution.y -100.), vec2(8,15), load(_time).r, 5.0, 2.0));\n\n\n        \n        \/\/if (fragCoord.x < 20.) fragColor.rgb = mix(fragColor.rgb, texture(iChannel0, fragCoord \/ iResolution.xy).rgb, texture(iChannel0, fragCoord \/ iResolution.xy).a);\n        \n        \/\/FRAMERATE, MEMORY RANGE, HEIGHT LIMIT, RAY DISTANCE\n        fragColor = mix( fragColor, vec2(1,.5).xxyx, PrintValue(fragCoord, vec2(0.0, 105.), vec2(8,15), load(_pixelSize).r, 5.0, 1.0));\n        fragColor = mix( fragColor, vec2(1,.5).xxyx, PrintValue(fragCoord, vec2(0.0, 85.), vec2(8,15), 1.\/ iTimeDelta, 5.0, 1.0));\n\n#if SURFACE_CACHE>0\n        fragColor = mix( fragColor, vec2(1,.5).yxxx, PrintValue(fragCoord, vec2(0., 65.), vec2(8,15), calcLoadDist_C( iChannelResolution[2].xy), 5.0, 2.0));\n        fragColor = mix( fragColor, vec2(1,.5).xxxx, PrintValue(fragCoord, vec2(0., 45.), vec2(8,15),  heightLimit_C, 5.0, 2.0));\n#endif\n        fragColor = mix( fragColor, vec2(1,.5).xxxx, PrintValue(fragCoord, vec2(0., 25.), vec2(8,15),  load(_rayDistMax).r, 5.0, 2.0));\n\n    }\n\t\n    \/\/ \"BUFFER C\" DUMP\n    if(load(_stats).g>.5) {               \n        vec3 offset = floor(vec3(load(_pos).xy, 0.));\n        vec4  color= texture(iChannel2,fragCoord \/ iResolution.xy);\n        fragColor = color;       \n    }\n    \/\/\"BUFFER A\" DUMP\n\n    if(load(_stats).b>.5) fragColor= texture(iChannel0, fragCoord \/iResolution.xy\/3.);\n\n#endif\n}\n\/*\nCHANGELOG \n\t- 20200425: added elevators\n\t            added repeated towers\n                20200425-1902: fixed map key\n\t- 20200426: new materials; voxel.value to store user actions and prevent override\n         \t    select from inventory with mouse\n    \t \t    more realistic elevator, stabilizing adaptive pixelSize and renderDistance\n                fix: when placing & destroying a block, it becomes invisible\n                fix: tree grows correctly when placed\n                water block not solid and semi-transparent \n    - 20200427: structures are placed randomly; water in caves and water swimming\n                added optional \"#define FAST_COMPILE\" (uncomment row32 of file common to reduce compilation time by half)\n                Pyramids\n                water flow downward\n    - 20200428: water refraction and waves\n\t            fog and clouds\n\t- 20200429: cut compilation time - removed duplicated call to render() in buffer D\n\t- 20200501: compilation optimization and fixed inventory bug\n\t \t\t    replaced voxel traversal algorithm with the one described in \"Voxel Edge Occlusion\" by Iq\n\t \t\t\tskeleton for subvoxels\n\t- 20200502: revised light diffusion and default\n\t- 20200503: added shapes (change shape with \"R\")\n\t            shape rotation ( with \"F\")\n\t- 20200504: shape vertical rotation ( with \"G\") ... not always working\n\t            disabled unecessary keys\n\t            multiselection with \"C\" \n\t- 20200505: shadows; working but unfinished\n\t            fixed shadows (#ifdef SHADOW);now working\n\t- 20200509: webgl 1.0 compatibility and compilation optimization\n\t            compilation optimization\n\t- 20200510: tree detail (can be disable)\n\t            optimization: discard if unused texels in buffer A & C\n\t            revised textures (need to refine) \n\t            refactoring - merged buffer A & buffer C with better performances\n\t- 20200511: refactoring in buffer B neightbour scan; grass prototype\n\t            grass rendering from https:\/\/www.shadertoy.com\/view\/MdsGzS\n\t- 20200512: configurable cloud density , grass height & pathway\n\t- 20200513: inventory toggle with \"I\" \n\t            proof of concept: electriciy with gold=source, diamond=wire\n\t- 20200514: lighing of unconnected blocks or sand with more than 4 horizontal steps\n\t            falling sand if  more than 4 horizontal steps\n\t- 20200515: demo mode at start\n\t- 20200518: minimalist mirror (red block)\n\t- 20200520: revised encode\/decodeVoxel in order to exploit al 64 pixel bits\n\t- 20200522: refactoring calcOcclusion()\n\t- 20200523: mouse double click \n\t- 20200524: refactoring: reused raycasting in buffer D for mouse pointer\n\t- 20200526: added buffer C(surface cache) and other refactoring\n\t- 20200603: added water physics and water source (pink marble) - work in progress\n\t- 20200608: performance optimization and revised subvoxel rendering with SUBTEXTURE\n\t- 20200609: refactoring calcOcclusion (less code & reduced compilation time)\n\t            refactoring reflection (mirror block) and refraction (water)\n\t- 20200611: heightmap cache in buffer C (much faster and many new possibilities)\n\t            far trees (work in progress)\n\t- 20200612: fixed shadows & occlusion  for subvoxels\n                map view rotation, detailed buildings, configurable building distance\n\t- 20200625: variable water level (50% of the territory is flooded)\n\t- 20200704: more realistic water refraction and reflection (inspired by Venice shader)\n\t- 20200712: pseudo Fresnel reflection \n\t- 20200723: enable\/disable torch(F7) and water flow (F8)\n\nTODO LIST:\n\t- substitute buffer B\/C with cubemap  (done but not working https:\/\/www.shadertoy.com\/view\/3t2yWR)\n\t- more shapes and materials \n\t- more menus (shape, rotation, etc..) \n\t- circuits (wire, gate, flip-flop, sensor, etc...) --> in a fork\n\t- portals\n    - constructions: bridge, tower,wall, road\n\t- explosions\n\n*\/",
            "name": "Image",
            "description": "",
            "type": "image"
        },
        {
            "inputs": [],
            "outputs": [],
            "code": "\/* ----------------------------------------------------------\n\tCONFIGURABLE SETTINGS\n\/\/----------------------------------------------------------*\/\n\/\/  MAX_PICK_DISTANCE: distance for block selection with mouse (default = 10)\n#define MAX_PICK_DISTANCE 10.\n\/\/  FAST_NOISE: use cheaper noise function \n#define FAST_NOISE\n\/\/\tOCCLUSION: enable voxel occlusion\n#define OCCLUSION\n\/\/  SUBVOXEL: enable shapes actions with keys R,F,G\n#define SUBVOXEL\n\/\/\tSUBTEXTURE: apply texture scaled on subvoxels (more detailed but aliased)\n#define SUBTEXTURE\n\/\/\tTREE_DETAIL: if enabled, tree blocks are detailed with subvoxels \n#define TREE_DETAIL\n\/\/\tTREE SIZE: height of the trees \n#define TREE_SIZE 3.\n\/\/  GRASS_DETAIL: enable grass\n#define GRASS_DETAIL\n\/\/  SHADOW 0.=disabled else shadow intensity\n#define SHADOW 1.\n\/\/  CLOUDS 0.=disabled else cloud density (*)\n\/\/#define CLOUDS 1.5\n\/\/  FALLING_SAND: sand blocks fall if unstable \n\/\/#define FALLING_SAND\n\/\/  MAP: map rendering\n#define MAP\n\/\/\tHIGHLIGHT 0.=disabled else higlight of  unconnected blocks, sand with 4+ horizontal steps, cascading diamonds connected to gold\n#define HIGHLIGHT 0.\n\/\/\tSURFACE_CACHE:  secondary cache mode with buffer C (1=surface blocks,2=heightmap,0=disabled)\n#define SURFACE_CACHE 2 \n\/\/\tSTRUCTURES: build pyramids & towers; values 0=none, 1=basic, 2=detailed\n#define STRUCTURES 2 \n\/\/  STATS: display debug info if F3,F4,F5 keys pressed \n\/\/#define STATS\n\/\/\tFLAT: flat world\n\/\/#define FLAT\n\/\/  XRAY_MODE: fly mode, with no collisions and transparent blocks (*)\n\/\/#define XRAY_MODE\n\/\/ \tEXCLUDE_CACHE:view only mode, with disabled buffer B \n\/\/#define EXCLUDE_CACHE\n\/\/\tWATER_LEVEL: level of water (10.=caves, 55.= islands); 50% of the areas use WATER_LEVEL2\n#define WATER_LEVEL 12.\n#define WATER_LEVEL2 45.\n\/\/\tWATER_FLOW: enable water flow (value= levelling distance)\n#define WATER_FLOW 250.\n\/\/  BUILD_DISTANCE average distance between costructions\n#define BUILD_DISTANCE 160.\n\n\/\/ flickering light from fireflies at night\n#define FIREFLIES\n\n\/\/------------------------------------------------------\n\n\/\/SHARED VARIABLES\n#define var(name, x, y) const vec2 name = vec2(x, y)\n#define varRow 0.\n#define load( coord)  texture(iChannel0, vec2((floor(coord) + 0.5) \/ iChannelResolution[0].xy)) \n#define getTexture( id,  c) texture(iChannel0, 16. * (clamp(c,0.001,.999) + vec2(mod(id, 8.), floor(id \/ 8.)+2.)) \/ iChannelResolution[0].xy, 0.0)\n\n\/\/shared variables are stored in buffer A where  y=0\nvar(_pos, 0, varRow);\/\/_old _pos\nvar(_angle, 2, varRow);\nvar(_mouse, 3, varRow);\nvar(_loadRange_B, 4, varRow);\nvar(_loadRange_C, 5, varRow);\nvar(_vel, 6, varRow);\nvar(_pick, 7, varRow);\/\/_old _pick\nvar(_pickTimer, 8, varRow);  \/\/_old _pickTimer\nvar(_renderScale, 9, varRow);\nvar(_selectedInventory, 10, varRow);\nvar(_flightMode, 11, varRow);\nvar(_sprintMode, 12, varRow);\nvar(_time, 13, varRow);\nvar(_stats, 14, varRow);\nvar(_rayDistMax,15,varRow);\nvar(_loadDistLimit,16,varRow);\nvar(_rayLimit,17,varRow);\nvar(_map,18,varRow);\nvar(_pixelSize,19,varRow);\nvar(_inventory,20,varRow);\nvar(_demo,21,varRow);\nvar(_mouseBusy,22,varRow);\nvar(_torch,23,varRow);\nvar(_flow,24,varRow);\n\/\/old value are stored in rows with y=n where n is the iFrame difference\nvar(_old, 0, 1); \n\n\/\/BUFFER B\nconst int  BUFFER_B = 1;\nconst vec2 packedChunkSize_B = vec2(13,7);\nconst float heightLimit_B = packedChunkSize_B.x * packedChunkSize_B.y;\n\n\/\/BUFFER C\n#if SURFACE_CACHE==1\nconst int  BUFFER_C = 2;\nconst float SURFACE_C=45.;\nconst vec2 packedChunkSize_C = vec2(7,4);\nconst float heightLimit_C = packedChunkSize_C.x * packedChunkSize_C.y ;\n#elif SURFACE_CACHE==2\nconst int  BUFFER_C = 2;\nconst vec2 packedChunkSize_C = vec2(1,1);\nconst float heightLimit_C = packedChunkSize_C.x * packedChunkSize_C.y ;\n#endif\n\n\n\/\/INVENTORY ITEMS FOR EACH ROW\nconst float NUM_ITEMS=8.;\n\/\/INVENTORY ROWS\nconst float NUM_ITEM_ROWS=2.;\n\/\/\nconst float N_SUBVOXEL=5.;\n\/\/ USED BY FALLING SANDS\nconst float MAX_GROUND=45.;\n\n   \n\/\/ VOXEL CACHE FUNCTION\nvec2 unswizzleChunkCoord(vec2 storageCoord) {\n \tvec2 s = floor(storageCoord);\n    float dist = max(s.x, s.y);\n    float offset = floor(dist \/ 2.);\n    float neg = step(0.5, mod(dist, 2.)) * 2. - 1.;\n    return neg * (s - offset);\n}\n\nvec2 swizzleChunkCoord(vec2 chunkCoord) {\n    vec2 c = chunkCoord;\n    float dist = max(abs(c.x), abs(c.y));\n    vec2 c2 = floor(abs(c - 0.5));\n    float offset = max(c2.x, c2.y);\n    float neg = step(c.x + c.y, 0.) * -2. + 1.;\n    return (neg * c) + offset;\n}\n\n\nfloat calcLoadDist_B(vec2 iResolutionxy) {\n    vec2  chunks = floor(iResolutionxy \/ packedChunkSize_B); \n    float gridSize = min(chunks.x, chunks.y);    \n    return floor((gridSize - 1.) \/ 2.);\n}\n\nvec4 calcLoadRange_B(vec2 pos,vec2 iResolutionxy, float border) {\n\tvec2 d = (calcLoadDist_B(iResolutionxy) - border)* vec2(-1,1);\n    return floor(pos).xxyy + d.xyxy;\n}\n\n#if SURFACE_CACHE>0\nfloat calcLoadDist_C(vec2 iResolutionxy) {\n    vec2  chunks = floor(iResolutionxy \/ packedChunkSize_C); \n    float gridSize = min(chunks.x, chunks.y);    \n    return floor((gridSize - 1.) \/ 2.);\n}\n\nvec4 calcLoadRange_C(vec2 pos,vec2 iResolutionxy, float border) {\n\tvec2 d = (calcLoadDist_C(iResolutionxy) - border)* vec2(-1,1);\n    return floor(pos).xxyy + d.xyxy;\n}\n#endif \n\nvec3 texToVoxCoord(vec2 textelCoord, vec3 offset,int bufferId) {\n#if SURFACE_CACHE>0\n    vec2 packedChunkSize= bufferId==1?packedChunkSize_B:packedChunkSize_C;\n#else\n    vec2 packedChunkSize= packedChunkSize_B;\n#endif\n\tvec3 voxelCoord = offset;\n    voxelCoord.xy += unswizzleChunkCoord(textelCoord \/ packedChunkSize);\n    voxelCoord.z += mod(textelCoord.x, packedChunkSize.x) + packedChunkSize.x * mod(textelCoord.y, packedChunkSize.y);\n    return voxelCoord;\n}\n\nvec2 voxToTexCoord(vec3 voxCoord,int bufferId) {\n#if SURFACE_CACHE>0\n    vec2 packedChunkSize= bufferId==1?packedChunkSize_B:packedChunkSize_C;\n#else\n    vec2 packedChunkSize= packedChunkSize_B;\n#endif\n    vec3 p = floor(voxCoord);\n    return swizzleChunkCoord(p.xy) * packedChunkSize + vec2(mod(p.z, packedChunkSize.x), floor(p.z \/ packedChunkSize.x));\n}\n\n\nstruct voxel {\n\tfloat id;\n    int value; \/\/1=modified,2=selected,3=falling\n    vec2 light;\n    float life;\n    int shape;\n    float rotation;\n    float ground;\n    float surface;\n    int buffer;\n     \n};\n \n\/\/from https:\/\/www.shadertoy.com\/view\/wsBfzW\nfloat gb(float c, float start, float bits){return mod(floor(c\/pow(2.,start)),pow(2.,bits));}\/\/get bits\n\n\/\/lazy version:\n\/\/#define sb(f,s,b,v) f+=(v-gb(f,s,b))*pow(2.,s)\n\/\/strict version (use in case of strange behaviours):\n#define sb(f,s,b,v) f+=(clamp(floor(v+.5),0.,pow(2.,b)-1.)-gb(f,s,b))*pow(2.,s)\n\n\/\/ each voxel is decoded\/encoded with the pixel 64 bits\n\/\/ r bit 1-6 id        bit 7-8 value     bit 9-12 light.s   bit 13-16 light.t\n\/\/ g bit 1-8 unused    bit 9-16 life\n\/\/ b bit 1-4 shape     bit 5-8 rotation  bit 9-16 unused \n\/\/ a bit 1-8 ground                      bit 9-16 surface\nvoxel decodeVoxel(vec4 t) {\n\tvoxel o;\n    o.id        = gb(t.r,0., 6.);\n    o.value     = int(gb(t.r,6., 2.));\n    \n    o.light.s   = gb(t.r,8., 4.) ;\n    o.light.t   = gb(t.r,12., 4.);\n    o.life      = gb(t.g,8., 9.);\n    \n    o.shape     = int(gb(t.b,0., 4.));\n    o.rotation  = gb(t.b,4., 4.);\n    \n    o.ground    = gb(t.a,0., 8.);\n    o.surface   = gb(t.a,8., 8.);\n    return o;\n}\n\nvec4 encodeVoxel(voxel v) {\n\tvec4 t=vec4(0.);\n    sb(t.r,0.,6.,v.id);\n    sb(t.r,6.,2.,float(v.value));\n    \n    sb(t.r,8.,4.,v.light.s);\n    sb(t.r,12.,4.,v.light.t);\n    sb(t.g,8.,9.,v.life); \n    \n    sb(t.b,0.,4.,float(v.shape));\n    sb(t.b,4.,4.,v.rotation);\n    \n    sb(t.a,0.,8.,v.ground);\n    sb(t.a,8.,8.,v.surface);\n    return t;\n}\n\nfloat lightDefault(float z){\n\tif(z>55.) return 15.;\n    else if(z>45.) return 14.; \n    else if(z>35.) return 11.; \n    else if(z>10.) return 8.;\n    else return 5.;\n}\n\nvoxel newVox(float z){\n    voxel vox;\n    vox.life=0.;\n    vox.rotation=0.;\n    vox.value=0;\n    vox.shape=0;\n    vox.ground=200.;\n    vox.surface=0.;\n\tvox.id=0.;\n    vox.light.t = z>10.? 0.:12.;\n    vox.light.s = lightDefault(z);\n \tvox.id=0.;\n    vox.buffer=0;\n    return vox;\n}\n\nvec4 readMapTex(vec2 pos, sampler2D iChannel,vec3 resolution) {\n    return texture(iChannel, (floor(pos) + 0.5) \/  (floor (resolution.xy)), 0.0);   \n \n}\n\n\nvoxel getCachedVoxel(vec3 p,sampler2D iChannel,vec3 resolution,int bufferId) {\n    if(p.z>heightLimit_B || p.z<0.){voxel vox; vox.id=0.; return vox;}\n    voxel vox= decodeVoxel(readMapTex(voxToTexCoord(p, bufferId),iChannel,resolution));\n    vox.buffer=bufferId;\n    return vox;\n}\n\n\nfloat isSolidVoxel(voxel vox) {\n    \n    return (vox.id==0. || vox.id==12. ||vox.id==26.)?0.:1.;\n}\n\nfloat getInventory(float slot) {\n\treturn slot + 1. + step(2.5, slot);  \n}\n\n\n\n\/\/ WORLD GENERATION \n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\nconst float PI = 3.14159265359;\n\n\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453);\n}\n\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n    \nfloat hash2(in vec2 p) { return hash(dot(p, vec2(87.1, 313.7))); }\n\nvec2 hash22(in float p) {\n\tfloat x = hash(p);\n\treturn vec2(x, hash(p+x));\n}\n\/\/vec2 hash22(in vec2 p) { return hash2(dot(p, vec2(87.1, 313.7))); }\n\n\nvec2 hash22( vec2 p ) \n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract(vec4((p4.x + p4.y)*p4.z, (p4.x + p4.z)*p4.y, (p4.y + p4.z)*p4.w, (p4.z + p4.w)*p4.x));\n}\n\n\n\/\/ Fork of \"Optimized Ashima SimplexNoise3D\" by Makio64. https:\/\/shadertoy.com\/view\/Xd3GRf\n\/\/ 2020-04-23 14:52:01\n\n\/\/ Optimized AshimaSimplexNoise by @makio64 https:\/\/www.shadertoy.com\/view\/Xd3GRf\n\/\/ Original : https:\/\/github.com\/ashima\/webgl-noise\/blob\/master\/src\/noise3D.glsl\n\n#ifndef FAST_NOISE\nlowp vec4 permute(in lowp vec4 x){return mod(x*x*34.+x,289.);}\nlowp float snoise(in mediump vec3 v){\n  const lowp vec2 C = vec2(0.16666666666,0.33333333333);\n  const lowp vec4 D = vec4(0,.5,1,2);\n  lowp vec3 i  = floor(C.y*(v.x+v.y+v.z) + v);\n  lowp vec3 x0 = C.x*(i.x+i.y+i.z) + (v - i);\n  lowp vec3 g = step(x0.yzx, x0);\n  lowp vec3 l = (1. - g).zxy;\n  lowp vec3 i1 = min( g, l );\n  lowp vec3 i2 = max( g, l );\n  lowp vec3 x1 = x0 - i1 + C.x;\n  lowp vec3 x2 = x0 - i2 + C.y;\n  lowp vec3 x3 = x0 - D.yyy;\n  i = mod(i,289.);\n  lowp vec4 p = permute( permute( permute(\n\t  i.z + vec4(0., i1.z, i2.z, 1.))\n\t+ i.y + vec4(0., i1.y, i2.y, 1.))\n\t+ i.x + vec4(0., i1.x, i2.x, 1.));\n  lowp vec3 ns = .142857142857 * D.wyz - D.xzx;\n  lowp vec4 j = -49. * floor(p * ns.z * ns.z) + p;\n  lowp vec4 x_ = floor(j * ns.z);\n  lowp vec4 x = x_ * ns.x + ns.yyyy;\n  lowp vec4 y = floor(j - 7. * x_ ) * ns.x + ns.yyyy;\n  lowp vec4 h = 1. - abs(x) - abs(y);\n  lowp vec4 b0 = vec4( x.xy, y.xy );\n  lowp vec4 b1 = vec4( x.zw, y.zw );\n  lowp vec4 sh = -step(h, vec4(0));\n  lowp vec4 a0 = b0.xzyw + (floor(b0)*2.+ 1.).xzyw*sh.xxyy;\n  lowp vec4 a1 = b1.xzyw + (floor(b1)*2.+ 1.).xzyw*sh.zzww;\n  lowp vec3 p0 = vec3(a0.xy,h.x);\n  lowp vec3 p1 = vec3(a0.zw,h.y);\n  lowp vec3 p2 = vec3(a1.xy,h.z);\n  lowp vec3 p3 = vec3(a1.zw,h.w);\n  lowp vec4 norm = inversesqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  lowp vec4 m = max(.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.);\n  return -0.334 +.5 + 12. * dot( m * m * m, vec4( dot(p0,x0), dot(p1,x1),dot(p2,x2), dot(p3,x3) ) );\n}\n\/\/ Optimized Ashima Simplex noise2D by @makio64 https:\/\/www.shadertoy.com\/view\/4sdGD8\n\/\/ Original shader : https:\/\/github.com\/ashima\/webgl-noise\/blob\/master\/src\/noise2D.glsl\n\/\/ snoise return a value between 0 & 1\n\nlowp vec3 permute(in lowp vec3 x) { return mod( x*x*34.+x, 289.); }\nlowp float snoise(in lowp vec2 v) {\n  lowp vec2 i = floor((v.x+v.y)*.36602540378443 + v),\n      x0 = (i.x+i.y)*.211324865405187 + v - i;\n  lowp float s = step(x0.x,x0.y);\n  lowp vec2 j = vec2(1.0-s,s),\n      x1 = x0 - j + .211324865405187, \n      x3 = x0 - .577350269189626; \n  i = mod(i,289.);\n  lowp vec3 p = permute( permute( i.y + vec3(0, j.y, 1 ))+ i.x + vec3(0, j.x, 1 )   ),\n       m = max( .5 - vec3(dot(x0,x0), dot(x1,x1), dot(x3,x3)), 0.),\n       x = fract(p * .024390243902439) * 2. - 1.,\n       h = abs(x) - .5,\n      a0 = x - floor(x + .5);\n  return -0.278 + .5 + 65. * dot( pow(m,vec3(4.))*(- 0.85373472095314*( a0*a0 + h*h )+1.79284291400159 ), a0 * vec3(x0.x,x1.x,x3.x) + h * vec3(x0.y,x1.y,x3.y));\n}\n#endif\n\n#ifdef FAST_NOISE\nfloat snoise( in vec2 p )\n{\n    const float K1 = 0.366025404; \/\/ (sqrt(3)-1)\/2;\n    const float K2 = 0.211324865; \/\/ (3-sqrt(3))\/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash22(i+0.0)), dot(b,hash22(i+o)), dot(c,hash22(i+1.0)));\n    \n    return dot( n, vec3(70.0) );\n}\n\nfloat noise3D(vec3 p)\n{\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,128.852))) * 43758.5453)*2.0-1.0;\n}\nfloat snoise(vec3 p)\n{\n \t\n\tfloat f3 = 1.0\/3.0;\n\tfloat s = (p.x+p.y+p.z)*f3;\n\tint i = int(floor(p.x+s));\n\tint j = int(floor(p.y+s));\n\tint k = int(floor(p.z+s));\n\t\n\tfloat g3 = 1.0\/6.0;\n\tfloat t = float((i+j+k))*g3;\n\tfloat x0 = float(i)-t;\n\tfloat y0 = float(j)-t;\n\tfloat z0 = float(k)-t;\n\tx0 = p.x-x0;\n\ty0 = p.y-y0;\n\tz0 = p.z-z0;\n\t\n\tint i1,j1,k1;\n\tint i2,j2,k2;\n\t\n\tif(x0>=y0)\n\t{\n\t\tif(y0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; } \/\/ X Y Z order\n\t\telse if(x0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; } \/\/ X Z Y order\n\t\telse { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }  \/\/ Z X Z order\n\t}\n\telse \n\t{ \n\t\tif(y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; } \/\/ Z Y X order\n\t\telse if(x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; } \/\/ Y Z X order\n\t\telse { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; } \/\/ Y X Z order\n\t}\n\t\n\tfloat x1 = x0 - float(i1) + g3; \n\tfloat y1 = y0 - float(j1) + g3;\n\tfloat z1 = z0 - float(k1) + g3;\n\tfloat x2 = x0 - float(i2) + 2.0*g3; \n\tfloat y2 = y0 - float(j2) + 2.0*g3;\n\tfloat z2 = z0 - float(k2) + 2.0*g3;\n\tfloat x3 = x0 - 1.0 + 3.0*g3; \n\tfloat y3 = y0 - 1.0 + 3.0*g3;\n\tfloat z3 = z0 - 1.0 + 3.0*g3;\t\n\t\t\t\t \n\tvec3 ijk0 = vec3(i,j,k);\n\tvec3 ijk1 = vec3(i+i1,j+j1,k+k1);\t\n\tvec3 ijk2 = vec3(i+i2,j+j2,k+k2);\n\tvec3 ijk3 = vec3(i+1,j+1,k+1);\t\n            \n\tvec3 gr0 = normalize(vec3(noise3D(ijk0),noise3D(ijk0*2.01),noise3D(ijk0*2.02)));\n\tvec3 gr1 = normalize(vec3(noise3D(ijk1),noise3D(ijk1*2.01),noise3D(ijk1*2.02)));\n\tvec3 gr2 = normalize(vec3(noise3D(ijk2),noise3D(ijk2*2.01),noise3D(ijk2*2.02)));\n\tvec3 gr3 = normalize(vec3(noise3D(ijk3),noise3D(ijk3*2.01),noise3D(ijk3*2.02)));\n\t\n\tfloat n0 = 0.0;\n\tfloat n1 = 0.0;\n\tfloat n2 = 0.0;\n\tfloat n3 = 0.0;\n\n\tfloat t0 = 0.5 - x0*x0 - y0*y0 - z0*z0;\n\tif(t0>=0.0)\n\t{\n\t\tt0*=t0;\n\t\tn0 = t0 * t0 * dot(gr0, vec3(x0, y0, z0));\n\t}\n\tfloat t1 = 0.5 - x1*x1 - y1*y1 - z1*z1;\n\tif(t1>=0.0)\n\t{\n\t\tt1*=t1;\n\t\tn1 = t1 * t1 * dot(gr1, vec3(x1, y1, z1));\n\t}\n\tfloat t2 = 0.5 - x2*x2 - y2*y2 - z2*z2;\n\tif(t2>=0.0)\n\t{\n\t\tt2 *= t2;\n\t\tn2 = t2 * t2 * dot(gr2, vec3(x2, y2, z2));\n\t}\n\tfloat t3 = 0.5 - x3*x3 - y3*y3 - z3*z3;\n\tif(t3>=0.0)\n\t{\n\t\tt3 *= t3;\n\t\tn3 = t3 * t3 * dot(gr3, vec3(x3, y3, z3));\n\t}\n\treturn 96.0*(n0+n1+n2+n3);\n\t\n}\n\n#endif\n\nbool overworld(vec3 p) {\n\tfloat density = 48. - p.z;\n    density += mix(0., 40., pow(.5 + .5 * snoise(p.xy \/557. + vec2(0.576, .492)), 2.)) * snoise(p \/ 31.51 + vec3(0.981, .245, .497));\n\n    return density > 0.;\n}\n\n\/\/https:\/\/www.iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat sdCross( vec3 p, vec3 b )\n{\n  float d1 = length(max( abs(p) - b,0.));\n  float d2 = length(max( abs(p) - b.zyx,0.));\n  float d3 = length(max( abs(p) - b.xzy,0.));\n  return min(d1, min(d2,d3));\n}\n\n\nvoxel getGeneratedVoxel(vec3 voxelCoord,bool caves,int frame){\n\n    \tvoxel vox=newVox(voxelCoord.z);\n#ifdef FLAT\n    \tvox.id=(voxelCoord.z>=50.?0.:3.);\n#else \n    \n    \tbool layer[4];\n    \tfor (int i =0; i <=3 ; i++) {\n            float h;\n            if(i==1) h=1.; \n            else if(i==2) h=3.; \n            else if(i==3)  h=-1.; \n            else h=0.;\n            \n            layer[i+min(frame,0)]=overworld(voxelCoord+ vec3(0,0,h));\n            if(!layer[0]) break;\n        }\n         \n    \tbool solid = layer[0];\n    \n   \n        if (solid) {\n            \/\/GRASS\n            vox.id = 3.;\n                             \n            \/\/DIRT\n            if (layer[1]) vox.id = 2.; \n            \/\/ROCK\n            if (layer[2]) vox.id = 1.; \n            \/\/TORCH\n            if (hash13(voxelCoord) > 0.98 && !layer[3]) {vox.id = 6.;vox.light.t = 15.;}\n \n            \/\/TREE BASE\n            if (hash13(voxelCoord) > 0.98 && !layer[1]) {vox.id = 10.;vox.life = 2.+ TREE_SIZE; vox.shape=9;}\n\n             \/\/ CAVE\n            if(caves){\n                caves=snoise(voxelCoord \/ 27.99 + vec3(0.981, .245, .497).yzx * 17.) > 1. - (smoothstep(0., 5., voxelCoord.z) - 0.7 * smoothstep(32., 48., voxelCoord.z));\n\t        \tif (caves) {vox.id = 0.;}\n            }\n        } \n \t    \n    \t\/\/WATER\n    \tif(vox.id == 0. && voxelCoord.z < WATER_LEVEL) {\n            vox.id=12.; \n            if(voxelCoord.z > WATER_LEVEL -2.) vox.shape=3;\n#ifdef WATER_FLOW\n            vox.life=WATER_FLOW;    \n#endif                \n         }\n        \/\/GEMS\n        if (hash13(voxelCoord) > 0.995 && voxelCoord.z < 20.  &&  vox.id!=12. && vox.id!=0. ) {if(hash13(voxelCoord +vec3(1.))>.5) vox.id = 6.; else vox.id=8.;}    \n        \/\/BEDROCK\n        if (voxelCoord.z < 1.) vox.id = 16.; \n    \n#if STRUCTURES>0    \n    \t\/\/ STRUCTURES REPEATED EVERY BUILD_DISTANCE SQUARE\n    \tvec3  buildCoord = vec3(floor((voxelCoord.xy -vec2(3260. -40.,9650. -40.))\/BUILD_DISTANCE)*BUILD_DISTANCE,0.)   +vec3(3260.,9650.,50.);\n \t\t\/\/RANDOM POSITION INSIDE THE 80x80 SQUARE\t buildCoord += hash33(buildCoord)\n    \tif(length(voxelCoord.xy -vec2(3260, 9650.))>50.) buildCoord += floor(hash33(buildCoord) *vec3(50.,50, .10)) -vec3(25.,25, 5.);\n   \n    \tfloat type =hash13(buildCoord);\n    \tfloat type2 =hash13(buildCoord+vec3(1.));\n        if(type2>.5 && vox.id == 0. && voxelCoord.z < WATER_LEVEL2) {\n            vox.id=12.; \n#ifdef WATER_FLOW\n            vox.life=WATER_FLOW;\n            \n            \n            if(voxelCoord.z > WATER_LEVEL2-2.) vox.shape=3; else vox.shape=0;\n#endif                \n         }\n    \tif(type<.2) {\n            \/\/PYRAMID          \n            if(sdOctahedron(voxelCoord -  buildCoord -vec3(-2.,-3.,2.),30.)<=0.) vox.id=13.;\n\n        }\n    \telse{\n\n            \/\/TOWER\n             if(length(voxelCoord.xy - buildCoord.xy - vec2(-2.,-3.))<2.  && voxelCoord.z <75.)  {vox.id=1.;  vox.light.t=8.;}\n            if(length(voxelCoord - buildCoord  - vec3(-2.,-3.,30.))<1.5)  {vox.id=6.;  vox.light.t=15.;}\n        }\n#endif\n    \n#endif\n        \n  \t\n        return vox;\n\t\t\n}\n\n\n\n\/\/ MIX PROCEDURAL AND MEMORY VOXEL\nbool inRange(vec2 p, vec4 r) {\n\treturn (p.x > r.x && p.x < r.y && p.y > r.z && p.y < r.w);\n}\n\n\n\nvoxel getVoxelData( vec3 voxelCoord,\n                    sampler2D iChannel_B, \n                    sampler2D iChannel_C, \n                    int frame, \n                    vec3 resolution_B, \n                    vec3 resolution_C,\n                    vec4 range_B,\n                    vec4 range_C,\n                    vec3 offset,\n                    bool caves,\n                    int caller){\n  \n#ifdef EXCLUDE_CACHE\n    return getGeneratedVoxel(voxelCoord,true,frame); \n#else    \n    \n \n    if (inRange(voxelCoord.xy,range_B) && frame > 0 && voxelCoord.z <heightLimit_B  \n        && (caller!=2)  \/\/comment this line to enable persistence between cache (doesn't handle resolution change)\n       ) {\n        return getCachedVoxel(voxelCoord  - offset,iChannel_B,resolution_B,BUFFER_B); \n        \n    }\n#if SURFACE_CACHE==1     \n     if (inRange(voxelCoord.xy,range_C) && frame > 0  \n               &&  voxelCoord.z >= SURFACE_C\n         \t\t&& voxelCoord.z <heightLimit_C +SURFACE_C\n              \/\/&& (caller!=1) \/\/\n              \n             ) {\n        return getCachedVoxel(voxelCoord - vec3(0.,0.,SURFACE_C) - offset,iChannel_C,resolution_C,BUFFER_C); \n         \n    }\n#elif SURFACE_CACHE==2\n    if (inRange(voxelCoord.xy,range_C) && frame > 0){\n         if ( voxelCoord.z >= 0.&& voxelCoord.z <heightLimit_C  && (caller==2) ) {\n            \/\/ BUFFER C previous frame\n        \treturn getCachedVoxel(voxelCoord - offset,iChannel_C,resolution_C,BUFFER_C); \n         }\n        if(caller!=2){\n        \tvoxel vo= getCachedVoxel(vec3(voxelCoord.xy,0.) - offset,iChannel_C,resolution_C,BUFFER_C);\n         \tif(vo.ground>0. && vo.ground< heightLimit_B  ){\n                \/\/Above max height of BUFFER C --> air\n                float h=voxelCoord.z-vo.ground;\n                if(h==0. ) { return vo;}\n                \n                voxel vox=newVox(voxelCoord.z);\n             \tif(h>0. && caller==3) { \n                   \t\/\/GRASS\n                    if(h==1. &&vo.id==3.) vox.life=1.;\n                    \/\/TREE TRUNK\n                    if(h<TREE_SIZE+2. && vo.id==10. && vo.ground >= WATER_LEVEL-1.) {vox.id=10.; vox.life=2.+TREE_SIZE-h; ; vox.shape=9;}                   \n                    return vox;\n                }\n             \t\n                if(h>-3. && h<0. && vo.id==11. && caller==3) {\n                    \/\/TREE LEAFS\n                    vox.id=11.; \n                    vox.shape=8;\n                    vox.life=0.;\n                    return vox;\n                }\n\t\t\t\t\t\n         \t}\n         }\n    }    \n#endif\n  \n    return getGeneratedVoxel(voxelCoord,caves,frame);\n#endif\n}\n\n#define getCVoxel(p,v,id)           \\\n\t{vec2 frame=(id!=3&&id!=0?_old:vec2(0.) );\\\n    vec4 range_B = load(frame+_loadRange_B);  \\\n    vec4 range_C = load(frame+_loadRange_C);  \\\n    vec3 offset =(id==0?vec3(0.): floor(vec3(load(frame+_pos).xy, 0.)));   \\\n    if(id==2)  v= getCachedVoxel(p-offset,iChannel2,iChannelResolution[2],2); \\\n    else v= getCachedVoxel(p-offset,iChannel1,iChannelResolution[1],1);}\n\n\n#define getVoxel(p,v,id)           \\\n\t{vec2 frame=(id!=3&&id!=0?_old:vec2(0.) );\\\n    vec4 range_B = load(frame+_loadRange_B);  \\\n    vec4 range_C = load(frame+_loadRange_C);  \\\n    vec3 offset =(id==0?vec3(0.): floor(vec3(load(frame+_pos).xy, 0.)));   \\\n    v= getVoxelData(p,iChannel1,iChannel2,iFrame,iChannelResolution[1],iChannelResolution[2],range_B,range_C,offset,true,id);}\n\n\n\nvoid structures(vec3 voxelCoord, inout voxel vox, vec3 oldOffset, int iFrame, float iTime){\n\n    \/\/ STRUCTURES REPEATED EVERY 80x80 SQUARE  \n    vec3  buildCoord = vec3(floor((oldOffset.xy -vec2(3260. -40.,9650. -40.))\/BUILD_DISTANCE)*BUILD_DISTANCE,0.)   +vec3(3260.,9650.,50.);\n    \/\/vec3  buildCoord= +vec3(3260.,9650.,50.);\n\n\n    \/\/RANDOM POSITION INSIDE THE 80x80 SQUARE\n    if(length(oldOffset.xy -vec2(3260, 9650.))>50.) buildCoord += floor(hash33(buildCoord) *vec3(50.,50, .10)) -vec3(25.,25, 5.);\n    \n    \/\/REBUILD EVERY 30 FRAMES\n\n    if(iFrame==0 || (mod(float(iFrame),30.)==0.)  && vox.value<1){\n\n   float type =hash13(buildCoord);\n#if STRUCTURES==2\n         \n    \tif(type<.2) {\n            \/\/PYRAMID          \n\n            if(abs(sdOctahedron(voxelCoord -  buildCoord -vec3(-2.,-3.,2.),31.))<.5\n              && abs(voxelCoord.x-buildCoord.x+2.)<.5 && voxelCoord.y-buildCoord.y>-2.\n               && voxelCoord.z>48.\n              ) {vox.id=1.; vox.shape=6;}\n\n   \t\t }\n#endif\n    \n        \/\/TOWER\n        if(length(voxelCoord.xy - buildCoord.xy - vec2(-2.,-3.))<2.  && voxelCoord.z <75.)  {vox.id=1.;vox.shape=0;}\n        if(length(voxelCoord.xy - buildCoord.xy - vec2(-2.,-3.))<1.  && voxelCoord.z <75.)  {vox.id=14.;vox.shape=0;}\n        if(WATER_LEVEL<35. ){\n            \n             \/\/CAVE IF UNDER TERRAIN LEVEL\n            if(sdBox(voxelCoord-  buildCoord - vec3(0.,0.,-4.), vec3(10.,9.,4.)) <.5){ vox.id=1.;vox.shape=0;}\n       \t\t if(sdBox(voxelCoord-  buildCoord - vec3(0.,0.,-4.), vec3(8.,7.,2.)) <.5) vox.id=0.;\n            \/\/HOUSE\n            float house=sdBox(voxelCoord- buildCoord - vec3(-0.5,5.,-4.5), vec3(2.5,3.,2.5));\n            if( abs(house) <.5 ) {vox.id=7.;vox.shape=0; }\n\n            if(sdBox(voxelCoord- buildCoord- vec3(.5,1.,-7.), vec3(6.,8.,0.5)) <.5) {vox.id=9.;vox.shape=0;}\n            if(sdBox(voxelCoord- buildCoord- vec3(2.,4.,-5.), vec3(.1,.1,1.5)) <.5) vox.id=0.;\n            if(sdBox(voxelCoord- buildCoord- vec3(2.,6.,-5.), vec3(.1,.1,1.5)) <.5) {vox.id=14.;vox.shape=0;}\n\n            if(length(voxelCoord - buildCoord - vec3(3.,5.,-2.))<0.5)  {vox.id=6.; vox.shape=0; vox.light.t=15.;}\n            if(length(voxelCoord - buildCoord- vec3(3.,3.,-2.))<0.5)  {vox.id=6.; vox.shape=0; vox.light.t=15.;}\n            if(length(voxelCoord - buildCoord- vec3(-2.,7.,-4.))<0.5)  {vox.id=6.; vox.shape=0; vox.light.t=15.;}\n\n\n            \/\/WATER SOURCE\n            if(length(voxelCoord - buildCoord- vec3(+22.,4.,-8.))<0.5)  {vox.id=15.; vox.shape=0; }\n\n            \/\/POOL\n            \/\/if(sdBox(voxelCoord-  buildCoord - vec3(7.,10.,-9.), vec3(2.,2.,2.)) <.5) vox.id=12.;\n            if(sdBox(voxelCoord- buildCoord- vec3(8.,1.,-9.), vec3(3.,3.,1.5)) <.5) {vox.id=9.;vox.shape=0;}\n            if(sdBox(voxelCoord- buildCoord- vec3(8.,1.,-8.), vec3(2.,2.,1.5)) <.5) {vox.id=12.; vox.life=255.;vox.value=1;vox.shape=0;}\n\n       \n        }\n \n        \/\/ELEVATOR PLATFORMS (3 LEVELS)\n        if(type>.2){\n            if(sdBox(voxelCoord-buildCoord- vec3(-1.5,-3.,23.), vec3(4.,5.,0.5)) <.5) {vox.id=9.;vox.shape=0;}\n            if(abs(sdBox(voxelCoord-buildCoord- vec3(-1.5,-3.,24.), vec3(4.,5.,0.5))) <.5) {vox.id=9.; vox.shape=4; vox.rotation=1.;}\n            if(abs(sdBox(voxelCoord-buildCoord- vec3(-1.5,-3.5,24.), vec3(3.5,5.,0.5))) <.5) {vox.id=9.; vox.shape=4;}\n\n\n            if(sdBox(voxelCoord- buildCoord-vec3(-1.5,-3.,-26.), vec3(4.,4.,0.5)) <.5) {vox.id=9.; vox.shape=0;}\n\n            if(length(voxelCoord.xy - buildCoord.xy - vec2(-2.,-5.))<2. && abs(voxelCoord.z -buildCoord.z -1.)<27. && voxelCoord.z>WATER_LEVEL)  {vox.id=0.;}\n            if(length(voxelCoord.xy - buildCoord.xy - vec2(-2.,-1.))<2. && abs(voxelCoord.z- buildCoord.z -1.)<27. && voxelCoord.z>WATER_LEVEL)  {vox.id=0.;}\n\n\n            \/\/ LIGHTs\n            \/\/if(length(voxelCoord - buildCoord  - vec3(-2.,-3.,30.))<2.5)  {vox.id=6.;  vox.light.t=15.;}\n            if(length(voxelCoord - buildCoord - vec3(-2.,-3.,-26.))<2.5)  {vox.id=6.;  vox.light.t=15.;vox.shape=0;}\n        }\n    }\n\n\n    \/\/ ELEVATOR- UP\n    if(length(voxelCoord.xy - buildCoord.xy - vec2(-2.,-5.))<2. && abs(voxelCoord.z -buildCoord.z +26.-abs(mod((iTime-1.),100.)-50.) )<.5 )  {vox.id=0.;}\n    if(length(voxelCoord.xy - buildCoord.xy - vec2(-2.,-5.))<2. && abs(voxelCoord.z -buildCoord.z +26.-abs(mod((iTime),100.)-50.) )<.5 )  {vox.id=9.;vox.shape=0;}\n\n\n    \/\/ELEVATOR DOWN\n    if(length(voxelCoord.xy - buildCoord.xy - vec2(-2.,-1.))<2. && abs(voxelCoord.z -buildCoord.z -24.+abs(mod((iTime-1.),100.)-50.) )<.5 )  {vox.id=0.;}\n    if(length(voxelCoord.xy - buildCoord.xy - vec2(-2.,-1.))<2. && abs(voxelCoord.z -buildCoord.z -24. +abs(mod((iTime),100.)-50.) )<.5 )  {vox.id=9.;vox.shape=0;}\n\n\n}\n\n",
            "name": "Common",
            "description": "",
            "type": "common"
        },
        {
            "inputs": [
                {
                    "id": "4dXGRr",
                    "filepath": "\/presets\/tex00.jpg",
                    "previewfilepath": "\/presets\/tex00.jpg",
                    "type": "keyboard",
                    "channel": 2,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "nearest",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "XsXGR8",
                    "filepath": "\/media\/previz\/buffer01.png",
                    "previewfilepath": "\/media\/previz\/buffer01.png",
                    "type": "buffer",
                    "channel": 1,
                    "sampler": {
                        "filter": "nearest",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "XdfGR8",
                    "filepath": "\/media\/previz\/buffer03.png",
                    "previewfilepath": "\/media\/previz\/buffer03.png",
                    "type": "buffer",
                    "channel": 3,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dXGR8",
                    "channel": 0
                }
            ],
            "code": "#define KEY_FORWARDS 87\n#define KEY_BACKWARDS 83\n#define KEY_LEFT 65\n#define KEY_RIGHT 68\n#define KEY_JUMP 32\n#define KEY_SNEAK 16\n#define KEY_PLACE 81\n#define KEY_DESTROY 69\n#define KEY_SHAPE 82\n#define KEY_ROTATE_Z 70\n#define KEY_ROTATE_Y 71\n#define KEY_MULTISELECT 67\n#define KEY_DECREASE_ZOOM 33\n#define KEY_INCREASE_ZOOM 34\n#define KEY_DECREASE_PIXELSIZE 75\n#define KEY_INCREASE_PIXELSIZE 76\n#define KEY_INCREASE_TIME_SCALE 80\n#define KEY_DECREASE_TIME_SCALE 79\n#define KEY_STATS 114\n#define KEY_DUMP1 115\n#define KEY_DUMP2 116\n#define KEY_TORCH 118\n#define KEY_FLOW 119\n#define KEY_TELEPORT 84\n#define KEY_INCREASE_PERFORMANCE 117\n#define KEY_WORLD 89\n#define KEY_MAP 77\n#define KEY_INVENTORY 73\n\n\n\/\/ACTIONS \n\n\n\nbool inBox(vec2 coord, vec4 bounds) {\n    return coord.x >= bounds.x && coord.y >= bounds.y && coord.x < (bounds.x + bounds.z) && coord.y < (bounds.y + bounds.w);\n}\nvec2 currentCoord;\nvec4 outValue;\nbool store4(vec2 coord, vec4 value) {\n    if (inBox(currentCoord, vec4(coord, 1., 1.))) {\n        outValue = value;\n        return true;\n    }\n    else return false;\n}\nbool store3(vec2 coord, vec3 value) { return store4(coord, vec4(value, 1)); }\nbool store2(vec2 coord, vec2 value) { return store4(coord, vec4(value, 0, 1)); }\nbool store1(vec2 coord, float value) { return store4(coord, vec4(value, 0, 0, 1)); }\n\nfloat keyDown(int keyCode) {\n    return texture(iChannel2, vec2((float(keyCode) + 0.5) \/ 256., .5\/3.), 0.0).r;   \n}\n\nfloat keyPress(int keyCode) {\n    return texture(iChannel2, vec2((float(keyCode) + 0.5) \/ 256., 1.5\/3.), 0.0).r;   \n}\n\nfloat keySinglePress(int keycode) {\n    bool now = bool(keyDown(keycode));\n    bool previous = bool(texture(iChannel0, vec2(256. + float(keycode) + 0.5, 0.5) \/ iResolution.xy, 0.0).r);\n    return float(now && !previous);\n}\n\n\nfloat keyToggled(int keyCode) {\n    return texture(iChannel2, vec2((float(keyCode) + 0.5) \/ 256., 2.5\/3.), 0.0).r;   \n}\n\nfloat rectangleCollide(vec2 p1, vec2 p2, vec2 s) {\n    return float(all(lessThan(abs(p1 - p2), s)));   \n}\n\nfloat horizontalPlayerCollide(vec2 p1, vec2 p2, float h) {\n    vec2 s = (vec2(1) + vec2(.6, h)) \/ 2.;\n    p2.y += h \/ 2.;\n    return rectangleCollide(p1, p2, s);\n}\n\n\n\/*\nvoxel getCachedVoxel(vec3 p) {\n    return getCachedVoxel(p,iChannel1,iChannelResolution[1],BUFFER_B);\n}*\/\n\nfloat isSolidVoxel(bool slope,vec3 p) {\n    voxel t;\n    getCVoxel(p,t,0);\n    return isSolidVoxel(t) * (!slope || t.shape!=6?1.:0.);\n}\n\nstruct rayCastResults {\n    bool hit;\n    vec3 mapPos;\n    vec3 normal;\n};\n\nrayCastResults  getMouseRay(){\n       \n   vec4 mouseRay=  texture(iChannel3, vec2(0.));\n   rayCastResults res;\n   res.hit = mouseRay.a!=0.;\n   res.mapPos = mouseRay.rgb;\n    \n   float eN = mouseRay.a -1.;\n   res.normal=vec3(mod(eN,3.),floor(mod(eN,9.)\/3.),floor(eN\/9.))- vec3(1.);  \n   return res;\n}\n\nfloat mouseSelect(vec2 c,float h) {\n\tfloat scale = floor(iResolution.y \/ 128.);\n    c \/= scale;\n    vec2 r = iResolution.xy \/ scale;\n    float xStart = (r.x - 16. * NUM_ITEMS) \/ 2.;\n    c.x -= xStart;\n    if (c.x <NUM_ITEMS * 16. && c.x >= 0. && c.y < 16.*h) {\n        float slot = floor(c.x \/ 16.) + NUM_ITEMS*floor(c.y \/ 16.);\n    \treturn slot;\n    }\n\n    return -1.;\n}\n\nbool mouseDoubleClick(){\n    \n    if(iMouse.z <1. ) {\n   \n        int changeCount=0;\n        for(int i=0;i<20;i++){\n\n            int mouseChange=          \n               (load(_old *vec2(i) + _mouse ).z>0.?0:1)\n              +(load( _old * vec2(i+1) +_mouse ).z>0.?0:1);\n\n\n            if(mouseChange==1)changeCount++;\n            if(load(_mouseBusy).r>0.) {store1(_mouseBusy,float(1.));return false;}\n                               \n            if(changeCount>2){\n                \/\/if(load(_time).r - load(_old*vec2(i) +_time).r<1.) return false;\n                if(length(load(_mouse).xy -load(_old * vec2(i+1) +_mouse).xy)>.05) return false;\n                store1(_mouseBusy,float(1.));\n                return true;\n\n            }         \n        }\n    }\n    store1(_mouseBusy,float(0.));\n    return false; \n}\n\n\n\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n\/\/From https:\/\/www.shadertoy.com\/view\/4djGRh\nfloat tileableWorley(in vec2 p, in float numCells)\n{\n\tp *= numCells;\n\tfloat d = 1.0e10;\n\tfor (int xo = -1; xo <= 1; xo++)\n\t{\n\t\tfor (int yo = -1; yo <= 1; yo++)\n\t\t{\n\t\t\tvec2 tp = floor(p) + vec2(xo, yo);\n\t\t\ttp = p - tp - hash22(256. * mod(tp, numCells));\n\t\t\td = min(d, dot(tp, tp));\n\t\t}\n\t}\n\treturn sqrt(d);\n\t\/\/return 1.0 - d;\/\/ ...Bubbles.\n}\n\nfloat crackingAnimation(vec2 p, float t) {\n    t = ceil(t * 8.) \/ 8.;\n\tfloat d = 1.0e10;\n    \/\/t *= ;\n    for (float i = 0.; i < 25.; i++) {\n    \tvec2 tp = hash22(p )-.5; \/\/texture(iChannel1, vec2(4, i) \/ 256.).xy - 0.5;\n        tp *= max(0., (length(tp) + clamp(t, 0., 1.) - 1.) \/ length(tp));\n        d = min(d, length(tp + 0.5 - p));\n    }\n    return pow(mix(clamp(1. - d * 3., 0., 1.), 1., smoothstep(t - 0.3, t + 0.3, max(abs(p.x - 0.5), abs(p.y - 0.5)) * 2.)), .6) * 1.8 - 0.8;\n}\n\nfloat brickPattern(vec2 c) {\n\tfloat o = 1.;\n    if (mod(c.y, 4.) < 1.) o = 0.;\n    if (mod(c.x - 4. * step(4., mod(c.y, 8.)), 8.) > 7.) o = 0.;\n    return o;\n}\nfloat woodPattern(vec2 c) {\n\tfloat o = 1.;\n    if (mod(c.y, 4.) < 1.) o = 0.;\n    if (mod(c.x + 2. - 6. * step(4., mod(c.y, 8.)), 16.) > 15.) o = 0.;\n    return o;\n}\n\n\n\n\n\/\/textures from https:\/\/www.shadertoy.com\/view\/4ds3WS by Reinder\nvoid setTexture( out vec4 o, in vec2 fragCoord )\n{\n    \n \tif(fragCoord.x>8.*16. || fragCoord.y >10.*16.) discard;\n    vec2 gridPos = floor((fragCoord -vec2(0.,32.))\/ 16.) ;\n    vec2 c = mod(fragCoord, 16.);\n    int id = int(gridPos.x + gridPos.y * 8.);\n \n   \n    vec2 uv = floor( c );\t\n    float h = hash12(uv +vec2(float(id)));\n    float br = 1. - h * (96.\/255.);\t\t\n\tfloat xm1 = mod((uv.x * uv.x * 3. + uv.x * 81.) \/ 4., 4.);\n\n    if (iFrame > 10 && iChannelResolution[0].x > 0. && id!=32  ) discard;\n    o.a = 1.;\n    if (id == 0) { \/\/NO TEXTURE\n    \to = vec4(1,0,1,1);\n    }\n    if (id == 1) { \/\/STONE\n       \n        o.rgb =  vec3( 127.\/255., 127.\/255., 127.\/255.) *br;        \n    }\n    if (id == 2) { \/\/DIRT\n        \n        o.rgb =  vec3( 150.\/255., 108.\/255.,  74.\/255.) *br;\n    }\n    if (id == 3) { \/\/GRASS LATERAL\n        \n        o.rgb =  vec3( 150.\/255., 108.\/255.,  74.\/255.) *br;\n        if (c.y  + hash( c.x*2.) *3.  > 14. ) \n         o.rgb =  vec3( 96.\/255., 157.\/255.,  59.\/255.)*br;\n    }\n    if (id == 4) { \/\/GRASS UP\n   \t\t\n        o.rgb = vec3( 96.\/255., 157.\/255.,  59.\/255.)*br;\n    }\n    if (id == 5) { \/\/ROCK\n       \n        o.rgb = vec3( 106.\/255., 170.\/255.,  64.\/255.)*br;\n        o.rgb = vec3(clamp(pow(1. - tileableWorley(c \/ 16., 4.), 2.), 0.2, 0.6) + 0.2 * tileableWorley(c \/ 16., 5.));\n \n    }\n    if (id == 6 || id == 26) {\/\/LIGHT OR FIREFLY\n        float w = 1. - tileableWorley(c \/ 16., 4.);\n        float l = clamp(0.7 * pow(w, 4.) + 0.5 * w, 0., 1.);\n        o.rgb = mix(vec3(.3, .1, .05), vec3(1,1,.6), l);\n        if (w < 0.2) o.rgb = vec3(0.3, 0.25, 0.05);\n    }\n    if (id == 7) { \/\/BRICK\n        o.rgb = vec3( 181.\/255.,  58.\/255.,  21.\/255.)*br; \n\t\tif ( mod(uv.x + (floor(uv.y \/ 4.) * 5.), 8.) == 0. || mod( uv.y, 4.) == 0.) {\n\t\t\to.rgb = vec3( 188.\/255., 175.\/255., 165.\/255.); \n\t\t}\n        \n    \t\/\/o.rgb = -0.1 * hash12(c) + mix(vec3(.6,.3,.2) + 0.1 * (1. - brickPattern(c + vec2(-1,1)) * brickPattern(c)), vec3(0.8), 1. - brickPattern(c));\n    }\n    if (id == 8) {\/\/GOLD\n    \to.rgb = mix(vec3(1,1,.2), vec3(1,.8,.1), sin((c.x - c.y) \/ 3.) * .5 + .5);\n        if (any(greaterThan(abs(c - 8.), vec2(7)))) o.rgb = vec3(1,.8,.1);\n    }\n    if (id == 9) { \/\/WOOD\n        \n         o.rgb= vec3(0.5,0.4,0.25)*(0.5 + 0.5 * woodPattern(c))*br;        \n    }    \n    if (id == 10) {\/\/TREE\n\t\t\n        if ( h < 0.5 ) {\n\t\t\tbr = br * (1.5 - mod(uv.x, 2.));\n\t\t}\n        o.rgb = vec3( 103.\/255., 82.\/255.,  49.\/255.)*br; \t\t\t\t\n\t}\t\n    if (id == 11) {\/\/LEAF\n\t        o.rgb=  vec3(  40.\/255., 117.\/255.,  38.\/255.)*br;\t\t\n\t}\n    if (id == 12) {\/\/WATER\t\t\n        o.rgb=vec3(  64.\/255.,  64.\/255., 255.\/255.)*br;\t\t\n\t}\t\n    if (id == 13) {\/\/SAND\n\t\t\/\/getMaterialColor(10,c,o.rgb);\n\t\to.rgb= vec3(0.74,0.78,0.65);\n\t}\t\n    if (id == 14) {\/\/RED APPLE\t- MIRROR\t\n\t\to.rgb= vec3(.95,0.,0.05);\n       \n\t}\n    if (id == 15) {\/\/PINK MARBLE\t\n        o.rgb= vec3(.95,0.5,.5)*br;\n    \t\/\/o.rgb = mix(vec3(.2,1,1), vec3(1,.8,.1), sin((c.x - c.y) \/ 3.) * .5 + .5);\n       \/\/ if (any(greaterThan(abs(c - 8.), vec2(7)))) o.rgb = vec3(.1,.8,1);\n       \n\t}\n    if (id == 16) { \/\/BEDROcK\n        \n    \n        o.rgb =   .2*vec3( 127.\/255., 127.\/255., 127.\/255.) *br;   \n    }\n    if (id == 17) {\/\/DIAMOND\t\n       \n    \to.rgb = mix(vec3(.2,1,1), vec3(.1,.8,1), sin((c.x - c.y) \/ 3.) * .5 + .5);\n       if (any(greaterThan(abs(c - 8.), vec2(7)))) o.rgb = vec3(.1,.8,1);\n       \n\t}\n \/*   \n    \n    if (id == 18) {\/\/\t\n        o.rgb= vec3(0.04, 0.14, 0.42)*br;\n       \n\t}\n    if (id == 19) {\/\/\t\n        o.rgb=  vec3(0.05, 0.50, 0.95)*br;\n       \n\t}\n    if (id == 20) {\/\/\t\n        o.rgb= vec3(0.36, 0.72, 0.68)*br;\n       \n\t}\n    if (id == 21) {\/\/\t\n        o.rgb= vec3(0.48, 0.46, 0.28)*br;\n       \n\t}\n    if (id == 22) {\/\/\t\n        o.rgb= vec3(0.69, 0.58, 0.27)*br;\n       \n\t}\n    if (id == 23) {\/\/\t\n        o.rgb= vec3(0.42, 0.51, 0.20)*br;\n       \n\t}    \n    if (id == 24) {\/\/\t\n        o.rgb= vec3(0.23, 0.53, 0.16)*br;\n       \n\t}\n    if (id == 25) {\/\/\t\n        o.rgb= vec3(0.06, 0.20, 0.07)*br;\n       \n\t}\n    if (id == 26) {\/\/\t\n        o.rgb= vec3(0.32, 0.33, 0.27)*br;\n       \n\t}\n    if (id == 27) {\/\/\t\n        o.rgb= vec3(0.25, 0.37, 0.41)*br;\n       \n\t}\n    if (id == 28) {\/\/\t\n        o.rgb= vec3(0.44, 0.67, 0.74)*br;\n       \n\t}  \n    if (id == 29) {\/\/\t\n        o.rgb= vec3(0.73, 0.86, 0.91)*br;\n       \n\t}  \n*\/  \n\n    if (id == 32) { \/\/DESTROYING BLOCK ANIMATION\n    \to.rgb = vec3(crackingAnimation(c \/ 16., load(_pickTimer).r));\n    }\n    if (id == 48) { \n    \to = vec4(vec3(0.2), 0.7);\n        vec2 p = c - 8.;\n        float d = max(abs(p.x), abs(p.y));\n        if (d > 6.) {\n            o.rgb = vec3(0.7);\n            o.rgb += 0.05 * hash12(c);\n            o.a = 1.;\n            if ((d < 7. && p.x < 6.)|| (p.x > 7. && abs(p.y) < 7.)) o.rgb -= 0.3;\n        }\n        o.rgb += 0.05 * hash12(c);\n        \n    }\n    \n}\n\n\/*--------------------\n\nx=0 && y<256: global variables\nx=0 &&  256<=y<512: keyboard state for each ascii code with millisecs since laste change\n1<=x<16 y<512: previous values fo variables and keys\nx<= 128 && 16<=y< 140 : textures \n\n\n*\/\/\/-------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    currentCoord = fragCoord;\n    if(fragCoord.x>512. || fragCoord.y >160.) discard;\n    vec2 texCoord = floor(fragCoord);\n    if (texCoord.x < 512. && texCoord.y<32.) {\n        if (texCoord.y == varRow) {\n            if (texCoord.x >= 256.) {\n                fragColor.r = texture(iChannel2, (fragCoord - 256.) \/ vec2(256,3)).r;\n                vec4 old = texture(iChannel0, (_old + fragCoord) \/ iChannelResolution[0].xy);\n                if (fragColor.r != old.r) old.a = 0.;\n                fragColor.a = old.a + iTimeDelta;\n            }\n            else {\n                vec3 pos = load(_pos).xyz;\n                vec3 oldPos = pos;\n                vec3 offset = vec3(floor(pos.xy), 0.);\n                vec2 angle = load(_angle).xy;\n                vec4 oldMouse = load(_mouse);\n                vec3 vel = load(_vel).xyz;\n                vec4 mouse = iMouse \/ length(iResolution.xy);\n                float renderScale = load(_renderScale).r;\n                vec2 time = load(_time).rg;\n                vec2 flightMode = load(_flightMode).rg;\n                vec2 sprintMode = load(_sprintMode).rg;\n                float selected = load(_selectedInventory).r;\n                float dt = min(iTimeDelta, .05);\n                float rayDistMax = max(load(_rayDistMax).r,50.);\n\t\t\t\t\n                float pixelSize =load(_pixelSize).r;\n                float inventory =load(_inventory).r;\n                float demo =load(_demo).r;\n\t\t\t\tfloat map=load(_map).r;;\n\n                    \n                if (iFrame <2  ) {\n#ifdef FAST_NOISE  \n                    pos = vec3(2952.8,10140.8,89.);\n                    offset = vec3(floor(pos.xy), 0.);\n                    oldPos = pos;\n                    angle = vec2(-0.6,1.8  );                   \n#else\n                    pos = vec3(3265.5,9654.5,50.);                   \n                    angle = vec2(-2.,1.6  );\n#endif                    \n                    demo=1.;\n                    oldMouse = vec4(-1);\n                    vel = vec3(0);\n                    renderScale = -2.;\n                    time = vec2(0.,4);\n                    selected = 0.;\n                    inventory=0.;\n                    rayDistMax=250.;\n                    map=1.;\n                    pixelSize=2.;\n                }\n                if(demo>0. && \n                   (keyDown(KEY_JUMP)>.0||keyDown(KEY_FORWARDS)>0. || iMouse.z>0. ))\n                {\n                    inventory=1.;\n                    map=1.;\n                    demo=0.;\n                }\n                \n                if ( bool(keyDown(KEY_TELEPORT))) {\n\t\t\t\t\t\n                    if(hash(iTime) <.5) pos=vec3(3221.5,10159.5,70.);\n                    else pos =vec3(hash33(pos).xy *10000.,72.); \n                       \n                    offset = vec3(floor(pos.xy), 0.);\n                    oldPos = pos;\n                    time.r=hash13(pos)*1200.;\n                    oldMouse = vec4(-1);\n                    vel = vec3(0);\n                    renderScale = -2.;                  \n                    selected = 0.;\n                    rayDistMax=250.;\n                }\n                if (oldMouse.z > 0. && iMouse.z > 0. && map<1.5)\n                    if(1==1){\n                        float zoom = pow(10., load(_renderScale).r\/10.);\n                        angle += 5.*(mouse.xy - oldMouse.xy) * vec2(-1,-1)\/zoom;\n                        angle.y = clamp(angle.y, 0.1, PI - 0.1);\n                    }\n                vec3 dir = vec3(sin(angle.y) * cos(angle.x), sin(angle.y) * sin(angle.x), cos(angle.y));\n                vec3 dirU = vec3(normalize(vec2(dir.y, -dir.x)), 0);\n                vec3 dirV = cross(dirU, dir);\n                vec3 move = vec3(0);\n\n                \n                vec3 dirFwd = vec3(cos(angle.x), sin(angle.x), 0);;\n                    vec3 dirRight = vec3(dirFwd.y, -dirFwd.x, 0);\n                vec3 dirUp = vec3(0,0,1);\n                \n                float inBlock = 0.;      \n                vec3  vColPos, hColPos;\n                \n                \/\/z of closest  blocks below\n                float minHeight = 0.; \n                \n                \/\/z of closest  blocks above\n                float maxHeight = 1000.;\n                \n                \/\/XY of closest lateral blocks\n                float minX = pos.x - 1000.; \n                float maxX = pos.x + 1000.;\n                float minY = pos.y - 1000.;\n                float maxY = pos.y + 1000.;\n#ifndef XRAY_MODE\n                if(isSolidVoxel(false,pos-offset) >.5)  pos.z+=clamp(3.\/iTimeDelta,.3,1.);\n                \n                \/\/DOWN\n                for (float i = 0.; i < 4.; i++) {\n                    vColPos = vec3(floor(pos.xy - 0.5), floor(pos.z - 1. - i));\n                    float solid=0.;\n                    for(int j=0;j<4;j++){\n                        solid+=\n                          isSolidVoxel(false,vColPos - offset + vec3(j\/2,j%2,min(iFrame,0))) * rectangleCollide(vColPos.xy + vec2(0.5 +float(j\/2),0.5+float(j%2)), pos.xy, vec2(.8));\n                    }\n                    if ( solid> .5) {\n                        minHeight = vColPos.z + 1.001; \n                        inBlock = 1.;\n                        break;\n                    }\n                }\n\t\t\t\t\n                \/\/UP\n                vColPos = vec3(floor(pos.xy - 0.5), floor(pos.z + 1.8 + 1.));\n                float solidUp=0.;\n                for(int j=0;j<4;j++){\n                 \tsolidUp+= isSolidVoxel(false,vColPos - offset + vec3(j\/2,j%2,min(iFrame,0))) * rectangleCollide(vColPos.xy + vec2(0.5 +float(j\/2),0.5+float(j%2)), pos.xy, vec2(.8));\n                }\n\t\t\t\tif(  solidUp > .5) {\n                    maxHeight = vColPos.z - 1.8 - .001; \n                    inBlock = 1.;     \n\n                }\n               \n                \/\/LATERAL\n                float solidL[4];\n                for(int i=0;i<4;i++){\n                    vec2 posL;\n                    vec2 hColPosL;\n                    if(i==0) {hColPos = vec3(floor(pos.xy - vec2(.3, .5)) + vec2(-1,0), floor(pos.z)); hColPosL=hColPos.yz;posL=pos.yz;}\n                    if(i==1) {hColPos = vec3(floor(pos.xy - vec2(-.3, .5)) + vec2(1,0), floor(pos.z));hColPosL=hColPos.yz;posL=pos.yz;}\n                    if(i==2) {hColPos = vec3(floor(pos.xy - vec2(.5, .3)) + vec2(0,-1), floor(pos.z));hColPosL=hColPos.xz;posL=pos.xz;}\n                    if(i==3) {hColPos = vec3(floor(pos.xy - vec2(.5, -.3)) + vec2(0,1), floor(pos.z));hColPosL=hColPos.xz;posL=pos.xz;}\n                    solidL[i]=0.;\n                    for(int j=0;j<6;j++){\n                        \n       \n                        solidL[i ] += isSolidVoxel(true,hColPos - offset + vec3((i\/2)*(j%2),(1-i\/2)*(j%2),(j\/2)+min(iFrame,0))) \n                            * horizontalPlayerCollide(hColPosL + vec2(0.5+float(j%2), 0.5+float(j\/2)), posL, 1.8);\n                    }\n                \n                    if(i==0 && solidL[i]>.5) minX = hColPos.x + 1.301;\n                    if(i==1 && solidL[i]>.5) maxX = hColPos.x - .301;\n                    if(i==2 && solidL[i]>.5) minY = hColPos.y + 1.301;\n                    if(i==3 && solidL[i]>.5) maxY = hColPos.y - .301;\n                }\n                \n\n                \n                if (abs(pos.z - minHeight) < 0.01) flightMode.r = 0.; \n#else\n                flightMode.rg=vec2(.3,1.);\n                if(iFrame==0) pos.z=65.;\n#endif\n                \n                if (bool(keySinglePress(KEY_JUMP))) {\n                    if (flightMode.g > 0.) {\n                        flightMode.r = 1.- flightMode.r;\n                        sprintMode.r = 0.;\n                    }\n                    flightMode.g = 0.3;\n                }\n                flightMode.g = max(flightMode.g - dt, 0.);\n\n                if (bool(keySinglePress(KEY_FORWARDS))) {\n                    if (sprintMode.g > 0.) sprintMode.r = 1.;\n                    sprintMode.g = 0.3;\n                }\n                if (!bool(keyDown(KEY_FORWARDS))) {\n                    if (sprintMode.g <= 0.) sprintMode.r = 0.;\n                }\n                sprintMode.g = max(sprintMode.g - dt, 0.);\n\n                vec3 stats =vec3(\n                    bool(keyToggled(KEY_STATS))?1.:0.,\n                    bool(keyToggled(KEY_DUMP1))?1.:0.,\n                    bool(keyToggled(KEY_DUMP2))?1.:0.\n                );\n                float torch = bool(keyToggled(KEY_TORCH))?1.:0.;\n                float flow = bool(keyToggled(KEY_FLOW))?1.:0.;\n                \n                map = mod( map +keyPress(KEY_MAP),3.);\n                inventory = floor(mod( inventory + keyPress(KEY_INVENTORY),3.));\n                if(inventory<2.) selected=clamp(selected,0., NUM_ITEMS-1.);\n\n                float loadDistLimit=80.;\n                float rayLimit=500.; \n                if(bool(keyToggled(KEY_INCREASE_PERFORMANCE))){        \n                    pixelSize=max(2.,pixelSize) ;\n                    loadDistLimit=50.;\n                    rayLimit=200.;\n                }\n                pixelSize=clamp( pixelSize  + keyPress(KEY_INCREASE_PIXELSIZE) - keyPress(KEY_DECREASE_PIXELSIZE)  ,1.,4.);\n\n\n                if (bool(flightMode.r)) {\n                    if (length(vel) > 0.) vel -= min(length(vel), 25. * dt) * normalize(vel);\n                    vel += 50. * dt * dirFwd * sign(keyDown(KEY_FORWARDS)-keyDown(KEY_BACKWARDS)+keyDown(38)-keyDown(40));\n                    vel += 50. * dt * dirRight * sign(keyDown(KEY_RIGHT)-keyDown(KEY_LEFT)+keyDown(39)-keyDown(37));\n                    vel += 50. * dt * dirUp * sign(keyDown(KEY_JUMP) - keyDown(KEY_SNEAK));\n                    if (length(vel) > 20.) vel = normalize(vel) * 20.;\n                }\n                else {\n                    vel.xy *= max(0., (length(vel.xy) - 25. * dt) \/ length(vel.xy));\n                    vel += 50. * dt * dirFwd * sign(keyDown(KEY_FORWARDS)-keyDown(KEY_BACKWARDS)+keyDown(38)-keyDown(40));\n                    vel += 50. * dt * dirFwd * 0.4 * sprintMode.r;\n                    vel += 50. * dt * dirRight * sign(keyDown(KEY_RIGHT)-keyDown(KEY_LEFT)+keyDown(39)-keyDown(37));\n                    if (abs(pos.z - minHeight) < 0.01) {\n                        vel.z = 9. * keyDown(32);\n                    }\n                    \n                    else {\n                        \/\/voxel t;\n                        \/\/getCVoxel(pos -offset,t,0);\n                        \/\/bool isWater=(t.id ==12.);\n                        vel.z -= 32. * dt;\n                        vel.z = clamp(vel.z, -80., 30.);\n                    }\n\t\t\t\t\t\n                    if (length(vel.xy) > 4.317 * (1. + 0.4 * sprintMode.r)) vel.xy = normalize(vel.xy) * 4.317 * (1. + 0.4 * sprintMode.r);\n                }\n\n\n                pos += dt * vel; \n                if (pos.z < minHeight) {\n                    pos.z = minHeight;\n                    vel.z = 0.;\n                }\n                if (pos.z > maxHeight ) {\n                    pos.z = maxHeight;\n                    vel.z = 0.;\n                }\n                \n                if (pos.x < minX) {\n                    pos.x = minX;\n                    vel.x = 0.;\n                }\n                if (pos.x > maxX) {\n                    pos.x = maxX;\n                    vel.x = 0.;\n                }\n                if (pos.y < minY) {\n                    pos.y = minY;\n                    vel.y = 0.;\n                }\n                if (pos.y > maxY) {\n                    pos.y = maxY;\n                    vel.y = 0.;\n                }\n\n                float timer = load(_old+_pickTimer).r;\n                vec4 oldPick = load(_old+_pick);\n                vec4 pick;\n                float pickAction;\n                           \n                rayCastResults mousePointer = getMouseRay();\n            \n                bool dblClk =mouseDoubleClick();\n                if(dblClk){\n                    if (mousePointer.hit ) {\n                        \n                            pick.xyz = mousePointer.mapPos;\n                            pick.a = 7.;\n                  }                \n                }\n                \n                if (iMouse.z > 0. ) {                    \n                    \n                    float h= (inventory>1.?NUM_ITEM_ROWS:1.);\n                    float slot = mouseSelect(iMouse.xy,h);\n                    if(slot>= 0. && inventory>0. ){\n                        selected = slot;\n                    }\n                    else {\t\n                    \n                    if (mousePointer.hit ) {\n                        pick.xyz = mousePointer.mapPos;\n                        if (bool(keyDown(KEY_DESTROY))) {\n                            pick.a = 1.;\n                            store1(_pick,pick.a);\n                            timer += dt \/ 0.25;\n                        }\n                        else if (dblClk || bool(keySinglePress(KEY_PLACE))) {\n                            pick.a = 2.;\n                            pick.xyz += mousePointer.normal;                         \n                        }\n                        else if (bool(keySinglePress(KEY_SHAPE))) {\n                            pick.a = 3.;\n                        }\n                        else if (bool(keySinglePress(KEY_ROTATE_Z))) {\n                            pick.a = 4.;\n                         }\n                        else if (bool(keySinglePress(KEY_ROTATE_Y))) {\n                            pick.a = 5.;\n                        }\n                         else if (bool(keyDown(KEY_MULTISELECT))) {\n                            pick.a = 6.;\n                             store1(_pick,pick.a);\n                             timer += dt \/ 0.25;\n                        }\n                        if (oldPick != pick) timer = 0.;\n                    }\n                    else {\n                        \/\/pick = vec4(-1,-1,-1,0);\n                        timer = 0.;\n                    }\n                }\n                }\n                else { \n                    \n                    \/\/ NO MOUSE KEY PRESSED  \n                    \/\/pick = vec4(-1,-1,-1,0);\n\t\t\t\t\t\tif (bool(keyDown(KEY_DESTROY))) {\n                            pick.a = 1.;\n                            store1(_pick,pick.a);\n                            timer += dt \/ 0.25;\n                        }\n                        else if (bool(keySinglePress(KEY_PLACE))) {\n                            pick.a = 2.;\n                        }\n                        else if (bool(keySinglePress(KEY_SHAPE))) {\n                            pick.a = 3.;\n                         }\n                        else if (bool(keySinglePress(KEY_ROTATE_Z))) {\n                            pick.a = 4.;\n                        }\n                        else if (bool(keySinglePress(KEY_ROTATE_Y))) {\n                            pick.a = 5.;\n                        }\n                        else if (bool(keyDown(KEY_MULTISELECT))) {\n                            pick.a = 6.;\n                             store1(_pick,pick.a);\n                             timer += dt \/ 0.25;                   \n                        }else timer = 0.;\n                }\n\n\n                renderScale = clamp(renderScale + keySinglePress(KEY_DECREASE_ZOOM) - keySinglePress(KEY_INCREASE_ZOOM), -5., 10.);\n                time.g = clamp(time.g + keySinglePress(KEY_INCREASE_TIME_SCALE) - keyPress(KEY_DECREASE_TIME_SCALE), 0., 8.);\n                time.r = mod(time.r + dt * sign(time.g) * pow(2., time.g - 1.), 1200.);\n\n                bool still= length(pos-oldPos)<0.01 && length(angle -load(_angle).xy )<0.01  &&  iMouse.z<1.;\n                rayDistMax= rayLimit;\/*clamp(rayDistMax  \n                                  +(still?10.:0.) \n                                  - ((iTimeDelta>0.03 && !still)?5.:0.)\n                                  -((iTimeDelta>0.1)?1.:0.) \n                                  -((iTimeDelta>0.1  && !still)?50.:0.) \n                                  + ((iTimeDelta<0.03 && still)?20.:0.)\n                                  ,loadDistLimit*2.5,rayLimit);*\/\n\n\n                store3(_pos, pos);\n                store2(_angle, angle);\n                store4(_loadRange_B,calcLoadRange_B(pos.xy,iChannelResolution[1].xy,0.));\n#if SURFACE_CACHE>0\n                store4(_loadRange_C,calcLoadRange_C(pos.xy,iChannelResolution[1].xy,0.));\n#endif\n                store4(_mouse, mouse);\n                \/\/store1(_inBlock, inBlock);\n                store3(_vel, vel);\n                store4(_pick, pick);\n                store1(_pickTimer, timer);\n                store1(_renderScale, renderScale);\n                store1(_selectedInventory, selected);\n                store2(_flightMode, flightMode);\n                store2(_sprintMode, sprintMode);\n                store2(_time, time);\n                store3(_stats, stats);\n                store1(_rayDistMax, rayDistMax);\n                store1(_loadDistLimit, loadDistLimit);\n                store1(_rayLimit, rayLimit);\n                store1(_map,map);\n                store1(_pixelSize,pixelSize);\n                store1(_inventory,inventory);\n                store1(_demo,demo);\n                store1(_torch,torch);\n                store1(_flow,flow);\n               \n\n\n                fragColor = outValue;\n            }\n        }  \n        else fragColor = texture(iChannel0, (fragCoord - _old) \/ iChannelResolution[0].xy);\n    }\n    else setTexture(fragColor,fragCoord);\n}\n\n\n",
            "name": "Buffer A",
            "description": "",
            "type": "buffer"
        },
        {
            "inputs": [
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "nearest",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "XsXGR8",
                    "filepath": "\/media\/previz\/buffer01.png",
                    "previewfilepath": "\/media\/previz\/buffer01.png",
                    "type": "buffer",
                    "channel": 1,
                    "sampler": {
                        "filter": "nearest",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "4sXGR8",
                    "filepath": "\/media\/previz\/buffer02.png",
                    "previewfilepath": "\/media\/previz\/buffer02.png",
                    "type": "buffer",
                    "channel": 2,
                    "sampler": {
                        "filter": "nearest",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "XsXGR8",
                    "channel": 0
                }
            ],
            "code": "void  lightDiffusion(inout voxel vox,in voxel temp ,vec3 rPos){\n    if(vox.id != 6. && vox.id != 26. ){\n \t   vox.light.s =  max( vox.light.s  ,  \ttemp.light.s  -(rPos.z==1.?0.:1.) - (vox.id==0.?0.: vox.id==11.?5.:15.));       \t\n \t   vox.light.t =  max( vox.light.t,   temp.light.t - (vox.id==0.|| vox.id==12.?1.:vox.id==11.? 5.:15.)); \n    \t\n    }        \n}\n\n\/\/VOXEL MEMORY 1 - NEAR BLOCKS\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef EXCLUDE_CACHE\n    discard;\n#else\n   \n    vec2 textelCoord = floor(fragCoord);\n    vec3 offset = floor(vec3(load(_pos).xy, 0.));\n    vec3 voxelCoord = texToVoxCoord(textelCoord, offset,BUFFER_B); \n\n    vec4 newRange= calcLoadRange_B(offset.xy,iChannelResolution[1].xy,0.);\n    \n    if(!inRange(voxelCoord.xy, newRange)) {discard;}\n    \n    vec4 pick = load(_pick);   \n\n    voxel vox ; \n    getVoxel( voxelCoord,vox,1);\n\n    if (voxelCoord == pick.xyz || vox.value==2 )  {\n        if(vox.value==0)vox.value=1;\n        \n        if (pick.a == 1. &&  vox.id != 16. && load(_pickTimer).r > 1.) \n        {vox.value=1; \n                vox.id = 0.; \n                vox.shape=0;  \n         \t\tvox.light.t=0.;\n         \t\tvox.life=0.;\n         \t\tvox.ground=0.;\n        }\n        else if (pick.a == 2.) \n        {\n            vox.id = getInventory(load(_selectedInventory).r);\n            if(vox.id==10.) vox.life=3.;\n            else if (vox.id==12.)vox.life=64.;\n            else vox.life=0.;               \n            vox.value=1;\n            vox.shape=0;\n        } \n        else if (pick.a == 3. && vox.id != 10. && vox.id != 11. && vox.id != 12.) \n          { if(vox.shape<7) vox.shape++; else vox.shape=0;}\n        else  if (pick.a == 4. && vox.id != 10. && vox.id != 11. && vox.id != 12.) \n          {if(vox.rotation<3.) vox.rotation++; else vox.rotation=0.;}\n        else if (pick.a == 5. && vox.id != 10. && vox.id != 11. && vox.id != 12.) \n          { if(vox.rotation<12.) vox.rotation+=4.; else vox.rotation= mod(vox.rotation , 4.);}     \n    } \n        \n     if(voxelCoord == pick.xyz  &&  pick.a == 6. ) \n     {vox.value= 2 ;}\n    \n    if(voxelCoord == pick.xyz  &&  pick.a == 7. ) \n     {\n        if(vox.value==2) vox.value=1;\n         else vox.value=2;          \n     }\n    if(load(_pickTimer).r >1. && pick.a == 6. && vox.value==2)\n     {vox.value= 1 ;}\n\n   \t\/\/ SUN LIGHT SOURCES\n   \n    if (voxelCoord.z >= heightLimit_B - 2.) {\n        vox.light.s = 15.;   \n    } else  {\n        \/\/vox.light.s=0.; \/\/correct but initial value is better oon surface\n        vox.light.s = lightDefault(voxelCoord.z);       \n    }\n    \n    \/\/ TORCH LIGHT SOURCES\n    if(vox.id==12.) vox.light.t=max(2.,vox.light.t);\n    else if(vox.id==6.) vox.light.t=15.;\n    else vox.light.t=clamp(vox.light.t- (hash(iTime)>.5?1.:0.),0.,15.);\n     \n    if(length( load(_pos).xyz + vec3(0,0,3.)- voxelCoord.xyz) <2.) vox.light.t=max( 12.,vox.light.t);\n  \n        \n        \n    voxel temp;\n    float air=0.;\n    \/\/int border=0;    \n    \n    \/\/NEIGHBOURS 2=ABOVE 5=BELOW, 0-1-3-4= SIDES\n    float iE=0.;\n      \n    float g=MAX_GROUND;\n    \n    voxel next[9];\n    for(int j=0;j<=2;j++){\n        for(int i=0;i<3;i++){\n            vec3 n= vec3(i==0?1.:0. ,i==1?1.:0.,i==2?1.:0.) * vec3((j==0?1.:-1.));\n#ifdef WATER_FLOW            \n            \/\/ lateral voxels, random direction\n            if(j==2) {\n                int k= int(hash(iTime)*4.);\/\/ iFrame%4;\n            \tn = vec3(   (1- k\/2) * (-1 +(k%2)*2), (k\/2)* (-1 +(k%2)*2)  ,1-i);;\n            }\n#endif            \n            voxel temp;\n            getVoxel(voxelCoord + n ,temp,1 );           \n    \t\tnext[i+3*j]= temp;\n            \n            if(j!=2){\n                if(voxelCoord.z> 80.) {vox.light.s=15.;vox.light.t=0.;}\n                else  lightDiffusion(vox,temp,n);\n\n                \/\/ELECTRICITY DIFFUSION\n                if(vox.id==17.){\n                    if(temp.id==8.) iE=10.;\n                    if(temp.id==17. && temp.life>1.) iE=max(iE,temp.life-1.);\n                }\n                \/\/GROUND DISTANCE\n                if(vox.id!=0. && vox.id!=12. &&vox.id!=26.){\n                    if(voxelCoord.z <=1.) g=1.;\n                    if(temp.id!=0. && temp.id!=12. &&vox.id!=26. && temp.ground>0. )  g=min(g, temp.ground+(i+3*j==5?0.:vox.id==13.?10.:1.)); \n                }\n\n               if(temp.id==0.) air += pow(2., float(j*3+i));\n\n                \/\/LEAFS:\n               if(temp.id==11.  && temp.life>0. &&vox.id==0.) {vox.id=11.;  vox.life=temp.life-1.; }  \n            }\n        }\n    }\n      \n    vec3 pos = load(_pos).xyz;\n    \n    \/\/ELECTRICITIY\n    if(vox.id==17.){\n        vox.life=max(iE,vox.life-1.);\n        \/\/if(iE>0.) vox.light.t=15.; else vox.light.t=0.;\n    }\n    \n    \/\/GROUND CONNECTION: blocks not connected to the ground or sand with 4+ horizontal steps\n    if(vox.id!=0. && vox.id!=12. &&vox.id!=26.){\n        vox.ground=clamp(min(vox.ground+2.,g),0.,MAX_GROUND);\n                \n        \/\/FALLING BLOCK\n#ifdef FALLING_SAND\n        if(vox.ground>=MAX_GROUND \n           && length(pos.xy-voxelCoord.xy)<load(_loadDistLimit).r -5.\n           &&  (next[5].id==0.|| next[5].id==12.)) vox.value=3;\n#endif        \n    }\n           \n\tif(sdBox(pos-voxelCoord -vec3(0.,0.,1.),vec3(.5,.5,.5))<=.01 &&vox.id==3.) vox.id=2.;\n       \n    \/\/ABOVE    \n    if(next[2].id==0.  &&  vox.id==2.) {if(hash13(voxelCoord +iTime ) >.95 && hash(iTime)>.99) vox.id=3.;vox.life=0.;}\n    if(next[2].id==0.  &&  vox.id==3.) {if(hash13(voxelCoord +iTime+30.) >.95 && hash(iTime +30.)>.99) vox.life=clamp(vox.life+1.,0.,3.);}\n    if(next[2].id==3.  &&  vox.id==3.) {vox.id=2.;}\n    if(next[2].value==3 && (vox.id==0.|| vox.id==12.)) {vox.id=next[2].id;} \n    \n    \/\/BELOW\n    if(next[5].id==10.  && next[5].life>0. && vox.id==0.) {vox.id=10.;  vox.life=next[5].life-1.; vox.ground=0.;}\n    if(next[5].id==10.  && next[5].life<1.) {vox.id=11.;  vox.life=TREE_SIZE;}\t\n    if((next[5].id!=3.|| next[5].shape!=0)  &&  vox.id==0.) {vox.life=0.;}\n    if((next[5].id!=0.|| next[5].id==12.)  &&  vox.value==3) {vox.id=0.; vox.value=0;vox.life=0.;}\n\n#ifdef WATER_FLOW\n    if(load(_flow).r>0.5) {\n    if(vox.id==0.) vox.life=0.;           \n    if(vox.id==12. || vox.id==0.){\n    \t\n        float w= vox.id==12.?vox.life:0.;\n        float w_new=w;\n        \n        float w_U  = next[2].id==12.?next[2].life:0.;\/\/(next[2].id==0.? 0.:-1.);\n        float w_D  = next[5].id==12.?next[5].life:(next[5].id==0.? 0.:-1.);\n        float w_LU = next[6].id==12.?next[6].life:(next[6].id==0.? 0.:-1.);\n        float w_L  = next[7].id==12.?next[7].life:(next[7].id==0.? 0.:-1.);\n        float w_LD = next[8].id==12.?next[8].life:(next[8].id==0.? 0.:-1.);\n\n               \n        float OW=.0;\n        float FL=.9; \/\/ lateral flow\n        \/\/TRANSITIONS \n     \t\/\/porting from https:\/\/www.shadertoy.com\/view\/WdjBDV\n\t\t\n        \n        \/\/RULE 1 OUT          \n        if( w>0. && w_D < WATER_FLOW && w_D>-1.) { w_new =max(0.,w +w_D -WATER_FLOW   ); }       \n        \/\/RULE 1 IN    \n         if( w_U>0. && w<WATER_FLOW ) {w_new=min(WATER_FLOW, w + w_U);}\n\n            \n         \/\/ RULE2_OUT \n        if(w>0. && (w_LD>= WATER_FLOW*OW || w_D<0.) && (w_L < w -2. ) && w_L>=0. && w_LU <1. )\n        {w_new= w -floor(w-w_L)*FL;}\n\n        \/\/RULE2 IN        \n        if( ( w_L >0. ) && (w_LD>=WATER_FLOW*(1.-OW*2.) || w_LD<0.) && (w<w_L-2.) && (w_U <1.))\n        {w_new  =  w + floor((w_L-w)*FL );}  \n\n\n        \/\/INFINITE SOURCE\n        if(next[7].id==15. || next[5].id==15. || next[2].id==15. ){ w_new  =  WATER_FLOW; }\n        \n        \n    \tif(w_new >0. && vox.value==0) {vox.id=12.; vox.life= clamp(w_new,0.,WATER_FLOW);}\n    \tif(w_new <.1 &&  vox.value==0){vox.id=0.;vox.life= 0.;}\n        if( vox.value==1) {vox.value=0;}\n#ifdef SUBVOXEL\n        \/\/surface water is half block\n        if( next[2].id!=12. && vox.id==12.){\n            if(vox.life < WATER_FLOW*.3) vox.shape=2;\n            else vox.shape=3;\n             \n        }\n        else  vox.shape=0;\n    \n#endif\n        \n    }\n\t}\n#endif\n    if(next[5].id==3.  &&  vox.id==0.) {vox.life=1.;}\n    \n#ifdef TREE_DETAIL\t\n    if(vox.id==11.) vox.shape=8;\n    if(vox.id==10.) {vox.shape=9;};\n#endif\n\n#ifdef FIREFLIES \n    \/\/if(vox.id==26.){vox.id=0.;  vox.light.t=15.;}\n    if(vox.id==26.){if(vox.light.t>1.) vox.light.t--; else vox.id=0.;vox.light.s=15.; }\n    \n    if(voxelCoord.z<35. || abs(load(_time).r-750.)<250.)\n        if( air>=62. && (voxelCoord.z < heightLimit_B - 1.)){\n            if(vox.id==0.  && hash13(voxelCoord +vec3(iTime))>0.9999  ) {vox.id=26.;  vox.light.t=15.;}\n        } \n#endif\n    \n#if STRUCTURES>0\n    vec3 oldOffset = floor(vec3(load(_old+_pos).xy, 0.));\n\tstructures( voxelCoord,   vox,  oldOffset,  iFrame,  iTime);\n#endif\n    \n    fragColor = encodeVoxel(vox);\n#endif\n}",
            "name": "Buffer B",
            "description": "",
            "type": "buffer"
        },
        {
            "inputs": [
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "nearest",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "XsXGR8",
                    "filepath": "\/media\/previz\/buffer01.png",
                    "previewfilepath": "\/media\/previz\/buffer01.png",
                    "type": "buffer",
                    "channel": 1,
                    "sampler": {
                        "filter": "nearest",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "4sXGR8",
                    "filepath": "\/media\/previz\/buffer02.png",
                    "previewfilepath": "\/media\/previz\/buffer02.png",
                    "type": "buffer",
                    "channel": 2,
                    "sampler": {
                        "filter": "nearest",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4sXGR8",
                    "channel": 0
                }
            ],
            "code": "\/*\nVOXEL MEMORY 2 - SURFACE \n  mode = 1 it's just a copy of buffer B, working in a limited z range\n  mode = 2 stores onlythe surface block with the height, for a wider area\n*\/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef EXCLUDE_CACHE\n    discard;\n#endif\n    \n#ifndef SURFACE_CACHE\n    discard;\n#elif SURFACE_CACHE==2\n    vec2 textelCoord = floor(fragCoord);\n    vec3 offset = floor(vec3(load(_pos).xy, 0.));\n    vec3 voxelCoord = texToVoxCoord(textelCoord, offset,BUFFER_C); \n\n    vec4 newRange_C= calcLoadRange_C(offset.xy,iChannelResolution[1].xy,0.);\n\n    if(!inRange(voxelCoord.xy, newRange_C)) {\n        discard;\n     \n    }\n    voxel vox;  \n    getVoxel( voxelCoord,vox,2);\n\n    if(voxelCoord.z==0. && vox.ground >100.){\n    \tvoxel temp;\n        float h= vox.ground-100.;\n        getVoxel(vec3(voxelCoord.xy,h),temp,2);\n        float id = temp.id;\n        if(id !=0.){\n            vox=temp;\n            vox.ground=h;\n        }\n        else vox.ground--;           \n    } \t\n \n    \/\/NEIGHBOURS\n    if(voxelCoord.z==0. && vox.ground<100.){\n       vec3 s = vec3(1.,0.,0. );\n       vec3 t = vec3(0.,1.,0. );    \n       voxel v[9];    \n       for (int i =-1; i <=1; i++) {\n            for (int j =-1; j <=1  ; j++) {\n               \n                getVoxel(voxelCoord + s* float(i)+t*float(j),v[4+ i+3*j +min(iFrame,0) ] ,2 );                     \t\n                voxel temp = v[4+ i+3*j ];\n                if(i+3*j !=0 && temp.id==10. && temp.ground <100. && temp.ground> vox.ground -TREE_SIZE -1.) {\n                \tvox.id=11.; vox.shape=8;vox.ground=temp.ground+TREE_SIZE+2.;vox.life=0.;\n                }\n            }\n        }\n    }\n    \n    fragColor = encodeVoxel(vox);\n\n#elif SURFACE_CACHE==1\n    vec2 textelCoord = floor(fragCoord);\n    vec3 offset = floor(vec3(load(_pos).xy, 0.));\n    vec3 voxelCoord = texToVoxCoord(textelCoord, offset,BUFFER_C); \n\n    voxelCoord.z+=SURFACE_C;\n\t\/\/vec4 newrange_B = calcLoadRange_B(offset.xy,iChannelResolution[1].xy,1.);\n    vec4 newRange_C= calcLoadRange_C(offset.xy,iChannelResolution[1].xy,0.);\n    \/\/if (inRange(voxelCoord.xy,newrange_B)  ||    \n    if(!inRange(voxelCoord.xy, newRange_C)) {\n        discard;       \n    }\n\n    voxel vox;    \n    getVoxel( voxelCoord,vox,2);\n\n   \t\/\/ SUN LIGHT SOURCES  \n    if (voxelCoord.z >= heightLimit_C- 2.) {\n        vox.light.s = 15.;   \n    } else  {\n        \/\/vox.light.s=0.; \/\/correct but initial value is better oon surface\n        vox.light.s = lightDefault(voxelCoord.z);       \n    }\n    \n    \/\/ TORCH LIGHT SOURCES\n    if(vox.id==12.) vox.light.t=max(2.,vox.light.t);\n    else if(vox.id==6.) vox.light.t=15.;\n    if(length( load(_pos).xyz + vec3(0,0,3.)- voxelCoord.xyz) <2.) vox.light.t=max( 12.,vox.light.t);\n    \n    \n        \n\t\/\/LIGHT DIFFUSE\n    voxel temp;\n    float air=0.;\n    \/\/int border=0;    \n    \n   \n    \/\/NEIGHBOURS 2=ABOVE 5=BELOW, 0-1-3-4= SIDES\n    float iE=0.;\n       \n    float g=MAX_GROUND;\n    \n    voxel next[6];\n    for(int j=0;j<=1;j++){\n        for(int i=0;i<3;i++){\n            vec3 n= vec3(i==0?1.:0. ,i==1?1.:0.,i==2?1.:0.) * vec3((j==0?1.:-1.));\n      \n            if(voxelCoord.z >= heightLimit_C +SURFACE_C-1.) break;\n            if( voxelCoord.z <SURFACE_C +1.) break;\n            voxel temp;\n            getVoxel(voxelCoord + n,temp,2);\/\/- vec3(0.,0.,SURFACE_C));\n            \n    \t\tnext[i+3*j]= temp;\n            \n            if(voxelCoord.z> heightLimit_C +SURFACE_C) vox.light.s=15.;\n                else lightDiffusion(vox,temp,n);\n            \n            \/\/ELECTRICITY DIFFUSION\n            if(vox.id==17.){\n            \tif(temp.id==8.) iE=10.;\n                if(temp.id==17. && temp.life>1.) iE=max(iE,temp.life-1.);\n            }\n\n            \n           if(temp.id==0.) air += pow(2., float(j*3+i));\n            \n            \/\/LEAFS:\n           if(temp.id==11.  && temp.life>0. &&vox.id==0.) {vox.id=11.;  vox.life=temp.life-1.; }\n     \n        }\n    }\n    \n    \n    vec3 pos = load(_pos).xyz;\n    \n    \/\/ELECTRICITIY\n    if(vox.id==17.){\n        vox.life=max(iE,vox.life-1.);\n        \/\/if(iE>0.) vox.light.t=15.; else vox.light.t=0.;\n    }\n        \n\tif(sdBox(pos-voxelCoord -vec3(0.,0.,1.),vec3(.5,.5,.5))<=.01 &&vox.id==3.) vox.id=2.;\n    \n    \n    \/\/ABOVE    \n    if(next[2].id==0.  &&  vox.id==2.) {if(hash13(voxelCoord +iTime ) >.95 && hash(iTime)>.99) vox.id=3.;vox.life=0.;}\n    if(next[2].id==0.  &&  vox.id==3.) {if(hash13(voxelCoord +iTime+30.) >.95 && hash(iTime +30.)>.99) vox.life=clamp(vox.life+1.,0.,3.);}\n    if(next[2].id==3.  &&  vox.id==3.) {vox.id=2.;}\n    if(next[2].id==12. && vox.id==0.) {vox.id=12.;}\n    if(next[2].value==3 && (vox.id==0.|| vox.id==12.)) {vox.id=next[2].id;} \n    \n    \/\/BELOW\n    if(next[5].id==10.  && next[5].life>0. && vox.id==0.) {vox.id=10.;  vox.life=next[5].life-1.; vox.ground=0.;}\n    if(next[5].id==10.  && next[5].life<1.) {vox.id=11.;  vox.life=TREE_SIZE;}\n    if((next[5].id!=3.|| next[5].shape!=0)  &&  vox.id==0.) {vox.life=0.;}\n    if((next[5].id!=0.|| next[5].id==12.)  &&  vox.value==3) {vox.id=0.; vox.value=0;vox.life=0.;}\n    if(next[5].id==3.  &&  vox.id==0.) {vox.life=1.;}\n    \n#ifdef TREE_DETAIL\t\n    if(vox.id==11.) vox.shape=8;\n    if(vox.id==10.) {vox.shape=9;};\n#endif\n\n\n    \/\/ FIREFLIES \n    \/\/if(vox.id==26.){vox.id=0.;  vox.light.t=15.;}\n    if(vox.id==26.){if(vox.light.t>1.) vox.light.t--; else vox.id=0.;vox.light.s=15.; }\n    \n    if(voxelCoord.z<35. || abs(load(_time).r-750.)<250.)\n        if( air>=62. && (voxelCoord.z < heightLimit_C +SURFACE_C - 1.)){\n            if(vox.id==0.  && hash13(voxelCoord +vec3(iTime))>0.9999  ) {vox.id=26.;  vox.light.t=15.;}\n\n        } \n\n#ifdef STRUCTURES\n    vec3 oldOffset = floor(vec3(load(_old+_pos).xy, 0.));\n\tstructures( voxelCoord,   vox,  oldOffset,  iFrame,  iTime);\n#endif\n    \n    fragColor = encodeVoxel(vox);\n#endif\n}",
            "name": "Buffer C",
            "description": "",
            "type": "buffer"
        },
        {
            "inputs": [
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "nearest",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "XsXGR8",
                    "filepath": "\/media\/previz\/buffer01.png",
                    "previewfilepath": "\/media\/previz\/buffer01.png",
                    "type": "buffer",
                    "channel": 1,
                    "sampler": {
                        "filter": "nearest",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "4sXGR8",
                    "filepath": "\/media\/previz\/buffer02.png",
                    "previewfilepath": "\/media\/previz\/buffer02.png",
                    "type": "buffer",
                    "channel": 2,
                    "sampler": {
                        "filter": "nearest",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                },
                {
                    "id": "XdfGR8",
                    "filepath": "\/media\/previz\/buffer03.png",
                    "previewfilepath": "\/media\/previz\/buffer03.png",
                    "type": "buffer",
                    "channel": 3,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "XdfGR8",
                    "channel": 0
                }
            ],
            "code": "\n\nvec2 max24(vec2 a, vec2 b, vec2 c, vec2 d) {\n\treturn max(max(a, b), max(c, d));   \n}\n\nfloat lightLevelCurve(float t) {\n    t = mod(t, 1200.);\n\treturn 1. - ( smoothstep(400., 700., t) - smoothstep(900., 1200., t));\n}\n\nvec3 lightmap(in vec2 light) {\n    light = 15. - light;\n\tif(load(_torch).r>0.5) light.t=13.;\n    \n    return clamp(mix(vec3(0), mix(vec3(0.11, 0.11, 0.21), vec3(1), lightLevelCurve(load(_time).r)), pow(.8, light.s)) + mix(vec3(0), vec3(1.3, 1.15, 1), pow(.75, light.t)), 0., 1.);   \n\n}\n\nfloat vertexAo(float side1, float side2, float corner) {\n\treturn 1. - (side1 + side2 + max(corner, side1 * side2)) \/ 5.0;\n}\n\nfloat opaque(float id) {\n\t\/\/return id > .5 ? 1. : 0.;\n    return  id != 0. && id!= 12. && id!= 26. ? 1. :0.;\n}\n\nvec3 calcOcclusion(vec3 r,vec3 n, vec2 uv,voxel vox) {\n#ifndef OCCLUSION\n    return vec3(vox.light , .75);\n#else    \n \t\/\/tangents:\n    vec3 s = vec3(step(.1,abs(n.y)), 1.- step( .1, abs(n.y)) ,0.                  );\n    vec3 t = vec3(step(.1,abs(n.z)), 0.                   ,1.- step(.1,abs(n.z)  ));\n    \n   \/\/neightbours vector\n   \/\/v[0],v[1],v[2]\n   \/\/v[3],v[4],v[5]\n   \/\/v[6],v[7],v[8]\n   voxel v[9]; \n   \n   for (int i =-1; i <=1; i++) {\n        for (int j =-1; j <=1  ; j++) {            \n             getVoxel(r +n + s* float(i)+t*float(j),v[4+ i+3*j +min(iFrame,0) ] ,3 );                     \t\n        }\n    }\n      \n    float aom, ao[4];\n    vec2 lightm,light[4];\n    for(int i=0;i<=3;i++){\n        \n        ivec4 ids;\n        if(i==0) ids=ivec4(6,7,3,4);\n        if(i==1) ids=ivec4(7,8,4,5);\n        if(i==2) ids=ivec4(3,4,0,1);\n        if(i==3) ids=ivec4(4,5,1,2);\n    \tlight[i +min(iFrame,0)] =max24(v[ids.x].light, v[ids.y].light, v[ids.z].light, v[ids.w].light);\n    }\n    lightm = mix(mix(light[2], light[3], uv.x), mix(light[0], light[1], uv.x), uv.y);\n    \n    for(int i=0;i<=3 ;i++){\n\n        ivec3 ids;\n        if(i==0) ids=ivec3(7,3,6);\n        if(i==1) ids=ivec3(7,5,8);\n        if(i==2) ids=ivec3(1,3,0);          \n        if(i==3) ids=ivec3(1,5,2);;\n        ao[i] = vertexAo(opaque(v[ids.x].id), opaque(v[ids.y].id), opaque(v[ids.z].id));\n    }\n    aom = mix(mix(ao[2], ao[3], uv.x), mix(ao[0], ao[1], uv.x), uv.y);\n   if(opaque(v[4].id)>0.) {aom*=0.75;}  \n    \n     \n    return vec3(lightm , aom);\n#endif    \n\n}\n\n\/\/ RENDERING\n\nvec3 rayDirection(vec2 angle, vec2 uv, vec2 renderResolution){\n    vec3 cameraDir = vec3(sin(angle.y) * cos(angle.x), sin(angle.y) * sin(angle.x), cos(angle.y));\n    vec3 cameraPlaneU = vec3(normalize(vec2(cameraDir.y, -cameraDir.x)), 0);\n    vec3 cameraPlaneV = cross(cameraPlaneU, cameraDir) * renderResolution.y \/ renderResolution.x;\n\treturn normalize(cameraDir + uv.x * cameraPlaneU + uv.y * cameraPlaneV);\n\n}\n\nstruct rayCastResults {\n\tbool hit;\n    vec3 rayPos;\n    vec3 mapPos;\n    vec3 normal;\n    vec2 uv;\n#ifdef SUBTEXTURE  \n    vec2 uv_txt;\n#endif    \n    float dist;\n    voxel vox;\n    float water;\n    float fog;\n    bool grass;\n    bool mirror;\n    vec3 color;\n    float fresnel;\n\n};\nmat3 rotate(float theta,int axis) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    if (axis==1) return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, s),\n        vec3(0, -s, c)\n    );\n    if (axis==2) return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n    return mat3(\n        vec3(c, s, 0),\n        vec3(-s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n\/\/From https:\/\/github.com\/hughsk\/glsl-hsv2rgb\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 \/ 3.0, 1.0 \/ 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 sun(){\n    float t = load(_time).r;\n    float sunAngle = (t * PI * 2. \/ 1200.) + PI \/ 4.;\n    const float risingAngle=PI\/6.;\n    return  vec4(cos(sunAngle)*sin(risingAngle), cos(sunAngle)*cos(risingAngle), sin(sunAngle),lightLevelCurve(t));\n}\n\n#ifdef CLOUDS \nfloat fogDensity(vec3 p) {\n\n\tfloat density = 2. - abs(p.z - 80.)*1.7;\n    \/\/density += mix(0., 40., pow(.5 + .5 * snoise(p.xy \/557. + vec2(0.576, .492)), 2.)) * snoise(p \/ 31.51 + vec3(0.981, .245, .497));\n    density += mix(0., 30., pow(.2 + 1.5 * snoise((p.xy +iTime)\/207. + vec2(0.576 +iTime\/200., .492)), 2.)) * snoise((p +iTime) \/ 30.99 + vec3(0.981, .245, .497 +iTime\/2000.));\n\n     return clamp(density ,0.,50.);\n\n}\nvoid applyFog( inout vec3  rgb,       \/\/ original color of the pixel\n               in float distance ) \/\/ camera to point distance\n{\n    \n    float fogAmount = 1.0 - exp( -distance*0.015 );\n    vec3  fogColor  = vec3(0.5,0.6,0.7)*clamp(sun().w,.1,1.);\n    rgb= mix( rgb, fogColor, fogAmount );\n}\n#endif\n\n\/\/-------------\n\nfloat noise(in vec2 p) {\n\tvec2 F = floor(p), f = fract(p);\n\tf = f * f * (3. - 2. * f);\n\treturn mix(\n\t\tmix(hash2(F), \t\t\t hash2(F+vec2(1.,0.)), f.x),\n\t\tmix(hash2(F+vec2(0.,1.)), hash2(F+vec2(1.)),\t  f.x), f.y);\n}\n\n\/\/GRASS ADAPTED FROM POLYANKA by W23\n\/\/https:\/\/www.shadertoy.com\/view\/MdsGzS\n#ifdef GRASS_DETAIL\nconst int c_grassmarch_steps = 48;\nconst float c_gscale = 37.;\nconst float c_gheight = 0.4;\n\/\/const float c_rgslope = 2. \/ (c_gscale * c_gheight);\n\n\nvec2 noise2(in vec2 p) {\n\tvec2 F = floor(p), f = fract(p);\n\tf = f * f * (3. - 2. * f);\n\treturn mix(\n\t\tmix(hash22(F), \t\t\t  hash22(F+vec2(1.,0.)), f.x),\n\t\tmix(hash22(F+vec2(0.,1.)), hash22(F+vec2(1.)),\tf.x), f.y);\n}\n\nfloat fnoise(in vec2 p) {\n\treturn .5 * noise(p) + .25 * noise(p*2.03) + .125 * noise(p*3.99);\n}\n\nvec2 wind_displacement(in vec2 p) {\n\treturn noise2(p*.1+iTime)\/100. - 0.005;\n}\n\nfloat grass_height(in vec3 p,float gheight) {\n\tfloat base_h= 0.15;\n\tfloat depth = 1. - (base_h - p.z) \/ gheight;\n\tvec2 gpos = (p.xy  + depth * wind_displacement(p.xy));\n\treturn base_h - noise(gpos * c_gscale) * gheight;\n}\n\n\nstruct xs_t {\n    bool hit;\n\tvec3 pos; \n\tfloat occlusion;\n    float dist;\n};\n\n\nxs_t trace_grass(vec3 o, vec3 d,vec3 mapPos,float gheight) {\n    bool hit=false;\n\tfloat L = .005;\n    \/\/float Lmax= 1.8;\n\tfor (int i = 0; i < c_grassmarch_steps; ++i) {\n\t\tvec3 pos = o + d * L ;\n\t\tfloat h = grass_height(pos +mod(mapPos,10.),gheight);\n\t\tfloat dh = pos.z - h;\n        if (dh < .005) {hit=true; break;}\n\t\tL += dh * 2. \/ (c_gscale * gheight);\n        vec3  dist = abs(pos-.5);\n        \/\/if (L > Lmax) break;\n\t\tif (max(dist.z, max(dist.x,dist.y))>.5) break;\n\t}\n\tvec3 pos = o + d * L;\n\tfloat occlusion = 1. - 2.*(0. - pos.z) \/ gheight;\n\treturn xs_t(hit, pos + mod(mapPos,99.),  (hit)?1.:min(1.,occlusion),L);\n}\n\nvec3 shade_grass(in xs_t xs) {\n    \n\tvec2 typepos = xs.pos.xy + wind_displacement(xs.pos.xy);\n\tfloat typemask1 = fnoise(2.5*typepos);\n\tfloat typemask2 = pow(fnoise(.4*typepos), 3.);\n\tfloat typemask3 = step(.71,fnoise(.8*typepos));\n\tvec3 col1 = vec3( 106.\/255., 170.\/255.,  64.\/255.);\n\tvec3 col2 = vec3(.7, .73, .3)*.3;\n\tvec3 col3 = vec3(1., 1., .1);\n\tvec3 col4 = vec3(1., .4, .7);\n\tvec3 color = mix(mix(mix(col1, col2, typemask1),\n\t\t\tcol3, typemask2), col4, typemask3) *.8;\n\tcolor *= xs.occlusion;\n\treturn color;\n}\t\n#endif\n\/\/-----------------------------\n\/\/water reflection: https:\/\/www.shadertoy.com\/view\/MdXGW2\n#define BUMPFACTOR 0.3\n#define EPSILON 0.1\n\nfloat waterHeightMap( vec2 pos ) {\n    return 0.9+.2*noise(pos +iTime\/3.);\n    \/\/better but requires more compilation time\n    \/\/return 0.9+.1*snoise(vec3(pos,iTime\/3.));\n}\n\nfloat fresnelR(vec3 d, vec3 n)\n{\n    \/\/float a = clamp(1.0-dot(n,-d), 0.0, 1.0);   \n   \/\/ return clamp(exp((5.0*a)-5.0), 0.0, 1.0);\n    return pow( clamp( 1.0 + dot(d,n), 0.0, 1.0 ), 5.0 );\n}\n\/\/------------------------*\/\nvec4 VoxelHitPos(vec3 pos, vec3 ro, vec3 rd){\n    vec3 ri = 1.0\/rd;\n\tvec3 rs = sign(rd);\n    vec3 mini = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;\n    float t=  max ( mini.x, max ( mini.y, mini.z ) );\n    return vec4(t*rd+ro,t);\n}\n\n#ifdef SUBVOXEL\nrayCastResults raySubCast(vec3 rayPosOrig, vec3 rayDir, int shape,float rotation,vec3 seed){\n \n\trayCastResults  res;\n    \n    \n    vec3 c=vec3(.5);\n    float theta1= PI\/2.*floor(mod(rotation,4.));\n    rayPosOrig = rotate( theta1,3) *(rayPosOrig-c) +c;\n    rayDir= rotate( theta1,3)*rayDir; \n    float theta2= PI\/2.*(floor(rotation\/4.));\n    rayPosOrig = rotate( theta2,2) *(rayPosOrig-c)+c;\n    rayDir= rotate( theta2,2)*rayDir; \n       \n     vec3 ro = (rayPosOrig) *N_SUBVOXEL;\n   \n\t\/\/if(abs(ro.x -N\/2.)>N\/2. ||abs(ro.y -N\/2.)>N\/2. ||abs(ro.y -N\/2.)>N\/2.)return vec4(0.,0.,0.,1.);\n       \n\tvec3 ri = 1.0\/rayDir;\n\tvec3 rs = sign(rayDir);\n    vec3 pos = floor(ro-rayDir*0.002);\n\tvec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;\n\t\n\tres.hit=false;\n\tvec3 mm = vec3(0.);\n    float t=0.;\n       \n\tfor( int i=0; i<int(N_SUBVOXEL)*3; i++ ) \n    {\t\n\t\tif(i>=0){\n       \t mm = step(dis.xyz, dis.yzx) * step(dis.xyz, dis.zxy);           \n        }\n         dis += mm * rs * ri;\n         pos += mm * rs;\n        \n        \/\/if( sdBox( ro+t*rayDir-vec3(N_SUBVOXEL\/2.),vec3(N_SUBVOXEL\/2.) )>.05) {res.hit=false; break;}\n        \n        \/\/float timestep= floor(mod(iTime,N_SUBVOXEL));\n        \/\/SHAPES\n       \n        \/\/SINGLE BLOCK\n        \/\/if( sdBox( pos-vec3(x,x,x) +rs*0.001 ,vec3(.5,.5,.5) )<.01) {res.hit=true; break;}\n     \n\n        if(shape==1){\/\/ POLE\n        \tif( sdBox( pos-vec3(2.,2.,2.) ,vec3(.5,.5,2.5) )<.001) {res.hit=true; break;}\n\t      \n        }else if(shape==2){\/\/STEP 1\n            if(sdBox( pos-vec3(2.,2.,0.)  ,vec3(2.5,2.5,0.5) )<.001) {res.hit=true; break;}\n          \n        }else if(shape==3){\/\/STEP 2\n             if( sdBox( pos-vec3(2.,2.,0.) ,vec3(2.5,2.5,1.5) )<.001) {res.hit=true; break;}\n           \n        }else if(shape==4){\/\/FENCE 1\n         \tif( sdBox( pos-vec3(2.,2.,2.)  ,vec3(.5,.5,2.5) )<.001) {res.hit=true; break;}\n          \tif( sdBox( pos-vec3(2.,2.,4.)  ,vec3(.5,2.5,.5) )<.001) {res.hit=true; break;}\n          \n        }else if(shape==5){\/\/FENCE 2\n        \tif( sdBox( pos-vec3(2.,2.,2.) ,vec3(.5,.5,2.5) )<.001) {res.hit=true; break;}\n          \tif( sdBox( pos-vec3(1.,2.,4.)  ,vec3(1.5,.5,.5) )<.001) {res.hit=true; break;}\n          \tif( sdBox( pos-vec3(2.,1.,4.)  ,vec3(.5,1.5,.5) )<.001) {res.hit=true;break;}\n\n        }else if(shape==6){\/\/SLOPE 1\n            if( dot(pos,  vec3(0.,sqrt(2.),sqrt(2.))) -6. <0.001 \n            && sdBox( pos-vec3(2.,2.,2.),vec3(2.5,2.5,2.5) )<.001  ) {res.hit=true; break;}\n            \n        }else if(shape==7){\/\/PANEL\n            if(sdBox( pos-vec3(0.,2.,2.)  ,vec3(.5,2.5,2.5) )<.001) {res.hit=true; break;}\n            \n        }\n#ifdef TREE_DETAIL        \n        else if(shape==8){\/\/TREE W LEAFS\n            \n     \t\tif( sdCross( pos-vec3(2.,2.,2.)  ,vec3(.5,.5,1.5) )<.001) {res.hit=true; res.vox.id=10.; break;}\n            vec3 applePos= vec3(1.,1.,1.);\/\/floor(hash33(seed)*5.);\n            if( sdBox( pos-applePos  ,vec3(.5,.5,.5) )<.01 \/\/ && hash13(seed)<.95 \n                 ){res.hit=true; res.vox.id=14.; break;}\n\n            if( sdBox( pos-vec3(2.,2.,2.)  ,vec3(2.5,2.5,2.5) )<.001 && hash13(floor(pos)+seed+.5 )  >.75){res.hit=true; res.vox.id=11.; break;}\n    \n            \/\/\n        }else if(shape==9){\/\/TRUNK\n\t\t\tvec3 p=pos-vec3(2.,2.,2.);\n            \/\/p= vec3(abs(p.x)+abs(p.y),max(p.x,p.y),p.z);\n            if(sdBox( p ,vec3(1.5,1.5,2.5) )<.001){res.hit=true; res.vox.id=10.; break;}\n         \n        }\n#endif        \n\t}\n\t\n\t\n    if(res.hit){\n        res.normal = - mm*rs; \n        vec4 hitPos=VoxelHitPos(pos,ro,rayDir);\n        res.dist=hitPos.a\/N_SUBVOXEL;\n        vec3 xyz = hitPos.xyz - pos;\n        res.uv = vec2( dot(mm.yzx, xyz), dot(mm.zxy, xyz) );\n        if(abs(mm.x)>0.) res.uv=res.uv.yx; \/\/invert xz \n        \/\/relative to absolute normals:\n   \t\tres.normal  = rotate( -theta2,2) * rotate(- theta1,3) *res.normal;\n    }\n    return res;  \n}\n#endif\n\nrayCastResults rayCast(vec3 rayPos0, vec3 rayDir,int maxRayDist,vec4 range,int rayType) {\n\t   \n    voxel vox;\n    vox.id=0.;\n    float waterDist=0.;\n    float fog=0.; \n    rayCastResults res;\n    res.hit = false;\n    res.color=vec3(-1.);\n    res.fresnel=0.;\n    res.mirror=false;\n    rayCastResults subRes;\n    subRes.hit=false;\n\n    vec3 raySign= sign(rayDir);\n    vec3 rayInv = 1.\/rayDir;\n\tvec3 rayPos=rayPos0;\n    \n    vec3 mapPos=floor(rayPos);\n    if ( rayPos.z >= heightLimit_B && rayDir.z<0.){\n       \n        \/\/MAP RAY FROM ABOVE\n        float nstep= (rayPos.z - heightLimit_B)*rayInv.z;\n        mapPos = floor(rayPos-rayDir *nstep+ raySign*0.001);\n    }\n    vec3 sideDist = (mapPos-rayPos + 0.5 + sign(rayDir)*0.5) *rayInv;\n    vec3 mask=vec3(0.); \n\n    \n    \/\/vec3 offset = floor(vec3(load(_pos).xy, 0.));\n    voxel currentVoxel;\n    getCVoxel( mapPos,currentVoxel,3);\n\tvec3 hitWater = (currentVoxel.id==12.? rayPos: vec3(0.));\n\tbool xRay=(currentVoxel.id!=0. && currentVoxel.id!=12.);\n        \n    for (int i = 0; i < 1000; i++) {\n\n        if(i>0){\n       \t\tmask = step(sideDist.xyz, sideDist.yzx) * step(sideDist.xyz, sideDist.zxy);\n\n        }\n\t\tsideDist += mask *  raySign *rayInv;\n        mapPos += mask *  raySign;\n        \n        if ( mapPos.z < 0. ) break;\n        if ( mapPos.z >= heightLimit_B && rayDir.z > 0.)  break;\n                   \n        getVoxel( mapPos, vox ,3 );\n        \n        \/\/GRASS\n#ifdef  GRASS_DETAIL      \n        if(vox.id==0. && vox.life>0. && rayType==1 ){\n\t\t\tvec4 vd =VoxelHitPos(mapPos,rayPos,rayDir);\n            res.rayPos= vd.xyz;\n            res.dist=vd.a;\n    \t\tvec3 relativePos = res.rayPos -mapPos;\n            \n            float grass = c_gheight*vox.life;\n           \txs_t xs = trace_grass(relativePos,rayDir,mapPos,grass);\n            \n            if (xs.hit ) {\n                \n                \/\/color = mix(color, c_skycolor, smoothstep(c_maxdist*.35, c_maxdist, xs.l));\n            \tres.hit = true;                \n                res.vox=vox;\n                res.grass=true;\n                res.color=shade_grass(xs);\n                res.mapPos = mapPos;\n                res.water =waterDist;\n    \t\t\tres.fog=fog;\n                res.normal = vec3(0,0,1);\n                res.dist+=  xs.dist ;\n    \t\t\tres.rayPos += rayDir * xs.dist ;\n                return res;\n            } \n\t\n        }\n#endif        \n       \n#ifdef SUBVOXEL        \n        if(vox.shape!=0 && vox.id!=0. ){ \n            \/\/SUB VOXEL\n\n    \t\tvec3 hitVoxelPos = VoxelHitPos(mapPos,rayPos,rayDir).xyz;\n            \n            if( sdBox( mapPos+vec3(.5) -rayPos,vec3(.5,.5,.5) )<.001) hitVoxelPos=rayPos;\n            float rotation= vox.rotation;\n            \n             subRes = raySubCast( hitVoxelPos - mapPos ,  rayDir, vox.shape,rotation,mapPos);\n            if(subRes.hit && vox.id!=12.) { \t\t\n       \t\t \tres.hit = true; \n                if(subRes.vox.id!=0.) vox.id=subRes.vox.id;             \n                break;\n            }\n            else if(vox.id==12. && subRes.hit && rayType!=3) { \n            \t\/\/nothing to do\n            }\n            else {vox.id=0.;res.hit = false;}\n        }\n#endif        \n        if(vox.id==14. &&rayType!=3){ \/\/&& length(rayPos-mapPos -vec3(0.,0.,1.))<=6.){\n            \/\/MIRROR \n                \n            vec3 endRayPos = VoxelHitPos(mapPos,rayPos,rayDir).xyz;\n            rayDir*= (vec3(1.) - 2.* mask); \t\t\t\t\n            rayDir=normalize(rayDir);rayInv=1.\/rayDir;raySign= sign(rayDir);\n\n            sideDist = (mapPos-endRayPos + 0.5 + raySign*0.5) \/rayDir;\n            vox.id=0.;\n            res.mirror=true;\n            rayPos=endRayPos;\n            continue;\n        }\n        if(vox.id==12.  ){ \/\/vox.life < WATER && vox.life>0.){\n        \t\/\/ENTERING WATER\n            if(hitWater.z<1.) {\n                \n                \/\/ deviate ray xy if intercept water NOT EXACT                \n    \t\t\tvec3 endRayPos = VoxelHitPos(mapPos,rayPos,rayDir).xyz;\n                vec3 n=mask;\n                if(subRes.hit) {\n                    \tendRayPos+=rayDir * subRes.dist;                    \t\n                        n=subRes.normal;\n                }\n     \t\t\thitWater=endRayPos;\n\n                if(abs(n.z)>0.) {\n                    vec2 coord = hitWater.xy;\n                    vec2 dx = vec2( EPSILON, 0. );\n                    vec2 dy = vec2( 0., EPSILON );\n                    float bumpfactor = BUMPFACTOR ;\/\/* (1. - smoothstep( 0., BUMPDISTANCE, dist) );\n\n                    vec3 normal = vec3( 0., 0., 1. );\n                    normal.x = -bumpfactor * (waterHeightMap(coord + dx) - waterHeightMap(coord-dx) ) \/ (2. * EPSILON);\n                    normal.y = -bumpfactor * (waterHeightMap(coord + dy) - waterHeightMap(coord-dy) ) \/ (2. * EPSILON);\n                    normal = normalize( normal );\n                   \n                    vec3 rayDirOld=rayDir;\n                    \n                    res.fresnel=fresnelR(rayDir, normal);\n    \t\t\t\t\n                    \n                    rayDir = refract( rayDir, normal ,1.3);\n                    if(res.fresnel>.005){\n                        rayDir = reflect( rayDirOld, normal );\n                        hitWater=vec3(0.,0.,-1.);\n                    }\n                }else if(abs(n.x)>0.) rayDir.yz*=(0.7+.4*noise(endRayPos.yz+iTime));\n                else  rayDir.xz*=(0.7+.4*noise(endRayPos.xz+iTime));\n                rayDir=normalize(rayDir);rayInv=1.\/rayDir;raySign=sign(rayDir);\n\n                rayPos=endRayPos;\n                sideDist = (mapPos-endRayPos + 0.5 + raySign*0.5) \/rayDir;\n                               \n            }\n            subRes.hit=false;\n            \/\/vox.id=0.;\n            continue;\n        }\n        if( vox.id !=0. && vox.id!=26. && vox.id!=12. ){\n        \tif(xRay) continue;\n            else{\n            \tres.hit = true; \n                break;\n            }\n        } \n\n#ifdef CLOUDS         \n        \/\/FOG & CLOUDS\n        if(CLOUDS>0.) {\n        \tfloat fogd= fogDensity(mapPos)\/4.*CLOUDS;\n        \tif(fogd >4. && rayType!=2) break;        \n        \tfog += fogd;\n        }\n#endif        \n        \/\/NO HIT\n        xRay=false; \n        if(hitWater.z>0. && vox.id==0.)  {waterDist +=length(hitWater-mapPos); hitWater=vec3(-1.);res.fresnel=.001;}\n        \n        if(!inRange(mapPos.xy, range) && i> maxRayDist) break;\n\n        if(i > int( load(_rayLimit).r)) break;\n\t}\n    if(hitWater.z>0.)  waterDist +=length(hitWater-mapPos);\n    if(hitWater.z<0.)  waterDist =0.;   \/\/reflection\n    \n    \n    if(load(_stats).r>0.5){\n    \tvec4 range_B= calcLoadRange_B(rayPos.xy,iResolution.xy,1.);\n        if(res.hit && inRange(mapPos.xy, range)  && !inRange(mapPos.xy, range_B)) vox.id = 8.;    \n\n\n#if SURFACE_CACHE>0        \n        vec4 range_C1= calcLoadRange_C(rayPos.xy,iResolution.xy,1.);\n\t\tvec4 range_C0 = load(_old+_loadRange_C);\n        if(res.hit && inRange(mapPos.xy, range_C0)  && !inRange(mapPos.xy, range_C1)) vox.id = 17.;    \n#endif\n    }\n        \n    if(!res.hit  &&rayDir.z < 0. && !inRange(mapPos.xy, range)){\n        if(mapPos.z>55.) {vox.id = 0.; res.hit=false;}\n        else { vox.id=3.; res.hit = true;}\n    }\n    \n    res.mapPos = mapPos;\n    res.normal = res.hit? -raySign * mask:vec3(0.);\n    res.rayPos = VoxelHitPos(mapPos,rayPos,rayDir).xyz;\n    res.dist = length(rayPos0 - res.rayPos);\n    res.vox=vox;\n    res.water =waterDist;\n    res.fog=fog;\n    \n    if(subRes.hit){\n        \n       \tres.normal=  subRes.normal; \n      \tmask=abs(subRes.normal);\n        res.rayPos += rayDir * subRes.dist ;\n        res.dist = length(rayPos - res.rayPos);\n        \n#ifdef SUBTEXTURE\n        \/\/ uv coordinates are relative to subvoxel (more detailed but aliased)\n    \tres.uv_txt = subRes.uv ;\n    \t\/\/return res;\n#endif\n    }\n    \n    \/\/uv coordinates are relative to block (also with subvoxels)                       \n    if (abs(mask.x) > 0.) {\n        res.uv = fract(res.rayPos.yz);\n    }\n    else if (abs(mask.y) > 0.) {\n        res.uv = fract(res.rayPos.xz);\n    }\n    else {\n        res.uv = fract(res.rayPos.yx);\n    }  \n    if(res.hit && !res.grass){\n        float textureId = res.vox.id;\n        if (textureId == 3.) textureId += res.normal.z;\n        vec2 uv_txt= res.uv;\n#ifdef SUBTEXTURE                \n        if(res.vox.shape!=0) uv_txt= res.uv_txt;\n#endif               \n        res.color = getTexture(textureId, uv_txt).rgb;\n    \n    }   \n    return res;\n}\n\n\nvec3 skyColor(vec3 rayDir) {\n    \n    vec4 s= sun();\n    float lightLevel = s.w;\n\n    vec3 sunDir=s.xyz;\n    vec3 daySkyColor = vec3(.5,.75,1);\n    vec3 dayHorizonColor = vec3(0.8,0.8,0.9);\n    vec3 nightSkyColor = vec3(0.1,0.1,0.2) \/ 2.;\n    \n    vec3 skyColor = mix(nightSkyColor, daySkyColor, lightLevel);\n    vec3 horizonColor = mix(nightSkyColor, dayHorizonColor, lightLevel);\n    float sunVis = smoothstep(.99, 0.995, dot(sunDir, rayDir));\n    float moonVis = smoothstep(.999, 0.9995, dot(-sunDir, rayDir));\n    return mix(mix(mix(horizonColor, skyColor, clamp(dot(rayDir, vec3(0,0,1)), 0., 1.)), vec3(1,1,0.95), sunVis), vec3(0.8), moonVis);\n    \n}\n\n\n\n\/\/ ---- 8< -------- 8< -------- 8< -------- 8< ----\n\n\nvoid render( out vec4 fragColor, vec3 rayPos, vec3 rayDir ,int  maxRayDist, int rayType) {\n\n    vec4 range_B = load(_old+_loadRange_B);\n    vec3 sunDir = sun().xyz; sunDir *= sign(sunDir.z);\n      \n    rayCastResults rays[2] ;\/\/0=view,1 =shadow\n    vec3 ro=rayPos;\n    vec3 rd=rayDir;\n    int rt=rayType;\n    for(int i=0; i<=1;i++){\n    \trays[i]=rayCast(ro, rd,maxRayDist,range_B,rt);\n\t\tif(!rays[i].hit) break;\n \t\tif(SHADOW<0.) break;\n        ro=rays[i].rayPos +rays[i].normal*0.01;\n        rd=sunDir;\n        maxRayDist=  25;\/\/inRange(rays[i].rayPos.xy, range_B) ? 25:5;\n        rt=3;\n            \n    }\n    \n   rayCastResults res = rays[0];\n\t\n\tvec3 color = vec3(0.);\n    \n    if (res.hit) {\n        \n\t\t\t\n        float shadow =rays[1].hit?SHADOW:0.;\n\n        color=res.color;\n\n\n        if(rayType==1 ){\n            bool hB=(res.vox.ground>=MAX_GROUND && res.vox.id!=0. &&res.vox.buffer==BUFFER_B)  \n                   || (res.vox.id==17. && res.vox.life >0.) ;        \n                             \n            if(hB && HIGHLIGHT>0. ){              \n                color  *=(fract(iTime*4.)+.5);\n            }\n            \n            if(res.grass) {              \n            \tcolor *= lightmap( vec2(res.vox.light.s*(1.-shadow*.2),res.vox.light.t)   );                 \n            }else{\n              vec3 occ=calcOcclusion(res.mapPos, res.normal, res.uv,res.vox);\n                color *= lightmap(vec2(occ.x*(1.-shadow*.2),occ.y)) *occ.z; \n            }\n\t\t\t\n            \/\/ SELECTION AND MOUSE OVER\n            vec4 pick = load(_pick);\n            if (res.mapPos == pick.xyz || res.vox.value==2) {\n                if (pick.a == 1.) color *= getTexture(32., res.uv).r;\n                else if (res.vox.value==2) color = mix(color, vec3(1.,0.,0.), 0.5);\n                \n                else color = mix(color, vec3(1), 0.2);\n            }\n        }else\n        {\t\n            \/\/MAP\n \t\t\t color *=  clamp( (res.mapPos.z-30.) \/30.,0.,1.);\n            color = mix(color, vec3(1), 0.2);\n          \n        }\n        \n    }\n     else color = skyColor(rayDir);\n    \n    vec3 wcolor= vec3(.03,.1,.60)* lightmap( vec2(res.vox.light.s,res.vox.light.t)   );\n    \/\/if(res.water>0.) color *= pow( wcolor ,vec3(sqrt(res.water)\/(7. + res.fresnel*1000.)));\n    if(res.water>0.) {\n        color *= pow( wcolor ,vec3(sqrt(res.water)\/7.));\n        color = mix(color,wcolor, clamp(res.fresnel*500.,0.3,1.));\n    }\n    else if(res.fresnel>0. ) color =mix(wcolor ,color,clamp(res.fresnel*4.,0.,.9));\n    if(res.mirror) color *= vec3(.9,.5,.5);\n    if(rayType==1) {\n#ifdef CLOUDS        \n        applyFog(color.rgb,res.fog);\n#endif\n        color = pow( color, vec3(0.9) );\n             \n    }\n    fragColor.rgb = color; \/\/pow(color, vec3(1.));\n    \n    if(rayType==3 ) {\n        \n        float encodeNormal=14.+ res.normal.x + res.normal.y*3. + res.normal.z*9.;\n        fragColor=vec4(res.mapPos,(res.hit && res.dist >1. && res.dist <MAX_PICK_DISTANCE ? encodeNormal:0.));\n    }  \n     \n    \/\/DEBUG:\n    \/\/fragColor=vec4( vec2(1.- res.dist \/50.),  res.hit?1.:0.,1.);\n    \/\/fragColor=vec4( (1.-.5* sign(res.normal))* abs(res.normal) ,1.);\n    \/\/fragColor=vec4( res.uv,max(abs(res.uv -.5).x,abs(res.uv-.5).y)<.5?1:0 ,1.);\n    \/\/if(res.vox.id==12.) fragColor=vec4(vec2(res.vox.life<2. ? .5:0.),1.- res.vox.life\/255.,1.);\n}\n\n\n#define NB 8\nfloat[] \n    camx = float[]   (2954. , 2952. , 2972. , 2972.,2971. ,2955. ,2955. ,2954.),\n\tcamy = float[]   (10139., 10140., 10151.,10151.,10152.,10151.,10153.,10139.),\n\tcamz = float[]   (71.   , 83.   , 48.   ,34.   ,50.   ,50.   ,71.   ,71.),\n    lookx = float[]  (2970. ,2972.  , 2972. ,2952. ,2955. ,2955. ,2954. ,2970.),\n\tlooky = float[]  (10152.,10153. , 10154.,10133.,10151.,10150.,10139.,10152.),\n\tlookz = float[]  (55.   , 50.   , 34.   ,27.   ,50.   ,71.   ,71.   ,55.); \n \n\nmat3 LookAt(in vec3 ro, in vec3 up){\n    vec3 fw=normalize(ro),\n    \t rt=normalize(cross(fw,up));\n    return mat3(rt, cross(rt,fw),fw);\n}\n\nvec3 RD(in vec3 ro, in vec3 cp, vec2 uv, vec2 res) {\n    return LookAt(cp-ro, vec3(0,0,1))*normalize(vec3((2.*uv-res.xy)\/res.y, 3.5));\n}\n\nvoid getCam(in vec2 uv, in vec2 res, in float time, out vec3 ro, out vec3 rd) {\n       \n\tvec2 q = uv\/res;\n    \n    float t = .16* time,\n\t\t kt = smoothstep(0.,1.,fract(t));\n\n    \/\/ - Interpolate positions  and direction\n    int  i0 = int(t)%NB, i1 = i0+1;\n    \n    vec3 cp = mix(vec3(lookx[i0],looky[i0],lookz[i0]), vec3(lookx[i1],looky[i1],lookz[i1]), kt); \n  \n    ro = mix(vec3(camx[i0],camy[i0],camz[i0]), vec3(camx[i1],camy[i1],camz[i1]), kt),\n    ro += vec3(.01*cos(2.*time), .01*cos(time),0.);\n    rd = RD(ro, cp, uv, res);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n \n    float pixelSize = load(_pixelSize).r;\n    vec2 renderResolution = ceil(iResolution.xy \/ pixelSize); \n    if (any(greaterThan(fragCoord, renderResolution))) {\n        fragColor = vec4(0);\n        return;\n    }\n        \n    vec3 cameraPos;    \n    vec3 cameraDir;\n    int  rayType = 1;\n \n#ifdef MAP    \n    float MAP_SIZE= iResolution.y\/8.\/pixelSize; \n    vec2 MapCenter=vec2(iResolution.x\/pixelSize -MAP_SIZE , iResolution.y\/pixelSize - MAP_SIZE);\n    if(abs(load(_map).r-1.) <.1 && distance(fragCoord,MapCenter)<MAP_SIZE) rayType=2;\n    if(abs(load(_map).r-2.) <.1) {\n        rayType=2;\n        MapCenter=vec2(iResolution.x\/pixelSize\/2. , iResolution.y\/pixelSize\/2.);\n    }\n    \n#endif    \n    \n    if(max(fragCoord.x,fragCoord.y)<1. ) rayType=3;\n    if(rayType==3){\n        \/\/MOUSE RAY\n        float zoom = pow(10., load(_renderScale).r\/10.);\/\/\/pixelSize;\n        vec2 renderResolution = iResolution.xy *zoom; \n        vec2 renderCenter=vec2(0.5);\n        vec2 uv = (iMouse.xy- renderCenter) \/ renderResolution - (renderCenter\/zoom);\/\/  \/pixelSize;\n         cameraPos = load(_pos).xyz + vec3(0,0,1.6);    \n         cameraDir = rayDirection(load(_angle).xy,uv,renderResolution);\n  \n    } \n#ifdef MAP \n    else if(rayType==2){\n     \n        \/\/ MAP CAMERA\n        float cameraHeight =1500.;\n        float zoom = cameraHeight\/iResolution.x\/pixelSize*(load(_map).r>1.5?1.6:.4);\n        vec2 renderResolution = iResolution.xy *zoom; \n        vec2 renderCenter=MapCenter\/iResolution.xy*pixelSize;\n        vec2 uv = (fragCoord.xy- renderCenter) \/ renderResolution - (renderCenter\/zoom\/pixelSize);    \n        vec2 angle = vec2(0.,PI);\n        if(load(_map).r>1.5){\n        \tangle=iMouse.xy\/iResolution.xy*vec2(PI,-PI\/3.)+vec2(0,PI);\n        }\n        cameraDir = rayDirection(angle,uv,renderResolution); \n        vec3 cameraCenterDir = vec3(sin(angle.y) * cos(angle.x), sin(angle.y) * sin(angle.x), cos(angle.y));\n        cameraPos = load(_pos).xyz -cameraCenterDir* cameraHeight;\n    }       \n#endif            \n    else if(rayType==1) \n    {    \n        \/\/ MAIN CAMERA\n        float zoom = pow(10., load(_renderScale).r\/10.)\/pixelSize;\n        vec2 renderResolution = iResolution.xy *zoom; \n        vec2 renderCenter=vec2(0.5);\n        vec2 uv = (fragCoord.xy- renderCenter) \/ renderResolution - (renderCenter\/zoom\/pixelSize);\n         cameraPos = load(_pos).xyz + vec3(0,0,1.6);    \n         cameraDir = rayDirection(load(_angle).xy,uv,renderResolution);\n     \n      \/\/DEMO VIEW     \n         if(load(_demo).r >.5)\n             getCam((fragCoord.xy- renderCenter) , renderResolution, iTime, cameraPos, cameraDir);\n                  \n    }   \n\n    render(fragColor,cameraPos, cameraDir, int(load(_rayDistMax).r),rayType);\n       \n    \/\/MAP BORDER:\n#ifdef MAP\n    if(rayType==2){\n        if(load(_map).r <1.5){\n        \tif(abs(distance(fragCoord,MapCenter)-MAP_SIZE)<1.) fragColor.rgb=vec3(0.);    \n        \tif(distance(fragCoord,MapCenter + vec2(sin( load(_angle).x), -cos( load(_angle).x))*MAP_SIZE )<3.) fragColor.rgb= vec3(1.,0.,0.);\n        }\n    }\n#endif        \n    \/\/fragColor = texture(iChannel2, fragCoord \/ 3. \/ iResolution.xy);\n}",
            "name": "Buffer D",
            "description": "",
            "type": "buffer"
        }
    ]
}