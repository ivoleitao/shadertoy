{
    "ver": "0.1",
    "info": {
        "id": "wl3yDn",
        "date": "1608833734",
        "viewed": 1774,
        "name": "Truchet Grid Inversion",
        "username": "pjkarlik",
        "description": "Making a mess with truchet tiles - two 2d layers in a cube\/grid setup. Add some rings and warp.",
        "likes": 40,
        "published": 3,
        "flags": 0,
        "usePreview": 0,
        "tags": [
            "raymarching",
            "inversion",
            "tuchet"
        ],
        "hasliked": 0
    },
    "renderpass": [
        {
            "inputs": [],
            "outputs": [
                {
                    "id": "4dfGRr",
                    "channel": 0
                }
            ],
            "code": "\/**\n    Playing with some abstract forms and shapes\n    Standard truchet patten in 3d (grid) and\n    then warped \n    nothing too exciting @pjkarlik\n*\/\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n#define S           smoothstep\n#define PI          3.1415926535\n#define PI2         6.2831853070\n\n#define MAX_DIST    50.\n#define MIN_DIST    .001\n#define SCALE .7\n\n#define r2(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define hue(a) .45 + .45 * cos(PI2* a * vec3(.25,.15,1.));\n\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.608, 57.584)))*43758.51453); }\n\nvoid getMouse( inout vec3 p ) {\n    float x = M.xy == vec2(0) ? 0. : -(M.y\/R.y * .25 - .125) * PI;\n    float y = M.xy == vec2(0) ? 0. :  (M.x\/R.x * .25 - .125) * PI;\n    p.zy *=r2(x);\n    p.xz *=r2(y);   \n}\n\n\/\/@iq\nmat2 trs;\nfloat sdTorus( vec3 p, vec2 t, float a ) {\n  if(a>0.){\n      p.xy *= trs;\n      p.yz *= trs;\n  }\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n\nvec3 shp,fhp;\nvec3 sip,bip;\nfloat thsh,fhsh;\nmat2 t90;\n\nconst float size = 1.\/SCALE;\nconst float hlf = size\/2.;\nconst float shorten = 1.26;   \n    \nvec2 map(vec3 q3){\n    vec2 res = vec2(100.,0.);\n\n    float k = 5.0\/dot(q3,q3); \n    q3 *= k;\n\n    q3.z += T*.225;\n    \n    float d = 1e5, t = 1e5, f = 1e5, g = 1e5;\n  \n    vec3 qid=floor((q3+hlf)\/size);\n    vec3 qm = mod(q3+hlf,size)-hlf;\n    \n    q3+=hlf;\n    \n    vec3 did=floor((q3+hlf)\/size);\n    vec3 qd = mod(q3+hlf,size)-hlf;\n    \n    float ht = hash21(qid.xy+qid.z);\n    float hy = hash21(did.xz);\n    \n    \/\/ truchet build parts\n    float thx = (.075+.025*sin((q3.y+qid.z)*3.15) ) *size;\n    float thz = (.075+.025*sin(T*4.+(q3.y+did.x)*3.45) ) *size;\n\n    if(ht>.5) qm.x *= -1.;\n    if(hy>.5) qd.z *= -1.;\n    \n    float ti = min(\n      sdTorus(qm-vec3(hlf,hlf,.0),vec2(hlf,thx),0.),\n      sdTorus(qm-vec3(-hlf,-hlf,.0),vec2(hlf,thx),0.)\n    );\n\n    \/\/ truchet\n    if(ti<t) {\n        t = ti;\n        bip = qid;\n        fhp = qm;\n    }\n    \n    float gi = min(\n      sdTorus(qm.xzy-vec3(.0,0,hlf),vec2(.2,.025),0.),\n      sdTorus(qm.xzy-vec3(.0,0,-hlf),vec2(.2,.025),0.)\n    );\n\n    if(gi<g) {\n        g = gi;\n        sip = qid;\n        shp = qm;\n    }\n    \n    qd.xz*=t90;\n    float di = min(\n      sdTorus(qd-vec3(hlf,hlf,.0),vec2(hlf,thz),0.),\n      sdTorus(qd-vec3(-hlf,-hlf,.0),vec2(hlf,thz),0.)\n    );\n   \n   \/\/ truchet\n    if(di<d) {\n        d = di;\n        sip = did;\n        shp = qd;\n    }\n\n    float fi = min(\n      sdTorus(qd.xzy-vec3(.0,0,hlf),vec2(.2,.025),0.),\n      sdTorus(qd.xzy-vec3(.0,0,-hlf),vec2(.2,.025),0.)\n    );\n\n    if(fi<f) {\n        f = fi;\n        sip = did;\n        shp = qd;\n    }\n    if(d<res.x) res = vec2(d,1.);\n    if(t<res.x) res = vec2(t,2.);\n    if(f<res.x) res = vec2(f,3.);\n    if(g<res.x) res = vec2(g,3.);\n    float mul = 1.0\/k;\n    res.x = res.x * mul \/ shorten;\n    \n    return res;\n}\n\nvec2 marcher(vec3 ro, vec3 rd, int maxsteps) {\n    float d = 0.;\n    float m = -1.;\n    for(int i=0;i<maxsteps;i++){\n        vec2 t = map(ro + rd * d);\n        if(t.x<d*MIN_DIST||d>MAX_DIST) break;\n        d += i < 32 ? t.x*.35 : t.x*.85;\n        m  = t.y;\n    }\n    return vec2(d,m);\n}\n\n\/\/ Tetrahedron technique @iq\n\/\/ https:\/\/www.iquilezles.org\/www\/articles\/normalsSDF\nvec3 getNormal(vec3 p, float t){\n    float e = MIN_DIST *t;\n    vec2 h = vec2(1.,-1.)*.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n                      h.yyx*map( p + h.yyx*e ).x + \n                      h.yxy*map( p + h.yxy*e ).x + \n                      h.xxx*map( p + h.xxx*e ).x );\n}\n\n\n\/\/ softshadow www.pouet.net\n\/\/ http:\/\/www.pouet.net\/topic.php?which=7931\nfloat softshadow( vec3 ro, vec3 rd, float mint, float maxt, float k ){\n    float res = 1.0;\n    for( float t=mint; t < maxt; ){\n        float h = map(ro + rd*t).x;\n        if( h<0.001 ) return 0.2;\n        res = min( res, k*h\/t );\n        t += h;\n    }\n    return res+0.2;\n}\n\nvec3 getSpec(vec3 p, vec3 n, vec3 l, vec3 ro) {\n    vec3 spec = vec3(0.);\n    float strength = 0.75;\n    vec3 view = normalize(p - ro);\n    vec3 ref = reflect(l, n);\n    float specValue = pow(max(dot(view, ref), 0.), 32.);\n    return spec + strength * specValue;\n}\n\nvec3 camera(vec3 lp, vec3 ro, vec2 uv) {\n    vec3 cf = normalize(lp - ro),\n         cr = normalize(cross(vec3(0,1,0),cf)),\n         cu = normalize(cross(cf,cr)),\n         c  = ro + cf *.85,\n         i  = c + uv.x * cr + uv.y * cu,\n         rd = i - ro;\n    return rd;\n}\n\nvec3 thp,ghp;\nvec3 tip,fid;\n\nfloat circle(vec2 pt, float r, vec2 center, float lw) {\n    float len = length(pt - center);\n    float hlw = lw \/ 2.;\n    float edge = .005;\n    return S(r-hlw-edge,r-hlw, len)-S(r+hlw,r+hlw+edge, len);\n}\n\nvec3 getColor(float m, vec3 p, vec3 n) {\n    vec3 h = vec3(.5); \n    \n    if(m==1.) {\n        float hs = hash21(vec2(tip.x+12.75));\n        float xt = floor(1.+(3.23*hs))*2.;\n        xt +=3.;\n        \/\/ strip patterns..\n        thp\/=1.\/SCALE;\n        float dir = mod(tip.z + tip.y,2.) * 2. - 1.;  \n\n        vec2 cUv = thp.xy-sign(thp.x+thp.y+.001)*.5;\n        float angle = atan(cUv.x, cUv.y);\n        float a = sin( dir * angle * xt + T * 1.25);\n        a = abs(a)-.5;a = abs(a)-.24;\n        vec3 nz = hue((p.x+(T*.633))*.075);\n        h = mix(nz, vec3(0), smoothstep(.01, .02, a));   \n    }\n    \n    if(m==2.) {    \n        float hs = hash21(vec2(fid.z-12.75));\n        float xt = floor(2.-(3.73*hs))*2.;\n        xt +=7.;\n        \n        ghp\/=1.\/SCALE;\n        \n        \/** \n        \/\/ strip patterns..\n        float dir = mod(fid.x + fid.y,2.) * 2. - 1.;  \n\n        vec2 cUv = ghp.xy-sign(ghp.x+ghp.y+.001)*.5;\n        float angle = atan(cUv.x, cUv.y);\n        float a = sin( dir * angle * xt + T * 1.15);\n        \n        a = abs(a)-.5; a = abs(a)-.25; a = abs(a)-.15;\n        vec3 nz = hue((p.x+(2.+T*.83))*.065);\n        h = mix(nz, vec3(0), smoothstep(.01, .02, a)); \n         *\/\n        \n        \/\/TRUCHET PATTERN\n        ghp.xy *= 20.;\n        vec3 nz = hue((p.x+(2.+T*.83))*.065);\n        vec2 id = floor(ghp.xy);\n        vec2 rg = fract(ghp.xy)-.5;\n        if(hash21(id) <.5) rg.x *= -1.;\n        vec2 dUv = rg.xy-sign(rg.x+rg.y+.001)*.5;\n        float d = length(dUv);\n        float pix = 1.312;\n        float mask = smoothstep(pix, -pix, abs(d-.5)-.15);\n \n        h *= S(.5,.53,mask);\n       \n    }\n    \n    return h;\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n    \/\/ precal\n    trs = r2(PI*4.5);\n    t90 = r2(90.*PI\/180.);\n    \/\/ Normalized coordinates (from -1 to 1)\n    vec2 uv = (2.*F.xy-iResolution.xy)\/max(iResolution.x,iResolution.y);\n    vec3 C = vec3(0.);\n    vec3 tC= vec3(0.);\n    vec3 FC = vec3(.05);\n    vec3 lp = vec3(0.,0.,0.),\n         ro = vec3(.0,0.,3.70);\n         getMouse(ro);\n\n    vec3 rd = camera(lp,ro,uv);\n    vec2 t = marcher(ro,rd, 192);\n    \/\/ save all globals\n    thp = shp;\n    ghp = fhp;\n    tip = sip;\n    fid = bip;\n    if(t.x<MAX_DIST){\n        vec3 p = ro + rd * t.x;\n        vec3 n = getNormal(p,t.x);\n        vec3 lpos = vec3(.0,.001,3.85);\n        vec3 lp = normalize(lpos-p);\n        vec3 ll = normalize(lpos);\n        float shadow = softshadow(p + n * MIN_DIST, lp, .1, 32., 32.);     \n        float diff = clamp(dot(n,lp),.0, 1.);\n        vec3 spec = getSpec(p,n,ll,ro);\n        vec3 h = getColor(t.y, p, n);\n\n        C += (h * diff * shadow + spec);\n\n        \/\/ reflection\n        \/\/ if material && hue black \n        if(h.x<.001 &&h.y<.001 &&h.z<.001 || t.y == 3.){\n            vec3 rr=reflect(rd,n); \n            vec2 tr = marcher(p ,rr, 128);\n            thp = shp;\n            ghp = fhp;\n            tip = sip;\n            fid = bip;\n            if(tr.x<MAX_DIST){\n                p += rr*tr.x;\n                n = getNormal(p,tr.x);\n                lp = normalize(lpos-p);\n                diff = diff = clamp(dot(n,lp),.01 , 1.);\n                h = getColor(tr.y, p, n);\n                tC = (h * diff * shadow);\n                tC = mix( tC, FC, 1.-exp(-.03*tr.x*tr.x*tr.x));\n            }\n        } \n        \n    } \n    C+= (tC*.45);\/\/fade back reflections.. so bright..\n    C = mix( C, FC, 1.-exp(-.04*t.x*t.x*t.x));\n    \/\/ Output to screen\n    O = vec4(C,1.0);\n}",
            "name": "Image",
            "description": "",
            "type": "image"
        }
    ]
}