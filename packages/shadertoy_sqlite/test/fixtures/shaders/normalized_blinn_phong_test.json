{
    "ver": "0.1",
    "info": {
        "id": "WttyRj",
        "date": "1609499319",
        "viewed": 42,
        "name": "Normalized Blinn Phong test",
        "username": "iY0Yi",
        "description": "Another test for Normalized Blinn Phong shading.\nMouse enabled.\nref:\nhttps:\/\/hanecci.hatenadiary.org\/entry\/20130505\/p2\nhttp:\/\/www.project-asura.com\/program\/d3d11\/d3d11_006.html",
        "likes": 5,
        "published": 3,
        "flags": 32,
        "usePreview": 0,
        "tags": [
            "phong",
            "blinn",
            "normalized"
        ],
        "hasliked": 0
    },
    "renderpass": [
        {
            "inputs": [
                {
                    "id": "4dXGR8",
                    "filepath": "\/media\/previz\/buffer00.png",
                    "previewfilepath": "\/media\/previz\/buffer00.png",
                    "type": "buffer",
                    "channel": 0,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "clamp",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dfGRr",
                    "channel": 0
                }
            ],
            "code": "vec3 ACESFilm(vec3 x){\n\tfloat a = 2.51;\n\tfloat b = 0.03;\n\tfloat c = 2.43;\n\tfloat d = 0.59;\n\tfloat e = 0.14;\n\treturn (x*(a*x+b))\/(x*(c*x+d)+e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n\tuv\/=ERNST_RENDER_SCALE;\n\n\tvec3 col = texture(iChannel0, uv).rgb;\n\tcol = ACESFilm(col);\n\tcol = pow(col, vec3(.9));\n\n\tfragColor = vec4(col, 1);\n}",
            "name": "Image",
            "description": "",
            "type": "image"
        },
        {
            "inputs": [],
            "outputs": [],
            "code": "\/\/ General\n\/\/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define iFrameRate 24.0\n#define PI acos(-1.)\n#define HALF_PI (PI*.5)\n#define TAU (PI*2.)\n#define ZERO min(0,iFrame)\n\n#define sat(x) clamp(x, 0.0, 1.0)\n#define sms(min, max, x) smoothstep(min, max, x)\n#define s2u(x) (x*.5+.5)\n#define u2s(x) ((x*2.)-1.)\n\n\/\/ Raymarching\n\/\/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define ERNST_RENDER_SCALE float(1.0)\n#define INV_ERNST_RENDER_SCALE (1.\/ERNST_RENDER_SCALE)\n#define MIN_DIST 0.01\n#define MAX_DIST 1000.0\n#define ITERATION 100\n\n#define MAT_VOID vec3(-1)\n#define MAT_ERNST1 vec3(0.2396, 0.2396, 0.2396)\n\n#define AMB_COL vec3(1.0, 1.0, 1.0)\n#define AMB_STRENGTH 0.3\n#define FOG_COL vec3(1.0, 1.0, 1.0)\n#define FOG_START -0.63\n#define FOG_POW 1.0\n\n\/\/ \"hash11()\" - \"hash44()\"\n\/\/ \"Hash without Sine\" by Dave_Hoskins:\n\/\/ https:\/\/www.shadertoy.com\/view\/4djSRW\n\/\/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat hash11(float p){\n\tp = fract(p * .1031);\n\tp *= p + 33.33;\n\tp *= p + p;\n\treturn fract(p);\n}\n\n\n\n\/\/ \"SDF Font Texture Adventures\" by P_Malin:\n\/\/ https:\/\/www.shadertoy.com\/view\/ldfcDr\n\/\/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define BLACK\t\tvec3(0)\n#define WHITE\t\tvec3(1)\n#define GREY(A)\t\tvec3(A)\n#define RED  \t\tvec3(1,0,0)\n#define GREEN\t\tvec3(0,1,0)\n#define BLUE \t\tvec3(0,0,1)\n#define TURQUOISE \tvec3(0,1,1)\n#define PURPLE\t\tvec3(1,0,1)\n#define YELLOW \t\tvec3(1,1,0)\n#define VIOLET \t\tvec3(.5,0,1)\n#define LIGHT_BLUE\tvec3(0,.5,1)\n#define LIGHT_GREEN\tvec3(.5,1,0)\n#define LAGOON\t\tvec3(0,1,.5)\n#define ORANGE\t\tvec3(1,.5,0)\n#define MAGENTA\t\tvec3(1,0,.5)\n#define PINK\t\tvec3(1,.3,.7)\n\n\n#define POW2(A) ((A)*(A))\n#define POW3(A) (POW2(A)*(A))\n#define POW4(A) (POW3(A)*(A))\n\n#define Res iResolution\n\nint powInt(int a, int b){\n    int r = 1;\n    for(int i=0;i++<b;r*=a);\n    return r;\n}\n\nint intLog(int x, int base){\n    if(x<1) return 0;\n    int res = 0;\n    for(;x>=base;res++)\n        x \/= base;\n    return res;\n}\n\n\/\/ Periodic function __|__|__|__|__\n\/\/ s : dirac compression\nfloat periodicDirac(float x, float period, float s){\n\treturn pow(abs(cos(x*(PI\/period))),s);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ Ascii encoding. Takes ~900 chars so you may want to take onlywhat you need\nconst int\t_=32,\n\t\t\t_EXCL=33,\t\t\/\/ !\n\t\t\t_QUOTE=34,\t\t\/\/ \"\n\t\t\t_SHARP=35,\t\t\/\/ #\n\t\t\t_DOLLAR=36,\t\t\/\/ $\n\t\t\t_PERCENT=37,\t\/\/ %\n\t\t\t_AMPER=38,\t\t\/\/ &\n\t\t\t_SQUOTE=39,\t\t\/\/ '\n\t\t\t_LPAR=40,\t\t\/\/ (\n\t\t\t_RPAR=41,\t\t\/\/ )\n\t\t\t_ASTERISK=42,\t\/\/ *\n\t\t\t_PLUS=43,\t\t\/\/ +\n\t\t\t_COMMA=44,\t\t\/\/ ,\n\t\t\t_MINUS=45,\t\t\/\/ -\n\t\t\t_DOT=46,\t\t\/\/ .\n\t\t\t_SLASH=47,\t\t\/\/ \/\n\t\t\t_0=48,\t_1=49,\t_2=50,\t_3=51,\t_4=52,\n    \t\t_5=53,\t_6=54,\t_7=55,\t_8=56,\t_9=57,\n    \t\t_COLON=58,\t\t\/\/ :\n    \t\t_SEMICOLON=59,\t\/\/ ;\n    \t\t_LT=60,\t\t\t\/\/ <\n    \t\t_EQ=61,\t\t\t\/\/ =\n    \t\t_GT=62,\t\t\t\/\/ >\n    \t\t_QUEST=63,\t\t\/\/ ?\n    \t\t_AT=64,\t\t\t\/\/ @\n\t\t\t_A=65,\t_B=66,\t_C=67,\t_D=68,\t_E=69,\n\t\t\t_F=70,\t_G=71,\t_H=72,\t_I=73,\t_J=74,\n\t\t\t_K=75,\t_L=76,\t_M=77,\t_N=78,\t_O=79,\n\t\t\t_P=80,\t_Q=81,\t_R=82,\t_S=83,\t_T=84,\n\t\t\t_U=85,\t_V=86,\t_W=87,\t_X=88,\t_Y=89,\n\t\t\t_Z=90,\n\t\t\t_a=97,\t_b=98,\t_c=99,\t_d=100,\t_e=101,\n\t\t\t_f=102,\t_g=103,\t_h=104,\t_i=105,\t_j=106,\n\t\t\t_k=107,\t_l=108,\t_m=109,\t_n=110,\t_o=111,\n\t\t\t_p=112,\t_q=113,\t_r=114,\t_s=115,\t_t=116,\n\t\t\t_u=117,\t_v=118,\t_w=119,\t_x=120,\t_y=121,\n\t\t\t_z=122,\n    \t\t_alpha=128,\t\t_beta=129,\t_gamma=130,\t\t_delta=131,\n    \t\t_epsilon=132,\t_theta=133,\t_lambda=134,\t_mu=135,\n    \t\t_xi=136,\t\t_pi=137,\t_rho=138,\t\t_sigma=139,\n    \t\t_tau=140,\t\t_phi=141,\t_psi=142,\t\t_omega=143,\n    \t\t_GAMMA=144,\t\t_DELTA=145,\t_THETA=146,\t\t_LAMBDA=147,\n    \t\t_PI=148,\t\t_SIGMA=149,\t_PHI=150,\t\t_PSI=151,\n    \t\t_OMEGA=152;\n\nstruct PrintPosition{\n    vec2 uv,\n         pos,\n         Res;\n    float scale;\n};\n\nstruct PrintStyle{\n    vec3 char_color,\n         outline_color;\n    float outline_size;\n};\n\nPrintStyle NewPrintStyle(vec3 col1, vec3 col2, float w){\n\treturn PrintStyle(col1,col2,w);\n}\nPrintStyle NewPrintStyle(vec3 col1, vec3 col2){\n\treturn PrintStyle(col1,col2,.05);\n}\nPrintStyle NewPrintStyle(vec3 col){\n\treturn PrintStyle(col,col,0.);\n}\n#define DefaultPrintStyle NewPrintStyle(WHITE,BLACK)\n\n#define getDisplayPos(pos,scale) PrintPosition((COORD-pos*Res.xy)\/(scale*Res.x),pos,Res.xy,scale);\n#define nextLine(p)\tp.pos.y -= scale*1.5,\\\n\t\t\t\t\tp = getDisplayPos(p.pos,p.scale);\n\nvoid writeChar(int char, PrintStyle style,\n               float w, float x_offset, \/\/ Dimensions of the bbox of the char\n               inout PrintPosition p, sampler2D font_tex, inout vec3 color){\n    \t#define getFont(uv,char) texture(font_tex, (uv+vec2(char%16,15-char\/16))\/16.)\n\t\tvec2 uv = p.uv;\n    \tuv.x += x_offset;\n    \tfloat outline_size = style.outline_size;\n    \tif(uv.x>0. && uv.x<w && uv.y>0. && uv.y<1.){\n            \/\/ We are inside the bbox, display the char\n            color = mix(color,style.outline_color,smoothstep(0.,-1.\/p.Res.y,getFont(uv,char).a - outline_size-.5));\n            color = mix(color,style.char_color, getFont(uv,char).r);\n        }\n\t\tuv.x -= w; \/\/ move uv for next char\n    \tp.uv = uv;\n}\n\nfloat default_ch_w = .8,\n      default_ch_off = .3;\n\nvoid writeStandardChar(int char, PrintStyle style,\n                     inout PrintPosition p, sampler2D font_tex, inout vec3 color){\n    writeChar(char,style,\n              default_ch_w,default_ch_off,\n              p,font_tex,color);\n}\n\n#define writeText(text, style, p, font_tex, color)\\\n\t{int chars_per_line = int((1.-p.pos.x)\/(p.scale*(default_ch_w-default_ch_off)));\\\n\tfor(int i=0;i<text.length();i++){\\\n        writeStandardChar(text[i],style,p,font_tex,color);\\\n        if((i+1)%chars_per_line==0)\\\n            nextLine(p);\\\n    }}\n\n#define writeWord(word, style, p, font_tex, color)\\\n\tfor(int i=0;i<word.length();i++)\\\n        writeStandardChar(word[i],style,p,font_tex,color);\n\nvoid writeNumber(float number, int min_int_digits, int dec_digits,\n                 PrintStyle style,\n                 inout PrintPosition p, sampler2D font_tex, inout vec3 color){\n\t\n    if(isnan(number)){\n    \tPrintStyle NaN_style = PrintStyle(BLACK,RED,.05);\n        writeWord(int[](_N,_a,_N),NaN_style,p,font_tex,color);\n    }\n    else if(isinf(number)){\n        PrintStyle Inf_style = PrintStyle(BLACK,LIGHT_BLUE,.05);\n        writeWord(int[](_I,_n,_f),Inf_style,p,font_tex,color);\n    }\n    else{\n        \/\/ Display the minus if number is negative\n        if(number<0.)\n            writeStandardChar(_MINUS,style,p,font_tex,color);\n        \n        \/\/ Round the number according to the number of decimal digits\n        float decimal_digits_factor = float(powInt(10,dec_digits));\n        int rounded_number = int(round(abs(number)*decimal_digits_factor));\n        \n        int int_part = rounded_number\/int(decimal_digits_factor);\n        int int_digits = 1 + intLog(int_part,10);\n        \/\/ Fill with zeros to match min digits\n        for(int i=0;i++< min_int_digits - int_digits ;)\n            writeStandardChar(_0,style,\n                              p,font_tex,color);\n        \n        \n        int digits = int_digits+dec_digits;\n        for(int x = powInt(10,digits);digits>0;digits--){\n            if(digits==dec_digits)\n                \/\/ Dot\n                writeChar(_DOT,style,\n                      .65,.45,\n                      p,font_tex,color);\n            writeStandardChar(_0+rounded_number\/(x\/=10),style,\n                              p,font_tex,color);\n            rounded_number%=x;\n        }\n    }\n        \n}\n\nvoid writeNumber(int number, int min_int_digits, PrintStyle style,\n                 inout PrintPosition p, sampler2D font_tex, inout vec3 color){\n    writeNumber(float(number),min_int_digits,0,\n                style,\n                p,font_tex,color);\n}",
            "name": "Common",
            "description": "",
            "type": "common"
        },
        {
            "inputs": [
                {
                    "id": "4dXGzr",
                    "filepath": "\/media\/a\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png",
                    "previewfilepath": "\/media\/ap\/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png",
                    "type": "texture",
                    "channel": 0,
                    "sampler": {
                        "filter": "linear",
                        "wrap": "repeat",
                        "vflip": "true",
                        "srgb": "false",
                        "internal": "byte"
                    },
                    "published": 1
                }
            ],
            "outputs": [
                {
                    "id": "4dXGR8",
                    "channel": 0
                }
            ],
            "code": "struct Ray{\n\tvec3 origin;\n\tvec3 direction;\n};\n\nstruct Camera{\n\tvec3 position;\n\tvec3 direction;\n\tvec3 target;\n\tvec4 quaternion;\n\tfloat fov;\n\tfloat orthoDist;\n\tfloat orthoScale;\n};\n\nstruct Light{\n\tvec3 direction;\n\tvec3 color;\n\tfloat intensity;\n\tfloat shadowStart;\n\tfloat shadowEnd;\n\tfloat shadowSoft;\n};\n\nstruct RenderData{\n\tvec3 position;\n\tvec3 albedo;\n\tvec3 normal;\n\tfloat diffuse;\n\tfloat specular;\n\tfloat shadow;\n\tfloat ao;\n\tfloat depth;\n\tvec3 result;\n}renDat;\n\n\/\/ Cheap Rotation by las:\n\/\/ http:\/\/www.pouet.net\/topic.php?which=7931&page=1\n\/\/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\nvec3 rot(vec3 p,vec3 r){\n\tR(p.xz, r.y);\n\tR(p.yx, r.z);\n\tR(p.zy, r.x);\n\treturn p;\n}\n\n\/\/ \"init\": init camera\/lights.\n\/\/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nRay ray;\nCamera cam0;\nLight lit0;\nLight lit1;\nvoid init(){\n    cam0.position = vec3(41.593, 63.9086, 42.6658);\n\tcam0.quaternion = vec4(0.1393, 0.3404, 0.8606, 0.3522);\n\tcam0.fov = 0.18;\n\tcam0.orthoDist = 0.0;\n\tcam0.orthoScale = 0.0;\n\n\tlit0.direction = vec3(0.2662, 0.8589, -0.4376);\n    R(lit0.direction.xz, iTime);\n\tlit0.color = vec3(1.0, 1.0, 1.0);\n\tlit0.shadowStart = 0.05;\n\tlit0.shadowEnd = 30.0;\n\tlit0.shadowSoft = 50.0;\n\tlit1.direction = normalize(vec3(-0.2662, -0.8589, 0.4376));\n\tlit1.color = vec3(0.3, 0.3, 0.3);\n\tlit1.shadowStart = 0.05;\n\tlit1.shadowEnd = 30.0;\n\tlit1.shadowSoft = 50.0;\n}\n\/\/ \"camera\": create camera vectors.\n\/\/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 quat_rotate(vec4 quat, vec3 dir){\n\treturn dir + 2.0 * cross(quat.xyz, cross(quat.xyz, dir) + quat.w * dir);\n}void perspectiveCam(vec2 uv){\n\tvec3 up = vec3(0,1,0);\n    \n    vec3 pos = vec3(42,64,42);\n    if(iMouse.z>0.)\n\tpos = vec3(42.*sin(iMouse.x\/iResolution.x*TAU), 64.*iMouse.y\/iResolution.y, 42.*cos(iMouse.x\/iResolution.x*TAU));\n\tvec3 target = vec3(0,0,0);\n    vec3 dir = normalize(pos-target);\n\n\tfloat fov = cam0.fov;\n\n\tvec3 cw = normalize(dir);\n\tvec3 cu = normalize(cross(cw, up));\n\tvec3 cv = normalize(cross(cu, cw));\n\n\tmat3 camMat = mat3(cu, cv, cw);\n\tray.origin = pos;\n\tray.direction = normalize(camMat * normalize(vec3(sin(fov) * uv.x, sin(fov) * uv.y, -cos(fov))));\n}\nvoid camera(vec2 uv){\n\n\tperspectiveCam(uv);\n\n}\n\n\/\/ SDF functions\n\/\/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat sdPlane(in vec3 p){\n\treturn p.y;\n}\n\nfloat sdSphere(in vec3 p,in float r){\n\treturn length(p)-r;\n}\n\nfloat fOpUnion(in float a,in float b){\n\treturn a<b?a:b;\n}\n\nvec4 v4OpUnion(in vec4 a,in vec4 b){\n\treturn a.x<b.x?a:b;\n}\n\nfloat fOpUnionSmooth(float a,float b,float r){\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\n\/\/ \"Limited Repetition SDF\" by iq:\n\/\/ https:\/\/www.shadertoy.com\/view\/3syGzz\nvoid pRepLimited(inout float p_el, float s, float repetitions ){\n#if 0\n\tfloat r = round(p_el\/s);\n\tfloat half_num = (repetitions-1.)\/2.;\n\tr = clamp(r, -half_num, repetitions-half_num);\n\tp_el-=s*r;\n#else\n\trepetitions -= 1.;\n\tfloat offset = 1.-step(.5, mod(repetitions, 2.));\n\tp_el += s*.5*offset;\n\tfloat r = round(p_el\/s);\n\tfloat half_rep = ceil(repetitions\/2.);\n\tr = clamp(r, -half_rep, repetitions-half_rep);\n\tp_el-=s*r;\n#endif\n}\n\n\/\/ scene: Shapes.\n\/\/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\n\nvec4 sdScene(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n\n    vec3 cp000 = p;\n\tcp000.xyz += vec3(-1.5, -1.0, -1.5);\n\tpRepLimited(cp000.z, 3.0, 5.);\n\tpRepLimited(cp000.x, 3.0, 5.);\n\n\td = sdPlane(p);\n\t{\n\t\tvec3 tp = cp000+vec3(0.5, 0.0, 0.0);\n\t\tvec3 trp = rot(cp000+vec3(0.5, 0.0, 0.0), vec3(0.0, 1.5708, 0.0));\n\t\tvec3 dim = vec3(1.0, 1.0, 0.5);\n\t\tfloat td = MAX_DIST;\n\t\t\/\/ Custom Primitive Example: Hex\n\t\tconst vec3 k = vec3(-0.866254, 0.5, 0.57735);\n\t\tvec2 h = dim.xz;\n\t\ttrp = abs(trp);\n\t\ttrp.xy -= 2.0*min(dot(k.xy, trp.xy), 0.0)*k.xy;\n\t\tvec2 d2 = vec2(\n\t\t\t length(trp.xy-vec2(clamp(trp.x,-k.z*h.x,k.z*h.x), h.x))*sign(trp.y-h.x),\n\t\t\t trp.z-h.y );\n\t\ttd = min(max(d2.x,d2.y),0.0) + length(max(d2,0.0))-.1;\n\t\td=fOpUnionSmooth(td, d, 0.01);\n\t}\n\td = fOpUnionSmooth(sdSphere(cp000+vec3(-0.5, 0.0, 0.0), 0.9), d, 0.124);\n\tres = v4OpUnion(vec4(d, MAT_ERNST1), res);\n\n\treturn res;\n}\n\n\/\/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec4 intersect(){\n\tfloat d = 1.;\n\tvec3  m = MAT_VOID;\n\tfor (int i = 0; i < ITERATION; i++){\n\t\tvec3 p = ray.origin + d * ray.direction;\n\t\tvec4 res = sdScene(p);\n\t\tm = res.yzw;\n\t\tres.x *= .5;\n\t\tif (abs(res.x) < MIN_DIST || res.x >= MAX_DIST) break;\n\t\td += res.x;\n\t\tif (d >= MAX_DIST) break;\n\t}\n\treturn vec4(d,m);\n}\n\n\/\/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 normal(vec3 p){\n\tfloat c=sdScene(p).x;\n\tfloat e=MIN_DIST*.1;\n\treturn normalize(vec3(\n\t\tsdScene(p+vec3(e,0.,0.)).x-c,\n\t\tsdScene(p+vec3(0.,e,0.)).x-c,\n\t\tsdScene(p+vec3(0.,0.,e)).x-c)\n\t);\n}\n\n\/\/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat shadow(vec3 o, vec3 n){\n\tfloat mint=lit0.shadowStart;\n\tfloat maxt=lit0.shadowEnd;\n\tfloat k = lit0.shadowSoft;\n\tfloat res = 1.;\n\tfloat t=mint;\n\tfloat ph = 1e10; \/\/ big, such that y = 0 on the first iteration\n\tfor( int i=0; i < ITERATION; i++){\n\t\tfloat h = sdScene(o + lit0.direction*t).x;\n#if 1\n\t\tres = min( res, k*h\/t);\n#else\n\t\tfloat y = h*h\/(2.0*ph);\n\t\tfloat d = sqrt(h*h-y*y);\n\t\tres = min( res, k*d\/max(0.0,t-y) );\n\t\tph = h;\n#endif\n\t\tt += h;\n\t\tif( res<0.0001 || t>maxt ) break;\n\t}\n\treturn sat(res);\n}\n\n\/\/ \"Hemispherical SDF AO\" by XT95:\n\/\/ https:\/\/www.shadertoy.com\/view\/4sdGWN\n\/\/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 randomSphereDir(vec2 rnd){\n\tfloat s = rnd.x*PI*2.;\n\tfloat t = rnd.y*2.-1.;\n\treturn vec3(sin(s), cos(s), t) \/ sqrt(1.0 + t * t);\n}\nvec3 randomHemisphereDir(vec3 dir, float i){\n\tvec3 v = randomSphereDir( vec2(hash11(i+1.), hash11(i+2.)) );\n\treturn v * sign(dot(v, dir));\n}\nfloat ambientOcclusion( in vec3 p, in vec3 n, in float maxDist, in float falloff ){\n\tconst int nbIte = 12;\n\tconst float nbIteInv = 1.\/float(nbIte);\n\tconst float rad = 1.-1.*nbIteInv; \/\/Hemispherical factor (self occlusion correction)\n\n\tfloat ao = 0.0;\n\n\tfor( int i=0; i<nbIte; i++ ){\n\t\tfloat l = hash11(float(i))*maxDist;\n\t\tvec3 aord = normalize(n+randomHemisphereDir(n, l )*rad)*l; \/\/ mix direction with the normal\/\/ for self occlusion problems!\n\t\tao += (l - max(sdScene( p + aord ).x,0.)) \/ maxDist * falloff;\n\t}\n\n\treturn clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\n\/\/ Phong specular\n\/\/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat normalizedPhong(float shininess, vec3 n, vec3 vd, vec3 ld){\n    float norm_factor = (shininess+1.) \/ (2.*PI);\n    vec3 reflect_light = normalize(reflect(ld, n));\n    return pow(max(dot(-vd, reflect_light), 0.), shininess) * norm_factor;\n}\nfloat normalizedPhongRef(float shininess, vec3 n, vec3 vd, vec3 ld){\n    return 1.-normalizedPhong(shininess, n, vd, ld);\n}\n\n\/\/ https:\/\/hanecci.hatenadiary.org\/entry\/20130505\/p2\n\/\/ http:\/\/www.project-asura.com\/program\/d3d11\/d3d11_006.html\nfloat normalizedBlinnPhong(float shininess, vec3 n, vec3 vd, vec3 ld){\n    float norm_factor = (shininess+1.) \/ (2.*PI);\n    vec3 h  = normalize(-vd+ld);\n    return pow(max(0., dot(h, n)), shininess) * norm_factor;\n}\nfloat BlinnPhongRef(float shininess, vec3 n, vec3 vd, vec3 ld){\n    vec3 h  = normalize(-vd+ld);\n    return 1.-pow(max(0., dot(h, n)), shininess);\n}\n\n#define tex iChannel0\n#define NextLine nextLine(p)\n#define WriteChar(char,style) writeStandardChar(char,style,pp,tex,renDat.albedo)\n#define WriteWord(word,style) writeWord(word,style,pp,tex,renDat.albedo)\n#define WriteText(text,style) writeText(text,style,pp,tex,renDat.albedo)\n#define WriteNumber(number,min_int_digits,dec_digits,style) writeNumber(number,min_int_digits,dec_digits,style,pp,tex,renDat.albedo)\n\n\n\/\/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid render(){\n\tvec4 res = intersect();\n\tvec3 p = ray.origin + res.x * ray.direction;\n\n\tif (res.x>=MAX_DIST){\n\t\trenDat.position = vec3(0);\n\t\trenDat.albedo = FOG_COL;\n\t\trenDat.normal = vec3(0);\n\t\trenDat.diffuse = 0.;\n\t\trenDat.specular = 0.;\n\t\trenDat.shadow = 0.;\n\t\trenDat.ao = 0.;\n\t\trenDat.depth = 1.;\n\t\trenDat.result = FOG_COL;\n\t}\n\telse{\n\t\trenDat.position = p;\n\t\trenDat.albedo = res.yzw;\n\t\trenDat.normal = normal(p);\n        \n        \/\/ \"Utils : font display\" by ABizard:\n        \/\/ https:\/\/www.shadertoy.com\/view\/MdycDK\n        const int[] text1 = int[](_I,_n,_t,_e,_n,_s,_i,_t,_y);\n        const int[] text2 = int[](_S,_h,_i,_n,_i,_n,_e,_s,_s);\n        vec2 COORD = floor(p.xz*iResolution.x);\n        PrintStyle white_out_black = NewPrintStyle(WHITE,renDat.albedo);\n        \n        vec2 pos = vec2(-7.,-14.);\n        float scale = 1.\/2.;\n        PrintPosition pp;\n        pp = getDisplayPos(pos,scale);\n\n        WriteWord(text1,white_out_black);\n        \n        R(COORD, HALF_PI);\n        pp = getDisplayPos(pos,scale);\n        WriteWord(text2,white_out_black);\n        \n        R(COORD, HALF_PI);\n        pp = getDisplayPos(pos,scale);\n        WriteWord(text1,white_out_black);\n    \n        R(COORD, HALF_PI);\n        pp = getDisplayPos(pos,scale);\n        WriteWord(text2,white_out_black);\n    \n    \n\t\tfloat lamb1 = sat(dot(renDat.normal, lit0.direction))*(1.\/PI);\n\t\tfloat lamb2 = sat(dot(renDat.normal, lit1.direction))*(1.\/PI);\n\n\t\trenDat.shadow = shadow(p+renDat.normal*.0001, renDat.normal);\n\n\t\trenDat.ao = ambientOcclusion(p, renDat.normal, .1, .5);\n\t\trenDat.ao += ambientOcclusion(p, renDat.normal, .5, .5);\n\t\trenDat.ao += ambientOcclusion(p, renDat.normal, 2., 2.);\n\t\trenDat.ao += ambientOcclusion(p, renDat.normal, 4., 2.);\n\t\trenDat.ao = smoothstep(0., 4., renDat.ao);\n\n\t\trenDat.diffuse = lamb1;\n\t\trenDat.diffuse *= renDat.shadow;\n\t\trenDat.result = mix(vec3(0), lit0.color, renDat.diffuse);\n\n\t\trenDat.diffuse += lamb2*renDat.ao;\n\t\trenDat.result += mix(vec3(0), lit1.color, lamb2*renDat.ao);\n\n\t\tfloat shininess = pow(5., max(0.,floor((p.z+9.+1.5)*.3333)))+2.;\n\t\tfloat shininessRef = pow(.25, max(0.,floor((p.z+9.+1.5)*.3333)))+4.;\n\t\tfloat intensity = pow(.3, max(0.,floor((p.x+9.+1.5)*.3333)));\n\t\trenDat.diffuse += renDat.ao*AMB_STRENGTH;\n\t\tfloat ref = BlinnPhongRef(shininessRef, renDat.normal, ray.direction, lit0.direction);\n\t\trenDat.result += mix(vec3(0), AMB_COL, renDat.ao*AMB_STRENGTH)*(.5+.5*ref);\n\t\trenDat.result*= renDat.albedo;\n        \n        \n\n\t\tfloat roughness = .7;\n\t\tfloat linearRoughness = roughness * roughness;\n\t\tfloat spec = normalizedBlinnPhong(shininess, renDat.normal, ray.direction, lit0.direction);\n\t\trenDat.specular = spec*intensity*step(0.1,p.y);\n\t\trenDat.result = mix(renDat.result, renDat.result+lit0.color, renDat.specular*renDat.shadow*1.);\n\t\t\/\/ renDat.result = vec3(shininess*.001);\n\t\trenDat.depth = distance(ray.origin, p)\/MAX_DIST;\n\t\trenDat.result = mix(renDat.result, FOG_COL, sat(pow(renDat.depth+FOG_START, FOG_POW)));\n\t}\n}\n\n\/\/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n\tif(uv.x>INV_ERNST_RENDER_SCALE || uv.y>INV_ERNST_RENDER_SCALE) return;\n\n\tuv*=ERNST_RENDER_SCALE;\n\tfloat ml = (min(iResolution.x, iResolution.y)==iResolution.x)?1.0:iResolution.y\/iResolution.x;\n\tuv = (uv*2.-1.)*ml;\n\tuv.x *= iResolution.x \/ iResolution.y;\n\n\tinit();\n\tcamera(uv);\n\trender();\n\n\tfragColor = vec4(renDat.result, 1.);\n}",
            "name": "Buffer A",
            "description": "",
            "type": "buffer"
        }
    ]
}